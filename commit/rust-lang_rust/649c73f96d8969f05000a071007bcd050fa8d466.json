{"sha": "649c73f96d8969f05000a071007bcd050fa8d466", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0OWM3M2Y5NmQ4OTY5ZjA1MDAwYTA3MTAwN2JjZDA1MGZhOGQ0NjY=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-10-11T03:16:44Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-12-02T13:30:30Z"}, "message": "Simplify Cache wrapper to single type, impl Deref on it, fix all compilation errors in librustc_codegen_ssa", "tree": {"sha": "2f5f8d3bac4b6f6163726592c7f8cd93d00509e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f5f8d3bac4b6f6163726592c7f8cd93d00509e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/649c73f96d8969f05000a071007bcd050fa8d466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/649c73f96d8969f05000a071007bcd050fa8d466", "html_url": "https://github.com/rust-lang/rust/commit/649c73f96d8969f05000a071007bcd050fa8d466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/649c73f96d8969f05000a071007bcd050fa8d466/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0592faa67a1fe8fb7425f24899c5538dec23ee1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0592faa67a1fe8fb7425f24899c5538dec23ee1", "html_url": "https://github.com/rust-lang/rust/commit/c0592faa67a1fe8fb7425f24899c5538dec23ee1"}], "stats": {"total": 294, "additions": 132, "deletions": 162}, "files": [{"sha": "e218931b74916502c61fee9bbb17d878df6b1b7a", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -6,7 +6,7 @@ use crate::mir::{BasicBlock, BasicBlockData, Body, LocalDecls, Location, Success\n use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use std::iter;\n-use std::ops::{Index, IndexMut};\n+use std::ops::{Deref, DerefMut, Index, IndexMut};\n use std::vec::IntoIter;\n \n #[derive(Clone, Debug)]\n@@ -111,33 +111,21 @@ impl Cache {\n     }\n }\n \n-pub struct OwningCache<'tcx> {\n+pub struct BodyCache<T> {\n     cache: Cache,\n-    body: Body<'tcx>,\n+    body: T,\n }\n \n-impl<'tcx> OwningCache<'tcx> {\n-    pub fn borrow(&mut self) -> BorrowedCache<'_, 'tcx> {\n-        BorrowedCache {\n-            cache: &mut self.cache,\n-            body: &self.body,\n-        }\n-    }\n-\n-    pub fn borrow_mut(&mut self) -> MutCache<'_, 'tcx> {\n-        MutCache {\n-            cache: &mut self.cache,\n-            body: &mut self.body,\n+impl<T> BodyCache<T> {\n+    pub fn new(body: T) -> Self {\n+        Self {\n+            cache: Cache::new(),\n+            body\n         }\n     }\n }\n \n-pub struct BorrowedCache<'a, 'tcx> {\n-    cache: &'a mut Cache,\n-    body: &'a Body<'tcx>\n-}\n-\n-impl<'a, 'tcx> BorrowedCache<'a, 'tcx> {\n+impl<'a, 'tcx> BodyCache<&'a Body<'tcx>> {\n     #[inline]\n     pub fn predecessors_for(&mut self, bb: BasicBlock) -> &[BasicBlock] {\n         self.cache.predecessors_for(bb, self.body)\n@@ -159,7 +147,14 @@ impl<'a, 'tcx> BorrowedCache<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Index<BasicBlock> for BorrowedCache<'a, 'tcx> {\n+impl<'a, 'tcx> Deref for BodyCache<&'a Body<'tcx>> {\n+    type Target = Body<'tcx>;\n+    fn deref(&self) -> &Body<'tcx> {\n+        self.body\n+    }\n+}\n+\n+impl<'a, 'tcx> Index<BasicBlock> for BodyCache<&'a Body<'tcx>> {\n     type Output = BasicBlockData<'tcx>;\n \n     #[inline]\n@@ -168,16 +163,16 @@ impl<'a, 'tcx> Index<BasicBlock> for BorrowedCache<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> graph::DirectedGraph for BorrowedCache<'a, 'tcx> {\n+impl<'a, 'tcx> graph::DirectedGraph for BodyCache<&'a Body<'tcx>> {\n     type Node = BasicBlock;\n }\n \n-impl<'a, 'graph, 'tcx> graph::GraphPredecessors<'graph> for BorrowedCache<'a, 'tcx> {\n+impl<'a, 'graph, 'tcx> graph::GraphPredecessors<'graph> for BodyCache<&'a Body<'tcx>> {\n     type Item = BasicBlock;\n     type Iter = IntoIter<BasicBlock>;\n }\n \n-impl<'a, 'tcx> graph::WithPredecessors for BorrowedCache<'a, 'tcx> {\n+impl<'a, 'tcx> graph::WithPredecessors for BodyCache<&'a Body<'tcx>> {\n     fn predecessors(\n         &mut self,\n         node: Self::Node,\n@@ -186,19 +181,19 @@ impl<'a, 'tcx> graph::WithPredecessors for BorrowedCache<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> graph::WithNumNodes for BorrowedCache<'a, 'tcx> {\n+impl<'a, 'tcx> graph::WithNumNodes for BodyCache<&'a Body<'tcx>> {\n     fn num_nodes(&self) -> usize {\n         self.body.num_nodes()\n     }\n }\n \n-impl<'a, 'tcx> graph::WithStartNode for BorrowedCache<'a, 'tcx> {\n+impl<'a, 'tcx> graph::WithStartNode for BodyCache<&'a Body<'tcx>> {\n     fn start_node(&self) -> Self::Node {\n         self.body.start_node()\n     }\n }\n \n-impl<'a, 'tcx> graph::WithSuccessors for BorrowedCache<'a, 'tcx> {\n+impl<'a, 'tcx> graph::WithSuccessors for BodyCache<&'a Body<'tcx>> {\n     fn successors(\n         &self,\n         node: Self::Node,\n@@ -207,17 +202,12 @@ impl<'a, 'tcx> graph::WithSuccessors for BorrowedCache<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for BorrowedCache<'a, 'tcx> {\n+impl<'a, 'b, 'tcx> graph::GraphSuccessors<'b> for BodyCache<&'a Body<'tcx>> {\n     type Item = BasicBlock;\n     type Iter = iter::Cloned<Successors<'b>>;\n }\n \n-pub struct MutCache<'a, 'tcx> {\n-    cache: &'a mut Cache,\n-    body: &'a mut Body<'tcx>,\n-}\n-\n-impl<'a, 'tcx> MutCache<'a, 'tcx> {\n+impl<'a, 'tcx> BodyCache<&'a mut Body<'tcx>> {\n     #[inline]\n     pub fn body(&mut self) -> &mut Body<'tcx> {\n         self.body\n@@ -234,7 +224,21 @@ impl<'a, 'tcx> MutCache<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Index<BasicBlock> for MutCache<'a, 'tcx> {\n+impl<'a, 'tcx> Deref for BodyCache<&'a mut Body<'tcx>> {\n+    type Target = Body<'tcx>;\n+\n+    fn deref(&self) -> &Body<'tcx> {\n+        self.body\n+    }\n+}\n+\n+impl<'a, 'tcx> DerefMut for BodyCache<&'a mut Body<'tcx>> {\n+    fn deref_mut(&mut self) -> &mut Body<'tcx> {\n+        self.body\n+    }\n+}\n+\n+impl<'a, 'tcx> Index<BasicBlock> for BodyCache<&'a mut Body<'tcx>> {\n     type Output = BasicBlockData<'tcx>;\n \n     #[inline]\n@@ -243,13 +247,9 @@ impl<'a, 'tcx> Index<BasicBlock> for MutCache<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> IndexMut<BasicBlock> for MutCache<'a, 'tcx> {\n+impl<'a, 'tcx> IndexMut<BasicBlock> for BodyCache<&'a mut Body<'tcx>> {\n     fn index_mut(&mut self, index: BasicBlock) -> &mut Self::Output {\n         self.cache.invalidate_predecessors();\n         &mut self.body.basic_blocks[index]\n     }\n }\n-\n-//CloneTypeFoldableAndLiftImpls! {\n-//    Cache,\n-//}"}, {"sha": "9f71840576382fccbd0334af45b24bd90274e1ad", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -38,6 +38,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use crate::mir::interpret::AssertMessage;\n+pub use crate::mir::cache::BodyCache;\n \n pub mod cache;\n pub mod interpret;\n@@ -2596,7 +2597,11 @@ impl Location {\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n-    pub fn is_predecessor_of<'tcx>(&self, other: Location, mut body_cache: cache::BorrowedCache<'_, 'tcx>) -> bool {\n+    pub fn is_predecessor_of<'tcx>(\n+        &self,\n+        other: Location,\n+        mut body_cache: BodyCache<&'_ Body<'tcx>>\n+    ) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`.\n         if self.block == other.block && self.statement_index < other.statement_index {"}, {"sha": "5803663bbecddeefc216243ffafa8caab03f8817", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -1,7 +1,6 @@\n use crate::ty::subst::SubstsRef;\n use crate::ty::{CanonicalUserTypeAnnotation, Ty};\n use crate::mir::*;\n-use crate::mir::cache::*;\n use syntax_pos::Span;\n \n // # The MIR Visitor\n@@ -72,7 +71,10 @@ macro_rules! make_mir_visitor {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_body(&mut self, body_cache: & $($mutability)? cache_type!('tcx $($mutability)?)) {\n+            fn visit_body(\n+                &mut self,\n+                body_cache: & $($mutability)? BodyCache<&'_ $($mutability)? Body<'tcx>>\n+            ) {\n                 self.super_body(body_cache);\n             }\n \n@@ -241,8 +243,10 @@ macro_rules! make_mir_visitor {\n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n-            fn super_body(&mut self,\n-                         body_cache: & $($mutability)? cache_type!('tcx $($mutability)?)) {\n+            fn super_body(\n+                &mut self,\n+                body_cache: & $($mutability)? BodyCache<&'_ $($mutability)? Body<'tcx>>\n+            ) {\n                 let span = body_cache.body().span;\n                 if let Some(yield_ty) = &$($mutability)? body_cache.body().yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n@@ -793,7 +797,11 @@ macro_rules! make_mir_visitor {\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, body_cache: & $($mutability)? cache_type!('tcx $($mutability)?), location: Location) {\n+            fn visit_location(\n+                &mut self,\n+                body_cache: & $($mutability)? BodyCache<&'_ $($mutability)? Body<'tcx>>,\n+                location: Location\n+            ) {\n                 let basic_block = & $($mutability)? body_cache[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n                     if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n@@ -809,11 +817,6 @@ macro_rules! make_mir_visitor {\n     }\n }\n \n-macro_rules! cache_type {\n-    ($tcx:lifetime mut) => {MutCache<'_, $tcx>};\n-    ($tcx:lifetime) => {BorrowedCache<'_, $tcx>};\n-}\n-\n macro_rules! visit_place_fns {\n     (mut) => (\n         fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;"}, {"sha": "d67a9d3799eabfb985af76c0417e8b8b03180d31", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -31,6 +31,7 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n+use rustc::mir::BodyCache;\n use rustc::mir::mono::{CodegenUnitNameBuilder, CodegenUnit, MonoItem};\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n@@ -374,7 +375,9 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     let lldecl = cx.get_fn(instance);\n \n     let mir = cx.tcx().instance_mir(instance.def);\n-    mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n+    // TODO(nashenas88) move this into instance_mir before merging PR\n+    let mut mir = BodyCache::new(mir);\n+    mir::codegen_mir::<Bx>(cx, lldecl, &mut mir, instance, sig);\n }\n \n /// Creates the `main` function which will initialize the rust runtime and call"}, {"sha": "7a2940a8e673b91de800a0eeb47a7d52a365c277", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -4,7 +4,7 @@\n use rustc_index::bit_set::BitSet;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc::mir::{self, Location, TerminatorKind};\n+use rustc::mir::{self, Body, BodyCache, Location, TerminatorKind};\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext, NonUseContext,\n };\n@@ -17,10 +17,10 @@ use super::FunctionCx;\n use crate::traits::*;\n \n pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    fx: &FunctionCx<'a, 'tcx, Bx>,\n+    fx: &mut FunctionCx<'a, 'tcx, Bx>,\n ) -> BitSet<mir::Local> {\n-    let mir = fx.mir;\n-    let mut analyzer = LocalAnalyzer::new(fx);\n+    let mir = fx.mir.take().unwrap();\n+    let mut analyzer = LocalAnalyzer::new(fx, mir);\n \n     analyzer.visit_body(mir);\n \n@@ -54,11 +54,14 @@ pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         }\n     }\n \n-    analyzer.non_ssa_locals\n+    let (mir, non_ssa_locals) = analyzer.finalize();\n+    fx.mir = Some(mir);\n+    non_ssa_locals\n }\n \n struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     fx: &'mir FunctionCx<'a, 'tcx, Bx>,\n+    mir: &'a mut BodyCache<&'a Body<'tcx>>,\n     dominators: Dominators<mir::BasicBlock>,\n     non_ssa_locals: BitSet<mir::Local>,\n     // The location of the first visited direct assignment to each\n@@ -67,27 +70,32 @@ struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n }\n \n impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n-    fn new(fx: &'mir FunctionCx<'a, 'tcx, Bx>) -> Self {\n+    fn new(fx: &'mir FunctionCx<'a, 'tcx, Bx>, mir: &'a mut BodyCache<&'a Body<'tcx>>) -> Self {\n         let invalid_location =\n-            mir::BasicBlock::new(fx.mir.basic_blocks().len()).start_location();\n+            mir::BasicBlock::new(mir.basic_blocks().len()).start_location();\n         let mut analyzer = LocalAnalyzer {\n             fx,\n-            dominators: fx.mir.dominators(),\n-            non_ssa_locals: BitSet::new_empty(fx.mir.local_decls.len()),\n-            first_assignment: IndexVec::from_elem(invalid_location, &fx.mir.local_decls)\n+            dominators: mir.dominators(),\n+            mir,\n+            non_ssa_locals: BitSet::new_empty(mir.local_decls.len()),\n+            first_assignment: IndexVec::from_elem(invalid_location, &mir.local_decls)\n         };\n \n         // Arguments get assigned to by means of the function being called\n-        for arg in fx.mir.args_iter() {\n+        for arg in mir.args_iter() {\n             analyzer.first_assignment[arg] = mir::START_BLOCK.start_location();\n         }\n \n         analyzer\n     }\n \n+    fn finalize(self) -> (&'a mut BodyCache<&'a Body<'tcx>>, BitSet<mir::Local>) {\n+        (self.mir, self.non_ssa_locals)\n+    }\n+\n     fn first_assignment(&self, local: mir::Local) -> Option<Location> {\n         let location = self.first_assignment[local];\n-        if location.block.index() < self.fx.mir.basic_blocks().len() {\n+        if location.block.index() < self.mir.basic_blocks().len() {\n             Some(location)\n         } else {\n             None\n@@ -130,7 +138,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, proj_base, self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.base, proj_base, self.mir.body(), cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n@@ -139,7 +147,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                     .ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 let span = if let mir::PlaceBase::Local(index) = place_ref.base {\n-                    self.fx.mir.local_decls[*index].source_info.span\n+                    self.mir.local_decls[*index].source_info.span\n                 } else {\n                     DUMMY_SP\n                 };\n@@ -243,7 +251,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n         if let Some(index) = place.as_local() {\n             self.assign(index, location);\n-            let decl_span = self.fx.mir.local_decls[index].source_info.span;\n+            let decl_span = self.mir.local_decls[index].source_info.span;\n             if !self.fx.rvalue_creates_operand(rvalue, decl_span) {\n                 self.not_ssa(index);\n             }\n@@ -348,7 +356,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             }\n \n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n-                let ty = self.fx.mir.local_decls[local].ty;\n+                let ty = self.mir.local_decls[local].ty;\n                 let ty = self.fx.monomorphize(&ty);\n \n                 // Only need the place if we're actually dropping it."}, {"sha": "d09ff0160db172651d7f9a98536bd91034fb0109", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'a, 'tcx> {\n         } else {\n             let llret = bx.call(fn_ptr, &llargs, self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, llret);\n-            if fx.mir[*self.bb].is_cleanup {\n+            if fx.mir.unwrap()[*self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline\n                 // drop glue. Also, when there is a deeply-nested\n                 // struct, there are \"symmetry\" issues that cause\n@@ -324,7 +324,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(self.mir, bx.tcx()).ty;\n+        let ty = location.ty(self.mir.unwrap().body(), bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n@@ -510,7 +510,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let extra_args = &args[sig.inputs().len()..];\n         let extra_args = extra_args.iter().map(|op_arg| {\n-            let op_ty = op_arg.ty(self.mir, bx.tcx());\n+            let op_ty = op_arg.ty(self.mir.unwrap().body(), bx.tcx());\n             self.monomorphize(&op_ty)\n         }).collect::<Vec<_>>();\n \n@@ -791,7 +791,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bb: mir::BasicBlock,\n     ) {\n         let mut bx = self.build_block(bb);\n-        let data = &self.mir[bb];\n+        let data = &self.mir.unwrap()[bb];\n \n         debug!(\"codegen_block({:?}={:?})\", bb, data);\n \n@@ -1053,7 +1053,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target_bb: Bx::BasicBlock\n     ) -> Bx::BasicBlock {\n         if base::wants_msvc_seh(self.cx.sess()) {\n-            span_bug!(self.mir.span, \"landing pad was not inserted?\")\n+            span_bug!(self.mir.unwrap().span, \"landing pad was not inserted?\")\n         }\n \n         let mut bx = self.new_block(\"cleanup\");\n@@ -1154,7 +1154,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 //\n                 // If someone changes that, please update this code path\n                 // to create a temporary.\n-                span_bug!(self.mir.span, \"can't directly store to unaligned value\");\n+                span_bug!(self.mir.unwrap().span, \"can't directly store to unaligned value\");\n             }\n             llargs.push(dest.llval);\n             ReturnDest::Nothing"}, {"sha": "8b127867238025514c9f9e5665712802dc08d9f9", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{TyLayout, HasTyCtxt, FnAbiExt};\n-use rustc::mir::{self, Body};\n+use rustc::mir::{self, Body, BodyCache};\n use rustc_target::abi::call::{FnAbi, PassMode};\n use crate::base;\n use crate::traits::*;\n@@ -21,7 +21,7 @@ use self::operand::{OperandRef, OperandValue};\n pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n-    mir: &'a mir::Body<'tcx>,\n+    mir: Option<&'a mut BodyCache<&'a mir::Body<'tcx>>>,\n \n     debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n \n@@ -122,7 +122,7 @@ impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     llfn: Bx::Function,\n-    mir: &'a Body<'tcx>,\n+    mir: &'a mut BodyCache<&'a Body<'tcx>>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n ) {\n@@ -159,7 +159,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     let mut fx = FunctionCx {\n         instance,\n-        mir,\n+        mir: Some(mir),\n         llfn,\n         fn_abi,\n         cx,\n@@ -174,7 +174,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         per_local_var_debug_info: debuginfo::per_local_var_debug_info(cx.tcx(), mir),\n     };\n \n-    let memory_locals = analyze::non_ssa_locals(&fx);\n+    let memory_locals = analyze::non_ssa_locals(&mut fx);\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n@@ -327,10 +327,10 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let mut idx = 0;\n     let mut llarg_idx = fx.fn_abi.ret.is_indirect() as usize;\n \n-    mir.args_iter().enumerate().map(|(arg_index, local)| {\n-        let arg_decl = &mir.local_decls[local];\n+    mir.unwrap().args_iter().enumerate().map(|(arg_index, local)| {\n+        let arg_decl = &mir.unwrap().local_decls[local];\n \n-        if Some(local) == mir.spread_arg {\n+        if Some(local) == mir.unwrap().spread_arg {\n             // This argument (e.g., the last argument in the \"rust-call\" ABI)\n             // is a tuple that was spread at the ABI level and now we have\n             // to reconstruct it into a tuple local variable, from multiple"}, {"sha": "8f3c1de9c64409715fd0ca88030c73bde7071d2e", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -591,7 +591,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     pub fn monomorphized_place_ty(&self, place_ref: &mir::PlaceRef<'_, 'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n-        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, self.mir, tcx);\n+        let place_ty = mir::Place::ty_from(place_ref.base, place_ref.projection, self.mir.unwrap().body(), tcx);\n         self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "c1519b6106dfc58d8ae27b6e5e5d718af47cb721", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n-                let discr_ty = rvalue.ty(&*self.mir, bx.tcx());\n+                let discr_ty = rvalue.ty(self.mir.unwrap().body(), bx.tcx());\n                 let discr =  self.codegen_place(&mut bx, &place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n                 (bx, OperandRef {\n@@ -513,7 +513,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir.unwrap().body(), self.cx.tcx());\n                 let operand = OperandRef::new_zst(\n                     &mut bx,\n                     self.cx.layout_of(self.monomorphize(&ty)),\n@@ -710,7 +710,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(self.mir.unwrap().body(), self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }"}, {"sha": "f861a423ae266dac658bab44d7c810bd4acd8643", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -9,8 +9,8 @@ use rustc::lint::builtin::UNUSED_MUT;\n use rustc::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT};\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{\n-    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceElem,\n-    PlaceRef, Static, StaticKind\n+    ClearCrossCrate, Local, Location, Body, BodyCache, Mutability, Operand, Place, PlaceBase,\n+    PlaceElem, PlaceRef, Static, StaticKind\n };\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -167,16 +167,12 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let free_regions =\n         nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n \n-    // Region replacement above very likely invalidated the predecessors cache. It's used later on\n-    // when retrieving the dominators from the body, so we need to ensure it exists before locking\n-    // the body for changes.\n-    body.ensure_predecessors();\n-    let body = &body; // no further changes\n-    let location_table = &LocationTable::new(body);\n+    let body_cache = &BodyCache::new(&body); // no further changes\n+    let location_table = &LocationTable::new(body_cache);\n \n     let mut errors_buffer = Vec::new();\n     let (move_data, move_errors): (MoveData<'tcx>, Option<Vec<(Place<'tcx>, MoveError<'tcx>)>>) =\n-        match MoveData::gather_moves(body, tcx) {\n+        match MoveData::gather_moves(body_cache, tcx) {\n             Ok(move_data) => (move_data, None),\n             Err((move_data, move_errors)) => (move_data, Some(move_errors)),\n         };\n@@ -186,27 +182,27 @@ fn do_mir_borrowck<'a, 'tcx>(\n         param_env,\n     };\n \n-    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n+    let dead_unwinds = BitSet::new_empty(body_cache.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body,\n+        body_cache,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeInitializedPlaces::new(tcx, body, &mdpe),\n+        MaybeInitializedPlaces::new(tcx, body_cache, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n \n     let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n     let borrow_set = Rc::new(BorrowSet::build(\n-            tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n+            tcx, body_cache, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n     let (regioncx, polonius_output, opt_closure_req) = nll::compute_regions(\n         infcx,\n         def_id,\n         free_regions,\n-        body,\n+        body_cache,\n         &promoted,\n         &local_names,\n         &upvars,\n@@ -227,29 +223,29 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let flow_borrows = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body,\n+        body_cache,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, body, param_env, regioncx.clone(), &borrow_set),\n+        Borrows::new(tcx, body_cache, param_env, regioncx.clone(), &borrow_set),\n         |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body,\n+        body_cache,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeUninitializedPlaces::new(tcx, body, &mdpe),\n+        MaybeUninitializedPlaces::new(tcx, body_cache, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        body,\n+        body_cache,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        EverInitializedPlaces::new(tcx, body, &mdpe),\n+        EverInitializedPlaces::new(tcx, body_cache, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n@@ -261,11 +257,11 @@ fn do_mir_borrowck<'a, 'tcx>(\n         _ => true,\n     };\n \n-    let dominators = body.dominators();\n+    let dominators = body_cache.dominators();\n \n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n-        body,\n+        body_cache,\n         mir_def_id: def_id,\n         param_env,\n         move_data: &mdpe.move_data,\n@@ -403,7 +399,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    body: &'cx Body<'tcx>,\n+    body_cache: BodyCache<&'cx Body<'tcx>>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     move_data: &'cx MoveData<'tcx>,\n@@ -494,7 +490,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n     type FlowState = Flows<'cx, 'tcx>;\n \n     fn body(&self) -> &'cx Body<'tcx> {\n-        self.body\n+        self.body_cache\n     }\n \n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n@@ -644,7 +640,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(self.body, self.infcx.tcx);\n+                let drop_place_ty = drop_place.ty(self.body_cache, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n@@ -988,7 +984,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n-        let body = self.body;\n+        let body = self.body_cache;\n         let param_env = self.param_env;\n         let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();"}, {"sha": "4f95aa4a7b003d89b6264b1f13cbb49b4b894c1f", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -385,15 +385,15 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn visit_body(&mut self, body: &Body<'tcx>) {\n-        self.sanitize_type(&\"return type\", body.return_ty());\n-        for local_decl in &body.local_decls {\n+    fn visit_body(&mut self, body_cache: &BodyCache<&'_ Body<'tcx>>) {\n+        self.sanitize_type(&\"return type\", body_cache.return_ty());\n+        for local_decl in &body_cache.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);\n         }\n         if self.errors_reported {\n             return;\n         }\n-        self.super_body(body);\n+        self.super_body(body_cache);\n     }\n }\n "}, {"sha": "734e1a5972e4568115a5fa94e4eb57038e0d3bb4", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -123,17 +123,6 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n         &add_call_guards::CriticalCallEdges,\n     ]);\n \n-    // The `ensure_predecessors_cache::EnsurePredecessorsCache` MirPass wasn't used in the\n-    // `run_passes` above because the above pass is not always guaranteed to run. There can be\n-    // instances where, e.g. a `MirPhase::Validated` pass has already been run on a `Body` by the\n-    // time it arrived at this line, and so the above `run_passes` call will NOT run any of the\n-    // passes (They do not run if a same or later pass has already been executed on a `Body`).\n-    // Adding the ensure pass during the `run_passes` for `MirPhase::Validated` would not\n-    // help because the predecessors cache would be invalidated between that pass and this call.\n-    // Having the single ensure outside of the `run_passes` list here guarantees that anyone\n-    // using this `Body` could call `Body::unwrap_predecessors()` without worrying about a panic.\n-    result.ensure_predecessors();\n-\n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n     tcx.arena.alloc(result)\n@@ -926,7 +915,6 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n         sig.inputs().len(),\n         span,\n     );\n-    body.ensure_predecessors();\n \n     crate::util::dump_mir(\n         tcx,"}, {"sha": "db1ef863351c0d57b273c81c2cb2d456ce2c11f4", "filename": "src/librustc_mir/transform/ensure_predecessors_cache.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc_mir%2Ftransform%2Fensure_predecessors_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0592faa67a1fe8fb7425f24899c5538dec23ee1/src%2Flibrustc_mir%2Ftransform%2Fensure_predecessors_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fensure_predecessors_cache.rs?ref=c0592faa67a1fe8fb7425f24899c5538dec23ee1", "patch": "@@ -1,26 +0,0 @@\n-use rustc::mir::Body;\n-use rustc::ty::TyCtxt;\n-use crate::transform::{MirPass, MirSource};\n-\n-pub struct EnsurePredecessorsCache {\n-    label: String,\n-}\n-\n-impl EnsurePredecessorsCache {\n-    pub fn new<S: Into<String>>(label: S) -> Self {\n-        Self {\n-            label: label.into(),\n-        }\n-    }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for EnsurePredecessorsCache {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        debug!(\"{}: Ensure predecessors cache: {:?}\", self.label, body.span.data());\n-        // predecessors is lazily calculated. We want to ensure that the cache is properly filled\n-        // before the next stages of compilation, since these following stages will only be allowed\n-        // to read the cache and not generate it. If the cache is already up to date, this line is\n-        // a nop.\n-        body.ensure_predecessors();\n-    }\n-}"}, {"sha": "37205e65a0a4251a56d3a1b4cc9b1901ee5703c5", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -1203,10 +1203,6 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         // RETURN_PLACE then is a fresh unused local with type ret_ty.\n         let new_ret_local = replace_result_variable(ret_ty, body, tcx);\n \n-        // Replacing result variables very likely clears the predecessors cache (needed inside of\n-        // compute layout), so we need to ensure the cache exists.\n-        body.ensure_predecessors();\n-\n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n         // `storage_liveness` tells us which locals have live storage at suspension points"}, {"sha": "1eac40fc591a02a8f56028c16e4d186057d7164f", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649c73f96d8969f05000a071007bcd050fa8d466/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=649c73f96d8969f05000a071007bcd050fa8d466", "patch": "@@ -20,7 +20,6 @@ pub mod check_unsafety;\n pub mod simplify_branches;\n pub mod simplify_try;\n pub mod simplify;\n-pub mod ensure_predecessors_cache;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod rustc_peek;\n@@ -251,7 +250,6 @@ fn mir_validated(\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);\n \n-    body.ensure_predecessors();\n     let promoted = promote_pass.promoted_fragments.into_inner();\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n@@ -316,7 +314,6 @@ fn run_optimization_passes<'tcx>(\n         &simplify::SimplifyLocals,\n \n         &add_call_guards::CriticalCallEdges,\n-        &ensure_predecessors_cache::EnsurePredecessorsCache::new(\"before-opt-dump\"),\n         &dump_mir::Marker(\"PreCodegen\"),\n     ]);\n }"}]}