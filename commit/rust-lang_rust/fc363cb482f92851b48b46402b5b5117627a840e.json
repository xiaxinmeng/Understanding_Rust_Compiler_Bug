{"sha": "fc363cb482f92851b48b46402b5b5117627a840e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMzYzY2I0ODJmOTI4NTFiNDhiNDY0MDJiNWI1MTE3NjI3YTg0MGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-31T11:00:29Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:07:54Z"}, "message": "rustc_metadata: go only through rustc_serialize in astencode.", "tree": {"sha": "3fcb17d93a2ee42b2dc266c486e1c651260fa393", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fcb17d93a2ee42b2dc266c486e1c651260fa393"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc363cb482f92851b48b46402b5b5117627a840e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc363cb482f92851b48b46402b5b5117627a840e", "html_url": "https://github.com/rust-lang/rust/commit/fc363cb482f92851b48b46402b5b5117627a840e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc363cb482f92851b48b46402b5b5117627a840e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91e7239db40372027a642bdbda19a6d593155a9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/91e7239db40372027a642bdbda19a6d593155a9f", "html_url": "https://github.com/rust-lang/rust/commit/91e7239db40372027a642bdbda19a6d593155a9f"}], "stats": {"total": 1819, "additions": 606, "deletions": 1213}, "files": [{"sha": "f36fcfd5187339006349441996fb7b0dbd15cfc8", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -8,12 +8,59 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::cstore::LOCAL_CRATE;\n use ty;\n-use syntax::ast::CrateNum;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+use serialize;\n+\n use std::fmt;\n use std::u32;\n \n+#[derive(Clone, Copy, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, Hash, Debug)]\n+pub struct CrateNum(u32);\n+\n+impl Idx for CrateNum {\n+    fn new(value: usize) -> Self {\n+        assert!(value < (u32::MAX) as usize);\n+        CrateNum(value as u32)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// Item definitions in the currently-compiled crate would have the CrateNum\n+/// LOCAL_CRATE in their DefId.\n+pub const LOCAL_CRATE: CrateNum = CrateNum(0);\n+\n+impl CrateNum {\n+    pub fn new(x: usize) -> CrateNum {\n+        assert!(x < (u32::MAX as usize));\n+        CrateNum(x as u32)\n+    }\n+\n+    pub fn from_u32(x: u32) -> CrateNum {\n+        CrateNum(x)\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+impl fmt::Display for CrateNum {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+impl serialize::UseSpecializedDecodable for CrateNum {}\n+\n /// A DefIndex is an index into the hir-map for a crate, identifying a\n /// particular definition. It should really be considered an interned\n /// shorthand for a particular DefPath.\n@@ -46,8 +93,7 @@ pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n \n /// A DefId identifies a particular *definition*, by combining a crate\n /// index and a def index.\n-#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n-           RustcDecodable, Hash, Copy)]\n+#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub index: DefIndex,"}, {"sha": "726e4e53e231c1fc5c592ac4e80b9be80f7c3524", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -881,8 +881,8 @@ pub struct IdRange {\n impl IdRange {\n     pub fn max() -> IdRange {\n         IdRange {\n-            min: u32::MAX,\n-            max: u32::MIN,\n+            min: NodeId::from_u32(u32::MAX),\n+            max: NodeId::from_u32(u32::MIN),\n         }\n     }\n \n@@ -896,7 +896,7 @@ impl IdRange {\n \n     pub fn add(&mut self, id: NodeId) {\n         self.min = cmp::min(self.min, id);\n-        self.max = cmp::max(self.max, id + 1);\n+        self.max = cmp::max(self.max, NodeId::from_u32(id.as_u32() + 1));\n     }\n \n }"}, {"sha": "9f7400c983e5aafb8a3f36e9f2f9699a7de19c21", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -61,7 +61,7 @@ use syntax_pos::Span;\n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n-    sess: Option<&'a Session>,\n+    sess: &'a Session,\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n@@ -101,22 +101,13 @@ pub fn lower_crate(sess: &Session,\n         } else {\n             Some(\"std\")\n         },\n-        sess: Some(sess),\n+        sess: sess,\n         parent_def: None,\n         resolver: resolver,\n     }.lower_crate(krate)\n }\n \n impl<'a> LoweringContext<'a> {\n-    pub fn testing_context(resolver: &'a mut Resolver) -> Self {\n-        LoweringContext {\n-            crate_root: None,\n-            sess: None,\n-            parent_def: None,\n-            resolver: resolver,\n-        }\n-    }\n-\n     fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             items: BTreeMap<NodeId, hir::Item>,\n@@ -147,12 +138,11 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn next_id(&self) -> NodeId {\n-        self.sess.map(Session::next_node_id).unwrap_or(0)\n+        self.sess.next_node_id()\n     }\n \n     fn diagnostic(&self) -> &errors::Handler {\n-        self.sess.map(Session::diagnostic)\n-                 .unwrap_or_else(|| panic!(\"this lowerer cannot emit diagnostics\"))\n+        self.sess.diagnostic()\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> Name {"}, {"sha": "6c6de8e8902454972ce0238a0242fc858dee39e4", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -63,10 +63,10 @@ impl<'ast> NodeCollector<'ast> {\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n-        if id as usize >= len {\n-            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n+        if id.as_usize() >= len {\n+            self.map.extend(repeat(NotPresent).take(id.as_usize() - len + 1));\n         }\n-        self.map[id as usize] = entry;\n+        self.map[id.as_usize()] = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {"}, {"sha": "c0c28939ab27f6f0d4cb9fe0d4d564041d6d1d2c", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map::def_collector::DefCollector;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::fmt::Write;\n@@ -70,15 +69,15 @@ pub struct DefPath {\n     pub data: Vec<DisambiguatedDefPathData>,\n \n     /// what krate root is this path relative to?\n-    pub krate: ast::CrateNum,\n+    pub krate: CrateNum,\n }\n \n impl DefPath {\n     pub fn is_local(&self) -> bool {\n         self.krate == LOCAL_CRATE\n     }\n \n-    pub fn make<FN>(start_krate: ast::CrateNum,\n+    pub fn make<FN>(start_krate: CrateNum,\n                     start_index: DefIndex,\n                     mut get_key: FN) -> DefPath\n         where FN: FnMut(DefIndex) -> DefKey"}, {"sha": "b728f1cbca097ccf4c605a19b036e52a7f3f6fa8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 16, "deletions": 90, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -22,17 +22,15 @@ use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n+use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use hir::*;\n-use hir::fold::Folder;\n use hir::print as pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n-use std::cmp;\n use std::io;\n use std::mem;\n \n@@ -240,7 +238,7 @@ impl<'ast> Map<'ast> {\n         let mut id = id0;\n         if !self.is_inlined_node_id(id) {\n             loop {\n-                match map[id as usize] {\n+                match map[id.as_usize()] {\n                     EntryItem(_, item) => {\n                         let def_id = self.local_def_id(item.id);\n                         // NB                          ^~~~~~~\n@@ -295,7 +293,7 @@ impl<'ast> Map<'ast> {\n             // reading from an inlined def-id is really a read out of\n             // the metadata from which we loaded the item.\n             loop {\n-                match map[id as usize] {\n+                match map[id.as_usize()] {\n                     EntryItem(p, _) |\n                     EntryForeignItem(p, _) |\n                     EntryTraitItem(p, _) |\n@@ -373,7 +371,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().get(id as usize).cloned()\n+        self.map.borrow().get(id.as_usize()).cloned()\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n@@ -456,8 +454,8 @@ impl<'ast> Map<'ast> {\n         let mut id = start_id;\n         loop {\n             let parent_node = self.get_parent_node(id);\n-            if parent_node == 0 {\n-                return Ok(0);\n+            if parent_node == CRATE_NODE_ID {\n+                return Ok(CRATE_NODE_ID);\n             }\n             if parent_node == id {\n                 return Err(id);\n@@ -680,7 +678,7 @@ impl<'ast> Map<'ast> {\n             map: self,\n             item_name: parts.last().unwrap(),\n             in_which: &parts[..parts.len() - 1],\n-            idx: 0,\n+            idx: CRATE_NODE_ID,\n         }\n     }\n \n@@ -801,10 +799,10 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;\n-            if idx as usize >= self.map.entry_count() {\n+            if idx.as_usize() >= self.map.entry_count() {\n                 return None;\n             }\n-            self.idx += 1;\n+            self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n             let name = match self.map.find_entry(idx) {\n                 Some(EntryItem(_, n))       => n.name(),\n                 Some(EntryForeignItem(_, n))=> n.name(),\n@@ -832,57 +830,6 @@ impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n-pub trait FoldOps {\n-    fn new_id(&self, id: NodeId) -> NodeId {\n-        id\n-    }\n-    fn new_def_id(&self, def_id: DefId) -> DefId {\n-        def_id\n-    }\n-    fn new_span(&self, span: Span) -> Span {\n-        span\n-    }\n-}\n-\n-/// A Folder that updates IDs and Span's according to fold_ops.\n-pub struct IdAndSpanUpdater<F> {\n-    fold_ops: F,\n-    min_id_assigned: NodeId,\n-    max_id_assigned: NodeId,\n-}\n-\n-impl<F: FoldOps> IdAndSpanUpdater<F> {\n-    pub fn new(fold_ops: F) -> IdAndSpanUpdater<F> {\n-        IdAndSpanUpdater {\n-            fold_ops: fold_ops,\n-            min_id_assigned: ::std::u32::MAX,\n-            max_id_assigned: ::std::u32::MIN,\n-        }\n-    }\n-\n-    pub fn id_range(&self) -> intravisit::IdRange {\n-        intravisit::IdRange {\n-            min: self.min_id_assigned,\n-            max: self.max_id_assigned + 1,\n-        }\n-    }\n-}\n-\n-impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n-    fn new_id(&mut self, id: NodeId) -> NodeId {\n-        let id = self.fold_ops.new_id(id);\n-\n-        self.min_id_assigned = cmp::min(self.min_id_assigned, id);\n-        self.max_id_assigned = cmp::max(self.max_id_assigned, id);\n-\n-        id\n-    }\n-\n-    fn new_span(&mut self, span: Span) -> Span {\n-        self.fold_ops.new_span(span)\n-    }\n-}\n-\n pub fn map_crate<'ast>(forest: &'ast mut Forest,\n                        definitions: Definitions)\n                        -> Map<'ast> {\n@@ -906,7 +853,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    let local_node_id_watermark = map.len() as NodeId;\n+    let local_node_id_watermark = NodeId::new(map.len());\n     let local_def_id_watermark = definitions.len();\n \n     Map {\n@@ -921,36 +868,15 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n \n /// Used for items loaded from external crate that are being inlined into this\n /// crate.\n-pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n-                                          parent_def_path: DefPath,\n-                                          parent_def_id: DefId,\n-                                          ii: InlinedItem,\n-                                          fold_ops: F)\n-                                          -> &'ast InlinedItem {\n+pub fn map_decoded_item<'ast>(map: &Map<'ast>,\n+                              parent_def_path: DefPath,\n+                              parent_def_id: DefId,\n+                              ii: InlinedItem,\n+                              ii_parent_id: NodeId)\n+                              -> &'ast InlinedItem {\n     let _ignore = map.forest.dep_graph.in_ignore();\n \n-    let mut fld = IdAndSpanUpdater::new(fold_ops);\n-    let ii = match ii {\n-        II::Item(d, i) => II::Item(fld.fold_ops.new_def_id(d),\n-                                   i.map(|i| fld.fold_item(i))),\n-        II::TraitItem(d, ti) => {\n-            II::TraitItem(fld.fold_ops.new_def_id(d),\n-                          ti.map(|ti| fld.fold_trait_item(ti)))\n-        }\n-        II::ImplItem(d, ii) => {\n-            II::ImplItem(fld.fold_ops.new_def_id(d),\n-                         ii.map(|ii| fld.fold_impl_item(ii)))\n-        }\n-    };\n-\n     let ii = map.forest.inlined_items.alloc(ii);\n-    let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n-\n-    // Assert that the ii_parent_id is the last NodeId in our reserved range\n-    assert!(ii_parent_id == fld.max_id_assigned);\n-    // Assert that we did not violate the invariant that all inlined HIR items\n-    // have NodeIds greater than or equal to `local_node_id_watermark`\n-    assert!(fld.min_id_assigned >= map.local_node_id_watermark);\n \n     let defs = &mut *map.definitions.borrow_mut();\n     let mut def_collector = DefCollector::extend(ii_parent_id,"}, {"sha": "289f7d6c7380088ba4a8bb6f25d346a864f4f284", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -63,9 +63,8 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n-    let requested_node: Option<ast::NodeId> = env::var(\"RUST_REGION_GRAPH_NODE\")\n-                                                  .ok()\n-                                                  .and_then(|s| s.parse().ok());\n+    let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n+        .ok().and_then(|s| s.parse().map(ast::NodeId::new).ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;"}, {"sha": "55a895b37ee330613580e0dfe396d99e8944e750", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -23,7 +23,7 @@\n // probably get a better home if someone can find one.\n \n use hir::def::{self, Def};\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n use hir::map::definitions::DefKey;\n use hir::svh::Svh;\n@@ -64,7 +64,7 @@ pub struct LinkMeta {\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n-    pub cnum: ast::CrateNum,\n+    pub cnum: CrateNum,\n }\n \n #[derive(Copy, Debug, PartialEq, Clone)]\n@@ -101,17 +101,13 @@ pub enum InlinedItem {\n }\n \n /// A borrowed version of `hir::InlinedItem`.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n pub enum InlinedItemRef<'a> {\n     Item(DefId, &'a hir::Item),\n     TraitItem(DefId, &'a hir::TraitItem),\n     ImplItem(DefId, &'a hir::ImplItem)\n }\n \n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n-pub const LOCAL_CRATE: ast::CrateNum = 0;\n-\n #[derive(Copy, Clone)]\n pub struct ChildItem {\n     pub def: DefLike,\n@@ -203,35 +199,35 @@ pub trait CrateStore<'tcx> {\n     fn is_typedef(&self, did: DefId) -> bool;\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                    -> Vec<(ast::CrateNum, LinkagePreference)>;\n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>;\n-    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>;\n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_compiler_builtins(&self, cnum: ast::CrateNum) -> bool;\n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy;\n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>;\n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>;\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                    -> Vec<(CrateNum, LinkagePreference)>;\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n+    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool;\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool;\n+    fn is_allocator(&self, cnum: CrateNum) -> bool;\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool;\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy;\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>;\n+    fn crate_attrs(&self, cnum: CrateNum) -> Vec<ast::Attribute>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n-    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n+    fn crate_name(&self, cnum: CrateNum) -> InternedString;\n     /// The name of the crate as it is stored in the crate's metadata.\n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh;\n-    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> InternedString;\n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n+    fn original_crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh;\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_struct_field_attrs(&self, cnum: CrateNum)\n                                 -> FnvHashMap<DefId, Vec<ast::Attribute>>;\n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>;\n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>;\n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool;\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>;\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex>;\n     fn def_key(&self, def: DefId) -> hir_map::DefKey;\n@@ -241,7 +237,7 @@ pub trait CrateStore<'tcx> {\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<ChildItem>;\n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>;\n+    fn crate_top_level_items(&self, cnum: CrateNum) -> Vec<ChildItem>;\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -255,7 +251,7 @@ pub trait CrateStore<'tcx> {\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<ast::CrateNum>;\n+    fn crates(&self) -> Vec<CrateNum>;\n     fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)>;\n     fn used_link_args(&self) -> Vec<String>;\n \n@@ -267,9 +263,9 @@ pub trait CrateStore<'tcx> {\n                        ty: Ty<'tcx>,\n                        def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n                        -> Vec<u8>;\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>;\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n@@ -360,7 +356,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex> {\n         None\n@@ -396,40 +392,40 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                    -> Vec<(ast::CrateNum, LinkagePreference)>\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                    -> Vec<(CrateNum, LinkagePreference)>\n         { bug!(\"dylib_dependency_formats\") }\n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n         { bug!(\"lang_items\") }\n-    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>\n+    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n         { bug!(\"missing_lang_items\") }\n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_staged_api\") }\n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_allocator\") }\n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n-    fn is_compiler_builtins(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy {\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool { bug!(\"is_staged_api\") }\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n+    fn is_allocator(&self, cnum: CrateNum) -> bool { bug!(\"is_allocator\") }\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n         bug!(\"panic_strategy\")\n     }\n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n+    fn crate_attrs(&self, cnum: CrateNum) -> Vec<ast::Attribute>\n         { bug!(\"crate_attrs\") }\n-    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString { bug!(\"crate_name\") }\n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString {\n+    fn crate_name(&self, cnum: CrateNum) -> InternedString { bug!(\"crate_name\") }\n+    fn original_crate_name(&self, cnum: CrateNum) -> InternedString {\n         bug!(\"original_crate_name\")\n     }\n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh { bug!(\"crate_hash\") }\n-    fn crate_disambiguator(&self, cnum: ast::CrateNum)\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n+    fn crate_disambiguator(&self, cnum: CrateNum)\n                            -> InternedString { bug!(\"crate_disambiguator\") }\n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n+    fn crate_struct_field_attrs(&self, cnum: CrateNum)\n                                 -> FnvHashMap<DefId, Vec<ast::Attribute>>\n         { bug!(\"crate_struct_field_attrs\") }\n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n         { bug!(\"native_libraries\") }\n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_no_builtins\") }\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> hir_map::DefKey { bug!(\"def_key\") }\n@@ -443,7 +439,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { bug!(\"tuple_struct_definition_if_ctor\") }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<ChildItem> { bug!(\"item_children\") }\n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>\n+    fn crate_top_level_items(&self, cnum: CrateNum) -> Vec<ChildItem>\n         { bug!(\"crate_top_level_items\") }\n \n     // misc. metadata\n@@ -466,7 +462,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<ast::CrateNum> { vec![] }\n+    fn crates(&self) -> Vec<CrateNum> { vec![] }\n     fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)> { vec![] }\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n@@ -480,10 +476,10 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                        -> Vec<u8> {\n         bug!(\"encode_type\")\n     }\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n         { vec![] }\n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,"}, {"sha": "7f3a58808c225edbf261871171935d1d2a88fcc7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -112,10 +112,10 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n-            pprust::NodeName(_) => 0,\n+            pprust::NodeName(_) => ast::CRATE_NODE_ID,\n             pprust::NodeExpr(expr) => expr.id,\n             pprust::NodeBlock(blk) => blk.id,\n-            pprust::NodeItem(_) | pprust::NodeSubItem(_) => 0,\n+            pprust::NodeItem(_) | pprust::NodeSubItem(_) => ast::CRATE_NODE_ID,\n             pprust::NodePat(pat) => pat.id\n         };\n "}, {"sha": "c6908e11ed20950902468383b5437c203ff89769", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -61,7 +61,7 @@\n //! Additionally, the algorithm is geared towards finding *any* solution rather\n //! than finding a number of solutions (there are normally quite a few).\n \n-use syntax::ast;\n+use hir::def_id::CrateNum;\n \n use session;\n use session::config::{self, PanicStrategy};\n@@ -169,9 +169,9 @@ fn calculate_type(sess: &session::Session,\n     }\n \n     // Collect what we've got so far in the return vector.\n-    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        match formats.get(&cnum) {\n+        match formats.get(&CrateNum::new(cnum)) {\n             Some(&RequireDynamic) => Linkage::Dynamic,\n             Some(&RequireStatic) => Linkage::IncludedFromDylib,\n             None => Linkage::NotLinked,\n@@ -191,7 +191,7 @@ fn calculate_type(sess: &session::Session,\n             assert!(src.rlib.is_some());\n             info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n             add_library(sess, cnum, RequireStatic, &mut formats);\n-            ret[cnum as usize - 1] = Linkage::Static;\n+            ret[cnum.as_usize() - 1] = Linkage::Static;\n         }\n     }\n \n@@ -213,7 +213,7 @@ fn calculate_type(sess: &session::Session,\n     // For situations like this, we perform one last pass over the dependencies,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n-        let cnum = (cnum + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(cnum + 1);\n         let src = sess.cstore.used_crate_source(cnum);\n         match *kind {\n             Linkage::NotLinked |\n@@ -237,9 +237,9 @@ fn calculate_type(sess: &session::Session,\n }\n \n fn add_library(sess: &session::Session,\n-               cnum: ast::CrateNum,\n+               cnum: CrateNum,\n                link: LinkagePreference,\n-               m: &mut FnvHashMap<ast::CrateNum, LinkagePreference>) {\n+               m: &mut FnvHashMap<CrateNum, LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n@@ -269,9 +269,9 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n \n     // All crates are available in an rlib format, so we're just going to link\n     // everything in explicitly so long as it's actually required.\n-    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        if sess.cstore.is_explicitly_linked(cnum) {\n+        if sess.cstore.is_explicitly_linked(CrateNum::new(cnum)) {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked\n@@ -298,11 +298,11 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n // a required dependency) in one of the session's field. If this field is not\n // set then this compilation doesn't actually need the dependency and we can\n // also skip this step entirely.\n-fn activate_injected_dep(injected: Option<ast::CrateNum>,\n+fn activate_injected_dep(injected: Option<CrateNum>,\n                          list: &mut DependencyList,\n-                         replaces_injected: &Fn(ast::CrateNum) -> bool) {\n+                         replaces_injected: &Fn(CrateNum) -> bool) {\n     for (i, slot) in list.iter().enumerate() {\n-        let cnum = (i + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(i + 1);\n         if !replaces_injected(cnum) {\n             continue\n         }\n@@ -311,7 +311,7 @@ fn activate_injected_dep(injected: Option<ast::CrateNum>,\n         }\n     }\n     if let Some(injected) = injected {\n-        let idx = injected as usize - 1;\n+        let idx = injected.as_usize() - 1;\n         assert_eq!(list[idx], Linkage::NotLinked);\n         list[idx] = Linkage::Static;\n     }\n@@ -329,7 +329,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n         if let Linkage::NotLinked = *linkage {\n             continue\n         }\n-        let cnum = (i + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(i + 1);\n         if sess.cstore.is_allocator(cnum) {\n             if let Some(prev) = allocator {\n                 let prev_name = sess.cstore.crate_name(prev);\n@@ -380,7 +380,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n             if desired_strategy == PanicStrategy::Abort {\n                 continue\n             }\n-            let cnum = (i + 1) as ast::CrateNum;\n+            let cnum = CrateNum::new(i + 1);\n             let found_strategy = sess.cstore.panic_strategy(cnum);\n             if desired_strategy == found_strategy {\n                 continue"}, {"sha": "e2b997ed60f2d70d5f9f6a564a917de9c9f75f09", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -17,9 +17,8 @@ use dep_graph::DepNode;\n use hir::map as hir_map;\n use session::Session;\n use lint;\n-use middle::cstore::LOCAL_CRATE;\n use hir::def::Def;\n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n use ty::{self, TyCtxt, AdtKind};\n use middle::privacy::AccessLevels;\n use syntax::parse::token::InternedString;\n@@ -103,7 +102,7 @@ pub struct Index<'tcx> {\n     depr_map: DefIdMap<Option<DeprecationEntry>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FnvHashMap<ast::CrateNum, bool>\n+    staged_api: FnvHashMap<CrateNum, bool>\n }\n \n // A private tree-walker for producing an Index."}, {"sha": "268dbd70bb5bb2f8cd1bdde4a9c4e8bbd4efbbd2", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepGraph;\n-use hir::def_id::DefIndex;\n+use hir::def_id::{CrateNum, DefIndex};\n use hir::svh::Svh;\n use lint;\n use middle::cstore::CrateStore;\n@@ -93,8 +93,8 @@ pub struct Session {\n     /// The metadata::creader module may inject an allocator/panic_runtime\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n-    pub injected_allocator: Cell<Option<ast::CrateNum>>,\n-    pub injected_panic_runtime: Cell<Option<ast::CrateNum>>,\n+    pub injected_allocator: Cell<Option<CrateNum>>,\n+    pub injected_panic_runtime: Cell<Option<CrateNum>>,\n \n     /// Map from imported macro spans (which consist of\n     /// the localized span for the macro body) to the\n@@ -266,11 +266,13 @@ impl Session {\n         }\n         lints.insert(id, vec!((lint_id, sp, msg)));\n     }\n-    pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n+    pub fn reserve_node_ids(&self, count: usize) -> ast::NodeId {\n         let id = self.next_node_id.get();\n \n-        match id.checked_add(count) {\n-            Some(next) => self.next_node_id.set(next),\n+        match id.as_usize().checked_add(count) {\n+            Some(next) => {\n+                self.next_node_id.set(ast::NodeId::new(next));\n+            }\n             None => bug!(\"Input too large, ran out of node ids!\")\n         }\n \n@@ -545,7 +547,7 @@ pub fn build_session_(sopts: config::Options,\n         crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n-        next_node_id: Cell::new(1),\n+        next_node_id: Cell::new(NodeId::new(1)),\n         injected_allocator: Cell::new(None),\n         injected_panic_runtime: Cell::new(None),\n         imported_macro_spans: RefCell::new(HashMap::new()),"}, {"sha": "68c88249ec0c36b29c3d061069f116dd438b6a53", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -12,8 +12,7 @@\n \n use super::{SelectionContext, Obligation, ObligationCause};\n \n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use infer::{InferCtxt, TypeOrigin};\n use syntax_pos::DUMMY_SP;"}, {"sha": "a96cf1111e1d3fbe8ab0ea4fb82a81d20632e2f4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -571,7 +571,7 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n \n     pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: 0, code: MiscObligation }\n+        ObligationCause { span: DUMMY_SP, body_id: ast::CRATE_NODE_ID, code: MiscObligation }\n     }\n }\n "}, {"sha": "cfe370343ae490093682f58b15a0cc3469972184", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -19,7 +19,7 @@ use syntax_pos::Span;\n \n use hir;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum AutoAdjustment<'tcx> {\n     AdjustNeverToAny(Ty<'tcx>), // go from ! to any type\n     AdjustReifyFnPointer,       // go from a fn-item type to a fn-pointer type\n@@ -90,7 +90,7 @@ pub enum AutoAdjustment<'tcx> {\n ///     unsize: Some(Box<[i32]>),\n /// }\n /// ```\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct AutoDerefRef<'tcx> {\n     /// Step 1. Apply a number of dereferences, producing an lvalue.\n     pub autoderefs: usize,\n@@ -122,7 +122,7 @@ impl<'tcx> AutoDerefRef<'tcx> {\n }\n \n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoRef<'tcx> {\n     /// Convert from T to &T.\n     AutoPtr(&'tcx ty::Region, hir::Mutability),"}, {"sha": "bb9e90f8919429771a001ecd1cbfead12b62daba", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -13,10 +13,9 @@\n use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n use middle;\n-use middle::cstore::LOCAL_CRATE;\n use hir::TraitMap;\n use hir::def::DefMap;\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as ast_map;\n use hir::map::{DefKey, DefPath, DefPathData, DisambiguatedDefPathData};\n use middle::free_region::FreeRegionMap;\n@@ -512,15 +511,15 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: ast::CrateNum) -> token::InternedString {\n+    pub fn crate_name(self, cnum: CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.crate_name(cnum)\n         }\n     }\n \n-    pub fn crate_disambiguator(self, cnum: ast::CrateNum) -> token::InternedString {\n+    pub fn crate_disambiguator(self, cnum: CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.sess.local_crate_disambiguator()\n         } else {\n@@ -533,7 +532,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// relative to `krate`.\n     ///\n     /// Returns `None` if there is no `DefIndex` with that key.\n-    pub fn def_index_for_def_key(self, krate: ast::CrateNum, key: DefKey)\n+    pub fn def_index_for_def_key(self, krate: CrateNum, key: DefKey)\n                                  -> Option<DefIndex> {\n         if krate == LOCAL_CRATE {\n             self.map.def_index_for_def_key(key)"}, {"sha": "e4247a60b15ec1b7d0f87c70b8e0801969d54931", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use hir::map::DefPathData;\n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use syntax::parse::token;\n@@ -67,7 +66,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the \"path\" to a particular crate. This can proceed in\n     /// various ways, depending on the `root_mode` of the `buffer`.\n     /// (See `RootMode` enum for more details.)\n-    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: ast::CrateNum)\n+    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum)\n         where T: ItemPathBuffer\n     {\n         match *buffer.root_mode() {"}, {"sha": "5e7a2bc0266cfa06672b54e04e3a0ec74f38d6c4", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -367,7 +367,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    pub fn repr_discr(tcx: TyCtxt, hint: attr::ReprAttr, min: i64, max: i64)\n+    pub fn repr_discr(tcx: TyCtxt, ty: Ty, hint: attr::ReprAttr, min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -377,11 +377,12 @@ impl Integer {\n         let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n \n         let at_least = match hint {\n-            attr::ReprInt(span, ity) => {\n+            attr::ReprInt(ity) => {\n                 let discr = Integer::from_attr(&tcx.data_layout, ity);\n                 let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n                 if discr < fit {\n-                    span_bug!(span, \"representation hint insufficient for discriminant range\")\n+                    bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                          discriminant range of enum `{}\", ty)\n                 }\n                 return (discr, ity.is_signed());\n             }\n@@ -397,10 +398,10 @@ impl Integer {\n             }\n             attr::ReprAny => I8,\n             attr::ReprPacked => {\n-                bug!(\"Integer::repr_discr: found #[repr(packed)] on an enum\");\n+                bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n             }\n             attr::ReprSimd => {\n-                bug!(\"Integer::repr_discr: found #[repr(simd)] on an enum\");\n+                bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n             }\n         };\n \n@@ -962,7 +963,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if x > max { max = x; }\n                     }\n \n-                    let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, hint, min, max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n@@ -1052,7 +1053,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // The general case.\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, hint, 0, discr_max);\n+                let (min_ity, _) = Integer::repr_discr(tcx, ty, hint, 0, discr_max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);"}, {"sha": "6cabc25df6afa6fcff104ffc2d586d05aca61aa1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -21,9 +21,8 @@ pub use self::fold::TypeFoldable;\n use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n-use middle::cstore::LOCAL_CRATE;\n use hir::def::{Def, PathResolution, ExportMap};\n-use hir::def_id::DefId;\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n use traits;\n@@ -42,7 +41,7 @@ use std::iter;\n use std::rc::Rc;\n use std::slice;\n use std::vec::IntoIter;\n-use syntax::ast::{self, CrateNum, Name, NodeId};\n+use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token::InternedString;\n use syntax_pos::{DUMMY_SP, Span};\n@@ -425,7 +424,7 @@ pub enum Variance {\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise.\n     pub def_id: DefId,\n@@ -627,7 +626,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy)]\n+#[derive(PartialEq, Clone, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -638,7 +637,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n+#[derive(PartialEq, Clone, Copy, RustcEncodable, RustcDecodable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -1940,7 +1939,7 @@ impl<'a, 'gcx, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n \n /// Records the substitutions used to translate the polytype for an\n /// item into the monotype of an item reference.\n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct ItemSubsts<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }"}, {"sha": "2090877fb3c92635c5144a02812f36a5b5627200", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -240,7 +240,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn enum_repr_type(self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n         match opt_hint {\n             // Feed in the given type\n-            Some(&attr::ReprInt(_, int_t)) => int_t,\n+            Some(&attr::ReprInt(int_t)) => int_t,\n             // ... but provide sensible default if none provided\n             //\n             // NB. Historically `fn enum_variants` generate i64 here, while"}, {"sha": "f7ae47d2e5e56efac5e5707f4cc1c47ef43b2d2e", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -46,7 +46,6 @@ extern crate serialize;\n #[macro_use] extern crate log;\n \n pub mod tempdir;\n-pub mod rpath;\n pub mod sha2;\n pub mod target;\n pub mod slice;"}, {"sha": "5d2b266ec4b7f5df8554bb8f153c74a53c28ea6f", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -460,7 +460,7 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n         _ => bug!()\n     };\n     P(hir::Expr {\n-        id: 0,\n+        id: DUMMY_NODE_ID,\n         node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP,\n         attrs: ast::ThinVec::new(),\n@@ -625,7 +625,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     };\n \n     P(hir::Pat {\n-        id: 0,\n+        id: DUMMY_NODE_ID,\n         node: pat,\n         span: DUMMY_SP\n     })"}, {"sha": "215287f84399c1d9e079c8ac09bc6326e5d99ed1", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -539,6 +539,7 @@ impl FromStr for UserIdentifiedItem {\n     type Err = ();\n     fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n         Ok(s.parse()\n+            .map(ast::NodeId::new)\n             .map(ItemViaNode)\n             .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n     }"}, {"sha": "f6772b8771844526844b125f35a575bc00d17633", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -166,16 +166,17 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn create_simple_region_hierarchy(&self) {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n+\n+        let node = ast::NodeId::from_u32;\n         let dscope = self.infcx\n                          .tcx\n                          .region_maps\n-                         .intern_code_extent(CodeExtentData::DestructionScope(1),\n+                         .intern_code_extent(CodeExtentData::DestructionScope(node(1)),\n                                              region::ROOT_CODE_EXTENT);\n         self.create_region_hierarchy(&RH {\n-                                         id: 1,\n-                                         sub: &[RH { id: 10, sub: &[] }, RH { id: 11, sub: &[] }],\n-                                     },\n-                                     dscope);\n+            id: node(1),\n+            sub: &[RH { id: node(10), sub: &[] }, RH { id: node(11), sub: &[] }],\n+        }, dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -315,8 +316,8 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n-    pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        let r = ty::ReScope(self.tcx().region_maps.node_extent(id));\n+    pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n+        let r = ty::ReScope(self.tcx().region_maps.node_extent(ast::NodeId::from_u32(id)));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n@@ -327,8 +328,8 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         }))\n     }\n \n-    pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n-        let r = self.re_free(nid, id);\n+    pub fn t_rptr_free(&self, nid: u32, id: u32) -> Ty<'tcx> {\n+        let r = self.re_free(ast::NodeId::from_u32(nid), id);\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n "}, {"sha": "cca364f442d599001b61cceb7fab3ffbc72cd54d", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -15,13 +15,11 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map::DefPath;\n-use rustc::hir::def_id::DefId;\n-use rustc::middle::cstore::LOCAL_CRATE;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n use rustc::util::nodemap::DefIdMap;\n use std::fmt::{self, Debug};\n use std::iter::once;\n-use syntax::ast;\n \n /// Index into the DefIdDirectory\n #[derive(Copy, Clone, Debug, PartialOrd, Ord, Hash, PartialEq, Eq,\n@@ -43,7 +41,7 @@ pub struct DefIdDirectory {\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct CrateInfo {\n-    krate: ast::CrateNum,\n+    krate: CrateNum,\n     name: String,\n     disambiguator: String,\n }\n@@ -53,7 +51,7 @@ impl DefIdDirectory {\n         DefIdDirectory { paths: vec![], krates: krates }\n     }\n \n-    fn max_current_crate(&self, tcx: TyCtxt) -> ast::CrateNum {\n+    fn max_current_crate(&self, tcx: TyCtxt) -> CrateNum {\n         tcx.sess.cstore.crates()\n                        .into_iter()\n                        .max()\n@@ -72,16 +70,16 @@ impl DefIdDirectory {\n \n     pub fn krate_still_valid(&self,\n                              tcx: TyCtxt,\n-                             max_current_crate: ast::CrateNum,\n-                             krate: ast::CrateNum) -> bool {\n+                             max_current_crate: CrateNum,\n+                             krate: CrateNum) -> bool {\n         // Check that the crate-number still matches. For now, if it\n         // doesn't, just return None. We could do better, such as\n         // finding the new number.\n \n         if krate > max_current_crate {\n             false\n         } else {\n-            let old_info = &self.krates[krate as usize];\n+            let old_info = &self.krates[krate.as_usize()];\n             assert_eq!(old_info.krate, krate);\n             let old_name: &str = &old_info.name;\n             let old_disambiguator: &str = &old_info.disambiguator;\n@@ -101,7 +99,7 @@ impl DefIdDirectory {\n                                 } else {\n                                     debug!(\"crate {} changed from {:?} to {:?}/{:?}\",\n                                            path.krate,\n-                                           self.krates[path.krate as usize],\n+                                           self.krates[path.krate.as_usize()],\n                                            tcx.crate_name(path.krate),\n                                            tcx.crate_disambiguator(path.krate));\n                                     None"}, {"sha": "c9cfaf4f6613fd6a59490b8d571477bbbe05e7ec", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -114,8 +114,8 @@\n //! unsupported file system and emit a warning in that case. This is not yet\n //! implemented.\n \n+use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n@@ -129,7 +129,6 @@ use std::mem;\n use std::path::{Path, PathBuf};\n use std::time::{UNIX_EPOCH, SystemTime, Duration};\n use std::__rand::{thread_rng, Rng};\n-use syntax::ast;\n \n const LOCK_FILE_EXT: &'static str = \".lock\";\n const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n@@ -580,7 +579,7 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n     Ok(UNIX_EPOCH + duration)\n }\n \n-fn crate_path_tcx(tcx: TyCtxt, cnum: ast::CrateNum) -> PathBuf {\n+fn crate_path_tcx(tcx: TyCtxt, cnum: CrateNum) -> PathBuf {\n     crate_path(tcx.sess, &tcx.crate_name(cnum), &tcx.crate_disambiguator(cnum))\n }\n \n@@ -592,7 +591,7 @@ fn crate_path_tcx(tcx: TyCtxt, cnum: ast::CrateNum) -> PathBuf {\n /// crate's (name, disambiguator) pair. The metadata hashes are only valid for\n /// the exact version of the binary we are reading from now (i.e. the hashes\n /// are part of the dependency graph of a specific compilation session).\n-pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: ast::CrateNum) -> Option<PathBuf> {\n+pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: CrateNum) -> Option<PathBuf> {\n     let crate_directory = crate_path_tcx(tcx, cnum);\n \n     if !crate_directory.exists() {"}, {"sha": "6dcf2c288914c2c5dd35955f5f6bd505556623f9", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -11,15 +11,14 @@\n use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::svh::Svh;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n use std::io::{ErrorKind, Read};\n use std::fs::File;\n-use syntax::ast;\n \n use IncrementalHashesMap;\n use super::data::*;\n@@ -29,7 +28,7 @@ pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n     item_metadata_hashes: FnvHashMap<DefId, u64>,\n-    crate_hashes: FnvHashMap<ast::CrateNum, Svh>,\n+    crate_hashes: FnvHashMap<CrateNum, Svh>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n@@ -121,7 +120,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    fn load_data(&mut self, cnum: ast::CrateNum) {\n+    fn load_data(&mut self, cnum: CrateNum) {\n         debug!(\"load_data(cnum={})\", cnum);\n \n         let svh = self.tcx.sess.cstore.crate_hash(cnum);\n@@ -187,7 +186,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n     }\n \n     fn load_from_data(&mut self,\n-                      cnum: ast::CrateNum,\n+                      cnum: CrateNum,\n                       data: &[u8],\n                       expected_svh: Svh) -> Result<(), Error> {\n         debug!(\"load_from_data(cnum={})\", cnum);"}, {"sha": "1209ced8dd3d75ffd0d4fc45c67363267194ebd3", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -92,7 +92,7 @@ pub struct TypeLimits {\n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n         TypeLimits {\n-            negated_expr_id: !0,\n+            negated_expr_id: ast::DUMMY_NODE_ID,\n         }\n     }\n }"}, {"sha": "397b33178dce88d91383f4c84fc111c46f17302a", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 60, "deletions": 582, "changes": 642, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -9,98 +9,57 @@\n // except according to those terms.\n \n #![allow(non_camel_case_types)]\n-// FIXME: remove this after snapshot, and Results are handled\n-#![allow(unused_must_use)]\n \n use rustc::hir::map as ast_map;\n \n-use rustc::hir;\n-use rustc::hir::fold;\n-use rustc::hir::fold::Folder;\n use rustc::hir::intravisit::{Visitor, IdRangeComputingVisitor, IdRange};\n \n use common as c;\n use cstore;\n-use decoder;\n \n use decoder::DecodeContext;\n use encoder::EncodeContext;\n \n use middle::cstore::{InlinedItem, InlinedItemRef};\n use rustc::ty::adjustment;\n-use rustc::ty::cast;\n-use middle::const_qualif::ConstQualif;\n-use rustc::hir::def::{self, Def};\n+use rustc::hir::def;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n \n use syntax::ast;\n-use syntax::ptr::P;\n-use syntax_pos;\n-\n-use std::io::SeekFrom;\n-use std::io::prelude::*;\n \n use rbml::reader;\n use rbml;\n-use rustc_serialize::{Decodable, Decoder, DecoderHelpers};\n-use rustc_serialize::{Encodable, EncoderHelpers};\n-\n-trait tr {\n-    fn tr(&self, dcx: &DecodeContext) -> Self;\n-}\n+use rustc_serialize::{Decodable, Encodable};\n \n // ______________________________________________________________________\n // Top-level methods.\n \n pub fn encode_inlined_item(ecx: &mut EncodeContext, ii: InlinedItemRef) {\n-    let id = match ii {\n-        InlinedItemRef::Item(_, i) => i.id,\n-        InlinedItemRef::TraitItem(_, ti) => ti.id,\n-        InlinedItemRef::ImplItem(_, ii) => ii.id,\n-    };\n-    debug!(\"> Encoding inlined item: {} ({:?})\",\n-           ecx.tcx.node_path_str(id),\n-           ecx.writer.seek(SeekFrom::Current(0)));\n-\n-    // Folding could be avoided with a smarter encoder.\n-    let (ii, expected_id_range) = simplify_ast(ii);\n-    let id_range = inlined_item_id_range(&ii);\n-    assert_eq!(expected_id_range, id_range);\n-\n-    ecx.start_tag(c::tag_ast);\n-\n-    ecx.start_tag(c::tag_id_range);\n-    id_range.encode(&mut ecx.opaque());\n-    ecx.end_tag();\n-\n-    ecx.start_tag(c::tag_tree);\n-    ii.encode(ecx);\n-    ecx.end_tag();\n-\n-    encode_side_tables_for_ii(ecx, &ii);\n-    ecx.end_tag();\n+    ecx.tag(c::tag_ast, |ecx| {\n+        ecx.tag(c::tag_id_range, |ecx| {\n+            let mut visitor = IdRangeComputingVisitor::new();\n+            match ii {\n+                InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n+                InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n+                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n+            }\n+            visitor.result().encode(&mut ecx.opaque()).unwrap()\n+        });\n \n-    debug!(\"< Encoded inlined fn: {} ({:?})\",\n-           ecx.tcx.node_path_str(id),\n-           ecx.writer.seek(SeekFrom::Current(0)));\n-}\n+        ecx.tag(c::tag_tree, |ecx| ii.encode(ecx).unwrap());\n \n-impl<'a, 'b, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'tcx> {\n-    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n-        if id == ast::DUMMY_NODE_ID {\n-            // Used by ast_map to map the NodeInlinedParent.\n-            self.tcx.sess.next_node_id()\n-        } else {\n-            self.tr_id(id)\n-        }\n-    }\n-    fn new_def_id(&self, def_id: DefId) -> DefId {\n-        self.tr_def_id(def_id)\n-    }\n-    fn new_span(&self, span: syntax_pos::Span) -> syntax_pos::Span {\n-        self.tr_span(span)\n-    }\n+        ecx.tag(c::tag_table, |ecx| {\n+            let mut visitor = SideTableEncodingIdVisitor {\n+                ecx: ecx\n+            };\n+            match ii {\n+                InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n+                InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n+                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n+            }\n+        });\n+    });\n }\n \n /// Decodes an item from its AST in the cdata's metadata and adds it to the\n@@ -113,8 +72,13 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                      orig_did: DefId)\n                                      -> &'tcx InlinedItem {\n     debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n-    let id_range_doc = ast_doc.get(c::tag_id_range);\n-    let from_id_range = IdRange::decode(&mut id_range_doc.opaque()).unwrap();\n+    let from_id_range = {\n+        let decoder = &mut ast_doc.get(c::tag_id_range).opaque();\n+        IdRange {\n+            min: ast::NodeId::from_u32(u32::decode(decoder).unwrap()),\n+            max: ast::NodeId::from_u32(u32::decode(decoder).unwrap())\n+        }\n+    };\n     let mut dcx = DecodeContext::new(tcx, cdata, from_id_range,\n                                      ast_doc.get(c::tag_tree));\n     let ii = InlinedItem::decode(&mut dcx).unwrap();\n@@ -123,7 +87,7 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                        parent_def_path,\n                                        parent_did,\n                                        ii,\n-                                       &dcx);\n+                                       tcx.sess.next_node_id());\n \n     let item_node_id = match ii {\n         &InlinedItem::Item(_, ref i) => i.id,\n@@ -138,376 +102,18 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n     ii\n }\n \n-// ______________________________________________________________________\n-// Enumerating the IDs which appear in an AST\n-\n-impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    /// Translates an internal id, meaning a node id that is known to refer to some part of the\n-    /// item currently being inlined, such as a local variable or argument.  All naked node-ids\n-    /// that appear in types have this property, since if something might refer to an external item\n-    /// we would use a def-id to allow for the possibility that the item resides in another crate.\n-    pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n-        // from_id_range should be non-empty\n-        assert!(!self.from_id_range.empty());\n-        // Make sure that translating the NodeId will actually yield a\n-        // meaningful result\n-        assert!(self.from_id_range.contains(id));\n-\n-        // Use wrapping arithmetic because otherwise it introduces control flow.\n-        // Maybe we should just have the control flow? -- aatch\n-        (id.wrapping_sub(self.from_id_range.min).wrapping_add(self.to_id_range.min))\n-    }\n-\n-    /// Translates an EXTERNAL def-id, converting the crate number from the one used in the encoded\n-    /// data to the current crate numbers..  By external, I mean that it be translated to a\n-    /// reference to the item in its original crate, as opposed to being translated to a reference\n-    /// to the inlined version of the item.  This is typically, but not always, what you want,\n-    /// because most def-ids refer to external things like types or other fns that may or may not\n-    /// be inlined.  Note that even when the inlined function is referencing itself recursively, we\n-    /// would want `tr_def_id` for that reference--- conceptually the function calls the original,\n-    /// non-inlined version, and trans deals with linking that recursive call to the inlined copy.\n-    pub fn tr_def_id(&self, did: DefId) -> DefId {\n-        decoder::translate_def_id(self.cdata, did)\n-    }\n-\n-    /// Translates a `Span` from an extern crate to the corresponding `Span`\n-    /// within the local crate's codemap.\n-    pub fn tr_span(&self, span: syntax_pos::Span) -> syntax_pos::Span {\n-        decoder::translate_span(self.cdata,\n-                                self.tcx.sess.codemap(),\n-                                &self.last_filemap_index,\n-                                span)\n-    }\n-}\n-\n-impl tr for DefId {\n-    fn tr(&self, dcx: &DecodeContext) -> DefId {\n-        dcx.tr_def_id(*self)\n-    }\n-}\n-\n-impl tr for Option<DefId> {\n-    fn tr(&self, dcx: &DecodeContext) -> Option<DefId> {\n-        self.map(|d| dcx.tr_def_id(d))\n-    }\n-}\n-\n-impl tr for syntax_pos::Span {\n-    fn tr(&self, dcx: &DecodeContext) -> syntax_pos::Span {\n-        dcx.tr_span(*self)\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding the AST itself\n-//\n-// When decoding, we have to renumber the AST so that the node ids that\n-// appear within are disjoint from the node ids in our existing ASTs.\n-// We also have to adjust the spans: for now we just insert a dummy span,\n-// but eventually we should add entries to the local codemap as required.\n-\n-struct NestedItemsDropper {\n-    id_range: IdRange\n-}\n-\n-impl Folder for NestedItemsDropper {\n-\n-    // The unit tests below run on HIR with NodeIds not properly assigned. That\n-    // causes an integer overflow. So we just don't track the id_range when\n-    // building the unit tests.\n-    #[cfg(not(test))]\n-    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n-        // Record the range of NodeIds we are visiting, so we can do a sanity\n-        // check later\n-        self.id_range.add(id);\n-        id\n-    }\n-\n-    fn fold_block(&mut self, blk: P<hir::Block>) -> P<hir::Block> {\n-        blk.and_then(|hir::Block {id, stmts, expr, rules, span, ..}| {\n-            let stmts_sans_items = stmts.into_iter().filter_map(|stmt| {\n-                let use_stmt = match stmt.node {\n-                    hir::StmtExpr(..) | hir::StmtSemi(..) => true,\n-                    hir::StmtDecl(ref decl, _) => {\n-                        match decl.node {\n-                            hir::DeclLocal(_) => true,\n-                            hir::DeclItem(_) => false,\n-                        }\n-                    }\n-                };\n-                if use_stmt {\n-                    Some(stmt)\n-                } else {\n-                    None\n-                }\n-            }).collect();\n-            let blk_sans_items = P(hir::Block {\n-                stmts: stmts_sans_items,\n-                expr: expr,\n-                id: id,\n-                rules: rules,\n-                span: span,\n-            });\n-            fold::noop_fold_block(blk_sans_items, self)\n-        })\n-    }\n-}\n-\n-// Produces a simplified copy of the AST which does not include things\n-// that we do not need to or do not want to export.  For example, we\n-// do not include any nested items: if these nested items are to be\n-// inlined, their AST will be exported separately (this only makes\n-// sense because, in Rust, nested items are independent except for\n-// their visibility).\n-//\n-// As it happens, trans relies on the fact that we do not export\n-// nested items, as otherwise it would get confused when translating\n-// inlined items.\n-fn simplify_ast(ii: InlinedItemRef) -> (InlinedItem, IdRange) {\n-    let mut fld = NestedItemsDropper {\n-        id_range: IdRange::max()\n-    };\n-\n-    let ii = match ii {\n-        // HACK we're not dropping items.\n-        InlinedItemRef::Item(d, i) => {\n-            InlinedItem::Item(d, P(fold::noop_fold_item(i.clone(), &mut fld)))\n-        }\n-        InlinedItemRef::TraitItem(d, ti) => {\n-            InlinedItem::TraitItem(d, P(fold::noop_fold_trait_item(ti.clone(), &mut fld)))\n-        }\n-        InlinedItemRef::ImplItem(d, ii) => {\n-            InlinedItem::ImplItem(d, P(fold::noop_fold_impl_item(ii.clone(), &mut fld)))\n-        }\n-    };\n-\n-    (ii, fld.id_range)\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding of ast::def\n-\n-impl tr for Def {\n-    fn tr(&self, dcx: &DecodeContext) -> Def {\n-        match *self {\n-          Def::Fn(did) => Def::Fn(did.tr(dcx)),\n-          Def::Method(did) => Def::Method(did.tr(dcx)),\n-          Def::SelfTy(opt_did, impl_id) => {\n-              // Since the impl_id will never lie within the reserved range of\n-              // imported NodeIds, it does not make sense to translate it.\n-              // The result would not make any sense within the importing crate.\n-              // We also don't allow for impl items to be inlined (just their\n-              // members), so even if we had a DefId here, we wouldn't be able\n-              // to do much with it.\n-              // So, we set the id to DUMMY_NODE_ID. That way we make it\n-              // explicit that this is no usable NodeId.\n-              Def::SelfTy(opt_did.map(|did| did.tr(dcx)),\n-                          impl_id.map(|_| ast::DUMMY_NODE_ID))\n-          }\n-          Def::Mod(did) => { Def::Mod(did.tr(dcx)) }\n-          Def::ForeignMod(did) => { Def::ForeignMod(did.tr(dcx)) }\n-          Def::Static(did, m) => { Def::Static(did.tr(dcx), m) }\n-          Def::Const(did) => { Def::Const(did.tr(dcx)) }\n-          Def::AssociatedConst(did) => Def::AssociatedConst(did.tr(dcx)),\n-          Def::Local(_, nid) => {\n-              let nid = dcx.tr_id(nid);\n-              let did = dcx.tcx.map.local_def_id(nid);\n-              Def::Local(did, nid)\n-          }\n-          Def::Variant(e_did, v_did) => Def::Variant(e_did.tr(dcx), v_did.tr(dcx)),\n-          Def::Trait(did) => Def::Trait(did.tr(dcx)),\n-          Def::Enum(did) => Def::Enum(did.tr(dcx)),\n-          Def::TyAlias(did) => Def::TyAlias(did.tr(dcx)),\n-          Def::AssociatedTy(trait_did, did) =>\n-              Def::AssociatedTy(trait_did.tr(dcx), did.tr(dcx)),\n-          Def::PrimTy(p) => Def::PrimTy(p),\n-          Def::TyParam(did) => Def::TyParam(did.tr(dcx)),\n-          Def::Upvar(_, nid1, index, nid2) => {\n-              let nid1 = dcx.tr_id(nid1);\n-              let nid2 = dcx.tr_id(nid2);\n-              let did1 = dcx.tcx.map.local_def_id(nid1);\n-              Def::Upvar(did1, nid1, index, nid2)\n-          }\n-          Def::Struct(did) => Def::Struct(did.tr(dcx)),\n-          Def::Union(did) => Def::Union(did.tr(dcx)),\n-          Def::Label(nid) => Def::Label(dcx.tr_id(nid)),\n-          Def::Err => Def::Err,\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding of freevar information\n-\n-impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    fn read_freevar_entry(&mut self) -> hir::Freevar {\n-        hir::Freevar::decode(self).unwrap().tr(self)\n-    }\n-}\n-\n-impl tr for hir::Freevar {\n-    fn tr(&self, dcx: &DecodeContext) -> hir::Freevar {\n-        hir::Freevar {\n-            def: self.def.tr(dcx),\n-            span: self.span.tr(dcx),\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Encoding and decoding of MethodCallee\n-\n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_method_callee(&mut self,\n-                            autoderef: u32,\n-                            method: &ty::MethodCallee<'tcx>) {\n-        use rustc_serialize::Encoder;\n-\n-        self.emit_struct(\"MethodCallee\", 4, |this| {\n-            this.emit_struct_field(\"autoderef\", 0, |this| {\n-                autoderef.encode(this)\n-            });\n-            this.emit_struct_field(\"def_id\", 1, |this| {\n-                method.def_id.encode(this)\n-            });\n-            this.emit_struct_field(\"ty\", 2, |this| {\n-                method.ty.encode(this)\n-            });\n-            this.emit_struct_field(\"substs\", 3, |this| {\n-                method.substs.encode(this)\n-            })\n-        }).unwrap();\n-    }\n-}\n-\n-impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    fn read_method_callee(&mut self)  -> (u32, ty::MethodCallee<'tcx>) {\n-        self.read_struct(\"MethodCallee\", 4, |this| {\n-            let autoderef = this.read_struct_field(\"autoderef\", 0,\n-                                                   Decodable::decode).unwrap();\n-            Ok((autoderef, ty::MethodCallee {\n-                def_id: this.read_struct_field(\"def_id\", 1, |this| {\n-                    DefId::decode(this).map(|d| d.tr(this))\n-                }).unwrap(),\n-                ty: this.read_struct_field(\"ty\", 2, |this| {\n-                    Ty::decode(this)\n-                }).unwrap(),\n-                substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Decodable::decode(this)\n-                }).unwrap()\n-            }))\n-        }).unwrap()\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn emit_upvar_capture(&mut self, capture: &ty::UpvarCapture<'tcx>) {\n-        use rustc_serialize::Encoder;\n-\n-        self.emit_enum(\"UpvarCapture\", |this| {\n-            match *capture {\n-                ty::UpvarCapture::ByValue => {\n-                    this.emit_enum_variant(\"ByValue\", 1, 0, |_| Ok(()))\n-                }\n-                ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind, region }) => {\n-                    this.emit_enum_variant(\"ByRef\", 2, 0, |this| {\n-                        this.emit_enum_variant_arg(0, |this| kind.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| region.encode(this))\n-                    })\n-                }\n-            }\n-        }).unwrap()\n-    }\n-\n-    fn emit_auto_adjustment(&mut self, adj: &adjustment::AutoAdjustment<'tcx>) {\n-        use rustc_serialize::Encoder;\n-\n-        self.emit_enum(\"AutoAdjustment\", |this| {\n-            match *adj {\n-                adjustment::AdjustReifyFnPointer => {\n-                    this.emit_enum_variant(\"AdjustReifyFnPointer\", 1, 0, |_| Ok(()))\n-                }\n-\n-                adjustment::AdjustUnsafeFnPointer => {\n-                    this.emit_enum_variant(\"AdjustUnsafeFnPointer\", 2, 0, |_| {\n-                        Ok(())\n-                    })\n-                }\n-\n-                adjustment::AdjustMutToConstPointer => {\n-                    this.emit_enum_variant(\"AdjustMutToConstPointer\", 3, 0, |_| {\n-                        Ok(())\n-                    })\n-                }\n-\n-                adjustment::AdjustDerefRef(ref auto_deref_ref) => {\n-                    this.emit_enum_variant(\"AdjustDerefRef\", 4, 2, |this| {\n-                        this.emit_enum_variant_arg(0,\n-                            |this| Ok(this.emit_auto_deref_ref(auto_deref_ref)))\n-                    })\n-                }\n-\n-                adjustment::AdjustNeverToAny(ref ty) => {\n-                    this.emit_enum_variant(\"AdjustNeverToAny\", 5, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| ty.encode(this))\n-                    })\n-                }\n-            }\n-        });\n-    }\n-\n-    fn emit_autoref(&mut self, autoref: &adjustment::AutoRef<'tcx>) {\n-        use rustc_serialize::Encoder;\n-\n-        self.emit_enum(\"AutoRef\", |this| {\n-            match autoref {\n-                &adjustment::AutoPtr(r, m) => {\n-                    this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n-                        this.emit_enum_variant_arg(0, |this| r.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| m.encode(this))\n-                    })\n-                }\n-                &adjustment::AutoUnsafe(m) => {\n-                    this.emit_enum_variant(\"AutoUnsafe\", 1, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| m.encode(this))\n-                    })\n-                }\n-            }\n-        });\n-    }\n-\n-    fn emit_auto_deref_ref(&mut self, auto_deref_ref: &adjustment::AutoDerefRef<'tcx>) {\n-        use rustc_serialize::Encoder;\n-\n-        self.emit_struct(\"AutoDerefRef\", 2, |this| {\n-            this.emit_struct_field(\"autoderefs\", 0, |this| auto_deref_ref.autoderefs.encode(this));\n-\n-            this.emit_struct_field(\"autoref\", 1, |this| {\n-                this.emit_option(|this| {\n-                    match auto_deref_ref.autoref {\n-                        None => this.emit_option_none(),\n-                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(a))),\n-                    }\n-                })\n-            });\n-\n-            this.emit_struct_field(\"unsize\", 2, |this| {\n-                auto_deref_ref.unsize.encode(this)\n-            })\n-        });\n-    }\n-\n     fn tag<F>(&mut self,\n               tag_id: usize,\n               f: F) where\n         F: FnOnce(&mut Self),\n     {\n-        self.start_tag(tag_id);\n+        self.start_tag(tag_id).unwrap();\n         f(self);\n-        self.end_tag();\n+        self.end_tag().unwrap();\n     }\n \n     fn id(&mut self, id: ast::NodeId) {\n@@ -525,14 +131,6 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx>\n     }\n }\n \n-fn encode_side_tables_for_ii(ecx: &mut EncodeContext, ii: &InlinedItem) {\n-    ecx.start_tag(c::tag_table);\n-    ii.visit(&mut SideTableEncodingIdVisitor {\n-        ecx: ecx\n-    });\n-    ecx.end_tag();\n-}\n-\n fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n@@ -548,23 +146,21 @@ fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n     if let Some(ty) = tcx.node_types().get(&id) {\n         ecx.tag(c::tag_table_node_type, |ecx| {\n             ecx.id(id);\n-            ty.encode(ecx);\n+            ty.encode(ecx).unwrap();\n         })\n     }\n \n     if let Some(item_substs) = tcx.tables.borrow().item_substs.get(&id) {\n         ecx.tag(c::tag_table_item_subst, |ecx| {\n             ecx.id(id);\n-            item_substs.substs.encode(ecx);\n+            item_substs.substs.encode(ecx).unwrap();\n         })\n     }\n \n     if let Some(fv) = tcx.freevars.borrow().get(&id) {\n         ecx.tag(c::tag_table_freevars, |ecx| {\n             ecx.id(id);\n-            ecx.emit_from_vec(fv, |ecx, fv_entry| {\n-                fv_entry.encode(ecx)\n-            });\n+            fv.encode(ecx).unwrap();\n         });\n \n         for freevar in fv {\n@@ -582,8 +178,8 @@ fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n                                        .get(&upvar_id)\n                                        .unwrap()\n                                        .clone();\n-                var_id.encode(ecx);\n-                ecx.emit_upvar_capture(&upvar_capture);\n+                var_id.encode(ecx).unwrap();\n+                upvar_capture.encode(ecx).unwrap();\n             })\n         }\n     }\n@@ -592,7 +188,8 @@ fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n         ecx.tag(c::tag_table_method_map, |ecx| {\n             ecx.id(id);\n-            ecx.encode_method_callee(method_call.autoderef, method)\n+            method_call.autoderef.encode(ecx).unwrap();\n+            method.encode(ecx).unwrap();\n         })\n     }\n \n@@ -604,7 +201,8 @@ fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n                     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n                         ecx.tag(c::tag_table_method_map, |ecx| {\n                             ecx.id(id);\n-                            ecx.encode_method_callee(method_call.autoderef, method)\n+                            method_call.autoderef.encode(ecx).unwrap();\n+                            method.encode(ecx).unwrap();\n                         })\n                     }\n                 }\n@@ -614,7 +212,7 @@ fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n \n         ecx.tag(c::tag_table_adjustments, |ecx| {\n             ecx.id(id);\n-            ecx.emit_auto_adjustment(adjustment);\n+            adjustment.encode(ecx).unwrap();\n         })\n     }\n \n@@ -633,180 +231,60 @@ fn encode_side_tables_for_id(ecx: &mut EncodeContext, id: ast::NodeId) {\n     }\n }\n \n-impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n-    fn read_upvar_capture(&mut self) -> ty::UpvarCapture<'tcx> {\n-        self.read_enum(\"UpvarCapture\", |this| {\n-            let variants = [\"ByValue\", \"ByRef\"];\n-            this.read_enum_variant(&variants, |this, i| {\n-                Ok(match i {\n-                    1 => ty::UpvarCapture::ByValue,\n-                    2 => ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                        kind: this.read_enum_variant_arg(0,\n-                                  |this| Decodable::decode(this)).unwrap(),\n-                        region: this.read_enum_variant_arg(1,\n-                                    |this| Decodable::decode(this)).unwrap()\n-                    }),\n-                    _ => bug!(\"bad enum variant for ty::UpvarCapture\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n-    fn read_auto_adjustment(&mut self) -> adjustment::AutoAdjustment<'tcx> {\n-        self.read_enum(\"AutoAdjustment\", |this| {\n-            let variants = [\"AdjustReifyFnPointer\", \"AdjustUnsafeFnPointer\",\n-                            \"AdjustMutToConstPointer\", \"AdjustDerefRef\",\n-                            \"AdjustNeverToAny\"];\n-            this.read_enum_variant(&variants, |this, i| {\n-                Ok(match i {\n-                    1 => adjustment::AdjustReifyFnPointer,\n-                    2 => adjustment::AdjustUnsafeFnPointer,\n-                    3 => adjustment::AdjustMutToConstPointer,\n-                    4 => {\n-                        let auto_deref_ref: adjustment::AutoDerefRef =\n-                            this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_auto_deref_ref())).unwrap();\n-\n-                        adjustment::AdjustDerefRef(auto_deref_ref)\n-                    }\n-                    5 => {\n-                        let ty: Ty<'tcx> = this.read_enum_variant_arg(0, |this| {\n-                            Ty::decode(this)\n-                        }).unwrap();\n-\n-                        adjustment::AdjustNeverToAny(ty)\n-                    }\n-                    _ => bug!(\"bad enum variant for adjustment::AutoAdjustment\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n-\n-    fn read_auto_deref_ref(&mut self) -> adjustment::AutoDerefRef<'tcx> {\n-        self.read_struct(\"AutoDerefRef\", 2, |this| {\n-            Ok(adjustment::AutoDerefRef {\n-                autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n-                    Decodable::decode(this)\n-                }).unwrap(),\n-                autoref: this.read_struct_field(\"autoref\", 1, |this| {\n-                    this.read_option(|this, b| {\n-                        if b {\n-                            Ok(Some(this.read_autoref()))\n-                        } else {\n-                            Ok(None)\n-                        }\n-                    })\n-                }).unwrap(),\n-                unsize: this.read_struct_field(\"unsize\", 2, |this| {\n-                    Decodable::decode(this)\n-                }).unwrap(),\n-            })\n-        }).unwrap()\n-    }\n-\n-    fn read_autoref(&mut self) -> adjustment::AutoRef<'tcx> {\n-        self.read_enum(\"AutoRef\", |this| {\n-            let variants = [\"AutoPtr\", \"AutoUnsafe\"];\n-            this.read_enum_variant(&variants, |this, i| {\n-                Ok(match i {\n-                    0 => {\n-                        let r: &'tcx ty::Region =\n-                            this.read_enum_variant_arg(0, |this| {\n-                                Decodable::decode(this)\n-                            }).unwrap();\n-                        let m: hir::Mutability =\n-                            this.read_enum_variant_arg(1, |this| {\n-                                Decodable::decode(this)\n-                            }).unwrap();\n-\n-                        adjustment::AutoPtr(r, m)\n-                    }\n-                    1 => {\n-                        let m: hir::Mutability =\n-                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n-\n-                        adjustment::AutoUnsafe(m)\n-                    }\n-                    _ => bug!(\"bad enum variant for adjustment::AutoRef\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n-}\n-\n fn decode_side_tables<'a, 'tcx>(dcx: &mut DecodeContext<'a, 'tcx>,\n                                 ast_doc: rbml::Doc<'a>) {\n     for (tag, entry_doc) in reader::docs(ast_doc.get(c::tag_table)) {\n         dcx.rbml_r = reader::Decoder::new(entry_doc);\n-\n-        let id0: ast::NodeId = Decodable::decode(dcx).unwrap();\n-        let id = dcx.tr_id(id0);\n-\n-        debug!(\">> Side table document with tag 0x{:x} \\\n-                found for id {} (orig {})\",\n-               tag, id, id0);\n-\n+        let id = Decodable::decode(dcx).unwrap();\n+        debug!(\"decode_side_tables: entry for id={}, tag=0x{:x}\", id, tag);\n         match tag {\n             c::tag_table_def => {\n-                let def = Def::decode(dcx).unwrap().tr(dcx);\n+                let def = Decodable::decode(dcx).unwrap();\n                 dcx.tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n             }\n             c::tag_table_node_type => {\n-                let ty = Ty::decode(dcx).unwrap();\n+                let ty = Decodable::decode(dcx).unwrap();\n                 dcx.tcx.node_type_insert(id, ty);\n             }\n             c::tag_table_item_subst => {\n-                let item_substs = ty::ItemSubsts {\n-                    substs: Decodable::decode(dcx).unwrap()\n-                };\n-                dcx.tcx.tables.borrow_mut().item_substs.insert(\n-                    id, item_substs);\n+                let item_substs = Decodable::decode(dcx).unwrap();\n+                dcx.tcx.tables.borrow_mut().item_substs.insert(id, item_substs);\n             }\n             c::tag_table_freevars => {\n-                let fv_info = dcx.read_to_vec(|dcx| {\n-                    Ok(dcx.read_freevar_entry())\n-                }).unwrap().into_iter().collect();\n+                let fv_info = Decodable::decode(dcx).unwrap();\n                 dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n             }\n             c::tag_table_upvar_capture_map => {\n-                let var_id = ast::NodeId::decode(dcx).unwrap();\n                 let upvar_id = ty::UpvarId {\n-                    var_id: dcx.tr_id(var_id),\n+                    var_id: Decodable::decode(dcx).unwrap(),\n                     closure_expr_id: id\n                 };\n-                let ub = dcx.read_upvar_capture();\n+                let ub = Decodable::decode(dcx).unwrap();\n                 dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n             }\n             c::tag_table_method_map => {\n-                let (autoderef, method) = dcx.read_method_callee();\n                 let method_call = ty::MethodCall {\n                     expr_id: id,\n-                    autoderef: autoderef\n+                    autoderef: Decodable::decode(dcx).unwrap()\n                 };\n+                let method = Decodable::decode(dcx).unwrap();\n                 dcx.tcx.tables.borrow_mut().method_map.insert(method_call, method);\n             }\n             c::tag_table_adjustments => {\n-                let adj = dcx.read_auto_adjustment();\n+                let adj = Decodable::decode(dcx).unwrap();\n                 dcx.tcx.tables.borrow_mut().adjustments.insert(id, adj);\n             }\n             c::tag_table_cast_kinds => {\n-                let cast_kind = cast::CastKind::decode(dcx).unwrap();\n+                let cast_kind = Decodable::decode(dcx).unwrap();\n                 dcx.tcx.cast_kinds.borrow_mut().insert(id, cast_kind);\n             }\n             c::tag_table_const_qualif => {\n-                let qualif = ConstQualif::decode(dcx).unwrap();\n+                let qualif = Decodable::decode(dcx).unwrap();\n                 dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);\n             }\n             _ => {\n-                bug!(\"unknown tag found in side tables: {:x}\", tag);\n+                bug!(\"unknown tag found in side tables: 0x{:x}\", tag);\n             }\n         }\n-\n-        debug!(\">< Side table doc loaded\");\n     }\n }\n-\n-fn inlined_item_id_range(ii: &InlinedItem) -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor::new();\n-    ii.visit(&mut visitor);\n-    visitor.result()\n-}"}, {"sha": "2774ffdf6c77255e2ee3a4f1a4e6a42b1f751258", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -16,7 +16,7 @@ use cstore::{self, CStore, CrateSource, MetadataBlob};\n use decoder;\n use loader::{self, CratePaths};\n \n-use rustc::hir::def_id::DefIndex;\n+use rustc::hir::def_id::{CrateNum, DefIndex};\n use rustc::hir::svh::Svh;\n use rustc::dep_graph::{DepGraph, DepNode};\n use rustc::session::{config, Session};\n@@ -52,7 +52,7 @@ struct LocalCrateReader<'a> {\n pub struct CrateReader<'a> {\n     sess: &'a Session,\n     cstore: &'a CStore,\n-    next_crate_num: ast::CrateNum,\n+    next_crate_num: CrateNum,\n     foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n     local_crate_name: String,\n     local_crate_config: ast::CrateConfig,\n@@ -152,7 +152,7 @@ impl PMDSource {\n }\n \n enum LoadResult {\n-    Previous(ast::CrateNum),\n+    Previous(CrateNum),\n     Loaded(loader::Library),\n }\n \n@@ -208,7 +208,7 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n-                      -> Option<ast::CrateNum> {\n+                      -> Option<CrateNum> {\n         let mut ret = None;\n         self.cstore.iter_crate_data(|cnum, data| {\n             if data.name != name { return }\n@@ -295,14 +295,14 @@ impl<'a> CrateReader<'a> {\n                       span: Span,\n                       lib: loader::Library,\n                       explicitly_linked: bool)\n-                      -> (ast::CrateNum, Rc<cstore::CrateMetadata>,\n+                      -> (CrateNum, Rc<cstore::CrateMetadata>,\n                           cstore::CrateSource) {\n         info!(\"register crate `extern crate {} as {}`\", name, ident);\n         self.verify_no_symbol_conflicts(span, &lib.metadata);\n \n         // Claim this crate number and cache it\n         let cnum = self.next_crate_num;\n-        self.next_crate_num += 1;\n+        self.next_crate_num = CrateNum::from_u32(cnum.as_u32() + 1);\n \n         // Stash paths for top-most crate locally if necessary.\n         let crate_paths = if root.is_none() {\n@@ -370,7 +370,7 @@ impl<'a> CrateReader<'a> {\n                      span: Span,\n                      kind: PathKind,\n                      explicitly_linked: bool)\n-                     -> (ast::CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n+                     -> (CrateNum, Rc<cstore::CrateMetadata>, cstore::CrateSource) {\n         info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n         let result = match self.existing_match(name, hash, kind) {\n             Some(cnum) => LoadResult::Previous(cnum),\n@@ -447,9 +447,9 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn update_extern_crate(&mut self,\n-                           cnum: ast::CrateNum,\n+                           cnum: CrateNum,\n                            mut extern_crate: ExternCrate,\n-                           visited: &mut FnvHashSet<(ast::CrateNum, bool)>)\n+                           visited: &mut FnvHashSet<(CrateNum, bool)>)\n     {\n         if !visited.insert((cnum, extern_crate.direct)) { return }\n \n@@ -482,7 +482,7 @@ impl<'a> CrateReader<'a> {\n     fn resolve_crate_deps(&mut self,\n                           root: &Option<CratePaths>,\n                           cdata: &[u8],\n-                          krate: ast::CrateNum,\n+                          krate: CrateNum,\n                           span: Span)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n@@ -500,11 +500,13 @@ impl<'a> CrateReader<'a> {\n             (dep.cnum, local_cnum)\n         }).collect();\n \n-        let max_cnum = map.values().cloned().max().unwrap_or(0);\n+        let max_cnum = map.values().cloned().max().map(|cnum| cnum.as_u32()).unwrap_or(0);\n \n         // we map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        (0..max_cnum+1).map(|cnum| map.get(&cnum).cloned().unwrap_or(krate)).collect()\n+        (0..max_cnum+1).map(|cnum| {\n+            map.get(&CrateNum::from_u32(cnum)).cloned().unwrap_or(krate)\n+        }).collect()\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n@@ -875,7 +877,7 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn inject_dependency_if(&self,\n-                            krate: ast::CrateNum,\n+                            krate: CrateNum,\n                             what: &str,\n                             needs_dep: &Fn(&cstore::CrateMetadata) -> bool) {\n         // don't perform this validation if the session has errors, as one of\n@@ -1113,7 +1115,7 @@ pub fn read_local_crates(sess: & Session,\n /// function. When an item from an external crate is later inlined into this\n /// crate, this correspondence information is used to translate the span\n /// information of the inlined item so that it refers the correct positions in\n-/// the local codemap (see `astencode::DecodeContext::tr_span()`).\n+/// the local codemap (see `<decoder::DecodeContext as SpecializedDecoder<Span>>`).\n ///\n /// The import algorithm in the function below will reuse FileMaps already\n /// existing in the local codemap. For example, even if the FileMap of some"}, {"sha": "a30a5743c34f2d122569605b1a9075b81401edf5", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -20,7 +20,7 @@ use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use rustc::hir::def;\n use middle::lang_items;\n use rustc::ty::{self, Ty, TyCtxt, VariantKind};\n-use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n@@ -303,14 +303,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_typedef(&cdata, did.index)\n     }\n \n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                -> Vec<(ast::CrateNum, LinkagePreference)>\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                -> Vec<(CrateNum, LinkagePreference)>\n     {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_dylib_dependency_formats(&cdata)\n     }\n \n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n     {\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(cnum);\n@@ -320,80 +320,80 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn missing_lang_items(&self, cnum: ast::CrateNum)\n+    fn missing_lang_items(&self, cnum: CrateNum)\n                           -> Vec<lang_items::LangItem>\n     {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_missing_lang_items(&cdata)\n     }\n \n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool\n     {\n         self.get_crate_data(cnum).staged_api\n     }\n \n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool\n     {\n         self.get_crate_data(cnum).explicitly_linked.get()\n     }\n \n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool\n+    fn is_allocator(&self, cnum: CrateNum) -> bool\n     {\n         self.get_crate_data(cnum).is_allocator()\n     }\n \n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool\n     {\n         self.get_crate_data(cnum).is_panic_runtime()\n     }\n \n-    fn is_compiler_builtins(&self, cnum: ast::CrateNum) -> bool {\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool {\n         self.get_crate_data(cnum).is_compiler_builtins()\n     }\n \n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy {\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n         self.get_crate_data(cnum).panic_strategy()\n     }\n \n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n+    fn crate_attrs(&self, cnum: CrateNum) -> Vec<ast::Attribute>\n     {\n         decoder::get_crate_attributes(self.get_crate_data(cnum).data())\n     }\n \n-    fn crate_name(&self, cnum: ast::CrateNum) -> token::InternedString\n+    fn crate_name(&self, cnum: CrateNum) -> token::InternedString\n     {\n         token::intern_and_get_ident(&self.get_crate_data(cnum).name[..])\n     }\n \n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> token::InternedString\n+    fn original_crate_name(&self, cnum: CrateNum) -> token::InternedString\n     {\n         token::intern_and_get_ident(&self.get_crate_data(cnum).name())\n     }\n \n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>\n     {\n         self.get_crate_data(cnum).extern_crate.get()\n     }\n \n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh\n     {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> token::InternedString\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> token::InternedString\n     {\n         let cdata = self.get_crate_data(cnum);\n         token::intern_and_get_ident(decoder::get_crate_disambiguator(cdata.data()))\n     }\n \n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n+    fn crate_struct_field_attrs(&self, cnum: CrateNum)\n                                 -> FnvHashMap<DefId, Vec<ast::Attribute>>\n     {\n         decoder::get_struct_field_attrs(&self.get_crate_data(cnum))\n     }\n \n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_plugin_registrar_fn(cdata.data()).map(|index| DefId {\n@@ -402,24 +402,24 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         })\n     }\n \n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n     {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_native_libraries(&cdata)\n     }\n \n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>\n     {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_reachable_ids(&cdata)\n     }\n \n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool {\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool {\n         attr::contains_name(&self.crate_attrs(cnum), \"no_builtins\")\n     }\n \n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex> {\n         let cdata = self.get_crate_data(cnum);\n@@ -488,7 +488,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>\n+    fn crate_top_level_items(&self, cnum: CrateNum) -> Vec<ChildItem>\n     {\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(cnum);\n@@ -651,7 +651,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_item_mir_available(&cdata, def.index)\n     }\n \n-    fn crates(&self) -> Vec<ast::CrateNum>\n+    fn crates(&self) -> Vec<CrateNum>\n     {\n         let mut result = vec![];\n         self.iter_crate_data(|cnum, _| result.push(cnum));\n@@ -686,17 +686,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         encoder::encoded_ty(tcx, ty, def_id_to_string)\n     }\n \n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n     {\n         self.do_get_used_crates(prefer)\n     }\n \n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource\n     {\n         self.opt_used_crate_source(cnum).unwrap()\n     }\n \n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n     {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n@@ -738,7 +738,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         use rustc::middle::cstore::ChildItem;\n         use std::collections::vec_deque::VecDeque;\n         use std::collections::hash_map::Entry;\n-        for cnum in 1 .. self.next_crate_num() {\n+        for cnum in (1 .. self.next_crate_num().as_usize()).map(CrateNum::new) {\n             let cdata = self.get_crate_data(cnum);\n \n             match cdata.extern_crate.get() {"}, {"sha": "388620a2dafd3549057e9f99ed79e7aa4f85c534", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -22,7 +22,7 @@ use index;\n use loader;\n \n use rustc::dep_graph::DepGraph;\n-use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::hir::def_id::{CrateNum, DefIndex, DefId};\n use rustc::hir::map::DefKey;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::ExternCrate;\n@@ -47,7 +47,7 @@ pub use middle::cstore::{CrateSource, LinkMeta};\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-pub type CrateNumMap = IndexVec<ast::CrateNum, ast::CrateNum>;\n+pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub enum MetadataBlob {\n     MetadataVec(Bytes),\n@@ -75,7 +75,7 @@ pub struct CrateMetadata {\n \n     pub data: MetadataBlob,\n     pub cnum_map: RefCell<CrateNumMap>,\n-    pub cnum: ast::CrateNum,\n+    pub cnum: CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n     pub staged_api: bool,\n \n@@ -105,9 +105,9 @@ pub struct CachedInlinedItem {\n \n pub struct CStore {\n     pub dep_graph: DepGraph,\n-    metas: RefCell<FnvHashMap<ast::CrateNum, Rc<CrateMetadata>>>,\n+    metas: RefCell<FnvHashMap<CrateNum, Rc<CrateMetadata>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n-    extern_mod_crate_map: RefCell<NodeMap<ast::CrateNum>>,\n+    extern_mod_crate_map: RefCell<NodeMap<CrateNum>>,\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n@@ -135,25 +135,25 @@ impl CStore {\n         }\n     }\n \n-    pub fn next_crate_num(&self) -> ast::CrateNum {\n-        self.metas.borrow().len() as ast::CrateNum + 1\n+    pub fn next_crate_num(&self) -> CrateNum {\n+        CrateNum::new(self.metas.borrow().len() + 1)\n     }\n \n-    pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<CrateMetadata> {\n+    pub fn get_crate_data(&self, cnum: CrateNum) -> Rc<CrateMetadata> {\n         self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n-    pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {\n+    pub fn get_crate_hash(&self, cnum: CrateNum) -> Svh {\n         let cdata = self.get_crate_data(cnum);\n         decoder::get_crate_hash(cdata.data())\n     }\n \n-    pub fn set_crate_data(&self, cnum: ast::CrateNum, data: Rc<CrateMetadata>) {\n+    pub fn set_crate_data(&self, cnum: CrateNum, data: Rc<CrateMetadata>) {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n     pub fn iter_crate_data<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &Rc<CrateMetadata>),\n+        I: FnMut(CrateNum, &Rc<CrateMetadata>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             i(k, v);\n@@ -162,7 +162,7 @@ impl CStore {\n \n     /// Like `iter_crate_data`, but passes source paths (if available) as well.\n     pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n-        I: FnMut(ast::CrateNum, &CrateMetadata, Option<CrateSource>),\n+        I: FnMut(CrateNum, &CrateMetadata, Option<CrateSource>),\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.opt_used_crate_source(k);\n@@ -178,7 +178,7 @@ impl CStore {\n         }\n     }\n \n-    pub fn opt_used_crate_source(&self, cnum: ast::CrateNum)\n+    pub fn opt_used_crate_source(&self, cnum: CrateNum)\n                                  -> Option<CrateSource> {\n         self.used_crate_sources.borrow_mut()\n             .iter().find(|source| source.cnum == cnum).cloned()\n@@ -193,7 +193,7 @@ impl CStore {\n         self.statically_included_foreign_items.borrow_mut().clear();\n     }\n \n-    pub fn crate_dependencies_in_rpo(&self, krate: ast::CrateNum) -> Vec<ast::CrateNum>\n+    pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum>\n     {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);\n@@ -202,8 +202,8 @@ impl CStore {\n     }\n \n     pub fn push_dependencies_in_postorder(&self,\n-                                          ordering: &mut Vec<ast::CrateNum>,\n-                                          krate: ast::CrateNum)\n+                                          ordering: &mut Vec<CrateNum>,\n+                                          krate: CrateNum)\n     {\n         if ordering.contains(&krate) { return }\n \n@@ -227,7 +227,7 @@ impl CStore {\n     // topological sort of all crates putting the leaves at the right-most\n     // positions.\n     pub fn do_get_used_crates(&self, prefer: LinkagePreference)\n-                              -> Vec<(ast::CrateNum, Option<PathBuf>)> {\n+                              -> Vec<(CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n@@ -272,7 +272,7 @@ impl CStore {\n \n     pub fn add_extern_mod_stmt_cnum(&self,\n                                     emod_id: ast::NodeId,\n-                                    cnum: ast::CrateNum) {\n+                                    cnum: CrateNum) {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n@@ -284,7 +284,7 @@ impl CStore {\n         self.statically_included_foreign_items.borrow().contains(&id)\n     }\n \n-    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>\n+    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n     {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }"}, {"sha": "72e95804ce8e3ee5aa6fa147d1680ec859e11f23", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 117, "deletions": 129, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -34,42 +34,38 @@ use rustc::session::config::PanicStrategy;\n use middle::cstore::{InlinedItem, LinkagePreference};\n use middle::cstore::{DefLike, DlDef, DlField, DlImpl};\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use middle::lang_items;\n use rustc::ty::{ImplContainer, TraitContainer};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, VariantKind};\n use rustc::ty::subst::Substs;\n \n use rustc_const_math::ConstInt;\n \n-use rustc::mir;\n-use rustc::mir::visit::MutVisitor;\n-use rustc::mir::repr::Location;\n+use rustc::mir::repr::Mir;\n \n-use std::cell::Cell;\n use std::io;\n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::str;\n \n use rbml::reader;\n use rbml;\n-use rustc_serialize::{Decodable, Decoder, SpecializedDecoder};\n+use rustc_serialize::{Decodable, SpecializedDecoder};\n use syntax::attr;\n use syntax::parse::token;\n-use syntax::ast;\n-use syntax::codemap;\n+use syntax::ast::{self, NodeId};\n use syntax::print::pprust;\n use syntax_pos::{self, Span, BytePos, NO_EXPANSION};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     pub rbml_r: rbml::reader::Decoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub cdata: &'a cstore::CrateMetadata,\n-    pub from_id_range: IdRange,\n-    pub to_id_range: IdRange,\n+    from_id_range: IdRange,\n+    to_id_range: IdRange,\n     // Cache the last used filemap for translating spans as an optimization.\n-    pub last_filemap_index: Cell<usize>,\n+    last_filemap_index: usize,\n }\n \n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n@@ -82,9 +78,9 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         let to_id_range = if from_id_range.empty() {\n             from_id_range\n         } else {\n-            let cnt = from_id_range.max - from_id_range.min;\n+            let cnt = from_id_range.max.as_usize() - from_id_range.min.as_usize();\n             let to_id_min = tcx.sess.reserve_node_ids(cnt);\n-            let to_id_max = to_id_min + cnt;\n+            let to_id_max = NodeId::new(to_id_min.as_usize() + cnt);\n             IdRange { min: to_id_min, max: to_id_max }\n         };\n \n@@ -94,7 +90,7 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n             tcx: tcx,\n             from_id_range: from_id_range,\n             to_id_range: to_id_range,\n-            last_filemap_index: Cell::new(0)\n+            last_filemap_index: 0\n         }\n     }\n \n@@ -104,7 +100,7 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(op(&mut TyDecoder::with_doc(\n                 this.tcx, this.cdata.cnum, doc,\n-                &mut |d| this.tr_def_id(d))))\n+                &mut |d| translate_def_id(&this.cdata, d))))\n         }).unwrap()\n     }\n }\n@@ -122,6 +118,93 @@ impl<'a, 'tcx> DerefMut for DecodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<NodeId> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n+        let id = u32::decode(self)?;\n+\n+        // from_id_range should be non-empty\n+        assert!(!self.from_id_range.empty());\n+        // Make sure that translating the NodeId will actually yield a\n+        // meaningful result\n+        if !self.from_id_range.contains(NodeId::from_u32(id)) {\n+            bug!(\"NodeId::decode: {} out of DecodeContext range ({:?} -> {:?})\",\n+                 id, self.from_id_range, self.to_id_range);\n+        }\n+\n+        // Use wrapping arithmetic because otherwise it introduces control flow.\n+        // Maybe we should just have the control flow? -- aatch\n+        Ok(NodeId::from_u32(id.wrapping_sub(self.from_id_range.min.as_u32())\n+                              .wrapping_add(self.to_id_range.min.as_u32())))\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<CrateNum> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n+        let cnum = CrateNum::from_u32(u32::decode(self)?);\n+        if cnum == LOCAL_CRATE {\n+            Ok(self.cdata.cnum)\n+        } else {\n+            Ok(self.cdata.cnum_map.borrow()[cnum])\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n+        let lo = BytePos::decode(self)?;\n+        let hi = BytePos::decode(self)?;\n+\n+        let (lo, hi) = if lo > hi {\n+            // Currently macro expansion sometimes produces invalid Span values\n+            // where lo > hi. In order not to crash the compiler when trying to\n+            // translate these values, let's transform them into something we\n+            // can handle (and which will produce useful debug locations at\n+            // least some of the time).\n+            // This workaround is only necessary as long as macro expansion is\n+            // not fixed. FIXME(#23480)\n+            (lo, lo)\n+        } else {\n+            (lo, hi)\n+        };\n+\n+        let imported_filemaps = self.cdata.imported_filemaps(&self.tcx.sess.codemap());\n+        let filemap = {\n+            // Optimize for the case that most spans within a translated item\n+            // originate from the same filemap.\n+            let last_filemap = &imported_filemaps[self.last_filemap_index];\n+\n+            if lo >= last_filemap.original_start_pos &&\n+            lo <= last_filemap.original_end_pos &&\n+            hi >= last_filemap.original_start_pos &&\n+            hi <= last_filemap.original_end_pos {\n+                last_filemap\n+            } else {\n+                let mut a = 0;\n+                let mut b = imported_filemaps.len();\n+\n+                while b - a > 1 {\n+                    let m = (a + b) / 2;\n+                    if imported_filemaps[m].original_start_pos > lo {\n+                        b = m;\n+                    } else {\n+                        a = m;\n+                    }\n+                }\n+\n+                self.last_filemap_index = a;\n+                &imported_filemaps[a]\n+            }\n+        };\n+\n+        let lo = (lo - filemap.original_start_pos) +\n+                  filemap.translated_filemap.start_pos;\n+        let hi = (hi - filemap.original_start_pos) +\n+                  filemap.translated_filemap.start_pos;\n+\n+        Ok(syntax_pos::mk_sp(lo, hi))\n+    }\n+}\n+\n // FIXME(#36588) These impls are horribly unsound as they allow\n // the caller to pick any lifetime for 'tcx, including 'static,\n // by using the unspecialized proxies to them.\n@@ -148,16 +231,15 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Region> for DecodeContext<'a, 'tcx>\n impl<'a, 'tcx> SpecializedDecoder<ty::ClosureSubsts<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ty::ClosureSubsts<'tcx>, Self::Error> {\n         Ok(ty::ClosureSubsts {\n-            func_substs: Decodable::decode(this)?,\n-            upvar_tys: this.tcx.mk_type_list(Decodable::decode(this)?)\n+            func_substs: Decodable::decode(self)?,\n+            upvar_tys: self.tcx.mk_type_list(Decodable::decode(self)?)\n         })\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<ty::AdtDef<'tcx>, Self::Error> {\n         let def_id = DefId::decode(self)?;\n-        let def_id = translate_def_id(self.cdata, def_id);\n         Ok(self.tcx.lookup_adt_def(def_id))\n     }\n }\n@@ -318,8 +400,10 @@ fn item_sort(item: rbml::Doc) -> Option<char> {\n \n fn untranslated_def_id(d: rbml::Doc) -> DefId {\n     let id = reader::doc_as_u64(d);\n-    let index = DefIndex::new((id & 0xFFFF_FFFF) as usize);\n-    DefId { krate: (id >> 32) as u32, index: index }\n+    DefId {\n+        krate: CrateNum::from_u32((id >> 32) as u32),\n+        index: DefIndex::from_u32((id & 0xFFFF_FFFF) as u32)\n+    }\n }\n \n fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> DefId {\n@@ -744,7 +828,7 @@ fn each_child_of_item_or_crate<F, G>(cdata: Cmd,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n     F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n+    G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n {\n     // Iterate over all children.\n     for child_info_doc in reader::tagged_docs(item_doc, tag_mod_child) {\n@@ -806,7 +890,7 @@ fn each_child_of_item_or_crate<F, G>(cdata: Cmd,\n /// Iterates over each child of the given item.\n pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex, get_crate_data: G, callback: F)\n     where F: FnMut(DefLike, ast::Name, ty::Visibility),\n-          G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n+          G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n {\n     // Find the item.\n     let item_doc = match cdata.get_item(id) {\n@@ -820,7 +904,7 @@ pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex, get_crate_data: G, cal\n /// Iterates over all the top-level crate items.\n pub fn each_top_level_item_of_crate<F, G>(cdata: Cmd, get_crate_data: G, callback: F)\n     where F: FnMut(DefLike, ast::Name, ty::Visibility),\n-          G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n+          G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n {\n     each_child_of_item(cdata, CRATE_DEF_INDEX, get_crate_data, callback)\n }\n@@ -894,52 +978,14 @@ pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     id: DefIndex)\n-                                    -> Option<mir::repr::Mir<'tcx>> {\n+                                    -> Option<Mir<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n-    return reader::maybe_get_doc(item_doc, tag_mir as usize).map(|mir_doc| {\n-        let mut dcx = DecodeContext::new(tcx, cdata,\n-                                         IdRange { min: 0, max: 0 },\n-                                         mir_doc);\n-\n-        let mut mir = Decodable::decode(&mut dcx).unwrap();\n-\n-        assert!(dcx.rbml_r.position() == mir_doc.end);\n-\n-        let mut def_id_and_span_translator = MirDefIdAndSpanTranslator {\n-            crate_metadata: cdata,\n-            codemap: tcx.sess.codemap(),\n-            last_filemap_index_hint: Cell::new(0),\n-        };\n-\n-        def_id_and_span_translator.visit_mir(&mut mir);\n-        for promoted in &mut mir.promoted {\n-            def_id_and_span_translator.visit_mir(promoted);\n-        }\n-\n-        mir\n-    });\n-\n-    struct MirDefIdAndSpanTranslator<'cdata, 'codemap> {\n-        crate_metadata: Cmd<'cdata>,\n-        codemap: &'codemap codemap::CodeMap,\n-        last_filemap_index_hint: Cell<usize>\n-    }\n-\n-    impl<'v, 'cdata, 'codemap> mir::visit::MutVisitor<'v>\n-        for MirDefIdAndSpanTranslator<'cdata, 'codemap>\n-    {\n-        fn visit_def_id(&mut self, def_id: &mut DefId, _: Location) {\n-            *def_id = translate_def_id(self.crate_metadata, *def_id);\n-        }\n-\n-        fn visit_span(&mut self, span: &mut Span) {\n-            *span = translate_span(self.crate_metadata,\n-                                   self.codemap,\n-                                   &self.last_filemap_index_hint,\n-                                   *span);\n-        }\n-    }\n+    reader::maybe_get_doc(item_doc, tag_mir).map(|mir_doc| {\n+        let id_range = IdRange { min: NodeId::new(0), max: NodeId::new(0) };\n+        let mut dcx = DecodeContext::new(tcx, cdata, id_range, mir_doc);\n+        Decodable::decode(&mut dcx).unwrap()\n+    })\n }\n \n fn get_explicit_self<'a, 'tcx>(item: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n@@ -1225,7 +1271,7 @@ pub fn get_crate_attributes(data: &[u8]) -> Vec<ast::Attribute> {\n \n #[derive(Clone)]\n pub struct CrateDep {\n-    pub cnum: ast::CrateNum,\n+    pub cnum: CrateNum,\n     pub name: String,\n     pub hash: Svh,\n     pub explicitly_linked: bool,\n@@ -1246,7 +1292,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n         let doc = reader::get_doc(depdoc, tag_crate_dep_explicitly_linked);\n         let explicitly_linked = reader::doc_as_u8(doc) != 0;\n         CrateDep {\n-            cnum: crate_num as u32 + 1,\n+            cnum: CrateNum::new(crate_num + 1),\n             name: name,\n             hash: hash,\n             explicitly_linked: explicitly_linked,\n@@ -1335,64 +1381,6 @@ fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n     None\n }\n \n-/// Translates a `Span` from an extern crate to the corresponding `Span`\n-/// within the local crate's codemap.\n-pub fn translate_span(cdata: Cmd,\n-                      codemap: &codemap::CodeMap,\n-                      last_filemap_index_hint: &Cell<usize>,\n-                      span: syntax_pos::Span)\n-                      -> syntax_pos::Span {\n-    let span = if span.lo > span.hi {\n-        // Currently macro expansion sometimes produces invalid Span values\n-        // where lo > hi. In order not to crash the compiler when trying to\n-        // translate these values, let's transform them into something we\n-        // can handle (and which will produce useful debug locations at\n-        // least some of the time).\n-        // This workaround is only necessary as long as macro expansion is\n-        // not fixed. FIXME(#23480)\n-        syntax_pos::mk_sp(span.lo, span.lo)\n-    } else {\n-        span\n-    };\n-\n-    let imported_filemaps = cdata.imported_filemaps(&codemap);\n-    let filemap = {\n-        // Optimize for the case that most spans within a translated item\n-        // originate from the same filemap.\n-        let last_filemap_index = last_filemap_index_hint.get();\n-        let last_filemap = &imported_filemaps[last_filemap_index];\n-\n-        if span.lo >= last_filemap.original_start_pos &&\n-           span.lo <= last_filemap.original_end_pos &&\n-           span.hi >= last_filemap.original_start_pos &&\n-           span.hi <= last_filemap.original_end_pos {\n-            last_filemap\n-        } else {\n-            let mut a = 0;\n-            let mut b = imported_filemaps.len();\n-\n-            while b - a > 1 {\n-                let m = (a + b) / 2;\n-                if imported_filemaps[m].original_start_pos > span.lo {\n-                    b = m;\n-                } else {\n-                    a = m;\n-                }\n-            }\n-\n-            last_filemap_index_hint.set(a);\n-            &imported_filemaps[a]\n-        }\n-    };\n-\n-    let lo = (span.lo - filemap.original_start_pos) +\n-              filemap.translated_filemap.start_pos;\n-    let hi = (span.hi - filemap.original_start_pos) +\n-              filemap.translated_filemap.start_pos;\n-\n-    syntax_pos::mk_sp(lo, hi)\n-}\n-\n pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n                                                 id: DefIndex,\n                                                 mut callback: F)\n@@ -1491,7 +1479,7 @@ pub fn get_macro_span(doc: rbml::Doc) -> Span {\n }\n \n pub fn get_dylib_dependency_formats(cdata: Cmd)\n-    -> Vec<(ast::CrateNum, LinkagePreference)>\n+    -> Vec<(CrateNum, LinkagePreference)>\n {\n     let formats = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                   tag_dylib_dependency_formats);\n@@ -1503,7 +1491,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         let mut split = spec.split(':');\n         let cnum = split.next().unwrap();\n         let link = split.next().unwrap();\n-        let cnum: ast::CrateNum = cnum.parse().unwrap();\n+        let cnum = CrateNum::new(cnum.parse().unwrap());\n         let cnum = cdata.cnum_map.borrow()[cnum];\n         result.push((cnum, if link == \"d\" {\n             LinkagePreference::RequireDynamic"}, {"sha": "e493daab09103dd05929ce5226391c57c8bee614", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -23,7 +23,7 @@ use index::{self, IndexData};\n \n use middle::cstore::{InlinedItemRef, LinkMeta};\n use rustc::hir::def;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n use rustc::dep_graph::DepNode;\n use rustc::traits::specialization_graph;\n@@ -42,7 +42,7 @@ use std::io::{Cursor, SeekFrom};\n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::u32;\n-use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n+use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID};\n use syntax::attr;\n use syntax;\n use syntax_pos::BytePos;\n@@ -136,8 +136,7 @@ fn encode_family(ecx: &mut EncodeContext, c: char) {\n }\n \n pub fn def_to_u64(did: DefId) -> u64 {\n-    assert!(did.index.as_u32() < u32::MAX);\n-    (did.krate as u64) << 32 | (did.index.as_usize() as u64)\n+    (did.krate.as_u32() as u64) << 32 | (did.index.as_u32() as u64)\n }\n \n pub fn def_to_string(_tcx: TyCtxt, did: DefId) -> String {\n@@ -1457,7 +1456,7 @@ fn encode_crate_deps(ecx: &mut EncodeContext, cstore: &cstore::CStore) {\n         // Sanity-check the crate numbers\n         let mut expected_cnum = 1;\n         for &(n, _) in &deps {\n-            assert_eq!(n, expected_cnum);\n+            assert_eq!(n, CrateNum::new(expected_cnum));\n             expected_cnum += 1;\n         }\n "}, {"sha": "6d3b8571d3c3b9650d458aec63e9a59ea81becd4", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -18,7 +18,7 @@\n \n use rustc::hir;\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex};\n use middle::region;\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -38,23 +38,23 @@ pub type DefIdConvert<'a> = &'a mut FnMut(DefId) -> DefId;\n \n pub struct TyDecoder<'a, 'tcx: 'a> {\n     data: &'a [u8],\n-    krate: ast::CrateNum,\n+    krate: CrateNum,\n     pos: usize,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     conv_def_id: DefIdConvert<'a>,\n }\n \n impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     pub fn with_doc(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    crate_num: ast::CrateNum,\n+                    crate_num: CrateNum,\n                     doc: rbml::Doc<'a>,\n                     conv: DefIdConvert<'a>)\n                     -> TyDecoder<'a,'tcx> {\n         TyDecoder::new(doc.data, crate_num, doc.start, tcx, conv)\n     }\n \n     pub fn new(data: &'a [u8],\n-               crate_num: ast::CrateNum,\n+               crate_num: CrateNum,\n                pos: usize,\n                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                conv: DefIdConvert<'a>)\n@@ -258,9 +258,9 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             // May still be worth fixing though.\n             'C' => {\n                 assert_eq!(self.next(), '[');\n-                let fn_id = self.parse_uint() as ast::NodeId;\n+                let fn_id = ast::NodeId::new(self.parse_uint());\n                 assert_eq!(self.next(), '|');\n-                let body_id = self.parse_uint() as ast::NodeId;\n+                let body_id = ast::NodeId::new(self.parse_uint());\n                 assert_eq!(self.next(), ']');\n                 region::CodeExtentData::CallSiteScope {\n                     fn_id: fn_id, body_id: body_id\n@@ -269,25 +269,25 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             // This creates scopes with the wrong NodeId. (See note above.)\n             'P' => {\n                 assert_eq!(self.next(), '[');\n-                let fn_id = self.parse_uint() as ast::NodeId;\n+                let fn_id = ast::NodeId::new(self.parse_uint());\n                 assert_eq!(self.next(), '|');\n-                let body_id = self.parse_uint() as ast::NodeId;\n+                let body_id = ast::NodeId::new(self.parse_uint());\n                 assert_eq!(self.next(), ']');\n                 region::CodeExtentData::ParameterScope {\n                     fn_id: fn_id, body_id: body_id\n                 }\n             }\n             'M' => {\n-                let node_id = self.parse_uint() as ast::NodeId;\n+                let node_id = ast::NodeId::new(self.parse_uint());\n                 region::CodeExtentData::Misc(node_id)\n             }\n             'D' => {\n-                let node_id = self.parse_uint() as ast::NodeId;\n+                let node_id = ast::NodeId::new(self.parse_uint());\n                 region::CodeExtentData::DestructionScope(node_id)\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n-                let node_id = self.parse_uint() as ast::NodeId;\n+                let node_id = ast::NodeId::new(self.parse_uint());\n                 assert_eq!(self.next(), '|');\n                 let first_stmt_index = self.parse_u32();\n                 assert_eq!(self.next(), ']');\n@@ -726,7 +726,7 @@ fn parse_defid(buf: &[u8]) -> DefId {\n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n         s.parse::<usize>().ok()\n     }) {\n-        Some(cn) => cn as ast::CrateNum,\n+        Some(cn) => CrateNum::new(cn),\n         None => bug!(\"internal error: parse_defid: crate number expected, found {:?}\",\n                        crate_part)\n     };"}, {"sha": "e75a9543196693bed90c73e01ae513c329b6df58", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -20,6 +20,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{self, Visitor};\n use std::fmt;\n+use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -673,7 +674,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         where T: fmt::Debug + TypeFoldable<'tcx>\n     {\n         let mut selcx = traits::SelectionContext::new(self.infcx);\n-        let cause = traits::ObligationCause::misc(self.last_span, 0);\n+        let cause = traits::ObligationCause::misc(self.last_span, ast::CRATE_NODE_ID);\n         let traits::Normalized { value, obligations } =\n             traits::normalize(&mut selcx, cause, value);\n "}, {"sha": "659edb86be166d2924a9f47f162033d88ad6b404", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -49,14 +49,14 @@ use rustc::middle::cstore::MacroLoader;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n-use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n+use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n "}, {"sha": "e452a44cea5878b7fafaacd258dcbb04efcbf35a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -135,7 +135,7 @@ struct ExpansionVisitor<'b, 'a: 'b> {\n \n impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) {\n-        assert_eq!(id, self.resolver.expansion_data.len() as u32);\n+        assert_eq!(id.as_u32(), self.resolver.expansion_data.len() as u32);\n         self.resolver.expansion_data.push(ExpansionData {\n             module: self.current_module.clone(),\n         });"}, {"sha": "fc235aaf9276b7450fa4cfec91e900776573fb80", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -14,8 +14,8 @@\n //! retrieve the data from a crate.\n \n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-use syntax::ast::{self, CrateNum, NodeId};\n+use rustc::hir::def_id::{CrateNum, DefId};\n+use syntax::ast::{self, NodeId};\n use syntax_pos::Span;\n \n pub struct CrateData {"}, {"sha": "37b31eda5a35ae0e9c7c24db7a60487aa05e1b42", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -29,15 +29,15 @@\n \n use rustc::hir;\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::map::{Node, NodeItem};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt, ImplOrTraitItem, ImplOrTraitItemContainer};\n \n use std::collections::HashSet;\n use std::hash::*;\n \n-use syntax::ast::{self, NodeId, PatKind, Attribute};\n+use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string, bounds_to_string, generics_to_string};\n@@ -95,7 +95,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             analysis: analysis,\n             dumper: dumper,\n             span: span_utils.clone(),\n-            cur_scope: 0,\n+            cur_scope: CRATE_NODE_ID,\n             mac_defs: HashSet::new(),\n             mac_uses: HashSet::new(),\n         }\n@@ -124,7 +124,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             let lo_loc = self.span.sess.codemap().lookup_char_pos(c.span.lo);\n             ExternalCrateData {\n                 name: c.name,\n-                num: c.number,\n+                num: CrateNum::from_u32(c.number),\n                 file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n             }\n         }).collect();\n@@ -252,7 +252,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             ref_id: None,\n             span: *span,\n             qualname: qualname.to_owned(),\n-            scope: 0\n+            scope: CRATE_NODE_ID\n         }.lower(self.tcx));\n \n         // write the other sub-paths\n@@ -368,7 +368,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         qualname: format!(\"{}::{}\", qualname, path_to_string(p)),\n                         type_value: typ,\n                         value: String::new(),\n-                        scope: 0,\n+                        scope: CRATE_NODE_ID,\n                         parent: None,\n                         visibility: Visibility::Inherited,\n                         docs: String::new(),\n@@ -1044,7 +1044,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     qualname: format!(\"{}${}\", path_to_string(p), id),\n                     value: value,\n                     type_value: typ,\n-                    scope: 0,\n+                    scope: CRATE_NODE_ID,\n                     parent: None,\n                     visibility: Visibility::Inherited,\n                     docs: String::new(),\n@@ -1239,7 +1239,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 let alias_span = self.span.span_for_last_ident(item.span);\n                 let cnum = match self.sess.cstore.extern_mod_stmt_cnum(item.id) {\n                     Some(cnum) => cnum,\n-                    None => 0,\n+                    None => LOCAL_CRATE,\n                 };\n \n                 if !self.span.filter_generated(alias_span, item.span) {\n@@ -1478,7 +1478,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                             qualname: format!(\"{}${}\", path_to_string(p), id),\n                             value: value,\n                             type_value: typ,\n-                            scope: 0,\n+                            scope: CRATE_NODE_ID,\n                             parent: None,\n                             visibility: Visibility::Inherited,\n                             docs: String::new(),"}, {"sha": "5847575742342680efc3ed8742c77c1f44c8f436", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc::hir::def_id::{CrateNum, DefId, DefIndex};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n-use syntax::ast::{CrateNum, NodeId};\n+use syntax::ast::NodeId;\n use syntax::codemap::CodeMap;\n use syntax_pos::Span;\n \n@@ -28,7 +28,10 @@ pub fn make_def_id(id: NodeId, map: &Map) -> DefId {\n }\n \n pub fn null_def_id() -> DefId {\n-    DefId { krate: u32::max_value(), index: DefIndex::from_u32(u32::max_value()) }\n+    DefId {\n+        krate: CrateNum::from_u32(u32::max_value()),\n+        index: DefIndex::from_u32(u32::max_value())\n+    }\n }\n \n #[derive(Clone, Debug, RustcEncodable)]"}, {"sha": "d56aae18a7cd1f65e49a64d55bacc1acbf47082b", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -117,7 +117,7 @@ struct Id {\n impl From<DefId> for Id {\n     fn from(id: DefId) -> Id {\n         Id {\n-            krate: id.krate,\n+            krate: id.krate.as_u32(),\n             index: id.index.as_u32(),\n         }\n     }"}, {"sha": "0378d75cc6eb1d4d57e5ce3302748095f902ae8c", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -120,7 +120,7 @@ struct Id {\n impl From<DefId> for Id {\n     fn from(id: DefId) -> Id {\n         Id {\n-            krate: id.krate,\n+            krate: id.krate.as_u32(),\n             index: id.index.as_u32(),\n         }\n     }"}, {"sha": "3764e26b020db414e28caeb5b2a52a5d9c014e98", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -52,7 +52,7 @@ use std::env;\n use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n \n-use syntax::ast::{self, NodeId, PatKind, Attribute};\n+use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token::{self, keywords, InternedString};\n use syntax::visit::{self, Visitor};\n@@ -120,7 +120,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             };\n             result.push(CrateData {\n                 name: (&self.tcx.sess.cstore.crate_name(n)[..]).to_owned(),\n-                number: n,\n+                number: n.as_u32(),\n                 span: span,\n             });\n         }\n@@ -676,7 +676,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     #[inline]\n     pub fn enclosing_scope(&self, id: NodeId) -> NodeId {\n-        self.tcx.map.get_enclosing_scope(id).unwrap_or(0)\n+        self.tcx.map.get_enclosing_scope(id).unwrap_or(CRATE_NODE_ID)\n     }\n }\n "}, {"sha": "2b92d7e9e457cf9d1bcd0b374ce79b402ff642c4", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -556,9 +556,9 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n \n     let attempts;\n     match hint {\n-        attr::ReprInt(span, ity) => {\n+        attr::ReprInt(ity) => {\n             if !bounds_usable(cx, ity, bounds) {\n-                span_bug!(span, \"representation hint insufficient for discriminant range\")\n+                bug!(\"representation hint insufficient for discriminant range\")\n             }\n             return ity;\n         }"}, {"sha": "201e1e5f2ec4cf05619bbcd239d317fe69a33586", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -26,6 +26,7 @@ use CrateTranslation;\n use util::common::time;\n use util::fs::fix_windows_verbatim_for_gcc;\n use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n use rustc_incremental::IncrementalHashesMap;\n@@ -288,7 +289,7 @@ pub fn filename_for_input(sess: &Session,\n }\n \n pub fn each_linked_rlib(sess: &Session,\n-                        f: &mut FnMut(ast::CrateNum, &Path)) {\n+                        f: &mut FnMut(CrateNum, &Path)) {\n     let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable)\n@@ -299,7 +300,7 @@ pub fn each_linked_rlib(sess: &Session,\n         bug!(\"could not find formats for rlibs\")\n     });\n     for (cnum, path) in crates {\n-        match fmts[cnum as usize - 1] {\n+        match fmts[cnum.as_usize() - 1] {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => continue,\n             _ => {}\n         }\n@@ -933,7 +934,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n         let src = sess.cstore.used_crate_source(cnum);\n-        match data[cnum as usize - 1] {\n+        match data[cnum.as_usize() - 1] {\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n             _ if sess.cstore.is_compiler_builtins(cnum) => {\n@@ -1003,7 +1004,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                         sess: &Session,\n                         tmpdir: &Path,\n                         crate_type: config::CrateType,\n-                        cnum: ast::CrateNum) {\n+                        cnum: CrateNum) {\n         let src = sess.cstore.used_crate_source(cnum);\n         let cratepath = &src.rlib.unwrap().0;\n         if !sess.lto() && crate_type != config::CrateTypeDylib {"}, {"sha": "dd14f98c9207fc6e97b0c24f0d7ea5b8be2ea591", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -21,10 +21,10 @@ use monomorphize::Instance;\n \n use back::archive;\n use middle::dependency_format::Linkage;\n+use rustc::hir::def_id::CrateNum;\n use session::Session;\n use session::config::CrateType;\n use session::config;\n-use syntax::ast;\n \n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n@@ -473,7 +473,7 @@ fn exported_symbols(scx: &SharedCrateContext,\n     let deps = formats[&crate_type].iter();\n     symbols.extend(deps.enumerate().filter_map(|(i, f)| {\n         if *f == Linkage::Static {\n-            Some((i + 1) as ast::CrateNum)\n+            Some(CrateNum::new(i + 1))\n         } else {\n             None\n         }"}, {"sha": "4ed860bd40d86b3f835b98aa94c7efeeca42f13f", "filename": "src/librustc_trans/back/rpath.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -12,10 +12,11 @@ use std::collections::HashSet;\n use std::env;\n use std::path::{Path, PathBuf};\n use std::fs;\n-use syntax::ast;\n+\n+use rustc::hir::def_id::CrateNum;\n \n pub struct RPathConfig<'a> {\n-    pub used_crates: Vec<(ast::CrateNum, Option<PathBuf>)>,\n+    pub used_crates: Vec<(CrateNum, Option<PathBuf>)>,\n     pub out_filename: PathBuf,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,", "previous_filename": "src/librustc_back/rpath.rs"}, {"sha": "ab1474c235132ac13e6a203cf9b962c78b521291", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -101,8 +101,8 @@ use common::{CrateContext, SharedCrateContext, gensym_name};\n use monomorphize::Instance;\n use util::sha2::{Digest, Sha256};\n \n-use rustc::middle::{cstore, weak_lang_items};\n-use rustc::hir::def_id::DefId;\n+use rustc::middle::weak_lang_items;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map as hir_map;\n use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n@@ -298,7 +298,7 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                                     -> String {\n     let empty_def_path = DefPath {\n         data: vec![],\n-        krate: cstore::LOCAL_CRATE,\n+        krate: LOCAL_CRATE,\n     };\n     let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n     let path = [token::intern_and_get_ident(prefix)];\n@@ -315,7 +315,7 @@ pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>\n                 gensym_name(suffix).as_str()];\n     let def_path = DefPath {\n         data: vec![],\n-        krate: cstore::LOCAL_CRATE,\n+        krate: LOCAL_CRATE,\n     };\n     let hash = get_symbol_hash(ccx.shared(), &def_path, t, None);\n     mangle(path.iter().cloned(), Some(&hash[..]))"}, {"sha": "41c8d565d418c93a75e1639378bf76a08b84dc52", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -69,7 +69,6 @@ pub use base::trans_crate;\n pub use disr::Disr;\n \n pub mod back {\n-    pub use rustc_back::rpath;\n     pub use rustc::hir::svh;\n \n     pub mod archive;\n@@ -79,6 +78,7 @@ pub mod back {\n     pub mod symbol_names;\n     pub mod write;\n     pub mod msvc;\n+    pub mod rpath;\n }\n \n pub mod diagnostics;"}, {"sha": "141b8506c39b8d3e50a376094e1d5f10238cfc46", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -356,7 +356,7 @@ fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         format!(\"{}<{}>\", base, strings.join(\", \"))\n     };\n \n-    if did.krate == 0 {\n+    if did.is_local() {\n         tstr\n     } else {\n         format!(\"{}.{}\", did.krate, tstr)"}, {"sha": "d1fb0736d21154e465e0948ed94be55a6d84f19b", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -12,9 +12,8 @@ use super::{DeferredCallResolution, Expectation, FnCtxt,\n             TupleArgumentsFlag};\n \n use CrateCtxt;\n-use middle::cstore::LOCAL_CRATE;\n use hir::def::Def;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, LvaluePreference, Ty};\n use syntax::parse::token;"}, {"sha": "4a631493398e98fd318af22b4b4d36e98c64a677", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -577,7 +577,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 assoc::normalize_associated_types_in(&infcx,\n                                                      &mut fulfillment_cx,\n                                                      impl_c_span,\n-                                                     0,\n+                                                     ast::CRATE_NODE_ID,\n                                                      &impl_ty);\n \n             debug!(\"compare_const_impl: impl_ty={:?}\",\n@@ -587,7 +587,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 assoc::normalize_associated_types_in(&infcx,\n                                                      &mut fulfillment_cx,\n                                                      impl_c_span,\n-                                                     0,\n+                                                     ast::CRATE_NODE_ID,\n                                                      &trait_ty);\n \n             debug!(\"compare_const_impl: trait_ty={:?}\","}, {"sha": "01d7b1e54751c282ff766148fa0df5e487a9e71b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -83,9 +83,8 @@ use self::TupleArgumentsFlag::*;\n use astconv::{AstConv, ast_region_to_region, PathParamMode};\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n-use middle::cstore::LOCAL_CRATE;\n use hir::def::{Def, PathResolution};\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n use rustc::ty::subst::{Subst, Substs};\n@@ -1450,7 +1449,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             writeback_errors: Cell::new(false),\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_ty: rty,\n-            ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal, 0)),\n+            ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n+                                                     ast::CRATE_NODE_ID)),\n             inh: inh,\n         }\n     }\n@@ -2117,7 +2117,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             .unwrap_or(type_variable::Default {\n                                 ty: self.next_ty_var(),\n                                 origin_span: syntax_pos::DUMMY_SP,\n-                                def_id: self.tcx.map.local_def_id(0) // what do I put here?\n+                                // what do I put here?\n+                                def_id: self.tcx.map.local_def_id(ast::CRATE_NODE_ID)\n                             });\n \n                     // This is to ensure that we elimnate any non-determinism from the error"}, {"sha": "70342a0cd258e3658372df31df5f3ae0cb590b52", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -11,8 +11,7 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::traits;\n use rustc::ty::{self, TyCtxt};\n use syntax::ast;"}, {"sha": "7ee173019a51619120519377efa167237b630028", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -37,7 +37,7 @@ use rustc::middle::cstore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{self, DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::fold::Folder;\n use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n@@ -116,15 +116,15 @@ pub struct Crate {\n     pub name: String,\n     pub src: PathBuf,\n     pub module: Option<Item>,\n-    pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n+    pub externs: Vec<(def_id::CrateNum, ExternalCrate)>,\n     pub primitives: Vec<PrimitiveType>,\n     pub access_levels: Arc<AccessLevels<DefId>>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n     pub external_traits: FnvHashMap<DefId, Trait>,\n }\n \n-struct CrateNum(ast::CrateNum);\n+struct CrateNum(def_id::CrateNum);\n \n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n@@ -1159,7 +1159,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n                 values: sig.0.inputs.iter().map(|t| {\n                     Argument {\n                         type_: t.clean(cx),\n-                        id: 0,\n+                        id: ast::CRATE_NODE_ID,\n                         name: names.next().unwrap_or(\"\".to_string()),\n                     }\n                 }).collect(),\n@@ -1808,7 +1808,7 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                     type_params: Vec::new(),\n                     where_predicates: Vec::new()\n                 },\n-                decl: (cx.map.local_def_id(0), &fty.sig).clean(cx),\n+                decl: (cx.map.local_def_id(ast::CRATE_NODE_ID), &fty.sig).clean(cx),\n                 abi: fty.abi,\n             }),\n             ty::TyAdt(def, substs) => {\n@@ -2590,7 +2590,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n-            def_id: cx.map.local_def_id(0),\n+            def_id: cx.map.local_def_id(ast::CRATE_NODE_ID),\n             visibility: self.vis.clean(cx),\n             stability: None,\n             deprecation: None,"}, {"sha": "ab6858a09310fea57551e68a28c2be51ce70a317", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -13,7 +13,7 @@ use rustc_lint;\n use rustc_driver::{driver, target_features, abort_on_err};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir::map as hir_map;\n@@ -23,7 +23,7 @@ use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n \n-use syntax::{ast, codemap};\n+use syntax::codemap;\n use syntax::feature_gate::UnstableFeatures;\n use errors;\n use errors::emitter::ColorConfig;\n@@ -51,7 +51,7 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub map: &'a hir_map::Map<'tcx>,\n     pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n-    pub populated_crate_impls: RefCell<FnvHashSet<ast::CrateNum>>,\n+    pub populated_crate_impls: RefCell<FnvHashSet<CrateNum>>,\n     pub deref_trait_did: Cell<Option<DefId>>,\n     pub deref_mut_trait_did: Cell<Option<DefId>>,\n     // Note that external items for which `doc(hidden)` applies to are shown as"}, {"sha": "609ae0c0e6daf60f9cee7a8bc22d1cb0c4d4bc5c", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -21,6 +21,7 @@ use syntax::ptr::P;\n use syntax_pos::{self, Span};\n \n use rustc::hir;\n+use rustc::hir::def_id::CrateNum;\n \n pub struct Module {\n     pub name: Option<Name>,\n@@ -53,7 +54,7 @@ impl Module {\n     pub fn new(name: Option<Name>) -> Module {\n         Module {\n             name       : name,\n-            id: 0,\n+            id: ast::CRATE_NODE_ID,\n             vis: hir::Inherited,\n             stab: None,\n             depr: None,\n@@ -245,7 +246,7 @@ pub struct Macro {\n \n pub struct ExternCrate {\n     pub name: Name,\n-    pub cnum: ast::CrateNum,\n+    pub cnum: CrateNum,\n     pub path: Option<String>,\n     pub vis: hir::Visibility,\n     pub attrs: hir::HirVec<ast::Attribute>,"}, {"sha": "adcdc7aaab4005d252381e41dc8dbcca2d3fa158", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -18,8 +18,7 @@\n use std::fmt;\n use std::iter::repeat;\n \n-use rustc::middle::cstore::LOCAL_CRATE;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use syntax::abi::Abi;\n use rustc::hir;\n "}, {"sha": "03d772d1a6db3f0294cfc088e306d37d1cfb1b2a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -53,10 +53,9 @@ use std::sync::Arc;\n use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n-use syntax::{abi, ast};\n+use syntax::abi;\n use syntax::feature_gate::UnstableFeatures;\n-use rustc::middle::cstore::LOCAL_CRATE;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::session::config::get_unstable_features_setting;\n@@ -246,10 +245,10 @@ pub struct Cache {\n     pub implementors: FnvHashMap<DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FnvHashMap<ast::CrateNum, (String, ExternalLocation)>,\n+    pub extern_locations: FnvHashMap<CrateNum, (String, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FnvHashMap<clean::PrimitiveType, ast::CrateNum>,\n+    pub primitive_locations: FnvHashMap<clean::PrimitiveType, CrateNum>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing"}, {"sha": "a29566f7a0717abb390205bedd1290f48e810f9b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -20,6 +20,7 @@ use syntax_pos::Span;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::privacy::AccessLevel;\n use rustc::util::nodemap::FnvHashSet;\n \n@@ -339,7 +340,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let cstore = &self.cx.sess().cstore;\n                 om.extern_crates.push(ExternCrate {\n                     cnum: cstore.extern_mod_stmt_cnum(item.id)\n-                                .unwrap_or(ast::CrateNum::max_value()),\n+                                .unwrap_or(LOCAL_CRATE),\n                     name: name,\n                     path: p.map(|x|x.to_string()),\n                     vis: item.vis.clone(),"}, {"sha": "cbc556730fb63099ddeefd3bcfced820563a6c24", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -11,9 +11,8 @@\n use rustc::middle::cstore::{CrateStore, ChildItem, DefLike};\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty::Visibility;\n-use syntax::ast;\n \n use std::cell::RefMut;\n \n@@ -42,7 +41,7 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n         }\n     }\n \n-    pub fn visit_lib(&mut self, cnum: ast::CrateNum) {\n+    pub fn visit_lib(&mut self, cnum: CrateNum) {\n         let did = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n         self.update(did, Some(AccessLevel::Public));\n         self.visit_mod(did);"}, {"sha": "7082ee5d292dfabf1503a801740f4e369e2664de", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -45,8 +45,7 @@ Core encoding and decoding interfaces.\n extern crate rustc_unicode;\n extern crate collections;\n \n-pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n-                          DecoderHelpers, EncoderHelpers};\n+pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};\n \n pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};\n pub use self::serialize::{UseSpecializedEncodable, UseSpecializedDecodable};"}, {"sha": "ba6eefe82bbc6df6691f91e94e7ee9e18a483560", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -593,50 +593,6 @@ impl<T:Decodable+Send+Sync> Decodable for Arc<T> {\n     }\n }\n \n-// ___________________________________________________________________________\n-// Helper routines\n-\n-pub trait EncoderHelpers: Encoder {\n-    fn emit_from_vec<T, F>(&mut self, v: &[T], f: F)\n-                           -> Result<(), Self::Error>\n-        where F: FnMut(&mut Self, &T) -> Result<(), Self::Error>;\n-}\n-\n-impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T, F>(&mut self, v: &[T], mut f: F) -> Result<(), S::Error> where\n-        F: FnMut(&mut S, &T) -> Result<(), S::Error>,\n-    {\n-        self.emit_seq(v.len(), |this| {\n-            for (i, e) in v.iter().enumerate() {\n-                this.emit_seq_elt(i, |this| {\n-                    f(this, e)\n-                })?;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-pub trait DecoderHelpers: Decoder {\n-    fn read_to_vec<T, F>(&mut self, f: F)\n-                         -> Result<Vec<T>, Self::Error> where\n-        F: FnMut(&mut Self) -> Result<T, Self::Error>;\n-}\n-\n-impl<D: Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T, F>(&mut self, mut f: F) -> Result<Vec<T>, D::Error> where F:\n-        FnMut(&mut D) -> Result<T, D::Error>,\n-    {\n-        self.read_seq(|this, len| {\n-            let mut v = Vec::with_capacity(len);\n-            for i in 0..len {\n-                v.push(this.read_seq_elt(i, |this| f(this))?);\n-            }\n-            Ok(v)\n-        })\n-    }\n-}\n-\n // ___________________________________________________________________________\n // Specialization-based interface for multi-dispatch Encodable/Decodable.\n "}, {"sha": "70e614f9c9a91d7d71e0f5c2c99f9e96936dbac9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -27,7 +27,9 @@ use tokenstream::{TokenTree};\n \n use std::fmt;\n use std::rc::Rc;\n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n+use std::u32;\n+\n+use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n /// the result of interning.\n@@ -298,17 +300,43 @@ pub struct ParenthesizedParameterData {\n     pub output: Option<P<Ty>>,\n }\n \n-pub type CrateNum = u32;\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, RustcEncodable, Hash, Debug)]\n+pub struct NodeId(u32);\n+\n+impl NodeId {\n+    pub fn new(x: usize) -> NodeId {\n+        assert!(x < (u32::MAX as usize));\n+        NodeId(x as u32)\n+    }\n+\n+    pub fn from_u32(x: u32) -> NodeId {\n+        NodeId(x)\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+impl fmt::Display for NodeId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n \n-pub type NodeId = u32;\n+impl serialize::UseSpecializedDecodable for NodeId {}\n \n /// Node id used to represent the root of the crate.\n-pub const CRATE_NODE_ID: NodeId = 0;\n+pub const CRATE_NODE_ID: NodeId = NodeId(0);\n \n /// When parsing and doing expansions, we initially give all AST nodes this AST\n /// node value. Then later, in the renumber pass, we renumber them to have\n /// small, positive ids.\n-pub const DUMMY_NODE_ID: NodeId = !0;\n+pub const DUMMY_NODE_ID: NodeId = NodeId(!0);\n \n /// The AST represents all type param bounds as types.\n /// typeck::collect::compute_bounds matches these against"}, {"sha": "dc02c26039c15e9b46ce5f23f519aed47fb479ed", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -895,7 +895,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         \"packed\" => Some(ReprPacked),\n                         \"simd\" => Some(ReprSimd),\n                         _ => match int_type_of_word(word) {\n-                            Some(ity) => Some(ReprInt(item.span, ity)),\n+                            Some(ity) => Some(ReprInt(ity)),\n                             None => {\n                                 // Not a word we recognize\n                                 span_err!(diagnostic, item.span, E0552,\n@@ -939,7 +939,7 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n #[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n pub enum ReprAttr {\n     ReprAny,\n-    ReprInt(Span, IntType),\n+    ReprInt(IntType),\n     ReprExtern,\n     ReprPacked,\n     ReprSimd,\n@@ -949,7 +949,7 @@ impl ReprAttr {\n     pub fn is_ffi_safe(&self) -> bool {\n         match *self {\n             ReprAny => false,\n-            ReprInt(_sp, ity) => ity.is_ffi_safe(),\n+            ReprInt(ity) => ity.is_ffi_safe(),\n             ReprExtern => true,\n             ReprPacked => false,\n             ReprSimd => true,"}, {"sha": "db0183a8b3a2778402cc771303a5f36de8eef9b3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -242,11 +242,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n                 let expansion = expansion.fold_with(&mut placeholder_expander);\n-                placeholder_expander.add(mark, expansion);\n+                placeholder_expander.add(ast::NodeId::from_u32(mark), expansion);\n             }\n         }\n \n-        placeholder_expander.remove(0)\n+        placeholder_expander.remove(ast::NodeId::from_u32(0))\n     }\n \n     fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n@@ -424,7 +424,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             expansion_kind: expansion_kind,\n             expansion_data: ExpansionData { mark: mark, ..self.cx.current_expansion.clone() },\n         });\n-        placeholder(expansion_kind, mark.as_u32())\n+        placeholder(expansion_kind, ast::NodeId::from_u32(mark.as_u32()))\n     }\n \n     fn collect_bang("}, {"sha": "118ceb17ab4a4538c639e2c493348c44a95fd326", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -33,6 +33,7 @@\n #![feature(unicode)]\n #![feature(question_mark)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(specialization)]\n \n extern crate serialize;\n extern crate term;"}, {"sha": "e307925a6ed83907b03de79f5b25d2b13188b4f2", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -780,17 +780,17 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n                 attr::ReprAny | attr::ReprPacked | attr::ReprSimd => continue,\n                 attr::ReprExtern => \"i32\",\n \n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::Is)) => \"isize\",\n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I8)) => \"i8\",\n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n-                attr::ReprInt(_, attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n-\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::Us)) => \"usize\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n-                attr::ReprInt(_, attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::Is)) => \"isize\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I8)) => \"i8\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n+\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::Us)) => \"usize\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n             }\n         }\n     }"}, {"sha": "fb59f41110670e4b9a624147219b7b68b81c0ca9", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc363cb482f92851b48b46402b5b5117627a840e/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=fc363cb482f92851b48b46402b5b5117627a840e", "patch": "@@ -28,6 +28,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(question_mark)]\n+#![feature(specialization)]\n \n use std::cell::{Cell, RefCell};\n use std::ops::{Add, Sub};\n@@ -151,21 +152,7 @@ impl Encodable for Span {\n     }\n }\n \n-impl Decodable for Span {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n-        d.read_struct(\"Span\", 2, |d| {\n-            let lo = d.read_struct_field(\"lo\", 0, |d| {\n-                BytePos::decode(d)\n-            })?;\n-\n-            let hi = d.read_struct_field(\"hi\", 1, |d| {\n-                BytePos::decode(d)\n-            })?;\n-\n-            Ok(mk_sp(lo, hi))\n-        })\n-    }\n-}\n+impl serialize::UseSpecializedDecodable for Span {}\n \n fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n     write!(f, \"Span {{ lo: {:?}, hi: {:?}, expn_id: {:?} }}\","}]}