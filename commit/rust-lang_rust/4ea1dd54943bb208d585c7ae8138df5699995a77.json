{"sha": "4ea1dd54943bb208d585c7ae8138df5699995a77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYTFkZDU0OTQzYmIyMDhkNTg1YzdhZTgxMzhkZjU2OTk5OTVhNzc=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2014-07-22T16:24:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-24T14:25:48Z"}, "message": "Add a null pointer check to CString::new\n\nThis also removes checks in other methods of `CString`\n\nBreaking changes:\n* `CString::new` now fails if `buf` is null. To avoid this add a check\nbefore creatng a new `CString` .\n* The `is_null` and `is_not_null` methods are deprecated, because a\n`CString` cannot be null.\n* Other methods which used to fail if the `CString` was null do not fail anymore\n\n[breaking-change]", "tree": {"sha": "072829598fe36318152b41565c6bd95312277627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/072829598fe36318152b41565c6bd95312277627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ea1dd54943bb208d585c7ae8138df5699995a77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ea1dd54943bb208d585c7ae8138df5699995a77", "html_url": "https://github.com/rust-lang/rust/commit/4ea1dd54943bb208d585c7ae8138df5699995a77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ea1dd54943bb208d585c7ae8138df5699995a77/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6988bcd74c6ab85d0a5f85c8b96c61f7fb75ad1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6988bcd74c6ab85d0a5f85c8b96c61f7fb75ad1d", "html_url": "https://github.com/rust-lang/rust/commit/6988bcd74c6ab85d0a5f85c8b96c61f7fb75ad1d"}], "stats": {"total": 133, "additions": 19, "deletions": 114}, "files": [{"sha": "343fe05ed42c132ff9ebf89bb0bd50fb150c4a53", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ea1dd54943bb208d585c7ae8138df5699995a77/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ea1dd54943bb208d585c7ae8138df5699995a77/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=4ea1dd54943bb208d585c7ae8138df5699995a77", "patch": "@@ -10,7 +10,6 @@\n \n use libc::{c_char, c_int};\n use libc;\n-use std::c_str::CString;\n use std::mem;\n use std::ptr::{null, mut_null};\n use std::rt::rtio;\n@@ -27,8 +26,8 @@ impl GetAddrInfoRequest {\n     {\n         assert!(host.is_some() || servname.is_some());\n \n-        let c_host = host.map_or(unsafe { CString::new(null(), true) }, |x| x.to_c_str());\n-        let c_serv = servname.map_or(unsafe { CString::new(null(), true) }, |x| x.to_c_str());\n+        let c_host = host.map(|x| x.to_c_str());\n+        let c_serv = servname.map(|x| x.to_c_str());\n \n         let hint = hint.map(|hint| {\n             libc::addrinfo {\n@@ -50,8 +49,8 @@ impl GetAddrInfoRequest {\n \n         // Make the call\n         let s = unsafe {\n-            let ch = if c_host.is_null() { null() } else { c_host.as_ptr() };\n-            let cs = if c_serv.is_null() { null() } else { c_serv.as_ptr() };\n+            let ch = if c_host.is_none() { null() } else { c_host.unwrap().as_ptr() };\n+            let cs = if c_serv.is_none() { null() } else { c_serv.unwrap().as_ptr() };\n             getaddrinfo(ch, cs, hint_ptr, &mut res)\n         };\n \n@@ -104,6 +103,7 @@ fn get_error(_: c_int) -> IoError {\n \n #[cfg(not(windows))]\n fn get_error(s: c_int) -> IoError {\n+    use std::c_str::CString;\n \n     let err_str = unsafe {\n         CString::new(gai_strerror(s), false).as_str().unwrap().to_string()"}, {"sha": "5dd61c03d17e75b053eabff31b5baecde5e91ca9", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 14, "deletions": 109, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4ea1dd54943bb208d585c7ae8138df5699995a77/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ea1dd54943bb208d585c7ae8138df5699995a77/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=4ea1dd54943bb208d585c7ae8138df5699995a77", "patch": "@@ -70,10 +70,10 @@ use core::prelude::*;\n use alloc::libc_heap::malloc_raw;\n use collections::string::String;\n use collections::hash;\n+use core::fmt;\n use core::kinds::marker;\n use core::mem;\n use core::ptr;\n-use core::fmt;\n use core::raw::Slice;\n use core::slice;\n use core::str;\n@@ -93,23 +93,18 @@ impl Clone for CString {\n     /// reasons, this is always a deep clone, rather than the usual shallow\n     /// clone.\n     fn clone(&self) -> CString {\n-        if self.buf.is_null() {\n-            CString { buf: self.buf, owns_buffer_: self.owns_buffer_ }\n-        } else {\n-            let len = self.len() + 1;\n-            let buf = unsafe { malloc_raw(len) } as *mut libc::c_char;\n-            unsafe { ptr::copy_nonoverlapping_memory(buf, self.buf, len); }\n-            CString { buf: buf as *const libc::c_char, owns_buffer_: true }\n-        }\n+        let len = self.len() + 1;\n+        let buf = unsafe { malloc_raw(len) } as *mut libc::c_char;\n+        unsafe { ptr::copy_nonoverlapping_memory(buf, self.buf, len); }\n+        CString { buf: buf as *const libc::c_char, owns_buffer_: true }\n     }\n }\n \n impl PartialEq for CString {\n     fn eq(&self, other: &CString) -> bool {\n+        // Check if the two strings share the same buffer\n         if self.buf as uint == other.buf as uint {\n             true\n-        } else if self.buf.is_null() || other.buf.is_null() {\n-            false\n         } else {\n             unsafe {\n                 libc::strcmp(self.buf, other.buf) == 0\n@@ -136,7 +131,12 @@ impl<S: hash::Writer> hash::Hash<S> for CString {\n \n impl CString {\n     /// Create a C String from a pointer.\n+    ///\n+    ///# Failure\n+    ///\n+    /// Fails if `buf` is null\n     pub unsafe fn new(buf: *const libc::c_char, owns_buffer: bool) -> CString {\n+        assert!(!buf.is_null());\n         CString { buf: buf, owns_buffer_: owns_buffer }\n     }\n \n@@ -158,10 +158,6 @@ impl CString {\n     /// let p = foo.to_c_str().as_ptr();\n     /// ```\n     ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n-    ///\n     /// # Example\n     ///\n     /// ```rust\n@@ -175,8 +171,6 @@ impl CString {\n     /// }\n     /// ```\n     pub fn as_ptr(&self) -> *const libc::c_char {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n-\n         self.buf\n     }\n \n@@ -197,44 +191,30 @@ impl CString {\n     /// // wrong (the CString will be freed, invalidating `p`)\n     /// let p = foo.to_c_str().as_mut_ptr();\n     /// ```\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     pub fn as_mut_ptr(&mut self) -> *mut libc::c_char {\n-        if self.buf.is_null() { fail!(\"CString is null!\") }\n-\n         self.buf as *mut _\n     }\n \n     /// Calls a closure with a reference to the underlying `*libc::c_char`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[deprecated=\"use `.as_ptr()`\"]\n     pub fn with_ref<T>(&self, f: |*const libc::c_char| -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf)\n     }\n \n     /// Calls a closure with a mutable reference to the underlying `*libc::c_char`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[deprecated=\"use `.as_mut_ptr()`\"]\n     pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf as *mut libc::c_char)\n     }\n \n     /// Returns true if the CString is a null.\n+    #[deprecated=\"a CString cannot be null\"]\n     pub fn is_null(&self) -> bool {\n         self.buf.is_null()\n     }\n \n     /// Returns true if the CString is not null.\n+    #[deprecated=\"a CString cannot be null\"]\n     pub fn is_not_null(&self) -> bool {\n         self.buf.is_not_null()\n     }\n@@ -246,51 +226,32 @@ impl CString {\n \n     /// Converts the CString into a `&[u8]` without copying.\n     /// Includes the terminating NUL byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[inline]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n             mem::transmute(Slice { data: self.buf, len: self.len() + 1 })\n         }\n     }\n \n     /// Converts the CString into a `&[u8]` without copying.\n     /// Does not include the terminating NUL byte.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[inline]\n     pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u8] {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n             mem::transmute(Slice { data: self.buf, len: self.len() })\n         }\n     }\n \n     /// Converts the CString into a `&str` without copying.\n     /// Returns None if the CString is not UTF-8.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[inline]\n     pub fn as_str<'a>(&'a self) -> Option<&'a str> {\n         let buf = self.as_bytes_no_nul();\n         str::from_utf8(buf)\n     }\n \n     /// Return a CString iterator.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     pub fn iter<'a>(&'a self) -> CChars<'a> {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         CChars {\n             ptr: self.buf,\n             marker: marker::ContravariantLifetime,\n@@ -326,13 +287,8 @@ impl Drop for CString {\n \n impl Collection for CString {\n     /// Return the number of bytes in the CString (not including the NUL terminator).\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the CString is null.\n     #[inline]\n     fn len(&self) -> uint {\n-        if self.buf.is_null() { fail!(\"CString is null!\"); }\n         let mut cur = self.buf;\n         let mut len = 0;\n         unsafe {\n@@ -631,13 +587,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_is_null() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        assert!(c_str.is_null());\n-        assert!(!c_str.is_not_null());\n-    }\n-\n     #[test]\n     fn test_unwrap() {\n         let c_str = \"hello\".to_c_str();\n@@ -648,16 +597,8 @@ mod tests {\n     fn test_as_ptr() {\n         let c_str = \"hello\".to_c_str();\n         let len = unsafe { libc::strlen(c_str.as_ptr()) };\n-        assert!(!c_str.is_null());\n-        assert!(c_str.is_not_null());\n         assert_eq!(len, 5);\n     }\n-    #[test]\n-    #[should_fail]\n-    fn test_as_ptr_empty_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.as_ptr();\n-    }\n \n     #[test]\n     fn test_iterator() {\n@@ -716,20 +657,6 @@ mod tests {\n         assert_eq!(c_str.as_bytes_no_nul(), b\"foo\\xFF\");\n     }\n \n-    #[test]\n-    #[should_fail]\n-    fn test_as_bytes_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.as_bytes();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_as_bytes_no_nul_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.as_bytes_no_nul();\n-    }\n-\n     #[test]\n     fn test_as_str() {\n         let c_str = \"hello\".to_c_str();\n@@ -742,23 +669,8 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n-    fn test_as_str_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.as_str();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_len_fail() {\n+    fn test_new_fail() {\n         let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.len();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_iter_fail() {\n-        let c_str = unsafe { CString::new(ptr::null(), false) };\n-        c_str.iter();\n     }\n \n     #[test]\n@@ -791,13 +703,6 @@ mod tests {\n         // force a copy, reading the memory\n         c_.as_bytes().to_vec();\n     }\n-\n-    #[test]\n-    fn test_clone_eq_null() {\n-        let x = unsafe { CString::new(ptr::null(), false) };\n-        let y = x.clone();\n-        assert!(x == y);\n-    }\n }\n \n #[cfg(test)]"}]}