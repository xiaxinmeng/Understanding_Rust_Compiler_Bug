{"sha": "b197f1ac2e455d9c39405cd1b70935a7da81f69d", "node_id": "C_kwDOAAsO6NoAKGIxOTdmMWFjMmU0NTVkOWMzOTQwNWNkMWI3MDkzNWE3ZGE4MWY2OWQ", "commit": {"author": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2023-01-27T14:22:05Z"}, "committer": {"name": "Ali MJ Al-Nasrawy", "email": "alimjalnasrawy@gmail.com", "date": "2023-03-26T08:43:12Z"}, "message": "remove obsolete `givens` from regionck", "tree": {"sha": "2b4815ec4712d64595950dae210b9eea17b88f35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b4815ec4712d64595950dae210b9eea17b88f35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b197f1ac2e455d9c39405cd1b70935a7da81f69d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b197f1ac2e455d9c39405cd1b70935a7da81f69d", "html_url": "https://github.com/rust-lang/rust/commit/b197f1ac2e455d9c39405cd1b70935a7da81f69d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b197f1ac2e455d9c39405cd1b70935a7da81f69d/comments", "author": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aliemjay", "id": 28497461, "node_id": "MDQ6VXNlcjI4NDk3NDYx", "avatar_url": "https://avatars.githubusercontent.com/u/28497461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aliemjay", "html_url": "https://github.com/aliemjay", "followers_url": "https://api.github.com/users/aliemjay/followers", "following_url": "https://api.github.com/users/aliemjay/following{/other_user}", "gists_url": "https://api.github.com/users/aliemjay/gists{/gist_id}", "starred_url": "https://api.github.com/users/aliemjay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aliemjay/subscriptions", "organizations_url": "https://api.github.com/users/aliemjay/orgs", "repos_url": "https://api.github.com/users/aliemjay/repos", "events_url": "https://api.github.com/users/aliemjay/events{/privacy}", "received_events_url": "https://api.github.com/users/aliemjay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8859fde21fa4e059c71a843cc7ee995c189a97c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8859fde21fa4e059c71a843cc7ee995c189a97c0", "html_url": "https://github.com/rust-lang/rust/commit/8859fde21fa4e059c71a843cc7ee995c189a97c0"}], "stats": {"total": 170, "additions": 26, "deletions": 144}, "files": [{"sha": "34ffd2e6c8e8800454e7f414a84e7a785fccbeb7", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -330,7 +330,6 @@ fn compare_method_predicate_entailment<'tcx>(\n     // lifetime parameters.\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n     infcx.process_registered_region_obligations(\n@@ -727,7 +726,6 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     // lifetime parameters.\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n     infcx\n@@ -2068,8 +2066,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),"}, {"sha": "c27da5fa8998a49fc16e814970652e7f64ff2a89", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -114,8 +114,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         return;\n     }\n \n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     let _ = infcx\n         .err_ctxt()\n@@ -675,7 +674,6 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n     );\n     let region_bound_pairs = outlives_environment.region_bound_pairs();"}, {"sha": "2c1b7f7efacd12b6bfb058543c5a3621537f14c0", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -179,7 +179,7 @@ fn get_impl_substs(\n     }\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n-    let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n     let _ =\n         infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {"}, {"sha": "11ff65d0c373a2a82700a5435482b2ecbe57b872", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -238,15 +238,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Note that there are two tests to check that this remains true\n         // (`regions-reassign-{match,let}-bound-pointer.rs`).\n         //\n-        // 2. Things go horribly wrong if we use subtype. The reason for\n-        // THIS is a fairly subtle case involving bound regions. See the\n-        // `givens` field in `region_constraints`, as well as the test\n+        // 2. An outdated issue related to the old HIR borrowck. See the test\n         // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n-        // for details. Short version is that we must sometimes detect\n-        // relationships between specific region variables and regions\n-        // bound in a closure signature, and that detection gets thrown\n-        // off when we substitute fresh region variables here to enable\n-        // subtyping.\n     }\n \n     /// Compute the new expected type and default binding mode from the old ones"}, {"sha": "e98f68ae5a851b05ace2f947404f37e35dc6b97f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -640,11 +640,9 @@ pub fn make_query_region_constraints<'tcx>(\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n-    let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n-        region_constraints;\n+    let RegionConstraintData { constraints, verifys, member_constraints } = region_constraints;\n \n     assert!(verifys.is_empty());\n-    assert!(givens.is_empty());\n \n     debug!(?constraints);\n "}, {"sha": "cf657756ff534477c967f6b8ceefcf36536c42ad", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 46, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_data_structures::intern::Interned;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::PlaceholderRegion;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -132,7 +132,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         let graph = self.construct_graph();\n-        self.expand_givens(&graph);\n         self.expansion(&mut var_data);\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n@@ -164,38 +163,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn expand_givens(&mut self, graph: &RegionGraph<'_>) {\n-        // Givens are a kind of horrible hack to account for\n-        // constraints like 'c <= '0 that are known to hold due to\n-        // closure signatures (see the comment above on the `givens`\n-        // field). They should go away. But until they do, the role\n-        // of this fn is to account for the transitive nature:\n-        //\n-        //     Given 'c <= '0\n-        //     and   '0 <= '1\n-        //     then  'c <= '1\n-\n-        let seeds: Vec<_> = self.data.givens.iter().cloned().collect();\n-        for (r, vid) in seeds {\n-            // While all things transitively reachable in the graph\n-            // from the variable (`'0` in the example above).\n-            let seed_index = NodeIndex(vid.index() as usize);\n-            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n-                let succ_index = succ_index.0;\n-\n-                // The first N nodes correspond to the region\n-                // variables. Other nodes correspond to constant\n-                // regions.\n-                if succ_index < self.num_vars() {\n-                    let succ_vid = RegionVid::new(succ_index);\n-\n-                    // Add `'c <= '1`.\n-                    self.data.givens.insert((r, succ_vid));\n-                }\n-            }\n-        }\n-    }\n-\n     /// Gets the LUb of a given region and the empty region\n     fn lub_empty(&self, a_region: Region<'tcx>) -> Result<Region<'tcx>, PlaceholderRegion> {\n         match *a_region {\n@@ -362,18 +329,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n \n-        match *a_region {\n-            // Check if this relationship is implied by a given.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                if self.data.givens.contains(&(a_region, b_vid)) {\n-                    debug!(\"given\");\n-                    return false;\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n         match *b_data {\n             VarValue::Empty(empty_ui) => {\n                 let lub = match self.lub_empty(a_region) {"}, {"sha": "731559de67c06023f6ec1e3fc3c4d324a5c29c6c", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -867,10 +867,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow().undo_log.opaque_types_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n-    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n-    }\n-\n     pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,"}, {"sha": "95f8f05ab6098101663afe859c4a939d26f108d7", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::free_regions::FreeRegionMap;\n-use crate::infer::{GenericKind, InferCtxt};\n+use crate::infer::GenericKind;\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_data_structures::transitive_relation::TransitiveRelationBuilder;\n-use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n+use rustc_middle::ty::{self, Region};\n \n use super::explicit_outlives_bounds;\n \n@@ -75,7 +75,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n             region_bound_pairs: Default::default(),\n         };\n \n-        builder.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n+        builder.add_outlives_bounds(explicit_outlives_bounds(param_env));\n \n         builder\n     }\n@@ -89,11 +89,10 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n     /// Create a new `OutlivesEnvironment` with extra outlives bounds.\n     pub fn with_bounds(\n         param_env: ty::ParamEnv<'tcx>,\n-        infcx: Option<&InferCtxt<'tcx>>,\n         extra_bounds: impl IntoIterator<Item = OutlivesBound<'tcx>>,\n     ) -> Self {\n         let mut builder = Self::builder(param_env);\n-        builder.add_outlives_bounds(infcx, extra_bounds);\n+        builder.add_outlives_bounds(extra_bounds);\n         builder.build()\n     }\n \n@@ -120,12 +119,7 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n-    ///\n-    /// The `infcx` parameter is optional; if the implied bounds may\n-    /// contain inference variables, it must be supplied, in which\n-    /// case we will register \"givens\" on the inference context. (See\n-    /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'tcx>>, outlives_bounds: I)\n+    fn add_outlives_bounds<I>(&mut self, outlives_bounds: I)\n     where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n@@ -143,24 +137,18 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n                         .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n                 OutlivesBound::RegionSubRegion(r_a, r_b) => {\n-                    if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {\n-                        infcx\n-                            .expect(\"no infcx provided but region vars found\")\n-                            .add_given(r_a, vid_b);\n-                    } else {\n-                        // In principle, we could record (and take\n-                        // advantage of) every relationship here, but\n-                        // we are also free not to -- it simply means\n-                        // strictly less that we can successfully type\n-                        // check. Right now we only look for things\n-                        // relationships between free regions. (It may\n-                        // also be that we should revise our inference\n-                        // system to be more general and to make use\n-                        // of *every* relationship that arises here,\n-                        // but presently we do not.)\n-                        if r_a.is_free_or_static() && r_b.is_free() {\n-                            self.region_relation.add(r_a, r_b)\n-                        }\n+                    // In principle, we could record (and take\n+                    // advantage of) every relationship here, but\n+                    // we are also free not to -- it simply means\n+                    // strictly less that we can successfully type\n+                    // check. Right now we only look for things\n+                    // relationships between free regions. (It may\n+                    // also be that we should revise our inference\n+                    // system to be more general and to make use\n+                    // of *every* relationship that arises here,\n+                    // but presently we do not.)\n+                    if r_a.is_free_or_static() && r_b.is_free() {\n+                        self.region_relation.add(r_a, r_b)\n                     }\n                 }\n             }"}, {"sha": "89ada23c6673aefeaa4ccac65e25ff748ee14a13", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -424,9 +424,6 @@ impl<'tcx> MiniGraph<'tcx> {\n                 &AddConstraint(Constraint::RegSubReg(a, b)) => {\n                     each_edge(a, b);\n                 }\n-                &AddGiven(a, b) => {\n-                    each_edge(a, tcx.mk_re_var(b));\n-                }\n                 &AddVerify(i) => span_bug!(\n                     verifys[i].origin.span(),\n                     \"we never add verifications while doing higher-ranked things\","}, {"sha": "7b272dfd2a4547f3dcba6ab063b12ca39eb816af", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 41, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -7,7 +7,7 @@ use super::{\n     InferCtxtUndoLogs, MiscVariable, RegionVariableOrigin, Rollback, Snapshot, SubregionOrigin,\n };\n \n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n@@ -104,26 +104,6 @@ pub struct RegionConstraintData<'tcx> {\n     /// An example is a `A <= B` where neither `A` nor `B` are\n     /// inference variables.\n     pub verifys: Vec<Verify<'tcx>>,\n-\n-    /// A \"given\" is a relationship that is known to hold. In\n-    /// particular, we often know from closure fn signatures that a\n-    /// particular free region must be a subregion of a region\n-    /// variable:\n-    ///\n-    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    ///\n-    /// In situations like this, `'b` is in fact a region variable\n-    /// introduced by the call to `iter()`, and `'a` is a bound region\n-    /// on the closure (as indicated by the `<'a>` prefix). If we are\n-    /// naive, we wind up inferring that `'b` must be `'static`,\n-    /// because we require that it be greater than `'a` and we do not\n-    /// know what `'a` is precisely.\n-    ///\n-    /// This hashmap is used to avoid that naive scenario. Basically\n-    /// we record the fact that `'a <= 'b` is implied by the fn\n-    /// signature, and then ignore the constraint when solving\n-    /// equations. This is a bit of a hack but seems to work.\n-    pub givens: FxIndexSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n /// Represents a constraint that influences the inference process.\n@@ -297,9 +277,6 @@ pub(crate) enum UndoLog<'tcx> {\n     /// We added the given `verify`.\n     AddVerify(usize),\n \n-    /// We added the given `given`.\n-    AddGiven(Region<'tcx>, ty::RegionVid),\n-\n     /// We added a GLB/LUB \"combination variable\".\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n }\n@@ -348,9 +325,6 @@ impl<'tcx> RegionConstraintStorage<'tcx> {\n                 self.data.verifys.pop();\n                 assert_eq!(self.data.verifys.len(), index);\n             }\n-            AddGiven(sub, sup) => {\n-                self.data.givens.remove(&(sub, sup));\n-            }\n             AddCombination(Glb, ref regions) => {\n                 self.glbs.remove(regions);\n             }\n@@ -492,15 +466,6 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.undo_log.push(AddVerify(index));\n     }\n \n-    pub(super) fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n-        // cannot add givens once regions are resolved\n-        if self.data.givens.insert((sub, sup)) {\n-            debug!(\"add_given({:?} <= {:?})\", sub, sup);\n-\n-            self.undo_log.push(AddGiven(sub, sup));\n-        }\n-    }\n-\n     pub(super) fn make_eqregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -804,11 +769,8 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     /// Returns `true` if this region constraint data contains no constraints, and `false`\n     /// otherwise.\n     pub fn is_empty(&self) -> bool {\n-        let RegionConstraintData { constraints, member_constraints, verifys, givens } = self;\n-        constraints.is_empty()\n-            && member_constraints.is_empty()\n-            && verifys.is_empty()\n-            && givens.is_empty()\n+        let RegionConstraintData { constraints, member_constraints, verifys } = self;\n+        constraints.is_empty() && member_constraints.is_empty() && verifys.is_empty()\n     }\n }\n "}, {"sha": "65feda56db4770bbc85b8903d423dee4eb99aa69", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -396,7 +396,6 @@ fn resolve_negative_obligation<'tcx>(\n     let wf_tys = ocx.assumed_wf_types(param_env, DUMMY_SP, body_def_id);\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, body_def_id, wf_tys),\n     );\n "}, {"sha": "0bde43c54df99892fba558fa3bef7ac282986fb5", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b197f1ac2e455d9c39405cd1b70935a7da81f69d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=b197f1ac2e455d9c39405cd1b70935a7da81f69d", "patch": "@@ -111,7 +111,6 @@ pub fn type_allowed_to_implement_copy<'tcx>(\n             // Check regions assuming the self type of the impl is WF\n             let outlives_env = OutlivesEnvironment::with_bounds(\n                 param_env,\n-                Some(&infcx),\n                 infcx.implied_bounds_tys(\n                     param_env,\n                     parent_cause.body_id,"}]}