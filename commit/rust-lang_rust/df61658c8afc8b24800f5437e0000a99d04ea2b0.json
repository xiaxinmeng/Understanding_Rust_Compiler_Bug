{"sha": "df61658c8afc8b24800f5437e0000a99d04ea2b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNjE2NThjOGFmYzhiMjQ4MDBmNTQzN2UwMDAwYTk5ZDA0ZWEyYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-02T13:51:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-02T13:51:43Z"}, "message": "Auto merge of #38766 - eddyb:less-fake-hir, r=arielb1\n\nStop creating fake HIR pattern nodes.\n\nThis replaces all the HIR patterns `rustc_const_eval` creates with the more appropriate HAIR equivalent.\n\nThe only place left that creates HIR nodes is the \"explicit lifetimes in function signature\" suggestion, which only creates type nodes while rebuilding the signature, but that is only in case of an error.\n\ncc @arielb1", "tree": {"sha": "43ba219a112a59398362d813a6d4781fd7a6c133", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ba219a112a59398362d813a6d4781fd7a6c133"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df61658c8afc8b24800f5437e0000a99d04ea2b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df61658c8afc8b24800f5437e0000a99d04ea2b0", "html_url": "https://github.com/rust-lang/rust/commit/df61658c8afc8b24800f5437e0000a99d04ea2b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df61658c8afc8b24800f5437e0000a99d04ea2b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07191e2b11b4f9f0328470b5af13d4765085ff6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/07191e2b11b4f9f0328470b5af13d4765085ff6a", "html_url": "https://github.com/rust-lang/rust/commit/07191e2b11b4f9f0328470b5af13d4765085ff6a"}, {"sha": "c6e130e89bb6e57ce492a9551da6828cce054422", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6e130e89bb6e57ce492a9551da6828cce054422", "html_url": "https://github.com/rust-lang/rust/commit/c6e130e89bb6e57ce492a9551da6828cce054422"}], "stats": {"total": 704, "additions": 411, "deletions": 293}, "files": [{"sha": "6d04975f533da853e30acff48273b106e13bfc9a", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 62, "deletions": 83, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/df61658c8afc8b24800f5437e0000a99d04ea2b0/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df61658c8afc8b24800f5437e0000a99d04ea2b0/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=df61658c8afc8b24800f5437e0000a99d04ea2b0", "patch": "@@ -23,18 +23,12 @@ use rustc_data_structures::indexed_vec::Idx;\n use pattern::{FieldPattern, Pattern, PatternKind};\n use pattern::{PatternFoldable, PatternFolder};\n \n-use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n-use rustc::hir;\n-use rustc::hir::def::CtorKind;\n-use rustc::hir::{Pat, PatKind};\n+use rustc::mir::Field;\n use rustc::util::common::ErrorReported;\n \n-use syntax::ast::{self, DUMMY_NODE_ID};\n-use syntax::codemap::Spanned;\n-use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n@@ -74,12 +68,6 @@ impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     }\n }\n \n-pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n-    id: DUMMY_NODE_ID,\n-    node: PatKind::Wild,\n-    span: DUMMY_SP\n-};\n-\n impl<'tcx> Pattern<'tcx> {\n     fn is_wildcard(&self) -> bool {\n         match *self.kind {\n@@ -224,25 +212,34 @@ pub enum Constructor {\n }\n \n impl<'tcx> Constructor {\n-    fn variant_for_adt(&self, adt: &'tcx ty::AdtDef) -> &'tcx ty::VariantDef {\n+    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> usize {\n         match self {\n-            &Variant(vid) => adt.variant_with_id(vid),\n+            &Variant(vid) => adt.variant_index_with_id(vid),\n             &Single => {\n                 assert_eq!(adt.variants.len(), 1);\n-                &adt.variants[0]\n+                0\n             }\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }\n }\n \n-#[derive(Clone, PartialEq)]\n-pub enum Usefulness {\n+#[derive(Clone)]\n+pub enum Usefulness<'tcx> {\n     Useful,\n-    UsefulWithWitness(Vec<Witness>),\n+    UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful\n }\n \n+impl<'tcx> Usefulness<'tcx> {\n+    fn is_useful(&self) -> bool {\n+        match *self {\n+            NotUseful => false,\n+            _ => true\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub enum WitnessPreference {\n     ConstructWitness,\n@@ -255,39 +252,25 @@ struct PatternContext<'tcx> {\n     max_slice_length: usize,\n }\n \n-\n-fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n-    let node = match value {\n-        &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n-        _ => bug!()\n-    };\n-    P(hir::Expr {\n-        id: DUMMY_NODE_ID,\n-        node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n-        span: DUMMY_SP,\n-        attrs: ast::ThinVec::new(),\n-    })\n-}\n-\n /// A stack of patterns in reverse order of construction\n-#[derive(Clone, PartialEq, Eq)]\n-pub struct Witness(Vec<P<Pat>>);\n+#[derive(Clone)]\n+pub struct Witness<'tcx>(Vec<Pattern<'tcx>>);\n \n-impl Witness {\n-    pub fn single_pattern(&self) -> &Pat {\n+impl<'tcx> Witness<'tcx> {\n+    pub fn single_pattern(&self) -> &Pattern<'tcx> {\n         assert_eq!(self.0.len(), 1);\n         &self.0[0]\n     }\n \n-    fn push_wild_constructor<'a, 'tcx>(\n+    fn push_wild_constructor<'a>(\n         mut self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n         ctor: &Constructor,\n         ty: Ty<'tcx>)\n         -> Self\n     {\n         let arity = constructor_arity(cx, ctor, ty);\n-        self.0.extend(repeat(DUMMY_WILD_PAT).take(arity).map(|p| P(p.clone())));\n+        self.0.extend(repeat(cx.wild_pattern).take(arity).cloned());\n         self.apply_constructor(cx, ctor, ty)\n     }\n \n@@ -305,7 +288,7 @@ impl Witness {\n     ///\n     /// left_ty: struct X { a: (bool, &'static str), b: usize}\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-    fn apply_constructor<'a, 'tcx>(\n+    fn apply_constructor<'a>(\n         mut self,\n         cx: &MatchCheckCtxt<'a,'tcx>,\n         ctor: &Constructor,\n@@ -318,60 +301,56 @@ impl Witness {\n             let mut pats = self.0.drain(len-arity..).rev();\n \n             match ty.sty {\n-                ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n-\n-                ty::TyAdt(adt, _) => {\n-                    let v = ctor.variant_for_adt(adt);\n-                    let qpath = hir::QPath::Resolved(None, P(hir::Path {\n-                        span: DUMMY_SP,\n-                        def: Def::Err,\n-                        segments: vec![hir::PathSegment::from_name(v.name)].into(),\n-                    }));\n-                    match v.ctor_kind {\n-                        CtorKind::Fictive => {\n-                            let field_pats: hir::HirVec<_> = v.fields.iter()\n-                                .zip(pats)\n-                                .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n-                                .map(|(field, pat)| Spanned {\n-                                    span: DUMMY_SP,\n-                                    node: hir::FieldPat {\n-                                        name: field.name,\n-                                        pat: pat,\n-                                        is_shorthand: false,\n-                                    }\n-                                }).collect();\n-                            let has_more_fields = field_pats.len() < arity;\n-                            PatKind::Struct(qpath, field_pats, has_more_fields)\n+                ty::TyAdt(..) |\n+                ty::TyTuple(..) => {\n+                    let pats = pats.enumerate().map(|(i, p)| {\n+                        FieldPattern {\n+                            field: Field::new(i),\n+                            pattern: p\n                         }\n-                        CtorKind::Fn => {\n-                            PatKind::TupleStruct(qpath, pats.collect(), None)\n+                    }).collect();\n+\n+                    if let ty::TyAdt(adt, _) = ty.sty {\n+                        if adt.variants.len() > 1 {\n+                            PatternKind::Variant {\n+                                adt_def: adt,\n+                                variant_index: ctor.variant_index_for_adt(adt),\n+                                subpatterns: pats\n+                            }\n+                        } else {\n+                            PatternKind::Leaf { subpatterns: pats }\n                         }\n-                        CtorKind::Const => PatKind::Path(qpath)\n+                    } else {\n+                        PatternKind::Leaf { subpatterns: pats }\n                     }\n                 }\n \n-                ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n-                    PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n+                ty::TyRef(..) => {\n+                    PatternKind::Deref { subpattern: pats.nth(0).unwrap() }\n                 }\n \n                 ty::TySlice(_) | ty::TyArray(..) => {\n-                    PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n+                    PatternKind::Slice {\n+                        prefix: pats.collect(),\n+                        slice: None,\n+                        suffix: vec![]\n+                    }\n                 }\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n-                        _ => PatKind::Wild,\n+                        ConstantValue(ref v) => PatternKind::Constant { value: v.clone() },\n+                        _ => PatternKind::Wild,\n                     }\n                 }\n             }\n         };\n \n-        self.0.push(P(hir::Pat {\n-            id: DUMMY_NODE_ID,\n-            node: pat,\n-            span: DUMMY_SP\n-        }));\n+        self.0.push(Pattern {\n+            ty: ty,\n+            span: DUMMY_SP,\n+            kind: Box::new(pat),\n+        });\n \n         self\n     }\n@@ -528,13 +507,13 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                            matrix: &Matrix<'a, 'tcx>,\n                            v: &[&'a Pattern<'tcx>],\n                            witness: WitnessPreference)\n-                           -> Usefulness {\n+                           -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:?}, {:?})\", matrix, v);\n     if rows.is_empty() {\n         return match witness {\n             ConstructWitness => UsefulWithWitness(vec![Witness(\n-                repeat(DUMMY_WILD_PAT).take(v.len()).map(|p| P(p.clone())).collect()\n+                repeat(cx.wild_pattern).take(v.len()).cloned().collect()\n             )]),\n             LeaveOutWitness => Useful\n         };\n@@ -559,15 +538,15 @@ pub fn is_useful<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         debug!(\"is_useful - expanding constructors: {:?}\", constructors);\n         constructors.into_iter().map(|c|\n             is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n-        ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+        ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n         let constructors = missing_constructors(cx, matrix, pcx);\n         debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n         if constructors.is_empty() {\n             all_constructors(cx, pcx).into_iter().map(|c| {\n                 is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n-            }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+            }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n                 if r[0].is_wildcard() {\n@@ -597,7 +576,7 @@ fn is_useful_specialized<'a, 'tcx>(\n     v: &[&'a Pattern<'tcx>],\n     ctor: Constructor,\n     lty: Ty<'tcx>,\n-    witness: WitnessPreference) -> Usefulness\n+    witness: WitnessPreference) -> Usefulness<'tcx>\n {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().flat_map(|r| {\n@@ -672,7 +651,7 @@ fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize\n         },\n         ty::TyRef(..) => 1,\n         ty::TyAdt(adt, _) => {\n-            ctor.variant_for_adt(adt).fields.len()\n+            adt.variants[ctor.variant_index_for_adt(adt)].fields.len()\n         }\n         _ => 0\n     }"}, {"sha": "53e83815b465233ca5261435a56afc543971a289", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/df61658c8afc8b24800f5437e0000a99d04ea2b0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df61658c8afc8b24800f5437e0000a99d04ea2b0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=df61658c8afc8b24800f5437e0000a99d04ea2b0", "patch": "@@ -9,11 +9,10 @@\n // except according to those terms.\n \n use _match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n-use _match::{DUMMY_WILD_PAT};\n use _match::Usefulness::*;\n use _match::WitnessPreference::*;\n \n-use pattern::{Pattern, PatternContext, PatternError};\n+use pattern::{Pattern, PatternContext, PatternError, PatternKind};\n \n use eval::report_const_eval_err;\n \n@@ -117,13 +116,6 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     fn report_inlining_errors(&self, patcx: PatternContext, pat_span: Span) {\n         for error in patcx.errors {\n             match error {\n-                PatternError::BadConstInPattern(span, def_id) => {\n-                    self.tcx.sess.span_err(\n-                        span,\n-                        &format!(\"constants of the type `{}` \\\n-                                  cannot be used in patterns\",\n-                                 self.tcx.item_path_str(def_id)));\n-                }\n                 PatternError::StaticInPattern(span) => {\n                     span_err!(self.tcx.sess, span, E0158,\n                               \"statics cannot be referenced in patterns\");\n@@ -230,9 +222,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 Useful => bug!()\n             };\n \n-            let pattern_string = hir::print::to_string(&self.tcx.map, |s| {\n-                s.print_pat(witness[0].single_pattern())\n-            });\n+            let pattern_string = witness[0].single_pattern().to_string();\n             let mut diag = struct_span_err!(\n                 self.tcx.sess, pat.span, E0005,\n                 \"refutable pattern in {}: `{}` not covered\",\n@@ -369,23 +359,21 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     match is_useful(cx, matrix, &[cx.wild_pattern], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witnesses = if pats.is_empty() {\n-                vec![DUMMY_WILD_PAT]\n+                vec![cx.wild_pattern]\n             } else {\n                 pats.iter().map(|w| w.single_pattern()).collect()\n             };\n             match source {\n                 hir::MatchSource::ForLoopDesugar => {\n                     // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n-                    let witness = match witnesses[0].node {\n-                        PatKind::TupleStruct(_, ref pats, _) => match &pats[..] {\n-                            &[ref pat] => &**pat,\n+                    let witness = match *witnesses[0].kind {\n+                        PatternKind::Variant { ref subpatterns, .. } => match &subpatterns[..] {\n+                            &[ref pat] => &pat.pattern,\n                             _ => bug!(),\n                         },\n                         _ => bug!(),\n                     };\n-                    let pattern_string = hir::print::to_string(&cx.tcx.map, |s| {\n-                        s.print_pat(witness)\n-                    });\n+                    let pattern_string = witness.to_string();\n                     struct_span_err!(cx.tcx.sess, sp, E0297,\n                         \"refutable pattern in `for` loop binding: \\\n                                 `{}` not covered\",\n@@ -394,24 +382,23 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                         .emit();\n                 },\n                 _ => {\n-                    let pattern_strings: Vec<_> = witnesses.iter().map(|w| {\n-                        hir::print::to_string(&cx.tcx.map, |s| s.print_pat(w))\n-                    }).collect();\n                     const LIMIT: usize = 3;\n-                    let joined_patterns = match pattern_strings.len() {\n+                    let joined_patterns = match witnesses.len() {\n                         0 => bug!(),\n-                        1 => format!(\"`{}`\", pattern_strings[0]),\n+                        1 => format!(\"`{}`\", witnesses[0]),\n                         2...LIMIT => {\n-                            let (tail, head) = pattern_strings.split_last().unwrap();\n-                            format!(\"`{}`\", head.join(\"`, `\") + \"` and `\" + tail)\n+                            let (tail, head) = witnesses.split_last().unwrap();\n+                            let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n+                            format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n                         },\n                         _ => {\n-                            let (head, tail) = pattern_strings.split_at(LIMIT);\n+                            let (head, tail) = witnesses.split_at(LIMIT);\n+                            let head: Vec<_> = head.iter().map(|w| w.to_string()).collect();\n                             format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n                         }\n                     };\n \n-                    let label_text = match pattern_strings.len(){\n+                    let label_text = match witnesses.len() {\n                         1 => format!(\"pattern {} not covered\", joined_patterns),\n                         _ => format!(\"patterns {} not covered\", joined_patterns)\n                     };"}, {"sha": "6b8e0e34c1df63db42f70429e13631ce284b7b48", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 3, "deletions": 127, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/df61658c8afc8b24800f5437e0000a99d04ea2b0/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df61658c8afc8b24800f5437e0000a99d04ea2b0/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=df61658c8afc8b24800f5437e0000a99d04ea2b0", "patch": "@@ -18,24 +18,20 @@ use self::EvalHint::*;\n use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits;\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::DefIdMap;\n-use rustc::lint;\n \n use graphviz::IntoCow;\n use syntax::ast;\n-use rustc::hir::{Expr, PatKind};\n-use rustc::hir;\n-use syntax::ptr::P;\n-use syntax::codemap;\n+use rustc::hir::{self, Expr};\n use syntax::attr::IntType;\n-use syntax_pos::{self, Span};\n+use syntax_pos::Span;\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n@@ -186,126 +182,6 @@ fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     }\n }\n \n-pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   expr: &Expr,\n-                                   pat_id: ast::NodeId,\n-                                   span: Span)\n-                                   -> Result<P<hir::Pat>, DefId> {\n-    let pat_ty = tcx.tables().expr_ty(expr);\n-    debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n-    match pat_ty.sty {\n-        ty::TyFloat(_) => {\n-            tcx.sess.add_lint(\n-                lint::builtin::ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n-                pat_id,\n-                span,\n-                format!(\"floating point constants cannot be used in patterns\"));\n-        }\n-        ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n-            // Matching on union fields is unsafe, we can't hide it in constants\n-            tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n-        }\n-        ty::TyAdt(adt_def, _) => {\n-            if !tcx.has_attr(adt_def.did, \"structural_match\") {\n-                tcx.sess.add_lint(\n-                    lint::builtin::ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n-                    pat_id,\n-                    span,\n-                    format!(\"to use a constant of type `{}` \\\n-                             in a pattern, \\\n-                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                            tcx.item_path_str(adt_def.did),\n-                            tcx.item_path_str(adt_def.did)));\n-            }\n-        }\n-        _ => { }\n-    }\n-    let pat = match expr.node {\n-        hir::ExprTup(ref exprs) =>\n-            PatKind::Tuple(exprs.iter()\n-                                .map(|expr| const_expr_to_pat(tcx, &expr, pat_id, span))\n-                                .collect::<Result<_, _>>()?, None),\n-\n-        hir::ExprCall(ref callee, ref args) => {\n-            let qpath = match callee.node {\n-                hir::ExprPath(ref qpath) => qpath,\n-                _ => bug!()\n-            };\n-            let def = tcx.tables().qpath_def(qpath, callee.id);\n-            let ctor_path = if let hir::QPath::Resolved(_, ref path) = *qpath {\n-                match def {\n-                    Def::StructCtor(_, CtorKind::Fn) |\n-                    Def::VariantCtor(_, CtorKind::Fn) => {\n-                        Some(path.clone())\n-                    }\n-                    _ => None\n-                }\n-            } else {\n-                None\n-            };\n-            match (def, ctor_path) {\n-                (Def::Fn(..), None) | (Def::Method(..), None) => {\n-                    PatKind::Lit(P(expr.clone()))\n-                }\n-                (_, Some(ctor_path)) => {\n-                    let pats = args.iter()\n-                                   .map(|expr| const_expr_to_pat(tcx, expr, pat_id, span))\n-                                   .collect::<Result<_, _>>()?;\n-                    PatKind::TupleStruct(hir::QPath::Resolved(None, ctor_path), pats, None)\n-                }\n-                _ => bug!()\n-            }\n-        }\n-\n-        hir::ExprStruct(ref qpath, ref fields, None) => {\n-            let field_pats =\n-                fields.iter()\n-                      .map(|field| Ok(codemap::Spanned {\n-                          span: syntax_pos::DUMMY_SP,\n-                          node: hir::FieldPat {\n-                              name: field.name.node,\n-                              pat: const_expr_to_pat(tcx, &field.expr, pat_id, span)?,\n-                              is_shorthand: false,\n-                          },\n-                      }))\n-                      .collect::<Result<_, _>>()?;\n-            PatKind::Struct(qpath.clone(), field_pats, false)\n-        }\n-\n-        hir::ExprArray(ref exprs) => {\n-            let pats = exprs.iter()\n-                            .map(|expr| const_expr_to_pat(tcx, &expr, pat_id, span))\n-                            .collect::<Result<_, _>>()?;\n-            PatKind::Slice(pats, None, hir::HirVec::new())\n-        }\n-\n-        hir::ExprPath(ref qpath) => {\n-            let def = tcx.tables().qpath_def(qpath, expr.id);\n-            match def {\n-                Def::StructCtor(_, CtorKind::Const) |\n-                Def::VariantCtor(_, CtorKind::Const) => {\n-                    match expr.node {\n-                        hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                            PatKind::Path(hir::QPath::Resolved(None, path.clone()))\n-                        }\n-                        _ => bug!()\n-                    }\n-                }\n-                Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                    let substs = Some(tcx.tables().node_id_item_substs(expr.id)\n-                        .unwrap_or_else(|| tcx.intern_substs(&[])));\n-                    let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();\n-                    return const_expr_to_pat(tcx, expr, pat_id, span);\n-                },\n-                _ => bug!(),\n-            }\n-        }\n-\n-        _ => PatKind::Lit(P(expr.clone()))\n-    };\n-    Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n-}\n-\n pub fn report_const_eval_err<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err: &ConstEvalErr,"}, {"sha": "b122d97a702f6df6574582667f6625a171d58fa5", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 331, "deletions": 55, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/df61658c8afc8b24800f5437e0000a99d04ea2b0/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df61658c8afc8b24800f5437e0000a99d04ea2b0/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=df61658c8afc8b24800f5437e0000a99d04ea2b0", "patch": "@@ -10,24 +10,24 @@\n \n use eval;\n \n+use rustc::lint;\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::hir::{self, PatKind};\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n+use std::fmt;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n pub enum PatternError {\n     StaticInPattern(Span),\n-    BadConstInPattern(Span, DefId),\n     ConstEval(eval::ConstEvalErr),\n }\n \n@@ -105,6 +105,158 @@ pub enum PatternKind<'tcx> {\n     },\n }\n \n+fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n+    match *value {\n+        ConstVal::Float(ref x) => write!(f, \"{}\", x),\n+        ConstVal::Integral(ref i) => write!(f, \"{}\", i),\n+        ConstVal::Str(ref s) => write!(f, \"{:?}\", &s[..]),\n+        ConstVal::ByteStr(ref b) => write!(f, \"{:?}\", &b[..]),\n+        ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n+        ConstVal::Char(c) => write!(f, \"{:?}\", c),\n+        ConstVal::Struct(_) |\n+        ConstVal::Tuple(_) |\n+        ConstVal::Function(_) |\n+        ConstVal::Array(..) |\n+        ConstVal::Repeat(..) |\n+        ConstVal::Dummy => bug!(\"{:?} not printable in a pattern\", value)\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for Pattern<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self.kind {\n+            PatternKind::Wild => write!(f, \"_\"),\n+            PatternKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n+                let is_mut = match mode {\n+                    BindingMode::ByValue => mutability == Mutability::Mut,\n+                    BindingMode::ByRef(_, bk) => {\n+                        write!(f, \"ref \")?;\n+                        bk == BorrowKind::Mut\n+                    }\n+                };\n+                if is_mut {\n+                    write!(f, \"mut \")?;\n+                }\n+                write!(f, \"{}\", name)?;\n+                if let Some(ref subpattern) = *subpattern {\n+                    write!(f, \" @ {}\", subpattern)?;\n+                }\n+                Ok(())\n+            }\n+            PatternKind::Variant { ref subpatterns, .. } |\n+            PatternKind::Leaf { ref subpatterns } => {\n+                let variant = match *self.kind {\n+                    PatternKind::Variant { adt_def, variant_index, .. } => {\n+                        Some(&adt_def.variants[variant_index])\n+                    }\n+                    _ => if let ty::TyAdt(adt, _) = self.ty.sty {\n+                        Some(adt.struct_variant())\n+                    } else {\n+                        None\n+                    }\n+                };\n+\n+                let mut first = true;\n+                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n+\n+                if let Some(variant) = variant {\n+                    write!(f, \"{}\", variant.name)?;\n+\n+                    // Only for TyAdt we can have `S {...}`,\n+                    // which we handle separately here.\n+                    if variant.ctor_kind == CtorKind::Fictive {\n+                        write!(f, \" {{ \")?;\n+\n+                        let mut printed = 0;\n+                        for p in subpatterns {\n+                            if let PatternKind::Wild = *p.pattern.kind {\n+                                continue;\n+                            }\n+                            let name = variant.fields[p.field.index()].name;\n+                            write!(f, \"{}{}: {}\", start_or_continue(), name, p.pattern)?;\n+                            printed += 1;\n+                        }\n+\n+                        if printed < variant.fields.len() {\n+                            write!(f, \"{}..\", start_or_continue())?;\n+                        }\n+\n+                        return write!(f, \" }}\");\n+                    }\n+                }\n+\n+                let num_fields = variant.map_or(subpatterns.len(), |v| v.fields.len());\n+                if num_fields != 0 || variant.is_none() {\n+                    write!(f, \"(\")?;\n+                    for i in 0..num_fields {\n+                        write!(f, \"{}\", start_or_continue())?;\n+\n+                        // Common case: the field is where we expect it.\n+                        if let Some(p) = subpatterns.get(i) {\n+                            if p.field.index() == i {\n+                                write!(f, \"{}\", p.pattern)?;\n+                                continue;\n+                            }\n+                        }\n+\n+                        // Otherwise, we have to go looking for it.\n+                        if let Some(p) = subpatterns.iter().find(|p| p.field.index() == i) {\n+                            write!(f, \"{}\", p.pattern)?;\n+                        } else {\n+                            write!(f, \"_\")?;\n+                        }\n+                    }\n+                    write!(f, \")\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            PatternKind::Deref { ref subpattern } => {\n+                match self.ty.sty {\n+                    ty::TyBox(_) => write!(f, \"box \")?,\n+                    ty::TyRef(_, mt) => {\n+                        write!(f, \"&\")?;\n+                        if mt.mutbl == hir::MutMutable {\n+                            write!(f, \"mut \")?;\n+                        }\n+                    }\n+                    _ => bug!(\"{} is a bad Deref pattern type\", self.ty)\n+                }\n+                write!(f, \"{}\", subpattern)\n+            }\n+            PatternKind::Constant { ref value } => {\n+                print_const_val(value, f)\n+            }\n+            PatternKind::Range { ref lo, ref hi } => {\n+                print_const_val(lo, f)?;\n+                write!(f, \"...\")?;\n+                print_const_val(hi, f)\n+            }\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+                let mut first = true;\n+                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n+                write!(f, \"[\")?;\n+                for p in prefix {\n+                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                }\n+                if let Some(ref slice) = *slice {\n+                    write!(f, \"{}\", start_or_continue())?;\n+                    match *slice.kind {\n+                        PatternKind::Wild => {}\n+                        _ => write!(f, \"{}\", slice)?\n+                    }\n+                    write!(f, \"..\")?;\n+                }\n+                for p in suffix {\n+                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                }\n+                write!(f, \"]\")\n+            }\n+        }\n+    }\n+}\n+\n pub struct PatternContext<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub errors: Vec<PatternError>,\n@@ -133,64 +285,20 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n \n-            PatKind::Lit(ref value) => {\n-                match eval::eval_const_expr_checked(self.tcx.global_tcx(), value) {\n-                    Ok(value) => {\n-                        PatternKind::Constant { value: value }\n-                    }\n-                    Err(e) => {\n-                        self.errors.push(PatternError::ConstEval(e));\n-                        PatternKind::Wild\n-                    }\n-                }\n-            }\n+            PatKind::Lit(ref value) => self.lower_lit(value),\n \n             PatKind::Range(ref lo, ref hi) => {\n-                let r_lo = eval::eval_const_expr_checked(self.tcx.global_tcx(), lo);\n-                if let Err(ref e_lo) = r_lo {\n-                    self.errors.push(PatternError::ConstEval(e_lo.clone()));\n-                }\n-\n-                let r_hi = eval::eval_const_expr_checked(self.tcx.global_tcx(), hi);\n-                if let Err(ref e_hi) = r_hi {\n-                    self.errors.push(PatternError::ConstEval(e_hi.clone()));\n-                }\n-\n-                if let (Ok(lo), Ok(hi)) = (r_lo, r_hi) {\n-                    PatternKind::Range { lo: lo, hi: hi }\n-                } else {\n-                    PatternKind::Wild\n+                match (self.lower_lit(lo), self.lower_lit(hi)) {\n+                    (PatternKind::Constant { value: lo },\n+                     PatternKind::Constant { value: hi }) => {\n+                        PatternKind::Range { lo: lo, hi: hi }\n+                    }\n+                    _ => PatternKind::Wild\n                 }\n             }\n \n             PatKind::Path(ref qpath) => {\n-                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n-                match def {\n-                    Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                        let tcx = self.tcx.global_tcx();\n-                        let substs = tcx.tables().node_id_item_substs(pat.id)\n-                            .unwrap_or_else(|| tcx.intern_substs(&[]));\n-                        match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n-                            Some((const_expr, _const_ty)) => {\n-                                match eval::const_expr_to_pat(\n-                                    tcx, const_expr, pat.id, pat.span)\n-                                {\n-                                    Ok(pat) => return self.lower_pattern(&pat),\n-                                    Err(_) => {\n-                                        self.errors.push(PatternError::BadConstInPattern(\n-                                            pat.span, def_id));\n-                                        PatternKind::Wild\n-                                    }\n-                                }\n-                            }\n-                            None => {\n-                                self.errors.push(PatternError::StaticInPattern(pat.span));\n-                                PatternKind::Wild\n-                            }\n-                        }\n-                    }\n-                    _ => self.lower_variant_or_leaf(def, vec![])\n-                }\n+                return self.lower_path(qpath, pat.id, pat.id, pat.span);\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n@@ -447,6 +555,174 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n             _ => bug!()\n         }\n     }\n+\n+    fn lower_path(&mut self,\n+                  qpath: &hir::QPath,\n+                  id: ast::NodeId,\n+                  pat_id: ast::NodeId,\n+                  span: Span)\n+                  -> Pattern<'tcx> {\n+        let def = self.tcx.tables().qpath_def(qpath, id);\n+        let kind = match def {\n+            Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                let tcx = self.tcx.global_tcx();\n+                let substs = tcx.tables().node_id_item_substs(id)\n+                    .unwrap_or_else(|| tcx.intern_substs(&[]));\n+                match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n+                    Some((const_expr, _const_ty)) => {\n+                        return self.lower_const_expr(const_expr, pat_id, span);\n+                    }\n+                    None => {\n+                        self.errors.push(PatternError::StaticInPattern(span));\n+                        PatternKind::Wild\n+                    }\n+                }\n+            }\n+            _ => self.lower_variant_or_leaf(def, vec![])\n+        };\n+\n+        Pattern {\n+            span: span,\n+            ty: self.tcx.tables().node_id_to_type(id),\n+            kind: Box::new(kind),\n+        }\n+    }\n+\n+    fn lower_lit(&mut self, expr: &hir::Expr) -> PatternKind<'tcx> {\n+        match eval::eval_const_expr_checked(self.tcx.global_tcx(), expr) {\n+            Ok(value) => {\n+                PatternKind::Constant { value: value }\n+            }\n+            Err(e) => {\n+                self.errors.push(PatternError::ConstEval(e));\n+                PatternKind::Wild\n+            }\n+        }\n+    }\n+\n+    fn lower_const_expr(&mut self,\n+                        expr: &hir::Expr,\n+                        pat_id: ast::NodeId,\n+                        span: Span)\n+                        -> Pattern<'tcx> {\n+        let pat_ty = self.tcx.tables().expr_ty(expr);\n+        debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n+        match pat_ty.sty {\n+            ty::TyFloat(_) => {\n+                self.tcx.sess.add_lint(\n+                    lint::builtin::ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n+                    pat_id,\n+                    span,\n+                    format!(\"floating point constants cannot be used in patterns\"));\n+            }\n+            ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n+                // Matching on union fields is unsafe, we can't hide it in constants\n+                self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+            }\n+            ty::TyAdt(adt_def, _) => {\n+                if !self.tcx.has_attr(adt_def.did, \"structural_match\") {\n+                    self.tcx.sess.add_lint(\n+                        lint::builtin::ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n+                        pat_id,\n+                        span,\n+                        format!(\"to use a constant of type `{}` \\\n+                                 in a pattern, \\\n+                                 `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                                self.tcx.item_path_str(adt_def.did),\n+                                self.tcx.item_path_str(adt_def.did)));\n+                }\n+            }\n+            _ => { }\n+        }\n+        let kind = match expr.node {\n+            hir::ExprTup(ref exprs) => {\n+                PatternKind::Leaf {\n+                    subpatterns: exprs.iter().enumerate().map(|(i, expr)| {\n+                        FieldPattern {\n+                            field: Field::new(i),\n+                            pattern: self.lower_const_expr(expr, pat_id, span)\n+                        }\n+                    }).collect()\n+                }\n+            }\n+\n+            hir::ExprCall(ref callee, ref args) => {\n+                let qpath = match callee.node {\n+                    hir::ExprPath(ref qpath) => qpath,\n+                    _ => bug!()\n+                };\n+                let def = self.tcx.tables().qpath_def(qpath, callee.id);\n+                match def {\n+                    Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n+                    _ => {\n+                        let subpatterns = args.iter().enumerate().map(|(i, expr)| {\n+                            FieldPattern {\n+                                field: Field::new(i),\n+                                pattern: self.lower_const_expr(expr, pat_id, span)\n+                            }\n+                        }).collect();\n+                        self.lower_variant_or_leaf(def, subpatterns)\n+                    }\n+                }\n+            }\n+\n+            hir::ExprStruct(ref qpath, ref fields, None) => {\n+                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n+                let pat_ty = self.tcx.tables().node_id_to_type(expr.id);\n+                let adt_def = match pat_ty.sty {\n+                    ty::TyAdt(adt_def, _) => adt_def,\n+                    _ => {\n+                        span_bug!(\n+                            expr.span,\n+                            \"struct expr without ADT type\");\n+                    }\n+                };\n+                let variant_def = adt_def.variant_of_def(def);\n+\n+                let subpatterns =\n+                    fields.iter()\n+                          .map(|field| {\n+                              let index = variant_def.index_of_field_named(field.name.node);\n+                              let index = index.unwrap_or_else(|| {\n+                                  span_bug!(\n+                                      expr.span,\n+                                      \"no field with name {:?}\",\n+                                      field.name);\n+                              });\n+                              FieldPattern {\n+                                  field: Field::new(index),\n+                                  pattern: self.lower_const_expr(&field.expr, pat_id, span),\n+                              }\n+                          })\n+                          .collect();\n+\n+                self.lower_variant_or_leaf(def, subpatterns)\n+            }\n+\n+            hir::ExprArray(ref exprs) => {\n+                let pats = exprs.iter()\n+                                .map(|expr| self.lower_const_expr(expr, pat_id, span))\n+                                .collect();\n+                PatternKind::Array {\n+                    prefix: pats,\n+                    slice: None,\n+                    suffix: vec![]\n+                }\n+            }\n+\n+            hir::ExprPath(ref qpath) => {\n+                return self.lower_path(qpath, expr.id, pat_id, span);\n+            }\n+\n+            _ => self.lower_lit(expr)\n+        };\n+\n+        Pattern {\n+            span: span,\n+            ty: pat_ty,\n+            kind: Box::new(kind),\n+        }\n+    }\n }\n \n pub trait PatternFoldable<'tcx> : Sized {"}]}