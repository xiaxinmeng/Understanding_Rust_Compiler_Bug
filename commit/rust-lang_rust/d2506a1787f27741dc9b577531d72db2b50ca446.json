{"sha": "d2506a1787f27741dc9b577531d72db2b50ca446", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNTA2YTE3ODdmMjc3NDFkYzliNTc3NTMxZDcyZGIyYjUwY2E0NDY=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-18T19:08:42Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-26T23:20:24Z"}, "message": "test: Add a test for auto_serialize2", "tree": {"sha": "7fe9ddbba7197eccb1e232e659b62ffb3b550d8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fe9ddbba7197eccb1e232e659b62ffb3b550d8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2506a1787f27741dc9b577531d72db2b50ca446", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2506a1787f27741dc9b577531d72db2b50ca446", "html_url": "https://github.com/rust-lang/rust/commit/d2506a1787f27741dc9b577531d72db2b50ca446", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2506a1787f27741dc9b577531d72db2b50ca446/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ba9d2a888aeb8978d94050bf01e6b68271fd82e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba9d2a888aeb8978d94050bf01e6b68271fd82e", "html_url": "https://github.com/rust-lang/rust/commit/2ba9d2a888aeb8978d94050bf01e6b68271fd82e"}], "stats": {"total": 152, "additions": 152, "deletions": 0}, "files": [{"sha": "da48de2ffabaf1eb1c8db6ac716dd430425bac20", "filename": "src/test/run-pass/auto_serialize2.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/d2506a1787f27741dc9b577531d72db2b50ca446/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2506a1787f27741dc9b577531d72db2b50ca446/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize2.rs?ref=d2506a1787f27741dc9b577531d72db2b50ca446", "patch": "@@ -0,0 +1,152 @@\n+extern mod std;\n+\n+// These tests used to be separate files, but I wanted to refactor all\n+// the common code.\n+\n+use cmp::Eq;\n+use std::ebml2;\n+use io::Writer;\n+use std::serialization2::{Serializer, Serializable, deserialize};\n+use std::prettyprint2;\n+\n+fn test_ser_and_deser<A:Eq Serializable>(\n+    a1: A,\n+    expected: ~str\n+) {\n+\n+    // check the pretty printer:\n+    let s = io::with_str_writer(|w| a1.serialize(w));\n+    debug!(\"s == %?\", s);\n+    assert s == expected;\n+\n+    // check the EBML serializer:\n+    let bytes = do io::with_bytes_writer |wr| {\n+        let ebml_w = ebml2::Serializer(wr);\n+        a1.serialize(ebml_w)\n+    };\n+    let d = ebml2::Doc(@bytes);\n+    let a2: A = deserialize(ebml2::Deserializer(d));\n+    assert a1 == a2;\n+}\n+\n+#[auto_serialize2]\n+enum Expr {\n+    Val(uint),\n+    Plus(@Expr, @Expr),\n+    Minus(@Expr, @Expr)\n+}\n+\n+impl AnEnum : cmp::Eq {\n+    pure fn eq(&&other: AnEnum) -> bool {\n+        self.v == other.v\n+    }\n+    pure fn ne(&&other: AnEnum) -> bool { !self.eq(other) }\n+}\n+\n+impl Point : cmp::Eq {\n+    pure fn eq(&&other: Point) -> bool {\n+        self.x == other.x && self.y == other.y\n+    }\n+    pure fn ne(&&other: Point) -> bool { !self.eq(other) }\n+}\n+\n+impl<T:cmp::Eq> Quark<T> : cmp::Eq {\n+    pure fn eq(&&other: Quark<T>) -> bool {\n+        match self {\n+          Top(ref q) => match other {\n+            Top(ref r) => q == r,\n+            Bottom(_) => false\n+          },\n+          Bottom(ref q) => match other {\n+            Top(_) => false,\n+            Bottom(ref r) => q == r\n+          }\n+        }\n+    }\n+    pure fn ne(&&other: Quark<T>) -> bool { !self.eq(other) }\n+}\n+\n+impl CLike : cmp::Eq {\n+    pure fn eq(&&other: CLike) -> bool {\n+        self as int == other as int\n+    }\n+    pure fn ne(&&other: CLike) -> bool { !self.eq(other) }\n+}\n+\n+impl Expr : cmp::Eq {\n+    pure fn eq(&&other: Expr) -> bool {\n+        match self {\n+            Val(e0a) => {\n+                match other {\n+                    Val(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n+            Plus(e0a, e1a) => {\n+                match other {\n+                    Plus(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+            Minus(e0a, e1a) => {\n+                match other {\n+                    Minus(e0b, e1b) => e0a == e0b && e1a == e1b,\n+                    _ => false\n+                }\n+            }\n+        }\n+    }\n+    pure fn ne(&&other: Expr) -> bool { !self.eq(other) }\n+}\n+\n+#[auto_serialize2]\n+type Spanned<T> = {lo: uint, hi: uint, node: T};\n+\n+impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n+    pure fn eq(&&other: Spanned<T>) -> bool {\n+        self.lo == other.lo && self.hi == other.hi && self.node.eq(other.node)\n+    }\n+    pure fn ne(&&other: Spanned<T>) -> bool { !self.eq(other) }\n+}\n+\n+#[auto_serialize2]\n+type SomeRec = {v: ~[uint]};\n+\n+#[auto_serialize2]\n+enum AnEnum = SomeRec;\n+\n+#[auto_serialize2]\n+type Point = {x: uint, y: uint};\n+\n+#[auto_serialize2]\n+enum Quark<T> {\n+    Top(T),\n+    Bottom(T)\n+}\n+\n+#[auto_serialize2]\n+enum CLike { A, B, C }\n+\n+fn main() {\n+\n+    test_ser_and_deser(Plus(@Minus(@Val(3u), @Val(10u)),\n+                            @Plus(@Val(22u), @Val(5u))),\n+                       ~\"Plus(@Minus(@Val(3u), @Val(10u)), \\\n+                        @Plus(@Val(22u), @Val(5u)))\");\n+\n+    test_ser_and_deser({lo: 0u, hi: 5u, node: 22u},\n+                       ~\"{lo: 0u, hi: 5u, node: 22u}\");\n+\n+    test_ser_and_deser(AnEnum({v: ~[1u, 2u, 3u]}),\n+                       ~\"AnEnum({v: [1u, 2u, 3u]})\");\n+\n+    test_ser_and_deser({x: 3u, y: 5u}, ~\"{x: 3u, y: 5u}\");\n+\n+    test_ser_and_deser(~[1u, 2u, 3u], ~\"[1u, 2u, 3u]\");\n+\n+    test_ser_and_deser(Top(22u), ~\"Top(22u)\");\n+    test_ser_and_deser(Bottom(222u), ~\"Bottom(222u)\");\n+\n+    test_ser_and_deser(A, ~\"A\");\n+    test_ser_and_deser(B, ~\"B\");\n+}"}]}