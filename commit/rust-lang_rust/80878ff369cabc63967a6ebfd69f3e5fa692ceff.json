{"sha": "80878ff369cabc63967a6ebfd69f3e5fa692ceff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwODc4ZmYzNjljYWJjNjM5NjdhNmViZmQ2OWYzZTVmYTY5MmNlZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-11T19:21:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-11T19:21:20Z"}, "message": "auto merge of #9809 : fhahn/rust/remove-old-cratemap-code, r=alexcrichton\n\nThis patch removes the code responsible for handling older CrateMap versions (as discussed during #9593). Only the new (safer) layout is supported now.", "tree": {"sha": "7a0ffc8513828f65642e43d8ad4a9e6d4508ffb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a0ffc8513828f65642e43d8ad4a9e6d4508ffb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80878ff369cabc63967a6ebfd69f3e5fa692ceff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80878ff369cabc63967a6ebfd69f3e5fa692ceff", "html_url": "https://github.com/rust-lang/rust/commit/80878ff369cabc63967a6ebfd69f3e5fa692ceff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80878ff369cabc63967a6ebfd69f3e5fa692ceff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c147ec6d06b19b6e84f488212d7775b5eb937754", "url": "https://api.github.com/repos/rust-lang/rust/commits/c147ec6d06b19b6e84f488212d7775b5eb937754", "html_url": "https://github.com/rust-lang/rust/commit/c147ec6d06b19b6e84f488212d7775b5eb937754"}, {"sha": "f3b1f79716394a91afa179ee27620679c4651228", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3b1f79716394a91afa179ee27620679c4651228", "html_url": "https://github.com/rust-lang/rust/commit/f3b1f79716394a91afa179ee27620679c4651228"}], "stats": {"total": 180, "additions": 10, "deletions": 170}, "files": [{"sha": "8785dcca7bdbf5bf57b5ed01793d42bb8856e380", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 10, "deletions": 170, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/80878ff369cabc63967a6ebfd69f3e5fa692ceff/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80878ff369cabc63967a6ebfd69f3e5fa692ceff/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=80878ff369cabc63967a6ebfd69f3e5fa692ceff", "patch": "@@ -13,45 +13,13 @@ use hashmap::HashSet;\n use option::{Some, None, Option};\n use vec::ImmutableVector;\n \n-/// Imports for old crate map versions\n-use cast::transmute;\n-use libc::c_char;\n-use ptr;\n-use str::raw::from_c_str;\n-use vec;\n-\n // Need to tell the linker on OS X to not barf on undefined symbols\n // and instead look them up at runtime, which we need to resolve\n // the crate_map properly.\n #[cfg(target_os = \"macos\")]\n #[link_args = \"-undefined dynamic_lookup\"]\n extern {}\n \n-#[cfg(not(windows))]\n-extern {\n-    #[weak_linkage]\n-    #[link_name = \"_rust_crate_map_toplevel\"]\n-    static CRATE_MAP: CrateMap<'static>;\n-}\n-\n-/// structs for old crate map versions\n-pub struct ModEntryV0 {\n-    name: *c_char,\n-    log_level: *mut u32\n-}\n-pub struct CrateMapV0 {\n-    entries: *ModEntryV0,\n-    children: [*CrateMapV0, ..1]\n-}\n-\n-pub struct CrateMapV1 {\n-    version: i32,\n-    entries: *ModEntryV0,\n-    /// a dynamically sized struct, where all pointers to children are listed adjacent\n-    /// to the struct, terminated with NULL\n-    children: [*CrateMapV1, ..1]\n-}\n-\n pub struct ModEntry<'self> {\n     name: &'self str,\n     log_level: *mut u32\n@@ -65,6 +33,12 @@ pub struct CrateMap<'self> {\n \n #[cfg(not(windows))]\n pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n+    extern {\n+        #[weak_linkage]\n+        #[link_name = \"_rust_crate_map_toplevel\"]\n+        static CRATE_MAP: CrateMap<'static>;\n+    }\n+\n     let ptr: (*CrateMap) = &'static CRATE_MAP;\n     if ptr.is_null() {\n         return None;\n@@ -77,6 +51,7 @@ pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n #[fixed_stack_segment]\n #[inline(never)]\n pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n+    use cast::transmute;\n     use c_str::ToCStr;\n     use unstable::dynamic_lib::dl;\n \n@@ -101,54 +76,23 @@ pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n fn version(crate_map: &CrateMap) -> i32 {\n     match crate_map.version {\n         2 => return 2,\n-        1 => return 1,\n         _ => return 0\n     }\n }\n \n-fn iter_module_map(mod_entries: &[ModEntry], f: &fn(&ModEntry)) {\n-    for entry in mod_entries.iter() {\n-        f(entry);\n-    }\n-}\n-\n-unsafe fn iter_module_map_v0(entries: *ModEntryV0, f: &fn(&ModEntry)) {\n-    let mut curr = entries;\n-    while !(*curr).name.is_null() {\n-        let mod_entry = ModEntry { name: from_c_str((*curr).name), log_level: (*curr).log_level };\n-        f(&mod_entry);\n-        curr = curr.offset(1);\n-    }\n-}\n-\n fn do_iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry),\n                             visited: &mut HashSet<*CrateMap<'a>>) {\n     if visited.insert(crate_map as *CrateMap) {\n         match version(crate_map) {\n             2 => {\n                 let (entries, children) = (crate_map.entries, crate_map.children);\n-                iter_module_map(entries, |x| f(x));\n+                for entry in entries.iter() {\n+                    f(entry);\n+                }\n                 for child in children.iter() {\n                     do_iter_crate_map(*child, |x| f(x), visited);\n                 }\n             },\n-            // code for old crate map versions\n-            1 => unsafe {\n-                let v1: *CrateMapV1 = transmute(crate_map);\n-                iter_module_map_v0((*v1).entries, |x| f(x));\n-                let children = vec::raw::to_ptr((*v1).children);\n-                do ptr::array_each(children) |child| {\n-                    do_iter_crate_map(transmute(child), |x| f(x), visited);\n-                }\n-            },\n-            0 => unsafe {\n-                let v0: *CrateMapV0 = transmute(crate_map);\n-                iter_module_map_v0((*v0).entries, |x| f(x));\n-                let children = vec::raw::to_ptr((*v0).children);\n-                do ptr::array_each(children) |child| {\n-                    do_iter_crate_map(transmute(child), |x| f(x), visited);\n-                }\n-            },\n             _ => fail2!(\"invalid crate map version\")\n         }\n     }\n@@ -234,108 +178,4 @@ mod tests {\n             assert!(cnt == 4);\n         }\n     }\n-\n-\n-    /// Tests for old crate map versions\n-    #[test]\n-    fn iter_crate_map_duplicates_v1() {\n-        use c_str::ToCStr;\n-        use cast::transmute;\n-        use ptr;\n-        use rt::crate_map::{CrateMapV1, ModEntryV0, iter_crate_map};\n-        use vec;\n-\n-        struct CrateMapT3 {\n-            version: i32,\n-            entries: *ModEntryV0,\n-            children: [*CrateMapV1, ..3]\n-        }\n-\n-        unsafe {\n-            let mod_name1 = \"c::m1\".to_c_str();\n-            let mut level3: u32 = 3;\n-\n-            let entries: ~[ModEntryV0] = ~[\n-                ModEntryV0 { name: mod_name1.with_ref(|buf| buf), log_level: &mut level3},\n-                ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n-            ];\n-            let child_crate = CrateMapV1 {\n-                version: 1,\n-                entries: vec::raw::to_ptr(entries),\n-                children: [ptr::null()]\n-            };\n-\n-            let root_crate = CrateMapT3 {\n-                version: 1,\n-                entries: vec::raw::to_ptr([\n-                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n-                ]),\n-                children: [&child_crate as *CrateMapV1, &child_crate as *CrateMapV1, ptr::null()]\n-            };\n-\n-            let mut cnt = 0;\n-            do iter_crate_map(transmute(&root_crate)) |entry| {\n-                assert!(*(*entry).log_level == 3);\n-                cnt += 1;\n-            }\n-            assert!(cnt == 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn iter_crate_map_follow_children_v1() {\n-        use c_str::ToCStr;\n-        use cast::transmute;\n-        use ptr;\n-        use rt::crate_map::{CrateMapV1, ModEntryV0, iter_crate_map};\n-        use vec;\n-\n-        struct CrateMapT2 {\n-            version: i32,\n-            entries: *ModEntryV0,\n-            children: [*CrateMapV1, ..2]\n-        }\n-\n-        unsafe {\n-            let mod_name1 = \"c::m1\".to_c_str();\n-            let mod_name2 = \"c::m2\".to_c_str();\n-            let mut level2: u32 = 2;\n-            let mut level3: u32 = 3;\n-            let child_crate2 = CrateMapV1 {\n-                version: 1,\n-                entries: vec::raw::to_ptr([\n-                    ModEntryV0 { name: mod_name1.with_ref(|buf| buf), log_level: &mut level2},\n-                    ModEntryV0 { name: mod_name2.with_ref(|buf| buf), log_level: &mut level3},\n-                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n-                ]),\n-                children: [ptr::null()]\n-            };\n-\n-            let child_crate1 = CrateMapT2 {\n-                version: 1,\n-                entries: vec::raw::to_ptr([\n-                    ModEntryV0 { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 1},\n-                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n-                ]),\n-                children: [&child_crate2 as *CrateMapV1, ptr::null()]\n-            };\n-\n-            let child_crate1_ptr: *CrateMapV1 = transmute(&child_crate1);\n-            let root_crate = CrateMapT2 {\n-                version: 1,\n-                entries: vec::raw::to_ptr([\n-                    ModEntryV0 { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 0},\n-                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n-                ]),\n-                children: [child_crate1_ptr, ptr::null()]\n-            };\n-\n-            let mut cnt = 0;\n-            do iter_crate_map(transmute(&root_crate)) |entry| {\n-                assert!(*(*entry).log_level == cnt);\n-                cnt += 1;\n-            }\n-            assert!(cnt == 4);\n-        }\n-    }\n }"}]}