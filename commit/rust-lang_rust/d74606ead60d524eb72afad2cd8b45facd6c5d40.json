{"sha": "d74606ead60d524eb72afad2cd8b45facd6c5d40", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NDYwNmVhZDYwZDUyNGViNzJhZmFkMmNkOGI0NWZhY2Q2YzVkNDA=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-23T16:25:16Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-26T13:59:17Z"}, "message": "pre-rebase commit", "tree": {"sha": "55c4d07b5e67f9576fb496a0e24b67600504324e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55c4d07b5e67f9576fb496a0e24b67600504324e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d74606ead60d524eb72afad2cd8b45facd6c5d40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d74606ead60d524eb72afad2cd8b45facd6c5d40", "html_url": "https://github.com/rust-lang/rust/commit/d74606ead60d524eb72afad2cd8b45facd6c5d40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d74606ead60d524eb72afad2cd8b45facd6c5d40/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "624a685283f66afcb40ee3c235624aedebc2f08f", "url": "https://api.github.com/repos/rust-lang/rust/commits/624a685283f66afcb40ee3c235624aedebc2f08f", "html_url": "https://github.com/rust-lang/rust/commit/624a685283f66afcb40ee3c235624aedebc2f08f"}], "stats": {"total": 220, "additions": 119, "deletions": 101}, "files": [{"sha": "28f76125746c4f0cbce077a221ce8e6423333f91", "filename": "src/libcore/str.rs", "status": "modified", "additions": 102, "deletions": 99, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/d74606ead60d524eb72afad2cd8b45facd6c5d40/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74606ead60d524eb72afad2cd8b45facd6c5d40/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d74606ead60d524eb72afad2cd8b45facd6c5d40", "patch": "@@ -56,15 +56,15 @@ pub fn from_slice(s: &str) -> ~str {\n \n impl ToStr for ~str {\n     #[inline(always)]\n-    fn to_str(&self) -> ~str { copy *self }\n+    fn to_str(&self) -> ~str { from_slice(*self) }\n }\n impl ToStr for &'self str {\n     #[inline(always)]\n-    fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+    fn to_str(&self) -> ~str { from_slice(*self) }\n }\n impl ToStr for @str {\n     #[inline(always)]\n-    fn to_str(&self) -> ~str { ::str::from_slice(*self) }\n+    fn to_str(&self) -> ~str { from_slice(*self) }\n }\n \n /**\n@@ -383,7 +383,7 @@ Section: Transforming strings\n */\n \n /**\n- * Converts a string to a vector of bytes\n+ * Converts a string to a unique vector of bytes\n  *\n  * The result vector is not null-terminated.\n  */\n@@ -403,22 +403,19 @@ pub fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n     }\n }\n \n-/// Convert a string to a vector of characters\n-pub fn chars(s: &str) -> ~[char] {\n-    let mut buf = ~[], i = 0;\n-    let len = len(s);\n-    while i < len {\n-        let CharRange {ch, next} = char_range_at(s, i);\n-        unsafe { buf.push(ch); }\n-        i = next;\n+/// Convert a string to a unique vector of characters\n+pub fn to_chars(s: &str) -> ~[char] {\n+    let mut buf = ~[];\n+    for each_char(s) |c| {\n+        buf.push(c);\n     }\n     buf\n }\n \n /**\n  * Take a substring of another.\n  *\n- * Returns a string containing `n` characters starting at byte offset\n+ * Returns a slice pointing at `n` characters starting from byte offset\n  * `begin`.\n  */\n pub fn substr(s: &'a str, begin: uint, n: uint) -> &'a str {\n@@ -437,10 +434,17 @@ pub fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n-/// Splits a string into substrings at each occurrence of a given\n-/// character.\n-pub fn split_char(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), true, true)\n+/// Splits a string into substrings at each occurrence of a given character\n+pub fn each_split_char(s: &str, sep: char, it: &fn(&str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), true, true, it)\n+}\n+\n+/**\n+ * Like `split_char`, but a trailing empty string is omitted\n+ * (e.g. `split_char_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n+ */\n+pub fn each_split_char_no_trailing(s: &str, sep: char, it: &fn(&str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), true, false, it)\n }\n \n /**\n@@ -449,35 +453,25 @@ pub fn split_char(s: &str, sep: char) -> ~[~str] {\n  *\n  * The byte must be a valid UTF-8/ASCII byte\n  */\n-pub fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n-    split_char_inner(s, sep, count, true, true)\n+pub fn each_splitn_char(s: &str, sep: char, count: uint, it: &fn(&str) -> bool) {\n+    each_split_char_inner(s, sep, count, true, true, it)\n }\n \n /// Like `split_char`, but omits empty strings from the returned vector\n-pub fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), false, false)\n-}\n-\n-/**\n- * Like `split_char`, but a trailing empty string is omitted\n- * (e.g. `split_char_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n- */\n-pub fn split_char_no_trailing(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), true, false)\n+pub fn each_split_char_nonempty(s: &str, sep: char, it: &fn(&str) -> bool) {\n+    each_split_char_inner(s, sep, len(s), false, false, it)\n }\n \n-fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n-                    allow_trailing_empty: bool) -> ~[~str] {\n+fn each_split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n+                         allow_trailing_empty: bool), it: &fn(&str) -> bool) {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n-        let mut result = ~[], done = 0u;\n+        let mut done = 0u;\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n                 if allow_empty || start < i {\n-                    unsafe {\n-                        result.push(raw::slice_bytes_unique(s, start, i));\n-                    }\n+                    if !it( unsafe{ raw::slice_bytes(s, start, i) } ) { return; }\n                 }\n                 start = i + 1u;\n                 done += 1u;\n@@ -486,68 +480,57 @@ fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n         }\n         // only push a non-empty trailing substring\n         if allow_trailing_empty || start < l {\n-            unsafe { result.push(raw::slice_bytes_unique(s, start, l) ) };\n+            if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return; }\n         }\n-        result\n     } else {\n-        split_inner(s, |cur| cur == sep, count, allow_empty, allow_trailing_empty)\n+        each_split_inner(s, |cur| cur == sep, count, allow_empty, allow_trailing_empty, it)\n     }\n }\n \n-\n /// Splits a string into substrings using a character function\n-pub fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), true, true)\n+pub fn each_split(s: &str, sepfn: &fn(char) -> bool, it: &fn(&str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), true, true, it)\n+}\n+\n+/**\n+ * Like `split`, but a trailing empty string is omitted\n+ * (e.g. `split_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n+ */\n+pub fn each_split_no_trailing(s: &str, sepfn: &fn(char) -> bool, it: &fn(&str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), true, false, it)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pub fn splitn(s: &str,\n-                   sepfn: &fn(char) -> bool,\n-                   count: uint)\n-                -> ~[~str] {\n-    split_inner(s, sepfn, count, true, true)\n+pub fn each_splitn(s: &str, sepfn: &fn(char) -> bool, count: uint, it: &fn(&str) -> bool) {\n+    each_split_inner(s, sepfn, count, true, true, it)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n-pub fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), false, false)\n-}\n-\n-\n-/**\n- * Like `split`, but a trailing empty string is omitted\n- * (e.g. `split_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n- */\n-pub fn split_no_trailing(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), true, false)\n+pub fn each_split_nonempty(s: &str, sepfn: &fn(char) -> bool, it: &fn(&str) -> bool) {\n+    each_split_inner(s, sepfn, len(s), false, false, it)\n }\n \n-fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool, allow_trailing_empty: bool) -> ~[~str] {\n+pure fn each_split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n+               allow_empty: bool, allow_trailing_empty: bool), it: &fn(&str) -> bool) {\n     let l = len(s);\n-    let mut result = ~[], i = 0u, start = 0u, done = 0u;\n+    let mut i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n         let CharRange {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n             if allow_empty || start < i {\n-                unsafe {\n-                    result.push(raw::slice_bytes_unique(s, start, i));\n-                }\n+                if !it( unsafe{ raw::slice_bytes(s, start, i) } ) { return; }\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n     if allow_trailing_empty || start < l {\n-        unsafe {\n-            result.push(raw::slice_bytes_unique(s, start, l));\n-        }\n+        if !it( unsafe{ raw::slice_bytes(s, start, l) } ) { return;  }\n     }\n-    result\n }\n \n // See Issue #1932 for why this is a naive search\n@@ -596,22 +579,18 @@ fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n  * fail_unless!([\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\"))\n  * ~~~\n  */\n-pub fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n-    let mut result = ~[];\n+pub fn each_split_str(s: &'a str, sep: &'b str, it: &fn(&str) -> bool) {\n     do iter_between_matches(s, sep) |from, to| {\n-        unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n+        if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n     }\n-    result\n }\n \n-pub fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n-    let mut result = ~[];\n+pub fn each_split_str_nonempty(s: &'a str, sep: &'b str, it: &fn(&str) -> bool) {\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n-            unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n+            if !it( unsafe { raw::slice_bytes(s, from, to) } ) { return; }\n         }\n     }\n-    result\n }\n \n /// Levenshtein Distance between two strings\n@@ -651,34 +630,32 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n').\n  */\n-pub fn lines(s: &str) -> ~[~str] {\n-    split_char_no_trailing(s, '\\n')\n-}\n+pub fn each_line(s: &str, it: &fn(&str) -> bool) { each_split_char(s, '\\n', it) }\n \n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-pub fn lines_any(s: &str) -> ~[~str] {\n-    vec::map(lines(s), |s| {\n-        let l = len(*s);\n-        let mut cp = copy *s;\n+pub fn each_line_any(s: &str, it: &fn(&str) -> bool) {\n+    for each_line(s) |s| {\n+        let l = s.len();\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n-            unsafe { raw::set_len(&mut cp, l - 1u); }\n+            if !it( unsafe { raw::slice_bytes(s, 0, l - 1) } ) { return; }\n+        } else {\n+            if !it( s ) { return; }\n         }\n-        cp\n-    })\n+    }\n }\n \n /// Splits a string into a vector of the substrings separated by whitespace\n-pub fn words(s: &str) -> ~[~str] {\n-    split_nonempty(s, char::is_whitespace)\n+pub fn each_word(s: &str, it: &fn(&str) -> bool) {\n+    each_split_nonempty(s, |c| char::is_whitespace(c), it)\n }\n \n /** Split a string into a vector of substrings,\n- *  each of which is less than a limit\n+ *  each of which is less bytes long than a limit\n  */\n-pub fn split_within(ss: &str, lim: uint) -> ~[~str] {\n+pub fn each_split_within(ss: &str, lim: uint, it: &fn(&str) -> bool) {\n     let words = str::words(ss);\n \n     // empty?\n@@ -705,6 +682,22 @@ pub fn split_within(ss: &str, lim: uint) -> ~[~str] {\n     if row != ~\"\" { rows.push(row); }\n \n     rows\n+    // NOTE: Finish change here\n+\n+    let mut last_slice_i = 0, last_word_i = 0, word_start = true;\n+    for each_chari(s) |i, c| {\n+        if (i - last_slice_i) <= lim {\n+            if char::is_whitespace(c) {\n+\n+            } else {\n+\n+            }\n+        } else {\n+\n+        }\n+\n+\n+    }\n }\n \n \n@@ -997,10 +990,17 @@ pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) {\n     }\n }\n \n-/// Iterates over the chars in a string\n+\n+/// Iterate over each char of a string, without allocating\n #[inline(always)]\n pub fn each_char(s: &str, it: &fn(char) -> bool) {\n-    each_chari(s, |_i, c| it(c))\n+    let mut i = 0;\n+    let len = len(s);\n+    while i < len {\n+        let CharRange {ch, next} = char_range_at(s, i);\n+        if !it(ch) { return; }\n+        i = next;\n+    }\n }\n \n /// Iterates over the chars in a string, with indices\n@@ -1038,31 +1038,34 @@ pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) {\n     }\n }\n \n-/// Apply a function to each substring after splitting by character\n+/////////////////////////////////////////////////////////////////////////////////////////////////\n+// NOTE: Remove afterwards\n+/* /// Apply a function to each substring after splitting by character\n pub fn split_char_each(ss: &str, cc: char, ff: &fn(v: &str) -> bool) {\n     vec::each(split_char(ss, cc), |s| ff(*s))\n }\n \n-/**\n+**\n  * Apply a function to each substring after splitting by character, up to\n  * `count` times\n- */\n+ *\n pub fn splitn_char_each(ss: &str, sep: char, count: uint,\n                          ff: &fn(v: &str) -> bool) {\n     vec::each(splitn_char(ss, sep, count), |s| ff(*s))\n }\n \n-/// Apply a function to each word\n+/ Apply a function to each word\n pub fn words_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(words(ss), |s| ff(*s))\n }\n \n-/**\n+**\n  * Apply a function to each line (by '\\n')\n- */\n+ *\n pub fn lines_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(lines(ss), |s| ff(*s))\n-}\n+} */\n+/////////////////////////////////////////////////////////////////////////////////////////////////\n \n /*\n Section: Searching\n@@ -2511,7 +2514,7 @@ impl OwnedStr for ~str {\n impl Clone for ~str {\n     #[inline(always)]\n     fn clone(&self) -> ~str {\n-        self.to_str()  // hilarious\n+        from_slice(*self)\n     }\n }\n "}, {"sha": "f837f776b96ce80f9574db870f7b65da9b2e9483", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d74606ead60d524eb72afad2cd8b45facd6c5d40/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74606ead60d524eb72afad2cd8b45facd6c5d40/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=d74606ead60d524eb72afad2cd8b45facd6c5d40", "patch": "@@ -601,7 +601,7 @@ pub mod groups {\n             row += match short_name.len() {\n                 0 => ~\"\",\n                 1 => ~\"-\" + short_name + \" \",\n-                _ => fail!(~\"the short name should only be 1 char long\"),\n+                _ => fail!(~\"the short name should only be 1 ascii char long\"),\n             };\n \n             // long option\n@@ -617,6 +617,7 @@ pub mod groups {\n                 Maybe => ~\"[\" + hint + ~\"]\",\n             };\n \n+            // FIXME: #5516\n             // here we just need to indent the start of the description\n             let rowlen = row.len();\n             row += if rowlen < 24 {\n@@ -625,8 +626,22 @@ pub mod groups {\n                 desc_sep\n             };\n \n+            // Normalize desc to contain words seperated by one space character\n+            let mut desc_normalized_whitespace = ~str\n+            for desc.each_word |word| {\n+                desc_normalized_whitespace.push_str(word);\n+                desc_normalized_whitespace.push_char(' ');\n+            }\n+\n+            // FIXME: #5516\n+            let mut desc_rows: ~[~str] = ~[];\n+            for desc_normalized_whitespace.each_split_within(54) |substr| {\n+                desc_rows.push(~substr);\n+            }\n+\n+            // FIXME: #5516\n             // wrapped description\n-            row += str::connect(str::split_within(desc, 54), desc_sep);\n+            row += str::connect(desc_rows, desc_sep);\n \n             row\n         });"}]}