{"sha": "e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0N2QyZjYwNjA3MTQyZWFmNjhhMGM1NjBmNWMzZDM3ZmQxZGExM2Q=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-24T18:04:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-24T19:55:08Z"}, "message": "extend liveness to treat bindings more like other variables\n\nThis results in a lot of warnings in rustc.  I left them in because\nmany are bugs and we should fix our code, but Graydon asked that\nI not touch every file in the codebase.", "tree": {"sha": "945346c3472ce432a367fff3aa4dd0ffed61efe4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/945346c3472ce432a367fff3aa4dd0ffed61efe4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "html_url": "https://github.com/rust-lang/rust/commit/e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa024acae3912d7d58e38fdd8185a115f2ab4e8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa024acae3912d7d58e38fdd8185a115f2ab4e8f", "html_url": "https://github.com/rust-lang/rust/commit/aa024acae3912d7d58e38fdd8185a115f2ab4e8f"}], "stats": {"total": 183, "additions": 158, "deletions": 25}, "files": [{"sha": "1a2e36d081b87acd4b881e4c9103515330fcbc54", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "patch": "@@ -1450,8 +1450,10 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n             word_nbsp(s, ~\"ref\");\n             print_mutability(s, mutbl);\n           }\n+          ast::bind_by_move => {\n+            word_nbsp(s, ~\"move\");\n+          }\n           ast::bind_by_implicit_ref |\n-          ast::bind_by_move | // this is totally the wrong thing\n           ast::bind_by_value => {}\n         }\n         print_path(s, path, true);"}, {"sha": "1a26072532a885d7837ecc8d44565902af143fbf", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "patch": "@@ -52,7 +52,11 @@ enum lint {\n     vecs_implicitly_copyable,\n     deprecated_mode,\n     deprecated_pattern,\n-    non_camel_case_types\n+    non_camel_case_types,\n+\n+    // FIXME(#3266)--make liveness warnings lintable\n+    // unused_variable,\n+    // dead_assignment\n }\n \n fn level_to_str(lv: level) -> ~str {\n@@ -134,7 +138,19 @@ fn get_lint_dict() -> lint_dict {\n         (~\"non_camel_case_types\",\n          @{lint: non_camel_case_types,\n            desc: ~\"types, variants and traits must have camel case names\",\n-           default: allow})\n+           default: allow}),\n+\n+        /* FIXME(#3266)--make liveness warnings lintable\n+        (~\"unused_variable\",\n+         @{lint: unused_variable,\n+           desc: ~\"detect variables which are not used in any way\",\n+           default: warn}),\n+\n+        (~\"dead_assignment\",\n+         @{lint: dead_assignment,\n+           desc: ~\"detect assignments that will never be read\",\n+           default: warn}),\n+        */\n     ];\n     hash_from_strs(v)\n }"}, {"sha": "ee8c6c2baeca24918a96296d425da166b147299d", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 96, "deletions": 20, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "patch": "@@ -140,7 +140,8 @@ fn check_crate(tcx: ty::ctxt,\n     let visitor = visit::mk_vt(@{\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n-        visit_expr: visit_expr\n+        visit_expr: visit_expr,\n+        visit_arm: visit_arm,\n         with *visit::default_visitor()\n     });\n \n@@ -191,11 +192,17 @@ enum RelevantDef { RelevantVar(node_id), RelevantSelf }\n \n type CaptureInfo = {ln: LiveNode, is_move: bool, rv: RelevantDef};\n \n+enum LocalKind {\n+    FromMatch(binding_mode),\n+    FromLetWithInitializer,\n+    FromLetNoInitializer\n+}\n+\n struct LocalInfo {\n     id: node_id;\n     ident: ident;\n     is_mutbl: bool;\n-    initialized: bool;\n+    kind: LocalKind;\n }\n \n enum VarKind {\n@@ -209,7 +216,11 @@ enum VarKind {\n fn relevant_def(def: def) -> option<RelevantDef> {\n     match def {\n       def_self(_) => some(RelevantSelf),\n-      def_arg(nid, _) | def_local(nid, _) => some(RelevantVar(nid)),\n+\n+      def_binding(nid, _) |\n+      def_arg(nid, _) |\n+      def_local(nid, _) => some(RelevantVar(nid)),\n+\n       _ => none\n     }\n }\n@@ -329,7 +340,16 @@ impl IrMaps {\n         match vk {\n           Arg(id, name, by_move) |\n           Arg(id, name, by_copy) |\n-          Local(LocalInfo {id:id, ident:name, _}) => {\n+          Local(LocalInfo {id:id, ident:name,\n+                           kind: FromLetNoInitializer, _}) |\n+          Local(LocalInfo {id:id, ident:name,\n+                           kind: FromLetWithInitializer, _}) |\n+          Local(LocalInfo {id:id, ident:name,\n+                           kind: FromMatch(bind_by_value), _}) |\n+          Local(LocalInfo {id:id, ident:name,\n+                           kind: FromMatch(bind_by_ref(_)), _}) |\n+          Local(LocalInfo {id:id, ident:name,\n+                           kind: FromMatch(bind_by_move), _}) => {\n             let v = match self.last_use_map.find(expr_id) {\n               some(v) => v,\n               none => {\n@@ -342,7 +362,8 @@ impl IrMaps {\n             (*v).push(id);\n           }\n           Arg(_, _, by_ref) | Arg(_, _, by_mutbl_ref) |\n-          Arg(_, _, by_val) | Self | Field(_) | ImplicitRet => {\n+          Arg(_, _, by_val) | Self | Field(_) | ImplicitRet |\n+          Local(LocalInfo {kind: FromMatch(bind_by_implicit_ref), _}) => {\n             debug!(\"--but it is not owned\");\n           }\n         }\n@@ -396,7 +417,8 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     let check_vt = visit::mk_vt(@{\n         visit_fn: check_fn,\n         visit_local: check_local,\n-        visit_expr: check_expr\n+        visit_expr: check_expr,\n+        visit_arm: check_arm,\n         with *visit::default_visitor()\n     });\n     check_vt.visit_block(body, lsets, check_vt);\n@@ -419,16 +441,39 @@ fn visit_local(local: @local, &&self: @IrMaps, vt: vt<@IrMaps>) {\n         debug!(\"adding local variable %d\", p_id);\n         let name = ast_util::path_to_ident(path);\n         self.add_live_node_for_node(p_id, VarDefNode(sp));\n+        let kind = match local.node.init {\n+          some(_) => FromLetWithInitializer,\n+          none => FromLetNoInitializer\n+        };\n         self.add_variable(Local(LocalInfo {\n-            id: p_id,\n-            ident: name,\n-            is_mutbl: local.node.is_mutbl,\n-            initialized: local.node.init.is_some()\n+          id: p_id,\n+          ident: name,\n+          is_mutbl: local.node.is_mutbl,\n+          kind: kind\n         }));\n     }\n     visit::visit_local(local, self, vt);\n }\n \n+fn visit_arm(arm: arm, &&self: @IrMaps, vt: vt<@IrMaps>) {\n+    let def_map = self.tcx.def_map;\n+    for arm.pats.each |pat| {\n+        do pat_util::pat_bindings(def_map, pat) |bm, p_id, sp, path| {\n+            debug!(\"adding local variable %d from match with bm %?\",\n+                   p_id, bm);\n+            let name = ast_util::path_to_ident(path);\n+            self.add_live_node_for_node(p_id, VarDefNode(sp));\n+            self.add_variable(Local(LocalInfo {\n+                id: p_id,\n+                ident: name,\n+                is_mutbl: false,\n+                kind: FromMatch(bm)\n+            }));\n+        }\n+    }\n+    visit::visit_arm(arm, self, vt);\n+}\n+\n fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n@@ -612,6 +657,30 @@ impl Liveness {\n         }\n     }\n \n+    fn arm_pats_bindings(pats: &[@pat], f: fn(LiveNode, Variable, span)) {\n+        // only consider the first pattern; any later patterns must have\n+        // the same bindings, and we also consider the first pattern to be\n+        // the \"authoratative\" set of ids\n+        if !pats.is_empty() {\n+            self.pat_bindings(pats[0], f)\n+        }\n+    }\n+\n+    fn define_bindings_in_pat(pat: @pat, succ: LiveNode) -> LiveNode {\n+        self.define_bindings_in_arm_pats([pat], succ)\n+    }\n+\n+    fn define_bindings_in_arm_pats(pats: &[@pat],\n+                                   succ: LiveNode) -> LiveNode {\n+        let mut succ = succ;\n+        do self.arm_pats_bindings(pats) |ln, var, _sp| {\n+            self.init_from_succ(ln, succ);\n+            self.define(ln, var);\n+            succ = ln;\n+        }\n+        succ\n+    }\n+\n     fn idx(ln: LiveNode, var: Variable) -> uint {\n         *ln * self.ir.num_vars + *var\n     }\n@@ -894,13 +963,8 @@ impl Liveness {\n         // once at the func header but otherwise equivalent.\n \n         let opt_init = local.node.init.map(|i| i.expr );\n-        let mut succ = self.propagate_through_opt_expr(opt_init, succ);\n-        do self.pat_bindings(local.node.pat) |ln, var, _sp| {\n-            self.init_from_succ(ln, succ);\n-            self.define(ln, var);\n-            succ = ln;\n-        }\n-        succ\n+        let succ = self.propagate_through_opt_expr(opt_init, succ);\n+        self.define_bindings_in_pat(local.node.pat, succ)\n     }\n \n     fn propagate_through_exprs(exprs: ~[@expr],\n@@ -1003,10 +1067,12 @@ impl Liveness {\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n             for arms.each |arm| {\n+                let body_succ =\n+                    self.propagate_through_block(arm.body, succ);\n+                let guard_succ =\n+                    self.propagate_through_opt_expr(arm.guard, body_succ);\n                 let arm_succ =\n-                    self.propagate_through_opt_expr(\n-                        arm.guard,\n-                        self.propagate_through_block(arm.body, succ));\n+                    self.define_bindings_in_arm_pats(arm.pats, guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n             };\n@@ -1409,6 +1475,13 @@ fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n     visit::visit_local(local, self, vt);\n }\n \n+fn check_arm(arm: arm, &&self: @Liveness, vt: vt<@Liveness>) {\n+    do self.arm_pats_bindings(arm.pats) |ln, var, sp| {\n+        self.warn_about_unused(sp, ln, var);\n+    }\n+    visit::visit_arm(arm, self, vt);\n+}\n+\n fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n     match expr.node {\n       expr_path(_) => {\n@@ -1798,10 +1871,12 @@ impl @Liveness {\n                 };\n \n                 if is_assigned {\n+                    // FIXME(#3266)--make liveness warnings lintable\n                     self.tcx.sess.span_warn(\n                         sp, fmt!(\"variable `%s` is assigned to, \\\n                                   but never used\", name));\n                 } else {\n+                    // FIXME(#3266)--make liveness warnings lintable\n                     self.tcx.sess.span_warn(\n                         sp, fmt!(\"unused variable: `%s`\", name));\n                 }\n@@ -1814,6 +1889,7 @@ impl @Liveness {\n     fn warn_about_dead_assign(sp: span, ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             for self.should_warn(var).each |name| {\n+                // FIXME(#3266)--make liveness warnings lintable\n                 self.tcx.sess.span_warn(\n                     sp,\n                     fmt!(\"value assigned to `%s` is never read\", name));"}, {"sha": "29a05ce5410a0b9c6eacc088cd6d87b4479c4fb7", "filename": "src/test/compile-fail/borrowck-issue-2657-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-issue-2657-1.rs?ref=e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n let x = some(~1);\n match x { //~ NOTE loan of immutable local variable granted here\n-  some(ref y) => {\n+  some(ref _y) => {\n     let _a <- x; //~ ERROR moving out of immutable local variable prohibited due to outstanding loan\n   }\n   _ => {}"}, {"sha": "9eb8a620da9d560a9b0b1a86545183904190d8ed", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "patch": "@@ -8,7 +8,7 @@ fn main() {\n         // fact no outstanding loan of x!\n         x = some(0);\n       }\n-      some(ref i) => {\n+      some(ref _i) => {\n         x = some(1); //~ ERROR assigning to mutable local variable prohibited due to outstanding loan\n       }\n     }"}, {"sha": "c0a3b8821da89c7703bae0f4d2dc3da7b2c5ae5e", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "patch": "@@ -29,11 +29,24 @@ fn f3b() {\n fn f4() {\n     match some(3) {\n       some(i) => {\n+        //~^ WARNING unused variable: `i`\n       }\n       none => {}\n     }\n }\n \n+enum tri {\n+    a(int), b(int), c(int)\n+}\n+\n+fn f4b() -> int {\n+    match a(3) {\n+      a(i) | b(i) | c(i) => {\n+        i\n+      }\n+    }\n+}\n+\n // leave this in here just to trigger compile-fail:\n struct r {\n     let x: ();"}, {"sha": "bbb8c3eb5c99d4a555f0ec85d779896a811e77ef", "filename": "src/test/run-pass/option-unwrap.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Ftest%2Frun-pass%2Foption-unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e47d2f60607142eaf68a0c560f5c3d37fd1da13d/src%2Ftest%2Frun-pass%2Foption-unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-unwrap.rs?ref=e47d2f60607142eaf68a0c560f5c3d37fd1da13d", "patch": "@@ -0,0 +1,26 @@\n+struct dtor {\n+    x: @mut int;\n+\n+    drop {\n+        // abuse access to shared mutable state to write this code\n+        *self.x -= 1;\n+    }\n+}\n+\n+fn unwrap<T>(+o: option<T>) -> T {\n+    match move o {\n+      some(move v) => v,\n+      none => fail\n+    }\n+}\n+\n+fn main() {\n+    let x = @mut 1;\n+\n+    {\n+        let b = some(dtor { x:x });\n+        let c = unwrap(b);\n+    }\n+\n+    assert *x == 0;\n+}\n\\ No newline at end of file"}]}