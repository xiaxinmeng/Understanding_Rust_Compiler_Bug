{"sha": "90c34fafcfa1d00ae25a165dc006e688761a5776", "node_id": "C_kwDOAAsO6NoAKDkwYzM0ZmFmY2ZhMWQwMGFlMjVhMTY1ZGMwMDZlNjg4NzYxYTU3NzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-27T22:41:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-27T22:41:47Z"}, "message": "Auto merge of #102377 - matthiaskrgr:rollup-1zvj50t, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #101555 (Stabilize `#![feature(mixed_integer_ops)]`)\n - #102253 (rustdoc: use CSS containment to speed up render)\n - #102281 (make invalid_value lint a bit smarter around enums)\n - #102284 (Structured suggestion for missing `mut`/`const` in raw pointer)\n - #102330 (rustdoc: remove no-op CSS `.srclink { font-weight; font-size }`)\n - #102337 (Avoid LLVM-deprecated `Optional::hasValue`)\n - #102356 (session: remove now-unnecessary lint `#[allow]`s)\n - #102367 (rustdoc: remove redundant `#help-button` CSS)\n - #102369 (Fix search result colors)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f954e73e2a2919ad277b97be0a9ea0d2b67f292c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f954e73e2a2919ad277b97be0a9ea0d2b67f292c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90c34fafcfa1d00ae25a165dc006e688761a5776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90c34fafcfa1d00ae25a165dc006e688761a5776", "html_url": "https://github.com/rust-lang/rust/commit/90c34fafcfa1d00ae25a165dc006e688761a5776", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90c34fafcfa1d00ae25a165dc006e688761a5776/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "470e518c4b43265020c882bcf3c86632f5494910", "url": "https://api.github.com/repos/rust-lang/rust/commits/470e518c4b43265020c882bcf3c86632f5494910", "html_url": "https://github.com/rust-lang/rust/commit/470e518c4b43265020c882bcf3c86632f5494910"}, {"sha": "f28ac30527b423d01f762bbf93aec0c6bd1adf52", "url": "https://api.github.com/repos/rust-lang/rust/commits/f28ac30527b423d01f762bbf93aec0c6bd1adf52", "html_url": "https://github.com/rust-lang/rust/commit/f28ac30527b423d01f762bbf93aec0c6bd1adf52"}], "stats": {"total": 888, "additions": 593, "deletions": 295}, "files": [{"sha": "146c4971348ea411dac25ee0bfdd9111f120c859", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 117, "deletions": 51, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -46,8 +46,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::Instance;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n@@ -2425,12 +2424,63 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             None\n         }\n \n-        /// Test if this enum has several actually \"existing\" variants.\n-        /// Zero-sized uninhabited variants do not always have a tag assigned and thus do not \"exist\".\n-        fn is_multi_variant<'tcx>(adt: ty::AdtDef<'tcx>) -> bool {\n-            // As an approximation, we only count dataless variants. Those are definitely inhabited.\n-            let existing_variants = adt.variants().iter().filter(|v| v.fields.is_empty()).count();\n-            existing_variants > 1\n+        /// Determines whether the given type is inhabited. `None` means that we don't know.\n+        fn ty_inhabited<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n+            use rustc_type_ir::sty::TyKind::*;\n+            if !cx.tcx.type_uninhabited_from(cx.param_env.and(ty)).is_empty() {\n+                // This is definitely uninhabited from some module.\n+                return Some(false);\n+            }\n+            match ty.kind() {\n+                Never => Some(false),\n+                Int(_) | Uint(_) | Float(_) | Bool | Char | RawPtr(_) => Some(true),\n+                // Fallback for more complicated types. (Note that `&!` might be considered\n+                // uninhabited so references are \"complicated\", too.)\n+                _ => None,\n+            }\n+        }\n+        /// Determines whether a product type formed from a list of types is inhabited.\n+        fn tys_inhabited<'tcx>(\n+            cx: &LateContext<'tcx>,\n+            tys: impl Iterator<Item = Ty<'tcx>>,\n+        ) -> Option<bool> {\n+            let mut definitely_inhabited = true; // with no fields, we are definitely inhabited.\n+            for ty in tys {\n+                match ty_inhabited(cx, ty) {\n+                    // If any type is uninhabited, the product is uninhabited.\n+                    Some(false) => return Some(false),\n+                    // Otherwise go searching for a `None`.\n+                    None => {\n+                        // We don't know.\n+                        definitely_inhabited = false;\n+                    }\n+                    Some(true) => {}\n+                }\n+            }\n+            if definitely_inhabited { Some(true) } else { None }\n+        }\n+\n+        fn variant_find_init_error<'tcx>(\n+            cx: &LateContext<'tcx>,\n+            variant: &VariantDef,\n+            substs: ty::SubstsRef<'tcx>,\n+            descr: &str,\n+            init: InitKind,\n+        ) -> Option<InitError> {\n+            variant.fields.iter().find_map(|field| {\n+                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(|(mut msg, span)| {\n+                    if span.is_none() {\n+                        // Point to this field, should be helpful for figuring\n+                        // out where the source of the error is.\n+                        let span = cx.tcx.def_span(field.did);\n+                        write!(&mut msg, \" (in this {descr})\").unwrap();\n+                        (msg, Some(span))\n+                    } else {\n+                        // Just forward.\n+                        (msg, span)\n+                    }\n+                })\n+            })\n         }\n \n         /// Return `Some` only if we are sure this type does *not*\n@@ -2468,14 +2518,15 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 RawPtr(_) if init == InitKind::Uninit => {\n                     Some((\"raw pointers must not be uninitialized\".to_string(), None))\n                 }\n-                // Recurse and checks for some compound types.\n+                // Recurse and checks for some compound types. (but not unions)\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n                     // First check if this ADT has a layout attribute (like `NonNull` and friends).\n                     use std::ops::Bound;\n                     match cx.tcx.layout_scalar_valid_range(adt_def.did()) {\n                         // We exploit here that `layout_scalar_valid_range` will never\n                         // return `Bound::Excluded`.  (And we have tests checking that we\n                         // handle the attribute correctly.)\n+                        // We don't add a span since users cannot declare such types anyway.\n                         (Bound::Included(lo), _) if lo > 0 => {\n                             return Some((format!(\"`{}` must be non-null\", ty), None));\n                         }\n@@ -2492,50 +2543,65 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         }\n                         _ => {}\n                     }\n-                    // Now, recurse.\n-                    match adt_def.variants().len() {\n-                        0 => Some((\"enums with no variants have no valid value\".to_string(), None)),\n-                        1 => {\n-                            // Struct, or enum with exactly one variant.\n-                            // Proceed recursively, check all fields.\n-                            let variant = &adt_def.variant(VariantIdx::from_u32(0));\n-                            variant.fields.iter().find_map(|field| {\n-                                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(\n-                                    |(mut msg, span)| {\n-                                        if span.is_none() {\n-                                            // Point to this field, should be helpful for figuring\n-                                            // out where the source of the error is.\n-                                            let span = cx.tcx.def_span(field.did);\n-                                            write!(\n-                                                &mut msg,\n-                                                \" (in this {} field)\",\n-                                                adt_def.descr()\n-                                            )\n-                                            .unwrap();\n-                                            (msg, Some(span))\n-                                        } else {\n-                                            // Just forward.\n-                                            (msg, span)\n-                                        }\n-                                    },\n-                                )\n-                            })\n-                        }\n-                        // Multi-variant enum.\n-                        _ => {\n-                            if init == InitKind::Uninit && is_multi_variant(*adt_def) {\n-                                let span = cx.tcx.def_span(adt_def.did());\n-                                Some((\n-                                    \"enums have to be initialized to a variant\".to_string(),\n-                                    Some(span),\n-                                ))\n-                            } else {\n-                                // In principle, for zero-initialization we could figure out which variant corresponds\n-                                // to tag 0, and check that... but for now we just accept all zero-initializations.\n-                                None\n-                            }\n+                    // Handle structs.\n+                    if adt_def.is_struct() {\n+                        return variant_find_init_error(\n+                            cx,\n+                            adt_def.non_enum_variant(),\n+                            substs,\n+                            \"struct field\",\n+                            init,\n+                        );\n+                    }\n+                    // And now, enums.\n+                    let span = cx.tcx.def_span(adt_def.did());\n+                    let mut potential_variants = adt_def.variants().iter().filter_map(|variant| {\n+                        let inhabited = tys_inhabited(\n+                            cx,\n+                            variant.fields.iter().map(|field| field.ty(cx.tcx, substs)),\n+                        );\n+                        let definitely_inhabited = match inhabited {\n+                            // Entirely skip uninhbaited variants.\n+                            Some(false) => return None,\n+                            // Forward the others, but remember which ones are definitely inhabited.\n+                            Some(true) => true,\n+                            None => false,\n+                        };\n+                        Some((variant, definitely_inhabited))\n+                    });\n+                    let Some(first_variant) = potential_variants.next() else {\n+                        return Some((\"enums with no inhabited variants have no valid value\".to_string(), Some(span)));\n+                    };\n+                    // So we have at least one potentially inhabited variant. Might we have two?\n+                    let Some(second_variant) = potential_variants.next() else {\n+                        // There is only one potentially inhabited variant. So we can recursively check that variant!\n+                        return variant_find_init_error(\n+                            cx,\n+                            &first_variant.0,\n+                            substs,\n+                            \"field of the only potentially inhabited enum variant\",\n+                            init,\n+                        );\n+                    };\n+                    // So we have at least two potentially inhabited variants.\n+                    // If we can prove that we have at least two *definitely* inhabited variants,\n+                    // then we have a tag and hence leaving this uninit is definitely disallowed.\n+                    // (Leaving it zeroed could be okay, depending on which variant is encoded as zero tag.)\n+                    if init == InitKind::Uninit {\n+                        let definitely_inhabited = (first_variant.1 as usize)\n+                            + (second_variant.1 as usize)\n+                            + potential_variants\n+                                .filter(|(_variant, definitely_inhabited)| *definitely_inhabited)\n+                                .count();\n+                        if definitely_inhabited > 1 {\n+                            return Some((\n+                                \"enums with multiple inhabited variants have to be initialized to a variant\".to_string(),\n+                                Some(span),\n+                            ));\n                         }\n                     }\n+                    // We couldn't find anything wrong here.\n+                    None\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields."}, {"sha": "879a3b660b4be68ad285ec1444de5abc41860fc9", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -1044,7 +1044,7 @@ extern \"C\" void LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n extern \"C\" void LLVMRustSetModuleCodeModel(LLVMModuleRef M,\n                                            LLVMRustCodeModel Model) {\n   auto CM = fromRust(Model);\n-  if (!CM.hasValue())\n+  if (!CM)\n     return;\n   unwrap(M)->setCodeModel(*CM);\n }"}, {"sha": "2a8512acf8cfac886ada546e0b01a72c387e99fb", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -397,10 +397,13 @@ impl<'a> Parser<'a> {\n     fn parse_ty_ptr(&mut self) -> PResult<'a, TyKind> {\n         let mutbl = self.parse_const_or_mut().unwrap_or_else(|| {\n             let span = self.prev_token.span;\n-            let msg = \"expected mut or const in raw pointer type\";\n-            self.struct_span_err(span, msg)\n-                .span_label(span, msg)\n-                .help(\"use `*mut T` or `*const T` as appropriate\")\n+            self.struct_span_err(span, \"expected `mut` or `const` keyword in raw pointer type\")\n+                .span_suggestions(\n+                    span.shrink_to_hi(),\n+                    \"add `mut` or `const` here\",\n+                    [\"mut \".to_string(), \"const \".to_string()].into_iter(),\n+                    Applicability::HasPlaceholders,\n+                )\n                 .emit();\n             Mutability::Not\n         });"}, {"sha": "aaf265ad7c336222be085dda70128938307c488d", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -376,8 +376,6 @@ impl ParseSess {\n     }\n \n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n-    #[allow(rustc::untranslatable_diagnostic)]\n     pub fn struct_err(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -386,22 +384,16 @@ impl ParseSess {\n     }\n \n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n-    #[allow(rustc::untranslatable_diagnostic)]\n     pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.span_diagnostic.struct_warn(msg)\n     }\n \n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n-    #[allow(rustc::untranslatable_diagnostic)]\n     pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         self.span_diagnostic.struct_fatal(msg)\n     }\n \n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n-    #[allow(rustc::untranslatable_diagnostic)]\n     pub fn struct_diagnostic<G: EmissionGuarantee>(\n         &self,\n         msg: impl Into<DiagnosticMessage>,"}, {"sha": "59b544ce9eb832266c836573788db0be232c737d", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -288,8 +288,6 @@ impl Session {\n     }\n \n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_span_warn<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -298,8 +296,6 @@ impl Session {\n         self.diagnostic().struct_span_warn(sp, msg)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_span_warn_with_expectation<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -309,8 +305,6 @@ impl Session {\n         self.diagnostic().struct_span_warn_with_expectation(sp, msg, id)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -320,14 +314,10 @@ impl Session {\n         self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_warn(msg)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_warn_with_expectation(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -336,8 +326,6 @@ impl Session {\n         self.diagnostic().struct_warn_with_expectation(msg, id)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_span_allow<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -346,14 +334,10 @@ impl Session {\n         self.diagnostic().struct_span_allow(sp, msg)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_allow(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_allow(msg)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_expect(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -362,8 +346,6 @@ impl Session {\n         self.diagnostic().struct_expect(msg, id)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -372,8 +354,6 @@ impl Session {\n         self.diagnostic().struct_span_err(sp, msg)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -384,17 +364,13 @@ impl Session {\n     }\n     // FIXME: This method should be removed (every error should have an associated error code).\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_err(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.parse_sess.struct_err(msg)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_err_with_code(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -403,8 +379,6 @@ impl Session {\n         self.diagnostic().struct_err_with_code(msg, code)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_warn_with_code(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -413,8 +387,6 @@ impl Session {\n         self.diagnostic().struct_warn_with_code(msg, code)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_span_fatal<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -423,8 +395,6 @@ impl Session {\n         self.diagnostic().struct_span_fatal(sp, msg)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -434,21 +404,15 @@ impl Session {\n         self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_fatal(msg)\n     }\n \n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.diagnostic().span_fatal(sp, msg)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -458,14 +422,10 @@ impl Session {\n         self.diagnostic().span_fatal_with_code(sp, msg, code)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn fatal(&self, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.diagnostic().fatal(msg).raise()\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_err_or_warn<S: Into<MultiSpan>>(\n         &self,\n         is_warning: bool,\n@@ -479,8 +439,6 @@ impl Session {\n         }\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -489,8 +447,6 @@ impl Session {\n         self.diagnostic().span_err(sp, msg)\n     }\n     #[rustc_lint_diagnostics]\n-    #[allow(rustc::untranslatable_diagnostic)]\n-    #[allow(rustc::diagnostic_outside_of_impl)]\n     pub fn span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,"}, {"sha": "c3df0d4f9b91a2e85d30090c3319e34f425789c6", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -195,7 +195,6 @@\n #![feature(link_llvm_intrinsics)]\n #![feature(macro_metavar_expr)]\n #![feature(min_specialization)]\n-#![feature(mixed_integer_ops)]\n #![feature(must_not_suspend)]\n #![feature(negative_impls)]\n #![feature(never_type)]"}, {"sha": "d6aeee299e30d8eac207e13903193816675e8e9c", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -464,12 +464,11 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_unsigned(2), Some(3));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_unsigned(3), None);\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -533,12 +532,11 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_unsigned(2), Some(-1));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub_unsigned(3), None);\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -907,12 +905,11 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_unsigned(2), 3);\")]\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add_unsigned(100), \", stringify!($SelfT), \"::MAX);\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -954,12 +951,11 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub_unsigned(127), -27);\")]\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub_unsigned(100), \", stringify!($SelfT), \"::MIN);\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1135,12 +1131,11 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add_unsigned(27), 127);\")]\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add_unsigned(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n@@ -1176,12 +1171,11 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub_unsigned(127), -127);\")]\n         #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), -1);\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline(always)]\n@@ -1574,13 +1568,12 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_unsigned(2), (3, false));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_add_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MAX, false));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_unsigned(3), (\", stringify!($SelfT), \"::MIN, true));\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1658,13 +1651,12 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_unsigned(2), (-1, false));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).overflowing_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MIN, false));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).overflowing_sub_unsigned(3), (\", stringify!($SelfT), \"::MAX, true));\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "46b0ca2303406df292efa4b2b6beffe5fb7692f3", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -474,13 +474,12 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1057,13 +1056,12 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1198,13 +1196,12 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1564,13 +1561,12 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n         /// ```\n-        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n-        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "ac5d0384d43dc22669ce41e696570450346b430f", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -294,7 +294,6 @@\n #![feature(is_some_with)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_write_slice)]\n-#![feature(mixed_integer_ops)]\n #![feature(nonnull_slice_from_raw_parts)]\n #![feature(panic_can_unwind)]\n #![feature(panic_info_message)]"}, {"sha": "c8ea5bef37a559e9bd6d0cc54987f145413011fb", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -132,7 +132,7 @@ h1, h2, h3, h4, h5, h6 {\n \tfont-weight: 500;\n }\n h1, h2, h3, h4 {\n-\tmargin: 20px 0 15px 0;\n+\tmargin: 25px 0 15px 0;\n \tpadding-bottom: 6px;\n }\n .docblock h3, .docblock h4, h5, h6 {\n@@ -176,8 +176,6 @@ h4.code-header {\n \tborder-bottom-style: none;\n \tmargin: 0;\n \tpadding: 0;\n-\tmargin-top: 0.6rem;\n-\tmargin-bottom: 0.4rem;\n }\n .impl,\n .impl-items .method,\n@@ -257,7 +255,9 @@ pre.rust a,\n }\n \n .content span.fn, .content a.fn,\n-.content .fnname {\n+.content .fnname,\n+.content span.method, .content a.method,\n+.content span.tymethod, .content a.tymethod {\n \tcolor: var(--function-link-color);\n }\n \n@@ -292,6 +292,11 @@ p {\n \t   https://www.w3.org/WAI/WCAG21/Understanding/visual-presentation.html */\n \tmargin: 0 0 .75em 0;\n }\n+/* For the last child of a div, the margin will be taken care of\n+\tby the margin-top of the next item. */\n+p:last-child {\n+\tmargin: 0;\n+}\n \n summary {\n \toutline: none;\n@@ -565,9 +570,16 @@ h2.location a {\n \n .rustdoc .example-wrap {\n \tdisplay: flex;\n-\tmargin-bottom: 10px;\n \tposition: relative;\n }\n+.rustdoc .example-wrap {\n+\tmargin-bottom: 10px;\n+}\n+/* For the last child of a div, the margin will be taken care of\n+\tby the margin-top of the next item. */\n+.rustdoc .example-wrap:last-child {\n+\tmargin-bottom: 0px;\n+}\n \n pre.example-line-numbers {\n \toverflow: initial;\n@@ -726,10 +738,6 @@ pre, .rustdoc.source .example-wrap {\n \tmargin-left: 24px;\n }\n \n-.content .impl-items .docblock, .content .impl-items .item-info {\n-\tmargin-bottom: .6em;\n-}\n-\n #main-content > .item-info {\n \tmargin-top: 0;\n \tmargin-left: 0;\n@@ -1019,8 +1027,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \tfont-size: 1.125rem;\n }\n #help-button span.top {\n-\ttext-align: center;\n-\tdisplay: block;\n \tmargin: 10px 0;\n \tborder-bottom: 1px solid var(--border-color);\n \tpadding-bottom: 4px;\n@@ -1030,9 +1036,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \tclear: both;\n \tborder-top: 1px solid var(--border-color);\n }\n-.side-by-side {\n-\ttext-align: initial;\n-}\n .side-by-side > div {\n \twidth: 50%;\n \tfloat: left;\n@@ -1110,13 +1113,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \tcolor: var(--right-side-color);\n }\n \n-\n-.impl-items .srclink, .impl .srclink, .methods .srclink {\n-\t/* Override header settings otherwise it's too bold */\n-\tfont-weight: normal;\n-\tfont-size: 1rem;\n-}\n-\n pre.rust .question-mark {\n \tfont-weight: bold;\n }\n@@ -1532,6 +1528,16 @@ details.dir-entry a {\n \tdisplay: block;\n }\n \n+/* We use CSS containment on the details elements because most sizeable elements\n+\tof the page are contained in one of these. This also makes re-rendering\n+\tfaster on document changes (like closing and opening toggles).\n+\tUnfortunately we can't yet specify contain: content or contain: strict\n+\tbecause the [-]/[+] toggles extend past the boundaries of the <details>\n+\thttps://developer.mozilla.org/en-US/docs/Web/CSS/contain */\n+details.rustdoc-toggle {\n+\tcontain: layout;\n+}\n+\n /* The hideme class is used on summary tags that contain a span with\n \tplaceholder text shown only when the toggle is closed. For instance,\n \t\"Expand description\" or \"Show methods\". */\n@@ -2012,17 +2018,17 @@ in storage.js plus the media query with (min-width: 701px)\n \tmargin-bottom: 0.75em;\n }\n \n-.method-toggle[open] {\n+.method-toggle[open]:not(:last-child) {\n \tmargin-bottom: 2em;\n }\n \n-.implementors-toggle[open]  {\n+.implementors-toggle[open]:not(:last-child) {\n \tmargin-bottom: 2em;\n }\n \n-#trait-implementations-list .method-toggle,\n-#synthetic-implementations-list .method-toggle,\n-#blanket-implementations-list .method-toggle {\n+#trait-implementations-list .method-toggle:not(:last-child),\n+#synthetic-implementations-list .method-toggle:not(:last-child),\n+#blanket-implementations-list .method-toggle:not(:last-child) {\n \tmargin-bottom: 1em;\n }\n "}, {"sha": "c4b5fdf53dd6bd4863c497a6d590b56cfca2f6b2", "filename": "src/test/rustdoc-gui/search-result-color.goml", "status": "modified", "additions": 149, "deletions": 4, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -7,7 +7,6 @@ show-text: true\n // Ayu theme\n local-storage: {\n     \"rustdoc-theme\": \"ayu\",\n-    \"rustdoc-preferred-dark-theme\": \"ayu\",\n     \"rustdoc-use-system-theme\": \"false\",\n }\n reload:\n@@ -23,16 +22,66 @@ assert-css: (\n     {\"color\": \"rgb(0, 150, 207)\"},\n )\n \n-// Checking the color for \"keyword\".\n+// Checking the color of \"keyword\" text.\n assert-css: (\n     \"//*[@class='result-name']//*[text()='(keyword)']\",\n     {\"color\": \"rgb(120, 135, 151)\"},\n )\n \n+// Checking the color of \"keyword\".\n+assert-css: (\n+    \".result-name .keyword\",\n+    {\"color\": \"rgb(57, 175, 215)\"},\n+    ALL,\n+)\n+// Check the color of \"struct\".\n+assert-css: (\n+    \".result-name .struct\",\n+    {\"color\": \"rgb(255, 160, 165)\"},\n+    ALL,\n+)\n+// Check the color of \"associated type\".\n+assert-css: (\n+    \".result-name .associatedtype\",\n+    {\"color\": \"rgb(57, 175, 215)\"},\n+    ALL,\n+)\n+// Check the color of \"type method\".\n+assert-css: (\n+    \".result-name .tymethod\",\n+    {\"color\": \"rgb(253, 214, 135)\"},\n+    ALL,\n+)\n+// Check the color of \"method\".\n+assert-css: (\n+    \".result-name .method\",\n+    {\"color\": \"rgb(253, 214, 135)\"},\n+    ALL,\n+)\n+// Check the color of \"struct field\".\n+assert-css: (\n+    \".result-name .structfield\",\n+    {\"color\": \"rgb(0, 150, 207)\"},\n+    ALL,\n+)\n+// Check the color of \"macro\".\n+assert-css: (\n+    \".result-name .macro\",\n+    {\"color\": \"rgb(163, 122, 204)\"},\n+    ALL,\n+)\n+// Check the color of \"fn\".\n+assert-css: (\n+    \".result-name .fn\",\n+    {\"color\": \"rgb(253, 214, 135)\"},\n+    ALL,\n+)\n+\n // Checking the `<a>` container.\n assert-css: (\n     \"//*[@class='result-name']/*[text()='test_docs::']/ancestor::a\",\n     {\"color\": \"rgb(0, 150, 207)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n+    ALL,\n )\n \n // Checking color and background on hover.\n@@ -49,7 +98,6 @@ assert-css: (\n // Dark theme\n local-storage: {\n     \"rustdoc-theme\": \"dark\",\n-    \"rustdoc-preferred-dark-theme\": \"dark\",\n     \"rustdoc-use-system-theme\": \"false\",\n }\n reload:\n@@ -71,6 +119,55 @@ assert-css: (\n     {\"color\": \"rgb(221, 221, 221)\"},\n )\n \n+// Checking the color of \"keyword\".\n+assert-css: (\n+    \".result-name .keyword\",\n+    {\"color\": \"rgb(210, 153, 29)\"},\n+    ALL,\n+)\n+// Check the color of \"struct\".\n+assert-css: (\n+    \".result-name .struct\",\n+    {\"color\": \"rgb(45, 191, 184)\"},\n+    ALL,\n+)\n+// Check the color of \"associated type\".\n+assert-css: (\n+    \".result-name .associatedtype\",\n+    {\"color\": \"rgb(210, 153, 29)\"},\n+    ALL,\n+)\n+// Check the color of \"type method\".\n+assert-css: (\n+    \".result-name .tymethod\",\n+    {\"color\": \"rgb(43, 171, 99)\"},\n+    ALL,\n+)\n+// Check the color of \"method\".\n+assert-css: (\n+    \".result-name .method\",\n+    {\"color\": \"rgb(43, 171, 99)\"},\n+    ALL,\n+)\n+// Check the color of \"struct field\".\n+assert-css: (\n+    \".result-name .structfield\",\n+    {\"color\": \"rgb(221, 221, 221)\"},\n+    ALL,\n+)\n+// Check the color of \"macro\".\n+assert-css: (\n+    \".result-name .macro\",\n+    {\"color\": \"rgb(9, 189, 0)\"},\n+    ALL,\n+)\n+// Check the color of \"fn\".\n+assert-css: (\n+    \".result-name .fn\",\n+    {\"color\": \"rgb(43, 171, 99)\"},\n+    ALL,\n+)\n+\n // Checking the `<a>` container.\n assert-css: (\n     \"//*[@class='result-name']/*[text()='test_docs::']/ancestor::a\",\n@@ -109,6 +206,55 @@ assert-css: (\n     {\"color\": \"rgb(0, 0, 0)\"},\n )\n \n+// Checking the color of \"keyword\".\n+assert-css: (\n+    \".result-name .keyword\",\n+    {\"color\": \"rgb(56, 115, 173)\"},\n+    ALL,\n+)\n+// Check the color of \"struct\".\n+assert-css: (\n+    \".result-name .struct\",\n+    {\"color\": \"rgb(173, 55, 138)\"},\n+    ALL,\n+)\n+// Check the color of \"associated type\".\n+assert-css: (\n+    \".result-name .associatedtype\",\n+    {\"color\": \"rgb(56, 115, 173)\"},\n+    ALL,\n+)\n+// Check the color of \"type method\".\n+assert-css: (\n+    \".result-name .tymethod\",\n+    {\"color\": \"rgb(173, 124, 55)\"},\n+    ALL,\n+)\n+// Check the color of \"method\".\n+assert-css: (\n+    \".result-name .method\",\n+    {\"color\": \"rgb(173, 124, 55)\"},\n+    ALL,\n+)\n+// Check the color of \"struct field\".\n+assert-css: (\n+    \".result-name .structfield\",\n+    {\"color\": \"rgb(0, 0, 0)\"},\n+    ALL,\n+)\n+// Check the color of \"macro\".\n+assert-css: (\n+    \".result-name .macro\",\n+    {\"color\": \"rgb(6, 128, 0)\"},\n+    ALL,\n+)\n+// Check the color of \"fn\".\n+assert-css: (\n+    \".result-name .fn\",\n+    {\"color\": \"rgb(173, 124, 55)\"},\n+    ALL,\n+)\n+\n // Checking the `<a>` container.\n assert-css: (\n     \"//*[@class='result-name']/*[text()='test_docs::']/ancestor::a\",\n@@ -132,7 +278,6 @@ goto: file://|DOC_PATH|/test_docs/index.html\n // this test is running on.\n local-storage: {\n     \"rustdoc-theme\": \"dark\",\n-    \"rustdoc-preferred-dark-theme\": \"dark\",\n     \"rustdoc-use-system-theme\": \"false\",\n }\n // If the text isn't displayed, the browser doesn't compute color style correctly..."}, {"sha": "9af7c636a0cac6d24af4f51b41327c5469d744f3", "filename": "src/test/rustdoc-gui/sidebar-mobile-scroll.goml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile-scroll.goml", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile-scroll.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsidebar-mobile-scroll.goml?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -6,7 +6,7 @@ assert-css: (\".sidebar\", {\"display\": \"block\", \"left\": \"-1000px\"})\n \n // Scroll down.\n scroll-to: \"//h2[@id='blanket-implementations']\"\n-assert-window-property: {\"pageYOffset\": \"643\"}\n+assert-window-property: {\"pageYOffset\": \"639\"}\n \n // Open the sidebar menu.\n click: \".sidebar-menu-toggle\"\n@@ -21,11 +21,11 @@ assert-window-property: {\"pageYOffset\": \"0\"}\n // Close the sidebar menu. Make sure the scroll position gets restored.\n click: \".sidebar-menu-toggle\"\n wait-for-css: (\".sidebar\", {\"left\": \"-1000px\"})\n-assert-window-property: {\"pageYOffset\": \"643\"}\n+assert-window-property: {\"pageYOffset\": \"639\"}\n \n // Now test that scrollability returns when the browser window is just resized.\n click: \".sidebar-menu-toggle\"\n wait-for-css: (\".sidebar\", {\"left\": \"0px\"})\n assert-window-property: {\"pageYOffset\": \"0\"}\n size: (900, 600)\n-assert-window-property: {\"pageYOffset\": \"643\"}\n+assert-window-property: {\"pageYOffset\": \"639\"}"}, {"sha": "24aecc70d65e0b1694450160cf022738f776b608", "filename": "src/test/rustdoc-gui/src/lib2/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Flib2%2Flib.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -38,11 +38,14 @@ pub trait Trait {\n \n     #[deprecated = \"Whatever [`Foo`](#tadam)\"]\n     fn foo() {}\n+    fn fooo();\n }\n \n impl Trait for Foo {\n     type X = u32;\n     const Y: u32 = 0;\n+\n+    fn fooo() {}\n }\n \n impl implementors::Whatever for Foo {"}, {"sha": "80395e32db0caa8ff2217b843e075245c107e422", "filename": "src/test/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:23:1\n+  --> $DIR/ub-enum.rs:24:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000001, but expected a valid enum tag\n@@ -10,7 +10,7 @@ LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:26:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -22,7 +22,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:31:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -33,7 +33,7 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:43:1\n+  --> $DIR/ub-enum.rs:44:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n@@ -44,7 +44,7 @@ LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -55,7 +55,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:49:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -66,13 +66,13 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:59:42\n+  --> $DIR/ub-enum.rs:60:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:64:1\n+  --> $DIR/ub-enum.rs:65:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -83,7 +83,7 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:82:1\n+  --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n@@ -94,7 +94,7 @@ LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:84:1\n+  --> $DIR/ub-enum.rs:85:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n@@ -105,7 +105,7 @@ LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:92:1\n+  --> $DIR/ub-enum.rs:93:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n@@ -116,13 +116,13 @@ LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::tran\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:97:77\n+  --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:99:77\n+  --> $DIR/ub-enum.rs:100:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n@@ -132,7 +132,7 @@ error: aborting due to 13 previous errors\n For more information about this error, try `rustc --explain E0080`.\n Future incompatibility report: Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:26:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -145,7 +145,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:31:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -158,7 +158,7 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -171,7 +171,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:49:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -184,7 +184,7 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:64:1\n+  --> $DIR/ub-enum.rs:65:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes"}, {"sha": "d20f63a7289947f3ffc95f9e05041c85f7e31c9c", "filename": "src/test/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:23:1\n+  --> $DIR/ub-enum.rs:24:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n    | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000001, but expected a valid enum tag\n@@ -10,7 +10,7 @@ LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:26:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -22,7 +22,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:31:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -33,7 +33,7 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:43:1\n+  --> $DIR/ub-enum.rs:44:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n@@ -44,7 +44,7 @@ LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -55,7 +55,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:49:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -66,13 +66,13 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:59:42\n+  --> $DIR/ub-enum.rs:60:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:64:1\n+  --> $DIR/ub-enum.rs:65:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -83,7 +83,7 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:82:1\n+  --> $DIR/ub-enum.rs:83:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n@@ -94,7 +94,7 @@ LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:84:1\n+  --> $DIR/ub-enum.rs:85:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n@@ -105,7 +105,7 @@ LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:92:1\n+  --> $DIR/ub-enum.rs:93:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n@@ -116,13 +116,13 @@ LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::tran\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:97:77\n+  --> $DIR/ub-enum.rs:98:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:99:77\n+  --> $DIR/ub-enum.rs:100:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n@@ -132,7 +132,7 @@ error: aborting due to 13 previous errors\n For more information about this error, try `rustc --explain E0080`.\n Future incompatibility report: Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:26:1\n+  --> $DIR/ub-enum.rs:27:1\n    |\n LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -145,7 +145,7 @@ LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:30:1\n+  --> $DIR/ub-enum.rs:31:1\n    |\n LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -158,7 +158,7 @@ LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:45:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -171,7 +171,7 @@ LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:49:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -184,7 +184,7 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:64:1\n+  --> $DIR/ub-enum.rs:65:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes"}, {"sha": "9e1c28e2351a81322880d355812db2ff4e94852c", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -1,5 +1,6 @@\n // stderr-per-bitwidth\n #![feature(never_type)]\n+#![allow(invalid_value)]\n \n use std::mem;\n "}, {"sha": "b568518b4499dae0a7a6fc6f6fc00c9e774d6ca7", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -40,11 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: enums with no variants have no valid value (in this struct field)\n-  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |\n-LL |     pub struct Empty(Void);\n-   |                      ^^^^\n+LL |     enum Void {}\n+   |     ^^^^^^^^^\n \n error: aborting due to 2 previous errors; 2 warnings emitted\n "}, {"sha": "b568518b4499dae0a7a6fc6f6fc00c9e774d6ca7", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -40,11 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: enums with no variants have no valid value (in this struct field)\n-  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |\n-LL |     pub struct Empty(Void);\n-   |                      ^^^^\n+LL |     enum Void {}\n+   |     ^^^^^^^^^\n \n error: aborting due to 2 previous errors; 2 warnings emitted\n "}, {"sha": "51edb2b7baf598fbe306991ef6240b41331d5a44", "filename": "src/test/ui/lint/invalid_value.rs", "status": "renamed", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -34,6 +34,16 @@ enum OneFruit {\n     Banana,\n }\n \n+enum OneFruitNonZero {\n+    Apple(!),\n+    Banana(NonZeroU32),\n+}\n+\n+enum TwoUninhabited {\n+    A(!),\n+    B(Void),\n+}\n+\n #[allow(unused)]\n fn generic<T: 'static>() {\n     unsafe {\n@@ -84,6 +94,12 @@ fn main() {\n         let _val: [fn(); 2] = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: [fn(); 2] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: TwoUninhabited = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: TwoUninhabited = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: OneFruitNonZero = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: OneFruitNonZero = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Things that can be zero, but not uninit.\n         let _val: bool = mem::zeroed();\n         let _val: bool = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n@@ -112,6 +128,16 @@ fn main() {\n         let _val: *const [()] = mem::zeroed();\n         let _val: *const [()] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        // Things where 0 is okay due to rustc implementation details,\n+        // but that are not guaranteed to keep working.\n+        let _val: Result<i32, i32> = mem::zeroed();\n+        let _val: Result<i32, i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Some things that happen to work due to rustc implementation details,\n+        // but are not guaranteed to keep working.\n+        let _val: OneFruit = mem::zeroed();\n+        let _val: OneFruit = mem::uninitialized();\n+\n         // Transmute-from-0\n         let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n         let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n@@ -129,9 +155,5 @@ fn main() {\n         let _val: bool = MaybeUninit::zeroed().assume_init();\n         let _val: [bool; 0] = MaybeUninit::uninit().assume_init();\n         let _val: [!; 0] = MaybeUninit::zeroed().assume_init();\n-\n-        // Some things that happen to work due to rustc implementation details,\n-        // but are not guaranteed to keep working.\n-        let _val: OneFruit = mem::uninitialized();\n     }\n }", "previous_filename": "src/test/ui/lint/uninitialized-zeroed.rs"}, {"sha": "750b3c76c44c2a82618a072b9f6f474f04d168e5", "filename": "src/test/ui/lint/invalid_value.stderr", "status": "renamed", "additions": 145, "deletions": 62, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -1,5 +1,5 @@\n error: the type `&T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:40:32\n+  --> $DIR/invalid_value.rs:50:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -8,14 +8,14 @@ LL |         let _val: &'static T = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: the lint level is defined here\n-  --> $DIR/uninitialized-zeroed.rs:6:9\n+  --> $DIR/invalid_value.rs:6:9\n    |\n LL | #![deny(invalid_value)]\n    |         ^^^^^^^^^^^^^\n    = note: references must be non-null\n \n error: the type `&T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:41:32\n+  --> $DIR/invalid_value.rs:51:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Wrap<&T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:43:38\n+  --> $DIR/invalid_value.rs:53:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -35,13 +35,13 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:44:38\n+  --> $DIR/invalid_value.rs:54:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -50,13 +50,13 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:51:23\n+  --> $DIR/invalid_value.rs:61:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:52:23\n+  --> $DIR/invalid_value.rs:62:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:54:30\n+  --> $DIR/invalid_value.rs:64:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:55:30\n+  --> $DIR/invalid_value.rs:65:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,29 +100,37 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:57:26\n+  --> $DIR/invalid_value.rs:67:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n    |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:12:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:58:26\n+  --> $DIR/invalid_value.rs:68:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n    |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:12:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:60:34\n+  --> $DIR/invalid_value.rs:70:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -133,7 +141,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: references must be non-null\n \n error: the type `&i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:61:34\n+  --> $DIR/invalid_value.rs:71:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -144,7 +152,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:63:25\n+  --> $DIR/invalid_value.rs:73:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -153,13 +161,13 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:12\n+  --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:64:25\n+  --> $DIR/invalid_value.rs:74:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -168,13 +176,13 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:12\n+  --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:66:26\n+  --> $DIR/invalid_value.rs:76:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -185,7 +193,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:67:26\n+  --> $DIR/invalid_value.rs:77:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -196,7 +204,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:69:32\n+  --> $DIR/invalid_value.rs:79:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -205,13 +213,13 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:70:32\n+  --> $DIR/invalid_value.rs:80:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -220,43 +228,43 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:72:36\n+  --> $DIR/invalid_value.rs:82:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:18:28\n+note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:73:36\n+  --> $DIR/invalid_value.rs:83:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:18:28\n+note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:75:42\n+  --> $DIR/invalid_value.rs:85:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -265,13 +273,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:15:16\n+  --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:76:42\n+  --> $DIR/invalid_value.rs:86:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -280,13 +288,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:15:16\n+  --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:78:34\n+  --> $DIR/invalid_value.rs:88:34\n    |\n LL |         let _val: NonNull<i32> = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -297,7 +305,7 @@ LL |         let _val: NonNull<i32> = mem::zeroed();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:79:34\n+  --> $DIR/invalid_value.rs:89:34\n    |\n LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -308,7 +316,7 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `*const dyn Send` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:81:37\n+  --> $DIR/invalid_value.rs:91:37\n    |\n LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -319,7 +327,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `*const dyn Send` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:82:37\n+  --> $DIR/invalid_value.rs:92:37\n    |\n LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -330,7 +338,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `[fn(); 2]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:84:31\n+  --> $DIR/invalid_value.rs:94:31\n    |\n LL |         let _val: [fn(); 2] = mem::zeroed();\n    |                               ^^^^^^^^^^^^^\n@@ -341,7 +349,7 @@ LL |         let _val: [fn(); 2] = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `[fn(); 2]` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:85:31\n+  --> $DIR/invalid_value.rs:95:31\n    |\n LL |         let _val: [fn(); 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -351,8 +359,68 @@ LL |         let _val: [fn(); 2] = mem::uninitialized();\n    |\n    = note: function pointers must be non-null\n \n+error: the type `TwoUninhabited` does not permit zero-initialization\n+  --> $DIR/invalid_value.rs:97:36\n+   |\n+LL |         let _val: TwoUninhabited = mem::zeroed();\n+   |                                    ^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:42:1\n+   |\n+LL | enum TwoUninhabited {\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: the type `TwoUninhabited` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:98:36\n+   |\n+LL |         let _val: TwoUninhabited = mem::uninitialized();\n+   |                                    ^^^^^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:42:1\n+   |\n+LL | enum TwoUninhabited {\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: the type `OneFruitNonZero` does not permit zero-initialization\n+  --> $DIR/invalid_value.rs:100:37\n+   |\n+LL |         let _val: OneFruitNonZero = mem::zeroed();\n+   |                                     ^^^^^^^^^^^^^\n+   |                                     |\n+   |                                     this code causes undefined behavior when executed\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:39:12\n+   |\n+LL |     Banana(NonZeroU32),\n+   |            ^^^^^^^^^^\n+\n+error: the type `OneFruitNonZero` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:101:37\n+   |\n+LL |         let _val: OneFruitNonZero = mem::uninitialized();\n+   |                                     ^^^^^^^^^^^^^^^^^^^^\n+   |                                     |\n+   |                                     this code causes undefined behavior when executed\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:39:12\n+   |\n+LL |     Banana(NonZeroU32),\n+   |            ^^^^^^^^^^\n+\n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:89:26\n+  --> $DIR/invalid_value.rs:105:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -363,7 +431,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:92:32\n+  --> $DIR/invalid_value.rs:108:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -372,13 +440,13 @@ LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: characters must be a valid Unicode codepoint (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:95:28\n+  --> $DIR/invalid_value.rs:111:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -389,22 +457,22 @@ LL |         let _val: NonBig = mem::uninitialized();\n    = note: `NonBig` must be initialized inside its custom valid range\n \n error: the type `Fruit` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:98:27\n+  --> $DIR/invalid_value.rs:114:27\n    |\n LL |         let _val: Fruit = mem::uninitialized();\n    |                           ^^^^^^^^^^^^^^^^^^^^\n    |                           |\n    |                           this code causes undefined behavior when executed\n    |                           help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: enums have to be initialized to a variant\n-  --> $DIR/uninitialized-zeroed.rs:26:1\n+note: enums with multiple inhabited variants have to be initialized to a variant\n+  --> $DIR/invalid_value.rs:26:1\n    |\n LL | enum Fruit {\n    | ^^^^^^^^^^\n \n error: the type `[bool; 2]` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:101:31\n+  --> $DIR/invalid_value.rs:117:31\n    |\n LL |         let _val: [bool; 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -415,7 +483,7 @@ LL |         let _val: [bool; 2] = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:104:25\n+  --> $DIR/invalid_value.rs:120:25\n    |\n LL |         let _val: i32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -426,7 +494,7 @@ LL |         let _val: i32 = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `f32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:107:25\n+  --> $DIR/invalid_value.rs:123:25\n    |\n LL |         let _val: f32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -437,7 +505,7 @@ LL |         let _val: f32 = mem::uninitialized();\n    = note: floats must not be uninitialized\n \n error: the type `*const ()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:110:31\n+  --> $DIR/invalid_value.rs:126:31\n    |\n LL |         let _val: *const () = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -448,7 +516,7 @@ LL |         let _val: *const () = mem::uninitialized();\n    = note: raw pointers must not be uninitialized\n \n error: the type `*const [()]` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:113:33\n+  --> $DIR/invalid_value.rs:129:33\n    |\n LL |         let _val: *const [()] = mem::uninitialized();\n    |                                 ^^^^^^^^^^^^^^^^^^^^\n@@ -458,8 +526,23 @@ LL |         let _val: *const [()] = mem::uninitialized();\n    |\n    = note: raw pointers must not be uninitialized\n \n+error: the type `Result<i32, i32>` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:134:38\n+   |\n+LL |         let _val: Result<i32, i32> = mem::uninitialized();\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+   |                                      |\n+   |                                      this code causes undefined behavior when executed\n+   |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums with multiple inhabited variants have to be initialized to a variant\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | pub enum Result<T, E> {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:116:34\n+  --> $DIR/invalid_value.rs:142:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -470,7 +553,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:117:36\n+  --> $DIR/invalid_value.rs:143:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -481,7 +564,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `NonZeroU32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:118:32\n+  --> $DIR/invalid_value.rs:144:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -492,7 +575,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:121:34\n+  --> $DIR/invalid_value.rs:147:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -503,7 +586,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:122:34\n+  --> $DIR/invalid_value.rs:148:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -514,7 +597,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:123:26\n+  --> $DIR/invalid_value.rs:149:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -524,5 +607,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 43 previous errors\n+error: aborting due to 48 previous errors\n ", "previous_filename": "src/test/ui/lint/uninitialized-zeroed.stderr"}, {"sha": "6a82acb4cd6b5dce05b47fbff64c1563ab009fd7", "filename": "src/test/ui/parser/bad-pointer-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fparser%2Fbad-pointer-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fparser%2Fbad-pointer-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-pointer-type.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -1,5 +1,5 @@\n fn foo(_: *()) {\n-    //~^ ERROR expected mut or const in raw pointer type\n+    //~^ ERROR expected `mut` or `const` keyword in raw pointer type\n }\n \n fn main() {}"}, {"sha": "b7225ca887dd4d0074a0086fad9510fe9e745dd5", "filename": "src/test/ui/parser/bad-pointer-type.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fparser%2Fbad-pointer-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fparser%2Fbad-pointer-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-pointer-type.stderr?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -1,10 +1,15 @@\n-error: expected mut or const in raw pointer type\n+error: expected `mut` or `const` keyword in raw pointer type\n   --> $DIR/bad-pointer-type.rs:1:11\n    |\n LL | fn foo(_: *()) {\n-   |           ^ expected mut or const in raw pointer type\n+   |           ^\n    |\n-   = help: use `*mut T` or `*const T` as appropriate\n+help: add `mut` or `const` here\n+   |\n+LL | fn foo(_: *const ()) {\n+   |            +++++\n+LL | fn foo(_: *mut ()) {\n+   |            +++\n \n error: aborting due to previous error\n "}, {"sha": "54d34db4a50f495e1b734ae885098203c7daf8d8", "filename": "src/test/ui/parser/double-pointer.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fparser%2Fdouble-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fparser%2Fdouble-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdouble-pointer.rs?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let x: i32 = 5;\n+    let ptr: *const i32 = &x;\n+    let dptr: **const i32 = &ptr;\n+    //~^ ERROR expected `mut` or `const` keyword in raw pointer type\n+    //~| HELP add `mut` or `const` here\n+}"}, {"sha": "28037f9326552cc7a49943d2753aa150a5671295", "filename": "src/test/ui/parser/double-pointer.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fparser%2Fdouble-pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fparser%2Fdouble-pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdouble-pointer.stderr?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -0,0 +1,15 @@\n+error: expected `mut` or `const` keyword in raw pointer type\n+  --> $DIR/double-pointer.rs:4:15\n+   |\n+LL |     let dptr: **const i32 = &ptr;\n+   |               ^\n+   |\n+help: add `mut` or `const` here\n+   |\n+LL |     let dptr: *const *const i32 = &ptr;\n+   |                +++++\n+LL |     let dptr: *mut *const i32 = &ptr;\n+   |                +++\n+\n+error: aborting due to previous error\n+"}, {"sha": "6d37de8ff3f688a2ed52643f785ce9ee7e096b47", "filename": "src/test/ui/statics/uninhabited-static.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90c34fafcfa1d00ae25a165dc006e688761a5776/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr?ref=90c34fafcfa1d00ae25a165dc006e688761a5776", "patch": "@@ -59,7 +59,11 @@ LL | static VOID2: Void = unsafe { std::mem::transmute(()) };\n    |                               help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: `#[warn(invalid_value)]` on by default\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/uninhabited-static.rs:4:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $DIR/uninhabited-static.rs:16:32\n@@ -76,7 +80,11 @@ LL | static NEVER2: Void = unsafe { std::mem::transmute(()) };\n    |                                this code causes undefined behavior when executed\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/uninhabited-static.rs:4:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error: aborting due to 6 previous errors; 2 warnings emitted\n "}]}