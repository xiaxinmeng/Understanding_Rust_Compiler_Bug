{"sha": "e87cd7e380c89e3f80ceab417e3525e546a1e362", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4N2NkN2UzODBjODllM2Y4MGNlYWI0MTdlMzUyNWU1NDZhMWUzNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-16T06:14:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-16T06:14:52Z"}, "message": "Auto merge of #33505 - petrochenkov:self, r=nrc\n\nRemove ExplicitSelf from HIR\n\n`self` argument is already kept in the argument list and can be retrieved from there if necessary, so there's no need for the duplication.\nThe same changes can be applied to AST, I'll make them in the next breaking batch.\nThe first commit also improves parsing of method declarations and fixes https://github.com/rust-lang/rust/issues/33413.\n\nr? @eddyb", "tree": {"sha": "288390b3cbebcc2f747a8ffea4a26b5c800bdabe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/288390b3cbebcc2f747a8ffea4a26b5c800bdabe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e87cd7e380c89e3f80ceab417e3525e546a1e362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e87cd7e380c89e3f80ceab417e3525e546a1e362", "html_url": "https://github.com/rust-lang/rust/commit/e87cd7e380c89e3f80ceab417e3525e546a1e362", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e87cd7e380c89e3f80ceab417e3525e546a1e362/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e90307d2a214614ca55ce31371c0768d7bffa114", "url": "https://api.github.com/repos/rust-lang/rust/commits/e90307d2a214614ca55ce31371c0768d7bffa114", "html_url": "https://github.com/rust-lang/rust/commit/e90307d2a214614ca55ce31371c0768d7bffa114"}, {"sha": "a62a6903268a68e793407aca05a64e89b8b22f1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a62a6903268a68e793407aca05a64e89b8b22f1b", "html_url": "https://github.com/rust-lang/rust/commit/a62a6903268a68e793407aca05a64e89b8b22f1b"}], "stats": {"total": 1066, "additions": 430, "deletions": 636}, "files": [{"sha": "740d72f4c3e3cfd777337eb9827039f6cac4ed6a", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -158,14 +158,6 @@ pub trait Folder : Sized {\n         noop_fold_local(l, self)\n     }\n \n-    fn fold_explicit_self(&mut self, es: ExplicitSelf) -> ExplicitSelf {\n-        noop_fold_explicit_self(es, self)\n-    }\n-\n-    fn fold_explicit_self_underscore(&mut self, es: ExplicitSelf_) -> ExplicitSelf_ {\n-        noop_fold_explicit_self_underscore(es, self)\n-    }\n-\n     fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n@@ -495,29 +487,6 @@ pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attr\n     })\n }\n \n-pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_,\n-                                                     fld: &mut T)\n-                                                     -> ExplicitSelf_ {\n-    match es {\n-        SelfStatic | SelfValue(_) => es,\n-        SelfRegion(lifetime, m, name) => {\n-            SelfRegion(fld.fold_opt_lifetime(lifetime), m, name)\n-        }\n-        SelfExplicit(typ, name) => {\n-            SelfExplicit(fld.fold_ty(typ), name)\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_explicit_self<T: Folder>(Spanned { span, node }: ExplicitSelf,\n-                                          fld: &mut T)\n-                                          -> ExplicitSelf {\n-    Spanned {\n-        node: fld.fold_explicit_self_underscore(node),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n     mi.map(|Spanned { node, span }| {\n         Spanned {\n@@ -941,7 +910,6 @@ pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> Method\n     MethodSig {\n         generics: folder.fold_generics(sig.generics),\n         abi: sig.abi,\n-        explicit_self: folder.fold_explicit_self(sig.explicit_self),\n         unsafety: sig.unsafety,\n         constness: sig.constness,\n         decl: folder.fold_fn_decl(sig.decl),"}, {"sha": "b387ced48228ca3784b890d7cf77e5c58989f05a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -180,9 +180,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n-        walk_explicit_self(self, es)\n-    }\n     fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n@@ -258,23 +255,6 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V, lifetime_def: &'v\n     walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n-pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V, explicit_self: &'v ExplicitSelf) {\n-    match explicit_self.node {\n-        SelfStatic => {}\n-        SelfValue(name) => {\n-            visitor.visit_name(explicit_self.span, name)\n-        }\n-        SelfRegion(ref opt_lifetime, _, name) => {\n-            visitor.visit_name(explicit_self.span, name);\n-            walk_list!(visitor, visit_lifetime, opt_lifetime);\n-        }\n-        SelfExplicit(ref typ, name) => {\n-            visitor.visit_name(explicit_self.span, name);\n-            visitor.visit_ty(typ)\n-        }\n-    }\n-}\n-\n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n                                   _modifier: &'v TraitBoundModifier)\n@@ -620,7 +600,6 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n         }\n         FnKind::Method(_, sig, _, _) => {\n             visitor.visit_generics(&sig.generics);\n-            visitor.visit_explicit_self(&sig.explicit_self);\n         }\n         FnKind::Closure(_) => {}\n     }\n@@ -645,7 +624,6 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_list!(visitor, visit_expr, default);\n         }\n         MethodTraitItem(ref sig, None) => {\n-            visitor.visit_explicit_self(&sig.explicit_self);\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }"}, {"sha": "0c3c190064b08351a762847b6c8401a3eba65e0e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -388,35 +388,13 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_explicit_self_underscore(&mut self, es: &SelfKind) -> hir::ExplicitSelf_ {\n-        match *es {\n-            SelfKind::Static => hir::SelfStatic,\n-            SelfKind::Value(v) => hir::SelfValue(v.name),\n-            SelfKind::Region(ref lifetime, m, ident) => {\n-                hir::SelfRegion(self.lower_opt_lifetime(lifetime),\n-                                self.lower_mutability(m),\n-                                ident.name)\n-            }\n-            SelfKind::Explicit(ref typ, ident) => {\n-                hir::SelfExplicit(self.lower_ty(typ), ident.name)\n-            }\n-        }\n-    }\n-\n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n         match m {\n             Mutability::Mutable => hir::MutMutable,\n             Mutability::Immutable => hir::MutImmutable,\n         }\n     }\n \n-    fn lower_explicit_self(&mut self, s: &ExplicitSelf) -> hir::ExplicitSelf {\n-        Spanned {\n-            node: self.lower_explicit_self_underscore(&s.node),\n-            span: s.span,\n-        }\n-    }\n-\n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n         hir::Arg {\n             id: arg.id,\n@@ -797,10 +775,19 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_method_sig(&mut self, sig: &MethodSig) -> hir::MethodSig {\n+        // Check for `self: _` and `self: &_`\n+        if let SelfKind::Explicit(ref ty, _) = sig.explicit_self.node {\n+            match sig.decl.inputs.get(0).and_then(Arg::to_self).map(|eself| eself.node) {\n+                Some(SelfKind::Value(..)) | Some(SelfKind::Region(..)) => {\n+                    self.id_assigner.diagnostic().span_err(ty.span,\n+                        \"the type placeholder `_` is not allowed within types on item signatures\");\n+                }\n+                _ => {}\n+            }\n+        }\n         hir::MethodSig {\n             generics: self.lower_generics(&sig.generics),\n             abi: sig.abi,\n-            explicit_self: self.lower_explicit_self(&sig.explicit_self),\n             unsafety: self.lower_unsafety(sig.unsafety),\n             constness: self.lower_constness(sig.constness),\n             decl: self.lower_fn_decl(&sig.decl),"}, {"sha": "eb38458a3acfa78435f02bcee803213f28782c02", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -15,7 +15,6 @@ pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n pub use self::Decl_::*;\n-pub use self::ExplicitSelf_::*;\n pub use self::Expr_::*;\n pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n@@ -37,12 +36,12 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use util::nodemap::{NodeMap, FnvHashSet};\n \n-use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n+use syntax::codemap::{self, mk_sp, respan, Span, Spanned, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::attr::{ThinAttributes, ThinAttributesExt};\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n \n use std::collections::BTreeMap;\n@@ -1055,7 +1054,6 @@ pub struct MethodSig {\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n-    pub explicit_self: ExplicitSelf,\n }\n \n /// Represents an item declaration within a trait declaration,\n@@ -1196,25 +1194,41 @@ pub struct Arg {\n     pub id: NodeId,\n }\n \n+/// Alternative representation for `Arg`s describing `self` parameter of methods.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum SelfKind {\n+    /// `self`, `mut self`\n+    Value(Mutability),\n+    /// `&'lt self`, `&'lt mut self`\n+    Region(Option<Lifetime>, Mutability),\n+    /// `self: TYPE`, `mut self: TYPE`\n+    Explicit(P<Ty>, Mutability),\n+}\n+\n+pub type ExplicitSelf = Spanned<SelfKind>;\n+\n impl Arg {\n-    pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n-        let path = Spanned {\n-            span: span,\n-            node: self_ident,\n-        };\n-        Arg {\n-            // HACK(eddyb) fake type for the self argument.\n-            ty: P(Ty {\n-                id: DUMMY_NODE_ID,\n-                node: TyInfer,\n-                span: DUMMY_SP,\n-            }),\n-            pat: P(Pat {\n-                id: DUMMY_NODE_ID,\n-                node: PatKind::Ident(BindByValue(mutability), path, None),\n-                span: span,\n-            }),\n-            id: DUMMY_NODE_ID,\n+    pub fn to_self(&self) -> Option<ExplicitSelf> {\n+        if let PatKind::Ident(BindByValue(mutbl), ident, _) = self.pat.node {\n+            if ident.node.unhygienic_name == keywords::SelfValue.name() {\n+                return match self.ty.node {\n+                    TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n+                    TyRptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyInfer => {\n+                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n+                    }\n+                    _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n+                                     SelfKind::Explicit(self.ty.clone(), mutbl)))\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn is_self(&self) -> bool {\n+        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+            ident.node.unhygienic_name == keywords::SelfValue.name()\n+        } else {\n+            false\n         }\n     }\n }\n@@ -1227,6 +1241,12 @@ pub struct FnDecl {\n     pub variadic: bool,\n }\n \n+impl FnDecl {\n+    pub fn has_self(&self) -> bool {\n+        self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,\n@@ -1308,21 +1328,6 @@ impl FunctionRetTy {\n     }\n }\n \n-/// Represents the kind of 'self' associated with a method\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum ExplicitSelf_ {\n-    /// No self\n-    SelfStatic,\n-    /// `self`\n-    SelfValue(Name),\n-    /// `&'lt self`, `&'lt mut self`\n-    SelfRegion(Option<Lifetime>, Mutability, Name),\n-    /// `self: TYPE`\n-    SelfExplicit(P<Ty>, Name),\n-}\n-\n-pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`."}, {"sha": "c3617cb768d56334060c94ffc5e35e7ed59044c8", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 27, "deletions": 85, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -23,7 +23,7 @@ use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n \n use hir;\n-use hir::{Crate, PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use hir::{Crate, PatKind, RegionTyParamBound, SelfKind, TraitTyParamBound, TraitBoundModifier};\n \n use std::io::{self, Write, Read};\n \n@@ -281,7 +281,6 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n                      unsafety: hir::Unsafety,\n                      constness: hir::Constness,\n                      name: ast::Name,\n-                     opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                      generics: &hir::Generics)\n                      -> String {\n     to_string(|s| {\n@@ -292,7 +291,6 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n                    Abi::Rust,\n                    Some(name),\n                    generics,\n-                   opt_explicit_self,\n                    &hir::Inherited)?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n@@ -309,10 +307,6 @@ pub fn block_to_string(blk: &hir::Block) -> String {\n     })\n }\n \n-pub fn explicit_self_to_string(explicit_self: &hir::ExplicitSelf_) -> String {\n-    to_string(|s| s.print_explicit_self(explicit_self, hir::MutImmutable).map(|_| {}))\n-}\n-\n pub fn variant_to_string(var: &hir::Variant) -> String {\n     to_string(|s| s.print_variant(var))\n }\n@@ -526,7 +520,7 @@ impl<'a> State<'a> {\n                         predicates: hir::HirVec::new(),\n                     },\n                 };\n-                self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics, None)?;\n+                self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics)?;\n             }\n             hir::TyPath(None, ref path) => {\n                 self.print_path(path, false, 0)?;\n@@ -573,7 +567,6 @@ impl<'a> State<'a> {\n                               Abi::Rust,\n                               Some(item.name),\n                               generics,\n-                              None,\n                               &item.vis)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n@@ -710,7 +703,6 @@ impl<'a> State<'a> {\n                               abi,\n                               Some(item.name),\n                               typarams,\n-                              None,\n                               &item.vis)?;\n                 word(&mut self.s, \" \")?;\n                 self.print_block_with_attrs(&body, &item.attrs)?;\n@@ -976,7 +968,6 @@ impl<'a> State<'a> {\n                       m.abi,\n                       Some(name),\n                       &m.generics,\n-                      Some(&m.explicit_self.node),\n                       vis)\n     }\n \n@@ -1881,32 +1872,25 @@ impl<'a> State<'a> {\n         self.end() // close enclosing cbox\n     }\n \n-    // Returns whether it printed anything\n-    fn print_explicit_self(&mut self,\n-                           explicit_self: &hir::ExplicitSelf_,\n-                           mutbl: hir::Mutability)\n-                           -> io::Result<bool> {\n-        self.print_mutability(mutbl)?;\n-        match *explicit_self {\n-            hir::SelfStatic => {\n-                return Ok(false);\n-            }\n-            hir::SelfValue(_) => {\n-                word(&mut self.s, \"self\")?;\n+    fn print_explicit_self(&mut self, explicit_self: &hir::ExplicitSelf) -> io::Result<()> {\n+        match explicit_self.node {\n+            SelfKind::Value(m) => {\n+                self.print_mutability(m)?;\n+                word(&mut self.s, \"self\")\n             }\n-            hir::SelfRegion(ref lt, m, _) => {\n+            SelfKind::Region(ref lt, m) => {\n                 word(&mut self.s, \"&\")?;\n                 self.print_opt_lifetime(lt)?;\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")?;\n+                word(&mut self.s, \"self\")\n             }\n-            hir::SelfExplicit(ref typ, _) => {\n+            SelfKind::Explicit(ref typ, m) => {\n+                self.print_mutability(m)?;\n                 word(&mut self.s, \"self\")?;\n                 self.word_space(\":\")?;\n-                self.print_type(&typ)?;\n+                self.print_type(&typ)\n             }\n         }\n-        return Ok(true);\n     }\n \n     pub fn print_fn(&mut self,\n@@ -1916,7 +1900,6 @@ impl<'a> State<'a> {\n                     abi: Abi,\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n-                    opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                     vis: &hir::Visibility)\n                     -> io::Result<()> {\n         self.print_fn_header_info(unsafety, constness, abi, vis)?;\n@@ -1926,55 +1909,13 @@ impl<'a> State<'a> {\n             self.print_name(name)?;\n         }\n         self.print_generics(generics)?;\n-        self.print_fn_args_and_ret(decl, opt_explicit_self)?;\n+        self.print_fn_args_and_ret(decl)?;\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    pub fn print_fn_args(&mut self,\n-                         decl: &hir::FnDecl,\n-                         opt_explicit_self: Option<&hir::ExplicitSelf_>,\n-                         is_closure: bool)\n-                         -> io::Result<()> {\n-        // It is unfortunate to duplicate the commasep logic, but we want the\n-        // self type and the args all in the same box.\n-        self.rbox(0, Inconsistent)?;\n-        let mut first = true;\n-        if let Some(explicit_self) = opt_explicit_self {\n-            let m = match explicit_self {\n-                &hir::SelfStatic => hir::MutImmutable,\n-                _ => match decl.inputs[0].pat.node {\n-                    PatKind::Ident(hir::BindByValue(m), _, _) => m,\n-                    _ => hir::MutImmutable,\n-                },\n-            };\n-            first = !self.print_explicit_self(explicit_self, m)?;\n-        }\n-\n-        // HACK(eddyb) ignore the separately printed self argument.\n-        let args = if first {\n-            &decl.inputs[..]\n-        } else {\n-            &decl.inputs[1..]\n-        };\n-\n-        for arg in args {\n-            if first {\n-                first = false;\n-            } else {\n-                self.word_space(\",\")?;\n-            }\n-            self.print_arg(arg, is_closure)?;\n-        }\n-\n-        self.end()\n-    }\n-\n-    pub fn print_fn_args_and_ret(&mut self,\n-                                 decl: &hir::FnDecl,\n-                                 opt_explicit_self: Option<&hir::ExplicitSelf_>)\n-                                 -> io::Result<()> {\n+    pub fn print_fn_args_and_ret(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n         self.popen()?;\n-        self.print_fn_args(decl, opt_explicit_self, false)?;\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n         if decl.variadic {\n             word(&mut self.s, \", ...\")?;\n         }\n@@ -1985,7 +1926,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn_block_args(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n         word(&mut self.s, \"|\")?;\n-        self.print_fn_args(decl, None, true)?;\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, true))?;\n         word(&mut self.s, \"|\")?;\n \n         if let hir::DefaultReturn(..) = decl.output {\n@@ -2207,18 +2148,21 @@ impl<'a> State<'a> {\n         match input.ty.node {\n             hir::TyInfer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n-                match input.pat.node {\n-                    PatKind::Ident(_, ref path1, _)\n-                            if path1.node.name == keywords::Invalid.name() => {\n-                        // Do nothing.\n-                    }\n-                    _ => {\n+                if let Some(eself) = input.to_self() {\n+                    self.print_explicit_self(&eself)?;\n+                } else {\n+                    let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n+                        ident.node.name == keywords::Invalid.name()\n+                    } else {\n+                        false\n+                    };\n+                    if !invalid {\n                         self.print_pat(&input.pat)?;\n                         word(&mut self.s, \":\")?;\n                         space(&mut self.s)?;\n                     }\n+                    self.print_type(&input.ty)?;\n                 }\n-                self.print_type(&input.ty)?;\n             }\n         }\n         self.end()\n@@ -2250,8 +2194,7 @@ impl<'a> State<'a> {\n                        unsafety: hir::Unsafety,\n                        decl: &hir::FnDecl,\n                        name: Option<ast::Name>,\n-                       generics: &hir::Generics,\n-                       opt_explicit_self: Option<&hir::ExplicitSelf_>)\n+                       generics: &hir::Generics)\n                        -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n@@ -2272,7 +2215,6 @@ impl<'a> State<'a> {\n                       abi,\n                       name,\n                       &generics,\n-                      opt_explicit_self,\n                       &hir::Inherited)?;\n         self.end()\n     }"}, {"sha": "950b7f68ed878f70c4bb91f90fc5e86859ef026c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 50, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -976,8 +976,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n                         hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n-                            Some((fn_decl, gen, unsafety, constness,\n-                                  item.name, None, item.span))\n+                            Some((fn_decl, gen, unsafety, constness, item.name, item.span))\n                         },\n                         _ => None\n                     }\n@@ -990,7 +989,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                   sig.unsafety,\n                                   sig.constness,\n                                   item.name,\n-                                  Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n                         _ => None,\n@@ -1004,7 +1002,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                   sig.unsafety,\n                                   sig.constness,\n                                   item.name,\n-                                  Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n                         _ => None\n@@ -1014,13 +1011,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             },\n             None => None\n         };\n-        let (fn_decl, generics, unsafety, constness, name, expl_self, span)\n+        let (fn_decl, generics, unsafety, constness, name, span)\n                                     = node_inner.expect(\"expect item fn\");\n-        let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n-                                       generics, same_regions, &life_giver);\n-        let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n-        self.give_expl_lifetime_param(err, &fn_decl, unsafety, constness, name,\n-                                      expl_self.as_ref(), &generics, span);\n+        let rebuilder = Rebuilder::new(self.tcx, fn_decl, generics, same_regions, &life_giver);\n+        let (fn_decl, generics) = rebuilder.rebuild();\n+        self.give_expl_lifetime_param(err, &fn_decl, unsafety, constness, name, &generics, span);\n     }\n }\n \n@@ -1038,7 +1033,6 @@ struct RebuildPathInfo<'a> {\n struct Rebuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     fn_decl: &'a hir::FnDecl,\n-    expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n     generics: &'a hir::Generics,\n     same_regions: &'a [SameRegions],\n     life_giver: &'a LifeGiver,\n@@ -1054,15 +1048,13 @@ enum FreshOrKept {\n impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            fn_decl: &'a hir::FnDecl,\n-           expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n            generics: &'a hir::Generics,\n            same_regions: &'a [SameRegions],\n            life_giver: &'a LifeGiver)\n            -> Rebuilder<'a, 'gcx, 'tcx> {\n         Rebuilder {\n             tcx: tcx,\n             fn_decl: fn_decl,\n-            expl_self_opt: expl_self_opt,\n             generics: generics,\n             same_regions: same_regions,\n             life_giver: life_giver,\n@@ -1071,9 +1063,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn rebuild(&self)\n-               -> (hir::FnDecl, Option<hir::ExplicitSelf_>, hir::Generics) {\n-        let mut expl_self_opt = self.expl_self_opt.cloned();\n+    fn rebuild(&self) -> (hir::FnDecl, hir::Generics) {\n         let mut inputs = self.fn_decl.inputs.clone();\n         let mut output = self.fn_decl.output.clone();\n         let mut ty_params = self.generics.ty_params.clone();\n@@ -1089,8 +1079,6 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 Kept => { kept_lifetimes.insert(lifetime.name); }\n                 _ => ()\n             }\n-            expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n-                                                   &anon_nums, &region_names);\n             inputs = self.rebuild_args_ty(&inputs[..], lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n@@ -1110,7 +1098,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n             output: output,\n             variadic: self.fn_decl.variadic\n         };\n-        (new_fn_decl, expl_self_opt, generics)\n+        (new_fn_decl, generics)\n     }\n \n     fn pick_lifetime(&self,\n@@ -1250,34 +1238,6 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         }).collect()\n     }\n \n-    fn rebuild_expl_self(&self,\n-                         expl_self_opt: Option<hir::ExplicitSelf_>,\n-                         lifetime: hir::Lifetime,\n-                         anon_nums: &HashSet<u32>,\n-                         region_names: &HashSet<ast::Name>)\n-                         -> Option<hir::ExplicitSelf_> {\n-        match expl_self_opt {\n-            Some(ref expl_self) => match *expl_self {\n-                hir::SelfRegion(lt_opt, muta, id) => match lt_opt {\n-                    Some(lt) => if region_names.contains(&lt.name) {\n-                        return Some(hir::SelfRegion(Some(lifetime), muta, id));\n-                    },\n-                    None => {\n-                        let anon = self.cur_anon.get();\n-                        self.inc_and_offset_cur_anon(1);\n-                        if anon_nums.contains(&anon) {\n-                            self.track_anon(anon);\n-                            return Some(hir::SelfRegion(Some(lifetime), muta, id));\n-                        }\n-                    }\n-                },\n-                _ => ()\n-            },\n-            None => ()\n-        }\n-        expl_self_opt\n-    }\n-\n     fn rebuild_generics(&self,\n                         generics: &hir::Generics,\n                         add: &Vec<hir::Lifetime>,\n@@ -1575,11 +1535,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n                                 name: ast::Name,\n-                                opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                                 generics: &hir::Generics,\n                                 span: Span) {\n-        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, name,\n-                                                 opt_explicit_self, generics);\n+        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, name, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n         err.span_help(span, &msg[..]);"}, {"sha": "0801f8f4ac7ef8bc63e5d18325b6fc2fb89c3210", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -889,11 +889,6 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         run_lints!(self, check_lifetime_def, late_passes, lt);\n     }\n \n-    fn visit_explicit_self(&mut self, es: &hir::ExplicitSelf) {\n-        run_lints!(self, check_explicit_self, late_passes, es);\n-        hir_visit::walk_explicit_self(self, es);\n-    }\n-\n     fn visit_path(&mut self, p: &hir::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, late_passes, p, id);\n         hir_visit::walk_path(self, p);"}, {"sha": "932f2882b496335a8deb23d0c1a0675991779ea3", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -483,7 +483,6 @@ impl<'a> LifetimeContext<'a> {\n             FnKind::Method(_, sig, _, _) => {\n                 intravisit::walk_fn_decl(self, fd);\n                 self.visit_generics(&sig.generics);\n-                self.visit_explicit_self(&sig.explicit_self);\n             }\n             FnKind::Closure(_) => {\n                 intravisit::walk_fn_decl(self, fd);"}, {"sha": "e914c38963cab872d9c298f389678c9aaa395b52", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -172,7 +172,6 @@ mod svh_visitor {\n         SawImplItem,\n         SawStructField,\n         SawVariant,\n-        SawExplicitSelf,\n         SawPath,\n         SawBlock,\n         SawPat,\n@@ -391,10 +390,6 @@ mod svh_visitor {\n             SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n         }\n \n-        fn visit_explicit_self(&mut self, es: &'a ExplicitSelf) {\n-            SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es)\n-        }\n-\n         fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n             SawPath.hash(self.st); visit::walk_path(self, path)\n         }"}, {"sha": "f1e744098b960bd0d1068a040620ce321cb8ad1c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -831,8 +831,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                                 }\n                             }\n                             hir::ImplItemKind::Method(ref sig, _) => {\n-                                if sig.explicit_self.node == hir::SelfStatic &&\n-                                      self.item_is_public(&impl_item.id, &impl_item.vis) {\n+                                if !sig.decl.has_self() &&\n+                                        self.item_is_public(&impl_item.id, &impl_item.vis) {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }"}, {"sha": "5b447a1690f6c8daa585f4d19b0b1bfe93313a8c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -596,7 +596,6 @@ impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n             }\n             FnKind::Method(_, sig, _) => {\n                 self.visit_generics(&sig.generics);\n-                self.visit_explicit_self(&sig.explicit_self);\n                 MethodRibKind\n             }\n             FnKind::Closure => ClosureRibKind(node_id),"}, {"sha": "4faefb610562df32e0dfdebda5b327ca830a4229", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -75,7 +75,7 @@ use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::parse::token::{self, keywords};\n \n use rustc::hir::print as pprust;\n-use rustc::hir;\n+use rustc::hir::{self, SelfKind};\n use rustc_back::slice;\n \n pub trait AstConv<'gcx, 'tcx> {\n@@ -166,11 +166,6 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n-struct SelfInfo<'a, 'tcx> {\n-    untransformed_self_ty: Ty<'tcx>,\n-    explicit_self: &'a hir::ExplicitSelf,\n-}\n-\n type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n \n pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n@@ -1719,33 +1714,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         sig: &hir::MethodSig,\n                         untransformed_self_ty: Ty<'tcx>)\n                         -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n-        let self_info = Some(SelfInfo {\n-            untransformed_self_ty: untransformed_self_ty,\n-            explicit_self: &sig.explicit_self,\n-        });\n         let (bare_fn_ty, optional_explicit_self_category) =\n             self.ty_of_method_or_bare_fn(sig.unsafety,\n                                          sig.abi,\n-                                         self_info,\n+                                         Some(untransformed_self_ty),\n                                          &sig.decl);\n-        (bare_fn_ty, optional_explicit_self_category.unwrap())\n+        (bare_fn_ty, optional_explicit_self_category)\n     }\n \n     pub fn ty_of_bare_fn(&self,\n-                         unsafety: hir::Unsafety, abi: abi::Abi,\n+                         unsafety: hir::Unsafety,\n+                         abi: abi::Abi,\n                          decl: &hir::FnDecl)\n                          -> &'tcx ty::BareFnTy<'tcx> {\n-        let (bare_fn_ty, _) = self.ty_of_method_or_bare_fn(unsafety, abi, None, decl);\n-        bare_fn_ty\n+        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl).0\n     }\n \n     fn ty_of_method_or_bare_fn<'a>(&self,\n                                    unsafety: hir::Unsafety,\n                                    abi: abi::Abi,\n-                                   opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n+                                   opt_untransformed_self_ty: Option<Ty<'tcx>>,\n                                    decl: &hir::FnDecl)\n-                                   -> (&'tcx ty::BareFnTy<'tcx>,\n-                                       Option<ty::ExplicitSelfCategory>)\n+                                   -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory)\n     {\n         debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1758,9 +1748,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // lifetime elision, we can determine it in two ways. First (determined\n         // here), if self is by-reference, then the implied output region is the\n         // region of the self parameter.\n-        let (self_ty, explicit_self_category) = match opt_self_info {\n-            None => (None, None),\n-            Some(self_info) => self.determine_self_type(&rb, self_info)\n+        let explicit_self = decl.inputs.get(0).and_then(hir::Arg::to_self);\n+        let (self_ty, explicit_self_category) = match (opt_untransformed_self_ty, explicit_self) {\n+            (Some(untransformed_self_ty), Some(explicit_self)) => {\n+                let self_type = self.determine_self_type(&rb, untransformed_self_ty,\n+                                                         &explicit_self);\n+                (Some(self_type.0), self_type.1)\n+            }\n+            _ => (None, ty::ExplicitSelfCategory::Static),\n         };\n \n         // HACK(eddyb) replace the fake self type in the AST with the actual type.\n@@ -1778,7 +1773,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // reference) in the arguments, then any anonymous regions in the output\n         // have that lifetime.\n         let implied_output_region = match explicit_self_category {\n-            Some(ty::ExplicitSelfCategory::ByReference(region, _)) => Ok(region),\n+            ty::ExplicitSelfCategory::ByReference(region, _) => Ok(region),\n             _ => self.find_implied_output_region(&arg_tys, arg_pats)\n         };\n \n@@ -1803,29 +1798,29 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn determine_self_type<'a>(&self,\n                                rscope: &RegionScope,\n-                               self_info: SelfInfo<'a, 'tcx>)\n-                               -> (Option<Ty<'tcx>>, Option<ty::ExplicitSelfCategory>)\n+                               untransformed_self_ty: Ty<'tcx>,\n+                               explicit_self: &hir::ExplicitSelf)\n+                               -> (Ty<'tcx>, ty::ExplicitSelfCategory)\n     {\n-        let self_ty = self_info.untransformed_self_ty;\n-        return match self_info.explicit_self.node {\n-            hir::SelfStatic => (None, Some(ty::ExplicitSelfCategory::Static)),\n-            hir::SelfValue(_) => {\n-                (Some(self_ty), Some(ty::ExplicitSelfCategory::ByValue))\n+        return match explicit_self.node {\n+            SelfKind::Value(..) => {\n+                (untransformed_self_ty, ty::ExplicitSelfCategory::ByValue)\n             }\n-            hir::SelfRegion(ref lifetime, mutability, _) => {\n+            SelfKind::Region(ref lifetime, mutability) => {\n                 let region =\n-                    self.opt_ast_region_to_region(rscope,\n-                                                  self_info.explicit_self.span,\n-                                                  lifetime);\n-                (Some(self.tcx().mk_ref(\n+                    self.opt_ast_region_to_region(\n+                                             rscope,\n+                                             explicit_self.span,\n+                                             lifetime);\n+                (self.tcx().mk_ref(\n                     self.tcx().mk_region(region),\n                     ty::TypeAndMut {\n-                        ty: self_ty,\n+                        ty: untransformed_self_ty,\n                         mutbl: mutability\n-                    })),\n-                 Some(ty::ExplicitSelfCategory::ByReference(region, mutability)))\n+                    }),\n+                 ty::ExplicitSelfCategory::ByReference(region, mutability))\n             }\n-            hir::SelfExplicit(ref ast_type, _) => {\n+            SelfKind::Explicit(ref ast_type, _) => {\n                 let explicit_type = self.ast_ty_to_ty(rscope, &ast_type);\n \n                 // We wish to (for now) categorize an explicit self\n@@ -1857,13 +1852,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // type has two, so we end up with\n                 // ExplicitSelfCategory::ByReference.\n \n-                let impl_modifiers = count_modifiers(self_info.untransformed_self_ty);\n+                let impl_modifiers = count_modifiers(untransformed_self_ty);\n                 let method_modifiers = count_modifiers(explicit_type);\n \n                 debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={:?} \\\n                        explicit_type={:?} \\\n                        modifiers=({},{})\",\n-                       self_info.untransformed_self_ty,\n+                       untransformed_self_ty,\n                        explicit_type,\n                        impl_modifiers,\n                        method_modifiers);\n@@ -1878,7 +1873,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     }\n                 };\n \n-                (Some(explicit_type), Some(category))\n+                (explicit_type, category)\n             }\n         };\n "}, {"sha": "f5d54123f37b52a018bee19ad27259ba87b8fba6", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -361,7 +361,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                 let mut item = method.clean(cx);\n                 item.inner = match item.inner.clone() {\n                     clean::TyMethodItem(clean::TyMethod {\n-                        unsafety, decl, self_, generics, abi\n+                        unsafety, decl, generics, abi\n                     }) => {\n                         let constness = if tcx.sess.cstore.is_const_fn(did) {\n                             hir::Constness::Const\n@@ -373,7 +373,6 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                             unsafety: unsafety,\n                             constness: constness,\n                             decl: decl,\n-                            self_: self_,\n                             generics: generics,\n                             abi: abi\n                         })"}, {"sha": "ce83c4a258ce9b8b9a7e7d906c25790788549cb6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 44, "deletions": 69, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -1025,7 +1025,6 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Method {\n     pub generics: Generics,\n-    pub self_: SelfTy,\n     pub unsafety: hir::Unsafety,\n     pub constness: hir::Constness,\n     pub decl: FnDecl,\n@@ -1034,22 +1033,16 @@ pub struct Method {\n \n impl Clean<Method> for hir::MethodSig {\n     fn clean(&self, cx: &DocContext) -> Method {\n-        let all_inputs = &self.decl.inputs;\n-        let inputs = match self.explicit_self.node {\n-            hir::SelfStatic => &**all_inputs,\n-            _ => &all_inputs[1..]\n-        };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.clean(cx),\n+                values: self.decl.inputs.clean(cx),\n             },\n             output: self.decl.output.clean(cx),\n             variadic: false,\n             attrs: Vec::new()\n         };\n         Method {\n             generics: self.generics.clean(cx),\n-            self_: self.explicit_self.node.clean(cx),\n             unsafety: self.unsafety,\n             constness: self.constness,\n             decl: decl,\n@@ -1063,19 +1056,14 @@ pub struct TyMethod {\n     pub unsafety: hir::Unsafety,\n     pub decl: FnDecl,\n     pub generics: Generics,\n-    pub self_: SelfTy,\n     pub abi: Abi,\n }\n \n impl Clean<TyMethod> for hir::MethodSig {\n     fn clean(&self, cx: &DocContext) -> TyMethod {\n-        let inputs = match self.explicit_self.node {\n-            hir::SelfStatic => &*self.decl.inputs,\n-            _ => &self.decl.inputs[1..]\n-        };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.clean(cx),\n+                values: self.decl.inputs.clean(cx),\n             },\n             output: self.decl.output.clean(cx),\n             variadic: false,\n@@ -1084,34 +1072,12 @@ impl Clean<TyMethod> for hir::MethodSig {\n         TyMethod {\n             unsafety: self.unsafety.clone(),\n             decl: decl,\n-            self_: self.explicit_self.node.clean(cx),\n             generics: self.generics.clean(cx),\n             abi: self.abi\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n-pub enum SelfTy {\n-    SelfStatic,\n-    SelfValue,\n-    SelfBorrowed(Option<Lifetime>, Mutability),\n-    SelfExplicit(Type),\n-}\n-\n-impl Clean<SelfTy> for hir::ExplicitSelf_ {\n-    fn clean(&self, cx: &DocContext) -> SelfTy {\n-        match *self {\n-            hir::SelfStatic => SelfStatic,\n-            hir::SelfValue(_) => SelfValue,\n-            hir::SelfRegion(ref lt, ref mt, _) => {\n-                SelfBorrowed(lt.clean(cx), mt.clean(cx))\n-            }\n-            hir::SelfExplicit(ref typ, _) => SelfExplicit(typ.clean(cx)),\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n@@ -1150,6 +1116,12 @@ pub struct FnDecl {\n     pub attrs: Vec<Attribute>,\n }\n \n+impl FnDecl {\n+    pub fn has_self(&self) -> bool {\n+        return self.inputs.values.len() > 0 && self.inputs.values[0].name == \"self\";\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Arguments {\n     pub values: Vec<Argument>,\n@@ -1185,9 +1157,6 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n         } else {\n             cx.tcx().sess.cstore.method_arg_names(did).into_iter()\n         }.peekable();\n-        if let Some(\"self\") = names.peek().map(|s| &s[..]) {\n-            let _ = names.next();\n-        }\n         FnDecl {\n             output: Return(sig.0.output.clean(cx)),\n             attrs: Vec::new(),\n@@ -1212,6 +1181,29 @@ pub struct Argument {\n     pub id: ast::NodeId,\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+pub enum SelfTy {\n+    SelfValue,\n+    SelfBorrowed(Option<Lifetime>, Mutability),\n+    SelfExplicit(Type),\n+}\n+\n+impl Argument {\n+    pub fn to_self(&self) -> Option<SelfTy> {\n+        if self.name == \"self\" {\n+            match self.type_ {\n+                Infer => Some(SelfValue),\n+                BorrowedRef{ref lifetime, mutability, ref type_} if **type_ == Infer => {\n+                    Some(SelfBorrowed(lifetime.clone(), mutability))\n+                }\n+                _ => Some(SelfExplicit(self.type_.clone()))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl Clean<Argument> for hir::Arg {\n     fn clean(&self, cx: &DocContext) -> Argument {\n         Argument {\n@@ -1346,36 +1338,21 @@ impl Clean<Item> for hir::ImplItem {\n \n impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let (self_, sig) = match self.explicit_self {\n-            ty::ExplicitSelfCategory::Static => (hir::SelfStatic.clean(cx),\n-                                                 self.fty.sig.clone()),\n-            s => {\n-                let sig = ty::Binder(ty::FnSig {\n-                    inputs: self.fty.sig.0.inputs[1..].to_vec(),\n-                    ..self.fty.sig.0.clone()\n-                });\n-                let s = match s {\n-                    ty::ExplicitSelfCategory::ByValue => SelfValue,\n-                    ty::ExplicitSelfCategory::ByReference(..) => {\n-                        match self.fty.sig.0.inputs[0].sty {\n-                            ty::TyRef(r, mt) => {\n-                                SelfBorrowed(r.clean(cx), mt.mutbl.clean(cx))\n-                            }\n-                            _ => unreachable!(),\n-                        }\n-                    }\n-                    ty::ExplicitSelfCategory::ByBox => {\n-                        SelfExplicit(self.fty.sig.0.inputs[0].clean(cx))\n-                    }\n-                    ty::ExplicitSelfCategory::Static => unreachable!(),\n-                };\n-                (s, sig)\n-            }\n-        };\n-\n         let generics = (&self.generics, &self.predicates,\n                         subst::FnSpace).clean(cx);\n-        let decl = (self.def_id, &sig).clean(cx);\n+        let mut decl = (self.def_id, &self.fty.sig).clean(cx);\n+        match self.explicit_self {\n+            ty::ExplicitSelfCategory::ByValue => {\n+                decl.inputs.values[0].type_ = Infer;\n+            }\n+            ty::ExplicitSelfCategory::ByReference(..) => {\n+                match decl.inputs.values[0].type_ {\n+                    BorrowedRef{ref mut type_, ..} => **type_ = Infer,\n+                    _ => unreachable!(),\n+                }\n+            }\n+            _ => {}\n+        }\n         let provided = match self.container {\n             ty::ImplContainer(..) => false,\n             ty::TraitContainer(did) => {\n@@ -1388,7 +1365,6 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             MethodItem(Method {\n                 unsafety: self.fty.unsafety,\n                 generics: generics,\n-                self_: self_,\n                 decl: decl,\n                 abi: self.fty.abi,\n \n@@ -1399,7 +1375,6 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             TyMethodItem(TyMethod {\n                 unsafety: self.fty.unsafety,\n                 generics: generics,\n-                self_: self_,\n                 decl: decl,\n                 abi: self.fty.abi,\n             })"}, {"sha": "d4fdafea88adeccf1a61c58b14dd55485f939b21", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -43,7 +43,7 @@ pub struct UnsafetySpace(pub hir::Unsafety);\n #[derive(Copy, Clone)]\n pub struct ConstnessSpace(pub hir::Constness);\n /// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'a>(pub &'a clean::SelfTy, pub &'a clean::FnDecl);\n+pub struct Method<'a>(pub &'a clean::FnDecl);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n@@ -648,29 +648,31 @@ impl fmt::Display for clean::FnDecl {\n \n impl<'a> fmt::Display for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let Method(selfty, d) = *self;\n+        let decl = self.0;\n         let mut args = String::new();\n-        match *selfty {\n-            clean::SelfStatic => {},\n-            clean::SelfValue => args.push_str(\"self\"),\n-            clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                args.push_str(&format!(\"&amp;{} {}self\", *lt, MutableSpace(mtbl)));\n-            }\n-            clean::SelfBorrowed(None, mtbl) => {\n-                args.push_str(&format!(\"&amp;{}self\", MutableSpace(mtbl)));\n-            }\n-            clean::SelfExplicit(ref typ) => {\n-                args.push_str(&format!(\"self: {}\", *typ));\n-            }\n-        }\n-        for (i, input) in d.inputs.values.iter().enumerate() {\n+        for (i, input) in decl.inputs.values.iter().enumerate() {\n             if i > 0 || !args.is_empty() { args.push_str(\", \"); }\n-            if !input.name.is_empty() {\n-                args.push_str(&format!(\"{}: \", input.name));\n+            if let Some(selfty) = input.to_self() {\n+                match selfty {\n+                    clean::SelfValue => args.push_str(\"self\"),\n+                    clean::SelfBorrowed(Some(ref lt), mtbl) => {\n+                        args.push_str(&format!(\"&amp;{} {}self\", *lt, MutableSpace(mtbl)));\n+                    }\n+                    clean::SelfBorrowed(None, mtbl) => {\n+                        args.push_str(&format!(\"&amp;{}self\", MutableSpace(mtbl)));\n+                    }\n+                    clean::SelfExplicit(ref typ) => {\n+                        args.push_str(&format!(\"self: {}\", *typ));\n+                    }\n+                }\n+            } else {\n+                if !input.name.is_empty() {\n+                    args.push_str(&format!(\"{}: \", input.name));\n+                }\n+                args.push_str(&format!(\"{}\", input.type_));\n             }\n-            args.push_str(&format!(\"{}\", input.type_));\n         }\n-        write!(f, \"({args}){arrow}\", args = args, arrow = d.output)\n+        write!(f, \"({args}){arrow}\", args = args, arrow = decl.output)\n     }\n }\n "}, {"sha": "005e25b07d42d35c7fe603ffc47549f00330f69d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -62,7 +62,7 @@ use rustc::middle::stability;\n use rustc::session::config::get_unstable_features_setting;\n use rustc::hir;\n \n-use clean::{self, SelfTy, Attributes, GetDefId};\n+use clean::{self, Attributes, GetDefId};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -592,16 +592,14 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for &(did, ref item) in orphan_methods {\n         match paths.get(&did) {\n             Some(&(ref fqp, _)) => {\n-                // Needed to determine `self` type.\n-                let parent_basename = Some(fqp[fqp.len() - 1].clone());\n                 search_index.push(IndexItem {\n                     ty: shortty(item),\n                     name: item.name.clone().unwrap(),\n                     path: fqp[..fqp.len() - 1].join(\"::\"),\n                     desc: Escape(&shorter(item.doc_value())).to_string(),\n                     parent: Some(did),\n                     parent_idx: None,\n-                    search_type: get_index_search_type(&item, parent_basename),\n+                    search_type: get_index_search_type(&item),\n                 });\n             },\n             None => {}\n@@ -1081,13 +1079,6 @@ impl DocFolder for Cache {\n \n             match parent {\n                 (parent, Some(path)) if is_method || (!self.stripped_mod) => {\n-                    // Needed to determine `self` type.\n-                    let parent_basename = self.parent_stack.first().and_then(|parent| {\n-                        match self.paths.get(parent) {\n-                            Some(&(ref fqp, _)) => Some(fqp[fqp.len() - 1].clone()),\n-                            _ => None\n-                        }\n-                    });\n                     debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n@@ -1101,7 +1092,7 @@ impl DocFolder for Cache {\n                             desc: Escape(&shorter(item.doc_value())).to_string(),\n                             parent: parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item, parent_basename),\n+                            search_type: get_index_search_type(&item),\n                         });\n                     }\n                 }\n@@ -2167,7 +2158,6 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n               constness: hir::Constness,\n               abi: abi::Abi,\n               g: &clean::Generics,\n-              selfty: &clean::SelfTy,\n               d: &clean::FnDecl,\n               link: AssocItemLink)\n               -> fmt::Result {\n@@ -2201,18 +2191,18 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                href = href,\n                name = name,\n                generics = *g,\n-               decl = Method(selfty, d),\n+               decl = Method(d),\n                where_clause = WhereClause(g))\n     }\n     match item.inner {\n         clean::StrippedItem(..) => Ok(()),\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.unsafety, hir::Constness::NotConst,\n-                   m.abi, &m.generics, &m.self_, &m.decl, link)\n+                   m.abi, &m.generics, &m.decl, link)\n         }\n         clean::MethodItem(ref m) => {\n             method(w, item, m.unsafety, m.constness,\n-                   m.abi, &m.generics, &m.self_, &m.decl,\n+                   m.abi, &m.generics, &m.decl,\n                    link)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {\n@@ -2570,8 +2560,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         let name = item.name.as_ref().unwrap();\n \n         let is_static = match item.inner {\n-            clean::MethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n-            clean::TyMethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n+            clean::MethodItem(ref method) => !method.decl.has_self(),\n+            clean::TyMethodItem(ref method) => !method.decl.has_self(),\n             _ => false\n         };\n \n@@ -2760,27 +2750,15 @@ fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())\n }\n \n-fn get_index_search_type(item: &clean::Item,\n-                         parent: Option<String>) -> Option<IndexItemFunctionType> {\n-    let (decl, selfty) = match item.inner {\n-        clean::FunctionItem(ref f) => (&f.decl, None),\n-        clean::MethodItem(ref m) => (&m.decl, Some(&m.self_)),\n-        clean::TyMethodItem(ref m) => (&m.decl, Some(&m.self_)),\n+fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n+    let decl = match item.inner {\n+        clean::FunctionItem(ref f) => &f.decl,\n+        clean::MethodItem(ref m) => &m.decl,\n+        clean::TyMethodItem(ref m) => &m.decl,\n         _ => return None\n     };\n \n-    let mut inputs = Vec::new();\n-\n-    // Consider `self` an argument as well.\n-    match parent.and_then(|p| selfty.map(|s| (p, s)) ) {\n-        Some((_, &clean::SelfStatic)) | None => (),\n-        Some((name, _)) => inputs.push(Type { name: Some(name.to_ascii_lowercase()) }),\n-    }\n-\n-    inputs.extend(&mut decl.inputs.values.iter().map(|arg| {\n-        get_index_type(&arg.type_)\n-    }));\n-\n+    let inputs = decl.inputs.values.iter().map(|arg| get_index_type(&arg.type_)).collect();\n     let output = match decl.output {\n         clean::FunctionRetTy::Return(ref return_type) => Some(get_index_type(return_type)),\n         _ => None"}, {"sha": "0f3b9be3a7ac640619912baa6d6165003c545cb9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 65, "deletions": 18, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -16,13 +16,12 @@ pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n \n use attr::ThinAttributes;\n-use codemap::{Span, Spanned, DUMMY_SP, ExpnId};\n+use codemap::{mk_sp, respan, Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n use errors;\n use ext::base;\n use ext::tt::macro_parser;\n-use parse::token::InternedString;\n-use parse::token;\n+use parse::token::{self, keywords, InternedString};\n use parse::lexer;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use print::pprust;\n@@ -1674,7 +1673,25 @@ pub struct Arg {\n     pub id: NodeId,\n }\n \n+/// Represents the kind of 'self' associated with a method.\n+/// String representation of `Ident` here is always \"self\", but hygiene contexts may differ.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum SelfKind {\n+    /// No self\n+    Static,\n+    /// `self`, `mut self`\n+    Value(Ident),\n+    /// `&'lt self`, `&'lt mut self`\n+    Region(Option<Lifetime>, Mutability, Ident),\n+    /// `self: TYPE`, `mut self: TYPE`\n+    Explicit(P<Ty>, Ident),\n+}\n+\n+pub type ExplicitSelf = Spanned<SelfKind>;\n+\n impl Arg {\n+    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n+    #[rustc_deprecated(since = \"1.10.0\", reason = \"use `from_self` instead\")]\n     pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n         let path = Spanned{span:span,node:self_ident};\n         Arg {\n@@ -1692,6 +1709,51 @@ impl Arg {\n             id: DUMMY_NODE_ID\n         }\n     }\n+\n+    pub fn to_self(&self) -> Option<ExplicitSelf> {\n+        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+            if ident.node.name == keywords::SelfValue.name() {\n+                return match self.ty.node {\n+                    TyKind::Infer => Some(respan(self.pat.span, SelfKind::Value(ident.node))),\n+                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::Infer => {\n+                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl, ident.node)))\n+                    }\n+                    _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n+                                     SelfKind::Explicit(self.ty.clone(), ident.node))),\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn from_self(eself: ExplicitSelf, ident_sp: Span, mutbl: Mutability) -> Arg {\n+        let pat = |ident, span| P(Pat {\n+            id: DUMMY_NODE_ID,\n+            node: PatKind::Ident(BindingMode::ByValue(mutbl), respan(ident_sp, ident), None),\n+            span: span,\n+        });\n+        let infer_ty = P(Ty {\n+            id: DUMMY_NODE_ID,\n+            node: TyKind::Infer,\n+            span: DUMMY_SP,\n+        });\n+        let arg = |ident, ty, span| Arg {\n+            pat: pat(ident, span),\n+            ty: ty,\n+            id: DUMMY_NODE_ID,\n+        };\n+        match eself.node {\n+            SelfKind::Static => panic!(\"bug: `Arg::from_self` is called \\\n+                                        with `SelfKind::Static` argument\"),\n+            SelfKind::Explicit(ty, ident) => arg(ident, ty, mk_sp(eself.span.lo, ident_sp.hi)),\n+            SelfKind::Value(ident) => arg(ident, infer_ty, eself.span),\n+            SelfKind::Region(lt, mutbl, ident) => arg(ident, P(Ty {\n+                id: DUMMY_NODE_ID,\n+                node: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl: mutbl }),\n+                span: DUMMY_SP,\n+            }), eself.span),\n+        }\n+    }\n }\n \n /// Represents the header (not the body) of a function declaration\n@@ -1772,21 +1834,6 @@ impl FunctionRetTy {\n     }\n }\n \n-/// Represents the kind of 'self' associated with a method\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum SelfKind {\n-    /// No self\n-    Static,\n-    /// `self`\n-    Value(Ident),\n-    /// `&'lt self`, `&'lt mut self`\n-    Region(Option<Lifetime>, Mutability, Ident),\n-    /// `self: TYPE`\n-    Explicit(P<Ty>, Ident),\n-}\n-\n-pub type ExplicitSelf = Spanned<SelfKind>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`."}, {"sha": "fc62cee92fdbc5948b2dec120236b7125c927129", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 102, "deletions": 144, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -2036,7 +2036,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse mutability declaration (mut/const/imm)\n+    /// Parse mutability (`mut` or nothing).\n     pub fn parse_mutability(&mut self) -> PResult<'a, Mutability> {\n         if self.eat_keyword(keywords::Mut) {\n             Ok(Mutability::Mutable)\n@@ -4616,184 +4616,142 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn expect_self_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.token {\n-            token::Ident(id) if id.name == keywords::SelfValue.name() => {\n-                self.bump();\n-                // The hygiene context of `id` needs to be preserved here,\n-                // so we can't just return `SelfValue.ident()`.\n-                Ok(id)\n-            },\n-            _ => {\n-                let token_str = self.this_token_to_string();\n-                return Err(self.fatal(&format!(\"expected `self`, found `{}`\",\n-                                   token_str)))\n-            }\n-        }\n-    }\n-\n-    /// Parse the argument list and result type of a function\n-    /// that may have a self type.\n+    /// Parse the parameter list and result type of a function that may have a `self` parameter.\n     fn parse_fn_decl_with_self<F>(&mut self,\n-                                  parse_arg_fn: F) -> PResult<'a, (ExplicitSelf, P<FnDecl>)> where\n-        F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n+                                  parse_arg_fn: F)\n+                                  -> PResult<'a, (ExplicitSelf, P<FnDecl>)>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n     {\n-        fn maybe_parse_borrowed_explicit_self<'b>(this: &mut Parser<'b>)\n-                                                  -> PResult<'b, ast::SelfKind> {\n-            // The following things are possible to see here:\n-            //\n-            //     fn(&mut self)\n-            //     fn(&mut self)\n-            //     fn(&'lt self)\n-            //     fn(&'lt mut self)\n-            //\n-            // We already know that the current token is `&`.\n-\n-            if this.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n-                this.bump();\n-                Ok(SelfKind::Region(None, Mutability::Immutable, this.expect_self_ident()?))\n-            } else if this.look_ahead(1, |t| t.is_mutability()) &&\n-                      this.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n-                this.bump();\n-                let mutability = this.parse_mutability()?;\n-                Ok(SelfKind::Region(None, mutability, this.expect_self_ident()?))\n-            } else if this.look_ahead(1, |t| t.is_lifetime()) &&\n-                      this.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n-                this.bump();\n-                let lifetime = this.parse_lifetime()?;\n-                let ident = this.expect_self_ident()?;\n-                Ok(SelfKind::Region(Some(lifetime), Mutability::Immutable, ident))\n-            } else if this.look_ahead(1, |t| t.is_lifetime()) &&\n-                      this.look_ahead(2, |t| t.is_mutability()) &&\n-                      this.look_ahead(3, |t| t.is_keyword(keywords::SelfValue)) {\n-                this.bump();\n-                let lifetime = this.parse_lifetime()?;\n-                let mutability = this.parse_mutability()?;\n-                Ok(SelfKind::Region(Some(lifetime), mutability, this.expect_self_ident()?))\n-            } else {\n-                Ok(SelfKind::Static)\n-            }\n-        }\n+        let expect_ident = |this: &mut Self| match this.token {\n+            token::Ident(ident) => { this.bump(); ident } // Preserve hygienic context.\n+            _ => unreachable!()\n+        };\n \n         self.expect(&token::OpenDelim(token::Paren))?;\n \n-        // A bit of complexity and lookahead is needed here in order to be\n-        // backwards compatible.\n-        let lo = self.span.lo;\n-        let mut self_ident_lo = self.span.lo;\n-        let mut self_ident_hi = self.span.hi;\n-\n-        let mut mutbl_self = Mutability::Immutable;\n-        let explicit_self = match self.token {\n+        // Parse optional self parameter of a method.\n+        // Only a limited set of initial token sequences is considered self parameters, anything\n+        // else is parsed as a normal function parameter list, so some lookahead is required.\n+        let eself_lo = self.span.lo;\n+        let mut eself_mutbl = Mutability::Immutable;\n+        let (eself, eself_ident_sp) = match self.token {\n             token::BinOp(token::And) => {\n-                let eself = maybe_parse_borrowed_explicit_self(self)?;\n-                self_ident_lo = self.last_span.lo;\n-                self_ident_hi = self.last_span.hi;\n-                eself\n+                // &self\n+                // &mut self\n+                // &'lt self\n+                // &'lt mut self\n+                // &not_self\n+                if self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    (SelfKind::Region(None, Mutability::Immutable, expect_ident(self)),\n+                        self.last_span)\n+                } else if self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n+                          self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    self.bump();\n+                    (SelfKind::Region(None, Mutability::Mutable, expect_ident(self)),\n+                        self.last_span)\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n+                          self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    let lt = self.parse_lifetime()?;\n+                    (SelfKind::Region(Some(lt), Mutability::Immutable, expect_ident(self)),\n+                        self.last_span)\n+                } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n+                          self.look_ahead(2, |t| t.is_keyword(keywords::Mut)) &&\n+                          self.look_ahead(3, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    let lt = self.parse_lifetime()?;\n+                    self.bump();\n+                    (SelfKind::Region(Some(lt), Mutability::Mutable, expect_ident(self)),\n+                        self.last_span)\n+                } else {\n+                    (SelfKind::Static, codemap::DUMMY_SP)\n+                }\n             }\n             token::BinOp(token::Star) => {\n-                // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n-                // emitting cryptic \"unexpected token\" errors.\n-                self.bump();\n-                let _mutability = if self.token.is_mutability() {\n-                    self.parse_mutability()?\n-                } else {\n-                    Mutability::Immutable\n-                };\n-                if self.token.is_keyword(keywords::SelfValue) {\n-                    let span = self.span;\n-                    self.span_err(span, \"cannot pass self by raw pointer\");\n+                // *self\n+                // *const self\n+                // *mut self\n+                // *not_self\n+                // Emit special error for `self` cases.\n+                if self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n+                    self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n+                    (SelfKind::Value(expect_ident(self)), self.last_span)\n+                } else if self.look_ahead(1, |t| t.is_mutability()) &&\n+                          self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n+                    self.bump();\n+                    self.bump();\n+                    self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n+                    (SelfKind::Value(expect_ident(self)), self.last_span)\n+                } else {\n+                    (SelfKind::Static, codemap::DUMMY_SP)\n                 }\n-                // error case, making bogus self ident:\n-                SelfKind::Value(keywords::SelfValue.ident())\n             }\n             token::Ident(..) => {\n                 if self.token.is_keyword(keywords::SelfValue) {\n-                    let self_ident = self.expect_self_ident()?;\n-\n-                    // Determine whether this is the fully explicit form, `self:\n-                    // TYPE`.\n+                    // self\n+                    // self: TYPE\n+                    let eself_ident = expect_ident(self);\n+                    let eself_ident_sp = self.last_span;\n                     if self.eat(&token::Colon) {\n-                        SelfKind::Explicit(self.parse_ty_sum()?, self_ident)\n+                        (SelfKind::Explicit(self.parse_ty_sum()?, eself_ident), eself_ident_sp)\n                     } else {\n-                        SelfKind::Value(self_ident)\n+                        (SelfKind::Value(eself_ident), eself_ident_sp)\n                     }\n-                } else if self.token.is_mutability() &&\n+                } else if self.token.is_keyword(keywords::Mut) &&\n                         self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n-                    mutbl_self = self.parse_mutability()?;\n-                    let self_ident = self.expect_self_ident()?;\n-\n-                    // Determine whether this is the fully explicit form,\n-                    // `self: TYPE`.\n+                    // mut self\n+                    // mut self: TYPE\n+                    eself_mutbl = Mutability::Mutable;\n+                    self.bump();\n+                    let eself_ident = expect_ident(self);\n+                    let eself_ident_sp = self.last_span;\n                     if self.eat(&token::Colon) {\n-                        SelfKind::Explicit(self.parse_ty_sum()?, self_ident)\n+                        (SelfKind::Explicit(self.parse_ty_sum()?, eself_ident), eself_ident_sp)\n                     } else {\n-                        SelfKind::Value(self_ident)\n+                        (SelfKind::Value(eself_ident), eself_ident_sp)\n                     }\n                 } else {\n-                    SelfKind::Static\n+                    (SelfKind::Static, codemap::DUMMY_SP)\n                 }\n             }\n-            _ => SelfKind::Static,\n+            _ => (SelfKind::Static, codemap::DUMMY_SP)\n         };\n+        let mut eself = codemap::respan(mk_sp(eself_lo, self.last_span.hi), eself);\n \n-        let explicit_self_sp = mk_sp(self_ident_lo, self_ident_hi);\n-\n-        // shared fall-through for the three cases below. borrowing prevents simply\n-        // writing this as a closure\n-        macro_rules! parse_remaining_arguments {\n-            ($self_id:ident) =>\n-            {\n-            // If we parsed a self type, expect a comma before the argument list.\n-            match self.token {\n-                token::Comma => {\n+        // Parse the rest of the function parameter list.\n+        let sep = SeqSep::trailing_allowed(token::Comma);\n+        let fn_inputs = match eself.node {\n+            SelfKind::Static => {\n+                eself.span = codemap::DUMMY_SP;\n+                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n+            }\n+            SelfKind::Value(..) | SelfKind::Region(..) | SelfKind::Explicit(..) => {\n+                if self.check(&token::CloseDelim(token::Paren)) {\n+                    vec![Arg::from_self(eself.clone(), eself_ident_sp, eself_mutbl)]\n+                } else if self.check(&token::Comma) {\n                     self.bump();\n-                    let sep = SeqSep::trailing_allowed(token::Comma);\n-                    let mut fn_inputs = self.parse_seq_to_before_end(\n-                        &token::CloseDelim(token::Paren),\n-                        sep,\n-                        parse_arg_fn\n+                    let mut fn_inputs = vec![Arg::from_self(eself.clone(), eself_ident_sp,\n+                                                            eself_mutbl)];\n+                    fn_inputs.append(&mut self.parse_seq_to_before_end(\n+                        &token::CloseDelim(token::Paren), sep, parse_arg_fn)\n                     );\n-                    fn_inputs.insert(0, Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n                     fn_inputs\n-                }\n-                token::CloseDelim(token::Paren) => {\n-                    vec!(Arg::new_self(explicit_self_sp, mutbl_self, $self_id))\n-                }\n-                _ => {\n-                    let token_str = self.this_token_to_string();\n-                    return Err(self.fatal(&format!(\"expected `,` or `)`, found `{}`\",\n-                                       token_str)))\n+                } else {\n+                    return self.unexpected();\n                 }\n             }\n-            }\n-        }\n-\n-        let fn_inputs = match explicit_self {\n-            SelfKind::Static =>  {\n-                let sep = SeqSep::trailing_allowed(token::Comma);\n-                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n-            }\n-            SelfKind::Value(id) => parse_remaining_arguments!(id),\n-            SelfKind::Region(_,_,id) => parse_remaining_arguments!(id),\n-            SelfKind::Explicit(_,id) => parse_remaining_arguments!(id),\n         };\n \n-\n+        // Parse closing paren and return type.\n         self.expect(&token::CloseDelim(token::Paren))?;\n-\n-        let hi = self.span.hi;\n-\n-        let ret_ty = self.parse_ret_ty()?;\n-\n-        let fn_decl = P(FnDecl {\n+        Ok((eself, P(FnDecl {\n             inputs: fn_inputs,\n-            output: ret_ty,\n+            output: self.parse_ret_ty()?,\n             variadic: false\n-        });\n-\n-        Ok((spanned(lo, hi, explicit_self), fn_decl))\n+        })))\n     }\n \n     // parse the |arg, arg| header on a lambda"}, {"sha": "ebb4927d69c0b7cfad3d5f80bc1c509ca2fc84c6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -1522,7 +1522,7 @@ impl<'a> State<'a> {\n                       m.abi,\n                       Some(ident),\n                       &m.generics,\n-                      Some(&m.explicit_self.node),\n+                      None,\n                       vis)\n     }\n \n@@ -2656,36 +2656,9 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_args(&mut self, decl: &ast::FnDecl,\n-                         opt_explicit_self: Option<&ast::SelfKind>,\n+                         _: Option<&ast::SelfKind>,\n                          is_closure: bool) -> io::Result<()> {\n-        // It is unfortunate to duplicate the commasep logic, but we want the\n-        // self type and the args all in the same box.\n-        self.rbox(0, Inconsistent)?;\n-        let mut first = true;\n-        if let Some(explicit_self) = opt_explicit_self {\n-            let m = match *explicit_self {\n-                ast::SelfKind::Static => ast::Mutability::Immutable,\n-                _ => match decl.inputs[0].pat.node {\n-                    PatKind::Ident(ast::BindingMode::ByValue(m), _, _) => m,\n-                    _ => ast::Mutability::Immutable\n-                }\n-            };\n-            first = !self.print_explicit_self(explicit_self, m)?;\n-        }\n-\n-        // HACK(eddyb) ignore the separately printed self argument.\n-        let args = if first {\n-            &decl.inputs[..]\n-        } else {\n-            &decl.inputs[1..]\n-        };\n-\n-        for arg in args {\n-            if first { first = false; } else { self.word_space(\",\")?; }\n-            self.print_arg(arg, is_closure)?;\n-        }\n-\n-        self.end()\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, is_closure))\n     }\n \n     pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl,\n@@ -2956,18 +2929,24 @@ impl<'a> State<'a> {\n         match input.ty.node {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n-                match input.pat.node {\n-                    PatKind::Ident(_, ref path1, _)\n-                            if path1.node.name == keywords::Invalid.name() => {\n-                        // Do nothing.\n+                let (mutbl, invalid) = match input.pat.node {\n+                    PatKind::Ident(ast::BindingMode::ByValue(mutbl), ident, _) |\n+                    PatKind::Ident(ast::BindingMode::ByRef(mutbl), ident, _) => {\n+                        (mutbl, ident.node.name == keywords::Invalid.name())\n                     }\n-                    _ => {\n+                    _ => (ast::Mutability::Immutable, false)\n+                };\n+\n+                if let Some(eself) = input.to_self() {\n+                    self.print_explicit_self(&eself.node, mutbl)?;\n+                } else {\n+                    if !invalid {\n                         self.print_pat(&input.pat)?;\n                         word(&mut self.s, \":\")?;\n                         space(&mut self.s)?;\n                     }\n+                    self.print_type(&input.ty)?;\n                 }\n-                self.print_type(&input.ty)?;\n             }\n         }\n         self.end()"}, {"sha": "20fb4bf32ccb7671687348f3359779802d085269", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -867,9 +867,8 @@ impl<'a> MethodDef<'a> {\n         let self_arg = match explicit_self.node {\n             ast::SelfKind::Static => None,\n             // creating fresh self id\n-            _ => Some(ast::Arg::new_self(trait_.span,\n-                                         ast::Mutability::Immutable,\n-                                         keywords::SelfValue.ident()))\n+            _ => Some(ast::Arg::from_self(explicit_self.clone(), trait_.span,\n+                                          ast::Mutability::Immutable)),\n         };\n         let args = {\n             let args = arg_types.into_iter().map(|(name, ty)| {"}, {"sha": "fd011318a4800a4eac29452e9230387184aa58b1", "filename": "src/test/compile-fail/self-infer.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Ftest%2Fcompile-fail%2Fself-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Ftest%2Fcompile-fail%2Fself-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself-infer.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+impl S {\n+    fn f(self: _) {} //~ERROR the type placeholder `_` is not allowed within types on item sig\n+    fn g(self: &_) {} //~ERROR the type placeholder `_` is not allowed within types on item sig\n+}\n+\n+fn main() {}"}, {"sha": "699af8ca7ab4fda5bfce891b768c19f32308d7a3", "filename": "src/test/parse-fail/issue-33413.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Ftest%2Fparse-fail%2Fissue-33413.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Ftest%2Fparse-fail%2Fissue-33413.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-33413.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+impl S {\n+    fn f(*, a: u8) -> u8 {} //~ ERROR expected pattern, found `*`\n+    //~^ ERROR expected one of `)`, `-`, `box`, `false`, `mut`, `ref`, or `true`, found `*`\n+}"}, {"sha": "22baf88b43f5a2de2e1cc7cc29fc3a476ca64d0f", "filename": "src/test/parse-fail/no-unsafe-self.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Ftest%2Fparse-fail%2Fno-unsafe-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e87cd7e380c89e3f80ceab417e3525e546a1e362/src%2Ftest%2Fparse-fail%2Fno-unsafe-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fno-unsafe-self.rs?ref=e87cd7e380c89e3f80ceab417e3525e546a1e362", "patch": "@@ -11,14 +11,16 @@\n // compile-flags: -Z parse-only -Z continue-parse-after-error\n \n trait A {\n-    fn foo(*mut self); //~ ERROR cannot pass self by raw pointer\n-    fn bar(*self); //~ ERROR cannot pass self by raw pointer\n+    fn foo(*mut self); //~ ERROR cannot pass `self` by raw pointer\n+    fn baz(*const self); //~ ERROR cannot pass `self` by raw pointer\n+    fn bar(*self); //~ ERROR cannot pass `self` by raw pointer\n }\n \n struct X;\n impl A for X {\n-    fn foo(*mut self) { } //~ ERROR cannot pass self by raw pointer\n-    fn bar(*self) { } //~ ERROR cannot pass self by raw pointer\n+    fn foo(*mut self) { } //~ ERROR cannot pass `self` by raw pointer\n+    fn baz(*const self) { } //~ ERROR cannot pass `self` by raw pointer\n+    fn bar(*self) { } //~ ERROR cannot pass `self` by raw pointer\n }\n \n fn main() { }"}]}