{"sha": "b638d8c75f4e38c75c5caa52b10b18a350431687", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MzhkOGM3NWY0ZTM4Yzc1YzVjYWE1MmIxMGIxOGEzNTA0MzE2ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-27T11:47:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-27T11:47:03Z"}, "message": "Auto merge of #53656 - nnethercote:HybridIdxSet-tweaks, r=nikomatsakis\n\n`HybridIdxSet` tweaks\n\nA couple of tweaks to `HybridIdxSet`.\n\nr? @nikomatsakis", "tree": {"sha": "c1dacc3d092d28dce7552358bffbe50c40e44bf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1dacc3d092d28dce7552358bffbe50c40e44bf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b638d8c75f4e38c75c5caa52b10b18a350431687", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b638d8c75f4e38c75c5caa52b10b18a350431687", "html_url": "https://github.com/rust-lang/rust/commit/b638d8c75f4e38c75c5caa52b10b18a350431687", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b638d8c75f4e38c75c5caa52b10b18a350431687/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "291d958585296b39df0d8ecc785b8786e14cd523", "url": "https://api.github.com/repos/rust-lang/rust/commits/291d958585296b39df0d8ecc785b8786e14cd523", "html_url": "https://github.com/rust-lang/rust/commit/291d958585296b39df0d8ecc785b8786e14cd523"}, {"sha": "626b2987a9d9f36c9f0586e91f19d1f3062666a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/626b2987a9d9f36c9f0586e91f19d1f3062666a7", "html_url": "https://github.com/rust-lang/rust/commit/626b2987a9d9f36c9f0586e91f19d1f3062666a7"}], "stats": {"total": 194, "additions": 110, "deletions": 84}, "files": [{"sha": "65fdf10a86d13f7d6fa1897a7bbe9a40f9adea62", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 100, "deletions": 74, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/b638d8c75f4e38c75c5caa52b10b18a350431687/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b638d8c75f4e38c75c5caa52b10b18a350431687/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=b638d8c75f4e38c75c5caa52b10b18a350431687", "patch": "@@ -19,6 +19,20 @@ use bitslice::{bitwise, Union, Subtract, Intersect};\n use indexed_vec::Idx;\n use rustc_serialize;\n \n+/// This is implemented by all the index sets so that IdxSet::union() can be\n+/// passed any type of index set.\n+pub trait UnionIntoIdxSet<T: Idx> {\n+    // Performs `other = other | self`.\n+    fn union_into(&self, other: &mut IdxSet<T>) -> bool;\n+}\n+\n+/// This is implemented by all the index sets so that IdxSet::subtract() can be\n+/// passed any type of index set.\n+pub trait SubtractFromIdxSet<T: Idx> {\n+    // Performs `other = other - self`.\n+    fn subtract_from(&self, other: &mut IdxSet<T>) -> bool;\n+}\n+\n /// Represents a set of some element type E, where each E is identified by some\n /// unique index type `T`.\n ///\n@@ -68,34 +82,34 @@ impl<T: Idx> fmt::Debug for IdxSet<T> {\n }\n \n impl<T: Idx> IdxSet<T> {\n-    fn new(init: Word, universe_size: usize) -> Self {\n-        let num_words = (universe_size + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n+    fn new(init: Word, domain_size: usize) -> Self {\n+        let num_words = (domain_size + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n         IdxSet {\n             _pd: Default::default(),\n             bits: vec![init; num_words],\n         }\n     }\n \n-    /// Creates set holding every element whose index falls in range 0..universe_size.\n-    pub fn new_filled(universe_size: usize) -> Self {\n-        let mut result = Self::new(!0, universe_size);\n-        result.trim_to(universe_size);\n+    /// Creates set holding every element whose index falls in range 0..domain_size.\n+    pub fn new_filled(domain_size: usize) -> Self {\n+        let mut result = Self::new(!0, domain_size);\n+        result.trim_to(domain_size);\n         result\n     }\n \n     /// Creates set holding no elements.\n-    pub fn new_empty(universe_size: usize) -> Self {\n-        Self::new(0, universe_size)\n+    pub fn new_empty(domain_size: usize) -> Self {\n+        Self::new(0, domain_size)\n     }\n \n     /// Duplicates as a hybrid set.\n     pub fn to_hybrid(&self) -> HybridIdxSet<T> {\n-        // This universe_size may be slightly larger than the one specified\n+        // This domain_size may be slightly larger than the one specified\n         // upon creation, due to rounding up to a whole word. That's ok.\n-        let universe_size = self.bits.len() * BITS_PER_WORD;\n+        let domain_size = self.bits.len() * BITS_PER_WORD;\n \n         // Note: we currently don't bother trying to make a Sparse set.\n-        HybridIdxSet::Dense(self.to_owned(), universe_size)\n+        HybridIdxSet::Dense(self.to_owned(), domain_size)\n     }\n \n     /// Removes all elements\n@@ -105,29 +119,29 @@ impl<T: Idx> IdxSet<T> {\n         }\n     }\n \n-    /// Sets all elements up to `universe_size`\n-    pub fn set_up_to(&mut self, universe_size: usize) {\n+    /// Sets all elements up to `domain_size`\n+    pub fn set_up_to(&mut self, domain_size: usize) {\n         for b in &mut self.bits {\n             *b = !0;\n         }\n-        self.trim_to(universe_size);\n+        self.trim_to(domain_size);\n     }\n \n-    /// Clear all elements above `universe_size`.\n-    fn trim_to(&mut self, universe_size: usize) {\n+    /// Clear all elements above `domain_size`.\n+    fn trim_to(&mut self, domain_size: usize) {\n         // `trim_block` is the first block where some bits have\n         // to be cleared.\n-        let trim_block = universe_size / BITS_PER_WORD;\n+        let trim_block = domain_size / BITS_PER_WORD;\n \n         // all the blocks above it have to be completely cleared.\n         if trim_block < self.bits.len() {\n             for b in &mut self.bits[trim_block+1..] {\n                 *b = 0;\n             }\n \n-            // at that block, the `universe_size % BITS_PER_WORD` lsbs\n+            // at that block, the `domain_size % BITS_PER_WORD` LSBs\n             // should remain.\n-            let remaining_bits = universe_size % BITS_PER_WORD;\n+            let remaining_bits = domain_size % BITS_PER_WORD;\n             let mask = (1<<remaining_bits)-1;\n             self.bits[trim_block] &= mask;\n         }\n@@ -164,48 +178,14 @@ impl<T: Idx> IdxSet<T> {\n \n     /// Set `self = self | other` and return true if `self` changed\n     /// (i.e., if new bits were added).\n-    pub fn union(&mut self, other: &IdxSet<T>) -> bool {\n-        bitwise(self.words_mut(), other.words(), &Union)\n-    }\n-\n-    /// Like `union()`, but takes a `SparseIdxSet` argument.\n-    fn union_sparse(&mut self, other: &SparseIdxSet<T>) -> bool {\n-        let mut changed = false;\n-        for elem in other.iter() {\n-            changed |= self.add(&elem);\n-        }\n-        changed\n-    }\n-\n-    /// Like `union()`, but takes a `HybridIdxSet` argument.\n-    pub fn union_hybrid(&mut self, other: &HybridIdxSet<T>) -> bool {\n-        match other {\n-            HybridIdxSet::Sparse(sparse, _) => self.union_sparse(sparse),\n-            HybridIdxSet::Dense(dense, _) => self.union(dense),\n-        }\n+    pub fn union(&mut self, other: &impl UnionIntoIdxSet<T>) -> bool {\n+        other.union_into(self)\n     }\n \n     /// Set `self = self - other` and return true if `self` changed.\n     /// (i.e., if any bits were removed).\n-    pub fn subtract(&mut self, other: &IdxSet<T>) -> bool {\n-        bitwise(self.words_mut(), other.words(), &Subtract)\n-    }\n-\n-    /// Like `subtract()`, but takes a `SparseIdxSet` argument.\n-    fn subtract_sparse(&mut self, other: &SparseIdxSet<T>) -> bool {\n-        let mut changed = false;\n-        for elem in other.iter() {\n-            changed |= self.remove(&elem);\n-        }\n-        changed\n-    }\n-\n-    /// Like `subtract()`, but takes a `HybridIdxSet` argument.\n-    pub fn subtract_hybrid(&mut self, other: &HybridIdxSet<T>) -> bool {\n-        match other {\n-            HybridIdxSet::Sparse(sparse, _) => self.subtract_sparse(sparse),\n-            HybridIdxSet::Dense(dense, _) => self.subtract(dense),\n-        }\n+    pub fn subtract(&mut self, other: &impl SubtractFromIdxSet<T>) -> bool {\n+        other.subtract_from(self)\n     }\n \n     /// Set `self = self & other` and return true if `self` changed.\n@@ -223,6 +203,18 @@ impl<T: Idx> IdxSet<T> {\n     }\n }\n \n+impl<T: Idx> UnionIntoIdxSet<T> for IdxSet<T> {\n+    fn union_into(&self, other: &mut IdxSet<T>) -> bool {\n+        bitwise(other.words_mut(), self.words(), &Union)\n+    }\n+}\n+\n+impl<T: Idx> SubtractFromIdxSet<T> for IdxSet<T> {\n+    fn subtract_from(&self, other: &mut IdxSet<T>) -> bool {\n+        bitwise(other.words_mut(), self.words(), &Subtract)\n+    }\n+}\n+\n pub struct Iter<'a, T: Idx> {\n     cur: Option<(Word, usize)>,\n     iter: iter::Enumerate<slice::Iter<'a, Word>>,\n@@ -293,8 +285,8 @@ impl<T: Idx> SparseIdxSet<T> {\n         }\n     }\n \n-    fn to_dense(&self, universe_size: usize) -> IdxSet<T> {\n-        let mut dense = IdxSet::new_empty(universe_size);\n+    fn to_dense(&self, domain_size: usize) -> IdxSet<T> {\n+        let mut dense = IdxSet::new_empty(domain_size);\n         for elem in self.0.iter() {\n             dense.add(elem);\n         }\n@@ -308,6 +300,26 @@ impl<T: Idx> SparseIdxSet<T> {\n     }\n }\n \n+impl<T: Idx> UnionIntoIdxSet<T> for SparseIdxSet<T> {\n+    fn union_into(&self, other: &mut IdxSet<T>) -> bool {\n+        let mut changed = false;\n+        for elem in self.iter() {\n+            changed |= other.add(&elem);\n+        }\n+        changed\n+    }\n+}\n+\n+impl<T: Idx> SubtractFromIdxSet<T> for SparseIdxSet<T> {\n+    fn subtract_from(&self, other: &mut IdxSet<T>) -> bool {\n+        let mut changed = false;\n+        for elem in self.iter() {\n+            changed |= other.remove(&elem);\n+        }\n+        changed\n+    }\n+}\n+\n pub struct SparseIter<'a, T: Idx> {\n     iter: slice::Iter<'a, T>,\n }\n@@ -323,28 +335,24 @@ impl<'a, T: Idx> Iterator for SparseIter<'a, T> {\n /// Like IdxSet, but with a hybrid representation: sparse when there are few\n /// elements in the set, but dense when there are many. It's especially\n /// efficient for sets that typically have a small number of elements, but a\n-/// large `universe_size`, and are cleared frequently.\n+/// large `domain_size`, and are cleared frequently.\n #[derive(Clone, Debug)]\n pub enum HybridIdxSet<T: Idx> {\n     Sparse(SparseIdxSet<T>, usize),\n     Dense(IdxSet<T>, usize),\n }\n \n impl<T: Idx> HybridIdxSet<T> {\n-    pub fn new_empty(universe_size: usize) -> Self {\n-        HybridIdxSet::Sparse(SparseIdxSet::new(), universe_size)\n+    pub fn new_empty(domain_size: usize) -> Self {\n+        HybridIdxSet::Sparse(SparseIdxSet::new(), domain_size)\n     }\n \n-    fn universe_size(&mut self) -> usize {\n-        match *self {\n+    pub fn clear(&mut self) {\n+        let domain_size = match *self {\n             HybridIdxSet::Sparse(_, size) => size,\n             HybridIdxSet::Dense(_, size) => size,\n-        }\n-    }\n-\n-    pub fn clear(&mut self) {\n-        let universe_size = self.universe_size();\n-        *self = HybridIdxSet::new_empty(universe_size);\n+        };\n+        *self = HybridIdxSet::new_empty(domain_size);\n     }\n \n     /// Returns true iff set `self` contains `elem`.\n@@ -374,11 +382,11 @@ impl<T: Idx> HybridIdxSet<T> {\n                 //        appease the borrow checker.\n                 let dummy = HybridIdxSet::Sparse(SparseIdxSet::new(), 0);\n                 match mem::replace(self, dummy) {\n-                    HybridIdxSet::Sparse(sparse, universe_size) => {\n-                        let mut dense = sparse.to_dense(universe_size);\n+                    HybridIdxSet::Sparse(sparse, domain_size) => {\n+                        let mut dense = sparse.to_dense(domain_size);\n                         let changed = dense.add(elem);\n                         assert!(changed);\n-                        mem::replace(self, HybridIdxSet::Dense(dense, universe_size));\n+                        mem::replace(self, HybridIdxSet::Dense(dense, domain_size));\n                         changed\n                     }\n                     _ => panic!(\"impossible\"),\n@@ -401,7 +409,7 @@ impl<T: Idx> HybridIdxSet<T> {\n     /// Converts to a dense set, consuming itself in the process.\n     pub fn to_dense(self) -> IdxSet<T> {\n         match self {\n-            HybridIdxSet::Sparse(sparse, universe_size) => sparse.to_dense(universe_size),\n+            HybridIdxSet::Sparse(sparse, domain_size) => sparse.to_dense(domain_size),\n             HybridIdxSet::Dense(dense, _) => dense,\n         }\n     }\n@@ -415,6 +423,24 @@ impl<T: Idx> HybridIdxSet<T> {\n     }\n }\n \n+impl<T: Idx> UnionIntoIdxSet<T> for HybridIdxSet<T> {\n+    fn union_into(&self, other: &mut IdxSet<T>) -> bool {\n+        match self {\n+            HybridIdxSet::Sparse(sparse, _) => sparse.union_into(other),\n+            HybridIdxSet::Dense(dense, _) => dense.union_into(other),\n+        }\n+    }\n+}\n+\n+impl<T: Idx> SubtractFromIdxSet<T> for HybridIdxSet<T> {\n+    fn subtract_from(&self, other: &mut IdxSet<T>) -> bool {\n+        match self {\n+            HybridIdxSet::Sparse(sparse, _) => sparse.subtract_from(other),\n+            HybridIdxSet::Dense(dense, _) => dense.subtract_from(other),\n+        }\n+    }\n+}\n+\n pub enum HybridIter<'a, T: Idx> {\n     Sparse(SparseIter<'a, T>),\n     Dense(Iter<'a, T>),"}, {"sha": "1f7faa21a12c06c892dfd7eefbe33371e76e96fd", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b638d8c75f4e38c75c5caa52b10b18a350431687/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b638d8c75f4e38c75c5caa52b10b18a350431687/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=b638d8c75f4e38c75c5caa52b10b18a350431687", "patch": "@@ -129,8 +129,8 @@ where\n         F: FnOnce(Iter<BD::Idx>),\n     {\n         let mut curr_state = self.curr_state.clone();\n-        curr_state.union_hybrid(&self.stmt_gen);\n-        curr_state.subtract_hybrid(&self.stmt_kill);\n+        curr_state.union(&self.stmt_gen);\n+        curr_state.subtract(&self.stmt_kill);\n         f(curr_state.iter());\n     }\n }\n@@ -193,8 +193,8 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n     }\n \n     fn apply_local_effect(&mut self, _loc: Location) {\n-        self.curr_state.union_hybrid(&self.stmt_gen);\n-        self.curr_state.subtract_hybrid(&self.stmt_kill);\n+        self.curr_state.union(&self.stmt_gen);\n+        self.curr_state.subtract(&self.stmt_kill);\n     }\n }\n "}, {"sha": "48d349978686df58db2574200ec8a7cf114571ed", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b638d8c75f4e38c75c5caa52b10b18a350431687/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b638d8c75f4e38c75c5caa52b10b18a350431687/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=b638d8c75f4e38c75c5caa52b10b18a350431687", "patch": "@@ -241,8 +241,8 @@ impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: Bi\n                 let sets = self.builder.flow_state.sets.for_block(bb.index());\n                 debug_assert!(in_out.words().len() == sets.on_entry.words().len());\n                 in_out.overwrite(sets.on_entry);\n-                in_out.union_hybrid(sets.gen_set);\n-                in_out.subtract_hybrid(sets.kill_set);\n+                in_out.union(sets.gen_set);\n+                in_out.subtract(sets.kill_set);\n             }\n             self.builder.propagate_bits_into_graph_successors_of(\n                 in_out, (bb, bb_data), &mut dirty_queue);\n@@ -534,8 +534,8 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n     }\n \n     fn apply_local_effect(&mut self) {\n-        self.on_entry.union_hybrid(&self.gen_set);\n-        self.on_entry.subtract_hybrid(&self.kill_set);\n+        self.on_entry.union(self.gen_set);\n+        self.on_entry.subtract(self.kill_set);\n     }\n }\n "}, {"sha": "eda7de0fd79d48da9ade13918219acb914d4af23", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b638d8c75f4e38c75c5caa52b10b18a350431687/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b638d8c75f4e38c75c5caa52b10b18a350431687/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=b638d8c75f4e38c75c5caa52b10b18a350431687", "patch": "@@ -209,8 +209,8 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             &mut sets, Location { block: bb, statement_index: j });\n         results.0.operator.statement_effect(\n             &mut sets, Location { block: bb, statement_index: j });\n-        sets.on_entry.union_hybrid(sets.gen_set);\n-        sets.on_entry.subtract_hybrid(sets.kill_set);\n+        sets.on_entry.union(sets.gen_set);\n+        sets.on_entry.subtract(sets.kill_set);\n     }\n \n     results.0.operator.before_terminator_effect("}]}