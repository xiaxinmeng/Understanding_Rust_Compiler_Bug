{"sha": "8eaf68f92c213358dda59dc3eb648036ab62e18d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYWY2OGY5MmMyMTMzNThkZGE1OWRjM2ViNjQ4MDM2YWI2MmUxOGQ=", "commit": {"author": {"name": "J. Ryan Stinnett", "email": "jryans@gmail.com", "date": "2021-01-03T13:13:30Z"}, "committer": {"name": "J. Ryan Stinnett", "email": "jryans@gmail.com", "date": "2021-01-08T07:15:03Z"}, "message": "Preserve non-local recursive `Deref` impls\n\nThis adjusts the `rustdoc` trait impl collection path to preserve `Deref` impls\nfrom other crates. This adds a first pass to map all of the `Deref` type to\ntarget edges and then recursively preserves all targets.", "tree": {"sha": "c647188378110e5958ae64f5f4e90942215905db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c647188378110e5958ae64f5f4e90942215905db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8eaf68f92c213358dda59dc3eb648036ab62e18d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8eaf68f92c213358dda59dc3eb648036ab62e18d", "html_url": "https://github.com/rust-lang/rust/commit/8eaf68f92c213358dda59dc3eb648036ab62e18d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8eaf68f92c213358dda59dc3eb648036ab62e18d/comments", "author": {"login": "jryans", "id": 279572, "node_id": "MDQ6VXNlcjI3OTU3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/279572?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jryans", "html_url": "https://github.com/jryans", "followers_url": "https://api.github.com/users/jryans/followers", "following_url": "https://api.github.com/users/jryans/following{/other_user}", "gists_url": "https://api.github.com/users/jryans/gists{/gist_id}", "starred_url": "https://api.github.com/users/jryans/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jryans/subscriptions", "organizations_url": "https://api.github.com/users/jryans/orgs", "repos_url": "https://api.github.com/users/jryans/repos", "events_url": "https://api.github.com/users/jryans/events{/privacy}", "received_events_url": "https://api.github.com/users/jryans/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jryans", "id": 279572, "node_id": "MDQ6VXNlcjI3OTU3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/279572?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jryans", "html_url": "https://github.com/jryans", "followers_url": "https://api.github.com/users/jryans/followers", "following_url": "https://api.github.com/users/jryans/following{/other_user}", "gists_url": "https://api.github.com/users/jryans/gists{/gist_id}", "starred_url": "https://api.github.com/users/jryans/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jryans/subscriptions", "organizations_url": "https://api.github.com/users/jryans/orgs", "repos_url": "https://api.github.com/users/jryans/repos", "events_url": "https://api.github.com/users/jryans/events{/privacy}", "received_events_url": "https://api.github.com/users/jryans/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06ce97c3c938c18ed392e72e535931443c1455c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/06ce97c3c938c18ed392e72e535931443c1455c0", "html_url": "https://github.com/rust-lang/rust/commit/06ce97c3c938c18ed392e72e535931443c1455c0"}], "stats": {"total": 126, "additions": 90, "deletions": 36}, "files": [{"sha": "7b5e9e5905f334372eadb979d930c92d81ddf81b", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 64, "deletions": 36, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf68f92c213358dda59dc3eb648036ab62e18d/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf68f92c213358dda59dc3eb648036ab62e18d/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=8eaf68f92c213358dda59dc3eb648036ab62e18d", "patch": "@@ -3,7 +3,7 @@ use crate::clean::*;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n@@ -54,39 +54,6 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         }\n     }\n \n-    let mut cleaner = BadImplStripper { prims, items: crate_items };\n-\n-    // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n-    for it in &new_items {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if cleaner.keep_item(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n-                let target = items\n-                    .iter()\n-                    .find_map(|item| match *item.kind {\n-                        TypedefItem(ref t, true) => Some(&t.type_),\n-                        _ => None,\n-                    })\n-                    .expect(\"Deref impl without Target type\");\n-\n-                if let Some(prim) = target.primitive_type() {\n-                    cleaner.prims.insert(prim);\n-                } else if let Some(did) = target.def_id() {\n-                    cleaner.items.insert(did);\n-                }\n-            }\n-        }\n-    }\n-\n-    new_items.retain(|it| {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n-            cleaner.keep_item(for_)\n-                || trait_.as_ref().map_or(false, |t| cleaner.keep_item(t))\n-                || blanket_impl.is_some()\n-        } else {\n-            true\n-        }\n-    });\n-\n     // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n     // doesn't work with it anyway, so pull them from the HIR map instead\n     for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n@@ -123,6 +90,63 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         }\n     }\n \n+    let mut cleaner = BadImplStripper { prims, items: crate_items };\n+\n+    let mut type_did_to_deref_target: FxHashMap<DefId, &Type> = FxHashMap::default();\n+    // Gather all type to `Deref` target edges.\n+    for it in &new_items {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n+            if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+                let target = items.iter().find_map(|item| match *item.kind {\n+                    TypedefItem(ref t, true) => Some(&t.type_),\n+                    _ => None,\n+                });\n+                if let (Some(for_did), Some(target)) = (for_.def_id(), target) {\n+                    type_did_to_deref_target.insert(for_did, target);\n+                }\n+            }\n+        }\n+    }\n+    // Follow all `Deref` targets of included items and recursively add them as valid\n+    fn add_deref_target(\n+        map: &FxHashMap<DefId, &Type>,\n+        cleaner: &mut BadImplStripper,\n+        type_did: &DefId,\n+    ) {\n+        if let Some(target) = map.get(type_did) {\n+            debug!(\"add_deref_target: type {:?}, target {:?}\", type_did, target);\n+            if let Some(target_prim) = target.primitive_type() {\n+                cleaner.prims.insert(target_prim);\n+            } else if let Some(target_did) = target.def_id() {\n+                // `impl Deref<Target = S> for S`\n+                if target_did == *type_did {\n+                    // Avoid infinite cycles\n+                    return;\n+                }\n+                cleaner.items.insert(target_did);\n+                add_deref_target(map, cleaner, &target_did);\n+            }\n+        }\n+    }\n+    for type_did in type_did_to_deref_target.keys() {\n+        // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n+        // `Deref` target type and the impl for type positions, this map of types is keyed by\n+        // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n+        if cleaner.keep_impl_with_def_id(type_did) {\n+            add_deref_target(&type_did_to_deref_target, &mut cleaner, type_did);\n+        }\n+    }\n+\n+    new_items.retain(|it| {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n+            cleaner.keep_impl(for_)\n+                || trait_.as_ref().map_or(false, |t| cleaner.keep_impl(t))\n+                || blanket_impl.is_some()\n+        } else {\n+            true\n+        }\n+    });\n+\n     if let Some(ref mut it) = krate.module {\n         if let ModuleItem(Module { ref mut items, .. }) = *it.kind {\n             items.extend(synth.impls);\n@@ -192,16 +216,20 @@ struct BadImplStripper {\n }\n \n impl BadImplStripper {\n-    fn keep_item(&self, ty: &Type) -> bool {\n+    fn keep_impl(&self, ty: &Type) -> bool {\n         if let Generic(_) = ty {\n             // keep impls made on generics\n             true\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n         } else if let Some(did) = ty.def_id() {\n-            self.items.contains(&did)\n+            self.keep_impl_with_def_id(&did)\n         } else {\n             false\n         }\n     }\n+\n+    fn keep_impl_with_def_id(&self, did: &DefId) -> bool {\n+        self.items.contains(did)\n+    }\n }"}, {"sha": "759e881aab4159f16ad1bd8a6770753386fceaad", "filename": "src/test/rustdoc/deref-recursive-pathbuf.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8eaf68f92c213358dda59dc3eb648036ab62e18d/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eaf68f92c213358dda59dc3eb648036ab62e18d/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs?ref=8eaf68f92c213358dda59dc3eb648036ab62e18d", "patch": "@@ -0,0 +1,26 @@\n+// ignore-tidy-linelength\n+\n+// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n+// levels and across multiple crates.\n+\n+// @has 'foo/struct.Foo.html'\n+// @has '-' '//*[@id=\"deref-methods-PathBuf\"]' 'Methods from Deref<Target = PathBuf>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.as_path\"]' 'pub fn as_path(&self)'\n+// @has '-' '//*[@id=\"deref-methods-Path\"]' 'Methods from Deref<Target = Path>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.exists\"]' 'pub fn exists(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-PathBuf\"]' 'Methods from Deref<Target=PathBuf>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.as_path\"]' 'as_path'\n+// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-Path\"]' 'Methods from Deref<Target=Path>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.exists\"]' 'exists'\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::Deref;\n+use std::path::PathBuf;\n+\n+pub struct Foo(PathBuf);\n+\n+impl Deref for Foo {\n+    type Target = PathBuf;\n+    fn deref(&self) -> &PathBuf { &self.0 }\n+}"}]}