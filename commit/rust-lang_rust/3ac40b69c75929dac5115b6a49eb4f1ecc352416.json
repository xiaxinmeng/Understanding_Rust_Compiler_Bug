{"sha": "3ac40b69c75929dac5115b6a49eb4f1ecc352416", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYzQwYjY5Yzc1OTI5ZGFjNTExNWI2YTQ5ZWI0ZjFlY2MzNTI0MTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-26T13:15:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-26T13:15:05Z"}, "message": "Auto merge of #67327 - oli-obk:cleanup, r=RalfJung\n\nSplit up `const_eval.rs`\n\nFixes #67316\n\nr? @RalfJung", "tree": {"sha": "4ae4ab11d07eb5689f76f6a8bbee77766731cd50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ae4ab11d07eb5689f76f6a8bbee77766731cd50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ac40b69c75929dac5115b6a49eb4f1ecc352416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac40b69c75929dac5115b6a49eb4f1ecc352416", "html_url": "https://github.com/rust-lang/rust/commit/3ac40b69c75929dac5115b6a49eb4f1ecc352416", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ac40b69c75929dac5115b6a49eb4f1ecc352416/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acb6690e1d58fc5f262ada5b5030fe73e601f1e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/acb6690e1d58fc5f262ada5b5030fe73e601f1e8", "html_url": "https://github.com/rust-lang/rust/commit/acb6690e1d58fc5f262ada5b5030fe73e601f1e8"}, {"sha": "07df1479e5c79e5f62520d5e13796a6696a16421", "url": "https://api.github.com/repos/rust-lang/rust/commits/07df1479e5c79e5f62520d5e13796a6696a16421", "html_url": "https://github.com/rust-lang/rust/commit/07df1479e5c79e5f62520d5e13796a6696a16421"}], "stats": {"total": 1625, "additions": 871, "deletions": 754}, "files": [{"sha": "63e63f304d213826029497c5432ea066c5a9d239", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 13, "deletions": 716, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=3ac40b69c75929dac5115b6a49eb4f1ecc352416", "patch": "@@ -1,511 +1,25 @@\n // Not in interpret to make sure we do not use private implementation details\n \n-use std::borrow::{Borrow, Cow};\n-use std::collections::hash_map::Entry;\n-use std::convert::TryInto;\n-use std::error::Error;\n-use std::fmt;\n-use std::hash::Hash;\n-\n-use crate::interpret::eval_nullary_intrinsic;\n-use rustc::hir::def::DefKind;\n-use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n-use rustc::traits::Reveal;\n-use rustc::ty::layout::{self, HasTyCtxt, LayoutOf, VariantIdx};\n-use rustc::ty::{self, subst::Subst, Ty, TyCtxt};\n-use rustc_data_structures::fx::FxHashMap;\n-\n-use syntax::{\n-    source_map::{Span, DUMMY_SP},\n-    symbol::Symbol,\n-};\n-\n-use crate::interpret::{\n-    self, intern_const_alloc_recursive, snapshot, AllocId, Allocation, AssertMessage, ConstValue,\n-    GlobalId, ImmTy, Immediate, InterpCx, InterpErrorInfo, InterpResult, MPlaceTy, Machine, Memory,\n-    MemoryKind, OpTy, PlaceTy, Pointer, RawConst, RefTracking, Scalar, StackPopCleanup,\n-};\n-\n-/// Number of steps until the detector even starts doing anything.\n-/// Also, a warning is shown to the user when this number is reached.\n-const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n-/// The number of steps between loop detector snapshots.\n-/// Should be a power of two for performance reasons.\n-const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n-\n-/// The `InterpCx` is only meant to be used to do field and index projections into constants for\n-/// `simd_shuffle` and const patterns in match arms.\n-///\n-/// The function containing the `match` that is currently being analyzed may have generic bounds\n-/// that inform us about the generic bounds of the constant. E.g., using an associated constant\n-/// of a function's generic parameter will require knowledge about the bounds on the generic\n-/// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n-fn mk_eval_cx<'mir, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    span: Span,\n-    param_env: ty::ParamEnv<'tcx>,\n-    can_access_statics: bool,\n-) -> CompileTimeEvalContext<'mir, 'tcx> {\n-    debug!(\"mk_eval_cx: {:?}\", param_env);\n-    InterpCx::new(\n-        tcx.at(span),\n-        param_env,\n-        CompileTimeInterpreter::new(),\n-        MemoryExtra { can_access_statics },\n-    )\n-}\n-\n-fn op_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n-    op: OpTy<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n-    // We do not have value optimizations for everything.\n-    // Only scalars and slices, since they are very common.\n-    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n-    // from scalar unions that are initialized with one of their zero sized variants. We could\n-    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n-    // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n-    // `Undef` situation.\n-    let try_as_immediate = match op.layout.abi {\n-        layout::Abi::Scalar(..) => true,\n-        layout::Abi::ScalarPair(..) => match op.layout.ty.kind {\n-            ty::Ref(_, inner, _) => match inner.kind {\n-                ty::Slice(elem) => elem == ecx.tcx.types.u8,\n-                ty::Str => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        },\n-        _ => false,\n-    };\n-    let immediate = if try_as_immediate {\n-        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n-    } else {\n-        // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n-        // When we come back from raw const eval, we are always by-ref. The only way our op here is\n-        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n-        // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n-        // structs containing such.\n-        op.try_as_mplace()\n-    };\n-    let val = match immediate {\n-        Ok(mplace) => {\n-            let ptr = mplace.ptr.to_ptr().unwrap();\n-            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-            ConstValue::ByRef { alloc, offset: ptr.offset }\n-        }\n-        // see comment on `let try_as_immediate` above\n-        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n-            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n-            ScalarMaybeUndef::Undef => {\n-                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n-                // argument and we will not need this. The only way we can already have an\n-                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n-                // comes from a constant so it can happen have `Undef`, because the indirect\n-                // memory that was read had undefined bytes.\n-                let mplace = op.assert_mem_place();\n-                let ptr = mplace.ptr.to_ptr().unwrap();\n-                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                ConstValue::ByRef { alloc, offset: ptr.offset }\n-            }\n-        },\n-        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n-            let (data, start) = match a.not_undef().unwrap() {\n-                Scalar::Ptr(ptr) => {\n-                    (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n-                }\n-                Scalar::Raw { .. } => (\n-                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n-                    0,\n-                ),\n-            };\n-            let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n-            let start = start.try_into().unwrap();\n-            let len: usize = len.try_into().unwrap();\n-            ConstValue::Slice { data, start, end: start + len }\n-        }\n-    };\n-    ecx.tcx.mk_const(ty::Const { val: ty::ConstKind::Value(val), ty: op.layout.ty })\n-}\n-\n-// Returns a pointer to where the result lives\n-fn eval_body_using_ecx<'mir, 'tcx>(\n-    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n-    cid: GlobalId<'tcx>,\n-    body: &'mir mir::Body<'tcx>,\n-) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n-    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n-    let tcx = ecx.tcx.tcx;\n-    let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n-    assert!(!layout.is_unsized());\n-    let ret = ecx.allocate(layout, MemoryKind::Stack);\n-\n-    let name = ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id()));\n-    let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n-    trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n-\n-    // Assert all args (if any) are zero-sized types; `eval_body_using_ecx` doesn't\n-    // make sense if the body is expecting nontrivial arguments.\n-    // (The alternative would be to use `eval_fn_call` with an args slice.)\n-    for arg in body.args_iter() {\n-        let decl = body.local_decls.get(arg).expect(\"arg missing from local_decls\");\n-        let layout = ecx.layout_of(decl.ty.subst(tcx, cid.instance.substs))?;\n-        assert!(layout.is_zst())\n-    }\n-\n-    ecx.push_stack_frame(\n-        cid.instance,\n-        body.span,\n-        body,\n-        Some(ret.into()),\n-        StackPopCleanup::None { cleanup: false },\n-    )?;\n-\n-    // The main interpreter loop.\n-    ecx.run()?;\n-\n-    // Intern the result\n-    intern_const_alloc_recursive(ecx, tcx.static_mutability(cid.instance.def_id()), ret)?;\n-\n-    debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n-    Ok(ret)\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum ConstEvalError {\n-    NeedsRfc(String),\n-    ConstAccessesStatic,\n-}\n-\n-impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n-    fn into(self) -> InterpErrorInfo<'tcx> {\n-        err_unsup!(Unsupported(self.to_string())).into()\n-    }\n-}\n-\n-impl fmt::Display for ConstEvalError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use self::ConstEvalError::*;\n-        match *self {\n-            NeedsRfc(ref msg) => {\n-                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n-            }\n-            ConstAccessesStatic => write!(f, \"constant accesses static\"),\n-        }\n-    }\n-}\n-\n-impl Error for ConstEvalError {}\n-\n-// Extra machine state for CTFE, and the Machine instance\n-pub struct CompileTimeInterpreter<'mir, 'tcx> {\n-    /// When this value is negative, it indicates the number of interpreter\n-    /// steps *until* the loop detector is enabled. When it is positive, it is\n-    /// the number of steps after the detector has been enabled modulo the loop\n-    /// detector period.\n-    pub(super) steps_since_detector_enabled: isize,\n-\n-    /// Extra state to detect loops.\n-    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'mir, 'tcx>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct MemoryExtra {\n-    /// Whether this machine may read from statics\n-    can_access_statics: bool,\n-}\n-\n-impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    fn new() -> Self {\n-        CompileTimeInterpreter {\n-            loop_detector: Default::default(),\n-            steps_since_detector_enabled: -STEPS_UNTIL_DETECTOR_ENABLED,\n-        }\n-    }\n-}\n-\n-impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n-    #[inline(always)]\n-    fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n-    where\n-        K: Borrow<Q>,\n-    {\n-        FxHashMap::contains_key(self, k)\n-    }\n-\n-    #[inline(always)]\n-    fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        FxHashMap::insert(self, k, v)\n-    }\n-\n-    #[inline(always)]\n-    fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n-    where\n-        K: Borrow<Q>,\n-    {\n-        FxHashMap::remove(self, k)\n-    }\n-\n-    #[inline(always)]\n-    fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n-        self.iter().filter_map(move |(k, v)| f(k, &*v)).collect()\n-    }\n-\n-    #[inline(always)]\n-    fn get_or<E>(&self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&V, E> {\n-        match self.get(&k) {\n-            Some(v) => Ok(v),\n-            None => {\n-                vacant()?;\n-                bug!(\"The CTFE machine shouldn't ever need to extend the alloc_map when reading\")\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n-        match self.entry(k) {\n-            Entry::Occupied(e) => Ok(e.into_mut()),\n-            Entry::Vacant(e) => {\n-                let v = vacant()?;\n-                Ok(e.insert(v))\n-            }\n-        }\n-    }\n-}\n-\n-crate type CompileTimeEvalContext<'mir, 'tcx> =\n-    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n+use rustc::ty::layout::VariantIdx;\n+use rustc::ty::{self, TyCtxt};\n \n-impl interpret::MayLeak for ! {\n-    #[inline(always)]\n-    fn may_leak(self) -> bool {\n-        // `self` is uninhabited\n-        self\n-    }\n-}\n-\n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n-    type MemoryKinds = !;\n-    type PointerTag = ();\n-    type ExtraFnVal = !;\n-\n-    type FrameExtra = ();\n-    type MemoryExtra = MemoryExtra;\n-    type AllocExtra = ();\n-\n-    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n-\n-    const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n-\n-    // We do not check for alignment to avoid having to carry an `Align`\n-    // in `ConstValue::ByRef`.\n-    const CHECK_ALIGN: bool = false;\n-\n-    #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        false // for now, we don't enforce validity\n-    }\n-\n-    fn find_mir_or_eval_fn(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n-        debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n-\n-        // Only check non-glue functions\n-        if let ty::InstanceDef::Item(def_id) = instance.def {\n-            // Execution might have wandered off into other crates, so we cannot do a stability-\n-            // sensitive check here.  But we can at least rule out functions that are not const\n-            // at all.\n-            if ecx.tcx.is_const_fn_raw(def_id) {\n-                // If this function is a `const fn` then as an optimization we can query this\n-                // evaluation immediately.\n-                //\n-                // For the moment we only do this for functions which take no arguments\n-                // (or all arguments are ZSTs) so that we don't memoize too much.\n-                //\n-                // Because `#[track_caller]` adds an implicit non-ZST argument, we also cannot\n-                // perform this optimization on items tagged with it.\n-                let no_implicit_args = !instance.def.requires_caller_location(ecx.tcx());\n-                if args.iter().all(|a| a.layout.is_zst()) && no_implicit_args {\n-                    let gid = GlobalId { instance, promoted: None };\n-                    ecx.eval_const_fn_call(gid, ret)?;\n-                    return Ok(None);\n-                }\n-            } else {\n-                // Some functions we support even if they are non-const -- but avoid testing\n-                // that for const fn!  We certainly do *not* want to actually call the fn\n-                // though, so be sure we return here.\n-                return if ecx.hook_panic_fn(instance, args, ret)? {\n-                    Ok(None)\n-                } else {\n-                    throw_unsup_format!(\"calling non-const function `{}`\", instance)\n-                };\n-            }\n-        }\n-        // This is a const fn. Call it.\n-        Ok(Some(match ecx.load_mir(instance.def, None) {\n-            Ok(body) => *body,\n-            Err(err) => {\n-                if let err_unsup!(NoMirFor(ref path)) = err.kind {\n-                    return Err(ConstEvalError::NeedsRfc(format!(\n-                        \"calling extern function `{}`\",\n-                        path\n-                    ))\n-                    .into());\n-                }\n-                return Err(err);\n-            }\n-        }))\n-    }\n-\n-    fn call_extra_fn(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        fn_val: !,\n-        _args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        match fn_val {}\n-    }\n-\n-    fn call_intrinsic(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        span: Span,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n-        _unwind: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        if ecx.emulate_intrinsic(span, instance, args, ret)? {\n-            return Ok(());\n-        }\n-        // An intrinsic that we do not support\n-        let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n-        Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n-    }\n+use syntax::{source_map::DUMMY_SP, symbol::Symbol};\n \n-    fn assert_panic(\n-        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _span: Span,\n-        msg: &AssertMessage<'tcx>,\n-        _unwind: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        use rustc::mir::interpret::PanicInfo::*;\n-        Err(match msg {\n-            BoundsCheck { ref len, ref index } => {\n-                let len = ecx\n-                    .read_immediate(ecx.eval_operand(len, None)?)\n-                    .expect(\"can't eval len\")\n-                    .to_scalar()?\n-                    .to_machine_usize(&*ecx)?;\n-                let index = ecx\n-                    .read_immediate(ecx.eval_operand(index, None)?)\n-                    .expect(\"can't eval index\")\n-                    .to_scalar()?\n-                    .to_machine_usize(&*ecx)?;\n-                err_panic!(BoundsCheck { len, index })\n-            }\n-            Overflow(op) => err_panic!(Overflow(*op)),\n-            OverflowNeg => err_panic!(OverflowNeg),\n-            DivisionByZero => err_panic!(DivisionByZero),\n-            RemainderByZero => err_panic!(RemainderByZero),\n-            ResumedAfterReturn(generator_kind) => err_panic!(ResumedAfterReturn(*generator_kind)),\n-            ResumedAfterPanic(generator_kind) => err_panic!(ResumedAfterPanic(*generator_kind)),\n-            Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n-        }\n-        .into())\n-    }\n+use crate::interpret::{intern_const_alloc_recursive, ConstValue, InterpCx};\n \n-    fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n-        Err(ConstEvalError::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n-    }\n+mod error;\n+mod eval_queries;\n+mod machine;\n \n-    fn binary_ptr_op(\n-        _ecx: &InterpCx<'mir, 'tcx, Self>,\n-        _bin_op: mir::BinOp,\n-        _left: ImmTy<'tcx>,\n-        _right: ImmTy<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        Err(ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n-    }\n-\n-    fn find_foreign_static(\n-        _tcx: TyCtxt<'tcx>,\n-        _def_id: DefId,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        throw_unsup!(ReadForeignStatic)\n-    }\n-\n-    #[inline(always)]\n-    fn init_allocation_extra<'b>(\n-        _memory_extra: &MemoryExtra,\n-        _id: AllocId,\n-        alloc: Cow<'b, Allocation>,\n-        _kind: Option<MemoryKind<!>>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n-        // We do not use a tag so we can just cheaply forward the allocation\n-        (alloc, ())\n-    }\n-\n-    #[inline(always)]\n-    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {\n-        ()\n-    }\n-\n-    fn box_alloc(\n-        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _dest: PlaceTy<'tcx>,\n-    ) -> InterpResult<'tcx> {\n-        Err(ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n-    }\n-\n-    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        {\n-            let steps = &mut ecx.machine.steps_since_detector_enabled;\n-\n-            *steps += 1;\n-            if *steps < 0 {\n-                return Ok(());\n-            }\n-\n-            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n-            if *steps != 0 {\n-                return Ok(());\n-            }\n-        }\n-\n-        let span = ecx.frame().span;\n-        ecx.machine.loop_detector.observe_and_analyze(*ecx.tcx, span, &ecx.memory, &ecx.stack[..])\n-    }\n-\n-    #[inline(always)]\n-    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    fn before_access_static(\n-        memory_extra: &MemoryExtra,\n-        _allocation: &Allocation,\n-    ) -> InterpResult<'tcx> {\n-        if memory_extra.can_access_statics {\n-            Ok(())\n-        } else {\n-            Err(ConstEvalError::ConstAccessesStatic.into())\n-        }\n-    }\n-}\n+pub use error::*;\n+pub use eval_queries::*;\n+pub use machine::*;\n \n /// Extracts a field of a (variant of a) const.\n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs\n-pub fn const_field<'tcx>(\n+pub(crate) fn const_field<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     variant: Option<VariantIdx>,\n@@ -528,7 +42,7 @@ pub fn const_field<'tcx>(\n     op_to_const(&ecx, field)\n }\n \n-pub fn const_caller_location<'tcx>(\n+pub(crate) fn const_caller_location<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (file, line, col): (Symbol, u32, u32),\n ) -> &'tcx ty::Const<'tcx> {\n@@ -548,7 +62,7 @@ pub fn const_caller_location<'tcx>(\n \n // this function uses `unwrap` copiously, because an already validated constant must have valid\n // fields and can thus never fail outside of compiler bugs\n-pub fn const_variant_index<'tcx>(\n+pub(crate) fn const_variant_index<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     val: &'tcx ty::Const<'tcx>,\n@@ -558,220 +72,3 @@ pub fn const_variant_index<'tcx>(\n     let op = ecx.eval_const_to_op(val, None).unwrap();\n     ecx.read_discriminant(op).unwrap().1\n }\n-\n-/// Turn an interpreter error into something to report to the user.\n-/// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n-/// Should be called only if the error is actually going to to be reported!\n-pub fn error_to_const_error<'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n-    ecx: &InterpCx<'mir, 'tcx, M>,\n-    mut error: InterpErrorInfo<'tcx>,\n-) -> ConstEvalErr<'tcx> {\n-    error.print_backtrace();\n-    let stacktrace = ecx.generate_stacktrace(None);\n-    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n-}\n-\n-pub fn note_on_undefined_behavior_error() -> &'static str {\n-    \"The rules on what exactly is undefined behavior aren't clear, \\\n-     so this check might be overzealous. Please open an issue on the rustc \\\n-     repository if you believe it should not be considered undefined behavior.\"\n-}\n-\n-fn validate_and_turn_into_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    constant: RawConst<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n-    let cid = key.value;\n-    let def_id = cid.instance.def.def_id();\n-    let is_static = tcx.is_static(def_id);\n-    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n-    let val = (|| {\n-        let mplace = ecx.raw_const_to_mplace(constant)?;\n-        let mut ref_tracking = RefTracking::new(mplace);\n-        while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-            ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n-        }\n-        // Now that we validated, turn this into a proper constant.\n-        // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n-        // whether they become immediates.\n-        if is_static || cid.promoted.is_some() {\n-            let ptr = mplace.ptr.to_ptr()?;\n-            Ok(tcx.mk_const(ty::Const {\n-                val: ty::ConstKind::Value(ConstValue::ByRef {\n-                    alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n-                    offset: ptr.offset,\n-                }),\n-                ty: mplace.layout.ty,\n-            }))\n-        } else {\n-            Ok(op_to_const(&ecx, mplace.into()))\n-        }\n-    })();\n-\n-    val.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error);\n-        match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n-            Ok(mut diag) => {\n-                diag.note(note_on_undefined_behavior_error());\n-                diag.emit();\n-                ErrorHandled::Reported\n-            }\n-            Err(err) => err,\n-        }\n-    })\n-}\n-\n-pub fn const_eval_validated_provider<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n-    // see comment in const_eval_raw_provider for what we're doing here\n-    if key.param_env.reveal == Reveal::All {\n-        let mut key = key.clone();\n-        key.param_env.reveal = Reveal::UserFacing;\n-        match tcx.const_eval_validated(key) {\n-            // try again with reveal all as requested\n-            Err(ErrorHandled::TooGeneric) => {\n-                // Promoteds should never be \"too generic\" when getting evaluated.\n-                // They either don't get evaluated, or we are in a monomorphic context\n-                assert!(key.value.promoted.is_none());\n-            }\n-            // dedupliate calls\n-            other => return other,\n-        }\n-    }\n-\n-    // We call `const_eval` for zero arg intrinsics, too, in order to cache their value.\n-    // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n-    if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n-        let ty = key.value.instance.ty(tcx);\n-        let substs = match ty.kind {\n-            ty::FnDef(_, substs) => substs,\n-            _ => bug!(\"intrinsic with type {:?}\", ty),\n-        };\n-        return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs).map_err(|error| {\n-            let span = tcx.def_span(def_id);\n-            let error = ConstEvalErr { error: error.kind, stacktrace: vec![], span };\n-            error.report_as_error(tcx.at(span), \"could not evaluate nullary intrinsic\")\n-        });\n-    }\n-\n-    tcx.const_eval_raw(key).and_then(|val| validate_and_turn_into_const(tcx, val, key))\n-}\n-\n-pub fn const_eval_raw_provider<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc::mir::interpret::ConstEvalRawResult<'tcx> {\n-    // Because the constant is computed twice (once per value of `Reveal`), we are at risk of\n-    // reporting the same error twice here. To resolve this, we check whether we can evaluate the\n-    // constant in the more restrictive `Reveal::UserFacing`, which most likely already was\n-    // computed. For a large percentage of constants that will already have succeeded. Only\n-    // associated constants of generic functions will fail due to not enough monomorphization\n-    // information being available.\n-\n-    // In case we fail in the `UserFacing` variant, we just do the real computation.\n-    if key.param_env.reveal == Reveal::All {\n-        let mut key = key.clone();\n-        key.param_env.reveal = Reveal::UserFacing;\n-        match tcx.const_eval_raw(key) {\n-            // try again with reveal all as requested\n-            Err(ErrorHandled::TooGeneric) => {}\n-            // dedupliate calls\n-            other => return other,\n-        }\n-    }\n-    if cfg!(debug_assertions) {\n-        // Make sure we format the instance even if we do not print it.\n-        // This serves as a regression test against an ICE on printing.\n-        // The next two lines concatenated contain some discussion:\n-        // https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/\n-        // subject/anon_const_instance_printing/near/135980032\n-        let instance = key.value.instance.to_string();\n-        trace!(\"const eval: {:?} ({})\", key, instance);\n-    }\n-\n-    let cid = key.value;\n-    let def_id = cid.instance.def.def_id();\n-\n-    if def_id.is_local() && tcx.typeck_tables_of(def_id).tainted_by_errors {\n-        return Err(ErrorHandled::Reported);\n-    }\n-\n-    let is_static = tcx.is_static(def_id);\n-\n-    let span = tcx.def_span(cid.instance.def_id());\n-    let mut ecx = InterpCx::new(\n-        tcx.at(span),\n-        key.param_env,\n-        CompileTimeInterpreter::new(),\n-        MemoryExtra { can_access_statics: is_static },\n-    );\n-\n-    let res = ecx.load_mir(cid.instance.def, cid.promoted);\n-    res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, *body))\n-        .and_then(|place| {\n-            Ok(RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n-        })\n-        .map_err(|error| {\n-            let err = error_to_const_error(&ecx, error);\n-            // errors in statics are always emitted as fatal errors\n-            if is_static {\n-                // Ensure that if the above error was either `TooGeneric` or `Reported`\n-                // an error must be reported.\n-                let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n-                tcx.sess.delay_span_bug(\n-                    err.span,\n-                    &format!(\"static eval failure did not emit an error: {:#?}\", v),\n-                );\n-                v\n-            } else if def_id.is_local() {\n-                // constant defined in this crate, we can figure out a lint level!\n-                match tcx.def_kind(def_id) {\n-                    // constants never produce a hard error at the definition site. Anything else is\n-                    // a backwards compatibility hazard (and will break old versions of winapi for sure)\n-                    //\n-                    // note that validation may still cause a hard error on this very same constant,\n-                    // because any code that existed before validation could not have failed validation\n-                    // thus preventing such a hard error from being a backwards compatibility hazard\n-                    Some(DefKind::Const) | Some(DefKind::AssocConst) => {\n-                        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-                        err.report_as_lint(\n-                            tcx.at(tcx.def_span(def_id)),\n-                            \"any use of this value will cause an error\",\n-                            hir_id,\n-                            Some(err.span),\n-                        )\n-                    }\n-                    // promoting runtime code is only allowed to error if it references broken constants\n-                    // any other kind of error will be reported to the user as a deny-by-default lint\n-                    _ => {\n-                        if let Some(p) = cid.promoted {\n-                            let span = tcx.promoted_mir(def_id)[p].span;\n-                            if let err_inval!(ReferencedConstant) = err.error {\n-                                err.report_as_error(\n-                                    tcx.at(span),\n-                                    \"evaluation of constant expression failed\",\n-                                )\n-                            } else {\n-                                err.report_as_lint(\n-                                    tcx.at(span),\n-                                    \"reaching this expression at runtime will panic or abort\",\n-                                    tcx.hir().as_local_hir_id(def_id).unwrap(),\n-                                    Some(err.span),\n-                                )\n-                            }\n-                        // anything else (array lengths, enum initializers, constant patterns) are reported\n-                        // as hard errors\n-                        } else {\n-                            err.report_as_error(ecx.tcx, \"evaluation of constant value failed\")\n-                        }\n-                    }\n-                }\n-            } else {\n-                // use of broken constant from other crate\n-                err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n-            }\n-        })\n-}"}, {"sha": "c2db3c31f85be45e667944cf1287b57ca43cc6d9", "filename": "src/librustc_mir/const_eval/error.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=3ac40b69c75929dac5115b6a49eb4f1ecc352416", "patch": "@@ -0,0 +1,42 @@\n+use std::error::Error;\n+use std::fmt;\n+\n+use super::InterpCx;\n+use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n+#[derive(Clone, Debug)]\n+pub enum ConstEvalError {\n+    NeedsRfc(String),\n+    ConstAccessesStatic,\n+}\n+\n+impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n+    fn into(self) -> InterpErrorInfo<'tcx> {\n+        err_unsup!(Unsupported(self.to_string())).into()\n+    }\n+}\n+\n+impl fmt::Display for ConstEvalError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use self::ConstEvalError::*;\n+        match *self {\n+            NeedsRfc(ref msg) => {\n+                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n+            }\n+            ConstAccessesStatic => write!(f, \"constant accesses static\"),\n+        }\n+    }\n+}\n+\n+impl Error for ConstEvalError {}\n+\n+/// Turn an interpreter error into something to report to the user.\n+/// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n+/// Should be called only if the error is actually going to to be reported!\n+pub fn error_to_const_error<'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n+    ecx: &InterpCx<'mir, 'tcx, M>,\n+    mut error: InterpErrorInfo<'tcx>,\n+) -> ConstEvalErr<'tcx> {\n+    error.print_backtrace();\n+    let stacktrace = ecx.generate_stacktrace(None);\n+    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n+}"}, {"sha": "62ec4bbaec769d016a26d6e3b9e88ab17dece73c", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=3ac40b69c75929dac5115b6a49eb4f1ecc352416", "patch": "@@ -0,0 +1,360 @@\n+use super::{error_to_const_error, CompileTimeEvalContext, CompileTimeInterpreter, MemoryExtra};\n+use crate::interpret::eval_nullary_intrinsic;\n+use crate::interpret::{\n+    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InterpCx,\n+    InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar, ScalarMaybeUndef,\n+    StackPopCleanup,\n+};\n+use rustc::hir::def::DefKind;\n+use rustc::mir;\n+use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n+use rustc::traits::Reveal;\n+use rustc::ty::{self, layout, layout::LayoutOf, subst::Subst, TyCtxt};\n+use std::convert::TryInto;\n+use syntax::source_map::Span;\n+\n+pub fn note_on_undefined_behavior_error() -> &'static str {\n+    \"The rules on what exactly is undefined behavior aren't clear, \\\n+     so this check might be overzealous. Please open an issue on the rustc \\\n+     repository if you believe it should not be considered undefined behavior.\"\n+}\n+\n+// Returns a pointer to where the result lives\n+fn eval_body_using_ecx<'mir, 'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n+    cid: GlobalId<'tcx>,\n+    body: &'mir mir::Body<'tcx>,\n+) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n+    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, ecx.param_env);\n+    let tcx = ecx.tcx.tcx;\n+    let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n+    assert!(!layout.is_unsized());\n+    let ret = ecx.allocate(layout, MemoryKind::Stack);\n+\n+    let name = ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id()));\n+    let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n+    trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n+\n+    // Assert all args (if any) are zero-sized types; `eval_body_using_ecx` doesn't\n+    // make sense if the body is expecting nontrivial arguments.\n+    // (The alternative would be to use `eval_fn_call` with an args slice.)\n+    for arg in body.args_iter() {\n+        let decl = body.local_decls.get(arg).expect(\"arg missing from local_decls\");\n+        let layout = ecx.layout_of(decl.ty.subst(tcx, cid.instance.substs))?;\n+        assert!(layout.is_zst())\n+    }\n+\n+    ecx.push_stack_frame(\n+        cid.instance,\n+        body.span,\n+        body,\n+        Some(ret.into()),\n+        StackPopCleanup::None { cleanup: false },\n+    )?;\n+\n+    // The main interpreter loop.\n+    ecx.run()?;\n+\n+    // Intern the result\n+    intern_const_alloc_recursive(ecx, tcx.static_mutability(cid.instance.def_id()), ret)?;\n+\n+    debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n+    Ok(ret)\n+}\n+\n+/// The `InterpCx` is only meant to be used to do field and index projections into constants for\n+/// `simd_shuffle` and const patterns in match arms.\n+///\n+/// The function containing the `match` that is currently being analyzed may have generic bounds\n+/// that inform us about the generic bounds of the constant. E.g., using an associated constant\n+/// of a function's generic parameter will require knowledge about the bounds on the generic\n+/// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n+pub(super) fn mk_eval_cx<'mir, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    param_env: ty::ParamEnv<'tcx>,\n+    can_access_statics: bool,\n+) -> CompileTimeEvalContext<'mir, 'tcx> {\n+    debug!(\"mk_eval_cx: {:?}\", param_env);\n+    InterpCx::new(\n+        tcx.at(span),\n+        param_env,\n+        CompileTimeInterpreter::new(),\n+        MemoryExtra { can_access_statics },\n+    )\n+}\n+\n+pub(super) fn op_to_const<'tcx>(\n+    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n+    op: OpTy<'tcx>,\n+) -> &'tcx ty::Const<'tcx> {\n+    // We do not have value optimizations for everything.\n+    // Only scalars and slices, since they are very common.\n+    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n+    // from scalar unions that are initialized with one of their zero sized variants. We could\n+    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n+    // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n+    // `Undef` situation.\n+    let try_as_immediate = match op.layout.abi {\n+        layout::Abi::Scalar(..) => true,\n+        layout::Abi::ScalarPair(..) => match op.layout.ty.kind {\n+            ty::Ref(_, inner, _) => match inner.kind {\n+                ty::Slice(elem) => elem == ecx.tcx.types.u8,\n+                ty::Str => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        },\n+        _ => false,\n+    };\n+    let immediate = if try_as_immediate {\n+        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n+    } else {\n+        // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n+        // When we come back from raw const eval, we are always by-ref. The only way our op here is\n+        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n+        // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n+        // structs containing such.\n+        op.try_as_mplace()\n+    };\n+    let val = match immediate {\n+        Ok(mplace) => {\n+            let ptr = mplace.ptr.to_ptr().unwrap();\n+            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+            ConstValue::ByRef { alloc, offset: ptr.offset }\n+        }\n+        // see comment on `let try_as_immediate` above\n+        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n+            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n+            ScalarMaybeUndef::Undef => {\n+                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n+                // argument and we will not need this. The only way we can already have an\n+                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n+                // comes from a constant so it can happen have `Undef`, because the indirect\n+                // memory that was read had undefined bytes.\n+                let mplace = op.assert_mem_place();\n+                let ptr = mplace.ptr.to_ptr().unwrap();\n+                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+                ConstValue::ByRef { alloc, offset: ptr.offset }\n+            }\n+        },\n+        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n+            let (data, start) = match a.not_undef().unwrap() {\n+                Scalar::Ptr(ptr) => {\n+                    (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n+                }\n+                Scalar::Raw { .. } => (\n+                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n+                    0,\n+                ),\n+            };\n+            let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+            let start = start.try_into().unwrap();\n+            let len: usize = len.try_into().unwrap();\n+            ConstValue::Slice { data, start, end: start + len }\n+        }\n+    };\n+    ecx.tcx.mk_const(ty::Const { val: ty::ConstKind::Value(val), ty: op.layout.ty })\n+}\n+\n+fn validate_and_turn_into_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    constant: RawConst<'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n+) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n+    let cid = key.value;\n+    let def_id = cid.instance.def.def_id();\n+    let is_static = tcx.is_static(def_id);\n+    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n+    let val = (|| {\n+        let mplace = ecx.raw_const_to_mplace(constant)?;\n+        let mut ref_tracking = RefTracking::new(mplace);\n+        while let Some((mplace, path)) = ref_tracking.todo.pop() {\n+            ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n+        }\n+        // Now that we validated, turn this into a proper constant.\n+        // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n+        // whether they become immediates.\n+        if is_static || cid.promoted.is_some() {\n+            let ptr = mplace.ptr.to_ptr()?;\n+            Ok(tcx.mk_const(ty::Const {\n+                val: ty::ConstKind::Value(ConstValue::ByRef {\n+                    alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                    offset: ptr.offset,\n+                }),\n+                ty: mplace.layout.ty,\n+            }))\n+        } else {\n+            Ok(op_to_const(&ecx, mplace.into()))\n+        }\n+    })();\n+\n+    val.map_err(|error| {\n+        let err = error_to_const_error(&ecx, error);\n+        match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n+            Ok(mut diag) => {\n+                diag.note(note_on_undefined_behavior_error());\n+                diag.emit();\n+                ErrorHandled::Reported\n+            }\n+            Err(err) => err,\n+        }\n+    })\n+}\n+\n+pub fn const_eval_validated_provider<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n+) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n+    // see comment in const_eval_raw_provider for what we're doing here\n+    if key.param_env.reveal == Reveal::All {\n+        let mut key = key.clone();\n+        key.param_env.reveal = Reveal::UserFacing;\n+        match tcx.const_eval_validated(key) {\n+            // try again with reveal all as requested\n+            Err(ErrorHandled::TooGeneric) => {\n+                // Promoteds should never be \"too generic\" when getting evaluated.\n+                // They either don't get evaluated, or we are in a monomorphic context\n+                assert!(key.value.promoted.is_none());\n+            }\n+            // dedupliate calls\n+            other => return other,\n+        }\n+    }\n+\n+    // We call `const_eval` for zero arg intrinsics, too, in order to cache their value.\n+    // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n+    if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n+        let ty = key.value.instance.ty(tcx);\n+        let substs = match ty.kind {\n+            ty::FnDef(_, substs) => substs,\n+            _ => bug!(\"intrinsic with type {:?}\", ty),\n+        };\n+        return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs).map_err(|error| {\n+            let span = tcx.def_span(def_id);\n+            let error = ConstEvalErr { error: error.kind, stacktrace: vec![], span };\n+            error.report_as_error(tcx.at(span), \"could not evaluate nullary intrinsic\")\n+        });\n+    }\n+\n+    tcx.const_eval_raw(key).and_then(|val| validate_and_turn_into_const(tcx, val, key))\n+}\n+\n+pub fn const_eval_raw_provider<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n+) -> ::rustc::mir::interpret::ConstEvalRawResult<'tcx> {\n+    // Because the constant is computed twice (once per value of `Reveal`), we are at risk of\n+    // reporting the same error twice here. To resolve this, we check whether we can evaluate the\n+    // constant in the more restrictive `Reveal::UserFacing`, which most likely already was\n+    // computed. For a large percentage of constants that will already have succeeded. Only\n+    // associated constants of generic functions will fail due to not enough monomorphization\n+    // information being available.\n+\n+    // In case we fail in the `UserFacing` variant, we just do the real computation.\n+    if key.param_env.reveal == Reveal::All {\n+        let mut key = key.clone();\n+        key.param_env.reveal = Reveal::UserFacing;\n+        match tcx.const_eval_raw(key) {\n+            // try again with reveal all as requested\n+            Err(ErrorHandled::TooGeneric) => {}\n+            // dedupliate calls\n+            other => return other,\n+        }\n+    }\n+    if cfg!(debug_assertions) {\n+        // Make sure we format the instance even if we do not print it.\n+        // This serves as a regression test against an ICE on printing.\n+        // The next two lines concatenated contain some discussion:\n+        // https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/\n+        // subject/anon_const_instance_printing/near/135980032\n+        let instance = key.value.instance.to_string();\n+        trace!(\"const eval: {:?} ({})\", key, instance);\n+    }\n+\n+    let cid = key.value;\n+    let def_id = cid.instance.def.def_id();\n+\n+    if def_id.is_local() && tcx.typeck_tables_of(def_id).tainted_by_errors {\n+        return Err(ErrorHandled::Reported);\n+    }\n+\n+    let is_static = tcx.is_static(def_id);\n+\n+    let span = tcx.def_span(cid.instance.def_id());\n+    let mut ecx = InterpCx::new(\n+        tcx.at(span),\n+        key.param_env,\n+        CompileTimeInterpreter::new(),\n+        MemoryExtra { can_access_statics: is_static },\n+    );\n+\n+    let res = ecx.load_mir(cid.instance.def, cid.promoted);\n+    res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, *body))\n+        .and_then(|place| {\n+            Ok(RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n+        })\n+        .map_err(|error| {\n+            let err = error_to_const_error(&ecx, error);\n+            // errors in statics are always emitted as fatal errors\n+            if is_static {\n+                // Ensure that if the above error was either `TooGeneric` or `Reported`\n+                // an error must be reported.\n+                let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n+                tcx.sess.delay_span_bug(\n+                    err.span,\n+                    &format!(\"static eval failure did not emit an error: {:#?}\", v),\n+                );\n+                v\n+            } else if def_id.is_local() {\n+                // constant defined in this crate, we can figure out a lint level!\n+                match tcx.def_kind(def_id) {\n+                    // constants never produce a hard error at the definition site. Anything else is\n+                    // a backwards compatibility hazard (and will break old versions of winapi for\n+                    // sure)\n+                    //\n+                    // note that validation may still cause a hard error on this very same constant,\n+                    // because any code that existed before validation could not have failed\n+                    // validation thus preventing such a hard error from being a backwards\n+                    // compatibility hazard\n+                    Some(DefKind::Const) | Some(DefKind::AssocConst) => {\n+                        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                        err.report_as_lint(\n+                            tcx.at(tcx.def_span(def_id)),\n+                            \"any use of this value will cause an error\",\n+                            hir_id,\n+                            Some(err.span),\n+                        )\n+                    }\n+                    // promoting runtime code is only allowed to error if it references broken\n+                    // constants any other kind of error will be reported to the user as a\n+                    // deny-by-default lint\n+                    _ => {\n+                        if let Some(p) = cid.promoted {\n+                            let span = tcx.promoted_mir(def_id)[p].span;\n+                            if let err_inval!(ReferencedConstant) = err.error {\n+                                err.report_as_error(\n+                                    tcx.at(span),\n+                                    \"evaluation of constant expression failed\",\n+                                )\n+                            } else {\n+                                err.report_as_lint(\n+                                    tcx.at(span),\n+                                    \"reaching this expression at runtime will panic or abort\",\n+                                    tcx.hir().as_local_hir_id(def_id).unwrap(),\n+                                    Some(err.span),\n+                                )\n+                            }\n+                        // anything else (array lengths, enum initializers, constant patterns) are\n+                        // reported as hard errors\n+                        } else {\n+                            err.report_as_error(ecx.tcx, \"evaluation of constant value failed\")\n+                        }\n+                    }\n+                }\n+            } else {\n+                // use of broken constant from other crate\n+                err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n+            }\n+        })\n+}"}, {"sha": "a76153c19ec676a8c210b13063ea7a5e88b23d8d", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=3ac40b69c75929dac5115b6a49eb4f1ecc352416", "patch": "@@ -0,0 +1,364 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::mir;\n+use rustc::ty::layout::HasTyCtxt;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use std::borrow::{Borrow, Cow};\n+use std::collections::hash_map::Entry;\n+use std::hash::Hash;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use syntax::source_map::Span;\n+\n+use crate::interpret::{\n+    self, snapshot, AllocId, Allocation, AssertMessage, GlobalId, ImmTy, InterpCx, InterpResult,\n+    Memory, MemoryKind, OpTy, PlaceTy, Pointer, Scalar,\n+};\n+\n+use super::error::*;\n+\n+impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n+    /// Evaluate a const function where all arguments (if any) are zero-sized types.\n+    /// The evaluation is memoized thanks to the query system.\n+    ///\n+    /// Returns `true` if the call has been evaluated.\n+    fn try_eval_const_fn_call(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        args: &[OpTy<'tcx>],\n+    ) -> InterpResult<'tcx, bool> {\n+        trace!(\"try_eval_const_fn_call: {:?}\", instance);\n+        // Because `#[track_caller]` adds an implicit non-ZST argument, we also cannot\n+        // perform this optimization on items tagged with it.\n+        if instance.def.requires_caller_location(self.tcx()) {\n+            return Ok(false);\n+        }\n+        // For the moment we only do this for functions which take no arguments\n+        // (or all arguments are ZSTs) so that we don't memoize too much.\n+        if args.iter().any(|a| !a.layout.is_zst()) {\n+            return Ok(false);\n+        }\n+\n+        let dest = match ret {\n+            Some((dest, _)) => dest,\n+            // Don't memoize diverging function calls.\n+            None => return Ok(false),\n+        };\n+\n+        let gid = GlobalId { instance, promoted: None };\n+\n+        let place = self.const_eval_raw(gid)?;\n+\n+        self.copy_op(place.into(), dest)?;\n+\n+        self.return_to_block(ret.map(|r| r.1))?;\n+        self.dump_place(*dest);\n+        return Ok(true);\n+    }\n+}\n+\n+/// Number of steps until the detector even starts doing anything.\n+/// Also, a warning is shown to the user when this number is reached.\n+const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n+/// The number of steps between loop detector snapshots.\n+/// Should be a power of two for performance reasons.\n+const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n+\n+// Extra machine state for CTFE, and the Machine instance\n+pub struct CompileTimeInterpreter<'mir, 'tcx> {\n+    /// When this value is negative, it indicates the number of interpreter\n+    /// steps *until* the loop detector is enabled. When it is positive, it is\n+    /// the number of steps after the detector has been enabled modulo the loop\n+    /// detector period.\n+    pub(super) steps_since_detector_enabled: isize,\n+\n+    /// Extra state to detect loops.\n+    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'mir, 'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct MemoryExtra {\n+    /// Whether this machine may read from statics\n+    pub(super) can_access_statics: bool,\n+}\n+\n+impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n+    pub(super) fn new() -> Self {\n+        CompileTimeInterpreter {\n+            loop_detector: Default::default(),\n+            steps_since_detector_enabled: -STEPS_UNTIL_DETECTOR_ENABLED,\n+        }\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n+    #[inline(always)]\n+    fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n+    where\n+        K: Borrow<Q>,\n+    {\n+        FxHashMap::contains_key(self, k)\n+    }\n+\n+    #[inline(always)]\n+    fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        FxHashMap::insert(self, k, v)\n+    }\n+\n+    #[inline(always)]\n+    fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n+    where\n+        K: Borrow<Q>,\n+    {\n+        FxHashMap::remove(self, k)\n+    }\n+\n+    #[inline(always)]\n+    fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n+        self.iter().filter_map(move |(k, v)| f(k, &*v)).collect()\n+    }\n+\n+    #[inline(always)]\n+    fn get_or<E>(&self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&V, E> {\n+        match self.get(&k) {\n+            Some(v) => Ok(v),\n+            None => {\n+                vacant()?;\n+                bug!(\"The CTFE machine shouldn't ever need to extend the alloc_map when reading\")\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n+        match self.entry(k) {\n+            Entry::Occupied(e) => Ok(e.into_mut()),\n+            Entry::Vacant(e) => {\n+                let v = vacant()?;\n+                Ok(e.insert(v))\n+            }\n+        }\n+    }\n+}\n+\n+crate type CompileTimeEvalContext<'mir, 'tcx> =\n+    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n+\n+impl interpret::MayLeak for ! {\n+    #[inline(always)]\n+    fn may_leak(self) -> bool {\n+        // `self` is uninhabited\n+        self\n+    }\n+}\n+\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n+    type MemoryKinds = !;\n+    type PointerTag = ();\n+    type ExtraFnVal = !;\n+\n+    type FrameExtra = ();\n+    type MemoryExtra = MemoryExtra;\n+    type AllocExtra = ();\n+\n+    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n+\n+    const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n+\n+    // We do not check for alignment to avoid having to carry an `Align`\n+    // in `ConstValue::ByRef`.\n+    const CHECK_ALIGN: bool = false;\n+\n+    #[inline(always)]\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        false // for now, we don't enforce validity\n+    }\n+\n+    fn find_mir_or_eval_fn(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+        debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n+\n+        // Only check non-glue functions\n+        if let ty::InstanceDef::Item(def_id) = instance.def {\n+            // Execution might have wandered off into other crates, so we cannot do a stability-\n+            // sensitive check here.  But we can at least rule out functions that are not const\n+            // at all.\n+            if ecx.tcx.is_const_fn_raw(def_id) {\n+                // If this function is a `const fn` then under certain circumstances we\n+                // can evaluate call via the query system, thus memoizing all future calls.\n+                if ecx.try_eval_const_fn_call(instance, ret, args)? {\n+                    return Ok(None);\n+                }\n+            } else {\n+                // Some functions we support even if they are non-const -- but avoid testing\n+                // that for const fn!  We certainly do *not* want to actually call the fn\n+                // though, so be sure we return here.\n+                return if ecx.hook_panic_fn(instance, args, ret)? {\n+                    Ok(None)\n+                } else {\n+                    throw_unsup_format!(\"calling non-const function `{}`\", instance)\n+                };\n+            }\n+        }\n+        // This is a const fn. Call it.\n+        Ok(Some(match ecx.load_mir(instance.def, None) {\n+            Ok(body) => *body,\n+            Err(err) => {\n+                if let err_unsup!(NoMirFor(ref path)) = err.kind {\n+                    return Err(ConstEvalError::NeedsRfc(format!(\n+                        \"calling extern function `{}`\",\n+                        path\n+                    ))\n+                    .into());\n+                }\n+                return Err(err);\n+            }\n+        }))\n+    }\n+\n+    fn call_extra_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        fn_val: !,\n+        _args: &[OpTy<'tcx>],\n+        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        match fn_val {}\n+    }\n+\n+    fn call_intrinsic(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        span: Span,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        if ecx.emulate_intrinsic(span, instance, args, ret)? {\n+            return Ok(());\n+        }\n+        // An intrinsic that we do not support\n+        let intrinsic_name = ecx.tcx.item_name(instance.def_id());\n+        Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into())\n+    }\n+\n+    fn assert_panic(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _span: Span,\n+        msg: &AssertMessage<'tcx>,\n+        _unwind: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        use rustc::mir::interpret::PanicInfo::*;\n+        Err(match msg {\n+            BoundsCheck { ref len, ref index } => {\n+                let len = ecx\n+                    .read_immediate(ecx.eval_operand(len, None)?)\n+                    .expect(\"can't eval len\")\n+                    .to_scalar()?\n+                    .to_machine_usize(&*ecx)?;\n+                let index = ecx\n+                    .read_immediate(ecx.eval_operand(index, None)?)\n+                    .expect(\"can't eval index\")\n+                    .to_scalar()?\n+                    .to_machine_usize(&*ecx)?;\n+                err_panic!(BoundsCheck { len, index })\n+            }\n+            Overflow(op) => err_panic!(Overflow(*op)),\n+            OverflowNeg => err_panic!(OverflowNeg),\n+            DivisionByZero => err_panic!(DivisionByZero),\n+            RemainderByZero => err_panic!(RemainderByZero),\n+            ResumedAfterReturn(generator_kind) => err_panic!(ResumedAfterReturn(*generator_kind)),\n+            ResumedAfterPanic(generator_kind) => err_panic!(ResumedAfterPanic(*generator_kind)),\n+            Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n+        }\n+        .into())\n+    }\n+\n+    fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n+        Err(ConstEvalError::NeedsRfc(\"pointer-to-integer cast\".to_string()).into())\n+    }\n+\n+    fn binary_ptr_op(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _bin_op: mir::BinOp,\n+        _left: ImmTy<'tcx>,\n+        _right: ImmTy<'tcx>,\n+    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n+        Err(ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n+    }\n+\n+    fn find_foreign_static(\n+        _tcx: TyCtxt<'tcx>,\n+        _def_id: DefId,\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n+        throw_unsup!(ReadForeignStatic)\n+    }\n+\n+    #[inline(always)]\n+    fn init_allocation_extra<'b>(\n+        _memory_extra: &MemoryExtra,\n+        _id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        _kind: Option<MemoryKind<!>>,\n+    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n+        // We do not use a tag so we can just cheaply forward the allocation\n+        (alloc, ())\n+    }\n+\n+    #[inline(always)]\n+    fn tag_static_base_pointer(_memory_extra: &MemoryExtra, _id: AllocId) -> Self::PointerTag {\n+        ()\n+    }\n+\n+    fn box_alloc(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _dest: PlaceTy<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        Err(ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n+    }\n+\n+    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        {\n+            let steps = &mut ecx.machine.steps_since_detector_enabled;\n+\n+            *steps += 1;\n+            if *steps < 0 {\n+                return Ok(());\n+            }\n+\n+            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n+            if *steps != 0 {\n+                return Ok(());\n+            }\n+        }\n+\n+        let span = ecx.frame().span;\n+        ecx.machine.loop_detector.observe_and_analyze(*ecx.tcx, span, &ecx.memory, &ecx.stack[..])\n+    }\n+\n+    #[inline(always)]\n+    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    fn before_access_static(\n+        memory_extra: &MemoryExtra,\n+        _allocation: &Allocation,\n+    ) -> InterpResult<'tcx> {\n+        if memory_extra.can_access_statics {\n+            Ok(())\n+        } else {\n+            Err(ConstEvalError::ConstAccessesStatic.into())\n+        }\n+    }\n+}\n+\n+// Please do not add any code below the above `Machine` trait impl. I (oli-obk) plan more cleanups\n+// so we can end up having a file with just that impl, but for now, let's keep the impl discoverable\n+// at the bottom of this file."}, {"sha": "1cc22c03a05f996f7f1c7944c2b0ed11ba563ced", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=3ac40b69c75929dac5115b6a49eb4f1ecc352416", "patch": "@@ -7,8 +7,7 @@ use rustc_target::spec::abi::Abi;\n use syntax::source_map::Span;\n \n use super::{\n-    FnVal, GlobalId, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy,\n-    StackPopCleanup,\n+    FnVal, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy, StackPopCleanup,\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -402,26 +401,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Evaluate a const function where all arguments (if any) are zero-sized types.\n-    /// The evaluation is memoized thanks to the query system.\n-    // FIXME: Consider moving this to `const_eval.rs`.\n-    pub(crate) fn eval_const_fn_call(\n-        &mut self,\n-        gid: GlobalId<'tcx>,\n-        ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n-    ) -> InterpResult<'tcx> {\n-        trace!(\"eval_const_fn_call: {:?}\", gid);\n-\n-        let place = self.const_eval_raw(gid)?;\n-        let dest = ret.ok_or_else(|| err_ub!(Unreachable))?.0;\n-\n-        self.copy_op(place.into(), dest)?;\n-\n-        self.return_to_block(ret.map(|r| r.1))?;\n-        self.dump_place(*dest);\n-        return Ok(());\n-    }\n-\n     fn drop_in_place(\n         &mut self,\n         place: PlaceTy<'tcx, M::PointerTag>,"}, {"sha": "15436f9c1b2cfa0cd8ecf1e308396658cb14b984", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.rs?ref=3ac40b69c75929dac5115b6a49eb4f1ecc352416", "patch": "@@ -5,15 +5,15 @@ pub const unsafe fn fake_type<T>() -> T {\n }\n \n pub const unsafe fn hint_unreachable() -> ! {\n-    fake_type() //~ ERROR cycle detected when const-evaluating `hint_unreachable` [E0391]\n+    fake_type() //~ ERROR evaluation of constant value failed\n }\n \n trait Const {\n-    const CONSTANT: i32 = unsafe { fake_type() };\n+    const CONSTANT: i32 = unsafe { fake_type() }; //~ ERROR any use of this value will cause an err\n }\n \n-impl <T> Const for T {}\n+impl<T> Const for T {}\n \n pub fn main() -> () {\n-    dbg!(i32::CONSTANT);\n+    dbg!(i32::CONSTANT); //~ ERROR erroneous constant used\n }"}, {"sha": "1f3e2cf5b2f586a158a45cae778b01667a70bb2e", "filename": "src/test/ui/consts/uninhabited-const-issue-61744.stderr", "status": "modified", "additions": 87, "deletions": 12, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ac40b69c75929dac5115b6a49eb4f1ecc352416/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funinhabited-const-issue-61744.stderr?ref=3ac40b69c75929dac5115b6a49eb4f1ecc352416", "patch": "@@ -1,21 +1,96 @@\n-error[E0391]: cycle detected when const-evaluating `hint_unreachable`\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/uninhabited-const-issue-61744.rs:8:5\n    |\n+LL |     hint_unreachable()\n+   |     ------------------\n+   |     |\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+   |     inside call to `hint_unreachable` at $DIR/uninhabited-const-issue-61744.rs:4:5\n+...\n LL |     fake_type()\n    |     ^^^^^^^^^^^\n+   |     |\n+   |     reached the configured maximum number of stack frames\n+   |     inside call to `fake_type::<!>` at $DIR/uninhabited-const-issue-61744.rs:8:5\n+\n+error: any use of this value will cause an error\n+  --> $DIR/uninhabited-const-issue-61744.rs:12:36\n    |\n-note: ...which requires const-evaluating `fake_type`...\n-  --> $DIR/uninhabited-const-issue-61744.rs:4:5\n+LL |     const CONSTANT: i32 = unsafe { fake_type() };\n+   |     -------------------------------^^^^^^^^^^^---\n+   |                                    |\n+   |                                    referenced constant has errors\n    |\n-LL |     hint_unreachable()\n-   |     ^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires const-evaluating `hint_unreachable`, completing the cycle\n-note: cycle used when const-evaluating `fake_type`\n-  --> $DIR/uninhabited-const-issue-61744.rs:4:5\n+   = note: `#[deny(const_err)]` on by default\n+\n+error[E0080]: erroneous constant used\n+  --> $DIR/uninhabited-const-issue-61744.rs:18:10\n    |\n-LL |     hint_unreachable()\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |     dbg!(i32::CONSTANT);\n+   |          ^^^^^^^^^^^^^ referenced constant has errors\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0391`.\n+For more information about this error, try `rustc --explain E0080`."}]}