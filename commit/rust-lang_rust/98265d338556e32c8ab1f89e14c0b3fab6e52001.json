{"sha": "98265d338556e32c8ab1f89e14c0b3fab6e52001", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MjY1ZDMzODU1NmUzMmM4YWIxZjg5ZTE0YzBiM2ZhYjZlNTIwMDE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-29T22:18:47Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-04T13:56:05Z"}, "message": "Convert Drop statement into terminator\n\nThe structure of the old translator as well as MIR assumed that drop glue cannot possibly panic and\ntranslated the drops accordingly. However, in presence of `Drop::drop` this assumption can be\ntrivially shown to be untrue. As such, the Rust code like the following would never print number 2:\n\n```rust\nstruct Droppable(u32);\nimpl Drop for Droppable {\n    fn drop(&mut self) {\n        if self.0 == 1 { panic!(\"Droppable(1)\") } else { println!(\"{}\", self.0) }\n    }\n}\nfn main() {\n    let x = Droppable(2);\n    let y = Droppable(1);\n}\n```\n\nWhile the behaviour is allowed according to the language rules (we allow drops to not run), that\u2019s\na very counter-intuitive behaviour. We fix this in MIR by allowing `Drop` to have a target to take\non divergence and connect the drops in such a way so the leftover drops are executed when some drop\nunwinds.\n\nNote, that this commit still does not implement the translator part of changes necessary for the\ngrand scheme of things to fully work, so the actual observed behaviour does not change yet. Coming\nsoon\u2122.\n\nSee #14875.", "tree": {"sha": "36b5cca413a599d71a461718d10c67f05f9a5dd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36b5cca413a599d71a461718d10c67f05f9a5dd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98265d338556e32c8ab1f89e14c0b3fab6e52001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98265d338556e32c8ab1f89e14c0b3fab6e52001", "html_url": "https://github.com/rust-lang/rust/commit/98265d338556e32c8ab1f89e14c0b3fab6e52001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98265d338556e32c8ab1f89e14c0b3fab6e52001/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1", "html_url": "https://github.com/rust-lang/rust/commit/65dd5e6a84aa8d9af477f21fa9797e3d0774a2c1"}], "stats": {"total": 470, "additions": 309, "deletions": 161}, "files": [{"sha": "783c58469a1b3c79011456b72e1c57dff5a9a72e", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=98265d338556e32c8ab1f89e14c0b3fab6e52001", "patch": "@@ -262,6 +262,13 @@ pub enum Terminator<'tcx> {\n     /// `END_BLOCK`.\n     Return,\n \n+    /// Drop the Lvalue\n+    Drop {\n+        value: Lvalue<'tcx>,\n+        target: BasicBlock,\n+        unwind: Option<BasicBlock>\n+    },\n+\n     /// Block ends with a call of a converging function\n     Call {\n         /// The function that\u2019s being called\n@@ -290,6 +297,8 @@ impl<'tcx> Terminator<'tcx> {\n                 slice::ref_slice(t).into_cow(),\n             Call { destination: None, cleanup: Some(ref c), .. } => slice::ref_slice(c).into_cow(),\n             Call { destination: None, cleanup: None, .. } => (&[]).into_cow(),\n+            Drop { target, unwind: Some(unwind), .. } => vec![target, unwind].into_cow(),\n+            Drop { ref target, .. } => slice::ref_slice(target).into_cow(),\n         }\n     }\n \n@@ -308,6 +317,8 @@ impl<'tcx> Terminator<'tcx> {\n             Call { destination: Some((_, ref mut t)), cleanup: None, .. } => vec![t],\n             Call { destination: None, cleanup: Some(ref mut c), .. } => vec![c],\n             Call { destination: None, cleanup: None, .. } => vec![],\n+            Drop { ref mut target, unwind: Some(ref mut unwind), .. } => vec![target, unwind],\n+            Drop { ref mut target, .. } => vec![target]\n         }\n     }\n }\n@@ -374,6 +385,7 @@ impl<'tcx> Terminator<'tcx> {\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Return => write!(fmt, \"return\"),\n             Resume => write!(fmt, \"resume\"),\n+            Drop { ref value, .. } => write!(fmt, \"drop({:?})\", value),\n             Call { ref func, ref args, ref destination, .. } => {\n                 if let Some((ref destination, _)) = *destination {\n                     try!(write!(fmt, \"{:?} = \", destination));\n@@ -418,6 +430,8 @@ impl<'tcx> Terminator<'tcx> {\n             Call { destination: Some(_), cleanup: None, .. } => vec![\"return\".into_cow()],\n             Call { destination: None, cleanup: Some(_), .. } => vec![\"unwind\".into_cow()],\n             Call { destination: None, cleanup: None, .. } => vec![],\n+            Drop { unwind: None, .. } => vec![\"return\".into_cow()],\n+            Drop { .. } => vec![\"return\".into_cow(), \"unwind\".into_cow()],\n         }\n     }\n }\n@@ -435,15 +449,13 @@ pub struct Statement<'tcx> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n     Assign(Lvalue<'tcx>, Rvalue<'tcx>),\n-    Drop(Lvalue<'tcx>),\n }\n \n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n-            Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n-            Drop(ref lv) => write!(fmt, \"drop {:?}\", lv),\n+            Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv)\n         }\n     }\n }"}, {"sha": "fb4e0e97054b9fc41d7a3cbc05446dc3cac9c655", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=98265d338556e32c8ab1f89e14c0b3fab6e52001", "patch": "@@ -124,9 +124,6 @@ macro_rules! make_mir_visitor {\n                                           ref $($mutability)* rvalue) => {\n                         self.visit_assign(block, lvalue, rvalue);\n                     }\n-                    StatementKind::Drop(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::Drop);\n-                    }\n                 }\n             }\n \n@@ -177,10 +174,16 @@ macro_rules! make_mir_visitor {\n                     Terminator::Return => {\n                     }\n \n+                    Terminator::Drop { ref $($mutability)* value, target, unwind } => {\n+                        self.visit_lvalue(value, LvalueContext::Drop);\n+                        self.visit_branch(block, target);\n+                        unwind.map(|t| self.visit_branch(block, t));\n+                    }\n+\n                     Terminator::Call { ref $($mutability)* func,\n                                        ref $($mutability)* args,\n                                        ref $($mutability)* destination,\n-                                       ref $($mutability)* cleanup } => {\n+                                       cleanup } => {\n                         self.visit_operand(func);\n                         for arg in args {\n                             self.visit_operand(arg);"}, {"sha": "c7147d111aace02a0dddeb90e6e8107a629f700c", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=98265d338556e32c8ab1f89e14c0b3fab6e52001", "patch": "@@ -43,13 +43,6 @@ impl<'tcx> CFG<'tcx> {\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n-    pub fn push_drop(&mut self, block: BasicBlock, span: Span, lvalue: &Lvalue<'tcx>) {\n-        self.push(block, Statement {\n-            span: span,\n-            kind: StatementKind::Drop(lvalue.clone())\n-        });\n-    }\n-\n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n                        span: Span,"}, {"sha": "f50e5689df017cdbb7bcdc0c924070f964c91cb7", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=98265d338556e32c8ab1f89e14c0b3fab6e52001", "patch": "@@ -188,7 +188,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // operators like x[j] = x[i].\n                 let rhs = unpack!(block = this.as_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                this.cfg.push_drop(block, expr_span, &lhs);\n+                unpack!(block = this.build_drop(block, lhs.clone()));\n                 this.cfg.push_assign(block, expr_span, &lhs, Rvalue::Use(rhs));\n                 block.unit()\n             }"}, {"sha": "33397b483bea9a9739f7715fc0426022ac02d758", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 270, "deletions": 130, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=98265d338556e32c8ab1f89e14c0b3fab6e52001", "patch": "@@ -86,20 +86,41 @@ should go to.\n \n */\n \n-use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n use rustc::middle::region::CodeExtent;\n use rustc::middle::lang_items;\n-use rustc::middle::subst::{Substs, VecPerParamSpace};\n+use rustc::middle::subst::{Substs, Subst, VecPerParamSpace};\n use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::intern_and_get_ident;\n \n pub struct Scope<'tcx> {\n     extent: CodeExtent,\n-    drops: Vec<(Span, Lvalue<'tcx>)>,\n-    frees: Vec<(Span, Lvalue<'tcx>, Ty<'tcx>)>,\n-    cached_block: Option<BasicBlock>,\n+    drops: Vec<DropData<'tcx>>,\n+    // A scope may only have one associated free, because:\n+    // 1. We require a `free` to only be scheduled in the scope of `EXPR` in `box EXPR`;\n+    // 2. It only makes sense to have it translated into the diverge-path.\n+    free: Option<FreeData<'tcx>>,\n+}\n+\n+struct DropData<'tcx> {\n+    value: Lvalue<'tcx>,\n+    /// The cached block for the cleanups-on-diverge path. This block contains code to run the\n+    /// current drop and all the preceding drops (i.e. those having lower index in Drop\u2019s\n+    /// Scope drop array)\n+    cached_block: Option<BasicBlock>\n+}\n+\n+struct FreeData<'tcx> {\n+    span: Span,\n+    /// Lvalue containing the allocated box.\n+    value: Lvalue<'tcx>,\n+    /// type of item for which the box was allocated for (i.e. the T in Box<T>).\n+    item_ty: Ty<'tcx>,\n+    /// The cached block containing code to run the free. The block will also execute all the drops\n+    /// in the scope.\n+    cached_block: Option<BasicBlock>\n }\n \n #[derive(Clone, Debug)]\n@@ -115,7 +136,36 @@ pub struct LoopScope {\n     pub might_break: bool\n }\n \n+impl<'tcx> Scope<'tcx> {\n+    /// Invalidate cached blocks in the scope. Should always be run for all inner scopes when a\n+    /// drop is pushed into some scope enclosing a larger extent of code.\n+    fn invalidate_cache(&mut self, only_free: bool) {\n+        if let Some(ref mut freedata) = self.free {\n+            freedata.cached_block = None;\n+        }\n+        if !only_free {\n+            for dropdata in &mut self.drops {\n+                dropdata.cached_block = None;\n+            }\n+        }\n+    }\n+\n+    /// Returns the cached block for this scope.\n+    ///\n+    /// Precondition: the caches must be fully filled (i.e. diverge_cleanup is called) in order for\n+    /// this method to work correctly.\n+    fn cached_block(&self) -> Option<BasicBlock> {\n+        if let Some(ref free_data) = self.free {\n+            free_data.cached_block\n+        } else {\n+            self.drops.last().iter().flat_map(|dd| dd.cached_block).next()\n+        }\n+    }\n+}\n+\n impl<'a,'tcx> Builder<'a,'tcx> {\n+    // Adding and removing scopes\n+    // ==========================\n     /// Start a loop scope, which tracks where `continue` and `break`\n     /// should branch to. See module comment for more details.\n     ///\n@@ -147,9 +197,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        self.push_scope(extent, block);\n+        self.push_scope(extent);\n         let rv = unpack!(block = f(self));\n-        self.pop_scope(extent, block);\n+        unpack!(block = self.pop_scope(extent, block));\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n         block.and(rv)\n     }\n@@ -158,36 +208,51 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent, block: BasicBlock) {\n-        debug!(\"push_scope({:?}, {:?})\", extent, block);\n-\n-        // push scope, execute `f`, then pop scope again\n+    pub fn push_scope(&mut self, extent: CodeExtent) {\n+        debug!(\"push_scope({:?})\", extent);\n         self.scopes.push(Scope {\n             extent: extent.clone(),\n             drops: vec![],\n-            frees: vec![],\n-            cached_block: None,\n+            free: None\n         });\n     }\n \n     /// Pops a scope, which should have extent `extent`, adding any\n     /// drops onto the end of `block` that are needed.  This must\n     /// match 1-to-1 with `push_scope`.\n-    pub fn pop_scope(&mut self, extent: CodeExtent, block: BasicBlock) {\n+    pub fn pop_scope(&mut self, extent: CodeExtent, block: BasicBlock) -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", extent, block);\n+        // We need to have `cached_block`s available for all the drops, so we call diverge_cleanup\n+        // to make sure all the `cached_block`s are filled in.\n+        self.diverge_cleanup();\n         let scope = self.scopes.pop().unwrap();\n-\n         assert_eq!(scope.extent, extent);\n+        build_scope_drops(block, &scope, &self.scopes[..], &mut self.cfg)\n+    }\n+\n+\n+    /// Branch out of `block` to `target`, exiting all scopes up to\n+    /// and including `extent`.  This will insert whatever drops are\n+    /// needed, as well as tracking this exit for the SEME region. See\n+    /// module comment for details.\n+    pub fn exit_scope(&mut self,\n+                      span: Span,\n+                      extent: CodeExtent,\n+                      mut block: BasicBlock,\n+                      target: BasicBlock) {\n+        let scope_count = 1 + self.scopes.iter().rev().position(|scope| scope.extent == extent)\n+                                                      .unwrap_or_else(||{\n+            self.hir.span_bug(span, &format!(\"extent {:?} does not enclose\", extent))\n+        });\n \n-        // add in any drops needed on the fallthrough path (any other\n-        // exiting paths, such as those that arise from `break`, will\n-        // have drops already)\n-        for (span, lvalue) in scope.drops {\n-            self.cfg.push_drop(block, span, &lvalue);\n+        for (idx, ref scope) in self.scopes.iter().enumerate().rev().take(scope_count) {\n+            unpack!(block = build_scope_drops(block, scope, &self.scopes[..idx], &mut self.cfg));\n         }\n+        self.cfg.terminate(block, Terminator::Goto { target: target });\n     }\n \n-\n+    // Finding scopes\n+    // ==============\n     /// Finds the loop scope for a given label. This is used for\n     /// resolving `break` and `continue`.\n     pub fn find_loop_scope(&mut self,\n@@ -210,30 +275,79 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }.unwrap_or_else(|| hir.span_bug(span, \"no enclosing loop scope found?\"))\n     }\n \n-    /// Branch out of `block` to `target`, exiting all scopes up to\n-    /// and including `extent`.  This will insert whatever drops are\n-    /// needed, as well as tracking this exit for the SEME region. See\n-    /// module comment for details.\n-    pub fn exit_scope(&mut self,\n-                      span: Span,\n-                      extent: CodeExtent,\n-                      block: BasicBlock,\n-                      target: BasicBlock) {\n-        let Builder { ref mut scopes, ref mut cfg, ref mut hir, .. } = *self;\n+    pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n+        self.scopes.last().map(|scope| scope.extent).unwrap()\n+    }\n \n-        let scope_count = 1 + scopes.iter().rev().position(|scope| scope.extent == extent)\n-                                                 .unwrap_or_else(||{\n-            hir.span_bug(span, &format!(\"extent {:?} does not enclose\", extent))\n-        });\n+    pub fn extent_of_outermost_scope(&self) -> CodeExtent {\n+        self.scopes.first().map(|scope| scope.extent).unwrap()\n+    }\n+\n+    // Scheduling drops\n+    // ================\n+    /// Indicates that `lvalue` should be dropped on exit from\n+    /// `extent`.\n+    pub fn schedule_drop(&mut self,\n+                         span: Span,\n+                         extent: CodeExtent,\n+                         lvalue: &Lvalue<'tcx>,\n+                         lvalue_ty: Ty<'tcx>) {\n+        if !self.hir.needs_drop(lvalue_ty) {\n+            return\n+        }\n+        for scope in self.scopes.iter_mut().rev() {\n+            if scope.extent == extent {\n+                // We only invalidate cached block of free here; all other drops\u2019 cached blocks to\n+                // not become invalid (this drop will branch into them).\n+                scope.invalidate_cache(true);\n+                scope.drops.push(DropData {\n+                    value: lvalue.clone(),\n+                    cached_block: None\n+                });\n+                return;\n+            } else {\n+                // We must invalidate all the cached_blocks leading up to the scope we\u2019re\n+                // looking for, because all of the blocks in the chain become incorrect.\n+                scope.invalidate_cache(false)\n+            }\n+        }\n+        self.hir.span_bug(span,\n+                          &format!(\"extent {:?} not in scope to drop {:?}\", extent, lvalue));\n+    }\n \n-        for scope in scopes.iter_mut().rev().take(scope_count) {\n-            for &(drop_span, ref lvalue) in &scope.drops {\n-                cfg.push_drop(block, drop_span, lvalue);\n+    /// Schedule dropping of a not-yet-fully-initialised box.\n+    ///\n+    /// This cleanup will only be translated into unwind branch.\n+    /// The extent should be for the `EXPR` inside `box EXPR`.\n+    /// There may only be one \u201cfree\u201d scheduled in any given scope.\n+    pub fn schedule_box_free(&mut self,\n+                             span: Span,\n+                             extent: CodeExtent,\n+                             value: &Lvalue<'tcx>,\n+                             item_ty: Ty<'tcx>) {\n+        for scope in self.scopes.iter_mut().rev() {\n+            if scope.extent == extent {\n+                assert!(scope.free.is_none(), \"scope already has a scheduled free!\");\n+                scope.free = Some(FreeData {\n+                    span: span,\n+                    value: value.clone(),\n+                    item_ty: item_ty,\n+                    cached_block: None\n+                });\n+                return;\n+            } else {\n+                // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n+                // for, because otherwise some/most of the blocks in the chain might become\n+                // incorrect.\n+                scope.invalidate_cache(false);\n             }\n         }\n-        cfg.terminate(block, Terminator::Goto { target: target });\n+        self.hir.span_bug(span,\n+                          &format!(\"extent {:?} not in scope to free {:?}\", extent, value));\n     }\n \n+    // Other\n+    // =====\n     /// Creates a path that performs all required cleanup for unwinding.\n     ///\n     /// This path terminates in Resume. Returns the start of the path.\n@@ -244,114 +358,113 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             return None;\n         }\n \n-        let tcx = self.hir.tcx();\n         let unit_tmp = self.get_unit_temp();\n-        let mut terminator = Terminator::Resume;\n+        let Builder { ref mut scopes, ref mut cfg, ref mut hir, .. } = *self;\n+\n+        let tcx = hir.tcx();\n+        let mut next_block = None;\n+\n         // Given an array of scopes, we generate these from the outermost scope to the innermost\n         // one. Thus for array [S0, S1, S2] with corresponding cleanup blocks [B0, B1, B2], we will\n-        // generate B0 <- B1 <- B2 in left-to-right order. The outermost scope (B0) will always\n-        // terminate with a Resume terminator.\n-        for scope in self.scopes.iter_mut().filter(|s| !s.drops.is_empty() || !s.frees.is_empty()) {\n-            if let Some(b) = scope.cached_block {\n-                terminator = Terminator::Goto { target: b };\n+        // generate B0 <- B1 <- B2 in left-to-right order. Control flow of the generated blocks\n+        // always ends up at a block with the Resume terminator.\n+        //\n+        // Similarly to the scopes, we translate drops so:\n+        // * Scheduled free drop is executed first;\n+        // * Drops are executed after the free drop in the decreasing order (decreasing as\n+        // from higher index in drops array to lower index);\n+        //\n+        // NB: We do the building backwards here. We will first produce a block containing the\n+        // Resume terminator (which is executed last for any given chain of cleanups) and then go\n+        // on building the drops from the outermost one to the innermost one. Similar note applies\n+        // to the drops within the scope too.\n+        {\n+        let iter = scopes.iter_mut().filter(|s| !s.drops.is_empty() || s.free.is_some());\n+        for scope in iter {\n+            // Try using the cached free drop if any\u2026\n+            if let Some(FreeData { cached_block: Some(cached_block), .. }) = scope.free {\n+                next_block = Some(cached_block);\n                 continue;\n-            } else {\n-                let mut new_block = self.cfg.start_new_cleanup_block();\n-                self.cfg.terminate(new_block, terminator);\n-                terminator = Terminator::Goto { target: new_block };\n-\n-                for &(span, ref lvalue) in scope.drops.iter().rev() {\n-                    self.cfg.push_drop(new_block, span, lvalue);\n+            }\n+            // otherwise look for the cached regular drop (fast path)\u2026\n+            if let Some(&DropData { cached_block: Some(cached_block), .. }) = scope.drops.last() {\n+                next_block = Some(cached_block);\n+                continue;\n+            }\n+            // otherwise build the blocks\u2026\n+            for drop_data in scope.drops.iter_mut() {\n+                // skipping them if they\u2019re already built\u2026\n+                if let Some(cached_block) = drop_data.cached_block {\n+                    next_block = Some(cached_block);\n+                    continue;\n                 }\n+                let block = cfg.start_new_cleanup_block();\n+                let target = next_block.unwrap_or_else(|| {\n+                    let b = cfg.start_new_cleanup_block();\n+                    cfg.terminate(b, Terminator::Resume);\n+                    b\n+                });\n+                cfg.terminate(block, Terminator::Drop {\n+                    value: drop_data.value.clone(),\n+                    target: target,\n+                    unwind: None\n+                });\n+                drop_data.cached_block = Some(block);\n+                next_block = Some(block);\n+            }\n \n-                for &(_, ref lvalue, ref item_ty) in scope.frees.iter().rev() {\n-                    let item = lang_items::SpannedLangItems::box_free_fn(&tcx.lang_items)\n-                        .expect(\"box_free language item required\");\n-                    let substs = tcx.mk_substs(Substs::new(\n-                        VecPerParamSpace::new(vec![], vec![], vec![item_ty]),\n-                        VecPerParamSpace::new(vec![], vec![], vec![])\n-                    ));\n-                    let func = Constant {\n-                        span: item.1,\n-                        ty: tcx.lookup_item_type(item.0).ty,\n+            if let Some(ref mut free_data) = scope.free {\n+                // The free was not cached yet. It must be translated the last and will be executed\n+                // first.\n+                let free_func = tcx.lang_items.box_free_fn()\n+                                   .expect(\"box_free language item is missing\");\n+                let substs = tcx.mk_substs(Substs::new(\n+                    VecPerParamSpace::new(vec![], vec![], vec![free_data.item_ty]),\n+                    VecPerParamSpace::new(vec![], vec![], vec![])\n+                ));\n+                let block = cfg.start_new_cleanup_block();\n+                let target = next_block.unwrap_or_else(|| {\n+                    let b = cfg.start_new_cleanup_block();\n+                    cfg.terminate(b, Terminator::Resume);\n+                    b\n+                });\n+                cfg.terminate(block, Terminator::Call {\n+                    func: Operand::Constant(Constant {\n+                        span: free_data.span,\n+                        ty: tcx.lookup_item_type(free_func).ty.subst(tcx, substs),\n                         literal: Literal::Item {\n-                            def_id: item.0,\n+                            def_id: free_func,\n                             kind: ItemKind::Function,\n                             substs: substs\n                         }\n-                    };\n-                    let old_block = new_block;\n-                    new_block = self.cfg.start_new_cleanup_block();\n-                    self.cfg.terminate(new_block, Terminator::Call {\n-                        func: Operand::Constant(func),\n-                        args: vec![Operand::Consume(lvalue.clone())],\n-                        destination: Some((unit_tmp.clone(), old_block)),\n-                        cleanup: None // we\u2019re already doing divergence cleanups\n-                    });\n-                    terminator = Terminator::Goto { target: new_block };\n-                }\n-\n-                scope.cached_block = Some(new_block);\n+                    }),\n+                    args: vec![Operand::Consume(free_data.value.clone())],\n+                    destination: Some((unit_tmp.clone(), target)),\n+                    cleanup: None\n+                });\n+                free_data.cached_block = Some(block);\n+                next_block = Some(block);\n             }\n         }\n-        // Return the innermost cached block, most likely the one we just generated.\n-        // Note that if there are no cleanups in scope we return None.\n-        self.scopes.iter().rev().flat_map(|b| b.cached_block).next()\n-    }\n-\n-    /// Indicates that `lvalue` should be dropped on exit from\n-    /// `extent`.\n-    pub fn schedule_drop(&mut self,\n-                         span: Span,\n-                         extent: CodeExtent,\n-                         lvalue: &Lvalue<'tcx>,\n-                         lvalue_ty: Ty<'tcx>) {\n-        if self.hir.needs_drop(lvalue_ty) {\n-            for scope in self.scopes.iter_mut().rev() {\n-                // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n-                // for, because otherwise some/most of the blocks in the chain might become\n-                // incorrect (i.e. they still are pointing at old cached_block).\n-                scope.cached_block = None;\n-                if scope.extent == extent {\n-                    scope.drops.push((span, lvalue.clone()));\n-                    return;\n-                }\n-            }\n-            self.hir.span_bug(span,\n-                              &format!(\"extent {:?} not in scope to drop {:?}\", extent, lvalue));\n         }\n+        scopes.iter().rev().flat_map(|x| x.cached_block()).next()\n     }\n \n-    /// Schedule dropping of a not yet fully initialised box. This cleanup will (and should) only\n-    /// be translated into unwind branch. The extent should be for the `EXPR` inside `box EXPR`.\n-    pub fn schedule_box_free(&mut self,\n-                             span: Span,\n-                             extent: CodeExtent,\n-                             lvalue: &Lvalue<'tcx>,\n-                             item_ty: Ty<'tcx>) {\n-        for scope in self.scopes.iter_mut().rev() {\n-            // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n-            // for, because otherwise some/most of the blocks in the chain might become\n-            // incorrect (i.e. they still are pointing at old cached_block).\n-            scope.cached_block = None;\n-            if scope.extent == extent {\n-                scope.frees.push((span, lvalue.clone(), item_ty));\n-                return;\n-            }\n-        }\n-        self.hir.span_bug(span,\n-                          &format!(\"extent {:?} not in scope to drop {:?}\", extent, lvalue));\n-    }\n-\n-    pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n-        self.scopes.last().map(|scope| scope.extent).unwrap()\n-    }\n-\n-    pub fn extent_of_outermost_scope(&self) -> CodeExtent {\n-        self.scopes.first().map(|scope| scope.extent).unwrap()\n+    /// Utility function for *non*-scope code to build their own drops\n+    pub fn build_drop(&mut self, block: BasicBlock, value: Lvalue<'tcx>) -> BlockAnd<()> {\n+        let next_target = self.cfg.start_new_block();\n+        let diverge_target = self.diverge_cleanup();\n+        self.cfg.terminate(block, Terminator::Drop {\n+            value: value,\n+            target: next_target,\n+            unwind: diverge_target,\n+        });\n+        next_target.unit()\n     }\n \n-\n+    // Panicking\n+    // =========\n+    // FIXME: should be moved into their own module\n     pub fn panic_bounds_check(&mut self,\n                              block: BasicBlock,\n                              index: Operand<'tcx>,\n@@ -456,3 +569,30 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     }\n \n }\n+\n+/// Builds drops for pop_scope and exit_scope.\n+fn build_scope_drops<'tcx>(mut block: BasicBlock,\n+                           scope: &Scope<'tcx>,\n+                           earlier_scopes: &[Scope<'tcx>],\n+                           cfg: &mut CFG<'tcx>)\n+                           -> BlockAnd<()> {\n+    let mut iter = scope.drops.iter().rev().peekable();\n+    while let Some(drop_data) = iter.next() {\n+        // Try to find the next block with its cached block for us to diverge into in case the\n+        // drop panics.\n+        let on_diverge = iter.peek().iter().flat_map(|dd| dd.cached_block.into_iter()).next();\n+        // If there\u2019s no `cached_block`s within current scope, we must look for one in the\n+        // enclosing scope.\n+        let on_diverge = on_diverge.or_else(||{\n+            earlier_scopes.iter().rev().flat_map(|s| s.cached_block()).next()\n+        });\n+        let next = cfg.start_new_block();\n+        cfg.terminate(block, Terminator::Drop {\n+            value: drop_data.value.clone(),\n+            target: next,\n+            unwind: on_diverge\n+        });\n+        block = next;\n+    }\n+    block.unit()\n+}"}, {"sha": "6c0f1c7081be8f44c47a7cd3da41483bb11df4d6", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=98265d338556e32c8ab1f89e14c0b3fab6e52001", "patch": "@@ -42,16 +42,16 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 None => {\n                     let (extent, _) = stmt_lists.pop().unwrap();\n                     if let Some(extent) = extent {\n-                        this.pop_scope(extent, block);\n+                        unpack!(block = this.pop_scope(extent, block));\n                     }\n                     continue\n                 }\n             };\n \n-            let Stmt { span, kind } = this.hir.mirror(stmt);\n+            let Stmt { span: _, kind } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Let { remainder_scope, init_scope, pattern, initializer, stmts } => {\n-                    this.push_scope(remainder_scope, block);\n+                    this.push_scope(remainder_scope);\n                     stmt_lists.push((Some(remainder_scope), stmts.into_iter()));\n                     unpack!(block = this.in_scope(init_scope, block, move |this| {\n                         // FIXME #30046                              ^~~~\n@@ -72,7 +72,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         let expr = this.hir.mirror(expr);\n                         let temp = this.temp(expr.ty.clone());\n                         unpack!(block = this.into(&temp, block, expr));\n-                        this.cfg.push_drop(block, span, &temp);\n+                        unpack!(block = this.build_drop(block, temp));\n                         block.unit()\n                     }));\n                 }"}, {"sha": "d0dbdeb033db216db97c9d3b7b5ad4cd1349b0c3", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=98265d338556e32c8ab1f89e14c0b3fab6e52001", "patch": "@@ -69,9 +69,6 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n                 self.erase_regions_lvalue(lvalue);\n                 self.erase_regions_rvalue(rvalue);\n             }\n-            StatementKind::Drop(ref mut lvalue) => {\n-                self.erase_regions_lvalue(lvalue);\n-            }\n         }\n     }\n \n@@ -93,6 +90,9 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n                 self.erase_regions_lvalue(discr);\n                 *switch_ty = self.tcx.erase_regions(switch_ty);\n             },\n+            Terminator::Drop { ref mut value, .. } => {\n+                self.erase_regions_lvalue(value);\n+            }\n             Terminator::Call { ref mut func, ref mut args, ref mut destination, .. } => {\n                 if let Some((ref mut destination, _)) = *destination {\n                     self.erase_regions_lvalue(destination);"}, {"sha": "bb43c5ae97e5892fd6acfc68795f5f08ca685fa1", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=98265d338556e32c8ab1f89e14c0b3fab6e52001", "patch": "@@ -18,10 +18,11 @@ use trans::base;\n use trans::build;\n use trans::common::{self, Block, LandingPad};\n use trans::debuginfo::DebugLoc;\n+use trans::Disr;\n use trans::foreign;\n+use trans::glue;\n use trans::type_of;\n use trans::type_::Type;\n-use trans::Disr;\n \n use super::MirContext;\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n@@ -94,6 +95,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n             }\n \n+            mir::Terminator::Drop { ref value, target, unwind: _ } => {\n+                let lvalue = self.trans_lvalue(bcx, value);\n+                // FIXME: this does not account for possibility of unwinding (and totally should).\n+                glue::drop_ty(bcx, lvalue.llval, lvalue.ty.to_ty(bcx.tcx()), DebugLoc::None);\n+                build::Br(bcx, self.llblock(target), DebugLoc::None);\n+            }\n+\n             mir::Terminator::Call { ref func, ref args, ref destination, ref cleanup } => {\n                 // Create the callee. This will always be a fn ptr and hence a kind of scalar.\n                 let callee = self.trans_operand(bcx, func);"}, {"sha": "fc8885647377c685c169bd5e88556e1d171ce280", "filename": "src/librustc_trans/trans/mir/statement.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98265d338556e32c8ab1f89e14c0b3fab6e52001/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs?ref=98265d338556e32c8ab1f89e14c0b3fab6e52001", "patch": "@@ -10,8 +10,6 @@\n \n use rustc::mir::repr as mir;\n use trans::common::Block;\n-use trans::debuginfo::DebugLoc;\n-use trans::glue;\n \n use super::MirContext;\n use super::TempRef;\n@@ -50,12 +48,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                 }\n             }\n-\n-            mir::StatementKind::Drop(ref lvalue) => {\n-                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                glue::drop_ty(bcx, tr_lvalue.llval, ty, DebugLoc::None)\n-            }\n         }\n     }\n }"}]}