{"sha": "17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YjYyNjFjYzQxMzQzYjFmMmI2MTFjYTEyZjFjY2QyZDQzMDZlZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-27T18:51:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-27T18:51:53Z"}, "message": "Auto merge of #33795 - srinivasreddy:lib_coll_test, r=nrc\n\nrun rustfmt on libcollections test module", "tree": {"sha": "45f741684846665591541480448d502a9ff4ed2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45f741684846665591541480448d502a9ff4ed2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "html_url": "https://github.com/rust-lang/rust/commit/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab7c35fa0fcd725cdc207487b760d85fd07ecdd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7c35fa0fcd725cdc207487b760d85fd07ecdd7", "html_url": "https://github.com/rust-lang/rust/commit/ab7c35fa0fcd725cdc207487b760d85fd07ecdd7"}, {"sha": "69db6e6032e81f9e5b85d28d73ddd0569e5a2166", "url": "https://api.github.com/repos/rust-lang/rust/commits/69db6e6032e81f9e5b85d28d73ddd0569e5a2166", "html_url": "https://github.com/rust-lang/rust/commit/69db6e6032e81f9e5b85d28d73ddd0569e5a2166"}], "stats": {"total": 847, "additions": 442, "deletions": 405}, "files": [{"sha": "e19090c7599ecd3d6e6b4fc35fd26c365469403e", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 74, "deletions": 44, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::collections::BTreeMap;\n-use std::collections::Bound::{Excluded, Included, Unbounded, self};\n+use std::collections::Bound::{self, Excluded, Included, Unbounded};\n use std::collections::btree_map::Entry::{Occupied, Vacant};\n use std::rc::Rc;\n \n@@ -20,41 +20,41 @@ fn test_basic_large() {\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n-        assert_eq!(map.insert(i, 10*i), None);\n+        assert_eq!(map.insert(i, 10 * i), None);\n         assert_eq!(map.len(), i + 1);\n     }\n \n     for i in 0..size {\n-        assert_eq!(map.get(&i).unwrap(), &(i*10));\n+        assert_eq!(map.get(&i).unwrap(), &(i * 10));\n     }\n \n-    for i in size..size*2 {\n+    for i in size..size * 2 {\n         assert_eq!(map.get(&i), None);\n     }\n \n     for i in 0..size {\n-        assert_eq!(map.insert(i, 100*i), Some(10*i));\n+        assert_eq!(map.insert(i, 100 * i), Some(10 * i));\n         assert_eq!(map.len(), size);\n     }\n \n     for i in 0..size {\n-        assert_eq!(map.get(&i).unwrap(), &(i*100));\n+        assert_eq!(map.get(&i).unwrap(), &(i * 100));\n     }\n \n-    for i in 0..size/2 {\n-        assert_eq!(map.remove(&(i*2)), Some(i*200));\n+    for i in 0..size / 2 {\n+        assert_eq!(map.remove(&(i * 2)), Some(i * 200));\n         assert_eq!(map.len(), size - i - 1);\n     }\n \n-    for i in 0..size/2 {\n-        assert_eq!(map.get(&(2*i)), None);\n-        assert_eq!(map.get(&(2*i+1)).unwrap(), &(i*200 + 100));\n+    for i in 0..size / 2 {\n+        assert_eq!(map.get(&(2 * i)), None);\n+        assert_eq!(map.get(&(2 * i + 1)).unwrap(), &(i * 200 + 100));\n     }\n \n-    for i in 0..size/2 {\n-        assert_eq!(map.remove(&(2*i)), None);\n-        assert_eq!(map.remove(&(2*i+1)), Some(i*200 + 100));\n-        assert_eq!(map.len(), size/2 - i - 1);\n+    for i in 0..size / 2 {\n+        assert_eq!(map.remove(&(2 * i)), None);\n+        assert_eq!(map.remove(&(2 * i + 1)), Some(i * 200 + 100));\n+        assert_eq!(map.len(), size / 2 - i - 1);\n     }\n }\n \n@@ -81,7 +81,9 @@ fn test_iter() {\n     // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-    fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n+    fn test<T>(size: usize, mut iter: T)\n+        where T: Iterator<Item = (usize, usize)>\n+    {\n         for i in 0..size {\n             assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n             assert_eq!(iter.next().unwrap(), (i, i));\n@@ -101,7 +103,9 @@ fn test_iter_rev() {\n     // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-    fn test<T>(size: usize, mut iter: T) where T: Iterator<Item=(usize, usize)> {\n+    fn test<T>(size: usize, mut iter: T)\n+        where T: Iterator<Item = (usize, usize)>\n+    {\n         for i in 0..size {\n             assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n             assert_eq!(iter.next().unwrap(), (size - i - 1, size - i - 1));\n@@ -125,8 +129,7 @@ fn test_values_mut() {\n     }\n \n     let values: Vec<String> = a.values().cloned().collect();\n-    assert_eq!(values, [String::from(\"hello!\"),\n-                        String::from(\"goodbye!\")]);\n+    assert_eq!(values, [String::from(\"hello!\"), String::from(\"goodbye!\")]);\n }\n \n #[test]\n@@ -137,7 +140,8 @@ fn test_iter_mixed() {\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n-            where T: Iterator<Item=(usize, usize)> + DoubleEndedIterator {\n+        where T: Iterator<Item = (usize, usize)> + DoubleEndedIterator\n+    {\n         for i in 0..size / 4 {\n             assert_eq!(iter.size_hint(), (size - i * 2, Some(size - i * 2)));\n             assert_eq!(iter.next().unwrap(), (i, i));\n@@ -202,7 +206,7 @@ fn test_range() {\n     for i in 0..size {\n         for j in i..size {\n             let mut kvs = map.range(Included(&i), Included(&j)).map(|(&k, &v)| (k, v));\n-            let mut pairs = (i..j+1).map(|i| (i, i));\n+            let mut pairs = (i..j + 1).map(|i| (i, i));\n \n             for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n                 assert_eq!(kv, pair);\n@@ -242,7 +246,7 @@ fn test_borrow() {\n }\n \n #[test]\n-fn test_entry(){\n+fn test_entry() {\n     let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n     let mut map: BTreeMap<_, _> = xs.iter().cloned().collect();\n@@ -341,17 +345,23 @@ fn test_bad_zst() {\n     struct Bad;\n \n     impl PartialEq for Bad {\n-        fn eq(&self, _: &Self) -> bool { false }\n+        fn eq(&self, _: &Self) -> bool {\n+            false\n+        }\n     }\n \n     impl Eq for Bad {}\n \n     impl PartialOrd for Bad {\n-        fn partial_cmp(&self, _: &Self) -> Option<Ordering> { Some(Ordering::Less) }\n+        fn partial_cmp(&self, _: &Self) -> Option<Ordering> {\n+            Some(Ordering::Less)\n+        }\n     }\n \n     impl Ord for Bad {\n-        fn cmp(&self, _: &Self) -> Ordering { Ordering::Less }\n+        fn cmp(&self, _: &Self) -> Ordering {\n+            Ordering::Less\n+        }\n     }\n \n     let mut m = BTreeMap::new();\n@@ -368,27 +378,27 @@ fn test_clone() {\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n-        assert_eq!(map.insert(i, 10*i), None);\n+        assert_eq!(map.insert(i, 10 * i), None);\n         assert_eq!(map.len(), i + 1);\n         assert_eq!(map, map.clone());\n     }\n \n     for i in 0..size {\n-        assert_eq!(map.insert(i, 100*i), Some(10*i));\n+        assert_eq!(map.insert(i, 100 * i), Some(10 * i));\n         assert_eq!(map.len(), size);\n         assert_eq!(map, map.clone());\n     }\n \n-    for i in 0..size/2 {\n-        assert_eq!(map.remove(&(i*2)), Some(i*200));\n+    for i in 0..size / 2 {\n+        assert_eq!(map.remove(&(i * 2)), Some(i * 200));\n         assert_eq!(map.len(), size - i - 1);\n         assert_eq!(map, map.clone());\n     }\n \n-    for i in 0..size/2 {\n-        assert_eq!(map.remove(&(2*i)), None);\n-        assert_eq!(map.remove(&(2*i+1)), Some(i*200 + 100));\n-        assert_eq!(map.len(), size/2 - i - 1);\n+    for i in 0..size / 2 {\n+        assert_eq!(map.remove(&(2 * i)), None);\n+        assert_eq!(map.remove(&(2 * i + 1)), Some(i * 200 + 100));\n+        assert_eq!(map.len(), size / 2 - i - 1);\n         assert_eq!(map, map.clone());\n     }\n }\n@@ -398,16 +408,36 @@ fn test_clone() {\n fn test_variance() {\n     use std::collections::btree_map::{Iter, IntoIter, Range, Keys, Values};\n \n-    fn map_key<'new>(v: BTreeMap<&'static str, ()>) -> BTreeMap<&'new str, ()> { v }\n-    fn map_val<'new>(v: BTreeMap<(), &'static str>) -> BTreeMap<(), &'new str> { v }\n-    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, ()>) -> Iter<'a, &'new str, ()> { v }\n-    fn iter_val<'a, 'new>(v: Iter<'a, (), &'static str>) -> Iter<'a, (), &'new str> { v }\n-    fn into_iter_key<'new>(v: IntoIter<&'static str, ()>) -> IntoIter<&'new str, ()> { v }\n-    fn into_iter_val<'new>(v: IntoIter<(), &'static str>) -> IntoIter<(), &'new str> { v }\n-    fn range_key<'a, 'new>(v: Range<'a, &'static str, ()>) -> Range<'a, &'new str, ()> { v }\n-    fn range_val<'a, 'new>(v: Range<'a, (), &'static str>) -> Range<'a, (), &'new str> { v }\n-    fn keys<'a, 'new>(v: Keys<'a, &'static str, ()>) -> Keys<'a, &'new str, ()> { v }\n-    fn vals<'a, 'new>(v: Values<'a, (), &'static str>) -> Values<'a, (), &'new str> { v }\n+    fn map_key<'new>(v: BTreeMap<&'static str, ()>) -> BTreeMap<&'new str, ()> {\n+        v\n+    }\n+    fn map_val<'new>(v: BTreeMap<(), &'static str>) -> BTreeMap<(), &'new str> {\n+        v\n+    }\n+    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, ()>) -> Iter<'a, &'new str, ()> {\n+        v\n+    }\n+    fn iter_val<'a, 'new>(v: Iter<'a, (), &'static str>) -> Iter<'a, (), &'new str> {\n+        v\n+    }\n+    fn into_iter_key<'new>(v: IntoIter<&'static str, ()>) -> IntoIter<&'new str, ()> {\n+        v\n+    }\n+    fn into_iter_val<'new>(v: IntoIter<(), &'static str>) -> IntoIter<(), &'new str> {\n+        v\n+    }\n+    fn range_key<'a, 'new>(v: Range<'a, &'static str, ()>) -> Range<'a, &'new str, ()> {\n+        v\n+    }\n+    fn range_val<'a, 'new>(v: Range<'a, (), &'static str>) -> Range<'a, (), &'new str> {\n+        v\n+    }\n+    fn keys<'a, 'new>(v: Keys<'a, &'static str, ()>) -> Keys<'a, &'new str, ()> {\n+        v\n+    }\n+    fn vals<'a, 'new>(v: Values<'a, (), &'static str>) -> Values<'a, (), &'new str> {\n+        v\n+    }\n }\n \n #[test]\n@@ -440,7 +470,7 @@ fn test_vacant_entry_key() {\n         Vacant(e) => {\n             assert_eq!(key, *e.key());\n             e.insert(value.clone());\n-        },\n+        }\n     }\n     assert_eq!(a.len(), 1);\n     assert_eq!(a[key], value);"}, {"sha": "972361326d7bb33af99e99d0a34b49ff8a4ccc70", "filename": "src/libcollectionstest/enum_set.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fenum_set.rs?ref=17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "patch": "@@ -17,7 +17,9 @@ use self::Foo::*;\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(usize)]\n enum Foo {\n-    A, B, C\n+    A,\n+    B,\n+    C,\n }\n \n impl CLike for Foo {\n@@ -157,15 +159,15 @@ fn test_iterator() {\n \n     e1.insert(C);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A,C]);\n+    assert_eq!(elems, [A, C]);\n \n     e1.insert(C);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A,C]);\n+    assert_eq!(elems, [A, C]);\n \n     e1.insert(B);\n     let elems: Vec<_> = e1.iter().collect();\n-    assert_eq!(elems, [A,B,C]);\n+    assert_eq!(elems, [A, B, C]);\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -183,7 +185,7 @@ fn test_operators() {\n \n     let e_union = e1 | e2;\n     let elems: Vec<_> = e_union.iter().collect();\n-    assert_eq!(elems, [A,B,C]);\n+    assert_eq!(elems, [A, B, C]);\n \n     let e_intersection = e1 & e2;\n     let elems: Vec<_> = e_intersection.iter().collect();\n@@ -201,17 +203,17 @@ fn test_operators() {\n     // Bitwise XOR of two sets, aka symmetric difference\n     let e_symmetric_diff = e1 ^ e2;\n     let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!(elems, [A,B]);\n+    assert_eq!(elems, [A, B]);\n \n     // Another way to express symmetric difference\n     let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n     let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!(elems, [A,B]);\n+    assert_eq!(elems, [A, B]);\n \n     // Yet another way to express symmetric difference\n     let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n     let elems: Vec<_> = e_symmetric_diff.iter().collect();\n-    assert_eq!(elems, [A,B]);\n+    assert_eq!(elems, [A, B]);\n }\n \n #[test]"}, {"sha": "956d75a95a58e9b77230ce2804a5ebbaeab9e72c", "filename": "src/libcollectionstest/linked_list.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flinked_list.rs?ref=17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "patch": "@@ -54,7 +54,7 @@ fn test_basic() {\n \n #[cfg(test)]\n fn generate_test() -> LinkedList<i32> {\n-    list_from(&[0,1,2,3,4,5,6])\n+    list_from(&[0, 1, 2, 3, 4, 5, 6])\n }\n \n #[cfg(test)]\n@@ -78,7 +78,7 @@ fn test_split_off() {\n \n     // not singleton, forwards\n     {\n-        let u = vec![1,2,3,4,5];\n+        let u = vec![1, 2, 3, 4, 5];\n         let mut m = list_from(&u);\n         let mut n = m.split_off(2);\n         assert_eq!(m.len(), 2);\n@@ -92,7 +92,7 @@ fn test_split_off() {\n     }\n     // not singleton, backwards\n     {\n-        let u = vec![1,2,3,4,5];\n+        let u = vec![1, 2, 3, 4, 5];\n         let mut m = list_from(&u);\n         let mut n = m.split_off(4);\n         assert_eq!(m.len(), 4);\n@@ -246,33 +246,33 @@ fn test_eq() {\n     m.push_back(1);\n     assert!(n == m);\n \n-    let n = list_from(&[2,3,4]);\n-    let m = list_from(&[1,2,3]);\n+    let n = list_from(&[2, 3, 4]);\n+    let m = list_from(&[1, 2, 3]);\n     assert!(n != m);\n }\n \n #[test]\n fn test_hash() {\n-  let mut x = LinkedList::new();\n-  let mut y = LinkedList::new();\n+    let mut x = LinkedList::new();\n+    let mut y = LinkedList::new();\n \n-  assert!(::hash(&x) == ::hash(&y));\n+    assert!(::hash(&x) == ::hash(&y));\n \n-  x.push_back(1);\n-  x.push_back(2);\n-  x.push_back(3);\n+    x.push_back(1);\n+    x.push_back(2);\n+    x.push_back(3);\n \n-  y.push_front(3);\n-  y.push_front(2);\n-  y.push_front(1);\n+    y.push_front(3);\n+    y.push_front(2);\n+    y.push_front(1);\n \n-  assert!(::hash(&x) == ::hash(&y));\n+    assert!(::hash(&x) == ::hash(&y));\n }\n \n #[test]\n fn test_ord() {\n     let n = list_from(&[]);\n-    let m = list_from(&[1,2,3]);\n+    let m = list_from(&[1, 2, 3]);\n     assert!(n < m);\n     assert!(m > n);\n     assert!(n <= n);\n@@ -281,7 +281,7 @@ fn test_ord() {\n \n #[test]\n fn test_ord_nan() {\n-    let nan = 0.0f64/0.0;\n+    let nan = 0.0f64 / 0.0;\n     let n = list_from(&[nan]);\n     let m = list_from(&[nan]);\n     assert!(!(n < m));\n@@ -296,15 +296,15 @@ fn test_ord_nan() {\n     assert!(!(n <= one));\n     assert!(!(n >= one));\n \n-    let u = list_from(&[1.0f64,2.0,nan]);\n-    let v = list_from(&[1.0f64,2.0,3.0]);\n+    let u = list_from(&[1.0f64, 2.0, nan]);\n+    let v = list_from(&[1.0f64, 2.0, 3.0]);\n     assert!(!(u < v));\n     assert!(!(u > v));\n     assert!(!(u <= v));\n     assert!(!(u >= v));\n \n-    let s = list_from(&[1.0f64,2.0,4.0,2.0]);\n-    let t = list_from(&[1.0f64,2.0,3.0,2.0]);\n+    let s = list_from(&[1.0f64, 2.0, 4.0, 2.0]);\n+    let t = list_from(&[1.0f64, 2.0, 3.0, 2.0]);\n     assert!(!(s < t));\n     assert!(s > one);\n     assert!(!(s <= one));\n@@ -317,7 +317,8 @@ fn test_show() {\n     assert_eq!(format!(\"{:?}\", list), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n     let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-    assert_eq!(format!(\"{:?}\", list), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    assert_eq!(format!(\"{:?}\", list),\n+               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]"}, {"sha": "71416f2069fa0976d5042d11d9e67f0f110261be", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 172, "deletions": 192, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "patch": "@@ -13,9 +13,13 @@ use std::mem;\n use std::__rand::{Rng, thread_rng};\n use std::rc::Rc;\n \n-fn square(n: usize) -> usize { n * n }\n+fn square(n: usize) -> usize {\n+    n * n\n+}\n \n-fn is_odd(n: &usize) -> bool { *n % 2 == 1 }\n+fn is_odd(n: &usize) -> bool {\n+    *n % 2 == 1\n+}\n \n #[test]\n fn test_from_fn() {\n@@ -76,9 +80,9 @@ fn test_is_empty() {\n #[test]\n fn test_len_divzero() {\n     type Z = [i8; 0];\n-    let v0 : &[Z] = &[];\n-    let v1 : &[Z] = &[[]];\n-    let v2 : &[Z] = &[[], []];\n+    let v0: &[Z] = &[];\n+    let v1: &[Z] = &[[]];\n+    let v2: &[Z] = &[[], []];\n     assert_eq!(mem::size_of::<Z>(), 0);\n     assert_eq!(v0.len(), 0);\n     assert_eq!(v1.len(), 1);\n@@ -295,7 +299,7 @@ fn test_push() {\n \n #[test]\n fn test_truncate() {\n-    let mut v: Vec<Box<_>> = vec![box 6,box 5,box 4];\n+    let mut v: Vec<Box<_>> = vec![box 6, box 5, box 4];\n     v.truncate(1);\n     let v = v;\n     assert_eq!(v.len(), 1);\n@@ -305,7 +309,7 @@ fn test_truncate() {\n \n #[test]\n fn test_clear() {\n-    let mut v: Vec<Box<_>> = vec![box 6,box 5,box 4];\n+    let mut v: Vec<Box<_>> = vec![box 6, box 5, box 4];\n     v.clear();\n     assert_eq!(v.len(), 0);\n     // If the unsafe block didn't drop things properly, we blow up here.\n@@ -320,12 +324,12 @@ fn test_dedup() {\n     }\n     case(vec![], vec![]);\n     case(vec![1], vec![1]);\n-    case(vec![1,1], vec![1]);\n-    case(vec![1,2,3], vec![1,2,3]);\n-    case(vec![1,1,2,3], vec![1,2,3]);\n-    case(vec![1,2,2,3], vec![1,2,3]);\n-    case(vec![1,2,3,3], vec![1,2,3]);\n-    case(vec![1,1,2,2,2,3,3], vec![1,2,3]);\n+    case(vec![1, 1], vec![1]);\n+    case(vec![1, 2, 3], vec![1, 2, 3]);\n+    case(vec![1, 1, 2, 3], vec![1, 2, 3]);\n+    case(vec![1, 2, 2, 3], vec![1, 2, 3]);\n+    case(vec![1, 2, 3, 3], vec![1, 2, 3]);\n+    case(vec![1, 1, 2, 2, 2, 3, 3], vec![1, 2, 3]);\n }\n \n #[test]\n@@ -336,10 +340,8 @@ fn test_dedup_unique() {\n     v1.dedup();\n     let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n     v2.dedup();\n-    /*\n-     * If the boxed pointers were leaked or otherwise misused, valgrind\n-     * and/or rt should raise errors.\n-     */\n+    // If the boxed pointers were leaked or otherwise misused, valgrind\n+    // and/or rt should raise errors.\n }\n \n #[test]\n@@ -350,10 +352,8 @@ fn test_dedup_shared() {\n     v1.dedup();\n     let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n     v2.dedup();\n-    /*\n-     * If the pointers were leaked or otherwise misused, valgrind and/or\n-     * rt should raise errors.\n-     */\n+    // If the pointers were leaked or otherwise misused, valgrind and/or\n+    // rt should raise errors.\n }\n \n #[test]\n@@ -365,31 +365,31 @@ fn test_retain() {\n \n #[test]\n fn test_binary_search() {\n-    assert_eq!([1,2,3,4,5].binary_search(&5).ok(), Some(4));\n-    assert_eq!([1,2,3,4,5].binary_search(&4).ok(), Some(3));\n-    assert_eq!([1,2,3,4,5].binary_search(&3).ok(), Some(2));\n-    assert_eq!([1,2,3,4,5].binary_search(&2).ok(), Some(1));\n-    assert_eq!([1,2,3,4,5].binary_search(&1).ok(), Some(0));\n-\n-    assert_eq!([2,4,6,8,10].binary_search(&1).ok(), None);\n-    assert_eq!([2,4,6,8,10].binary_search(&5).ok(), None);\n-    assert_eq!([2,4,6,8,10].binary_search(&4).ok(), Some(1));\n-    assert_eq!([2,4,6,8,10].binary_search(&10).ok(), Some(4));\n-\n-    assert_eq!([2,4,6,8].binary_search(&1).ok(), None);\n-    assert_eq!([2,4,6,8].binary_search(&5).ok(), None);\n-    assert_eq!([2,4,6,8].binary_search(&4).ok(), Some(1));\n-    assert_eq!([2,4,6,8].binary_search(&8).ok(), Some(3));\n-\n-    assert_eq!([2,4,6].binary_search(&1).ok(), None);\n-    assert_eq!([2,4,6].binary_search(&5).ok(), None);\n-    assert_eq!([2,4,6].binary_search(&4).ok(), Some(1));\n-    assert_eq!([2,4,6].binary_search(&6).ok(), Some(2));\n-\n-    assert_eq!([2,4].binary_search(&1).ok(), None);\n-    assert_eq!([2,4].binary_search(&5).ok(), None);\n-    assert_eq!([2,4].binary_search(&2).ok(), Some(0));\n-    assert_eq!([2,4].binary_search(&4).ok(), Some(1));\n+    assert_eq!([1, 2, 3, 4, 5].binary_search(&5).ok(), Some(4));\n+    assert_eq!([1, 2, 3, 4, 5].binary_search(&4).ok(), Some(3));\n+    assert_eq!([1, 2, 3, 4, 5].binary_search(&3).ok(), Some(2));\n+    assert_eq!([1, 2, 3, 4, 5].binary_search(&2).ok(), Some(1));\n+    assert_eq!([1, 2, 3, 4, 5].binary_search(&1).ok(), Some(0));\n+\n+    assert_eq!([2, 4, 6, 8, 10].binary_search(&1).ok(), None);\n+    assert_eq!([2, 4, 6, 8, 10].binary_search(&5).ok(), None);\n+    assert_eq!([2, 4, 6, 8, 10].binary_search(&4).ok(), Some(1));\n+    assert_eq!([2, 4, 6, 8, 10].binary_search(&10).ok(), Some(4));\n+\n+    assert_eq!([2, 4, 6, 8].binary_search(&1).ok(), None);\n+    assert_eq!([2, 4, 6, 8].binary_search(&5).ok(), None);\n+    assert_eq!([2, 4, 6, 8].binary_search(&4).ok(), Some(1));\n+    assert_eq!([2, 4, 6, 8].binary_search(&8).ok(), Some(3));\n+\n+    assert_eq!([2, 4, 6].binary_search(&1).ok(), None);\n+    assert_eq!([2, 4, 6].binary_search(&5).ok(), None);\n+    assert_eq!([2, 4, 6].binary_search(&4).ok(), Some(1));\n+    assert_eq!([2, 4, 6].binary_search(&6).ok(), Some(2));\n+\n+    assert_eq!([2, 4].binary_search(&1).ok(), None);\n+    assert_eq!([2, 4].binary_search(&5).ok(), None);\n+    assert_eq!([2, 4].binary_search(&2).ok(), Some(0));\n+    assert_eq!([2, 4].binary_search(&4).ok(), Some(1));\n \n     assert_eq!([2].binary_search(&1).ok(), None);\n     assert_eq!([2].binary_search(&5).ok(), None);\n@@ -398,14 +398,14 @@ fn test_binary_search() {\n     assert_eq!([].binary_search(&1).ok(), None);\n     assert_eq!([].binary_search(&5).ok(), None);\n \n-    assert!([1,1,1,1,1].binary_search(&1).ok() != None);\n-    assert!([1,1,1,1,2].binary_search(&1).ok() != None);\n-    assert!([1,1,1,2,2].binary_search(&1).ok() != None);\n-    assert!([1,1,2,2,2].binary_search(&1).ok() != None);\n-    assert_eq!([1,2,2,2,2].binary_search(&1).ok(), Some(0));\n+    assert!([1, 1, 1, 1, 1].binary_search(&1).ok() != None);\n+    assert!([1, 1, 1, 1, 2].binary_search(&1).ok() != None);\n+    assert!([1, 1, 1, 2, 2].binary_search(&1).ok() != None);\n+    assert!([1, 1, 2, 2, 2].binary_search(&1).ok() != None);\n+    assert_eq!([1, 2, 2, 2, 2].binary_search(&1).ok(), Some(0));\n \n-    assert_eq!([1,2,3,4,5].binary_search(&6).ok(), None);\n-    assert_eq!([1,2,3,4,5].binary_search(&0).ok(), None);\n+    assert_eq!([1, 2, 3, 4, 5].binary_search(&6).ok(), None);\n+    assert_eq!([1, 2, 3, 4, 5].binary_search(&0).ok(), None);\n }\n \n #[test]\n@@ -460,15 +460,17 @@ fn test_sort_stability() {\n             // the second item represents which occurrence of that\n             // number this element is, i.e. the second elements\n             // will occur in sorted order.\n-            let mut v: Vec<_> = (0..len).map(|_| {\n-                    let n = thread_rng().gen::<usize>() % 10;\n-                    counts[n] += 1;\n-                    (n, counts[n])\n-                }).collect();\n+            let mut v: Vec<_> = (0..len)\n+                                    .map(|_| {\n+                                        let n = thread_rng().gen::<usize>() % 10;\n+                                        counts[n] += 1;\n+                                        (n, counts[n])\n+                                    })\n+                                    .collect();\n \n             // only sort on the first element, so an unstable sort\n             // may mix up the counts.\n-            v.sort_by(|&(a,_), &(b,_)| a.cmp(&b));\n+            v.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n             // this comparison includes the count (the second item\n             // of the tuple), so elements with equal first items\n@@ -679,43 +681,40 @@ fn test_rev_iterator() {\n #[test]\n fn test_mut_rev_iterator() {\n     let mut xs = [1, 2, 3, 4, 5];\n-    for (i,x) in xs.iter_mut().rev().enumerate() {\n+    for (i, x) in xs.iter_mut().rev().enumerate() {\n         *x += i;\n     }\n     assert!(xs == [5, 5, 5, 5, 5])\n }\n \n #[test]\n fn test_move_iterator() {\n-    let xs = vec![1,2,3,4,5];\n-    assert_eq!(xs.into_iter().fold(0, |a: usize, b: usize| 10*a + b), 12345);\n+    let xs = vec![1, 2, 3, 4, 5];\n+    assert_eq!(xs.into_iter().fold(0, |a: usize, b: usize| 10 * a + b),\n+               12345);\n }\n \n #[test]\n fn test_move_rev_iterator() {\n-    let xs = vec![1,2,3,4,5];\n-    assert_eq!(xs.into_iter().rev().fold(0, |a: usize, b: usize| 10*a + b), 54321);\n+    let xs = vec![1, 2, 3, 4, 5];\n+    assert_eq!(xs.into_iter().rev().fold(0, |a: usize, b: usize| 10 * a + b),\n+               54321);\n }\n \n #[test]\n fn test_splitator() {\n-    let xs = &[1,2,3,4,5];\n+    let xs = &[1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[1], &[3], &[5]];\n-    assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[], &[2,3,4,5]];\n-    assert_eq!(xs.split(|x| *x == 1).collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[1,2,3,4], &[]];\n-    assert_eq!(xs.split(|x| *x == 5).collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-    assert_eq!(xs.split(|x| *x == 10).collect::<Vec<_>>(),\n-               splits);\n+    assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[], &[2, 3, 4, 5]];\n+    assert_eq!(xs.split(|x| *x == 1).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4], &[]];\n+    assert_eq!(xs.split(|x| *x == 5).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split(|x| *x == 10).collect::<Vec<_>>(), splits);\n     let splits: &[&[_]] = &[&[], &[], &[], &[], &[], &[]];\n-    assert_eq!(xs.split(|_| true).collect::<Vec<&[i32]>>(),\n-               splits);\n+    assert_eq!(xs.split(|_| true).collect::<Vec<&[i32]>>(), splits);\n \n     let xs: &[i32] = &[];\n     let splits: &[&[i32]] = &[&[]];\n@@ -724,17 +723,14 @@ fn test_splitator() {\n \n #[test]\n fn test_splitnator() {\n-    let xs = &[1,2,3,4,5];\n+    let xs = &[1, 2, 3, 4, 5];\n \n-    let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-    assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[1], &[3,4,5]];\n-    assert_eq!(xs.splitn(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[], &[], &[], &[4,5]];\n-    assert_eq!(xs.splitn(4, |_| true).collect::<Vec<_>>(),\n-               splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[3, 4, 5]];\n+    assert_eq!(xs.splitn(2, |x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[], &[], &[], &[4, 5]];\n+    assert_eq!(xs.splitn(4, |_| true).collect::<Vec<_>>(), splits);\n \n     let xs: &[i32] = &[];\n     let splits: &[&[i32]] = &[&[]];\n@@ -743,40 +739,34 @@ fn test_splitnator() {\n \n #[test]\n fn test_splitnator_mut() {\n-    let xs = &mut [1,2,3,4,5];\n+    let xs = &mut [1, 2, 3, 4, 5];\n \n-    let splits: &[&mut[_]] = &[&mut [1,2,3,4,5]];\n+    let splits: &[&mut [_]] = &[&mut [1, 2, 3, 4, 5]];\n     assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n-    let splits: &[&mut[_]] = &[&mut [1], &mut [3,4,5]];\n+    let splits: &[&mut [_]] = &[&mut [1], &mut [3, 4, 5]];\n     assert_eq!(xs.splitn_mut(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n-    let splits: &[&mut[_]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n-    assert_eq!(xs.splitn_mut(4, |_| true).collect::<Vec<_>>(),\n-               splits);\n+    let splits: &[&mut [_]] = &[&mut [], &mut [], &mut [], &mut [4, 5]];\n+    assert_eq!(xs.splitn_mut(4, |_| true).collect::<Vec<_>>(), splits);\n \n     let xs: &mut [i32] = &mut [];\n-    let splits: &[&mut[i32]] = &[&mut []];\n-    assert_eq!(xs.splitn_mut(2, |x| *x == 5).collect::<Vec<_>>(),\n-               splits);\n+    let splits: &[&mut [i32]] = &[&mut []];\n+    assert_eq!(xs.splitn_mut(2, |x| *x == 5).collect::<Vec<_>>(), splits);\n }\n \n #[test]\n fn test_rsplitator() {\n-    let xs = &[1,2,3,4,5];\n+    let xs = &[1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[5], &[3], &[1]];\n-    assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[2,3,4,5], &[]];\n-    assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[], &[1,2,3,4]];\n-    assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-    assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<_>>(),\n-               splits);\n+    assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[2, 3, 4, 5], &[]];\n+    assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[], &[1, 2, 3, 4]];\n+    assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<_>>(), splits);\n \n     let xs: &[i32] = &[];\n     let splits: &[&[i32]] = &[&[]];\n@@ -785,75 +775,72 @@ fn test_rsplitator() {\n \n #[test]\n fn test_rsplitnator() {\n-    let xs = &[1,2,3,4,5];\n+    let xs = &[1, 2, 3, 4, 5];\n \n-    let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-    assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[5], &[1,2,3]];\n-    assert_eq!(xs.rsplitn(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n-               splits);\n-    let splits: &[&[_]] = &[&[], &[], &[], &[1,2]];\n-    assert_eq!(xs.rsplitn(4, |_| true).collect::<Vec<_>>(),\n-               splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[5], &[1, 2, 3]];\n+    assert_eq!(xs.rsplitn(2, |x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[], &[], &[], &[1, 2]];\n+    assert_eq!(xs.rsplitn(4, |_| true).collect::<Vec<_>>(), splits);\n \n-    let xs: &[i32]  = &[];\n+    let xs: &[i32] = &[];\n     let splits: &[&[i32]] = &[&[]];\n     assert_eq!(xs.rsplitn(2, |x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n     assert!(xs.rsplitn(0, |x| *x % 2 == 0).next().is_none());\n }\n \n #[test]\n fn test_windowsator() {\n-    let v = &[1,2,3,4];\n+    let v = &[1, 2, 3, 4];\n \n-    let wins: &[&[_]] = &[&[1,2], &[2,3], &[3,4]];\n+    let wins: &[&[_]] = &[&[1, 2], &[2, 3], &[3, 4]];\n     assert_eq!(v.windows(2).collect::<Vec<_>>(), wins);\n \n-    let wins: &[&[_]] = &[&[1,2,3], &[2,3,4]];\n+    let wins: &[&[_]] = &[&[1, 2, 3], &[2, 3, 4]];\n     assert_eq!(v.windows(3).collect::<Vec<_>>(), wins);\n     assert!(v.windows(6).next().is_none());\n \n-    let wins: &[&[_]] = &[&[3,4], &[2,3], &[1,2]];\n+    let wins: &[&[_]] = &[&[3, 4], &[2, 3], &[1, 2]];\n     assert_eq!(v.windows(2).rev().collect::<Vec<&[_]>>(), wins);\n }\n \n #[test]\n #[should_panic]\n fn test_windowsator_0() {\n-    let v = &[1,2,3,4];\n+    let v = &[1, 2, 3, 4];\n     let _it = v.windows(0);\n }\n \n #[test]\n fn test_chunksator() {\n-    let v = &[1,2,3,4,5];\n+    let v = &[1, 2, 3, 4, 5];\n \n     assert_eq!(v.chunks(2).len(), 3);\n \n-    let chunks: &[&[_]] = &[&[1,2], &[3,4], &[5]];\n+    let chunks: &[&[_]] = &[&[1, 2], &[3, 4], &[5]];\n     assert_eq!(v.chunks(2).collect::<Vec<_>>(), chunks);\n-    let chunks: &[&[_]] = &[&[1,2,3], &[4,5]];\n+    let chunks: &[&[_]] = &[&[1, 2, 3], &[4, 5]];\n     assert_eq!(v.chunks(3).collect::<Vec<_>>(), chunks);\n-    let chunks: &[&[_]] = &[&[1,2,3,4,5]];\n+    let chunks: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n     assert_eq!(v.chunks(6).collect::<Vec<_>>(), chunks);\n \n-    let chunks: &[&[_]] = &[&[5], &[3,4], &[1,2]];\n+    let chunks: &[&[_]] = &[&[5], &[3, 4], &[1, 2]];\n     assert_eq!(v.chunks(2).rev().collect::<Vec<_>>(), chunks);\n }\n \n #[test]\n #[should_panic]\n fn test_chunksator_0() {\n-    let v = &[1,2,3,4];\n+    let v = &[1, 2, 3, 4];\n     let _it = v.chunks(0);\n }\n \n #[test]\n fn test_reverse_part() {\n-    let mut values = [1,2,3,4,5];\n+    let mut values = [1, 2, 3, 4, 5];\n     values[1..4].reverse();\n-    assert!(values == [1,4,3,2,5]);\n+    assert!(values == [1, 4, 3, 2, 5]);\n }\n \n #[test]\n@@ -869,16 +856,15 @@ fn test_show() {\n     test_show_vec!(empty, \"[]\");\n     test_show_vec!(vec![1], \"[1]\");\n     test_show_vec!(vec![1, 2, 3], \"[1, 2, 3]\");\n-    test_show_vec!(vec![vec![], vec![1], vec![1, 1]],\n-                   \"[[], [1], [1, 1]]\");\n+    test_show_vec!(vec![vec![], vec![1], vec![1, 1]], \"[[], [1], [1, 1]]\");\n \n-    let empty_mut: &mut [i32] = &mut[];\n+    let empty_mut: &mut [i32] = &mut [];\n     test_show_vec!(empty_mut, \"[]\");\n-    let v = &mut[1];\n+    let v = &mut [1];\n     test_show_vec!(v, \"[1]\");\n-    let v = &mut[1, 2, 3];\n+    let v = &mut [1, 2, 3];\n     test_show_vec!(v, \"[1, 2, 3]\");\n-    let v: &mut[&mut[_]] = &mut[&mut[], &mut[1], &mut[1, 1]];\n+    let v: &mut [&mut [_]] = &mut [&mut [], &mut [1], &mut [1, 1]];\n     test_show_vec!(v, \"[[], [1], [1, 1]]\");\n }\n \n@@ -914,7 +900,7 @@ fn test_overflow_does_not_cause_segfault_managed() {\n \n #[test]\n fn test_mut_split_at() {\n-    let mut values = [1,2,3,4,5];\n+    let mut values = [1, 2, 3, 4, 5];\n     {\n         let (left, right) = values.split_at_mut(2);\n         {\n@@ -1021,32 +1007,32 @@ fn test_ends_with() {\n \n #[test]\n fn test_mut_splitator() {\n-    let mut xs = [0,1,0,2,3,0,0,4,5,0];\n+    let mut xs = [0, 1, 0, 2, 3, 0, 0, 4, 5, 0];\n     assert_eq!(xs.split_mut(|x| *x == 0).count(), 6);\n     for slice in xs.split_mut(|x| *x == 0) {\n         slice.reverse();\n     }\n-    assert!(xs == [0,1,0,3,2,0,0,5,4,0]);\n+    assert!(xs == [0, 1, 0, 3, 2, 0, 0, 5, 4, 0]);\n \n-    let mut xs = [0,1,0,2,3,0,0,4,5,0,6,7];\n+    let mut xs = [0, 1, 0, 2, 3, 0, 0, 4, 5, 0, 6, 7];\n     for slice in xs.split_mut(|x| *x == 0).take(5) {\n         slice.reverse();\n     }\n-    assert!(xs == [0,1,0,3,2,0,0,5,4,0,6,7]);\n+    assert!(xs == [0, 1, 0, 3, 2, 0, 0, 5, 4, 0, 6, 7]);\n }\n \n #[test]\n fn test_mut_splitator_rev() {\n-    let mut xs = [1,2,0,3,4,0,0,5,6,0];\n+    let mut xs = [1, 2, 0, 3, 4, 0, 0, 5, 6, 0];\n     for slice in xs.split_mut(|x| *x == 0).rev().take(4) {\n         slice.reverse();\n     }\n-    assert!(xs == [1,2,0,4,3,0,0,6,5,0]);\n+    assert!(xs == [1, 2, 0, 4, 3, 0, 0, 6, 5, 0]);\n }\n \n #[test]\n fn test_get_mut() {\n-    let mut v = [0,1,2];\n+    let mut v = [0, 1, 2];\n     assert_eq!(v.get_mut(3), None);\n     v.get_mut(1).map(|e| *e = 7);\n     assert_eq!(v[1], 7);\n@@ -1119,7 +1105,7 @@ fn test_box_slice_clone_panics() {\n \n     struct Canary {\n         count: Arc<AtomicUsize>,\n-        panics: bool\n+        panics: bool,\n     }\n \n     impl Drop for Canary {\n@@ -1130,27 +1116,37 @@ fn test_box_slice_clone_panics() {\n \n     impl Clone for Canary {\n         fn clone(&self) -> Self {\n-            if self.panics { panic!() }\n+            if self.panics {\n+                panic!()\n+            }\n \n             Canary {\n                 count: self.count.clone(),\n-                panics: self.panics\n+                panics: self.panics,\n             }\n         }\n     }\n \n     let drop_count = Arc::new(AtomicUsize::new(0));\n-    let canary = Canary { count: drop_count.clone(), panics: false };\n-    let panic = Canary { count: drop_count.clone(), panics: true };\n+    let canary = Canary {\n+        count: drop_count.clone(),\n+        panics: false,\n+    };\n+    let panic = Canary {\n+        count: drop_count.clone(),\n+        panics: true,\n+    };\n \n     spawn(move || {\n         // When xs is dropped, +5.\n-        let xs = vec![canary.clone(), canary.clone(), canary.clone(),\n-                      panic, canary].into_boxed_slice();\n+        let xs = vec![canary.clone(), canary.clone(), canary.clone(), panic, canary]\n+                     .into_boxed_slice();\n \n         // When panic is cloned, +3.\n         xs.clone();\n-    }).join().unwrap_err();\n+    })\n+        .join()\n+        .unwrap_err();\n \n     // Total = 8\n     assert_eq!(drop_count.load(Ordering::SeqCst), 8);\n@@ -1198,7 +1194,9 @@ mod bench {\n                 sum += *x;\n             }\n             // sum == 11806, to stop dead code elimination.\n-            if sum == 0 {panic!()}\n+            if sum == 0 {\n+                panic!()\n+            }\n         })\n     }\n \n@@ -1217,20 +1215,16 @@ mod bench {\n \n     #[bench]\n     fn concat(b: &mut Bencher) {\n-        let xss: Vec<Vec<i32>> =\n-            (0..100).map(|i| (0..i).collect()).collect();\n+        let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n             xss.concat();\n         });\n     }\n \n     #[bench]\n     fn join(b: &mut Bencher) {\n-        let xss: Vec<Vec<i32>> =\n-            (0..100).map(|i| (0..i).collect()).collect();\n-        b.iter(|| {\n-            xss.join(&0)\n-        });\n+        let xss: Vec<Vec<i32>> = (0..100).map(|i| (0..i).collect()).collect();\n+        b.iter(|| xss.join(&0));\n     }\n \n     #[bench]\n@@ -1245,68 +1239,52 @@ mod bench {\n     #[bench]\n     fn starts_with_same_vector(b: &mut Bencher) {\n         let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| {\n-            vec.starts_with(&vec)\n-        })\n+        b.iter(|| vec.starts_with(&vec))\n     }\n \n     #[bench]\n     fn starts_with_single_element(b: &mut Bencher) {\n         let vec: Vec<_> = vec![0];\n-        b.iter(|| {\n-            vec.starts_with(&vec)\n-        })\n+        b.iter(|| vec.starts_with(&vec))\n     }\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n         let vec: Vec<_> = (0..100).collect();\n         let mut match_vec: Vec<_> = (0..99).collect();\n         match_vec.push(0);\n-        b.iter(|| {\n-            vec.starts_with(&match_vec)\n-        })\n+        b.iter(|| vec.starts_with(&match_vec))\n     }\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n         let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| {\n-            vec.ends_with(&vec)\n-        })\n+        b.iter(|| vec.ends_with(&vec))\n     }\n \n     #[bench]\n     fn ends_with_single_element(b: &mut Bencher) {\n         let vec: Vec<_> = vec![0];\n-        b.iter(|| {\n-            vec.ends_with(&vec)\n-        })\n+        b.iter(|| vec.ends_with(&vec))\n     }\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n         let vec: Vec<_> = (0..100).collect();\n         let mut match_vec: Vec<_> = (0..100).collect();\n         match_vec[0] = 200;\n-        b.iter(|| {\n-            vec.starts_with(&match_vec)\n-        })\n+        b.iter(|| vec.starts_with(&match_vec))\n     }\n \n     #[bench]\n     fn contains_last_element(b: &mut Bencher) {\n         let vec: Vec<_> = (0..100).collect();\n-        b.iter(|| {\n-            vec.contains(&99)\n-        })\n+        b.iter(|| vec.contains(&99))\n     }\n \n     #[bench]\n     fn zero_1kb_from_elem(b: &mut Bencher) {\n-        b.iter(|| {\n-            vec![0u8; 1024]\n-        });\n+        b.iter(|| vec![0u8; 1024]);\n     }\n \n     #[bench]\n@@ -1356,8 +1334,7 @@ mod bench {\n             let mut v = vec![(0, 0); 30];\n             for _ in 0..100 {\n                 let l = v.len();\n-                v.insert(rng.gen::<usize>() % (l + 1),\n-                         (1, 1));\n+                v.insert(rng.gen::<usize>() % (l + 1), (1, 1));\n             }\n         })\n     }\n@@ -1418,7 +1395,8 @@ mod bench {\n     fn sort_big_random_small(b: &mut Bencher) {\n         let mut rng = thread_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>().take(5)\n+            let mut v = rng.gen_iter::<BigSortable>()\n+                           .take(5)\n                            .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n@@ -1429,7 +1407,8 @@ mod bench {\n     fn sort_big_random_medium(b: &mut Bencher) {\n         let mut rng = thread_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>().take(100)\n+            let mut v = rng.gen_iter::<BigSortable>()\n+                           .take(100)\n                            .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n@@ -1440,7 +1419,8 @@ mod bench {\n     fn sort_big_random_large(b: &mut Bencher) {\n         let mut rng = thread_rng();\n         b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>().take(10000)\n+            let mut v = rng.gen_iter::<BigSortable>()\n+                           .take(10000)\n                            .collect::<Vec<BigSortable>>();\n             v.sort();\n         });"}, {"sha": "7f0fd282ae5e943f32b7f281a7c2f9137f2f50d7", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 51, "deletions": 66, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "patch": "@@ -31,8 +31,8 @@ impl<'a> IntoCow<'a, str> for &'a str {\n \n #[test]\n fn test_from_str() {\n-  let owned: Option<::std::string::String> = \"string\".parse().ok();\n-  assert_eq!(owned.as_ref().map(|s| &**s), Some(\"string\"));\n+    let owned: Option<::std::string::String> = \"string\".parse().ok();\n+    assert_eq!(owned.as_ref().map(|s| &**s), Some(\"string\"));\n }\n \n #[test]\n@@ -44,8 +44,7 @@ fn test_unsized_to_string() {\n #[test]\n fn test_from_utf8() {\n     let xs = b\"hello\".to_vec();\n-    assert_eq!(String::from_utf8(xs).unwrap(),\n-               String::from(\"hello\"));\n+    assert_eq!(String::from_utf8(xs).unwrap(), String::from(\"hello\"));\n \n     let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes().to_vec();\n     assert_eq!(String::from_utf8(xs).unwrap(),\n@@ -87,56 +86,40 @@ fn test_from_utf8_lossy() {\n                String::from(\"\\u{FFFD}foo\\u{FFFD}bar\\u{FFFD}\\u{FFFD}baz\").into_cow());\n \n     let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n-    assert_eq!(String::from_utf8_lossy(xs), String::from(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}\\u{FFFD}\\\n-                                           foo\\u{10000}bar\").into_cow());\n+    assert_eq!(String::from_utf8_lossy(xs),\n+               String::from(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\u{10000}bar\").into_cow());\n \n     // surrogates\n     let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n-    assert_eq!(String::from_utf8_lossy(xs), String::from(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\\n-                                           \\u{FFFD}\\u{FFFD}\\u{FFFD}bar\").into_cow());\n+    assert_eq!(String::from_utf8_lossy(xs),\n+               String::from(\"\\u{FFFD}\\u{FFFD}\\u{FFFD}foo\\u{FFFD}\\u{FFFD}\\u{FFFD}bar\").into_cow());\n }\n \n #[test]\n fn test_from_utf16() {\n-    let pairs =\n-        [(String::from(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n-          vec![0xd800, 0xdf45, 0xd800, 0xdf3f,\n-            0xd800, 0xdf3b, 0xd800, 0xdf46,\n-            0xd800, 0xdf39, 0xd800, 0xdf3b,\n-            0xd800, 0xdf30, 0x000a]),\n-\n-         (String::from(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n-          vec![0xd801, 0xdc12, 0xd801,\n-            0xdc49, 0xd801, 0xdc2e, 0xd801,\n-            0xdc40, 0xd801, 0xdc32, 0xd801,\n-            0xdc4b, 0x0020, 0xd801, 0xdc0f,\n-            0xd801, 0xdc32, 0xd801, 0xdc4d,\n-            0x000a]),\n-\n-         (String::from(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n-          vec![0xd800, 0xdf00, 0xd800, 0xdf16,\n-            0xd800, 0xdf0b, 0xd800, 0xdf04,\n-            0xd800, 0xdf11, 0xd800, 0xdf09,\n-            0x00b7, 0xd800, 0xdf0c, 0xd800,\n-            0xdf04, 0xd800, 0xdf15, 0xd800,\n-            0xdf04, 0xd800, 0xdf0b, 0xd800,\n-            0xdf09, 0xd800, 0xdf11, 0x000a ]),\n-\n-         (String::from(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n-          vec![0xd801, 0xdc8b, 0xd801, 0xdc98,\n-            0xd801, 0xdc88, 0xd801, 0xdc91,\n-            0xd801, 0xdc9b, 0xd801, 0xdc92,\n-            0x0020, 0xd801, 0xdc95, 0xd801,\n-            0xdc93, 0x0020, 0xd801, 0xdc88,\n-            0xd801, 0xdc9a, 0xd801, 0xdc8d,\n-            0x0020, 0xd801, 0xdc8f, 0xd801,\n-            0xdc9c, 0xd801, 0xdc92, 0xd801,\n-            0xdc96, 0xd801, 0xdc86, 0x0020,\n-            0xd801, 0xdc95, 0xd801, 0xdc86,\n-            0x000a ]),\n-         // Issue #12318, even-numbered non-BMP planes\n-         (String::from(\"\\u{20000}\"),\n-          vec![0xD840, 0xDC00])];\n+    let pairs = [(String::from(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\"),\n+                  vec![0xd800, 0xdf45, 0xd800, 0xdf3f, 0xd800, 0xdf3b, 0xd800, 0xdf46, 0xd800,\n+                       0xdf39, 0xd800, 0xdf3b, 0xd800, 0xdf30, 0x000a]),\n+\n+                 (String::from(\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\"),\n+                  vec![0xd801, 0xdc12, 0xd801, 0xdc49, 0xd801, 0xdc2e, 0xd801, 0xdc40, 0xd801,\n+                       0xdc32, 0xd801, 0xdc4b, 0x0020, 0xd801, 0xdc0f, 0xd801, 0xdc32, 0xd801,\n+                       0xdc4d, 0x000a]),\n+\n+                 (String::from(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\"),\n+                  vec![0xd800, 0xdf00, 0xd800, 0xdf16, 0xd800, 0xdf0b, 0xd800, 0xdf04, 0xd800,\n+                       0xdf11, 0xd800, 0xdf09, 0x00b7, 0xd800, 0xdf0c, 0xd800, 0xdf04, 0xd800,\n+                       0xdf15, 0xd800, 0xdf04, 0xd800, 0xdf0b, 0xd800, 0xdf09, 0xd800, 0xdf11,\n+                       0x000a]),\n+\n+                 (String::from(\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\"),\n+                  vec![0xd801, 0xdc8b, 0xd801, 0xdc98, 0xd801, 0xdc88, 0xd801, 0xdc91, 0xd801,\n+                       0xdc9b, 0xd801, 0xdc92, 0x0020, 0xd801, 0xdc95, 0xd801, 0xdc93, 0x0020,\n+                       0xd801, 0xdc88, 0xd801, 0xdc9a, 0xd801, 0xdc8d, 0x0020, 0xd801, 0xdc8f,\n+                       0xd801, 0xdc9c, 0xd801, 0xdc92, 0xd801, 0xdc96, 0xd801, 0xdc86, 0x0020,\n+                       0xd801, 0xdc95, 0xd801, 0xdc86, 0x000a]),\n+                 // Issue #12318, even-numbered non-BMP planes\n+                 (String::from(\"\\u{20000}\"), vec![0xD840, 0xDC00])];\n \n     for p in &pairs {\n         let (s, u) = (*p).clone();\n@@ -173,13 +156,15 @@ fn test_utf16_invalid() {\n fn test_from_utf16_lossy() {\n     // completely positive cases tested above.\n     // lead + eof\n-    assert_eq!(String::from_utf16_lossy(&[0xD800]), String::from(\"\\u{FFFD}\"));\n+    assert_eq!(String::from_utf16_lossy(&[0xD800]),\n+               String::from(\"\\u{FFFD}\"));\n     // lead + lead\n     assert_eq!(String::from_utf16_lossy(&[0xD800, 0xD800]),\n                String::from(\"\\u{FFFD}\\u{FFFD}\"));\n \n     // isolated trail\n-    assert_eq!(String::from_utf16_lossy(&[0x0061, 0xDC00]), String::from(\"a\\u{FFFD}\"));\n+    assert_eq!(String::from_utf16_lossy(&[0x0061, 0xDC00]),\n+               String::from(\"a\\u{FFFD}\"));\n \n     // general\n     assert_eq!(String::from_utf16_lossy(&[0xD800, 0xd801, 0xdc8b, 0xD800]),\n@@ -288,7 +273,8 @@ fn remove() {\n     assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n }\n \n-#[test] #[should_panic]\n+#[test]\n+#[should_panic]\n fn remove_bad() {\n     \"\u0e28\".to_string().remove(1);\n }\n@@ -302,8 +288,16 @@ fn insert() {\n     assert_eq!(s, \"\u1ec7foo\u0e22bar\");\n }\n \n-#[test] #[should_panic] fn insert_bad1() { \"\".to_string().insert(1, 't'); }\n-#[test] #[should_panic] fn insert_bad2() { \"\u1ec7\".to_string().insert(1, 't'); }\n+#[test]\n+#[should_panic]\n+fn insert_bad1() {\n+    \"\".to_string().insert(1, 't');\n+}\n+#[test]\n+#[should_panic]\n+fn insert_bad2() {\n+    \"\u1ec7\".to_string().insert(1, 't');\n+}\n \n #[test]\n fn test_slicing() {\n@@ -331,8 +325,7 @@ fn test_vectors() {\n     assert_eq!(format!(\"{:?}\", x), \"[]\");\n     assert_eq!(format!(\"{:?}\", vec![1]), \"[1]\");\n     assert_eq!(format!(\"{:?}\", vec![1, 2, 3]), \"[1, 2, 3]\");\n-    assert!(format!(\"{:?}\", vec![vec![], vec![1], vec![1, 1]]) ==\n-           \"[[], [1], [1, 1]]\");\n+    assert!(format!(\"{:?}\", vec![vec![], vec![1], vec![1, 1]]) == \"[[], [1], [1, 1]]\");\n }\n \n #[test]\n@@ -390,9 +383,7 @@ fn test_into_boxed_str() {\n \n #[bench]\n fn bench_with_capacity(b: &mut Bencher) {\n-    b.iter(|| {\n-        String::with_capacity(100)\n-    });\n+    b.iter(|| String::with_capacity(100));\n }\n \n #[bench]\n@@ -495,25 +486,19 @@ fn bench_exact_size_shrink_to_fit(b: &mut Bencher) {\n fn bench_from_str(b: &mut Bencher) {\n     let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n              Lorem ipsum dolor sit amet, consectetur. \";\n-    b.iter(|| {\n-        String::from(s)\n-    })\n+    b.iter(|| String::from(s))\n }\n \n #[bench]\n fn bench_from(b: &mut Bencher) {\n     let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n              Lorem ipsum dolor sit amet, consectetur. \";\n-    b.iter(|| {\n-        String::from(s)\n-    })\n+    b.iter(|| String::from(s))\n }\n \n #[bench]\n fn bench_to_string(b: &mut Bencher) {\n     let s = \"Hello there, the quick brown fox jumped over the lazy dog! \\\n              Lorem ipsum dolor sit amet, consectetur. \";\n-    b.iter(|| {\n-        s.to_string()\n-    })\n+    b.iter(|| s.to_string())\n }"}, {"sha": "cb99659cc0ead7238fd30d75d49cdef095aea976", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "patch": "@@ -15,7 +15,7 @@ use std::mem::size_of;\n use test::Bencher;\n \n struct DropCounter<'a> {\n-    count: &'a mut u32\n+    count: &'a mut u32,\n }\n \n impl<'a> Drop for DropCounter<'a> {\n@@ -33,17 +33,17 @@ fn test_small_vec_struct() {\n fn test_double_drop() {\n     struct TwoVec<T> {\n         x: Vec<T>,\n-        y: Vec<T>\n+        y: Vec<T>,\n     }\n \n     let (mut count_x, mut count_y) = (0, 0);\n     {\n         let mut tv = TwoVec {\n             x: Vec::new(),\n-            y: Vec::new()\n+            y: Vec::new(),\n         };\n-        tv.x.push(DropCounter {count: &mut count_x});\n-        tv.y.push(DropCounter {count: &mut count_y});\n+        tv.x.push(DropCounter { count: &mut count_x });\n+        tv.y.push(DropCounter { count: &mut count_y });\n \n         // If Vec had a drop flag, here is where it would be zeroed.\n         // Instead, it should rely on its internal state to prevent\n@@ -85,12 +85,16 @@ fn test_extend() {\n     let mut w = Vec::new();\n \n     v.extend(0..3);\n-    for i in 0..3 { w.push(i) }\n+    for i in 0..3 {\n+        w.push(i)\n+    }\n \n     assert_eq!(v, w);\n \n     v.extend(3..10);\n-    for i in 3..10 { w.push(i) }\n+    for i in 3..10 {\n+        w.push(i)\n+    }\n \n     assert_eq!(v, w);\n \n@@ -117,7 +121,7 @@ fn test_extend_ref() {\n fn test_slice_from_mut() {\n     let mut values = vec![1, 2, 3, 4, 5];\n     {\n-        let slice = &mut values[2 ..];\n+        let slice = &mut values[2..];\n         assert!(slice == [3, 4, 5]);\n         for p in slice {\n             *p += 2;\n@@ -131,7 +135,7 @@ fn test_slice_from_mut() {\n fn test_slice_to_mut() {\n     let mut values = vec![1, 2, 3, 4, 5];\n     {\n-        let slice = &mut values[.. 2];\n+        let slice = &mut values[..2];\n         assert!(slice == [1, 2]);\n         for p in slice {\n             *p += 1;\n@@ -169,7 +173,7 @@ fn test_split_at_mut() {\n #[test]\n fn test_clone() {\n     let v: Vec<i32> = vec![];\n-    let w = vec!(1, 2, 3);\n+    let w = vec![1, 2, 3];\n \n     assert_eq!(v, v.clone());\n \n@@ -181,9 +185,9 @@ fn test_clone() {\n \n #[test]\n fn test_clone_from() {\n-    let mut v = vec!();\n-    let three: Vec<Box<_>> = vec!(box 1, box 2, box 3);\n-    let two: Vec<Box<_>> = vec!(box 4, box 5);\n+    let mut v = vec![];\n+    let three: Vec<Box<_>> = vec![box 1, box 2, box 3];\n+    let two: Vec<Box<_>> = vec![box 4, box 5];\n     // zero, long\n     v.clone_from(&three);\n     assert_eq!(v, three);\n@@ -235,16 +239,22 @@ fn zero_sized_values() {\n     assert_eq!(v.iter_mut().count(), 4);\n \n     for &mut () in &mut v {}\n-    unsafe { v.set_len(0); }\n+    unsafe {\n+        v.set_len(0);\n+    }\n     assert_eq!(v.iter_mut().count(), 0);\n }\n \n #[test]\n fn test_partition() {\n-    assert_eq!(vec![].into_iter().partition(|x: &i32| *x < 3), (vec![], vec![]));\n-    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 4), (vec![1, 2, 3], vec![]));\n-    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 2), (vec![1], vec![2, 3]));\n-    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 0), (vec![], vec![1, 2, 3]));\n+    assert_eq!(vec![].into_iter().partition(|x: &i32| *x < 3),\n+               (vec![], vec![]));\n+    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 4),\n+               (vec![1, 2, 3], vec![]));\n+    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 2),\n+               (vec![1], vec![2, 3]));\n+    assert_eq!(vec![1, 2, 3].into_iter().partition(|x| *x < 0),\n+               (vec![], vec![1, 2, 3]));\n }\n \n #[test]\n@@ -264,7 +274,9 @@ fn test_vec_truncate_drop() {\n     struct Elem(i32);\n     impl Drop for Elem {\n         fn drop(&mut self) {\n-            unsafe { drops += 1; }\n+            unsafe {\n+                drops += 1;\n+            }\n         }\n     }\n \n@@ -344,7 +356,7 @@ fn test_slice_out_of_bounds_5() {\n #[test]\n #[should_panic]\n fn test_swap_remove_empty() {\n-    let mut vec= Vec::<i32>::new();\n+    let mut vec = Vec::<i32>::new();\n     vec.swap_remove(0);\n }\n \n@@ -386,7 +398,7 @@ fn test_drain_items() {\n         vec2.push(i);\n     }\n     assert_eq!(vec, []);\n-    assert_eq!(vec2, [ 1, 2, 3 ]);\n+    assert_eq!(vec2, [1, 2, 3]);\n }\n \n #[test]\n@@ -472,7 +484,7 @@ fn test_into_iter_count() {\n \n #[test]\n fn test_into_iter_clone() {\n-    fn iter_equal<I: Iterator<Item=i32>>(it: I, slice: &[i32]) {\n+    fn iter_equal<I: Iterator<Item = i32>>(it: I, slice: &[i32]) {\n         let v: Vec<i32> = it.collect();\n         assert_eq!(&v[..], slice);\n     }"}, {"sha": "a02666a50c2258e20bb1b8bc3f589fe91a4a3122", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 78, "deletions": 51, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b6261cc41343b1f2b611ca12f1ccd2d4306ee5/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=17b6261cc41343b1f2b611ca12f1ccd2d4306ee5", "patch": "@@ -52,7 +52,7 @@ fn test_simple() {\n }\n \n #[cfg(test)]\n-fn test_parameterized<T:Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n+fn test_parameterized<T: Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n     let mut deq = VecDeque::new();\n     assert_eq!(deq.len(), 0);\n     deq.push_front(a.clone());\n@@ -186,7 +186,7 @@ enum Taggypar<T> {\n struct RecCy {\n     x: i32,\n     y: i32,\n-    t: Taggy\n+    t: Taggy,\n }\n \n #[test]\n@@ -209,10 +209,26 @@ fn test_param_taggypar() {\n \n #[test]\n fn test_param_reccy() {\n-    let reccy1 = RecCy { x: 1, y: 2, t: One(1) };\n-    let reccy2 = RecCy { x: 345, y: 2, t: Two(1, 2) };\n-    let reccy3 = RecCy { x: 1, y: 777, t: Three(1, 2, 3) };\n-    let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n+    let reccy1 = RecCy {\n+        x: 1,\n+        y: 2,\n+        t: One(1),\n+    };\n+    let reccy2 = RecCy {\n+        x: 345,\n+        y: 2,\n+        t: Two(1, 2),\n+    };\n+    let reccy3 = RecCy {\n+        x: 1,\n+        y: 777,\n+        t: Three(1, 2, 3),\n+    };\n+    let reccy4 = RecCy {\n+        x: 19,\n+        y: 252,\n+        t: Two(17, 42),\n+    };\n     test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n }\n \n@@ -257,13 +273,13 @@ fn test_with_capacity_non_power_two() {\n     // underlying Vec which didn't hold and lead\n     // to corruption.\n     // (Vec grows to next power of two)\n-    //good- [9, 12, 15, X, X, X, X, |6]\n-    //bug-  [15, 12, X, X, X, |6, X, X]\n+    // good- [9, 12, 15, X, X, X, X, |6]\n+    // bug-  [15, 12, X, X, X, |6, X, X]\n     assert_eq!(d3.pop_front(), Some(6));\n \n     // Which leads us to the following state which\n     // would be a failure case.\n-    //bug-  [15, 12, X, X, X, X, |X, X]\n+    // bug-  [15, 12, X, X, X, X, |X, X]\n     assert_eq!(d3.front(), Some(&9));\n }\n \n@@ -301,15 +317,15 @@ fn test_iter() {\n         d.push_back(i);\n     }\n     {\n-        let b: &[_] = &[&0,&1,&2,&3,&4];\n+        let b: &[_] = &[&0, &1, &2, &3, &4];\n         assert_eq!(d.iter().collect::<Vec<_>>(), b);\n     }\n \n     for i in 6..9 {\n         d.push_front(i);\n     }\n     {\n-        let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n+        let b: &[_] = &[&8, &7, &6, &0, &1, &2, &3, &4];\n         assert_eq!(d.iter().collect::<Vec<_>>(), b);\n     }\n \n@@ -318,7 +334,10 @@ fn test_iter() {\n     loop {\n         match it.next() {\n             None => break,\n-            _ => { len -= 1; assert_eq!(it.size_hint(), (len, Some(len))) }\n+            _ => {\n+                len -= 1;\n+                assert_eq!(it.size_hint(), (len, Some(len)))\n+            }\n         }\n     }\n }\n@@ -332,14 +351,14 @@ fn test_rev_iter() {\n         d.push_back(i);\n     }\n     {\n-        let b: &[_] = &[&4,&3,&2,&1,&0];\n+        let b: &[_] = &[&4, &3, &2, &1, &0];\n         assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n     }\n \n     for i in 6..9 {\n         d.push_front(i);\n     }\n-    let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n+    let b: &[_] = &[&4, &3, &2, &1, &0, &6, &7, &8];\n     assert_eq!(d.iter().rev().collect::<Vec<_>>(), b);\n }\n \n@@ -424,7 +443,7 @@ fn test_into_iter() {\n             d.push_back(i);\n         }\n \n-        let b = vec![0,1,2,3,4];\n+        let b = vec![0, 1, 2, 3, 4];\n         assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n     }\n \n@@ -438,7 +457,7 @@ fn test_into_iter() {\n             d.push_front(i);\n         }\n \n-        let b = vec![8,7,6,0,1,2,3,4];\n+        let b = vec![8, 7, 6, 0, 1, 2, 3, 4];\n         assert_eq!(d.into_iter().collect::<Vec<_>>(), b);\n     }\n \n@@ -502,7 +521,7 @@ fn test_drain() {\n             d.push_front(i);\n         }\n \n-        assert_eq!(d.drain(..).collect::<Vec<_>>(), [8,7,6,0,1,2,3,4]);\n+        assert_eq!(d.drain(..).collect::<Vec<_>>(), [8, 7, 6, 0, 1, 2, 3, 4]);\n         assert!(d.is_empty());\n     }\n \n@@ -532,15 +551,15 @@ fn test_drain() {\n \n #[test]\n fn test_from_iter() {\n-    let v = vec!(1,2,3,4,5,6,7);\n+    let v = vec![1, 2, 3, 4, 5, 6, 7];\n     let deq: VecDeque<_> = v.iter().cloned().collect();\n     let u: Vec<_> = deq.iter().cloned().collect();\n     assert_eq!(u, v);\n \n     let seq = (0..).step_by(2).take(256);\n     let deq: VecDeque<_> = seq.collect();\n     for (i, &x) in deq.iter().enumerate() {\n-        assert_eq!(2*i, x);\n+        assert_eq!(2 * i, x);\n     }\n     assert_eq!(deq.len(), 256);\n }\n@@ -585,20 +604,20 @@ fn test_eq() {\n \n #[test]\n fn test_hash() {\n-  let mut x = VecDeque::new();\n-  let mut y = VecDeque::new();\n+    let mut x = VecDeque::new();\n+    let mut y = VecDeque::new();\n \n-  x.push_back(1);\n-  x.push_back(2);\n-  x.push_back(3);\n+    x.push_back(1);\n+    x.push_back(2);\n+    x.push_back(3);\n \n-  y.push_back(0);\n-  y.push_back(1);\n-  y.pop_front();\n-  y.push_back(2);\n-  y.push_back(3);\n+    y.push_back(0);\n+    y.push_back(1);\n+    y.pop_front();\n+    y.push_back(2);\n+    y.push_back(3);\n \n-  assert!(::hash(&x) == ::hash(&y));\n+    assert!(::hash(&x) == ::hash(&y));\n }\n \n #[test]\n@@ -665,10 +684,12 @@ fn test_show() {\n     let ringbuf: VecDeque<_> = (0..10).collect();\n     assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n-                                                                    .cloned()\n-                                                                    .collect();\n-    assert_eq!(format!(\"{:?}\", ringbuf), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"]\n+                                   .iter()\n+                                   .cloned()\n+                                   .collect();\n+    assert_eq!(format!(\"{:?}\", ringbuf),\n+               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n@@ -677,7 +698,9 @@ fn test_drop() {\n     struct Elem;\n     impl Drop for Elem {\n         fn drop(&mut self) {\n-            unsafe { drops += 1; }\n+            unsafe {\n+                drops += 1;\n+            }\n         }\n     }\n \n@@ -688,7 +711,7 @@ fn test_drop() {\n     ring.push_front(Elem);\n     drop(ring);\n \n-    assert_eq!(unsafe {drops}, 4);\n+    assert_eq!(unsafe { drops }, 4);\n }\n \n #[test]\n@@ -697,7 +720,9 @@ fn test_drop_with_pop() {\n     struct Elem;\n     impl Drop for Elem {\n         fn drop(&mut self) {\n-            unsafe { drops += 1; }\n+            unsafe {\n+                drops += 1;\n+            }\n         }\n     }\n \n@@ -709,10 +734,10 @@ fn test_drop_with_pop() {\n \n     drop(ring.pop_back());\n     drop(ring.pop_front());\n-    assert_eq!(unsafe {drops}, 2);\n+    assert_eq!(unsafe { drops }, 2);\n \n     drop(ring);\n-    assert_eq!(unsafe {drops}, 4);\n+    assert_eq!(unsafe { drops }, 4);\n }\n \n #[test]\n@@ -721,7 +746,9 @@ fn test_drop_clear() {\n     struct Elem;\n     impl Drop for Elem {\n         fn drop(&mut self) {\n-            unsafe { drops += 1; }\n+            unsafe {\n+                drops += 1;\n+            }\n         }\n     }\n \n@@ -731,10 +758,10 @@ fn test_drop_clear() {\n     ring.push_back(Elem);\n     ring.push_front(Elem);\n     ring.clear();\n-    assert_eq!(unsafe {drops}, 4);\n+    assert_eq!(unsafe { drops }, 4);\n \n     drop(ring);\n-    assert_eq!(unsafe {drops}, 4);\n+    assert_eq!(unsafe { drops }, 4);\n }\n \n #[test]\n@@ -822,7 +849,7 @@ fn test_get_mut() {\n \n     match ring.get_mut(1) {\n         Some(x) => *x = -1,\n-        None => ()\n+        None => (),\n     };\n \n     assert_eq!(ring.get_mut(0), Some(&mut 0));\n@@ -852,21 +879,21 @@ fn test_front() {\n fn test_as_slices() {\n     let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n     let cap = ring.capacity() as i32;\n-    let first = cap/2;\n-    let last  = cap - first;\n+    let first = cap / 2;\n+    let last = cap - first;\n     for i in 0..first {\n         ring.push_back(i);\n \n         let (left, right) = ring.as_slices();\n-        let expected: Vec<_> = (0..i+1).collect();\n+        let expected: Vec<_> = (0..i + 1).collect();\n         assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n     for j in -last..0 {\n         ring.push_front(j);\n         let (left, right) = ring.as_slices();\n-        let expected_left: Vec<_> = (-last..j+1).rev().collect();\n+        let expected_left: Vec<_> = (-last..j + 1).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n         assert_eq!(left, &expected_left[..]);\n         assert_eq!(right, &expected_right[..]);\n@@ -880,21 +907,21 @@ fn test_as_slices() {\n fn test_as_mut_slices() {\n     let mut ring: VecDeque<i32> = VecDeque::with_capacity(127);\n     let cap = ring.capacity() as i32;\n-    let first = cap/2;\n-    let last  = cap - first;\n+    let first = cap / 2;\n+    let last = cap - first;\n     for i in 0..first {\n         ring.push_back(i);\n \n         let (left, right) = ring.as_mut_slices();\n-        let expected: Vec<_> = (0..i+1).collect();\n+        let expected: Vec<_> = (0..i + 1).collect();\n         assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n     for j in -last..0 {\n         ring.push_front(j);\n         let (left, right) = ring.as_mut_slices();\n-        let expected_left: Vec<_> = (-last..j+1).rev().collect();\n+        let expected_left: Vec<_> = (-last..j + 1).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n         assert_eq!(left, &expected_left[..]);\n         assert_eq!(right, &expected_right[..]);"}]}