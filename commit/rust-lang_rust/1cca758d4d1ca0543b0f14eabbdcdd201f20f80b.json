{"sha": "1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjY2E3NThkNGQxY2EwNTQzYjBmMTRlYWJiZGNkZDIwMWYyMGY4MGI=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-06-25T20:24:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-25T20:24:34Z"}, "message": "Merge pull request #2807 from topecongiro/raw-identifiers\n\nHandle raw identifiers", "tree": {"sha": "29a509db0c02c51afd2c1b696dbbb9369650f1f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29a509db0c02c51afd2c1b696dbbb9369650f1f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbMU+CCRBK7hj4Ov3rIwAAdHIIAJdD3fjOSLxITAKowv2ZqEFZ\nPtrGUjXp3LO+qQFTtJNQkFWBzcr+kSXM0tmU7ekNKpR9yjpNGxd4edTav8NblpeM\nqZ73ErcZRHqKgvlx+e2n3qlFgOH8FT7cxGPgAGmsGZGtNivBdfvvVpnolvP69HER\nlHzVEXu+xQ26Qb/HiwOBjuBxePqnAp62KamSkuLBk9eyV06eo5VenHNEIWEBTOsW\n2R4GBU+XCjFVdqfRJu5RAT6hTAMR6DsQeugmLlBtwAM5ZgqJr0nodVeB5yoKfOZM\nMdJ4VEmI+HEvrnTl3w4dH6VbHGXWRiYVVfortvwaampKamPe1ne0RniNn2dZyHo=\n=+SBv\n-----END PGP SIGNATURE-----\n", "payload": "tree 29a509db0c02c51afd2c1b696dbbb9369650f1f4\nparent ca1c13a8968e95ab9eff4c692fed2a57e0308342\nparent eb168f608a11972ca208a84a445b18d8c0cdce60\nauthor Nick Cameron <nrc@ncameron.org> 1529958274 +1200\ncommitter GitHub <noreply@github.com> 1529958274 +1200\n\nMerge pull request #2807 from topecongiro/raw-identifiers\n\nHandle raw identifiers"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "html_url": "https://github.com/rust-lang/rust/commit/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca1c13a8968e95ab9eff4c692fed2a57e0308342", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1c13a8968e95ab9eff4c692fed2a57e0308342", "html_url": "https://github.com/rust-lang/rust/commit/ca1c13a8968e95ab9eff4c692fed2a57e0308342"}, {"sha": "eb168f608a11972ca208a84a445b18d8c0cdce60", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb168f608a11972ca208a84a445b18d8c0cdce60", "html_url": "https://github.com/rust-lang/rust/commit/eb168f608a11972ca208a84a445b18d8c0cdce60"}], "stats": {"total": 245, "additions": 178, "deletions": 67}, "files": [{"sha": "ddb7262430d8f1af6051c98cb49c7e118cb28c30", "filename": "src/imports.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -21,7 +21,7 @@ use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListIte\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n-use utils::mk_sp;\n+use utils::{mk_sp, rewrite_ident};\n use visitor::FmtVisitor;\n \n use std::borrow::Cow;\n@@ -141,9 +141,12 @@ impl UseSegment {\n         }\n     }\n \n-    fn from_path_segment(path_seg: &ast::PathSegment) -> Option<UseSegment> {\n-        let name = path_seg.ident.name.as_str();\n-        if name == \"{{root}}\" {\n+    fn from_path_segment(\n+        context: &RewriteContext,\n+        path_seg: &ast::PathSegment,\n+    ) -> Option<UseSegment> {\n+        let name = rewrite_ident(context, path_seg.ident);\n+        if name.is_empty() || name == \"{{root}}\" {\n             return None;\n         }\n         Some(if name == \"self\" {\n@@ -231,10 +234,9 @@ impl fmt::Display for UseTree {\n impl UseTree {\n     // Rewrite use tree with `use ` and a trailing `;`.\n     pub fn rewrite_top_level(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let vis = self\n-            .visibility\n-            .as_ref()\n-            .map_or(Cow::from(\"\"), |vis| ::utils::format_visibility(&vis));\n+        let vis = self.visibility.as_ref().map_or(Cow::from(\"\"), |vis| {\n+            ::utils::format_visibility(context, &vis)\n+        });\n         let use_str = self\n             .rewrite(context, shape.offset_left(vis.len())?)\n             .map(|s| {\n@@ -314,7 +316,7 @@ impl UseTree {\n             attrs,\n         };\n         for p in &a.prefix.segments {\n-            if let Some(use_segment) = UseSegment::from_path_segment(p) {\n+            if let Some(use_segment) = UseSegment::from_path_segment(context, p) {\n                 result.path.push(use_segment);\n             }\n         }\n@@ -347,12 +349,12 @@ impl UseTree {\n                 ));\n             }\n             UseTreeKind::Simple(ref rename, ..) => {\n-                let mut name = (*path_to_imported_ident(&a.prefix).name.as_str()).to_owned();\n+                let mut name = rewrite_ident(context, path_to_imported_ident(&a.prefix)).to_owned();\n                 let alias = rename.and_then(|ident| {\n                     if ident == path_to_imported_ident(&a.prefix) {\n                         None\n                     } else {\n-                        Some(ident.to_string())\n+                        Some(rewrite_ident(context, ident).to_owned())\n                     }\n                 });\n "}, {"sha": "bef8fd7959909380563af4f91182b753816e04aa", "filename": "src/items.rs", "status": "modified", "additions": 66, "deletions": 31, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -233,7 +233,7 @@ impl<'a> FnSig<'a> {\n     fn to_str(&self, context: &RewriteContext) -> String {\n         let mut result = String::with_capacity(128);\n         // Vis defaultness constness unsafety abi.\n-        result.push_str(&*format_visibility(&self.visibility));\n+        result.push_str(&*format_visibility(context, &self.visibility));\n         result.push_str(format_defaultness(self.defaultness));\n         result.push_str(format_constness(self.constness));\n         result.push_str(format_unsafety(self.unsafety));\n@@ -437,7 +437,7 @@ impl<'a> FmtVisitor<'a> {\n         generics: &ast::Generics,\n         span: Span,\n     ) {\n-        let enum_header = format_header(\"enum \", ident, vis);\n+        let enum_header = format_header(&self.get_context(), \"enum \", ident, vis);\n         self.push_str(&enum_header);\n \n         let enum_snippet = self.snippet(span);\n@@ -571,10 +571,10 @@ impl<'a> FmtVisitor<'a> {\n             )?,\n             ast::VariantData::Unit(..) => {\n                 if let Some(ref expr) = field.node.disr_expr {\n-                    let lhs = format!(\"{} =\", field.node.ident.name);\n+                    let lhs = format!(\"{} =\", rewrite_ident(&context, field.node.ident));\n                     rewrite_assign_rhs(&context, lhs, &*expr.value, shape)?\n                 } else {\n-                    field.node.ident.name.to_string()\n+                    rewrite_ident(&context, field.node.ident).to_owned()\n                 }\n             }\n         };\n@@ -797,7 +797,7 @@ fn format_impl_ref_and_type(\n     {\n         let mut result = String::with_capacity(128);\n \n-        result.push_str(&format_visibility(&item.vis));\n+        result.push_str(&format_visibility(context, &item.vis));\n         result.push_str(format_defaultness(defaultness));\n         result.push_str(format_unsafety(unsafety));\n \n@@ -916,8 +916,8 @@ pub struct StructParts<'a> {\n }\n \n impl<'a> StructParts<'a> {\n-    fn format_header(&self) -> String {\n-        format_header(self.prefix, self.ident, self.vis)\n+    fn format_header(&self, context: &RewriteContext) -> String {\n+        format_header(context, self.prefix, self.ident, self.vis)\n     }\n \n     fn from_variant(variant: &'a ast::Variant) -> Self {\n@@ -977,7 +977,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let mut result = String::with_capacity(128);\n         let header = format!(\n             \"{}{}{}trait \",\n-            format_visibility(&item.vis),\n+            format_visibility(context, &item.vis),\n             format_unsafety(unsafety),\n             format_auto(is_auto),\n         );\n@@ -988,7 +988,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let shape = Shape::indented(offset, context.config).offset_left(result.len())?;\n         let generics_str = rewrite_generics(\n             context,\n-            &item.ident.to_string(),\n+            rewrite_ident(context, item.ident),\n             generics,\n             shape,\n             mk_sp(item.span.lo(), body_lo),\n@@ -999,7 +999,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         if !generic_bounds.is_empty() {\n             let ident_hi = context\n                 .snippet_provider\n-                .span_after(item.span, &format!(\"{}\", item.ident));\n+                .span_after(item.span, &item.ident.as_str());\n             let bound_hi = generic_bounds.last().unwrap().span().hi();\n             let snippet = context.snippet(mk_sp(ident_hi, bound_hi));\n             if contains_comment(snippet) {\n@@ -1135,7 +1135,7 @@ pub fn format_trait_alias(\n     generic_bounds: &ast::GenericBounds,\n     shape: Shape,\n ) -> Option<String> {\n-    let alias = ident.name.as_str();\n+    let alias = rewrite_ident(context, ident);\n     // 6 = \"trait \", 2 = \" =\"\n     let g_shape = shape.offset_left(6)?.sub_width(2)?;\n     let generics_str = rewrite_generics(context, &alias, generics, g_shape, generics.span)?;\n@@ -1145,7 +1145,7 @@ pub fn format_trait_alias(\n }\n \n fn format_unit_struct(context: &RewriteContext, p: &StructParts, offset: Indent) -> Option<String> {\n-    let header_str = format_header(p.prefix, p.ident, p.vis);\n+    let header_str = format_header(context, p.prefix, p.ident, p.vis);\n     let generics_str = if let Some(generics) = p.generics {\n         let hi = if generics.where_clause.predicates.is_empty() {\n             generics.span.hi()\n@@ -1177,7 +1177,7 @@ pub fn format_struct_struct(\n     let mut result = String::with_capacity(1024);\n     let span = struct_parts.span;\n \n-    let header_str = struct_parts.format_header();\n+    let header_str = struct_parts.format_header(context);\n     result.push_str(&header_str);\n \n     let header_hi = span.lo() + BytePos(header_str.len() as u32);\n@@ -1312,7 +1312,7 @@ fn format_tuple_struct(\n     let mut result = String::with_capacity(1024);\n     let span = struct_parts.span;\n \n-    let header_str = struct_parts.format_header();\n+    let header_str = struct_parts.format_header(context);\n     result.push_str(&header_str);\n \n     let body_lo = if fields.is_empty() {\n@@ -1413,7 +1413,7 @@ pub fn rewrite_type_alias(\n ) -> Option<String> {\n     let mut result = String::with_capacity(128);\n \n-    result.push_str(&format_visibility(vis));\n+    result.push_str(&format_visibility(context, vis));\n     result.push_str(\"type \");\n \n     // 2 = `= `\n@@ -1424,7 +1424,13 @@ pub fn rewrite_type_alias(\n         context.snippet_provider.span_after(span, \"type\"),\n         ty.span.lo(),\n     );\n-    let generics_str = rewrite_generics(context, &ident.to_string(), generics, g_shape, g_span)?;\n+    let generics_str = rewrite_generics(\n+        context,\n+        rewrite_ident(context, ident),\n+        generics,\n+        g_shape,\n+        g_span,\n+    )?;\n     result.push_str(&generics_str);\n \n     let where_budget = context.budget(last_line_width(&result));\n@@ -1467,10 +1473,15 @@ pub fn rewrite_struct_field_prefix(\n     context: &RewriteContext,\n     field: &ast::StructField,\n ) -> Option<String> {\n-    let vis = format_visibility(&field.vis);\n+    let vis = format_visibility(context, &field.vis);\n     let type_annotation_spacing = type_annotation_spacing(context.config);\n     Some(match field.ident {\n-        Some(name) => format!(\"{}{}{}:\", vis, name, type_annotation_spacing.0),\n+        Some(name) => format!(\n+            \"{}{}{}:\",\n+            vis,\n+            rewrite_ident(context, name),\n+            type_annotation_spacing.0\n+        ),\n         None => format!(\"{}\", vis),\n     })\n }\n@@ -1623,7 +1634,7 @@ fn rewrite_static(\n     );\n     let mut prefix = format!(\n         \"{}{}{} {}{}{}\",\n-        format_visibility(static_parts.vis),\n+        format_visibility(context, static_parts.vis),\n         static_parts.defaultness.map_or(\"\", format_defaultness),\n         static_parts.prefix,\n         format_mutability(static_parts.mutability),\n@@ -1673,7 +1684,7 @@ pub fn rewrite_associated_type(\n     context: &RewriteContext,\n     indent: Indent,\n ) -> Option<String> {\n-    let prefix = format!(\"type {}\", ident);\n+    let prefix = format!(\"type {}\", rewrite_ident(context, ident));\n \n     let type_bounds_str = if let Some(bounds) = generic_bounds_opt {\n         if bounds.is_empty() {\n@@ -1881,8 +1892,13 @@ fn rewrite_fn_base(\n     };\n     let fd = fn_sig.decl;\n     let g_span = mk_sp(span.lo(), fd.output.span().lo());\n-    let generics_str =\n-        rewrite_generics(context, &ident.to_string(), fn_sig.generics, shape, g_span)?;\n+    let generics_str = rewrite_generics(\n+        context,\n+        rewrite_ident(context, ident),\n+        fn_sig.generics,\n+        shape,\n+        g_span,\n+    )?;\n     result.push_str(&generics_str);\n \n     let snuggle_angle_bracket = generics_str\n@@ -2665,8 +2681,18 @@ fn rewrite_comments_before_after_where(\n     Some((before_comment, after_comment))\n }\n \n-fn format_header(item_name: &str, ident: ast::Ident, vis: &ast::Visibility) -> String {\n-    format!(\"{}{}{}\", format_visibility(vis), item_name, ident)\n+fn format_header(\n+    context: &RewriteContext,\n+    item_name: &str,\n+    ident: ast::Ident,\n+    vis: &ast::Visibility,\n+) -> String {\n+    format!(\n+        \"{}{}{}\",\n+        format_visibility(context, vis),\n+        item_name,\n+        rewrite_ident(context, ident)\n+    )\n }\n \n #[derive(PartialEq, Eq, Clone, Copy)]\n@@ -2771,15 +2797,24 @@ impl Rewrite for ast::ForeignItem {\n             ast::ForeignItemKind::Static(ref ty, is_mutable) => {\n                 // FIXME(#21): we're dropping potential comments in between the\n                 // function keywords here.\n-                let vis = format_visibility(&self.vis);\n+                let vis = format_visibility(context, &self.vis);\n                 let mut_str = if is_mutable { \"mut \" } else { \"\" };\n-                let prefix = format!(\"{}static {}{}:\", vis, mut_str, self.ident);\n+                let prefix = format!(\n+                    \"{}static {}{}:\",\n+                    vis,\n+                    mut_str,\n+                    rewrite_ident(context, self.ident)\n+                );\n                 // 1 = ;\n                 rewrite_assign_rhs(context, prefix, &**ty, shape.sub_width(1)?).map(|s| s + \";\")\n             }\n             ast::ForeignItemKind::Ty => {\n-                let vis = format_visibility(&self.vis);\n-                Some(format!(\"{}type {};\", vis, self.ident))\n+                let vis = format_visibility(context, &self.vis);\n+                Some(format!(\n+                    \"{}type {};\",\n+                    vis,\n+                    rewrite_ident(context, self.ident)\n+                ))\n             }\n             ast::ForeignItemKind::Macro(ref mac) => {\n                 rewrite_macro(mac, None, context, shape, MacroPosition::Item)\n@@ -2803,11 +2838,11 @@ impl Rewrite for ast::ForeignItem {\n }\n \n /// Rewrite an inline mod.\n-pub fn rewrite_mod(item: &ast::Item) -> String {\n+pub fn rewrite_mod(context: &RewriteContext, item: &ast::Item) -> String {\n     let mut result = String::with_capacity(32);\n-    result.push_str(&*format_visibility(&item.vis));\n+    result.push_str(&*format_visibility(context, &item.vis));\n     result.push_str(\"mod \");\n-    result.push_str(&item.ident.to_string());\n+    result.push_str(rewrite_ident(context, item.ident));\n     result.push(';');\n     result\n }"}, {"sha": "e3539d3b699194314a1db84d448b3c9a71e62901", "filename": "src/macros.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -43,7 +43,7 @@ use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use spanned::Spanned;\n-use utils::{format_visibility, mk_sp, wrap_str};\n+use utils::{format_visibility, mk_sp, rewrite_ident, wrap_str};\n \n const FORCED_BRACKET_MACROS: &[&str] = &[\"vec!\"];\n \n@@ -116,10 +116,14 @@ fn parse_macro_arg(parser: &mut Parser) -> Option<MacroArg> {\n }\n \n /// Rewrite macro name without using pretty-printer if possible.\n-fn rewrite_macro_name(path: &ast::Path, extra_ident: Option<ast::Ident>) -> String {\n+fn rewrite_macro_name(\n+    context: &RewriteContext,\n+    path: &ast::Path,\n+    extra_ident: Option<ast::Ident>,\n+) -> String {\n     let name = if path.segments.len() == 1 {\n         // Avoid using pretty-printer in the common case.\n-        format!(\"{}!\", path.segments[0].ident)\n+        format!(\"{}!\", rewrite_ident(context, path.segments[0].ident))\n     } else {\n         format!(\"{}!\", path)\n     };\n@@ -170,7 +174,7 @@ pub fn rewrite_macro_inner(\n \n     let original_style = macro_style(mac, context);\n \n-    let macro_name = rewrite_macro_name(&mac.node.path, extra_ident);\n+    let macro_name = rewrite_macro_name(context, &mac.node.path, extra_ident);\n \n     let style = if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) {\n         DelimToken::Bracket\n@@ -361,11 +365,11 @@ pub fn rewrite_macro_def(\n     let mut result = if def.legacy {\n         String::from(\"macro_rules!\")\n     } else {\n-        format!(\"{}macro\", format_visibility(vis))\n+        format!(\"{}macro\", format_visibility(context, vis))\n     };\n \n     result += \" \";\n-    result += &ident.name.as_str();\n+    result += rewrite_ident(context, ident);\n \n     let multi_branch_style = def.legacy || parsed_def.branches.len() != 1;\n \n@@ -1339,7 +1343,7 @@ fn format_lazy_static(context: &RewriteContext, shape: Shape, ts: &TokenStream)\n \n     while parser.token != Token::Eof {\n         // Parse a `lazy_static!` item.\n-        let vis = ::utils::format_visibility(&parse_or!(parse_visibility, false));\n+        let vis = ::utils::format_visibility(context, &parse_or!(parse_visibility, false));\n         parser.eat_keyword(symbol::keywords::Static);\n         parser.eat_keyword(symbol::keywords::Ref);\n         let id = parse_or!(parse_ident);"}, {"sha": "943434b68eca9271b9e07f8b5415a3a2970fb76d", "filename": "src/patterns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -28,7 +28,7 @@ use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n use types::{rewrite_path, PathContext};\n-use utils::{format_mutability, mk_sp};\n+use utils::{format_mutability, mk_sp, rewrite_ident};\n \n /// Returns true if the given pattern is short. A short pattern is defined by the following grammer:\n ///\n@@ -74,7 +74,7 @@ impl Rewrite for Pat {\n                     BindingMode::ByValue(mutability) => (\"\", mutability),\n                 };\n                 let mut_infix = format_mutability(mutability);\n-                let id_str = ident.name.to_string();\n+                let id_str = rewrite_ident(context, ident);\n                 let sub_pat = match *sub_pat {\n                     Some(ref p) => {\n                         // 3 - ` @ `.\n@@ -246,7 +246,7 @@ impl Rewrite for FieldPat {\n             pat\n         } else {\n             let pat_str = pat?;\n-            let id_str = self.ident.to_string();\n+            let id_str = rewrite_ident(context, self.ident);\n             let one_line_width = id_str.len() + 2 + pat_str.len();\n             if one_line_width <= shape.width {\n                 Some(format!(\"{}: {}\", id_str, pat_str))"}, {"sha": "9908c402a43ca675ec6a623c3df817917d0e6ad7", "filename": "src/reorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -100,7 +100,7 @@ fn rewrite_reorderable_item(\n \n     let item_str = match item.node {\n         ast::ItemKind::ExternCrate(..) => rewrite_extern_crate(context, item)?,\n-        ast::ItemKind::Mod(..) => rewrite_mod(item),\n+        ast::ItemKind::Mod(..) => rewrite_mod(context, item),\n         _ => return None,\n     };\n "}, {"sha": "3608d582d980a723752a75b7320a7087cd275916", "filename": "src/types.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -29,7 +29,7 @@ use shape::Shape;\n use spanned::Spanned;\n use utils::{\n     colon_spaces, extra_offset, first_line_width, format_abi, format_mutability, last_line_width,\n-    mk_sp,\n+    mk_sp, rewrite_ident,\n };\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -187,8 +187,10 @@ impl<'a> Rewrite for SegmentParam<'a> {\n             SegmentParam::Type(ty) => ty.rewrite(context, shape),\n             SegmentParam::Binding(binding) => {\n                 let mut result = match context.config.type_punctuation_density() {\n-                    TypeDensity::Wide => format!(\"{} = \", binding.ident),\n-                    TypeDensity::Compressed => format!(\"{}=\", binding.ident),\n+                    TypeDensity::Wide => format!(\"{} = \", rewrite_ident(context, binding.ident)),\n+                    TypeDensity::Compressed => {\n+                        format!(\"{}=\", rewrite_ident(context, binding.ident))\n+                    }\n                 };\n                 let budget = shape.width.checked_sub(result.len())?;\n                 let rewrite = binding\n@@ -220,7 +222,7 @@ fn rewrite_segment(\n     shape: Shape,\n ) -> Option<String> {\n     let mut result = String::with_capacity(128);\n-    result.push_str(&segment.ident.name.as_str());\n+    result.push_str(rewrite_ident(context, segment.ident));\n \n     let ident_len = result.len();\n     let shape = if context.use_block_indent() {\n@@ -496,8 +498,8 @@ fn rewrite_bounded_lifetime(\n }\n \n impl Rewrite for ast::Lifetime {\n-    fn rewrite(&self, _: &RewriteContext, _: Shape) -> Option<String> {\n-        Some(self.ident.to_string())\n+    fn rewrite(&self, context: &RewriteContext, _: Shape) -> Option<String> {\n+        Some(rewrite_ident(context, self.ident).to_owned())\n     }\n }\n \n@@ -532,7 +534,7 @@ impl Rewrite for ast::GenericParam {\n             Some(ref rw) if !rw.is_empty() => result.push_str(&format!(\"{} \", rw)),\n             _ => (),\n         }\n-        result.push_str(&self.ident.to_string());\n+        result.push_str(rewrite_ident(context, self.ident));\n         if !self.bounds.is_empty() {\n             result.push_str(type_bound_colon(context));\n             result.push_str(&self.bounds.rewrite(context, shape)?)"}, {"sha": "a8f8592d2f2fe549b501adf3cebda64a24e79fea", "filename": "src/utils.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -24,6 +24,10 @@ use shape::Shape;\n pub const DEPR_SKIP_ANNOTATION: &str = \"rustfmt_skip\";\n pub const SKIP_ANNOTATION: &str = \"rustfmt::skip\";\n \n+pub fn rewrite_ident<'a>(context: &'a RewriteContext, ident: ast::Ident) -> &'a str {\n+    context.snippet(ident.span)\n+}\n+\n // Computes the length of a string's last line, minus offset.\n pub fn extra_offset(text: &str, shape: Shape) -> usize {\n     match text.rfind('\\n') {\n@@ -34,15 +38,15 @@ pub fn extra_offset(text: &str, shape: Shape) -> usize {\n }\n \n // Uses Cow to avoid allocating in the common cases.\n-pub fn format_visibility(vis: &Visibility) -> Cow<'static, str> {\n+pub fn format_visibility(context: &RewriteContext, vis: &Visibility) -> Cow<'static, str> {\n     match vis.node {\n         VisibilityKind::Public => Cow::from(\"pub \"),\n         VisibilityKind::Inherited => Cow::from(\"\"),\n         VisibilityKind::Crate(CrateSugar::PubCrate) => Cow::from(\"pub(crate) \"),\n         VisibilityKind::Crate(CrateSugar::JustCrate) => Cow::from(\"crate \"),\n         VisibilityKind::Restricted { ref path, .. } => {\n             let Path { ref segments, .. } = **path;\n-            let mut segments_iter = segments.iter().map(|seg| seg.ident.name.to_string());\n+            let mut segments_iter = segments.iter().map(|seg| rewrite_ident(context, seg.ident));\n             if path.is_global() {\n                 segments_iter\n                     .next()"}, {"sha": "58422d782ac9ab9a9781bed0aec306e7de108bb8", "filename": "src/vertical.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -24,7 +24,7 @@ use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separat\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use spanned::Spanned;\n-use utils::{contains_skip, is_attributes_extendable, mk_sp};\n+use utils::{contains_skip, is_attributes_extendable, mk_sp, rewrite_ident};\n \n pub trait AlignedItem {\n     fn skip(&self) -> bool;\n@@ -88,7 +88,7 @@ impl AlignedItem for ast::Field {\n \n     fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let attrs_str = self.attrs.rewrite(context, shape)?;\n-        let name = &self.ident.name.to_string();\n+        let name = rewrite_ident(context, self.ident);\n         let missing_span = if self.attrs.is_empty() {\n             mk_sp(self.span.lo(), self.span.lo())\n         } else {"}, {"sha": "76fd3395ba9ca1dfeb1772612194aedc4b297f1b", "filename": "src/visitor.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -28,7 +28,7 @@ use shape::{Indent, Shape};\n use spanned::Spanned;\n use utils::{\n     self, contains_skip, count_newlines, inner_attributes, mk_sp, ptr_vec_to_ref_vec,\n-    DEPR_SKIP_ANNOTATION,\n+    rewrite_ident, DEPR_SKIP_ANNOTATION,\n };\n use {ErrorKind, FormatReport, FormattingError};\n \n@@ -682,9 +682,12 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         attrs: &[ast::Attribute],\n         is_internal: bool,\n     ) {\n-        self.push_str(&*utils::format_visibility(vis));\n+        let vis_str = utils::format_visibility(&self.get_context(), vis);\n+        self.push_str(&*vis_str);\n         self.push_str(\"mod \");\n-        self.push_str(&ident.to_string());\n+        // Calling `to_owned()` to work around borrow checker.\n+        let ident_str = rewrite_ident(&self.get_context(), ident).to_owned();\n+        self.push_str(&ident_str);\n \n         if is_internal {\n             match self.config.brace_style() {"}, {"sha": "4abb22b88b7a0e1538adf93ea6e96c715d9ffb70", "filename": "tests/target/raw_identifiers.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/tests%2Ftarget%2Fraw_identifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cca758d4d1ca0543b0f14eabbdcdd201f20f80b/tests%2Ftarget%2Fraw_identifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fraw_identifiers.rs?ref=1cca758d4d1ca0543b0f14eabbdcdd201f20f80b", "patch": "@@ -0,0 +1,61 @@\n+#![feature(custom_attribute)]\n+#![feature(raw_identifiers)]\n+#![feature(extern_types)]\n+#![allow(invalid_type_param_default)]\n+#![allow(unused_attributes)]\n+\n+use r#foo as r#alias_foo;\n+\n+fn main() {\n+    #[r#attr]\n+    r#foo::r#bar();\n+\n+    let r#local = 3;\n+    let r#async = r#foo(r#local);\n+    r#macro!();\n+\n+    if let r#sub_pat @ r#Foo(_) = r#Foo(3) {}\n+\n+    match r#async {\n+        r#Foo | r#Bar => r#foo(),\n+    }\n+}\n+\n+fn r#bar<'a, r#T>(r#x: &'a r#T) {}\n+\n+mod r#foo {\n+    pub fn r#bar() {}\n+}\n+\n+enum r#Foo {\n+    r#Bar {},\n+}\n+\n+struct r#Struct {\n+    r#field: r#FieldType,\n+}\n+\n+trait r#Trait {\n+    type r#Type;\n+}\n+\n+impl r#Trait for r#Impl {\n+    type r#Type = r#u32;\n+    fn r#xxx(r#fjio: r#u32) {}\n+}\n+\n+extern \"C\" {\n+    type r#ccc;\n+    static r#static_val: u32;\n+}\n+\n+macro_rules! r#macro {\n+    () => {};\n+}\n+\n+macro_rules! foo {\n+    ($x:expr) => {\n+        let r#catch = $x + 1;\n+        println!(\"{}\", r#catch);\n+    };\n+}"}]}