{"sha": "43b2486a9589380fd10698c2169351641a142f2e", "node_id": "C_kwDOAAsO6NoAKDQzYjI0ODZhOTU4OTM4MGZkMTA2OThjMjE2OTM1MTY0MWExNDJmMmU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-27T02:10:54Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-27T02:49:53Z"}, "message": "Clean up operator type checking", "tree": {"sha": "5371ddefe2880b61022c80a87b89f1bbb0fb8bdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5371ddefe2880b61022c80a87b89f1bbb0fb8bdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43b2486a9589380fd10698c2169351641a142f2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43b2486a9589380fd10698c2169351641a142f2e", "html_url": "https://github.com/rust-lang/rust/commit/43b2486a9589380fd10698c2169351641a142f2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43b2486a9589380fd10698c2169351641a142f2e/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58f5a0180ccd4ab87363c4b35a23fbe15a9a310c", "url": "https://api.github.com/repos/rust-lang/rust/commits/58f5a0180ccd4ab87363c4b35a23fbe15a9a310c", "html_url": "https://github.com/rust-lang/rust/commit/58f5a0180ccd4ab87363c4b35a23fbe15a9a310c"}], "stats": {"total": 114, "additions": 27, "deletions": 87}, "files": [{"sha": "bd3b90134d7ff3cdaf33de5d4a35f1cf4ef5bec8", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 16, "deletions": 55, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/43b2486a9589380fd10698c2169351641a142f2e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b2486a9589380fd10698c2169351641a142f2e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=43b2486a9589380fd10698c2169351641a142f2e", "patch": "@@ -306,8 +306,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        opt_input_type: Option<Ty<'tcx>>,\n-        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        opt_rhs: Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)>,\n         expected: Expectation<'tcx>,\n     ) -> (traits::Obligation<'tcx, ty::Predicate<'tcx>>, &'tcx ty::List<ty::subst::GenericArg<'tcx>>)\n     {\n@@ -318,7 +317,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 GenericParamDefKind::Type { .. } => {\n                     if param.index == 0 {\n                         return self_ty.into();\n-                    } else if let Some(input_type) = opt_input_type {\n+                    } else if let Some((_, input_type)) = opt_rhs {\n                         return input_type.into();\n                     }\n                 }\n@@ -339,9 +338,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     span,\n                     self.body_id,\n                     traits::BinOp {\n-                        rhs_span: opt_input_expr.map(|expr| expr.span),\n-                        is_lit: opt_input_expr\n-                            .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                        rhs_span: opt_rhs.map(|(expr, _)| expr.span),\n+                        is_lit: opt_rhs\n+                            .map_or(false, |(expr, _)| matches!(expr.kind, hir::ExprKind::Lit(_))),\n                         output_ty,\n                     },\n                 ),\n@@ -368,15 +367,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         let (obligation, substs) =\n             self.obligation_for_method(span, trait_def_id, self_ty, opt_input_types);\n-        self.construct_obligation_for_trait(\n-            span,\n-            m_name,\n-            trait_def_id,\n-            obligation,\n-            substs,\n-            None,\n-            false,\n-        )\n+        self.construct_obligation_for_trait(span, m_name, trait_def_id, obligation, substs)\n     }\n \n     pub(super) fn lookup_op_method_in_trait(\n@@ -385,27 +376,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         m_name: Ident,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n-        opt_input_type: Option<Ty<'tcx>>,\n-        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        opt_rhs: Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)>,\n         expected: Expectation<'tcx>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        let (obligation, substs) = self.obligation_for_op_method(\n-            span,\n-            trait_def_id,\n-            self_ty,\n-            opt_input_type,\n-            opt_input_expr,\n-            expected,\n-        );\n-        self.construct_obligation_for_trait(\n-            span,\n-            m_name,\n-            trait_def_id,\n-            obligation,\n-            substs,\n-            opt_input_expr,\n-            true,\n-        )\n+        let (obligation, substs) =\n+            self.obligation_for_op_method(span, trait_def_id, self_ty, opt_rhs, expected);\n+        self.construct_obligation_for_trait(span, m_name, trait_def_id, obligation, substs)\n     }\n \n     // FIXME(#18741): it seems likely that we can consolidate some of this\n@@ -418,8 +394,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         trait_def_id: DefId,\n         obligation: traits::PredicateObligation<'tcx>,\n         substs: &'tcx ty::List<ty::subst::GenericArg<'tcx>>,\n-        opt_input_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        is_op: bool,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(?obligation);\n \n@@ -463,22 +437,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n         let fn_sig = self.replace_bound_vars_with_fresh_vars(span, infer::FnCall, fn_sig);\n \n-        let cause = if is_op {\n-            ObligationCause::new(\n-                span,\n-                self.body_id,\n-                traits::BinOp {\n-                    rhs_span: opt_input_expr.map(|expr| expr.span),\n-                    is_lit: opt_input_expr\n-                        .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                    output_ty: None,\n-                },\n-            )\n-        } else {\n-            traits::ObligationCause::misc(span, self.body_id)\n-        };\n-\n-        let InferOk { value, obligations: o } = self.at(&cause, self.param_env).normalize(fn_sig);\n+        let InferOk { value, obligations: o } =\n+            self.at(&obligation.cause, self.param_env).normalize(fn_sig);\n         let fn_sig = {\n             obligations.extend(o);\n             value\n@@ -494,15 +454,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // any late-bound regions appearing in its bounds.\n         let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n \n-        let InferOk { value, obligations: o } = self.at(&cause, self.param_env).normalize(bounds);\n+        let InferOk { value, obligations: o } =\n+            self.at(&obligation.cause, self.param_env).normalize(bounds);\n         let bounds = {\n             obligations.extend(o);\n             value\n         };\n \n         assert!(!bounds.has_escaping_bound_vars());\n \n-        let predicates_cause = cause.clone();\n+        let predicates_cause = obligation.cause.clone();\n         obligations.extend(traits::predicates_for_generics(\n             move |_, _| predicates_cause.clone(),\n             self.param_env,\n@@ -517,7 +478,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         obligations.push(traits::Obligation::new(\n             tcx,\n-            cause,\n+            obligation.cause,\n             self.param_env,\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(method_ty.into())),\n         ));"}, {"sha": "632f4e9401e44d815705a595f4ef52e45fe3a2ed", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 11, "deletions": 32, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/43b2486a9589380fd10698c2169351641a142f2e/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b2486a9589380fd10698c2169351641a142f2e/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=43b2486a9589380fd10698c2169351641a142f2e", "patch": "@@ -48,8 +48,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if self\n                     .lookup_op_method(\n                         lhs_deref_ty,\n-                        Some(rhs_ty),\n-                        Some(rhs),\n+                        Some((rhs, rhs_ty)),\n                         Op::Binary(op, IsAssign::Yes),\n                         expected,\n                     )\n@@ -60,8 +59,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if self\n                         .lookup_op_method(\n                             lhs_ty,\n-                            Some(rhs_ty),\n-                            Some(rhs),\n+                            Some((rhs, rhs_ty)),\n                             Op::Binary(op, IsAssign::Yes),\n                             expected,\n                         )\n@@ -248,8 +246,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let result = self.lookup_op_method(\n             lhs_ty,\n-            Some(rhs_ty_var),\n-            Some(rhs_expr),\n+            Some((rhs_expr, rhs_ty_var)),\n             Op::Binary(op, is_assign),\n             expected,\n         );\n@@ -382,8 +379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if self\n                         .lookup_op_method(\n                             lhs_deref_ty,\n-                            Some(rhs_ty),\n-                            Some(rhs_expr),\n+                            Some((rhs_expr, rhs_ty)),\n                             Op::Binary(op, is_assign),\n                             expected,\n                         )\n@@ -410,8 +406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let is_compatible = |lhs_ty, rhs_ty| {\n                     self.lookup_op_method(\n                         lhs_ty,\n-                        Some(rhs_ty),\n-                        Some(rhs_expr),\n+                        Some((rhs_expr, rhs_ty)),\n                         Op::Binary(op, is_assign),\n                         expected,\n                     )\n@@ -471,8 +466,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let errors = self\n                             .lookup_op_method(\n                                 lhs_ty,\n-                                Some(rhs_ty),\n-                                Some(rhs_expr),\n+                                Some((rhs_expr, rhs_ty)),\n                                 Op::Binary(op, is_assign),\n                                 expected,\n                             )\n@@ -625,7 +619,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         assert!(op.is_by_value());\n-        match self.lookup_op_method(operand_ty, None, None, Op::Unary(op, ex.span), expected) {\n+        match self.lookup_op_method(operand_ty, None, Op::Unary(op, ex.span), expected) {\n             Ok(method) => {\n                 self.write_method_call(ex.hir_id, method);\n                 method.sig.output()\n@@ -712,8 +706,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn lookup_op_method(\n         &self,\n         lhs_ty: Ty<'tcx>,\n-        other_ty: Option<Ty<'tcx>>,\n-        other_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        opt_rhs: Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)>,\n         op: Op,\n         expected: Expectation<'tcx>,\n     ) -> Result<MethodCallee<'tcx>, Vec<FulfillmentError<'tcx>>> {\n@@ -747,15 +740,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let opname = Ident::with_dummy_span(opname);\n         let method = trait_did.and_then(|trait_did| {\n-            self.lookup_op_method_in_trait(\n-                span,\n-                opname,\n-                trait_did,\n-                lhs_ty,\n-                other_ty,\n-                other_ty_expr,\n-                expected,\n-            )\n+            self.lookup_op_method_in_trait(span, opname, trait_did, lhs_ty, opt_rhs, expected)\n         });\n \n         match (method, trait_did) {\n@@ -766,14 +751,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             (None, None) => Err(vec![]),\n             (None, Some(trait_did)) => {\n-                let (obligation, _) = self.obligation_for_op_method(\n-                    span,\n-                    trait_did,\n-                    lhs_ty,\n-                    other_ty,\n-                    other_ty_expr,\n-                    expected,\n-                );\n+                let (obligation, _) =\n+                    self.obligation_for_op_method(span, trait_did, lhs_ty, opt_rhs, expected);\n                 Err(rustc_trait_selection::traits::fully_solve_obligation(self, obligation))\n             }\n         }"}]}