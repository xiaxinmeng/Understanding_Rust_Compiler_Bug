{"sha": "ed22428b7292db18f8e0b90e06b91a802c0bf647", "node_id": "C_kwDOAAsO6NoAKGVkMjI0MjhiNzI5MmRiMThmOGUwYjkwZTA2YjkxYTgwMmMwYmY2NDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-22T09:57:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-22T09:57:00Z"}, "message": "Auto merge of #8717 - Alexendoo:manual-split-once-manual-iter, r=dswij,xFrednet\n\n`manual_split_once`: lint manual iteration of `SplitN`\n\nchangelog: `manual_split_once`: lint manual iteration of `SplitN`\n\nNow lints:\n\n```rust\nlet mut iter = \"a.b.c\".splitn(2, '.');\nlet first = iter.next().unwrap();\nlet second = iter.next().unwrap();\n\nlet mut iter = \"a.b.c\".splitn(2, '.');\nlet first = iter.next()?;\nlet second = iter.next()?;\n\nlet mut iter = \"a.b.c\".rsplitn(2, '.');\nlet first = iter.next().unwrap();\nlet second = iter.next().unwrap();\n\nlet mut iter = \"a.b.c\".rsplitn(2, '.');\nlet first = iter.next()?;\nlet second = iter.next()?;\n```\n\nIt suggests (minus leftover whitespace):\n\n```rust\nlet (first, second) = \"a.b.c\".split_once('.').unwrap();\n\nlet (first, second) = \"a.b.c\".split_once('.')?;\n\nlet (second, first) = \"a.b.c\".rsplit_once('.').unwrap();\n\nlet (second, first) = \"a.b.c\".rsplit_once('.')?;\n```\n\nCurrently only lints if the statements are next to each other, as detecting the various kinds of shadowing was tricky, so the following won't lint\n\n```rust\nlet mut iter = \"a.b.c\".splitn(2, '.');\nlet something_else = 1;\nlet first = iter.next()?;\nlet second = iter.next()?;\n```", "tree": {"sha": "7d10eacdd915fd08eaa80d0c05311803fbd7ed77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d10eacdd915fd08eaa80d0c05311803fbd7ed77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed22428b7292db18f8e0b90e06b91a802c0bf647", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed22428b7292db18f8e0b90e06b91a802c0bf647", "html_url": "https://github.com/rust-lang/rust/commit/ed22428b7292db18f8e0b90e06b91a802c0bf647", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed22428b7292db18f8e0b90e06b91a802c0bf647/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf68cadc4556c5139e12c082e2c05fa716553e2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf68cadc4556c5139e12c082e2c05fa716553e2b", "html_url": "https://github.com/rust-lang/rust/commit/cf68cadc4556c5139e12c082e2c05fa716553e2b"}, {"sha": "4424aa444c2b24c3728e3f09d85bd9b69f57a48d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4424aa444c2b24c3728e3f09d85bd9b69f57a48d", "html_url": "https://github.com/rust-lang/rust/commit/4424aa444c2b24c3728e3f09d85bd9b69f57a48d"}], "stats": {"total": 566, "additions": 527, "deletions": 39}, "files": [{"sha": "7a1bf36489a18a48e56235b2c12789bb391c6cd4", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed22428b7292db18f8e0b90e06b91a802c0bf647/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed22428b7292db18f8e0b90e06b91a802c0bf647/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=ed22428b7292db18f8e0b90e06b91a802c0bf647", "patch": "@@ -2009,13 +2009,27 @@ declare_clippy_lint! {\n     /// ### Example\n     /// ```rust,ignore\n     /// // Bad\n-    ///  let (key, value) = _.splitn(2, '=').next_tuple()?;\n-    ///  let value = _.splitn(2, '=').nth(1)?;\n+    /// let s = \"key=value=add\";\n+    /// let (key, value) = s.splitn(2, '=').next_tuple()?;\n+    /// let value = s.splitn(2, '=').nth(1)?;\n     ///\n+    /// let mut parts = s.splitn(2, '=');\n+    /// let key = parts.next()?;\n+    /// let value = parts.next()?;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n     /// // Good\n-    /// let (key, value) = _.split_once('=')?;\n-    /// let value = _.split_once('=')?.1;\n+    /// let s = \"key=value=add\";\n+    /// let (key, value) = s.split_once('=')?;\n+    /// let value = s.split_once('=')?.1;\n+    ///\n+    /// let (key, value) = s.split_once('=')?;\n     /// ```\n+    ///\n+    /// ### Limitations\n+    /// The multiple statement variant currently only detects `iter.next()?`/`iter.next().unwrap()`\n+    /// in two separate `let` statements that immediately follow the `splitn()`\n     #[clippy::version = \"1.57.0\"]\n     pub MANUAL_SPLIT_ONCE,\n     complexity,"}, {"sha": "52891eeed0696db2031bcb2fcb67943972c31036", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 192, "deletions": 31, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/ed22428b7292db18f8e0b90e06b91a802c0bf647/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed22428b7292db18f8e0b90e06b91a802c0bf647/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=ed22428b7292db18f8e0b90e06b91a802c0bf647", "patch": "@@ -1,14 +1,19 @@\n use clippy_utils::consts::{constant, Constant};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_context;\n-use clippy_utils::{is_diag_item_method, match_def_path, meets_msrv, msrvs, paths};\n+use clippy_utils::usage::local_used_after_expr;\n+use clippy_utils::visitors::expr_visitor;\n+use clippy_utils::{is_diag_item_method, match_def_path, meets_msrv, msrvs, path_to_local_id, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirId, LangItem, Node, QPath};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{\n+    BindingAnnotation, Expr, ExprKind, HirId, LangItem, Local, MatchSource, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n-use rustc_span::{symbol::sym, Span, SyntaxContext};\n+use rustc_span::{sym, Span, Symbol, SyntaxContext};\n \n use super::{MANUAL_SPLIT_ONCE, NEEDLESS_SPLITN};\n \n@@ -25,40 +30,41 @@ pub(super) fn check(\n         return;\n     }\n \n-    let ctxt = expr.span.ctxt();\n-    let Some(usage) = parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id)) else { return };\n-\n-    let needless = match usage.kind {\n+    let needless = |usage_kind| match usage_kind {\n         IterUsageKind::Nth(n) => count > n + 1,\n         IterUsageKind::NextTuple => count > 2,\n     };\n+    let manual = count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE);\n \n-    if needless {\n-        let mut app = Applicability::MachineApplicable;\n-        let (r, message) = if method_name == \"splitn\" {\n-            (\"\", \"unnecessary use of `splitn`\")\n-        } else {\n-            (\"r\", \"unnecessary use of `rsplitn`\")\n-        };\n-\n-        span_lint_and_sugg(\n-            cx,\n-            NEEDLESS_SPLITN,\n-            expr.span,\n-            message,\n-            \"try this\",\n-            format!(\n-                \"{}.{r}split({})\",\n-                snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0,\n-                snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0,\n-            ),\n-            app,\n-        );\n-    } else if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n-        check_manual_split_once(cx, method_name, expr, self_arg, pat_arg, &usage);\n+    match parse_iter_usage(cx, expr.span.ctxt(), cx.tcx.hir().parent_iter(expr.hir_id)) {\n+        Some(usage) if needless(usage.kind) => lint_needless(cx, method_name, expr, self_arg, pat_arg),\n+        Some(usage) if manual => check_manual_split_once(cx, method_name, expr, self_arg, pat_arg, &usage),\n+        None if manual => {\n+            check_manual_split_once_indirect(cx, method_name, expr, self_arg, pat_arg);\n+        },\n+        _ => {},\n     }\n }\n \n+fn lint_needless(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, pat_arg: &Expr<'_>) {\n+    let mut app = Applicability::MachineApplicable;\n+    let r = if method_name == \"splitn\" { \"\" } else { \"r\" };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        NEEDLESS_SPLITN,\n+        expr.span,\n+        &format!(\"unnecessary use of `{r}splitn`\"),\n+        \"try this\",\n+        format!(\n+            \"{}.{r}split({})\",\n+            snippet_with_context(cx, self_arg.span, expr.span.ctxt(), \"..\", &mut app).0,\n+            snippet_with_context(cx, pat_arg.span, expr.span.ctxt(), \"..\", &mut app).0,\n+        ),\n+        app,\n+    );\n+}\n+\n fn check_manual_split_once(\n     cx: &LateContext<'_>,\n     method_name: &str,\n@@ -107,16 +113,171 @@ fn check_manual_split_once(\n     span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n }\n \n+/// checks for\n+///\n+/// ```\n+/// let mut iter = \"a.b.c\".splitn(2, '.');\n+/// let a = iter.next();\n+/// let b = iter.next();\n+/// ```\n+fn check_manual_split_once_indirect(\n+    cx: &LateContext<'_>,\n+    method_name: &str,\n+    expr: &Expr<'_>,\n+    self_arg: &Expr<'_>,\n+    pat_arg: &Expr<'_>,\n+) -> Option<()> {\n+    let ctxt = expr.span.ctxt();\n+    let mut parents = cx.tcx.hir().parent_iter(expr.hir_id);\n+    if let (_, Node::Local(local)) = parents.next()?\n+        && let PatKind::Binding(BindingAnnotation::Mutable, iter_binding_id, iter_ident, None) = local.pat.kind\n+        && let (iter_stmt_id, Node::Stmt(_)) = parents.next()?\n+        && let (_, Node::Block(enclosing_block)) = parents.next()?\n+\n+        && let mut stmts = enclosing_block\n+            .stmts\n+            .iter()\n+            .skip_while(|stmt| stmt.hir_id != iter_stmt_id)\n+            .skip(1)\n+\n+        && let first = indirect_usage(cx, stmts.next()?, iter_binding_id, ctxt)?\n+        && let second = indirect_usage(cx, stmts.next()?, iter_binding_id, ctxt)?\n+        && first.unwrap_kind == second.unwrap_kind\n+        && first.name != second.name\n+        && !local_used_after_expr(cx, iter_binding_id, second.init_expr)\n+    {\n+        let (r, lhs, rhs) = if method_name == \"splitn\" {\n+            (\"\", first.name, second.name)\n+        } else {\n+            (\"r\", second.name, first.name)\n+        };\n+        let msg = format!(\"manual implementation of `{r}split_once`\");\n+\n+        let mut app = Applicability::MachineApplicable;\n+        let self_snip = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n+        let pat_snip = snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0;\n+\n+        span_lint_and_then(cx, MANUAL_SPLIT_ONCE, local.span, &msg, |diag| {\n+            diag.span_label(first.span, \"first usage here\");\n+            diag.span_label(second.span, \"second usage here\");\n+\n+            let unwrap = match first.unwrap_kind {\n+                UnwrapKind::Unwrap => \".unwrap()\",\n+                UnwrapKind::QuestionMark => \"?\",\n+            };\n+            diag.span_suggestion_verbose(\n+                local.span,\n+                &format!(\"try `{r}split_once`\"),\n+                format!(\"let ({lhs}, {rhs}) = {self_snip}.{r}split_once({pat_snip}){unwrap};\"),\n+                app,\n+            );\n+\n+            let remove_msg = format!(\"remove the `{iter_ident}` usages\");\n+            diag.span_suggestion(\n+                first.span,\n+                &remove_msg,\n+                String::new(),\n+                app,\n+            );\n+            diag.span_suggestion(\n+                second.span,\n+                &remove_msg,\n+                String::new(),\n+                app,\n+            );\n+        });\n+    }\n+\n+    Some(())\n+}\n+\n+#[derive(Debug)]\n+struct IndirectUsage<'a> {\n+    name: Symbol,\n+    span: Span,\n+    init_expr: &'a Expr<'a>,\n+    unwrap_kind: UnwrapKind,\n+}\n+\n+/// returns `Some(IndirectUsage)` for e.g.\n+///\n+/// ```ignore\n+/// let name = binding.next()?;\n+/// let name = binding.next().unwrap();\n+/// ```\n+fn indirect_usage<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    stmt: &Stmt<'tcx>,\n+    binding: HirId,\n+    ctxt: SyntaxContext,\n+) -> Option<IndirectUsage<'tcx>> {\n+    if let StmtKind::Local(Local {\n+        pat:\n+            Pat {\n+                kind: PatKind::Binding(BindingAnnotation::Unannotated, _, ident, None),\n+                ..\n+            },\n+        init: Some(init_expr),\n+        hir_id: local_hir_id,\n+        ..\n+    }) = stmt.kind\n+    {\n+        let mut path_to_binding = None;\n+        expr_visitor(cx, |expr| {\n+            if path_to_local_id(expr, binding) {\n+                path_to_binding = Some(expr);\n+            }\n+\n+            path_to_binding.is_none()\n+        })\n+        .visit_expr(init_expr);\n+\n+        let mut parents = cx.tcx.hir().parent_iter(path_to_binding?.hir_id);\n+        let iter_usage = parse_iter_usage(cx, ctxt, &mut parents)?;\n+\n+        let (parent_id, _) = parents.find(|(_, node)| {\n+            !matches!(\n+                node,\n+                Node::Expr(Expr {\n+                    kind: ExprKind::Match(.., MatchSource::TryDesugar),\n+                    ..\n+                })\n+            )\n+        })?;\n+\n+        if let IterUsage {\n+            kind: IterUsageKind::Nth(0),\n+            unwrap_kind: Some(unwrap_kind),\n+            ..\n+        } = iter_usage\n+        {\n+            if parent_id == *local_hir_id {\n+                return Some(IndirectUsage {\n+                    name: ident.name,\n+                    span: stmt.span,\n+                    init_expr,\n+                    unwrap_kind,\n+                });\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n enum IterUsageKind {\n     Nth(u128),\n     NextTuple,\n }\n \n+#[derive(Debug, PartialEq)]\n enum UnwrapKind {\n     Unwrap,\n     QuestionMark,\n }\n \n+#[derive(Debug)]\n struct IterUsage {\n     kind: IterUsageKind,\n     unwrap_kind: Option<UnwrapKind>,"}, {"sha": "c7ca770434a318c53308c073bbb72ecc3e540749", "filename": "tests/ui/manual_split_once.fixed", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ed22428b7292db18f8e0b90e06b91a802c0bf647/tests%2Fui%2Fmanual_split_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ed22428b7292db18f8e0b90e06b91a802c0bf647/tests%2Fui%2Fmanual_split_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.fixed?ref=ed22428b7292db18f8e0b90e06b91a802c0bf647", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(custom_inner_attributes)]\n #![warn(clippy::manual_split_once)]\n-#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+#![allow(unused, clippy::iter_skip_next, clippy::iter_nth_zero)]\n \n extern crate itertools;\n \n@@ -41,13 +41,107 @@ fn main() {\n     let _ = s.rsplit_once('=').map(|x| x.0);\n }\n \n+fn indirect() -> Option<()> {\n+    let (l, r) = \"a.b.c\".split_once('.').unwrap();\n+    \n+    \n+\n+    let (l, r) = \"a.b.c\".split_once('.')?;\n+    \n+    \n+\n+    let (l, r) = \"a.b.c\".rsplit_once('.').unwrap();\n+    \n+    \n+\n+    let (l, r) = \"a.b.c\".rsplit_once('.')?;\n+    \n+    \n+\n+    // could lint, currently doesn't\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let other = 1;\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let mut mut_binding = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let tuple = (iter.next()?, iter.next()?);\n+\n+    // should not lint\n+\n+    let mut missing_unwrap = \"a.b.c\".splitn(2, '.');\n+    let l = missing_unwrap.next();\n+    let r = missing_unwrap.next();\n+\n+    let mut mixed_unrap = \"a.b.c\".splitn(2, '.');\n+    let unwrap = mixed_unrap.next().unwrap();\n+    let question_mark = mixed_unrap.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let same_name = iter.next()?;\n+    let same_name = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let shadows_existing = \"d\";\n+    let shadows_existing = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let becomes_shadowed = iter.next()?;\n+    let becomes_shadowed = \"d\";\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+    let third_usage = iter.next()?;\n+\n+    let mut n_three = \"a.b.c\".splitn(3, '.');\n+    let l = n_three.next()?;\n+    let r = n_three.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    {\n+        let in_block = iter.next()?;\n+    }\n+    let r = iter.next()?;\n+\n+    let mut lacks_binding = \"a.b.c\".splitn(2, '.');\n+    let _ = lacks_binding.next()?;\n+    let r = lacks_binding.next()?;\n+\n+    let mut mapped = \"a.b.c\".splitn(2, '.').map(|_| \"~\");\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut assigned = \"\";\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    assigned = iter.next()?;\n+\n+    None\n+}\n+\n fn _msrv_1_51() {\n     #![clippy::msrv = \"1.51\"]\n     // `str::split_once` was stabilized in 1.52. Do not lint this\n     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let a = iter.next().unwrap();\n+    let b = iter.next().unwrap();\n }\n \n fn _msrv_1_52() {\n     #![clippy::msrv = \"1.52\"]\n     let _ = \"key=value\".split_once('=').unwrap().1;\n+\n+    let (a, b) = \"a.b.c\".split_once('.').unwrap();\n+    \n+    \n }"}, {"sha": "ee2848a251ee3b2e666c49644a7768597e41782d", "filename": "tests/ui/manual_split_once.rs", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ed22428b7292db18f8e0b90e06b91a802c0bf647/tests%2Fui%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed22428b7292db18f8e0b90e06b91a802c0bf647/tests%2Fui%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.rs?ref=ed22428b7292db18f8e0b90e06b91a802c0bf647", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(custom_inner_attributes)]\n #![warn(clippy::manual_split_once)]\n-#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+#![allow(unused, clippy::iter_skip_next, clippy::iter_nth_zero)]\n \n extern crate itertools;\n \n@@ -41,13 +41,107 @@ fn main() {\n     let _ = s.rsplitn(2, '=').nth(1);\n }\n \n+fn indirect() -> Option<()> {\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next().unwrap();\n+    let r = iter.next().unwrap();\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".rsplitn(2, '.');\n+    let r = iter.next().unwrap();\n+    let l = iter.next().unwrap();\n+\n+    let mut iter = \"a.b.c\".rsplitn(2, '.');\n+    let r = iter.next()?;\n+    let l = iter.next()?;\n+\n+    // could lint, currently doesn't\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let other = 1;\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let mut mut_binding = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let tuple = (iter.next()?, iter.next()?);\n+\n+    // should not lint\n+\n+    let mut missing_unwrap = \"a.b.c\".splitn(2, '.');\n+    let l = missing_unwrap.next();\n+    let r = missing_unwrap.next();\n+\n+    let mut mixed_unrap = \"a.b.c\".splitn(2, '.');\n+    let unwrap = mixed_unrap.next().unwrap();\n+    let question_mark = mixed_unrap.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let same_name = iter.next()?;\n+    let same_name = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let shadows_existing = \"d\";\n+    let shadows_existing = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let becomes_shadowed = iter.next()?;\n+    let becomes_shadowed = \"d\";\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+    let third_usage = iter.next()?;\n+\n+    let mut n_three = \"a.b.c\".splitn(3, '.');\n+    let l = n_three.next()?;\n+    let r = n_three.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    {\n+        let in_block = iter.next()?;\n+    }\n+    let r = iter.next()?;\n+\n+    let mut lacks_binding = \"a.b.c\".splitn(2, '.');\n+    let _ = lacks_binding.next()?;\n+    let r = lacks_binding.next()?;\n+\n+    let mut mapped = \"a.b.c\".splitn(2, '.').map(|_| \"~\");\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut assigned = \"\";\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    assigned = iter.next()?;\n+\n+    None\n+}\n+\n fn _msrv_1_51() {\n     #![clippy::msrv = \"1.51\"]\n     // `str::split_once` was stabilized in 1.52. Do not lint this\n     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let a = iter.next().unwrap();\n+    let b = iter.next().unwrap();\n }\n \n fn _msrv_1_52() {\n     #![clippy::msrv = \"1.52\"]\n     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let a = iter.next().unwrap();\n+    let b = iter.next().unwrap();\n }"}, {"sha": "2563a6904b77c928bd94e48fa1fc41473e23bd21", "filename": "tests/ui/manual_split_once.stderr", "status": "modified", "additions": 127, "deletions": 2, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ed22428b7292db18f8e0b90e06b91a802c0bf647/tests%2Fui%2Fmanual_split_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed22428b7292db18f8e0b90e06b91a802c0bf647/tests%2Fui%2Fmanual_split_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.stderr?ref=ed22428b7292db18f8e0b90e06b91a802c0bf647", "patch": "@@ -79,10 +79,135 @@ LL |     let _ = s.rsplitn(2, '=').nth(1);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit_once('=').map(|x| x.0)`\n \n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:52:13\n+  --> $DIR/manual_split_once.rs:45:5\n+   |\n+LL |     let mut iter = \"a.b.c\".splitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let l = iter.next().unwrap();\n+   |     ----------------------------- first usage here\n+LL |     let r = iter.next().unwrap();\n+   |     ----------------------------- second usage here\n+   |\n+help: try `split_once`\n+   |\n+LL |     let (l, r) = \"a.b.c\".split_once('.').unwrap();\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let l = iter.next().unwrap();\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let r = iter.next().unwrap();\n+LL +     \n+   | \n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:49:5\n+   |\n+LL |     let mut iter = \"a.b.c\".splitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let l = iter.next()?;\n+   |     --------------------- first usage here\n+LL |     let r = iter.next()?;\n+   |     --------------------- second usage here\n+   |\n+help: try `split_once`\n+   |\n+LL |     let (l, r) = \"a.b.c\".split_once('.')?;\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let l = iter.next()?;\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let r = iter.next()?;\n+LL +     \n+   | \n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:53:5\n+   |\n+LL |     let mut iter = \"a.b.c\".rsplitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let r = iter.next().unwrap();\n+   |     ----------------------------- first usage here\n+LL |     let l = iter.next().unwrap();\n+   |     ----------------------------- second usage here\n+   |\n+help: try `rsplit_once`\n+   |\n+LL |     let (l, r) = \"a.b.c\".rsplit_once('.').unwrap();\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let r = iter.next().unwrap();\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let l = iter.next().unwrap();\n+LL +     \n+   | \n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:57:5\n+   |\n+LL |     let mut iter = \"a.b.c\".rsplitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let r = iter.next()?;\n+   |     --------------------- first usage here\n+LL |     let l = iter.next()?;\n+   |     --------------------- second usage here\n+   |\n+help: try `rsplit_once`\n+   |\n+LL |     let (l, r) = \"a.b.c\".rsplit_once('.')?;\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let r = iter.next()?;\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let l = iter.next()?;\n+LL +     \n+   | \n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:142:13\n    |\n LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n \n-error: aborting due to 14 previous errors\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:144:5\n+   |\n+LL |     let mut iter = \"a.b.c\".splitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let a = iter.next().unwrap();\n+   |     ----------------------------- first usage here\n+LL |     let b = iter.next().unwrap();\n+   |     ----------------------------- second usage here\n+   |\n+help: try `split_once`\n+   |\n+LL |     let (a, b) = \"a.b.c\".split_once('.').unwrap();\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let a = iter.next().unwrap();\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let b = iter.next().unwrap();\n+LL +     \n+   | \n+\n+error: aborting due to 19 previous errors\n "}]}