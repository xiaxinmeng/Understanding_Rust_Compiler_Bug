{"sha": "ee5d2383894944dcbb3b72a130ed0abaef0e8951", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNWQyMzgzODk0OTQ0ZGNiYjNiNzJhMTMwZWQwYWJhZWYwZTg5NTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T23:29:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-03T23:55:59Z"}, "message": "rollup merge of #18536 : bjz/strconv", "tree": {"sha": "2778103261b2a59c356b93781a5eb0158bb03640", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2778103261b2a59c356b93781a5eb0158bb03640"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee5d2383894944dcbb3b72a130ed0abaef0e8951", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee5d2383894944dcbb3b72a130ed0abaef0e8951", "html_url": "https://github.com/rust-lang/rust/commit/ee5d2383894944dcbb3b72a130ed0abaef0e8951", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee5d2383894944dcbb3b72a130ed0abaef0e8951/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5aba685ba8ef7272520b705962abadf6f330b67", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5aba685ba8ef7272520b705962abadf6f330b67", "html_url": "https://github.com/rust-lang/rust/commit/a5aba685ba8ef7272520b705962abadf6f330b67"}, {"sha": "8bd37e672411bf004a4ad64bb7d2160e455a72b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bd37e672411bf004a4ad64bb7d2160e455a72b0", "html_url": "https://github.com/rust-lang/rust/commit/8bd37e672411bf004a4ad64bb7d2160e455a72b0"}], "stats": {"total": 835, "additions": 283, "deletions": 552}, "files": [{"sha": "92f3b888dcd523576ce3d755ec9f601314c943e5", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ee5d2383894944dcbb3b72a130ed0abaef0e8951", "patch": "@@ -36,7 +36,7 @@ use std::io::extensions::u64_from_be_bytes;\n use std::io;\n use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n-use std::u64;\n+use std::str;\n use rbml::reader;\n use rbml;\n use serialize::Decodable;\n@@ -215,7 +215,9 @@ fn each_reexport(d: rbml::Doc, f: |rbml::Doc| -> bool) -> bool {\n \n fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n-        reader::with_doc_data(val_doc, |data| u64::parse_bytes(data, 10u))\n+        reader::with_doc_data(val_doc, |data| {\n+            str::from_utf8(data).and_then(from_str)\n+        })\n     })\n }\n "}, {"sha": "6e7a6dfa0944898a46eecda2a23785eb5fdc95ae", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=ee5d2383894944dcbb3b72a130ed0abaef0e8951", "patch": "@@ -23,7 +23,6 @@ use middle::ty;\n use std::rc::Rc;\n use std::str;\n use std::string::String;\n-use std::uint;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n@@ -615,12 +614,12 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let crate_part = buf[0u..colon_idx];\n     let def_part = buf[colon_idx + 1u..len];\n \n-    let crate_num = match uint::parse_bytes(crate_part, 10u) {\n+    let crate_num = match str::from_utf8(crate_part).and_then(from_str::<uint>) {\n        Some(cn) => cn as ast::CrateNum,\n        None => panic!(\"internal error: parse_def_id: crate number expected, found {}\",\n                      crate_part)\n     };\n-    let def_num = match uint::parse_bytes(def_part, 10u) {\n+    let def_num = match str::from_utf8(def_part).and_then(from_str::<uint>) {\n        Some(dn) => dn as ast::NodeId,\n        None => panic!(\"internal error: parse_def_id: id expected, found {}\",\n                      def_part)"}, {"sha": "63c3956ef24121cee057eed930aea25036bda765", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 15, "deletions": 42, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=ee5d2383894944dcbb3b72a130ed0abaef0e8951", "patch": "@@ -333,35 +333,10 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     r\n }\n \n-/// Convert a string in base 16 to a float.\n-/// Accepts an optional binary exponent.\n-///\n-/// This function accepts strings such as\n-///\n-/// * 'a4.fe'\n-/// * '+a4.fe', equivalent to 'a4.fe'\n-/// * '-a4.fe'\n-/// * '2b.aP128', or equivalently, '2b.ap128'\n-/// * '2b.aP-128'\n-/// * '.' (understood as 0)\n-/// * 'c.'\n-/// * '.c', or, equivalently,  '0.c'\n-/// * '+inf', 'inf', '-inf', 'NaN'\n-///\n-/// Leading and trailing whitespace represent an error.\n-///\n-/// # Arguments\n-///\n-/// * num - A string\n-///\n-/// # Return value\n-///\n-/// `None` if the string did not represent a valid number.  Otherwise,\n-/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n #[inline]\n-pub fn from_str_hex(num: &str) -> Option<f32> {\n-    strconv::from_str_common(num, 16u, true, true, true,\n-                             strconv::ExpBin, false, false)\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f32> {\n+    strconv::from_str_radix_float(src, 16)\n }\n \n impl FromStr for f32 {\n@@ -384,16 +359,15 @@ impl FromStr for f32 {\n     ///\n     /// # Arguments\n     ///\n-    /// * num - A string\n+    /// * src - A string\n     ///\n     /// # Return value\n     ///\n     /// `None` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n     #[inline]\n-    fn from_str(val: &str) -> Option<f32> {\n-        strconv::from_str_common(val, 10u, true, true, true,\n-                                 strconv::ExpDec, false, false)\n+    fn from_str(src: &str) -> Option<f32> {\n+        strconv::from_str_radix_float(src, 10u)\n     }\n }\n \n@@ -408,17 +382,16 @@ impl num::FromStrRadix for f32 {\n     ///\n     /// # Arguments\n     ///\n-    /// * num - A string\n+    /// * src - A string\n     /// * radix - The base to use. Must lie in the range [2 .. 36]\n     ///\n     /// # Return value\n     ///\n     /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n     #[inline]\n-    fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n-        strconv::from_str_common(val, rdx, true, true, false,\n-                                 strconv::ExpNone, false, false)\n+    fn from_str_radix(src: &str, radix: uint) -> Option<f32> {\n+        strconv::from_str_radix_float(src, radix)\n     }\n }\n \n@@ -710,8 +683,8 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = from_str_hex(\"1p-123\").unwrap();\n-        let f2: f32 = from_str_hex(\"1p-111\").unwrap();\n+        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n         assert_eq!(FloatMath::ldexp(1f32, -123), f1);\n         assert_eq!(FloatMath::ldexp(1f32, -111), f2);\n \n@@ -730,8 +703,8 @@ mod tests {\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = from_str_hex(\"1p-123\").unwrap();\n-        let f2: f32 = from_str_hex(\"1p-111\").unwrap();\n+        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f32, -122));"}, {"sha": "6e8e92eb91d03ce1080490d9f60618d3a203ba12", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 17, "deletions": 49, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=ee5d2383894944dcbb3b72a130ed0abaef0e8951", "patch": "@@ -341,92 +341,60 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     r\n }\n \n-/// Convert a string in base 16 to a float.\n-/// Accepts an optional binary exponent.\n-///\n-/// This function accepts strings such as\n-///\n-/// * 'a4.fe'\n-/// * '+a4.fe', equivalent to 'a4.fe'\n-/// * '-a4.fe'\n-/// * '2b.aP128', or equivalently, '2b.ap128'\n-/// * '2b.aP-128'\n-/// * '.' (understood as 0)\n-/// * 'c.'\n-/// * '.c', or, equivalently,  '0.c'\n-/// * '+inf', 'inf', '-inf', 'NaN'\n-///\n-/// Leading and trailing whitespace represent an error.\n-///\n-/// # Arguments\n-///\n-/// * num - A string\n-///\n-/// # Return value\n-///\n-/// `None` if the string did not represent a valid number.  Otherwise,\n-/// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n #[inline]\n-pub fn from_str_hex(num: &str) -> Option<f64> {\n-    strconv::from_str_common(num, 16u, true, true, true,\n-                             strconv::ExpBin, false, false)\n+#[deprecated=\"Use `FromStrRadix::from_str_radix(src, 16)`\"]\n+pub fn from_str_hex(src: &str) -> Option<f64> {\n+    strconv::from_str_radix_float(src, 16)\n }\n \n impl FromStr for f64 {\n     /// Convert a string in base 10 to a float.\n     /// Accepts an optional decimal exponent.\n     ///\n-    /// This function accepts strings such as\n+    /// This function accepts strings such as:\n     ///\n     /// * '3.14'\n-    /// * '+3.14', equivalent to '3.14'\n     /// * '-3.14'\n     /// * '2.5E10', or equivalently, '2.5e10'\n     /// * '2.5E-10'\n     /// * '.' (understood as 0)\n     /// * '5.'\n     /// * '.5', or, equivalently,  '0.5'\n-    /// * '+inf', 'inf', '-inf', 'NaN'\n+    /// * inf', '-inf', 'NaN'\n     ///\n     /// Leading and trailing whitespace represent an error.\n     ///\n     /// # Arguments\n     ///\n-    /// * num - A string\n+    /// * src - A string\n     ///\n     /// # Return value\n     ///\n     /// `none` if the string did not represent a valid number.  Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n     #[inline]\n-    fn from_str(val: &str) -> Option<f64> {\n-        strconv::from_str_common(val, 10u, true, true, true,\n-                                 strconv::ExpDec, false, false)\n+    fn from_str(src: &str) -> Option<f64> {\n+        strconv::from_str_radix_float(src, 10u)\n     }\n }\n \n impl num::FromStrRadix for f64 {\n     /// Convert a string in a given base to a float.\n     ///\n-    /// Due to possible conflicts, this function does **not** accept\n-    /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**\n-    /// does it recognize exponents of any kind.\n-    ///\n     /// Leading and trailing whitespace represent an error.\n     ///\n     /// # Arguments\n     ///\n-    /// * num - A string\n+    /// * src - A string\n     /// * radix - The base to use. Must lie in the range [2 .. 36]\n     ///\n     /// # Return value\n     ///\n     /// `None` if the string did not represent a valid number. Otherwise,\n-    /// `Some(n)` where `n` is the floating-point number represented by `num`.\n+    /// `Some(n)` where `n` is the floating-point number represented by `src`.\n     #[inline]\n-    fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n-        strconv::from_str_common(val, rdx, true, true, false,\n-                                 strconv::ExpNone, false, false)\n+    fn from_str_radix(src: &str, radix: uint) -> Option<f64> {\n+        strconv::from_str_radix_float(src, radix)\n     }\n }\n \n@@ -712,8 +680,8 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = from_str_hex(\"1p-123\").unwrap();\n-        let f2: f64 = from_str_hex(\"1p-111\").unwrap();\n+        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n         assert_eq!(FloatMath::ldexp(1f64, -123), f1);\n         assert_eq!(FloatMath::ldexp(1f64, -111), f2);\n \n@@ -732,8 +700,8 @@ mod tests {\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = from_str_hex(\"1p-123\").unwrap();\n-        let f2: f64 = from_str_hex(\"1p-111\").unwrap();\n+        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f64, -122));"}, {"sha": "9ae146c840ae884b96e31139013061888bed6a54", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 35, "deletions": 59, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=ee5d2383894944dcbb3b72a130ed0abaef0e8951", "patch": "@@ -14,50 +14,26 @@\n \n macro_rules! int_module (($T:ty) => (\n \n-// String conversion functions and impl str -> num\n-\n-/// Parse a byte slice as a number in the given base\n-///\n-/// Yields an `Option` because `buf` may or may not actually be parseable.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let num = std::i64::parse_bytes([49,50,51,52,53,54,55,56,57], 10);\n-/// assert!(num == Some(123456789));\n-/// ```\n-#[inline]\n-#[experimental = \"might need to return Result\"]\n-pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n-    strconv::from_str_bytes_common(buf, radix, true, false, false,\n-                               strconv::ExpNone, false, false)\n-}\n-\n #[experimental = \"might need to return Result\"]\n impl FromStr for $T {\n     #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_common(s, 10u, true, false, false,\n-                             strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, 10)\n     }\n }\n \n #[experimental = \"might need to return Result\"]\n impl FromStrRadix for $T {\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_common(s, radix, true, false, false,\n-                             strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, radix)\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use super::*;\n-\n-    use i32;\n-    use str::StrSlice;\n+    use num::FromStrRadix;\n \n     #[test]\n     fn test_from_str() {\n@@ -73,33 +49,33 @@ mod tests {\n         assert_eq!(from_str::<i32>(\"-123456789\"), Some(-123456789 as i32));\n         assert_eq!(from_str::<$T>(\"-00100\"), Some(-100 as $T));\n \n-        assert!(from_str::<$T>(\" \").is_none());\n-        assert!(from_str::<$T>(\"x\").is_none());\n+        assert_eq!(from_str::<$T>(\"\"), None);\n+        assert_eq!(from_str::<$T>(\" \"), None);\n+        assert_eq!(from_str::<$T>(\"x\"), None);\n     }\n \n     #[test]\n-    fn test_parse_bytes() {\n-        use str::StrSlice;\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 10u), Some(123 as $T));\n-        assert_eq!(parse_bytes(\"1001\".as_bytes(), 2u), Some(9 as $T));\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 8u), Some(83 as $T));\n-        assert_eq!(i32::parse_bytes(\"123\".as_bytes(), 16u), Some(291 as i32));\n-        assert_eq!(i32::parse_bytes(\"ffff\".as_bytes(), 16u), Some(65535 as i32));\n-        assert_eq!(i32::parse_bytes(\"FFFF\".as_bytes(), 16u), Some(65535 as i32));\n-        assert_eq!(parse_bytes(\"z\".as_bytes(), 36u), Some(35 as $T));\n-        assert_eq!(parse_bytes(\"Z\".as_bytes(), 36u), Some(35 as $T));\n-\n-        assert_eq!(parse_bytes(\"-123\".as_bytes(), 10u), Some(-123 as $T));\n-        assert_eq!(parse_bytes(\"-1001\".as_bytes(), 2u), Some(-9 as $T));\n-        assert_eq!(parse_bytes(\"-123\".as_bytes(), 8u), Some(-83 as $T));\n-        assert_eq!(i32::parse_bytes(\"-123\".as_bytes(), 16u), Some(-291 as i32));\n-        assert_eq!(i32::parse_bytes(\"-ffff\".as_bytes(), 16u), Some(-65535 as i32));\n-        assert_eq!(i32::parse_bytes(\"-FFFF\".as_bytes(), 16u), Some(-65535 as i32));\n-        assert_eq!(parse_bytes(\"-z\".as_bytes(), 36u), Some(-35 as $T));\n-        assert_eq!(parse_bytes(\"-Z\".as_bytes(), 36u), Some(-35 as $T));\n-\n-        assert!(parse_bytes(\"Z\".as_bytes(), 35u).is_none());\n-        assert!(parse_bytes(\"-9\".as_bytes(), 2u).is_none());\n+    fn test_from_str_radix() {\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Some(65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Some(35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Some(-123 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Some(-9 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Some(-83 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Some(-291 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Some(-65535 as i32));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Some(-35 as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Some(-35 as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2), None::<$T>);\n     }\n \n     #[test]\n@@ -133,35 +109,35 @@ mod tests {\n     fn test_int_from_str_overflow() {\n         let mut i8_val: i8 = 127_i8;\n         assert_eq!(from_str::<i8>(\"127\"), Some(i8_val));\n-        assert!(from_str::<i8>(\"128\").is_none());\n+        assert_eq!(from_str::<i8>(\"128\"), None);\n \n         i8_val += 1 as i8;\n         assert_eq!(from_str::<i8>(\"-128\"), Some(i8_val));\n-        assert!(from_str::<i8>(\"-129\").is_none());\n+        assert_eq!(from_str::<i8>(\"-129\"), None);\n \n         let mut i16_val: i16 = 32_767_i16;\n         assert_eq!(from_str::<i16>(\"32767\"), Some(i16_val));\n-        assert!(from_str::<i16>(\"32768\").is_none());\n+        assert_eq!(from_str::<i16>(\"32768\"), None);\n \n         i16_val += 1 as i16;\n         assert_eq!(from_str::<i16>(\"-32768\"), Some(i16_val));\n-        assert!(from_str::<i16>(\"-32769\").is_none());\n+        assert_eq!(from_str::<i16>(\"-32769\"), None);\n \n         let mut i32_val: i32 = 2_147_483_647_i32;\n         assert_eq!(from_str::<i32>(\"2147483647\"), Some(i32_val));\n-        assert!(from_str::<i32>(\"2147483648\").is_none());\n+        assert_eq!(from_str::<i32>(\"2147483648\"), None);\n \n         i32_val += 1 as i32;\n         assert_eq!(from_str::<i32>(\"-2147483648\"), Some(i32_val));\n-        assert!(from_str::<i32>(\"-2147483649\").is_none());\n+        assert_eq!(from_str::<i32>(\"-2147483649\"), None);\n \n         let mut i64_val: i64 = 9_223_372_036_854_775_807_i64;\n         assert_eq!(from_str::<i64>(\"9223372036854775807\"), Some(i64_val));\n-        assert!(from_str::<i64>(\"9223372036854775808\").is_none());\n+        assert_eq!(from_str::<i64>(\"9223372036854775808\"), None);\n \n         i64_val += 1 as i64;\n         assert_eq!(from_str::<i64>(\"-9223372036854775808\"), Some(i64_val));\n-        assert!(from_str::<i64>(\"-9223372036854775809\").is_none());\n+        assert_eq!(from_str::<i64>(\"-9223372036854775809\"), None);\n     }\n }\n "}, {"sha": "7a02d8d77b0b1db19b9bbf8e1e6f903c7a231aba", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 186, "deletions": 346, "changes": 532, "blob_url": "https://github.com/rust-lang/rust/blob/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=ee5d2383894944dcbb3b72a130ed0abaef0e8951", "patch": "@@ -13,14 +13,14 @@\n #![allow(missing_docs)]\n \n use char;\n-use clone::Clone;\n-use num::{NumCast, Zero, One, cast, Int};\n-use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n+use char::Char;\n+use from_str::from_str;\n+use iter::Iterator;\n use num;\n-use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+use num::{Int, Bounded};\n+use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use option::{None, Option, Some};\n use slice::{ImmutableSlice, MutableSlice, CloneableVector};\n-use std::cmp::{PartialOrd, PartialEq};\n use str::StrSlice;\n use string::String;\n use vec::Vec;\n@@ -67,81 +67,6 @@ pub enum SignFormat {\n     SignAll,\n }\n \n-/// Encompasses functions used by the string converter.\n-pub trait NumStrConv {\n-    /// Returns the NaN value.\n-    fn nan()      -> Option<Self>;\n-\n-    /// Returns the infinite value.\n-    fn inf()      -> Option<Self>;\n-\n-    /// Returns the negative infinite value.\n-    fn neg_inf()  -> Option<Self>;\n-\n-    /// Returns -0.0.\n-    fn neg_zero() -> Option<Self>;\n-\n-    /// Rounds the number toward zero.\n-    fn round_to_zero(&self)   -> Self;\n-\n-    /// Returns the fractional part of the number.\n-    fn fractional_part(&self) -> Self;\n-}\n-\n-macro_rules! impl_NumStrConv_Floating (($t:ty) => (\n-    impl NumStrConv for $t {\n-        #[inline]\n-        fn nan()      -> Option<$t> { Some( 0.0 / 0.0) }\n-        #[inline]\n-        fn inf()      -> Option<$t> { Some( 1.0 / 0.0) }\n-        #[inline]\n-        fn neg_inf()  -> Option<$t> { Some(-1.0 / 0.0) }\n-        #[inline]\n-        fn neg_zero() -> Option<$t> { Some(-0.0      ) }\n-\n-        #[inline]\n-        fn round_to_zero(&self) -> $t { self.trunc() }\n-        #[inline]\n-        fn fractional_part(&self) -> $t { self.fract() }\n-    }\n-))\n-\n-macro_rules! impl_NumStrConv_Integer (($t:ty) => (\n-    impl NumStrConv for $t {\n-        #[inline] fn nan()      -> Option<$t> { None }\n-        #[inline] fn inf()      -> Option<$t> { None }\n-        #[inline] fn neg_inf()  -> Option<$t> { None }\n-        #[inline] fn neg_zero() -> Option<$t> { None }\n-\n-        #[inline] fn round_to_zero(&self)   -> $t { *self }\n-        #[inline] fn fractional_part(&self) -> $t {     0 }\n-    }\n-))\n-\n-// FIXME: #4955\n-// Replace by two generic impls for traits 'Integral' and 'Floating'\n-impl_NumStrConv_Floating!(f32)\n-impl_NumStrConv_Floating!(f64)\n-\n-impl_NumStrConv_Integer!(int)\n-impl_NumStrConv_Integer!(i8)\n-impl_NumStrConv_Integer!(i16)\n-impl_NumStrConv_Integer!(i32)\n-impl_NumStrConv_Integer!(i64)\n-\n-impl_NumStrConv_Integer!(uint)\n-impl_NumStrConv_Integer!(u8)\n-impl_NumStrConv_Integer!(u16)\n-impl_NumStrConv_Integer!(u32)\n-impl_NumStrConv_Integer!(u64)\n-\n-\n-// Special value strings as [u8] consts.\n-static INF_BUF:     [u8, ..3] = [b'i', b'n', b'f'];\n-static POS_INF_BUF: [u8, ..4] = [b'+', b'i', b'n', b'f'];\n-static NEG_INF_BUF: [u8, ..4] = [b'-', b'i', b'n', b'f'];\n-static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n-\n /**\n  * Converts an integral number to its string representation as a byte vector.\n  * This is meant to be a common base implementation for all integral string\n@@ -170,10 +95,10 @@ static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n-    let _0: T = Zero::zero();\n+    let _0: T = num::zero();\n \n     let neg = num < _0;\n-    let radix_gen: T = cast(radix).unwrap();\n+    let radix_gen: T = num::cast(radix).unwrap();\n \n     let mut deccum = num;\n     // This is just for integral types, the largest of which is a u64. The\n@@ -255,8 +180,7 @@ fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8\n  * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n-pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n-                                  Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+pub fn float_to_str_bytes_common<T: Float>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n         ) -> (Vec<u8>, bool) {\n@@ -271,8 +195,8 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n         _ => ()\n     }\n \n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n+    let _0: T = num::zero();\n+    let _1: T = num::one();\n \n     match num.classify() {\n         FPNaN => { return (b\"NaN\".to_vec(), true); }\n@@ -293,7 +217,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n \n     let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n     let mut buf = Vec::new();\n-    let radix_gen: T   = cast(radix as int).unwrap();\n+    let radix_gen: T = num::cast(radix as int).unwrap();\n \n     let (num, exp) = match exp_format {\n         ExpNone => (num, 0i32),\n@@ -302,12 +226,12 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                 (num, 0i32)\n             } else {\n                 let (exp, exp_base) = match exp_format {\n-                    ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n-                    ExpBin => (num.abs().log2().floor(), cast::<f64, T>(2.0f64).unwrap()),\n+                    ExpDec => (num.abs().log10().floor(), num::cast::<f64, T>(10.0f64).unwrap()),\n+                    ExpBin => (num.abs().log2().floor(), num::cast::<f64, T>(2.0f64).unwrap()),\n                     ExpNone => unreachable!()\n                 };\n \n-                (num / exp_base.powf(exp), cast::<T, i32>(exp).unwrap())\n+                (num / exp_base.powf(exp), num::cast::<T, i32>(exp).unwrap())\n             }\n         }\n     };\n@@ -488,8 +412,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline]\n-pub fn float_to_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+NumStrConv+Float+\n-                             Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+pub fn float_to_str_common<T: Float>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n         ) -> (String, bool) {\n@@ -501,311 +424,228 @@ pub fn float_to_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+NumStrConv+Fl\n // Some constants for from_str_bytes_common's input validation,\n // they define minimum radix values for which the character is a valid digit.\n static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n-static DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n-/**\n- * Parses a byte slice as a number. This is meant to\n- * be a common base implementation for all numeric string conversion\n- * functions like `from_str()` or `from_str_radix()`.\n- *\n- * # Arguments\n- * - `buf`        - The byte slice to parse.\n- * - `radix`      - Which base to parse the number as. Accepts 2-36.\n- * - `negative`   - Whether to accept negative numbers.\n- * - `fractional` - Whether to accept numbers with fractional parts.\n- * - `special`    - Whether to accept special values like `inf`\n- *                  and `NaN`. Can conflict with `radix`, see Failure.\n- * - `exponent`   - Which exponent format to accept. Options are:\n- *     - `ExpNone`: No Exponent, accepts just plain numbers like `42` or\n- *                  `-8.2`.\n- *     - `ExpDec`:  Accepts numbers with a decimal exponent like `42e5` or\n- *                  `8.2E-2`. The exponent string itself is always base 10.\n- *                  Can conflict with `radix`, see Failure.\n- *     - `ExpBin`:  Accepts numbers with a binary exponent like `42P-8` or\n- *                  `FFp128`. The exponent string itself is always base 10.\n- *                  Can conflict with `radix`, see Failure.\n- * - `empty_zero` - Whether to accept an empty `buf` as a 0 or not.\n- * - `ignore_underscores` - Whether all underscores within the string should\n- *                          be ignored.\n- *\n- * # Return value\n- * Returns `Some(n)` if `buf` parses to a number n without overflowing, and\n- * `None` otherwise, depending on the constraints set by the remaining\n- * arguments.\n- *\n- * # Failure\n- * - Fails if `radix` < 2 or `radix` > 36.\n- * - Fails if `radix` > 14 and `exponent` is `ExpDec` due to conflict\n- *   between digit and exponent sign `'e'`.\n- * - Fails if `radix` > 25 and `exponent` is `ExpBin` due to conflict\n- *   between digit and exponent sign `'p'`.\n- * - Fails if `radix` > 18 and `special == true` due to conflict\n- *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n- */\n-pub fn from_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+\n-                                    Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n-                                    NumStrConv+Clone>(\n-        buf: &[u8], radix: uint, negative: bool, fractional: bool,\n-        special: bool, exponent: ExponentFormat, empty_zero: bool,\n-        ignore_underscores: bool\n-        ) -> Option<T> {\n-    match exponent {\n-        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n-                    use of 'e' as decimal exponent\", radix),\n-        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n-                    use of 'p' as binary exponent\", radix),\n-        _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n-          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n-                    special values 'inf' and 'NaN'\", radix),\n-        _ if (radix as int) < 2\n-          => panic!(\"from_str_bytes_common: radix {} to low, \\\n-                    must lie in the range [2, 36]\", radix),\n-        _ if (radix as int) > 36\n-          => panic!(\"from_str_bytes_common: radix {} to high, \\\n-                    must lie in the range [2, 36]\", radix),\n-        _ => ()\n-    }\n-\n-    let _0: T = Zero::zero();\n-    let _1: T = One::one();\n-    let radix_gen: T = cast(radix as int).unwrap();\n-\n-    let len = buf.len();\n-\n-    if len == 0 {\n-        if empty_zero {\n-            return Some(_0);\n-        } else {\n-            return None;\n-        }\n+pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n+   assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n+\n+    let _0: T = num::zero();\n+    let _1: T = num::one();\n+    let radix_t: T = num::cast(radix as int).unwrap();\n+\n+    // Special values\n+    match src {\n+        \"inf\"   => return Some(Float::infinity()),\n+        \"-inf\"  => return Some(Float::neg_infinity()),\n+        \"NaN\"   => return Some(Float::nan()),\n+        _       => {},\n     }\n \n-    if special {\n-        if buf == INF_BUF || buf == POS_INF_BUF {\n-            return NumStrConv::inf();\n-        } else if buf == NEG_INF_BUF {\n-            if negative {\n-                return NumStrConv::neg_inf();\n-            } else {\n-                return None;\n-            }\n-        } else if buf == NAN_BUF {\n-            return NumStrConv::nan();\n-        }\n-    }\n-\n-    let (start, accum_positive) = match buf[0] as char {\n-      '-' if !negative => return None,\n-      '-' => (1u, false),\n-      '+' => (1u, true),\n-       _  => (0u, true)\n+    let (is_positive, src) =  match src.slice_shift_char() {\n+        (None, _)        => return None,\n+        (Some('-'), \"\")  => return None,\n+        (Some('-'), src) => (false, src),\n+        (Some(_), _)     => (true,  src),\n     };\n \n-    // Initialize accumulator with signed zero for floating point parsing to\n-    // work\n-    let mut accum      = if accum_positive { _0.clone() } else { -_1 * _0};\n-    let mut last_accum = accum.clone(); // Necessary to detect overflow\n-    let mut i          = start;\n-    let mut exp_found  = false;\n-\n-    // Parse integer part of number\n-    while i < len {\n-        let c = buf[i] as char;\n-\n-        match char::to_digit(c, radix) {\n+    // The significand to accumulate\n+    let mut sig = if is_positive { _0 } else { -_1 };\n+    // Necessary to detect overflow\n+    let mut prev_sig = sig;\n+    let mut cs = src.chars().enumerate();\n+    // Exponent prefix and exponent index offset\n+    let mut exp_info = None::<(char, uint)>;\n+\n+    // Parse the integer part of the significand\n+    for (i, c) in cs {\n+        match c.to_digit(radix) {\n             Some(digit) => {\n-                // shift accum one digit left\n-                accum = accum * radix_gen.clone();\n+                // shift significand one digit left\n+                sig = sig * radix_t;\n \n                 // add/subtract current digit depending on sign\n-                if accum_positive {\n-                    accum = accum + cast(digit as int).unwrap();\n+                if is_positive {\n+                    sig = sig + num::cast(digit as int).unwrap();\n                 } else {\n-                    accum = accum - cast(digit as int).unwrap();\n+                    sig = sig - num::cast(digit as int).unwrap();\n                 }\n \n                 // Detect overflow by comparing to last value, except\n                 // if we've not seen any non-zero digits.\n-                if last_accum != _0 {\n-                    if accum_positive && accum <= last_accum { return NumStrConv::inf(); }\n-                    if !accum_positive && accum >= last_accum { return NumStrConv::neg_inf(); }\n+                if prev_sig != _0 {\n+                    if is_positive && sig <= prev_sig\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && sig >= prev_sig\n+                        { return Some(Float::neg_infinity()); }\n \n                     // Detect overflow by reversing the shift-and-add process\n-                    if accum_positive &&\n-                        (last_accum != ((accum - cast(digit as int).unwrap())/radix_gen.clone())) {\n-                        return NumStrConv::inf();\n-                    }\n-                    if !accum_positive &&\n-                        (last_accum != ((accum + cast(digit as int).unwrap())/radix_gen.clone())) {\n-                        return NumStrConv::neg_inf();\n-                    }\n+                    let digit: T = num::cast(digit as int).unwrap();\n+                    if is_positive && (prev_sig != ((sig - digit) / radix_t))\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && (prev_sig != ((sig + digit) / radix_t))\n+                        { return Some(Float::neg_infinity()); }\n                 }\n-                last_accum = accum.clone();\n-            }\n+                prev_sig = sig;\n+            },\n             None => match c {\n-                '_' if ignore_underscores => {}\n                 'e' | 'E' | 'p' | 'P' => {\n-                    exp_found = true;\n-                    break;                       // start of exponent\n-                }\n-                '.' if fractional => {\n-                    i += 1u;                     // skip the '.'\n-                    break;                       // start of fractional part\n-                }\n-                _ => return None                 // invalid number\n-            }\n+                    exp_info = Some((c, i + 1));\n+                    break;  // start of exponent\n+                },\n+                '.' => {\n+                    break;  // start of fractional part\n+                },\n+                _ => {\n+                    return None;\n+                },\n+            },\n         }\n-\n-        i += 1u;\n     }\n \n-    // Parse fractional part of number\n-    // Skip if already reached start of exponent\n-    if !exp_found {\n-        let mut power = _1.clone();\n-\n-        while i < len {\n-            let c = buf[i] as char;\n-\n-            match char::to_digit(c, radix) {\n+    // If we are not yet at the exponent parse the fractional\n+    // part of the significand\n+    if exp_info.is_none() {\n+        let mut power = _1;\n+        for (i, c) in cs {\n+            match c.to_digit(radix) {\n                 Some(digit) => {\n+                    let digit: T = num::cast(digit).unwrap();\n                     // Decrease power one order of magnitude\n-                    power = power / radix_gen;\n-\n-                    let digit_t: T = cast(digit).unwrap();\n-\n+                    power = power / radix_t;\n                     // add/subtract current digit depending on sign\n-                    if accum_positive {\n-                        accum = accum + digit_t * power;\n+                    sig = if is_positive {\n+                        sig + digit * power\n                     } else {\n-                        accum = accum - digit_t * power;\n-                    }\n-\n+                        sig - digit * power\n+                    };\n                     // Detect overflow by comparing to last value\n-                    if accum_positive && accum < last_accum { return NumStrConv::inf(); }\n-                    if !accum_positive && accum > last_accum { return NumStrConv::neg_inf(); }\n-                    last_accum = accum.clone();\n-                }\n+                    if is_positive && sig < prev_sig\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && sig > prev_sig\n+                        { return Some(Float::neg_infinity()); }\n+                    prev_sig = sig;\n+                },\n                 None => match c {\n-                    '_' if ignore_underscores => {}\n                     'e' | 'E' | 'p' | 'P' => {\n-                        exp_found = true;\n-                        break;                   // start of exponent\n-                    }\n-                    _ => return None             // invalid number\n-                }\n+                        exp_info = Some((c, i + 1));\n+                        break; // start of exponent\n+                    },\n+                    _ => {\n+                        return None; // invalid number\n+                    },\n+                },\n             }\n-\n-            i += 1u;\n         }\n     }\n \n-    // Special case: buf not empty, but does not contain any digit in front\n-    // of the exponent sign -> number is empty string\n-    if i == start {\n-        if empty_zero {\n-            return Some(_0);\n-        } else {\n-            return None;\n-        }\n-    }\n+    // Parse and calculate the exponent\n+    let exp = match exp_info {\n+        Some((c, offset)) => {\n+            let base: T = match c {\n+                'E' | 'e' if radix == 10 => num::cast(10u).unwrap(),\n+                'P' | 'p' if radix == 16 => num::cast(2u).unwrap(),\n+                _ => return None,\n+            };\n \n-    let mut multiplier = _1.clone();\n+            // Parse the exponent as decimal integer\n+            let src = src[offset..];\n+            let (is_positive, exp) = match src.slice_shift_char() {\n+                (Some('-'), src) => (false, from_str::<uint>(src)),\n+                (Some('+'), src) => (true,  from_str::<uint>(src)),\n+                (Some(_), _)     => (true,  from_str::<uint>(src)),\n+                (None, _)        => return None,\n+            };\n \n-    if exp_found {\n-        let c = buf[i] as char;\n-        let base: T = match (c, exponent) {\n-            // c is never _ so don't need to handle specially\n-            ('e', ExpDec) | ('E', ExpDec) => cast(10u).unwrap(),\n-            ('p', ExpBin) | ('P', ExpBin) => cast(2u).unwrap(),\n-            _ => return None // char doesn't fit given exponent format\n-        };\n+            match (is_positive, exp) {\n+                (true,  Some(exp)) => num::pow(base, exp),\n+                (false, Some(exp)) => _1 / num::pow(base, exp),\n+                (_, None)          => return None,\n+            }\n+        },\n+        None => _1, // no exponent\n+    };\n+\n+    Some(sig * exp)\n+}\n \n-        // parse remaining bytes as decimal integer,\n-        // skipping the exponent char\n-        let exp: Option<int> = from_str_bytes_common(\n-            buf[i+1..len], 10, true, false, false, ExpNone, false,\n-            ignore_underscores);\n+pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n+   assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n \n-        match exp {\n-            Some(exp_pow) => {\n-                multiplier = if exp_pow < 0 {\n-                    _1 / num::pow(base, (-exp_pow.to_int().unwrap()) as uint)\n-                } else {\n-                    num::pow(base, exp_pow.to_int().unwrap() as uint)\n-                }\n-            }\n-            None => return None // invalid exponent -> invalid number\n-        }\n+    fn cast<T: Int>(x: uint) -> T {\n+        num::cast(x).unwrap()\n     }\n \n-    Some(accum * multiplier)\n-}\n+    let _0: T = num::zero();\n+    let _1: T = num::one();\n+    let is_signed = _0 > Bounded::min_value();\n \n-/**\n- * Parses a string as a number. This is a wrapper for\n- * `from_str_bytes_common()`, for details see there.\n- */\n-#[inline]\n-pub fn from_str_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Div<T,T>+Mul<T,T>+\n-                              Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv+Clone>(\n-        buf: &str, radix: uint, negative: bool, fractional: bool,\n-        special: bool, exponent: ExponentFormat, empty_zero: bool,\n-        ignore_underscores: bool\n-        ) -> Option<T> {\n-    from_str_bytes_common(buf.as_bytes(), radix, negative,\n-                          fractional, special, exponent, empty_zero,\n-                          ignore_underscores)\n+    let (is_positive, src) =  match src.slice_shift_char() {\n+        (Some('-'), src) if is_signed => (false, src),\n+        (Some(_), _) => (true, src),\n+        (None, _) => return None,\n+    };\n+\n+    let mut xs = src.chars().map(|c| {\n+        c.to_digit(radix).map(cast)\n+    });\n+    let radix = cast(radix);\n+    let mut result = _0;\n+\n+    if is_positive {\n+        for x in xs {\n+            let x = match x {\n+                Some(x) => x,\n+                None => return None,\n+            };\n+            result = match result.checked_mul(&radix) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+            result = match result.checked_add(&x) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+        }\n+    } else {\n+        for x in xs {\n+            let x = match x {\n+                Some(x) => x,\n+                None => return None,\n+            };\n+            result = match result.checked_mul(&radix) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+            result = match result.checked_sub(&x) {\n+                Some(result) => result,\n+                None => return None,\n+            };\n+        }\n+    }\n+\n+    Some(result)\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n     use option::*;\n-\n-    #[test]\n-    fn from_str_ignore_underscores() {\n-        let s : Option<u8> = from_str_common(\"__1__\", 2, false, false, false,\n-                                             ExpNone, false, true);\n-        assert_eq!(s, Some(1u8));\n-\n-        let n : Option<u8> = from_str_common(\"__1__\", 2, false, false, false,\n-                                             ExpNone, false, false);\n-        assert_eq!(n, None);\n-\n-        let f : Option<f32> = from_str_common(\"_1_._5_e_1_\", 10, false, true, false,\n-                                              ExpDec, false, true);\n-        assert_eq!(f, Some(1.5e1f32));\n-    }\n-\n-    #[test]\n-    fn from_str_issue5770() {\n-        // try to parse 0b1_1111_1111 = 511 as a u8. Caused problems\n-        // since 255*2+1 == 255 (mod 256) so the overflow wasn't\n-        // detected.\n-        let n : Option<u8> = from_str_common(\"111111111\", 2, false, false, false,\n-                                             ExpNone, false, false);\n-        assert_eq!(n, None);\n-    }\n+    use num::Float;\n \n     #[test]\n     fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_common(\"1000\", 10, false, false, false,\n-                                            ExpNone, false, false);\n+        let u : Option<u8> = from_str_radix_int(\"1000\", 10);\n         assert_eq!(u, None);\n-        let s : Option<i16> = from_str_common(\"80000\", 10, false, false, false,\n-                                             ExpNone, false, false);\n+        let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n         assert_eq!(s, None);\n-        let f : Option<f32> = from_str_common(\n-            \"10000000000000000000000000000000000000000\", 10, false, false, false,\n-            ExpNone, false, false);\n-        assert_eq!(f, NumStrConv::inf())\n-        let fe : Option<f32> = from_str_common(\"1e40\", 10, false, false, false,\n-                                            ExpDec, false, false);\n-        assert_eq!(fe, NumStrConv::inf())\n+        let f : Option<f32> = from_str_radix_float(\"10000000000000000000000000000000000000000\", 10);\n+        assert_eq!(f, Some(Float::infinity()))\n+        let fe : Option<f32> = from_str_radix_float(\"1e40\", 10);\n+        assert_eq!(fe, Some(Float::infinity()))\n     }\n }\n "}, {"sha": "aa8e58bab0286a9b3cc5561d7d28b85e7e98329a", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=ee5d2383894944dcbb3b72a130ed0abaef0e8951", "patch": "@@ -15,40 +15,19 @@\n \n macro_rules! uint_module (($T:ty) => (\n \n-// String conversion functions and impl str -> num\n-\n-/// Parse a byte slice as a number in the given base\n-///\n-/// Yields an `Option` because `buf` may or may not actually be parseable.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let num = std::uint::parse_bytes([49,50,51,52,53,54,55,56,57], 10);\n-/// assert!(num == Some(123456789));\n-/// ```\n-#[inline]\n-#[experimental = \"might need to return Result\"]\n-pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<$T> {\n-    strconv::from_str_bytes_common(buf, radix, false, false, false,\n-                                   strconv::ExpNone, false, false)\n-}\n-\n #[experimental = \"might need to return Result\"]\n impl FromStr for $T {\n     #[inline]\n     fn from_str(s: &str) -> Option<$T> {\n-        strconv::from_str_common(s, 10u, false, false, false,\n-                                 strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, 10)\n     }\n }\n \n #[experimental = \"might need to return Result\"]\n impl FromStrRadix for $T {\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint) -> Option<$T> {\n-        strconv::from_str_common(s, radix, false, false, false,\n-                                 strconv::ExpNone, false, false)\n+        strconv::from_str_radix_int(s, radix)\n     }\n }\n \n@@ -85,10 +64,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use super::*;\n-\n-    use str::StrSlice;\n-    use u16;\n+    use num::FromStrRadix;\n \n     #[test]\n     pub fn test_from_str() {\n@@ -98,23 +74,22 @@ mod tests {\n         assert_eq!(from_str::<u32>(\"123456789\"), Some(123456789 as u32));\n         assert_eq!(from_str::<$T>(\"00100\"), Some(100u as $T));\n \n-        assert!(from_str::<$T>(\"\").is_none());\n-        assert!(from_str::<$T>(\" \").is_none());\n-        assert!(from_str::<$T>(\"x\").is_none());\n+        assert_eq!(from_str::<$T>(\"\"), None);\n+        assert_eq!(from_str::<$T>(\" \"), None);\n+        assert_eq!(from_str::<$T>(\"x\"), None);\n     }\n \n     #[test]\n     pub fn test_parse_bytes() {\n-        use str::StrSlice;\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 10u), Some(123u as $T));\n-        assert_eq!(parse_bytes(\"1001\".as_bytes(), 2u), Some(9u as $T));\n-        assert_eq!(parse_bytes(\"123\".as_bytes(), 8u), Some(83u as $T));\n-        assert_eq!(u16::parse_bytes(\"123\".as_bytes(), 16u), Some(291u as u16));\n-        assert_eq!(u16::parse_bytes(\"ffff\".as_bytes(), 16u), Some(65535u as u16));\n-        assert_eq!(parse_bytes(\"z\".as_bytes(), 36u), Some(35u as $T));\n-\n-        assert!(parse_bytes(\"Z\".as_bytes(), 10u).is_none());\n-        assert!(parse_bytes(\"_\".as_bytes(), 2u).is_none());\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Some(123u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Some(9u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Some(83u as $T));\n+        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Some(291u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Some(65535u as u16));\n+        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Some(35u as $T));\n+\n+        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10), None::<$T>);\n+        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2), None::<$T>);\n     }\n \n     #[test]\n@@ -148,35 +123,35 @@ mod tests {\n     fn test_uint_from_str_overflow() {\n         let mut u8_val: u8 = 255_u8;\n         assert_eq!(from_str::<u8>(\"255\"), Some(u8_val));\n-        assert!(from_str::<u8>(\"256\").is_none());\n+        assert_eq!(from_str::<u8>(\"256\"), None);\n \n         u8_val += 1 as u8;\n         assert_eq!(from_str::<u8>(\"0\"), Some(u8_val));\n-        assert!(from_str::<u8>(\"-1\").is_none());\n+        assert_eq!(from_str::<u8>(\"-1\"), None);\n \n         let mut u16_val: u16 = 65_535_u16;\n         assert_eq!(from_str::<u16>(\"65535\"), Some(u16_val));\n-        assert!(from_str::<u16>(\"65536\").is_none());\n+        assert_eq!(from_str::<u16>(\"65536\"), None);\n \n         u16_val += 1 as u16;\n         assert_eq!(from_str::<u16>(\"0\"), Some(u16_val));\n-        assert!(from_str::<u16>(\"-1\").is_none());\n+        assert_eq!(from_str::<u16>(\"-1\"), None);\n \n         let mut u32_val: u32 = 4_294_967_295_u32;\n         assert_eq!(from_str::<u32>(\"4294967295\"), Some(u32_val));\n-        assert!(from_str::<u32>(\"4294967296\").is_none());\n+        assert_eq!(from_str::<u32>(\"4294967296\"), None);\n \n         u32_val += 1 as u32;\n         assert_eq!(from_str::<u32>(\"0\"), Some(u32_val));\n-        assert!(from_str::<u32>(\"-1\").is_none());\n+        assert_eq!(from_str::<u32>(\"-1\"), None);\n \n         let mut u64_val: u64 = 18_446_744_073_709_551_615_u64;\n         assert_eq!(from_str::<u64>(\"18446744073709551615\"), Some(u64_val));\n-        assert!(from_str::<u64>(\"18446744073709551616\").is_none());\n+        assert_eq!(from_str::<u64>(\"18446744073709551616\"), None);\n \n         u64_val += 1 as u64;\n         assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n-        assert!(from_str::<u64>(\"-1\").is_none());\n+        assert_eq!(from_str::<u64>(\"-1\"), None);\n     }\n }\n "}, {"sha": "7fa13d6074d43129835958260163b6f96be36e20", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee5d2383894944dcbb3b72a130ed0abaef0e8951/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=ee5d2383894944dcbb3b72a130ed0abaef0e8951", "patch": "@@ -24,7 +24,6 @@ extern crate time;\n use std::os;\n use std::result::{Ok, Err};\n use std::task;\n-use std::uint;\n \n fn fib(n: int) -> int {\n     fn pfib(tx: &Sender<int>, n: int) {\n@@ -102,8 +101,7 @@ fn main() {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = uint::parse_bytes(args[1].as_bytes(), 10u).unwrap() as\n-            int;\n+        let max = from_str::<uint>(args[1].as_slice()).unwrap() as int;\n \n         let num_trials = 10;\n "}]}