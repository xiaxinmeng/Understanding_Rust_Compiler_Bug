{"sha": "27e944231c3ca26add3c1a801fbe1c6de79f51fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZTk0NDIzMWMzY2EyNmFkZDNjMWE4MDFmYmUxYzZkZTc5ZjUxZmQ=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-12-05T05:03:20Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-12-14T05:00:02Z"}, "message": "Begin changing vectors to const generics", "tree": {"sha": "425ce97bea14b6ca93ad53dc454d9df7ad81b903", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/425ce97bea14b6ca93ad53dc454d9df7ad81b903"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27e944231c3ca26add3c1a801fbe1c6de79f51fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27e944231c3ca26add3c1a801fbe1c6de79f51fd", "html_url": "https://github.com/rust-lang/rust/commit/27e944231c3ca26add3c1a801fbe1c6de79f51fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27e944231c3ca26add3c1a801fbe1c6de79f51fd/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35b9ab9f5cf446712ea74ce8603267f9338c4440", "url": "https://api.github.com/repos/rust-lang/rust/commits/35b9ab9f5cf446712ea74ce8603267f9338c4440", "html_url": "https://github.com/rust-lang/rust/commit/35b9ab9f5cf446712ea74ce8603267f9338c4440"}], "stats": {"total": 650, "additions": 243, "deletions": 407}, "files": [{"sha": "16b8f3b95d9ab1e2440bbb819ea07c95f46d01c2", "filename": "crates/core_simd/src/fmt.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -30,18 +30,18 @@ debug_wrapper! {\n }\n \n macro_rules! impl_fmt_trait {\n-    { $($type:ty => $(($trait:ident, $format:ident)),*;)* } => {\n+    { $($type:ident => $(($trait:ident, $format:ident)),*;)* } => {\n         $( // repeat type\n             $( // repeat trait\n-                impl core::fmt::$trait for $type {\n+                impl<const LANES: usize> core::fmt::$trait for crate::$type<LANES> {\n                     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                         $format(self.as_ref(), f)\n                     }\n                 }\n             )*\n         )*\n     };\n-    { integers: $($type:ty,)* } => {\n+    { integers: $($type:ident,)* } => {\n         impl_fmt_trait! {\n             $($type =>\n               (Debug, format),\n@@ -54,7 +54,7 @@ macro_rules! impl_fmt_trait {\n             )*\n         }\n     };\n-    { floats: $($type:ty,)* } => {\n+    { floats: $($type:ident,)* } => {\n         impl_fmt_trait! {\n             $($type =>\n               (Debug, format),\n@@ -63,7 +63,7 @@ macro_rules! impl_fmt_trait {\n             )*\n         }\n     };\n-    { masks: $($type:ty,)* } => {\n+    { masks: $($type:ident,)* } => {\n         impl_fmt_trait! {\n             $($type =>\n               (Debug, format);\n@@ -74,32 +74,12 @@ macro_rules! impl_fmt_trait {\n \n impl_fmt_trait! {\n     integers:\n-        crate::u8x8,    crate::u8x16,   crate::u8x32,   crate::u8x64,\n-        crate::i8x8,    crate::i8x16,   crate::i8x32,   crate::i8x64,\n-        crate::u16x4,   crate::u16x8,   crate::u16x16,  crate::u16x32,\n-        crate::i16x4,   crate::i16x8,   crate::i16x16,  crate::i16x32,\n-        crate::u32x2,   crate::u32x4,   crate::u32x8,   crate::u32x16,\n-        crate::i32x2,   crate::i32x4,   crate::i32x8,   crate::i32x16,\n-        crate::u64x2,   crate::u64x4,   crate::u64x8,\n-        crate::i64x2,   crate::i64x4,   crate::i64x8,\n-        crate::u128x2,  crate::u128x4,\n-        crate::i128x2,  crate::i128x4,\n-        crate::usizex2, crate::usizex4, crate::usizex8,\n-        crate::isizex2, crate::isizex4, crate::isizex8,\n+        SimdU8, SimdU16, SimdU32, SimdU64, SimdU128,\n+        SimdI8, SimdI16, SimdI32, SimdI64, SimdI128,\n+        SimdUsize, SimdIsize,\n }\n \n impl_fmt_trait! {\n     floats:\n-        crate::f32x2, crate::f32x4, crate::f32x8, crate::f32x16,\n-        crate::f64x2, crate::f64x4, crate::f64x8,\n-}\n-\n-impl_fmt_trait! {\n-    masks:\n-        crate::masks::wide::m8x8,    crate::masks::wide::m8x16,   crate::masks::wide::m8x32,   crate::masks::wide::m8x64,\n-        crate::masks::wide::m16x4,   crate::masks::wide::m16x8,   crate::masks::wide::m16x16,  crate::masks::wide::m16x32,\n-        crate::masks::wide::m32x2,   crate::masks::wide::m32x4,   crate::masks::wide::m32x8,   crate::masks::wide::m32x16,\n-        crate::masks::wide::m64x2,   crate::masks::wide::m64x4,   crate::masks::wide::m64x8,\n-        crate::masks::wide::m128x2,  crate::masks::wide::m128x4,\n-        crate::masks::wide::msizex2, crate::masks::wide::msizex4, crate::masks::wide::msizex8,\n+        SimdF32, SimdF64,\n }"}, {"sha": "ba5e4db931280bd41b045fbaa3ed94e327c6a7c0", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,5 +1,5 @@\n #![no_std]\n-#![feature(repr_simd, platform_intrinsics, link_llvm_intrinsics, simd_ffi)]\n+#![feature(repr_simd, platform_intrinsics, link_llvm_intrinsics, simd_ffi, min_const_generics)]\n #![warn(missing_docs)]\n //! Portable SIMD module.\n \n@@ -8,10 +8,11 @@ mod macros;\n \n mod fmt;\n mod intrinsics;\n-mod ops;\n+//mod ops;\n+//mod round;\n \n-pub mod masks;\n-pub use masks::opaque::*;\n+//pub mod masks;\n+//pub use masks::opaque::*;\n \n mod vectors_u8;\n pub use vectors_u8::*;\n@@ -44,4 +45,15 @@ pub use vectors_f32::*;\n mod vectors_f64;\n pub use vectors_f64::*;\n \n-mod round;\n+//mod vectors_mask8;\n+//pub use vectors_mask8::*;\n+//mod vectors_mask16;\n+//pub use vectors_mask16::*;\n+//mod vectors_mask32;\n+//pub use vectors_mask32::*;\n+//mod vectors_mask64;\n+//pub use vectors_mask64::*;\n+//mod vectors_mask128;\n+//pub use vectors_mask128::*;\n+//mod vectors_masksize;\n+//pub use vectors_masksize::*;"}, {"sha": "abf165c78b2adb2d3d6faa7934e4c5869d95ba35", "filename": "crates/core_simd/src/macros.rs", "status": "modified", "additions": 89, "deletions": 174, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmacros.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -136,73 +136,110 @@ macro_rules! call_counting_args {\n }\n \n /// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! base_vector_traits {\n-    { $name:path => [$type:ty; $lanes:literal] } => {\n-        impl Copy for $name {}\n+macro_rules! impl_vector {\n+    { $name:ident, $type:ty } => {\n+        impl<const LANES: usize> $name<LANES> {\n+            /// Construct a vector by setting all lanes to the given value.\n+            pub const fn splat(value: $type) -> Self {\n+                Self([value; LANES])\n+            }\n+\n+            pub const fn as_slice(&self) -> &[$type] {\n+                &self.0\n+            }\n+\n+            pub fn as_mut_slice(&mut self) -> &mut [$type] {\n+                &mut self.0\n+            }\n+\n+            pub const fn as_ptr(&self) -> *const $type {\n+                self.0.as_ptr()\n+            }\n+\n+            pub fn as_mut_ptr(&mut self) -> *mut $type {\n+                self.0.as_mut_ptr()\n+            }\n \n-        impl Clone for $name {\n+            pub const fn from_array(array: [$type; LANES]) -> Self {\n+                Self(array)\n+            }\n+\n+            pub const fn to_array(self) -> [$type; LANES] {\n+                self.0\n+            }\n+        }\n+\n+        impl<const LANES: usize> Copy for $name<LANES> {}\n+\n+        impl<const LANES: usize> Clone for $name<LANES> {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl Default for $name {\n+        impl<const LANES: usize> Default for $name<LANES> {\n             #[inline]\n             fn default() -> Self {\n                 Self::splat(<$type>::default())\n             }\n         }\n \n-        impl PartialEq for $name {\n+        impl<const LANES: usize> PartialEq for $name<LANES> {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n-                AsRef::<[$type]>::as_ref(self) == AsRef::<[$type]>::as_ref(other)\n+                // TODO use SIMD equality\n+                self.to_array() == other.to_array()\n             }\n         }\n \n-        impl PartialOrd for $name {\n+        impl<const LANES: usize> PartialOrd for $name<LANES> {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                AsRef::<[$type]>::as_ref(self).partial_cmp(AsRef::<[$type]>::as_ref(other))\n+                // TODO use SIMD equalitya\n+                self.to_array().partial_cmp(other.as_ref())\n             }\n         }\n \n         // array references\n-        impl AsRef<[$type; $lanes]> for $name {\n+        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> {\n             #[inline]\n-            fn as_ref(&self) -> &[$type; $lanes] {\n-                unsafe { &*(self as *const _ as *const _) }\n+            fn as_ref(&self) -> &[$type; LANES] {\n+                &self.0\n             }\n         }\n \n-        impl AsMut<[$type; $lanes]> for $name {\n+        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> {\n             #[inline]\n-            fn as_mut(&mut self) -> &mut [$type; $lanes] {\n-                unsafe { &mut *(self as *mut _ as *mut _) }\n+            fn as_mut(&mut self) -> &mut [$type; LANES] {\n+                &mut self.0\n             }\n         }\n \n         // slice references\n-        impl AsRef<[$type]> for $name {\n+        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> {\n             #[inline]\n             fn as_ref(&self) -> &[$type] {\n-                AsRef::<[$type; $lanes]>::as_ref(self)\n+                &self.0\n             }\n         }\n \n-        impl AsMut<[$type]> for $name {\n+        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> {\n             #[inline]\n             fn as_mut(&mut self) -> &mut [$type] {\n-                AsMut::<[$type; $lanes]>::as_mut(self)\n+                &mut self.0\n             }\n         }\n \n         // vector/array conversion\n-        from_transmute! { unsafe $name => [$type; $lanes] }\n+        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> {\n+            fn from(array: [$type; LANES]) -> Self {\n+                Self(array)\n+            }\n+        }\n \n         // splat\n-        impl From<$type> for $name {\n+        impl<const LANES: usize> From<$type> for $name<LANES> {\n             #[inline]\n             fn from(value: $type) -> Self {\n                 Self::splat(value)\n@@ -212,181 +249,59 @@ macro_rules! base_vector_traits {\n }\n \n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! integer_vector_traits {\n-    { $name:path => [$type:ty; $lanes:literal] } => {\n-        impl Eq for $name {}\n+macro_rules! impl_integer_vector {\n+    { $name:path, $type:ty } => {\n+        impl_vector! { $name, $type }\n \n-        impl Ord for $name {\n+        impl<const LANES: usize> Eq for $name<LANES> {}\n+\n+        impl<const LANES: usize> Ord for $name<LANES> {\n             #[inline]\n             fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n-                AsRef::<[$type]>::as_ref(self).cmp(AsRef::<[$type]>::as_ref(other))\n+                // TODO use SIMD cmp\n+                self.to_array().cmp(other.as_ref())\n             }\n         }\n \n-        impl core::hash::Hash for $name {\n+        impl<const LANES: usize> core::hash::Hash for $name<LANES> {\n             #[inline]\n             fn hash<H>(&self, state: &mut H)\n             where\n                 H: core::hash::Hasher\n             {\n-                AsRef::<[$type]>::as_ref(self).hash(state)\n+                self.as_slice().hash(state)\n             }\n         }\n     }\n }\n \n-/// Defines a vector `$name` containing multiple `$lanes` of `$type`.\n-macro_rules! define_vector {\n-    { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); } => {\n-        call_repeat! { $lanes => define_vector [$type] def $(#[$attr])* | $name | }\n-\n-        impl $name {\n-            call_repeat! { $lanes => define_vector [$type] splat $type | }\n-            call_counting_args! { $lanes => define_vector => new $type | }\n-        }\n-\n-        base_vector_traits! { $name => [$type; $lanes] }\n-    };\n-    { def $(#[$attr:meta])* | $name:ident | $($itype:ty)* } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        #[repr(simd)]\n-        pub struct $name($($itype),*);\n-    };\n-    { splat $type:ty | $($itype:ty)* } => {\n-        /// Construct a vector by setting all lanes to the given value.\n-        #[inline]\n-        pub const fn splat(value: $type) -> Self {\n-            Self($(value as $itype),*)\n-        }\n-    };\n-    { new $type:ty | $($var:ident)* } => {\n-        /// Construct a vector by setting each lane to the given values.\n-        #[allow(clippy::too_many_arguments)]\n-        #[inline]\n-        pub const fn new($($var: $type),*) -> Self {\n-            Self($($var),*)\n-        }\n-    }\n-}\n-\n /// Implements inherent methods for a float vector `$name` containing multiple\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n /// representation. Called from `define_float_vector!`.\n macro_rules! impl_float_vector {\n     { $name:path => [$type:ty; $lanes:literal]; bits $bits_ty:ty; } => {\n         impl $name {\n-            /// Raw transmutation to an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            pub fn to_bits(self) -> $bits_ty {\n-                unsafe { core::mem::transmute(self) }\n-            }\n-\n-            /// Raw transmutation from an unsigned integer vector type with the\n-            /// same size and number of lanes.\n-            #[inline]\n-            pub fn from_bits(bits: $bits_ty) -> Self {\n-                unsafe { core::mem::transmute(bits) }\n-            }\n-\n-            /// Produces a vector where every lane has the absolute value of the\n-            /// equivalently-indexed lane in `self`.\n-            #[inline]\n-            pub fn abs(self) -> Self {\n-                let no_sign = <$bits_ty>::splat(!0 >> 1);\n-                Self::from_bits(self.to_bits() & no_sign)\n-            }\n-        }\n-    };\n-}\n-\n-/// Defines a float vector `$name` containing multiple `$lanes` of float\n-/// `$type`, which uses `$bits_ty` as its binary representation.\n-macro_rules! define_float_vector {\n-    { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); bits $bits_ty:ty; } => {\n-        define_vector! {\n-            $(#[$attr])*\n-            struct $name([$type; $lanes]);\n-        }\n-\n-        impl_float_vector! { $name => [$type; $lanes]; bits $bits_ty; }\n-    }\n-}\n-\n-/// Defines an integer vector `$name` containing multiple `$lanes` of integer `$type`.\n-macro_rules! define_integer_vector {\n-    { $(#[$attr:meta])* struct $name:ident([$type:ty; $lanes:tt]); } => {\n-        define_vector! {\n-            $(#[$attr])*\n-            struct $name([$type; $lanes]);\n-        }\n-\n-        integer_vector_traits! { $name => [$type; $lanes] }\n-    }\n-}\n-\n-/// Defines a mask vector `$name` containing multiple `$lanes` of `$type`, represented by the\n-/// underlying type `$impl_type`.\n-macro_rules! define_mask_vector {\n-    { $(#[$attr:meta])* struct $name:ident([$impl_type:ty as $type:ty; $lanes:tt]); } => {\n-        call_repeat! { $lanes => define_mask_vector [$impl_type] def $(#[$attr])* | $name | }\n-\n-        impl $name {\n-            call_repeat! { $lanes => define_mask_vector [$impl_type] splat $type | }\n-            call_counting_args! { $lanes => define_mask_vector => new $type | }\n-            call_counting_args! { $lanes => define_mask_vector => new_from_bool $type | }\n-\n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn test(&self, lane: usize) -> bool {\n-                self[lane].test()\n-            }\n-\n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn set(&mut self, lane: usize, value: bool) {\n-                self[lane] = value.into();\n-            }\n-        }\n-\n-        base_vector_traits! { $name => [$type; $lanes] }\n-        integer_vector_traits! { $name => [$type; $lanes] }\n-    };\n-    { def $(#[$attr:meta])* | $name:ident | $($itype:ty)* } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        #[repr(simd)]\n-        pub struct $name($($itype),*);\n-    };\n-    { splat $type:ty | $($itype:ty)* } => {\n-        /// Construct a vector by setting all lanes to the given value.\n-        #[inline]\n-        pub const fn splat(value: $type) -> Self {\n-            Self($(value.0 as $itype),*)\n+//            /// Raw transmutation to an unsigned integer vector type with the\n+//            /// same size and number of lanes.\n+//            #[inline]\n+//            pub fn to_bits(self) -> $bits_ty {\n+//                unsafe { core::mem::transmute(self) }\n+//            }\n+//\n+//            /// Raw transmutation from an unsigned integer vector type with the\n+//            /// same size and number of lanes.\n+//            #[inline]\n+//            pub fn from_bits(bits: $bits_ty) -> Self {\n+//                unsafe { core::mem::transmute(bits) }\n+//            }\n+//\n+//            /// Produces a vector where every lane has the absolute value of the\n+//            /// equivalently-indexed lane in `self`.\n+//            #[inline]\n+//            pub fn abs(self) -> Self {\n+//                let no_sign = <$bits_ty>::splat(!0 >> 1);\n+//                Self::from_bits(self.to_bits() & no_sign)\n+//            }\n         }\n     };\n-    { new $type:ty | $($var:ident)* } => {\n-        /// Construct a vector by setting each lane to the given values.\n-        #[allow(clippy::too_many_arguments)]\n-        #[inline]\n-        pub const fn new($($var: $type),*) -> Self {\n-            Self($($var.0),*)\n-        }\n-    };\n-    { new_from_bool $type:ty | $($var:ident)* } => {\n-        /// Used internally (since we can't use the Into trait in `const fn`s)\n-        #[allow(clippy::too_many_arguments)]\n-        #[allow(unused)]\n-        #[inline]\n-        pub(crate) const fn new_from_bool($($var: bool),*) -> Self {\n-            Self($(<$type>::new($var).0),*)\n-        }\n-    }\n }"}, {"sha": "fbe89bb853bd90ab0272a4aaf51e33c6a7b01296", "filename": "crates/core_simd/src/vectors_f32.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,29 +1,16 @@\n-define_float_vector! {\n-    /// Vector of two `f32` values\n-    struct f32x2([f32; 2]);\n-    bits crate::u32x2;\n-}\n+#![allow(non_camel_case_types)]\n \n-define_float_vector! {\n-    /// Vector of four `f32` values\n-    struct f32x4([f32; 4]);\n-    bits crate::u32x4;\n-}\n+/// A SIMD vector of containing `LANES` lanes of `f32`.\n+#[repr(simd)]\n+pub struct SimdF32<const LANES: usize>([f32; LANES]);\n \n-define_float_vector! {\n-    /// Vector of eight `f32` values\n-    struct f32x8([f32; 8]);\n-    bits crate::u32x8;\n-}\n+impl_vector! { SimdF32, f32 }\n \n-define_float_vector! {\n-    /// Vector of 16 `f32` values\n-    struct f32x16([f32; 16]);\n-    bits crate::u32x16;\n-}\n+pub type f32x2 = SimdF32<2>;\n+pub type f32x4 = SimdF32<4>;\n+pub type f32x8 = SimdF32<8>;\n+pub type f32x16 = SimdF32<16>;\n \n from_transmute_x86! { unsafe f32x4 => __m128 }\n from_transmute_x86! { unsafe f32x8 => __m256 }\n //from_transmute_x86! { unsafe f32x16 => __m512 }\n-\n-"}, {"sha": "f588aa4b15d34ac414dbed797e93eb56fe0e8435", "filename": "crates/core_simd/src/vectors_f64.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,20 +1,14 @@\n-define_float_vector! {\n-    /// Vector of two `f64` values\n-    struct f64x2([f64; 2]);\n-    bits crate::u64x2;\n-}\n+#![allow(non_camel_case_types)]\n \n-define_float_vector! {\n-    /// Vector of four `f64` values\n-    struct f64x4([f64; 4]);\n-    bits crate::u64x4;\n-}\n+/// A SIMD vector of containing `LANES` lanes of `f64`.\n+#[repr(simd)]\n+pub struct SimdF64<const LANES: usize>([f64; LANES]);\n \n-define_float_vector! {\n-    /// Vector of eight `f64` values\n-    struct f64x8([f64; 8]);\n-    bits crate::u64x8;\n-}\n+impl_vector! { SimdF64, f64 }\n+\n+pub type f64x2 = SimdF64<2>;\n+pub type f64x4 = SimdF64<4>;\n+pub type f64x8 = SimdF64<8>;\n \n from_transmute_x86! { unsafe f64x2 => __m128d }\n from_transmute_x86! { unsafe f64x4 => __m256d }"}, {"sha": "46c17fa12faedd3a00ae8c0c3c11f1d97df1ba33", "filename": "crates/core_simd/src/vectors_i128.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i128.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,12 +1,13 @@\n-define_integer_vector! {\n-    /// Vector of two `i128` values\n-    struct i128x2([i128; 2]);\n-}\n-\n-define_integer_vector! {\n-    /// Vector of four `i128` values\n-    struct i128x4([i128; 4]);\n-}\n+#![allow(non_camel_case_types)]\n+\n+/// A SIMD vector of containing `LANES` lanes of `i128`.\n+#[repr(simd)]\n+pub struct SimdI128<const LANES: usize>([i128; LANES]);\n+\n+impl_vector! { SimdI128, i128 }\n+\n+pub type i128x2 = SimdI128<2>;\n+pub type i128x4 = SimdI128<4>;\n \n from_transmute_x86! { unsafe i128x2 => __m256i }\n //from_transmute_x86! { unsafe i128x4 => __m512i }"}, {"sha": "d3eefdb745c9f11cff14c7efb26063b1e3160f36", "filename": "crates/core_simd/src/vectors_i16.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i16.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,22 +1,15 @@\n-define_integer_vector! {\n-    /// Vector of four `i16` values\n-    struct i16x4([i16; 4]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of eight `i16` values\n-    struct i16x8([i16; 8]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `i16`.\n+#[repr(simd)]\n+pub struct SimdI16<const LANES: usize>([i16; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of 16 `i16` values\n-    struct i16x16([i16; 16]);\n-}\n+impl_vector! { SimdI16, i16 }\n \n-define_integer_vector! {\n-    /// Vector of 32 `i16` values\n-    struct i16x32([i16; 32]);\n-}\n+pub type i16x4 = SimdI16<4>;\n+pub type i16x8 = SimdI16<8>;\n+pub type i16x16 = SimdI16<16>;\n+pub type i16x32 = SimdI16<32>;\n \n from_transmute_x86! { unsafe i16x8 => __m128i }\n from_transmute_x86! { unsafe i16x16 => __m256i }"}, {"sha": "63e70393d7ff2d114522739e8292c01ae393833c", "filename": "crates/core_simd/src/vectors_i32.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i32.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,22 +1,15 @@\n-define_integer_vector! {\n-    /// Vector of two `i32` values\n-    struct i32x2([i32; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `i32` values\n-    struct i32x4([i32; 4]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `i32`.\n+#[repr(simd)]\n+pub struct SimdI32<const LANES: usize>([i32; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `i32` values\n-    struct i32x8([i32; 8]);\n-}\n+impl_vector! { SimdI32, i32 }\n \n-define_integer_vector! {\n-    /// Vector of 16 `i32` values\n-    struct i32x16([i32; 16]);\n-}\n+pub type i32x2 = SimdI32<2>;\n+pub type i32x4 = SimdI32<4>;\n+pub type i32x8 = SimdI32<8>;\n+pub type i32x16 = SimdI32<16>;\n \n from_transmute_x86! { unsafe i32x4 => __m128i }\n from_transmute_x86! { unsafe i32x8 => __m256i }"}, {"sha": "1d5e9b89f9a6fe54622c77fa3472509aae5241f9", "filename": "crates/core_simd/src/vectors_i64.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i64.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,17 +1,14 @@\n-define_integer_vector! {\n-    /// Vector of two `i64` values\n-    struct i64x2([i64; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `i64` values\n-    struct i64x4([i64; 4]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `i64`.\n+#[repr(simd)]\n+pub struct SimdI64<const LANES: usize>([i64; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `i64` values\n-    struct i64x8([i64; 8]);\n-}\n+impl_vector! { SimdI64, i64 }\n+\n+pub type i64x2 = SimdI64<2>;\n+pub type i64x4 = SimdI64<4>;\n+pub type i64x8 = SimdI64<8>;\n \n from_transmute_x86! { unsafe i64x2 => __m128i }\n from_transmute_x86! { unsafe i64x4 => __m256i }"}, {"sha": "6a38bd42122ebae569bd50b6a0ed3dff181d2829", "filename": "crates/core_simd/src/vectors_i8.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_i8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i8.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,22 +1,15 @@\n-define_integer_vector! {\n-    /// Vector of eight `i8` values\n-    struct i8x8([i8; 8]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of 16 `i8` values\n-    struct i8x16([i8; 16]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `i8`.\n+#[repr(simd)]\n+pub struct SimdI8<const LANES: usize>([i8; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of 32 `i8` values\n-    struct i8x32([i8; 32]);\n-}\n+impl_vector! { SimdI8, i8 }\n \n-define_integer_vector! {\n-    /// Vector of 64 `i8` values\n-    struct i8x64([i8; 64]);\n-}\n+pub type i8x8 = SimdI8<8>;\n+pub type i8x16 = SimdI8<16>;\n+pub type i8x32 = SimdI8<32>;\n+pub type i8x64 = SimdI8<64>;\n \n from_transmute_x86! { unsafe i8x16 => __m128i }\n from_transmute_x86! { unsafe i8x32 => __m256i }"}, {"sha": "805aade88bbe215db63a9aec41324e9debea4f0e", "filename": "crates/core_simd/src/vectors_isize.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_isize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_isize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_isize.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,17 +1,14 @@\n-define_integer_vector! {\n-    /// Vector of two `isize` values\n-    struct isizex2([isize; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `isize` values\n-    struct isizex4([isize; 4]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `isize`.\n+#[repr(simd)]\n+pub struct SimdIsize<const LANES: usize>([isize; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `isize` values\n-    struct isizex8([isize; 8]);\n-}\n+impl_vector! { SimdIsize, isize }\n+\n+pub type isizex2 = SimdIsize<2>;\n+pub type isizex4 = SimdIsize<4>;\n+pub type isizex8 = SimdIsize<8>;\n \n #[cfg(target_pointer_width = \"32\")]\n from_transmute_x86! { unsafe isizex4 => __m128i }"}, {"sha": "06617876ce0bd9696843c2461dcdb2b0330f2a5e", "filename": "crates/core_simd/src/vectors_u128.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u128.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,12 +1,13 @@\n-define_integer_vector! {\n-    /// Vector of two `u128` values\n-    struct u128x2([u128; 2]);\n-}\n-\n-define_integer_vector! {\n-    /// Vector of four `u128` values\n-    struct u128x4([u128; 4]);\n-}\n+#![allow(non_camel_case_types)]\n+\n+/// A SIMD vector of containing `LANES` lanes of `u128`.\n+#[repr(simd)]\n+pub struct SimdU128<const LANES: usize>([u128; LANES]);\n+\n+impl_vector! { SimdU128, u128 }\n+\n+pub type u128x2 = SimdU128<2>;\n+pub type u128x4 = SimdU128<4>;\n \n from_transmute_x86! { unsafe u128x2 => __m256i }\n //from_transmute_x86! { unsafe u128x4 => __m512i }"}, {"sha": "208c0e36aa3ffa9147faa4d0342f6b5ae0c2edd6", "filename": "crates/core_simd/src/vectors_u16.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u16.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,22 +1,15 @@\n-define_integer_vector! {\n-    /// Vector of four `u16` values\n-    struct u16x4([u16; 4]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of eight `u16` values\n-    struct u16x8([u16; 8]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `u16`.\n+#[repr(simd)]\n+pub struct SimdU16<const LANES: usize>([u16; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of 16 `u16` values\n-    struct u16x16([u16; 16]);\n-}\n+impl_vector! { SimdU16, u16 }\n \n-define_integer_vector! {\n-    /// Vector of 32 `u16` values\n-    struct u16x32([u16; 32]);\n-}\n+pub type u16x4 = SimdU16<4>;\n+pub type u16x8 = SimdU16<8>;\n+pub type u16x16 = SimdU16<16>;\n+pub type u16x32 = SimdU16<32>;\n \n from_transmute_x86! { unsafe u16x8 => __m128i }\n from_transmute_x86! { unsafe u16x16 => __m256i }"}, {"sha": "8a5239e7daf8a4a267bcf71ae686e1fedab346dd", "filename": "crates/core_simd/src/vectors_u32.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u32.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,22 +1,15 @@\n-define_integer_vector! {\n-    /// Vector of two `u32` values\n-    struct u32x2([u32; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `u32` values\n-    struct u32x4([u32; 4]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `u32`.\n+#[repr(simd)]\n+pub struct SimdU32<const LANES: usize>([u32; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `u32` values\n-    struct u32x8([u32; 8]);\n-}\n+impl_vector! { SimdU32, u32 }\n \n-define_integer_vector! {\n-    /// Vector of 16 `u32` values\n-    struct u32x16([u32; 16]);\n-}\n+pub type u32x2 = SimdU32<2>;\n+pub type u32x4 = SimdU32<4>;\n+pub type u32x8 = SimdU32<8>;\n+pub type u32x16 = SimdU32<16>;\n \n from_transmute_x86! { unsafe u32x4 => __m128i }\n from_transmute_x86! { unsafe u32x8 => __m256i }"}, {"sha": "48b8a9ef3908d6872d1567039a29f20af22f3770", "filename": "crates/core_simd/src/vectors_u64.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u64.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,17 +1,14 @@\n-define_integer_vector! {\n-    /// Vector of two `u64` values\n-    struct u64x2([u64; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `u64` values\n-    struct u64x4([u64; 4]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `u64`.\n+#[repr(simd)]\n+pub struct SimdU64<const LANES: usize>([u64; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `u64` values\n-    struct u64x8([u64; 8]);\n-}\n+impl_vector! { SimdU64, u64 }\n+\n+pub type u64x2 = SimdU64<2>;\n+pub type u64x4 = SimdU64<4>;\n+pub type u64x8 = SimdU64<8>;\n \n from_transmute_x86! { unsafe u64x2 => __m128i }\n from_transmute_x86! { unsafe u64x4 => __m256i }"}, {"sha": "83a179eff575146a497b36f223a75c4b2e884954", "filename": "crates/core_simd/src/vectors_u8.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u8.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,22 +1,15 @@\n-define_integer_vector! {\n-    /// Vector of eight `u8` values\n-    struct u8x8([u8; 8]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of 16 `u8` values\n-    struct u8x16([u8; 16]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `u8`.\n+#[repr(simd)]\n+pub struct SimdU8<const LANES: usize>([u8; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of 32 `u8` values\n-    struct u8x32([u8; 32]);\n-}\n+impl_vector! { SimdU8, u8 }\n \n-define_integer_vector! {\n-    /// Vector of 64 `u8` values\n-    struct u8x64([u8; 64]);\n-}\n+pub type u8x8 = SimdU8<8>;\n+pub type u8x16 = SimdU8<16>;\n+pub type u8x32 = SimdU8<32>;\n+pub type u8x64 = SimdU8<64>;\n \n from_transmute_x86! { unsafe u8x16 => __m128i }\n from_transmute_x86! { unsafe u8x32 => __m256i }"}, {"sha": "096b6cea08d0f61579793c5b2482b0b57b439afd", "filename": "crates/core_simd/src/vectors_usize.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_usize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27e944231c3ca26add3c1a801fbe1c6de79f51fd/crates%2Fcore_simd%2Fsrc%2Fvectors_usize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_usize.rs?ref=27e944231c3ca26add3c1a801fbe1c6de79f51fd", "patch": "@@ -1,17 +1,14 @@\n-define_integer_vector! {\n-    /// Vector of two `usize` values\n-    struct usizex2([usize; 2]);\n-}\n+#![allow(non_camel_case_types)]\n \n-define_integer_vector! {\n-    /// Vector of four `usize` values\n-    struct usizex4([usize; 4]);\n-}\n+/// A SIMD vector of containing `LANES` lanes of `usize`.\n+#[repr(simd)]\n+pub struct SimdUsize<const LANES: usize>([usize; LANES]);\n \n-define_integer_vector! {\n-    /// Vector of eight `usize` values\n-    struct usizex8([usize; 8]);\n-}\n+impl_vector! { SimdUsize, usize }\n+\n+pub type usizex2 = SimdUsize<2>;\n+pub type usizex4 = SimdUsize<4>;\n+pub type usizex8 = SimdUsize<8>;\n \n #[cfg(target_pointer_width = \"32\")]\n from_transmute_x86! { unsafe usizex4 => __m128i }"}]}