{"sha": "c6a1979e2046a8eb56900f3191ef69d11e7455e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YTE5NzllMjA0NmE4ZWI1NjkwMGYzMTkxZWY2OWQxMWU3NDU1ZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-19T00:27:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-19T00:27:45Z"}, "message": "Auto merge of #50603 - eddyb:issue-49955, r=nikomatsakis\n\n rustc_mir: allow promotion of promotable temps indexed at runtime.\n\nFixes #49955.\n\nr? @nikomatsakis", "tree": {"sha": "2e42113babfb222098cd4e53d6c148b900c785f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e42113babfb222098cd4e53d6c148b900c785f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6a1979e2046a8eb56900f3191ef69d11e7455e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6a1979e2046a8eb56900f3191ef69d11e7455e3", "html_url": "https://github.com/rust-lang/rust/commit/c6a1979e2046a8eb56900f3191ef69d11e7455e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6a1979e2046a8eb56900f3191ef69d11e7455e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37a409177c80e6f301c41833fc7ee8fda2412c00", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a409177c80e6f301c41833fc7ee8fda2412c00", "html_url": "https://github.com/rust-lang/rust/commit/37a409177c80e6f301c41833fc7ee8fda2412c00"}, {"sha": "d1f117df0fd71d443742a455532e5f053f24a741", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f117df0fd71d443742a455532e5f053f24a741", "html_url": "https://github.com/rust-lang/rust/commit/d1f117df0fd71d443742a455532e5f053f24a741"}], "stats": {"total": 299, "additions": 217, "deletions": 82}, "files": [{"sha": "5af19ab36469677e2a01a3e56adc3d25d634ac45", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 104, "deletions": 58, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=c6a1979e2046a8eb56900f3191ef69d11e7455e3", "patch": "@@ -25,14 +25,12 @@\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use syntax_pos::Span;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n-use std::iter;\n-use std::mem;\n-use std::usize;\n+use std::{cmp, iter, mem, usize};\n \n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -150,9 +148,11 @@ pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> IndexVec<Local, T\n }\n \n struct Promoter<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: &'a mut Mir<'tcx>,\n     promoted: Mir<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n+    extra_statements: &'a mut Vec<(Location, Statement<'tcx>)>,\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n@@ -288,38 +288,90 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn promote_candidate(mut self, candidate: Candidate) {\n-        let span = self.promoted.span;\n-        let new_operand = Operand::Constant(box Constant {\n-            span,\n-            ty: self.promoted.return_ty(),\n-            literal: Literal::Promoted {\n+        let mut rvalue = {\n+            let promoted = &mut self.promoted;\n+            let literal = Literal::Promoted {\n                 index: Promoted::new(self.source.promoted.len())\n-            }\n-        });\n-        let mut rvalue = match candidate {\n-            Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                let ref mut statement = self.source[bb].statements[stmt_idx];\n-                match statement.kind {\n-                    StatementKind::Assign(_, ref mut rvalue) => {\n-                        mem::replace(rvalue, Rvalue::Use(new_operand))\n+            };\n+            let operand = |ty, span| {\n+                promoted.span = span;\n+                promoted.local_decls[RETURN_PLACE] =\n+                    LocalDecl::new_return_place(ty, span);\n+                Operand::Constant(box Constant {\n+                    span,\n+                    ty,\n+                    literal\n+                })\n+            };\n+            let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n+            match candidate {\n+                Candidate::Ref(loc) => {\n+                    let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n+                    match statement.kind {\n+                        StatementKind::Assign(_, Rvalue::Ref(r, bk, ref mut place)) => {\n+                            // Find the underlying local for this (necessarilly interior) borrow.\n+                            // HACK(eddyb) using a recursive function because of mutable borrows.\n+                            fn interior_base<'a, 'tcx>(place: &'a mut Place<'tcx>)\n+                                                       -> &'a mut Place<'tcx> {\n+                                if let Place::Projection(ref mut proj) = *place {\n+                                    assert_ne!(proj.elem, ProjectionElem::Deref);\n+                                    return interior_base(&mut proj.base);\n+                                }\n+                                place\n+                            }\n+                            let place = interior_base(place);\n+\n+                            let ty = place.ty(local_decls, self.tcx).to_ty(self.tcx);\n+                            let ref_ty = self.tcx.mk_ref(r,\n+                                ty::TypeAndMut {\n+                                    ty,\n+                                    mutbl: bk.to_mutbl_lossy()\n+                                }\n+                            );\n+                            let span = statement.source_info.span;\n+\n+                            // Create a temp to hold the promoted reference.\n+                            // This is because `*r` requires `r` to be a local,\n+                            // otherwise we would use the `promoted` directly.\n+                            let mut promoted_ref = LocalDecl::new_temp(ref_ty, span);\n+                            promoted_ref.source_info = statement.source_info;\n+                            let promoted_ref = local_decls.push(promoted_ref);\n+                            assert_eq!(self.temps.push(TempState::Unpromotable), promoted_ref);\n+                            self.extra_statements.push((loc, Statement {\n+                                source_info: statement.source_info,\n+                                kind: StatementKind::Assign(\n+                                    Place::Local(promoted_ref),\n+                                    Rvalue::Use(operand(ref_ty, span)),\n+                                )\n+                            }));\n+                            let promoted_place = Place::Local(promoted_ref).deref();\n+\n+                            Rvalue::Ref(r, bk, mem::replace(place, promoted_place))\n+                        }\n+                        _ => bug!()\n                     }\n-                    _ => bug!()\n                 }\n-            }\n-            Candidate::Argument { bb, index } => {\n-                match self.source[bb].terminator_mut().kind {\n-                    TerminatorKind::Call { ref mut args, .. } => {\n-                        Rvalue::Use(mem::replace(&mut args[index], new_operand))\n+                Candidate::Argument { bb, index } => {\n+                    let terminator = blocks[bb].terminator_mut();\n+                    match terminator.kind {\n+                        TerminatorKind::Call { ref mut args, .. } => {\n+                            let ty = args[index].ty(local_decls, self.tcx);\n+                            let span = terminator.source_info.span;\n+                            Rvalue::Use(mem::replace(&mut args[index], operand(ty, span)))\n+                        }\n+                        _ => bug!()\n                     }\n-                    _ => bug!()\n                 }\n             }\n         };\n+\n+        assert_eq!(self.new_block(), START_BLOCK);\n         self.visit_rvalue(&mut rvalue, Location {\n             block: BasicBlock::new(0),\n             statement_index: usize::MAX\n         });\n \n+        let span = self.promoted.span;\n         self.assign(RETURN_PLACE, rvalue, span);\n         self.source.promoted.push(self.promoted);\n     }\n@@ -343,43 +395,29 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                     candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n+\n+    let mut extra_statements = vec![];\n     for candidate in candidates.into_iter().rev() {\n-        let (span, ty) = match candidate {\n-            Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                let statement = &mir[bb].statements[stmt_idx];\n-                let dest = match statement.kind {\n-                    StatementKind::Assign(ref dest, _) => dest,\n-                    _ => {\n-                        span_bug!(statement.source_info.span,\n-                                  \"expected assignment to promote\");\n-                    }\n-                };\n-                if let Place::Local(index) = *dest {\n-                    if temps[index] == TempState::PromotedOut {\n-                        // Already promoted.\n-                        continue;\n+        match candidate {\n+            Candidate::Ref(Location { block, statement_index }) => {\n+                match mir[block].statements[statement_index].kind {\n+                    StatementKind::Assign(Place::Local(local), _) => {\n+                        if temps[local] == TempState::PromotedOut {\n+                            // Already promoted.\n+                            continue;\n+                        }\n                     }\n+                    _ => {}\n                 }\n-                (statement.source_info.span, dest.ty(mir, tcx).to_ty(tcx))\n-            }\n-            Candidate::Argument { bb, index } => {\n-                let terminator = mir[bb].terminator();\n-                let ty = match terminator.kind {\n-                    TerminatorKind::Call { ref args, .. } => {\n-                        args[index].ty(mir, tcx)\n-                    }\n-                    _ => {\n-                        span_bug!(terminator.source_info.span,\n-                                  \"expected call argument to promote\");\n-                    }\n-                };\n-                (terminator.source_info.span, ty)\n             }\n-        };\n+            Candidate::Argument { .. } => {}\n+        }\n+\n \n-        // Declare return place local\n-        let initial_locals = iter::once(LocalDecl::new_return_place(ty, span))\n-            .collect();\n+        // Declare return place local so that `Mir::new` doesn't complain.\n+        let initial_locals = iter::once(\n+            LocalDecl::new_return_place(tcx.types.never, mir.span)\n+        ).collect();\n \n         let mut promoter = Promoter {\n             promoted: Mir::new(\n@@ -393,16 +431,24 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 initial_locals,\n                 0,\n                 vec![],\n-                span\n+                mir.span\n             ),\n+            tcx,\n             source: mir,\n             temps: &mut temps,\n+            extra_statements: &mut extra_statements,\n             keep_original: false\n         };\n-        assert_eq!(promoter.new_block(), START_BLOCK);\n         promoter.promote_candidate(candidate);\n     }\n \n+    // Insert each of `extra_statements` before its indicated location, which\n+    // has to be done in reverse location order, to not invalidate the rest.\n+    extra_statements.sort_by_key(|&(loc, _)| cmp::Reverse(loc));\n+    for (loc, statement) in extra_statements {\n+        mir[loc.block].statements.insert(loc.statement_index, statement);\n+    }\n+\n     // Eliminate assignments to, and drops of promoted temps.\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n     for block in mir.basic_blocks_mut() {"}, {"sha": "fd4ba1d75625a0787bd097f28f9d57fa31a818d5", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c6a1979e2046a8eb56900f3191ef69d11e7455e3", "patch": "@@ -229,12 +229,12 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     /// Check if a Local with the current qualifications is promotable.\n-    fn can_promote(&mut self) -> bool {\n+    fn can_promote(&self, qualif: Qualif) -> bool {\n         // References to statics are allowed, but only in other statics.\n         if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-            (self.qualif - Qualif::STATIC_REF).is_empty()\n+            (qualif - Qualif::STATIC_REF).is_empty()\n         } else {\n-            self.qualif.is_empty()\n+            qualif.is_empty()\n         }\n     }\n \n@@ -679,24 +679,31 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n \n                 let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                // Default to forbidding the borrow and/or its promotion,\n+                // due to the potential for direct or interior mutability,\n+                // and only proceed by setting `forbidden_mut` to `false`.\n+                let mut forbidden_mut = true;\n+\n                 if let BorrowKind::Mut { .. } = kind {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n                     // is allowed right now, and only in functions.\n-                    let allow = if self.mode == Mode::StaticMut {\n+                    if self.mode == Mode::StaticMut {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.sty {\n-                            ty::TyArray(..) | ty::TySlice(_) => true,\n-                            _ => false\n+                            ty::TyArray(..) | ty::TySlice(_) => forbidden_mut = false,\n+                            _ => {}\n                         }\n                     } else if let ty::TyArray(_, len) = ty.sty {\n-                        len.unwrap_usize(self.tcx) == 0 &&\n-                            self.mode == Mode::Fn\n-                    } else {\n-                        false\n-                    };\n+                        // FIXME(eddyb) the `self.mode == Mode::Fn` condition\n+                        // seems unnecessary, given that this is merely a ZST.\n+                        if len.unwrap_usize(self.tcx) == 0 && self.mode == Mode::Fn {\n+                            forbidden_mut = false;\n+                        }\n+                    }\n \n-                    if !allow {\n+                    if forbidden_mut {\n                         self.add(Qualif::NOT_CONST);\n                         if self.mode != Mode::Fn {\n                             let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n@@ -722,25 +729,46 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     // it means that our \"silent insertion of statics\" could change\n                     // initializer values (very bad).\n                     if self.qualif.intersects(Qualif::MUTABLE_INTERIOR) {\n-                        // Replace MUTABLE_INTERIOR with NOT_CONST to avoid\n+                        // A reference of a MUTABLE_INTERIOR place is instead\n+                        // NOT_CONST (see `if forbidden_mut` below), to avoid\n                         // duplicate errors (from reborrowing, for example).\n                         self.qualif = self.qualif - Qualif::MUTABLE_INTERIOR;\n-                        self.add(Qualif::NOT_CONST);\n                         if self.mode != Mode::Fn {\n                             span_err!(self.tcx.sess, self.span, E0492,\n                                       \"cannot borrow a constant which may contain \\\n                                        interior mutability, create a static instead\");\n                         }\n+                    } else {\n+                        // We allow immutable borrows of frozen data.\n+                        forbidden_mut = false;\n                     }\n                 }\n \n-                // We might have a candidate for promotion.\n-                let candidate = Candidate::Ref(location);\n-                if self.can_promote() {\n-                    // We can only promote direct borrows of temps.\n+                if forbidden_mut {\n+                    self.add(Qualif::NOT_CONST);\n+                } else {\n+                    // We might have a candidate for promotion.\n+                    let candidate = Candidate::Ref(location);\n+                    // We can only promote interior borrows of promotable temps.\n+                    let mut place = place;\n+                    while let Place::Projection(ref proj) = *place {\n+                        if proj.elem == ProjectionElem::Deref {\n+                            break;\n+                        }\n+                        place = &proj.base;\n+                    }\n                     if let Place::Local(local) = *place {\n                         if self.mir.local_kind(local) == LocalKind::Temp {\n-                            self.promotion_candidates.push(candidate);\n+                            if let Some(qualif) = self.temp_qualif[local] {\n+                                // `forbidden_mut` is false, so we can safely ignore\n+                                // `MUTABLE_INTERIOR` from the local's qualifications.\n+                                // This allows borrowing fields which don't have\n+                                // `MUTABLE_INTERIOR`, from a type that does, e.g.:\n+                                // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                                if self.can_promote(qualif - Qualif::MUTABLE_INTERIOR) {\n+                                    self.promotion_candidates.push(candidate);\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -897,7 +925,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                     }\n                     let candidate = Candidate::Argument { bb, index: i };\n                     if is_shuffle && i == 2 {\n-                        if this.can_promote() {\n+                        if this.can_promote(this.qualif) {\n                             this.promotion_candidates.push(candidate);\n                         } else {\n                             span_err!(this.tcx.sess, this.span, E0526,\n@@ -913,7 +941,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                     if !constant_arguments.contains(&i) {\n                         return\n                     }\n-                    if this.can_promote() {\n+                    if this.can_promote(this.qualif) {\n                         this.promotion_candidates.push(candidate);\n                     } else {\n                         this.tcx.sess.span_err(this.span,"}, {"sha": "15b104f6c2ff74b9206f5c38872395a3a0883b70", "filename": "src/test/mir-opt/end_region_destruction_extents_1.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_destruction_extents_1.rs?ref=c6a1979e2046a8eb56900f3191ef69d11e7455e3", "patch": "@@ -130,17 +130,21 @@ unsafe impl<'a, #[may_dangle] 'b> Drop for D1<'a, 'b> {\n //     let mut _7: &'10s S1;\n //     let mut _8: &'10s S1;\n //     let mut _9: S1;\n+//     let mut _10: &'10s S1;\n+//     let mut _11: &'12ds S1;\n //\n //     bb0: {\n //         StorageLive(_2);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         _5 = promoted[1];\n+//         _11 = promoted[1];\n+//         _5 = &'12ds (*_11);\n //         _4 = &'12ds (*_5);\n //         StorageLive(_7);\n //         StorageLive(_8);\n-//         _8 = promoted[0];\n+//         _10 = promoted[0];\n+//         _8 = &'10s (*_10);\n //         _7 = &'10s (*_8);\n //         _3 = D1<'12ds, '10s>::{{constructor}}(move _4, move _7);\n //         EndRegion('10s);"}, {"sha": "c2a40399efe3d5718f5e3604a13a04ad56d724fb", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=c6a1979e2046a8eb56900f3191ef69d11e7455e3", "patch": "@@ -88,7 +88,8 @@ fn main() {\n //  }\n //  bb9: { // binding1 and guard\n //      StorageLive(_5);\n-//      _5 = &((_2 as Some).0: i32);\n+//      _11 = promoted[0];\n+//      _5 = &(((*_11) as Some).0: i32);\n //      StorageLive(_8);\n //      _8 = const guard() -> [return: bb10, unwind: bb1];\n //  }"}, {"sha": "17e1de95dd30e493c20caec3759408460d741b27", "filename": "src/test/run-pass/issue-49955-2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Ftest%2Frun-pass%2Fissue-49955-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Ftest%2Frun-pass%2Fissue-49955-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-49955-2.rs?ref=c6a1979e2046a8eb56900f3191ef69d11e7455e3", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck=mir\n+\n+use std::cell::Cell;\n+\n+#[inline(never)]\n+fn tuple_field() -> &'static u32 {\n+    // This test is MIR-borrowck-only because the old borrowck\n+    // doesn't agree that borrows of \"frozen\" (i.e. without any\n+    // interior mutability) fields of non-frozen temporaries,\n+    // should be promoted, while MIR promotion does promote them.\n+    &(Cell::new(5), 42).1\n+}\n+\n+fn main() {\n+    assert_eq!(tuple_field().to_string(), \"42\");\n+}"}, {"sha": "57a1264aaee8033f6f504e52c4ee98c1389794d2", "filename": "src/test/run-pass/issue-49955.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Ftest%2Frun-pass%2Fissue-49955.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6a1979e2046a8eb56900f3191ef69d11e7455e3/src%2Ftest%2Frun-pass%2Fissue-49955.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-49955.rs?ref=c6a1979e2046a8eb56900f3191ef69d11e7455e3", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck=compare\n+\n+const ALL_THE_NUMS: [u32; 1] = [\n+    1\n+];\n+\n+#[inline(never)]\n+fn array(i: usize) -> &'static u32 {\n+    return &ALL_THE_NUMS[i];\n+}\n+\n+#[inline(never)]\n+fn tuple_field() -> &'static u32 {\n+    &(42,).0\n+}\n+\n+fn main() {\n+    assert_eq!(tuple_field().to_string(), \"42\");\n+    assert_eq!(array(0).to_string(), \"1\");\n+}"}]}