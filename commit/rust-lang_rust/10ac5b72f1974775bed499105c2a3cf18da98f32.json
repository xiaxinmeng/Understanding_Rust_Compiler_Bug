{"sha": "10ac5b72f1974775bed499105c2a3cf18da98f32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYWM1YjcyZjE5NzQ3NzViZWQ0OTkxMDVjMmEzY2YxOGRhOThmMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-14T07:07:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-14T07:07:31Z"}, "message": "auto merge of #19677 : japaric/rust/deprecate-tupleN, r=alexcrichton\n\nr? @alexcrichton or anyone else\r\ncloses #18006", "tree": {"sha": "e940ac9e694fea0d39efcfc294620dbc9ca01e53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e940ac9e694fea0d39efcfc294620dbc9ca01e53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10ac5b72f1974775bed499105c2a3cf18da98f32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10ac5b72f1974775bed499105c2a3cf18da98f32", "html_url": "https://github.com/rust-lang/rust/commit/10ac5b72f1974775bed499105c2a3cf18da98f32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10ac5b72f1974775bed499105c2a3cf18da98f32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f07526a9990ab07983905fb5f383e62ae72242bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f07526a9990ab07983905fb5f383e62ae72242bc", "html_url": "https://github.com/rust-lang/rust/commit/f07526a9990ab07983905fb5f383e62ae72242bc"}, {"sha": "029789b98cf0115f347fe12fd19bd2c29751f8ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/029789b98cf0115f347fe12fd19bd2c29751f8ce", "html_url": "https://github.com/rust-lang/rust/commit/029789b98cf0115f347fe12fd19bd2c29751f8ce"}], "stats": {"total": 329, "additions": 166, "deletions": 163}, "files": [{"sha": "257cd80258246ef536c1195f155ea2184eed3f6a", "filename": "src/etc/unicode.py", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -348,22 +348,21 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     f.write(\"\"\"\n     use core::cmp::Ordering::{Equal, Less, Greater};\n     use core::slice::SlicePrelude;\n-    use core::tuple::Tuple2;\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::slice;\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n           None        => c,\n-          Some(index) => LuLl_table[index].val1()\n+          Some(index) => LuLl_table[index].1\n         }\n     }\n \n     pub fn to_upper(c: char) -> char {\n         match bsearch_case_table(c, LlLu_table) {\n             None        => c,\n-            Some(index) => LlLu_table[index].val1()\n+            Some(index) => LlLu_table[index].1\n         }\n     }\n "}, {"sha": "7664fb9c426ae653649335ff5c840394c42b6a63", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -62,7 +62,7 @@ use core::iter::AdditiveIterator;\n use core::kinds::Sized;\n use core::prelude::{Char, Clone, Eq, Equiv};\n use core::prelude::{Iterator, IteratorExt, SlicePrelude, None, Option, Ord, Ordering};\n-use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some, Tuple2};\n+use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some};\n use core::prelude::{range};\n \n use hash;\n@@ -185,8 +185,8 @@ fn canonical_sort(comb: &mut [(char, u8)]) {\n     for i in range(0, len) {\n         let mut swapped = false;\n         for j in range(1, len-i) {\n-            let class_a = *comb[j-1].ref1();\n-            let class_b = *comb[j].ref1();\n+            let class_a = comb[j-1].1;\n+            let class_b = comb[j].1;\n             if class_a != 0 && class_b != 0 && class_a > class_b {\n                 comb.swap(j-1, j);\n                 swapped = true;"}, {"sha": "8160424be292c116b69e0958da8d8757df88a93e", "filename": "src/libcore/tuple/mod.rs", "status": "modified", "additions": 112, "deletions": 106, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibcore%2Ftuple%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibcore%2Ftuple%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple%2Fmod.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -38,9 +38,12 @@\n //! Using methods:\n //!\n //! ```\n+//! #[allow(deprecated)]\n+//! # fn main() {\n //! let pair = (\"pi\", 3.14f64);\n //! assert_eq!(pair.val0(), \"pi\");\n //! assert_eq!(pair.val1(), 3.14f64);\n+//! # }\n //! ```\n //!\n //! Using traits implemented for tuples:\n@@ -72,25 +75,28 @@ use default::Default;\n use option::Option;\n use option::Option::Some;\n \n+// FIXME(#19630) Remove this work-around\n+macro_rules! e {\n+    ($e:expr) => { $e }\n+}\n+\n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {\n     ($(\n         $Tuple:ident {\n-            $(($valN:ident, $refN:ident, $mutN:ident) -> $T:ident {\n-                ($($x:ident),+) => $ret:expr\n-            })+\n+            $(($valN:ident, $refN:ident, $mutN:ident, $idx:tt) -> $T:ident)+\n         }\n     )+) => {\n         $(\n             #[allow(missing_docs)]\n-            #[stable]\n+            #[deprecated]\n             pub trait $Tuple<$($T),+> {\n                 $(\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `tuple.N`\"]\n                     fn $valN(self) -> $T;\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `&tuple.N`\"]\n                     fn $refN<'a>(&'a self) -> &'a $T;\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `&mut tuple.N`\"]\n                     fn $mutN<'a>(&'a mut self) -> &'a mut $T;\n                  )+\n             }\n@@ -99,43 +105,43 @@ macro_rules! tuple_impls {\n                 $(\n                     #[inline]\n                     #[allow(unused_variables)]\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `tuple.N`\"]\n                     fn $valN(self) -> $T {\n-                        let ($($x,)+) = self; $ret\n+                        e!(self.$idx)\n                     }\n \n                     #[inline]\n                     #[allow(unused_variables)]\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `&tuple.N`\"]\n                     fn $refN<'a>(&'a self) -> &'a $T {\n-                        let ($(ref $x,)+) = *self; $ret\n+                        e!(&self.$idx)\n                     }\n \n                     #[inline]\n                     #[allow(unused_variables)]\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: &mut tuple.N\"]\n                     fn $mutN<'a>(&'a mut self) -> &'a mut $T {\n-                        let ($(ref mut $x,)+) = *self; $ret\n+                        e!(&mut self.$idx)\n                     }\n                 )+\n             }\n \n             #[unstable = \"waiting for Clone to stabilize\"]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n-                    ($(self.$refN().clone(),)+)\n+                    ($(e!(self.$idx.clone()),)+)\n                 }\n             }\n \n             #[unstable = \"waiting for PartialEq to stabilize\"]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n-                    $(*self.$refN() == *other.$refN())&&+\n+                    e!($(self.$idx == other.$idx)&&+)\n                 }\n                 #[inline]\n                 fn ne(&self, other: &($($T,)+)) -> bool {\n-                    $(*self.$refN() != *other.$refN())||+\n+                    e!($(self.$idx != other.$idx)||+)\n                 }\n             }\n \n@@ -146,31 +152,31 @@ macro_rules! tuple_impls {\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n-                    lexical_partial_cmp!($(self.$refN(), other.$refN()),+)\n+                    lexical_partial_cmp!($(self.$idx, other.$idx),+)\n                 }\n                 #[inline]\n                 fn lt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(lt, $(self.$refN(), other.$refN()),+)\n+                    lexical_ord!(lt, $(self.$idx, other.$idx),+)\n                 }\n                 #[inline]\n                 fn le(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(le, $(self.$refN(), other.$refN()),+)\n+                    lexical_ord!(le, $(self.$idx, other.$idx),+)\n                 }\n                 #[inline]\n                 fn ge(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(ge, $(self.$refN(), other.$refN()),+)\n+                    lexical_ord!(ge, $(self.$idx, other.$idx),+)\n                 }\n                 #[inline]\n                 fn gt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(gt, $(self.$refN(), other.$refN()),+)\n+                    lexical_ord!(gt, $(self.$idx, other.$idx),+)\n                 }\n             }\n \n             #[unstable = \"waiting for Ord to stabilize\"]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                    lexical_cmp!($(self.$refN(), other.$refN()),+)\n+                    lexical_cmp!($(self.$idx, other.$idx),+)\n                 }\n             }\n \n@@ -191,134 +197,134 @@ macro_rules! tuple_impls {\n // a3, b3)` (and similarly for `lexical_cmp`)\n macro_rules! lexical_ord {\n     ($rel: ident, $a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n-        if *$a != *$b { lexical_ord!($rel, $a, $b) }\n+        if $a != $b { lexical_ord!($rel, $a, $b) }\n         else { lexical_ord!($rel, $($rest_a, $rest_b),+) }\n     };\n-    ($rel: ident, $a:expr, $b:expr) => { (*$a) . $rel ($b) };\n+    ($rel: ident, $a:expr, $b:expr) => { ($a) . $rel (& $b) };\n }\n \n macro_rules! lexical_partial_cmp {\n     ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n-        match ($a).partial_cmp($b) {\n+        match ($a).partial_cmp(&$b) {\n             Some(Equal) => lexical_partial_cmp!($($rest_a, $rest_b),+),\n             ordering   => ordering\n         }\n     };\n-    ($a:expr, $b:expr) => { ($a).partial_cmp($b) };\n+    ($a:expr, $b:expr) => { ($a).partial_cmp(&$b) };\n }\n \n macro_rules! lexical_cmp {\n     ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n-        match ($a).cmp($b) {\n+        match ($a).cmp(&$b) {\n             Equal => lexical_cmp!($($rest_a, $rest_b),+),\n             ordering   => ordering\n         }\n     };\n-    ($a:expr, $b:expr) => { ($a).cmp($b) };\n+    ($a:expr, $b:expr) => { ($a).cmp(&$b) };\n }\n \n tuple_impls! {\n     Tuple1 {\n-        (val0, ref0, mut0) -> A { (a) => a }\n+        (val0, ref0, mut0, 0) -> A\n     }\n     Tuple2 {\n-        (val0, ref0, mut0) -> A { (a, b) => a }\n-        (val1, ref1, mut1) -> B { (a, b) => b }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n     }\n     Tuple3 {\n-        (val0, ref0, mut0) -> A { (a, b, c) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c) => c }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n     }\n     Tuple4 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d) => d }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n     }\n     Tuple5 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e) => e }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n     }\n     Tuple6 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f) => f }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n     }\n     Tuple7 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g) => f }\n-        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g) => g }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n     }\n     Tuple8 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h) => f }\n-        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h) => g }\n-        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h) => h }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n     }\n     Tuple9 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h, i) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h, i) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h, i) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h, i) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h, i) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h, i) => f }\n-        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h, i) => g }\n-        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h, i) => h }\n-        (val8, ref8, mut8) -> I { (a, b, c, d, e, f, g, h, i) => i }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n+        (val8, ref8, mut8, 8) -> I\n     }\n     Tuple10 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h, i, j) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h, i, j) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h, i, j) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h, i, j) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h, i, j) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h, i, j) => f }\n-        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h, i, j) => g }\n-        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h, i, j) => h }\n-        (val8, ref8, mut8) -> I { (a, b, c, d, e, f, g, h, i, j) => i }\n-        (val9, ref9, mut9) -> J { (a, b, c, d, e, f, g, h, i, j) => j }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n+        (val8, ref8, mut8, 8) -> I\n+        (val9, ref9, mut9, 9) -> J\n     }\n     Tuple11 {\n-        (val0,  ref0,  mut0)  -> A { (a, b, c, d, e, f, g, h, i, j, k) => a }\n-        (val1,  ref1,  mut1)  -> B { (a, b, c, d, e, f, g, h, i, j, k) => b }\n-        (val2,  ref2,  mut2)  -> C { (a, b, c, d, e, f, g, h, i, j, k) => c }\n-        (val3,  ref3,  mut3)  -> D { (a, b, c, d, e, f, g, h, i, j, k) => d }\n-        (val4,  ref4,  mut4)  -> E { (a, b, c, d, e, f, g, h, i, j, k) => e }\n-        (val5,  ref5,  mut5)  -> F { (a, b, c, d, e, f, g, h, i, j, k) => f }\n-        (val6,  ref6,  mut6)  -> G { (a, b, c, d, e, f, g, h, i, j, k) => g }\n-        (val7,  ref7,  mut7)  -> H { (a, b, c, d, e, f, g, h, i, j, k) => h }\n-        (val8,  ref8,  mut8)  -> I { (a, b, c, d, e, f, g, h, i, j, k) => i }\n-        (val9,  ref9,  mut9)  -> J { (a, b, c, d, e, f, g, h, i, j, k) => j }\n-        (val10, ref10, mut10) -> K { (a, b, c, d, e, f, g, h, i, j, k) => k }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n+        (val8, ref8, mut8, 8) -> I\n+        (val9, ref9, mut9, 9) -> J\n+        (val10, ref10, mut10, 10) -> K\n     }\n     Tuple12 {\n-        (val0,  ref0,  mut0)  -> A { (a, b, c, d, e, f, g, h, i, j, k, l) => a }\n-        (val1,  ref1,  mut1)  -> B { (a, b, c, d, e, f, g, h, i, j, k, l) => b }\n-        (val2,  ref2,  mut2)  -> C { (a, b, c, d, e, f, g, h, i, j, k, l) => c }\n-        (val3,  ref3,  mut3)  -> D { (a, b, c, d, e, f, g, h, i, j, k, l) => d }\n-        (val4,  ref4,  mut4)  -> E { (a, b, c, d, e, f, g, h, i, j, k, l) => e }\n-        (val5,  ref5,  mut5)  -> F { (a, b, c, d, e, f, g, h, i, j, k, l) => f }\n-        (val6,  ref6,  mut6)  -> G { (a, b, c, d, e, f, g, h, i, j, k, l) => g }\n-        (val7,  ref7,  mut7)  -> H { (a, b, c, d, e, f, g, h, i, j, k, l) => h }\n-        (val8,  ref8,  mut8)  -> I { (a, b, c, d, e, f, g, h, i, j, k, l) => i }\n-        (val9,  ref9,  mut9)  -> J { (a, b, c, d, e, f, g, h, i, j, k, l) => j }\n-        (val10, ref10, mut10) -> K { (a, b, c, d, e, f, g, h, i, j, k, l) => k }\n-        (val11, ref11, mut11) -> L { (a, b, c, d, e, f, g, h, i, j, k, l) => l }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n+        (val8, ref8, mut8, 8) -> I\n+        (val9, ref9, mut9, 9) -> J\n+        (val10, ref10, mut10, 10) -> K\n+        (val11, ref11, mut11, 11) -> L\n     }\n }\n "}, {"sha": "0bcebe073a3ef67f6a1daf2926e1384ebf999cf6", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -334,7 +334,7 @@ fn test_iterator_size_hint() {\n     assert_eq!(vi.size_hint(), (10, Some(10)));\n \n     assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n-    assert_eq!(c.skip(5).size_hint().val1(), None);\n+    assert_eq!(c.skip(5).size_hint().1, None);\n     assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n     assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n     assert_eq!(c.enumerate().size_hint(), (uint::MAX, None));"}, {"sha": "fa048346e99b593d1378d52b6137e3da3975e590", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -218,7 +218,7 @@\n //! impl<'a> dot::Labeller<'a, Nd<'a>, Ed<'a>> for Graph {\n //!     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example3\").unwrap() }\n //!     fn node_id(&'a self, n: &Nd<'a>) -> dot::Id<'a> {\n-//!         dot::Id::new(format!(\"N{}\", n.val0())).unwrap()\n+//!         dot::Id::new(format!(\"N{}\", n.0)).unwrap()\n //!     }\n //!     fn node_label<'a>(&'a self, n: &Nd<'a>) -> dot::LabelText<'a> {\n //!         let &(i, _) = n;"}, {"sha": "f9ae4d2591ab84a43155f72cbb9155e64661472a", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -1031,7 +1031,7 @@ fn is_valid_cap(c: char) -> bool {\n \n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n     match classes.binary_search(|&(s, _)| s.cmp(name)) {\n-        BinarySearchResult::Found(i) => Some(classes[i].val1().to_vec()),\n+        BinarySearchResult::Found(i) => Some(classes[i].1.to_vec()),\n         BinarySearchResult::NotFound(_) => None,\n     }\n }"}, {"sha": "75f2fc81900c463df82d7255eb56dee405ad2a61", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -34,7 +34,6 @@ use lint::builtin;\n use util::nodemap::FnvHashMap;\n \n use std::cell::RefCell;\n-use std::tuple::Tuple2;\n use std::mem;\n use syntax::ast_util::IdVisitingOperation;\n use syntax::attr::AttrMetaMethods;\n@@ -87,7 +86,7 @@ impl LintStore {\n     }\n \n     fn set_level(&mut self, lint: LintId, lvlsrc: LevelSource) {\n-        if lvlsrc.val0() == Allow {\n+        if lvlsrc.0 == Allow {\n             self.levels.remove(&lint);\n         } else {\n             self.levels.insert(lint, lvlsrc);\n@@ -110,8 +109,8 @@ impl LintStore {\n \n     pub fn get_lint_groups<'t>(&'t self) -> Vec<(&'static str, Vec<LintId>, bool)> {\n         self.lint_groups.iter().map(|(k, v)| (*k,\n-                                              v.ref0().clone(),\n-                                              *v.ref1())).collect()\n+                                              v.0.clone(),\n+                                              v.1)).collect()\n     }\n \n     pub fn register_pass(&mut self, sess: Option<&Session>,\n@@ -275,7 +274,7 @@ impl LintStore {\n             match self.find_lint(lint_name.as_slice(), sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n-                    match self.lint_groups.iter().map(|(&x, pair)| (x, pair.ref0().clone()))\n+                    match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n                                                  .get(lint_name.as_slice()) {\n@@ -443,7 +442,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n             None => return,\n             Some(&(Warn, src)) => {\n                 let lint_id = LintId::of(builtin::WARNINGS);\n-                (self.lints.get_level_source(lint_id).val0(), src)\n+                (self.lints.get_level_source(lint_id).0, src)\n             }\n             Some(&pair) => pair,\n         };\n@@ -503,15 +502,15 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n             };\n \n             for (lint_id, level, span) in v.into_iter() {\n-                let now = self.lints.get_level_source(lint_id).val0();\n+                let now = self.lints.get_level_source(lint_id).0;\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n                     self.tcx.sess.span_err(span,\n                                            format!(\"{}({}) overruled by outer forbid({})\",\n                                                    level.as_str(), lint_name,\n                                                    lint_name).as_slice());\n                 } else if now != level {\n-                    let src = self.lints.get_level_source(lint_id).val1();\n+                    let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));\n                     pushed += 1;\n                     self.lints.set_level(lint_id, (level, Node(span)));"}, {"sha": "e83f69b1e318ee5725281202557319ceaebfc930", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -364,7 +364,7 @@ impl<'a> Context<'a> {\n         let dypair = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}\", dypair.ref0(), self.crate_name);\n+        let dylib_prefix = format!(\"{}{}\", dypair.0, self.crate_name);\n         let rlib_prefix = format!(\"lib{}\", self.crate_name);\n \n         let mut candidates = HashMap::new();\n@@ -392,8 +392,8 @@ impl<'a> Context<'a> {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n             } else if file.starts_with(dylib_prefix.as_slice()) &&\n-                      file.ends_with(dypair.ref1().as_slice()) {\n-                (file.slice(dylib_prefix.len(), file.len() - dypair.ref1().len()),\n+                      file.ends_with(dypair.1.as_slice()) {\n+                (file.slice(dylib_prefix.len(), file.len() - dypair.1.len()),\n                  false)\n             } else {\n                 return FileDoesntMatch"}, {"sha": "669f4ee6ec81c4c030c05caec66952c2421216dd", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -220,7 +220,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             let matrix: Matrix = inlined_arms\n                 .iter()\n                 .filter(|&&(_, guard)| guard.is_none())\n-                .flat_map(|arm| arm.ref0().iter())\n+                .flat_map(|arm| arm.0.iter())\n                 .map(|pat| vec![&**pat])\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix);"}, {"sha": "9d41efd678c7cd47e03590be7fe3868751a9defb", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -53,7 +53,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n-        let id = n.val1().data.id;\n+        let id = n.1.data.id;\n         debug!(\"dataflow_for({}, id={}) {}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;\n@@ -67,7 +67,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     }\n \n     fn dataflow_for_variant(&self, e: EntryOrExit, n: &Node, v: Variant) -> String {\n-        let cfgidx = n.val0();\n+        let cfgidx = n.0;\n         match v {\n             Loans   => self.dataflow_loans_for(e, cfgidx),\n             Moves   => self.dataflow_moves_for(e, cfgidx),"}, {"sha": "e4f0543b5e70fccd12ebb21f49e0de48209c7006", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -91,7 +91,7 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let vs = es.iter().map(|e| const_expr(cx, &**e).val0())\n+    let vs = es.iter().map(|e| const_expr(cx, &**e).0)\n                       .collect::<Vec<_>>();\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n@@ -302,7 +302,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n // if it's assigned to a static.\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n     let map_list = |exprs: &[P<ast::Expr>]| {\n-        exprs.iter().map(|e| const_expr(cx, &**e).val0())\n+        exprs.iter().map(|e| const_expr(cx, &**e).0)\n              .fold(Vec::new(), |mut l, val| { l.push(val); l })\n     };\n     unsafe {\n@@ -575,7 +575,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   let cs = field_tys.iter().enumerate()\n                                     .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.name == f.ident.node.name) {\n-                          Some(ref f) => const_expr(cx, &*f.expr).val0(),\n+                          Some(ref f) => const_expr(cx, &*f.expr).0,\n                           None => {\n                               match base_val {\n                                   Some((bv, _)) => {\n@@ -594,7 +594,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               })\n           }\n           ast::ExprVec(ref es) => {\n-            const_vec(cx, e, es.as_slice()).val0()\n+            const_vec(cx, e, es.as_slice()).0\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n             let vec_ty = ty::expr_ty(cx.tcx(), e);\n@@ -605,7 +605,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = Vec::from_elem(n, const_expr(cx, &**elem).val0());\n+            let vs = Vec::from_elem(n, const_expr(cx, &**elem).0);\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs.as_slice(), false)\n             } else {\n@@ -673,10 +673,10 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(ref e) => const_expr(cx, &**e).val0(),\n+          ast::ExprParen(ref e) => const_expr(cx, &**e).0,\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => const_expr(cx, &**expr).val0(),\n+                Some(ref expr) => const_expr(cx, &**expr).0,\n                 None => C_nil(cx)\n             }\n           }"}, {"sha": "484eed649bbcd945eec13ab4c2546e3166ea897e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -346,7 +346,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                 Some(root) => {\n                     try!(write!(f, \"<a href='{}{}/primitive.{}.html'>\",\n                                 root,\n-                                path.ref0().head().unwrap(),\n+                                path.0.head().unwrap(),\n                                 prim.to_url_str()));\n                     needs_termination = true;\n                 }"}, {"sha": "542169620e64886ba9ad8f2290a9978d4ed9d771", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -323,7 +323,7 @@ pub fn run(mut krate: clean::Crate,\n       }).unwrap_or(HashMap::new());\n     let mut cache = Cache {\n         impls: HashMap::new(),\n-        external_paths: paths.iter().map(|(&k, v)| (k, v.ref0().clone()))\n+        external_paths: paths.iter().map(|(&k, v)| (k, v.0.clone()))\n                              .collect(),\n         paths: paths,\n         implementors: HashMap::new(),"}, {"sha": "d3a766285809bdee95d157255ae8917354301b91", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -400,7 +400,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n                                  .position(|&(p, _, _)| {\n                                      p == *pass\n                                  }) {\n-            Some(i) => PASSES[i].val1(),\n+            Some(i) => PASSES[i].1,\n             None => {\n                 error!(\"unknown pass {}, skipping\", *pass);\n                 continue"}, {"sha": "70cabb24397056c4f51f365a3fee2fc1cd60b5af", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -151,14 +151,14 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n         ImplItem(Impl { items: ref subitems, trait_: None, .. }) => {\n             let subcounts = subitems.iter().filter(|i| visible(*i))\n                                            .map(summarize_item)\n-                                           .map(|s| s.val0())\n+                                           .map(|s| s.0)\n                                            .fold(Counts::zero(), |acc, x| acc + x);\n             (subcounts, None)\n         }\n         // `pub` automatically\n         EnumItem(Enum { variants: ref subitems, .. }) => {\n             let subcounts = subitems.iter().map(summarize_item)\n-                                           .map(|s| s.val0())\n+                                           .map(|s| s.0)\n                                            .fold(Counts::zero(), |acc, x| acc + x);\n             (item_counts + subcounts, None)\n         }\n@@ -176,7 +176,7 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             let subcounts = trait_items.iter()\n                                        .map(extract_item)\n                                        .map(summarize_item)\n-                                       .map(|s| s.val0())\n+                                       .map(|s| s.0)\n                                        .fold(Counts::zero(), |acc, x| acc + x);\n             (item_counts + subcounts, None)\n         }\n@@ -212,7 +212,7 @@ pub fn build(krate: &Crate) -> ModuleSummary {\n             submodules: Vec::new(),\n         },\n         Some(ref item) => ModuleSummary {\n-            name: krate.name.clone(), .. summarize_item(item).val1().unwrap()\n+            name: krate.name.clone(), .. summarize_item(item).1.unwrap()\n         }\n     }\n }"}, {"sha": "dfbba0f335cdd1b663f1d621689dc2018ad26a25", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -379,8 +379,8 @@ impl Process {\n                 // wait indefinitely for a message to arrive.\n                 //\n                 // FIXME: sure would be nice to not have to scan the entire array\n-                let min = active.iter().map(|a| *a.ref2()).enumerate().min_by(|p| {\n-                    p.val1()\n+                let min = active.iter().map(|a| a.2).enumerate().min_by(|p| {\n+                    p.1\n                 });\n                 let (p, idx) = match min {\n                     Some((idx, deadline)) => {\n@@ -564,9 +564,9 @@ fn with_envp<K, V, T>(env: Option<&collections::HashMap<K, V>>,\n \n             for pair in env.iter() {\n                 let mut kv = Vec::new();\n-                kv.push_all(pair.ref0().container_as_bytes());\n+                kv.push_all(pair.0.container_as_bytes());\n                 kv.push('=' as u8);\n-                kv.push_all(pair.ref1().container_as_bytes());\n+                kv.push_all(pair.1.container_as_bytes());\n                 kv.push(0); // terminating null\n                 tmps.push(kv);\n             }"}, {"sha": "bbfd32ee76bfab72b273127eacc9b88b7af24f72", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -430,8 +430,8 @@ fn with_envp<K, V, T, F>(env: Option<&collections::HashMap<K, V>>, cb: F) -> T w\n \n             for pair in env.iter() {\n                 let kv = format!(\"{}={}\",\n-                                 pair.ref0().container_as_str().unwrap(),\n-                                 pair.ref1().container_as_str().unwrap());\n+                                 pair.0.container_as_str().unwrap(),\n+                                 pair.1.container_as_str().unwrap());\n                 blk.extend(kv.utf16_units());\n                 blk.push(0);\n             }"}, {"sha": "310d5662afa20aab56f1d237e07ee2e93b7be2b9", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -431,7 +431,7 @@ pub fn str_lit(lit: &str) -> String {\n     /// Eat everything up to a non-whitespace\n     fn eat<'a>(it: &mut iter::Peekable<(uint, char), str::CharOffsets<'a>>) {\n         loop {\n-            match it.peek().map(|x| x.val1()) {\n+            match it.peek().map(|x| x.1) {\n                 Some(' ') | Some('\\n') | Some('\\r') | Some('\\t') => {\n                     it.next();\n                 },\n@@ -448,15 +448,15 @@ pub fn str_lit(lit: &str) -> String {\n                     '\\\\' => {\n                         let ch = chars.peek().unwrap_or_else(|| {\n                             panic!(\"{}\", error(i).as_slice())\n-                        }).val1();\n+                        }).1;\n \n                         if ch == '\\n' {\n                             eat(&mut chars);\n                         } else if ch == '\\r' {\n                             chars.next();\n                             let ch = chars.peek().unwrap_or_else(|| {\n                                 panic!(\"{}\", error(i).as_slice())\n-                            }).val1();\n+                            }).1;\n \n                             if ch != '\\n' {\n                                 panic!(\"lexer accepted bare CR\");\n@@ -474,7 +474,7 @@ pub fn str_lit(lit: &str) -> String {\n                     '\\r' => {\n                         let ch = chars.peek().unwrap_or_else(|| {\n                             panic!(\"{}\", error(i).as_slice())\n-                        }).val1();\n+                        }).1;\n \n                         if ch != '\\n' {\n                             panic!(\"lexer accepted bare CR\");\n@@ -600,7 +600,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     /// Eat everything up to a non-whitespace\n     fn eat<'a, I: Iterator<(uint, u8)>>(it: &mut iter::Peekable<(uint, u8), I>) {\n         loop {\n-            match it.peek().map(|x| x.val1()) {\n+            match it.peek().map(|x| x.1) {\n                 Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') => {\n                     it.next();\n                 },\n@@ -615,11 +615,11 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n         match chars.next() {\n             Some((i, b'\\\\')) => {\n                 let em = error(i);\n-                match chars.peek().expect(em.as_slice()).val1() {\n+                match chars.peek().expect(em.as_slice()).1 {\n                     b'\\n' => eat(&mut chars),\n                     b'\\r' => {\n                         chars.next();\n-                        if chars.peek().expect(em.as_slice()).val1() != b'\\n' {\n+                        if chars.peek().expect(em.as_slice()).1 != b'\\n' {\n                             panic!(\"lexer accepted bare CR\");\n                         }\n                         eat(&mut chars);\n@@ -637,7 +637,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n             },\n             Some((i, b'\\r')) => {\n                 let em = error(i);\n-                if chars.peek().expect(em.as_slice()).val1() != b'\\n' {\n+                if chars.peek().expect(em.as_slice()).1 != b'\\n' {\n                     panic!(\"lexer accepted bare CR\");\n                 }\n                 chars.next();"}, {"sha": "e9cc91d94151a2f231a252ea3c856dbdba1b1b02", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -1740,8 +1740,8 @@ impl<'a> Parser<'a> {\n             }\n             token::Literal(lit, suf) => {\n                 let (suffix_illegal, out) = match lit {\n-                    token::Byte(i) => (true, LitByte(parse::byte_lit(i.as_str()).val0())),\n-                    token::Char(i) => (true, LitChar(parse::char_lit(i.as_str()).val0())),\n+                    token::Byte(i) => (true, LitByte(parse::byte_lit(i.as_str()).0)),\n+                    token::Char(i) => (true, LitChar(parse::char_lit(i.as_str()).0)),\n \n                     // there are some valid suffixes for integer and\n                     // float literals, so all the handling is done"}, {"sha": "7c78c777ddaa04bf9ce21588a1c7c5825d21fd78", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -6959,22 +6959,21 @@ pub mod normalization {\n pub mod conversions {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n     use core::slice::SlicePrelude;\n-    use core::tuple::Tuple2;\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::slice;\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n           None        => c,\n-          Some(index) => LuLl_table[index].val1()\n+          Some(index) => LuLl_table[index].1\n         }\n     }\n \n     pub fn to_upper(c: char) -> char {\n         match bsearch_case_table(c, LlLu_table) {\n             None        => c,\n-            Some(index) => LlLu_table[index].val1()\n+            Some(index) => LlLu_table[index].1\n         }\n     }\n "}, {"sha": "1f0bed055211dc35778a3f8f1a2bc0f58db606ca", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ac5b72f1974775bed499105c2a3cf18da98f32/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=10ac5b72f1974775bed499105c2a3cf18da98f32", "patch": "@@ -78,7 +78,7 @@ impl<'a> Iterator<u8> for AAGen<'a> {\n     fn next(&mut self) -> Option<u8> {\n         let r = self.rng.gen();\n         self.data.iter()\n-            .skip_while(|pc| pc.val0() < r)\n+            .skip_while(|pc| pc.0 < r)\n             .map(|&(_, c)| c)\n             .next()\n     }"}]}