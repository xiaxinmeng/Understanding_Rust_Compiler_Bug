{"sha": "cb1bec9096d09da202f5c33756144de54e9fcd56", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMWJlYzkwOTZkMDlkYTIwMmY1YzMzNzU2MTQ0ZGU1NGU5ZmNkNTY=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-08T03:37:56Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-08T03:37:56Z"}, "message": "Fix some type-related bugs\n\nSome types weren't being properly monomorphised, and didn't have their\nregions properly erased. This is now fixed.\n\nAlso fixes an issue where a temp was initialized in two separate\nbranches, but wasn't given an alloca.", "tree": {"sha": "16d3b5d5e05355b9f741addc1714b1ad4e3864af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16d3b5d5e05355b9f741addc1714b1ad4e3864af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb1bec9096d09da202f5c33756144de54e9fcd56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb1bec9096d09da202f5c33756144de54e9fcd56", "html_url": "https://github.com/rust-lang/rust/commit/cb1bec9096d09da202f5c33756144de54e9fcd56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb1bec9096d09da202f5c33756144de54e9fcd56/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73790f02e3a9c021cc5dd65ac7c017a9f6ae889f", "url": "https://api.github.com/repos/rust-lang/rust/commits/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f", "html_url": "https://github.com/rust-lang/rust/commit/73790f02e3a9c021cc5dd65ac7c017a9f6ae889f"}], "stats": {"total": 54, "additions": 36, "deletions": 18}, "files": [{"sha": "f721e88a954139138cc03e3bb9a84950dfdad1db", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb1bec9096d09da202f5c33756144de54e9fcd56/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1bec9096d09da202f5c33756144de54e9fcd56/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=cb1bec9096d09da202f5c33756144de54e9fcd56", "patch": "@@ -105,7 +105,9 @@ impl<'tcx> Visitor<'tcx> for TempAnalyzer {\n         match *lvalue {\n             mir::Lvalue::Temp(index) => {\n                 match context {\n-                    LvalueContext::Call |\n+                    LvalueContext::Call => {\n+                        self.mark_assigned(index as usize);\n+                    }\n                     LvalueContext::Consume => {\n                     }\n                     LvalueContext::Store |"}, {"sha": "303cf61ad3379e81cf271a88e7caf5a804d2bc41", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cb1bec9096d09da202f5c33756144de54e9fcd56/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1bec9096d09da202f5c33756144de54e9fcd56/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=cb1bec9096d09da202f5c33756144de54e9fcd56", "patch": "@@ -16,7 +16,7 @@ use adt;\n use base;\n use build;\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, Block, BlockAndBuilder, C_undef};\n+use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, C_undef};\n use debuginfo::DebugLoc;\n use Disr;\n use machine::{llalign_of_min, llbitsize_of_real};\n@@ -169,6 +169,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n \n+                let sig = bcx.tcx().erase_late_bound_regions(sig);\n+\n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n                 let intrinsic = match (&callee.ty.sty, &callee.data) {\n                     (&ty::TyFnDef(def_id, _, _), &Intrinsic) => {\n@@ -200,7 +202,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     return;\n                 }\n \n-                let extra_args = &args[sig.0.inputs.len()..];\n+                let extra_args = &args[sig.inputs.len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n                     self.mir.operand_ty(bcx.tcx(), op_arg)\n                 }).collect::<Vec<_>>();\n@@ -263,30 +265,30 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         };\n \n                         bcx.with_block(|bcx| {\n-                            let res = trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n+                            trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n                                                            ArgVals(llargs), dest,\n                                                            DebugLoc::None);\n-                            let bcx = res.bcx.build();\n-                            if let Some((_, target)) = *destination {\n-                                for op in args {\n-                                    self.set_operand_dropped(&bcx, op);\n-                                }\n-                                funclet_br(bcx, self.llblock(target));\n-                            } else {\n-                                // trans_intrinsic_call already used Unreachable.\n-                                // bcx.unreachable();\n-                            }\n                         });\n \n                         if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n                             // Make a fake operand for store_return\n                             let op = OperandRef {\n                                 val: OperandValue::Ref(dst),\n-                                ty: sig.0.output.unwrap()\n+                                ty: sig.output.unwrap()\n                             };\n                             self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         }\n \n+                        if let Some((_, target)) = *destination {\n+                            for op in args {\n+                                self.set_operand_dropped(&bcx, op);\n+                            }\n+                            funclet_br(bcx, self.llblock(target));\n+                        } else {\n+                            // trans_intrinsic_call already used Unreachable.\n+                            // bcx.unreachable();\n+                        }\n+\n                         return;\n                     }\n                     Fn(f) => f,\n@@ -318,7 +320,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         ret_bcx.at_start(|ret_bcx| {\n                             let op = OperandRef {\n                                 val: OperandValue::Immediate(invokeret),\n-                                ty: sig.0.output.unwrap()\n+                                ty: sig.output.unwrap()\n                             };\n                             self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n                             for op in args {\n@@ -332,7 +334,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if let Some((_, target)) = *destination {\n                         let op = OperandRef {\n                             val: OperandValue::Immediate(llret),\n-                            ty: sig.0.output.unwrap()\n+                            ty: sig.output.unwrap()\n                         };\n                         self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n                         for op in args {\n@@ -554,6 +556,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let dest = match *dest {\n             mir::Lvalue::Temp(idx) => {\n                 let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), dest);\n+                let lvalue_ty = bcx.monomorphize(&lvalue_ty);\n                 let ret_ty = lvalue_ty.to_ty(bcx.tcx());\n                 match self.temps[idx as usize] {\n                     TempRef::Lvalue(dest) => dest,\n@@ -633,6 +636,18 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n             }\n             DirectOperand(idx) => {\n+                let op = if type_is_fat_ptr(bcx.tcx(), op.ty) {\n+                    let llval = op.immediate();\n+                    let ptr = bcx.extract_value(llval, 0);\n+                    let meta = bcx.extract_value(llval, 1);\n+\n+                    OperandRef {\n+                        val: OperandValue::FatPtr(ptr, meta),\n+                        ty: op.ty\n+                    }\n+                } else {\n+                    op\n+                };\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n             }\n         }"}, {"sha": "695806aa82cee0393800de13b20280994c143c44", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb1bec9096d09da202f5c33756144de54e9fcd56/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1bec9096d09da202f5c33756144de54e9fcd56/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=cb1bec9096d09da202f5c33756144de54e9fcd56", "patch": "@@ -220,6 +220,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     TempRef::Lvalue(lvalue) => f(self, lvalue),\n                     TempRef::Operand(None) => {\n                         let lvalue_ty = self.mir.lvalue_ty(bcx.tcx(), lvalue);\n+                        let lvalue_ty = bcx.monomorphize(&lvalue_ty);\n                         let lvalue = LvalueRef::alloca(bcx,\n                                                        lvalue_ty.to_ty(bcx.tcx()),\n                                                        \"lvalue_temp\");"}, {"sha": "ab3cdbee71f9a709973f1eb3b6d826d8bbc4ca2f", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb1bec9096d09da202f5c33756144de54e9fcd56/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb1bec9096d09da202f5c33756144de54e9fcd56/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=cb1bec9096d09da202f5c33756144de54e9fcd56", "patch": "@@ -182,7 +182,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     debug!(\"type_of {:?}\", t);\n \n-    assert!(!t.has_escaping_regions());\n+    assert!(!t.has_escaping_regions(), \"{:?} has escaping regions\", t);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain"}]}