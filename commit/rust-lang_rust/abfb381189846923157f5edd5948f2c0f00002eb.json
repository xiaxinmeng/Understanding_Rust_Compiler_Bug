{"sha": "abfb381189846923157f5edd5948f2c0f00002eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZmIzODExODk4NDY5MjMxNTdmNWVkZDU5NDhmMmMwZjAwMDAyZWI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2019-03-24T09:55:11Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2019-03-24T09:55:11Z"}, "message": "Avoid rewriting pairs mutiple times", "tree": {"sha": "d43d91b4731d8426a4f6d86216c9021a7e73f792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d43d91b4731d8426a4f6d86216c9021a7e73f792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abfb381189846923157f5edd5948f2c0f00002eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abfb381189846923157f5edd5948f2c0f00002eb", "html_url": "https://github.com/rust-lang/rust/commit/abfb381189846923157f5edd5948f2c0f00002eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abfb381189846923157f5edd5948f2c0f00002eb/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04cc821e4a3de60808cf5f7eaa8277f1a0c06a2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/04cc821e4a3de60808cf5f7eaa8277f1a0c06a2b", "html_url": "https://github.com/rust-lang/rust/commit/04cc821e4a3de60808cf5f7eaa8277f1a0c06a2b"}], "stats": {"total": 93, "additions": 51, "deletions": 42}, "files": [{"sha": "49a77c102f6cac5160099f1ea7b6c7c4c28c3e62", "filename": "src/pairs.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/abfb381189846923157f5edd5948f2c0f00002eb/src%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abfb381189846923157f5edd5948f2c0f00002eb/src%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpairs.rs?ref=abfb381189846923157f5edd5948f2c0f00002eb", "patch": "@@ -34,19 +34,11 @@ pub(crate) fn rewrite_all_pairs(\n     shape: Shape,\n     context: &RewriteContext<'_>,\n ) -> Option<String> {\n-    // First we try formatting on one line.\n-    if let Some(list) = expr.flatten(false) {\n-        if let Some(r) = rewrite_pairs_one_line(&list, shape, context) {\n-            return Some(r);\n-        }\n-    }\n-\n-    // We can't format on line, so try many. When we flatten here we make sure\n-    // to only flatten pairs with the same operator, that way we don't\n-    // necessarily need one line per sub-expression, but we don't do anything\n-    // too funny wrt precedence.\n-    expr.flatten(true)\n-        .and_then(|list| rewrite_pairs_multiline(&list, shape, context))\n+    expr.flatten(context, shape).and_then(|list| {\n+        // First we try formatting on one line.\n+        rewrite_pairs_one_line(&list, shape, context)\n+            .or_else(|| rewrite_pairs_multiline(&list, shape, context))\n+    })\n }\n \n // This may return a multi-line result since we allow the last expression to go\n@@ -61,22 +53,23 @@ fn rewrite_pairs_one_line<T: Rewrite>(\n     let mut result = String::new();\n     let base_shape = shape.block();\n \n-    for (e, s) in list.list.iter().zip(list.separators.iter()) {\n-        let cur_shape = base_shape.offset_left(last_line_width(&result))?;\n-        let rewrite = e.rewrite(context, cur_shape)?;\n+    for ((_, rewrite), s) in list.list.iter().zip(list.separators.iter()) {\n+        if let Some(rewrite) = rewrite {\n+            if !is_single_line(&rewrite) || result.len() > shape.width {\n+                return None;\n+            }\n \n-        if !is_single_line(&rewrite) || result.len() > shape.width {\n+            result.push_str(&rewrite);\n+            result.push(' ');\n+            result.push_str(s);\n+            result.push(' ');\n+        } else {\n             return None;\n         }\n-\n-        result.push_str(&rewrite);\n-        result.push(' ');\n-        result.push_str(s);\n-        result.push(' ');\n     }\n \n     let prefix_len = result.len();\n-    let last = list.list.last().unwrap();\n+    let last = list.list.last()?.0;\n     let cur_shape = base_shape.offset_left(last_line_width(&result))?;\n     let last_rewrite = last.rewrite(context, cur_shape)?;\n     result.push_str(&last_rewrite);\n@@ -112,10 +105,9 @@ fn rewrite_pairs_multiline<T: Rewrite>(\n     let indent_str = nested_shape.indent.to_string_with_newline(context.config);\n     let mut result = String::new();\n \n-    let rewrite = list.list[0].rewrite(context, shape)?;\n-    result.push_str(&rewrite);\n+    result.push_str(&list.list[0].1.as_ref()?);\n \n-    for (e, s) in list.list[1..].iter().zip(list.separators.iter()) {\n+    for ((e, default_rw), s) in list.list[1..].iter().zip(list.separators.iter()) {\n         // The following test checks if we should keep two subexprs on the same\n         // line. We do this if not doing so would create an orphan and there is\n         // enough space to do so.\n@@ -139,24 +131,20 @@ fn rewrite_pairs_multiline<T: Rewrite>(\n             }\n         }\n \n-        let nested_overhead = s.len() + 1;\n-        let line_shape = match context.config.binop_separator() {\n+        match context.config.binop_separator() {\n             SeparatorPlace::Back => {\n                 result.push(' ');\n                 result.push_str(s);\n                 result.push_str(&indent_str);\n-                nested_shape.sub_width(nested_overhead)?\n             }\n             SeparatorPlace::Front => {\n                 result.push_str(&indent_str);\n                 result.push_str(s);\n                 result.push(' ');\n-                nested_shape.offset_left(nested_overhead)?\n             }\n-        };\n+        }\n \n-        let rewrite = e.rewrite(context, line_shape)?;\n-        result.push_str(&rewrite);\n+        result.push_str(&default_rw.as_ref()?);\n     }\n     Some(result)\n }\n@@ -250,27 +238,46 @@ where\n \n // A pair which forms a tree and can be flattened (e.g., binops).\n trait FlattenPair: Rewrite + Sized {\n-    // If `_same_op` is `true`, then we only combine binops with the same\n-    // operator into the list. E.g,, if the source is `a * b + c`, if `_same_op`\n-    // is true, we make `[(a * b), c]` if `_same_op` is false, we make\n-    // `[a, b, c]`\n-    fn flatten(&self, _same_op: bool) -> Option<PairList<'_, '_, Self>> {\n+    fn flatten(&self, _: &RewriteContext<'_>, _: Shape) -> Option<PairList<'_, '_, Self>> {\n         None\n     }\n }\n \n struct PairList<'a, 'b, T: Rewrite> {\n-    list: Vec<&'b T>,\n+    list: Vec<(&'b T, Option<String>)>,\n     separators: Vec<&'a str>,\n }\n \n impl FlattenPair for ast::Expr {\n-    fn flatten(&self, same_op: bool) -> Option<PairList<'_, '_, ast::Expr>> {\n+    fn flatten(\n+        &self,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+    ) -> Option<PairList<'_, '_, ast::Expr>> {\n         let top_op = match self.node {\n             ast::ExprKind::Binary(op, _, _) => op.node,\n             _ => return None,\n         };\n \n+        let default_rewrite = |node: &ast::Expr, sep: usize, is_first: bool| {\n+            if is_first {\n+                return node.rewrite(context, shape);\n+            }\n+            let nested_overhead = sep + 1;\n+            let rhs_offset = shape.rhs_overhead(&context.config);\n+            let nested_shape = (match context.config.indent_style() {\n+                IndentStyle::Visual => shape.visual_indent(0),\n+                IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n+            })\n+            .with_max_width(&context.config)\n+            .sub_width(rhs_offset)?;\n+            let default_shape = match context.config.binop_separator() {\n+                SeparatorPlace::Back => nested_shape.sub_width(nested_overhead)?,\n+                SeparatorPlace::Front => nested_shape.offset_left(nested_overhead)?,\n+            };\n+            node.rewrite(context, default_shape)\n+        };\n+\n         // Turn a tree of binop expressions into a list using a depth-first,\n         // in-order traversal.\n         let mut stack = vec![];\n@@ -279,12 +286,14 @@ impl FlattenPair for ast::Expr {\n         let mut node = self;\n         loop {\n             match node.node {\n-                ast::ExprKind::Binary(op, ref lhs, _) if !same_op || op.node == top_op => {\n+                ast::ExprKind::Binary(op, ref lhs, _) if op.node == top_op => {\n                     stack.push(node);\n                     node = lhs;\n                 }\n                 _ => {\n-                    list.push(node);\n+                    let op_len = separators.last().map_or(0, |s: &&str| s.len());\n+                    let rw = default_rewrite(node, op_len, list.is_empty());\n+                    list.push((node, rw));\n                     if let Some(pop) = stack.pop() {\n                         match pop.node {\n                             ast::ExprKind::Binary(op, _, ref rhs) => {"}]}