{"sha": "ef81fca760067e887e1dc69413f004327d23bb7e", "node_id": "C_kwDOAAsO6NoAKGVmODFmY2E3NjAwNjdlODg3ZTFkYzY5NDEzZjAwNDMyN2QyM2JiN2U", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-07-27T15:55:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-27T15:55:01Z"}, "message": "Rollup merge of #94247 - saethlin:chunksmut-aliasing, r=the8472\n\nFix slice::ChunksMut aliasing\n\nFixes https://github.com/rust-lang/rust/issues/94231, details in that issue.\ncc `@RalfJung`\n\nThis isn't done just yet, all the safety comments are placeholders. But otherwise, it seems to work.\n\nI don't really like this approach though. There's a lot of unsafe code where there wasn't before, but as far as I can tell the only other way to uphold the aliasing requirement imposed by `__iterator_get_unchecked` is to use raw slices, which I think require the same amount of unsafe code. All that would do is tie the `len` and `ptr` fields together.\n\nOh I just looked and I'm pretty sure that `ChunksExactMut`, `RChunksMut`, and `RChunksExactMut` also need to be patched. Even more reason to put up a draft.", "tree": {"sha": "f422a1cde63dd156fc294db5719f34ce459c4653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f422a1cde63dd156fc294db5719f34ce459c4653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef81fca760067e887e1dc69413f004327d23bb7e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi4V/WCRBK7hj4Ov3rIwAAyAEIAJMyce/3SUQGzezrDhSSpcSO\nq1MS+kbrBdkz44ac9eTMaxLetPH7SfxzfH2/5yxZA9finalhBu3rk0zQX7YZpVGp\nBPQ9ZqOgv0LGl5s9SustV9cZ+3TFG6lE42VGls7sCbKw2nD1l7SL1igkxQuu0N41\nafKwrGwxs4cNu2Anx1huwGOk7AYxr5mt2O0ice6TYx8DyYTgQhjJBMvXinEj1KVA\nHrXYCAMKKktMqmfZvvdbGn8kdPuZKmc4Cv41fqFxKFWJhUZB8AkORcXf4nUCZmK4\nNpwIBDQNDIkwx1RXqOXBBSPWj+8ksBEErXE0awSLAK+mKlRCJM717hkuwmprjw4=\n=uK72\n-----END PGP SIGNATURE-----\n", "payload": "tree f422a1cde63dd156fc294db5719f34ce459c4653\nparent 2a220937c283803bfd5d1155e4a81e6287089504\nparent 746afe8952a026c24fd229474f40658cbc9e12c7\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1658937301 +0200\ncommitter GitHub <noreply@github.com> 1658937301 +0200\n\nRollup merge of #94247 - saethlin:chunksmut-aliasing, r=the8472\n\nFix slice::ChunksMut aliasing\n\nFixes https://github.com/rust-lang/rust/issues/94231, details in that issue.\ncc `@RalfJung`\n\nThis isn't done just yet, all the safety comments are placeholders. But otherwise, it seems to work.\n\nI don't really like this approach though. There's a lot of unsafe code where there wasn't before, but as far as I can tell the only other way to uphold the aliasing requirement imposed by `__iterator_get_unchecked` is to use raw slices, which I think require the same amount of unsafe code. All that would do is tie the `len` and `ptr` fields together.\n\nOh I just looked and I'm pretty sure that `ChunksExactMut`, `RChunksMut`, and `RChunksExactMut` also need to be patched. Even more reason to put up a draft.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef81fca760067e887e1dc69413f004327d23bb7e", "html_url": "https://github.com/rust-lang/rust/commit/ef81fca760067e887e1dc69413f004327d23bb7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef81fca760067e887e1dc69413f004327d23bb7e/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a220937c283803bfd5d1155e4a81e6287089504", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a220937c283803bfd5d1155e4a81e6287089504", "html_url": "https://github.com/rust-lang/rust/commit/2a220937c283803bfd5d1155e4a81e6287089504"}, {"sha": "746afe8952a026c24fd229474f40658cbc9e12c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/746afe8952a026c24fd229474f40658cbc9e12c7", "html_url": "https://github.com/rust-lang/rust/commit/746afe8952a026c24fd229474f40658cbc9e12c7"}], "stats": {"total": 238, "additions": 166, "deletions": 72}, "files": [{"sha": "76b4a534e5db5b7989904ac479c42624e60e4a30", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 122, "deletions": 72, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ef81fca760067e887e1dc69413f004327d23bb7e/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef81fca760067e887e1dc69413f004327d23bb7e/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=ef81fca760067e887e1dc69413f004327d23bb7e", "patch": "@@ -1628,14 +1628,21 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksMut<'a, T: 'a> {\n-    v: &'a mut [T],\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n+    v: *mut [T],\n     chunk_size: usize,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n impl<'a, T: 'a> ChunksMut<'a, T> {\n     #[inline]\n     pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n-        Self { v: slice, chunk_size: size }\n+        Self { v: slice, chunk_size: size, _marker: PhantomData }\n     }\n }\n \n@@ -1649,10 +1656,11 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(sz);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, tail) = unsafe { self.v.split_at_mut(sz) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -1684,11 +1692,13 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n                 Some(sum) => cmp::min(self.v.len(), sum),\n                 None => self.v.len(),\n             };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(end);\n-            let (_, nth) = head.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (_, nth) = unsafe { head.split_at_mut(start) };\n             self.v = tail;\n-            Some(nth)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth })\n         }\n     }\n \n@@ -1698,13 +1708,14 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             None\n         } else {\n             let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n-            Some(&mut self.v[start..])\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *self.v.get_unchecked_mut(start..) })\n         }\n     }\n \n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n-        // SAFETY: see comments for `Chunks::__iterator_get_unchecked`.\n+        // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.\n         //\n         // Also note that the caller also guarantees that we're never called\n         // with the same index again, and that no other methods that will\n@@ -1726,12 +1737,12 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n+            let len = self.v.len();\n             // SAFETY: Similar to `Chunks::next_back`\n-            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n+            let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -1747,10 +1758,13 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n                 Some(res) => cmp::min(self.v.len(), res),\n                 None => self.v.len(),\n             };\n-            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (head, nth_back) = temp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (temp, _tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n-            Some(nth_back)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -1956,9 +1970,16 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for ChunksExact<'a, T> {\n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksExactMut<'a, T: 'a> {\n-    v: &'a mut [T],\n-    rem: &'a mut [T],\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n+    v: *mut [T],\n+    rem: &'a mut [T], // The iterator never yields from here, so this can be unique\n     chunk_size: usize,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n impl<'a, T> ChunksExactMut<'a, T> {\n@@ -1968,7 +1989,7 @@ impl<'a, T> ChunksExactMut<'a, T> {\n         let fst_len = slice.len() - rem;\n         // SAFETY: 0 <= fst_len <= slice.len() by construction above\n         let (fst, snd) = unsafe { slice.split_at_mut_unchecked(fst_len) };\n-        Self { v: fst, rem: snd, chunk_size }\n+        Self { v: fst, rem: snd, chunk_size, _marker: PhantomData }\n     }\n \n     /// Returns the remainder of the original slice that is not going to be\n@@ -1990,10 +2011,11 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            // SAFETY: self.chunk_size is inbounds because we compared above against self.v.len()\n+            let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -2015,8 +2037,8 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n             self.v = &mut [];\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (_, snd) = tmp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (_, snd) = unsafe { self.v.split_at_mut(start) };\n             self.v = snd;\n             self.next()\n         }\n@@ -2029,7 +2051,7 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n \n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n-        // SAFETY: see comments for `ChunksMut::__iterator_get_unchecked`.\n+        // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.\n         unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n }\n@@ -2041,11 +2063,11 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            // SAFETY: This subtraction is inbounds because of the check above\n+            let (head, tail) = unsafe { self.v.split_at_mut(self.v.len() - self.chunk_size) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -2058,10 +2080,13 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n         } else {\n             let start = (len - 1 - n) * self.chunk_size;\n             let end = start + self.chunk_size;\n-            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (head, nth_back) = temp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (temp, _tail) = unsafe { mem::replace(&mut self.v, &mut []).split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n-            Some(nth_back)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -2645,14 +2670,21 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunks<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksMut<'a, T: 'a> {\n-    v: &'a mut [T],\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n+    v: *mut [T],\n     chunk_size: usize,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n impl<'a, T: 'a> RChunksMut<'a, T> {\n     #[inline]\n     pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n-        Self { v: slice, chunk_size: size }\n+        Self { v: slice, chunk_size: size, _marker: PhantomData }\n     }\n }\n \n@@ -2666,16 +2698,16 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n+            let len = self.v.len();\n             // SAFETY: split_at_mut_unchecked just requires the argument be less\n             // than the length. This could only happen if the expression\n-            // `tmp_len - sz` overflows. This could only happen if `sz >\n-            // tmp_len`, which is impossible as we initialize it as the `min` of\n-            // `self.v.len()` (e.g. `tmp_len`) and `self.chunk_size`.\n-            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(tmp_len - sz) };\n+            // `len - sz` overflows. This could only happen if `sz >\n+            // len`, which is impossible as we initialize it as the `min` of\n+            // `self.v.len()` (e.g. `len`) and `self.chunk_size`.\n+            let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -2709,11 +2741,15 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n                 Some(sum) => sum,\n                 None => 0,\n             };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(start);\n-            let (nth, _) = tail.split_at_mut(end - start);\n+            // SAFETY: This type ensures that self.v is a valid pointer with a correct len.\n+            // Therefore the bounds check in split_at_mut guarantess the split point is inbounds.\n+            let (head, tail) = unsafe { self.v.split_at_mut(start) };\n+            // SAFETY: This type ensures that self.v is a valid pointer with a correct len.\n+            // Therefore the bounds check in split_at_mut guarantess the split point is inbounds.\n+            let (nth, _) = unsafe { tail.split_at_mut(end - start) };\n             self.v = head;\n-            Some(nth)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth })\n         }\n     }\n \n@@ -2724,7 +2760,8 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n         } else {\n             let rem = self.v.len() % self.chunk_size;\n             let end = if rem == 0 { self.chunk_size } else { rem };\n-            Some(&mut self.v[0..end])\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *self.v.get_unchecked_mut(0..end) })\n         }\n     }\n \n@@ -2735,7 +2772,7 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             Some(start) => start,\n         };\n         // SAFETY: see comments for `RChunks::__iterator_get_unchecked` and\n-        // `ChunksMut::__iterator_get_unchecked`\n+        // `ChunksMut::__iterator_get_unchecked`, `self.v`.\n         unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n     }\n }\n@@ -2749,11 +2786,11 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n         } else {\n             let remainder = self.v.len() % self.chunk_size;\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n             // SAFETY: Similar to `Chunks::next_back`\n-            let (head, tail) = unsafe { tmp.split_at_mut_unchecked(sz) };\n+            let (head, tail) = unsafe { self.v.split_at_mut_unchecked(sz) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -2768,10 +2805,13 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             let offset_from_end = (len - 1 - n) * self.chunk_size;\n             let end = self.v.len() - offset_from_end;\n             let start = end.saturating_sub(self.chunk_size);\n-            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (_, nth_back) = tmp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n-            Some(nth_back)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }\n@@ -2897,8 +2937,7 @@ impl<'a, T> Iterator for RChunksExact<'a, T> {\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = end - self.chunk_size;\n-        // SAFETY:\n-        // SAFETY: mostmy identical to `Chunks::__iterator_get_unchecked`.\n+        // SAFETY: mostly identical to `Chunks::__iterator_get_unchecked`.\n         unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n     }\n }\n@@ -2981,7 +3020,13 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunksExact<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksExactMut<'a, T: 'a> {\n-    v: &'a mut [T],\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n+    v: *mut [T],\n     rem: &'a mut [T],\n     chunk_size: usize,\n }\n@@ -3014,11 +3059,12 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.split_at_mut(tmp_len - self.chunk_size);\n+            let len = self.v.len();\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, tail) = unsafe { self.v.split_at_mut(len - self.chunk_size) };\n             self.v = head;\n-            Some(tail)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *tail })\n         }\n     }\n \n@@ -3040,9 +3086,9 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n             self.v = &mut [];\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (fst, _) = tmp.split_at_mut(tmp_len - end);\n+            let len = self.v.len();\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (fst, _) = unsafe { self.v.split_at_mut(len - end) };\n             self.v = fst;\n             self.next()\n         }\n@@ -3056,7 +3102,7 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = end - self.chunk_size;\n-        // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked`.\n+        // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked` and `self.v`.\n         unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n }\n@@ -3068,10 +3114,11 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.split_at_mut(self.chunk_size);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };\n             self.v = tail;\n-            Some(head)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *head })\n         }\n     }\n \n@@ -3087,10 +3134,13 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n             let offset = (len - n) * self.chunk_size;\n             let start = self.v.len() - offset;\n             let end = start + self.chunk_size;\n-            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n-            let (_, nth_back) = tmp.split_at_mut(start);\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n+            let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n-            Some(nth_back)\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n+            Some(unsafe { &mut *nth_back })\n         }\n     }\n }"}, {"sha": "6d1516958f39bd49b38217d196bcb1d11fb16c8c", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ef81fca760067e887e1dc69413f004327d23bb7e/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef81fca760067e887e1dc69413f004327d23bb7e/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=ef81fca760067e887e1dc69413f004327d23bb7e", "patch": "@@ -409,6 +409,50 @@ fn test_chunks_mut_zip() {\n     assert_eq!(v1, [13, 14, 19, 20, 14]);\n }\n \n+#[test]\n+fn test_chunks_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.chunks_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [0, 1][..], &[6, 7][..]));\n+}\n+\n+#[test]\n+fn test_chunks_exact_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.chunks_exact_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [0, 1][..], &[6, 7][..]));\n+}\n+\n+#[test]\n+fn test_rchunks_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.rchunks_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [3, 4][..], &[6, 7][..]));\n+}\n+\n+#[test]\n+fn test_rchunks_exact_mut_zip_aliasing() {\n+    let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let mut it = v1.rchunks_exact_mut(2).zip(v2.chunks(2));\n+    let first = it.next().unwrap();\n+    let _ = it.next().unwrap();\n+    assert_eq!(first, (&mut [3, 4][..], &[6, 7][..]));\n+}\n+\n #[test]\n fn test_chunks_exact_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];"}]}