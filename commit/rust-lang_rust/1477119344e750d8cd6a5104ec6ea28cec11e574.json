{"sha": "1477119344e750d8cd6a5104ec6ea28cec11e574", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NzcxMTkzNDRlNzUwZDhjZDZhNTEwNGVjNmVhMjhjZWMxMWU1NzQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-20T15:17:23Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:32Z"}, "message": "rustc_trans: keep a layout instead of a type in {Lvalue,Operand}Ref.", "tree": {"sha": "3358f437ae8d63af3964ef1fd956dc55c3ffa8c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3358f437ae8d63af3964ef1fd956dc55c3ffa8c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1477119344e750d8cd6a5104ec6ea28cec11e574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1477119344e750d8cd6a5104ec6ea28cec11e574", "html_url": "https://github.com/rust-lang/rust/commit/1477119344e750d8cd6a5104ec6ea28cec11e574", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1477119344e750d8cd6a5104ec6ea28cec11e574/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88f70323e451f63f812c6cd92cc1d654b32971e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/88f70323e451f63f812c6cd92cc1d654b32971e1", "html_url": "https://github.com/rust-lang/rust/commit/88f70323e451f63f812c6cd92cc1d654b32971e1"}], "stats": {"total": 788, "additions": 374, "deletions": 414}, "files": [{"sha": "cdb0d9f4451b6bba1ed34a2103d4f324ffb71fdd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -771,6 +771,15 @@ impl Abi {\n         }\n     }\n \n+    /// Returns true if the type is a ZST and not unsized.\n+    pub fn is_zst(&self) -> bool {\n+        match *self {\n+            Abi::Scalar(_) => false,\n+            Abi::Vector { count, .. } => count == 0,\n+            Abi::Aggregate { sized, size, .. } => sized && size.bytes() == 0\n+        }\n+    }\n+\n     pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n         let dl = cx.data_layout();\n \n@@ -1377,7 +1386,7 @@ impl<'a, 'tcx> Layout {\n                    no_explicit_discriminants {\n                     // Nullable pointer optimization\n                     for i in 0..2 {\n-                        if !variants[1 - i].iter().all(|f| f.size(dl).bytes() == 0) {\n+                        if !variants[1 - i].iter().all(|f| f.is_zst()) {\n                             continue;\n                         }\n \n@@ -1456,7 +1465,7 @@ impl<'a, 'tcx> Layout {\n                     for i in st.fields.index_by_increasing_offset() {\n                         let field = field_layouts[i];\n                         let field_align = field.align(dl);\n-                        if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n+                        if !field.is_zst() || field_align.abi() != 1 {\n                             start_align = start_align.min(field_align);\n                             break;\n                         }\n@@ -2145,6 +2154,11 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n         self.abi.is_packed()\n     }\n \n+    /// Returns true if the type is a ZST and not unsized.\n+    pub fn is_zst(&self) -> bool {\n+        self.abi.is_zst()\n+    }\n+\n     pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n         self.abi.size(cx)\n     }"}, {"sha": "0b09bca7b6889d4565dacb5d4ab21e04922c88ca", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -697,7 +697,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n             if ty.is_bool() {\n                 arg.attrs.set(ArgAttribute::ZExt);\n             } else {\n-                if arg.layout.size(ccx).bytes() == 0 {\n+                if arg.layout.is_zst() {\n                     // For some forsaken reason, x86_64-pc-windows-gnu\n                     // doesn't ignore zero-sized struct arguments.\n                     // The same is true for s390x-unknown-linux-gnu."}, {"sha": "44bdc75f8461f183a0ad84eb8c951b8371c9f55c", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -16,10 +16,9 @@ use type_::Type;\n use builder::Builder;\n \n use rustc::hir;\n-use rustc::ty::Ty;\n-use rustc::ty::layout::Align;\n \n-use mir::lvalue::{LvalueRef, Alignment};\n+use mir::lvalue::LvalueRef;\n+use mir::operand::OperandValue;\n \n use std::ffi::CString;\n use syntax::ast::AsmDialect;\n@@ -29,29 +28,23 @@ use libc::{c_uint, c_char};\n pub fn trans_inline_asm<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     ia: &hir::InlineAsm,\n-    outputs: Vec<(ValueRef, Ty<'tcx>)>,\n+    outputs: Vec<LvalueRef<'tcx>>,\n     mut inputs: Vec<ValueRef>\n ) {\n     let mut ext_constraints = vec![];\n     let mut output_types = vec![];\n \n     // Prepare the output operands\n     let mut indirect_outputs = vec![];\n-    for (i, (out, &(val, ty))) in ia.outputs.iter().zip(&outputs).enumerate() {\n-        let val = if out.is_rw || out.is_indirect {\n-            Some(LvalueRef::new_sized(val, ty,\n-                Alignment::Packed(Align::from_bytes(1, 1).unwrap())).load(bcx))\n-        } else {\n-            None\n-        };\n+    for (i, (out, lvalue)) in ia.outputs.iter().zip(&outputs).enumerate() {\n         if out.is_rw {\n-            inputs.push(val.unwrap().immediate());\n+            inputs.push(lvalue.load(bcx).immediate());\n             ext_constraints.push(i.to_string());\n         }\n         if out.is_indirect {\n-            indirect_outputs.push(val.unwrap().immediate());\n+            indirect_outputs.push(lvalue.load(bcx).immediate());\n         } else {\n-            output_types.push(bcx.ccx.llvm_type_of(ty));\n+            output_types.push(bcx.ccx.llvm_type_of(lvalue.layout.ty));\n         }\n     }\n     if !indirect_outputs.is_empty() {\n@@ -106,9 +99,9 @@ pub fn trans_inline_asm<'a, 'tcx>(\n \n     // Again, based on how many outputs we have\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n-    for (i, (_, &(val, _))) in outputs.enumerate() {\n+    for (i, (_, &lvalue)) in outputs.enumerate() {\n         let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i as u64) };\n-        bcx.store(v, val, None);\n+        OperandValue::Immediate(v).store(bcx, lvalue);\n     }\n \n     // Store mark in a metadata node so we can map LLVM errors"}, {"sha": "036f1dfbcfd965d565bbfc9181309132215eb16d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -40,7 +40,7 @@ use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::Align;\n+use rustc::ty::layout::{Align, FullLayout};\n use rustc::ty::maps::Providers;\n use rustc::dep_graph::{DepNode, DepKind, DepConstructor};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n@@ -55,10 +55,7 @@ use builder::Builder;\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use collector::{self, TransItemCollectionMode};\n-use common::{C_struct_in_context, C_array};\n-use common::CrateContext;\n-use common::{type_is_zero_size, val_ty};\n-use common;\n+use common::{self, C_struct_in_context, C_array, CrateContext, val_ty};\n use consts;\n use context::{self, LocalCrateContext, SharedCrateContext};\n use debuginfo;\n@@ -88,7 +85,7 @@ use syntax::attr;\n use rustc::hir;\n use syntax::ast;\n \n-use mir::operand::{OperandRef, OperandValue};\n+use mir::operand::OperandValue;\n \n pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n pub use rustc_trans_utils::trans_item::linkage_by_name;\n@@ -249,8 +246,8 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                      src: LvalueRef<'tcx>,\n                                      dst: LvalueRef<'tcx>) {\n-    let src_ty = src.ty.to_ty(bcx.tcx());\n-    let dst_ty = dst.ty.to_ty(bcx.tcx());\n+    let src_ty = src.layout.ty;\n+    let dst_ty = dst.layout.ty;\n     let coerce_ptr = || {\n         let (base, info) = match src.load(bcx).val {\n             OperandValue::Pair(base, info) => {\n@@ -266,10 +263,7 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             }\n             OperandValue::Ref(..) => bug!()\n         };\n-        OperandRef {\n-            val: OperandValue::Pair(base, info),\n-            ty: dst_ty\n-        }.store(bcx, dst);\n+        OperandValue::Pair(base, info).store(bcx, dst);\n     };\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n@@ -288,15 +282,12 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let src_f = src.project_field(bcx, i);\n                 let dst_f = dst.project_field(bcx, i);\n \n-                let src_f_ty = src_f.ty.to_ty(bcx.tcx());\n-                let dst_f_ty = dst_f.ty.to_ty(bcx.tcx());\n-\n-                if type_is_zero_size(bcx.ccx, dst_f_ty) {\n+                if dst_f.layout.is_zst() {\n                     continue;\n                 }\n \n-                if src_f_ty == dst_f_ty {\n-                    memcpy_ty(bcx, dst_f.llval, src_f.llval, src_f_ty,\n+                if src_f.layout.ty == dst_f.layout.ty {\n+                    memcpy_ty(bcx, dst_f.llval, src_f.llval, src_f.layout,\n                         (src_f.alignment | dst_f.alignment).non_abi());\n                 } else {\n                     coerce_unsized_into(bcx, src_f, dst_f);\n@@ -409,17 +400,17 @@ pub fn memcpy_ty<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n     dst: ValueRef,\n     src: ValueRef,\n-    t: Ty<'tcx>,\n+    layout: FullLayout<'tcx>,\n     align: Option<Align>,\n ) {\n     let ccx = bcx.ccx;\n \n-    let size = ccx.size_of(t).bytes();\n+    let size = layout.size(ccx).bytes();\n     if size == 0 {\n         return;\n     }\n \n-    let align = align.unwrap_or_else(|| ccx.align_of(t));\n+    let align = align.unwrap_or_else(|| layout.align(ccx));\n     call_memcpy(bcx, dst, src, C_usize(ccx, size), align);\n }\n "}, {"sha": "00e8562c2a134e6c955c711ec9a5a29c51b3c73e", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -58,7 +58,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                           off: Size)\n                           -> Result<(), Memory> {\n         if !off.is_abi_aligned(layout.align(ccx)) {\n-            if layout.size(ccx).bytes() > 0 {\n+            if !layout.is_zst() {\n                 return Err(Memory);\n             }\n             return Ok(());"}, {"sha": "55f02ed5f917127986fe0de136e7e38feb6da464", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -58,9 +58,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     match layout.abi {\n         layout::Abi::Scalar(_) | layout::Abi::Vector { .. } => true,\n \n-        layout::Abi::Aggregate { .. } => {\n-            !layout.is_unsized() && layout.size(ccx).bytes() == 0\n-        }\n+        layout::Abi::Aggregate { .. } => layout.is_zst()\n     }\n }\n \n@@ -83,12 +81,6 @@ pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n     }\n }\n \n-/// Identify types which have size zero at runtime.\n-pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    let layout = ccx.layout_of(ty);\n-    !layout.is_unsized() && layout.size(ccx).bytes() == 0\n-}\n-\n pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.needs_drop(tcx, ty::ParamEnv::empty(traits::Reveal::All))\n }"}, {"sha": "c0df25202d8a9379f2730cf27ae7813ebdc59233", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -335,8 +335,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.extend(inputs.iter().map(|&t| {\n                 let t = match t.sty {\n                     ty::TyArray(ct, _)\n-                        if (ct == cx.tcx().types.u8) ||\n-                           (cx.layout_of(ct).size(cx).bytes() == 0) => {\n+                        if (ct == cx.tcx().types.u8) || cx.layout_of(ct).is_zst() => {\n                         cx.tcx().mk_imm_ptr(ct)\n                     }\n                     _ => t"}, {"sha": "1cdd192bfeda67a274c69c130aae398c4fb89ceb", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -22,7 +22,7 @@ use declare;\n use glue;\n use type_::Type;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::HasDataLayout;\n+use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -86,7 +86,7 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n /// add them to librustc_trans/trans/context.rs\n pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                       callee_ty: Ty<'tcx>,\n-                                      fn_ty: &FnType,\n+                                      fn_ty: &FnType<'tcx>,\n                                       args: &[OperandRef<'tcx>],\n                                       llresult: ValueRef,\n                                       span: Span) {\n@@ -105,7 +105,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let name = &*tcx.item_name(def_id);\n \n     let llret_ty = ccx.llvm_type_of(ret_ty);\n-    let result = LvalueRef::new_sized(llresult, ret_ty, Alignment::AbiAligned);\n+    let result = LvalueRef::new_sized(llresult, fn_ty.ret.layout, Alignment::AbiAligned);\n \n     let simple = get_simple_intrinsic(ccx, name);\n     let llval = match name {\n@@ -179,7 +179,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         }\n         \"init\" => {\n             let ty = substs.type_at(0);\n-            if !type_is_zero_size(ccx, ty) {\n+            if !ccx.layout_of(ty).is_zst() {\n                 // Just zero out the stack slot.\n                 // If we store a zero constant, LLVM will drown in vreg allocation for large data\n                 // structures, and the generated code will be awful. (A telltale sign of this is\n@@ -247,15 +247,15 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         },\n         \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);\n-            let dst = LvalueRef::new_sized(args[0].immediate(), tp_ty, Alignment::AbiAligned);\n+            let dst = args[0].deref(bcx.ccx);\n             if let OperandValue::Pair(a, b) = args[1].val {\n                 bcx.volatile_store(a, dst.project_field(bcx, 0).llval);\n                 bcx.volatile_store(b, dst.project_field(bcx, 1).llval);\n             } else {\n                 let val = if let OperandValue::Ref(ptr, align) = args[1].val {\n                     bcx.load(ptr, align.non_abi())\n                 } else {\n-                    if type_is_zero_size(ccx, tp_ty) {\n+                    if dst.layout.is_zst() {\n                         return;\n                     }\n                     from_immediate(bcx, args[1].immediate())\n@@ -393,13 +393,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         },\n \n         \"discriminant_value\" => {\n-            let val_ty = substs.type_at(0);\n-            let adt_val = LvalueRef::new_sized(args[0].immediate(),\n-                                               val_ty,\n-                                               Alignment::AbiAligned);\n-            match val_ty.sty {\n+            match substs.type_at(0).sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    adt_val.trans_get_discr(bcx, ret_ty)\n+                    args[0].deref(bcx.ccx).trans_get_discr(bcx, ret_ty)\n                 }\n                 _ => C_null(llret_ty)\n             }\n@@ -612,12 +608,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // This assumes the type is \"simple\", i.e. no\n                         // destructors, and the contents are SIMD\n                         // etc.\n-                        assert!(!bcx.ccx.shared().type_needs_drop(arg.ty));\n+                        assert!(!bcx.ccx.shared().type_needs_drop(arg.layout.ty));\n                         let (ptr, align) = match arg.val {\n                             OperandValue::Ref(ptr, align) => (ptr, align),\n                             _ => bug!()\n                         };\n-                        let arg = LvalueRef::new_sized(ptr, arg.ty, align);\n+                        let arg = LvalueRef::new_sized(ptr, arg.layout, align);\n                         (0..contents.len()).map(|i| {\n                             arg.project_field(bcx, i).load(bcx).immediate()\n                         }).collect()\n@@ -685,8 +681,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         } else {\n             OperandRef {\n                 val: OperandValue::Immediate(llval),\n-                ty: ret_ty\n-            }.unpack_if_pair(bcx).store(bcx, result);\n+                layout: result.layout\n+            }.unpack_if_pair(bcx).val.store(bcx, result);\n         }\n     }\n }"}, {"sha": "bca33a8c3074e2d6fd54f90289f763ce094e1d62", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -18,6 +18,7 @@ use rustc::mir::{self, Location, TerminatorKind, Literal};\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use rustc::ty;\n+use rustc::ty::layout::LayoutOf;\n use common;\n use super::MirContext;\n \n@@ -34,7 +35,7 @@ pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n             ty.is_box() ||\n             ty.is_region_ptr() ||\n             ty.is_simd() ||\n-            common::type_is_zero_size(mircx.ccx, ty)\n+            mircx.ccx.layout_of(ty).is_zst()\n         {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca."}, {"sha": "82d5dabc86c7aacbdf6cfe39fa67e69b6183273b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 51, "deletions": 60, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, BasicBlockRef};\n use rustc::middle::lang_items;\n use rustc::middle::const_val::{ConstEvalErr, ConstInt, ErrKind};\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::LayoutOf;\n use rustc::traits;\n use rustc::mir;\n@@ -116,11 +116,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             fn_ty: FnType<'tcx>,\n             fn_ptr: ValueRef,\n             llargs: &[ValueRef],\n-            destination: Option<(ReturnDest<'tcx>, Ty<'tcx>, mir::BasicBlock)>,\n+            destination: Option<(ReturnDest<'tcx>, mir::BasicBlock)>,\n             cleanup: Option<mir::BasicBlock>\n         | {\n             if let Some(cleanup) = cleanup {\n-                let ret_bcx = if let Some((_, _, target)) = destination {\n+                let ret_bcx = if let Some((_, target)) = destination {\n                     this.blocks[target]\n                 } else {\n                     this.unreachable_block()\n@@ -132,12 +132,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                            cleanup_bundle);\n                 fn_ty.apply_attrs_callsite(invokeret);\n \n-                if let Some((ret_dest, ret_ty, target)) = destination {\n+                if let Some((ret_dest, target)) = destination {\n                     let ret_bcx = this.get_builder(target);\n                     this.set_debug_loc(&ret_bcx, terminator.source_info);\n                     let op = OperandRef {\n                         val: Immediate(invokeret),\n-                        ty: ret_ty,\n+                        layout: fn_ty.ret.layout,\n                     };\n                     this.store_return(&ret_bcx, ret_dest, &fn_ty.ret, op);\n                 }\n@@ -152,10 +152,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n                 }\n \n-                if let Some((ret_dest, ret_ty, target)) = destination {\n+                if let Some((ret_dest, target)) = destination {\n                     let op = OperandRef {\n                         val: Immediate(llret),\n-                        ty: ret_ty,\n+                        layout: fn_ty.ret.layout,\n                     };\n                     this.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n                     funclet_br(this, bcx, target);\n@@ -227,14 +227,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         LocalRef::Lvalue(tr_lvalue) => {\n                             OperandRef {\n                                 val: Ref(tr_lvalue.llval, tr_lvalue.alignment),\n-                                ty: tr_lvalue.ty.to_ty(bcx.tcx())\n+                                layout: tr_lvalue.layout\n                             }\n                         }\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let scratch = LvalueRef::alloca(&bcx, self.fn_ty.ret.layout.ty, \"ret\");\n-                            op.store(&bcx, scratch);\n+                            let scratch = LvalueRef::alloca(&bcx, self.fn_ty.ret.layout, \"ret\");\n+                            op.val.store(&bcx, scratch);\n                             scratch.llval\n                         }\n                         Ref(llval, align) => {\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 let args = &[lvalue.llval, lvalue.llextra][..1 + need_extra as usize];\n                 do_call(self, bcx, fn_ty, drop_fn, args,\n-                        Some((ReturnDest::Nothing, tcx.mk_nil(), target)),\n+                        Some((ReturnDest::Nothing, target)),\n                         unwind);\n             }\n \n@@ -427,7 +427,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n-                let (instance, mut llfn) = match callee.ty.sty {\n+                let (instance, mut llfn) = match callee.layout.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n                         (Some(ty::Instance::resolve(bcx.ccx.tcx(),\n                                                     ty::ParamEnv::empty(traits::Reveal::All),\n@@ -438,10 +438,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     ty::TyFnPtr(_) => {\n                         (None, Some(callee.immediate()))\n                     }\n-                    _ => bug!(\"{} is not callable\", callee.ty)\n+                    _ => bug!(\"{} is not callable\", callee.layout.ty)\n                 };\n                 let def = instance.map(|i| i.def);\n-                let sig = callee.ty.fn_sig(bcx.tcx());\n+                let sig = callee.layout.ty.fn_sig(bcx.tcx());\n                 let sig = bcx.tcx().erase_late_bound_regions_and_normalize(&sig);\n                 let abi = sig.abi;\n \n@@ -520,7 +520,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     let val = self.trans_constant(&bcx, constant);\n                                     return OperandRef {\n                                         val: Immediate(val.llval),\n-                                        ty: val.ty\n+                                        layout: bcx.ccx.layout_of(val.ty)\n                                     };\n                                 }\n                             }\n@@ -539,7 +539,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // Make a fake operand for store_return\n                         let op = OperandRef {\n                             val: Ref(dst.llval, Alignment::AbiAligned),\n-                            ty: sig.output(),\n+                            layout: fn_ty.ret.layout,\n                         };\n                         self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n                     }\n@@ -577,8 +577,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // The callee needs to own the argument memory if we pass it\n                     // by-ref, so make a local copy of non-immediate constants.\n                     if let (&mir::Operand::Constant(_), Ref(..)) = (arg, op.val) {\n-                        let tmp = LvalueRef::alloca(&bcx, op.ty, \"const\");\n-                        op.store(&bcx, tmp);\n+                        let tmp = LvalueRef::alloca(&bcx, op.layout, \"const\");\n+                        op.val.store(&bcx, tmp);\n                         op.val = Ref(tmp.llval, tmp.alignment);\n                     }\n \n@@ -596,7 +596,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n \n                 do_call(self, bcx, fn_ty, fn_ptr, &llargs,\n-                        destination.as_ref().map(|&(_, target)| (ret_dest, sig.output(), target)),\n+                        destination.as_ref().map(|&(_, target)| (ret_dest, target)),\n                         cleanup);\n             }\n             mir::TerminatorKind::GeneratorDrop |\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let imm_op = |x| OperandRef {\n                     val: Immediate(x),\n                     // We won't be checking the type again.\n-                    ty: bcx.tcx().types.err\n+                    layout: bcx.ccx.layout_of(bcx.tcx().types.never)\n                 };\n                 self.trans_argument(bcx, imm_op(a), llargs, &arg.nested[0]);\n                 self.trans_argument(bcx, imm_op(b), llargs, &arg.nested[1]);\n@@ -638,8 +638,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n-                    let scratch = LvalueRef::alloca(bcx, arg.layout.ty, \"arg\");\n-                    op.store(bcx, scratch);\n+                    let scratch = LvalueRef::alloca(bcx, arg.layout, \"arg\");\n+                    op.val.store(bcx, scratch);\n                     (scratch.llval, Alignment::AbiAligned, true)\n                 } else {\n                     (op.pack_if_pair(bcx).immediate(), Alignment::AbiAligned, false)\n@@ -650,8 +650,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n-                let scratch = LvalueRef::alloca(bcx, arg.layout.ty, \"arg\");\n-                base::memcpy_ty(bcx, scratch.llval, llval, op.ty, align.non_abi());\n+                let scratch = LvalueRef::alloca(bcx, arg.layout, \"arg\");\n+                base::memcpy_ty(bcx, scratch.llval, llval, op.layout, align.non_abi());\n                 (scratch.llval, Alignment::AbiAligned, true)\n             }\n             Ref(llval, align) => (llval, align, true)\n@@ -682,32 +682,31 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 args: &[ArgType<'tcx>]) {\n         let tuple = self.trans_operand(bcx, operand);\n \n-        let arg_types = match tuple.ty.sty {\n+        let arg_types = match tuple.layout.ty.sty {\n             ty::TyTuple(ref tys, _) => tys,\n             _ => span_bug!(self.mir.span,\n-                           \"bad final argument to \\\"rust-call\\\" fn {:?}\", tuple.ty)\n+                           \"bad final argument to \\\"rust-call\\\" fn {:?}\", tuple.layout.ty)\n         };\n \n         // Handle both by-ref and immediate tuples.\n         match tuple.val {\n             Ref(llval, align) => {\n-                let tuple_ptr = LvalueRef::new_sized(llval, tuple.ty, align);\n+                let tuple_ptr = LvalueRef::new_sized(llval, tuple.layout, align);\n                 for n in 0..arg_types.len() {\n                     let field_ptr = tuple_ptr.project_field(bcx, n);\n                     self.trans_argument(bcx, field_ptr.load(bcx), llargs, &args[n]);\n                 }\n \n             }\n             Immediate(llval) => {\n-                let layout = bcx.ccx.layout_of(tuple.ty);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = bcx.extract_value(llval, layout.llvm_field_index(n));\n+                    let mut elem = bcx.extract_value(llval, tuple.layout.llvm_field_index(n));\n                     // Truncate bools to i1, if needed\n                     elem = base::to_immediate(bcx, elem, ty);\n                     // If the tuple is immediate, the elements are as well\n                     let op = OperandRef {\n                         val: Immediate(elem),\n-                        ty,\n+                        layout: bcx.ccx.layout_of(ty),\n                     };\n                     self.trans_argument(bcx, op, llargs, &args[n]);\n                 }\n@@ -719,7 +718,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // Pair is always made up of immediates\n                     let op = OperandRef {\n                         val: Immediate(elem),\n-                        ty,\n+                        layout: bcx.ccx.layout_of(ty),\n                     };\n                     self.trans_argument(bcx, op, llargs, &args[n]);\n                 }\n@@ -733,11 +732,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         if let Some(slot) = self.personality_slot {\n             slot\n         } else {\n-            let ty = ccx.tcx().intern_tup(&[\n+            let layout = ccx.layout_of(ccx.tcx().intern_tup(&[\n                 ccx.tcx().mk_mut_ptr(ccx.tcx().types.u8),\n                 ccx.tcx().types.i32\n-            ], false);\n-            let slot = LvalueRef::alloca(bcx, ty, \"personalityslot\");\n+            ], false));\n+            let slot = LvalueRef::alloca(bcx, layout, \"personalityslot\");\n             self.personality_slot = Some(slot);\n             slot\n         }\n@@ -764,18 +763,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let bcx = self.new_block(\"cleanup\");\n \n-        let ccx = bcx.ccx;\n         let llpersonality = self.ccx.eh_personality();\n         let llretty = self.landing_pad_type();\n         let lp = bcx.landing_pad(llretty, llpersonality, 1, self.llfn);\n         bcx.set_cleanup(lp);\n \n         let slot = self.get_personality_slot(&bcx);\n         slot.storage_live(&bcx);\n-        OperandRef {\n-            val: Pair(bcx.extract_value(lp, 0), bcx.extract_value(lp, 1)),\n-            ty: slot.ty.to_ty(ccx.tcx())\n-        }.store(&bcx, slot);\n+        Pair(bcx.extract_value(lp, 0), bcx.extract_value(lp, 1)).store(&bcx, slot);\n \n         bcx.br(target_bb);\n         bcx.llbb()\n@@ -806,32 +801,31 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn make_return_dest(&mut self, bcx: &Builder<'a, 'tcx>,\n-                        dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n+                        dest: &mir::Lvalue<'tcx>, fn_ret: &ArgType<'tcx>,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool)\n                         -> ReturnDest<'tcx> {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n-        if fn_ret_ty.is_ignore() {\n+        if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n         let dest = if let mir::Lvalue::Local(index) = *dest {\n-            let ret_ty = self.monomorphized_lvalue_ty(dest);\n             match self.locals[index] {\n                 LocalRef::Lvalue(dest) => dest,\n                 LocalRef::Operand(None) => {\n                     // Handle temporary lvalues, specifically Operand ones, as\n                     // they don't have allocas\n-                    return if fn_ret_ty.is_indirect() {\n+                    return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = LvalueRef::alloca(bcx, ret_ty, \"tmp_ret\");\n+                        let tmp = LvalueRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n                         tmp.storage_live(bcx);\n                         llargs.push(tmp.llval);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result. so we create a temporary alloca for the\n                         // result\n-                        let tmp = LvalueRef::alloca(bcx, ret_ty, \"tmp_ret\");\n+                        let tmp = LvalueRef::alloca(bcx, fn_ret.layout, \"tmp_ret\");\n                         tmp.storage_live(bcx);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n@@ -845,7 +839,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         } else {\n             self.trans_lvalue(bcx, dest)\n         };\n-        if fn_ret_ty.is_indirect() {\n+        if fn_ret.is_indirect() {\n             match dest.alignment {\n                 Alignment::AbiAligned => {\n                     llargs.push(dest.llval);\n@@ -873,18 +867,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             match self.locals[index] {\n                 LocalRef::Lvalue(lvalue) => self.trans_transmute_into(bcx, src, lvalue),\n                 LocalRef::Operand(None) => {\n-                    let lvalue_ty = self.monomorphized_lvalue_ty(dst);\n-                    assert!(!lvalue_ty.has_erasable_regions());\n-                    let lvalue = LvalueRef::alloca(bcx, lvalue_ty, \"transmute_temp\");\n+                    let dst_layout = bcx.ccx.layout_of(self.monomorphized_lvalue_ty(dst));\n+                    assert!(!dst_layout.ty.has_erasable_regions());\n+                    let lvalue = LvalueRef::alloca(bcx, dst_layout, \"transmute_temp\");\n                     lvalue.storage_live(bcx);\n                     self.trans_transmute_into(bcx, src, lvalue);\n                     let op = lvalue.load(bcx);\n                     lvalue.storage_dead(bcx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n                 }\n-                LocalRef::Operand(Some(_)) => {\n-                    let ty = self.monomorphized_lvalue_ty(dst);\n-                    assert!(common::type_is_zero_size(bcx.ccx, ty),\n+                LocalRef::Operand(Some(op)) => {\n+                    assert!(op.layout.is_zst(),\n                             \"assigning to initialized SSAtemp\");\n                 }\n             }\n@@ -897,14 +890,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     fn trans_transmute_into(&mut self, bcx: &Builder<'a, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n                             dst: LvalueRef<'tcx>) {\n-        let val = self.trans_operand(bcx, src);\n-        let llty = bcx.ccx.llvm_type_of(val.ty);\n+        let src = self.trans_operand(bcx, src);\n+        let llty = bcx.ccx.llvm_type_of(src.layout.ty);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n-        let in_type = val.ty;\n-        let out_type = dst.ty.to_ty(bcx.tcx());\n-        let align = bcx.ccx.align_of(in_type).min(bcx.ccx.align_of(out_type));\n-        val.store(bcx,\n-            LvalueRef::new_sized(cast_ptr, val.ty, Alignment::Packed(align)));\n+        let align = src.layout.align(bcx.ccx).min(dst.layout.align(bcx.ccx));\n+        src.val.store(bcx,\n+            LvalueRef::new_sized(cast_ptr, src.layout, Alignment::Packed(align)));\n     }\n \n \n@@ -927,7 +918,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if ret_ty.cast.is_some() {\n-                    let tmp = LvalueRef::alloca(bcx, op.ty, \"tmp_ret\");\n+                    let tmp = LvalueRef::alloca(bcx, op.layout, \"tmp_ret\");\n                     tmp.storage_live(bcx);\n                     ret_ty.store(bcx, op.immediate(), tmp);\n                     let op = tmp.load(bcx);"}, {"sha": "8b86eca755825f34b70e14315e82fb6be20fd15e", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> Const<'tcx> {\n \n         OperandRef {\n             val,\n-            ty: self.ty\n+            layout: ccx.layout_of(self.ty)\n         }\n     }\n }\n@@ -1100,11 +1100,11 @@ fn trans_const_adt<'a, 'tcx>(\n                 _ => 0,\n             };\n             let discr_ty = l.field(ccx, 0).ty;\n-            let discr = Const::new(C_int(ccx.llvm_type_of(discr_ty), discr as i64),\n-                                   discr_ty);\n+            let discr = C_int(ccx.llvm_type_of(discr_ty), discr as i64);\n             if let layout::Abi::Scalar(_) = l.abi {\n-                discr\n+                Const::new(discr, t)\n             } else {\n+                let discr = Const::new(discr, discr_ty);\n                 build_const_struct(ccx, l.for_variant(variant_index), vals, Some(discr))\n             }\n         }"}, {"sha": "3c0776d47981739c7bdd918f62d88456bf5e54f9", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 92, "deletions": 106, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Align, FullLayout, LayoutOf};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n@@ -86,36 +86,44 @@ pub struct LvalueRef<'tcx> {\n     pub llextra: ValueRef,\n \n     /// Monomorphized type of this lvalue, including variant information\n-    pub ty: LvalueTy<'tcx>,\n+    pub layout: FullLayout<'tcx>,\n \n     /// Whether this lvalue is known to be aligned according to its layout\n     pub alignment: Alignment,\n }\n \n impl<'a, 'tcx> LvalueRef<'tcx> {\n-    pub fn new_sized(llval: ValueRef, ty: Ty<'tcx>, alignment: Alignment) -> LvalueRef<'tcx> {\n-        LvalueRef { llval, llextra: ptr::null_mut(), ty: LvalueTy::from_ty(ty), alignment }\n+    pub fn new_sized(llval: ValueRef,\n+                     layout: FullLayout<'tcx>,\n+                     alignment: Alignment)\n+                     -> LvalueRef<'tcx> {\n+        LvalueRef {\n+            llval,\n+            llextra: ptr::null_mut(),\n+            layout,\n+            alignment\n+        }\n     }\n \n-    pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n-        debug!(\"alloca({:?}: {:?})\", name, ty);\n+    pub fn alloca(bcx: &Builder<'a, 'tcx>, layout: FullLayout<'tcx>, name: &str)\n+                  -> LvalueRef<'tcx> {\n+        debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bcx.alloca(\n-            bcx.ccx.llvm_type_of(ty), name, bcx.ccx.over_align_of(ty));\n-        assert!(!ty.has_param_types());\n-        Self::new_sized(tmp, ty, Alignment::AbiAligned)\n+            bcx.ccx.llvm_type_of(layout.ty), name, layout.over_align(bcx.ccx));\n+        Self::new_sized(tmp, layout, Alignment::AbiAligned)\n     }\n \n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n-        let ty = self.ty.to_ty(ccx.tcx());\n-        match ty.sty {\n-            ty::TyArray(_, n) => {\n-                common::C_usize(ccx, n.val.to_const_int().unwrap().to_u64().unwrap())\n-            }\n-            ty::TySlice(_) | ty::TyStr => {\n-                assert!(self.llextra != ptr::null_mut());\n+        if let layout::FieldPlacement::Array { count, .. } = *self.layout.fields {\n+            if self.layout.is_unsized() {\n+                assert!(self.has_extra());\n+                assert_eq!(count, 0);\n                 self.llextra\n+            } else {\n+                common::C_usize(ccx, count)\n             }\n-            _ => bug!(\"unexpected type `{}` in LvalueRef::len\", ty)\n+        } else {\n+            bug!(\"unexpected layout `{:#?}` in LvalueRef::len\", self.layout)\n         }\n     }\n \n@@ -128,15 +136,13 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n         assert!(!self.has_extra());\n \n-        let ty = self.ty.to_ty(bcx.tcx());\n-\n-        if common::type_is_zero_size(bcx.ccx, ty) {\n-            return OperandRef::new_zst(bcx.ccx, ty);\n+        if self.layout.is_zst() {\n+            return OperandRef::new_zst(bcx.ccx, self.layout);\n         }\n \n-        let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n+        let val = if common::type_is_fat_ptr(bcx.ccx, self.layout.ty) {\n             let data = self.project_field(bcx, abi::FAT_PTR_ADDR);\n-            let lldata = if ty.is_region_ptr() || ty.is_box() {\n+            let lldata = if self.layout.ty.is_region_ptr() || self.layout.ty.is_box() {\n                 bcx.load_nonnull(data.llval, data.alignment.non_abi())\n             } else {\n                 bcx.load(data.llval, data.alignment.non_abi())\n@@ -153,11 +159,11 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             };\n \n             OperandValue::Pair(lldata, llextra)\n-        } else if common::type_is_imm_pair(bcx.ccx, ty) {\n+        } else if common::type_is_imm_pair(bcx.ccx, self.layout.ty) {\n             OperandValue::Pair(\n                 self.project_field(bcx, 0).load(bcx).pack_if_pair(bcx).immediate(),\n                 self.project_field(bcx, 1).load(bcx).pack_if_pair(bcx).immediate())\n-        } else if common::type_is_immediate(bcx.ccx, ty) {\n+        } else if common::type_is_immediate(bcx.ccx, self.layout.ty) {\n             let mut const_llval = ptr::null_mut();\n             unsafe {\n                 let global = llvm::LLVMIsAGlobalVariable(self.llval);\n@@ -168,48 +174,43 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n             let llval = if !const_llval.is_null() {\n                 const_llval\n-            } else if ty.is_bool() {\n+            } else if self.layout.ty.is_bool() {\n                 bcx.load_range_assert(self.llval, 0, 2, llvm::False,\n                     self.alignment.non_abi())\n-            } else if ty.is_char() {\n+            } else if self.layout.ty.is_char() {\n                 // a char is a Unicode codepoint, and so takes values from 0\n                 // to 0x10FFFF inclusive only.\n                 bcx.load_range_assert(self.llval, 0, 0x10FFFF + 1, llvm::False,\n                     self.alignment.non_abi())\n-            } else if ty.is_region_ptr() || ty.is_box() || ty.is_fn() {\n+            } else if self.layout.ty.is_region_ptr() ||\n+                      self.layout.ty.is_box() ||\n+                      self.layout.ty.is_fn() {\n                 bcx.load_nonnull(self.llval, self.alignment.non_abi())\n             } else {\n                 bcx.load(self.llval, self.alignment.non_abi())\n             };\n-            OperandValue::Immediate(base::to_immediate(bcx, llval, ty))\n+            OperandValue::Immediate(base::to_immediate(bcx, llval, self.layout.ty))\n         } else {\n             OperandValue::Ref(self.llval, self.alignment)\n         };\n \n-        OperandRef { val, ty }\n+        OperandRef { val, layout: self.layout }\n     }\n \n     /// Access a field, at a point when the value's case is known.\n     pub fn project_field(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> LvalueRef<'tcx> {\n         let ccx = bcx.ccx;\n-        let mut l = ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n-        match self.ty {\n-            LvalueTy::Ty { .. } => {}\n-            LvalueTy::Downcast { variant_index, .. } => {\n-                l = l.for_variant(variant_index)\n-            }\n-        }\n-        let field = l.field(ccx, ix);\n-        let offset = l.fields.offset(ix).bytes();\n+        let field = self.layout.field(ccx, ix);\n+        let offset = self.layout.fields.offset(ix).bytes();\n \n-        let alignment = self.alignment | Alignment::from(l);\n+        let alignment = self.alignment | Alignment::from(self.layout);\n \n         // Unions and newtypes only use an offset of 0.\n-        let has_llvm_fields = match *l.fields {\n+        let has_llvm_fields = match *self.layout.fields {\n             layout::FieldPlacement::Union(_) => false,\n             layout::FieldPlacement::Array { .. } => true,\n             layout::FieldPlacement::Arbitrary { .. } => {\n-                match l.abi {\n+                match self.layout.abi {\n                     layout::Abi::Scalar(_) | layout::Abi::Vector { .. } => false,\n                     layout::Abi::Aggregate { .. } => true\n                 }\n@@ -219,7 +220,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let simple = || {\n             LvalueRef {\n                 llval: if has_llvm_fields {\n-                    bcx.struct_gep(self.llval, l.llvm_field_index(ix))\n+                    bcx.struct_gep(self.llval, self.layout.llvm_field_index(ix))\n                 } else {\n                     assert_eq!(offset, 0);\n                     let ty = ccx.llvm_type_of(field.ty);\n@@ -230,15 +231,15 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 } else {\n                     ptr::null_mut()\n                 },\n-                ty: LvalueTy::from_ty(field.ty),\n+                layout: field,\n                 alignment,\n             }\n         };\n \n         // Simple case - we can just GEP the field\n         //   * Packed struct - There is no alignment padding\n         //   * Field is sized - pointer is properly aligned already\n-        if l.is_packed() || !field.is_unsized() {\n+        if self.layout.is_packed() || !field.is_unsized() {\n             return simple();\n         }\n \n@@ -301,29 +302,26 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         LvalueRef {\n             llval: bcx.pointercast(byte_ptr, ll_fty.ptr_to()),\n             llextra: self.llextra,\n-            ty: LvalueTy::from_ty(field.ty),\n+            layout: field,\n             alignment,\n         }\n     }\n \n     /// Obtain the actual discriminant of a value.\n     pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n-        let l = bcx.ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n-\n         let cast_to = bcx.ccx.immediate_llvm_type_of(cast_to);\n-        match *l.layout {\n+        match *self.layout.layout {\n             layout::Layout::Univariant { .. } |\n             layout::Layout::UntaggedUnion { .. } => return C_uint(cast_to, 0),\n             _ => {}\n         }\n \n         let discr = self.project_field(bcx, 0);\n-        let discr_layout = bcx.ccx.layout_of(discr.ty.to_ty(bcx.tcx()));\n-        let discr_scalar = match discr_layout.abi {\n+        let discr_scalar = match discr.layout.abi {\n             layout::Abi::Scalar(discr) => discr,\n-            _ => bug!(\"discriminant not scalar: {:#?}\", discr_layout)\n+            _ => bug!(\"discriminant not scalar: {:#?}\", discr.layout)\n         };\n-        let (min, max) = match *l.layout {\n+        let (min, max) = match *self.layout.layout {\n             layout::Layout::General { ref discr_range, .. } => (discr_range.start, discr_range.end),\n             _ => (0, u64::max_value()),\n         };\n@@ -349,7 +347,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 bcx.load(discr.llval, discr.alignment.non_abi())\n             }\n         };\n-        match *l.layout {\n+        match *self.layout.layout {\n             layout::Layout::General { .. } => {\n                 let signed = match discr_scalar {\n                     layout::Int(_, signed) => signed,\n@@ -359,29 +357,28 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             }\n             layout::Layout::NullablePointer { nndiscr, .. } => {\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                let zero = C_null(bcx.ccx.llvm_type_of(discr_layout.ty));\n+                let zero = C_null(bcx.ccx.llvm_type_of(discr.layout.ty));\n                 bcx.intcast(bcx.icmp(cmp, lldiscr, zero), cast_to, false)\n             }\n-            _ => bug!(\"{} is not an enum\", l.ty)\n+            _ => bug!(\"{} is not an enum\", self.layout.ty)\n         }\n     }\n \n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n     pub fn trans_set_discr(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize) {\n-        let l = bcx.ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n-        let to = l.ty.ty_adt_def().unwrap()\n+        let to = self.layout.ty.ty_adt_def().unwrap()\n             .discriminant_for_variant(bcx.tcx(), variant_index)\n             .to_u128_unchecked() as u64;\n-        match *l.layout {\n+        match *self.layout.layout {\n             layout::Layout::General { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n-                bcx.store(C_int(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx())), to as i64),\n+                bcx.store(C_int(bcx.ccx.llvm_type_of(ptr.layout.ty), to as i64),\n                     ptr.llval, ptr.alignment.non_abi());\n             }\n             layout::Layout::NullablePointer { nndiscr, .. } => {\n                 if to != nndiscr {\n-                    let use_memset = match l.abi {\n+                    let use_memset = match self.layout.abi {\n                         layout::Abi::Scalar(_) => false,\n                         _ => target_sets_discr_via_memset(bcx)\n                     };\n@@ -391,13 +388,13 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                         // than storing null to single target field.\n                         let llptr = bcx.pointercast(self.llval, Type::i8(bcx.ccx).ptr_to());\n                         let fill_byte = C_u8(bcx.ccx, 0);\n-                        let (size, align) = l.size_and_align(bcx.ccx);\n+                        let (size, align) = self.layout.size_and_align(bcx.ccx);\n                         let size = C_usize(bcx.ccx, size.bytes());\n                         let align = C_u32(bcx.ccx, align.abi() as u32);\n                         base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                     } else {\n                         let ptr = self.project_field(bcx, 0);\n-                        bcx.store(C_null(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx()))),\n+                        bcx.store(C_null(bcx.ccx.llvm_type_of(ptr.layout.ty)),\n                             ptr.llval, ptr.alignment.non_abi());\n                     }\n                 }\n@@ -410,48 +407,40 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n     pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef)\n                          -> LvalueRef<'tcx> {\n-        let ptr = bcx.inbounds_gep(self.llval, &[common::C_usize(bcx.ccx, 0), llindex]);\n-        let elem_ty = self.ty.to_ty(bcx.tcx()).builtin_index().unwrap();\n-        LvalueRef::new_sized(ptr, elem_ty, self.alignment)\n+        LvalueRef {\n+            llval: bcx.inbounds_gep(self.llval, &[common::C_usize(bcx.ccx, 0), llindex]),\n+            llextra: ptr::null_mut(),\n+            layout: self.layout.field(bcx.ccx, 0),\n+            alignment: self.alignment\n+        }\n     }\n \n     pub fn project_downcast(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize)\n                             -> LvalueRef<'tcx> {\n-        let ty = self.ty.to_ty(bcx.tcx());\n-        if let ty::TyAdt(adt_def, substs) = ty.sty {\n-            let mut downcast = *self;\n-            downcast.ty = LvalueTy::Downcast {\n-                adt_def,\n-                substs,\n-                variant_index,\n-            };\n+        let mut downcast = *self;\n+        downcast.layout = self.layout.for_variant(variant_index);\n \n-            // If this is an enum, cast to the appropriate variant struct type.\n-            let layout = bcx.ccx.layout_of(ty);\n-            match *layout.layout {\n-                layout::Layout::NullablePointer { .. } |\n-                layout::Layout::General { .. } => {\n-                    let variant_layout = layout.for_variant(variant_index);\n-                    let variant_ty = Type::struct_(bcx.ccx,\n-                        &type_of::struct_llfields(bcx.ccx, variant_layout),\n-                        variant_layout.is_packed());\n-                    downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n-                }\n-                _ => {}\n+        // If this is an enum, cast to the appropriate variant struct type.\n+        match *self.layout.layout {\n+            layout::Layout::NullablePointer { .. } |\n+            layout::Layout::General { .. } => {\n+                let variant_ty = Type::struct_(bcx.ccx,\n+                    &type_of::struct_llfields(bcx.ccx, downcast.layout),\n+                    downcast.layout.is_packed());\n+                downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n             }\n-\n-            downcast\n-        } else {\n-            bug!(\"unexpected type `{}` in LvalueRef::project_downcast\", ty)\n+            _ => {}\n         }\n+\n+        downcast\n     }\n \n     pub fn storage_live(&self, bcx: &Builder<'a, 'tcx>) {\n-        bcx.lifetime_start(self.llval, bcx.ccx.size_of(self.ty.to_ty(bcx.tcx())));\n+        bcx.lifetime_start(self.llval, self.layout.size(bcx.ccx));\n     }\n \n     pub fn storage_dead(&self, bcx: &Builder<'a, 'tcx>) {\n-        bcx.lifetime_end(self.llval, bcx.ccx.size_of(self.ty.to_ty(bcx.tcx())));\n+        bcx.lifetime_end(self.llval, self.layout.size(bcx.ccx));\n     }\n }\n \n@@ -480,15 +469,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Lvalue::Local(_) => bug!(), // handled above\n             mir::Lvalue::Static(box mir::Static { def_id, ty }) => {\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id),\n-                                     self.monomorphize(&ty),\n+                                     ccx.layout_of(self.monomorphize(&ty)),\n                                      Alignment::AbiAligned)\n             },\n             mir::Lvalue::Projection(box mir::Projection {\n                 ref base,\n                 elem: mir::ProjectionElem::Deref\n             }) => {\n                 // Load the pointer from its location.\n-                self.trans_consume(bcx, base).deref()\n+                self.trans_consume(bcx, base).deref(bcx.ccx)\n             }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n@@ -521,23 +510,20 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = tr_base.project_index(bcx,\n                             C_usize(bcx.ccx, from as u64));\n-                        subslice.ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n-                        subslice.ty = self.monomorphize(&subslice.ty);\n-\n-                        match subslice.ty.to_ty(tcx).sty {\n-                            ty::TyArray(..) => {}\n-                            ty::TySlice(..) => {\n-                                assert!(tr_base.has_extra());\n-                                subslice.llextra = bcx.sub(tr_base.llextra,\n-                                    C_usize(bcx.ccx, (from as u64) + (to as u64)));\n-                            }\n-                            _ => bug!(\"unexpected type {:?} in Subslice\", subslice.ty)\n+                        let projected_ty = LvalueTy::Ty { ty: tr_base.layout.ty }\n+                            .projection_ty(tcx, &projection.elem).to_ty(bcx.tcx());\n+                        subslice.layout = bcx.ccx.layout_of(self.monomorphize(&projected_ty));\n+\n+                        if subslice.layout.is_unsized() {\n+                            assert!(tr_base.has_extra());\n+                            subslice.llextra = bcx.sub(tr_base.llextra,\n+                                C_usize(bcx.ccx, (from as u64) + (to as u64)));\n                         }\n \n                         // Cast the lvalue pointer type to the new\n                         // array or slice type (*[%_; new_len]).\n                         subslice.llval = bcx.pointercast(subslice.llval,\n-                            bcx.ccx.llvm_type_of(subslice.ty.to_ty(tcx)).ptr_to());\n+                            bcx.ccx.llvm_type_of(subslice.layout.ty).ptr_to());\n \n                         subslice\n                     }"}, {"sha": "21d2711df83c71123fdb0dd4c458d2f5c627a31c", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -11,8 +11,8 @@\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::layout::{LayoutOf, FullLayout};\n use rustc::mir::{self, Mir};\n use rustc::ty::subst::Substs;\n use rustc::infer::TransNormalize;\n@@ -177,12 +177,12 @@ enum LocalRef<'tcx> {\n }\n \n impl<'a, 'tcx> LocalRef<'tcx> {\n-    fn new_operand(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> LocalRef<'tcx> {\n-        if common::type_is_zero_size(ccx, ty) {\n+    fn new_operand(ccx: &CrateContext<'a, 'tcx>, layout: FullLayout<'tcx>) -> LocalRef<'tcx> {\n+        if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(Some(OperandRef::new_zst(ccx, ty)))\n+            LocalRef::Operand(Some(OperandRef::new_zst(ccx, layout)))\n         } else {\n             LocalRef::Operand(None)\n         }\n@@ -253,7 +253,8 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let ty = mircx.monomorphize(&decl.ty);\n+            let layout = bcx.ccx.layout_of(mircx.monomorphize(&decl.ty));\n+            assert!(!layout.ty.has_erasable_regions());\n \n             if let Some(name) = decl.name {\n                 // User variable\n@@ -262,15 +263,14 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n                 if !lvalue_locals.contains(local.index()) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n-                    return LocalRef::new_operand(bcx.ccx, ty);\n+                    return LocalRef::new_operand(bcx.ccx, layout);\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n-                assert!(!ty.has_erasable_regions());\n-                let lvalue = LvalueRef::alloca(&bcx, ty, &name.as_str());\n+                let lvalue = LvalueRef::alloca(&bcx, layout, &name.as_str());\n                 if dbg {\n                     let (scope, span) = mircx.debug_loc(decl.source_info);\n-                    declare_local(&bcx, &mircx.debug_context, name, ty, scope,\n+                    declare_local(&bcx, &mircx.debug_context, name, layout.ty, scope,\n                         VariableAccess::DirectVariable { alloca: lvalue.llval },\n                         VariableKind::LocalVariable, span);\n                 }\n@@ -280,17 +280,18 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n-                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr, ty, Alignment::AbiAligned))\n+                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr,\n+                                                          layout,\n+                                                          Alignment::AbiAligned))\n                 } else if lvalue_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> lvalue\", local);\n-                    assert!(!ty.has_erasable_regions());\n-                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, ty,  &format!(\"{:?}\", local)))\n+                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, layout, &format!(\"{:?}\", local)))\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n                     // definition and update the operand there.\n                     debug!(\"alloc: {:?} -> operand\", local);\n-                    LocalRef::new_operand(bcx.ccx, ty)\n+                    LocalRef::new_operand(bcx.ccx, layout)\n                 }\n             }\n         };\n@@ -381,7 +382,6 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n-        let arg_ty = mircx.monomorphize(&arg_decl.ty);\n \n         let name = if let Some(name) = arg_decl.name {\n             name.as_str().to_string()\n@@ -395,12 +395,13 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // to reconstruct it into a tuple local variable, from multiple\n             // individual LLVM function arguments.\n \n+            let arg_ty = mircx.monomorphize(&arg_decl.ty);\n             let tupled_arg_tys = match arg_ty.sty {\n                 ty::TyTuple(ref tys, _) => tys,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let lvalue = LvalueRef::alloca(bcx, arg_ty, &name);\n+            let lvalue = LvalueRef::alloca(bcx, bcx.ccx.layout_of(arg_ty), &name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &mircx.fn_ty.args[idx];\n                 idx += 1;\n@@ -439,7 +440,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             bcx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n-            LvalueRef::new_sized(llarg, arg_ty, Alignment::AbiAligned)\n+            LvalueRef::new_sized(llarg, arg.layout, Alignment::AbiAligned)\n         } else if !lvalue_locals.contains(local.index()) &&\n                   !arg.nested.is_empty() {\n             assert_eq!(arg.nested.len(), 2);\n@@ -453,15 +454,15 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let mut b = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n \n-            if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n+            if common::type_is_fat_ptr(bcx.ccx, arg.layout.ty) {\n                 // FIXME(eddyb) As we can't perfectly represent the data and/or\n                 // vtable pointer in a fat pointers in Rust's typesystem, and\n                 // because we split fat pointers into two ArgType's, they're\n                 // not the right type so we have to cast them for now.\n-                let pointee = match arg_ty.sty {\n+                let pointee = match arg.layout.ty.sty {\n                     ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n                     ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => ty,\n-                    ty::TyAdt(def, _) if def.is_box() => arg_ty.boxed_ty(),\n+                    ty::TyAdt(def, _) if def.is_box() => arg.layout.ty.boxed_ty(),\n                     _ => bug!()\n                 };\n                 let data_llty = bcx.ccx.llvm_type_of(pointee);\n@@ -475,13 +476,13 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n             return LocalRef::Operand(Some(OperandRef {\n                 val: OperandValue::Pair(a, b),\n-                ty: arg_ty\n+                layout: arg.layout\n             }));\n         } else if !lvalue_locals.contains(local.index()) &&\n                   !arg.is_indirect() && arg.cast.is_none() &&\n                   arg_scope.is_none() {\n             if arg.is_ignore() {\n-                return LocalRef::new_operand(bcx.ccx, arg_ty);\n+                return LocalRef::new_operand(bcx.ccx, arg.layout);\n             }\n \n             // We don't have to cast or keep the argument in the alloca.\n@@ -495,11 +496,11 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             llarg_idx += 1;\n             let operand = OperandRef {\n                 val: OperandValue::Immediate(llarg),\n-                ty: arg_ty\n+                layout: arg.layout\n             };\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n-            let tmp = LvalueRef::alloca(bcx, arg_ty, &name);\n+            let tmp = LvalueRef::alloca(bcx, arg.layout, &name);\n             arg.store_fn_arg(bcx, &mut llarg_idx, tmp);\n             tmp\n         };\n@@ -523,7 +524,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     bcx,\n                     &mircx.debug_context,\n                     arg_decl.name.unwrap_or(keywords::Invalid.name()),\n-                    arg_ty,\n+                    arg.layout.ty,\n                     scope,\n                     variable_access,\n                     VariableKind::ArgumentVariable(arg_index + 1),\n@@ -533,15 +534,15 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             }\n \n             // Or is it the closure environment?\n-            let (closure_ty, env_ref) = match arg_ty.sty {\n-                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (mt.ty, true),\n-                _ => (arg_ty, false)\n+            let (closure_layout, env_ref) = match arg.layout.ty.sty {\n+                ty::TyRef(_, mt) | ty::TyRawPtr(mt) => (bcx.ccx.layout_of(mt.ty), true),\n+                _ => (arg.layout, false)\n             };\n \n-            let upvar_tys = match closure_ty.sty {\n+            let upvar_tys = match closure_layout.ty.sty {\n                 ty::TyClosure(def_id, substs) |\n                 ty::TyGenerator(def_id, substs, _) => substs.upvar_tys(def_id, tcx),\n-                _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty)\n+                _ => bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_layout.ty)\n             };\n \n             // Store the pointer to closure data in an alloca for debuginfo\n@@ -552,17 +553,17 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc_ty = tcx.mk_mut_ptr(arg_ty);\n-                let alloc = LvalueRef::alloca(bcx, alloc_ty, \"__debuginfo_env_ptr\");\n+                let alloc = LvalueRef::alloca(bcx,\n+                    bcx.ccx.layout_of(tcx.mk_mut_ptr(arg.layout.ty)),\n+                    \"__debuginfo_env_ptr\");\n                 bcx.store(lvalue.llval, alloc.llval, None);\n                 alloc.llval\n             } else {\n                 lvalue.llval\n             };\n \n-            let layout = bcx.ccx.layout_of(closure_ty);\n             for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n-                let byte_offset_of_var_in_env = layout.fields.offset(i).bytes();\n+                let byte_offset_of_var_in_env = closure_layout.fields.offset(i).bytes();\n \n                 let ops = unsafe {\n                     [llvm::LLVMRustDIBuilderCreateOpDeref(),"}, {"sha": "24f6a84f620728a2a8975dab188de52d4cd39846", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty;\n+use rustc::ty::layout::{LayoutOf, FullLayout};\n use rustc::mir;\n-use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n@@ -42,6 +41,22 @@ pub enum OperandValue {\n     Pair(ValueRef, ValueRef)\n }\n \n+impl fmt::Debug for OperandValue {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            OperandValue::Ref(r, align) => {\n+                write!(f, \"Ref({:?}, {:?})\", Value(r), align)\n+            }\n+            OperandValue::Immediate(i) => {\n+                write!(f, \"Immediate({:?})\", Value(i))\n+            }\n+            OperandValue::Pair(a, b) => {\n+                write!(f, \"Pair({:?}, {:?})\", Value(a), Value(b))\n+            }\n+        }\n+    }\n+}\n+\n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n /// its type.\n ///\n@@ -55,35 +70,24 @@ pub struct OperandRef<'tcx> {\n     // The value.\n     pub val: OperandValue,\n \n-    // The type of value being returned.\n-    pub ty: Ty<'tcx>\n+    // The layout of value, based on its Rust type.\n+    pub layout: FullLayout<'tcx>,\n }\n \n impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.val {\n-            OperandValue::Ref(r, align) => {\n-                write!(f, \"OperandRef(Ref({:?}, {:?}) @ {:?})\",\n-                       Value(r), align, self.ty)\n-            }\n-            OperandValue::Immediate(i) => {\n-                write!(f, \"OperandRef(Immediate({:?}) @ {:?})\",\n-                       Value(i), self.ty)\n-            }\n-            OperandValue::Pair(a, b) => {\n-                write!(f, \"OperandRef(Pair({:?}, {:?}) @ {:?})\",\n-                       Value(a), Value(b), self.ty)\n-            }\n-        }\n+        write!(f, \"OperandRef({:?} @ {:?})\", self.val, self.layout)\n     }\n }\n \n impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn new_zst(ccx: &CrateContext<'a, 'tcx>,\n-                   ty: Ty<'tcx>) -> OperandRef<'tcx> {\n-        assert!(common::type_is_zero_size(ccx, ty));\n-        let llty = ccx.llvm_type_of(ty);\n-        Const::new(C_undef(llty), ty).to_operand(ccx)\n+                   layout: FullLayout<'tcx>) -> OperandRef<'tcx> {\n+        assert!(layout.is_zst());\n+        let llty = ccx.llvm_type_of(layout.ty);\n+        // FIXME(eddyb) ZSTs should always be immediate, not pairs.\n+        // This hack only exists to unpack a constant undef pair.\n+        Const::new(C_undef(llty), layout.ty).to_operand(ccx)\n     }\n \n     /// Asserts that this operand refers to a scalar and returns\n@@ -95,8 +99,8 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    pub fn deref(self) -> LvalueRef<'tcx> {\n-        let projected_ty = self.ty.builtin_deref(true, ty::NoPreference)\n+    pub fn deref(self, ccx: &CrateContext<'a, 'tcx>) -> LvalueRef<'tcx> {\n+        let projected_ty = self.layout.ty.builtin_deref(true, ty::NoPreference)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n@@ -106,7 +110,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         LvalueRef {\n             llval: llptr,\n             llextra,\n-            ty: LvalueTy::from_ty(projected_ty),\n+            layout: ccx.layout_of(projected_ty),\n             alignment: Alignment::AbiAligned,\n         }\n     }\n@@ -115,15 +119,14 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     /// Immediate aggregate with the two values.\n     pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n-            let llty = bcx.ccx.llvm_type_of(self.ty);\n+            let llty = bcx.ccx.llvm_type_of(self.layout.ty);\n             debug!(\"Operand::pack_if_pair: packing {:?} into {:?}\", self, llty);\n             // Reconstruct the immediate aggregate.\n             let mut llpair = C_undef(llty);\n             let elems = [a, b];\n-            let layout = bcx.ccx.layout_of(self.ty);\n             for i in 0..2 {\n                 let elem = base::from_immediate(bcx, elems[i]);\n-                llpair = bcx.insert_value(llpair, elem, layout.llvm_field_index(i));\n+                llpair = bcx.insert_value(llpair, elem, self.layout.llvm_field_index(i));\n             }\n             self.val = OperandValue::Immediate(llpair);\n         }\n@@ -135,46 +138,46 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn unpack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Immediate(llval) = self.val {\n             // Deconstruct the immediate aggregate.\n-            if common::type_is_imm_pair(bcx.ccx, self.ty) {\n+            if common::type_is_imm_pair(bcx.ccx, self.layout.ty) {\n                 debug!(\"Operand::unpack_if_pair: unpacking {:?}\", self);\n \n-                let layout = bcx.ccx.layout_of(self.ty);\n-\n-                let a = bcx.extract_value(llval, layout.llvm_field_index(0));\n-                let a = base::to_immediate(bcx, a, layout.field(bcx.ccx, 0).ty);\n+                let a = bcx.extract_value(llval, self.layout.llvm_field_index(0));\n+                let a = base::to_immediate(bcx, a, self.layout.field(bcx.ccx, 0).ty);\n \n-                let b = bcx.extract_value(llval, layout.llvm_field_index(1));\n-                let b = base::to_immediate(bcx, b, layout.field(bcx.ccx, 1).ty);\n+                let b = bcx.extract_value(llval, self.layout.llvm_field_index(1));\n+                let b = base::to_immediate(bcx, b, self.layout.field(bcx.ccx, 1).ty);\n \n                 self.val = OperandValue::Pair(a, b);\n             }\n         }\n         self\n     }\n+}\n \n+impl<'a, 'tcx> OperandValue {\n     pub fn store(self, bcx: &Builder<'a, 'tcx>, dest: LvalueRef<'tcx>) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n-        if common::type_is_zero_size(bcx.ccx, self.ty) {\n+        if dest.layout.is_zst() {\n             return;\n         }\n-        match self.val {\n+        match self {\n             OperandValue::Ref(r, source_align) =>\n-                base::memcpy_ty(bcx, dest.llval, r, self.ty,\n+                base::memcpy_ty(bcx, dest.llval, r, dest.layout,\n                                 (source_align | dest.alignment).non_abi()),\n             OperandValue::Immediate(s) => {\n                 bcx.store(base::from_immediate(bcx, s), dest.llval, dest.alignment.non_abi());\n             }\n             OperandValue::Pair(a, b) => {\n                 // See comment above about zero-sized values.\n                 let dest_a = dest.project_field(bcx, 0);\n-                if !common::type_is_zero_size(bcx.ccx, dest_a.ty.to_ty(bcx.tcx())) {\n+                if !dest_a.layout.is_zst() {\n                     let a = base::from_immediate(bcx, a);\n                     bcx.store(a, dest_a.llval, dest_a.alignment.non_abi());\n                 }\n                 let dest_b = dest.project_field(bcx, 1);\n-                if !common::type_is_zero_size(bcx.ccx, dest_b.ty.to_ty(bcx.tcx())) {\n+                if !dest_b.layout.is_zst() {\n                     let b = base::from_immediate(bcx, b);\n                     bcx.store(b, dest_b.llval, dest_b.alignment.non_abi());\n                 }\n@@ -217,7 +220,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             let llval = [a, b][f.index()];\n                             let op = OperandRef {\n                                 val: OperandValue::Immediate(llval),\n-                                ty: self.monomorphize(&ty)\n+                                layout: bcx.ccx.layout_of(self.monomorphize(&ty))\n                             };\n \n                             // Handle nested pairs.\n@@ -251,7 +254,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let operand = val.to_operand(bcx.ccx);\n                 if let OperandValue::Ref(ptr, align) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it.\n-                    LvalueRef::new_sized(ptr, operand.ty, align).load(bcx)\n+                    LvalueRef::new_sized(ptr, operand.layout, align).load(bcx)\n                 } else {\n                     operand\n                 }"}, {"sha": "5c24e4b5536d215ae69663b79bba19c95ff7791d", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 72, "deletions": 79, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                let tr_operand = self.trans_operand(&bcx, operand);\n                // FIXME: consider not copying constants through stack. (fixable by translating\n                // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n-               tr_operand.store(&bcx, dest);\n+               tr_operand.val.store(&bcx, dest);\n                bcx\n            }\n \n@@ -60,7 +60,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    temp.store(&bcx, dest);\n+                    temp.val.store(&bcx, dest);\n                     return bcx;\n                 }\n \n@@ -80,14 +80,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n-                        let scratch = LvalueRef::alloca(&bcx, operand.ty, \"__unsize_temp\");\n+                        let scratch = LvalueRef::alloca(&bcx, operand.layout, \"__unsize_temp\");\n                         scratch.storage_live(&bcx);\n-                        operand.store(&bcx, scratch);\n+                        operand.val.store(&bcx, scratch);\n                         base::coerce_unsized_into(&bcx, scratch, dest);\n                         scratch.storage_dead(&bcx);\n                     }\n                     OperandValue::Ref(llref, align) => {\n-                        let source = LvalueRef::new_sized(llref, operand.ty, align);\n+                        let source = LvalueRef::new_sized(llref, operand.layout, align);\n                         base::coerce_unsized_into(&bcx, source, dest);\n                     }\n                 }\n@@ -98,18 +98,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n \n                 // Do not generate the loop for zero-sized elements or empty arrays.\n-                let dest_ty = dest.ty.to_ty(bcx.tcx());\n-                if common::type_is_zero_size(bcx.ccx, dest_ty) {\n+                if dest.layout.is_zst() {\n                     return bcx;\n                 }\n \n                 let start = dest.project_index(&bcx, C_usize(bcx.ccx, 0)).llval;\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n                     let align = dest.alignment.non_abi()\n-                        .unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n+                        .unwrap_or_else(|| tr_elem.layout.align(bcx.ccx));\n                     let align = C_i32(bcx.ccx, align.abi() as i32);\n-                    let size = C_usize(bcx.ccx, bcx.ccx.size_of(dest_ty).bytes());\n+                    let size = C_usize(bcx.ccx, dest.layout.size(bcx.ccx).bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if common::is_const_integral(v) && common::const_to_uint(v) == 0 {\n@@ -139,8 +138,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n                 header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n \n-                tr_elem.store(&body_bcx,\n-                    LvalueRef::new_sized(current, tr_elem.ty, dest.alignment));\n+                tr_elem.val.store(&body_bcx,\n+                    LvalueRef::new_sized(current, tr_elem.layout, dest.alignment));\n \n                 let next = body_bcx.inbounds_gep(current, &[C_usize(bcx.ccx, 1)]);\n                 body_bcx.br(header_bcx.llbb());\n@@ -164,9 +163,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 for (i, operand) in operands.iter().enumerate() {\n                     let op = self.trans_operand(&bcx, operand);\n                     // Do not generate stores and GEPis for zero-sized fields.\n-                    if !common::type_is_zero_size(bcx.ccx, op.ty) {\n+                    if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n-                        op.store(&bcx, dest.project_field(&bcx, field_index));\n+                        op.val.store(&bcx, dest.project_field(&bcx, field_index));\n                     }\n                 }\n                 bcx\n@@ -175,7 +174,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             _ => {\n                 assert!(self.rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                temp.store(&bcx, dest);\n+                temp.val.store(&bcx, dest);\n                 bcx\n             }\n         }\n@@ -189,32 +188,32 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         assert!(self.rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n+            mir::Rvalue::Cast(ref kind, ref source, mir_cast_ty) => {\n                 let operand = self.trans_operand(&bcx, source);\n                 debug!(\"cast operand is {:?}\", operand);\n-                let cast_ty = self.monomorphize(&cast_ty);\n+                let cast = bcx.ccx.layout_of(self.monomorphize(&mir_cast_ty));\n \n                 let val = match *kind {\n                     mir::CastKind::ReifyFnPointer => {\n-                        match operand.ty.sty {\n+                        match operand.layout.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n                                 OperandValue::Immediate(\n                                     callee::resolve_and_get_fn(bcx.ccx, def_id, substs))\n                             }\n                             _ => {\n-                                bug!(\"{} cannot be reified to a fn ptr\", operand.ty)\n+                                bug!(\"{} cannot be reified to a fn ptr\", operand.layout.ty)\n                             }\n                         }\n                     }\n                     mir::CastKind::ClosureFnPointer => {\n-                        match operand.ty.sty {\n+                        match operand.layout.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n                                 let instance = monomorphize::resolve_closure(\n                                     bcx.ccx.tcx(), def_id, substs, ty::ClosureKind::FnOnce);\n                                 OperandValue::Immediate(callee::get_fn(bcx.ccx, instance))\n                             }\n                             _ => {\n-                                bug!(\"{} cannot be cast to a fn ptr\", operand.ty)\n+                                bug!(\"{} cannot be cast to a fn ptr\", operand.layout.ty)\n                             }\n                         }\n                     }\n@@ -225,7 +224,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::CastKind::Unsize => {\n                         // unsize targets other than to a fat pointer currently\n                         // can't be operands.\n-                        assert!(common::type_is_fat_ptr(bcx.ccx, cast_ty));\n+                        assert!(common::type_is_fat_ptr(bcx.ccx, cast.ty));\n \n                         match operand.val {\n                             OperandValue::Pair(lldata, llextra) => {\n@@ -235,14 +234,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 //   &'a fmt::Debug+Send => &'a fmt::Debug,\n                                 // So we need to pointercast the base to ensure\n                                 // the types match up.\n-                                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, cast_ty);\n+                                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, cast.ty);\n                                 let lldata = bcx.pointercast(lldata, llcast_ty);\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n                                 // \"standard\" unsize\n                                 let (lldata, llextra) = base::unsize_thin_ptr(&bcx, lldata,\n-                                    operand.ty, cast_ty);\n+                                    operand.layout.ty, cast.ty);\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Ref(..) => {\n@@ -251,16 +250,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    mir::CastKind::Misc if common::type_is_fat_ptr(bcx.ccx, operand.ty) => {\n+                    mir::CastKind::Misc if common::type_is_fat_ptr(bcx.ccx, operand.layout.ty) => {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n-                            if common::type_is_fat_ptr(bcx.ccx, cast_ty) {\n-                                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, cast_ty);\n+                            if common::type_is_fat_ptr(bcx.ccx, cast.ty) {\n+                                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, cast.ty);\n                                 let data_cast = bcx.pointercast(data_ptr, llcast_ty);\n                                 OperandValue::Pair(data_cast, meta)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n-                                let llcast_ty = bcx.ccx.immediate_llvm_type_of(cast_ty);\n+                                let llcast_ty = bcx.ccx.immediate_llvm_type_of(cast.ty);\n                                 let llval = bcx.pointercast(data_ptr, llcast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n@@ -269,15 +268,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::CastKind::Misc => {\n-                        debug_assert!(common::type_is_immediate(bcx.ccx, cast_ty));\n-                        let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n-                        let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = bcx.ccx.immediate_llvm_type_of(operand.ty);\n-                        let ll_t_out = bcx.ccx.immediate_llvm_type_of(cast_ty);\n+                        debug_assert!(common::type_is_immediate(bcx.ccx, cast.ty));\n+                        let r_t_in = CastTy::from_ty(operand.layout.ty)\n+                            .expect(\"bad input type for cast\");\n+                        let r_t_out = CastTy::from_ty(cast.ty).expect(\"bad output type for cast\");\n+                        let ll_t_in = bcx.ccx.immediate_llvm_type_of(operand.layout.ty);\n+                        let ll_t_out = bcx.ccx.immediate_llvm_type_of(cast.ty);\n                         let llval = operand.immediate();\n-                        let l = bcx.ccx.layout_of(operand.ty);\n \n-                        if let Layout::General { ref discr_range, .. } = *l.layout {\n+                        if let Layout::General { ref discr_range, .. } = *operand.layout.layout {\n                             if discr_range.end > discr_range.start {\n                                 // We want `table[e as usize]` to not\n                                 // have bound checks, and this is the most\n@@ -291,7 +290,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             }\n                         }\n \n-                        let signed = match l.abi {\n+                        let signed = match operand.layout.abi {\n                             layout::Abi::Scalar(layout::Int(_, signed)) => signed,\n                             _ => false\n                         };\n@@ -326,76 +325,71 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 cast_float_to_int(&bcx, true, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n                                 cast_float_to_int(&bcx, false, llval, ll_t_in, ll_t_out),\n-                            _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n+                            _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.layout.ty, cast.ty)\n                         };\n                         OperandValue::Immediate(newval)\n                     }\n                 };\n-                let operand = OperandRef {\n+                (bcx, OperandRef {\n                     val,\n-                    ty: cast_ty\n-                };\n-                (bcx, operand)\n+                    layout: cast\n+                })\n             }\n \n             mir::Rvalue::Ref(_, bk, ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n \n-                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                let ref_ty = bcx.tcx().mk_ref(\n-                    bcx.tcx().types.re_erased,\n-                    ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() }\n-                );\n+                let ty = tr_lvalue.layout.ty;\n \n                 // Note: lvalues are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                let operand = if !bcx.ccx.shared().type_has_metadata(ty) {\n-                    OperandRef {\n-                        val: OperandValue::Immediate(tr_lvalue.llval),\n-                        ty: ref_ty,\n-                    }\n+                let val = if !bcx.ccx.shared().type_has_metadata(ty) {\n+                    OperandValue::Immediate(tr_lvalue.llval)\n                 } else {\n-                    OperandRef {\n-                        val: OperandValue::Pair(tr_lvalue.llval,\n-                                                tr_lvalue.llextra),\n-                        ty: ref_ty,\n-                    }\n+                    OperandValue::Pair(tr_lvalue.llval, tr_lvalue.llextra)\n                 };\n-                (bcx, operand)\n+                (bcx, OperandRef {\n+                    val,\n+                    layout: self.ccx.layout_of(self.ccx.tcx().mk_ref(\n+                        self.ccx.tcx().types.re_erased,\n+                        ty::TypeAndMut { ty, mutbl: bk.to_mutbl_lossy() }\n+                    )),\n+                })\n             }\n \n             mir::Rvalue::Len(ref lvalue) => {\n                 let size = self.evaluate_array_len(&bcx, lvalue);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(size),\n-                    ty: bcx.tcx().types.usize,\n+                    layout: bcx.ccx.layout_of(bcx.tcx().types.usize),\n                 };\n                 (bcx, operand)\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs = self.trans_operand(&bcx, lhs);\n                 let rhs = self.trans_operand(&bcx, rhs);\n-                let llresult = if common::type_is_fat_ptr(bcx.ccx, lhs.ty) {\n+                let llresult = if common::type_is_fat_ptr(bcx.ccx, lhs.layout.ty) {\n                     match (lhs.val, rhs.val) {\n                         (OperandValue::Pair(lhs_addr, lhs_extra),\n                          OperandValue::Pair(rhs_addr, rhs_extra)) => {\n                             self.trans_fat_ptr_binop(&bcx, op,\n                                                      lhs_addr, lhs_extra,\n                                                      rhs_addr, rhs_extra,\n-                                                     lhs.ty)\n+                                                     lhs.layout.ty)\n                         }\n                         _ => bug!()\n                     }\n \n                 } else {\n                     self.trans_scalar_binop(&bcx, op,\n                                             lhs.immediate(), rhs.immediate(),\n-                                            lhs.ty)\n+                                            lhs.layout.ty)\n                 };\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n-                    ty: op.ty(bcx.tcx(), lhs.ty, rhs.ty),\n+                    layout: bcx.ccx.layout_of(\n+                        op.ty(bcx.tcx(), lhs.layout.ty, rhs.layout.ty)),\n                 };\n                 (bcx, operand)\n             }\n@@ -404,12 +398,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let rhs = self.trans_operand(&bcx, rhs);\n                 let result = self.trans_scalar_checked_binop(&bcx, op,\n                                                              lhs.immediate(), rhs.immediate(),\n-                                                             lhs.ty);\n-                let val_ty = op.ty(bcx.tcx(), lhs.ty, rhs.ty);\n+                                                             lhs.layout.ty);\n+                let val_ty = op.ty(bcx.tcx(), lhs.layout.ty, rhs.layout.ty);\n                 let operand_ty = bcx.tcx().intern_tup(&[val_ty, bcx.tcx().types.bool], false);\n                 let operand = OperandRef {\n                     val: result,\n-                    ty: operand_ty\n+                    layout: bcx.ccx.layout_of(operand_ty)\n                 };\n \n                 (bcx, operand)\n@@ -418,7 +412,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::UnaryOp(op, ref operand) => {\n                 let operand = self.trans_operand(&bcx, operand);\n                 let lloperand = operand.immediate();\n-                let is_float = operand.ty.is_fp();\n+                let is_float = operand.layout.ty.is_fp();\n                 let llval = match op {\n                     mir::UnOp::Not => bcx.not(lloperand),\n                     mir::UnOp::Neg => if is_float {\n@@ -429,7 +423,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(llval),\n-                    ty: operand.ty,\n+                    layout: operand.layout,\n                 })\n             }\n \n@@ -439,7 +433,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     .trans_get_discr(&bcx, discr_ty);\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n-                    ty: discr_ty\n+                    layout: self.ccx.layout_of(discr_ty)\n                 })\n             }\n \n@@ -449,7 +443,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let tcx = bcx.tcx();\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(val),\n-                    ty: tcx.types.usize,\n+                    layout: self.ccx.layout_of(tcx.types.usize),\n                 })\n             }\n \n@@ -458,14 +452,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (size, align) = bcx.ccx.size_and_align_of(content_ty);\n                 let llsize = C_usize(bcx.ccx, size.bytes());\n                 let llalign = C_usize(bcx.ccx, align.abi());\n-                let box_ty = bcx.tcx().mk_box(content_ty);\n-                let llty_ptr = bcx.ccx.llvm_type_of(box_ty);\n+                let box_layout = bcx.ccx.layout_of(bcx.tcx().mk_box(content_ty));\n+                let llty_ptr = bcx.ccx.llvm_type_of(box_layout.ty);\n \n                 // Allocate space:\n                 let def_id = match bcx.tcx().lang_items().require(ExchangeMallocFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => {\n-                        bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n+                        bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_layout.ty, s));\n                     }\n                 };\n                 let instance = ty::Instance::mono(bcx.tcx(), def_id);\n@@ -474,7 +468,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(val),\n-                    ty: box_ty,\n+                    layout: box_layout,\n                 };\n                 (bcx, operand)\n             }\n@@ -487,7 +481,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n                 let ty = rvalue.ty(self.mir, self.ccx.tcx());\n-                (bcx, OperandRef::new_zst(self.ccx, self.monomorphize(&ty)))\n+                (bcx, OperandRef::new_zst(self.ccx,\n+                    self.ccx.layout_of(self.monomorphize(&ty))))\n             }\n         }\n     }\n@@ -500,11 +495,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // because trans_lvalue() panics if Local is operand.\n         if let mir::Lvalue::Local(index) = *lvalue {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n-                if common::type_is_zero_size(bcx.ccx, op.ty) {\n-                    if let ty::TyArray(_, n) = op.ty.sty {\n-                        let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n-                        return common::C_usize(bcx.ccx, n);\n-                    }\n+                if let ty::TyArray(_, n) = op.layout.ty.sty {\n+                    let n = n.val.to_const_int().unwrap().to_u64().unwrap();\n+                    return common::C_usize(bcx.ccx, n);\n                 }\n             }\n         }\n@@ -709,7 +702,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(..) => {\n                 let ty = rvalue.ty(self.mir, self.ccx.tcx());\n                 let ty = self.monomorphize(&ty);\n-                common::type_is_zero_size(self.ccx, ty)\n+                self.ccx.layout_of(ty).is_zst()\n             }\n         }\n "}, {"sha": "607ecd887fa7823be86285c0086af2f3c505d30d", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -11,7 +11,6 @@\n use rustc::mir;\n \n use asm;\n-use common;\n use builder::Builder;\n \n use super::MirContext;\n@@ -37,18 +36,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n                             bcx\n                         }\n-                        LocalRef::Operand(Some(_)) => {\n-                            let ty = self.monomorphized_lvalue_ty(lvalue);\n-\n-                            if !common::type_is_zero_size(bcx.ccx, ty) {\n+                        LocalRef::Operand(Some(op)) => {\n+                            if !op.layout.is_zst() {\n                                 span_bug!(statement.source_info.span,\n                                           \"operand {:?} already assigned\",\n                                           rvalue);\n-                            } else {\n-                                // If the type is zero-sized, it's already been set here,\n-                                // but we still need to make sure we translate the operand\n-                                self.trans_rvalue_operand(bcx, rvalue).0\n                             }\n+\n+                            // If the type is zero-sized, it's already been set here,\n+                            // but we still need to make sure we translate the operand\n+                            self.trans_rvalue_operand(bcx, rvalue).0\n                         }\n                     }\n                 } else {\n@@ -75,8 +72,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n-                    let lvalue = self.trans_lvalue(&bcx, output);\n-                    (lvalue.llval, lvalue.ty.to_ty(bcx.tcx()))\n+                    self.trans_lvalue(&bcx, output)\n                 }).collect();\n \n                 let input_vals = inputs.iter().map(|input| {"}, {"sha": "e9547bd746bfd0641b775eec25b5335b5720ccfa", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1477119344e750d8cd6a5104ec6ea28cec11e574/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=1477119344e750d8cd6a5104ec6ea28cec11e574", "patch": "@@ -209,14 +209,7 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n \n     /// Returns alignment if it is different than the primitive alignment.\n     pub fn over_align_of(&self, ty: Ty<'tcx>) -> Option<Align> {\n-        let layout = self.layout_of(ty);\n-        let align = layout.align(self);\n-        let primitive_align = layout.primitive_align(self);\n-        if align != primitive_align {\n-            Some(align)\n-        } else {\n-            None\n-        }\n+        self.layout_of(ty).over_align(self)\n     }\n \n     /// Get the LLVM type corresponding to a Rust type, i.e. `rustc::ty::Ty`.\n@@ -275,10 +268,21 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n }\n \n pub trait LayoutLlvmExt {\n+    fn over_align(&self, ccx: &CrateContext) -> Option<Align>;\n     fn llvm_field_index(&self, index: usize) -> u64;\n }\n \n impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n+    fn over_align(&self, ccx: &CrateContext) -> Option<Align> {\n+        let align = self.align(ccx);\n+        let primitive_align = self.primitive_align(ccx);\n+        if align != primitive_align {\n+            Some(align)\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn llvm_field_index(&self, index: usize) -> u64 {\n         if let layout::Abi::Scalar(_) = self.abi {\n             bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self);"}]}