{"sha": "7208a01cdf8dd23264ac3236012e881402ccbbd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMDhhMDFjZGY4ZGQyMzI2NGFjMzIzNjAxMmU4ODE0MDJjY2JiZDU=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2020-10-24T08:42:40Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2020-12-07T01:01:21Z"}, "message": "Turn quadratic time on number of impl blocks into linear time\n\nPreviously, if you had a lot of inherent impl blocks on a type like:\n\nstruct Foo;\n\nimpl Foo { fn foo_1() {} }\n...\nimpl Foo { fn foo_100_000() {} }\n\nThe compiler would be very slow at processing it, because\nan internal algorithm would run in O(n^2), where n is the number\nof impl blocks. Now, we add a new algorithm that allocates but\nis faster asymptotically.\n\nIf there is an overlap between multiple impl blocks in terms of\nidentifiers, we still run a O(m^2) algorithm on groups of impl\nblocks that have overlaps, but that m refers to the size of the\nconnected component, which is hopefully smaller than the n\nthat refers to the sum of all connected components.", "tree": {"sha": "b4fd5326de6fa4ef0780c38229bbd6036818ecc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4fd5326de6fa4ef0780c38229bbd6036818ecc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7208a01cdf8dd23264ac3236012e881402ccbbd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7208a01cdf8dd23264ac3236012e881402ccbbd5", "html_url": "https://github.com/rust-lang/rust/commit/7208a01cdf8dd23264ac3236012e881402ccbbd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7208a01cdf8dd23264ac3236012e881402ccbbd5/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9709ef149c50258b0205995be1dbd99a22a075e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9709ef149c50258b0205995be1dbd99a22a075e0", "html_url": "https://github.com/rust-lang/rust/commit/9709ef149c50258b0205995be1dbd99a22a075e0"}], "stats": {"total": 152, "additions": 147, "deletions": 5}, "files": [{"sha": "4efb2a6273be6cdd1bbf55e9941c5747b1e4f0ea", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 147, "deletions": 5, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/7208a01cdf8dd23264ac3236012e881402ccbbd5/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7208a01cdf8dd23264ac3236012e881402ccbbd5/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=7208a01cdf8dd23264ac3236012e881402ccbbd5", "patch": "@@ -1,10 +1,13 @@\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::Symbol;\n use rustc_trait_selection::traits::{self, SkipLeakCheck};\n use smallvec::SmallVec;\n+use std::collections::hash_map::Entry;\n \n pub fn crate_inherent_impls_overlap_check(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n@@ -45,7 +48,7 @@ impl InherentOverlapChecker<'tcx> {\n         false\n     }\n \n-    fn compare_hygienically(&self, item1: &'tcx ty::AssocItem, item2: &'tcx ty::AssocItem) -> bool {\n+    fn compare_hygienically(&self, item1: &ty::AssocItem, item2: &ty::AssocItem) -> bool {\n         // Symbols and namespace match, compare hygienically.\n         item1.kind.namespace() == item2.kind.namespace()\n             && item1.ident.normalize_to_macros_2_0() == item2.ident.normalize_to_macros_2_0()\n@@ -134,10 +137,149 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                     .map(|impl_def_id| (impl_def_id, self.tcx.associated_items(*impl_def_id)))\n                     .collect::<SmallVec<[_; 8]>>();\n \n-                for (i, &(&impl1_def_id, impl_items1)) in impls_items.iter().enumerate() {\n-                    for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n-                        if self.impls_have_common_items(impl_items1, impl_items2) {\n-                            self.check_for_overlapping_inherent_impls(impl1_def_id, impl2_def_id);\n+                // Perform a O(n^2) algorithm for small n,\n+                // otherwise switch to an allocating algorithm with\n+                // faster asymptotic runtime.\n+                if impls.len() < 30 {\n+                    for (i, &(&impl1_def_id, impl_items1)) in impls_items.iter().enumerate() {\n+                        for &(&impl2_def_id, impl_items2) in &impls_items[(i + 1)..] {\n+                            if self.impls_have_common_items(impl_items1, impl_items2) {\n+                                self.check_for_overlapping_inherent_impls(\n+                                    impl1_def_id,\n+                                    impl2_def_id,\n+                                );\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // Build a set of connected regions of impl blocks.\n+                    // Two impl blocks are regarded as connected if they share\n+                    // an item with the same unhygienic identifier.\n+                    // After we have assembled the connected regions,\n+                    // run the O(n^2) algorithm on each connected region.\n+                    // This is advantageous to running the algorithm over the\n+                    // entire graph when there are many connected regions.\n+\n+                    struct ConnectedRegion {\n+                        idents: SmallVec<[Symbol; 8]>,\n+                        impl_blocks: FxHashSet<usize>,\n+                    }\n+                    // Highest connected region id\n+                    let mut highest_region_id = 0;\n+                    let mut connected_region_ids = FxHashMap::default();\n+                    let mut connected_regions = FxHashMap::default();\n+\n+                    for (i, &(&_impl_def_id, impl_items)) in impls_items.iter().enumerate() {\n+                        if impl_items.len() == 0 {\n+                            continue;\n+                        }\n+                        // First obtain a list of existing connected region ids\n+                        let mut idents_to_add = SmallVec::<[Symbol; 8]>::new();\n+                        let ids = impl_items\n+                            .in_definition_order()\n+                            .filter_map(|item| {\n+                                let entry = connected_region_ids.entry(item.ident.name);\n+                                if let Entry::Occupied(e) = &entry {\n+                                    Some(*e.get())\n+                                } else {\n+                                    idents_to_add.push(item.ident.name);\n+                                    None\n+                                }\n+                            })\n+                            .collect::<FxHashSet<usize>>();\n+                        match ids.len() {\n+                            0 | 1 => {\n+                                let id_to_set = if ids.len() == 0 {\n+                                    // Create a new connected region\n+                                    let region = ConnectedRegion {\n+                                        idents: idents_to_add,\n+                                        impl_blocks: std::iter::once(i).collect(),\n+                                    };\n+                                    connected_regions.insert(highest_region_id, region);\n+                                    (highest_region_id, highest_region_id += 1).0\n+                                } else {\n+                                    // Take the only id inside the list\n+                                    let id_to_set = *ids.iter().next().unwrap();\n+                                    let region = connected_regions.get_mut(&id_to_set).unwrap();\n+                                    region.impl_blocks.insert(i);\n+                                    region.idents.extend_from_slice(&idents_to_add);\n+                                    id_to_set\n+                                };\n+                                let (_id, region) = connected_regions.iter().next().unwrap();\n+                                // Update the connected region ids\n+                                for ident in region.idents.iter() {\n+                                    connected_region_ids.insert(*ident, id_to_set);\n+                                }\n+                            }\n+                            _ => {\n+                                // We have multiple connected regions to merge.\n+                                // In the worst case this might add impl blocks\n+                                // one by one and can thus be O(n^2) in the size\n+                                // of the resulting final connected region, but\n+                                // this is no issue as the final step to check\n+                                // for overlaps runs in O(n^2) as well.\n+\n+                                // Take the smallest id from the list\n+                                let id_to_set = *ids.iter().min().unwrap();\n+\n+                                // Sort the id list so that the algorithm is deterministic\n+                                let mut ids = ids.into_iter().collect::<SmallVec<[_; 8]>>();\n+                                ids.sort();\n+\n+                                let mut region = connected_regions.remove(&id_to_set).unwrap();\n+                                region.idents.extend_from_slice(&idents_to_add);\n+                                region.impl_blocks.insert(i);\n+\n+                                for &id in ids.iter() {\n+                                    if id == id_to_set {\n+                                        continue;\n+                                    }\n+                                    let r = connected_regions.remove(&id).unwrap();\n+                                    // Update the connected region ids\n+                                    for ident in r.idents.iter() {\n+                                        connected_region_ids.insert(*ident, id_to_set);\n+                                    }\n+                                    region.idents.extend_from_slice(&r.idents);\n+                                    region.impl_blocks.extend(r.impl_blocks);\n+                                }\n+                                connected_regions.insert(id_to_set, region);\n+                            }\n+                        }\n+                    }\n+\n+                    debug!(\n+                        \"churning through {} components (sum={}, avg={}, var={}, max={})\",\n+                        connected_regions.len(),\n+                        impls.len(),\n+                        impls.len() / connected_regions.len(),\n+                        {\n+                            let avg = impls.len() / connected_regions.len();\n+                            let s = connected_regions\n+                                .iter()\n+                                .map(|r| r.1.impl_blocks.len() as isize - avg as isize)\n+                                .map(|v| v.abs() as usize)\n+                                .sum::<usize>();\n+                            s / connected_regions.len()\n+                        },\n+                        connected_regions.iter().map(|r| r.1.impl_blocks.len()).max().unwrap()\n+                    );\n+                    // List of connected regions is built. Now, run the overlap check\n+                    // for each pair of impl blocks in the same connected region.\n+                    for (_id, region) in connected_regions.into_iter() {\n+                        let mut impl_blocks =\n+                            region.impl_blocks.into_iter().collect::<SmallVec<[_; 8]>>();\n+                        impl_blocks.sort();\n+                        for (i, &impl1_items_idx) in impl_blocks.iter().enumerate() {\n+                            let &(&impl1_def_id, impl_items1) = &impls_items[impl1_items_idx];\n+                            for &impl2_items_idx in impl_blocks[(i + 1)..].iter() {\n+                                let &(&impl2_def_id, impl_items2) = &impls_items[impl2_items_idx];\n+                                if self.impls_have_common_items(impl_items1, impl_items2) {\n+                                    self.check_for_overlapping_inherent_impls(\n+                                        impl1_def_id,\n+                                        impl2_def_id,\n+                                    );\n+                                }\n+                            }\n                         }\n                     }\n                 }"}]}