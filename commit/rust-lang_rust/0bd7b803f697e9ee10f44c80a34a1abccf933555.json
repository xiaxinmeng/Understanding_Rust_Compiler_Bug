{"sha": "0bd7b803f697e9ee10f44c80a34a1abccf933555", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiZDdiODAzZjY5N2U5ZWUxMGY0NGM4MGEzNGExYWJjY2Y5MzM1NTU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-15T23:40:15Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-15T23:40:55Z"}, "message": "rustc: Translate literals in DPS style; no constification of strings yet.", "tree": {"sha": "b97186069f53c30886334b12c7c32884e6582634", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b97186069f53c30886334b12c7c32884e6582634"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bd7b803f697e9ee10f44c80a34a1abccf933555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd7b803f697e9ee10f44c80a34a1abccf933555", "html_url": "https://github.com/rust-lang/rust/commit/0bd7b803f697e9ee10f44c80a34a1abccf933555", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bd7b803f697e9ee10f44c80a34a1abccf933555/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e114a367f97c3388240746ca506b1e34416a71d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e114a367f97c3388240746ca506b1e34416a71d", "html_url": "https://github.com/rust-lang/rust/commit/6e114a367f97c3388240746ca506b1e34416a71d"}], "stats": {"total": 181, "additions": 174, "deletions": 7}, "files": [{"sha": "d827c4fe7f7c675c858846ff602f4bc7d0911dbb", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 174, "deletions": 7, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/0bd7b803f697e9ee10f44c80a34a1abccf933555/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd7b803f697e9ee10f44c80a34a1abccf933555/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=0bd7b803f697e9ee10f44c80a34a1abccf933555", "patch": "@@ -1,18 +1,28 @@\n // Translates individual functions in the completed AST to the LLVM IR, using\n // destination-passing style.\n \n-import syntax::ast;\n+import back::abi;\n+import lib::llvm::llvm;\n+import llvm::TypeRef;\n+import llvm::ValueRef;\n import middle::trans;\n import middle::ty;\n+import syntax::ast;\n import trans::block_ctxt;\n import trans::crate_ctxt;\n import trans::fn_ctxt;\n import trans::local_ctxt;\n-import lib::llvm::llvm::TypeRef;\n-import lib::llvm::llvm::ValueRef;\n+\n+import std::ivec;\n import std::option::none;\n import std::option::some;\n+import std::str;\n \n+import LLFalse = lib::llvm::False;\n+import LLTrue = lib::llvm::True;\n+import lltype_of = trans::val_ty;\n+import option = std::option::t;\n+import tc = trans_common;\n import type_of_node = trans::node_id_type;\n \n \n@@ -52,6 +62,13 @@ fn dest_tmp(&@block_ctxt bcx, ty::t t) -> tup(@block_ctxt, dest) {\n     ret tup(r.bcx, dest_move(bcx_tcx(bcx), r.val, t));\n }\n \n+fn dest_ptr(&dest dest) -> ValueRef {\n+    alt (dest.slot) {\n+      dst_nil { tc::C_null(tc::T_ptr(tc::T_i8())) }\n+      dst_val(?llptr) { llptr }\n+    }\n+}\n+\n \n // Accessors\n // TODO: When we have overloading, simplify these names!\n@@ -64,19 +81,94 @@ fn bcx_fcx(&@block_ctxt bcx) -> @fn_ctxt { ret bcx.fcx; }\n \n // Common operations\n \n-fn store(&@block_ctxt bcx, &dest dest, ValueRef llsrc) -> @block_ctxt {\n+// If \"cast\" is true, casts dest appropriately before the store.\n+fn store(&@block_ctxt bcx, &dest dest, ValueRef llsrc, bool cast)\n+        -> @block_ctxt {\n     alt (dest.slot) {\n       dst_nil { /* no-op */ }\n-      dst_val(?lldest) { bcx.build.Store(llsrc, lldest); }\n+      dst_val(?lldestptr_orig) {\n+        auto lldestptr = lldestptr_orig;\n+        if (cast) {\n+            lldestptr = bcx.build.PointerCast(lldestptr,\n+                                              tc::T_ptr(lltype_of(llsrc)));\n+        }\n+\n+        bcx.build.Store(llsrc, lldestptr);\n+      }\n+    }\n+    ret bcx;\n+}\n+\n+tag heap { hp_task; hp_shared; }\n+\n+// Allocates a value of the given LLVM size on either the task heap or the\n+// shared heap.\n+fn malloc(&@block_ctxt bcx, ValueRef lldest, heap heap,\n+          option[ValueRef] llcustom_size_opt) -> @block_ctxt {\n+    auto llptrty = llelement_type(lltype_of(lldest));\n+    auto llty = llelement_type(llptrty);\n+\n+    auto lltydescptr = tc::C_null(tc::T_ptr(bcx_ccx(bcx).tydesc_type));\n+\n+    auto llsize;\n+    alt (llcustom_size_opt) {\n+      none { llsize = trans::llsize_of(llty); }\n+      some(?llcustom_size) { llsize = llcustom_size; }\n+    }\n+\n+    auto llupcall;\n+    alt (heap) {\n+      hp_task { llupcall = bcx_ccx(bcx).upcalls.malloc; }\n+      hp_shared { llupcall = bcx_ccx(bcx).upcalls.shared_malloc; }\n     }\n+\n+    auto llresult = bcx.build.Call(llupcall, ~[bcx_fcx(bcx).lltaskptr, llsize,\n+                                               lltydescptr]);\n+    llresult = bcx.build.PointerCast(llresult, llptrty);\n+    bcx.build.Store(llresult, lldest);\n     ret bcx;\n }\n \n \n // AST substructure translation, with destinations\n \n+fn trans_lit(&@block_ctxt cx, &dest dest, &ast::lit lit) -> @block_ctxt {\n+    auto bcx = cx;\n+    alt (lit.node) {\n+      ast::lit_str(?s, ast::sk_unique) {\n+        auto r = trans_lit_str_common(bcx_ccx(bcx), s);\n+        auto llstackpart = r._0; auto llheappartopt = r._1;\n+        bcx = store(bcx, dest, llstackpart, true);\n+        alt (llheappartopt) {\n+          none { /* no-op */ }\n+          some(?llheappart) {\n+            auto lldestptrptr =\n+                bcx.build.InBoundsGEP(dest_ptr(dest),\n+                                      ~[tc::C_int(0),\n+                                        tc::C_uint(abi::ivec_elt_elems)]);\n+            auto llheappartty = lltype_of(llheappart);\n+            lldestptrptr =\n+                bcx.build.PointerCast(lldestptrptr,\n+                                      tc::T_ptr(tc::T_ptr(llheappartty)));\n+            malloc(bcx, lldestptrptr, hp_shared, none);\n+            auto lldestptr = bcx.build.Load(lldestptrptr);\n+            bcx.build.Store(llheappart, lldestptr);\n+          }\n+        }\n+      }\n+      _ {\n+        bcx = store(bcx, dest, trans_lit_common(bcx_ccx(bcx), lit), false);\n+      }\n+    }\n+\n+    ret bcx;\n+}\n+\n fn trans_expr(&@block_ctxt bcx, &dest dest, &@ast::expr expr) -> @block_ctxt {\n-    ret bcx;    // TODO\n+    alt (expr.node) {\n+      ast::expr_lit(?lit) { trans_lit(bcx, dest, *lit); ret bcx; }\n+      _ { fail \"unhandled expr type in trans_expr\"; }\n+    }\n }\n \n fn trans_recv(&@block_ctxt bcx, &dest dest, &@ast::expr expr) -> @block_ctxt {\n@@ -105,8 +197,83 @@ fn trans_block(&@block_ctxt cx, &dest dest, &ast::block block)\n }\n \n \n+\n // AST substructure translation, without destinations\n \n+// Common setup code shared between the crate-constant literal string case and\n+// the block-local literal string case. We don't use destination-passing style\n+// since that doesn't work for crate constants.\n+fn trans_lit_str_common(&@crate_ctxt ccx, &str s)\n+        -> tup(ValueRef, option[ValueRef]) {\n+    auto len = str::byte_len(s);\n+\n+    auto array = ~[];\n+    for (u8 ch in s) { array += ~[tc::C_u8(ch as uint)]; }\n+    array += ~[tc::C_u8(0u)];\n+\n+    if len < abi::ivec_default_length - 1u {    // minus 1 because of the \\0\n+        while (ivec::len(array) < abi::ivec_default_length) {\n+            array += ~[tc::C_u8(0u)];\n+        }\n+\n+        ret tup(tc::C_struct(~[tc::C_uint(len + 1u),\n+                               tc::C_uint(abi::ivec_default_length),\n+                               tc::C_array(tc::T_i8(), array)]),\n+                none);\n+    }\n+\n+    auto llarray = tc::C_array(tc::T_i8(), array);\n+    ret tup(tc::C_struct(~[tc::C_uint(0u),\n+                           tc::C_uint(abi::ivec_default_length),\n+                           tc::C_null(tc::T_ptr(lltype_of(llarray)))]),\n+            some(llarray));\n+}\n+\n+// As above, we don't use destination-passing style here.\n+fn trans_lit_common(&@crate_ctxt ccx, &ast::lit lit) -> ValueRef {\n+    alt (lit.node) {\n+      ast::lit_int(?i) { ret tc::C_int(i); }\n+      ast::lit_uint(?u) { ret tc::C_int(u as int); }\n+      ast::lit_mach_int(?tm, ?i) {\n+        // FIXME: the entire handling of mach types falls apart\n+        // if target int width is larger than host, at the moment;\n+        // re-do the mach-int types using 'big' when that works.\n+\n+        auto t = tc::T_int();\n+        auto s = LLTrue;\n+        alt (tm) {\n+          ast::ty_u8 { t = tc::T_i8(); s = LLFalse; }\n+          ast::ty_u16 { t = tc::T_i16(); s = LLFalse; }\n+          ast::ty_u32 { t = tc::T_i32(); s = LLFalse; }\n+          ast::ty_u64 { t = tc::T_i64(); s = LLFalse; }\n+          ast::ty_i8 { t = tc::T_i8(); }\n+          ast::ty_i16 { t = tc::T_i16(); }\n+          ast::ty_i32 { t = tc::T_i32(); }\n+          ast::ty_i64 { t = tc::T_i64(); }\n+        }\n+        ret tc::C_integral(t, i as uint, s);\n+      }\n+      ast::lit_float(?fs) { ret tc::C_float(fs); }\n+      ast::lit_mach_float(?tm, ?s) {\n+        auto t = tc::T_float();\n+        alt (tm) {\n+          ast::ty_f32 { t = tc::T_f32(); }\n+          ast::ty_f64 { t = tc::T_f64(); }\n+        }\n+        ret tc::C_floating(s, t);\n+      }\n+      ast::lit_char(?c) {\n+        ret tc::C_integral(tc::T_char(), c as uint, LLFalse);\n+      }\n+      ast::lit_bool(?b) { ret tc::C_bool(b); }\n+      ast::lit_nil { ret tc::C_nil(); }\n+      ast::lit_str(?s, ast::sk_rc) { ret tc::C_str(ccx, s); }\n+      ast::lit_str(?s, ast::sk_unique) {\n+        fail \"unique str in trans_lit_common\";\n+      }\n+    }\n+}\n+\n fn trans_init_local(&@block_ctxt bcx, &@ast::local local) -> @block_ctxt {\n     auto llptr = bcx_fcx(bcx).lllocals.get(local.node.id);\n \n@@ -129,7 +296,7 @@ fn trans_init_local(&@block_ctxt bcx, &@ast::local local) -> @block_ctxt {\n       }\n       none {\n         ret store(bcx, dest_copy(bcx_tcx(bcx), llptr, t),\n-                  trans_common::C_null(llelement_type(trans::val_ty(llptr))));\n+                  tc::C_null(llelement_type(trans::val_ty(llptr))), false);\n       }\n     }\n }"}]}