{"sha": "03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZGFmYTdkYTM4ZGVjYmU3NGZjZDhhMjNkN2VjODM1ZTYzN2M4ZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-18T02:56:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-18T02:56:35Z"}, "message": "Auto merge of #58824 - euclio:intra-link-ambiguity, r=petrochenkov\n\noverhaul intra-doc-link ambiguity warning\n\nFixes #52784.\n\n- Makes the warning part of the `intra_doc_link_resolution_failure`\nlint.\n- Tightens the span to just the ambiguous link.\n- Reports ambiguities across all three namespaces.\n- Uses structured suggestions for disambiguation.\n- Adds a test for the warnings.\n\nr? @QuietMisdreavus", "tree": {"sha": "eaa756de5943dff697eaa644d8edfcc93ca8061d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaa756de5943dff697eaa644d8edfcc93ca8061d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "html_url": "https://github.com/rust-lang/rust/commit/03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03dafa7da38decbe74fcd8a23d7ec835e637c8e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "817d074e5459e5c7e44010520f0491b91213b7f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/817d074e5459e5c7e44010520f0491b91213b7f2", "html_url": "https://github.com/rust-lang/rust/commit/817d074e5459e5c7e44010520f0491b91213b7f2"}, {"sha": "7c66ae2fc5eb15a5f9b3c7a0b2e18528c54e88a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c66ae2fc5eb15a5f9b3c7a0b2e18528c54e88a6", "html_url": "https://github.com/rust-lang/rust/commit/7c66ae2fc5eb15a5f9b3c7a0b2e18528c54e88a6"}], "stats": {"total": 449, "additions": 296, "deletions": 153}, "files": [{"sha": "7c1a61449a26fc2e8220fc00ee47e2ed5599f1e6", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 176, "deletions": 152, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/03dafa7da38decbe74fcd8a23d7ec835e637c8e4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03dafa7da38decbe74fcd8a23d7ec835e637c8e4/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "patch": "@@ -1,7 +1,8 @@\n-use rustc::lint as lint;\n-use rustc::hir;\n-use rustc::hir::def::Def;\n+use errors::Applicability;\n+use rustc::hir::def::{Def, Namespace::{self, *}, PerNS};\n use rustc::hir::def_id::DefId;\n+use rustc::hir;\n+use rustc::lint as lint;\n use rustc::ty;\n use syntax;\n use syntax::ast::{self, Ident};\n@@ -35,39 +36,24 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n }\n \n-#[derive(Debug)]\n-enum PathKind {\n-    /// Either a value or type, but not a macro\n-    Unknown,\n-    /// Macro\n-    Macro,\n-    /// Values, functions, consts, statics (everything in the value namespace)\n-    Value,\n-    /// Types, traits (everything in the type namespace)\n-    Type,\n-}\n-\n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n     mod_ids: Vec<ast::NodeId>,\n-    is_nightly_build: bool,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn new(cx: &'a DocContext<'tcx>) -> Self {\n         LinkCollector {\n             cx,\n             mod_ids: Vec::new(),\n-            is_nightly_build: UnstableFeatures::from_environment().is_nightly_build(),\n         }\n     }\n \n-    /// Resolves a given string as a path, along with whether or not it is\n-    /// in the value namespace. Also returns an optional URL fragment in the case\n-    /// of variants and methods.\n+    /// Resolves a string as a path within a particular namespace. Also returns an optional\n+    /// URL fragment in the case of variants and methods.\n     fn resolve(&self,\n                path_str: &str,\n-               is_val: bool,\n+               ns: Namespace,\n                current_item: &Option<String>,\n                parent_id: Option<ast::NodeId>)\n         -> Result<(Def, Option<String>), ()>\n@@ -78,11 +64,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // path.\n         if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n             // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let result = cx.enter_resolver(|resolver| resolver.with_scope(id,\n-                |resolver| {\n-                    resolver.resolve_str_path_error(DUMMY_SP,\n-                                                    &path_str, is_val)\n-            }));\n+            let result = cx.enter_resolver(|resolver| {\n+                resolver.with_scope(id, |resolver| {\n+                    resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns == ValueNS)\n+                })\n+            });\n \n             if let Ok(result) = result {\n                 // In case this is a trait item, skip the\n@@ -95,16 +81,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     _ => return Ok((result.def, None))\n                 };\n \n-                if value != is_val {\n+                if value != (ns == ValueNS) {\n                     return Err(())\n                 }\n-            } else if let Some(prim) = is_primitive(path_str, is_val) {\n+            } else if let Some(prim) = is_primitive(path_str, ns) {\n                 return Ok((prim, Some(path_str.to_owned())))\n             } else {\n                 // If resolution failed, it may still be a method\n                 // because methods are not handled by the resolver\n                 // If so, bail when we're not looking for a value.\n-                if !is_val {\n+                if ns != ValueNS {\n                     return Err(())\n                 }\n             }\n@@ -128,7 +114,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     path = name.clone();\n                 }\n             }\n-            if let Some(prim) = is_primitive(&path, false) {\n+            if let Some(prim) = is_primitive(&path, TypeNS) {\n                 let did = primitive_impl(cx, &path).ok_or(())?;\n                 return cx.tcx.associated_items(did)\n                     .find(|item| item.ident.name == item_name)\n@@ -152,8 +138,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                      .find(|item| item.ident.name == item_name);\n                     if let Some(item) = item {\n                         let out = match item.kind {\n-                            ty::AssociatedKind::Method if is_val => \"method\",\n-                            ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n+                            ty::AssociatedKind::Method if ns == ValueNS => \"method\",\n+                            ty::AssociatedKind::Const if ns == ValueNS => \"associatedconstant\",\n                             _ => return Err(())\n                         };\n                         Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n@@ -190,9 +176,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                  .find(|item| item.ident.name == item_name);\n                     if let Some(item) = item {\n                         let kind = match item.kind {\n-                            ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n-                            ty::AssociatedKind::Type if !is_val => \"associatedtype\",\n-                            ty::AssociatedKind::Method if is_val => {\n+                            ty::AssociatedKind::Const if ns == ValueNS => \"associatedconstant\",\n+                            ty::AssociatedKind::Type if ns == TypeNS => \"associatedtype\",\n+                            ty::AssociatedKind::Method if ns == ValueNS => {\n                                 if item.defaultness.has_value() {\n                                     \"method\"\n                                 } else {\n@@ -279,10 +265,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n         look_for_tests(&cx, &dox, &item, true);\n \n-        if !self.is_nightly_build {\n-            return None;\n-        }\n-\n         for (ori_link, link_range) in markdown_links(&dox) {\n             // Bail early for real links.\n             if ori_link.contains('/') {\n@@ -296,28 +278,28 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n             let link = ori_link.replace(\"`\", \"\");\n             let (def, fragment) = {\n-                let mut kind = PathKind::Unknown;\n+                let mut kind = None;\n                 let path_str = if let Some(prefix) =\n                     [\"struct@\", \"enum@\", \"type@\",\n                      \"trait@\", \"union@\"].iter()\n                                       .find(|p| link.starts_with(**p)) {\n-                    kind = PathKind::Type;\n+                    kind = Some(TypeNS);\n                     link.trim_start_matches(prefix)\n                 } else if let Some(prefix) =\n                     [\"const@\", \"static@\",\n                      \"value@\", \"function@\", \"mod@\",\n                      \"fn@\", \"module@\", \"method@\"]\n                         .iter().find(|p| link.starts_with(**p)) {\n-                    kind = PathKind::Value;\n+                    kind = Some(ValueNS);\n                     link.trim_start_matches(prefix)\n                 } else if link.ends_with(\"()\") {\n-                    kind = PathKind::Value;\n+                    kind = Some(ValueNS);\n                     link.trim_end_matches(\"()\")\n                 } else if link.starts_with(\"macro@\") {\n-                    kind = PathKind::Macro;\n+                    kind = Some(MacroNS);\n                     link.trim_start_matches(\"macro@\")\n                 } else if link.ends_with('!') {\n-                    kind = PathKind::Macro;\n+                    kind = Some(MacroNS);\n                     link.trim_end_matches('!')\n                 } else {\n                     &link[..]\n@@ -329,8 +311,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 }\n \n                 match kind {\n-                    PathKind::Value => {\n-                        if let Ok(def) = self.resolve(path_str, true, &current_item, parent_node) {\n+                    Some(ns @ ValueNS) => {\n+                        if let Ok(def) = self.resolve(path_str, ns, &current_item, parent_node) {\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n@@ -340,71 +322,58 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             continue;\n                         }\n                     }\n-                    PathKind::Type => {\n-                        if let Ok(def) = self.resolve(path_str, false, &current_item, parent_node) {\n+                    Some(ns @ TypeNS) => {\n+                        if let Ok(def) = self.resolve(path_str, ns, &current_item, parent_node) {\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n                             // This could just be a normal link.\n                             continue;\n                         }\n                     }\n-                    PathKind::Unknown => {\n+                    None => {\n                         // Try everything!\n-                        if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                            if let Ok(type_def) =\n-                                self.resolve(path_str, false, &current_item, parent_node)\n-                            {\n-                                let (type_kind, article, type_disambig)\n-                                    = type_ns_kind(type_def.0, path_str);\n-                                ambiguity_error(cx, &item.attrs, path_str,\n-                                                article, type_kind, &type_disambig,\n-                                                \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n-                                continue;\n-                            } else if let Ok(value_def) =\n-                                self.resolve(path_str, true, &current_item, parent_node)\n-                            {\n-                                let (value_kind, value_disambig)\n-                                    = value_ns_kind(value_def.0, path_str)\n-                                        .expect(\"struct and mod cases should have been \\\n-                                                 caught in previous branch\");\n-                                ambiguity_error(cx, &item.attrs, path_str,\n-                                                \"a\", value_kind, &value_disambig,\n-                                                \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n-                            }\n-                            (macro_def, None)\n-                        } else if let Ok(type_def) =\n-                            self.resolve(path_str, false, &current_item, parent_node)\n-                        {\n-                            // It is imperative we search for not-a-value first\n-                            // Otherwise we will find struct ctors for when we are looking\n-                            // for structs, and the link won't work if there is something in\n-                            // both namespaces.\n-                            if let Ok(value_def) =\n-                                self.resolve(path_str, true, &current_item, parent_node)\n-                            {\n-                                let kind = value_ns_kind(value_def.0, path_str);\n-                                if let Some((value_kind, value_disambig)) = kind {\n-                                    let (type_kind, article, type_disambig)\n-                                        = type_ns_kind(type_def.0, path_str);\n-                                    ambiguity_error(cx, &item.attrs, path_str,\n-                                                    article, type_kind, &type_disambig,\n-                                                    \"a\", value_kind, &value_disambig);\n-                                    continue;\n-                                }\n-                            }\n-                            type_def\n-                        } else if let Ok(value_def) =\n-                            self.resolve(path_str, true, &current_item, parent_node)\n-                        {\n-                            value_def\n-                        } else {\n+                        let candidates = PerNS {\n+                            macro_ns: macro_resolve(cx, path_str).map(|def| (def, None)),\n+                            type_ns: self\n+                                .resolve(path_str, TypeNS, &current_item, parent_node)\n+                                .ok(),\n+                            value_ns: self\n+                                .resolve(path_str, ValueNS, &current_item, parent_node)\n+                                .ok()\n+                                .and_then(|(def, fragment)| {\n+                                    // Constructors are picked up in the type namespace.\n+                                    match def {\n+                                        Def::StructCtor(..)\n+                                        | Def::VariantCtor(..)\n+                                        | Def::SelfCtor(..) => None,\n+                                        _ => Some((def, fragment))\n+                                    }\n+                                }),\n+                        };\n+\n+                        if candidates.is_empty() {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n                             // this could just be a normal link\n                             continue;\n                         }\n+\n+                        let is_unambiguous = candidates.clone().present_items().count() == 1;\n+                        if is_unambiguous {\n+                            candidates.present_items().next().unwrap()\n+                        } else {\n+                            ambiguity_error(\n+                                cx,\n+                                &item.attrs,\n+                                path_str,\n+                                &dox,\n+                                link_range,\n+                                candidates.map(|candidate| candidate.map(|(def, _)| def)),\n+                            );\n+                            continue;\n+                        }\n                     }\n-                    PathKind::Macro => {\n+                    Some(MacroNS) => {\n                         if let Some(def) = macro_resolve(cx, path_str) {\n                             (def, None)\n                         } else {\n@@ -511,59 +480,114 @@ fn resolution_failure(\n     diag.emit();\n }\n \n-fn ambiguity_error(cx: &DocContext<'_>, attrs: &Attributes,\n-                   path_str: &str,\n-                   article1: &str, kind1: &str, disambig1: &str,\n-                   article2: &str, kind2: &str, disambig2: &str) {\n+fn ambiguity_error(\n+    cx: &DocContext<'_>,\n+    attrs: &Attributes,\n+    path_str: &str,\n+    dox: &str,\n+    link_range: Option<Range<usize>>,\n+    candidates: PerNS<Option<Def>>,\n+) {\n     let sp = span_of_attrs(attrs);\n-    cx.sess()\n-      .struct_span_warn(sp,\n-                        &format!(\"`{}` is both {} {} and {} {}\",\n-                                 path_str, article1, kind1,\n-                                 article2, kind2))\n-      .help(&format!(\"try `{}` if you want to select the {}, \\\n-                      or `{}` if you want to \\\n-                      select the {}\",\n-                      disambig1, kind1, disambig2,\n-                      kind2))\n-      .emit();\n-}\n \n-/// Given a def, returns its name and disambiguator\n-/// for a value namespace.\n-///\n-/// Returns `None` for things which cannot be ambiguous since\n-/// they exist in both namespaces (structs and modules).\n-fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n-    match def {\n-        // Structs, variants, and mods exist in both namespaces; skip them.\n-        Def::StructCtor(..) | Def::Mod(..) | Def::Variant(..) |\n-        Def::VariantCtor(..) | Def::SelfCtor(..)\n-            => None,\n-        Def::Fn(..)\n-            => Some((\"function\", format!(\"{}()\", path_str))),\n-        Def::Method(..)\n-            => Some((\"method\", format!(\"{}()\", path_str))),\n-        Def::Const(..)\n-            => Some((\"const\", format!(\"const@{}\", path_str))),\n-        Def::Static(..)\n-            => Some((\"static\", format!(\"static@{}\", path_str))),\n-        _ => Some((\"value\", format!(\"value@{}\", path_str))),\n+    let mut msg = format!(\"`{}` is \", path_str);\n+\n+    let candidates = [TypeNS, ValueNS, MacroNS].iter().filter_map(|&ns| {\n+        candidates[ns].map(|def| (def, ns))\n+    }).collect::<Vec<_>>();\n+    match candidates.as_slice() {\n+        [(first_def, _), (second_def, _)] => {\n+            msg += &format!(\n+                \"both {} {} and {} {}\",\n+                first_def.article(),\n+                first_def.kind_name(),\n+                second_def.article(),\n+                second_def.kind_name(),\n+            );\n+        }\n+        _ => {\n+            let mut candidates = candidates.iter().peekable();\n+            while let Some((def, _)) = candidates.next() {\n+                if candidates.peek().is_some() {\n+                    msg += &format!(\"{} {}, \", def.article(), def.kind_name());\n+                } else {\n+                    msg += &format!(\"and {} {}\", def.article(), def.kind_name());\n+                }\n+            }\n+        }\n     }\n-}\n \n-/// Given a def, returns its name, the article to be used, and a disambiguator\n-/// for the type namespace.\n-fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String) {\n-    let (kind, article) = match def {\n-        // We can still have non-tuple structs.\n-        Def::Struct(..) => (\"struct\", \"a\"),\n-        Def::Enum(..) => (\"enum\", \"an\"),\n-        Def::Trait(..) => (\"trait\", \"a\"),\n-        Def::Union(..) => (\"union\", \"a\"),\n-        _ => (\"type\", \"a\"),\n-    };\n-    (kind, article, format!(\"{}@{}\", kind, path_str))\n+    let mut diag = cx.tcx.struct_span_lint_hir(\n+        lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        hir::CRATE_HIR_ID,\n+        sp,\n+        &msg,\n+    );\n+\n+    if let Some(link_range) = link_range {\n+        if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n+            diag.set_span(sp);\n+            diag.span_label(sp, \"ambiguous link\");\n+\n+            for (def, ns) in candidates {\n+                let (action, mut suggestion) = match def {\n+                    Def::Method(..) | Def::Fn(..) => {\n+                        (\"add parentheses\", format!(\"{}()\", path_str))\n+                    }\n+                    Def::Macro(..) => {\n+                        (\"add an exclamation mark\", format!(\"{}!\", path_str))\n+                    }\n+                    _ => {\n+                        let type_ = match (def, ns) {\n+                            (Def::Const(..), _) => \"const\",\n+                            (Def::Static(..), _) => \"static\",\n+                            (Def::Struct(..), _) => \"struct\",\n+                            (Def::Enum(..), _) => \"enum\",\n+                            (Def::Union(..), _) => \"union\",\n+                            (Def::Trait(..), _) => \"trait\",\n+                            (Def::Mod(..), _) => \"module\",\n+                            (_, TypeNS) => \"type\",\n+                            (_, ValueNS) => \"value\",\n+                            (_, MacroNS) => \"macro\",\n+                        };\n+\n+                        // FIXME: if this is an implied shortcut link, it's bad style to suggest `@`\n+                        (\"prefix with the item type\", format!(\"{}@{}\", type_, path_str))\n+                    }\n+                };\n+\n+                if dox.bytes().nth(link_range.start) == Some(b'`') {\n+                    suggestion = format!(\"`{}`\", suggestion);\n+                }\n+\n+                diag.span_suggestion(\n+                    sp,\n+                    &format!(\"to link to the {}, {}\", def.kind_name(), action),\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        } else {\n+            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+            //                       ^     ~~~~\n+            //                       |     link_range\n+            //                       last_new_line_offset\n+            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+            // Print the line containing the `link_range` and manually mark it with '^'s.\n+            diag.note(&format!(\n+                \"the link appears in this line:\\n\\n{line}\\n\\\n+                 {indicator: <before$}{indicator:^<found$}\",\n+                line=line,\n+                indicator=\"\",\n+                before=link_range.start - last_new_line_offset,\n+                found=link_range.len(),\n+            ));\n+        }\n+    }\n+\n+    diag.emit();\n }\n \n /// Given an enum variant's def, return the def of its enum and the associated fragment.\n@@ -600,11 +624,11 @@ const PRIMITIVES: &[(&str, Def)] = &[\n     (\"char\",  Def::PrimTy(hir::PrimTy::Char)),\n ];\n \n-fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {\n-    if is_val {\n-        None\n-    } else {\n+fn is_primitive(path_str: &str, ns: Namespace) -> Option<Def> {\n+    if ns == TypeNS {\n         PRIMITIVES.iter().find(|x| x.0 == path_str).map(|x| x.1)\n+    } else {\n+        None\n     }\n }\n "}, {"sha": "7316fcdad677296c31011a90dc4a2690be2e1e22", "filename": "src/test/rustdoc-ui/intra-links-ambiguity.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/03dafa7da38decbe74fcd8a23d7ec835e637c8e4/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03dafa7da38decbe74fcd8a23d7ec835e637c8e4/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.rs?ref=03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "patch": "@@ -0,0 +1,36 @@\n+#![deny(intra_doc_link_resolution_failure)]\n+#![allow(non_camel_case_types)]\n+#![allow(non_upper_case_globals)]\n+\n+pub fn ambiguous() {}\n+\n+pub struct ambiguous {}\n+\n+#[macro_export]\n+macro_rules! multi_conflict { () => {} }\n+\n+#[allow(non_camel_case_types)]\n+pub struct multi_conflict {}\n+\n+pub fn multi_conflict() {}\n+\n+pub mod type_and_value {}\n+\n+pub const type_and_value: i32 = 0;\n+\n+pub mod foo {\n+    pub enum bar {}\n+\n+    pub fn bar() {}\n+}\n+\n+/// [`ambiguous`] is ambiguous. //~ERROR `ambiguous`\n+///\n+/// [ambiguous] is ambiguous. //~ERROR ambiguous\n+///\n+/// [`multi_conflict`] is a three-way conflict. //~ERROR `multi_conflict`\n+///\n+/// Ambiguous [type_and_value]. //~ERROR type_and_value\n+///\n+/// Ambiguous non-implied shortcut link [`foo::bar`]. //~ERROR `foo::bar`\n+pub struct Docs {}"}, {"sha": "5d66cc1364c5f5c59655f2c5569a3ce3ad5c80b4", "filename": "src/test/rustdoc-ui/intra-links-ambiguity.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/03dafa7da38decbe74fcd8a23d7ec835e637c8e4/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/03dafa7da38decbe74fcd8a23d7ec835e637c8e4/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr?ref=03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "patch": "@@ -0,0 +1,82 @@\n+error: `ambiguous` is both a struct and a function\n+  --> $DIR/intra-links-ambiguity.rs:27:6\n+   |\n+LL | /// [`ambiguous`] is ambiguous.\n+   |      ^^^^^^^^^^^ ambiguous link\n+   |\n+note: lint level defined here\n+  --> $DIR/intra-links-ambiguity.rs:1:9\n+   |\n+LL | #![deny(intra_doc_link_resolution_failure)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the struct, prefix with the item type\n+   |\n+LL | /// [`struct@ambiguous`] is ambiguous.\n+   |      ^^^^^^^^^^^^^^^^^^\n+help: to link to the function, add parentheses\n+   |\n+LL | /// [`ambiguous()`] is ambiguous.\n+   |      ^^^^^^^^^^^^^\n+\n+error: `ambiguous` is both a struct and a function\n+  --> $DIR/intra-links-ambiguity.rs:29:6\n+   |\n+LL | /// [ambiguous] is ambiguous.\n+   |      ^^^^^^^^^ ambiguous link\n+help: to link to the struct, prefix with the item type\n+   |\n+LL | /// [struct@ambiguous] is ambiguous.\n+   |      ^^^^^^^^^^^^^^^^\n+help: to link to the function, add parentheses\n+   |\n+LL | /// [ambiguous()] is ambiguous.\n+   |      ^^^^^^^^^^^\n+\n+error: `multi_conflict` is a struct, a function, and a macro\n+  --> $DIR/intra-links-ambiguity.rs:31:6\n+   |\n+LL | /// [`multi_conflict`] is a three-way conflict.\n+   |      ^^^^^^^^^^^^^^^^ ambiguous link\n+help: to link to the struct, prefix with the item type\n+   |\n+LL | /// [`struct@multi_conflict`] is a three-way conflict.\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the function, add parentheses\n+   |\n+LL | /// [`multi_conflict()`] is a three-way conflict.\n+   |      ^^^^^^^^^^^^^^^^^^\n+help: to link to the macro, add an exclamation mark\n+   |\n+LL | /// [`multi_conflict!`] is a three-way conflict.\n+   |      ^^^^^^^^^^^^^^^^^\n+\n+error: `type_and_value` is both a module and a constant\n+  --> $DIR/intra-links-ambiguity.rs:33:16\n+   |\n+LL | /// Ambiguous [type_and_value].\n+   |                ^^^^^^^^^^^^^^ ambiguous link\n+help: to link to the module, prefix with the item type\n+   |\n+LL | /// Ambiguous [module@type_and_value].\n+   |                ^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the constant, prefix with the item type\n+   |\n+LL | /// Ambiguous [const@type_and_value].\n+   |                ^^^^^^^^^^^^^^^^^^^^\n+\n+error: `foo::bar` is both an enum and a function\n+  --> $DIR/intra-links-ambiguity.rs:35:42\n+   |\n+LL | /// Ambiguous non-implied shortcut link [`foo::bar`].\n+   |                                          ^^^^^^^^^^ ambiguous link\n+help: to link to the enum, prefix with the item type\n+   |\n+LL | /// Ambiguous non-implied shortcut link [`enum@foo::bar`].\n+   |                                          ^^^^^^^^^^^^^^^\n+help: to link to the function, add parentheses\n+   |\n+LL | /// Ambiguous non-implied shortcut link [`foo::bar()`].\n+   |                                          ^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "c356ab3a8ac52d9de2b85e3c9c61d8a848deac86", "filename": "src/test/rustdoc/intra-links.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03dafa7da38decbe74fcd8a23d7ec835e637c8e4/src%2Ftest%2Frustdoc%2Fintra-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03dafa7da38decbe74fcd8a23d7ec835e637c8e4/src%2Ftest%2Frustdoc%2Fintra-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-links.rs?ref=03dafa7da38decbe74fcd8a23d7ec835e637c8e4", "patch": "@@ -22,6 +22,7 @@\n //! * [`ThisType::this_method`](ThisType::this_method)\n //! * [`ThisEnum`](ThisEnum)\n //! * [`ThisEnum::ThisVariant`](ThisEnum::ThisVariant)\n+//! * [`ThisEnum::ThisVariantCtor`](ThisEnum::ThisVariantCtor)\n //! * [`ThisTrait`](ThisTrait)\n //! * [`ThisTrait::this_associated_method`](ThisTrait::this_associated_method)\n //! * [`ThisTrait::ThisAssociatedType`](ThisTrait::ThisAssociatedType)\n@@ -50,7 +51,7 @@ pub struct ThisType;\n impl ThisType {\n     pub fn this_method() {}\n }\n-pub enum ThisEnum { ThisVariant, }\n+pub enum ThisEnum { ThisVariant, ThisVariantCtor(u32), }\n pub trait ThisTrait {\n     type ThisAssociatedType;\n     const THIS_ASSOCIATED_CONST: u8;"}]}