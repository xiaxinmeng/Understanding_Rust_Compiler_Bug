{"sha": "515287f114b546a72d4a1fe8ffe1dbc20dedf13d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNTI4N2YxMTRiNTQ2YTcyZDRhMWZlOGZmZTFkYmMyMGRlZGYxM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-17T11:40:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-17T11:40:40Z"}, "message": "Auto merge of #1480 - RalfJung:diagnostic-stacktrace-fix, r=oli-obk\n\nfix non-fatal diagnostics stacktraces\n\nOur non-fatal diagnostics are printed *after* completing the step that triggered them, which means the span and stacktrace used for them is that of the *next* MIR statement being executed. That's quite bad, obviously, as pointing to where in the source something happens is their entire point.\n\nHere's an example:\n```rust\nuse std::ptr;\n\nstatic mut PTR: *mut u8 = ptr::null_mut();\n\nfn get_ptr() -> *const u8 { unsafe { PTR }}\n\nfn cause_ub() { unsafe {\n    let _x = &*get_ptr();\n} }\n\nfn main() { unsafe {\n   let mut l = 0;\n   PTR = &mut l;\n   let r = &mut *PTR;\n   cause_ub();\n   let _x = *r;\n} }\n```\nThis example is UB; if you track the pointer tag that is given in the final error, it points to the entire body of `cause_ub` as a span, instead of the `&*get_ptr();`.\n\nI am not sure what the best way is to fix this. The cleanest way would be to capture a stack trace before the step and use it in case of a diagnostic, but that seems silly perf-wise. So instead I went with reconstructing the old stacktrace by going back one step in the MIR. This is however not possible if we were executing a `Terminator`... I think those cannot cause diagnostics but still, this is not great.\n\nAny ideas?\nr? @oli-obk", "tree": {"sha": "de442b2211a9700d21ccc4bad1f22eeb98ffb0ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de442b2211a9700d21ccc4bad1f22eeb98ffb0ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/515287f114b546a72d4a1fe8ffe1dbc20dedf13d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/515287f114b546a72d4a1fe8ffe1dbc20dedf13d", "html_url": "https://github.com/rust-lang/rust/commit/515287f114b546a72d4a1fe8ffe1dbc20dedf13d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/515287f114b546a72d4a1fe8ffe1dbc20dedf13d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0454dabcfba481d4810a67511319ded727f281de", "url": "https://api.github.com/repos/rust-lang/rust/commits/0454dabcfba481d4810a67511319ded727f281de", "html_url": "https://github.com/rust-lang/rust/commit/0454dabcfba481d4810a67511319ded727f281de"}, {"sha": "545aa6019557ae2777233e1d8f6cbd8b6f7b3180", "url": "https://api.github.com/repos/rust-lang/rust/commits/545aa6019557ae2777233e1d8f6cbd8b6f7b3180", "html_url": "https://github.com/rust-lang/rust/commit/545aa6019557ae2777233e1d8f6cbd8b6f7b3180"}], "stats": {"total": 107, "additions": 79, "deletions": 28}, "files": [{"sha": "009f8aa29cecf11ebdf1fef0633aca6f6eaf41bc", "filename": "src/diagnostics.rs", "status": "modified", "additions": 74, "deletions": 27, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/515287f114b546a72d4a1fe8ffe1dbc20dedf13d/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515287f114b546a72d4a1fe8ffe1dbc20dedf13d/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=515287f114b546a72d4a1fe8ffe1dbc20dedf13d", "patch": "@@ -3,7 +3,8 @@ use std::fmt;\n \n use log::trace;\n \n-use rustc_span::DUMMY_SP;\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::{source_map::DUMMY_SP, Span};\n \n use crate::*;\n \n@@ -116,7 +117,17 @@ pub fn report_error<'tcx, 'mir>(\n \n     e.print_backtrace();\n     let msg = e.to_string();\n-    report_msg(ecx, &format!(\"{}: {}\", title, msg), msg, helps, true);\n+    report_msg(*ecx.tcx, /*error*/true, &format!(\"{}: {}\", title, msg), msg, helps, &ecx.generate_stacktrace());\n+\n+    // Debug-dump all locals.\n+    for (i, frame) in ecx.active_thread_stack().iter().enumerate() {\n+        trace!(\"-------------------\");\n+        trace!(\"Frame {}\", i);\n+        trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n+        for (i, local) in frame.locals.iter().enumerate() {\n+            trace!(\"    local {}: {:?}\", i, local.value);\n+        }\n+    }\n \n     // Extra output to help debug specific issues.\n     match e.kind {\n@@ -135,24 +146,21 @@ pub fn report_error<'tcx, 'mir>(\n     None\n }\n \n-/// Report an error or note (depending on the `error` argument) at the current frame's current statement.\n+/// Report an error or note (depending on the `error` argument) with the given stacktrace.\n /// Also emits a full stacktrace of the interpreter stack.\n-fn report_msg<'tcx, 'mir>(\n-    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+fn report_msg<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    error: bool,\n     title: &str,\n     span_msg: String,\n     mut helps: Vec<String>,\n-    error: bool,\n+    stacktrace: &[FrameInfo<'tcx>],\n ) {\n-    let span = if let Some(frame) = ecx.active_thread_stack().last() {\n-        frame.current_source_info().unwrap().span\n-    } else {\n-        DUMMY_SP\n-    };\n+    let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n     let mut err = if error {\n-        ecx.tcx.sess.struct_span_err(span, title)\n+        tcx.sess.struct_span_err(span, title)\n     } else {\n-        ecx.tcx.sess.diagnostic().span_note_diag(span, title)\n+        tcx.sess.diagnostic().span_note_diag(span, title)\n     };\n     err.span_label(span, span_msg);\n     if !helps.is_empty() {\n@@ -163,8 +171,7 @@ fn report_msg<'tcx, 'mir>(\n         }\n     }\n     // Add backtrace\n-    let frames = ecx.generate_stacktrace();\n-    for (idx, frame_info) in frames.iter().enumerate() {\n+    for (idx, frame_info) in stacktrace.iter().enumerate() {\n         let is_local = frame_info.instance.def_id().is_local();\n         // No span for non-local frames and the first frame (which is the error site).\n         if is_local && idx > 0 {\n@@ -175,15 +182,6 @@ fn report_msg<'tcx, 'mir>(\n     }\n \n     err.emit();\n-\n-    for (i, frame) in ecx.active_thread_stack().iter().enumerate() {\n-        trace!(\"-------------------\");\n-        trace!(\"Frame {}\", i);\n-        trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n-        for (i, local) in frame.locals.iter().enumerate() {\n-            trace!(\"    local {}: {:?}\", i, local.value);\n-        }\n-    }\n }\n \n thread_local! {\n@@ -196,13 +194,62 @@ pub fn register_diagnostic(e: NonHaltingDiagnostic) {\n     DIAGNOSTICS.with(|diagnostics| diagnostics.borrow_mut().push(e));\n }\n \n+/// Remember enough about the topmost frame so that we can restore the stack\n+/// after a step was taken.\n+pub struct TopFrameInfo<'tcx> {\n+    stack_size: usize,\n+    instance: ty::Instance<'tcx>,\n+    span: Span,\n+}\n+\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn preprocess_diagnostics(&self) -> TopFrameInfo<'tcx> {\n+        // Ensure we have no lingering diagnostics.\n+        DIAGNOSTICS.with(|diagnostics| assert!(diagnostics.borrow().is_empty()));\n+\n+        let this = self.eval_context_ref();\n+        let frame = this.frame();\n+\n+        TopFrameInfo {\n+            stack_size: this.active_thread_stack().len(),\n+            instance: frame.instance,\n+            span: frame.current_source_info().map_or(DUMMY_SP, |si| si.span),\n+        }\n+    }\n+\n     /// Emit all diagnostics that were registed with `register_diagnostics`\n-    fn process_diagnostics(&self) {\n+    fn process_diagnostics(&self, info: TopFrameInfo<'tcx>) {\n         let this = self.eval_context_ref();\n         DIAGNOSTICS.with(|diagnostics| {\n-            for e in diagnostics.borrow_mut().drain(..) {\n+            let mut diagnostics = diagnostics.borrow_mut();\n+            if diagnostics.is_empty() {\n+                return;\n+            }\n+            // We need to fix up the stack trace, because the machine has already\n+            // stepped to the next statement.\n+            let mut stacktrace = this.generate_stacktrace();\n+            // Remove newly pushed frames.\n+            while stacktrace.len() > info.stack_size {\n+                stacktrace.remove(0);\n+            }\n+            // Add popped frame back.\n+            if stacktrace.len() < info.stack_size {\n+                assert!(stacktrace.len() == info.stack_size-1, \"we should never pop more than one frame at once\");\n+                let frame_info = FrameInfo {\n+                    instance: info.instance,\n+                    span: info.span,\n+                    lint_root: None,\n+                };\n+                stacktrace.insert(0, frame_info);\n+            } else {\n+                // Adjust topmost frame.\n+                stacktrace[0].span = info.span;\n+                assert_eq!(stacktrace[0].instance, info.instance, \"we should not pop and push a frame in one step\");\n+            }\n+\n+            // Show diagnostics.\n+            for e in diagnostics.drain(..) {\n                 use NonHaltingDiagnostic::*;\n                 let msg = match e {\n                     PoppedPointerTag(item) =>\n@@ -214,7 +261,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     FreedAlloc(AllocId(id)) =>\n                         format!(\"freed allocation with id {}\", id),\n                 };\n-                report_msg(this, \"tracking was triggered\", msg, vec![], false);\n+                report_msg(*this.tcx, /*error*/false, \"tracking was triggered\", msg, vec![], &stacktrace);\n             }\n         });\n     }"}, {"sha": "79ceb6be806e23ad2bded4cda839614693e53430", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/515287f114b546a72d4a1fe8ffe1dbc20dedf13d/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515287f114b546a72d4a1fe8ffe1dbc20dedf13d/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=515287f114b546a72d4a1fe8ffe1dbc20dedf13d", "patch": "@@ -212,7 +212,9 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n         loop {\n             match ecx.schedule()? {\n                 SchedulingAction::ExecuteStep => {\n+                    let info = ecx.preprocess_diagnostics();\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n+                    ecx.process_diagnostics(info);\n                 }\n                 SchedulingAction::ExecuteTimeoutCallback => {\n                     assert!(ecx.machine.communicate,\n@@ -230,7 +232,6 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n                     break;\n                 }\n             }\n-            ecx.process_diagnostics();\n         }\n         let return_code = ecx.read_scalar(ret_place.into())?.not_undef()?.to_machine_isize(&ecx)?;\n         Ok(return_code)"}, {"sha": "42a4dbded58f4f33ea6f7d82b9373dcc70fd1d44", "filename": "src/thread.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/515287f114b546a72d4a1fe8ffe1dbc20dedf13d/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515287f114b546a72d4a1fe8ffe1dbc20dedf13d/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=515287f114b546a72d4a1fe8ffe1dbc20dedf13d", "patch": "@@ -373,6 +373,9 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Change the active thread to some enabled thread.\n     fn yield_active_thread(&mut self) {\n+        // We do not yield immediately, as swapping out the current stack while executing a MIR statement\n+        // could lead to all sorts of confusion.\n+        // We should only switch stacks between steps.\n         self.yield_active_thread = true;\n     }\n "}]}