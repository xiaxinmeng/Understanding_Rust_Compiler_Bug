{"sha": "dfaad04b7a14012ac282269eacfb51b4e97673c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYWFkMDRiN2ExNDAxMmFjMjgyMjY5ZWFjZmI1MWI0ZTk3NjczYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-30T06:56:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-30T06:56:41Z"}, "message": "auto merge of #19365 : frewsxcv/rust/getopts-cleanup, r=alexcrichton\n\n* Remove public reexports, as a part of #19253\r\n* Rename getopts::Fail_ to getopts::Fail\r\n * Didn't see a reason for the suffixed '_'\r\n* Removed getopts::FailType\r\n * Looked like it was only beings used for tests; refactored the tests\r\n   to stop requiring it\r\n* A few other non-breaking trivial refactoring changes\r\n\r\n[breaking-change]", "tree": {"sha": "d0c2b4859219283c538959184223d225076fa4d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0c2b4859219283c538959184223d225076fa4d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfaad04b7a14012ac282269eacfb51b4e97673c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfaad04b7a14012ac282269eacfb51b4e97673c1", "html_url": "https://github.com/rust-lang/rust/commit/dfaad04b7a14012ac282269eacfb51b4e97673c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfaad04b7a14012ac282269eacfb51b4e97673c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d8f41b75f9bec7c7676122f85e049e7d7933298", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8f41b75f9bec7c7676122f85e049e7d7933298", "html_url": "https://github.com/rust-lang/rust/commit/8d8f41b75f9bec7c7676122f85e049e7d7933298"}, {"sha": "1919b12775ca45e8f5bb4b7540ebfa3d100f5bf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1919b12775ca45e8f5bb4b7540ebfa3d100f5bf6", "html_url": "https://github.com/rust-lang/rust/commit/1919b12775ca45e8f5bb4b7540ebfa3d100f5bf6"}], "stats": {"total": 112, "additions": 42, "deletions": 70}, "files": [{"sha": "1204ac18f99dc1c5f11e23a2b91bbf3e3ae569e3", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 42, "deletions": 70, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/dfaad04b7a14012ac282269eacfb51b4e97673c1/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfaad04b7a14012ac282269eacfb51b4e97673c1/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=dfaad04b7a14012ac282269eacfb51b4e97673c1", "patch": "@@ -92,11 +92,10 @@\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n-pub use self::Name::*;\n-pub use self::HasArg::*;\n-pub use self::Occur::*;\n-pub use self::Fail_::*;\n-pub use self::FailType::*;\n+use self::Name::*;\n+use self::HasArg::*;\n+use self::Occur::*;\n+use self::Fail::*;\n use self::Optval::*;\n \n use std::fmt;\n@@ -191,7 +190,7 @@ pub struct Matches {\n /// expected format. Use the `Show` implementation to output detailed\n /// information.\n #[deriving(Clone, PartialEq, Eq)]\n-pub enum Fail_ {\n+pub enum Fail {\n     /// The option requires an argument but none was passed.\n     ArgumentMissing(String),\n     /// The passed option is not declared among the possible options.\n@@ -204,19 +203,8 @@ pub enum Fail_ {\n     UnexpectedArgument(String),\n }\n \n-/// The type of failure that occurred.\n-#[deriving(PartialEq, Eq)]\n-#[allow(missing_docs)]\n-pub enum FailType {\n-    ArgumentMissing_,\n-    UnrecognizedOption_,\n-    OptionMissing_,\n-    OptionDuplicated_,\n-    UnexpectedArgument_,\n-}\n-\n /// The result of parsing a command line with a set of options.\n-pub type Result = result::Result<Matches, Fail_>;\n+pub type Result = result::Result<Matches, Fail>;\n \n impl Name {\n     fn from_str(nm: &str) -> Name {\n@@ -264,7 +252,7 @@ impl OptGroup {\n             (1,_) => Opt {\n                 name: Long((long_name)),\n                 hasarg: hasarg,\n-                occur:  occur,\n+                occur: occur,\n                 aliases: vec!(\n                     Opt {\n                         name: Short(short_name.as_slice().char_at(0)),\n@@ -366,11 +354,12 @@ impl Matches {\n     pub fn opt_default(&self, nm: &str, def: &str) -> Option<String> {\n         let vals = self.opt_vals(nm);\n         if vals.is_empty() {\n-            return None;\n-        }\n-        match vals[0] {\n-            Val(ref s) => Some((*s).clone()),\n-            _ => Some(def.to_string())\n+            None\n+        } else {\n+            match vals[0] {\n+                Val(ref s) => Some((*s).clone()),\n+                _ => Some(def.to_string())\n+            }\n         }\n     }\n \n@@ -534,15 +523,15 @@ pub fn opt(short_name: &str,\n     }\n }\n \n-impl Fail_ {\n-    /// Convert a `Fail_` enum into an error string.\n+impl Fail {\n+    /// Convert a `Fail` enum into an error string.\n     #[deprecated=\"use `Show` (`{}` format specifier)\"]\n     pub fn to_err_msg(self) -> String {\n         self.to_string()\n     }\n }\n \n-impl fmt::Show for Fail_ {\n+impl fmt::Show for Fail {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ArgumentMissing(ref nm) => {\n@@ -570,7 +559,7 @@ impl fmt::Show for Fail_ {\n /// `opt_str`, etc. to interrogate results.\n /// # Panics\n ///\n-/// Returns `Err(Fail_)` on failure: use the `Show` implementation of `Fail_` to display\n+/// Returns `Err(Fail)` on failure: use the `Show` implementation of `Fail` to display\n /// information about it.\n pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n@@ -681,21 +670,15 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         }\n         i += 1;\n     }\n-    i = 0u;\n-    while i < n_opts {\n+    for i in range(0u, n_opts) {\n         let n = vals[i].len();\n         let occ = opts[i].occur;\n-        if occ == Req {\n-            if n == 0 {\n-                return Err(OptionMissing(opts[i].name.to_string()));\n-            }\n+        if occ == Req && n == 0 {\n+            return Err(OptionMissing(opts[i].name.to_string()));\n         }\n-        if occ != Multi {\n-            if n > 1 {\n-                return Err(OptionDuplicated(opts[i].name.to_string()));\n-            }\n+        if occ != Multi && n > 1 {\n+            return Err(OptionDuplicated(opts[i].name.to_string()));\n         }\n-        i += 1;\n     }\n     Ok(Matches {\n         opts: opts,\n@@ -966,20 +949,11 @@ fn test_split_within() {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use super::Fail::*;\n \n     use std::result::{Err, Ok};\n     use std::result;\n \n-    fn check_fail_type(f: Fail_, ft: FailType) {\n-        match f {\n-          ArgumentMissing(_) => assert!(ft == ArgumentMissing_),\n-          UnrecognizedOption(_) => assert!(ft == UnrecognizedOption_),\n-          OptionMissing(_) => assert!(ft == OptionMissing_),\n-          OptionDuplicated(_) => assert!(ft == OptionDuplicated_),\n-          UnexpectedArgument(_) => assert!(ft == UnexpectedArgument_)\n-        }\n-    }\n-\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt() {\n@@ -1013,7 +987,7 @@ mod tests {\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n-          Err(f) => check_fail_type(f, OptionMissing_),\n+          Err(OptionMissing(_)) => {},\n           _ => panic!()\n         }\n     }\n@@ -1024,12 +998,12 @@ mod tests {\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n-          Err(f) => check_fail_type(f, ArgumentMissing_),\n+          Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n-          Err(f) => check_fail_type(f, ArgumentMissing_),\n+          Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n     }\n@@ -1040,7 +1014,7 @@ mod tests {\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n-          Err(f) => check_fail_type(f, OptionDuplicated_),\n+          Err(OptionDuplicated(_)) => {},\n           _ => panic!()\n         }\n     }\n@@ -1092,12 +1066,12 @@ mod tests {\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n-          Err(f) => check_fail_type(f, ArgumentMissing_),\n+          Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n-          Err(f) => check_fail_type(f, ArgumentMissing_),\n+          Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n     }\n@@ -1108,7 +1082,7 @@ mod tests {\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n-          Err(f) => check_fail_type(f, OptionDuplicated_),\n+          Err(OptionDuplicated(_)) => {},\n           _ => panic!()\n         }\n     }\n@@ -1156,9 +1130,7 @@ mod tests {\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n-          Err(f) => {\n-            check_fail_type(f, UnexpectedArgument_);\n-          }\n+          Err(UnexpectedArgument(_)) => {},\n           _ => panic!()\n         }\n     }\n@@ -1169,7 +1141,7 @@ mod tests {\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n-          Err(f) => check_fail_type(f, OptionDuplicated_),\n+          Err(OptionDuplicated(_)) => {},\n           _ => panic!()\n         }\n     }\n@@ -1317,12 +1289,12 @@ mod tests {\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n-          Err(f) => check_fail_type(f, ArgumentMissing_),\n+          Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n         let short_args = vec!(\"-t\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n-          Err(f) => check_fail_type(f, ArgumentMissing_),\n+          Err(ArgumentMissing(_)) => {},\n           _ => panic!()\n         }\n     }\n@@ -1352,12 +1324,12 @@ mod tests {\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n-          Err(f) => check_fail_type(f, UnrecognizedOption_),\n+          Err(UnrecognizedOption(_)) => {},\n           _ => panic!()\n         }\n         let short_args = vec!(\"-u\".to_string());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n-          Err(f) => check_fail_type(f, UnrecognizedOption_),\n+          Err(UnrecognizedOption(_)) => {},\n           _ => panic!()\n         }\n     }\n@@ -1493,14 +1465,14 @@ mod tests {\n     #[test]\n     fn test_long_to_short() {\n         let mut short = Opt {\n-            name: Long(\"banana\".to_string()),\n-            hasarg: Yes,\n-            occur: Req,\n+            name: Name::Long(\"banana\".to_string()),\n+            hasarg: HasArg::Yes,\n+            occur: Occur::Req,\n             aliases: Vec::new(),\n         };\n-        short.aliases = vec!(Opt { name: Short('b'),\n-                                hasarg: Yes,\n-                                occur: Req,\n+        short.aliases = vec!(Opt { name: Name::Short('b'),\n+                                hasarg: HasArg::Yes,\n+                                occur: Occur::Req,\n                                 aliases: Vec::new() });\n         let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n "}]}