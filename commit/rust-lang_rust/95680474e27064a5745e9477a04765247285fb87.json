{"sha": "95680474e27064a5745e9477a04765247285fb87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NjgwNDc0ZTI3MDY0YTU3NDVlOTQ3N2EwNDc2NTI0NzI4NWZiODc=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-04T22:44:53Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-04T23:18:12Z"}, "message": "Use lambdas in the freevars pass.", "tree": {"sha": "19db4712b973fffb1c830fbbfe613717892e31fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19db4712b973fffb1c830fbbfe613717892e31fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95680474e27064a5745e9477a04765247285fb87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95680474e27064a5745e9477a04765247285fb87", "html_url": "https://github.com/rust-lang/rust/commit/95680474e27064a5745e9477a04765247285fb87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95680474e27064a5745e9477a04765247285fb87/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae3312002a87d673ae97a9e75455060fcd111069", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae3312002a87d673ae97a9e75455060fcd111069", "html_url": "https://github.com/rust-lang/rust/commit/ae3312002a87d673ae97a9e75455060fcd111069"}], "stats": {"total": 114, "additions": 50, "deletions": 64}, "files": [{"sha": "2290ff1fa5e85d7f5847a647d30f483acd028a5e", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 50, "deletions": 64, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/95680474e27064a5745e9477a04765247285fb87/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95680474e27064a5745e9477a04765247285fb87/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=95680474e27064a5745e9477a04765247285fb87", "patch": "@@ -26,8 +26,8 @@ export def_lookup;\n // Throughout the compiler, variables are generally dealt with using the\n // node_ids of the reference sites and not the def_id of the definition\n // site. Thus we store a set are the definitions along with a vec of one\n-// referencing node_id per free variable. The set is useful for testing\n-// membership, the list of referencing sites is what you want for most\n+// \"canonical\" referencing node_id per free variable. The set is useful for\n+// testing membership, the list of referencing sites is what you want for most\n // other things.\n type freevar_set = hashset[ast::node_id];\n type freevar_info = {defs: freevar_set, refs: @ast::node_id[]};\n@@ -41,67 +41,61 @@ type freevar_map = hashmap[ast::node_id, freevar_info];\n fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n                     walker: &fn(&visit::vt[()]) ,\n                     initial_decls: ast::node_id[]) -> freevar_info {\n-    type env =\n-        @{mutable refs: ast::node_id[],\n-          decls: hashset[ast::node_id],\n-          def_map: resolve::def_map,\n-          sess: session::session};\n+    let decls = new_int_hash();\n+    for decl: ast::node_id  in initial_decls { set_add(decls, decl); }\n+    let refs = @mutable ~[];\n \n-    fn walk_fn(e: env, f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n-               i: &ast::fn_ident, nid: ast::node_id) {\n-        for a: ast::arg  in f.decl.inputs { e.decls.insert(a.id, ()); }\n-    }\n-    fn walk_expr(e: env, expr: &@ast::expr) {\n+    let walk_fn = lambda(f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n+                         i: &ast::fn_ident, nid: ast::node_id) {\n+        for a: ast::arg  in f.decl.inputs { set_add(decls, a.id); }\n+    };\n+    let walk_expr = lambda(expr: &@ast::expr) {\n         alt expr.node {\n           ast::expr_path(path) {\n-            if !e.def_map.contains_key(expr.id) {\n-                e.sess.span_fatal(expr.span,\n-                                  \"internal error in collect_freevars\");\n+            if !def_map.contains_key(expr.id) {\n+                sess.span_fatal(expr.span,\n+                                \"internal error in collect_freevars\");\n             }\n-            alt e.def_map.get(expr.id) {\n-              ast::def_arg(did) { e.refs += ~[expr.id]; }\n-              ast::def_local(did) { e.refs += ~[expr.id]; }\n-              ast::def_binding(did) { e.refs += ~[expr.id]; }\n+            alt def_map.get(expr.id) {\n+              ast::def_arg(did) { *refs += ~[expr.id]; }\n+              ast::def_local(did) { *refs += ~[expr.id]; }\n+              ast::def_binding(did) { *refs += ~[expr.id]; }\n               _ {/* no-op */ }\n             }\n           }\n           _ { }\n         }\n-    }\n-    fn walk_local(e: env, local: &@ast::local) {\n+    };\n+    let walk_local = lambda(local: &@ast::local) {\n         for each b: @ast::pat in ast::pat_bindings(local.node.pat) {\n-            set_add(e.decls, b.id);\n+            set_add(decls, b.id);\n         }\n-    }\n-    fn walk_pat(e: env, p: &@ast::pat) {\n-        alt p.node { ast::pat_bind(_) { set_add(e.decls, p.id); } _ { } }\n-    }\n-    let decls: hashset[ast::node_id] = new_int_hash();\n-    for decl: ast::node_id  in initial_decls { set_add(decls, decl); }\n+    };\n+    let walk_pat = lambda(p: &@ast::pat) {\n+        alt p.node { ast::pat_bind(_) { set_add(decls, p.id); } _ { } }\n+    };\n \n-    let e: env =\n-        @{mutable refs: ~[], decls: decls, def_map: def_map, sess: sess};\n     walker(visit::mk_simple_visitor\n-           (@{visit_local: bind walk_local(e, _),\n-              visit_pat: bind walk_pat(e, _),\n-              visit_expr: bind walk_expr(e, _),\n-              visit_fn: bind walk_fn(e, _, _, _, _, _)\n+           (@{visit_local: walk_local,\n+              visit_pat: walk_pat,\n+              visit_expr: walk_expr,\n+              visit_fn: walk_fn\n               with *visit::default_simple_visitor()}));\n \n     // Calculate (refs - decls). This is the set of captured upvars.\n     // We build a vec of the node ids of the uses and a set of the\n     // node ids of the definitions.\n-    let refs = ~[];\n+    let canonical_refs = ~[];\n     let defs = new_int_hash();\n-    for ref_id_: ast::node_id  in e.refs {\n+    for ref_id_: ast::node_id  in *refs {\n         let ref_id = ref_id_;\n         let def_id = ast::def_id_of_def(def_map.get(ref_id)).node;\n         if !decls.contains_key(def_id) && !defs.contains_key(def_id) {\n-            refs += ~[ref_id];\n+            canonical_refs += ~[ref_id];\n             set_add(defs, def_id);\n         }\n     }\n-    ret {defs: defs, refs: @refs};\n+    ret {defs: defs, refs: @canonical_refs};\n }\n \n // Build a map from every function and for-each body to a set of the\n@@ -111,46 +105,38 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n // one pass. This could be improved upon if it turns out to matter.\n fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n                      crate: &@ast::crate) -> freevar_map {\n-    type env =\n-        {freevars: freevar_map,\n-         def_map: resolve::def_map,\n-         sess: session::session};\n+    let freevars = new_int_hash();\n \n-    fn walk_fn(e: env, f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n-               i: &ast::fn_ident, nid: ast::node_id) {\n-        fn start_walk(f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n-                      i: &ast::fn_ident, nid: ast::node_id,\n-                      v: &visit::vt[()]) {\n+    let walk_fn = lambda(f: &ast::_fn, tps: &ast::ty_param[], sp: &span,\n+                         i: &ast::fn_ident, nid: ast::node_id) {\n+        let start_walk = lambda(v: &visit::vt[()]) {\n             v.visit_fn(f, tps, sp, i, nid, (), v);\n-        }\n-        let walker = bind start_walk(f, tps, sp, i, nid, _);\n-        let vars = collect_freevars(e.def_map, e.sess, walker, ~[]);\n-        e.freevars.insert(nid, vars);\n-    }\n-    fn walk_expr(e: env, expr: &@ast::expr) {\n+        };\n+        let vars = collect_freevars(def_map, sess, start_walk, ~[]);\n+        freevars.insert(nid, vars);\n+    };\n+    let walk_expr = lambda(expr: &@ast::expr) {\n         alt expr.node {\n           ast::expr_for_each(local, _, body) {\n-            fn start_walk(b: &ast::blk, v: &visit::vt[()]) {\n-                v.visit_block(b, (), v);\n-            }\n+            let start_walk = lambda(v: &visit::vt[()]) {\n+                v.visit_block(body, (), v);\n+            };\n             let bound = ast::pat_binding_ids(local.node.pat);\n             let vars =\n-                collect_freevars(e.def_map, e.sess, bind start_walk(body, _),\n-                                 bound);\n-            e.freevars.insert(body.node.id, vars);\n+                collect_freevars(def_map, sess, start_walk, bound);\n+            freevars.insert(body.node.id, vars);\n           }\n           _ { }\n         }\n-    }\n+    };\n \n-    let e: env = {freevars: new_int_hash(), def_map: def_map, sess: sess};\n     let visitor =\n-        visit::mk_simple_visitor(@{visit_fn: bind walk_fn(e, _, _, _, _, _),\n-                                   visit_expr: bind walk_expr(e, _)\n+        visit::mk_simple_visitor(@{visit_fn: walk_fn,\n+                                   visit_expr: walk_expr\n                                       with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visitor);\n \n-    ret e.freevars;\n+    ret freevars;\n }\n \n fn get_freevar_info(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_info {"}]}