{"sha": "f503f6c0b90e69425952ddc3ee3c6022be769ace", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MDNmNmMwYjkwZTY5NDI1OTUyZGRjM2VlM2M2MDIyYmU3NjlhY2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-02T23:36:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-02T23:36:50Z"}, "message": "auto merge of #13257 : alexcrichton/rust/index-uint, r=pnkfelix\n\nThe details are outlined in the first commit. \r\n\r\nCloses #10453", "tree": {"sha": "07ce928ee77fea3d2b0a1d0bbfe021038bd0d708", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07ce928ee77fea3d2b0a1d0bbfe021038bd0d708"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f503f6c0b90e69425952ddc3ee3c6022be769ace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f503f6c0b90e69425952ddc3ee3c6022be769ace", "html_url": "https://github.com/rust-lang/rust/commit/f503f6c0b90e69425952ddc3ee3c6022be769ace", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f503f6c0b90e69425952ddc3ee3c6022be769ace/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3786b552a6ffd2219d8e42df6f8db6cc386cce56", "url": "https://api.github.com/repos/rust-lang/rust/commits/3786b552a6ffd2219d8e42df6f8db6cc386cce56", "html_url": "https://github.com/rust-lang/rust/commit/3786b552a6ffd2219d8e42df6f8db6cc386cce56"}, {"sha": "9a259f4303cd6550a38ccd12b07ae14c1e21a263", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a259f4303cd6550a38ccd12b07ae14c1e21a263", "html_url": "https://github.com/rust-lang/rust/commit/9a259f4303cd6550a38ccd12b07ae14c1e21a263"}], "stats": {"total": 284, "additions": 165, "deletions": 119}, "files": [{"sha": "7a51fca6cd5e8c2e869d76482a1d6e665386f027", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -1600,12 +1600,12 @@ mod test_map {\n \n     #[deriving(Hash, Eq, TotalEq)]\n     struct Dropable {\n-        k: int\n+        k: uint\n     }\n \n \n     impl Dropable {\n-        fn new(k: int) -> Dropable {\n+        fn new(k: uint) -> Dropable {\n             local_data::get_mut(drop_vector,\n                 |v| { v.unwrap().as_mut_slice()[k] += 1; });\n \n@@ -1628,24 +1628,24 @@ mod test_map {\n             let mut m = HashMap::new();\n \n             local_data::get(drop_vector, |v| {\n-                for i in range(0, 200) {\n+                for i in range(0u, 200) {\n                     assert_eq!(v.unwrap().as_slice()[i], 0);\n                 }\n             });\n \n-            for i in range(0, 100) {\n+            for i in range(0u, 100) {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 m.insert(d1, d2);\n             }\n \n             local_data::get(drop_vector, |v| {\n-                for i in range(0, 200) {\n+                for i in range(0u, 200) {\n                     assert_eq!(v.unwrap().as_slice()[i], 1);\n                 }\n             });\n \n-            for i in range(0, 50) {\n+            for i in range(0u, 50) {\n                 let k = Dropable::new(i);\n                 let v = m.pop(&k);\n \n@@ -1658,20 +1658,20 @@ mod test_map {\n             }\n \n             local_data::get(drop_vector, |v| {\n-                for i in range(0, 50) {\n+                for i in range(0u, 50) {\n                     assert_eq!(v.unwrap().as_slice()[i], 0);\n                     assert_eq!(v.unwrap().as_slice()[i+100], 0);\n                 }\n \n-                for i in range(50, 100) {\n+                for i in range(50u, 100) {\n                     assert_eq!(v.unwrap().as_slice()[i], 1);\n                     assert_eq!(v.unwrap().as_slice()[i+100], 1);\n                 }\n             });\n         }\n \n         local_data::get(drop_vector, |v| {\n-            for i in range(0, 200) {\n+            for i in range(0u, 200) {\n                 assert_eq!(v.unwrap().as_slice()[i], 0);\n             }\n         });"}, {"sha": "7979075aa025c174c7cfeff5a701aecbe214c902", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -296,7 +296,7 @@ mod imp {\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        set.fds_bits[fd / 32] |= 1 << (fd % 32);\n+        set.fds_bits[(fd / 32) as uint] |= 1 << (fd % 32);\n     }\n \n     extern {\n@@ -323,7 +323,7 @@ mod imp {\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        set.fds_bits[fd / 64] |= (1 << (fd % 64)) as u64;\n+        set.fds_bits[(fd / 64) as uint] |= (1 << (fd % 64)) as u64;\n     }\n \n     extern {"}, {"sha": "3e420e4544887bdf2e467290021627932c45f3e0", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -78,7 +78,7 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n             }\n         } else {\n             let remove = {\n-                match &chans[idx - 1] {\n+                match &chans[idx as uint - 1] {\n                     &(ref c, oneshot) => !c.try_send(()) || oneshot\n                 }\n             };"}, {"sha": "1d9da40f18b6efc6418a2453e0b581cb9e663f69", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -103,7 +103,7 @@ impl IsaacRng {\n         if use_rsl {\n             macro_rules! memloop (\n                 ($arr:expr) => {{\n-                    for i in range_step(0u32, RAND_SIZE, 8) {\n+                    for i in range_step(0, RAND_SIZE as uint, 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n                         c+=$arr[i+2]; d+=$arr[i+3];\n                         e+=$arr[i+4]; f+=$arr[i+5];\n@@ -120,7 +120,7 @@ impl IsaacRng {\n             memloop!(self.rsl);\n             memloop!(self.mem);\n         } else {\n-            for i in range_step(0u32, RAND_SIZE, 8) {\n+            for i in range_step(0, RAND_SIZE as uint, 8) {\n                 mix!();\n                 self.mem[i  ]=a; self.mem[i+1]=b;\n                 self.mem[i+2]=c; self.mem[i+3]=d;\n@@ -143,7 +143,7 @@ impl IsaacRng {\n         static MIDPOINT: uint = RAND_SIZE as uint / 2;\n \n         macro_rules! ind (($x:expr) => {\n-            self.mem[($x >> 2) & (RAND_SIZE - 1)]\n+            self.mem[(($x >> 2) & (RAND_SIZE - 1)) as uint]\n         });\n         macro_rules! rngstep(\n             ($j:expr, $shift:expr) => {{\n@@ -188,7 +188,7 @@ impl Rng for IsaacRng {\n             self.isaac();\n         }\n         self.cnt -= 1;\n-        self.rsl[self.cnt]\n+        self.rsl[self.cnt as uint]\n     }\n }\n "}, {"sha": "176ed409dd49f6bfb8082600277f542c3c2b7f81", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -2602,6 +2602,13 @@ pub fn type_is_integral(ty: t) -> bool {\n     }\n }\n \n+pub fn type_is_uint(ty: t) -> bool {\n+    match get(ty).sty {\n+      ty_infer(IntVar(_)) | ty_uint(ast::TyU) => true,\n+      _ => false\n+    }\n+}\n+\n pub fn type_is_char(ty: t) -> bool {\n     match get(ty).sty {\n         ty_char => true,\n@@ -4358,7 +4365,7 @@ pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n     /*bot*/     [t, t, t, t,     t,   t,  t,   t],\n     /*raw ptr*/ [f, f, f, f,     t,   t,  f,   f]];\n \n-    return tbl[tycat(cx, ty)][opcat(op)];\n+    return tbl[tycat(cx, ty) as uint ][opcat(op) as uint];\n }\n \n pub fn ty_params_to_tys(tcx: &ctxt, generics: &ast::Generics) -> Vec<t> {"}, {"sha": "4cf3cc51cc1b64116bb6aafdcb1179f7e421cc5c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -3151,7 +3151,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                           lvalue_pref, |base_t, _| ty::index(base_t));\n               match field_ty {\n                   Some(mt) => {\n-                      require_integral(fcx, idx.span, idx_t);\n+                      check_expr_has_type(fcx, idx, ty::mk_uint());\n                       fcx.write_ty(id, mt.ty);\n                       fcx.write_autoderef_adjustment(base.id, autoderefs);\n                   }\n@@ -3195,6 +3195,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     unifier();\n }\n \n+pub fn require_uint(fcx: &FnCtxt, sp: Span, t: ty::t) {\n+    if !type_is_uint(fcx, sp, t) {\n+        fcx.type_error_message(sp, |actual| {\n+            format!(\"mismatched types: expected `uint` type but found `{}`\",\n+                 actual)\n+        }, t, None);\n+    }\n+}\n+\n pub fn require_integral(fcx: &FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n@@ -3854,6 +3863,11 @@ pub fn type_is_integral(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     return ty::type_is_integral(typ_s);\n }\n \n+pub fn type_is_uint(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n+    let typ_s = structurally_resolved_type(fcx, sp, typ);\n+    return ty::type_is_uint(typ_s);\n+}\n+\n pub fn type_is_scalar(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_scalar(typ_s);"}, {"sha": "a6d1e1a6efdba84e279154ad50c72fe99eb3790e", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -791,7 +791,7 @@ mod test {\n                         Ok(10) => {} e => fail!(\"{:?}\", e),\n                     }\n                     for i in range(0, 10u8) {\n-                        assert_eq!(buf[i], i + 1);\n+                        assert_eq!(buf[i as uint], i + 1);\n                     }\n                 }\n                 Err(e) => fail!(\"{:?}\", e)\n@@ -827,7 +827,7 @@ mod test {\n                         Ok(10) => {} e => fail!(\"{:?}\", e),\n                     }\n                     for i in range(0, 10u8) {\n-                        assert_eq!(buf[i], i + 1);\n+                        assert_eq!(buf[i as uint], i + 1);\n                     }\n                 }\n                 Err(e) => fail!(\"{:?}\", e)\n@@ -859,7 +859,7 @@ mod test {\n                         e => fail!(\"{:?}\", e),\n                     }\n                     for i in range(0, 10u8) {\n-                        assert_eq!(buf[i], i + 1);\n+                        assert_eq!(buf[i as uint], i + 1);\n                     }\n                 }\n                 Err(e) => fail!(\"{:?}\", e)\n@@ -891,7 +891,7 @@ mod test {\n                         e => fail!(\"{:?}\", e),\n                     }\n                     for i in range(0, 10u8) {\n-                        assert_eq!(buf[i], i + 1);\n+                        assert_eq!(buf[i as uint], i + 1);\n                     }\n                 }\n                 Err(e) => fail!(\"{:?}\", e)"}, {"sha": "6aad2f5abbf58da0ecfd47263cd2db4ee774565a", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -99,10 +99,10 @@ impl<'a> ToBase64 for &'a [u8] {\n                     (self[i + 2] as u32);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n-            v.push(bytes[(n >> 18) & 63]);\n-            v.push(bytes[(n >> 12) & 63]);\n-            v.push(bytes[(n >> 6 ) & 63]);\n-            v.push(bytes[n & 63]);\n+            v.push(bytes[((n >> 18) & 63) as uint]);\n+            v.push(bytes[((n >> 12) & 63) as uint]);\n+            v.push(bytes[((n >> 6 ) & 63) as uint]);\n+            v.push(bytes[(n & 63) as uint]);\n \n             cur_length += 4;\n             i += 3;\n@@ -125,8 +125,8 @@ impl<'a> ToBase64 for &'a [u8] {\n             0 => (),\n             1 => {\n                 let n = (self[i] as u32) << 16;\n-                v.push(bytes[(n >> 18) & 63]);\n-                v.push(bytes[(n >> 12) & 63]);\n+                v.push(bytes[((n >> 18) & 63) as uint]);\n+                v.push(bytes[((n >> 12) & 63) as uint]);\n                 if config.pad {\n                     v.push('=' as u8);\n                     v.push('=' as u8);\n@@ -135,9 +135,9 @@ impl<'a> ToBase64 for &'a [u8] {\n             2 => {\n                 let n = (self[i] as u32) << 16 |\n                     (self[i + 1u] as u32) << 8;\n-                v.push(bytes[(n >> 18) & 63]);\n-                v.push(bytes[(n >> 12) & 63]);\n-                v.push(bytes[(n >> 6 ) & 63]);\n+                v.push(bytes[((n >> 18) & 63) as uint]);\n+                v.push(bytes[((n >> 12) & 63) as uint]);\n+                v.push(bytes[((n >> 6 ) & 63) as uint]);\n                 if config.pad {\n                     v.push('=' as u8);\n                 }"}, {"sha": "e6658f3b3670de6ab9c7a1e5059d68c4812f464b", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -41,8 +41,8 @@ impl<'a> ToHex for &'a [u8] {\n     fn to_hex(&self) -> ~str {\n         let mut v = slice::with_capacity(self.len() * 2);\n         for &byte in self.iter() {\n-            v.push(CHARS[byte >> 4]);\n-            v.push(CHARS[byte & 0xf]);\n+            v.push(CHARS[(byte >> 4) as uint]);\n+            v.push(CHARS[(byte & 0xf) as uint]);\n         }\n \n         unsafe {"}, {"sha": "a52658da209c6fdb82700be2dee6121099fa1b85", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -43,19 +43,19 @@ impl Ascii {\n     /// Convert to lowercase.\n     #[inline]\n     pub fn to_lower(self) -> Ascii {\n-        Ascii{chr: ASCII_LOWER_MAP[self.chr]}\n+        Ascii{chr: ASCII_LOWER_MAP[self.chr as uint]}\n     }\n \n     /// Convert to uppercase.\n     #[inline]\n     pub fn to_upper(self) -> Ascii {\n-        Ascii{chr: ASCII_UPPER_MAP[self.chr]}\n+        Ascii{chr: ASCII_UPPER_MAP[self.chr as uint]}\n     }\n \n     /// Compares two ascii characters of equality, ignoring case.\n     #[inline]\n     pub fn eq_ignore_case(self, other: Ascii) -> bool {\n-        ASCII_LOWER_MAP[self.chr] == ASCII_LOWER_MAP[other.chr]\n+        ASCII_LOWER_MAP[self.chr as uint] == ASCII_LOWER_MAP[other.chr as uint]\n     }\n \n     // the following methods are like ctype, and the implementation is inspired by musl\n@@ -370,8 +370,12 @@ impl<'a> StrAsciiExt for &'a str {\n \n     #[inline]\n     fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n-        self.len() == other.len() && self.as_bytes().iter().zip(other.as_bytes().iter()).all(\n-            |(byte_self, byte_other)| ASCII_LOWER_MAP[*byte_self] == ASCII_LOWER_MAP[*byte_other])\n+        self.len() == other.len() &&\n+            self.as_bytes().iter().zip(other.as_bytes().iter()).all(\n+            |(byte_self, byte_other)| {\n+                ASCII_LOWER_MAP[*byte_self as uint] ==\n+                    ASCII_LOWER_MAP[*byte_other as uint]\n+            })\n     }\n }\n \n@@ -392,15 +396,15 @@ unsafe fn str_map_bytes(string: ~str, map: &'static [u8]) -> ~str {\n     let mut bytes = string.into_bytes();\n \n     for b in bytes.mut_iter() {\n-        *b = map[*b];\n+        *b = map[*b as uint];\n     }\n \n     str::raw::from_utf8_owned(bytes)\n }\n \n #[inline]\n unsafe fn str_copy_map_bytes(string: &str, map: &'static [u8]) -> ~str {\n-    let bytes = string.bytes().map(|b| map[b]).collect::<~[_]>();\n+    let bytes = string.bytes().map(|b| map[b as uint]).collect::<~[_]>();\n \n     str::raw::from_utf8_owned(bytes)\n }"}, {"sha": "d01c4913b32afdc623377ade8cafa00a424e4823", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -254,7 +254,7 @@ pub use comm::select::{Select, Handle};\n macro_rules! test (\n     { fn $name:ident() $b:block $(#[$a:meta])*} => (\n         mod $name {\n-            #[allow(unused_imports)];\n+            #![allow(unused_imports)]\n \n             use native;\n             use comm::*;"}, {"sha": "6217ff0f58c7e29b263454acc662555999b45f18", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -432,7 +432,7 @@ mod tests {\n             assert!(f == i && f == v);\n \n             buf.push(t as u8);\n-            state_inc.write_u8(t);\n+            state_inc.write_u8(t as u8);\n \n             t += 1;\n         }"}, {"sha": "14b9b5c1e061b71417edde3aa782ca6c8e967c60", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -21,7 +21,7 @@ use sync::atomics::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n macro_rules! iotest (\n     { fn $name:ident() $b:block $(#[$a:meta])* } => (\n         mod $name {\n-            #[allow(unused_imports)];\n+            #![allow(unused_imports)]\n \n             use super::super::*;\n             use super::*;"}, {"sha": "761bd072bf8d24427a82a7a7125c960e4512e183", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -1655,7 +1655,7 @@ mod tests {\n     macro_rules! test_next_power_of_two(\n         ($test_name:ident, $T:ident) => (\n             fn $test_name() {\n-                #[test];\n+                #![test]\n                 assert_eq!(next_power_of_two::<$T>(0), 0);\n                 let mut next_power = 1;\n                 for i in range::<$T>(1, 40) {\n@@ -1675,7 +1675,7 @@ mod tests {\n     macro_rules! test_checked_next_power_of_two(\n         ($test_name:ident, $T:ident) => (\n             fn $test_name() {\n-                #[test];\n+                #![test]\n                 assert_eq!(checked_next_power_of_two::<$T>(0), None);\n                 let mut next_power = 1;\n                 for i in range::<$T>(1, 40) {"}, {"sha": "b15b5872fc281d7f3dfd88f35858c4753750b6eb", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -411,23 +411,23 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || buf[i] == '-' as u8\n-                    || buf[i] == '+' as u8 {\n+                    || buf[i as uint] == '-' as u8\n+                    || buf[i as uint] == '+' as u8 {\n                         buf.insert((i + 1) as uint, value2ascii(1));\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if buf[i] == '.' as u8 { i -= 1; continue; }\n+                    if buf[i as uint] == '.' as u8 { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i]);\n+                    let current_digit = ascii2value(buf[i as uint]);\n                     if current_digit < (radix - 1) {\n-                        buf[i] = value2ascii(current_digit+1);\n+                        buf[i as uint] = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        buf[i] = value2ascii(0);\n+                        buf[i as uint] = value2ascii(0);\n                         i -= 1;\n                     }\n                 }"}, {"sha": "f15e3e61ca1f850e809c063677eb21949eaef0fd", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -2922,8 +2922,6 @@ mod tests {\n \n     fn square(n: uint) -> uint { n * n }\n \n-    fn square_ref(n: &uint) -> uint { square(*n) }\n-\n     fn is_odd(n: &uint) -> bool { *n % 2u == 1u }\n \n     #[test]\n@@ -4441,7 +4439,7 @@ mod bench {\n             unsafe {\n                 v.set_len(1024);\n             }\n-            for i in range(0, 1024) {\n+            for i in range(0u, 1024) {\n                 v[i] = 0;\n             }\n         });"}, {"sha": "1d80af70b97560c674ab78af99de0142ad4d3501", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -1053,7 +1053,7 @@ static UTF8_CHAR_WIDTH: [u8, ..256] = [\n /// Given a first byte, determine how many bytes are in this UTF-8 character\n #[inline]\n pub fn utf8_char_width(b: u8) -> uint {\n-    return UTF8_CHAR_WIDTH[b] as uint;\n+    return UTF8_CHAR_WIDTH[b as uint] as uint;\n }\n \n /// Struct that contains a `char` and the index of the first byte of\n@@ -2636,7 +2636,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         // Multibyte case is a fn to allow char_range_at to inline cleanly\n         fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n             let mut val = s[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val] as uint;\n+            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n@@ -2665,7 +2665,7 @@ impl<'a> StrSlice<'a> for &'a str {\n             }\n \n             let mut val = s[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val] as uint;\n+            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);"}, {"sha": "b3e488a464d9c3058c325d1e5d494aff7975675e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -780,10 +780,10 @@ impl<'a> Parser<'a> {\n                       -> R {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n-            self.buffer[self.buffer_end] = self.reader.next_token();\n+            self.buffer[self.buffer_end as uint] = self.reader.next_token();\n             self.buffer_end = (self.buffer_end + 1) & 3;\n         }\n-        f(&self.buffer[(self.buffer_start + dist - 1) & 3].tok)\n+        f(&self.buffer[((self.buffer_start + dist - 1) & 3) as uint].tok)\n     }\n     pub fn fatal(&mut self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(self.span, m)"}, {"sha": "408d452adba2dd6cd4c823eed2b81ea294ed5a0b", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -293,12 +293,12 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('A' as u8);\n-                        vars.sta[idx] = stack.pop().unwrap();\n+                        vars.sta[idx as uint] = stack.pop().unwrap();\n                     } else { return Err(~\"stack is empty\") }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('a' as u8);\n-                        vars.dyn[idx] = stack.pop().unwrap();\n+                        vars.dyn[idx as uint] = stack.pop().unwrap();\n                     } else { return Err(~\"stack is empty\") }\n                 } else {\n                     return Err(~\"bad variable name in %P\");\n@@ -307,10 +307,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             GetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     let idx = (cur as u8) - ('A' as u8);\n-                    stack.push(vars.sta[idx].clone());\n+                    stack.push(vars.sta[idx as uint].clone());\n                 } else if cur >= 'a' && cur <= 'z' {\n                     let idx = (cur as u8) - ('a' as u8);\n-                    stack.push(vars.dyn[idx].clone());\n+                    stack.push(vars.dyn[idx as uint].clone());\n                 } else {\n                     return Err(~\"bad variable name in %g\");\n                 }\n@@ -563,7 +563,6 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,~str> {\n mod test {\n     use super::{expand,String,Variables,Number};\n     use std::result::Ok;\n-    use std::vec;\n \n     #[test]\n     fn test_basic_setabf() {"}, {"sha": "6d87d91ffc02c08473be0b51da888d61684fdc21", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -223,7 +223,7 @@ pub fn parse(file: &mut io::Reader,\n             if b < 0 {\n                 return Err(~\"error: expected more bools but hit EOF\");\n             } else if b == 1 {\n-                bools_map.insert(bnames[i].to_owned(), true);\n+                bools_map.insert(bnames[i as uint].to_owned(), true);\n             }\n         }\n     }\n@@ -237,7 +237,7 @@ pub fn parse(file: &mut io::Reader,\n         for i in range(0, numbers_count) {\n             let n = try!(file.read_le_u16());\n             if n != 0xFFFF {\n-                numbers_map.insert(nnames[i].to_owned(), n);\n+                numbers_map.insert(nnames[i as uint].to_owned(), n);\n             }\n         }\n     }"}, {"sha": "7e41fdea778de997085fc56ec9975f556bddd3a7", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -58,8 +58,9 @@ impl Noise2DContext {\n     }\n \n     fn get_gradient(&self, x: i32, y: i32) -> Vec2 {\n-        let idx = self.permutations[x & 255] + self.permutations[y & 255];\n-        self.rgradients[idx & 255]\n+        let idx = self.permutations[(x & 255) as uint] +\n+                    self.permutations[(y & 255) as uint];\n+        self.rgradients[(idx & 255) as uint]\n     }\n \n     fn get_gradients(&self, x: f32, y: f32) -> ([Vec2, ..4], [Vec2, ..4]) {\n@@ -103,16 +104,16 @@ fn main() {\n     let n2d = Noise2DContext::new();\n \n     for _ in range(0, 100) {\n-        for y in range(0, 256) {\n-            for x in range(0, 256) {\n+        for y in range(0u, 256) {\n+            for x in range(0u, 256) {\n                 let v = n2d.get(x as f32 * 0.1, y as f32 * 0.1);\n                 pixels[y*256+x] = v * 0.5 + 0.5;\n             }\n         }\n     }\n \n-    for y in range(0, 256) {\n-        for x in range(0, 256) {\n+    for y in range(0u, 256) {\n+        for x in range(0u, 256) {\n             let idx = (pixels[y*256+x] / 0.2) as uint;\n             print!(\"{:c}\", symbols[idx]);\n         }"}, {"sha": "e650367c6f5697c9ea09fda67527255822cbbe1a", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -30,7 +30,7 @@ fn fannkuch_redux(n: i32) -> i32 {\n     let mut r = n;\n     loop {\n         while r != 1 {\n-            count[r - 1] = r;\n+            count[r as uint - 1] = r;\n             r -= 1;\n         }\n \n@@ -71,13 +71,13 @@ fn fannkuch_redux(n: i32) -> i32 {\n             let mut i: i32 = 0;\n             while i < r {\n                 let j = i + 1;\n-                perm1[i] = perm1[j];\n+                perm1[i as uint] = perm1[j as uint];\n                 i = j;\n             }\n-            perm1[r] = perm0;\n+            perm1[r as uint] = perm0;\n \n-            count[r] -= 1;\n-            if count[r] > 0 {\n+            count[r as uint] -= 1;\n+            if count[r as uint] > 0 {\n                 break;\n             }\n             r += 1;"}, {"sha": "7ceaaa7ad22e298cb543181409149f1c25cd4231", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -201,7 +201,7 @@ fn pack_symbol(c: u8) -> u8 {\n }\n \n fn unpack_symbol(c: u8) -> u8 {\n-    TABLE[c]\n+    TABLE[c as uint]\n }\n \n fn generate_frequencies(frequencies: &mut Table,"}, {"sha": "45ce177662095861c14db115c99b0a4650e9ebc8", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -255,9 +255,9 @@ fn search(\n     // for every unused piece\n     for id in range(0, 10).filter(|id| board & (1 << (id + 50)) == 0) {\n         // for each mask that fits on the board\n-        for &m in masks[id].get(i as uint)\n-                           .iter()\n-                           .filter(|&m| board & *m == 0) {\n+        for &m in masks[id as uint].get(i as uint)\n+                                   .iter()\n+                                   .filter(|&m| board & *m == 0) {\n             // This check is too costy.\n             //if is_board_unfeasible(board | m, masks) {continue;}\n             if !search(masks, board | m, i + 1, Cons(m, &cur), data) {"}, {"sha": "a96e9e9f81a0b62687b695f4bbaa013276343a73", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -29,8 +29,8 @@ fn make_complements() -> [u8, ..256] {\n     }\n     let lower = 'A' as u8 - 'a' as u8;\n     for &(from, to) in transforms.iter() {\n-        complements[from as u8] = to as u8;\n-        complements[from as u8 - lower] = to as u8;\n+        complements[from as uint] = to as u8;\n+        complements[(from as u8 - lower) as uint] = to as u8;\n     }\n     complements\n }\n@@ -70,11 +70,11 @@ fn main() {\n         loop {\n             match (it.next(), it.next_back()) {\n                 (Some(front), Some(back)) => {\n-                    let tmp = complements[*front];\n-                    *front = complements[*back];\n+                    let tmp = complements[*front as uint];\n+                    *front = complements[*back as uint];\n                     *back = tmp;\n                 }\n-                (Some(last), None) => *last = complements[*last], // last element\n+                (Some(last), None) => *last = complements[*last as uint], // last element\n                 _ => break // vector exhausted.\n             }\n         }"}, {"sha": "9ac4bd2566e8be73dc61b5f964bd3ce169b3dbff", "filename": "src/test/compile-fail/indexing-requires-a-uint.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure that indexing an array is only valid with a `uint`, not any other\n+// integral type.\n+\n+fn main() {\n+    fn bar<T>(_: T) {}\n+    [0][0u8]; //~ ERROR: mismatched types\n+\n+    [0][0]; // should infer to be a uint\n+\n+    let i = 0;      // i is an IntVar\n+    [0][i];         // i should be locked to uint\n+    bar::<int>(i);  // i should not be re-coerced back to an int\n+    //~^ ERROR: mismatched types\n+}\n+"}, {"sha": "feda4be87ac87b6097f4ccfd6774e9a014176e71", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let v: Vec<int> = vec!(0, 1, 2, 3, 4, 5);\n+    let s: ~str = ~\"abcdef\";\n+    assert_eq!(v.as_slice()[3u], 3);\n+    assert_eq!(v.as_slice()[3u8], 3); //~ ERROR: mismatched types\n+    assert_eq!(v.as_slice()[3i8], 3); //~ ERROR: mismatched types\n+    assert_eq!(v.as_slice()[3u32], 3); //~ ERROR: mismatched types\n+    assert_eq!(v.as_slice()[3i32], 3); //~ ERROR: mismatched types\n+    println!(\"{}\", v.as_slice()[3u8]); //~ ERROR: mismatched types\n+    assert_eq!(s[3u], 'd' as u8);\n+    assert_eq!(s[3u8], 'd' as u8); //~ ERROR: mismatched types\n+    assert_eq!(s[3i8], 'd' as u8); //~ ERROR: mismatched types\n+    assert_eq!(s[3u32], 'd' as u8); //~ ERROR: mismatched types\n+    assert_eq!(s[3i32], 'd' as u8); //~ ERROR: mismatched types\n+    println!(\"{}\", s[3u8]); //~ ERROR: mismatched types\n+}"}, {"sha": "2a3fbecad9dcb2184c587bbe549ed45aa2b6ad16", "filename": "src/test/debug-info/lexical-scopes-in-block-expression.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fdebug-info%2Flexical-scopes-in-block-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Fdebug-info%2Flexical-scopes-in-block-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scopes-in-block-expression.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -211,8 +211,8 @@\n // check:$57 = 10\n // debugger:continue\n \n-#[allow(unused_variable)];\n-#[allow(dead_assignment)];\n+#![allow(unused_variable)]\n+#![allow(dead_assignment)]\n \n static mut MUT_INT: int = 0;\n \n@@ -366,7 +366,7 @@ fn main() {\n         zzz();\n         sentinel();\n \n-        val\n+        val as uint\n     }];\n \n     zzz();"}, {"sha": "dddec5a56249b68d3d42dea178d1b464329a5265", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -51,7 +51,7 @@ pub fn main() {\n     // Now try it with a type that *needs* to be borrowed\n     let z = [0,1,2,3];\n     // Call a method\n-    z.iterate(|y| { assert!(z[*y] == *y); true });\n+    z.iterate(|y| { assert!(z[*y as uint] == *y); true });\n     // Call a parameterized function\n     assert_eq!(length::<int, &[int]>(z), z.len());\n }"}, {"sha": "b3885691093c600b651ea25b5207f1dcb5362261", "filename": "src/test/run-pass/integral-indexing.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3786b552a6ffd2219d8e42df6f8db6cc386cce56/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3786b552a6ffd2219d8e42df6f8db6cc386cce56/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs?ref=3786b552a6ffd2219d8e42df6f8db6cc386cce56", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// This is a testcase for issue #94.\n-pub fn main() {\n-    let v: Vec<int> = vec!(0, 1, 2, 3, 4, 5);\n-    let s: ~str = ~\"abcdef\";\n-    assert_eq!(v.as_slice()[3u], 3);\n-    assert_eq!(v.as_slice()[3u8], 3);\n-    assert_eq!(v.as_slice()[3i8], 3);\n-    assert_eq!(v.as_slice()[3u32], 3);\n-    assert_eq!(v.as_slice()[3i32], 3);\n-    println!(\"{}\", v.as_slice()[3u8]);\n-    assert_eq!(s[3u], 'd' as u8);\n-    assert_eq!(s[3u8], 'd' as u8);\n-    assert_eq!(s[3i8], 'd' as u8);\n-    assert_eq!(s[3u32], 'd' as u8);\n-    assert_eq!(s[3i32], 'd' as u8);\n-    println!(\"{}\", s[3u8]);\n-}"}, {"sha": "c7763617269e5369b4efa7fd55f7962ffc87e79a", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f503f6c0b90e69425952ddc3ee3c6022be769ace/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=f503f6c0b90e69425952ddc3ee3c6022be769ace", "patch": "@@ -44,7 +44,7 @@ pub fn main() {\n         for ab in a.bytes() {\n             println!(\"{}\", i);\n             println!(\"{}\", ab);\n-            let bb: u8 = b[i];\n+            let bb: u8 = b[i as uint];\n             println!(\"{}\", bb);\n             assert_eq!(ab, bb);\n             i += 1;"}]}