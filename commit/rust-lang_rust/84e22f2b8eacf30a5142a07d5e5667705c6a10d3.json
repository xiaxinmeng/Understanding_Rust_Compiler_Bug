{"sha": "84e22f2b8eacf30a5142a07d5e5667705c6a10d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0ZTIyZjJiOGVhY2YzMGE1MTQyYTA3ZDVlNTY2NzcwNWM2YTEwZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-30T05:30:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-30T05:30:36Z"}, "message": "auto merge of #6108 : gifnksm/rust/bigint-shift-bug, r=brson\n\n`std::bigint` contains the following code.\r\n```rust\r\nborrow = *elem << (uint::bits - n_bits);\r\n```\r\nThe code above contains a bug that the value of the right operand of the shift operator exceeds the size of the left operand,\r\nbecause sizeof(*elem) == 32, and 0 <= n_bits < 32 in 64bit architecture.\r\n\r\nIf `--opt-level` option is not given to rustc, the code above runs as if the right operand is `(uint::bits - n_bits) % 32`,\r\nbut if --opt-level is given, `borrow` is always zero.\r\n\r\nI wonder why this bug is not catched in the libstd's testsuite (I try the `rustc --test --opt-level=2 bigint.rs` before fixing the bug,\r\nbut the unittest passes normally.)\r\n\r\nThis pull request also removes the implicit vector copies in `bigint.rs`.", "tree": {"sha": "cf184f6430454e771338c5c0ff3c66099ef62114", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf184f6430454e771338c5c0ff3c66099ef62114"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84e22f2b8eacf30a5142a07d5e5667705c6a10d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84e22f2b8eacf30a5142a07d5e5667705c6a10d3", "html_url": "https://github.com/rust-lang/rust/commit/84e22f2b8eacf30a5142a07d5e5667705c6a10d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84e22f2b8eacf30a5142a07d5e5667705c6a10d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48f50ac80063a6ebb59b1936b1e6020fd7a3251d", "url": "https://api.github.com/repos/rust-lang/rust/commits/48f50ac80063a6ebb59b1936b1e6020fd7a3251d", "html_url": "https://github.com/rust-lang/rust/commit/48f50ac80063a6ebb59b1936b1e6020fd7a3251d"}, {"sha": "ffa31d235badfb5544ddb2de151ccfc66c8a20e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffa31d235badfb5544ddb2de151ccfc66c8a20e6", "html_url": "https://github.com/rust-lang/rust/commit/ffa31d235badfb5544ddb2de151ccfc66c8a20e6"}], "stats": {"total": 60, "additions": 39, "deletions": 21}, "files": [{"sha": "e010340b94d8e200b905b1635eb0a2e1eb038947", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/84e22f2b8eacf30a5142a07d5e5667705c6a10d3/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84e22f2b8eacf30a5142a07d5e5667705c6a10d3/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=84e22f2b8eacf30a5142a07d5e5667705c6a10d3", "patch": "@@ -16,6 +16,9 @@ A BigUint is represented as an array of BigDigits.\n A BigInt is a combination of BigUint and Sign.\n */\n \n+#[deny(vecs_implicitly_copyable)];\n+#[deny(deprecated_mutable_fields)];\n+\n use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use core::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix};\n use core::*;\n@@ -355,16 +358,24 @@ impl Integer for BigUint {\n                 let mut (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n                 let mut prod = b * d0;\n                 while prod > m {\n-                    d0   -= d_unit;\n-                    prod -= b_unit;\n+                    // FIXME(#6050): overloaded operators force moves with generic types\n+                    // d0 -= d_unit\n+                    d0   = d0 - d_unit;\n+                    // FIXME(#6050): overloaded operators force moves with generic types\n+                    // prod = prod - b_unit;\n+                    prod = prod - b_unit\n                 }\n                 if d0.is_zero() {\n                     n = 2;\n                     loop;\n                 }\n                 n = 1;\n-                d += d0;\n-                m -= prod;\n+                // FIXME(#6102): Assignment operator for BigInt causes ICE\n+                // d += d0;\n+                d = d + d0;\n+                // FIXME(#6102): Assignment operator for BigInt causes ICE\n+                // m -= prod;\n+                m = m - prod;\n             }\n             return (d, m);\n         }\n@@ -411,7 +422,7 @@ impl Integer for BigUint {\n     #[inline(always)]\n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n-        let mut m = *self, n = *other;\n+        let mut m = copy *self, n = copy *other;\n         while !m.is_zero() {\n             let temp = m;\n             m = n % temp;\n@@ -547,14 +558,18 @@ impl BigUint {\n         loop {\n             let start = uint::max(end, unit_len) - unit_len;\n             match uint::parse_bytes(vec::slice(buf, start, end), radix) {\n-                Some(d) => n += BigUint::from_uint(d) * power,\n+                // FIXME(#6102): Assignment operator for BigInt causes ICE\n+                // Some(d) => n += BigUint::from_uint(d) * power,\n+                Some(d) => n = n + BigUint::from_uint(d) * power,\n                 None    => return None\n             }\n             if end <= unit_len {\n                 return Some(n);\n             }\n             end -= unit_len;\n-            power *= base_num;\n+            // FIXME(#6050): overloaded operators force moves with generic types\n+            // power *= base_num;\n+            power = power * base_num;\n         }\n     }\n \n@@ -569,15 +584,15 @@ impl BigUint {\n     }\n \n     #[inline(always)]\n-    priv fn shl_unit(self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 || self.is_zero() { return self; }\n+    priv fn shl_unit(&self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 || self.is_zero() { return copy *self; }\n \n         return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n     }\n \n     #[inline(always)]\n-    priv fn shl_bits(self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.is_zero() { return self; }\n+    priv fn shl_bits(&self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.is_zero() { return copy *self; }\n \n         let mut carry = 0;\n         let shifted = do vec::map(self.data) |elem| {\n@@ -592,23 +607,23 @@ impl BigUint {\n     }\n \n     #[inline(always)]\n-    priv fn shr_unit(self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 { return self; }\n+    priv fn shr_unit(&self, n_unit: uint) -> BigUint {\n+        if n_unit == 0 { return copy *self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n             vec::slice(self.data, n_unit, self.data.len())\n         );\n     }\n \n     #[inline(always)]\n-    priv fn shr_bits(self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.data.is_empty() { return self; }\n+    priv fn shr_bits(&self, n_bits: uint) -> BigUint {\n+        if n_bits == 0 || self.data.is_empty() { return copy *self; }\n \n         let mut borrow = 0;\n         let mut shifted = ~[];\n         for self.data.each_reverse |elem| {\n             shifted = ~[(*elem >> n_bits) | borrow] + shifted;\n-            borrow = *elem << (uint::bits - n_bits);\n+            borrow = *elem << (BigDigit::bits - n_bits);\n         }\n         return BigUint::new(shifted);\n     }\n@@ -1070,7 +1085,7 @@ pub impl BigInt {\n             start = 1;\n         }\n         return BigUint::parse_bytes(vec::slice(buf, start, buf.len()), radix)\n-            .map(|bu| BigInt::from_biguint(sign, *bu));\n+            .map_consume(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n     #[inline(always)]\n@@ -1198,6 +1213,7 @@ mod biguint_tests {\n         check(~[1 << 2], 2, ~[1]);\n         check(~[1, 2], 3, ~[1 << (BigDigit::bits - 2)]);\n         check(~[1, 1, 2], 3 + BigDigit::bits, ~[1 << (BigDigit::bits - 2)]);\n+        check(~[0, 1], 1, ~[0x80000000]);\n         test_shr_bits();\n \n         #[cfg(target_arch = \"x86_64\")]\n@@ -1376,10 +1392,10 @@ mod biguint_tests {\n             let c = BigUint::from_slice(cVec);\n \n             if !a.is_zero() {\n-                assert!(c.quot_rem(&a) == (b, Zero::zero()));\n+                assert!(c.quot_rem(&a) == (copy b, Zero::zero()));\n             }\n             if !b.is_zero() {\n-                assert!(c.quot_rem(&b) == (a, Zero::zero()));\n+                assert!(c.quot_rem(&b) == (copy a, Zero::zero()));\n             }\n         }\n \n@@ -1503,7 +1519,7 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                assert_eq!(Some(n), FromStrRadix::from_str_radix(str, radix));\n+                assert_eq!(&n, &FromStrRadix::from_str_radix(str, radix).get());\n             }\n         }\n \n@@ -1517,7 +1533,9 @@ mod biguint_tests {\n         fn factor(n: uint) -> BigUint {\n             let mut f= One::one::<BigUint>();\n             for uint::range(2, n + 1) |i| {\n-                f *= BigUint::from_uint(i);\n+                // FIXME(#6102): Assignment operator for BigInt causes ICE\n+                // f *= BigUint::from_uint(i);\n+                f = f * BigUint::from_uint(i);\n             }\n             return f;\n         }"}]}