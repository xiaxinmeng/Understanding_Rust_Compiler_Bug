{"sha": "3208fc36bf2c7e99451e21171f82dafef2ea51dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMDhmYzM2YmYyYzdlOTk0NTFlMjExNzFmODJkYWZlZjJlYTUxZGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-16T02:31:46Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-16T02:31:46Z"}, "message": "Merge remote-tracking branch 'brson/io-wip' into io\n\nConflicts:\n\tsrc/libstd/rt/sched.rs\n\tsrc/libstd/rt/task.rs\n\tsrc/libstd/rt/test.rs\n\tsrc/libstd/task/mod.rs\n\tsrc/libstd/task/spawn.rs", "tree": {"sha": "0ac94c64e1601824d3e326964580a3b84295737a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ac94c64e1601824d3e326964580a3b84295737a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3208fc36bf2c7e99451e21171f82dafef2ea51dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3208fc36bf2c7e99451e21171f82dafef2ea51dc", "html_url": "https://github.com/rust-lang/rust/commit/3208fc36bf2c7e99451e21171f82dafef2ea51dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3208fc36bf2c7e99451e21171f82dafef2ea51dc/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b08c4467980bc712995d421dd50c1cca2948b67b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b08c4467980bc712995d421dd50c1cca2948b67b", "html_url": "https://github.com/rust-lang/rust/commit/b08c4467980bc712995d421dd50c1cca2948b67b"}, {"sha": "505ef7e710ff890c0027fadad54997041b7ee93b", "url": "https://api.github.com/repos/rust-lang/rust/commits/505ef7e710ff890c0027fadad54997041b7ee93b", "html_url": "https://github.com/rust-lang/rust/commit/505ef7e710ff890c0027fadad54997041b7ee93b"}], "stats": {"total": 893, "additions": 788, "deletions": 105}, "files": [{"sha": "b501699509e477e393a608e995bc7711914910cb", "filename": "src/libstd/rt/join_latch.rs", "status": "added", "additions": 645, "deletions": 0, "changes": 645, "blob_url": "https://github.com/rust-lang/rust/blob/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Fjoin_latch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Fjoin_latch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fjoin_latch.rs?ref=3208fc36bf2c7e99451e21171f82dafef2ea51dc", "patch": "@@ -0,0 +1,645 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The JoinLatch is a concurrent type that establishes the task\n+//! tree and propagates failure.\n+//!\n+//! Each task gets a JoinLatch that is derived from the JoinLatch\n+//! of its parent task. Every latch must be released by either calling\n+//! the non-blocking `release` method or the task-blocking `wait` method.\n+//! Releasing a latch does not complete until all of its child latches\n+//! complete.\n+//!\n+//! Latches carry a `success` flag that is set to `false` during task\n+//! failure and is propagated both from children to parents and parents\n+//! to children. The status af this flag may be queried for the purposes\n+//! of linked failure.\n+//!\n+//! In addition to failure propagation the task tree serves to keep the\n+//! default task schedulers alive. The runtime only sends the shutdown\n+//! message to schedulers once the root task exits.\n+//!\n+//! Under this scheme tasks that terminate before their children become\n+//! 'zombies' since they may not exit until their children do. Zombie\n+//! tasks are 'tombstoned' as `Tombstone(~JoinLatch)` and the tasks\n+//! themselves allowed to terminate.\n+//!\n+//! XXX: Propagate flag from parents to children.\n+//! XXX: Tombstoning actually doesn't work.\n+//! XXX: This could probably be done in a way that doesn't leak tombstones\n+//!      longer than the life of the child tasks.\n+\n+use comm::{GenericPort, Peekable, GenericSmartChan};\n+use clone::Clone;\n+use container::Container;\n+use option::{Option, Some, None};\n+use ops::Drop;\n+use rt::comm::{SharedChan, Port, stream};\n+use rt::local::Local;\n+use rt::sched::Scheduler;\n+use unstable::atomics::{AtomicUint, SeqCst};\n+use util;\n+use vec::OwnedVector;\n+\n+// FIXME #7026: Would prefer this to be an enum\n+pub struct JoinLatch {\n+    priv parent: Option<ParentLink>,\n+    priv child: Option<ChildLink>,\n+    closed: bool,\n+}\n+\n+// Shared between parents and all their children.\n+struct SharedState {\n+    /// Reference count, held by a parent and all children.\n+    count: AtomicUint,\n+    success: bool\n+}\n+\n+struct ParentLink {\n+    shared: *mut SharedState,\n+    // For communicating with the parent.\n+    chan: SharedChan<Message>\n+}\n+\n+struct ChildLink {\n+    shared: ~SharedState,\n+    // For receiving from children.\n+    port: Port<Message>,\n+    chan: SharedChan<Message>,\n+    // Prevents dropping the child SharedState reference counts multiple times.\n+    dropped_child: bool\n+}\n+\n+// Messages from child latches to parent.\n+enum Message {\n+    Tombstone(~JoinLatch),\n+    ChildrenTerminated\n+}\n+\n+impl JoinLatch {\n+    pub fn new_root() -> ~JoinLatch {\n+        let this = ~JoinLatch {\n+            parent: None,\n+            child: None,\n+            closed: false\n+        };\n+        rtdebug!(\"new root latch %x\", this.id());\n+        return this;\n+    }\n+\n+    fn id(&self) -> uint {\n+        unsafe { ::cast::transmute(&*self) }\n+    }\n+\n+    pub fn new_child(&mut self) -> ~JoinLatch {\n+        rtassert!(!self.closed);\n+\n+        if self.child.is_none() {\n+            // This is the first time spawning a child\n+            let shared = ~SharedState {\n+                count: AtomicUint::new(1),\n+                success: true\n+            };\n+            let (port, chan) = stream();\n+            let chan = SharedChan::new(chan);\n+            let child = ChildLink {\n+                shared: shared,\n+                port: port,\n+                chan: chan,\n+                dropped_child: false\n+            };\n+            self.child = Some(child);\n+        }\n+\n+        let child_link: &mut ChildLink = self.child.get_mut_ref();\n+        let shared_state: *mut SharedState = &mut *child_link.shared;\n+\n+        child_link.shared.count.fetch_add(1, SeqCst);\n+\n+        let child = ~JoinLatch {\n+            parent: Some(ParentLink {\n+                shared: shared_state,\n+                chan: child_link.chan.clone()\n+            }),\n+            child: None,\n+            closed: false\n+        };\n+        rtdebug!(\"NEW child latch %x\", child.id());\n+        return child;\n+    }\n+\n+    pub fn release(~self, local_success: bool) {\n+        // XXX: This should not block, but there's a bug in the below\n+        // code that I can't figure out.\n+        self.wait(local_success);\n+    }\n+\n+    // XXX: Should not require ~self\n+    fn release_broken(~self, local_success: bool) {\n+        rtassert!(!self.closed);\n+\n+        rtdebug!(\"releasing %x\", self.id());\n+\n+        let id = self.id();\n+        let _ = id; // XXX: `id` is only used in debug statements so appears unused\n+        let mut this = self;\n+        let mut child_success = true;\n+        let mut children_done = false;\n+\n+        if this.child.is_some() {\n+            rtdebug!(\"releasing children\");\n+            let child_link: &mut ChildLink = this.child.get_mut_ref();\n+            let shared: &mut SharedState = &mut *child_link.shared;\n+\n+            if !child_link.dropped_child {\n+                let last_count = shared.count.fetch_sub(1, SeqCst);\n+                rtdebug!(\"child count before sub %u %x\", last_count, id);\n+                if last_count == 1 {\n+                    assert!(child_link.chan.try_send(ChildrenTerminated));\n+                }\n+                child_link.dropped_child = true;\n+            }\n+\n+            // Wait for messages from children\n+            let mut tombstones = ~[];\n+            loop {\n+                if child_link.port.peek() {\n+                    match child_link.port.recv() {\n+                        Tombstone(t) => {\n+                            tombstones.push(t);\n+                        },\n+                        ChildrenTerminated => {\n+                            children_done = true;\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    break\n+                }\n+            }\n+\n+            rtdebug!(\"releasing %u tombstones %x\", tombstones.len(), id);\n+\n+            // Try to release the tombstones. Those that still have\n+            // outstanding will be re-enqueued.  When this task's\n+            // parents release their latch we'll end up back here\n+            // trying them again.\n+            while !tombstones.is_empty() {\n+                tombstones.pop().release(true);\n+            }\n+\n+            if children_done {\n+                let count = shared.count.load(SeqCst);\n+                assert!(count == 0);\n+                // self_count is the acquire-read barrier\n+                child_success = shared.success;\n+            }\n+        } else {\n+            children_done = true;\n+        }\n+\n+        let total_success = local_success && child_success;\n+\n+        rtassert!(this.parent.is_some());\n+\n+        unsafe {\n+            {\n+                let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n+                let shared: *mut SharedState = parent_link.shared;\n+\n+                if !total_success {\n+                    // parent_count is the write-wait barrier\n+                    (*shared).success = false;\n+                }\n+            }\n+\n+            if children_done {\n+                rtdebug!(\"children done\");\n+                do Local::borrow::<Scheduler, ()> |sched| {\n+                    sched.metrics.release_tombstone += 1;\n+                }\n+                {\n+                    rtdebug!(\"RELEASING parent %x\", id);\n+                    let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n+                    let shared: *mut SharedState = parent_link.shared;\n+                    let last_count = (*shared).count.fetch_sub(1, SeqCst);\n+                    rtdebug!(\"count before parent sub %u %x\", last_count, id);\n+                    if last_count == 1 {\n+                        assert!(parent_link.chan.try_send(ChildrenTerminated));\n+                    }\n+                }\n+                this.closed = true;\n+                util::ignore(this);\n+            } else {\n+                rtdebug!(\"children not done\");\n+                rtdebug!(\"TOMBSTONING %x\", id);\n+                do Local::borrow::<Scheduler, ()> |sched| {\n+                    sched.metrics.release_no_tombstone += 1;\n+                }\n+                let chan = {\n+                    let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n+                    parent_link.chan.clone()\n+                };\n+                assert!(chan.try_send(Tombstone(this)));\n+            }\n+        }\n+    }\n+\n+    // XXX: Should not require ~self\n+    pub fn wait(~self, local_success: bool) -> bool {\n+        rtassert!(!self.closed);\n+\n+        rtdebug!(\"WAITING %x\", self.id());\n+\n+        let mut this = self;\n+        let mut child_success = true;\n+\n+        if this.child.is_some() {\n+            rtdebug!(\"waiting for children\");\n+            let child_link: &mut ChildLink = this.child.get_mut_ref();\n+            let shared: &mut SharedState = &mut *child_link.shared;\n+\n+            if !child_link.dropped_child {\n+                let last_count = shared.count.fetch_sub(1, SeqCst);\n+                rtdebug!(\"child count before sub %u\", last_count);\n+                if last_count == 1 {\n+                    assert!(child_link.chan.try_send(ChildrenTerminated));\n+                }\n+                child_link.dropped_child = true;\n+            }\n+\n+            // Wait for messages from children\n+            loop {\n+                match child_link.port.recv() {\n+                    Tombstone(t) => {\n+                        t.wait(true);\n+                    }\n+                    ChildrenTerminated => break\n+                }\n+            }\n+\n+            let count = shared.count.load(SeqCst);\n+            if count != 0 { ::io::println(fmt!(\"%u\", count)); }\n+            assert!(count == 0);\n+            // self_count is the acquire-read barrier\n+            child_success = shared.success;\n+        }\n+\n+        let total_success = local_success && child_success;\n+\n+        if this.parent.is_some() {\n+            rtdebug!(\"releasing parent\");\n+            unsafe {\n+                let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n+                let shared: *mut SharedState = parent_link.shared;\n+\n+                if !total_success {\n+                    // parent_count is the write-wait barrier\n+                    (*shared).success = false;\n+                }\n+\n+                let last_count = (*shared).count.fetch_sub(1, SeqCst);\n+                rtdebug!(\"count before parent sub %u\", last_count);\n+                if last_count == 1 {\n+                    assert!(parent_link.chan.try_send(ChildrenTerminated));\n+                }\n+            }\n+        }\n+\n+        this.closed = true;\n+        util::ignore(this);\n+\n+        return total_success;\n+    }\n+}\n+\n+impl Drop for JoinLatch {\n+    fn finalize(&self) {\n+        rtdebug!(\"DESTROYING %x\", self.id());\n+        rtassert!(self.closed);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use cell::Cell;\n+    use container::Container;\n+    use iter::Times;\n+    use old_iter::BaseIter;\n+    use rt::test::*;\n+    use rand;\n+    use rand::RngUtil;\n+    use vec::{CopyableVector, ImmutableVector};\n+\n+    #[test]\n+    fn success_immediately() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+            do spawntask_immediately {\n+                let child_latch = child_latch.take();\n+                assert!(child_latch.wait(true));\n+            }\n+\n+            assert!(latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn success_later() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+            do spawntask_later {\n+                let child_latch = child_latch.take();\n+                assert!(child_latch.wait(true));\n+            }\n+\n+            assert!(latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn mt_success() {\n+        do run_in_mt_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            for 10.times {\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_random {\n+                    let child_latch = child_latch.take();\n+                    assert!(child_latch.wait(true));\n+                }\n+            }\n+\n+            assert!(latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn mt_failure() {\n+        do run_in_mt_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            let spawn = |status| {\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_random {\n+                    let child_latch = child_latch.take();\n+                    child_latch.wait(status);\n+                }\n+            };\n+\n+            for 10.times { spawn(true) }\n+            spawn(false);\n+            for 10.times { spawn(true) }\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn mt_multi_level_success() {\n+        do run_in_mt_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            fn child(latch: &mut JoinLatch, i: int) {\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_random {\n+                    let mut child_latch = child_latch.take();\n+                    if i != 0 {\n+                        child(&mut *child_latch, i - 1);\n+                        child_latch.wait(true);\n+                    } else {\n+                        child_latch.wait(true);\n+                    }\n+                }\n+            }\n+\n+            child(&mut *latch, 10);\n+\n+            assert!(latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn mt_multi_level_failure() {\n+        do run_in_mt_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+\n+            fn child(latch: &mut JoinLatch, i: int) {\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_random {\n+                    let mut child_latch = child_latch.take();\n+                    if i != 0 {\n+                        child(&mut *child_latch, i - 1);\n+                        child_latch.wait(false);\n+                    } else {\n+                        child_latch.wait(true);\n+                    }\n+                }\n+            }\n+\n+            child(&mut *latch, 10);\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn release_child() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+\n+            do spawntask_immediately {\n+                let latch = child_latch.take();\n+                latch.release(false);\n+            }\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn release_child_tombstone() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+\n+            do spawntask_immediately {\n+                let mut latch = child_latch.take();\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_later {\n+                    let latch = child_latch.take();\n+                    latch.release(false);\n+                }\n+                latch.release(true);\n+            }\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn release_child_no_tombstone() {\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+            let child_latch = latch.new_child();\n+            let child_latch = Cell(child_latch);\n+\n+            do spawntask_later {\n+                let mut latch = child_latch.take();\n+                let child_latch = latch.new_child();\n+                let child_latch = Cell(child_latch);\n+                do spawntask_immediately {\n+                    let latch = child_latch.take();\n+                    latch.release(false);\n+                }\n+                latch.release(true);\n+            }\n+\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+\n+    #[test]\n+    fn release_child_tombstone_stress() {\n+        fn rand_orders() -> ~[bool] {\n+            let mut v = ~[false,.. 5];\n+            v[0] = true;\n+            let mut rng = rand::rng();\n+            return rng.shuffle(v);\n+        }\n+\n+        fn split_orders(orders: &[bool]) -> (~[bool], ~[bool]) {\n+            if orders.is_empty() {\n+                return (~[], ~[]);\n+            } else if orders.len() <= 2 {\n+                return (orders.to_owned(), ~[]);\n+            }\n+            let mut rng = rand::rng();\n+            let n = rng.gen_uint_range(1, orders.len());\n+            let first = orders.slice(0, n).to_owned();\n+            let last = orders.slice(n, orders.len()).to_owned();\n+            assert!(first.len() + last.len() == orders.len());\n+            return (first, last);\n+        }\n+\n+        for stress_factor().times {\n+            do run_in_newsched_task {\n+                fn doit(latch: &mut JoinLatch, orders: ~[bool], depth: uint) {\n+                    let (my_orders, remaining_orders) = split_orders(orders);\n+                    rtdebug!(\"(my_orders, remaining): %?\", (&my_orders, &remaining_orders));\n+                    rtdebug!(\"depth: %u\", depth);\n+                    let mut remaining_orders = remaining_orders;\n+                    let mut num = 0;\n+                    for my_orders.each |&order| {\n+                        let child_latch = latch.new_child();\n+                        let child_latch = Cell(child_latch);\n+                        let (child_orders, remaining) = split_orders(remaining_orders);\n+                        rtdebug!(\"(child_orders, remaining): %?\", (&child_orders, &remaining));\n+                        remaining_orders = remaining;\n+                        let child_orders = Cell(child_orders);\n+                        let child_num = num;\n+                        let _ = child_num; // XXX unused except in rtdebug!\n+                        do spawntask_random {\n+                            rtdebug!(\"depth %u num %u\", depth, child_num);\n+                            let mut child_latch = child_latch.take();\n+                            let child_orders = child_orders.take();\n+                            doit(&mut *child_latch, child_orders, depth + 1);\n+                            child_latch.release(order);\n+                        }\n+\n+                        num += 1;\n+                    }\n+                }\n+\n+                let mut latch = JoinLatch::new_root();\n+                let orders = rand_orders();\n+                rtdebug!(\"orders: %?\", orders);\n+\n+                doit(&mut *latch, orders, 0);\n+\n+                assert!(!latch.wait(true));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn whateverman() {\n+        struct Order {\n+            immediate: bool,\n+            succeed: bool,\n+            orders: ~[Order]\n+        }\n+        fn next(latch: &mut JoinLatch, orders: ~[Order]) {\n+            for orders.each |order| {\n+                let suborders = copy order.orders;\n+                let child_latch = Cell(latch.new_child());\n+                let succeed = order.succeed;\n+                if order.immediate {\n+                    do spawntask_immediately {\n+                        let mut child_latch = child_latch.take();\n+                        next(&mut *child_latch, copy suborders);\n+                        rtdebug!(\"immediate releasing\");\n+                        child_latch.release(succeed);\n+                    }\n+                } else {\n+                    do spawntask_later {\n+                        let mut child_latch = child_latch.take();\n+                        next(&mut *child_latch, copy suborders);\n+                        rtdebug!(\"later releasing\");\n+                        child_latch.release(succeed);\n+                    }\n+                }\n+            }\n+        }\n+\n+        do run_in_newsched_task {\n+            let mut latch = JoinLatch::new_root();\n+            let orders = ~[ Order { // 0 0\n+                immediate: true,\n+                succeed: true,\n+                orders: ~[ Order { // 1 0\n+                    immediate: true,\n+                    succeed: false,\n+                    orders: ~[ Order { // 2 0\n+                        immediate: false,\n+                        succeed: false,\n+                        orders: ~[ Order { // 3 0\n+                            immediate: true,\n+                            succeed: false,\n+                            orders: ~[]\n+                        }, Order { // 3 1\n+                            immediate: false,\n+                            succeed: false,\n+                            orders: ~[]\n+                        }]\n+                    }]\n+                }]\n+            }];\n+\n+            next(&mut *latch, orders);\n+            assert!(!latch.wait(true));\n+        }\n+    }\n+}"}, {"sha": "b0c0fa5d708623d216bdfb58bdf6947da29ada29", "filename": "src/libstd/rt/metrics.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmetrics.rs?ref=3208fc36bf2c7e99451e21171f82dafef2ea51dc", "patch": "@@ -34,7 +34,11 @@ pub struct SchedMetrics {\n     // Message receives that do not block the receiver\n     rendezvous_recvs: uint,\n     // Message receives that block the receiver\n-    non_rendezvous_recvs: uint\n+    non_rendezvous_recvs: uint,\n+    // JoinLatch releases that create tombstones\n+    release_tombstone: uint,\n+    // JoinLatch releases that do not create tombstones\n+    release_no_tombstone: uint,\n }\n \n impl SchedMetrics {\n@@ -51,7 +55,9 @@ impl SchedMetrics {\n             rendezvous_sends: 0,\n             non_rendezvous_sends: 0,\n             rendezvous_recvs: 0,\n-            non_rendezvous_recvs: 0\n+            non_rendezvous_recvs: 0,\n+            release_tombstone: 0,\n+            release_no_tombstone: 0\n         }\n     }\n }\n@@ -70,6 +76,8 @@ impl ToStr for SchedMetrics {\n               non_rendezvous_sends: %u\\n\\\n               rendezvous_recvs: %u\\n\\\n               non_rendezvous_recvs: %u\\n\\\n+              release_tombstone: %u\\n\\\n+              release_no_tombstone: %u\\n\\\n               \",\n              self.turns,\n              self.messages_received,\n@@ -82,7 +90,9 @@ impl ToStr for SchedMetrics {\n              self.rendezvous_sends,\n              self.non_rendezvous_sends,\n              self.rendezvous_recvs,\n-             self.non_rendezvous_recvs\n+             self.non_rendezvous_recvs,\n+             self.release_tombstone,\n+             self.release_no_tombstone\n         )\n     }\n }\n\\ No newline at end of file"}, {"sha": "5f06c1455a4dfbf5abe24f4cb6b8a9020de4a22c", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=3208fc36bf2c7e99451e21171f82dafef2ea51dc", "patch": "@@ -133,6 +133,9 @@ pub mod local_ptr;\n /// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n \n+/// A concurrent data structure with which parent tasks wait on child tasks.\n+pub mod join_latch;\n+\n pub mod metrics;\n \n \n@@ -164,7 +167,7 @@ pub fn start(_argc: int, _argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n     let sleepers = SleeperList::new();\n     let mut sched = ~Scheduler::new(loop_, work_queue, sleepers);\n     sched.no_sleep = true;\n-    let main_task = ~Coroutine::new(&mut sched.stack_pool, main);\n+    let main_task = ~Coroutine::new_root(&mut sched.stack_pool, main);\n \n     sched.enqueue_task(main_task);\n     sched.run();\n@@ -238,7 +241,7 @@ fn test_context() {\n     do run_in_bare_thread {\n         assert_eq!(context(), GlobalContext);\n         let mut sched = ~new_test_uv_sched();\n-        let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+        let task = ~do Coroutine::new_root(&mut sched.stack_pool) {\n             assert_eq!(context(), TaskContext);\n             let sched = Local::take::<Scheduler>();\n             do sched.deschedule_running_task_and_then() |sched, task| {"}, {"sha": "fe553467ebda553ff97dee7e95bcc0e523166d3f", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=3208fc36bf2c7e99451e21171f82dafef2ea51dc", "patch": "@@ -181,8 +181,10 @@ pub impl Scheduler {\n         // XXX: Reenable this once we're using a per-task queue. With a shared\n         // queue this is not true\n         //assert!(sched.work_queue.is_empty());\n-//        let out = sched.metrics.to_str();\n-//        rtdebug!(\"scheduler metrics: %s\\n\", out);\n+        rtdebug!(\"scheduler metrics: %s\\n\", {\n+            use to_str::ToStr;\n+            sched.metrics.to_str()\n+        });\n         return sched;\n     }\n \n@@ -728,19 +730,19 @@ pub impl Coroutine {\n     // using the AnySched paramter.\n \n     fn new_homed(stack_pool: &mut StackPool, home: SchedHome, start: ~fn()) -> Coroutine {\n-        Coroutine::with_task_homed(stack_pool, ~Task::new(), start, home)\n+        Coroutine::with_task_homed(stack_pool, ~Task::new_root(), start, home)\n     }\n \n-    fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n-        Coroutine::with_task(stack_pool, ~Task::new(), start)\n+    fn new_root(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n+        Coroutine::with_task(stack_pool, ~Task::new_root(), start)\n     }\n \n     fn with_task_homed(stack_pool: &mut StackPool,\n                        task: ~Task,\n                        start: ~fn(),\n                        home: SchedHome) -> Coroutine {\n \n-        static MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n+        static MIN_STACK_SIZE: uint = 1000000; // XXX: Too much stack\n \n         let start = Coroutine::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);\n@@ -930,14 +932,14 @@ mod test {\n             };\n             let t1f = Cell(t1f);\n \n-            let t2f = ~do Coroutine::new(&mut normal_sched.stack_pool) {\n+            let t2f = ~do Coroutine::new_root(&mut normal_sched.stack_pool) {\n                 let on_special = Coroutine::on_special();\n                 rtdebug!(\"t2 should not be on special: %b\", on_special);\n                 assert!(!on_special);\n             };\n             let t2f = Cell(t2f);\n \n-            let t3f = ~do Coroutine::new(&mut normal_sched.stack_pool) {\n+            let t3f = ~do Coroutine::new_root(&mut normal_sched.stack_pool) {\n                 // not on special\n                 let on_special = Coroutine::on_special();\n                 rtdebug!(\"t3 should not be on special: %b\", on_special);\n@@ -986,7 +988,7 @@ mod test {\n             let t4 = Cell(t4);\n \n             // build a main task that runs our four tests\n-            let main_task = ~do Coroutine::new(&mut normal_sched.stack_pool) {\n+            let main_task = ~do Coroutine::new_root(&mut normal_sched.stack_pool) {\n                 // the two tasks that require a normal start location\n                 t2.take()();\n                 t4.take()();\n@@ -1141,7 +1143,7 @@ mod test {\n             let task_ran_ptr: *mut bool = &mut task_ran;\n \n             let mut sched = ~new_test_uv_sched();\n-            let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+            let task = ~do Coroutine::new_root(&mut sched.stack_pool) {\n                 unsafe { *task_ran_ptr = true; }\n             };\n             sched.enqueue_task(task);\n@@ -1159,7 +1161,7 @@ mod test {\n \n             let mut sched = ~new_test_uv_sched();\n             for int::range(0, total) |_| {\n-                let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                let task = ~do Coroutine::new_root(&mut sched.stack_pool) {\n                     unsafe { *task_count_ptr = *task_count_ptr + 1; }\n                 };\n                 sched.enqueue_task(task);\n@@ -1176,10 +1178,10 @@ mod test {\n             let count_ptr: *mut int = &mut count;\n \n             let mut sched = ~new_test_uv_sched();\n-            let task1 = ~do Coroutine::new(&mut sched.stack_pool) {\n+            let task1 = ~do Coroutine::new_root(&mut sched.stack_pool) {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n                 let mut sched = Local::take::<Scheduler>();\n-                let task2 = ~do Coroutine::new(&mut sched.stack_pool) {\n+                let task2 = ~do Coroutine::new_root(&mut sched.stack_pool) {\n                     unsafe { *count_ptr = *count_ptr + 1; }\n                 };\n                 // Context switch directly to the new task\n@@ -1204,7 +1206,7 @@ mod test {\n \n             let mut sched = ~new_test_uv_sched();\n \n-            let start_task = ~do Coroutine::new(&mut sched.stack_pool) {\n+            let start_task = ~do Coroutine::new_root(&mut sched.stack_pool) {\n                 run_task(count_ptr);\n             };\n             sched.enqueue_task(start_task);\n@@ -1214,7 +1216,7 @@ mod test {\n \n             fn run_task(count_ptr: *mut int) {\n                 do Local::borrow::<Scheduler, ()> |sched| {\n-                    let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+                    let task = ~do Coroutine::new_root(&mut sched.stack_pool) {\n                         unsafe {\n                             *count_ptr = *count_ptr + 1;\n                             if *count_ptr != MAX {\n@@ -1232,7 +1234,7 @@ mod test {\n     fn test_block_task() {\n         do run_in_bare_thread {\n             let mut sched = ~new_test_uv_sched();\n-            let task = ~do Coroutine::new(&mut sched.stack_pool) {\n+            let task = ~do Coroutine::new_root(&mut sched.stack_pool) {\n                 let sched = Local::take::<Scheduler>();\n                 assert!(sched.in_task_context());\n                 do sched.deschedule_running_task_and_then() |sched, task| {\n@@ -1279,13 +1281,13 @@ mod test {\n             let mut sched1 = ~new_test_uv_sched();\n             let handle1 = sched1.make_handle();\n             let handle1_cell = Cell(handle1);\n-            let task1 = ~do Coroutine::new(&mut sched1.stack_pool) {\n+            let task1 = ~do Coroutine::new_root(&mut sched1.stack_pool) {\n                 chan_cell.take().send(());\n             };\n             sched1.enqueue_task(task1);\n \n             let mut sched2 = ~new_test_uv_sched();\n-            let task2 = ~do Coroutine::new(&mut sched2.stack_pool) {\n+            let task2 = ~do Coroutine::new_root(&mut sched2.stack_pool) {\n                 port_cell.take().recv();\n                 // Release the other scheduler's handle so it can exit\n                 handle1_cell.take();"}, {"sha": "6e4be3c1ef996b02c9ebdc94fd38909154cd4c10", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=3208fc36bf2c7e99451e21171f82dafef2ea51dc", "patch": "@@ -16,19 +16,23 @@\n use prelude::*;\n use libc::{c_void, uintptr_t};\n use cast::transmute;\n+use option::{Option, Some, None};\n use rt::local::Local;\n use super::local_heap::LocalHeap;\n use rt::logging::StdErrLogger;\n use rt::sched::{SchedHome, AnySched};\n+use rt::join_latch::JoinLatch;\n \n pub struct Task {\n     heap: LocalHeap,\n     gc: GarbageCollector,\n     storage: LocalStorage,\n     logger: StdErrLogger,\n-    unwinder: Option<Unwinder>,\n-    destroyed: bool,\n-    home: Option<SchedHome>\n+    unwinder: Unwinder,\n+    home: Option<SchedHome>,\n+    join_latch: Option<~JoinLatch>,\n+    on_exit: Option<~fn(bool)>,\n+    destroyed: bool\n }\n \n pub struct GarbageCollector;\n@@ -39,27 +43,31 @@ pub struct Unwinder {\n }\n \n impl Task {\n-    pub fn new() -> Task {\n+    pub fn new_root() -> Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n             logger: StdErrLogger,\n-            unwinder: Some(Unwinder { unwinding: false }),\n-            destroyed: false,\n-            home: Some(AnySched)\n+            unwinder: Unwinder { unwinding: false },\n+            home: Some(AnySched),\n+            join_latch: Some(JoinLatch::new_root()),\n+            on_exit: None,\n+            destroyed: false\n         }\n     }\n \n-    pub fn without_unwinding() -> Task {\n+    pub fn new_child(&mut self) -> Task {\n         Task {\n             heap: LocalHeap::new(),\n             gc: GarbageCollector,\n             storage: LocalStorage(ptr::null(), None),\n             logger: StdErrLogger,\n-            unwinder: None,\n-            destroyed: false,\n-            home: Some(AnySched)\n+            home: Some(AnySched),\n+            unwinder: Unwinder { unwinding: false },\n+            join_latch: Some(self.join_latch.get_mut_ref().new_child()),\n+            on_exit: None,\n+            destroyed: false\n         }\n     }\n \n@@ -74,20 +82,24 @@ impl Task {\n             assert!(ptr::ref_eq(task, self));\n         }\n \n-        match self.unwinder {\n-            Some(ref mut unwinder) => {\n-                // If there's an unwinder then set up the catch block\n-                unwinder.try(f);\n+        self.unwinder.try(f);\n+        self.destroy();\n+\n+        // Wait for children. Possibly report the exit status.\n+        let local_success = !self.unwinder.unwinding;\n+        let join_latch = self.join_latch.swap_unwrap();\n+        match self.on_exit {\n+            Some(ref on_exit) => {\n+                let success = join_latch.wait(local_success);\n+                (*on_exit)(success);\n             }\n             None => {\n-                // Otherwise, just run the body\n-                f()\n+                join_latch.release(local_success);\n             }\n         }\n-        self.destroy();\n     }\n \n-    /// Must be called manually before finalization to clean up\n+    /// must be called manually before finalization to clean up\n     /// thread-local resources. Some of the routines here expect\n     /// Task to be available recursively so this must be\n     /// called unsafely, without removing Task from\n@@ -233,5 +245,15 @@ mod test {\n             assert!(port.recv() == 10);\n         }\n     }\n+\n+    #[test]\n+    fn linked_failure() {\n+        do run_in_newsched_task() {\n+            let res = do spawntask_try {\n+                spawntask_random(|| fail!());\n+            };\n+            assert!(res.is_err());\n+        }\n+    }\n }\n "}, {"sha": "d35d01cf7198c5ad7d767c9fc89d804c99ba807f", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=3208fc36bf2c7e99451e21171f82dafef2ea51dc", "patch": "@@ -18,6 +18,7 @@ use vec::OwnedVector;\n use result::{Result, Ok, Err};\n use unstable::run_in_bare_thread;\n use super::io::net::ip::{IpAddr, Ipv4};\n+use rt::comm::oneshot;\n use rt::task::Task;\n use rt::thread::Thread;\n use rt::local::Local;\n@@ -47,8 +48,11 @@ pub fn run_in_newsched_task(f: ~fn()) {\n \n     do run_in_bare_thread {\n         let mut sched = ~new_test_uv_sched();\n+        let mut new_task = ~Task::new_root();\n+        let on_exit: ~fn(bool) = |exit_status| rtassert!(exit_status);\n+        new_task.on_exit = Some(on_exit);\n         let task = ~Coroutine::with_task(&mut sched.stack_pool,\n-                                         ~Task::without_unwinding(),\n+                                         new_task,\n                                          f.take());\n         sched.enqueue_task(task);\n         sched.run();\n@@ -95,16 +99,20 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n \n         let f_cell = Cell(f_cell.take());\n         let handles = Cell(handles);\n-        let main_task = ~do Coroutine::new(&mut scheds[0].stack_pool) {\n-            f_cell.take()();\n+        let mut new_task = ~Task::new_root();\n+        let on_exit: ~fn(bool) = |exit_status| {\n \n             let mut handles = handles.take();\n             // Tell schedulers to exit\n             for handles.each_mut |handle| {\n                 handle.send(Shutdown);\n             }\n-        };\n \n+            rtassert!(exit_status);\n+        };\n+        new_task.on_exit = Some(on_exit);\n+        let main_task = ~Coroutine::with_task(&mut scheds[0].stack_pool,\n+                                              new_task, f_cell.take());\n         scheds[0].enqueue_task(main_task);\n \n         let mut threads = ~[];\n@@ -201,7 +209,7 @@ pub fn run_in_mt_newsched_task_random_homed() {\n \n         rtdebug!(\"creating main task\");\n \n-        let main_task = ~do Coroutine::new(&mut scheds[0].stack_pool) {\n+        let main_task = ~do Coroutine::new_root(&mut scheds[0].stack_pool) {\n             f_cell.take()();\n             let mut handles = handles.take();\n             // Tell schedulers to exit\n@@ -245,10 +253,13 @@ pub fn spawntask(f: ~fn()) {\n     use super::sched::*;\n \n     rtdebug!(\"spawntask taking the scheduler from TLS\")\n+    let task = do Local::borrow::<Task, ~Task>() |running_task| {\n+        ~running_task.new_child()\n+    };\n+\n     let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n-                                     ~Task::without_unwinding(),\n-                                     f);\n+                                     task, f);\n     rtdebug!(\"spawntask scheduling the new task\");\n     sched.schedule_task(task);\n }\n@@ -257,10 +268,13 @@ pub fn spawntask(f: ~fn()) {\n pub fn spawntask_immediately(f: ~fn()) {\n     use super::sched::*;\n \n+    let task = do Local::borrow::<Task, ~Task>() |running_task| {\n+        ~running_task.new_child()\n+    };\n+\n     let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n-                                     ~Task::without_unwinding(),\n-                                     f);\n+                                     task, f);\n     do sched.switch_running_tasks_and_then(task) |sched, task| {\n         sched.enqueue_task(task);\n     }\n@@ -270,10 +284,13 @@ pub fn spawntask_immediately(f: ~fn()) {\n pub fn spawntask_later(f: ~fn()) {\n     use super::sched::*;\n \n+    let task = do Local::borrow::<Task, ~Task>() |running_task| {\n+        ~running_task.new_child()\n+    };\n+\n     let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n-                                     ~Task::without_unwinding(),\n-                                     f);\n+                                     task, f);\n \n     sched.enqueue_task(task);\n     Local::put(sched);\n@@ -284,13 +301,16 @@ pub fn spawntask_random(f: ~fn()) {\n     use super::sched::*;\n     use rand::{Rand, rng};\n \n-    let mut rng = rng();\n-    let run_now: bool = Rand::rand(&mut rng);\n+    let task = do Local::borrow::<Task, ~Task>() |running_task| {\n+        ~running_task.new_child()\n+    };\n \n     let mut sched = Local::take::<Scheduler>();\n     let task = ~Coroutine::with_task(&mut sched.stack_pool,\n-                                     ~Task::without_unwinding(),\n-                                     f);\n+                                     task, f);\n+\n+    let mut rng = rng();\n+    let run_now: bool = Rand::rand(&mut rng);\n \n     if run_now {\n         do sched.switch_running_tasks_and_then(task) |sched, task| {\n@@ -327,7 +347,7 @@ pub fn spawntask_homed(scheds: &mut ~[~Scheduler], f: ~fn()) {\n         };\n \n         ~Coroutine::with_task_homed(&mut sched.stack_pool,\n-                                    ~Task::without_unwinding(),\n+                                    ~Task::new_root(),\n                                     af,\n                                     Sched(handle))\n     };\n@@ -340,47 +360,37 @@ pub fn spawntask_homed(scheds: &mut ~[~Scheduler], f: ~fn()) {\n pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n     use cell::Cell;\n     use super::sched::*;\n-    use task;\n-    use unstable::finally::Finally;\n-\n-    // Our status variables will be filled in from the scheduler context\n-    let mut failed = false;\n-    let failed_ptr: *mut bool = &mut failed;\n-\n-    // Switch to the scheduler\n-    let f = Cell(Cell(f));\n-    let sched = Local::take::<Scheduler>();\n-    do sched.deschedule_running_task_and_then() |sched, old_task| {\n-        let old_task = Cell(old_task);\n-        let f = f.take();\n-        let new_task = ~do Coroutine::new(&mut sched.stack_pool) {\n-            do (|| {\n-                (f.take())()\n-            }).finally {\n-                // Check for failure then resume the parent task\n-                unsafe { *failed_ptr = task::failing(); }\n-                let sched = Local::take::<Scheduler>();\n-                do sched.switch_running_tasks_and_then(old_task.take()) |sched, new_task| {\n-                    sched.enqueue_task(new_task);\n-                }\n-            }\n-        };\n \n-        sched.enqueue_task(new_task);\n+    let (port, chan) = oneshot();\n+    let chan = Cell(chan);\n+    let mut new_task = ~Task::new_root();\n+    let on_exit: ~fn(bool) = |exit_status| chan.take().send(exit_status);\n+    new_task.on_exit = Some(on_exit);\n+    let mut sched = Local::take::<Scheduler>();\n+    let new_task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                         new_task, f);\n+    do sched.switch_running_tasks_and_then(new_task) |sched, old_task| {\n+        sched.enqueue_task(old_task);\n     }\n \n-    if !failed { Ok(()) } else { Err(()) }\n+    let exit_status = port.recv();\n+    if exit_status { Ok(()) } else { Err(()) }\n }\n \n // Spawn a new task in a new scheduler and return a thread handle.\n pub fn spawntask_thread(f: ~fn()) -> Thread {\n     use rt::sched::*;\n \n+    let task = do Local::borrow::<Task, ~Task>() |running_task| {\n+        ~running_task.new_child()\n+    };\n+\n+    let task = Cell(task);\n     let f = Cell(f);\n     let thread = do Thread::start {\n         let mut sched = ~new_test_uv_sched();\n         let task = ~Coroutine::with_task(&mut sched.stack_pool,\n-                                         ~Task::without_unwinding(),\n+                                         task.take(),\n                                          f.take());\n         sched.enqueue_task(task);\n         sched.run();"}, {"sha": "77085d195678d11d238a2a7343333581a7ec5bc4", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=3208fc36bf2c7e99451e21171f82dafef2ea51dc", "patch": "@@ -226,11 +226,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                 gc::cleanup_stack_for_failure();\n \n                 let task = Local::unsafe_borrow::<Task>();\n-                let unwinder: &mut Option<Unwinder> = &mut (*task).unwinder;\n-                match *unwinder {\n-                    Some(ref mut unwinder) => unwinder.begin_unwind(),\n-                    None => abort!(\"failure without unwinder. aborting process\")\n-                }\n+                (*task).unwinder.begin_unwind();\n             }\n         }\n     }"}, {"sha": "dbfb9baefa7482b3ec1c049dfd766fdb49a1789a", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=3208fc36bf2c7e99451e21171f82dafef2ea51dc", "patch": "@@ -513,20 +513,9 @@ pub fn failing() -> bool {\n             }\n         }\n         _ => {\n-            let mut unwinding = false;\n-            do Local::borrow::<Task, ()> |local| {\n-                unwinding = match local.unwinder {\n-                    Some(unwinder) => {\n-                        unwinder.unwinding\n-                    }\n-                    None => {\n-                        // Because there is no unwinder we can't be unwinding.\n-                        // (The process will abort on failure)\n-                        false\n-                    }\n-                }\n+            do Local::borrow::<Task, bool> |local| {\n+                local.unwinder.unwinding\n             }\n-            return unwinding;\n         }\n     }\n }"}, {"sha": "bff4aa1498d287fb69499e41daf79201fb5f3160", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3208fc36bf2c7e99451e21171f82dafef2ea51dc/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=3208fc36bf2c7e99451e21171f82dafef2ea51dc", "patch": "@@ -91,6 +91,7 @@ use uint;\n use util;\n use unstable::sync::{Exclusive, exclusive};\n use rt::local::Local;\n+use rt::task::Task;\n \n #[cfg(test)] use task::default_task_opts;\n \n@@ -576,8 +577,13 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n+    let task = do Local::borrow::<Task, ~Task>() |running_task| {\n+        ~running_task.new_child()\n+    };\n+\n     let mut sched = Local::take::<Scheduler>();\n-    let task = ~Coroutine::new(&mut sched.stack_pool, f);\n+    let task = ~Coroutine::with_task(&mut sched.stack_pool,\n+                                     task, f);\n     sched.schedule_task(task);\n }\n "}]}