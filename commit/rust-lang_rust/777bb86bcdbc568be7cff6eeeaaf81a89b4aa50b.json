{"sha": "777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "node_id": "C_kwDOAAsO6NoAKDc3N2JiODZiY2RiYzU2OGJlN2NmZjZlZWVhYWY4MWE4OWI0YWE1MGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-20T20:44:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-20T20:44:14Z"}, "message": "Auto merge of #93119 - matthiaskrgr:rollup-ku3cn5j, r=matthiaskrgr\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #89747 (Add MaybeUninit::(slice_)as_bytes(_mut))\n - #89764 (Fix variant index / discriminant confusion in uninhabited enum branching)\n - #91606 (Stabilize `-Z print-link-args` as `--print link-args`)\n - #91694 (rustdoc: decouple stability and const-stability)\n - #92183 (Point at correct argument when async fn output type lifetime disagrees with signature)\n - #92582 (improve `_` constants in item signature handling)\n - #92680 (intra-doc: Use the impl's assoc item where possible)\n - #92704 (Change lint message to be stronger for &T -> &mut T transmute)\n - #92861 (Rustdoc mobile: put out-of-band info on its own line)\n - #92992 (Help optimize out backtraces when disabled)\n - #93038 (Fix star handling in block doc comments)\n - #93108 (:arrow_up: rust-analyzer)\n - #93112 (Fix CVE-2022-21658)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "82f458e6da62ec8cd4baa7cf5c1b4c2eed5f3cc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82f458e6da62ec8cd4baa7cf5c1b4c2eed5f3cc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "html_url": "https://github.com/rust-lang/rust/commit/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74fbbefea8d13683cca5eee62e4740706cb3144a", "url": "https://api.github.com/repos/rust-lang/rust/commits/74fbbefea8d13683cca5eee62e4740706cb3144a", "html_url": "https://github.com/rust-lang/rust/commit/74fbbefea8d13683cca5eee62e4740706cb3144a"}, {"sha": "dbc97490bbca00e6913c34b8864791d660c60312", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc97490bbca00e6913c34b8864791d660c60312", "html_url": "https://github.com/rust-lang/rust/commit/dbc97490bbca00e6913c34b8864791d660c60312"}], "stats": {"total": 2717, "additions": 1914, "deletions": 803}, "files": [{"sha": "6a0ace04d4b618066d683a949d5f1ed4bdc74f4c", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -242,6 +242,17 @@ impl Attribute {\n         }\n     }\n \n+    pub fn doc_str_and_comment_kind(&self) -> Option<(Symbol, CommentKind)> {\n+        match self.kind {\n+            AttrKind::DocComment(kind, data) => Some((data, kind)),\n+            AttrKind::Normal(ref item, _) if item.path == sym::doc => item\n+                .meta_kind()\n+                .and_then(|kind| kind.value_str())\n+                .map(|data| (data, CommentKind::Line)),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn doc_str(&self) -> Option<Symbol> {\n         match self.kind {\n             AttrKind::DocComment(.., data) => Some(data),"}, {"sha": "612ee71f350f16e31b218607a8dabdd2bdbea7d4", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,3 +1,4 @@\n+use crate::token::CommentKind;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{BytePos, CharPos, FileName, Pos, Symbol};\n \n@@ -25,7 +26,7 @@ pub struct Comment {\n \n /// Makes a doc string more presentable to users.\n /// Used by rustdoc and perhaps other tools, but not by rustc.\n-pub fn beautify_doc_string(data: Symbol) -> Symbol {\n+pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n     fn get_vertical_trim(lines: &[&str]) -> Option<(usize, usize)> {\n         let mut i = 0;\n         let mut j = lines.len();\n@@ -42,10 +43,28 @@ pub fn beautify_doc_string(data: Symbol) -> Symbol {\n         if i != 0 || j != lines.len() { Some((i, j)) } else { None }\n     }\n \n-    fn get_horizontal_trim(lines: &[&str]) -> Option<usize> {\n+    fn get_horizontal_trim(lines: &[&str], kind: CommentKind) -> Option<usize> {\n         let mut i = usize::MAX;\n         let mut first = true;\n \n+        // In case we have doc comments like `/**` or `/*!`, we want to remove stars if they are\n+        // present. However, we first need to strip the empty lines so they don't get in the middle\n+        // when we try to compute the \"horizontal trim\".\n+        let lines = if kind == CommentKind::Block {\n+            let mut i = 0;\n+            let mut j = lines.len();\n+\n+            while i < j && lines[i].trim().is_empty() {\n+                i += 1;\n+            }\n+            while j > i && lines[j - 1].trim().is_empty() {\n+                j -= 1;\n+            }\n+            &lines[i..j]\n+        } else {\n+            lines\n+        };\n+\n         for line in lines {\n             for (j, c) in line.chars().enumerate() {\n                 if j > i || !\"* \\t\".contains(c) {\n@@ -79,11 +98,13 @@ pub fn beautify_doc_string(data: Symbol) -> Symbol {\n         } else {\n             &mut lines\n         };\n-        if let Some(horizontal) = get_horizontal_trim(&lines) {\n+        if let Some(horizontal) = get_horizontal_trim(&lines, kind) {\n             changes = true;\n             // remove a \"[ \\t]*\\*\" block from each line, if possible\n             for line in lines.iter_mut() {\n-                *line = &line[horizontal + 1..];\n+                if horizontal + 1 < line.len() {\n+                    *line = &line[horizontal + 1..];\n+                }\n             }\n         }\n         if changes {"}, {"sha": "98f692a7724e2778b9410ff4e8d85ae8e59273dd", "filename": "compiler/rustc_ast/src/util/comments/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -5,7 +5,7 @@ use rustc_span::create_default_session_globals_then;\n fn test_block_doc_comment_1() {\n     create_default_session_globals_then(|| {\n         let comment = \"\\n * Test \\n **  Test\\n *   Test\\n\";\n-        let stripped = beautify_doc_string(Symbol::intern(comment));\n+        let stripped = beautify_doc_string(Symbol::intern(comment), CommentKind::Block);\n         assert_eq!(stripped.as_str(), \" Test \\n*  Test\\n   Test\");\n     })\n }\n@@ -14,7 +14,7 @@ fn test_block_doc_comment_1() {\n fn test_block_doc_comment_2() {\n     create_default_session_globals_then(|| {\n         let comment = \"\\n * Test\\n *  Test\\n\";\n-        let stripped = beautify_doc_string(Symbol::intern(comment));\n+        let stripped = beautify_doc_string(Symbol::intern(comment), CommentKind::Block);\n         assert_eq!(stripped.as_str(), \" Test\\n  Test\");\n     })\n }\n@@ -23,21 +23,21 @@ fn test_block_doc_comment_2() {\n fn test_block_doc_comment_3() {\n     create_default_session_globals_then(|| {\n         let comment = \"\\n let a: *i32;\\n *a = 5;\\n\";\n-        let stripped = beautify_doc_string(Symbol::intern(comment));\n+        let stripped = beautify_doc_string(Symbol::intern(comment), CommentKind::Block);\n         assert_eq!(stripped.as_str(), \" let a: *i32;\\n *a = 5;\");\n     })\n }\n \n #[test]\n fn test_line_doc_comment() {\n     create_default_session_globals_then(|| {\n-        let stripped = beautify_doc_string(Symbol::intern(\" test\"));\n+        let stripped = beautify_doc_string(Symbol::intern(\" test\"), CommentKind::Line);\n         assert_eq!(stripped.as_str(), \" test\");\n-        let stripped = beautify_doc_string(Symbol::intern(\"! test\"));\n+        let stripped = beautify_doc_string(Symbol::intern(\"! test\"), CommentKind::Line);\n         assert_eq!(stripped.as_str(), \"! test\");\n-        let stripped = beautify_doc_string(Symbol::intern(\"test\"));\n+        let stripped = beautify_doc_string(Symbol::intern(\"test\"), CommentKind::Line);\n         assert_eq!(stripped.as_str(), \"test\");\n-        let stripped = beautify_doc_string(Symbol::intern(\"!test\"));\n+        let stripped = beautify_doc_string(Symbol::intern(\"!test\"), CommentKind::Line);\n         assert_eq!(stripped.as_str(), \"!test\");\n     })\n }"}, {"sha": "acf65259f61cf03a07ec42dc0fa5f7f66583e390", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -667,7 +667,7 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n         cmd.env_remove(k);\n     }\n \n-    if sess.opts.debugging_opts.print_link_args {\n+    if sess.opts.prints.contains(&PrintRequest::LinkArgs) {\n         println!(\"{:?}\", &cmd);\n     }\n "}, {"sha": "19fa6812b45d9ff3c957ca0d021f22712daad686", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -645,9 +645,9 @@ impl RustcDefaultCalls {\n         temps_dir: &Option<PathBuf>,\n     ) -> Compilation {\n         use rustc_session::config::PrintRequest::*;\n-        // PrintRequest::NativeStaticLibs is special - printed during linking\n+        // NativeStaticLibs and LinkArgs are special - printed during linking\n         // (empty iterator returns true)\n-        if sess.opts.prints.iter().all(|&p| p == PrintRequest::NativeStaticLibs) {\n+        if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n             return Compilation::Continue;\n         }\n \n@@ -738,7 +738,8 @@ impl RustcDefaultCalls {\n                     codegen_backend.print(*req, sess);\n                 }\n                 // Any output here interferes with Cargo's parsing of other printed output\n-                PrintRequest::NativeStaticLibs => {}\n+                NativeStaticLibs => {}\n+                LinkArgs => {}\n             }\n         }\n         Compilation::Stop"}, {"sha": "a9dbdd483fe6f7c3bd2f6bf61b09eb57febcde2e", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2726,6 +2726,10 @@ pub struct FnHeader {\n }\n \n impl FnHeader {\n+    pub fn is_async(&self) -> bool {\n+        matches!(&self.asyncness, IsAsync::Async)\n+    }\n+\n     pub fn is_const(&self) -> bool {\n         matches!(&self.constness, Constness::Const)\n     }\n@@ -3169,7 +3173,7 @@ impl<'hir> Node<'hir> {\n         }\n     }\n \n-    pub fn fn_decl(&self) -> Option<&FnDecl<'hir>> {\n+    pub fn fn_decl(&self) -> Option<&'hir FnDecl<'hir>> {\n         match self {\n             Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(fn_sig, _), .. })\n             | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(fn_sig, _), .. })\n@@ -3181,6 +3185,15 @@ impl<'hir> Node<'hir> {\n         }\n     }\n \n+    pub fn fn_sig(&self) -> Option<&'hir FnSig<'hir>> {\n+        match self {\n+            Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(fn_sig, _), .. })\n+            | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(fn_sig, _), .. })\n+            | Node::Item(Item { kind: ItemKind::Fn(fn_sig, _, _), .. }) => Some(fn_sig),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn body_id(&self) -> Option<BodyId> {\n         match self {\n             Node::TraitItem(TraitItem {"}, {"sha": "14ab635a2ae2b05cac26898141ca96f21fd42b83", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -65,11 +65,11 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::dep_graph::DepContext;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{\n     self,\n+    error::TypeError,\n     subst::{GenericArgKind, Subst, SubstsRef},\n-    Region, Ty, TyCtxt, TypeFoldable,\n+    Binder, Region, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::{sym, BytePos, DesugaringKind, MultiSpan, Pos, Span};\n use rustc_target::spec::abi;\n@@ -1765,7 +1765,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found, terr);\n     }\n \n-    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         if let ty::Opaque(def_id, substs) = ty.kind() {\n             let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n             // Future::Output\n@@ -1775,13 +1775,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             for (predicate, _) in bounds {\n                 let predicate = predicate.subst(self.tcx, substs);\n-                if let ty::PredicateKind::Projection(projection_predicate) =\n-                    predicate.kind().skip_binder()\n-                {\n-                    if projection_predicate.projection_ty.item_def_id == item_def_id {\n-                        // We don't account for multiple `Future::Output = Ty` contraints.\n-                        return projection_predicate.term.ty();\n-                    }\n+                let output = predicate\n+                    .kind()\n+                    .map_bound(|kind| match kind {\n+                        ty::PredicateKind::Projection(projection_predicate)\n+                            if projection_predicate.projection_ty.item_def_id == item_def_id =>\n+                        {\n+                            projection_predicate.term.ty()\n+                        }\n+                        _ => None,\n+                    })\n+                    .transpose();\n+                if output.is_some() {\n+                    // We don't account for multiple `Future::Output = Ty` contraints.\n+                    return output;\n                 }\n             }\n         }\n@@ -1823,8 +1830,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         match (\n-            self.get_impl_future_output_ty(exp_found.expected),\n-            self.get_impl_future_output_ty(exp_found.found),\n+            self.get_impl_future_output_ty(exp_found.expected).map(Binder::skip_binder),\n+            self.get_impl_future_output_ty(exp_found.found).map(Binder::skip_binder),\n         ) {\n             (Some(exp), Some(found)) if same_type_modulo_infer(exp, found) => match cause.code() {\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {"}, {"sha": "4eec492b3aeb9d4b7c2d9ac3e64a1322e6b50462", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 33, "deletions": 76, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -106,90 +106,47 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             None => String::new(),\n         };\n \n-        let (span_1, span_2, main_label, span_label, future_return_type) =\n-            match (sup_is_ret_type, sub_is_ret_type) {\n-                (None, None) => {\n-                    let (main_label_1, span_label_1) = if ty_sup.hir_id == ty_sub.hir_id {\n-                        (\n-                            \"this type is declared with multiple lifetimes...\".to_owned(),\n-                            \"...but data with one lifetime flows into the other here\".to_owned(),\n-                        )\n-                    } else {\n-                        (\n-                            \"these two types are declared with different lifetimes...\".to_owned(),\n-                            format!(\"...but data{} flows{} here\", span_label_var1, span_label_var2),\n-                        )\n-                    };\n-                    (ty_sup.span, ty_sub.span, main_label_1, span_label_1, None)\n-                }\n+        debug!(\n+            \"try_report_anon_anon_conflict: sub_is_ret_type={:?} sup_is_ret_type={:?}\",\n+            sub_is_ret_type, sup_is_ret_type\n+        );\n \n-                (Some(ret_span), _) => {\n-                    let sup_future = self.future_return_type(scope_def_id_sup);\n-                    let (return_type, action) = if sup_future.is_some() {\n-                        (\"returned future\", \"held across an await point\")\n-                    } else {\n-                        (\"return type\", \"returned\")\n-                    };\n+        let mut err = struct_span_err!(self.tcx().sess, span, E0623, \"lifetime mismatch\");\n \n-                    (\n-                        ty_sub.span,\n-                        ret_span,\n-                        format!(\n-                            \"this parameter and the {} are declared with different lifetimes...\",\n-                            return_type\n-                        ),\n-                        format!(\"...but data{} is {} here\", span_label_var1, action),\n-                        sup_future,\n-                    )\n-                }\n-                (_, Some(ret_span)) => {\n-                    let sub_future = self.future_return_type(scope_def_id_sub);\n-                    let (return_type, action) = if sub_future.is_some() {\n-                        (\"returned future\", \"held across an await point\")\n-                    } else {\n-                        (\"return type\", \"returned\")\n-                    };\n+        match (sup_is_ret_type, sub_is_ret_type) {\n+            (ret_capture @ Some(ret_span), _) | (_, ret_capture @ Some(ret_span)) => {\n+                let param_span =\n+                    if sup_is_ret_type == ret_capture { ty_sub.span } else { ty_sup.span };\n+\n+                err.span_label(\n+                    param_span,\n+                    \"this parameter and the return type are declared with different lifetimes...\",\n+                );\n+                err.span_label(ret_span, \"\");\n+                err.span_label(span, format!(\"...but data{} is returned here\", span_label_var1));\n+            }\n \n-                    (\n+            (None, None) => {\n+                if ty_sup.hir_id == ty_sub.hir_id {\n+                    err.span_label(ty_sup.span, \"this type is declared with multiple lifetimes...\");\n+                    err.span_label(ty_sub.span, \"\");\n+                    err.span_label(span, \"...but data with one lifetime flows into the other here\");\n+                } else {\n+                    err.span_label(\n                         ty_sup.span,\n-                        ret_span,\n-                        format!(\n-                            \"this parameter and the {} are declared with different lifetimes...\",\n-                            return_type\n-                        ),\n-                        format!(\"...but data{} is {} here\", span_label_var1, action),\n-                        sub_future,\n-                    )\n+                        \"these two types are declared with different lifetimes...\",\n+                    );\n+                    err.span_label(ty_sub.span, \"\");\n+                    err.span_label(\n+                        span,\n+                        format!(\"...but data{} flows{} here\", span_label_var1, span_label_var2),\n+                    );\n                 }\n-            };\n-\n-        let mut err = struct_span_err!(self.tcx().sess, span, E0623, \"lifetime mismatch\");\n-\n-        err.span_label(span_1, main_label);\n-        err.span_label(span_2, String::new());\n-        err.span_label(span, span_label);\n+            }\n+        }\n \n         self.suggest_adding_lifetime_params(sub, ty_sup, ty_sub, &mut err);\n \n-        if let Some(t) = future_return_type {\n-            let snip = self\n-                .tcx()\n-                .sess\n-                .source_map()\n-                .span_to_snippet(t.span)\n-                .ok()\n-                .and_then(|s| match (&t.kind, s.as_str()) {\n-                    (rustc_hir::TyKind::Tup(&[]), \"\") => Some(\"()\".to_string()),\n-                    (_, \"\") => None,\n-                    _ => Some(s),\n-                })\n-                .unwrap_or_else(|| \"{unnamed_type}\".to_string());\n-\n-            err.span_label(\n-                t.span,\n-                &format!(\"this `async fn` implicitly returns an `impl Future<Output = {}>`\", snip),\n-            );\n-        }\n         err.emit();\n         Some(ErrorReported)\n     }"}, {"sha": "b1535701bb399dc86fbda3a1f0c57c1a3b63e75e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,6 +1,5 @@\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::Node;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime as rl;\n@@ -25,25 +24,19 @@ pub(crate) fn find_anon_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     region: Region<'tcx>,\n     br: &ty::BoundRegionKind,\n-) -> Option<(&'tcx hir::Ty<'tcx>, &'tcx hir::FnDecl<'tcx>)> {\n+) -> Option<(&'tcx hir::Ty<'tcx>, &'tcx hir::FnSig<'tcx>)> {\n     if let Some(anon_reg) = tcx.is_suitable_region(region) {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n-        let fndecl = match tcx.hir().get(hir_id) {\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n-            | Node::TraitItem(&hir::TraitItem {\n-                kind: hir::TraitItemKind::Fn(ref m, ..), ..\n-            })\n-            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(ref m, ..), .. }) => {\n-                &m.decl\n-            }\n-            _ => return None,\n+        let Some(fn_sig) = tcx.hir().get(hir_id).fn_sig() else {\n+            return None\n         };\n \n-        fndecl\n+        fn_sig\n+            .decl\n             .inputs\n             .iter()\n             .find_map(|arg| find_component_for_bound_region(tcx, arg, br))\n-            .map(|ty| (ty, &**fndecl))\n+            .map(|ty| (ty, fn_sig))\n     } else {\n         None\n     }"}, {"sha": "6d71d702cc89b069950d2cf733d37d07eb932b42", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 26, "deletions": 65, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -4,7 +4,7 @@\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_middle::ty::{self, DefIdTree, Region, Ty};\n+use rustc_middle::ty::{self, Binder, DefIdTree, Region, Ty, TypeFoldable};\n use rustc_span::Span;\n \n /// Information about the anonymous region we are searching for.\n@@ -94,81 +94,42 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             })\n     }\n \n-    pub(super) fn future_return_type(\n-        &self,\n-        local_def_id: LocalDefId,\n-    ) -> Option<&rustc_hir::Ty<'_>> {\n-        if let Some(hir::IsAsync::Async) = self.asyncness(local_def_id) {\n-            if let rustc_middle::ty::Opaque(def_id, _) =\n-                self.tcx().type_of(local_def_id).fn_sig(self.tcx()).output().skip_binder().kind()\n-            {\n-                match self.tcx().hir().get_if_local(*def_id) {\n-                    Some(hir::Node::Item(hir::Item {\n-                        kind:\n-                            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                bounds,\n-                                origin: hir::OpaqueTyOrigin::AsyncFn(..),\n-                                ..\n-                            }),\n-                        ..\n-                    })) => {\n-                        for b in bounds.iter() {\n-                            if let hir::GenericBound::LangItemTrait(\n-                                hir::LangItem::Future,\n-                                _span,\n-                                _hir_id,\n-                                generic_args,\n-                            ) = b\n-                            {\n-                                for type_binding in generic_args.bindings.iter() {\n-                                    if type_binding.ident.name == rustc_span::sym::Output {\n-                                        if let hir::TypeBindingKind::Equality {\n-                                            term: hir::Term::Ty(ty),\n-                                        } = type_binding.kind\n-                                        {\n-                                            return Some(ty);\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n-    pub(super) fn asyncness(&self, local_def_id: LocalDefId) -> Option<hir::IsAsync> {\n-        // similar to the asyncness fn in rustc_ty_utils::ty\n-        let hir_id = self.tcx().hir().local_def_id_to_hir_id(local_def_id);\n-        let node = self.tcx().hir().get(hir_id);\n-        let fn_kind = node.fn_kind()?;\n-        Some(fn_kind.asyncness())\n-    }\n-\n     // Here, we check for the case where the anonymous region\n-    // is in the return type.\n+    // is in the return type as written by the user.\n     // FIXME(#42703) - Need to handle certain cases here.\n     pub(super) fn is_return_type_anon(\n         &self,\n         scope_def_id: LocalDefId,\n         br: ty::BoundRegionKind,\n-        decl: &hir::FnDecl<'_>,\n+        hir_sig: &hir::FnSig<'_>,\n     ) -> Option<Span> {\n-        let ret_ty = self.tcx().type_of(scope_def_id);\n-        if let ty::FnDef(_, _) = ret_ty.kind() {\n-            let sig = ret_ty.fn_sig(self.tcx());\n-            let late_bound_regions =\n-                self.tcx().collect_referenced_late_bound_regions(&sig.output());\n-            if late_bound_regions.iter().any(|r| *r == br) {\n-                return Some(decl.output.span());\n-            }\n+        let fn_ty = self.tcx().type_of(scope_def_id);\n+        if let ty::FnDef(_, _) = fn_ty.kind() {\n+            let ret_ty = fn_ty.fn_sig(self.tcx()).output();\n+            let span = hir_sig.decl.output.span();\n+            let future_output = if hir_sig.header.is_async() {\n+                ret_ty.map_bound(|ty| self.infcx.get_impl_future_output_ty(ty)).transpose()\n+            } else {\n+                None\n+            };\n+            return match future_output {\n+                Some(output) if self.includes_region(output, br) => Some(span),\n+                None if self.includes_region(ret_ty, br) => Some(span),\n+                _ => None,\n+            };\n         }\n         None\n     }\n \n+    fn includes_region(\n+        &self,\n+        ty: Binder<'tcx, impl TypeFoldable<'tcx>>,\n+        region: ty::BoundRegionKind,\n+    ) -> bool {\n+        let late_bound_regions = self.tcx().collect_referenced_late_bound_regions(&ty);\n+        late_bound_regions.iter().any(|r| *r == region)\n+    }\n+\n     // Here we check for the case where anonymous region\n     // corresponds to self and if yes, we display E0312.\n     // FIXME(#42700) - Need to format self properly to"}, {"sha": "44acbd3cf2159d592a0523de7ed609883e5ed6e8", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -678,7 +678,6 @@ fn test_debugging_options_tracking_hash() {\n     // `pre_link_arg` is omitted because it just forwards to `pre_link_args`.\n     untracked!(pre_link_args, vec![String::from(\"abc\"), String::from(\"def\")]);\n     untracked!(profile_closures, true);\n-    untracked!(print_link_args, true);\n     untracked!(print_llvm_passes, true);\n     untracked!(print_mono_items, Some(String::from(\"abc\")));\n     untracked!(print_type_sizes, true);"}, {"sha": "38e1669d331977ed5207eba26218ed452f1008dd", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1247,7 +1247,7 @@ declare_lint! {\n     /// [`UnsafeCell`]: https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html\n     MUTABLE_TRANSMUTES,\n     Deny,\n-    \"mutating transmuted &mut T from &T may cause undefined behavior\"\n+    \"transmuting &T to &mut T is undefined behavior, even if the reference is unused\"\n }\n \n declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n@@ -1259,8 +1259,8 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n             if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n-                let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n-                               consider instead using an UnsafeCell\";\n+                let msg = \"transmuting &T to &mut T is undefined behavior, \\\n+                    even if the reference is unused, consider instead using an UnsafeCell\";\n                 cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| lint.build(msg).emit());\n             }\n         }"}, {"sha": "8d591d6781235d6861ece7b63210cd0fc7073591", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1210,11 +1210,25 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(Error(DelaySpanBugEmitted(())))\n     }\n \n-    /// Like `err` but for constants.\n+    /// Like [TyCtxt::ty_error] but for constants.\n     #[track_caller]\n     pub fn const_error(self, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n-        self.sess\n-            .delay_span_bug(DUMMY_SP, \"ty::ConstKind::Error constructed but no error reported.\");\n+        self.const_error_with_message(\n+            ty,\n+            DUMMY_SP,\n+            \"ty::ConstKind::Error constructed but no error reported\",\n+        )\n+    }\n+\n+    /// Like [TyCtxt::ty_error_with_message] but for constants.\n+    #[track_caller]\n+    pub fn const_error_with_message<S: Into<MultiSpan>>(\n+        self,\n+        ty: Ty<'tcx>,\n+        span: S,\n+        msg: &str,\n+    ) -> &'tcx Const<'tcx> {\n+        self.sess.delay_span_bug(span, msg);\n         self.mk_const(ty::Const { val: ty::ConstKind::Error(DelaySpanBugEmitted(())), ty })\n     }\n "}, {"sha": "cda9ba9dcc87ff5c982382777bcfbd6b47cb8416", "filename": "compiler/rustc_mir_transform/src/uninhabited_enum_branching.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -3,8 +3,7 @@\n use crate::MirPass;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_middle::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, SwitchTargets,\n-    TerminatorKind,\n+    BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, SwitchTargets, TerminatorKind,\n };\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{Ty, TyCtxt};\n@@ -56,7 +55,10 @@ fn variant_discriminants<'tcx>(\n     match &layout.variants {\n         Variants::Single { index } => {\n             let mut res = FxHashSet::default();\n-            res.insert(index.as_u32() as u128);\n+            res.insert(\n+                ty.discriminant_for_variant(tcx, *index)\n+                    .map_or(index.as_u32() as u128, |discr| discr.val),\n+            );\n             res\n         }\n         Variants::Multiple { variants, .. } => variants\n@@ -75,16 +77,9 @@ impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        if body.source.promoted.is_some() {\n-            return;\n-        }\n-\n         trace!(\"UninhabitedEnumBranching starting for {:?}\", body.source);\n \n-        let basic_block_count = body.basic_blocks().len();\n-\n-        for bb in 0..basic_block_count {\n-            let bb = BasicBlock::from_usize(bb);\n+        for bb in body.basic_blocks().indices() {\n             trace!(\"processing block {:?}\", bb);\n \n             let Some(discriminant_ty) = get_switched_on_type(&body.basic_blocks()[bb], tcx, body) else {"}, {"sha": "0b4579b299d099cec7e674eb2fa77fc889f03fd5", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1148,19 +1148,11 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n                 if self.visit(ty).is_break() {\n                     return;\n                 }\n+            } else {\n+                // We don't do anything for const infers here.\n             }\n         } else {\n-            let local_id = self.tcx.hir().local_def_id(inf.hir_id);\n-            if let Some(did) = self.tcx.opt_const_param_of(local_id) {\n-                if self.visit_def_id(did, \"inferred\", &\"\").is_break() {\n-                    return;\n-                }\n-            }\n-\n-            // FIXME see above note for same issue.\n-            if self.visit(rustc_typeck::hir_ty_to_ty(self.tcx, &inf.to_ty())).is_break() {\n-                return;\n-            }\n+            bug!(\"visit_infer without typeck_results\");\n         }\n         intravisit::walk_inf(self, inf);\n     }"}, {"sha": "b95fe1b0549bd68232e4dc96374d42c49e66dcf7", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -821,9 +821,9 @@ impl<'tcx> SaveContext<'tcx> {\n         let mut result = String::new();\n \n         for attr in attrs {\n-            if let Some(val) = attr.doc_str() {\n+            if let Some((val, kind)) = attr.doc_str_and_comment_kind() {\n                 // FIXME: Should save-analysis beautify doc strings itself or leave it to users?\n-                result.push_str(beautify_doc_string(val).as_str());\n+                result.push_str(beautify_doc_string(val, kind).as_str());\n                 result.push('\\n');\n             }\n         }"}, {"sha": "92ad0723f4879f31690307761dffb600296f75ce", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -565,6 +565,7 @@ pub enum PrintRequest {\n     TargetSpec,\n     NativeStaticLibs,\n     StackProtectorStrategies,\n+    LinkArgs,\n }\n \n #[derive(Copy, Clone)]\n@@ -1187,7 +1188,8 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n             \"Compiler information to print on stdout\",\n             \"[crate-name|file-names|sysroot|target-libdir|cfg|target-list|\\\n              target-cpus|target-features|relocation-models|code-models|\\\n-             tls-models|target-spec-json|native-static-libs|stack-protector-strategies]\",\n+             tls-models|target-spec-json|native-static-libs|stack-protector-strategies\\\n+             link-args]\",\n         ),\n         opt::flagmulti_s(\"g\", \"\", \"Equivalent to -C debuginfo=2\"),\n         opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n@@ -1619,6 +1621,7 @@ fn collect_print_requests(\n                 );\n             }\n         }\n+        \"link-args\" => PrintRequest::LinkArgs,\n         req => early_error(error_format, &format!(\"unknown print request `{}`\", req)),\n     }));\n "}, {"sha": "e7ab8fffdf35c4440f3392151b7590c6eefb193d", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1339,8 +1339,6 @@ options! {\n         See #77382 and #74551.\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"make rustc print the total optimization fuel used by a crate\"),\n-    print_link_args: bool = (false, parse_bool, [UNTRACKED],\n-        \"print the arguments passed to the linker (default: no)\"),\n     print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"print the LLVM optimization passes being run (default: no)\"),\n     print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],"}, {"sha": "d9b3f51b5bd245834b86f14a69a7e6fde24e4051", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -6,7 +6,7 @@ mod errors;\n mod generics;\n \n use crate::bounds::Bounds;\n-use crate::collect::PlaceholderHirTyCollector;\n+use crate::collect::HirPlaceholderCollector;\n use crate::errors::{\n     AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n     TypeofReservedKeywordUsed, ValueOfAssociatedStructAlreadySpecified,\n@@ -2504,7 +2504,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         debug!(?bound_vars);\n \n         // We proactively collect all the inferred type params to emit a single error per fn def.\n-        let mut visitor = PlaceholderHirTyCollector::default();\n+        let mut visitor = HirPlaceholderCollector::default();\n         for ty in decl.inputs {\n             visitor.visit_ty(ty);\n         }"}, {"sha": "f6abeff60cd9468427320a917d0e696abc18ea9f", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1909,7 +1909,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return,\n         };\n         let mut add_label = true;\n-        if let ty::Adt(def, _) = output_ty.kind() {\n+        if let ty::Adt(def, _) = output_ty.skip_binder().kind() {\n             // no field access on enum type\n             if !def.is_enum() {\n                 if def"}, {"sha": "be4c9ec99b9c68a093f24882b520ec5c4f1c75df", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -609,14 +609,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = self.normalize_associated_types_in(expr.span, ty);\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n-                hir::IsAsync::Async => self.tcx.infer_ctxt().enter(|infcx| {\n-                    infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n-                        span_bug!(\n-                            fn_decl.output.span(),\n-                            \"failed to get output type of async function\"\n-                        )\n+                hir::IsAsync::Async => self\n+                    .tcx\n+                    .infer_ctxt()\n+                    .enter(|infcx| {\n+                        infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n+                            span_bug!(\n+                                fn_decl.output.span(),\n+                                \"failed to get output type of async function\"\n+                            )\n+                        })\n                     })\n-                }),\n+                    .skip_binder(),\n                 hir::IsAsync::NotAsync => ty,\n             };\n             if self.can_coerce(found, ty) {"}, {"sha": "96ab800afaffed0f4738907e902c1ee78a19e42e", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1274,7 +1274,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n     ) {\n         let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n-            Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n+            Some(output_ty) => self.resolve_vars_if_possible(output_ty).skip_binder(),\n             _ => return,\n         };\n         let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);"}, {"sha": "cf519a9ab32747be49555c008f9f7893c10aba2d", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -112,9 +112,9 @@ pub struct ItemCtxt<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n #[derive(Default)]\n-crate struct PlaceholderHirTyCollector(crate Vec<Span>);\n+crate struct HirPlaceholderCollector(crate Vec<Span>);\n \n-impl<'v> Visitor<'v> for PlaceholderHirTyCollector {\n+impl<'v> Visitor<'v> for HirPlaceholderCollector {\n     fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n         if let hir::TyKind::Infer = t.kind {\n             self.0.push(t.span);\n@@ -131,6 +131,12 @@ impl<'v> Visitor<'v> for PlaceholderHirTyCollector {\n             _ => {}\n         }\n     }\n+    fn visit_array_length(&mut self, length: &'v hir::ArrayLen) {\n+        if let &hir::ArrayLen::Infer(_, span) = length {\n+            self.0.push(span);\n+        }\n+        intravisit::walk_array_len(self, length)\n+    }\n }\n \n struct CollectItemTypesVisitor<'tcx> {\n@@ -175,7 +181,7 @@ crate fn placeholder_type_error<'tcx>(\n         sugg.push((span, format!(\", {}\", type_name)));\n     }\n \n-    let mut err = bad_placeholder(tcx, \"type\", placeholder_types, kind);\n+    let mut err = bad_placeholder(tcx, placeholder_types, kind);\n \n     // Suggest, but only if it is not a function in const or static\n     if suggest {\n@@ -233,7 +239,7 @@ fn reject_placeholder_type_signatures_in_item<'tcx>(\n         _ => return,\n     };\n \n-    let mut visitor = PlaceholderHirTyCollector::default();\n+    let mut visitor = HirPlaceholderCollector::default();\n     visitor.visit_item(item);\n \n     placeholder_type_error(\n@@ -311,7 +317,6 @@ impl<'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n \n fn bad_placeholder<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    placeholder_kind: &'static str,\n     mut spans: Vec<Span>,\n     kind: &'static str,\n ) -> rustc_errors::DiagnosticBuilder<'tcx> {\n@@ -322,8 +327,7 @@ fn bad_placeholder<'tcx>(\n         tcx.sess,\n         spans.clone(),\n         E0121,\n-        \"the {} placeholder `_` is not allowed within types on item signatures for {}\",\n-        placeholder_kind,\n+        \"the placeholder `_` is not allowed within types on item signatures for {}\",\n         kind\n     );\n     for span in spans {\n@@ -381,7 +385,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n \n     fn ty_infer(&self, _: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n-        self.tcx().ty_error_with_message(span, \"bad_placeholder_type\")\n+        self.tcx().ty_error_with_message(span, \"bad placeholder type\")\n     }\n \n     fn ct_infer(\n@@ -390,13 +394,11 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         _: Option<&ty::GenericParamDef>,\n         span: Span,\n     ) -> &'tcx Const<'tcx> {\n-        bad_placeholder(self.tcx(), \"const\", vec![span], \"generic\").emit();\n-        // Typeck doesn't expect erased regions to be returned from `type_of`.\n         let ty = self.tcx.fold_regions(ty, &mut false, |r, _| match r {\n             ty::ReErased => self.tcx.lifetimes.re_static,\n             _ => r,\n         });\n-        self.tcx().const_error(ty)\n+        self.tcx().const_error_with_message(ty, span, \"bad placeholder constant\")\n     }\n \n     fn projected_ty_from_poly_trait_ref(\n@@ -743,7 +745,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                 match item.kind {\n                     hir::ForeignItemKind::Fn(..) => tcx.ensure().fn_sig(item.def_id),\n                     hir::ForeignItemKind::Static(..) => {\n-                        let mut visitor = PlaceholderHirTyCollector::default();\n+                        let mut visitor = HirPlaceholderCollector::default();\n                         visitor.visit_foreign_item(item);\n                         placeholder_type_error(\n                             tcx,\n@@ -826,7 +828,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                 hir::ItemKind::Const(ty, ..) | hir::ItemKind::Static(ty, ..) => {\n                     // (#75889): Account for `const C: dyn Fn() -> _ = \"\";`\n                     if let hir::TyKind::TraitObject(..) = ty.kind {\n-                        let mut visitor = PlaceholderHirTyCollector::default();\n+                        let mut visitor = HirPlaceholderCollector::default();\n                         visitor.visit_item(it);\n                         placeholder_type_error(\n                             tcx,\n@@ -862,7 +864,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n         hir::TraitItemKind::Const(..) => {\n             tcx.ensure().type_of(trait_item_id.def_id);\n             // Account for `const C: _;`.\n-            let mut visitor = PlaceholderHirTyCollector::default();\n+            let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n             placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"constant\");\n         }\n@@ -871,7 +873,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n             tcx.ensure().item_bounds(trait_item_id.def_id);\n             tcx.ensure().type_of(trait_item_id.def_id);\n             // Account for `type T = _;`.\n-            let mut visitor = PlaceholderHirTyCollector::default();\n+            let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n             placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"associated type\");\n         }\n@@ -880,7 +882,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n             tcx.ensure().item_bounds(trait_item_id.def_id);\n             // #74612: Visit and try to find bad placeholders\n             // even if there is no concrete type.\n-            let mut visitor = PlaceholderHirTyCollector::default();\n+            let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n \n             placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"associated type\");\n@@ -902,7 +904,7 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n         }\n         hir::ImplItemKind::TyAlias(_) => {\n             // Account for `type T = _;`\n-            let mut visitor = PlaceholderHirTyCollector::default();\n+            let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_impl_item(impl_item);\n \n             placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"associated type\");\n@@ -1822,10 +1824,14 @@ fn are_suggestable_generic_args(generic_args: &[hir::GenericArg<'_>]) -> bool {\n /// Whether `ty` is a type with `_` placeholders that can be inferred. Used in diagnostics only to\n /// use inference to provide suggestions for the appropriate type if possible.\n fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n+    debug!(?ty);\n     use hir::TyKind::*;\n     match &ty.kind {\n         Infer => true,\n-        Slice(ty) | Array(ty, _) => is_suggestable_infer_ty(ty),\n+        Slice(ty) => is_suggestable_infer_ty(ty),\n+        Array(ty, length) => {\n+            is_suggestable_infer_ty(ty) || matches!(length, hir::ArrayLen::Infer(_, _))\n+        }\n         Tup(tys) => tys.iter().any(is_suggestable_infer_ty),\n         Ptr(mut_ty) | Rptr(_, mut_ty) => is_suggestable_infer_ty(mut_ty.ty),\n         OpaqueDef(_, generic_args) => are_suggestable_generic_args(generic_args),\n@@ -1877,9 +1883,9 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     });\n                     let fn_sig = ty::Binder::dummy(fn_sig);\n \n-                    let mut visitor = PlaceholderHirTyCollector::default();\n+                    let mut visitor = HirPlaceholderCollector::default();\n                     visitor.visit_ty(ty);\n-                    let mut diag = bad_placeholder(tcx, \"type\", visitor.0, \"return type\");\n+                    let mut diag = bad_placeholder(tcx, visitor.0, \"return type\");\n                     let ret_ty = fn_sig.skip_binder().output();\n                     if !ret_ty.references_error() {\n                         if !ret_ty.is_closure() {"}, {"sha": "63020b7f90f0abe51bd7537e7e3ddbfc3ed95d62", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -20,9 +20,6 @@ use super::{bad_placeholder, is_suggestable_infer_ty};\n /// This should be called using the query `tcx.opt_const_param_of`.\n #[instrument(level = \"debug\", skip(tcx))]\n pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<DefId> {\n-    // FIXME(generic_arg_infer): allow for returning DefIds of inference of\n-    // GenericArg::Infer below. This may require a change where GenericArg::Infer has some flag\n-    // for const or type.\n     use hir::*;\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n@@ -753,7 +750,7 @@ fn infer_placeholder_type<'a>(\n             err.emit();\n         }\n         None => {\n-            let mut diag = bad_placeholder(tcx, \"type\", vec![span], kind);\n+            let mut diag = bad_placeholder(tcx, vec![span], kind);\n \n             if !ty.references_error() {\n                 let mut mk_nameable = MakeNameable::new(tcx);"}, {"sha": "e38c0412a0afe444d14eb4826c1a8582998083f0", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 124, "deletions": 1, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,8 +1,9 @@\n use crate::any::type_name;\n use crate::fmt;\n use crate::intrinsics;\n-use crate::mem::ManuallyDrop;\n+use crate::mem::{self, ManuallyDrop};\n use crate::ptr;\n+use crate::slice;\n \n /// A wrapper type to construct uninitialized instances of `T`.\n ///\n@@ -1160,4 +1161,126 @@ impl<T> MaybeUninit<T> {\n         // SAFETY: Valid elements have just been written into `this` so it is initialized\n         unsafe { MaybeUninit::slice_assume_init_mut(this) }\n     }\n+\n+    /// Returns the contents of this `MaybeUninit` as a slice of potentially uninitialized bytes.\n+    ///\n+    /// Note that even if the contents of a `MaybeUninit` have been initialized, the value may still\n+    /// contain padding bytes which are left uninitialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(maybe_uninit_as_bytes, maybe_uninit_slice)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let val = 0x12345678i32;\n+    /// let uninit = MaybeUninit::new(val);\n+    /// let uninit_bytes = uninit.as_bytes();\n+    /// let bytes = unsafe { MaybeUninit::slice_assume_init_ref(uninit_bytes) };\n+    /// assert_eq!(bytes, val.to_ne_bytes());\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_as_bytes\", issue = \"93092\")]\n+    pub fn as_bytes(&self) -> &[MaybeUninit<u8>] {\n+        // SAFETY: MaybeUninit<u8> is always valid, even for padding bytes\n+        unsafe {\n+            slice::from_raw_parts(self.as_ptr() as *const MaybeUninit<u8>, mem::size_of::<T>())\n+        }\n+    }\n+\n+    /// Returns the contents of this `MaybeUninit` as a mutable slice of potentially uninitialized\n+    /// bytes.\n+    ///\n+    /// Note that even if the contents of a `MaybeUninit` have been initialized, the value may still\n+    /// contain padding bytes which are left uninitialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(maybe_uninit_as_bytes)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let val = 0x12345678i32;\n+    /// let mut uninit = MaybeUninit::new(val);\n+    /// let uninit_bytes = uninit.as_bytes_mut();\n+    /// if cfg!(target_endian = \"little\") {\n+    ///     uninit_bytes[0].write(0xcd);\n+    /// } else {\n+    ///     uninit_bytes[3].write(0xcd);\n+    /// }\n+    /// let val2 = unsafe { uninit.assume_init() };\n+    /// assert_eq!(val2, 0x123456cd);\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_as_bytes\", issue = \"93092\")]\n+    pub fn as_bytes_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n+        // SAFETY: MaybeUninit<u8> is always valid, even for padding bytes\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                self.as_mut_ptr() as *mut MaybeUninit<u8>,\n+                mem::size_of::<T>(),\n+            )\n+        }\n+    }\n+\n+    /// Returns the contents of this slice of `MaybeUninit` as a slice of potentially uninitialized\n+    /// bytes.\n+    ///\n+    /// Note that even if the contents of a `MaybeUninit` have been initialized, the value may still\n+    /// contain padding bytes which are left uninitialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(maybe_uninit_as_bytes, maybe_uninit_write_slice, maybe_uninit_slice)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let uninit = [MaybeUninit::new(0x1234u16), MaybeUninit::new(0x5678u16)];\n+    /// let uninit_bytes = MaybeUninit::slice_as_bytes(&uninit);\n+    /// let bytes = unsafe { MaybeUninit::slice_assume_init_ref(&uninit_bytes) };\n+    /// let val1 = u16::from_ne_bytes(bytes[0..2].try_into().unwrap());\n+    /// let val2 = u16::from_ne_bytes(bytes[2..4].try_into().unwrap());\n+    /// assert_eq!(&[val1, val2], &[0x1234u16, 0x5678u16]);\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_as_bytes\", issue = \"93092\")]\n+    pub fn slice_as_bytes(this: &[MaybeUninit<T>]) -> &[MaybeUninit<u8>] {\n+        // SAFETY: MaybeUninit<u8> is always valid, even for padding bytes\n+        unsafe {\n+            slice::from_raw_parts(\n+                this.as_ptr() as *const MaybeUninit<u8>,\n+                this.len() * mem::size_of::<T>(),\n+            )\n+        }\n+    }\n+\n+    /// Returns the contents of this mutable slice of `MaybeUninit` as a mutable slice of\n+    /// potentially uninitialized bytes.\n+    ///\n+    /// Note that even if the contents of a `MaybeUninit` have been initialized, the value may still\n+    /// contain padding bytes which are left uninitialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(maybe_uninit_as_bytes, maybe_uninit_write_slice, maybe_uninit_slice)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut uninit = [MaybeUninit::<u16>::uninit(), MaybeUninit::<u16>::uninit()];\n+    /// let uninit_bytes = MaybeUninit::slice_as_bytes_mut(&mut uninit);\n+    /// MaybeUninit::write_slice(uninit_bytes, &[0x12, 0x34, 0x56, 0x78]);\n+    /// let vals = unsafe { MaybeUninit::slice_assume_init_ref(&uninit) };\n+    /// if cfg!(target_endian = \"little\") {\n+    ///     assert_eq!(vals, &[0x3412u16, 0x7856u16]);\n+    /// } else {\n+    ///     assert_eq!(vals, &[0x1234u16, 0x5678u16]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_as_bytes\", issue = \"93092\")]\n+    pub fn slice_as_bytes_mut(this: &mut [MaybeUninit<T>]) -> &mut [MaybeUninit<u8>] {\n+        // SAFETY: MaybeUninit<u8> is always valid, even for padding bytes\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                this.as_mut_ptr() as *mut MaybeUninit<u8>,\n+                this.len() * mem::size_of::<T>(),\n+            )\n+        }\n+    }\n }"}, {"sha": "9d6b2fe8c25d845b9811385c57fa3b7f3f79a4a5", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2042,13 +2042,17 @@ pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// # Platform-specific behavior\n ///\n-/// This function currently corresponds to `opendir`, `lstat`, `rm` and `rmdir` functions on Unix\n-/// and the `FindFirstFile`, `GetFileAttributesEx`, `DeleteFile`, and `RemoveDirectory` functions\n-/// on Windows.\n-/// Note that, this [may change in the future][changes].\n+/// This function currently corresponds to `openat`, `fdopendir`, `unlinkat` and `lstat` functions\n+/// on Unix (except for macOS before version 10.10 and REDOX) and the `CreateFileW`,\n+/// `GetFileInformationByHandleEx`, `SetFileInformationByHandle`, and `NtOpenFile` functions on\n+/// Windows. Note that, this [may change in the future][changes].\n ///\n /// [changes]: io#platform-specific-behavior\n ///\n+/// On macOS before version 10.10 and REDOX this function is not protected against time-of-check to\n+/// time-of-use (TOCTOU) race conditions, and should not be used in security-sensitive code on\n+/// those platforms. All other platforms are protected.\n+///\n /// # Errors\n ///\n /// See [`fs::remove_file`] and [`fs::remove_dir`]."}, {"sha": "a62c01ef29b27d59407dec2c1f6410fa657d17d7", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -4,8 +4,10 @@ use crate::fs::{self, File, OpenOptions};\n use crate::io::{ErrorKind, SeekFrom};\n use crate::path::Path;\n use crate::str;\n+use crate::sync::Arc;\n use crate::sys_common::io::test::{tmpdir, TempDir};\n use crate::thread;\n+use crate::time::{Duration, Instant};\n \n use rand::{rngs::StdRng, RngCore, SeedableRng};\n \n@@ -601,6 +603,21 @@ fn recursive_rmdir_of_symlink() {\n     assert!(canary.exists());\n }\n \n+#[test]\n+fn recursive_rmdir_of_file_fails() {\n+    // test we do not delete a directly specified file.\n+    let tmpdir = tmpdir();\n+    let canary = tmpdir.join(\"do_not_delete\");\n+    check!(check!(File::create(&canary)).write(b\"foo\"));\n+    let result = fs::remove_dir_all(&canary);\n+    #[cfg(unix)]\n+    error!(result, \"Not a directory\");\n+    #[cfg(windows)]\n+    error!(result, 267); // ERROR_DIRECTORY - The directory name is invalid.\n+    assert!(result.is_err());\n+    assert!(canary.exists());\n+}\n+\n #[test]\n // only Windows makes a distinction between file and directory symlinks.\n #[cfg(windows)]\n@@ -620,6 +637,59 @@ fn recursive_rmdir_of_file_symlink() {\n     }\n }\n \n+#[test]\n+#[ignore] // takes too much time\n+fn recursive_rmdir_toctou() {\n+    // Test for time-of-check to time-of-use issues.\n+    //\n+    // Scenario:\n+    // The attacker wants to get directory contents deleted, to which he does not have access.\n+    // He has a way to get a privileged Rust binary call `std::fs::remove_dir_all()` on a\n+    // directory he controls, e.g. in his home directory.\n+    //\n+    // The POC sets up the `attack_dest/attack_file` which the attacker wants to have deleted.\n+    // The attacker repeatedly creates a directory and replaces it with a symlink from\n+    // `victim_del` to `attack_dest` while the victim code calls `std::fs::remove_dir_all()`\n+    // on `victim_del`. After a few seconds the attack has succeeded and\n+    // `attack_dest/attack_file` is deleted.\n+    let tmpdir = tmpdir();\n+    let victim_del_path = tmpdir.join(\"victim_del\");\n+    let victim_del_path_clone = victim_del_path.clone();\n+\n+    // setup dest\n+    let attack_dest_dir = tmpdir.join(\"attack_dest\");\n+    let attack_dest_dir = attack_dest_dir.as_path();\n+    fs::create_dir(attack_dest_dir).unwrap();\n+    let attack_dest_file = tmpdir.join(\"attack_dest/attack_file\");\n+    File::create(&attack_dest_file).unwrap();\n+\n+    let drop_canary_arc = Arc::new(());\n+    let drop_canary_weak = Arc::downgrade(&drop_canary_arc);\n+\n+    eprintln!(\"x: {:?}\", &victim_del_path);\n+\n+    // victim just continuously removes `victim_del`\n+    thread::spawn(move || {\n+        while drop_canary_weak.upgrade().is_some() {\n+            let _ = fs::remove_dir_all(&victim_del_path_clone);\n+        }\n+    });\n+\n+    // attacker (could of course be in a separate process)\n+    let start_time = Instant::now();\n+    while Instant::now().duration_since(start_time) < Duration::from_secs(1000) {\n+        if !attack_dest_file.exists() {\n+            panic!(\n+                \"Victim deleted symlinked file outside of victim_del. Attack succeeded in {:?}.\",\n+                Instant::now().duration_since(start_time)\n+            );\n+        }\n+        let _ = fs::create_dir(&victim_del_path);\n+        let _ = fs::remove_dir(&victim_del_path);\n+        let _ = symlink_dir(attack_dest_dir, &victim_del_path);\n+    }\n+}\n+\n #[test]\n fn unicode_path_is_dir() {\n     assert!(Path::new(\".\").is_dir());"}, {"sha": "d0f332fe5e810f9af151697d9cccdb766a5f034b", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -263,7 +263,7 @@ fn default_hook(info: &PanicInfo<'_>) {\n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n     let backtrace_env = if panic_count::get_count() >= 2 {\n-        RustBacktrace::Print(crate::backtrace_rs::PrintFmt::Full)\n+        backtrace::rust_backtrace_print_full()\n     } else {\n         backtrace::rust_backtrace_env()\n     };"}, {"sha": "f8deda93fe2a7797d91fa53e15472395bdebca02", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 274, "deletions": 11, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -64,7 +64,7 @@ use libc::{\n     dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, readdir64_r, stat64,\n };\n \n-pub use crate::sys_common::fs::{remove_dir_all, try_exists};\n+pub use crate::sys_common::fs::try_exists;\n \n pub struct File(FileDesc);\n \n@@ -228,7 +228,7 @@ pub struct DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     ))]\n-    name: Box<[u8]>,\n+    name: CString,\n }\n \n #[derive(Clone, Debug)]\n@@ -455,8 +455,6 @@ impl Iterator for ReadDir {\n         target_os = \"illumos\"\n     ))]\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        use crate::slice;\n-\n         unsafe {\n             loop {\n                 // Although readdir_r(3) would be a correct function to use here because\n@@ -474,14 +472,10 @@ impl Iterator for ReadDir {\n                     };\n                 }\n \n-                let name = (*entry_ptr).d_name.as_ptr();\n-                let namelen = libc::strlen(name) as usize;\n-\n                 let ret = DirEntry {\n                     entry: *entry_ptr,\n-                    name: slice::from_raw_parts(name as *const u8, namelen as usize)\n-                        .to_owned()\n-                        .into_boxed_slice(),\n+                    // d_name is guaranteed to be null-terminated.\n+                    name: CStr::from_ptr((*entry_ptr).d_name.as_ptr()).to_owned(),\n                     dir: Arc::clone(&self.inner),\n                 };\n                 if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n@@ -664,7 +658,21 @@ impl DirEntry {\n         target_os = \"redox\"\n     ))]\n     fn name_bytes(&self) -> &[u8] {\n-        &*self.name\n+        self.name.as_bytes()\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"fuchsia\",\n+        target_os = \"redox\"\n+    )))]\n+    fn name_cstr(&self) -> &CStr {\n+        unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n+    }\n+    #[cfg(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"fuchsia\"))]\n+    fn name_cstr(&self) -> &CStr {\n+        &self.name\n     }\n \n     pub fn file_name_os_str(&self) -> &OsStr {\n@@ -1437,3 +1445,258 @@ pub fn chroot(dir: &Path) -> io::Result<()> {\n     cvt(unsafe { libc::chroot(dir.as_ptr()) })?;\n     Ok(())\n }\n+\n+pub use remove_dir_impl::remove_dir_all;\n+\n+// Fallback for REDOX\n+#[cfg(target_os = \"redox\")]\n+mod remove_dir_impl {\n+    pub use crate::sys_common::fs::remove_dir_all;\n+}\n+\n+// Dynamically choose implementation Macos x86-64: modern for 10.10+, fallback for older versions\n+#[cfg(all(target_os = \"macos\", target_arch = \"x86_64\"))]\n+mod remove_dir_impl {\n+    use super::{cstr, lstat, Dir, InnerReadDir, ReadDir};\n+    use crate::ffi::CStr;\n+    use crate::io;\n+    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n+    use crate::os::unix::prelude::{OwnedFd, RawFd};\n+    use crate::path::{Path, PathBuf};\n+    use crate::sync::Arc;\n+    use crate::sys::weak::weak;\n+    use crate::sys::{cvt, cvt_r};\n+    use libc::{c_char, c_int, DIR};\n+\n+    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n+        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n+        let fd = cvt_r(|| unsafe {\n+            openat.get().unwrap()(\n+                parent_fd.unwrap_or(libc::AT_FDCWD),\n+                p.as_ptr(),\n+                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,\n+            )\n+        })?;\n+        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n+    }\n+\n+    fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)> {\n+        weak!(fn fdopendir(c_int) -> *mut DIR, \"fdopendir$INODE64\");\n+        let ptr = unsafe { fdopendir.get().unwrap()(dir_fd.as_raw_fd()) };\n+        if ptr.is_null() {\n+            return Err(io::Error::last_os_error());\n+        }\n+        let dirp = Dir(ptr);\n+        // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n+        let new_parent_fd = dir_fd.into_raw_fd();\n+        // a valid root is not needed because we do not call any functions involving the full path\n+        // of the DirEntrys.\n+        let dummy_root = PathBuf::new();\n+        Ok((\n+            ReadDir {\n+                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n+                end_of_stream: false,\n+            },\n+            new_parent_fd,\n+        ))\n+    }\n+\n+    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n+        weak!(fn unlinkat(c_int, *const c_char, c_int) -> c_int);\n+\n+        let pcstr = cstr(p)?;\n+\n+        // entry is expected to be a directory, open as such\n+        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+\n+        // open the directory passing ownership of the fd\n+        let (dir, fd) = fdreaddir(fd)?;\n+        for child in dir {\n+            let child = child?;\n+            match child.entry.d_type {\n+                libc::DT_DIR => {\n+                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                }\n+                libc::DT_UNKNOWN => {\n+                    match cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })\n+                    {\n+                        // type unknown - try to unlink\n+                        Err(err) if err.raw_os_error() == Some(libc::EPERM) => {\n+                            // if the file is a directory unlink fails with EPERM\n+                            remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                        }\n+                        result => {\n+                            result?;\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // not a directory -> unlink\n+                    cvt(unsafe { unlinkat.get().unwrap()(fd, child.name_cstr().as_ptr(), 0) })?;\n+                }\n+            }\n+        }\n+\n+        // unlink the directory after removing its contents\n+        cvt(unsafe {\n+            unlinkat.get().unwrap()(\n+                parent_fd.unwrap_or(libc::AT_FDCWD),\n+                pcstr.as_ptr(),\n+                libc::AT_REMOVEDIR,\n+            )\n+        })?;\n+        Ok(())\n+    }\n+\n+    fn remove_dir_all_modern(p: &Path) -> io::Result<()> {\n+        // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n+        // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n+        // into symlinks.\n+        let attr = lstat(p)?;\n+        if attr.file_type().is_symlink() {\n+            crate::fs::remove_file(p)\n+        } else {\n+            remove_dir_all_recursive(None, p)\n+        }\n+    }\n+\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        weak!(fn openat(c_int, *const c_char, c_int) -> c_int);\n+        if openat.get().is_some() {\n+            // openat() is available with macOS 10.10+, just like unlinkat() and fdopendir()\n+            remove_dir_all_modern(p)\n+        } else {\n+            // fall back to classic implementation\n+            crate::sys_common::fs::remove_dir_all(p)\n+        }\n+    }\n+}\n+\n+// Modern implementation using openat(), unlinkat() and fdopendir()\n+#[cfg(not(any(all(target_os = \"macos\", target_arch = \"x86_64\"), target_os = \"redox\")))]\n+mod remove_dir_impl {\n+    use super::{cstr, lstat, Dir, DirEntry, InnerReadDir, ReadDir};\n+    use crate::ffi::CStr;\n+    use crate::io;\n+    use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd};\n+    use crate::os::unix::prelude::{OwnedFd, RawFd};\n+    use crate::path::{Path, PathBuf};\n+    use crate::sync::Arc;\n+    use crate::sys::{cvt, cvt_r};\n+    use libc::{fdopendir, openat, unlinkat};\n+\n+    pub fn openat_nofollow_dironly(parent_fd: Option<RawFd>, p: &CStr) -> io::Result<OwnedFd> {\n+        let fd = cvt_r(|| unsafe {\n+            openat(\n+                parent_fd.unwrap_or(libc::AT_FDCWD),\n+                p.as_ptr(),\n+                libc::O_CLOEXEC | libc::O_RDONLY | libc::O_NOFOLLOW | libc::O_DIRECTORY,\n+            )\n+        })?;\n+        Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n+    }\n+\n+    fn fdreaddir(dir_fd: OwnedFd) -> io::Result<(ReadDir, RawFd)> {\n+        let ptr = unsafe { fdopendir(dir_fd.as_raw_fd()) };\n+        if ptr.is_null() {\n+            return Err(io::Error::last_os_error());\n+        }\n+        let dirp = Dir(ptr);\n+        // file descriptor is automatically closed by libc::closedir() now, so give up ownership\n+        let new_parent_fd = dir_fd.into_raw_fd();\n+        // a valid root is not needed because we do not call any functions involving the full path\n+        // of the DirEntrys.\n+        let dummy_root = PathBuf::new();\n+        Ok((\n+            ReadDir {\n+                inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n+                #[cfg(not(any(\n+                    target_os = \"solaris\",\n+                    target_os = \"illumos\",\n+                    target_os = \"fuchsia\",\n+                    target_os = \"redox\",\n+                )))]\n+                end_of_stream: false,\n+            },\n+            new_parent_fd,\n+        ))\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\",\n+        target_os = \"fuchsia\"\n+    ))]\n+    fn is_dir(_ent: &DirEntry) -> Option<bool> {\n+        None\n+    }\n+\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\",\n+        target_os = \"fuchsia\"\n+    )))]\n+    fn is_dir(ent: &DirEntry) -> Option<bool> {\n+        match ent.entry.d_type {\n+            libc::DT_UNKNOWN => None,\n+            libc::DT_DIR => Some(true),\n+            _ => Some(false),\n+        }\n+    }\n+\n+    fn remove_dir_all_recursive(parent_fd: Option<RawFd>, p: &Path) -> io::Result<()> {\n+        let pcstr = cstr(p)?;\n+\n+        // entry is expected to be a directory, open as such\n+        let fd = openat_nofollow_dironly(parent_fd, &pcstr)?;\n+\n+        // open the directory passing ownership of the fd\n+        let (dir, fd) = fdreaddir(fd)?;\n+        for child in dir {\n+            let child = child?;\n+            match is_dir(&child) {\n+                Some(true) => {\n+                    remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                }\n+                Some(false) => {\n+                    cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) })?;\n+                }\n+                None => match cvt(unsafe { unlinkat(fd, child.name_cstr().as_ptr(), 0) }) {\n+                    // type unknown - try to unlink\n+                    Err(err)\n+                        if err.raw_os_error() == Some(libc::EISDIR)\n+                            || err.raw_os_error() == Some(libc::EPERM) =>\n+                    {\n+                        // if the file is a directory unlink fails with EISDIR on Linux and EPERM everyhwere else\n+                        remove_dir_all_recursive(Some(fd), Path::new(&child.file_name()))?;\n+                    }\n+                    result => {\n+                        result?;\n+                    }\n+                },\n+            }\n+        }\n+\n+        // unlink the directory after removing its contents\n+        cvt(unsafe {\n+            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), pcstr.as_ptr(), libc::AT_REMOVEDIR)\n+        })?;\n+        Ok(())\n+    }\n+\n+    pub fn remove_dir_all(p: &Path) -> io::Result<()> {\n+        // We cannot just call remove_dir_all_recursive() here because that would not delete a passed\n+        // symlink. No need to worry about races, because remove_dir_all_recursive() does not recurse\n+        // into symlinks.\n+        let attr = lstat(p)?;\n+        if attr.file_type().is_symlink() {\n+            crate::fs::remove_file(p)\n+        } else {\n+            remove_dir_all_recursive(None, p)\n+        }\n+    }\n+}"}, {"sha": "da63c068384a2b56a4926360db10c4213646d616", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -73,12 +73,14 @@ impl<F> ExternWeak<F> {\n \n pub(crate) macro dlsym {\n     (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n+         dlsym!(fn $name($($t),*) -> $ret, stringify!($name));\n+    ),\n+    (fn $name:ident($($t:ty),*) -> $ret:ty, $sym:expr) => (\n         static DLSYM: DlsymWeak<unsafe extern \"C\" fn($($t),*) -> $ret> =\n-            DlsymWeak::new(concat!(stringify!($name), '\\0'));\n+            DlsymWeak::new(concat!($sym, '\\0'));\n         let $name = &DLSYM;\n     )\n }\n-\n pub(crate) struct DlsymWeak<F> {\n     name: &'static str,\n     addr: AtomicUsize,"}, {"sha": "5924789d12ba40bb75ef46e06d0efd187b380712", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -16,7 +16,7 @@ use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n-pub use crate::sys_common::fs::{remove_dir_all, try_exists};\n+pub use crate::sys_common::fs::try_exists;\n \n pub struct File {\n     fd: WasiFd,\n@@ -130,6 +130,18 @@ impl FileType {\n     }\n }\n \n+impl ReadDir {\n+    fn new(dir: File, root: PathBuf) -> ReadDir {\n+        ReadDir {\n+            cookie: Some(0),\n+            buf: vec![0; 128],\n+            offset: 0,\n+            cap: 0,\n+            inner: Arc::new(ReadDirInner { dir, root }),\n+        }\n+    }\n+}\n+\n impl fmt::Debug for ReadDir {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"ReadDir\").finish_non_exhaustive()\n@@ -516,13 +528,7 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     opts.directory(true);\n     opts.read(true);\n     let dir = File::open(p, &opts)?;\n-    Ok(ReadDir {\n-        cookie: Some(0),\n-        buf: vec![0; 128],\n-        offset: 0,\n-        cap: 0,\n-        inner: Arc::new(ReadDirInner { dir, root: p.to_path_buf() }),\n-    })\n+    Ok(ReadDir::new(dir, p.to_path_buf()))\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n@@ -716,3 +722,52 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n \n     io::copy(&mut reader, &mut writer)\n }\n+\n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    let (parent, path) = open_parent(path)?;\n+    remove_dir_all_recursive(&parent, &path)\n+}\n+\n+fn remove_dir_all_recursive(parent: &WasiFd, path: &Path) -> io::Result<()> {\n+    // Open up a file descriptor for the directory itself. Note that we don't\n+    // follow symlinks here and we specifically open directories.\n+    //\n+    // At the root invocation of this function this will correctly handle\n+    // symlinks passed to the top-level `remove_dir_all`. At the recursive\n+    // level this will double-check that after the `readdir` call deduced this\n+    // was a directory it's still a directory by the time we open it up.\n+    //\n+    // If the opened file was actually a symlink then the symlink is deleted,\n+    // not the directory recursively.\n+    let mut opts = OpenOptions::new();\n+    opts.lookup_flags(0);\n+    opts.directory(true);\n+    opts.read(true);\n+    let fd = open_at(parent, path, &opts)?;\n+    if fd.file_attr()?.file_type().is_symlink() {\n+        return parent.unlink_file(osstr2str(path.as_ref())?);\n+    }\n+\n+    // this \"root\" is only used by `DirEntry::path` which we don't use below so\n+    // it's ok for this to be a bogus value\n+    let dummy_root = PathBuf::new();\n+\n+    // Iterate over all the entries in this directory, and travel recursively if\n+    // necessary\n+    for entry in ReadDir::new(fd, dummy_root) {\n+        let entry = entry?;\n+        let path = crate::str::from_utf8(&entry.name).map_err(|_| {\n+            io::Error::new_const(io::ErrorKind::Uncategorized, &\"invalid utf-8 file name found\")\n+        })?;\n+\n+        if entry.file_type()?.is_dir() {\n+            remove_dir_all_recursive(&entry.inner.dir.fd, path.as_ref())?;\n+        } else {\n+            entry.inner.dir.fd.unlink_file(path)?;\n+        }\n+    }\n+\n+    // Once all this directory's contents are deleted it should be safe to\n+    // delete the directory tiself.\n+    parent.remove_directory(osstr2str(path.as_ref())?)\n+}"}, {"sha": "09d3661e4fd52d0b961f5e8fcaf898a3fe21ef71", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 114, "deletions": 10, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -4,6 +4,7 @@\n #![cfg_attr(test, allow(dead_code))]\n #![unstable(issue = \"none\", feature = \"windows_c\")]\n \n+use crate::mem;\n use crate::os::raw::NonZero_c_ulong;\n use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n use crate::ptr;\n@@ -36,6 +37,7 @@ pub type USHORT = c_ushort;\n pub type SIZE_T = usize;\n pub type WORD = u16;\n pub type CHAR = c_char;\n+pub type CCHAR = c_char;\n pub type ULONG_PTR = usize;\n pub type ULONG = c_ulong;\n pub type NTSTATUS = LONG;\n@@ -86,16 +88,21 @@ pub const FILE_SHARE_DELETE: DWORD = 0x4;\n pub const FILE_SHARE_READ: DWORD = 0x1;\n pub const FILE_SHARE_WRITE: DWORD = 0x2;\n \n+pub const FILE_OPEN_REPARSE_POINT: ULONG = 0x200000;\n+pub const OBJ_DONT_REPARSE: ULONG = 0x1000;\n+\n pub const CREATE_ALWAYS: DWORD = 2;\n pub const CREATE_NEW: DWORD = 1;\n pub const OPEN_ALWAYS: DWORD = 4;\n pub const OPEN_EXISTING: DWORD = 3;\n pub const TRUNCATE_EXISTING: DWORD = 5;\n \n+pub const FILE_LIST_DIRECTORY: DWORD = 0x1;\n pub const FILE_WRITE_DATA: DWORD = 0x00000002;\n pub const FILE_APPEND_DATA: DWORD = 0x00000004;\n pub const FILE_WRITE_EA: DWORD = 0x00000010;\n pub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n+pub const DELETE: DWORD = 0x10000;\n pub const READ_CONTROL: DWORD = 0x00020000;\n pub const SYNCHRONIZE: DWORD = 0x00100000;\n pub const GENERIC_READ: DWORD = 0x80000000;\n@@ -261,9 +268,61 @@ pub const FD_SETSIZE: usize = 64;\n pub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n \n pub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n+pub const STATUS_DELETE_PENDING: NTSTATUS = 0xc0000056_u32 as _;\n+pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n+\n+// Equivalent to the `NT_SUCCESS` C preprocessor macro.\n+// See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n+pub fn nt_success(status: NTSTATUS) -> bool {\n+    status >= 0\n+}\n \n pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG: DWORD = 0x00000002;\n \n+#[repr(C)]\n+pub struct UNICODE_STRING {\n+    pub Length: u16,\n+    pub MaximumLength: u16,\n+    pub Buffer: *mut u16,\n+}\n+impl UNICODE_STRING {\n+    pub fn from_ref(slice: &[u16]) -> Self {\n+        let len = slice.len() * mem::size_of::<u16>();\n+        Self { Length: len as _, MaximumLength: len as _, Buffer: slice.as_ptr() as _ }\n+    }\n+}\n+#[repr(C)]\n+pub struct OBJECT_ATTRIBUTES {\n+    pub Length: ULONG,\n+    pub RootDirectory: HANDLE,\n+    pub ObjectName: *const UNICODE_STRING,\n+    pub Attributes: ULONG,\n+    pub SecurityDescriptor: *mut c_void,\n+    pub SecurityQualityOfService: *mut c_void,\n+}\n+impl Default for OBJECT_ATTRIBUTES {\n+    fn default() -> Self {\n+        Self {\n+            Length: mem::size_of::<Self>() as _,\n+            RootDirectory: ptr::null_mut(),\n+            ObjectName: ptr::null_mut(),\n+            Attributes: 0,\n+            SecurityDescriptor: ptr::null_mut(),\n+            SecurityQualityOfService: ptr::null_mut(),\n+        }\n+    }\n+}\n+#[repr(C)]\n+pub struct IO_STATUS_BLOCK {\n+    pub Pointer: *mut c_void,\n+    pub Information: usize,\n+}\n+impl Default for IO_STATUS_BLOCK {\n+    fn default() -> Self {\n+        Self { Pointer: ptr::null_mut(), Information: 0 }\n+    }\n+}\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -353,9 +412,43 @@ pub enum FILE_INFO_BY_HANDLE_CLASS {\n     FileIdInfo = 18,                     // 0x12\n     FileIdExtdDirectoryInfo = 19,        // 0x13\n     FileIdExtdDirectoryRestartInfo = 20, // 0x14\n+    FileDispositionInfoEx = 21,          // 0x15, Windows 10 version 1607\n     MaximumFileInfoByHandlesClass,\n }\n \n+#[repr(C)]\n+pub struct FILE_DISPOSITION_INFO {\n+    pub DeleteFile: BOOLEAN,\n+}\n+\n+pub const FILE_DISPOSITION_DELETE: DWORD = 0x1;\n+pub const FILE_DISPOSITION_POSIX_SEMANTICS: DWORD = 0x2;\n+pub const FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE: DWORD = 0x10;\n+\n+#[repr(C)]\n+pub struct FILE_DISPOSITION_INFO_EX {\n+    pub Flags: DWORD,\n+}\n+\n+#[repr(C)]\n+#[derive(Default)]\n+pub struct FILE_ID_BOTH_DIR_INFO {\n+    pub NextEntryOffset: DWORD,\n+    pub FileIndex: DWORD,\n+    pub CreationTime: LARGE_INTEGER,\n+    pub LastAccessTime: LARGE_INTEGER,\n+    pub LastWriteTime: LARGE_INTEGER,\n+    pub ChangeTime: LARGE_INTEGER,\n+    pub EndOfFile: LARGE_INTEGER,\n+    pub AllocationSize: LARGE_INTEGER,\n+    pub FileAttributes: DWORD,\n+    pub FileNameLength: DWORD,\n+    pub EaSize: DWORD,\n+    pub ShortNameLength: CCHAR,\n+    pub ShortName: [WCHAR; 12],\n+    pub FileId: LARGE_INTEGER,\n+    pub FileName: [WCHAR; 1],\n+}\n #[repr(C)]\n pub struct FILE_BASIC_INFO {\n     pub CreationTime: LARGE_INTEGER,\n@@ -750,16 +843,6 @@ if #[cfg(target_vendor = \"uwp\")] {\n         pub DeletePending: BOOLEAN,\n         pub Directory: BOOLEAN,\n     }\n-\n-    #[link(name = \"kernel32\")]\n-    extern \"system\" {\n-        pub fn GetFileInformationByHandleEx(\n-            hFile: HANDLE,\n-            fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n-            lpFileInformation: LPVOID,\n-            dwBufferSize: DWORD,\n-        ) -> BOOL;\n-    }\n }\n }\n \n@@ -949,6 +1032,12 @@ extern \"system\" {\n         cchFilePath: DWORD,\n         dwFlags: DWORD,\n     ) -> DWORD;\n+    pub fn GetFileInformationByHandleEx(\n+        hFile: HANDLE,\n+        fileInfoClass: FILE_INFO_BY_HANDLE_CLASS,\n+        lpFileInformation: LPVOID,\n+        dwBufferSize: DWORD,\n+    ) -> BOOL;\n     pub fn SetFileInformationByHandle(\n         hFile: HANDLE,\n         FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n@@ -1139,6 +1228,21 @@ compat_fn! {\n \n compat_fn! {\n     \"ntdll\":\n+    pub fn NtOpenFile(\n+        FileHandle: *mut HANDLE,\n+        DesiredAccess: ACCESS_MASK,\n+        ObjectAttributes: *const OBJECT_ATTRIBUTES,\n+        IoStatusBlock: *mut IO_STATUS_BLOCK,\n+        ShareAccess: ULONG,\n+        OpenOptions: ULONG\n+    ) -> NTSTATUS {\n+        panic!(\"`NtOpenFile` not available\");\n+    }\n+    pub fn RtlNtStatusToDosError(\n+        Status: NTSTATUS\n+    ) -> ULONG {\n+        panic!(\"`RtlNtStatusToDosError` not available\");\n+    }\n     pub fn NtCreateKeyedEvent(\n         KeyedEventHandle: LPHANDLE,\n         DesiredAccess: ACCESS_MASK,"}, {"sha": "dd21c6b43891f137d3b70e3800e9152c4795c394", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 305, "deletions": 17, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -547,6 +547,218 @@ impl File {\n         })?;\n         Ok(())\n     }\n+    /// Get only basic file information such as attributes and file times.\n+    fn basic_info(&self) -> io::Result<c::FILE_BASIC_INFO> {\n+        unsafe {\n+            let mut info: c::FILE_BASIC_INFO = mem::zeroed();\n+            let size = mem::size_of_val(&info);\n+            cvt(c::GetFileInformationByHandleEx(\n+                self.handle.as_raw_handle(),\n+                c::FileBasicInfo,\n+                &mut info as *mut _ as *mut libc::c_void,\n+                size as c::DWORD,\n+            ))?;\n+            Ok(info)\n+        }\n+    }\n+    /// Delete using POSIX semantics.\n+    ///\n+    /// Files will be deleted as soon as the handle is closed. This is supported\n+    /// for Windows 10 1607 (aka RS1) and later. However some filesystem\n+    /// drivers will not support it even then, e.g. FAT32.\n+    ///\n+    /// If the operation is not supported for this filesystem or OS version\n+    /// then errors will be `ERROR_NOT_SUPPORTED` or `ERROR_INVALID_PARAMETER`.\n+    fn posix_delete(&self) -> io::Result<()> {\n+        let mut info = c::FILE_DISPOSITION_INFO_EX {\n+            Flags: c::FILE_DISPOSITION_DELETE\n+                | c::FILE_DISPOSITION_POSIX_SEMANTICS\n+                | c::FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE,\n+        };\n+        let size = mem::size_of_val(&info);\n+        cvt(unsafe {\n+            c::SetFileInformationByHandle(\n+                self.handle.as_raw_handle(),\n+                c::FileDispositionInfoEx,\n+                &mut info as *mut _ as *mut _,\n+                size as c::DWORD,\n+            )\n+        })?;\n+        Ok(())\n+    }\n+\n+    /// Delete a file using win32 semantics. The file won't actually be deleted\n+    /// until all file handles are closed. However, marking a file for deletion\n+    /// will prevent anyone from opening a new handle to the file.\n+    fn win32_delete(&self) -> io::Result<()> {\n+        let mut info = c::FILE_DISPOSITION_INFO { DeleteFile: c::TRUE as _ };\n+        let size = mem::size_of_val(&info);\n+        cvt(unsafe {\n+            c::SetFileInformationByHandle(\n+                self.handle.as_raw_handle(),\n+                c::FileDispositionInfo,\n+                &mut info as *mut _ as *mut _,\n+                size as c::DWORD,\n+            )\n+        })?;\n+        Ok(())\n+    }\n+\n+    /// Fill the given buffer with as many directory entries as will fit.\n+    /// This will remember its position and continue from the last call unless\n+    /// `restart` is set to `true`.\n+    ///\n+    /// The returned bool indicates if there are more entries or not.\n+    /// It is an error if `self` is not a directory.\n+    ///\n+    /// # Symlinks and other reparse points\n+    ///\n+    /// On Windows a file is either a directory or a non-directory.\n+    /// A symlink directory is simply an empty directory with some \"reparse\" metadata attached.\n+    /// So if you open a link (not its target) and iterate the directory,\n+    /// you will always iterate an empty directory regardless of the target.\n+    fn fill_dir_buff(&self, buffer: &mut DirBuff, restart: bool) -> io::Result<bool> {\n+        let class =\n+            if restart { c::FileIdBothDirectoryRestartInfo } else { c::FileIdBothDirectoryInfo };\n+\n+        unsafe {\n+            let result = cvt(c::GetFileInformationByHandleEx(\n+                self.handle.as_raw_handle(),\n+                class,\n+                buffer.as_mut_ptr().cast(),\n+                buffer.capacity() as _,\n+            ));\n+            match result {\n+                Ok(_) => Ok(true),\n+                Err(e) if e.raw_os_error() == Some(c::ERROR_NO_MORE_FILES as _) => Ok(false),\n+                Err(e) => Err(e),\n+            }\n+        }\n+    }\n+}\n+\n+/// A buffer for holding directory entries.\n+struct DirBuff {\n+    buffer: Vec<u8>,\n+}\n+impl DirBuff {\n+    fn new() -> Self {\n+        const BUFFER_SIZE: usize = 1024;\n+        Self { buffer: vec![0_u8; BUFFER_SIZE] }\n+    }\n+    fn capacity(&self) -> usize {\n+        self.buffer.len()\n+    }\n+    fn as_mut_ptr(&mut self) -> *mut u8 {\n+        self.buffer.as_mut_ptr().cast()\n+    }\n+    /// Returns a `DirBuffIter`.\n+    fn iter(&self) -> DirBuffIter<'_> {\n+        DirBuffIter::new(self)\n+    }\n+}\n+impl AsRef<[u8]> for DirBuff {\n+    fn as_ref(&self) -> &[u8] {\n+        &self.buffer\n+    }\n+}\n+\n+/// An iterator over entries stored in a `DirBuff`.\n+///\n+/// Currently only returns file names (UTF-16 encoded).\n+struct DirBuffIter<'a> {\n+    buffer: Option<&'a [u8]>,\n+    cursor: usize,\n+}\n+impl<'a> DirBuffIter<'a> {\n+    fn new(buffer: &'a DirBuff) -> Self {\n+        Self { buffer: Some(buffer.as_ref()), cursor: 0 }\n+    }\n+}\n+impl<'a> Iterator for DirBuffIter<'a> {\n+    type Item = &'a [u16];\n+    fn next(&mut self) -> Option<Self::Item> {\n+        use crate::mem::size_of;\n+        let buffer = &self.buffer?[self.cursor..];\n+\n+        // Get the name and next entry from the buffer.\n+        // SAFETY: The buffer contains a `FILE_ID_BOTH_DIR_INFO` struct but the\n+        // last field (the file name) is unsized. So an offset has to be\n+        // used to get the file name slice.\n+        let (name, next_entry) = unsafe {\n+            let info = buffer.as_ptr().cast::<c::FILE_ID_BOTH_DIR_INFO>();\n+            let next_entry = (*info).NextEntryOffset as usize;\n+            let name = crate::slice::from_raw_parts(\n+                (*info).FileName.as_ptr().cast::<u16>(),\n+                (*info).FileNameLength as usize / size_of::<u16>(),\n+            );\n+            (name, next_entry)\n+        };\n+\n+        if next_entry == 0 {\n+            self.buffer = None\n+        } else {\n+            self.cursor += next_entry\n+        }\n+\n+        // Skip `.` and `..` pseudo entries.\n+        const DOT: u16 = b'.' as u16;\n+        match name {\n+            [DOT] | [DOT, DOT] => self.next(),\n+            _ => Some(name),\n+        }\n+    }\n+}\n+\n+/// Open a link relative to the parent directory, ensure no symlinks are followed.\n+fn open_link_no_reparse(parent: &File, name: &[u16], access: u32) -> io::Result<File> {\n+    // This is implemented using the lower level `NtOpenFile` function as\n+    // unfortunately opening a file relative to a parent is not supported by\n+    // win32 functions. It is however a fundamental feature of the NT kernel.\n+    //\n+    // See https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntopenfile\n+    unsafe {\n+        let mut handle = ptr::null_mut();\n+        let mut io_status = c::IO_STATUS_BLOCK::default();\n+        let name_str = c::UNICODE_STRING::from_ref(name);\n+        use crate::sync::atomic::{AtomicU32, Ordering};\n+        // The `OBJ_DONT_REPARSE` attribute ensures that we haven't been\n+        // tricked into following a symlink. However, it may not be available in\n+        // earlier versions of Windows.\n+        static ATTRIBUTES: AtomicU32 = AtomicU32::new(c::OBJ_DONT_REPARSE);\n+        let object = c::OBJECT_ATTRIBUTES {\n+            ObjectName: &name_str,\n+            RootDirectory: parent.as_raw_handle(),\n+            Attributes: ATTRIBUTES.load(Ordering::Relaxed),\n+            ..c::OBJECT_ATTRIBUTES::default()\n+        };\n+        let status = c::NtOpenFile(\n+            &mut handle,\n+            access,\n+            &object,\n+            &mut io_status,\n+            c::FILE_SHARE_DELETE | c::FILE_SHARE_READ | c::FILE_SHARE_WRITE,\n+            // If `name` is a symlink then open the link rather than the target.\n+            c::FILE_OPEN_REPARSE_POINT,\n+        );\n+        // Convert an NTSTATUS to the more familiar Win32 error codes (aka \"DosError\")\n+        if c::nt_success(status) {\n+            Ok(File::from_raw_handle(handle))\n+        } else if status == c::STATUS_DELETE_PENDING {\n+            // We make a special exception for `STATUS_DELETE_PENDING` because\n+            // otherwise this will be mapped to `ERROR_ACCESS_DENIED` which is\n+            // very unhelpful.\n+            Err(io::Error::from_raw_os_error(c::ERROR_DELETE_PENDING as _))\n+        } else if status == c::STATUS_INVALID_PARAMETER\n+            && ATTRIBUTES.load(Ordering::Relaxed) == c::OBJ_DONT_REPARSE\n+        {\n+            // Try without `OBJ_DONT_REPARSE`. See above.\n+            ATTRIBUTES.store(0, Ordering::Relaxed);\n+            open_link_no_reparse(parent, name, access)\n+        } else {\n+            Err(io::Error::from_raw_os_error(c::RtlNtStatusToDosError(status) as _))\n+        }\n+    }\n }\n \n impl AsInner<Handle> for File {\n@@ -756,30 +968,106 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n+/// Open a file or directory without following symlinks.\n+fn open_link(path: &Path, access_mode: u32) -> io::Result<File> {\n+    let mut opts = OpenOptions::new();\n+    opts.access_mode(access_mode);\n+    // `FILE_FLAG_BACKUP_SEMANTICS` allows opening directories.\n+    // `FILE_FLAG_OPEN_REPARSE_POINT` opens a link instead of its target.\n+    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | c::FILE_FLAG_OPEN_REPARSE_POINT);\n+    File::open(path, &opts)\n+}\n+\n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    let filetype = lstat(path)?.file_type();\n-    if filetype.is_symlink() {\n-        // On Windows symlinks to files and directories are removed differently.\n-        // rmdir only deletes dir symlinks and junctions, not file symlinks.\n-        rmdir(path)\n+    let file = open_link(path, c::DELETE | c::FILE_LIST_DIRECTORY)?;\n+\n+    // Test if the file is not a directory or a symlink to a directory.\n+    if (file.basic_info()?.FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) == 0 {\n+        return Err(io::Error::from_raw_os_error(c::ERROR_DIRECTORY as _));\n+    }\n+    let mut delete: fn(&File) -> io::Result<()> = File::posix_delete;\n+    let result = match delete(&file) {\n+        Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n+            match remove_dir_all_recursive(&file, delete) {\n+                // Return unexpected errors.\n+                Err(e) if e.kind() != io::ErrorKind::DirectoryNotEmpty => return Err(e),\n+                result => result,\n+            }\n+        }\n+        // If POSIX delete is not supported for this filesystem then fallback to win32 delete.\n+        Err(e)\n+            if e.raw_os_error() == Some(c::ERROR_NOT_SUPPORTED as i32)\n+                || e.raw_os_error() == Some(c::ERROR_INVALID_PARAMETER as i32) =>\n+        {\n+            delete = File::win32_delete;\n+            Err(e)\n+        }\n+        result => result,\n+    };\n+    if result.is_ok() {\n+        Ok(())\n     } else {\n-        remove_dir_all_recursive(path)\n+        // This is a fallback to make sure the directory is actually deleted.\n+        // Otherwise this function is prone to failing with `DirectoryNotEmpty`\n+        // due to possible delays between marking a file for deletion and the\n+        // file actually being deleted from the filesystem.\n+        //\n+        // So we retry a few times before giving up.\n+        for _ in 0..5 {\n+            match remove_dir_all_recursive(&file, delete) {\n+                Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n+                result => return result,\n+            }\n+        }\n+        // Try one last time.\n+        delete(&file)\n     }\n }\n \n-fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n-    for child in readdir(path)? {\n-        let child = child?;\n-        let child_type = child.file_type()?;\n-        if child_type.is_dir() {\n-            remove_dir_all_recursive(&child.path())?;\n-        } else if child_type.is_symlink_dir() {\n-            rmdir(&child.path())?;\n-        } else {\n-            unlink(&child.path())?;\n+fn remove_dir_all_recursive(f: &File, delete: fn(&File) -> io::Result<()>) -> io::Result<()> {\n+    let mut buffer = DirBuff::new();\n+    let mut restart = true;\n+    // Fill the buffer and iterate the entries.\n+    while f.fill_dir_buff(&mut buffer, restart)? {\n+        for name in buffer.iter() {\n+            // Open the file without following symlinks and try deleting it.\n+            // We try opening will all needed permissions and if that is denied\n+            // fallback to opening without `FILE_LIST_DIRECTORY` permission.\n+            // Note `SYNCHRONIZE` permission is needed for synchronous access.\n+            let mut result =\n+                open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE | c::FILE_LIST_DIRECTORY);\n+            if matches!(&result, Err(e) if e.kind() == io::ErrorKind::PermissionDenied) {\n+                result = open_link_no_reparse(&f, name, c::SYNCHRONIZE | c::DELETE);\n+            }\n+            match result {\n+                Ok(file) => match delete(&file) {\n+                    Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {\n+                        // Iterate the directory's files.\n+                        // Ignore `DirectoryNotEmpty` errors here. They will be\n+                        // caught when `remove_dir_all` tries to delete the top\n+                        // level directory. It can then decide if to retry or not.\n+                        match remove_dir_all_recursive(&file, delete) {\n+                            Err(e) if e.kind() == io::ErrorKind::DirectoryNotEmpty => {}\n+                            result => result?,\n+                        }\n+                    }\n+                    result => result?,\n+                },\n+                // Ignore error if a delete is already in progress or the file\n+                // has already been deleted. It also ignores sharing violations\n+                // (where a file is locked by another process) as these are\n+                // usually temporary.\n+                Err(e)\n+                    if e.raw_os_error() == Some(c::ERROR_DELETE_PENDING as _)\n+                        || e.kind() == io::ErrorKind::NotFound\n+                        || e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as _) => {}\n+                Err(e) => return Err(e),\n+            }\n         }\n+        // Continue reading directory entries without restarting from the beginning,\n+        restart = false;\n     }\n-    rmdir(path)\n+    delete(&f)\n }\n \n pub fn readlink(path: &Path) -> io::Result<PathBuf> {"}, {"sha": "dc581a0675b38b95580db6953ffcda293df61cdb", "filename": "library/std/src/sys_common/backtrace.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -150,16 +150,18 @@ pub enum RustBacktrace {\n     RuntimeDisabled,\n }\n \n+// If the `backtrace` feature of this crate isn't enabled quickly return\n+// `Disabled` so this can be constant propagated all over the place to\n+// optimize away callers.\n+#[cfg(not(feature = \"backtrace\"))]\n+pub fn rust_backtrace_env() -> RustBacktrace {\n+    RustBacktrace::Disabled\n+}\n+\n // For now logging is turned off by default, and this function checks to see\n // whether the magical environment variable is present to see if it's turned on.\n+#[cfg(feature = \"backtrace\")]\n pub fn rust_backtrace_env() -> RustBacktrace {\n-    // If the `backtrace` feature of this crate isn't enabled quickly return\n-    // `None` so this can be constant propagated all over the place to turn\n-    // optimize away callers.\n-    if !cfg!(feature = \"backtrace\") {\n-        return RustBacktrace::Disabled;\n-    }\n-\n     // Setting environment variables for Fuchsia components isn't a standard\n     // or easily supported workflow. For now, always display backtraces.\n     if cfg!(target_os = \"fuchsia\") {\n@@ -189,6 +191,15 @@ pub fn rust_backtrace_env() -> RustBacktrace {\n     format\n }\n \n+/// Setting for printing the full backtrace, unless backtraces are completely disabled\n+pub(crate) fn rust_backtrace_print_full() -> RustBacktrace {\n+    if cfg!(feature = \"backtrace\") {\n+        RustBacktrace::Print(PrintFmt::Full)\n+    } else {\n+        RustBacktrace::Disabled\n+    }\n+}\n+\n /// Prints the filename of the backtrace frame.\n ///\n /// See also `output`."}, {"sha": "11925ab9785889e15dc6696b8c02c1322ad3b3e8", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -170,6 +170,12 @@ The valid types of print values are:\n   include a diagnostic note that indicates the linker flags to use when\n   linking the resulting static library. The note starts with the text\n   `native-static-libs:` to make it easier to fetch the output.\n+- `link-args` \u2014 This flag does not disable the `--emit` step. When linking,\n+  this flag causes `rustc` to print the full linker invocation in a\n+  human-readable form. This can be useful when debugging linker options. The\n+  exact format of this debugging output is not a stable guarantee, other than\n+  that it will include the linker executable and the text of each command-line\n+  argument passed to the linker.\n \n [conditional compilation]: ../reference/conditional-compilation.html\n "}, {"sha": "920dd202ee9e40b9869f10d963e9eeb44d55cc67", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1040,9 +1040,9 @@ impl Attributes {\n     ) -> Attributes {\n         let mut doc_strings: Vec<DocFragment> = vec![];\n         let clean_attr = |(attr, parent_module): (&ast::Attribute, Option<DefId>)| {\n-            if let Some(value) = attr.doc_str() {\n+            if let Some((value, kind)) = attr.doc_str_and_comment_kind() {\n                 trace!(\"got doc_str={:?}\", value);\n-                let value = beautify_doc_string(value);\n+                let value = beautify_doc_string(value, kind);\n                 let kind = if attr.is_doc_comment() {\n                     DocFragmentKind::SugaredDoc\n                 } else {"}, {"sha": "8badce8226fd9e67a444b2f6e9ce21cb34b1647f", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -799,58 +799,77 @@ fn assoc_type(\n     }\n }\n \n+/// Writes a span containing the versions at which an item became stable and/or const-stable. For\n+/// example, if the item became stable at 1.0.0, and const-stable at 1.45.0, this function would\n+/// write a span containing \"1.0.0 (const: 1.45.0)\".\n+///\n+/// Returns `true` if a stability annotation was rendered.\n+///\n+/// Stability and const-stability are considered separately. If the item is unstable, no version\n+/// will be written. If the item is const-unstable, \"const: unstable\" will be appended to the\n+/// span, with a link to the tracking issue if present. If an item's stability or const-stability\n+/// version matches the version of its enclosing item, that version will be omitted.\n+///\n+/// Note that it is possible for an unstable function to be const-stable. In that case, the span\n+/// will include the const-stable version, but no stable version will be emitted, as a natural\n+/// consequence of the above rules.\n fn render_stability_since_raw(\n     w: &mut Buffer,\n     ver: Option<Symbol>,\n     const_stability: Option<ConstStability>,\n     containing_ver: Option<Symbol>,\n     containing_const_ver: Option<Symbol>,\n ) -> bool {\n-    let ver = ver.filter(|inner| !inner.is_empty());\n+    let stable_version = ver.filter(|inner| !inner.is_empty() && Some(*inner) != containing_ver);\n \n-    match (ver, const_stability) {\n-        // stable and const stable\n-        (Some(v), Some(ConstStability { level: StabilityLevel::Stable { since }, .. }))\n+    let mut title = String::new();\n+    let mut stability = String::new();\n+\n+    if let Some(ver) = stable_version {\n+        stability.push_str(&ver.as_str());\n+        title.push_str(&format!(\"Stable since Rust version {}\", ver));\n+    }\n+\n+    let const_title_and_stability = match const_stability {\n+        Some(ConstStability { level: StabilityLevel::Stable { since }, .. })\n             if Some(since) != containing_const_ver =>\n         {\n-            write!(\n-                w,\n-                \"<span class=\\\"since\\\" title=\\\"Stable since Rust version {0}, const since {1}\\\">{0} (const: {1})</span>\",\n-                v, since\n-            );\n+            Some((format!(\"const since {}\", since), format!(\"const: {}\", since)))\n         }\n-        // stable and const unstable\n-        (\n-            Some(v),\n-            Some(ConstStability { level: StabilityLevel::Unstable { issue, .. }, feature, .. }),\n-        ) => {\n-            write!(\n-                w,\n-                \"<span class=\\\"since\\\" title=\\\"Stable since Rust version {0}, const unstable\\\">{0} (const: \",\n-                v\n-            );\n-            if let Some(n) = issue {\n-                write!(\n-                    w,\n-                    \"<a href=\\\"https://github.com/rust-lang/rust/issues/{}\\\" title=\\\"Tracking issue for {}\\\">unstable</a>\",\n+        Some(ConstStability { level: StabilityLevel::Unstable { issue, .. }, feature, .. }) => {\n+            let unstable = if let Some(n) = issue {\n+                format!(\n+                    r#\"<a href=\"https://github.com/rust-lang/rust/issues/{}\" title=\"Tracking issue for {}\">unstable</a>\"#,\n                     n, feature\n-                );\n+                )\n             } else {\n-                write!(w, \"unstable\");\n-            }\n-            write!(w, \")</span>\");\n+                String::from(\"unstable\")\n+            };\n+\n+            Some((String::from(\"const unstable\"), format!(\"const: {}\", unstable)))\n         }\n-        // stable\n-        (Some(v), _) if ver != containing_ver => {\n-            write!(\n-                w,\n-                \"<span class=\\\"since\\\" title=\\\"Stable since Rust version {0}\\\">{0}</span>\",\n-                v\n-            );\n+        _ => None,\n+    };\n+\n+    if let Some((const_title, const_stability)) = const_title_and_stability {\n+        if !title.is_empty() {\n+            title.push_str(&format!(\", {}\", const_title));\n+        } else {\n+            title.push_str(&const_title);\n+        }\n+\n+        if !stability.is_empty() {\n+            stability.push_str(&format!(\" ({})\", const_stability));\n+        } else {\n+            stability.push_str(&const_stability);\n         }\n-        _ => return false,\n     }\n-    true\n+\n+    if !stability.is_empty() {\n+        write!(w, r#\"<span class=\"since\" title=\"{}\">{}</span>\"#, title, stability);\n+    }\n+\n+    !stability.is_empty()\n }\n \n fn render_assoc_item("}, {"sha": "d0244351b5973d907995aee75ba8ce37d2582f07", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -148,11 +148,11 @@ h1.fqn {\n }\n .main-heading {\n \tdisplay: flex;\n+\tflex-wrap: wrap;\n+\tjustify-content: space-between;\n+\tborder-bottom: 1px dashed #DDDDDD;\n+\tpadding-bottom: 6px;\n \tmargin-bottom: 15px;\n-\n-\t/* workaround to keep flex from breaking below 700 px width due to the float: right on the nav\n-\t   above the h1 */\n-\tpadding-left: 1px;\n }\n .main-heading a:hover {\n \ttext-decoration: underline;\n@@ -623,11 +623,7 @@ nav.sub {\n \n .content .out-of-band {\n \tflex-grow: 0;\n-\ttext-align: right;\n-\tmargin-left: auto;\n-\tmargin-right: 0;\n \tfont-size: 1.15rem;\n-\tpadding: 0 0 0 12px;\n \tfont-weight: normal;\n \tfloat: right;\n }\n@@ -1748,10 +1744,25 @@ details.rustdoc-toggle[open] > summary.hideme::after {\n \t\tpadding-top: 0px;\n \t}\n \n-\t.rustdoc {\n+\t.rustdoc,\n+\t.main-heading {\n \t\tflex-direction: column;\n \t}\n \n+\t.content .out-of-band {\n+\t\ttext-align: left;\n+\t\tmargin-left: initial;\n+\t\tpadding: initial;\n+\t}\n+\n+\t.content .out-of-band .since::before {\n+\t\tcontent: \"Since \";\n+\t}\n+\n+\t#copy-path {\n+\t\tdisplay: none;\n+\t}\n+\n \t/* Hide the logo and item name from the sidebar. Those are displayed\n \t   in the mobile-topbar instead. */\n \t.sidebar .sidebar-logo,"}, {"sha": "7dbf00420de126c3eec76c09640a3e5ffb766092", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -305,16 +305,15 @@ crate enum FragmentKind {\n \n impl ItemFragment {\n     /// Create a fragment for an associated item.\n-    ///\n-    /// `is_prototype` is whether this associated item is a trait method\n-    /// without a default definition.\n-    fn from_assoc_item(def_id: DefId, kind: ty::AssocKind, is_prototype: bool) -> Self {\n-        match kind {\n+    #[instrument(level = \"debug\")]\n+    fn from_assoc_item(item: &ty::AssocItem) -> Self {\n+        let def_id = item.def_id;\n+        match item.kind {\n             ty::AssocKind::Fn => {\n-                if is_prototype {\n-                    ItemFragment(FragmentKind::TyMethod, def_id)\n-                } else {\n+                if item.defaultness.has_value() {\n                     ItemFragment(FragmentKind::Method, def_id)\n+                } else {\n+                    ItemFragment(FragmentKind::TyMethod, def_id)\n                 }\n             }\n             ty::AssocKind::Const => ItemFragment(FragmentKind::AssociatedConstant, def_id),\n@@ -473,8 +472,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             tcx.associated_items(impl_)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n                 .map(|item| {\n-                    let kind = item.kind;\n-                    let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n+                    let fragment = ItemFragment::from_assoc_item(item);\n                     (Res::Primitive(prim_ty), fragment)\n                 })\n         })\n@@ -726,8 +724,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         .flatten();\n \n                     assoc_item.map(|item| {\n-                        let kind = item.kind;\n-                        let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n+                        let fragment = ItemFragment::from_assoc_item(&item);\n                         (root_res, fragment)\n                     })\n                 })\n@@ -765,20 +762,19 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n-                        let item = resolve_associated_trait_item(\n+                        resolve_associated_trait_item(\n                             tcx.type_of(did),\n                             module_id,\n                             item_name,\n                             ns,\n                             self.cx,\n-                        );\n-                        debug!(\"got associated item {:?}\", item);\n-                        item\n+                        )\n                     });\n \n+                debug!(\"got associated item {:?}\", assoc_item);\n+\n                 if let Some(item) = assoc_item {\n-                    let kind = item.kind;\n-                    let fragment = ItemFragment::from_assoc_item(item.def_id, kind, false);\n+                    let fragment = ItemFragment::from_assoc_item(&item);\n                     return Some((root_res, fragment));\n                 }\n \n@@ -813,11 +809,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 .associated_items(did)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n-                    let fragment = ItemFragment::from_assoc_item(\n-                        item.def_id,\n-                        item.kind,\n-                        !item.defaultness.has_value(),\n-                    );\n+                    let fragment = ItemFragment::from_assoc_item(item);\n                     let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n                     (res, fragment)\n                 }),\n@@ -883,30 +875,56 @@ fn resolve_associated_trait_item<'a>(\n \n     // Next consider explicit impls: `impl MyTrait for MyType`\n     // Give precedence to inherent impls.\n-    let traits = traits_implemented_by(cx, ty, module);\n+    let traits = trait_impls_for(cx, ty, module);\n     debug!(\"considering traits {:?}\", traits);\n-    let mut candidates = traits.iter().filter_map(|&trait_| {\n-        cx.tcx.associated_items(trait_).find_by_name_and_namespace(\n-            cx.tcx,\n-            Ident::with_dummy_span(item_name),\n-            ns,\n-            trait_,\n-        )\n+    let mut candidates = traits.iter().filter_map(|&(impl_, trait_)| {\n+        cx.tcx\n+            .associated_items(trait_)\n+            .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n+            .map(|trait_assoc| {\n+                trait_assoc_to_impl_assoc_item(cx.tcx, impl_, trait_assoc.def_id)\n+                    .unwrap_or(trait_assoc)\n+            })\n     });\n     // FIXME(#74563): warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates.clone().collect::<Vec<_>>());\n     candidates.next().copied()\n }\n \n-/// Given a type, return all traits in scope in `module` implemented by that type.\n+/// Find the associated item in the impl `impl_id` that corresponds to the\n+/// trait associated item `trait_assoc_id`.\n+///\n+/// This function returns `None` if no associated item was found in the impl.\n+/// This can occur when the trait associated item has a default value that is\n+/// not overriden in the impl.\n+///\n+/// This is just a wrapper around [`TyCtxt::impl_item_implementor_ids()`] and\n+/// [`TyCtxt::associated_item()`] (with some helpful logging added).\n+#[instrument(level = \"debug\", skip(tcx))]\n+fn trait_assoc_to_impl_assoc_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_id: DefId,\n+    trait_assoc_id: DefId,\n+) -> Option<&'tcx ty::AssocItem> {\n+    let trait_to_impl_assoc_map = tcx.impl_item_implementor_ids(impl_id);\n+    debug!(?trait_to_impl_assoc_map);\n+    let impl_assoc_id = *trait_to_impl_assoc_map.get(&trait_assoc_id)?;\n+    debug!(?impl_assoc_id);\n+    let impl_assoc = tcx.associated_item(impl_assoc_id);\n+    debug!(?impl_assoc);\n+    Some(impl_assoc)\n+}\n+\n+/// Given a type, return all trait impls in scope in `module` for that type.\n+/// Returns a set of pairs of `(impl_id, trait_id)`.\n ///\n /// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n /// So it is not stable to serialize cross-crate.\n-fn traits_implemented_by<'a>(\n+fn trait_impls_for<'a>(\n     cx: &mut DocContext<'a>,\n     ty: Ty<'a>,\n     module: DefId,\n-) -> FxHashSet<DefId> {\n+) -> FxHashSet<(DefId, DefId)> {\n     let mut resolver = cx.resolver.borrow_mut();\n     let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n         resolver.access(|resolver| {\n@@ -948,7 +966,7 @@ fn traits_implemented_by<'a>(\n                     _ => false,\n                 };\n \n-            if saw_impl { Some(trait_) } else { None }\n+            if saw_impl { Some((impl_, trait_)) } else { None }\n         })\n     });\n     iter.collect()"}, {"sha": "f1410b69b3fceafe49a87bbab3a602b00610c3f0", "filename": "src/test/run-make-fulldeps/codegen-options-parsing/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fcodegen-options-parsing%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fcodegen-options-parsing%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcodegen-options-parsing%2FMakefile?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -24,8 +24,8 @@ all:\n \t$(RUSTC) -C lto dummy.rs\n \n \t# Should not link dead code...\n-\t$(RUSTC) -Z print-link-args dummy.rs 2>&1 | \\\n+\t$(RUSTC) --print link-args dummy.rs 2>&1 | \\\n \t\t$(CGREP) -e '--gc-sections|-z[^ ]* [^ ]*<ignore>|-dead_strip|/OPT:REF'\n \t# ... unless you specifically ask to keep it\n-\t$(RUSTC) -Z print-link-args -C link-dead-code dummy.rs 2>&1 | \\\n+\t$(RUSTC) --print link-args -C link-dead-code dummy.rs 2>&1 | \\\n \t\t$(CGREP) -ve '--gc-sections|-z[^ ]* [^ ]*<ignore>|-dead_strip|/OPT:REF'"}, {"sha": "0a50859cdaa4dd670423cb6cefcec9e546e38843", "filename": "src/test/run-make-fulldeps/interdependent-c-libraries/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Finterdependent-c-libraries%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Finterdependent-c-libraries%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finterdependent-c-libraries%2FMakefile?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -11,4 +11,4 @@\n all: $(call NATIVE_STATICLIB,foo) $(call NATIVE_STATICLIB,bar)\n \t$(RUSTC) foo.rs\n \t$(RUSTC) bar.rs\n-\t$(RUSTC) main.rs -Z print-link-args\n+\t$(RUSTC) main.rs --print link-args"}, {"sha": "0360ede762551a673873abba499d6293992e2df0", "filename": "src/test/run-make-fulldeps/link-arg/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Flink-arg%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Flink-arg%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flink-arg%2FMakefile?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,5 +1,5 @@\n -include ../tools.mk\n-RUSTC_FLAGS = -C link-arg=\"-lfoo\" -C link-arg=\"-lbar\" -Z print-link-args\n+RUSTC_FLAGS = -C link-arg=\"-lfoo\" -C link-arg=\"-lbar\" --print link-args\n \n all:\n \t$(RUSTC) $(RUSTC_FLAGS) empty.rs | $(CGREP) lfoo lbar"}, {"sha": "3ffbba9444bc2ea338d31e8e31c184c99f7980d2", "filename": "src/test/run-make-fulldeps/metadata-flag-frobs-symbols/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fmetadata-flag-frobs-symbols%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fmetadata-flag-frobs-symbols%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fmetadata-flag-frobs-symbols%2FMakefile?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -6,5 +6,5 @@ all:\n \t$(RUSTC) bar.rs \\\n \t\t--extern foo1=$(TMPDIR)/libfoo-a.rlib \\\n \t\t--extern foo2=$(TMPDIR)/libfoo-b.rlib \\\n-\t\t-Z print-link-args\n+\t\t--print link-args\n \t$(call RUN,bar)"}, {"sha": "2e41be39d5d00851348915f5ebfa2e2a200f5ed3", "filename": "src/test/run-make-fulldeps/no-builtins-lto/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fno-builtins-lto%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fno-builtins-lto%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fno-builtins-lto%2FMakefile?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -6,4 +6,4 @@ all:\n \t# Build an executable that depends on that crate using LTO. The no_builtins crate doesn't\n \t# participate in LTO, so its rlib must be explicitly linked into the final binary. Verify this by\n \t# grepping the linker arguments.\n-\t$(RUSTC) main.rs -C lto -Z print-link-args | $(CGREP) 'libno_builtins.rlib'\n+\t$(RUSTC) main.rs -C lto --print link-args | $(CGREP) 'libno_builtins.rlib'"}, {"sha": "e09841fb42e1876ae337328568d6994a20ac0e33", "filename": "src/test/run-make-fulldeps/redundant-libs/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fredundant-libs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fredundant-libs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fredundant-libs%2FMakefile?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -16,7 +16,7 @@ RUSTC_FLAGS = \\\n     -l foo \\\n     -l static=baz \\\n     -l foo \\\n-    -Z print-link-args\n+    --print link-args\n \n all: $(call DYLIB,foo) $(call STATICLIB,bar) $(call STATICLIB,baz)\n \t$(RUSTC) $(RUSTC_FLAGS) main.rs"}, {"sha": "8f78c401a11415fe9b4665d9117187b77734adb3", "filename": "src/test/run-make-fulldeps/static-nobundle/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fstatic-nobundle%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frun-make-fulldeps%2Fstatic-nobundle%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fstatic-nobundle%2FMakefile?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -13,9 +13,9 @@ all: $(call NATIVE_STATICLIB,aaa)\n \tnm $(TMPDIR)/libbbb.rlib | $(CGREP) -e \"U _*native_func\"\n \n \t# Check that aaa gets linked (either as `-l aaa` or `aaa.lib`) when building ccc.\n-\t$(RUSTC) ccc.rs -C prefer-dynamic --crate-type=dylib -Z print-link-args | $(CGREP) -e '-l[\" ]*aaa|aaa\\.lib'\n+\t$(RUSTC) ccc.rs -C prefer-dynamic --crate-type=dylib --print link-args | $(CGREP) -e '-l[\" ]*aaa|aaa\\.lib'\n \n \t# Check that aaa does NOT get linked when building ddd.\n-\t$(RUSTC) ddd.rs -Z print-link-args | $(CGREP) -ve '-l[\" ]*aaa|aaa\\.lib'\n+\t$(RUSTC) ddd.rs --print link-args | $(CGREP) -ve '-l[\" ]*aaa|aaa\\.lib'\n \n \t$(call RUN,ddd)"}, {"sha": "acde112392521caf3be383a9c11ce7c76d4ece7d", "filename": "src/test/rustdoc-gui/mobile.goml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc-gui%2Fmobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc-gui%2Fmobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fmobile.goml?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -0,0 +1,17 @@\n+// Test various properties of the mobile UI\n+goto: file://|DOC_PATH|/staged_api/struct.Foo.html\n+size: (400, 600)\n+\n+// The out-of-band info (source, stable version, collapse) should be below the\n+// h1 when the screen gets narrow enough.\n+assert-css: (\".main-heading\", {\n+  \"display\": \"flex\",\n+  \"flex-direction\": \"column\"\n+})\n+\n+// Note: We can't use assert-text here because the 'Since' is set by CSS and\n+// is therefore not part of the DOM.\n+assert-css: (\".content .out-of-band .since::before\", { \"content\": \"\\\"Since \\\"\" })\n+\n+size: (1000, 1000)\n+assert-css-false: (\".content .out-of-band .since::before\", { \"content\": \"\\\"Since \\\"\" })"}, {"sha": "e7a75b43c5a02abca8294d4cf1dc061608c4d9ab", "filename": "src/test/rustdoc-gui/toggle-docs-mobile.goml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Ftoggle-docs-mobile.goml?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,12 +1,12 @@\n goto: file://|DOC_PATH|/test_docs/struct.Foo.html\n size: (433, 600)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 250) // This is the position of the top doc comment toggle\n+click: (4, 270) // This is the position of the top doc comment toggle\n assert-attribute-false: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 250)\n+click: (4, 270)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n // To ensure that the toggle isn't over the text, we check that the toggle isn't clicked.\n-click: (3, 250)\n+click: (3, 270)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n \n // Assert the position of the toggle on the top doc block.\n@@ -22,10 +22,10 @@ assert-position: (\n // Now we do the same but with a little bigger width\n size: (600, 600)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 250) // New Y position since all search elements are back on one line.\n+click: (4, 270) // New Y position since all search elements are back on one line.\n assert-attribute-false: (\".top-doc\", {\"open\": \"\"})\n-click: (4, 250)\n+click: (4, 270)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})\n // To ensure that the toggle isn't over the text, we check that the toggle isn't clicked.\n-click: (3, 250)\n+click: (3, 270)\n assert-attribute: (\".top-doc\", {\"open\": \"\"})"}, {"sha": "b8e101038f8f11b4ba74c1f8f97c7aabd148807d", "filename": "src/test/rustdoc/const-display.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc%2Fconst-display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc%2Fconst-display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-display.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -67,3 +67,20 @@ impl Foo {\n     #[rustc_const_stable(feature = \"rust1\", since = \"1.2.0\")]\n     pub const fn stable_impl() -> u32 { 42 }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Bar;\n+\n+impl Bar {\n+    // Do not show non-const stabilities that are the same as the enclosing item.\n+    // @matches 'foo/struct.Bar.html' '//span[@class=\"since\"]' '^const: 1.2.0$'\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"rust1\", since = \"1.2.0\")]\n+    pub const fn stable_impl() -> u32 { 42 }\n+\n+    // Show const-stability even for unstable functions.\n+    // @matches 'foo/struct.Bar.html' '//span[@class=\"since\"]' '^const: 1.3.0$'\n+    #[unstable(feature = \"foo2\", issue = \"none\")]\n+    #[rustc_const_stable(feature = \"rust1\", since = \"1.3.0\")]\n+    pub const fn const_stable_unstable() -> u32 { 42 }\n+}"}, {"sha": "8ecca6d12d24af01bd4c61fe58a422a97bd9e607", "filename": "src/test/rustdoc/deref-const-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc%2Fderef-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc%2Fderef-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-const-fn.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -13,7 +13,7 @@ pub struct Bar;\n \n impl Bar {\n     // @has - '//*[@id=\"method.len\"]' 'pub const fn len(&self) -> usize'\n-    // @has - '//*[@id=\"method.len\"]//span[@class=\"since\"]' '1.0.0 (const: 1.0.0)'\n+    // @has - '//*[@id=\"method.len\"]//span[@class=\"since\"]' 'const: 1.0.0'\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn len(&self) -> usize { 0 }"}, {"sha": "22b0b5dc47e282b5272448238c13983b6c2a4b96", "filename": "src/test/rustdoc/strip-block-doc-comments-stars.docblock.html", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc%2Fstrip-block-doc-comments-stars.docblock.html", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc%2Fstrip-block-doc-comments-stars.docblock.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstrip-block-doc-comments-stars.docblock.html?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -0,0 +1,2 @@\n+<div class=\"docblock\"><p>a</p>\n+</div>\n\\ No newline at end of file"}, {"sha": "ed2297b4fac5daf07f482667879b495fe947ec38", "filename": "src/test/rustdoc/strip-block-doc-comments-stars.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc%2Fstrip-block-doc-comments-stars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Frustdoc%2Fstrip-block-doc-comments-stars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstrip-block-doc-comments-stars.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -0,0 +1,11 @@\n+#![crate_name = \"foo\"]\n+\n+// The goal of this test is to answer that it won't be generated as a list because\n+// block doc comments can have their lines starting with a star.\n+\n+// @has foo/fn.foo.html\n+// @snapshot docblock - '//*[@class=\"rustdoc-toggle top-doc\"]//*[@class=\"docblock\"]'\n+/**\n+ *     a\n+ */\n+pub fn foo() {}"}, {"sha": "ac5f99970c8148398b7d105253eccad924fee621", "filename": "src/test/ui/async-await/issue-76547.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,23 +2,17 @@ error[E0623]: lifetime mismatch\n   --> $DIR/issue-76547.rs:20:13\n    |\n LL | async fn fut(bufs: &mut [&mut [u8]]) {\n-   |                          ---------   -\n-   |                          |           |\n-   |                          |           this `async fn` implicitly returns an `impl Future<Output = ()>`\n-   |                          this parameter and the returned future are declared with different lifetimes...\n+   |                    ---------------- these two types are declared with different lifetimes...\n LL |     ListFut(bufs).await\n-   |             ^^^^ ...but data from `bufs` is held across an await point here\n+   |             ^^^^ ...but data from `bufs` flows into `bufs` here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/issue-76547.rs:34:14\n    |\n LL | async fn fut2(bufs: &mut [&mut [u8]]) -> i32 {\n-   |                           ---------      ---\n-   |                           |              |\n-   |                           |              this `async fn` implicitly returns an `impl Future<Output = i32>`\n-   |                           this parameter and the returned future are declared with different lifetimes...\n+   |                     ---------------- these two types are declared with different lifetimes...\n LL |     ListFut2(bufs).await\n-   |              ^^^^ ...but data from `bufs` is held across an await point here\n+   |              ^^^^ ...but data from `bufs` flows into `bufs` here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8f602a1492ad2ff02765b189b8ebc33f45a7c556", "filename": "src/test/ui/async-await/issues/issue-63388-1.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,14 +2,12 @@ error[E0623]: lifetime mismatch\n   --> $DIR/issue-63388-1.rs:14:9\n    |\n LL |         &'a self, foo: &dyn Foo\n-   |         -------- this parameter and the returned future are declared with different lifetimes...\n+   |                        -------- this parameter and the return type are declared with different lifetimes...\n LL |     ) -> &dyn Foo\n    |          --------\n-   |          |\n-   |          this `async fn` implicitly returns an `impl Future<Output = &dyn Foo>`\n LL |     {\n LL |         foo\n-   |         ^^^ ...but data from `foo` is held across an await point here\n+   |         ^^^ ...but data from `foo` is returned here\n \n error: aborting due to previous error\n "}, {"sha": "149692a2c6998e29981b192df521a48fa354c480", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -4,9 +4,8 @@ error[E0623]: lifetime mismatch\n LL | async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n    |                                                      ------     ^^^^^^^^^^^^^^^^^^^\n    |                                                      |          |\n-   |                                                      |          ...but data from `a` is held across an await point here\n-   |                                                      |          this `async fn` implicitly returns an `impl Future<Output = impl Trait<'a> + 'b>`\n-   |                                                      this parameter and the returned future are declared with different lifetimes...\n+   |                                                      |          ...but data from `a` is returned here\n+   |                                                      this parameter and the return type are declared with different lifetimes...\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ret-impl-trait-one.rs:16:65"}, {"sha": "56b88a426a1a8256623c64b31cd1091a7eae6c0f", "filename": "src/test/ui/const-generics/generic_arg_infer/array-in-sig.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74fbbefea8d13683cca5eee62e4740706cb3144a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Farray-in-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74fbbefea8d13683cca5eee62e4740706cb3144a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Farray-in-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Farray-in-sig.rs?ref=74fbbefea8d13683cca5eee62e4740706cb3144a", "patch": "@@ -1,12 +0,0 @@\n-// To avoid having to `or` gate `_` as an expr.\n-#![feature(generic_arg_infer)]\n-\n-fn foo() -> [u8; _] {\n-    //~^ ERROR the const placeholder `_` is not allowed within types on item signatures for generics\n-    // FIXME(generic_arg_infer): this error message should say in the return type or sth like that.\n-    [0; 3]\n-}\n-\n-fn main() {\n-    foo();\n-}"}, {"sha": "eaa12b4192dc60c4b55e68a91a274806913b01fb", "filename": "src/test/ui/const-generics/generic_arg_infer/array-in-sig.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/74fbbefea8d13683cca5eee62e4740706cb3144a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Farray-in-sig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74fbbefea8d13683cca5eee62e4740706cb3144a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Farray-in-sig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Farray-in-sig.stderr?ref=74fbbefea8d13683cca5eee62e4740706cb3144a", "patch": "@@ -1,9 +0,0 @@\n-error[E0121]: the const placeholder `_` is not allowed within types on item signatures for generics\n-  --> $DIR/array-in-sig.rs:4:18\n-   |\n-LL | fn foo() -> [u8; _] {\n-   |                  ^ not allowed in type signatures\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0121`."}, {"sha": "1f60b2242411dd39710c1c9d520f4a7f0f0b8987", "filename": "src/test/ui/const-generics/generic_arg_infer/in-signature.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fin-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fin-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fin-signature.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -0,0 +1,61 @@\n+#![crate_type = \"rlib\"]\n+#![feature(generic_arg_infer)]\n+\n+struct Foo<const N: usize>;\n+struct Bar<T, const N: usize>(T);\n+\n+fn arr_fn() -> [u8; _] {\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n+    [0; 3]\n+}\n+\n+fn ty_fn() -> Bar<i32, _> {\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n+    Bar::<i32, 3>(0)\n+}\n+\n+fn ty_fn_mixed() -> Bar<_, _> {\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n+    Bar::<i32, 3>(0)\n+}\n+\n+const ARR_CT: [u8; _] = [0; 3];\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n+static ARR_STATIC: [u8; _] = [0; 3];\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n+const TY_CT: Bar<i32, _> = Bar::<i32, 3>(0);\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n+static TY_STATIC: Bar<i32, _> = Bar::<i32, 3>(0);\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n+const TY_CT_MIXED: Bar<_, _> = Bar::<i32, 3>(0);\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n+static TY_STATIC_MIXED: Bar<_, _> = Bar::<i32, 3>(0);\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n+trait ArrAssocConst {\n+    const ARR: [u8; _];\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n+}\n+trait TyAssocConst {\n+    const ARR: Bar<i32, _>;\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n+}\n+trait TyAssocConstMixed {\n+    const ARR: Bar<_, _>;\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n+}\n+\n+trait AssocTy {\n+    type Assoc;\n+}\n+impl AssocTy for i8 {\n+    type Assoc = [u8; _];\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for associated types\n+}\n+impl AssocTy for i16 {\n+    type Assoc = Bar<i32, _>;\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for associated types\n+}\n+impl AssocTy for i32 {\n+    type Assoc = Bar<_, _>;\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for associated types\n+}"}, {"sha": "7581cf4120ecf89f43194f37d5e342eed01492be", "filename": "src/test/ui/const-generics/generic_arg_infer/in-signature.stderr", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fin-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fin-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fin-signature.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -0,0 +1,119 @@\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n+  --> $DIR/in-signature.rs:7:21\n+   |\n+LL | fn arr_fn() -> [u8; _] {\n+   |                -----^-\n+   |                |    |\n+   |                |    not allowed in type signatures\n+   |                help: replace with the correct return type: `[u8; 3]`\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n+  --> $DIR/in-signature.rs:12:24\n+   |\n+LL | fn ty_fn() -> Bar<i32, _> {\n+   |               ---------^-\n+   |               |        |\n+   |               |        not allowed in type signatures\n+   |               help: replace with the correct return type: `Bar<i32, 3_usize>`\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n+  --> $DIR/in-signature.rs:17:25\n+   |\n+LL | fn ty_fn_mixed() -> Bar<_, _> {\n+   |                     ----^--^-\n+   |                     |   |  |\n+   |                     |   |  not allowed in type signatures\n+   |                     |   not allowed in type signatures\n+   |                     help: replace with the correct return type: `Bar<i32, 3_usize>`\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n+  --> $DIR/in-signature.rs:22:15\n+   |\n+LL | const ARR_CT: [u8; _] = [0; 3];\n+   |               ^^^^^^^ not allowed in type signatures\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n+  --> $DIR/in-signature.rs:24:20\n+   |\n+LL | static ARR_STATIC: [u8; _] = [0; 3];\n+   |                    ^^^^^^^ not allowed in type signatures\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n+  --> $DIR/in-signature.rs:26:14\n+   |\n+LL | const TY_CT: Bar<i32, _> = Bar::<i32, 3>(0);\n+   |              ^^^^^^^^^^^\n+   |              |\n+   |              not allowed in type signatures\n+   |              help: replace with the correct type: `Bar<i32, 3_usize>`\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n+  --> $DIR/in-signature.rs:28:19\n+   |\n+LL | static TY_STATIC: Bar<i32, _> = Bar::<i32, 3>(0);\n+   |                   ^^^^^^^^^^^\n+   |                   |\n+   |                   not allowed in type signatures\n+   |                   help: replace with the correct type: `Bar<i32, 3_usize>`\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n+  --> $DIR/in-signature.rs:30:20\n+   |\n+LL | const TY_CT_MIXED: Bar<_, _> = Bar::<i32, 3>(0);\n+   |                    ^^^^^^^^^\n+   |                    |\n+   |                    not allowed in type signatures\n+   |                    help: replace with the correct type: `Bar<i32, 3_usize>`\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n+  --> $DIR/in-signature.rs:32:25\n+   |\n+LL | static TY_STATIC_MIXED: Bar<_, _> = Bar::<i32, 3>(0);\n+   |                         ^^^^^^^^^\n+   |                         |\n+   |                         not allowed in type signatures\n+   |                         help: replace with the correct type: `Bar<i32, 3_usize>`\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n+  --> $DIR/in-signature.rs:35:21\n+   |\n+LL |     const ARR: [u8; _];\n+   |                     ^ not allowed in type signatures\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n+  --> $DIR/in-signature.rs:39:25\n+   |\n+LL |     const ARR: Bar<i32, _>;\n+   |                         ^ not allowed in type signatures\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n+  --> $DIR/in-signature.rs:43:20\n+   |\n+LL |     const ARR: Bar<_, _>;\n+   |                    ^  ^ not allowed in type signatures\n+   |                    |\n+   |                    not allowed in type signatures\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for associated types\n+  --> $DIR/in-signature.rs:51:23\n+   |\n+LL |     type Assoc = [u8; _];\n+   |                       ^ not allowed in type signatures\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for associated types\n+  --> $DIR/in-signature.rs:55:27\n+   |\n+LL |     type Assoc = Bar<i32, _>;\n+   |                           ^ not allowed in type signatures\n+\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for associated types\n+  --> $DIR/in-signature.rs:59:22\n+   |\n+LL |     type Assoc = Bar<_, _>;\n+   |                      ^  ^ not allowed in type signatures\n+   |                      |\n+   |                      not allowed in type signatures\n+\n+error: aborting due to 15 previous errors\n+\n+For more information about this error, try `rustc --explain E0121`."}, {"sha": "f787c416c2d63cd19c63e3295edb5eef3d4f7675", "filename": "src/test/ui/did_you_mean/bad-assoc-ty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -16,7 +16,7 @@ type D = (u8, u8)::AssocTy;\n \n type E = _::AssocTy;\n //~^ ERROR missing angle brackets in associated item path\n-//~| ERROR the type placeholder `_` is not allowed within types on item signatures for type aliases\n+//~| ERROR the placeholder `_` is not allowed within types on item signatures for type aliases\n \n type F = &'static (u8)::AssocTy;\n //~^ ERROR missing angle brackets in associated item path\n@@ -49,37 +49,37 @@ type I = ty!()::AssocTy;\n \n trait K<A, B> {}\n fn foo<X: K<_, _>>(x: X) {}\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n fn bar<F>(_: F) where F: Fn() -> _ {}\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n fn baz<F: Fn() -> _>(_: F) {}\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n struct L<F>(F) where F: Fn() -> _;\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for structs\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for structs\n struct M<F> where F: Fn() -> _ {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for structs\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for structs\n     a: F,\n }\n enum N<F> where F: Fn() -> _ {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for enums\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for enums\n     Foo(F),\n }\n \n union O<F> where F: Fn() -> _ {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for unions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for unions\n     foo: F,\n }\n \n trait P<F> where F: Fn() -> _ {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for traits\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for traits\n }\n \n trait Q {\n     fn foo<F>(_: F) where F: Fn() -> _ {}\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n }\n \n fn main() {}"}, {"sha": "2326af934d014d509809643d24a0b50f2c1df214", "filename": "src/test/ui/did_you_mean/bad-assoc-ty.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -81,7 +81,7 @@ error[E0223]: ambiguous associated type\n LL | type D = (u8, u8)::AssocTy;\n    |          ^^^^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<(u8, u8) as Trait>::AssocTy`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for type aliases\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for type aliases\n   --> $DIR/bad-assoc-ty.rs:17:10\n    |\n LL | type E = _::AssocTy;\n@@ -136,7 +136,7 @@ error[E0223]: ambiguous associated type\n LL | type I = ty!()::AssocTy;\n    |          ^^^^^^^^^^^^^^ help: use fully-qualified syntax: `<u8 as Trait>::AssocTy`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/bad-assoc-ty.rs:51:13\n    |\n LL | fn foo<X: K<_, _>>(x: X) {}\n@@ -149,7 +149,7 @@ help: use type parameters instead\n LL | fn foo<X: K<T, T>, T>(x: X) {}\n    |             ~  ~ +++\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/bad-assoc-ty.rs:54:34\n    |\n LL | fn bar<F>(_: F) where F: Fn() -> _ {}\n@@ -160,7 +160,7 @@ help: use type parameters instead\n LL | fn bar<F, T>(_: F) where F: Fn() -> T {}\n    |         +++                         ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/bad-assoc-ty.rs:57:19\n    |\n LL | fn baz<F: Fn() -> _>(_: F) {}\n@@ -171,7 +171,7 @@ help: use type parameters instead\n LL | fn baz<F: Fn() -> T, T>(_: F) {}\n    |                   ~+++\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for structs\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for structs\n   --> $DIR/bad-assoc-ty.rs:60:33\n    |\n LL | struct L<F>(F) where F: Fn() -> _;\n@@ -182,7 +182,7 @@ help: use type parameters instead\n LL | struct L<F, T>(F) where F: Fn() -> T;\n    |           +++                      ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for structs\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for structs\n   --> $DIR/bad-assoc-ty.rs:62:30\n    |\n LL | struct M<F> where F: Fn() -> _ {\n@@ -193,7 +193,7 @@ help: use type parameters instead\n LL | struct M<F, T> where F: Fn() -> T {\n    |           +++                   ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for enums\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for enums\n   --> $DIR/bad-assoc-ty.rs:66:28\n    |\n LL | enum N<F> where F: Fn() -> _ {\n@@ -204,7 +204,7 @@ help: use type parameters instead\n LL | enum N<F, T> where F: Fn() -> T {\n    |         +++                   ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for unions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for unions\n   --> $DIR/bad-assoc-ty.rs:71:29\n    |\n LL | union O<F> where F: Fn() -> _ {\n@@ -215,7 +215,7 @@ help: use type parameters instead\n LL | union O<F, T> where F: Fn() -> T {\n    |          +++                   ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for traits\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for traits\n   --> $DIR/bad-assoc-ty.rs:76:29\n    |\n LL | trait P<F> where F: Fn() -> _ {\n@@ -226,7 +226,7 @@ help: use type parameters instead\n LL | trait P<F, T> where F: Fn() -> T {\n    |          +++                   ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/bad-assoc-ty.rs:81:38\n    |\n LL |     fn foo<F>(_: F) where F: Fn() -> _ {}"}, {"sha": "023d7e011bf3a0e7521495c838abcdfefabc4026", "filename": "src/test/ui/error-codes/E0121.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ferror-codes%2FE0121.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ferror-codes%2FE0121.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0121.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/E0121.rs:1:13\n    |\n LL | fn foo() -> _ { 5 }\n@@ -7,7 +7,7 @@ LL | fn foo() -> _ { 5 }\n    |             not allowed in type signatures\n    |             help: replace with the correct return type: `i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/E0121.rs:3:13\n    |\n LL | static BAR: _ = \"test\";"}, {"sha": "fcef6f1b60ecf6864a930bcdd576bfacd70be504", "filename": "src/test/ui/fn/issue-80179.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ffn%2Fissue-80179.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ffn%2Fissue-80179.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fissue-80179.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -8,15 +8,15 @@ fn returns_i32() -> i32 {\n }\n \n fn returns_fn_ptr() -> _ {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types [E0121]\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types [E0121]\n //~| NOTE not allowed in type signatures\n //~| HELP replace with the correct return type\n //~| SUGGESTION fn() -> i32\n     returns_i32\n }\n \n fn returns_closure() -> _ {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types [E0121]\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types [E0121]\n //~| NOTE not allowed in type signatures\n //~| HELP consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\n //~| NOTE for more information on `Fn` traits and closure types, see"}, {"sha": "2ca4ae982d96f30bca872b276ae28812a37b36f7", "filename": "src/test/ui/fn/issue-80179.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ffn%2Fissue-80179.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ffn%2Fissue-80179.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Fissue-80179.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/issue-80179.rs:10:24\n    |\n LL | fn returns_fn_ptr() -> _ {\n@@ -7,7 +7,7 @@ LL | fn returns_fn_ptr() -> _ {\n    |                        not allowed in type signatures\n    |                        help: replace with the correct return type: `fn() -> i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/issue-80179.rs:18:25\n    |\n LL | fn returns_closure() -> _ {"}, {"sha": "45a30857413b9df442e2b60a246e9e27603d923e", "filename": "src/test/ui/issues/issue-69396-const-no-type-in-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -4,7 +4,7 @@ macro_rules! suite {\n             const A = \"A\".$fn();\n             //~^ ERROR the name `A` is defined multiple times\n             //~| ERROR missing type for `const` item\n-            //~| ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+            //~| ERROR the placeholder `_` is not allowed within types on item signatures for constants\n         )*\n     }\n }"}, {"sha": "e5ab65169ce3bfad4818c90857a3d7f79b640207", "filename": "src/test/ui/issues/issue-69396-const-no-type-in-macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69396-const-no-type-in-macro.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -30,7 +30,7 @@ LL | | }\n    |\n    = note: this error originates in the macro `suite` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/issue-69396-const-no-type-in-macro.rs:4:19\n    |\n LL |               const A = \"A\".$fn();"}, {"sha": "299a2d2f2d3de6f9b21ac115ab6c9b70b24f1cbe", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch-async.stderr", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,28 +2,25 @@ error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:8:52\n    |\n LL |     async fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n-   |                          ----               ----   ^ ...but data from `f` is held across an await point here\n-   |                          |                  |\n-   |                          |                  this `async fn` implicitly returns an `impl Future<Output = &Foo>`\n-   |                          this parameter and the returned future are declared with different lifetimes...\n+   |                                    ----     ----   ^ ...but data from `f` is returned here\n+   |                                    |\n+   |                                    this parameter and the return type are declared with different lifetimes...\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:11:82\n    |\n LL |     async fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n-   |                          -----                        -----------------          ^ ...but data from `f` is held across an await point here\n-   |                          |                            |\n-   |                          |                            this `async fn` implicitly returns an `impl Future<Output = (Pin<&Foo>, &Foo)>`\n-   |                          this parameter and the returned future are declared with different lifetimes...\n+   |                                     ----              -----------------          ^ ...but data from `f` is returned here\n+   |                                     |\n+   |                                     this parameter and the return type are declared with different lifetimes...\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:17:64\n    |\n LL |     async fn bar<'a>(self: Alias<&Self>, arg: &'a ()) -> &() { arg }\n-   |                                  -----                   ---   ^^^ ...but data from `arg` is held across an await point here\n-   |                                  |                       |\n-   |                                  |                       this `async fn` implicitly returns an `impl Future<Output = &()>`\n-   |                                  this parameter and the returned future are declared with different lifetimes...\n+   |                                               ------     ---   ^^^ ...but data from `arg` is returned here\n+   |                                               |\n+   |                                               this parameter and the return type are declared with different lifetimes...\n \n error: aborting due to 3 previous errors\n "}, {"sha": "7448e8484b47a1af7b5e7bfffe1c14dd802d8ce4", "filename": "src/test/ui/self/elision/lt-ref-self-async.stderr", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,67 +2,61 @@ error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:13:9\n    |\n LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n-   |                       -----              ----\n-   |                       |                  |\n-   |                       |                  this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                       this parameter and the returned future are declared with different lifetimes...\n+   |                                 ----     ----\n+   |                                 |\n+   |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:19:9\n    |\n LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n-   |                             -----              ----\n-   |                             |                  |\n-   |                             |                  this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                             this parameter and the returned future are declared with different lifetimes...\n+   |                                       ----     ----\n+   |                                       |\n+   |                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:23:9\n    |\n LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n-   |                                     -----               ----\n-   |                                     |                   |\n-   |                                     |                   this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                ----     ----\n+   |                                                |\n+   |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:27:9\n    |\n LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n-   |                                     -----               ----\n-   |                                     |                   |\n-   |                                     |                   this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                ----     ----\n+   |                                                |\n+   |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:31:9\n    |\n LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n-   |                                             -----                ----\n-   |                                             |                    |\n-   |                                             |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                         ----     ----\n+   |                                                         |\n+   |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:35:9\n    |\n LL |     async fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n-   |                                         -----                ----\n-   |                                         |                    |\n-   |                                         |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                         this parameter and the returned future are declared with different lifetimes...\n+   |                                                     ----     ----\n+   |                                                     |\n+   |                                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 6 previous errors\n "}, {"sha": "6056cc46d3d8a505346e9bfade02dba8ce145809", "filename": "src/test/ui/self/elision/ref-mut-self-async.stderr", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,67 +2,61 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:13:9\n    |\n LL |     async fn ref_self(&mut self, f: &u32) -> &u32 {\n-   |                       ---------              ----\n-   |                       |                      |\n-   |                       |                      this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                       this parameter and the returned future are declared with different lifetimes...\n+   |                                     ----     ----\n+   |                                     |\n+   |                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:19:9\n    |\n LL |     async fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n-   |                             ---------              ----\n-   |                             |                      |\n-   |                             |                      this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                             this parameter and the returned future are declared with different lifetimes...\n+   |                                           ----     ----\n+   |                                           |\n+   |                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:23:9\n    |\n LL |     async fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n-   |                                     ---------               ----\n-   |                                     |                       |\n-   |                                     |                       this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                    ----     ----\n+   |                                                    |\n+   |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:27:9\n    |\n LL |     async fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n-   |                                     ---------               ----\n-   |                                     |                       |\n-   |                                     |                       this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                    ----     ----\n+   |                                                    |\n+   |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:31:9\n    |\n LL |     async fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n-   |                                             ---------                ----\n-   |                                             |                        |\n-   |                                             |                        this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                             ----     ----\n+   |                                                             |\n+   |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:35:9\n    |\n LL |     async fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n-   |                                             ---------                ----\n-   |                                             |                        |\n-   |                                             |                        this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                             ----     ----\n+   |                                                             |\n+   |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 6 previous errors\n "}, {"sha": "61034ae4d47b6792ec66874f9079af8558291364", "filename": "src/test/ui/self/elision/ref-mut-struct-async.stderr", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,56 +2,51 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:13:9\n    |\n LL |     async fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n-   |                               -----------              ----\n-   |                               |                        |\n-   |                               |                        this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                               this parameter and the returned future are declared with different lifetimes...\n+   |                                               ----     ----\n+   |                                               |\n+   |                                               this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:17:9\n    |\n LL |     async fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n-   |                                       -----------               ----\n-   |                                       |                         |\n-   |                                       |                         this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                       this parameter and the returned future are declared with different lifetimes...\n+   |                                                        ----     ----\n+   |                                                        |\n+   |                                                        this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:21:9\n    |\n LL |     async fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n-   |                                       -----------               ----\n-   |                                       |                         |\n-   |                                       |                         this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                       this parameter and the returned future are declared with different lifetimes...\n+   |                                                        ----     ----\n+   |                                                        |\n+   |                                                        this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:25:9\n    |\n LL |     async fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u32 {\n-   |                                               -----------                ----\n-   |                                               |                          |\n-   |                                               |                          this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                               this parameter and the returned future are declared with different lifetimes...\n+   |                                                                 ----     ----\n+   |                                                                 |\n+   |                                                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:29:9\n    |\n LL |     async fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u32 {\n-   |                                               -----------                ----\n-   |                                               |                          |\n-   |                                               |                          this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                               this parameter and the returned future are declared with different lifetimes...\n+   |                                                                 ----     ----\n+   |                                                                 |\n+   |                                                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 5 previous errors\n "}, {"sha": "0eab16e685d4c4fc618fd7962b55406c648311e2", "filename": "src/test/ui/self/elision/ref-self-async.stderr", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,78 +2,71 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:23:9\n    |\n LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n-   |                       -----              ----\n-   |                       |                  |\n-   |                       |                  this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                       this parameter and the returned future are declared with different lifetimes...\n+   |                                 ----     ----\n+   |                                 |\n+   |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:29:9\n    |\n LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n-   |                             -----              ----\n-   |                             |                  |\n-   |                             |                  this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                             this parameter and the returned future are declared with different lifetimes...\n+   |                                       ----     ----\n+   |                                       |\n+   |                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:33:9\n    |\n LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n-   |                                     -----               ----\n-   |                                     |                   |\n-   |                                     |                   this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                ----     ----\n+   |                                                |\n+   |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:37:9\n    |\n LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n-   |                                     -----               ----\n-   |                                     |                   |\n-   |                                     |                   this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                ----     ----\n+   |                                                |\n+   |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:41:9\n    |\n LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n-   |                                             -----                ----\n-   |                                             |                    |\n-   |                                             |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                         ----     ----\n+   |                                                         |\n+   |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:45:9\n    |\n LL |     async fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n-   |                                             -----                ----\n-   |                                             |                    |\n-   |                                             |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                         ----     ----\n+   |                                                         |\n+   |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:49:9\n    |\n LL |     async fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n-   |                                            -----                    ---\n-   |                                            |                        |\n-   |                                            |                        this `async fn` implicitly returns an `impl Future<Output = &u8>`\n-   |                                            this parameter and the returned future are declared with different lifetimes...\n+   |                                                             ---     ---\n+   |                                                             |\n+   |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 7 previous errors\n "}, {"sha": "aa1d7453e83e1c0fefc5a3123b57d143451f6e1f", "filename": "src/test/ui/self/elision/ref-struct-async.stderr", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,56 +2,51 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:13:9\n    |\n LL |     async fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n-   |                               -------              ----\n-   |                               |                    |\n-   |                               |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                               this parameter and the returned future are declared with different lifetimes...\n+   |                                           ----     ----\n+   |                                           |\n+   |                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:17:9\n    |\n LL |     async fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n-   |                                       -------               ----\n-   |                                       |                     |\n-   |                                       |                     this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                       this parameter and the returned future are declared with different lifetimes...\n+   |                                                    ----     ----\n+   |                                                    |\n+   |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:21:9\n    |\n LL |     async fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n-   |                                       -------               ----\n-   |                                       |                     |\n-   |                                       |                     this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                       this parameter and the returned future are declared with different lifetimes...\n+   |                                                    ----     ----\n+   |                                                    |\n+   |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:25:9\n    |\n LL |     async fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n-   |                                               -------                ----\n-   |                                               |                      |\n-   |                                               |                      this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                               this parameter and the returned future are declared with different lifetimes...\n+   |                                                             ----     ----\n+   |                                                             |\n+   |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:29:9\n    |\n LL |     async fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n-   |                                           -------                ----\n-   |                                           |                      |\n-   |                                           |                      this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                           this parameter and the returned future are declared with different lifetimes...\n+   |                                                         ----     ----\n+   |                                                         |\n+   |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 5 previous errors\n "}, {"sha": "9839b8880e9e1f43a25ca014553ba0a61c8bbab9", "filename": "src/test/ui/self/self-infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Fself-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Fself-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself-infer.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,8 +1,8 @@\n struct S;\n \n impl S {\n-    fn f(self: _) {} //~ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n-    fn g(self: &_) {} //~ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    fn f(self: _) {} //~ERROR the placeholder `_` is not allowed within types on item signatures for functions\n+    fn g(self: &_) {} //~ERROR the placeholder `_` is not allowed within types on item signatures for functions\n }\n \n fn main() {}"}, {"sha": "4f9e3f21dca52a5ce1fbe13ff75aed4a74c82119", "filename": "src/test/ui/self/self-infer.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Fself-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fself%2Fself-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself-infer.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/self-infer.rs:4:16\n    |\n LL |     fn f(self: _) {}\n@@ -9,7 +9,7 @@ help: use type parameters instead\n LL |     fn f<T>(self: T) {}\n    |         +++       ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/self-infer.rs:5:17\n    |\n LL |     fn g(self: &_) {}"}, {"sha": "f2485041d9ba22bde817d7e284a7e07e422679c4", "filename": "src/test/ui/suggestions/unnamable-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -8,14 +8,14 @@ const A = 5;\n //~| HELP: provide a type for the constant\n \n static B: _ = \"abc\";\n-//~^ ERROR: the type placeholder `_` is not allowed within types on item signatures for static variables\n+//~^ ERROR: the placeholder `_` is not allowed within types on item signatures for static variables\n //~| NOTE: not allowed in type signatures\n //~| HELP: replace with the correct type\n \n \n // FIXME: this should also suggest a function pointer, as the closure is non-capturing\n const C: _ = || 42;\n-//~^ ERROR: the type placeholder `_` is not allowed within types on item signatures for constants\n+//~^ ERROR: the placeholder `_` is not allowed within types on item signatures for constants\n //~| NOTE: not allowed in type signatures\n //~| NOTE: however, the inferred type\n "}, {"sha": "6127446c83e3b68e830c23d33c58e019a388b7b7", "filename": "src/test/ui/suggestions/unnamable-types.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Funnamable-types.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -4,7 +4,7 @@ error: missing type for `const` item\n LL | const A = 5;\n    |       ^ help: provide a type for the constant: `A: i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/unnamable-types.rs:10:11\n    |\n LL | static B: _ = \"abc\";\n@@ -13,7 +13,7 @@ LL | static B: _ = \"abc\";\n    |           not allowed in type signatures\n    |           help: replace with the correct type: `&str`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/unnamable-types.rs:17:10\n    |\n LL | const C: _ = || 42;"}, {"sha": "9f3f76c1ef3e0c91452c7d13f458703485e142cc", "filename": "src/test/ui/transmute/transmute-imut-to-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftransmute%2Ftransmute-imut-to-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftransmute%2Ftransmute-imut-to-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmute%2Ftransmute-imut-to-mut.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -4,5 +4,5 @@ use std::mem::transmute;\n \n fn main() {\n     let _a: &mut u8 = unsafe { transmute(&1u8) };\n-    //~^ ERROR mutating transmuted &mut T from &T may cause undefined behavior\n+    //~^ ERROR transmuting &T to &mut T is undefined behavior, even if the reference is unused, consider instead using an UnsafeCell\n }"}, {"sha": "1e9dff3ce89b26071e6db0ccb1c7deec0337e91a", "filename": "src/test/ui/transmute/transmute-imut-to-mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftransmute%2Ftransmute-imut-to-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftransmute%2Ftransmute-imut-to-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftransmute%2Ftransmute-imut-to-mut.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n-error: mutating transmuted &mut T from &T may cause undefined behavior, consider instead using an UnsafeCell\n+error: transmuting &T to &mut T is undefined behavior, even if the reference is unused, consider instead using an UnsafeCell\n   --> $DIR/transmute-imut-to-mut.rs:6:32\n    |\n LL |     let _a: &mut u8 = unsafe { transmute(&1u8) };"}, {"sha": "8d818d4a387a6fd199cdf8c33e0c5589820597ef", "filename": "src/test/ui/type-alias-impl-trait/issue-77179.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-77179.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-77179.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-77179.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -5,7 +5,7 @@\n type Pointer<T> = impl std::ops::Deref<Target=T>;\n \n fn test() -> Pointer<_> {\n-    //~^ ERROR: the type placeholder `_` is not allowed within types\n+    //~^ ERROR: the placeholder `_` is not allowed within types\n     Box::new(1)\n }\n "}, {"sha": "15205ba9b419e244513bcd6e55a84e68a60cbc49", "filename": "src/test/ui/type-alias-impl-trait/issue-77179.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-77179.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-77179.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-77179.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/issue-77179.rs:7:22\n    |\n LL | fn test() -> Pointer<_> {"}, {"sha": "44ca256b05163c0749e256c145448393a777b4dd", "filename": "src/test/ui/typeck/issue-74086.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-74086.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-74086.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-74086.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     static BUG: fn(_) -> u8 = |_| 8;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions [E0121]\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions [E0121]\n }"}, {"sha": "e7aea33758cb258b5a84572c90bee0f01902c5c5", "filename": "src/test/ui/typeck/issue-74086.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-74086.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-74086.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-74086.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/issue-74086.rs:2:20\n    |\n LL |     static BUG: fn(_) -> u8 = |_| 8;"}, {"sha": "885acc48231b24e4435e4f7c88f1f253dc3de2fe", "filename": "src/test/ui/typeck/issue-75883.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-75883.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-75883.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-75883.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -5,7 +5,7 @@ pub struct UI {}\n impl UI {\n     pub fn run() -> Result<_> {\n         //~^ ERROR: this enum takes 2 generic arguments but 1 generic argument was supplied\n-        //~| ERROR: the type placeholder `_` is not allowed within types on item signatures for return types\n+        //~| ERROR: the placeholder `_` is not allowed within types on item signatures for return types\n         let mut ui = UI {};\n         ui.interact();\n \n@@ -14,7 +14,7 @@ impl UI {\n \n     pub fn interact(&mut self) -> Result<_> {\n         //~^ ERROR: this enum takes 2 generic arguments but 1 generic argument was supplied\n-        //~| ERROR: the type placeholder `_` is not allowed within types on item signatures for return types\n+        //~| ERROR: the placeholder `_` is not allowed within types on item signatures for return types\n         unimplemented!();\n     }\n }"}, {"sha": "3861e0507f6ddeb6b8d313d76db226b38f6b601b", "filename": "src/test/ui/typeck/issue-75883.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-75883.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-75883.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-75883.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -34,13 +34,13 @@ help: add missing generic argument\n LL |     pub fn interact(&mut self) -> Result<_, E> {\n    |                                           +++\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/issue-75883.rs:15:42\n    |\n LL |     pub fn interact(&mut self) -> Result<_> {\n    |                                          ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/issue-75883.rs:6:28\n    |\n LL |     pub fn run() -> Result<_> {"}, {"sha": "1438f481ec7e135245e72fbad5a679f0666f55e2", "filename": "src/test/ui/typeck/issue-75889.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-75889.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-75889.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-75889.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,10 +1,10 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constant items\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constant items\n   --> $DIR/issue-75889.rs:3:24\n    |\n LL | const FOO: dyn Fn() -> _ = \"\";\n    |                        ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static items\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static items\n   --> $DIR/issue-75889.rs:4:25\n    |\n LL | static BOO: dyn Fn() -> _ = \"\";"}, {"sha": "1624f6b7742b0d88a3598f60c800eb9d9ade15b4", "filename": "src/test/ui/typeck/issue-80779.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-80779.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-80779.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-80779.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -3,11 +3,11 @@\n pub struct T<'a>(&'a str);\n \n pub fn f<'a>(val: T<'a>) -> _ {\n-    //~^ ERROR: the type placeholder `_` is not allowed within types on item signatures for return types\n+    //~^ ERROR: the placeholder `_` is not allowed within types on item signatures for return types\n     g(val)\n }\n \n pub fn g(_: T<'static>) -> _ {}\n-//~^ ERROR: the type placeholder `_` is not allowed within types on item signatures for return types\n+//~^ ERROR: the placeholder `_` is not allowed within types on item signatures for return types\n \n fn main() {}"}, {"sha": "2261ba616545fb2a167b1ff5942bc3789e2bf022", "filename": "src/test/ui/typeck/issue-80779.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-80779.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-80779.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-80779.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/issue-80779.rs:10:28\n    |\n LL | pub fn g(_: T<'static>) -> _ {}\n@@ -7,7 +7,7 @@ LL | pub fn g(_: T<'static>) -> _ {}\n    |                            not allowed in type signatures\n    |                            help: replace with the correct return type: `()`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/issue-80779.rs:5:29\n    |\n LL | pub fn f<'a>(val: T<'a>) -> _ {"}, {"sha": "8935535fb7eb8b9b9e79ca57bdcc813d322b6348", "filename": "src/test/ui/typeck/issue-81885.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-81885.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-81885.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-81885.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,8 +1,8 @@\n const TEST4: fn() -> _ = 42;\n-                  //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+                  //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n fn main() {\n     const TEST5: fn() -> _ = 42;\n-                      //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+                      //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n }"}, {"sha": "3ff4375cd8d3f1a514f48fc6accc9f37f0f2bcab", "filename": "src/test/ui/typeck/issue-81885.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-81885.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-81885.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-81885.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,10 +1,10 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/issue-81885.rs:1:22\n    |\n LL | const TEST4: fn() -> _ = 42;\n    |                      ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/issue-81885.rs:5:26\n    |\n LL |     const TEST5: fn() -> _ = 42;"}, {"sha": "9376e8bcf80bc7d317054e1897943e70b0e675fb", "filename": "src/test/ui/typeck/issue-83621-placeholder-static-in-extern.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-83621-placeholder-static-in-extern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-83621-placeholder-static-in-extern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-83621-placeholder-static-in-extern.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/issue-83621-placeholder-static-in-extern.rs:4:15\n    |\n LL |     static x: _;"}, {"sha": "3c7c990d4e27c1f002053f0a25a3cfc6080a9701", "filename": "src/test/ui/typeck/issue-91450-inner-ty-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-91450-inner-ty-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-91450-inner-ty-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-91450-inner-ty-error.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,6 +2,6 @@\n // This test ensures that the compiler does not suggest `Foo<[type error]>` in diagnostic messages.\n \n fn foo() -> Option<_> {} //~ ERROR: [E0308]\n-//~^ ERROR: the type placeholder `_` is not allowed\n+//~^ ERROR: the placeholder `_` is not allowed\n \n fn main() {}"}, {"sha": "32f4c8f6fdf8255def0295c2733c2fc3ae75eb03", "filename": "src/test/ui/typeck/issue-91450-inner-ty-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-91450-inner-ty-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Fissue-91450-inner-ty-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-91450-inner-ty-error.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -9,7 +9,7 @@ LL | fn foo() -> Option<_> {}\n    = note:   expected enum `Option<_>`\n            found unit type `()`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/issue-91450-inner-ty-error.rs:4:20\n    |\n LL | fn foo() -> Option<_> {}"}, {"sha": "ab2e2d8c53aa3eb2166af328d8aaff2a536a84b9", "filename": "src/test/ui/typeck/type-placeholder-fn-in-const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftype-placeholder-fn-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftype-placeholder-fn-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftype-placeholder-fn-in-const.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,13 +2,13 @@ struct MyStruct;\n \n trait Test {\n     const TEST: fn() -> _;\n-    //~^ ERROR: the type placeholder `_` is not allowed within types on item signatures for functions [E0121]\n-    //~| ERROR: the type placeholder `_` is not allowed within types on item signatures for constants [E0121]\n+    //~^ ERROR: the placeholder `_` is not allowed within types on item signatures for functions [E0121]\n+    //~| ERROR: the placeholder `_` is not allowed within types on item signatures for constants [E0121]\n }\n \n impl Test for MyStruct {\n     const TEST: fn() -> _ = 42;\n-    //~^ ERROR: the type placeholder `_` is not allowed within types on item signatures for functions [E0121]\n+    //~^ ERROR: the placeholder `_` is not allowed within types on item signatures for functions [E0121]\n }\n \n fn main() {}"}, {"sha": "e7b2e554a8d425261b3926352d2204168b6fac75", "filename": "src/test/ui/typeck/type-placeholder-fn-in-const.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftype-placeholder-fn-in-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftype-placeholder-fn-in-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftype-placeholder-fn-in-const.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,16 +1,16 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/type-placeholder-fn-in-const.rs:4:25\n    |\n LL |     const TEST: fn() -> _;\n    |                         ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/type-placeholder-fn-in-const.rs:4:25\n    |\n LL |     const TEST: fn() -> _;\n    |                         ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/type-placeholder-fn-in-const.rs:10:25\n    |\n LL |     const TEST: fn() -> _ = 42;"}, {"sha": "ca0876be58df9909d111e16ac6cea7d8272bb3f4", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -5,218 +5,218 @@\n // inference by using the `_` type placeholder.\n \n fn test() -> _ { 5 }\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n fn test2() -> (_, _) { (5, 5) }\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n static TEST3: _ = \"test\";\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for static variables\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n \n static TEST4: _ = 145;\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for static variables\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n \n static TEST5: (_, _) = (1, 2);\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for static variables\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n \n fn test6(_: _) { }\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n fn test6_b<T>(_: _, _: T) { }\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n fn test6_c<T, K, L, A, B>(_: _, _: (T, K, L, A, B)) { }\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n fn test7(x: _) { let _x: usize = x; }\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n fn test8(_f: fn() -> _) { }\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n-//~^^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n+//~^^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n struct Test9;\n \n impl Test9 {\n     fn test9(&self) -> _ { () }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n     fn test10(&self, _x : _) { }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n }\n \n fn test11(x: &usize) -> &_ {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n     &x\n }\n \n unsafe fn test12(x: *const usize) -> *const *const _ {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n     &x\n }\n \n impl Clone for Test9 {\n     fn clone(&self) -> _ { Test9 }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n     fn clone_from(&mut self, other: _) { *self = Test9; }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n }\n \n struct Test10 {\n     a: _,\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for structs\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for structs\n     b: (_, _),\n }\n \n pub fn main() {\n     static A = 42;\n     //~^ ERROR missing type for `static` item\n     static B: _ = 42;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for static variables\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n     static C: Option<_> = Some(42);\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for static variables\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n     fn fn_test() -> _ { 5 }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n     fn fn_test2() -> (_, _) { (5, 5) }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n     static FN_TEST3: _ = \"test\";\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for static variables\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n \n     static FN_TEST4: _ = 145;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for static variables\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n \n     static FN_TEST5: (_, _) = (1, 2);\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for static variables\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for static variables\n \n     fn fn_test6(_: _) { }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n     fn fn_test7(x: _) { let _x: usize = x; }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n     fn fn_test8(_f: fn() -> _) { }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n-    //~^^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n+    //~^^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n     struct FnTest9;\n \n     impl FnTest9 {\n         fn fn_test9(&self) -> _ { () }\n-        //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n         fn fn_test10(&self, _x : _) { }\n-        //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n     }\n \n     impl Clone for FnTest9 {\n         fn clone(&self) -> _ { FnTest9 }\n-        //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n         fn clone_from(&mut self, other: _) { *self = FnTest9; }\n-        //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n     }\n \n     struct FnTest10 {\n         a: _,\n-        //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for structs\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for structs\n         b: (_, _),\n     }\n \n     fn fn_test11(_: _) -> (_, _) { panic!() }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n     //~| ERROR type annotations needed\n \n     fn fn_test12(x: i32) -> (_, _) { (x, x) }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n     fn fn_test13(x: _) -> (i32, _) { (x, x) }\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n }\n \n trait T {\n     fn method_test1(&self, x: _);\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n     fn method_test2(&self, x: _) -> _;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n     fn method_test3(&self) -> _;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n     fn assoc_fn_test1(x: _);\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n     fn assoc_fn_test2(x: _) -> _;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n     fn assoc_fn_test3() -> _;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n }\n \n struct BadStruct<_>(_);\n //~^ ERROR expected identifier, found reserved identifier `_`\n-//~| ERROR the type placeholder `_` is not allowed within types on item signatures for structs\n+//~| ERROR the placeholder `_` is not allowed within types on item signatures for structs\n trait BadTrait<_> {}\n //~^ ERROR expected identifier, found reserved identifier `_`\n impl BadTrait<_> for BadStruct<_> {}\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for implementations\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for implementations\n \n fn impl_trait() -> impl BadTrait<_> {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for opaque types\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for opaque types\n     unimplemented!()\n }\n \n struct BadStruct1<_, _>(_);\n //~^ ERROR expected identifier, found reserved identifier `_`\n //~| ERROR expected identifier, found reserved identifier `_`\n //~| ERROR the name `_` is already used\n-//~| ERROR the type placeholder `_` is not allowed within types on item signatures for structs\n+//~| ERROR the placeholder `_` is not allowed within types on item signatures for structs\n struct BadStruct2<_, T>(_, T);\n //~^ ERROR expected identifier, found reserved identifier `_`\n-//~| ERROR the type placeholder `_` is not allowed within types on item signatures for structs\n+//~| ERROR the placeholder `_` is not allowed within types on item signatures for structs\n \n type X = Box<_>;\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for type aliases\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for type aliases\n \n struct Struct;\n trait Trait<T> {}\n impl Trait<usize> for Struct {}\n type Y = impl Trait<_>;\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for opaque types\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for opaque types\n fn foo() -> Y {\n     Struct\n }\n \n trait Qux {\n     type A;\n     type B = _;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for associated types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for associated types\n     const C: _;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n     const D: _ = 42;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n     // type E: _; // FIXME: make the parser propagate the existence of `B`\n     type F: std::ops::Fn(_);\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for associated types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for associated types\n }\n impl Qux for Struct {\n     type A = _;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for associated types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for associated types\n     type B = _;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for associated types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for associated types\n     const C: _;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n     //~| ERROR associated constant in `impl` without body\n     const D: _ = 42;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n }\n \n fn map<T>(_: fn() -> Option<&'static T>) -> Option<T> {\n     None\n }\n \n fn value() -> Option<&'static _> {\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n     Option::<&'static u8>::None\n }\n \n const _: Option<_> = map(value);\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants"}, {"sha": "c07b96f9a977ae325e2a2cc527f7719ff949d7a3", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -44,7 +44,7 @@ LL | struct BadStruct1<_, _>(_);\n    |                   |\n    |                   first use of `_`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:7:14\n    |\n LL | fn test() -> _ { 5 }\n@@ -53,7 +53,7 @@ LL | fn test() -> _ { 5 }\n    |              not allowed in type signatures\n    |              help: replace with the correct return type: `i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:10:16\n    |\n LL | fn test2() -> (_, _) { (5, 5) }\n@@ -63,7 +63,7 @@ LL | fn test2() -> (_, _) { (5, 5) }\n    |               |not allowed in type signatures\n    |               help: replace with the correct return type: `(i32, i32)`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/typeck_type_placeholder_item.rs:13:15\n    |\n LL | static TEST3: _ = \"test\";\n@@ -72,7 +72,7 @@ LL | static TEST3: _ = \"test\";\n    |               not allowed in type signatures\n    |               help: replace with the correct type: `&str`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/typeck_type_placeholder_item.rs:16:15\n    |\n LL | static TEST4: _ = 145;\n@@ -81,13 +81,13 @@ LL | static TEST4: _ = 145;\n    |               not allowed in type signatures\n    |               help: replace with the correct type: `i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/typeck_type_placeholder_item.rs:19:15\n    |\n LL | static TEST5: (_, _) = (1, 2);\n    |               ^^^^^^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:22:13\n    |\n LL | fn test6(_: _) { }\n@@ -98,7 +98,7 @@ help: use type parameters instead\n LL | fn test6<T>(_: T) { }\n    |         +++    ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:25:18\n    |\n LL | fn test6_b<T>(_: _, _: T) { }\n@@ -109,7 +109,7 @@ help: use type parameters instead\n LL | fn test6_b<T, U>(_: U, _: T) { }\n    |             +++     ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:28:30\n    |\n LL | fn test6_c<T, K, L, A, B>(_: _, _: (T, K, L, A, B)) { }\n@@ -120,7 +120,7 @@ help: use type parameters instead\n LL | fn test6_c<T, K, L, A, B, U>(_: U, _: (T, K, L, A, B)) { }\n    |                         +++     ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:31:13\n    |\n LL | fn test7(x: _) { let _x: usize = x; }\n@@ -131,7 +131,7 @@ help: use type parameters instead\n LL | fn test7<T>(x: T) { let _x: usize = x; }\n    |         +++    ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:34:22\n    |\n LL | fn test8(_f: fn() -> _) { }\n@@ -140,7 +140,7 @@ LL | fn test8(_f: fn() -> _) { }\n    |                      not allowed in type signatures\n    |                      help: use type parameters instead: `T`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:34:22\n    |\n LL | fn test8(_f: fn() -> _) { }\n@@ -151,7 +151,7 @@ help: use type parameters instead\n LL | fn test8<T>(_f: fn() -> T) { }\n    |         +++             ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:48:26\n    |\n LL | fn test11(x: &usize) -> &_ {\n@@ -160,7 +160,7 @@ LL | fn test11(x: &usize) -> &_ {\n    |                         |not allowed in type signatures\n    |                         help: replace with the correct return type: `&'static &'static usize`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:53:52\n    |\n LL | unsafe fn test12(x: *const usize) -> *const *const _ {\n@@ -169,7 +169,7 @@ LL | unsafe fn test12(x: *const usize) -> *const *const _ {\n    |                                      |             not allowed in type signatures\n    |                                      help: replace with the correct return type: `*const *const usize`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for structs\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for structs\n   --> $DIR/typeck_type_placeholder_item.rs:67:8\n    |\n LL |     a: _,\n@@ -194,7 +194,7 @@ error: missing type for `static` item\n LL |     static A = 42;\n    |            ^ help: provide a type for the static variable: `A: i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/typeck_type_placeholder_item.rs:75:15\n    |\n LL |     static B: _ = 42;\n@@ -203,13 +203,13 @@ LL |     static B: _ = 42;\n    |               not allowed in type signatures\n    |               help: replace with the correct type: `i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/typeck_type_placeholder_item.rs:77:15\n    |\n LL |     static C: Option<_> = Some(42);\n    |               ^^^^^^^^^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:79:21\n    |\n LL |     fn fn_test() -> _ { 5 }\n@@ -218,7 +218,7 @@ LL |     fn fn_test() -> _ { 5 }\n    |                     not allowed in type signatures\n    |                     help: replace with the correct return type: `i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:82:23\n    |\n LL |     fn fn_test2() -> (_, _) { (5, 5) }\n@@ -228,7 +228,7 @@ LL |     fn fn_test2() -> (_, _) { (5, 5) }\n    |                      |not allowed in type signatures\n    |                      help: replace with the correct return type: `(i32, i32)`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/typeck_type_placeholder_item.rs:85:22\n    |\n LL |     static FN_TEST3: _ = \"test\";\n@@ -237,7 +237,7 @@ LL |     static FN_TEST3: _ = \"test\";\n    |                      not allowed in type signatures\n    |                      help: replace with the correct type: `&str`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/typeck_type_placeholder_item.rs:88:22\n    |\n LL |     static FN_TEST4: _ = 145;\n@@ -246,13 +246,13 @@ LL |     static FN_TEST4: _ = 145;\n    |                      not allowed in type signatures\n    |                      help: replace with the correct type: `i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for static variables\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/typeck_type_placeholder_item.rs:91:22\n    |\n LL |     static FN_TEST5: (_, _) = (1, 2);\n    |                      ^^^^^^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:94:20\n    |\n LL |     fn fn_test6(_: _) { }\n@@ -263,7 +263,7 @@ help: use type parameters instead\n LL |     fn fn_test6<T>(_: T) { }\n    |                +++    ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:97:20\n    |\n LL |     fn fn_test7(x: _) { let _x: usize = x; }\n@@ -274,7 +274,7 @@ help: use type parameters instead\n LL |     fn fn_test7<T>(x: T) { let _x: usize = x; }\n    |                +++    ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:100:29\n    |\n LL |     fn fn_test8(_f: fn() -> _) { }\n@@ -283,7 +283,7 @@ LL |     fn fn_test8(_f: fn() -> _) { }\n    |                             not allowed in type signatures\n    |                             help: use type parameters instead: `T`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:100:29\n    |\n LL |     fn fn_test8(_f: fn() -> _) { }\n@@ -294,7 +294,7 @@ help: use type parameters instead\n LL |     fn fn_test8<T>(_f: fn() -> T) { }\n    |                +++             ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for structs\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for structs\n   --> $DIR/typeck_type_placeholder_item.rs:123:12\n    |\n LL |         a: _,\n@@ -319,15 +319,15 @@ error[E0282]: type annotations needed\n LL |     fn fn_test11(_: _) -> (_, _) { panic!() }\n    |                  ^ cannot infer type\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:128:28\n    |\n LL |     fn fn_test11(_: _) -> (_, _) { panic!() }\n    |                            ^  ^ not allowed in type signatures\n    |                            |\n    |                            not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:132:30\n    |\n LL |     fn fn_test12(x: i32) -> (_, _) { (x, x) }\n@@ -337,7 +337,7 @@ LL |     fn fn_test12(x: i32) -> (_, _) { (x, x) }\n    |                             |not allowed in type signatures\n    |                             help: replace with the correct return type: `(i32, i32)`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:135:33\n    |\n LL |     fn fn_test13(x: _) -> (i32, _) { (x, x) }\n@@ -346,7 +346,7 @@ LL |     fn fn_test13(x: _) -> (i32, _) { (x, x) }\n    |                           |     not allowed in type signatures\n    |                           help: replace with the correct return type: `(i32, i32)`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for structs\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for structs\n   --> $DIR/typeck_type_placeholder_item.rs:154:21\n    |\n LL | struct BadStruct<_>(_);\n@@ -357,7 +357,7 @@ help: use type parameters instead\n LL | struct BadStruct<T>(T);\n    |                  ~  ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for implementations\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for implementations\n   --> $DIR/typeck_type_placeholder_item.rs:159:15\n    |\n LL | impl BadTrait<_> for BadStruct<_> {}\n@@ -370,13 +370,13 @@ help: use type parameters instead\n LL | impl<T> BadTrait<T> for BadStruct<T> {}\n    |     +++          ~                ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for opaque types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for opaque types\n   --> $DIR/typeck_type_placeholder_item.rs:162:34\n    |\n LL | fn impl_trait() -> impl BadTrait<_> {\n    |                                  ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for structs\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for structs\n   --> $DIR/typeck_type_placeholder_item.rs:167:25\n    |\n LL | struct BadStruct1<_, _>(_);\n@@ -387,7 +387,7 @@ help: use type parameters instead\n LL | struct BadStruct1<T, _>(T);\n    |                   ~     ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for structs\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for structs\n   --> $DIR/typeck_type_placeholder_item.rs:172:25\n    |\n LL | struct BadStruct2<_, T>(_, T);\n@@ -398,19 +398,19 @@ help: use type parameters instead\n LL | struct BadStruct2<U, T>(U, T);\n    |                   ~     ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for type aliases\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for type aliases\n   --> $DIR/typeck_type_placeholder_item.rs:176:14\n    |\n LL | type X = Box<_>;\n    |              ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for opaque types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for opaque types\n   --> $DIR/typeck_type_placeholder_item.rs:182:21\n    |\n LL | type Y = impl Trait<_>;\n    |                     ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:216:31\n    |\n LL | fn value() -> Option<&'static _> {\n@@ -419,7 +419,7 @@ LL | fn value() -> Option<&'static _> {\n    |               |               not allowed in type signatures\n    |               help: replace with the correct return type: `Option<&'static u8>`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/typeck_type_placeholder_item.rs:221:10\n    |\n LL | const _: Option<_> = map(value);\n@@ -428,7 +428,7 @@ LL | const _: Option<_> = map(value);\n    |          not allowed in type signatures\n    |          help: replace with the correct type: `Option<u8>`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:140:31\n    |\n LL |     fn method_test1(&self, x: _);\n@@ -439,7 +439,7 @@ help: use type parameters instead\n LL |     fn method_test1<T>(&self, x: T);\n    |                    +++           ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:142:31\n    |\n LL |     fn method_test2(&self, x: _) -> _;\n@@ -452,7 +452,7 @@ help: use type parameters instead\n LL |     fn method_test2<T>(&self, x: T) -> T;\n    |                    +++           ~     ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:144:31\n    |\n LL |     fn method_test3(&self) -> _;\n@@ -463,7 +463,7 @@ help: use type parameters instead\n LL |     fn method_test3<T>(&self) -> T;\n    |                    +++           ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:146:26\n    |\n LL |     fn assoc_fn_test1(x: _);\n@@ -474,7 +474,7 @@ help: use type parameters instead\n LL |     fn assoc_fn_test1<T>(x: T);\n    |                      +++    ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:148:26\n    |\n LL |     fn assoc_fn_test2(x: _) -> _;\n@@ -487,7 +487,7 @@ help: use type parameters instead\n LL |     fn assoc_fn_test2<T>(x: T) -> T;\n    |                      +++    ~     ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:150:28\n    |\n LL |     fn assoc_fn_test3() -> _;\n@@ -498,19 +498,19 @@ help: use type parameters instead\n LL |     fn assoc_fn_test3<T>() -> T;\n    |                      +++      ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for associated types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for associated types\n   --> $DIR/typeck_type_placeholder_item.rs:190:14\n    |\n LL |     type B = _;\n    |              ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/typeck_type_placeholder_item.rs:192:14\n    |\n LL |     const C: _;\n    |              ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/typeck_type_placeholder_item.rs:194:14\n    |\n LL |     const D: _ = 42;\n@@ -519,13 +519,13 @@ LL |     const D: _ = 42;\n    |              not allowed in type signatures\n    |              help: replace with the correct type: `i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for associated types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for associated types\n   --> $DIR/typeck_type_placeholder_item.rs:197:26\n    |\n LL |     type F: std::ops::Fn(_);\n    |                          ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:41:24\n    |\n LL |     fn test9(&self) -> _ { () }\n@@ -534,7 +534,7 @@ LL |     fn test9(&self) -> _ { () }\n    |                        not allowed in type signatures\n    |                        help: replace with the correct return type: `()`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:44:27\n    |\n LL |     fn test10(&self, _x : _) { }\n@@ -545,7 +545,7 @@ help: use type parameters instead\n LL |     fn test10<T>(&self, _x : T) { }\n    |              +++             ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:59:24\n    |\n LL |     fn clone(&self) -> _ { Test9 }\n@@ -554,7 +554,7 @@ LL |     fn clone(&self) -> _ { Test9 }\n    |                        not allowed in type signatures\n    |                        help: replace with the correct return type: `Test9`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:62:37\n    |\n LL |     fn clone_from(&mut self, other: _) { *self = Test9; }\n@@ -565,7 +565,7 @@ help: use type parameters instead\n LL |     fn clone_from<T>(&mut self, other: T) { *self = Test9; }\n    |                  +++                   ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:107:31\n    |\n LL |         fn fn_test9(&self) -> _ { () }\n@@ -574,7 +574,7 @@ LL |         fn fn_test9(&self) -> _ { () }\n    |                               not allowed in type signatures\n    |                               help: replace with the correct return type: `()`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:110:34\n    |\n LL |         fn fn_test10(&self, _x : _) { }\n@@ -585,7 +585,7 @@ help: use type parameters instead\n LL |         fn fn_test10<T>(&self, _x : T) { }\n    |                     +++             ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:115:28\n    |\n LL |         fn clone(&self) -> _ { FnTest9 }\n@@ -594,7 +594,7 @@ LL |         fn clone(&self) -> _ { FnTest9 }\n    |                            not allowed in type signatures\n    |                            help: replace with the correct return type: `FnTest9`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:118:41\n    |\n LL |         fn clone_from(&mut self, other: _) { *self = FnTest9; }\n@@ -605,25 +605,25 @@ help: use type parameters instead\n LL |         fn clone_from<T>(&mut self, other: T) { *self = FnTest9; }\n    |                      +++                   ~\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for associated types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for associated types\n   --> $DIR/typeck_type_placeholder_item.rs:201:14\n    |\n LL |     type A = _;\n    |              ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for associated types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for associated types\n   --> $DIR/typeck_type_placeholder_item.rs:203:14\n    |\n LL |     type B = _;\n    |              ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/typeck_type_placeholder_item.rs:205:14\n    |\n LL |     const C: _;\n    |              ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/typeck_type_placeholder_item.rs:208:14\n    |\n LL |     const D: _ = 42;"}, {"sha": "53f31b683c1a4c4e3d725419d76a23c0ea040a2d", "filename": "src/test/ui/typeck/typeck_type_placeholder_item_help.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.rs?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -2,27 +2,27 @@\n // using the `_` type placeholder.\n \n fn test1() -> _ { Some(42) }\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for return types\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n \n const TEST2: _ = 42u32;\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n \n const TEST3: _ = Some(42);\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n \n const TEST4: fn() -> _ = 42;\n-//~^ ERROR the type placeholder `_` is not allowed within types on item signatures for functions\n+//~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n trait Test5 {\n     const TEST5: _ = 42;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n }\n \n struct Test6;\n \n impl Test6 {\n     const TEST6: _ = 13;\n-    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures for constants\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for constants\n }\n \n pub fn main() {"}, {"sha": "e8191832318e5b7f532eed9bf875b58233fc7db6", "filename": "src/test/ui/typeck/typeck_type_placeholder_item_help.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item_help.stderr?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1,4 +1,4 @@\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item_help.rs:4:15\n    |\n LL | fn test1() -> _ { Some(42) }\n@@ -7,7 +7,7 @@ LL | fn test1() -> _ { Some(42) }\n    |               not allowed in type signatures\n    |               help: replace with the correct return type: `Option<i32>`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/typeck_type_placeholder_item_help.rs:7:14\n    |\n LL | const TEST2: _ = 42u32;\n@@ -16,7 +16,7 @@ LL | const TEST2: _ = 42u32;\n    |              not allowed in type signatures\n    |              help: replace with the correct type: `u32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/typeck_type_placeholder_item_help.rs:10:14\n    |\n LL | const TEST3: _ = Some(42);\n@@ -25,13 +25,13 @@ LL | const TEST3: _ = Some(42);\n    |              not allowed in type signatures\n    |              help: replace with the correct type: `Option<i32>`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for functions\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item_help.rs:13:22\n    |\n LL | const TEST4: fn() -> _ = 42;\n    |                      ^ not allowed in type signatures\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/typeck_type_placeholder_item_help.rs:17:18\n    |\n LL |     const TEST5: _ = 42;\n@@ -40,7 +40,7 @@ LL |     const TEST5: _ = 42;\n    |                  not allowed in type signatures\n    |                  help: replace with the correct type: `i32`\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures for constants\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/typeck_type_placeholder_item_help.rs:24:18\n    |\n LL |     const TEST6: _ = 13;"}, {"sha": "9700addc82111200a2150b9a796f62dd8e600ddf", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b", "patch": "@@ -1 +1 @@\n-Subproject commit 8e9ccbf97a70259b6c6576e8fd7d77d28238737e\n+Subproject commit 9700addc82111200a2150b9a796f62dd8e600ddf"}]}