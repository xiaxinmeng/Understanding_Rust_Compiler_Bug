{"sha": "9b045069241f3a610f5ee1ff448e6e8997b5f92f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMDQ1MDY5MjQxZjNhNjEwZjVlZTFmZjQ0OGU2ZTg5OTdiNWY5MmY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-13T20:41:04Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-02-13T20:41:04Z"}, "message": "Fallback to renaming input NameRef node for macros when inside macro", "tree": {"sha": "65b0dd2e3a7309b3c5a87d2a98c640052ce36c61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65b0dd2e3a7309b3c5a87d2a98c640052ce36c61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b045069241f3a610f5ee1ff448e6e8997b5f92f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b045069241f3a610f5ee1ff448e6e8997b5f92f", "html_url": "https://github.com/rust-lang/rust/commit/9b045069241f3a610f5ee1ff448e6e8997b5f92f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b045069241f3a610f5ee1ff448e6e8997b5f92f/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1901172841c3986900633b4d216926f200fa35e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1901172841c3986900633b4d216926f200fa35e5", "html_url": "https://github.com/rust-lang/rust/commit/1901172841c3986900633b4d216926f200fa35e5"}], "stats": {"total": 69, "additions": 53, "deletions": 16}, "files": [{"sha": "bbd9426b6aac25ebf3f4c49e998789c39771f542", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9b045069241f3a610f5ee1ff448e6e8997b5f92f/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b045069241f3a610f5ee1ff448e6e8997b5f92f/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=9b045069241f3a610f5ee1ff448e6e8997b5f92f", "patch": "@@ -183,13 +183,16 @@ fn source_edit_from_references(\n ) -> (FileId, TextEdit) {\n     let mut edit = TextEdit::builder();\n     for reference in references {\n-        let (range, replacement) = if let Some(name_ref) = reference.name.as_name_ref() {\n-            source_edit_from_name_ref(name_ref, new_name, def)\n-        } else {\n-            (None, new_name.to_owned())\n+        match reference.name.as_name_ref() {\n+            // if the ranges differ then the node is inside a macro call, we can't really attempt\n+            // to make special rewrites like shorthand syntax and such, so just rename the node in\n+            // the macro input\n+            Some(name_ref) if name_ref.syntax().text_range() == reference.range => {\n+                let (range, replacement) = source_edit_from_name_ref(name_ref, new_name, def);\n+                edit.replace(range, replacement);\n+            }\n+            _ => edit.replace(reference.range, new_name.to_owned()),\n         };\n-        // FIXME: Some(range) will be incorrect when we are inside macros\n-        edit.replace(range.unwrap_or(reference.range), replacement);\n     }\n     (file_id, edit.finish())\n }\n@@ -198,7 +201,7 @@ fn source_edit_from_name_ref(\n     name_ref: &ast::NameRef,\n     new_name: &str,\n     def: Definition,\n-) -> (Option<TextRange>, String) {\n+) -> (TextRange, String) {\n     if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n         let rcf_name_ref = record_field.name_ref();\n         let rcf_expr = record_field.expr();\n@@ -208,20 +211,20 @@ fn source_edit_from_name_ref(\n                 if field_name == *name_ref {\n                     if init.text() == new_name {\n                         mark::hit!(test_rename_field_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead\n+                        // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n                         let s = field_name.syntax().text_range().start();\n                         let e = record_field.syntax().text_range().end();\n-                        return (Some(TextRange::new(s, e)), format!(\"{}\", new_name));\n+                        return (TextRange::new(s, e), new_name.to_owned());\n                     }\n                 } else if init == *name_ref {\n                     if field_name.text() == new_name {\n                         mark::hit!(test_rename_local_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead\n+                        // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n                         let s = field_name.syntax().text_range().start();\n                         let e = record_field.syntax().text_range().end();\n-                        return (Some(TextRange::new(s, e)), format!(\"{}\", new_name));\n+                        return (TextRange::new(s, e), new_name.to_owned());\n                     }\n                 }\n             }\n@@ -233,12 +236,12 @@ fn source_edit_from_name_ref(\n                     Definition::Field(_) => {\n                         mark::hit!(test_rename_field_in_field_shorthand);\n                         let s = name_ref.syntax().text_range().start();\n-                        return (Some(TextRange::empty(s)), format!(\"{}: \", new_name));\n+                        return (TextRange::empty(s), format!(\"{}: \", new_name));\n                     }\n                     Definition::Local(_) => {\n                         mark::hit!(test_rename_local_in_field_shorthand);\n                         let s = name_ref.syntax().text_range().end();\n-                        return (Some(TextRange::empty(s)), format!(\": {}\", new_name));\n+                        return (TextRange::empty(s), format!(\": {}\", new_name));\n                     }\n                     _ => {}\n                 }\n@@ -255,17 +258,17 @@ fn source_edit_from_name_ref(\n                 // field name is being renamed\n                 if pat.name().map_or(false, |it| it.text() == new_name) {\n                     mark::hit!(test_rename_field_put_init_shorthand_pat);\n-                    // same names, we can use a shorthand here instead\n+                    // same names, we can use a shorthand here instead/\n                     // we do not want to erase attributes hence this range start\n                     let s = field_name.syntax().text_range().start();\n                     let e = record_field.syntax().text_range().end();\n-                    return (Some(TextRange::new(s, e)), format!(\"{}\", new_name));\n+                    return (TextRange::new(s, e), new_name.to_owned());\n                 }\n             }\n             _ => {}\n         }\n     }\n-    (None, format!(\"{}\", new_name))\n+    (name_ref.syntax().text_range(), new_name.to_owned())\n }\n \n fn rename_mod(\n@@ -1682,6 +1685,40 @@ struct Foo;\n impl Foo {\n     fn foo(self) {}\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_rename_field_in_pat_in_macro_doesnt_shorthand() {\n+        // ideally we would be able to make this emit a short hand, but I doubt this is easily possible\n+        check(\n+            \"baz\",\n+            r#\"\n+macro_rules! foo {\n+    ($pattern:pat) => {\n+        let $pattern = loop {};\n+    };\n+}\n+struct Foo {\n+    bar$0: u32,\n+}\n+fn foo() {\n+    foo!(Foo { bar: baz });\n+}\n+\"#,\n+            r#\"\n+macro_rules! foo {\n+    ($pattern:pat) => {\n+        let $pattern = loop {};\n+    };\n+}\n+struct Foo {\n+    baz: u32,\n+}\n+fn foo() {\n+    foo!(Foo { baz: baz });\n+}\n \"#,\n         )\n     }"}]}