{"sha": "842e8001b287b0e3d77215235ae96a3bd8944207", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MmU4MDAxYjI4N2IwZTNkNzcyMTUyMzVhZTk2YTNiZDg5NDQyMDc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-08T08:52:18Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-08T11:34:30Z"}, "message": "move changes to a separate file", "tree": {"sha": "671c17814199a95510121c359191a3217ba2c207", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/671c17814199a95510121c359191a3217ba2c207"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/842e8001b287b0e3d77215235ae96a3bd8944207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/842e8001b287b0e3d77215235ae96a3bd8944207", "html_url": "https://github.com/rust-lang/rust/commit/842e8001b287b0e3d77215235ae96a3bd8944207", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/842e8001b287b0e3d77215235ae96a3bd8944207/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a1d2a46c249fa81294c156b9e23b624e14495cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a1d2a46c249fa81294c156b9e23b624e14495cd", "html_url": "https://github.com/rust-lang/rust/commit/9a1d2a46c249fa81294c156b9e23b624e14495cd"}], "stats": {"total": 517, "additions": 263, "deletions": 254}, "files": [{"sha": "992955740474666c239d39ebf750edeabab862b2", "filename": "crates/ra_ide_api/src/change.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/842e8001b287b0e3d77215235ae96a3bd8944207/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/842e8001b287b0e3d77215235ae96a3bd8944207/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=842e8001b287b0e3d77215235ae96a3bd8944207", "patch": "@@ -0,0 +1,255 @@\n+use std::{\n+    fmt, time,\n+    sync::Arc,\n+};\n+\n+use rustc_hash::FxHashMap;\n+use ra_db::{\n+    SourceRootId, FileId, CrateGraph, SourceDatabase, SourceRoot,\n+    salsa::{Database, SweepStrategy},\n+};\n+use ra_syntax::SourceFile;\n+use relative_path::RelativePathBuf;\n+use rayon::prelude::*;\n+\n+use crate::{\n+    db::RootDatabase,\n+    symbol_index::{SymbolIndex, SymbolsDatabase},\n+    status::syntax_tree_stats,\n+};\n+\n+#[derive(Default)]\n+pub struct AnalysisChange {\n+    new_roots: Vec<(SourceRootId, bool)>,\n+    roots_changed: FxHashMap<SourceRootId, RootChange>,\n+    files_changed: Vec<(FileId, Arc<String>)>,\n+    libraries_added: Vec<LibraryData>,\n+    crate_graph: Option<CrateGraph>,\n+}\n+\n+impl fmt::Debug for AnalysisChange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let mut d = fmt.debug_struct(\"AnalysisChange\");\n+        if !self.new_roots.is_empty() {\n+            d.field(\"new_roots\", &self.new_roots);\n+        }\n+        if !self.roots_changed.is_empty() {\n+            d.field(\"roots_changed\", &self.roots_changed);\n+        }\n+        if !self.files_changed.is_empty() {\n+            d.field(\"files_changed\", &self.files_changed.len());\n+        }\n+        if !self.libraries_added.is_empty() {\n+            d.field(\"libraries_added\", &self.libraries_added.len());\n+        }\n+        if !self.crate_graph.is_some() {\n+            d.field(\"crate_graph\", &self.crate_graph);\n+        }\n+        d.finish()\n+    }\n+}\n+\n+impl AnalysisChange {\n+    pub fn new() -> AnalysisChange {\n+        AnalysisChange::default()\n+    }\n+\n+    pub fn add_root(&mut self, root_id: SourceRootId, is_local: bool) {\n+        self.new_roots.push((root_id, is_local));\n+    }\n+\n+    pub fn add_file(\n+        &mut self,\n+        root_id: SourceRootId,\n+        file_id: FileId,\n+        path: RelativePathBuf,\n+        text: Arc<String>,\n+    ) {\n+        let file = AddFile {\n+            file_id,\n+            path,\n+            text,\n+        };\n+        self.roots_changed\n+            .entry(root_id)\n+            .or_default()\n+            .added\n+            .push(file);\n+    }\n+\n+    pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n+        self.files_changed.push((file_id, new_text))\n+    }\n+\n+    pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n+        let file = RemoveFile { file_id, path };\n+        self.roots_changed\n+            .entry(root_id)\n+            .or_default()\n+            .removed\n+            .push(file);\n+    }\n+\n+    pub fn add_library(&mut self, data: LibraryData) {\n+        self.libraries_added.push(data)\n+    }\n+\n+    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n+        self.crate_graph = Some(graph);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct AddFile {\n+    file_id: FileId,\n+    path: RelativePathBuf,\n+    text: Arc<String>,\n+}\n+\n+#[derive(Debug)]\n+struct RemoveFile {\n+    file_id: FileId,\n+    path: RelativePathBuf,\n+}\n+\n+#[derive(Default)]\n+struct RootChange {\n+    added: Vec<AddFile>,\n+    removed: Vec<RemoveFile>,\n+}\n+\n+impl fmt::Debug for RootChange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.debug_struct(\"AnalysisChange\")\n+            .field(\"added\", &self.added.len())\n+            .field(\"removed\", &self.removed.len())\n+            .finish()\n+    }\n+}\n+\n+pub struct LibraryData {\n+    root_id: SourceRootId,\n+    root_change: RootChange,\n+    symbol_index: SymbolIndex,\n+}\n+\n+impl fmt::Debug for LibraryData {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"LibraryData\")\n+            .field(\"root_id\", &self.root_id)\n+            .field(\"root_change\", &self.root_change)\n+            .field(\"n_symbols\", &self.symbol_index.len())\n+            .finish()\n+    }\n+}\n+\n+impl LibraryData {\n+    pub fn prepare(\n+        root_id: SourceRootId,\n+        files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n+    ) -> LibraryData {\n+        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, _, text)| {\n+            let file = SourceFile::parse(text);\n+            (*file_id, file)\n+        }));\n+        let mut root_change = RootChange::default();\n+        root_change.added = files\n+            .into_iter()\n+            .map(|(file_id, path, text)| AddFile {\n+                file_id,\n+                path,\n+                text,\n+            })\n+            .collect();\n+        LibraryData {\n+            root_id,\n+            root_change,\n+            symbol_index,\n+        }\n+    }\n+}\n+\n+const GC_COOLDOWN: time::Duration = time::Duration::from_millis(100);\n+\n+impl RootDatabase {\n+    pub(crate) fn apply_change(&mut self, change: AnalysisChange) {\n+        log::info!(\"apply_change {:?}\", change);\n+        if !change.new_roots.is_empty() {\n+            let mut local_roots = Vec::clone(&self.local_roots());\n+            for (root_id, is_local) in change.new_roots {\n+                self.set_source_root(root_id, Default::default());\n+                if is_local {\n+                    local_roots.push(root_id);\n+                }\n+            }\n+            self.set_local_roots(Arc::new(local_roots));\n+        }\n+\n+        for (root_id, root_change) in change.roots_changed {\n+            self.apply_root_change(root_id, root_change);\n+        }\n+        for (file_id, text) in change.files_changed {\n+            self.set_file_text(file_id, text)\n+        }\n+        if !change.libraries_added.is_empty() {\n+            let mut libraries = Vec::clone(&self.library_roots());\n+            for library in change.libraries_added {\n+                libraries.push(library.root_id);\n+                self.set_source_root(library.root_id, Default::default());\n+                self.set_constant_library_symbols(library.root_id, Arc::new(library.symbol_index));\n+                self.apply_root_change(library.root_id, library.root_change);\n+            }\n+            self.set_library_roots(Arc::new(libraries));\n+        }\n+        if let Some(crate_graph) = change.crate_graph {\n+            self.set_crate_graph(Arc::new(crate_graph))\n+        }\n+    }\n+\n+    fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n+        let mut source_root = SourceRoot::clone(&self.source_root(root_id));\n+        for add_file in root_change.added {\n+            self.set_file_text(add_file.file_id, add_file.text);\n+            self.set_file_relative_path(add_file.file_id, add_file.path.clone());\n+            self.set_file_source_root(add_file.file_id, root_id);\n+            source_root.files.insert(add_file.path, add_file.file_id);\n+        }\n+        for remove_file in root_change.removed {\n+            self.set_file_text(remove_file.file_id, Default::default());\n+            source_root.files.remove(&remove_file.path);\n+        }\n+        self.set_source_root(root_id, Arc::new(source_root));\n+    }\n+\n+    pub(crate) fn maybe_collect_garbage(&mut self) {\n+        if self.last_gc_check.elapsed() > GC_COOLDOWN {\n+            self.last_gc_check = time::Instant::now();\n+            let retained_trees = syntax_tree_stats(self).retained;\n+            if retained_trees > 100 {\n+                log::info!(\n+                    \"automatic garbadge collection, {} retained trees\",\n+                    retained_trees\n+                );\n+                self.collect_garbage();\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn collect_garbage(&mut self) {\n+        self.last_gc = time::Instant::now();\n+\n+        let sweep = SweepStrategy::default()\n+            .discard_values()\n+            .sweep_all_revisions();\n+\n+        self.query(ra_db::ParseQuery).sweep(sweep);\n+\n+        self.query(hir::db::HirParseQuery).sweep(sweep);\n+        self.query(hir::db::FileItemsQuery).sweep(sweep);\n+        self.query(hir::db::FileItemQuery).sweep(sweep);\n+\n+        self.query(hir::db::LowerModuleQuery).sweep(sweep);\n+        self.query(hir::db::LowerModuleSourceMapQuery).sweep(sweep);\n+        self.query(hir::db::BodySyntaxMappingQuery).sweep(sweep);\n+    }\n+}"}, {"sha": "7d672656f7a28e60bfde9265393f87c9da5b5859", "filename": "crates/ra_ide_api/src/imp.rs", "status": "modified", "additions": 3, "deletions": 98, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/842e8001b287b0e3d77215235ae96a3bd8944207/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/842e8001b287b0e3d77215235ae96a3bd8944207/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimp.rs?ref=842e8001b287b0e3d77215235ae96a3bd8944207", "patch": "@@ -1,115 +1,20 @@\n-use std::{\n-    sync::Arc,\n-    time,\n-};\n-\n use hir::{\n     self, Problem, source_binder\n };\n-use ra_db::{\n-    SourceDatabase, SourceRoot, SourceRootId,\n-    salsa::{Database, SweepStrategy},\n-};\n use ra_ide_api_light::{self, LocalEdit, Severity};\n use ra_syntax::{\n     algo::find_node_at_offset, ast::{self, NameOwner}, AstNode,\n     SourceFile,\n     TextRange,\n };\n+use ra_db::SourceDatabase;\n \n use crate::{\n-    AnalysisChange,\n     CrateId, db, Diagnostic, FileId, FilePosition, FileSystemEdit,\n-    Query, RootChange, SourceChange, SourceFileEdit,\n-    symbol_index::{FileSymbol, SymbolsDatabase},\n-    status::syntax_tree_stats\n+    Query, SourceChange, SourceFileEdit,\n+    symbol_index::FileSymbol,\n };\n \n-const GC_COOLDOWN: time::Duration = time::Duration::from_millis(100);\n-\n-impl db::RootDatabase {\n-    pub(crate) fn apply_change(&mut self, change: AnalysisChange) {\n-        log::info!(\"apply_change {:?}\", change);\n-        if !change.new_roots.is_empty() {\n-            let mut local_roots = Vec::clone(&self.local_roots());\n-            for (root_id, is_local) in change.new_roots {\n-                self.set_source_root(root_id, Default::default());\n-                if is_local {\n-                    local_roots.push(root_id);\n-                }\n-            }\n-            self.set_local_roots(Arc::new(local_roots));\n-        }\n-\n-        for (root_id, root_change) in change.roots_changed {\n-            self.apply_root_change(root_id, root_change);\n-        }\n-        for (file_id, text) in change.files_changed {\n-            self.set_file_text(file_id, text)\n-        }\n-        if !change.libraries_added.is_empty() {\n-            let mut libraries = Vec::clone(&self.library_roots());\n-            for library in change.libraries_added {\n-                libraries.push(library.root_id);\n-                self.set_source_root(library.root_id, Default::default());\n-                self.set_constant_library_symbols(library.root_id, Arc::new(library.symbol_index));\n-                self.apply_root_change(library.root_id, library.root_change);\n-            }\n-            self.set_library_roots(Arc::new(libraries));\n-        }\n-        if let Some(crate_graph) = change.crate_graph {\n-            self.set_crate_graph(Arc::new(crate_graph))\n-        }\n-    }\n-\n-    fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n-        let mut source_root = SourceRoot::clone(&self.source_root(root_id));\n-        for add_file in root_change.added {\n-            self.set_file_text(add_file.file_id, add_file.text);\n-            self.set_file_relative_path(add_file.file_id, add_file.path.clone());\n-            self.set_file_source_root(add_file.file_id, root_id);\n-            source_root.files.insert(add_file.path, add_file.file_id);\n-        }\n-        for remove_file in root_change.removed {\n-            self.set_file_text(remove_file.file_id, Default::default());\n-            source_root.files.remove(&remove_file.path);\n-        }\n-        self.set_source_root(root_id, Arc::new(source_root));\n-    }\n-\n-    pub(crate) fn maybe_collect_garbage(&mut self) {\n-        if self.last_gc_check.elapsed() > GC_COOLDOWN {\n-            self.last_gc_check = time::Instant::now();\n-            let retained_trees = syntax_tree_stats(self).retained;\n-            if retained_trees > 100 {\n-                log::info!(\n-                    \"automatic garbadge collection, {} retained trees\",\n-                    retained_trees\n-                );\n-                self.collect_garbage();\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn collect_garbage(&mut self) {\n-        self.last_gc = time::Instant::now();\n-\n-        let sweep = SweepStrategy::default()\n-            .discard_values()\n-            .sweep_all_revisions();\n-\n-        self.query(ra_db::ParseQuery).sweep(sweep);\n-\n-        self.query(hir::db::HirParseQuery).sweep(sweep);\n-        self.query(hir::db::FileItemsQuery).sweep(sweep);\n-        self.query(hir::db::FileItemQuery).sweep(sweep);\n-\n-        self.query(hir::db::LowerModuleQuery).sweep(sweep);\n-        self.query(hir::db::LowerModuleSourceMapQuery).sweep(sweep);\n-        self.query(hir::db::BodySyntaxMappingQuery).sweep(sweep);\n-    }\n-}\n-\n impl db::RootDatabase {\n     /// Returns `Vec` for the same reason as `parent_module`\n     pub(crate) fn crate_for(&self, file_id: FileId) -> Vec<CrateId> {"}, {"sha": "4fb0541395119a4f0dd57cdad723710dcf485cfc", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/842e8001b287b0e3d77215235ae96a3bd8944207/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/842e8001b287b0e3d77215235ae96a3bd8944207/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=842e8001b287b0e3d77215235ae96a3bd8944207", "patch": "@@ -1,4 +1,4 @@\n-use ra_db::{SourceDatabase};\n+use ra_db::SourceDatabase;\n use ra_syntax::{\n     AstNode, ast,\n     algo::find_node_at_offset,"}, {"sha": "22a601ec815f965d9e7656cab02d5dbb7bc06edc", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 4, "deletions": 155, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/842e8001b287b0e3d77215235ae96a3bd8944207/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/842e8001b287b0e3d77215235ae96a3bd8944207/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=842e8001b287b0e3d77215235ae96a3bd8944207", "patch": "@@ -18,6 +18,7 @@ mod imp;\n pub mod mock_analysis;\n mod symbol_index;\n mod navigation_target;\n+mod change;\n \n mod status;\n mod completion;\n@@ -35,27 +36,26 @@ mod assists;\n #[cfg(test)]\n mod marks;\n \n-use std::{fmt, sync::Arc};\n+use std::sync::Arc;\n \n use ra_syntax::{SourceFile, TreeArc, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n use ra_db::{\n     SourceDatabase, CheckCanceled,\n     salsa::{self, ParallelDatabase},\n };\n-use rayon::prelude::*;\n use relative_path::RelativePathBuf;\n-use rustc_hash::FxHashMap;\n \n use crate::{\n-    symbol_index::{FileSymbol, SymbolIndex},\n+    symbol_index::FileSymbol,\n     db::LineIndexDatabase,\n };\n \n pub use crate::{\n     completion::{CompletionItem, CompletionItemKind, InsertTextFormat},\n     runnables::{Runnable, RunnableKind},\n     navigation_target::NavigationTarget,\n+    change::{AnalysisChange, LibraryData},\n };\n pub use ra_ide_api_light::{\n     Fold, FoldKind, HighlightedRange, Severity, StructureNode,\n@@ -74,115 +74,6 @@ static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n \n pub type Cancelable<T> = Result<T, Canceled>;\n \n-#[derive(Default)]\n-pub struct AnalysisChange {\n-    new_roots: Vec<(SourceRootId, bool)>,\n-    roots_changed: FxHashMap<SourceRootId, RootChange>,\n-    files_changed: Vec<(FileId, Arc<String>)>,\n-    libraries_added: Vec<LibraryData>,\n-    crate_graph: Option<CrateGraph>,\n-}\n-\n-#[derive(Default)]\n-struct RootChange {\n-    added: Vec<AddFile>,\n-    removed: Vec<RemoveFile>,\n-}\n-\n-#[derive(Debug)]\n-struct AddFile {\n-    file_id: FileId,\n-    path: RelativePathBuf,\n-    text: Arc<String>,\n-}\n-\n-#[derive(Debug)]\n-struct RemoveFile {\n-    file_id: FileId,\n-    path: RelativePathBuf,\n-}\n-\n-impl fmt::Debug for AnalysisChange {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut d = fmt.debug_struct(\"AnalysisChange\");\n-        if !self.new_roots.is_empty() {\n-            d.field(\"new_roots\", &self.new_roots);\n-        }\n-        if !self.roots_changed.is_empty() {\n-            d.field(\"roots_changed\", &self.roots_changed);\n-        }\n-        if !self.files_changed.is_empty() {\n-            d.field(\"files_changed\", &self.files_changed.len());\n-        }\n-        if !self.libraries_added.is_empty() {\n-            d.field(\"libraries_added\", &self.libraries_added.len());\n-        }\n-        if self.crate_graph.is_none() {\n-            d.field(\"crate_graph\", &self.crate_graph);\n-        }\n-        d.finish()\n-    }\n-}\n-\n-impl fmt::Debug for RootChange {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.debug_struct(\"AnalysisChange\")\n-            .field(\"added\", &self.added.len())\n-            .field(\"removed\", &self.removed.len())\n-            .finish()\n-    }\n-}\n-\n-impl AnalysisChange {\n-    pub fn new() -> AnalysisChange {\n-        AnalysisChange::default()\n-    }\n-\n-    pub fn add_root(&mut self, root_id: SourceRootId, is_local: bool) {\n-        self.new_roots.push((root_id, is_local));\n-    }\n-\n-    pub fn add_file(\n-        &mut self,\n-        root_id: SourceRootId,\n-        file_id: FileId,\n-        path: RelativePathBuf,\n-        text: Arc<String>,\n-    ) {\n-        let file = AddFile {\n-            file_id,\n-            path,\n-            text,\n-        };\n-        self.roots_changed\n-            .entry(root_id)\n-            .or_default()\n-            .added\n-            .push(file);\n-    }\n-\n-    pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n-        self.files_changed.push((file_id, new_text))\n-    }\n-\n-    pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n-        let file = RemoveFile { file_id, path };\n-        self.roots_changed\n-            .entry(root_id)\n-            .or_default()\n-            .removed\n-            .push(file);\n-    }\n-\n-    pub fn add_library(&mut self, data: LibraryData) {\n-        self.libraries_added.push(data)\n-    }\n-\n-    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n-        self.crate_graph = Some(graph);\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct SourceChange {\n     pub label: String,\n@@ -508,48 +399,6 @@ impl Analysis {\n     }\n }\n \n-pub struct LibraryData {\n-    root_id: SourceRootId,\n-    root_change: RootChange,\n-    symbol_index: SymbolIndex,\n-}\n-\n-impl fmt::Debug for LibraryData {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LibraryData\")\n-            .field(\"root_id\", &self.root_id)\n-            .field(\"root_change\", &self.root_change)\n-            .field(\"n_symbols\", &self.symbol_index.len())\n-            .finish()\n-    }\n-}\n-\n-impl LibraryData {\n-    pub fn prepare(\n-        root_id: SourceRootId,\n-        files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n-    ) -> LibraryData {\n-        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, _, text)| {\n-            let file = SourceFile::parse(text);\n-            (*file_id, file)\n-        }));\n-        let mut root_change = RootChange::default();\n-        root_change.added = files\n-            .into_iter()\n-            .map(|(file_id, path, text)| AddFile {\n-                file_id,\n-                path,\n-                text,\n-            })\n-            .collect();\n-        LibraryData {\n-            root_id,\n-            root_change,\n-            symbol_index,\n-        }\n-    }\n-}\n-\n #[test]\n fn analysis_is_send() {\n     fn is_send<T: Send>() {}"}]}