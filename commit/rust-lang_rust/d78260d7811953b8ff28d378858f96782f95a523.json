{"sha": "d78260d7811953b8ff28d378858f96782f95a523", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ODI2MGQ3ODExOTUzYjhmZjI4ZDM3ODg1OGY5Njc4MmY5NWE1MjM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-12T02:22:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-12T02:22:47Z"}, "message": "Rollup merge of #61568 - Mark-Simulacrum:symbol-fmt-macros, r=estebank\n\nUse Symbol, Span in libfmt_macros\n\nI'm not super happy with this, personally, but I think it might be a decent start -- happy to take suggestions as to how to expand this or change things further.\n\nr? @estebank\n\nFixes #60795", "tree": {"sha": "36959e6a04f1f903ef43cf5dab893a224a541735", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36959e6a04f1f903ef43cf5dab893a224a541735"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d78260d7811953b8ff28d378858f96782f95a523", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdAGH3CRBK7hj4Ov3rIwAAdHIIAANwVnOjiBi0IF2e7TiChUES\nDkrVHFTkRiMJBQWp1INTMru7d/sbRdhwYDj6hLdUNou12TCDTRwv3NZIUg8r0MEk\nzx6z5J/8FaHiw5hOk6YTFMc8DrckybByqyG7vaIz532zPyPIVZsE39l2J+mccHC6\nss+YiELmsv0skUaaGeInxgFYJ+CqCsbawqP8u2iFl5LMEUnJ6BIGMOL3xjYjvJfW\nGWaMvRv58ZpugcdX13W8ul/IWgISGkzlJnwVvXXIosyK8Ai0lbkayHA8cK0SsdM4\nikLXJoN8WHBShZh8ZKbH3bZrkkA/1q0sMfS+m6oKIdMkv2eGxpSYJr9DzB0V9hI=\n=hHy6\n-----END PGP SIGNATURE-----\n", "payload": "tree 36959e6a04f1f903ef43cf5dab893a224a541735\nparent b5184e56a49652aadb279e42a4e55e7328071b35\nparent 45df52f2cca9bee04690f476f4a3f791ea1b04cc\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1560306167 +0200\ncommitter GitHub <noreply@github.com> 1560306167 +0200\n\nRollup merge of #61568 - Mark-Simulacrum:symbol-fmt-macros, r=estebank\n\nUse Symbol, Span in libfmt_macros\n\nI'm not super happy with this, personally, but I think it might be a decent start -- happy to take suggestions as to how to expand this or change things further.\n\nr? @estebank\n\nFixes #60795\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d78260d7811953b8ff28d378858f96782f95a523", "html_url": "https://github.com/rust-lang/rust/commit/d78260d7811953b8ff28d378858f96782f95a523", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d78260d7811953b8ff28d378858f96782f95a523/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5184e56a49652aadb279e42a4e55e7328071b35", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5184e56a49652aadb279e42a4e55e7328071b35", "html_url": "https://github.com/rust-lang/rust/commit/b5184e56a49652aadb279e42a4e55e7328071b35"}, {"sha": "45df52f2cca9bee04690f476f4a3f791ea1b04cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/45df52f2cca9bee04690f476f4a3f791ea1b04cc", "html_url": "https://github.com/rust-lang/rust/commit/45df52f2cca9bee04690f476f4a3f791ea1b04cc"}], "stats": {"total": 326, "additions": 175, "deletions": 151}, "files": [{"sha": "10beb3af6ea40c7b5c6f60d5b7e22e573d4c9bc9", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -910,6 +910,9 @@ dependencies = [\n [[package]]\n name = \"fmt_macros\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"syntax_pos 0.0.0\",\n+]\n \n [[package]]\n name = \"fnv\""}, {"sha": "fc32f21ec4e0a8b5816489b2f22e6786168e94bc", "filename": "src/libfmt_macros/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibfmt_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibfmt_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2FCargo.toml?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -8,3 +8,6 @@ edition = \"2018\"\n name = \"fmt_macros\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n+\n+[dependencies]\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "7d0a0035dc846cda8ef330867a9503f97d66410e", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 67, "deletions": 66, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -25,6 +25,17 @@ use std::str;\n use std::string;\n use std::iter;\n \n+use syntax_pos::{InnerSpan, Symbol};\n+\n+#[derive(Copy, Clone)]\n+struct InnerOffset(usize);\n+\n+impl InnerOffset {\n+    fn to(self, end: InnerOffset) -> InnerSpan {\n+        InnerSpan::new(self.0, end.0)\n+    }\n+}\n+\n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n #[derive(Copy, Clone, PartialEq)]\n@@ -40,7 +51,7 @@ pub enum Piece<'a> {\n #[derive(Copy, Clone, PartialEq)]\n pub struct Argument<'a> {\n     /// Where to find this argument\n-    pub position: Position<'a>,\n+    pub position: Position,\n     /// How to format the argument\n     pub format: FormatSpec<'a>,\n }\n@@ -55,9 +66,9 @@ pub struct FormatSpec<'a> {\n     /// Packed version of various flags provided\n     pub flags: u32,\n     /// The integer precision to use\n-    pub precision: Count<'a>,\n+    pub precision: Count,\n     /// The string width requested for the resulting format\n-    pub width: Count<'a>,\n+    pub width: Count,\n     /// The descriptor string representing the name of the format desired for\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n@@ -66,16 +77,16 @@ pub struct FormatSpec<'a> {\n \n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum Position<'a> {\n+pub enum Position {\n     /// The argument is implied to be located at an index\n     ArgumentImplicitlyIs(usize),\n     /// The argument is located at a specific index given in the format\n     ArgumentIs(usize),\n     /// The argument has a name.\n-    ArgumentNamed(&'a str),\n+    ArgumentNamed(Symbol),\n }\n \n-impl Position<'_> {\n+impl Position {\n     pub fn index(&self) -> Option<usize> {\n         match self {\n             ArgumentIs(i) | ArgumentImplicitlyIs(i) => Some(*i),\n@@ -120,11 +131,11 @@ pub enum Flag {\n /// A count is used for the precision and width parameters of an integer, and\n /// can reference either an argument or a literal integer.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum Count<'a> {\n+pub enum Count {\n     /// The count is specified explicitly.\n     CountIs(usize),\n     /// The count is specified by the argument with the given name.\n-    CountIsName(&'a str),\n+    CountIsName(Symbol),\n     /// The count is specified by the argument at the given index.\n     CountIsParam(usize),\n     /// The count is implied and cannot be explicitly specified.\n@@ -135,9 +146,8 @@ pub struct ParseError {\n     pub description: string::String,\n     pub note: Option<string::String>,\n     pub label: string::String,\n-    pub start: SpanIndex,\n-    pub end: SpanIndex,\n-    pub secondary_label: Option<(string::String, SpanIndex, SpanIndex)>,\n+    pub span: InnerSpan,\n+    pub secondary_label: Option<(string::String, InnerSpan)>,\n }\n \n /// The parser structure for interpreting the input format string. This is\n@@ -156,44 +166,36 @@ pub struct Parser<'a> {\n     /// `Some(raw count)` when the string is \"raw\", used to position spans correctly\n     style: Option<usize>,\n     /// Start and end byte offset of every successfully parsed argument\n-    pub arg_places: Vec<(SpanIndex, SpanIndex)>,\n+    pub arg_places: Vec<InnerSpan>,\n     /// Characters that need to be shifted\n     skips: Vec<usize>,\n-    /// Span offset of the last opening brace seen, used for error reporting\n-    last_opening_brace_pos: Option<SpanIndex>,\n+    /// Span of the last opening brace seen, used for error reporting\n+    last_opening_brace: Option<InnerSpan>,\n     /// Wether the source string is comes from `println!` as opposed to `format!` or `print!`\n     append_newline: bool,\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct SpanIndex(pub usize);\n-\n-impl SpanIndex {\n-    pub fn unwrap(self) -> usize {\n-        self.0\n-    }\n-}\n-\n impl<'a> Iterator for Parser<'a> {\n     type Item = Piece<'a>;\n \n     fn next(&mut self) -> Option<Piece<'a>> {\n         if let Some(&(pos, c)) = self.cur.peek() {\n             match c {\n                 '{' => {\n-                    let curr_last_brace = self.last_opening_brace_pos;\n-                    self.last_opening_brace_pos = Some(self.to_span_index(pos));\n+                    let curr_last_brace = self.last_opening_brace;\n+                    let byte_pos = self.to_span_index(pos);\n+                    self.last_opening_brace = Some(byte_pos.to(InnerOffset(byte_pos.0 + 1)));\n                     self.cur.next();\n                     if self.consume('{') {\n-                        self.last_opening_brace_pos = curr_last_brace;\n+                        self.last_opening_brace = curr_last_brace;\n \n                         Some(String(self.string(pos + 1)))\n                     } else {\n                         let arg = self.argument();\n-                        if let Some(arg_pos) = self.must_consume('}').map(|end| {\n-                            (self.to_span_index(pos), self.to_span_index(end + 1))\n-                        }) {\n-                            self.arg_places.push(arg_pos);\n+                        if let Some(end) = self.must_consume('}') {\n+                            let start = self.to_span_index(pos);\n+                            let end = self.to_span_index(end + 1);\n+                            self.arg_places.push(start.to(end));\n                         }\n                         Some(NextArgument(arg))\n                     }\n@@ -208,8 +210,7 @@ impl<'a> Iterator for Parser<'a> {\n                             \"unmatched `}` found\",\n                             \"unmatched `}`\",\n                             \"if you intended to print `}`, you can escape it using `}}`\",\n-                            err_pos,\n-                            err_pos,\n+                            err_pos.to(err_pos),\n                         );\n                         None\n                     }\n@@ -241,7 +242,7 @@ impl<'a> Parser<'a> {\n             style,\n             arg_places: vec![],\n             skips,\n-            last_opening_brace_pos: None,\n+            last_opening_brace: None,\n             append_newline,\n         }\n     }\n@@ -253,15 +254,13 @@ impl<'a> Parser<'a> {\n         &mut self,\n         description: S1,\n         label: S2,\n-        start: SpanIndex,\n-        end: SpanIndex,\n+        span: InnerSpan,\n     ) {\n         self.errors.push(ParseError {\n             description: description.into(),\n             note: None,\n             label: label.into(),\n-            start,\n-            end,\n+            span,\n             secondary_label: None,\n         });\n     }\n@@ -274,15 +273,13 @@ impl<'a> Parser<'a> {\n         description: S1,\n         label: S2,\n         note: S3,\n-        start: SpanIndex,\n-        end: SpanIndex,\n+        span: InnerSpan,\n     ) {\n         self.errors.push(ParseError {\n             description: description.into(),\n             note: Some(note.into()),\n             label: label.into(),\n-            start,\n-            end,\n+            span,\n             secondary_label: None,\n         });\n     }\n@@ -303,22 +300,21 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn raw(&self) -> usize {\n-        self.style.map(|raw| raw + 1).unwrap_or(0)\n-    }\n-\n-    fn to_span_index(&self, pos: usize) -> SpanIndex {\n+    fn to_span_index(&self, pos: usize) -> InnerOffset {\n         let mut pos = pos;\n+        // This handles the raw string case, the raw argument is the number of #\n+        // in r###\"...\"### (we need to add one because of the `r`).\n+        let raw = self.style.map(|raw| raw + 1).unwrap_or(0);\n         for skip in &self.skips {\n             if pos > *skip {\n                 pos += 1;\n-            } else if pos == *skip && self.raw() == 0 {\n+            } else if pos == *skip && raw == 0 {\n                 pos += 1;\n             } else {\n                 break;\n             }\n         }\n-        SpanIndex(self.raw() + pos + 1)\n+        InnerOffset(raw + pos + 1)\n     }\n \n     /// Forces consumption of the specified character. If the character is not\n@@ -336,8 +332,8 @@ impl<'a> Parser<'a> {\n                 let label = \"expected `}`\".to_owned();\n                 let (note, secondary_label) = if c == '}' {\n                     (Some(\"if you intended to print `{`, you can escape it using `{{`\".to_owned()),\n-                     self.last_opening_brace_pos.map(|pos| {\n-                        (\"because of this opening brace\".to_owned(), pos, pos)\n+                     self.last_opening_brace.map(|sp| {\n+                        (\"because of this opening brace\".to_owned(), sp)\n                      }))\n                 } else {\n                     (None, None)\n@@ -346,8 +342,7 @@ impl<'a> Parser<'a> {\n                     description,\n                     note,\n                     label,\n-                    start: pos,\n-                    end: pos,\n+                    span: pos.to(pos),\n                     secondary_label,\n                 });\n                 None\n@@ -361,8 +356,8 @@ impl<'a> Parser<'a> {\n                 let label = format!(\"expected `{:?}`\", c);\n                 let (note, secondary_label) = if c == '}' {\n                     (Some(\"if you intended to print `{`, you can escape it using `{{`\".to_owned()),\n-                     self.last_opening_brace_pos.map(|pos| {\n-                        (\"because of this opening brace\".to_owned(), pos, pos)\n+                     self.last_opening_brace.map(|sp| {\n+                        (\"because of this opening brace\".to_owned(), sp)\n                      }))\n                 } else {\n                     (None, None)\n@@ -371,12 +366,11 @@ impl<'a> Parser<'a> {\n                     description,\n                     note,\n                     label,\n-                    start: pos,\n-                    end: pos,\n+                    span: pos.to(pos),\n                     secondary_label,\n                 });\n             } else {\n-                self.err(description, format!(\"expected `{:?}`\", c), pos, pos);\n+                self.err(description, format!(\"expected `{:?}`\", c), pos.to(pos));\n             }\n             None\n         }\n@@ -435,20 +429,24 @@ impl<'a> Parser<'a> {\n     /// integer index of an argument, a named argument, or a blank string.\n     /// Returns `Some(parsed_position)` if the position is not implicitly\n     /// consuming a macro argument, `None` if it's the case.\n-    fn position(&mut self) -> Option<Position<'a>> {\n+    fn position(&mut self) -> Option<Position> {\n         if let Some(i) = self.integer() {\n             Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => Some(ArgumentNamed(self.word())),\n+                Some(&(_, c)) if c.is_alphabetic() => {\n+                    Some(ArgumentNamed(Symbol::intern(self.word())))\n+                }\n                 Some(&(pos, c)) if c == '_' => {\n                     let invalid_name = self.string(pos);\n                     self.err_with_note(format!(\"invalid argument name `{}`\", invalid_name),\n                                        \"invalid argument name\",\n                                        \"argument names cannot start with an underscore\",\n-                                       self.to_span_index(pos),\n-                                       self.to_span_index(pos + invalid_name.len()));\n-                    Some(ArgumentNamed(invalid_name))\n+                                        self.to_span_index(pos).to(\n+                                            self.to_span_index(pos + invalid_name.len())\n+                                        ),\n+                                        );\n+                    Some(ArgumentNamed(Symbol::intern(invalid_name)))\n                 },\n \n                 // This is an `ArgumentNext`.\n@@ -556,7 +554,7 @@ impl<'a> Parser<'a> {\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self) -> Count<'a> {\n+    fn count(&mut self) -> Count {\n         if let Some(i) = self.integer() {\n             if self.consume('$') {\n                 CountIsParam(i)\n@@ -570,7 +568,7 @@ impl<'a> Parser<'a> {\n                 self.cur = tmp;\n                 CountImplied\n             } else if self.consume('$') {\n-                CountIsName(word)\n+                CountIsName(Symbol::intern(word))\n             } else {\n                 self.cur = tmp;\n                 CountImplied\n@@ -760,6 +758,8 @@ mod tests {\n     }\n     #[test]\n     fn format_counts() {\n+        use syntax_pos::{GLOBALS, Globals, edition};\n+        GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n         same(\"{:10s}\",\n              &[NextArgument(Argument {\n                    position: ArgumentImplicitlyIs(0),\n@@ -815,11 +815,12 @@ mod tests {\n                        fill: None,\n                        align: AlignUnknown,\n                        flags: 0,\n-                       precision: CountIsName(\"b\"),\n-                       width: CountIsName(\"a\"),\n+                       precision: CountIsName(Symbol::intern(\"b\")),\n+                       width: CountIsName(Symbol::intern(\"a\")),\n                        ty: \"s\",\n                    },\n                })]);\n+        });\n     }\n     #[test]\n     fn format_flags() {"}, {"sha": "50d2eeef421c13d767e6a4e50196dddeb8ebd2d0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 // this is a \"direct\", user-specified, rather than derived,\n                 // obligation.\n-                flags.push((\"direct\".to_owned(), None));\n+                flags.push((sym::direct, None));\n             }\n         }\n \n@@ -365,27 +365,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // Currently I'm leaving it for what I need for `try`.\n             if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n                 let method = self.tcx.item_name(item);\n-                flags.push((\"from_method\".to_owned(), None));\n-                flags.push((\"from_method\".to_owned(), Some(method.to_string())));\n+                flags.push((sym::from_method, None));\n+                flags.push((sym::from_method, Some(method.to_string())));\n             }\n         }\n         if let Some(t) = self.get_parent_trait_ref(&obligation.cause.code) {\n-            flags.push((\"parent_trait\".to_owned(), Some(t)));\n+            flags.push((sym::parent_trait, Some(t)));\n         }\n \n         if let Some(k) = obligation.cause.span.compiler_desugaring_kind() {\n-            flags.push((\"from_desugaring\".to_owned(), None));\n-            flags.push((\"from_desugaring\".to_owned(), Some(k.name().to_string())));\n+            flags.push((sym::from_desugaring, None));\n+            flags.push((sym::from_desugaring, Some(k.name().to_string())));\n         }\n         let generics = self.tcx.generics_of(def_id);\n         let self_ty = trait_ref.self_ty();\n         // This is also included through the generics list as `Self`,\n         // but the parser won't allow you to use it\n-        flags.push((\"_Self\".to_owned(), Some(self_ty.to_string())));\n+        flags.push((sym::_Self, Some(self_ty.to_string())));\n         if let Some(def) = self_ty.ty_adt_def() {\n             // We also want to be able to select self's original\n             // signature with no type arguments resolved\n-            flags.push((\"_Self\".to_owned(), Some(self.tcx.type_of(def.did).to_string())));\n+            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n         }\n \n         for param in generics.params.iter() {\n@@ -396,38 +396,38 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 GenericParamDefKind::Lifetime => continue,\n             };\n-            let name = param.name.to_string();\n+            let name = param.name.as_symbol();\n             flags.push((name, Some(value)));\n         }\n \n         if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n-            flags.push((\"crate_local\".to_owned(), None));\n+            flags.push((sym::crate_local, None));\n         }\n \n         // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n         if self_ty.is_integral() {\n-            flags.push((\"_Self\".to_owned(), Some(\"{integral}\".to_owned())));\n+            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n         }\n \n         if let ty::Array(aty, len) = self_ty.sty {\n-            flags.push((\"_Self\".to_owned(), Some(\"[]\".to_owned())));\n-            flags.push((\"_Self\".to_owned(), Some(format!(\"[{}]\", aty))));\n+            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n             if let Some(def) = aty.ty_adt_def() {\n                 // We also want to be able to select the array's type's original\n                 // signature with no type arguments resolved\n                 flags.push((\n-                    \"_Self\".to_owned(),\n+                    sym::_Self,\n                     Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n                 ));\n                 let tcx = self.tcx;\n                 if let Some(len) = len.assert_usize(tcx) {\n                     flags.push((\n-                        \"_Self\".to_owned(),\n+                        sym::_Self,\n                         Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),\n                     ));\n                 } else {\n                     flags.push((\n-                        \"_Self\".to_owned(),\n+                        sym::_Self,\n                         Some(format!(\"[{}; _]\", self.tcx.type_of(def.did).to_string())),\n                     ));\n                 }"}, {"sha": "b78396c90dc657f2a70aba7c37922ac30048891d", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -7,7 +7,7 @@ use crate::util::nodemap::FxHashMap;\n \n use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;\n-use syntax::symbol::sym;\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n use syntax_pos::symbol::LocalInternedString;\n \n@@ -52,7 +52,7 @@ fn parse_error(tcx: TyCtxt<'_, '_, '_>, span: Span,\n }\n \n impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n-    pub fn parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                  trait_def_id: DefId,\n                  items: &[NestedMetaItem],\n                  span: Span,\n@@ -167,7 +167,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     pub fn evaluate(&self,\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     trait_ref: ty::TraitRef<'tcx>,\n-                    options: &[(String, Option<String>)])\n+                    options: &[(Symbol, Option<String>)])\n                     -> OnUnimplementedNote\n     {\n         let mut message = None;\n@@ -180,7 +180,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n                     c.ident().map_or(false, |ident| {\n                         options.contains(&(\n-                            ident.to_string(),\n+                            ident.name,\n                             c.value_str().map(|s| s.as_str().to_string())\n                         ))\n                     })\n@@ -203,8 +203,8 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n             }\n         }\n \n-        let options: FxHashMap<String, String> = options.into_iter()\n-            .filter_map(|(k, v)| v.as_ref().map(|v| (k.to_owned(), v.to_owned())))\n+        let options: FxHashMap<Symbol, String> = options.into_iter()\n+            .filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned())))\n             .collect();\n         OnUnimplementedNote {\n             label: label.map(|l| l.format(tcx, trait_ref, &options)),\n@@ -215,7 +215,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n }\n \n impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n-    pub fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      trait_def_id: DefId,\n                      from: LocalInternedString,\n                      err_sp: Span)\n@@ -241,16 +241,16 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                 Piece::String(_) => (), // Normal string, no need to check it\n                 Piece::NextArgument(a) => match a.position {\n                     // `{Self}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"Self\" => (),\n+                    Position::ArgumentNamed(s) if s == kw::SelfUpper => (),\n                     // `{ThisTraitsName}` is allowed\n-                    Position::ArgumentNamed(s) if s == name.as_str() => (),\n+                    Position::ArgumentNamed(s) if s == name => (),\n                     // `{from_method}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"from_method\" => (),\n+                    Position::ArgumentNamed(s) if s == sym::from_method => (),\n                     // `{from_desugaring}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"from_desugaring\" => (),\n+                    Position::ArgumentNamed(s) if s == sym::from_desugaring => (),\n                     // So is `{A}` if A is a type parameter\n                     Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n-                        param.name.as_str() == s\n+                        param.name.as_symbol() == s\n                     }) {\n                         Some(_) => (),\n                         None => {\n@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         &self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,\n-        options: &FxHashMap<String, String>,\n+        options: &FxHashMap<Symbol, String>,\n     ) -> String {\n         let name = tcx.item_name(trait_ref.def_id);\n         let trait_str = tcx.def_path_str(trait_ref.def_id);\n@@ -289,25 +289,25 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                 },\n                 GenericParamDefKind::Lifetime => return None\n             };\n-            let name = param.name.to_string();\n+            let name = param.name.as_symbol();\n             Some((name, value))\n-        }).collect::<FxHashMap<String, String>>();\n+        }).collect::<FxHashMap<Symbol, String>>();\n         let empty_string = String::new();\n \n         let parser = Parser::new(&self.0, None, vec![], false);\n         parser.map(|p|\n             match p {\n                 Piece::String(s) => s,\n                 Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                    Position::ArgumentNamed(s) => match generic_map.get(&s) {\n                         Some(val) => val,\n-                        None if s == name.as_str() => {\n+                        None if s == name => {\n                             &trait_str\n                         }\n                         None => {\n-                            if let Some(val) = options.get(s) {\n+                            if let Some(val) = options.get(&s) {\n                                 val\n-                            } else if s == \"from_desugaring\" || s == \"from_method\" {\n+                            } else if s == sym::from_desugaring || s == sym::from_method {\n                                 // don't break messages using these two arguments incorrectly\n                                 &empty_string\n                             } else {"}, {"sha": "6d51278b4e5e88315e74c52248e1499aa8bdd6c2", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -2,7 +2,7 @@ use errors::Applicability;\n use syntax::parse::lexer::{StringReader as Lexer};\n use syntax::parse::{ParseSess, token};\n use syntax::source_map::FilePathMapping;\n-use syntax_pos::FileName;\n+use syntax_pos::{InnerSpan, FileName};\n \n use crate::clean;\n use crate::core::DocContext;\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n                 }\n \n                 if code_block.syntax.is_none() && code_block.is_fenced {\n-                    let sp = sp.from_inner_byte_pos(0, 3);\n+                    let sp = sp.from_inner(InnerSpan::new(0, 3));\n                     diag.span_suggestion(\n                         sp,\n                         \"mark blocks that do not contain Rust code as text\","}, {"sha": "8fc6b9fdbe6b93d9b4f99636d6f1e7f01375b2b6", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -6,7 +6,7 @@ use rustc::lint as lint;\n use rustc::middle::privacy::AccessLevels;\n use rustc::util::nodemap::DefIdSet;\n use std::mem;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::{DUMMY_SP, InnerSpan, Span};\n use std::ops::Range;\n \n use crate::clean::{self, GetDefId, Item};\n@@ -440,10 +440,10 @@ crate fn source_span_for_markdown_range(\n         }\n     }\n \n-    let sp = span_of_attrs(attrs).from_inner_byte_pos(\n+    let sp = span_of_attrs(attrs).from_inner(InnerSpan::new(\n         md_range.start + start_bytes,\n         md_range.end + start_bytes + end_bytes,\n-    );\n+    ));\n \n     Some(sp)\n }"}, {"sha": "85b524786b2f5d8eb572acabcaa0eac8c392d61a", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -28,7 +28,7 @@ enum ArgumentType {\n \n enum Position {\n     Exact(usize),\n-    Named(String),\n+    Named(Symbol),\n }\n \n struct Context<'a, 'b: 'a> {\n@@ -57,7 +57,7 @@ struct Context<'a, 'b: 'a> {\n     /// Unique format specs seen for each argument.\n     arg_unique_types: Vec<Vec<ArgumentType>>,\n     /// Map from named arguments to their resolved indices.\n-    names: FxHashMap<String, usize>,\n+    names: FxHashMap<Symbol, usize>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -127,9 +127,9 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: &[tokenstream::TokenTree]\n-) -> Result<(P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<String, usize>), DiagnosticBuilder<'a>> {\n+) -> Result<(P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, usize>), DiagnosticBuilder<'a>> {\n     let mut args = Vec::<P<ast::Expr>>::new();\n-    let mut names = FxHashMap::<String, usize>::default();\n+    let mut names = FxHashMap::<Symbol, usize>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -158,11 +158,10 @@ fn parse_args<'a>(\n                     \"expected ident, positional arguments cannot follow named arguments\",\n                 ));\n             };\n-            let name: &str = &name.as_str();\n \n             p.expect(&token::Eq)?;\n             let e = p.parse_expr()?;\n-            if let Some(prev) = names.get(name) {\n+            if let Some(prev) = names.get(&name) {\n                 ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", name))\n                     .span_note(args[*prev].span, \"previously here\")\n                     .emit();\n@@ -174,7 +173,7 @@ fn parse_args<'a>(\n             // if the input is valid, we can simply append to the positional\n             // args. And remember the names.\n             let slot = args.len();\n-            names.insert(name.to_string(), slot);\n+            names.insert(name, slot);\n             args.push(e);\n         } else {\n             let e = p.parse_expr()?;\n@@ -188,7 +187,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn resolve_name_inplace(&self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup = |s| *self.names.get(s).unwrap_or(&0);\n+        let lookup = |s: Symbol| *self.names.get(&s).unwrap_or(&0);\n \n         match *p {\n             parse::String(_) => {}\n@@ -222,7 +221,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n                     parse::ArgumentIs(i) | parse::ArgumentImplicitlyIs(i) => Exact(i),\n-                    parse::ArgumentNamed(s) => Named(s.to_string()),\n+                    parse::ArgumentNamed(s) => Named(s),\n                 };\n \n                 let ty = Placeholder(arg.format.ty.to_string());\n@@ -232,15 +231,15 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn verify_count(&mut self, c: parse::Count<'_>) {\n+    fn verify_count(&mut self, c: parse::Count) {\n         match c {\n             parse::CountImplied |\n             parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n                 self.verify_arg_type(Exact(i), Count);\n             }\n             parse::CountIsName(s) => {\n-                self.verify_arg_type(Named(s.to_string()), Count);\n+                self.verify_arg_type(Named(s), Count);\n             }\n         }\n     }\n@@ -390,7 +389,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.std_path(&[sym::fmt, sym::rt, sym::v1, Symbol::intern(s)])\n     }\n \n-    fn build_count(&self, c: parse::Count<'_>) -> P<ast::Expr> {\n+    fn build_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, \"Count\");\n@@ -739,7 +738,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n                                     sp: Span,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    names: FxHashMap<String, usize>,\n+                                    names: FxHashMap<Symbol, usize>,\n                                     append_newline: bool)\n                                     -> P<ast::Expr> {\n     // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n@@ -901,25 +900,23 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n \n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n-        let sp = fmt.span.from_inner_byte_pos(err.start.unwrap(), err.end.unwrap());\n+        let sp = fmt.span.from_inner(err.span);\n         let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n                                                      err.description));\n         e.span_label(sp, err.label + \" in format string\");\n         if let Some(note) = err.note {\n             e.note(&note);\n         }\n-        if let Some((label, start, end)) = err.secondary_label {\n-            let sp = fmt.span.from_inner_byte_pos(start.unwrap(), end.unwrap());\n+        if let Some((label, span)) = err.secondary_label {\n+            let sp = fmt.span.from_inner(span);\n             e.span_label(sp, label);\n         }\n         e.emit();\n         return DummyResult::raw_expr(sp, true);\n     }\n \n     let arg_spans = parser.arg_places.iter()\n-        .map(|&(parse::SpanIndex(start), parse::SpanIndex(end))| {\n-            fmt.span.from_inner_byte_pos(start, end)\n-        })\n+        .map(|span| fmt.span.from_inner(*span))\n         .collect();\n \n     let mut cx = Context {\n@@ -1044,7 +1041,9 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n                     let mut show_doc_note = false;\n \n                     let mut suggestions = vec![];\n-                    for sub in foreign::$kind::iter_subs(fmt_str) {\n+                    // account for `\"` and account for raw strings `r#`\n+                    let padding = str_style.map(|i| i + 2).unwrap_or(1);\n+                    for sub in foreign::$kind::iter_subs(fmt_str, padding) {\n                         let trn = match sub.translate() {\n                             Some(trn) => trn,\n \n@@ -1064,10 +1063,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n                             show_doc_note = true;\n                         }\n \n-                        if let Some((start, end)) = pos {\n-                            // account for `\"` and account for raw strings `r#`\n-                            let padding = str_style.map(|i| i + 2).unwrap_or(1);\n-                            let sp = fmt_sp.from_inner_byte_pos(start + padding, end + padding);\n+                        if let Some(inner_sp) = pos {\n+                            let sp = fmt_sp.from_inner(inner_sp);\n                             suggestions.push((sp, trn));\n                         } else {\n                             diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));"}, {"sha": "7ad5997bf2c097c0942bdb4f55615e0a78c14344", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -1,5 +1,6 @@\n pub mod printf {\n     use super::strcursor::StrCursor as Cur;\n+    use syntax_pos::InnerSpan;\n \n     /// Represents a single `printf`-style substitution.\n     #[derive(Clone, PartialEq, Debug)]\n@@ -18,7 +19,7 @@ pub mod printf {\n             }\n         }\n \n-        pub fn position(&self) -> Option<(usize, usize)> {\n+        pub fn position(&self) -> Option<InnerSpan> {\n             match *self {\n                 Substitution::Format(ref fmt) => Some(fmt.position),\n                 _ => None,\n@@ -28,7 +29,7 @@ pub mod printf {\n         pub fn set_position(&mut self, start: usize, end: usize) {\n             match self {\n                 Substitution::Format(ref mut fmt) => {\n-                    fmt.position = (start, end);\n+                    fmt.position = InnerSpan::new(start, end);\n                 }\n                 _ => {}\n             }\n@@ -65,7 +66,7 @@ pub mod printf {\n         /// Type of parameter being converted.\n         pub type_: &'a str,\n         /// Byte offset for the start and end of this formatting directive.\n-        pub position: (usize, usize),\n+        pub position: InnerSpan,\n     }\n \n     impl Format<'_> {\n@@ -263,10 +264,10 @@ pub mod printf {\n     }\n \n     /// Returns an iterator over all substitutions in a given string.\n-    pub fn iter_subs(s: &str) -> Substitutions<'_> {\n+    pub fn iter_subs(s: &str, start_pos: usize) -> Substitutions<'_> {\n         Substitutions {\n             s,\n-            pos: 0,\n+            pos: start_pos,\n         }\n     }\n \n@@ -282,9 +283,9 @@ pub mod printf {\n             let (mut sub, tail) = parse_next_substitution(self.s)?;\n             self.s = tail;\n             match sub {\n-                Substitution::Format(_) => if let Some((start, end)) = sub.position() {\n-                    sub.set_position(start + self.pos, end + self.pos);\n-                    self.pos += end;\n+                Substitution::Format(_) => if let Some(inner_span) = sub.position() {\n+                    sub.set_position(inner_span.start + self.pos, inner_span.end + self.pos);\n+                    self.pos += inner_span.end;\n                 }\n                 Substitution::Escape => self.pos += 2,\n             }\n@@ -373,7 +374,7 @@ pub mod printf {\n                     precision: None,\n                     length: None,\n                     type_: at.slice_between(next).unwrap(),\n-                    position: (start.at, next.at),\n+                    position: InnerSpan::new(start.at, next.at),\n                 }),\n                 next.slice_after()\n             ));\n@@ -560,7 +561,7 @@ pub mod printf {\n         drop(next);\n \n         end = at;\n-        let position = (start.at, end.at);\n+        let position = InnerSpan::new(start.at, end.at);\n \n         let f = Format {\n             span: start.slice_between(end).unwrap(),\n@@ -650,7 +651,7 @@ pub mod printf {\n                                 precision: $prec,\n                                 length: $len,\n                                 type_: $type_,\n-                                position: $pos,\n+                                position: syntax_pos::InnerSpan::new($pos.0, $pos.1),\n                             }),\n                             \"!\"\n                         ))\n@@ -711,7 +712,7 @@ pub mod printf {\n         #[test]\n         fn test_iter() {\n             let s = \"The %d'th word %% is: `%.*s` %!\\n\";\n-            let subs: Vec<_> = iter_subs(s).map(|sub| sub.translate()).collect();\n+            let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate()).collect();\n             assert_eq!(\n                 subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n                 vec![Some(\"{}\"), None, Some(\"{:.*}\"), None]\n@@ -761,6 +762,7 @@ pub mod printf {\n \n pub mod shell {\n     use super::strcursor::StrCursor as Cur;\n+    use syntax_pos::InnerSpan;\n \n     #[derive(Clone, PartialEq, Debug)]\n     pub enum Substitution<'a> {\n@@ -778,11 +780,11 @@ pub mod shell {\n             }\n         }\n \n-        pub fn position(&self) -> Option<(usize, usize)> {\n+        pub fn position(&self) -> Option<InnerSpan> {\n             match self {\n                 Substitution::Ordinal(_, pos) |\n                 Substitution::Name(_, pos) |\n-                Substitution::Escape(pos) => Some(*pos),\n+                Substitution::Escape(pos) => Some(InnerSpan::new(pos.0, pos.1)),\n             }\n         }\n \n@@ -804,10 +806,10 @@ pub mod shell {\n     }\n \n     /// Returns an iterator over all substitutions in a given string.\n-    pub fn iter_subs(s: &str) -> Substitutions<'_> {\n+    pub fn iter_subs(s: &str, start_pos: usize) -> Substitutions<'_> {\n         Substitutions {\n             s,\n-            pos: 0,\n+            pos: start_pos,\n         }\n     }\n \n@@ -823,7 +825,7 @@ pub mod shell {\n             match parse_next_substitution(self.s) {\n                 Some((mut sub, tail)) => {\n                     self.s = tail;\n-                    if let Some((start, end)) = sub.position() {\n+                    if let Some(InnerSpan { start, end }) = sub.position() {\n                         sub.set_position(start + self.pos, end + self.pos);\n                         self.pos += end;\n                     }\n@@ -940,7 +942,7 @@ pub mod shell {\n         fn test_iter() {\n             use super::iter_subs;\n             let s = \"The $0'th word $$ is: `$WORD` $!\\n\";\n-            let subs: Vec<_> = iter_subs(s).map(|sub| sub.translate()).collect();\n+            let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate()).collect();\n             assert_eq!(\n                 subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n                 vec![Some(\"{0}\"), None, Some(\"{WORD}\")]"}, {"sha": "e7158372762dd99dba0c5f8c4594c5ce0505d4cc", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -505,10 +505,10 @@ impl Span {\n         )\n     }\n \n-    pub fn from_inner_byte_pos(self, start: usize, end: usize) -> Span {\n+    pub fn from_inner(self, inner: InnerSpan) -> Span {\n         let span = self.data();\n-        Span::new(span.lo + BytePos::from_usize(start),\n-                  span.lo + BytePos::from_usize(end),\n+        Span::new(span.lo + BytePos::from_usize(inner.start),\n+                  span.lo + BytePos::from_usize(inner.end),\n                   span.ctxt)\n     }\n \n@@ -1396,6 +1396,18 @@ pub struct MalformedSourceMapPositions {\n     pub end_pos: BytePos\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct InnerSpan {\n+    pub start: usize,\n+    pub end: usize,\n+}\n+\n+impl InnerSpan {\n+    pub fn new(start: usize, end: usize) -> InnerSpan {\n+        InnerSpan { start, end }\n+    }\n+}\n+\n // Given a slice of line start positions and a position, returns the index of\n // the line the position is on. Returns -1 if the position is located before\n // the first line."}, {"sha": "029685bcc2429e620058b30d6f043f4e8f89c25a", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78260d7811953b8ff28d378858f96782f95a523/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=d78260d7811953b8ff28d378858f96782f95a523", "patch": "@@ -203,6 +203,7 @@ symbols! {\n         core_intrinsics,\n         crate_id,\n         crate_in_paths,\n+        crate_local,\n         crate_name,\n         crate_type,\n         crate_visibility_modifier,\n@@ -221,6 +222,7 @@ symbols! {\n         deref,\n         deref_mut,\n         derive,\n+        direct,\n         doc,\n         doc_alias,\n         doc_cfg,\n@@ -278,8 +280,10 @@ symbols! {\n         format_args_nl,\n         from,\n         From,\n+        from_desugaring,\n         from_error,\n         from_generator,\n+        from_method,\n         from_ok,\n         from_usize,\n         fundamental,\n@@ -443,6 +447,7 @@ symbols! {\n         panic_impl,\n         panic_implementation,\n         panic_runtime,\n+        parent_trait,\n         partial_cmp,\n         PartialOrd,\n         passes,\n@@ -569,6 +574,7 @@ symbols! {\n         __rust_unstable_column,\n         rvalue_static_promotion,\n         sanitizer_runtime,\n+        _Self,\n         self_in_typedefs,\n         self_struct_ctor,\n         Send,"}]}