{"sha": "5e7336ec0d9e77755fbee2e306b95dcdd6f1898a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNzMzNmVjMGQ5ZTc3NzU1ZmJlZTJlMzA2Yjk1ZGNkZDZmMTg5OGE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-22T00:06:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-22T00:06:01Z"}, "message": "rustc: Add a shallow type equality function, not used yet", "tree": {"sha": "f6d20fb5c43ab4f04570d75074ec39c4faa69ee0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6d20fb5c43ab4f04570d75074ec39c4faa69ee0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e7336ec0d9e77755fbee2e306b95dcdd6f1898a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7336ec0d9e77755fbee2e306b95dcdd6f1898a", "html_url": "https://github.com/rust-lang/rust/commit/5e7336ec0d9e77755fbee2e306b95dcdd6f1898a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e7336ec0d9e77755fbee2e306b95dcdd6f1898a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "735435bf964dcafdfc09d01ea644bbfbe725abd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/735435bf964dcafdfc09d01ea644bbfbe725abd8", "html_url": "https://github.com/rust-lang/rust/commit/735435bf964dcafdfc09d01ea644bbfbe725abd8"}], "stats": {"total": 321, "additions": 321, "deletions": 0}, "files": [{"sha": "3a672028a384118deee5deea96b95ac3f9d05f9c", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/5e7336ec0d9e77755fbee2e306b95dcdd6f1898a/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7336ec0d9e77755fbee2e306b95dcdd6f1898a/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=5e7336ec0d9e77755fbee2e306b95dcdd6f1898a", "patch": "@@ -1,6 +1,7 @@\n import std._str;\n import std._uint;\n import std._vec;\n+import std.Box;\n import std.UFind;\n import std.map;\n import std.map.hashmap;\n@@ -862,6 +863,326 @@ fn hash_type_structure(&sty st) -> uint {\n fn hash_ty(&@t typ) -> uint { ret typ.hash; }\n \n \n+// Type equality. This function is private to this module (and slow); external\n+// users should use `eq_ty()` instead.\n+fn equal_type_structures(&sty a, &sty b) -> bool {\n+    fn equal_ty(@t a, @t b) -> bool { ret Box.ptr_eq[t](a, b); }\n+\n+    fn equal_proto(ast.proto a, ast.proto b) -> bool {\n+        alt (a) {\n+            case (ast.proto_iter) {\n+                alt (b) {\n+                    case (ast.proto_iter) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+            case (ast.proto_fn) {\n+                alt (b) {\n+                    case (ast.proto_fn) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn equal_abi(ast.native_abi a, ast.native_abi b) -> bool {\n+        alt (a) {\n+            case (ast.native_abi_rust) {\n+                alt (b) {\n+                    case (ast.native_abi_rust) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+            case (ast.native_abi_cdecl) {\n+                alt (b) {\n+                    case (ast.native_abi_cdecl) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+            case (ast.native_abi_llvm) {\n+                alt (b) {\n+                    case (ast.native_abi_llvm) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn equal_mut(ast.mutability a, ast.mutability b) -> bool {\n+        alt (a) {\n+            case (ast.mut) {\n+                alt (b) {\n+                    case (ast.mut) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+            case (ast.imm) {\n+                alt (b) {\n+                    case (ast.imm) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+            case (ast.maybe_mut) {\n+                alt (b) {\n+                    case (ast.maybe_mut) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn equal_mode(ast.mode a, ast.mode b) -> bool {\n+        alt (a) {\n+            case (ast.val) {\n+                alt (b) {\n+                    case (ast.val) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+            case (ast.alias) {\n+                alt (b) {\n+                    case (ast.alias) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn equal_mt(&mt a, &mt b) -> bool {\n+        ret equal_mut(a.mut, b.mut) && equal_ty(a.ty, b.ty);\n+    }\n+\n+    fn equal_fn(vec[arg] args_a, @t rty_a,\n+                vec[arg] args_b, @t rty_b) -> bool {\n+        if (!equal_ty(rty_a, rty_b)) { ret false; }\n+\n+        auto len = _vec.len[arg](args_a);\n+        if (len != _vec.len[arg](args_b)) { ret false; }\n+        auto i = 0u;\n+        while (i < len) {\n+            auto arg_a = args_a.(i); auto arg_b = args_b.(i);\n+            if (!equal_mode(arg_a.mode, arg_b.mode) ||\n+                    !equal_ty(arg_a.ty, arg_b.ty)) {\n+                ret false;\n+            }\n+            i += 1u;\n+        }\n+        ret true;\n+    }\n+\n+    fn equal_def(ast.def_id did_a, ast.def_id did_b) -> bool {\n+        ret did_a._0 == did_b._0 && did_a._1 == did_b._1;\n+    }\n+\n+    alt (a) {\n+        case (ty_nil) {\n+            alt (b) {\n+                case (ty_nil) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_bool) {\n+            alt (b) {\n+                case (ty_bool) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_int) {\n+            alt (b) {\n+                case (ty_int) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_float) {\n+            alt (b) {\n+                case (ty_float) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_uint) {\n+            alt (b) {\n+                case (ty_uint) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_machine(?tm_a)) {\n+            alt (b) {\n+                case (ty_machine(?tm_b)) {\n+                    ret hash_type_structure(a) == hash_type_structure(b);\n+                }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_char) {\n+            alt (b) {\n+                case (ty_char) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_str) {\n+            alt (b) {\n+                case (ty_str) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_tag(?id_a, ?tys_a)) {\n+            alt (b) {\n+                case (ty_tag(?id_b, ?tys_b)) {\n+                    if (id_a != id_b) { ret false; }\n+\n+                    auto len = _vec.len[@ty.t](tys_a);\n+                    if (len != _vec.len[@ty.t](tys_b)) { ret false; }\n+                    auto i = 0u;\n+                    while (i < len) {\n+                        if (!equal_ty(tys_a.(i), tys_b.(i))) { ret false; }\n+                        i += 1u;\n+                    }\n+                    ret true;\n+                }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_box(?mt_a)) {\n+            alt (b) {\n+                case (ty_box(?mt_b)) { ret equal_mt(mt_a, mt_b); }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_vec(?mt_a)) {\n+            alt (b) {\n+                case (ty_vec(?mt_b)) { ret equal_mt(mt_a, mt_b); }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_port(?t_a)) {\n+            alt (b) {\n+                case (ty_port(?t_b)) { ret equal_ty(t_a, t_b); }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_chan(?t_a)) {\n+            alt (b) {\n+                case (ty_chan(?t_b)) { ret equal_ty(t_a, t_b); }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_task) {\n+            alt (b) {\n+                case (ty_task) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_tup(?mts_a)) {\n+            alt (b) {\n+                case (ty_tup(?mts_b)) {\n+                    auto len = _vec.len[mt](mts_a);\n+                    if (len != _vec.len[mt](mts_b)) { ret false; }\n+                    auto i = 0u;\n+                    while (i < len) {\n+                        if (!equal_mt(mts_a.(i), mts_b.(i))) { ret false; }\n+                        i += 1u;\n+                    }\n+                    ret true;\n+                }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_rec(?flds_a)) {\n+            alt (b) {\n+                case (ty_rec(?flds_b)) {\n+                    auto len = _vec.len[field](flds_a);\n+                    if (len != _vec.len[field](flds_b)) { ret false; }\n+                    auto i = 0u;\n+                    while (i < len) {\n+                        auto fld_a = flds_a.(i); auto fld_b = flds_b.(i);\n+                        if (!_str.eq(fld_a.ident, fld_b.ident) ||\n+                                !equal_mt(fld_a.mt, fld_b.mt)) {\n+                            ret false;\n+                        }\n+                        i += 1u;\n+                    }\n+                    ret true;\n+                }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_fn(?p_a, ?args_a, ?rty_a)) {\n+            alt (b) {\n+                case (ty_fn(?p_b, ?args_b, ?rty_b)) {\n+                    ret equal_proto(p_a, p_b) &&\n+                        equal_fn(args_a, rty_a, args_b, rty_b);\n+                }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_native_fn(?abi_a, ?args_a, ?rty_a)) {\n+            alt (b) {\n+                case (ty_native_fn(?abi_b, ?args_b, ?rty_b)) {\n+                    ret equal_abi(abi_a, abi_b) &&\n+                        equal_fn(args_a, rty_a, args_b, rty_b);\n+                }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_obj(?methods_a)) {\n+            alt (b) {\n+                case (ty_obj(?methods_b)) {\n+                    auto len = _vec.len[method](methods_a);\n+                    if (len != _vec.len[method](methods_b)) { ret false; }\n+                    auto i = 0u;\n+                    while (i < len) {\n+                        auto m_a = methods_a.(i); auto m_b = methods_b.(i);\n+                        if (!equal_proto(m_a.proto, m_b.proto) ||\n+                                !_str.eq(m_a.ident, m_b.ident) ||\n+                                equal_fn(m_a.inputs, m_a.output,\n+                                         m_b.inputs, m_b.output)) {\n+                            ret false;\n+                        }\n+                    }\n+                    ret true;\n+                }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_var(?v_a)) {\n+            alt (b) {\n+                case (ty_var(?v_b)) { ret v_a == v_b; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_local(?did_a)) {\n+            alt (b) {\n+                case (ty_local(?did_b)) { ret equal_def(did_a, did_b); }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_param(?pid_a)) {\n+            alt (b) {\n+                case (ty_param(?pid_b)) { ret pid_a == pid_b; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_bound_param(?pid_a)) {\n+            alt (b) {\n+                case (ty_bound_param(?pid_b)) { ret pid_a == pid_b; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_type) {\n+            alt (b) {\n+                case (ty_type) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+        case (ty_native) {\n+            alt (b) {\n+                case (ty_native) { ret true; }\n+                case (_) { ret false; }\n+            }\n+        }\n+    }\n+}\n+\n \n fn ty_is_simple(&@t a) -> bool {\n     // a \"simple\" type is one in which the hash"}]}