{"sha": "c5c8258937f056a0f4b0e83e1d878c268daa09ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YzgyNTg5MzdmMDU2YTBmNGIwZTgzZTFkODc4YzI2OGRhYTA5ZmY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-11T02:49:58Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-11T03:18:07Z"}, "message": "Rework check_expr substantially.\n\nThe bulk of check_expr is now check_expr_with_unifier, which takes an\nexpected type and a unification function and will perform the\nunification on the type it produces. check_expr calls\ncheck_expr_with_unifier with a dummy unifier and a new function,\ncheck_expr_with, takes an expected type and uses the simple unifier.\n\nI think this generally makes thing cleaner, but the purpose for doing\nthis is to enable type inferred lambda-blocks to be useful by allowing\nthe argument types to be unified before the body of the lambda is\nchecked.", "tree": {"sha": "73bc30ec51c250d4f043d437bf322cfb0219b752", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73bc30ec51c250d4f043d437bf322cfb0219b752"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5c8258937f056a0f4b0e83e1d878c268daa09ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c8258937f056a0f4b0e83e1d878c268daa09ff", "html_url": "https://github.com/rust-lang/rust/commit/c5c8258937f056a0f4b0e83e1d878c268daa09ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5c8258937f056a0f4b0e83e1d878c268daa09ff/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67e361a9408c5226bdeccf49c958811dcad59405", "url": "https://api.github.com/repos/rust-lang/rust/commits/67e361a9408c5226bdeccf49c958811dcad59405", "html_url": "https://github.com/rust-lang/rust/commit/67e361a9408c5226bdeccf49c958811dcad59405"}], "stats": {"total": 196, "additions": 66, "deletions": 130}, "files": [{"sha": "8352588edeacb4a3ed068cdeb829fc47dbf444c1", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 66, "deletions": 130, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/c5c8258937f056a0f4b0e83e1d878c268daa09ff/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5c8258937f056a0f4b0e83e1d878c268daa09ff/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c5c8258937f056a0f4b0e83e1d878c268daa09ff", "patch": "@@ -1521,9 +1521,24 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: &ast::purity,\n     }\n }\n \n+type unifier = fn(fcx: &@fn_ctxt, sp: &span,\n+                  expected: &ty::t, actual: &ty::t) -> ty::t;\n+\n fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n-    // fcx.ccx.tcx.sess.span_warn(expr.span, \"typechecking expr \" +\n-    //                            syntax::print::pprust::expr_to_str(expr));\n+    fn dummy_unify(fcx: &@fn_ctxt, sp: &span,\n+                   expected: &ty::t, actual: &ty::t) -> ty::t {\n+        actual\n+    }\n+    ret check_expr_with_unifier(fcx, expr, dummy_unify, 0u);\n+}\n+fn check_expr_with(fcx: &@fn_ctxt, expr: &@ast::expr, expected: &ty::t)\n+    -> bool {\n+    ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n+}\n+\n+fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n+                           unify: &unifier, expected: &ty::t) -> bool {\n+    //log_err \"typechecking expr \" + syntax::print::pprust::expr_to_str(expr);\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n@@ -1594,14 +1609,14 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         }\n \n         // Check the arguments.\n+        let unifier =\n+            bind demand::autoderef(_, _, _, _, AUTODEREF_BLOCK_COERCE);\n         let i = 0u;\n         for a_opt: option::t[@ast::expr]  in args {\n             alt a_opt {\n               some(a) {\n-                bot |= check_expr(fcx, a);\n-                demand::autoderef(fcx, a.span, arg_tys.(i).ty,\n-                                  expr_ty(fcx.ccx.tcx, a),\n-                                  AUTODEREF_BLOCK_COERCE);\n+                bot |= check_expr_with_unifier(fcx, a, unifier,\n+                                               arg_tys.(i).ty);\n               }\n               none. { }\n             }\n@@ -1613,9 +1628,8 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n \n     fn check_assignment(fcx: &@fn_ctxt, sp: &span, lhs: &@ast::expr,\n                         rhs: &@ast::expr, id: &ast::node_id) -> bool {\n-        let bot = check_expr(fcx, lhs) | check_expr(fcx, rhs);\n-        demand::simple(fcx, sp, expr_ty(fcx.ccx.tcx, lhs),\n-                       expr_ty(fcx.ccx.tcx, rhs));\n+        let t = next_ty_var(fcx);\n+        let bot = check_expr_with(fcx, lhs, t) | check_expr_with(fcx, rhs, t);\n         write::ty_only_fixup(fcx, id, ty::mk_nil(fcx.ccx.tcx));\n         ret bot;\n     }\n@@ -1671,18 +1685,14 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         demand::simple(fcx, local.span,\n                        ty::node_id_to_type(fcx.ccx.tcx, local.node.id),\n                        element_ty);\n-        let typ = ty::mk_nil(fcx.ccx.tcx);\n-        write::ty_only_fixup(fcx, node_id, typ);\n+        write::nil_ty(fcx.ccx.tcx, node_id);\n         ret bot;\n     }\n \n     // A generic function for checking the pred in a check\n     // or if-check\n     fn check_pred_expr(fcx: &@fn_ctxt, e: &@ast::expr) -> bool {\n-        let bot = check_expr(fcx, e);\n-        demand::simple(fcx, e.span, ty::mk_bool(fcx.ccx.tcx),\n-                       expr_ty(fcx.ccx.tcx, e));\n-\n+        let bot = check_expr_with(fcx, e, ty::mk_bool(fcx.ccx.tcx));\n \n         /* e must be a call expr where all arguments are either\n            literals or slots */\n@@ -1732,10 +1742,9 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         let if_t =\n             alt elsopt {\n               some(els) {\n-                els_bot = check_expr(fcx, els);\n                 let thn_t = block_ty(fcx.ccx.tcx, thn);\n+                els_bot = check_expr_with(fcx, els, thn_t);\n                 let elsopt_t = expr_ty(fcx.ccx.tcx, els);\n-                demand::simple(fcx, sp, thn_t, elsopt_t);\n                 if !ty::type_is_bot(fcx.ccx.tcx, elsopt_t) {\n                     elsopt_t\n                 } else { thn_t }\n@@ -1769,17 +1778,13 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_binary(binop, lhs, rhs) {\n-        bot = check_expr(fcx, lhs);\n-        if ast::lazy_binop(binop) {\n-            check_expr(fcx, rhs);\n-        } else {\n-            bot |= check_expr(fcx, rhs);\n-        }\n+        let lhs_t = next_ty_var(fcx);\n+        bot = check_expr_with(fcx, lhs, lhs_t);\n \n-        let lhs_t = expr_ty(tcx, lhs);\n-        let rhs_t = expr_ty(tcx, rhs);\n+        let unifier = bind demand::autoderef(_, _, _, _, AUTODEREF_OK);\n+        let rhs_bot = check_expr_with_unifier(fcx, rhs, unifier, lhs_t);\n+        if !ast::lazy_binop(binop) { bot |= rhs_bot; }\n \n-        demand::autoderef(fcx, rhs.span, lhs_t, rhs_t, AUTODEREF_OK);\n         let deref_t = do_autoderef(fcx, expr.span, lhs_t);\n         check_binop_type_compat(fcx, expr.span, deref_t, binop);\n \n@@ -1864,9 +1869,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         alt expr_opt {\n           none. {/* do nothing */ }\n           some(e) {\n-            check_expr(fcx, e);\n-            let ety = expr_ty(tcx, e);\n-            demand::simple(fcx, e.span, ty::mk_str(tcx), ety);\n+            check_expr_with(fcx, e, ty::mk_str(tcx));\n           }\n         }\n         write::bot_ty(tcx, id);\n@@ -1882,15 +1885,12 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n                 tcx.sess.span_fatal(expr.span,\n                                     \"ret; in function returning non-nil\");\n             }\n-            write::bot_ty(tcx, id);\n           }\n           some(e) {\n-            check_expr(fcx, e);\n-            demand::simple(fcx, expr.span, fcx.ret_ty,\n-                           expr_ty(tcx, e));\n-            write::bot_ty(tcx, id);\n+            check_expr_with(fcx, e, fcx.ret_ty);\n           }\n         }\n+        write::bot_ty(tcx, id);\n       }\n       ast::expr_put(expr_opt) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n@@ -1906,19 +1906,16 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n             }\n           }\n           some(e) {\n-            bot = check_expr(fcx, e);\n-            demand::simple(fcx, expr.span, fcx.ret_ty,\n-                           expr_ty(tcx, e));\n+            bot = check_expr_with(fcx, e, fcx.ret_ty);\n           }\n         }\n         write::nil_ty(tcx, id);\n       }\n       ast::expr_be(e) {\n         // FIXME: prove instead of assert\n         assert (ast::is_call_expr(e));\n-        check_expr(fcx, e);\n+        check_expr_with(fcx, e, fcx.ret_ty);\n         bot = true;\n-        demand::simple(fcx, e.span, fcx.ret_ty, expr_ty(tcx, e));\n         write::nil_ty(tcx, id);\n       }\n       ast::expr_log(l, e) {\n@@ -1937,9 +1934,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         bot = check_expr(fcx, ast::ternary_to_if(expr));\n       }\n       ast::expr_assert(e) {\n-        bot = check_expr(fcx, e);\n-        let ety = expr_ty(tcx, e);\n-        demand::simple(fcx, expr.span, ty::mk_bool(tcx), ety);\n+        bot = check_expr_with(fcx, e, ty::mk_bool(tcx));\n         write::nil_ty(tcx, id);\n       }\n       ast::expr_move(lhs, rhs) {\n@@ -1962,34 +1957,23 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n       }\n       ast::expr_send(lhs, rhs) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n-        bot = check_expr(fcx, lhs) | check_expr(fcx, rhs);\n-        let rhs_t = expr_ty(tcx, rhs);\n+        let rhs_t = next_ty_var(fcx);\n         let chan_t = ty::mk_chan(tcx, rhs_t);\n-        let lhs_t = expr_ty(tcx, lhs);\n-        alt structure_of(fcx, expr.span, lhs_t) {\n-          ty::ty_chan(it) { }\n-          _ {\n-            let s = #fmt(\"mismatched types: expected chan but found %s\",\n-                         ty_to_str(tcx, lhs_t));\n-            tcx.sess.span_fatal(expr.span, s);\n-          }\n-        }\n-        demand::simple(fcx, expr.span, chan_t, lhs_t);\n+        bot = check_expr_with(fcx, lhs, chan_t) |\n+              check_expr_with(fcx, rhs, rhs_t);\n         write::ty_only_fixup(fcx, id, chan_t);\n       }\n       ast::expr_recv(lhs, rhs) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n-        bot = check_expr(fcx, lhs) | check_expr(fcx, rhs);\n-        let item_t = expr_ty(tcx, rhs);\n-        let port_t = ty::mk_port(tcx, item_t);\n-        demand::simple(fcx, expr.span, port_t, expr_ty(tcx, lhs));\n-        write::ty_only_fixup(fcx, id, item_t);\n+        let rhs_t = next_ty_var(fcx);\n+        let port_t = ty::mk_port(tcx, rhs_t);\n+        bot = check_expr_with(fcx, lhs, port_t) |\n+              check_expr_with(fcx, rhs, rhs_t);\n+        write::ty_only_fixup(fcx, id, rhs_t);\n       }\n       ast::expr_if(cond, thn, elsopt) {\n-        bot = check_expr(fcx, cond) |\n+        bot = check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n               check_then_else(fcx, thn, elsopt, id, expr.span);\n-        demand::simple(fcx, cond.span, ty::mk_bool(tcx),\n-                       expr_ty(tcx, cond));\n       }\n       ast::expr_for(decl, seq, body) {\n         bot = check_expr(fcx, seq);\n@@ -2021,24 +2005,19 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n                                      body, id);\n       }\n       ast::expr_while(cond, body) {\n-        bot = check_expr(fcx, cond);\n+        bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n         check_block(fcx, body);\n-        demand::simple(fcx, cond.span, ty::mk_bool(tcx),\n-                       expr_ty(tcx, cond));\n-        let typ = ty::mk_nil(tcx);\n-        write::ty_only_fixup(fcx, id, typ);\n+        write::ty_only_fixup(fcx, id, ty::mk_nil(tcx));\n       }\n       ast::expr_do_while(body, cond) {\n-        bot = check_expr(fcx, cond);\n-        check_block(fcx, body);\n-        let typ = block_ty(tcx, body);\n-        write::ty_only_fixup(fcx, id, typ);\n+        bot = check_expr(fcx, cond) | check_block(fcx, body);\n+        write::ty_only_fixup(fcx, id, block_ty(tcx, body));\n       }\n       ast::expr_alt(expr, arms) {\n         bot = check_expr(fcx, expr);\n+\n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n-\n         let pattern_ty = ty::expr_ty(tcx, expr);\n         for arm: ast::arm  in arms {\n             let id_map = ast::pat_id_map(arm.pats.(0));\n@@ -2052,12 +2031,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         for arm: ast::arm  in arms {\n             if !check_block(fcx, arm.block) { arm_non_bot = true; }\n             let bty = block_ty(tcx, arm.block);\n-\n-            // Failing alt arms don't need to have a matching type\n-            if !ty::type_is_bot(tcx, bty) {\n-                result_ty =\n-                    demand::simple(fcx, arm.block.span, result_ty, bty);\n-            }\n+            result_ty = demand::simple(fcx, arm.block.span, result_ty, bty);\n         }\n         bot |= !arm_non_bot;\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n@@ -2076,16 +2050,11 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n       }\n       ast::expr_block(b) {\n         bot = check_block(fcx, b);\n-        alt b.node.expr {\n-          some(expr) {\n-            let typ = expr_ty(tcx, expr);\n-            write::ty_only_fixup(fcx, id, typ);\n-          }\n-          none. {\n-            let typ = ty::mk_nil(tcx);\n-            write::ty_only_fixup(fcx, id, typ);\n-          }\n-        }\n+        let typ = alt b.node.expr {\n+          some(expr) { expr_ty(tcx, expr) }\n+          none. { ty::mk_nil(tcx) }\n+        };\n+        write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n@@ -2216,17 +2185,9 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n       ast::expr_vec(args, mut, kind) {\n-        let t: ty::t;\n-        if ivec::len[@ast::expr](args) == 0u {\n-            t = next_ty_var(fcx);\n-        } else {\n-            bot |= check_expr(fcx, args.(0));\n-            t = expr_ty(tcx, args.(0));\n-        }\n+        let t: ty::t = next_ty_var(fcx);;\n         for e: @ast::expr in args {\n-            bot |= check_expr(fcx, e);\n-            let expr_t = expr_ty(tcx, e);\n-            demand::simple(fcx, expr.span, t, expr_t);\n+            bot |= check_expr_with(fcx, e, t);\n         }\n         let typ;\n         alt kind {\n@@ -2350,29 +2311,13 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         }\n       }\n       ast::expr_port(typ) {\n-        let t = next_ty_var(fcx);\n-        alt ast_ty_to_ty_crate_infer(fcx.ccx, typ) {\n-          some(_t) {\n-            demand::simple(fcx, expr.span, _t, t);\n-          }\n-          none. { }\n-        }\n-        let pt = ty::mk_port(tcx, t);\n+        let pt = ty::mk_port(tcx, ast_ty_to_ty_crate_tyvar(fcx, typ));\n         write::ty_only_fixup(fcx, id, pt);\n       }\n       ast::expr_chan(x) {\n-        check_expr(fcx, x);\n-        let port_t = expr_ty(tcx, x);\n-        alt structure_of(fcx, expr.span, port_t) {\n-          ty::ty_port(subtype) {\n-            let ct = ty::mk_chan(tcx, subtype);\n-            write::ty_only_fixup(fcx, id, ct);\n-          }\n-          _ {\n-            tcx.sess.span_fatal(expr.span,\n-                                \"bad port type: \" + ty_to_str(tcx, port_t));\n-          }\n-        }\n+        let t = next_ty_var(fcx);\n+        check_expr_with(fcx, x, ty::mk_port(tcx, t));\n+        write::ty_only_fixup(fcx, id, ty::mk_chan(tcx, t));\n       }\n       ast::expr_anon_obj(ao) {\n         let fields: [ast::anon_obj_field] = ~[];\n@@ -2512,6 +2457,8 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n     if bot {\n         write::ty_only_fixup(fcx, expr.id, ty::mk_bot(tcx));\n     }\n+\n+    unify(fcx, expr.span, expected, expr_ty(tcx, expr));\n     ret bot;\n }\n \n@@ -2531,19 +2478,8 @@ fn get_obj_info(ccx: &@crate_ctxt) -> option::t[obj_info] {\n \n fn check_decl_initializer(fcx: &@fn_ctxt, nid: ast::node_id,\n                           init: &ast::initializer) -> bool {\n-    let bot = check_expr(fcx, init.expr);\n     let lty = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, init.expr.span, nid));\n-    alt init.op {\n-      ast::init_assign. {\n-        demand::simple(fcx, init.expr.span, lty,\n-                       expr_ty(fcx.ccx.tcx, init.expr));\n-      }\n-      ast::init_move. {\n-        demand::simple(fcx, init.expr.span, lty,\n-                       expr_ty(fcx.ccx.tcx, init.expr));\n-      }\n-    }\n-    ret bot;\n+    ret check_expr_with(fcx, init.expr, lty);\n }\n \n fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {"}]}