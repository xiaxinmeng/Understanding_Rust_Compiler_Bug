{"sha": "8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhM2I0ODljMmY1N2JkZjhmNjI0MWU2OTI3NmVmYTQ4YjVlZDRhOTg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-06T16:58:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-06T17:01:26Z"}, "message": "kill module source", "tree": {"sha": "2032c28d8a72b162abe9f7b8dddffef7f036b91d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2032c28d8a72b162abe9f7b8dddffef7f036b91d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "html_url": "https://github.com/rust-lang/rust/commit/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf0ce14351af03c620aca784ee2c03aad86b866e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0ce14351af03c620aca784ee2c03aad86b866e", "html_url": "https://github.com/rust-lang/rust/commit/cf0ce14351af03c620aca784ee2c03aad86b866e"}], "stats": {"total": 350, "additions": 156, "deletions": 194}, "files": [{"sha": "1f70af12aa67776be58b90fc1d2e79a8a438daa3", "filename": "crates/ra_analysis/tests/test/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs?ref=8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "patch": "@@ -70,7 +70,7 @@ fn test_resolve_parent_module_for_inline() {\n     );\n     let symbols = analysis.parent_module(pos).unwrap();\n     assert_eq_dbg(\n-        r#\"[NavigationTarget { file_id: FileId(1), name: \"bar\", kind: MODULE, range: [18; 21), ptr: None }]\"#,\n+        r#\"[NavigationTarget { file_id: FileId(1), name: \"baz\", kind: MODULE, range: [36; 39), ptr: None }]\"#,\n         &symbols,\n     );\n }"}, {"sha": "3275eafed4be3cfa4035c6c3aecbb51d542e446e", "filename": "crates/ra_hir/src/code_model_impl/krate.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs?ref=8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "patch": "@@ -1,7 +1,7 @@\n use ra_db::{CrateId, Cancelable};\n \n use crate::{\n-    HirFileId, Crate, CrateDependency, AsName, DefLoc, DefKind, Module,\n+    HirFileId, Crate, CrateDependency, AsName, DefLoc, DefKind, Module, SourceItemId,\n     db::HirDatabase,\n };\n \n@@ -27,15 +27,17 @@ impl Crate {\n         let file_id = HirFileId::from(file_id);\n         let module_tree = db.module_tree(source_root_id)?;\n         // FIXME: teach module tree about crate roots instead of guessing\n-        let (module_id, _) = ctry!(module_tree\n-            .modules_with_sources()\n-            .find(|(_, src)| src.file_id() == file_id));\n+        let source = SourceItemId {\n+            file_id,\n+            item_id: None,\n+        };\n+        let module_id = ctry!(module_tree.find_module_by_source(source));\n \n         let def_loc = DefLoc {\n             kind: DefKind::Module,\n             source_root_id,\n             module_id,\n-            source_item_id: module_id.source(&module_tree).0,\n+            source_item_id: module_id.source(&module_tree),\n         };\n         let def_id = def_loc.id(db);\n "}, {"sha": "eb35779f1cebb2e5d0b8f2dcf92b5bc3a52c0308", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "patch": "@@ -22,7 +22,7 @@ impl Module {\n             kind: DefKind::Module,\n             source_root_id,\n             module_id,\n-            source_item_id: module_id.source(&module_tree).0,\n+            source_item_id: module_id.source(&module_tree),\n         };\n         let def_id = def_loc.id(db);\n         let module = Module::new(def_id);\n@@ -63,9 +63,9 @@ impl Module {\n         let file_id = link\n             .owner(&module_tree)\n             .source(&module_tree)\n-            .file_id()\n+            .file_id\n             .as_original_file();\n-        let src = link.bind_source(&module_tree, db);\n+        let src = link.source(&module_tree, db);\n         Ok(Some((file_id, src)))\n     }\n "}, {"sha": "033f9d25f7f6df44820f750a29d5e163b911eded", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     query_definitions,\n     FnSignature, FnScopes,\n     macros::MacroExpansion,\n-    module_tree::{ModuleId, ModuleTree, ModuleSource},\n+    module_tree::{ModuleId, ModuleTree},\n     nameres::{ItemMap, InputModuleItems},\n     ty::{InferenceResult, Ty},\n     adt::{StructData, EnumData},\n@@ -71,7 +71,7 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::file_item;\n     }\n \n-    fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::module_tree::Submodule>>> {\n+    fn submodules(source: SourceItemId) -> Cancelable<Arc<Vec<crate::module_tree::Submodule>>> {\n         type SubmodulesQuery;\n         use fn crate::module_tree::Submodule::submodules_query;\n     }"}, {"sha": "c7a442319cd7237648215bb96762d39b6057f1bb", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 102, "deletions": 143, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "patch": "@@ -11,55 +11,70 @@ use ra_syntax::{\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n-use crate::{Name, AsName, HirDatabase, SourceItemId, SourceFileItemId, HirFileId, Problem};\n+use crate::{Name, AsName, HirDatabase, SourceItemId, HirFileId, Problem, SourceFileItems, ModuleSource};\n+\n+impl ModuleSource {\n+    pub fn from_source_item_id(\n+        db: &impl HirDatabase,\n+        source_item_id: SourceItemId,\n+    ) -> ModuleSource {\n+        let module_syntax = db.file_item(source_item_id);\n+        let module_syntax = module_syntax.borrowed();\n+        if let Some(source_file) = ast::SourceFile::cast(module_syntax) {\n+            ModuleSource::SourceFile(source_file.owned())\n+        } else if let Some(module) = ast::Module::cast(module_syntax) {\n+            assert!(module.item_list().is_some(), \"expected inline module\");\n+            ModuleSource::Module(module.owned())\n+        } else {\n+            panic!(\"expected file or inline module\")\n+        }\n+    }\n+}\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub enum Submodule {\n-    Declaration(Name),\n-    Definition(Name, ModuleSource),\n+pub struct Submodule {\n+    name: Name,\n+    is_declaration: bool,\n+    source: SourceItemId,\n }\n \n impl Submodule {\n     pub(crate) fn submodules_query(\n         db: &impl HirDatabase,\n-        source: ModuleSource,\n+        source: SourceItemId,\n     ) -> Cancelable<Arc<Vec<Submodule>>> {\n         db.check_canceled()?;\n-        let file_id = source.file_id();\n-        let submodules = match source.resolve(db) {\n-            ModuleSourceNode::SourceFile(it) => collect_submodules(db, file_id, it.borrowed()),\n-            ModuleSourceNode::Module(it) => it\n-                .borrowed()\n-                .item_list()\n-                .map(|it| collect_submodules(db, file_id, it))\n-                .unwrap_or_else(Vec::new),\n+        let file_id = source.file_id;\n+        let file_items = db.file_items(file_id);\n+        let module_source = ModuleSource::from_source_item_id(db, source);\n+        let submodules = match module_source {\n+            ModuleSource::SourceFile(source_file) => {\n+                collect_submodules(file_id, &file_items, source_file.borrowed())\n+            }\n+            ModuleSource::Module(module) => {\n+                let module = module.borrowed();\n+                collect_submodules(file_id, &file_items, module.item_list().unwrap())\n+            }\n         };\n         return Ok(Arc::new(submodules));\n \n         fn collect_submodules<'a>(\n-            db: &impl HirDatabase,\n             file_id: HirFileId,\n+            file_items: &SourceFileItems,\n             root: impl ast::ModuleItemOwner<'a>,\n         ) -> Vec<Submodule> {\n             modules(root)\n-                .map(|(name, m)| {\n-                    if m.has_semi() {\n-                        Submodule::Declaration(name)\n-                    } else {\n-                        let src = ModuleSource::new_inline(db, file_id, m);\n-                        Submodule::Definition(name, src)\n-                    }\n+                .map(|(name, m)| Submodule {\n+                    name,\n+                    is_declaration: m.has_semi(),\n+                    source: SourceItemId {\n+                        file_id,\n+                        item_id: Some(file_items.id_of(file_id, m.syntax())),\n+                    },\n                 })\n                 .collect()\n         }\n     }\n-\n-    fn name(&self) -> &Name {\n-        match self {\n-            Submodule::Declaration(name) => name,\n-            Submodule::Definition(name, _) => name,\n-        }\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -85,13 +100,14 @@ pub struct ModuleTree {\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n pub struct ModuleData {\n-    source: ModuleSource,\n+    source: SourceItemId,\n     parent: Option<LinkId>,\n     children: Vec<LinkId>,\n }\n \n #[derive(Hash, Debug, PartialEq, Eq)]\n struct LinkData {\n+    source: SourceItemId,\n     owner: ModuleId,\n     name: Name,\n     points_to: Vec<ModuleId>,\n@@ -112,27 +128,14 @@ impl ModuleTree {\n         self.mods.iter().map(|(id, _)| id)\n     }\n \n-    pub(crate) fn modules_with_sources<'a>(\n-        &'a self,\n-    ) -> impl Iterator<Item = (ModuleId, ModuleSource)> + 'a {\n-        self.mods.iter().map(|(id, m)| (id, m.source))\n+    pub(crate) fn find_module_by_source(&self, source: SourceItemId) -> Option<ModuleId> {\n+        let (res, _) = self.mods.iter().find(|(_, m)| m.source == source)?;\n+        Some(res)\n     }\n }\n \n-/// `ModuleSource` is the syntax tree element that produced this module:\n-/// either a file, or an inlinde module.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct ModuleSource(pub(crate) SourceItemId);\n-\n-/// An owned syntax node for a module. Unlike `ModuleSource`,\n-/// this holds onto the AST for the whole file.\n-pub(crate) enum ModuleSourceNode {\n-    SourceFile(ast::SourceFileNode),\n-    Module(ast::ModuleNode),\n-}\n-\n impl ModuleId {\n-    pub(crate) fn source(self, tree: &ModuleTree) -> ModuleSource {\n+    pub(crate) fn source(self, tree: &ModuleTree) -> SourceItemId {\n         tree.mods[self].source\n     }\n     pub(crate) fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n@@ -173,9 +176,9 @@ impl ModuleId {\n         tree.mods[self]\n             .children\n             .iter()\n-            .filter_map(|&it| {\n-                let p = tree.links[it].problem.clone()?;\n-                let s = it.bind_source(tree, db);\n+            .filter_map(|&link| {\n+                let p = tree.links[link].problem.clone()?;\n+                let s = link.source(tree, db);\n                 let s = s.borrowed().name().unwrap().syntax().owned();\n                 Some((s, p))\n             })\n@@ -190,59 +193,11 @@ impl LinkId {\n     pub(crate) fn name(self, tree: &ModuleTree) -> &Name {\n         &tree.links[self].name\n     }\n-    pub(crate) fn bind_source<'a>(\n-        self,\n-        tree: &ModuleTree,\n-        db: &impl HirDatabase,\n-    ) -> ast::ModuleNode {\n-        let owner = self.owner(tree);\n-        match owner.source(tree).resolve(db) {\n-            ModuleSourceNode::SourceFile(root) => {\n-                let ast = modules(root.borrowed())\n-                    .find(|(name, _)| name == &tree.links[self].name)\n-                    .unwrap()\n-                    .1;\n-                ast.owned()\n-            }\n-            ModuleSourceNode::Module(it) => it,\n-        }\n-    }\n-}\n-\n-impl ModuleSource {\n-    // precondition: item_id **must** point to module\n-    fn new(file_id: HirFileId, item_id: Option<SourceFileItemId>) -> ModuleSource {\n-        let source_item_id = SourceItemId { file_id, item_id };\n-        ModuleSource(source_item_id)\n-    }\n-\n-    pub(crate) fn new_file(file_id: HirFileId) -> ModuleSource {\n-        ModuleSource::new(file_id, None)\n-    }\n-\n-    pub(crate) fn new_inline(\n-        db: &impl HirDatabase,\n-        file_id: HirFileId,\n-        m: ast::Module,\n-    ) -> ModuleSource {\n-        assert!(!m.has_semi());\n-        let file_items = db.file_items(file_id);\n-        let item_id = file_items.id_of(file_id, m.syntax());\n-        ModuleSource::new(file_id, Some(item_id))\n-    }\n-\n-    pub(crate) fn file_id(self) -> HirFileId {\n-        self.0.file_id\n-    }\n-\n-    pub(crate) fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {\n-        let syntax_node = db.file_item(self.0);\n-        let syntax_node = syntax_node.borrowed();\n-        if let Some(file) = ast::SourceFile::cast(syntax_node) {\n-            return ModuleSourceNode::SourceFile(file.owned());\n-        }\n-        let module = ast::Module::cast(syntax_node).unwrap();\n-        ModuleSourceNode::Module(module.owned())\n+    pub(crate) fn source(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n+        let syntax_node = db.file_item(tree.links[self].source);\n+        ast::ModuleNode::cast(syntax_node.borrowed())\n+            .unwrap()\n+            .owned()\n     }\n }\n \n@@ -283,7 +238,10 @@ fn create_module_tree<'a>(\n \n     let source_root = db.source_root(source_root);\n     for &file_id in source_root.files.values() {\n-        let source = ModuleSource::new_file(file_id.into());\n+        let source = SourceItemId {\n+            file_id: file_id.into(),\n+            item_id: None,\n+        };\n         if visited.contains(&source) {\n             continue; // TODO: use explicit crate_roots here\n         }\n@@ -306,10 +264,10 @@ fn build_subtree(\n     db: &impl HirDatabase,\n     source_root: &SourceRoot,\n     tree: &mut ModuleTree,\n-    visited: &mut FxHashSet<ModuleSource>,\n+    visited: &mut FxHashSet<SourceItemId>,\n     roots: &mut FxHashMap<FileId, ModuleId>,\n     parent: Option<LinkId>,\n-    source: ModuleSource,\n+    source: SourceItemId,\n ) -> Cancelable<ModuleId> {\n     visited.insert(source);\n     let id = tree.push_mod(ModuleData {\n@@ -319,47 +277,48 @@ fn build_subtree(\n     });\n     for sub in db.submodules(source)?.iter() {\n         let link = tree.push_link(LinkData {\n-            name: sub.name().clone(),\n+            source: sub.source,\n+            name: sub.name.clone(),\n             owner: id,\n             points_to: Vec::new(),\n             problem: None,\n         });\n \n-        let (points_to, problem) = match sub {\n-            Submodule::Declaration(name) => {\n-                let (points_to, problem) = resolve_submodule(db, source, &name);\n-                let points_to = points_to\n-                    .into_iter()\n-                    .map(|file_id| match roots.remove(&file_id) {\n-                        Some(module_id) => {\n-                            tree.mods[module_id].parent = Some(link);\n-                            Ok(module_id)\n-                        }\n-                        None => build_subtree(\n-                            db,\n-                            source_root,\n-                            tree,\n-                            visited,\n-                            roots,\n-                            Some(link),\n-                            ModuleSource::new_file(file_id.into()),\n-                        ),\n-                    })\n-                    .collect::<Cancelable<Vec<_>>>()?;\n-                (points_to, problem)\n-            }\n-            Submodule::Definition(_name, submodule_source) => {\n-                let points_to = build_subtree(\n-                    db,\n-                    source_root,\n-                    tree,\n-                    visited,\n-                    roots,\n-                    Some(link),\n-                    *submodule_source,\n-                )?;\n-                (vec![points_to], None)\n-            }\n+        let (points_to, problem) = if sub.is_declaration {\n+            let (points_to, problem) = resolve_submodule(db, source.file_id, &sub.name);\n+            let points_to = points_to\n+                .into_iter()\n+                .map(|file_id| match roots.remove(&file_id) {\n+                    Some(module_id) => {\n+                        tree.mods[module_id].parent = Some(link);\n+                        Ok(module_id)\n+                    }\n+                    None => build_subtree(\n+                        db,\n+                        source_root,\n+                        tree,\n+                        visited,\n+                        roots,\n+                        Some(link),\n+                        SourceItemId {\n+                            file_id: file_id.into(),\n+                            item_id: None,\n+                        },\n+                    ),\n+                })\n+                .collect::<Cancelable<Vec<_>>>()?;\n+            (points_to, problem)\n+        } else {\n+            let points_to = build_subtree(\n+                db,\n+                source_root,\n+                tree,\n+                visited,\n+                roots,\n+                Some(link),\n+                sub.source,\n+            )?;\n+            (vec![points_to], None)\n         };\n \n         tree.links[link].points_to = points_to;\n@@ -370,11 +329,11 @@ fn build_subtree(\n \n fn resolve_submodule(\n     db: &impl HirDatabase,\n-    source: ModuleSource,\n+    file_id: HirFileId,\n     name: &Name,\n ) -> (Vec<FileId>, Option<Problem>) {\n     // FIXME: handle submodules of inline modules properly\n-    let file_id = source.file_id().original_file(db);\n+    let file_id = file_id.original_file(db);\n     let source_root_id = db.file_source_root(file_id);\n     let path = db.file_relative_path(file_id);\n     let root = RelativePathBuf::default();"}, {"sha": "9a412bc82b333d3c73e228ecde2b3a1eec50f440", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "patch": "@@ -339,7 +339,7 @@ where\n         // Populate extern crates prelude\n         {\n             let root_id = module_id.crate_root(&self.module_tree);\n-            let file_id = root_id.source(&self.module_tree).file_id();\n+            let file_id = root_id.source(&self.module_tree).file_id;\n             let crate_graph = self.db.crate_graph();\n             if let Some(crate_id) = crate_graph.crate_id_for_crate_root(file_id.as_original_file())\n             {\n@@ -399,7 +399,7 @@ where\n                 kind: DefKind::Module,\n                 source_root_id: self.source_root,\n                 module_id,\n-                source_item_id: module_id.source(&self.module_tree).0,\n+                source_item_id: module_id.source(&self.module_tree),\n             };\n             let def_id = def_loc.id(self.db);\n             self.add_module_item(&mut module_items, name, PerNs::types(def_id));"}, {"sha": "8f2c406696249ffeb98a9e1e89e0825de7a2f563", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "patch": "@@ -11,11 +11,11 @@ use ra_syntax::{\n use ra_db::{SourceRootId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind, DefId, HirFileId,\n+    SourceFileItems, SourceItemId, DefKind, DefId, HirFileId, ModuleSource,\n     MacroCallLoc,\n     db::HirDatabase,\n     function::FnScopes,\n-    module_tree::{ModuleId, ModuleSourceNode},\n+    module_tree::ModuleId,\n     nameres::{InputModuleItems, ItemMap, Resolver},\n     adt::{StructData, EnumData},\n };\n@@ -65,7 +65,8 @@ pub(super) fn input_module_items(\n ) -> Cancelable<Arc<InputModuleItems>> {\n     let module_tree = db.module_tree(source_root_id)?;\n     let source = module_id.source(&module_tree);\n-    let file_id = source.file_id();\n+    let file_id = source.file_id;\n+    let source = ModuleSource::from_source_item_id(db, source);\n     let file_items = db.file_items(file_id);\n     let fill = |acc: &mut InputModuleItems, items: &mut Iterator<Item = ast::ItemOrMacro>| {\n         for item in items {\n@@ -96,9 +97,9 @@ pub(super) fn input_module_items(\n     };\n \n     let mut res = InputModuleItems::default();\n-    match source.resolve(db) {\n-        ModuleSourceNode::SourceFile(it) => fill(&mut res, &mut it.borrowed().items_with_macros()),\n-        ModuleSourceNode::Module(it) => {\n+    match source {\n+        ModuleSource::SourceFile(it) => fill(&mut res, &mut it.borrowed().items_with_macros()),\n+        ModuleSource::Module(it) => {\n             if let Some(item_list) = it.borrowed().item_list() {\n                 fill(&mut res, &mut item_list.items_with_macros())\n             }"}, {"sha": "4c14650c09a2f0daf1ce01b11dccf5d920c11cb5", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a3b489c2f57bdf8f6241e69276efa48b5ed4a98/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=8a3b489c2f57bdf8f6241e69276efa48b5ed4a98", "patch": "@@ -14,15 +14,15 @@ use ra_syntax::{\n \n use crate::{\n     HirDatabase, Function, SourceItemId,\n-    module_tree::ModuleSource,\n-    DefKind, DefLoc, AsName,\n+    DefKind, DefLoc, AsName, Module,\n };\n \n-use crate::code_model_api::Module;\n-\n /// Locates the module by `FileId`. Picks topmost module in the file.\n pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Cancelable<Option<Module>> {\n-    let module_source = ModuleSource::new_file(file_id.into());\n+    let module_source = SourceItemId {\n+        file_id: file_id.into(),\n+        item_id: None,\n+    };\n     module_from_source(db, module_source)\n }\n \n@@ -51,11 +51,26 @@ pub fn module_from_position(\n     position: FilePosition,\n ) -> Cancelable<Option<Module>> {\n     let file = db.source_file(position.file_id);\n-    let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset) {\n-        Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id.into(), m),\n-        _ => ModuleSource::new_file(position.file_id.into()),\n+    match find_node_at_offset::<ast::Module>(file.syntax(), position.offset) {\n+        Some(m) if !m.has_semi() => module_from_inline(db, position.file_id.into(), m),\n+        _ => module_from_file_id(db, position.file_id.into()),\n+    }\n+}\n+\n+fn module_from_inline(\n+    db: &impl HirDatabase,\n+    file_id: FileId,\n+    module: ast::Module,\n+) -> Cancelable<Option<Module>> {\n+    assert!(!module.has_semi());\n+    let file_id = file_id.into();\n+    let file_items = db.file_items(file_id);\n+    let item_id = file_items.id_of(file_id, module.syntax());\n+    let source = SourceItemId {\n+        file_id,\n+        item_id: Some(item_id),\n     };\n-    module_from_source(db, module_source)\n+    module_from_source(db, source)\n }\n \n /// Locates the module by child syntax element within the module\n@@ -64,37 +79,22 @@ pub fn module_from_child_node(\n     file_id: FileId,\n     child: SyntaxNodeRef,\n ) -> Cancelable<Option<Module>> {\n-    let module_source = if let Some(m) = child\n+    if let Some(m) = child\n         .ancestors()\n         .filter_map(ast::Module::cast)\n         .find(|it| !it.has_semi())\n     {\n-        ModuleSource::new_inline(db, file_id.into(), m)\n+        module_from_inline(db, file_id.into(), m)\n     } else {\n-        ModuleSource::new_file(file_id.into())\n-    };\n-    module_from_source(db, module_source)\n+        module_from_file_id(db, file_id.into())\n+    }\n }\n \n-fn module_from_source(\n-    db: &impl HirDatabase,\n-    module_source: ModuleSource,\n-) -> Cancelable<Option<Module>> {\n-    let source_root_id = db.file_source_root(module_source.file_id().as_original_file());\n+fn module_from_source(db: &impl HirDatabase, source: SourceItemId) -> Cancelable<Option<Module>> {\n+    let source_root_id = db.file_source_root(source.file_id.as_original_file());\n     let module_tree = db.module_tree(source_root_id)?;\n-    let m = module_tree\n-        .modules_with_sources()\n-        .find(|(_id, src)| src == &module_source);\n-    let module_id = ctry!(m).0;\n-    let def_loc = DefLoc {\n-        kind: DefKind::Module,\n-        source_root_id,\n-        module_id,\n-        source_item_id: module_source.0,\n-    };\n-    let def_id = def_loc.id(db);\n-\n-    Ok(Some(Module::new(def_id)))\n+    let module_id = ctry!(module_tree.find_module_by_source(source));\n+    Ok(Some(Module::from_module_id(db, source_root_id, module_id)?))\n }\n \n pub fn function_from_position("}]}