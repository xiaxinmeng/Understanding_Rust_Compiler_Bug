{"sha": "9b1fee898f03b50113549b74da4c6d19eca4728e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMWZlZTg5OGYwM2I1MDExMzU0OWI3NGRhNGM2ZDE5ZWNhNDcyOGU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-06T03:07:47Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:06Z"}, "message": "De-@ ty::ctxt usage.", "tree": {"sha": "9fc93baffe3d90fba80b98990b0862c04090e799", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fc93baffe3d90fba80b98990b0862c04090e799"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b1fee898f03b50113549b74da4c6d19eca4728e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1fee898f03b50113549b74da4c6d19eca4728e", "html_url": "https://github.com/rust-lang/rust/commit/9b1fee898f03b50113549b74da4c6d19eca4728e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b1fee898f03b50113549b74da4c6d19eca4728e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fae06824ce1a3de3d24677196bf2e0d53346830", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fae06824ce1a3de3d24677196bf2e0d53346830", "html_url": "https://github.com/rust-lang/rust/commit/4fae06824ce1a3de3d24677196bf2e0d53346830"}], "stats": {"total": 1497, "additions": 741, "deletions": 756}, "files": [{"sha": "b86f03ae36b576c8ed072d14aa7eb9a6797accfe", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -534,7 +534,7 @@ fn truncated_hash_result(symbol_hasher: &mut Sha256) -> ~str {\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &mut Sha256,\n+fn symbol_hash(tcx: &ty::ctxt, symbol_hasher: &mut Sha256,\n                t: ty::t, link_meta: &LinkMeta) -> ~str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate."}, {"sha": "0c1b9d5732cdea5993dac45d6633ac1bd85940c0", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -327,60 +327,60 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                             freevars, region_map, lang_items);\n \n     // passes are timed inside typeck\n-    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map, krate);\n+    let (method_map, vtable_map) = typeck::check_crate(&ty_cx, trait_map, krate);\n \n     time(time_passes, \"check static items\", (), |_|\n-         middle::check_static::check_crate(ty_cx, krate));\n+         middle::check_static::check_crate(&ty_cx, krate));\n \n     // These next two const passes can probably be merged\n     time(time_passes, \"const marking\", (), |_|\n-         middle::const_eval::process_crate(krate, ty_cx));\n+         middle::const_eval::process_crate(krate, &ty_cx));\n \n     time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(krate, def_map, method_map, ty_cx));\n+         middle::check_const::check_crate(krate, def_map, method_map, &ty_cx));\n \n     let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n-                 middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n+                 middle::privacy::check_crate(&ty_cx, &method_map, &exp_map2,\n                                               a, b, krate));\n \n     time(time_passes, \"effect checking\", (), |_|\n-         middle::effect::check_crate(ty_cx, method_map, krate));\n+         middle::effect::check_crate(&ty_cx, method_map, krate));\n \n     time(time_passes, \"loop checking\", (), |_|\n-         middle::check_loop::check_crate(ty_cx, krate));\n+         middle::check_loop::check_crate(&ty_cx, krate));\n \n     let middle::moves::MoveMaps {moves_map, moved_variables_set,\n                                  capture_map} =\n         time(time_passes, \"compute moves\", (), |_|\n-             middle::moves::compute_moves(ty_cx, method_map, krate));\n+             middle::moves::compute_moves(&ty_cx, method_map, krate));\n \n     time(time_passes, \"match checking\", (), |_|\n-         middle::check_match::check_crate(ty_cx, method_map,\n+         middle::check_match::check_crate(&ty_cx, method_map,\n                                           moves_map, krate));\n \n     time(time_passes, \"liveness checking\", (), |_|\n-         middle::liveness::check_crate(ty_cx, method_map,\n+         middle::liveness::check_crate(&ty_cx, method_map,\n                                        capture_map, krate));\n \n     let root_map =\n         time(time_passes, \"borrow checking\", (), |_|\n-             middle::borrowck::check_crate(ty_cx, method_map,\n+             middle::borrowck::check_crate(&ty_cx, method_map,\n                                            moves_map, moved_variables_set,\n                                            capture_map, krate));\n \n     time(time_passes, \"kind checking\", (), |_|\n-         kind::check_crate(ty_cx, method_map, krate));\n+         kind::check_crate(&ty_cx, method_map, krate));\n \n     let reachable_map =\n         time(time_passes, \"reachability checking\", (), |_|\n-             reachable::find_reachable(ty_cx, method_map, &exported_items));\n+             reachable::find_reachable(&ty_cx, method_map, &exported_items));\n \n     {\n         let reachable_map = reachable_map.borrow();\n         time(time_passes, \"death checking\", (), |_| {\n-             middle::dead::check_crate(ty_cx,\n+             middle::dead::check_crate(&ty_cx,\n                                        method_map,\n                                        &exported_items,\n                                        reachable_map.get(),\n@@ -389,7 +389,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     }\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(ty_cx, method_map, &exported_items, krate));\n+         lint::check_crate(&ty_cx, method_map, &exported_items, krate));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n@@ -640,7 +640,7 @@ impl pprust::PpAnn for TypedAnnotation {\n         }\n     }\n     fn post(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n-        let tcx = self.analysis.ty_cx;\n+        let tcx = &self.analysis.ty_cx;\n         match node {\n             pprust::NodeExpr(s, expr) => {\n                 try!(pp::space(&mut s.s));"}, {"sha": "64e12679da1b1dd0255ef990267ef2a3ef39367f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -87,7 +87,7 @@ pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n                                           callback)\n }\n \n-pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n+pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     let path = decoder::get_item_path(cdata, def.node);\n@@ -107,29 +107,29 @@ pub enum found_ast {\n // Finds the AST for this item in the crate metadata, if any.  If the item was\n // not marked for inlining, then the AST will not be present and hence none\n // will be returned.\n-pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::DefId,\n+pub fn maybe_get_item_ast(tcx: &ty::ctxt, def: ast::DefId,\n                           decode_inlined_item: decoder::DecodeInlinedItem)\n                        -> found_ast {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::maybe_get_item_ast(cdata, tcx, def.node, decode_inlined_item)\n }\n \n-pub fn get_enum_variants(tcx: ty::ctxt, def: ast::DefId)\n+pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n                       -> Vec<@ty::VariantInfo> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(tcx: ty::ctxt, impl_def_id: ast::DefId)\n+pub fn get_impl(tcx: &ty::ctxt, impl_def_id: ast::DefId)\n                 -> ty::Impl {\n     let cdata = tcx.cstore.get_crate_data(impl_def_id.krate);\n     decoder::get_impl(tcx.cstore.intr, cdata, impl_def_id.node, tcx)\n }\n \n-pub fn get_method(tcx: ty::ctxt, def: ast::DefId) -> ty::Method {\n+pub fn get_method(tcx: &ty::ctxt, def: ast::DefId) -> ty::Method {\n     let cdata = tcx.cstore.get_crate_data(def.krate);\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }\n@@ -154,15 +154,15 @@ pub fn get_item_variances(cstore: @cstore::CStore,\n     decoder::get_item_variances(cdata, def.node)\n }\n \n-pub fn get_provided_trait_methods(tcx: ty::ctxt,\n+pub fn get_provided_trait_methods(tcx: &ty::ctxt,\n                                   def: ast::DefId)\n                                -> Vec<@ty::Method> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n+pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n@@ -195,21 +195,21 @@ pub fn get_struct_fields(cstore: @cstore::CStore,\n     decoder::get_struct_fields(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_type(tcx: ty::ctxt,\n+pub fn get_type(tcx: &ty::ctxt,\n                 def: ast::DefId)\n              -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n-pub fn get_trait_def(tcx: ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n+pub fn get_trait_def(tcx: &ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_def(cdata, def.node, tcx)\n }\n \n-pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n+pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n@@ -232,15 +232,15 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n \n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n-pub fn get_impl_trait(tcx: ty::ctxt,\n+pub fn get_impl_trait(tcx: &ty::ctxt,\n                       def: ast::DefId) -> Option<@ty::TraitRef> {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n-pub fn get_impl_vtables(tcx: ty::ctxt,\n+pub fn get_impl_vtables(tcx: &ty::ctxt,\n                         def: ast::DefId) -> typeck::impl_res {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n@@ -295,7 +295,7 @@ pub fn each_implementation_for_trait(cstore: @cstore::CStore,\n /// the trait that the method belongs to. Otherwise, returns `None`.\n pub fn get_trait_of_method(cstore: @cstore::CStore,\n                            def_id: ast::DefId,\n-                           tcx: ty::ctxt)\n+                           tcx: &ty::ctxt)\n                            -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_trait_of_method(cdata, def_id.node, tcx)"}, {"sha": "8f785268ae03f0c37642644c8219799f2b2aa2b0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -219,35 +219,35 @@ fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n     })\n }\n \n-fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n+fn doc_type(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n-fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n+fn doc_method_fty(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n     parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n pub fn item_type(_item_id: ast::DefId, item: ebml::Doc,\n-                 tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n+                 tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn doc_trait_ref(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n-fn item_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn item_trait_ref(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n fn item_ty_param_defs(item: ebml::Doc,\n-                      tcx: ty::ctxt,\n+                      tcx: &ty::ctxt,\n                       cdata: Cmd,\n                       tag: uint)\n                       -> Rc<Vec<ty::TypeParameterDef> > {\n@@ -378,7 +378,7 @@ fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n \n pub fn get_trait_def(cdata: Cmd,\n                      item_id: ast::NodeId,\n-                     tcx: ty::ctxt) -> ty::TraitDef\n+                     tcx: &ty::ctxt) -> ty::TraitDef\n {\n     let item_doc = lookup_item(item_id, cdata.data());\n     let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n@@ -403,7 +403,7 @@ pub fn get_trait_def(cdata: Cmd,\n     }\n }\n \n-pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n+pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n     let item = lookup_item(id, cdata.data());\n@@ -427,7 +427,7 @@ pub fn get_type_param_count(data: &[u8], id: ast::NodeId) -> uint {\n \n pub fn get_impl_trait(cdata: Cmd,\n                       id: ast::NodeId,\n-                      tcx: ty::ctxt) -> Option<@ty::TraitRef>\n+                      tcx: &ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n@@ -437,7 +437,7 @@ pub fn get_impl_trait(cdata: Cmd,\n \n pub fn get_impl_vtables(cdata: Cmd,\n                         id: ast::NodeId,\n-                        tcx: ty::ctxt) -> typeck::impl_res\n+                        tcx: &ty::ctxt) -> typeck::impl_res\n {\n     let item_doc = lookup_item(id, cdata.data());\n     let vtables_doc = reader::get_doc(item_doc, tag_item_impl_vtables);\n@@ -672,12 +672,12 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n }\n \n pub type DecodeInlinedItem<'a> = 'a |cdata: @cstore::crate_metadata,\n-                                     tcx: ty::ctxt,\n-                                     path: Vec<ast_map::PathElem> ,\n+                                     tcx: &ty::ctxt,\n+                                     path: Vec<ast_map::PathElem>,\n                                      par_doc: ebml::Doc|\n                                      -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n \n-pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n+pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n                           decode_inlined_item: DecodeInlinedItem)\n                           -> csearch::found_ast {\n     debug!(\"Looking up item: {}\", id);\n@@ -702,7 +702,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n }\n \n pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n-                     tcx: ty::ctxt) -> Vec<@ty::VariantInfo> {\n+                     tcx: &ty::ctxt) -> Vec<@ty::VariantInfo> {\n     let data = cdata.data();\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n@@ -761,7 +761,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n }\n \n fn item_impl_methods(intr: @IdentInterner, cdata: Cmd, item: ebml::Doc,\n-                     tcx: ty::ctxt) -> Vec<@ty::Method> {\n+                     tcx: &ty::ctxt) -> Vec<@ty::Method> {\n     let mut rslt = Vec::new();\n     reader::tagged_docs(item, tag_item_impl_method, |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n@@ -774,7 +774,7 @@ fn item_impl_methods(intr: @IdentInterner, cdata: Cmd, item: ebml::Doc,\n \n /// Returns information about the given implementation.\n pub fn get_impl(intr: @IdentInterner, cdata: Cmd, impl_id: ast::NodeId,\n-               tcx: ty::ctxt)\n+               tcx: &ty::ctxt)\n                 -> ty::Impl {\n     let data = cdata.data();\n     let impl_item = lookup_item(impl_id, data);\n@@ -800,7 +800,7 @@ pub fn get_method_name_and_explicit_self(\n }\n \n pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n-                  tcx: ty::ctxt) -> ty::Method\n+                  tcx: &ty::ctxt) -> ty::Method\n {\n     let method_doc = lookup_item(id, cdata.data());\n     let def_id = item_def_id(method_doc, cdata);\n@@ -858,7 +858,7 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n }\n \n pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n-                                  id: ast::NodeId, tcx: ty::ctxt) ->\n+                                  id: ast::NodeId, tcx: &ty::ctxt) ->\n         Vec<@ty::Method> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n@@ -878,7 +878,7 @@ pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n }\n \n /// Returns the supertraits of the given trait.\n-pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n+pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n                     -> Vec<@ty::TraitRef> {\n     let mut results = Vec::new();\n     let item_doc = lookup_item(id, cdata.data());\n@@ -1235,7 +1235,7 @@ pub fn each_implementation_for_trait(cdata: Cmd,\n     });\n }\n \n-pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n+pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n                            -> Option<ast::DefId> {\n     let item_doc = lookup_item(id, cdata.data());\n     let parent_item_id = match item_parent_item(item_doc) {"}, {"sha": "4ff8e9a489657a6bd6dbd12bd09e6e126adb1357", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -69,7 +69,7 @@ pub type EncodeInlinedItem<'a> = 'a |ecx: &EncodeContext,\n \n pub struct EncodeParams<'a> {\n     diag: @SpanHandler,\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'a RefCell<NodeMap<~str>>,\n     non_inlineable_statics: &'a RefCell<NodeSet>,\n@@ -96,7 +96,7 @@ pub struct Stats {\n \n pub struct EncodeContext<'a> {\n     diag: @SpanHandler,\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     stats: @Stats,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'a RefCell<NodeMap<~str>>,\n@@ -1899,7 +1899,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n+pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> ~str {\n     let cx = @tyencode::ctxt {\n         diag: tcx.diag,\n         ds: def_to_str,"}, {"sha": "1abbf1307c119484d519eb09c28d37efd568a171", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -62,7 +62,7 @@ pub struct PState<'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n     pos: uint,\n-    tcx: ty::ctxt\n+    tcx: &'a ty::ctxt\n }\n \n fn peek(st: &PState) -> char {\n@@ -105,7 +105,7 @@ fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n }\n \n pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n-                             pos: uint, tcx: ty::ctxt) -> PState<'a> {\n+                             pos: uint, tcx: &'a ty::ctxt) -> PState<'a> {\n     PState {\n         data: data,\n         krate: crate_num,\n@@ -114,25 +114,25 @@ pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n     }\n }\n \n-pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n+pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                      conv: conv_did) -> ty::t {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(&mut st, conv)\n }\n \n-pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n+pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                              conv: conv_did) -> ty::BareFnTy {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bare_fn_ty(&mut st, conv)\n }\n \n-pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n+pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                             conv: conv_did) -> ty::TraitRef {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_trait_ref(&mut st, conv)\n }\n \n-pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n+pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                          conv: conv_did) -> ty::substs {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_substs(&mut st, conv)\n@@ -565,7 +565,7 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n }\n \n pub fn parse_type_param_def_data(data: &[u8], start: uint,\n-                                 crate_num: ast::CrateNum, tcx: ty::ctxt,\n+                                 crate_num: ast::CrateNum, tcx: &ty::ctxt,\n                                  conv: conv_did) -> ty::TypeParameterDef\n {\n     let mut st = parse_state_from_data(data, crate_num, start, tcx);"}, {"sha": "ab792de4d5e9d49c620359437d5b1cce59c8a54c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -35,12 +35,12 @@ macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n     format_args!(|a| { mywrite($wr, a) }, $($arg)*)\n ) )\n \n-pub struct ctxt {\n+pub struct ctxt<'a> {\n     diag: @SpanHandler,\n     // Def -> str Callback:\n     ds: extern \"Rust\" fn(DefId) -> ~str,\n     // The type context.\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     abbrevs: abbrev_ctxt\n }\n "}, {"sha": "bd5e79a3a1f3d8c1598690d559f64639b45300f8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -56,14 +56,14 @@ pub struct Maps {\n     capture_map: middle::moves::CaptureMap,\n }\n \n-struct DecodeContext {\n+struct DecodeContext<'a> {\n     cdata: @cstore::crate_metadata,\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     maps: Maps\n }\n \n-struct ExtendedDecodeContext {\n-    dcx: @DecodeContext,\n+struct ExtendedDecodeContext<'a> {\n+    dcx: @DecodeContext<'a>,\n     from_id_range: ast_util::IdRange,\n     to_id_range: ast_util::IdRange\n }\n@@ -114,7 +114,7 @@ pub fn encode_exported_macro(ebml_w: &mut writer::Encoder, i: &ast::Item) {\n }\n \n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n-                           tcx: ty::ctxt,\n+                           tcx: &ty::ctxt,\n                            maps: Maps,\n                            path: Vec<ast_map::PathElem> ,\n                            par_doc: ebml::Doc)\n@@ -188,7 +188,7 @@ fn reserve_id_range(sess: &Session,\n     ast_util::IdRange { min: to_id_min, max: to_id_max }\n }\n \n-impl ExtendedDecodeContext {\n+impl<'a> ExtendedDecodeContext<'a> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         /*!\n          * Translates an internal id, meaning a node id that is known\n@@ -375,11 +375,11 @@ fn decode_ast(par_doc: ebml::Doc) -> ast::InlinedItem {\n     Decodable::decode(&mut d)\n }\n \n-struct AstRenumberer {\n-    xcx: @ExtendedDecodeContext,\n+struct AstRenumberer<'a> {\n+    xcx: @ExtendedDecodeContext<'a>,\n }\n \n-impl ast_map::FoldOps for AstRenumberer {\n+impl<'a> ast_map::FoldOps for AstRenumberer<'a> {\n     fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n         if id == ast::DUMMY_NODE_ID {\n             // Used by ast_map to map the NodeInlinedParent.\n@@ -702,19 +702,19 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n \n pub trait vtable_decoder_helpers {\n     fn read_vtable_res(&mut self,\n-                       tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res;\n     fn read_vtable_param_res(&mut self,\n-                       tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_param_res;\n     fn read_vtable_origin(&mut self,\n-                          tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                          tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                           -> typeck::vtable_origin;\n }\n \n impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     fn read_vtable_res(&mut self,\n-                       tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res {\n         @self.read_to_vec(|this|\n                           this.read_vtable_param_res(tcx, cdata))\n@@ -723,7 +723,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_param_res(&mut self,\n-                             tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                             tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n         @self.read_to_vec(|this|\n                           this.read_vtable_origin(tcx, cdata))\n@@ -732,7 +732,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_origin(&mut self,\n-                          tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                          tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n         -> typeck::vtable_origin {\n         self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant([\"vtable_static\",\n@@ -775,11 +775,11 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n // Encoding and decoding the side tables\n \n trait get_ty_str_ctxt {\n-    fn ty_str_ctxt(&self) -> @tyencode::ctxt;\n+    fn ty_str_ctxt<'a>(&'a self) -> @tyencode::ctxt<'a>;\n }\n \n impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n-    fn ty_str_ctxt(&self) -> @tyencode::ctxt {\n+    fn ty_str_ctxt<'a>(&'a self) -> @tyencode::ctxt<'a> {\n         @tyencode::ctxt {\n             diag: self.tcx.sess.diagnostic(),\n             ds: e::def_to_str,\n@@ -1122,15 +1122,15 @@ trait ebml_decoder_decoder_helpers {\n     // Versions of the type reading functions that don't need the full\n     // ExtendedDecodeContext.\n     fn read_ty_noxcx(&mut self,\n-                     tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t;\n+                     tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t;\n     fn read_tys_noxcx(&mut self,\n-                      tcx: ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> Vec<ty::t> ;\n+                      tcx: &ty::ctxt,\n+                      cdata: @cstore::crate_metadata) -> Vec<ty::t>;\n }\n \n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_noxcx(&mut self,\n-                     tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n+                     tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n         self.read_opaque(|_, doc| {\n             tydecode::parse_ty_data(\n                 doc.data,\n@@ -1142,7 +1142,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_tys_noxcx(&mut self,\n-                      tcx: ty::ctxt,\n+                      tcx: &ty::ctxt,\n                       cdata: @cstore::crate_metadata) -> Vec<ty::t> {\n         self.read_to_vec(|this| this.read_ty_noxcx(tcx, cdata) )\n             .move_iter()"}, {"sha": "fb212c01f5999a298ed781bda59456e78b20b5be", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -32,9 +32,9 @@ use syntax::visit;\n use util::ppaux::Repr;\n \n struct CheckLoanCtxt<'a> {\n-    bccx: &'a BorrowckCtxt,\n-    dfcx_loans: &'a LoanDataFlow,\n-    move_data: move_data::FlowedMoveData,\n+    bccx: &'a BorrowckCtxt<'a>,\n+    dfcx_loans: &'a LoanDataFlow<'a>,\n+    move_data: move_data::FlowedMoveData<'a>,\n     all_loans: &'a [Loan],\n }\n \n@@ -87,7 +87,7 @@ enum MoveError {\n }\n \n impl<'a> CheckLoanCtxt<'a> {\n-    pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+    pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n \n     pub fn each_issued_loan(&self, scope_id: ast::NodeId, op: |&Loan| -> bool)\n                             -> bool {"}, {"sha": "c16483f94c2675011f25c4e4660df3620d02a564", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -48,7 +48,7 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n // Private\n \n struct GuaranteeLifetimeContext<'a> {\n-    bccx: &'a BorrowckCtxt,\n+    bccx: &'a BorrowckCtxt<'a>,\n \n     // the node id of the function body for the enclosing item\n     item_scope_id: ast::NodeId,\n@@ -65,7 +65,7 @@ struct GuaranteeLifetimeContext<'a> {\n }\n \n impl<'a> GuaranteeLifetimeContext<'a> {\n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx(&self) -> &'a ty::ctxt {\n         self.bccx.tcx\n     }\n "}, {"sha": "914634d88b2f710e3b562af245f270caea82178f", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -69,7 +69,7 @@ mod gather_moves;\n /// body of the while loop and we will refuse to root the pointer `&*x`\n /// because it would have to be rooted for a region greater than `root_ub`.\n struct GatherLoanCtxt<'a> {\n-    bccx: &'a BorrowckCtxt,\n+    bccx: &'a BorrowckCtxt<'a>,\n     id_range: IdRange,\n     move_data: move_data::MoveData,\n     all_loans: @RefCell<Vec<Loan> >,\n@@ -315,7 +315,7 @@ fn with_assignee_loan_path(bccx: &BorrowckCtxt, expr: &ast::Expr, op: |@LoanPath\n }\n \n impl<'a> GatherLoanCtxt<'a> {\n-    pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+    pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n \n     pub fn push_repeating_id(&mut self, id: ast::NodeId) {\n         self.repeating_ids.push(id);"}, {"sha": "228e02fa0ac78f9d97370c41e817c76a3059d68e", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -46,7 +46,7 @@ pub fn compute_restrictions(bccx: &BorrowckCtxt,\n // Private\n \n struct RestrictionsContext<'a> {\n-    bccx: &'a BorrowckCtxt,\n+    bccx: &'a BorrowckCtxt<'a>,\n     span: Span,\n     cmt_original: mc::cmt,\n     loan_region: ty::Region,"}, {"sha": "e34a7ff94db6b03c6b217482c0226ecfa77491fd", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -61,16 +61,16 @@ impl Clone for LoanDataFlowOperator {\n     }\n }\n \n-pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n+pub type LoanDataFlow<'a> = DataFlowContext<'a, LoanDataFlowOperator>;\n \n-impl Visitor<()> for BorrowckCtxt {\n+impl<'a> Visitor<()> for BorrowckCtxt<'a> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         borrowck_fn(self, fk, fd, b, s, n);\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    moves_map: moves::MovesMap,\n                    moved_variables_set: moves::MovedVariablesSet,\n@@ -155,8 +155,8 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n // ----------------------------------------------------------------------\n // Type definitions\n \n-pub struct BorrowckCtxt {\n-    tcx: ty::ctxt,\n+pub struct BorrowckCtxt<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n     moves_map: moves::MovesMap,\n     moved_variables_set: moves::MovedVariablesSet,\n@@ -335,7 +335,7 @@ impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n }\n \n impl Repr for RestrictionSet {\n-    fn repr(&self, _tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ty::ctxt) -> ~str {\n         format!(\"RestrictionSet(0x{:x})\", self.bits as uint)\n     }\n }\n@@ -405,7 +405,7 @@ pub enum MovedValueUseKind {\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n-impl BorrowckCtxt {\n+impl<'a> BorrowckCtxt<'a> {\n     pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n                            -> bool {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n@@ -421,7 +421,7 @@ impl BorrowckCtxt {\n         moves_map.get().contains(&id)\n     }\n \n-    pub fn mc(&self) -> mc::MemCategorizationContext<TcxTyper> {\n+    pub fn mc(&self) -> mc::MemCategorizationContext<TcxTyper<'a>> {\n         mc::MemCategorizationContext {\n             typer: TcxTyper {\n                 tcx: self.tcx,\n@@ -601,7 +601,7 @@ impl BorrowckCtxt {\n             }\n         }\n \n-        fn move_suggestion(tcx: ty::ctxt, ty: ty::t, default_msg: &'static str)\n+        fn move_suggestion(tcx: &ty::ctxt, ty: ty::t, default_msg: &'static str)\n                           -> &'static str {\n             match ty::get(ty).sty {\n                 ty::ty_closure(ref cty) if cty.sigil == ast::BorrowedSigil =>\n@@ -871,7 +871,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n }\n \n impl Repr for Loan {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n              self.index,\n              self.loan_path.repr(tcx),\n@@ -883,15 +883,15 @@ impl Repr for Loan {\n }\n \n impl Repr for Restriction {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"Restriction({}, {:x})\",\n              self.loan_path.repr(tcx),\n              self.set.bits as uint)\n     }\n }\n \n impl Repr for LoanPath {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match self {\n             &LpVar(id) => {\n                 format!(\"$({})\", tcx.map.node_to_str(id))\n@@ -910,21 +910,21 @@ impl Repr for LoanPath {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub struct TcxTyper {\n-    tcx: ty::ctxt,\n+pub struct TcxTyper<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n }\n \n-impl mc::Typer for TcxTyper {\n-    fn tcx(&self) -> ty::ctxt {\n+impl<'a> mc::Typer for TcxTyper<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.tcx\n     }\n \n     fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n         Ok(ty::node_id_to_type(self.tcx, id))\n     }\n \n-    fn node_method_ty(&mut self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n         self.method_map.borrow().get().find(&method_call).map(|method| method.ty)\n     }\n "}, {"sha": "66e92583edb68fe2347643c4c3aaf171ea26a4a0", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -55,15 +55,15 @@ pub struct MoveData {\n     assignee_ids: RefCell<HashSet<ast::NodeId>>,\n }\n \n-pub struct FlowedMoveData {\n+pub struct FlowedMoveData<'a> {\n     move_data: MoveData,\n \n-    dfcx_moves: MoveDataFlow,\n+    dfcx_moves: MoveDataFlow<'a>,\n \n     // We could (and maybe should, for efficiency) combine both move\n     // and assign data flow into one, but this way it's easier to\n     // distinguish the bits that correspond to moves and assignments.\n-    dfcx_assign: AssignDataFlow\n+    dfcx_assign: AssignDataFlow<'a>\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n@@ -159,7 +159,7 @@ impl Clone for MoveDataFlowOperator {\n     }\n }\n \n-pub type MoveDataFlow = DataFlowContext<MoveDataFlowOperator>;\n+pub type MoveDataFlow<'a> = DataFlowContext<'a, MoveDataFlowOperator>;\n \n pub struct AssignDataFlowOperator;\n \n@@ -171,7 +171,7 @@ impl Clone for AssignDataFlowOperator {\n     }\n }\n \n-pub type AssignDataFlow = DataFlowContext<AssignDataFlowOperator>;\n+pub type AssignDataFlow<'a> = DataFlowContext<'a, AssignDataFlowOperator>;\n \n impl MoveData {\n     pub fn new() -> MoveData {\n@@ -236,7 +236,7 @@ impl MoveData {\n     }\n \n     pub fn move_path(&self,\n-                     tcx: ty::ctxt,\n+                     tcx: &ty::ctxt,\n                      lp: @LoanPath) -> MovePathIndex {\n         /*!\n          * Returns the existing move path index for `lp`, if any,\n@@ -355,7 +355,7 @@ impl MoveData {\n     }\n \n     pub fn add_move(&self,\n-                    tcx: ty::ctxt,\n+                    tcx: &ty::ctxt,\n                     lp: @LoanPath,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n@@ -390,7 +390,7 @@ impl MoveData {\n     }\n \n     pub fn add_assignment(&self,\n-                          tcx: ty::ctxt,\n+                          tcx: &ty::ctxt,\n                           lp: @LoanPath,\n                           assign_id: ast::NodeId,\n                           span: Span,\n@@ -435,7 +435,7 @@ impl MoveData {\n     }\n \n     fn add_gen_kills(&self,\n-                     tcx: ty::ctxt,\n+                     tcx: &ty::ctxt,\n                      dfcx_moves: &mut MoveDataFlow,\n                      dfcx_assign: &mut AssignDataFlow) {\n         /*!\n@@ -566,13 +566,13 @@ impl MoveData {\n     }\n }\n \n-impl FlowedMoveData {\n+impl<'a> FlowedMoveData<'a> {\n     pub fn new(move_data: MoveData,\n-               tcx: ty::ctxt,\n+               tcx: &'a ty::ctxt,\n                method_map: typeck::MethodMap,\n                id_range: ast_util::IdRange,\n                body: &ast::Block)\n-               -> FlowedMoveData {\n+               -> FlowedMoveData<'a> {\n         let mut dfcx_moves = {\n             let moves = move_data.moves.borrow();\n             DataFlowContext::new(tcx,"}, {"sha": "1c3f62df73f56314af7f66287738b326b57abc8c", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -18,8 +18,8 @@ use syntax::ast_util;\n use syntax::opt_vec;\n use util::nodemap::NodeMap;\n \n-struct CFGBuilder {\n-    tcx: ty::ctxt,\n+struct CFGBuilder<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n     exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n@@ -32,7 +32,7 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break\n }\n \n-pub fn construct(tcx: ty::ctxt,\n+pub fn construct(tcx: &ty::ctxt,\n                  method_map: typeck::MethodMap,\n                  blk: &ast::Block) -> CFG {\n     let mut cfg_builder = CFGBuilder {\n@@ -51,7 +51,7 @@ pub fn construct(tcx: ty::ctxt,\n          exit: exit}\n }\n \n-impl CFGBuilder {\n+impl<'a> CFGBuilder<'a> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n         for &stmt in blk.stmts.iter() {"}, {"sha": "5b4a5f89ea9288b8ff8799f424753fb919252dfa", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -53,7 +53,7 @@ pub struct CFGIndices {\n }\n \n impl CFG {\n-    pub fn new(tcx: ty::ctxt,\n+    pub fn new(tcx: &ty::ctxt,\n                method_map: typeck::MethodMap,\n                blk: &ast::Block) -> CFG {\n         construct::construct(tcx, method_map, blk)"}, {"sha": "53a53a66335577f9fc243af6c006d49f9d8c4da6", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -21,13 +21,13 @@ use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-pub struct CheckCrateVisitor {\n+pub struct CheckCrateVisitor<'a> {\n     def_map: resolve::DefMap,\n     method_map: typeck::MethodMap,\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n }\n \n-impl Visitor<bool> for CheckCrateVisitor {\n+impl<'a> Visitor<bool> for CheckCrateVisitor<'a> {\n     fn visit_item(&mut self, i: &Item, env: bool) {\n         check_item(self, i, env);\n     }\n@@ -42,7 +42,7 @@ impl Visitor<bool> for CheckCrateVisitor {\n pub fn check_crate(krate: &Crate,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::MethodMap,\n-                   tcx: ty::ctxt) {\n+                   tcx: &ty::ctxt) {\n     let mut v = CheckCrateVisitor {\n         def_map: def_map,\n         method_map: method_map,"}, {"sha": "4b99ce2850539fd0c489c103ae53920dfcc2ad1a", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -20,15 +20,15 @@ enum Context {\n     Normal, Loop, Closure\n }\n \n-struct CheckLoopVisitor {\n-    tcx: ty::ctxt,\n+struct CheckLoopVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n }\n \n-pub fn check_crate(tcx: ty::ctxt, krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n     visit::walk_crate(&mut CheckLoopVisitor { tcx: tcx }, krate, Normal)\n }\n \n-impl Visitor<Context> for CheckLoopVisitor {\n+impl<'a> Visitor<Context> for CheckLoopVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _cx: Context) {\n         visit::walk_item(self, i, Normal);\n     }\n@@ -52,7 +52,7 @@ impl Visitor<Context> for CheckLoopVisitor {\n     }\n }\n \n-impl CheckLoopVisitor {\n+impl<'a> CheckLoopVisitor<'a> {\n     fn require_loop(&self, name: &str, cx: Context, span: Span) {\n         match cx {\n             Loop => {}"}, {"sha": "9e74f440a7f575fd2f621a00c6df665836e1376c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -30,47 +30,41 @@ use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n \n-struct MatchCheckCtxt {\n-    tcx: ty::ctxt,\n+struct MatchCheckCtxt<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: MethodMap,\n     moves_map: moves::MovesMap\n }\n \n-struct CheckMatchVisitor {\n-    cx: @MatchCheckCtxt\n-}\n-\n-impl Visitor<()> for CheckMatchVisitor {\n+impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n-        check_expr(self, self.cx, ex, ());\n+        check_expr(self, ex);\n     }\n     fn visit_local(&mut self, l: &Local, _: ()) {\n-        check_local(self, self.cx, l, ());\n+        check_local(self, l);\n     }\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n-        check_fn(self, self.cx, fk, fd, b, s, n, ());\n+        check_fn(self, fk, fd, b, s, n);\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: MethodMap,\n                    moves_map: moves::MovesMap,\n                    krate: &Crate) {\n-    let cx = @MatchCheckCtxt {tcx: tcx,\n-                              method_map: method_map,\n-                              moves_map: moves_map};\n-    let mut v = CheckMatchVisitor { cx: cx };\n+    let mut cx = MatchCheckCtxt {\n+        tcx: tcx,\n+        method_map: method_map,\n+        moves_map: moves_map\n+    };\n \n-    visit::walk_crate(&mut v, krate, ());\n+    visit::walk_crate(&mut cx, krate, ());\n \n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(v: &mut CheckMatchVisitor,\n-                  cx: @MatchCheckCtxt,\n-                  ex: &Expr,\n-                  s: ()) {\n-    visit::walk_expr(v, ex, s);\n+fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n+    visit::walk_expr(cx, ex, ());\n     match ex.node {\n       ExprMatch(scrut, ref arms) => {\n         // First, check legality of move bindings.\n@@ -871,11 +865,8 @@ fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<Vec<@Pat> > {\n     }\n }\n \n-fn check_local(v: &mut CheckMatchVisitor,\n-                   cx: &MatchCheckCtxt,\n-                   loc: &Local,\n-                   s: ()) {\n-    visit::walk_local(v, loc, s);\n+fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n+    visit::walk_local(cx, loc, ());\n     if is_refutable(cx, loc.pat) {\n         cx.tcx.sess.span_err(loc.pat.span,\n                              \"refutable pattern in local binding\");\n@@ -885,15 +876,13 @@ fn check_local(v: &mut CheckMatchVisitor,\n     check_legality_of_move_bindings(cx, false, [ loc.pat ]);\n }\n \n-fn check_fn(v: &mut CheckMatchVisitor,\n-                cx: &MatchCheckCtxt,\n-                kind: &FnKind,\n-                decl: &FnDecl,\n-                body: &Block,\n-                sp: Span,\n-                id: NodeId,\n-                s: ()) {\n-    visit::walk_fn(v, kind, decl, body, sp, id, s);\n+fn check_fn(cx: &mut MatchCheckCtxt,\n+            kind: &FnKind,\n+            decl: &FnDecl,\n+            body: &Block,\n+            sp: Span,\n+            id: NodeId) {\n+    visit::walk_fn(cx, kind, decl, body, sp, id, ());\n     for input in decl.inputs.iter() {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,"}, {"sha": "e80c60ad015d834231628b35d5ea1c85456d9526", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -30,7 +30,7 @@ use syntax::visit;\n use syntax::print::pprust;\n \n \n-fn safe_type_for_static_mut(cx: ty::ctxt, e: &ast::Expr) -> Option<~str> {\n+fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<~str> {\n     let node_ty = ty::node_id_to_type(cx, e.id);\n     let tcontents = ty::type_contents(cx, node_ty);\n     debug!(\"safe_type_for_static_mut(dtor={}, managed={}, owned={})\",\n@@ -49,16 +49,15 @@ fn safe_type_for_static_mut(cx: ty::ctxt, e: &ast::Expr) -> Option<~str> {\n     Some(format!(\"mutable static items are not allowed to have {}\", suffix))\n }\n \n-struct CheckStaticVisitor {\n-    tcx: ty::ctxt,\n+struct CheckStaticVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n }\n \n-pub fn check_crate(tcx: ty::ctxt, krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n     visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx }, krate, false)\n }\n \n-impl CheckStaticVisitor {\n-\n+impl<'a> CheckStaticVisitor<'a> {\n     fn report_error(&self, span: Span, result: Option<~str>) -> bool {\n         match result {\n             None => { false }\n@@ -70,7 +69,7 @@ impl CheckStaticVisitor {\n     }\n }\n \n-impl Visitor<bool> for CheckStaticVisitor {\n+impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n \n     fn visit_item(&mut self, i: &ast::Item, _is_const: bool) {\n         debug!(\"visit_item(item={})\", pprust::item_to_str(i));"}, {"sha": "01c780de4a0a4740e8e28c23910f73ba1653f157", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -84,7 +84,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n     cs.fold(integral_const, |a, b| join(a, b))\n }\n \n-pub fn lookup_const(tcx: ty::ctxt, e: &Expr) -> Option<@Expr> {\n+pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<@Expr> {\n     let opt_def = {\n         let def_map = tcx.def_map.borrow();\n         def_map.get().find_copy(&e.id)\n@@ -100,7 +100,7 @@ pub fn lookup_const(tcx: ty::ctxt, e: &Expr) -> Option<@Expr> {\n     }\n }\n \n-pub fn lookup_variant_by_id(tcx: ty::ctxt,\n+pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n                             enum_def: ast::DefId,\n                             variant_def: ast::DefId)\n                        -> Option<@Expr> {\n@@ -161,7 +161,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n     }\n }\n \n-pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n+pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n                           -> Option<@Expr> {\n     if ast_util::is_local(def_id) {\n         {\n@@ -207,12 +207,12 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n     }\n }\n \n-struct ConstEvalVisitor {\n-    tcx: ty::ctxt,\n+struct ConstEvalVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n     ccache: constness_cache,\n }\n \n-impl ConstEvalVisitor {\n+impl<'a> ConstEvalVisitor<'a> {\n     fn classify(&mut self, e: &Expr) -> constness {\n         let did = ast_util::local_def(e.id);\n         match self.ccache.find(&did) {\n@@ -297,14 +297,14 @@ impl ConstEvalVisitor {\n \n }\n \n-impl Visitor<()> for ConstEvalVisitor {\n+impl<'a> Visitor<()> for ConstEvalVisitor<'a> {\n     fn visit_expr_post(&mut self, e: &Expr, _: ()) {\n         self.classify(e);\n     }\n }\n \n pub fn process_crate(krate: &ast::Crate,\n-                     tcx: ty::ctxt) {\n+                     tcx: &ty::ctxt) {\n     let mut v = ConstEvalVisitor {\n         tcx: tcx,\n         ccache: DefIdMap::new(),\n@@ -326,8 +326,8 @@ pub enum const_val {\n     const_bool(bool)\n }\n \n-pub fn eval_const_expr(tcx: middle::ty::ctxt, e: &Expr) -> const_val {\n-    match eval_const_expr_partial(&tcx, e) {\n+pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n+    match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(e.span, s)\n     }\n@@ -496,7 +496,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n       }\n       ExprPath(_) => {\n           match lookup_const(tcx.ty_ctxt(), e) {\n-              Some(actual_e) => eval_const_expr_partial(&tcx.ty_ctxt(), actual_e),\n+              Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), actual_e),\n               None => Err(~\"non-constant path in constant expr\")\n           }\n       }\n@@ -540,11 +540,11 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n     }\n }\n \n-pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: &Expr, b: &Expr) -> Option<int> {\n+pub fn compare_lit_exprs(tcx: &ty::ctxt, a: &Expr, b: &Expr) -> Option<int> {\n     compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n \n-pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: &Expr, b: &Expr) -> Option<bool> {\n+pub fn lit_expr_eq(tcx: &ty::ctxt, a: &Expr, b: &Expr) -> Option<bool> {\n     compare_lit_exprs(tcx, a, b).map(|val| val == 0)\n }\n "}, {"sha": "1f73373648fa1ac9493d75fbc9d6c823c36cd35c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -31,8 +31,8 @@ use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n #[deriving(Clone)]\n-pub struct DataFlowContext<O> {\n-    priv tcx: ty::ctxt,\n+pub struct DataFlowContext<'a, O> {\n+    priv tcx: &'a ty::ctxt,\n     priv method_map: typeck::MethodMap,\n \n     /// the data flow operator\n@@ -73,8 +73,8 @@ pub trait DataFlowOperator {\n     fn join(&self, succ: uint, pred: uint) -> uint;\n }\n \n-struct PropagationContext<'a, O> {\n-    dfcx: &'a mut DataFlowContext<O>,\n+struct PropagationContext<'a, 'b, O> {\n+    dfcx: &'a mut DataFlowContext<'b, O>,\n     changed: bool\n }\n \n@@ -83,7 +83,7 @@ struct LoopScope<'a> {\n     break_bits: Vec<uint>\n }\n \n-impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n+impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n     fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n         let (ps, id) = match node {\n             pprust::NodeExpr(ps, expr) => (ps, expr.id),\n@@ -120,12 +120,12 @@ impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n     }\n }\n \n-impl<O:DataFlowOperator> DataFlowContext<O> {\n-    pub fn new(tcx: ty::ctxt,\n+impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n+    pub fn new(tcx: &'a ty::ctxt,\n                method_map: typeck::MethodMap,\n                oper: O,\n                id_range: IdRange,\n-               bits_per_id: uint) -> DataFlowContext<O> {\n+               bits_per_id: uint) -> DataFlowContext<'a, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n \n         debug!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n@@ -315,8 +315,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     }\n }\n \n-impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n-//                      ^^^^^^^^^^^^^ only needed for pretty printing\n+impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n+//                          ^^^^^^^^^^^^^ only needed for pretty printing\n     pub fn propagate(&mut self, blk: &ast::Block) {\n         //! Performs the data flow analysis.\n \n@@ -327,7 +327,7 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n \n         {\n             let mut propcx = PropagationContext {\n-                dfcx: self,\n+                dfcx: &mut *self,\n                 changed: true\n             };\n \n@@ -359,8 +359,8 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n     }\n }\n \n-impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n-    fn tcx(&self) -> ty::ctxt {\n+impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n+    fn tcx(&self) -> &'b ty::ctxt {\n         self.dfcx.tcx\n     }\n "}, {"sha": "03d51f06ab57430f89220bdb9ce4df6b69a2a6f0", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -35,7 +35,7 @@ pub static DEAD_CODE_LINT_STR: &'static str = \"dead_code\";\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n+fn should_explore(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n     if !is_local(def_id) {\n         return false;\n     }\n@@ -49,17 +49,17 @@ fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n     }\n }\n \n-struct MarkSymbolVisitor {\n-    worklist: Vec<ast::NodeId> ,\n+struct MarkSymbolVisitor<'a> {\n+    worklist: Vec<ast::NodeId>,\n     method_map: typeck::MethodMap,\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     live_symbols: ~HashSet<ast::NodeId>,\n }\n \n-impl MarkSymbolVisitor {\n-    fn new(tcx: ty::ctxt,\n+impl<'a> MarkSymbolVisitor<'a> {\n+    fn new(tcx: &'a ty::ctxt,\n            method_map: typeck::MethodMap,\n-           worklist: Vec<ast::NodeId> ) -> MarkSymbolVisitor {\n+           worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             method_map: method_map,\n@@ -175,7 +175,7 @@ impl MarkSymbolVisitor {\n     }\n }\n \n-impl Visitor<()> for MarkSymbolVisitor {\n+impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n@@ -253,7 +253,7 @@ impl Visitor<()> for LifeSeeder {\n     }\n }\n \n-fn create_and_seed_worklist(tcx: ty::ctxt,\n+fn create_and_seed_worklist(tcx: &ty::ctxt,\n                             exported_items: &privacy::ExportedItems,\n                             reachable_symbols: &NodeSet,\n                             krate: &ast::Crate) -> Vec<ast::NodeId> {\n@@ -286,7 +286,7 @@ fn create_and_seed_worklist(tcx: ty::ctxt,\n     return life_seeder.worklist;\n }\n \n-fn find_live(tcx: ty::ctxt,\n+fn find_live(tcx: &ty::ctxt,\n              method_map: typeck::MethodMap,\n              exported_items: &privacy::ExportedItems,\n              reachable_symbols: &NodeSet,\n@@ -316,12 +316,12 @@ fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n     }\n }\n \n-struct DeadVisitor {\n-    tcx: ty::ctxt,\n+struct DeadVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n     live_symbols: ~HashSet<ast::NodeId>,\n }\n \n-impl DeadVisitor {\n+impl<'a> DeadVisitor<'a> {\n     // id := node id of an item's definition.\n     // ctor_id := `Some` if the item is a struct_ctor (tuple struct),\n     //            `None` otherwise.\n@@ -368,7 +368,7 @@ impl DeadVisitor {\n     }\n }\n \n-impl Visitor<()> for DeadVisitor {\n+impl<'a> Visitor<()> for DeadVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let ctor_id = get_struct_ctor_id(item);\n         if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {\n@@ -409,7 +409,7 @@ impl Visitor<()> for DeadVisitor {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    exported_items: &privacy::ExportedItems,\n                    reachable_symbols: &NodeSet,"}, {"sha": "592c4f7e29e423debd8f2b6146697674b40dfd01", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -35,16 +35,16 @@ fn type_is_unsafe_function(ty: ty::t) -> bool {\n     }\n }\n \n-struct EffectCheckVisitor {\n-    tcx: ty::ctxt,\n+struct EffectCheckVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n \n     /// The method map.\n     method_map: MethodMap,\n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n }\n \n-impl EffectCheckVisitor {\n+impl<'a> EffectCheckVisitor<'a> {\n     fn require_unsafe(&mut self, span: Span, description: &str) {\n         match self.unsafe_context {\n             SafeContext => {\n@@ -80,7 +80,7 @@ impl EffectCheckVisitor {\n     }\n }\n \n-impl Visitor<()> for EffectCheckVisitor {\n+impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n     fn visit_fn(&mut self, fn_kind: &visit::FnKind, fn_decl: &ast::FnDecl,\n                 block: &ast::Block, span: Span, node_id: ast::NodeId, _:()) {\n \n@@ -191,7 +191,7 @@ impl Visitor<()> for EffectCheckVisitor {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt, method_map: MethodMap, krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt, method_map: MethodMap, krate: &ast::Crate) {\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n         method_map: method_map,"}, {"sha": "1ccc5e51487a2e93425d92f0b86696065d5b6b62", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -141,14 +141,14 @@ pub fn annotate_freevars(def_map: resolve::DefMap, krate: &ast::Crate) ->\n     freevars\n }\n \n-pub fn get_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> freevar_info {\n+pub fn get_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> freevar_info {\n     let freevars = tcx.freevars.borrow();\n     match freevars.get().find(&fid) {\n         None => fail!(\"get_freevars: {} has no freevars\", fid),\n         Some(&d) => return d\n     }\n }\n \n-pub fn has_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> bool {\n+pub fn has_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> bool {\n     !get_freevars(tcx, fid).is_empty()\n }"}, {"sha": "cc1fdc7699169fd20ebd7a49144bf72363755ec1", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -52,12 +52,12 @@ use syntax::visit::Visitor;\n // types.\n \n #[deriving(Clone)]\n-pub struct Context {\n-    tcx: ty::ctxt,\n+pub struct Context<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n }\n \n-impl Visitor<()> for Context {\n+impl<'a> Visitor<()> for Context<'a> {\n \n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n@@ -76,7 +76,7 @@ impl Visitor<()> for Context {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    krate: &Crate) {\n     let mut ctx = Context {\n@@ -324,7 +324,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n             check_trait_cast(cx, source_ty, target_ty, source.span);\n         }\n         ExprRepeat(element, count_expr, _) => {\n-            let count = ty::eval_repeat_count(&cx.tcx, count_expr);\n+            let count = ty::eval_repeat_count(cx.tcx, count_expr);\n             if count > 1 {\n                 let element_ty = ty::expr_ty(cx.tcx, element);\n                 check_copy(cx, element_ty, element.span,\n@@ -476,7 +476,7 @@ pub fn check_send(cx: &Context, ty: ty::t, sp: Span) -> bool {\n     }\n }\n \n-pub fn check_static(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n+pub fn check_static(tcx: &ty::ctxt, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_static(tcx, ty) {\n         match ty::get(ty).sty {\n           ty::ty_param(..) => {"}, {"sha": "88ba1b990c1656cef38c2ecfddd3059989ec493a", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -427,7 +427,7 @@ struct Context<'a> {\n     // Current levels of each lint warning\n     cur: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     // maps from an expression id that corresponds to a method call to the\n     // details of the method to be invoked\n     method_map: typeck::MethodMap,\n@@ -670,7 +670,7 @@ fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n     }\n }\n impl<'a> AstConv for Context<'a>{\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         ty::lookup_item_type(self.tcx, id)\n@@ -795,7 +795,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n         }\n     }\n \n-    fn check_limits(tcx: ty::ctxt, binop: ast::BinOp,\n+    fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n                     l: &ast::Expr, r: &ast::Expr) -> bool {\n         let (lit, expr, swap) = match (&l.node, &r.node) {\n             (&ast::ExprLit(_), _) => (l, r, true),\n@@ -1749,7 +1749,7 @@ impl<'a> IdVisitingOperation for Context<'a> {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    exported_items: &privacy::ExportedItems,\n                    krate: &ast::Crate) {"}, {"sha": "b0fe9e8c91df9ac537ca8e80a99e964f22041ec3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -152,7 +152,7 @@ pub enum LiveNodeKind {\n     ExitNode\n }\n \n-fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n+fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> ~str {\n     let cm = cx.sess.codemap;\n     match lnk {\n         FreeVarNode(s) => format!(\"Free var node [{}]\", cm.span_to_str(s)),\n@@ -164,7 +164,7 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n \n struct LivenessVisitor;\n \n-impl Visitor<@IrMaps> for LivenessVisitor {\n+impl<'a> Visitor<@IrMaps<'a>> for LivenessVisitor {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, e: @IrMaps) {\n         visit_fn(self, fk, fd, b, s, n, e);\n     }\n@@ -173,7 +173,7 @@ impl Visitor<@IrMaps> for LivenessVisitor {\n     fn visit_arm(&mut self, a: &Arm, e: @IrMaps) { visit_arm(self, a, e); }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    capture_map: moves::CaptureMap,\n                    krate: &Crate) {\n@@ -251,8 +251,8 @@ pub enum VarKind {\n     ImplicitRet\n }\n \n-pub struct IrMaps {\n-    tcx: ty::ctxt,\n+pub struct IrMaps<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n     capture_map: moves::CaptureMap,\n \n@@ -265,10 +265,10 @@ pub struct IrMaps {\n     lnks: RefCell<Vec<LiveNodeKind> >,\n }\n \n-fn IrMaps(tcx: ty::ctxt,\n-          method_map: typeck::MethodMap,\n-          capture_map: moves::CaptureMap)\n-       -> IrMaps {\n+fn IrMaps<'a>(tcx: &'a ty::ctxt,\n+              method_map: typeck::MethodMap,\n+              capture_map: moves::CaptureMap)\n+              -> IrMaps<'a> {\n     IrMaps {\n         tcx: tcx,\n         method_map: method_map,\n@@ -283,7 +283,7 @@ fn IrMaps(tcx: ty::ctxt,\n     }\n }\n \n-impl IrMaps {\n+impl<'a> IrMaps<'a> {\n     pub fn add_live_node(&self, lnk: LiveNodeKind) -> LiveNode {\n         let num_live_nodes = self.num_live_nodes.get();\n         let ln = LiveNode(num_live_nodes);\n@@ -368,7 +368,7 @@ impl IrMaps {\n     }\n }\n \n-impl Visitor<()> for Liveness {\n+impl<'a> Visitor<()> for Liveness<'a> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n@@ -586,9 +586,9 @@ static ACC_USE: uint = 4u;\n \n pub type LiveNodeMap = @RefCell<NodeMap<LiveNode>>;\n \n-pub struct Liveness {\n-    tcx: ty::ctxt,\n-    ir: @IrMaps,\n+pub struct Liveness<'a> {\n+    tcx: &'a ty::ctxt,\n+    ir: @IrMaps<'a>,\n     s: Specials,\n     successors: @RefCell<Vec<LiveNode> >,\n     users: @RefCell<Vec<Users> >,\n@@ -602,7 +602,7 @@ pub struct Liveness {\n     cont_ln: LiveNodeMap\n }\n \n-fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n+fn Liveness<'a>(ir: @IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n     Liveness {\n         ir: ir,\n         tcx: ir.tcx,\n@@ -618,7 +618,7 @@ fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n     }\n }\n \n-impl Liveness {\n+impl<'a> Liveness<'a> {\n     pub fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n         let ir: &IrMaps = self.ir;\n         let live_node_map = ir.live_node_map.borrow();\n@@ -1549,7 +1549,7 @@ pub enum ReadKind {\n     PartiallyMovedValue\n }\n \n-impl Liveness {\n+impl<'a> Liveness<'a> {\n     pub fn check_ret(&self,\n                      id: NodeId,\n                      sp: Span,"}, {"sha": "be0aef64351ecba064d4588f4ba9c00ab7dc59b0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -216,7 +216,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     }\n }\n \n-pub fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n+pub fn deref_kind(tcx: &ty::ctxt, t: ty::t) -> deref_kind {\n     match opt_deref_kind(t) {\n       Some(k) => k,\n       None => {\n@@ -267,9 +267,9 @@ pub type McResult<T> = Result<T, ()>;\n  * can be sure that only `Ok` results will occur.\n  */\n pub trait Typer {\n-    fn tcx(&self) -> ty::ctxt;\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n     fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t>;\n-    fn node_method_ty(&mut self, method_call: typeck::MethodCall) -> Option<ty::t>;\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t>;\n     fn adjustment(&mut self, node_id: ast::NodeId) -> Option<@ty::AutoAdjustment>;\n     fn is_method_call(&mut self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&mut self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n@@ -351,7 +351,7 @@ macro_rules! if_ok(\n )\n \n impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.typer.tcx()\n     }\n \n@@ -886,7 +886,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         let cmt_slice = self.cat_index(slice_pat, vec_cmt, 0);\n         return Ok((cmt_slice, slice_mutbl, slice_r));\n \n-        fn vec_slice_info(tcx: ty::ctxt,\n+        fn vec_slice_info(tcx: &ty::ctxt,\n                           pat: @ast::Pat,\n                           slice_ty: ty::t)\n                           -> (ast::Mutability, ty::Region) {\n@@ -996,10 +996,9 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        let tcx = self.tcx();\n         debug!(\"cat_pattern: id={} pat={} cmt={}\",\n                pat.id, pprust::pat_to_str(pat),\n-               cmt.repr(tcx));\n+               cmt.repr(self.tcx()));\n \n         op(self, cmt, pat);\n \n@@ -1187,7 +1186,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n /// The node_id here is the node of the expression that references the field.\n /// This function looks it up in the def map in case the type happens to be\n /// an enum to determine which variant is in use.\n-pub fn field_mutbl(tcx: ty::ctxt,\n+pub fn field_mutbl(tcx: &ty::ctxt,\n                    base_ty: ty::t,\n                    // FIXME #6993: change type to Name\n                    f_name: ast::Ident,\n@@ -1312,7 +1311,7 @@ impl cmt_ {\n }\n \n impl Repr for cmt_ {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"\\\\{{} id:{} m:{:?} ty:{}\\\\}\",\n              self.cat.repr(tcx),\n              self.id,\n@@ -1322,7 +1321,7 @@ impl Repr for cmt_ {\n }\n \n impl Repr for categorization {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             cat_static_item |\n             cat_rvalue(..) |\n@@ -1365,7 +1364,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n }\n \n impl Repr for InteriorKind {\n-    fn repr(&self, _tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ty::ctxt) -> ~str {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n                 token::get_name(fld).get().to_str()"}, {"sha": "461ec4b4121e33b9d880ea4bb98474408c15eb9e", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -181,8 +181,8 @@ pub struct MoveMaps {\n }\n \n #[deriving(Clone)]\n-struct VisitContext {\n-    tcx: ty::ctxt,\n+struct VisitContext<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: MethodMap,\n     move_maps: MoveMaps\n }\n@@ -193,7 +193,7 @@ enum UseMode {\n     Read         // Read no matter what the type.\n }\n \n-impl visit::Visitor<()> for VisitContext {\n+impl<'a> visit::Visitor<()> for VisitContext<'a> {\n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         compute_modes_for_fn(self, fk, fd, b, s, n);\n@@ -208,7 +208,7 @@ impl visit::Visitor<()> for VisitContext {\n     fn visit_ty(&mut self, _t: &Ty, _: ()) {}\n }\n \n-pub fn compute_moves(tcx: ty::ctxt,\n+pub fn compute_moves(tcx: &ty::ctxt,\n                      method_map: MethodMap,\n                      krate: &Crate) -> MoveMaps\n {\n@@ -265,7 +265,7 @@ fn compute_modes_for_expr(cx: &mut VisitContext,\n     cx.consume_expr(expr);\n }\n \n-impl VisitContext {\n+impl<'a> VisitContext<'a> {\n     pub fn consume_exprs(&mut self, exprs: &[@Expr]) {\n         for expr in exprs.iter() {\n             self.consume_expr(*expr);\n@@ -444,7 +444,7 @@ impl VisitContext {\n                             ty::type_moves_by_default(self.tcx, tf.mt.ty)\n                     });\n \n-                    fn has_dtor(tcx: ty::ctxt, ty: ty::t) -> bool {\n+                    fn has_dtor(tcx: &ty::ctxt, ty: ty::t) -> bool {\n                         use middle::ty::{get,ty_struct,ty_enum};\n                         match get(ty).sty {\n                             ty_struct(did, _) | ty_enum(did, _) => ty::has_dtor(tcx, did),"}, {"sha": "1c98f745ab0920a657bc1888904563fb767804d5", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -142,7 +142,7 @@ impl Visitor<()> for ParentVisitor {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct EmbargoVisitor<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     exp_map2: &'a resolve::ExportMap2,\n \n     // This flag is an indicator of whether the previous item in the\n@@ -345,7 +345,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct PrivacyVisitor<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     curitem: ast::NodeId,\n     in_fn: bool,\n     in_foreign: bool,\n@@ -920,12 +920,12 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n /// The privacy sanity check visitor, ensures unnecessary visibility isn't here\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct SanePrivacyVisitor {\n-    tcx: ty::ctxt,\n+struct SanePrivacyVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n     in_fn: bool,\n }\n \n-impl Visitor<()> for SanePrivacyVisitor {\n+impl<'a> Visitor<()> for SanePrivacyVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         if self.in_fn {\n             self.check_all_inherited(item);\n@@ -976,7 +976,7 @@ impl Visitor<()> for SanePrivacyVisitor {\n     }\n }\n \n-impl SanePrivacyVisitor {\n+impl<'a> SanePrivacyVisitor<'a> {\n     /// Validates all of the visibility qualifers placed on the item given. This\n     /// ensures that there are no extraneous qualifiers that don't actually do\n     /// anything. In theory these qualifiers wouldn't parse, but that may happen\n@@ -1159,7 +1159,7 @@ impl SanePrivacyVisitor {\n }\n \n struct VisiblePrivateTypesVisitor<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     exported_items: &'a ExportedItems,\n     public_items: &'a PublicItems,\n }\n@@ -1403,7 +1403,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n     fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: &MethodMap,\n                    exp_map2: &resolve::ExportMap2,\n                    external_exports: resolve::ExternalExports,"}, {"sha": "11beadd40f70c14eb9d2b7de39e5284be3001115", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -59,7 +59,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n     }\n }\n \n-fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::Method,\n+fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n     if attributes_specify_inlining(method.attrs.as_slice()) ||\n         generics_require_inlining(&method.generics) {\n@@ -83,9 +83,9 @@ fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::Method,\n }\n \n // Information needed while computing reachability.\n-struct ReachableContext {\n+struct ReachableContext<'a> {\n     // The type context.\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     // The method map, which links node IDs of method call expressions to the\n     // methods they've been resolved to.\n     method_map: typeck::MethodMap,\n@@ -96,14 +96,14 @@ struct ReachableContext {\n     worklist: @RefCell<Vec<ast::NodeId> >,\n }\n \n-struct MarkSymbolVisitor {\n-    worklist: @RefCell<Vec<ast::NodeId> >,\n+struct MarkSymbolVisitor<'a> {\n+    worklist: @RefCell<Vec<ast::NodeId>>,\n     method_map: typeck::MethodMap,\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     reachable_symbols: @RefCell<NodeSet>,\n }\n \n-impl Visitor<()> for MarkSymbolVisitor {\n+impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n \n@@ -177,9 +177,9 @@ impl Visitor<()> for MarkSymbolVisitor {\n     }\n }\n \n-impl ReachableContext {\n+impl<'a> ReachableContext<'a> {\n     // Creates a new reachability computation context.\n-    fn new(tcx: ty::ctxt, method_map: typeck::MethodMap) -> ReachableContext {\n+    fn new(tcx: &'a ty::ctxt, method_map: typeck::MethodMap) -> ReachableContext<'a> {\n         ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n@@ -190,7 +190,7 @@ impl ReachableContext {\n \n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n-    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: ast::DefId)\n+    fn def_id_represents_local_inlined_item(tcx: &ty::ctxt, def_id: ast::DefId)\n                                             -> bool {\n         if def_id.krate != ast::LOCAL_CRATE {\n             return false\n@@ -233,7 +233,7 @@ impl ReachableContext {\n     }\n \n     // Helper function to set up a visitor for `propagate()` below.\n-    fn init_visitor(&self) -> MarkSymbolVisitor {\n+    fn init_visitor(&self) -> MarkSymbolVisitor<'a> {\n         let (worklist, method_map) = (self.worklist, self.method_map);\n         let (tcx, reachable_symbols) = (self.tcx, self.reachable_symbols);\n \n@@ -387,7 +387,7 @@ impl ReachableContext {\n     }\n }\n \n-pub fn find_reachable(tcx: ty::ctxt,\n+pub fn find_reachable(tcx: &ty::ctxt,\n                       method_map: typeck::MethodMap,\n                       exported_items: &privacy::ExportedItems)\n                       -> @RefCell<NodeSet> {"}, {"sha": "f82b43adc430f9a101b561402e26cffa5a1bc806", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -29,10 +29,10 @@ use syntax::opt_vec::OptVec;\n // information available (for better errors).\n \n pub trait Subst {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Self {\n+    fn subst(&self, tcx: &ty::ctxt, substs: &ty::substs) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Self;\n }\n@@ -46,7 +46,7 @@ pub trait Subst {\n // our current method/trait matching algorithm. - Niko\n \n impl Subst for ty::t {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::t {\n         if ty::substs_is_noop(substs) && !ty::type_has_params(*self) {\n@@ -64,7 +64,7 @@ impl Subst for ty::t {\n }\n \n struct SubstFolder<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     substs: &'a ty::substs,\n \n     // The location for which the substitution is performed, if available.\n@@ -75,7 +75,7 @@ struct SubstFolder<'a> {\n }\n \n impl<'a> TypeFolder for SubstFolder<'a> {\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         r.subst(self.tcx, self.substs)\n@@ -132,30 +132,30 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n // Other types\n \n impl<T:Subst> Subst for Vec<T> {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Vec<T> {\n         self.map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }\n impl<T:Subst> Subst for Rc<T> {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Rc<T> {\n         Rc::new(self.deref().subst_spanned(tcx, substs, span))\n     }\n }\n \n impl<T:Subst> Subst for OptVec<T> {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> OptVec<T> {\n         self.map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }\n \n impl<T:Subst + 'static> Subst for @T {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> @T {\n         match self {\n@@ -165,15 +165,15 @@ impl<T:Subst + 'static> Subst for @T {\n }\n \n impl<T:Subst> Subst for Option<T> {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Option<T> {\n         self.as_ref().map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }\n \n impl Subst for ty::TraitRef {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::TraitRef {\n         ty::TraitRef {\n@@ -184,7 +184,7 @@ impl Subst for ty::TraitRef {\n }\n \n impl Subst for ty::substs {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::substs {\n         ty::substs {\n@@ -196,7 +196,7 @@ impl Subst for ty::substs {\n }\n \n impl Subst for ty::RegionSubsts {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::RegionSubsts {\n         match *self {\n@@ -211,7 +211,7 @@ impl Subst for ty::RegionSubsts {\n }\n \n impl Subst for ty::BareFnTy {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::BareFnTy {\n         let mut folder = SubstFolder {\n@@ -225,7 +225,7 @@ impl Subst for ty::BareFnTy {\n }\n \n impl Subst for ty::ParamBounds {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::ParamBounds {\n         ty::ParamBounds {\n@@ -236,7 +236,7 @@ impl Subst for ty::ParamBounds {\n }\n \n impl Subst for ty::TypeParameterDef {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::TypeParameterDef {\n         ty::TypeParameterDef {\n@@ -249,7 +249,7 @@ impl Subst for ty::TypeParameterDef {\n }\n \n impl Subst for ty::Generics {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::Generics {\n         ty::Generics {\n@@ -260,15 +260,15 @@ impl Subst for ty::Generics {\n }\n \n impl Subst for ty::RegionParameterDef {\n-    fn subst_spanned(&self, _: ty::ctxt,\n+    fn subst_spanned(&self, _: &ty::ctxt,\n                      _: &ty::substs,\n                      _: Option<Span>) -> ty::RegionParameterDef {\n         *self\n     }\n }\n \n impl Subst for ty::Region {\n-    fn subst_spanned(&self, _tcx: ty::ctxt,\n+    fn subst_spanned(&self, _tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      _: Option<Span>) -> ty::Region {\n         // Note: This routine only handles regions that are bound on\n@@ -290,7 +290,7 @@ impl Subst for ty::Region {\n }\n \n impl Subst for ty::ty_param_bounds_and_ty {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::ty_param_bounds_and_ty {\n         ty::ty_param_bounds_and_ty {"}, {"sha": "9a9dc59060e708763981e95174edd5c05dd02bc1", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -257,7 +257,7 @@ enum Opt {\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n \n-fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n+fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (a, b) {\n         (&lit(a), &lit(b)) => {\n             match (a, b) {\n@@ -427,7 +427,7 @@ struct Match<'a,'b> {\n     bound_ptrs: Vec<(Ident, ValueRef)> }\n \n impl<'a,'b> Repr for Match<'a,'b> {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n             self.pats.repr(tcx)\n@@ -931,7 +931,7 @@ fn enter_region<'r,\n // on a set of enum variants or a literal.\n fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n     let ccx = bcx.ccx();\n-    fn add_to_set(tcx: ty::ctxt, set: &mut Vec<Opt> , val: Opt) {\n+    fn add_to_set(tcx: &ty::ctxt, set: &mut Vec<Opt>, val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }"}, {"sha": "7dbc30aaf86ac2a056e26ce0b349f608f15aeb31", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -236,7 +236,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n \n /// Determine, without doing translation, whether an ADT must be FFI-safe.\n /// For use in lint or similar, where being sound but slightly incomplete is acceptable.\n-pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n+pub fn is_ffi_safe(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n     match ty::get(ty::lookup_item_type(tcx, def_id).ty).sty {\n         ty::ty_enum(def_id, _) => {\n             let variants = ty::enum_variants(tcx, def_id);\n@@ -274,7 +274,7 @@ impl Case {\n     }\n }\n \n-fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Case> {\n+fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Case> {\n     ty::enum_variants(tcx, def_id).map(|vi| {\n         let arg_tys = vi.args.map(|&raw_ty| {\n             ty::subst(tcx, substs, raw_ty)"}, {"sha": "f29b51aa8cb5d83f32e52012bdaa5f7aba01bc3e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -135,15 +135,15 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     _InsnCtxt { _x: () }\n }\n \n-pub struct StatRecorder {\n-    ccx: @CrateContext,\n+pub struct StatRecorder<'a> {\n+    ccx: @CrateContext<'a>,\n     name: Option<~str>,\n     start: u64,\n     istart: uint,\n }\n \n-impl StatRecorder {\n-    pub fn new(ccx: @CrateContext, name: ~str) -> StatRecorder {\n+impl<'a> StatRecorder<'a> {\n+    pub fn new(ccx: @CrateContext<'a>, name: ~str) -> StatRecorder<'a> {\n         let start = if ccx.sess().trans_stats() {\n             time::precise_time_ns()\n         } else {\n@@ -160,7 +160,7 @@ impl StatRecorder {\n }\n \n #[unsafe_destructor]\n-impl Drop for StatRecorder {\n+impl<'a> Drop for StatRecorder<'a> {\n     fn drop(&mut self) {\n         if self.ccx.sess().trans_stats() {\n             let end = time::precise_time_ns();\n@@ -1225,7 +1225,7 @@ pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n //\n // Be warned! You must call `init_function` before doing anything with the\n // returned function context.\n-pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n+pub fn new_fn_ctxt<'a>(ccx: @CrateContext<'a>,\n                        llfndecl: ValueRef,\n                        id: ast::NodeId,\n                        has_env: bool,\n@@ -1670,11 +1670,11 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::EnumDef,\n     }\n }\n \n-pub struct TransItemVisitor {\n-    ccx: @CrateContext,\n+pub struct TransItemVisitor<'a> {\n+    ccx: @CrateContext<'a>,\n }\n \n-impl Visitor<()> for TransItemVisitor {\n+impl<'a> Visitor<()> for TransItemVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _:()) {\n         trans_item(self.ccx, i);\n     }\n@@ -2552,7 +2552,7 @@ pub fn trans_crate(krate: ast::Crate,\n     let llmod_id = link_meta.crateid.name + \".rs\";\n \n     let ccx = @CrateContext::new(llmod_id,\n-                                 analysis.ty_cx,\n+                                 &analysis.ty_cx,\n                                  analysis.exp_map2,\n                                  analysis.maps,\n                                  Sha256::new(),"}, {"sha": "55065d746d1eddee0122166be9cefd5de3c3e77a", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -25,7 +25,7 @@ use syntax::codemap::Span;\n \n pub struct Builder<'a> {\n     llbuilder: BuilderRef,\n-    ccx: &'a CrateContext,\n+    ccx: &'a CrateContext<'a>,\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a"}, {"sha": "da71acb325739179cf08cf3cbf0bcfef522c1ba3", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -846,7 +846,7 @@ impl Cleanup for FreeValue {\n     }\n }\n \n-pub fn temporary_scope(tcx: ty::ctxt,\n+pub fn temporary_scope(tcx: &ty::ctxt,\n                        id: ast::NodeId)\n                        -> ScopeId {\n     match tcx.region_maps.temporary_scope(id) {\n@@ -861,7 +861,7 @@ pub fn temporary_scope(tcx: ty::ctxt,\n     }\n }\n \n-pub fn var_scope(tcx: ty::ctxt,\n+pub fn var_scope(tcx: &ty::ctxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n     let r = AstScope(tcx.region_maps.var_scope(id));"}, {"sha": "519049fafa8bb9427bdd0e00003d832061f60cda", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -133,7 +133,7 @@ impl EnvValue {\n }\n \n // Given a closure ty, emits a corresponding tuple ty\n-pub fn mk_closure_tys(tcx: ty::ctxt,\n+pub fn mk_closure_tys(tcx: &ty::ctxt,\n                       bound_values: &[EnvValue])\n                    -> ty::t {\n     // determine the types of the values in the env.  Note that this\n@@ -151,7 +151,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+fn tuplify_box_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_imm_ptr(tcx, ty::mk_i8());\n     ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }"}, {"sha": "7a7d04b7a52002f9868466e8b86f65e25ed0b0bb", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -207,14 +207,14 @@ impl param_substs {\n     }\n }\n \n-fn param_substs_to_str(this: &param_substs, tcx: ty::ctxt) -> ~str {\n+fn param_substs_to_str(this: &param_substs, tcx: &ty::ctxt) -> ~str {\n     format!(\"param_substs \\\\{tys:{}, vtables:{}\\\\}\",\n          this.tys.repr(tcx),\n          this.vtables.repr(tcx))\n }\n \n impl Repr for param_substs {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         param_substs_to_str(self, tcx)\n     }\n }\n@@ -286,7 +286,7 @@ pub struct FunctionContext<'a> {\n     block_arena: &'a TypedArena<Block<'a>>,\n \n     // This function's enclosing crate context.\n-    ccx: @CrateContext,\n+    ccx: @CrateContext<'a>,\n \n     // Used and maintained by the debuginfo module.\n     debug_context: debuginfo::FunctionDebugContext,\n@@ -435,8 +435,8 @@ impl<'a> Block<'a> {\n         })\n     }\n \n-    pub fn ccx(&self) -> @CrateContext { self.fcx.ccx }\n-    pub fn tcx(&self) -> ty::ctxt {\n+    pub fn ccx(&self) -> @CrateContext<'a> { self.fcx.ccx }\n+    pub fn tcx(&self) -> &'a ty::ctxt {\n         self.fcx.ccx.tcx\n     }\n     pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n@@ -858,7 +858,7 @@ pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext, vts: typeck::vtable_res\n                                        vts)\n }\n \n-pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n+pub fn resolve_vtables_under_param_substs(tcx: &ty::ctxt,\n                                           param_substs: Option<@param_substs>,\n                                           vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n@@ -870,7 +870,7 @@ pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n }\n \n pub fn resolve_param_vtables_under_param_substs(\n-    tcx: ty::ctxt,\n+    tcx: &ty::ctxt,\n     param_substs: Option<@param_substs>,\n     ds: typeck::vtable_param_res)\n     -> typeck::vtable_param_res {\n@@ -883,7 +883,7 @@ pub fn resolve_param_vtables_under_param_substs(\n \n \n \n-pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n+pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n                                          param_substs: Option<@param_substs>,\n                                          vt: &typeck::vtable_origin)\n                                          -> typeck::vtable_origin {\n@@ -919,7 +919,7 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n     }\n }\n \n-pub fn find_vtable(tcx: ty::ctxt,\n+pub fn find_vtable(tcx: &ty::ctxt,\n                    ps: &param_substs,\n                    n_param: typeck::param_index,\n                    n_bound: uint)"}, {"sha": "b135569eb4308d4b6f7a8f0a71efd8429e9d7154", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -38,7 +38,7 @@ use collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-pub struct CrateContext {\n+pub struct CrateContext<'a> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     metadata_llmod: ModuleRef,\n@@ -100,7 +100,7 @@ pub struct CrateContext {\n     symbol_hasher: RefCell<Sha256>,\n     type_hashcodes: RefCell<HashMap<ty::t, ~str>>,\n     all_llvm_symbols: RefCell<HashSet<~str>>,\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     maps: astencode::Maps,\n     stats: @Stats,\n     tydesc_type: Type,\n@@ -116,15 +116,15 @@ pub struct CrateContext {\n     dbg_cx: Option<debuginfo::CrateDebugContext>,\n }\n \n-impl CrateContext {\n+impl<'a> CrateContext<'a> {\n     pub fn new(name: &str,\n-               tcx: ty::ctxt,\n+               tcx: &'a ty::ctxt,\n                emap2: resolve::ExportMap2,\n                maps: astencode::Maps,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n                reachable: @RefCell<NodeSet>)\n-               -> CrateContext {\n+               -> CrateContext<'a> {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n             set_task_llcx(llcx);\n@@ -275,7 +275,7 @@ impl CrateContext {\n }\n \n #[unsafe_destructor]\n-impl Drop for CrateContext {\n+impl<'a> Drop for CrateContext<'a> {\n     fn drop(&mut self) {\n         unset_task_llcx();\n     }"}, {"sha": "2331b7428b666196dd18585133a4c80222c0c5a1", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -709,11 +709,11 @@ impl<'a> DatumBlock<'a, Expr> {\n         self.datum.shallow_copy(self.bcx, dst)\n     }\n \n-    pub fn ccx(&self) -> @CrateContext {\n+    pub fn ccx(&self) -> @CrateContext<'a> {\n         self.bcx.ccx()\n     }\n \n-    pub fn tcx(&self) -> ty::ctxt {\n+    pub fn tcx(&self) -> &'a ty::ctxt {\n         self.bcx.tcx()\n     }\n "}, {"sha": "5dee72f6781f231d9612190a52af472aa4f67bda", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -940,7 +940,7 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub fn with_field_tys<R>(tcx: ty::ctxt,\n+pub fn with_field_tys<R>(tcx: &ty::ctxt,\n                          ty: ty::t,\n                          node_id_opt: Option<ast::NodeId>,\n                          op: |ty::Disr, (&[ty::field])| -> R)"}, {"sha": "d4b7e2b704509415bad371c18ac753bf338e2bef", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -38,7 +38,7 @@ use syntax::parse::token::InternedString;\n // containing an unboxed vector. This expands a boxed vector type into such an\n // expanded type. It doesn't respect mutability, but that doesn't matter at\n // this point.\n-pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+pub fn expand_boxed_vec_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n     let unit_ty = ty::sequence_element_type(tcx, t);\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n@@ -441,7 +441,7 @@ pub fn write_content<'a>(\n                     return expr::trans_into(bcx, element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    let count = ty::eval_repeat_count(&bcx.tcx(), count_expr);\n+                    let count = ty::eval_repeat_count(bcx.tcx(), count_expr);\n                     if count == 0 {\n                         return bcx;\n                     }\n@@ -505,7 +505,7 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n         },\n         ast::ExprVec(ref es, _) => es.len(),\n         ast::ExprRepeat(_, count_expr, _) => {\n-            ty::eval_repeat_count(&bcx.tcx(), count_expr)\n+            ty::eval_repeat_count(bcx.tcx(), count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n                                      \"unexpected vec content\")"}, {"sha": "550306a955b51b88aebab5651672debcddd0900c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 165, "deletions": 167, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -250,12 +250,10 @@ pub enum AutoRef {\n     AutoBorrowObj(Region, ast::Mutability),\n }\n \n-pub type ctxt = @ctxt_;\n-\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n-pub struct ctxt_ {\n+pub struct ctxt {\n     diag: @syntax::diagnostic::SpanHandler,\n     // Specifically use a speedy hash algorithm for this hash map, it's used\n     // quite often.\n@@ -1089,7 +1087,7 @@ pub fn mk_ctxt(s: Session,\n                region_maps: middle::region::RegionMaps,\n                lang_items: @middle::lang_items::LanguageItems)\n             -> ctxt {\n-    @ctxt_ {\n+    ctxt {\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         diag: s.diagnostic(),\n@@ -1143,7 +1141,7 @@ pub fn mk_ctxt(s: Session,\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n-pub fn mk_t(cx: ctxt, st: sty) -> t {\n+pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     // Check for primitive types.\n     match st {\n         ty_nil => return mk_nil(),\n@@ -1355,64 +1353,64 @@ pub fn mk_mach_float(tm: ast::FloatTy) -> t {\n #[inline]\n pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n-pub fn mk_str(cx: ctxt, t: vstore) -> t {\n+pub fn mk_str(cx: &ctxt, t: vstore) -> t {\n     mk_t(cx, ty_str(t))\n }\n \n-pub fn mk_enum(cx: ctxt, did: ast::DefId, substs: substs) -> t {\n+pub fn mk_enum(cx: &ctxt, did: ast::DefId, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n \n-pub fn mk_box(cx: ctxt, ty: t) -> t { mk_t(cx, ty_box(ty)) }\n+pub fn mk_box(cx: &ctxt, ty: t) -> t { mk_t(cx, ty_box(ty)) }\n \n-pub fn mk_uniq(cx: ctxt, ty: t) -> t { mk_t(cx, ty_uniq(ty)) }\n+pub fn mk_uniq(cx: &ctxt, ty: t) -> t { mk_t(cx, ty_uniq(ty)) }\n \n-pub fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n+pub fn mk_ptr(cx: &ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n-pub fn mk_rptr(cx: ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n+pub fn mk_rptr(cx: &ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n \n-pub fn mk_mut_rptr(cx: ctxt, r: Region, ty: t) -> t {\n+pub fn mk_mut_rptr(cx: &ctxt, r: Region, ty: t) -> t {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutMutable})\n }\n-pub fn mk_imm_rptr(cx: ctxt, r: Region, ty: t) -> t {\n+pub fn mk_imm_rptr(cx: &ctxt, r: Region, ty: t) -> t {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_mut_ptr(cx: ctxt, ty: t) -> t {\n+pub fn mk_mut_ptr(cx: &ctxt, ty: t) -> t {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::MutMutable})\n }\n \n-pub fn mk_imm_ptr(cx: ctxt, ty: t) -> t {\n+pub fn mk_imm_ptr(cx: &ctxt, ty: t) -> t {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_nil_ptr(cx: ctxt) -> t {\n+pub fn mk_nil_ptr(cx: &ctxt) -> t {\n     mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec(cx: ctxt, tm: mt, t: vstore) -> t {\n+pub fn mk_vec(cx: &ctxt, tm: mt, t: vstore) -> t {\n     mk_t(cx, ty_vec(tm, t))\n }\n \n-pub fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n+pub fn mk_unboxed_vec(cx: &ctxt, tm: mt) -> t {\n     mk_t(cx, ty_unboxed_vec(tm))\n }\n-pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n+pub fn mk_mut_unboxed_vec(cx: &ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::MutImmutable}))\n }\n \n-pub fn mk_tup(cx: ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n \n-pub fn mk_closure(cx: ctxt, fty: ClosureTy) -> t {\n+pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(fty))\n }\n \n-pub fn mk_bare_fn(cx: ctxt, fty: BareFnTy) -> t {\n+pub fn mk_bare_fn(cx: &ctxt, fty: BareFnTy) -> t {\n     mk_t(cx, ty_bare_fn(fty))\n }\n \n-pub fn mk_ctor_fn(cx: ctxt,\n+pub fn mk_ctor_fn(cx: &ctxt,\n                   binder_id: ast::NodeId,\n                   input_tys: &[ty::t],\n                   output: ty::t) -> t {\n@@ -1431,7 +1429,7 @@ pub fn mk_ctor_fn(cx: ctxt,\n }\n \n \n-pub fn mk_trait(cx: ctxt,\n+pub fn mk_trait(cx: &ctxt,\n                 did: ast::DefId,\n                 substs: substs,\n                 store: TraitStore,\n@@ -1442,22 +1440,22 @@ pub fn mk_trait(cx: ctxt,\n     mk_t(cx, ty_trait(did, substs, store, mutability, bounds))\n }\n \n-pub fn mk_struct(cx: ctxt, struct_id: ast::DefId, substs: substs) -> t {\n+pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-pub fn mk_var(cx: ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n+pub fn mk_var(cx: &ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n \n-pub fn mk_int_var(cx: ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n+pub fn mk_int_var(cx: &ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n \n-pub fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n+pub fn mk_float_var(cx: &ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n-pub fn mk_infer(cx: ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n+pub fn mk_infer(cx: &ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n-pub fn mk_self(cx: ctxt, did: ast::DefId) -> t { mk_t(cx, ty_self(did)) }\n+pub fn mk_self(cx: &ctxt, did: ast::DefId) -> t { mk_t(cx, ty_self(did)) }\n \n-pub fn mk_param(cx: ctxt, n: uint, k: DefId) -> t {\n+pub fn mk_param(cx: &ctxt, n: uint, k: DefId) -> t {\n     mk_t(cx, ty_param(param_ty { idx: n, def_id: k }))\n }\n \n@@ -1495,35 +1493,35 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty(cx: ctxt, t0: t, fldop: |t| -> t) -> t {\n+pub fn fold_ty(cx: &ctxt, t0: t, fldop: |t| -> t) -> t {\n     let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n     f.fold_ty(t0)\n }\n \n-pub fn walk_regions_and_ty(cx: ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n+pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n                            -> t {\n     ty_fold::RegionFolder::general(cx,\n                                    |r| { fldr(r); r },\n                                    |t| { fldt(t); t }).fold_ty(ty)\n }\n \n-pub fn fold_regions(cx: ctxt, ty: t, fldr: |r: Region| -> Region) -> t {\n+pub fn fold_regions(cx: &ctxt, ty: t, fldr: |r: Region| -> Region) -> t {\n     ty_fold::RegionFolder::regions(cx, fldr).fold_ty(ty)\n }\n \n // Substitute *only* type parameters.  Used in trans where regions are erased.\n-pub fn subst_tps(tcx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n+pub fn subst_tps(tcx: &ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     let mut subst = TpsSubst { tcx: tcx, self_ty_opt: self_ty_opt, tps: tps };\n     return subst.fold_ty(typ);\n \n     struct TpsSubst<'a> {\n-        tcx: ctxt,\n+        tcx: &'a ctxt,\n         self_ty_opt: Option<t>,\n         tps: &'a [t],\n     }\n \n     impl<'a> TypeFolder for TpsSubst<'a> {\n-        fn tcx(&self) -> ty::ctxt { self.tcx }\n+        fn tcx<'a>(&'a self) -> &'a ctxt { self.tcx }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n             if self.tps.len() == 0u && self.self_ty_opt.is_none() {\n@@ -1566,11 +1564,11 @@ pub fn substs_is_noop(substs: &substs) -> bool {\n         substs.self_ty.is_none()\n }\n \n-pub fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n+pub fn substs_to_str(cx: &ctxt, substs: &substs) -> ~str {\n     substs.repr(cx)\n }\n \n-pub fn subst(cx: ctxt,\n+pub fn subst(cx: &ctxt,\n              substs: &substs,\n              typ: t)\n           -> t {\n@@ -1631,7 +1629,7 @@ pub fn type_is_sequence(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_simd(cx: ctxt, ty: t) -> bool {\n+pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n     match get(ty).sty {\n         ty_struct(did, _) => lookup_simd(cx, did),\n         _ => false\n@@ -1645,15 +1643,15 @@ pub fn type_is_str(ty: t) -> bool {\n     }\n }\n \n-pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n+pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n       ty_str(_) => return mk_mach_uint(ast::TyU8),\n       ty_vec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n       _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n     }\n }\n \n-pub fn simd_type(cx: ctxt, ty: t) -> t {\n+pub fn simd_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n         ty_struct(did, ref substs) => {\n             let fields = lookup_struct_fields(cx, did);\n@@ -1663,7 +1661,7 @@ pub fn simd_type(cx: ctxt, ty: t) -> t {\n     }\n }\n \n-pub fn simd_size(cx: ctxt, ty: t) -> uint {\n+pub fn simd_size(cx: &ctxt, ty: t) -> uint {\n     match get(ty).sty {\n         ty_struct(did, _) => {\n             let fields = lookup_struct_fields(cx, did);\n@@ -1751,15 +1749,15 @@ pub fn type_is_scalar(ty: t) -> bool {\n     }\n }\n \n-pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n+pub fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).needs_drop(cx)\n }\n \n // Some things don't need cleanups during unwinding because the\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n-pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n+pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n     {\n         let needs_unwind_cleanup_cache = cx.needs_unwind_cleanup_cache\n                                            .borrow();\n@@ -1778,7 +1776,7 @@ pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n     return needs_unwind_cleanup;\n }\n \n-fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n+fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t,\n                               tycache: &mut HashSet<t>,\n                               encountered_box: bool) -> bool {\n \n@@ -1925,11 +1923,11 @@ def_type_content_sets!(\n )\n \n impl TypeContents {\n-    pub fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n+    pub fn meets_bounds(&self, cx: &ctxt, bbs: BuiltinBounds) -> bool {\n         bbs.iter().all(|bb| self.meets_bound(cx, bb))\n     }\n \n-    pub fn meets_bound(&self, cx: ctxt, bb: BuiltinBound) -> bool {\n+    pub fn meets_bound(&self, cx: &ctxt, bb: BuiltinBound) -> bool {\n         match bb {\n             BoundStatic => self.is_static(cx),\n             BoundFreeze => self.is_freezable(cx),\n@@ -1947,11 +1945,11 @@ impl TypeContents {\n         (self.bits & tc.bits) != 0\n     }\n \n-    pub fn is_static(&self, _: ctxt) -> bool {\n+    pub fn is_static(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonstatic)\n     }\n \n-    pub fn is_sendable(&self, _: ctxt) -> bool {\n+    pub fn is_sendable(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonsendable)\n     }\n \n@@ -1963,23 +1961,23 @@ impl TypeContents {\n         self.intersects(TC::OwnsOwned)\n     }\n \n-    pub fn is_freezable(&self, _: ctxt) -> bool {\n+    pub fn is_freezable(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonfreezable)\n     }\n \n-    pub fn is_sized(&self, _: ctxt) -> bool {\n+    pub fn is_sized(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonsized)\n     }\n \n-    pub fn is_pod(&self, _: ctxt) -> bool {\n+    pub fn is_pod(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonpod)\n     }\n \n-    pub fn moves_by_default(&self, _: ctxt) -> bool {\n+    pub fn moves_by_default(&self, _: &ctxt) -> bool {\n         self.intersects(TC::Moves)\n     }\n \n-    pub fn needs_drop(&self, _: ctxt) -> bool {\n+    pub fn needs_drop(&self, _: &ctxt) -> bool {\n         self.intersects(TC::NeedsDrop)\n     }\n \n@@ -2055,23 +2053,23 @@ impl fmt::Show for TypeContents {\n     }\n }\n \n-pub fn type_has_dtor(cx: ctxt, t: ty::t) -> bool {\n+pub fn type_has_dtor(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).has_dtor()\n }\n \n-pub fn type_is_static(cx: ctxt, t: ty::t) -> bool {\n+pub fn type_is_static(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_static(cx)\n }\n \n-pub fn type_is_sendable(cx: ctxt, t: ty::t) -> bool {\n+pub fn type_is_sendable(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_sendable(cx)\n }\n \n-pub fn type_is_freezable(cx: ctxt, t: ty::t) -> bool {\n+pub fn type_is_freezable(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_freezable(cx)\n }\n \n-pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n+pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     let ty_id = type_id(ty);\n \n     {\n@@ -2089,7 +2087,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n     tc_cache.get().insert(ty_id, result);\n     return result;\n \n-    fn tc_ty(cx: ctxt,\n+    fn tc_ty(cx: &ctxt,\n              ty: t,\n              cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n     {\n@@ -2255,15 +2253,15 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         return result;\n     }\n \n-    fn tc_mt(cx: ctxt,\n+    fn tc_mt(cx: &ctxt,\n              mt: mt,\n              cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n     {\n         let mc = TC::ReachesMutable.when(mt.mutbl == MutMutable);\n         mc | tc_ty(cx, mt.ty, cache)\n     }\n \n-    fn apply_lang_items(cx: ctxt,\n+    fn apply_lang_items(cx: &ctxt,\n                         did: ast::DefId,\n                         tc: TypeContents)\n                         -> TypeContents {\n@@ -2295,7 +2293,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         b | (TC::ReachesBorrowed).when(region != ty::ReStatic)\n     }\n \n-    fn closure_contents(cx: ctxt, cty: &ClosureTy) -> TypeContents {\n+    fn closure_contents(cx: &ctxt, cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n         let st = match cty.sigil {\n@@ -2321,7 +2319,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         st | rt | ot\n     }\n \n-    fn object_contents(cx: ctxt,\n+    fn object_contents(cx: &ctxt,\n                        store: TraitStore,\n                        mutbl: ast::Mutability,\n                        bounds: BuiltinBounds)\n@@ -2340,7 +2338,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         }\n     }\n \n-    fn kind_bounds_to_contents(cx: ctxt,\n+    fn kind_bounds_to_contents(cx: &ctxt,\n                                bounds: BuiltinBounds,\n                                traits: &[@TraitRef])\n                                -> TypeContents {\n@@ -2359,7 +2357,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n         // Iterates over all builtin bounds on the type parameter def, including\n         // those inherited from traits with builtin-kind-supertraits.\n-        fn each_inherited_builtin_bound(cx: ctxt,\n+        fn each_inherited_builtin_bound(cx: &ctxt,\n                                         bounds: BuiltinBounds,\n                                         traits: &[@TraitRef],\n                                         f: |BuiltinBound|) {\n@@ -2378,13 +2376,13 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n     }\n }\n \n-pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n+pub fn type_moves_by_default(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).moves_by_default(cx)\n }\n \n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n-pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n-    fn type_requires(cx: ctxt, seen: &mut Vec<DefId> ,\n+pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n+    fn type_requires(cx: &ctxt, seen: &mut Vec<DefId>,\n                      r_ty: t, ty: t) -> bool {\n         debug!(\"type_requires({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2402,7 +2400,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n         return r;\n     }\n \n-    fn subtypes_require(cx: ctxt, seen: &mut Vec<DefId> ,\n+    fn subtypes_require(cx: &ctxt, seen: &mut Vec<DefId>,\n                         r_ty: t, ty: t) -> bool {\n         debug!(\"subtypes_require({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2508,10 +2506,10 @@ pub enum Representability {\n \n /// Check whether a type is representable. This means it cannot contain unboxed\n /// structural recursion. This check is needed for structs and enums.\n-pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n+pub fn is_type_representable(cx: &ctxt, ty: t) -> Representability {\n \n     // Iterate until something non-representable is found\n-    fn find_nonrepresentable<It: Iterator<t>>(cx: ctxt, seen: &mut Vec<DefId> ,\n+    fn find_nonrepresentable<It: Iterator<t>>(cx: &ctxt, seen: &mut Vec<DefId>,\n                                               mut iter: It) -> Representability {\n         for ty in iter {\n             let r = type_structurally_recursive(cx, seen, ty);\n@@ -2524,7 +2522,7 @@ pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n \n     // Does the type `ty` directly (without indirection through a pointer)\n     // contain any types on stack `seen`?\n-    fn type_structurally_recursive(cx: ctxt, seen: &mut Vec<DefId> ,\n+    fn type_structurally_recursive(cx: &ctxt, seen: &mut Vec<DefId>,\n                                    ty: t) -> Representability {\n         debug!(\"type_structurally_recursive: {}\",\n                ::util::ppaux::ty_to_str(cx, ty));\n@@ -2656,7 +2654,7 @@ pub fn type_is_enum(ty: t) -> bool {\n }\n \n // Is the type's representation size known at compile time?\n-pub fn type_is_sized(cx: ctxt, ty: ty::t) -> bool {\n+pub fn type_is_sized(cx: &ctxt, ty: ty::t) -> bool {\n     match get(ty).sty {\n         // FIXME(#6308) add trait, vec, str, etc here.\n         ty_param(p) => {\n@@ -2673,7 +2671,7 @@ pub fn type_is_sized(cx: ctxt, ty: ty::t) -> bool {\n \n // Whether a type is enum like, that is an enum type with only nullary\n // constructors\n-pub fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n+pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n     match get(ty).sty {\n         ty_enum(did, _) => {\n             let variants = enum_variants(cx, did);\n@@ -2720,7 +2718,7 @@ pub fn index(t: t) -> Option<mt> {\n     }\n }\n \n-pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n+pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     let trait_refs = cx.trait_refs.borrow();\n     match trait_refs.get().find(&id) {\n        Some(&t) => t,\n@@ -2730,12 +2728,12 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     }\n }\n \n-pub fn try_node_id_to_type(cx: ctxt, id: ast::NodeId) -> Option<t> {\n+pub fn try_node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n     let node_types = cx.node_types.borrow();\n     node_types.get().find_copy(&(id as uint))\n }\n \n-pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n+pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n     match try_node_id_to_type(cx, id) {\n        Some(t) => t,\n        None => cx.sess.bug(\n@@ -2744,7 +2742,7 @@ pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n     }\n }\n \n-pub fn node_id_to_type_opt(cx: ctxt, id: ast::NodeId) -> Option<t> {\n+pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n     let node_types = cx.node_types.borrow();\n     debug!(\"id: {:?}, node_types: {:?}\", id, node_types);\n     match node_types.get().find(&(id as uint)) {\n@@ -2754,15 +2752,15 @@ pub fn node_id_to_type_opt(cx: ctxt, id: ast::NodeId) -> Option<t> {\n }\n \n // FIXME(pcwalton): Makes a copy, bleh. Probably better to not do that.\n-pub fn node_id_to_type_params(cx: ctxt, id: ast::NodeId) -> Vec<t> {\n+pub fn node_id_to_type_params(cx: &ctxt, id: ast::NodeId) -> Vec<t> {\n     let node_type_substs = cx.node_type_substs.borrow();\n     match node_type_substs.get().find(&id) {\n       None => return Vec::new(),\n       Some(ts) => return (*ts).clone(),\n     }\n }\n \n-fn node_id_has_type_params(cx: ctxt, id: ast::NodeId) -> bool {\n+fn node_id_has_type_params(cx: &ctxt, id: ast::NodeId) -> bool {\n     let node_type_substs = cx.node_type_substs.borrow();\n     node_type_substs.get().contains_key(&id)\n }\n@@ -2843,7 +2841,7 @@ pub fn ty_vstore(ty: t) -> vstore {\n     }\n }\n \n-pub fn ty_region(tcx: ctxt,\n+pub fn ty_region(tcx: &ctxt,\n                  span: Span,\n                  ty: t) -> Region {\n     match get(ty).sty {\n@@ -2858,7 +2856,7 @@ pub fn ty_region(tcx: ctxt,\n     }\n }\n \n-pub fn replace_fn_sig(cx: ctxt, fsty: &sty, new_sig: FnSig) -> t {\n+pub fn replace_fn_sig(cx: &ctxt, fsty: &sty, new_sig: FnSig) -> t {\n     match *fsty {\n         ty_bare_fn(ref f) => mk_bare_fn(cx, BareFnTy {sig: new_sig, ..*f}),\n         ty_closure(ref f) => mk_closure(cx, ClosureTy {sig: new_sig, ..*f}),\n@@ -2869,7 +2867,7 @@ pub fn replace_fn_sig(cx: ctxt, fsty: &sty, new_sig: FnSig) -> t {\n     }\n }\n \n-pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n+pub fn replace_closure_return_type(tcx: &ctxt, fn_type: t, ret_type: t) -> t {\n     /*!\n      *\n      * Returns a new function type based on `fn_type` but returning a value of\n@@ -2896,14 +2894,14 @@ pub fn tys_in_fn_sig(sig: &FnSig) -> Vec<t> {\n }\n \n // Type accessors for AST nodes\n-pub fn block_ty(cx: ctxt, b: &ast::Block) -> t {\n+pub fn block_ty(cx: &ctxt, b: &ast::Block) -> t {\n     return node_id_to_type(cx, b.id);\n }\n \n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-pub fn pat_ty(cx: ctxt, pat: &ast::Pat) -> t {\n+pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> t {\n     return node_id_to_type(cx, pat.id);\n }\n \n@@ -2919,15 +2917,15 @@ pub fn pat_ty(cx: ctxt, pat: &ast::Pat) -> t {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-pub fn expr_ty(cx: ctxt, expr: &ast::Expr) -> t {\n+pub fn expr_ty(cx: &ctxt, expr: &ast::Expr) -> t {\n     return node_id_to_type(cx, expr.id);\n }\n \n-pub fn expr_ty_opt(cx: ctxt, expr: &ast::Expr) -> Option<t> {\n+pub fn expr_ty_opt(cx: &ctxt, expr: &ast::Expr) -> Option<t> {\n     return node_id_to_type_opt(cx, expr.id);\n }\n \n-pub fn expr_ty_adjusted(cx: ctxt,\n+pub fn expr_ty_adjusted(cx: &ctxt,\n                         expr: &ast::Expr,\n                         method_map: &FnvHashMap<MethodCall, MethodCallee>)\n                         -> t {\n@@ -2951,7 +2949,7 @@ pub fn expr_ty_adjusted(cx: ctxt,\n     })\n }\n \n-pub fn expr_span(cx: ctxt, id: NodeId) -> Span {\n+pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n     match cx.map.find(id) {\n         Some(ast_map::NodeExpr(e)) => {\n             e.span\n@@ -2967,7 +2965,7 @@ pub fn expr_span(cx: ctxt, id: NodeId) -> Span {\n     }\n }\n \n-pub fn local_var_name_str(cx: ctxt, id: NodeId) -> InternedString {\n+pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n     match cx.map.find(id) {\n         Some(ast_map::NodeLocal(pat)) => {\n             match pat.node {\n@@ -2989,7 +2987,7 @@ pub fn local_var_name_str(cx: ctxt, id: NodeId) -> InternedString {\n     }\n }\n \n-pub fn adjust_ty(cx: ctxt,\n+pub fn adjust_ty(cx: &ctxt,\n                  span: Span,\n                  expr_id: ast::NodeId,\n                  unadjusted_ty: ty::t,\n@@ -3104,7 +3102,7 @@ pub fn adjust_ty(cx: ctxt,\n         None => unadjusted_ty\n     };\n \n-    fn borrow_vec(cx: ctxt, span: Span,\n+    fn borrow_vec(cx: &ctxt, span: Span,\n                   r: Region, m: ast::Mutability,\n                   ty: ty::t) -> ty::t {\n         match get(ty).sty {\n@@ -3125,7 +3123,7 @@ pub fn adjust_ty(cx: ctxt,\n         }\n     }\n \n-    fn borrow_fn(cx: ctxt, span: Span, r: Region, ty: ty::t) -> ty::t {\n+    fn borrow_fn(cx: &ctxt, span: Span, r: Region, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_closure(ref fty) => {\n                 ty::mk_closure(cx, ClosureTy {\n@@ -3144,7 +3142,7 @@ pub fn adjust_ty(cx: ctxt,\n         }\n     }\n \n-    fn borrow_obj(cx: ctxt, span: Span, r: Region,\n+    fn borrow_obj(cx: &ctxt, span: Span, r: Region,\n                   m: ast::Mutability, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_trait(trt_did, ref trt_substs, _, _, b) => {\n@@ -3161,7 +3159,7 @@ pub fn adjust_ty(cx: ctxt,\n     }\n }\n \n-pub fn trait_adjustment_to_ty(cx: ctxt, sigil: &ast::Sigil, region: &Option<Region>,\n+pub fn trait_adjustment_to_ty(cx: &ctxt, sigil: &ast::Sigil, region: &Option<Region>,\n                               def_id: ast::DefId, substs: &substs, m: ast::Mutability,\n                               bounds: BuiltinBounds) -> t {\n \n@@ -3192,7 +3190,7 @@ pub struct ParamsTy {\n     ty: t\n }\n \n-pub fn expr_ty_params_and_ty(cx: ctxt,\n+pub fn expr_ty_params_and_ty(cx: &ctxt,\n                              expr: &ast::Expr)\n                           -> ParamsTy {\n     ParamsTy {\n@@ -3201,12 +3199,12 @@ pub fn expr_ty_params_and_ty(cx: ctxt,\n     }\n }\n \n-pub fn expr_has_ty_params(cx: ctxt, expr: &ast::Expr) -> bool {\n+pub fn expr_has_ty_params(cx: &ctxt, expr: &ast::Expr) -> bool {\n     return node_id_has_type_params(cx, expr.id);\n }\n \n-pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::MethodOrigin)\n-                                   -> Rc<Vec<TypeParameterDef> > {\n+pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n+                                   -> Rc<Vec<TypeParameterDef>> {\n     match origin {\n         typeck::MethodStatic(did) => {\n             // n.b.: When we encode impl methods, the bounds\n@@ -3234,7 +3232,7 @@ pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::MethodOrigin)\n     }\n }\n \n-pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n+pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> ast::Def {\n     let def_map = tcx.def_map.borrow();\n     match def_map.get().find(&expr.id) {\n         Some(&def) => def,\n@@ -3245,7 +3243,7 @@ pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n     }\n }\n \n-pub fn expr_is_lval(tcx: ctxt,\n+pub fn expr_is_lval(tcx: &ctxt,\n                     method_map: MethodMap,\n                     e: &ast::Expr) -> bool {\n     match expr_kind(tcx, method_map, e) {\n@@ -3266,7 +3264,7 @@ pub enum ExprKind {\n     RvalueStmtExpr\n }\n \n-pub fn expr_kind(tcx: ctxt,\n+pub fn expr_kind(tcx: &ctxt,\n                  method_map: MethodMap,\n                  expr: &ast::Expr) -> ExprKind {\n     if method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)) {\n@@ -3440,7 +3438,7 @@ pub fn field_idx(name: ast::Name, fields: &[field]) -> Option<uint> {\n     return None;\n }\n \n-pub fn field_idx_strict(tcx: ty::ctxt, name: ast::Name, fields: &[field])\n+pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n@@ -3470,7 +3468,7 @@ pub fn param_tys_in_type(ty: t) -> Vec<param_ty> {\n     rslt\n }\n \n-pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n+pub fn ty_sort_str(cx: &ctxt, t: t) -> ~str {\n     match get(t).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str(_) => {\n@@ -3498,7 +3496,7 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     }\n }\n \n-pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n+pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n     /*!\n      *\n      * Explains the source of a type err in a short,\n@@ -3644,7 +3642,7 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n     }\n }\n \n-pub fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n+pub fn note_and_explain_type_err(cx: &ctxt, err: &type_err) {\n     match *err {\n         terr_regions_does_not_outlive(subregion, superregion) => {\n             note_and_explain_region(cx, \"\", subregion, \"...\");\n@@ -3683,12 +3681,12 @@ pub fn def_has_ty_params(def: ast::Def) -> bool {\n     }\n }\n \n-pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n+pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     let provided_method_sources = cx.provided_method_sources.borrow();\n     provided_method_sources.get().find(&id).map(|x| *x)\n }\n \n-pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> Vec<@Method> {\n+pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<@Method> {\n     if is_local(id) {\n         {\n             match cx.map.find(id.node) {\n@@ -3720,7 +3718,7 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> Vec<@Method> {\n     }\n }\n \n-pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n+pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n     // Check the cache.\n     {\n         let supertraits = cx.supertraits.borrow();\n@@ -3742,7 +3740,7 @@ pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n     return result;\n }\n \n-pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> Vec<@TraitRef> {\n+pub fn trait_ref_supertraits(cx: &ctxt, trait_ref: &ty::TraitRef) -> Vec<@TraitRef> {\n     let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n     supertrait_refs.map(\n         |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs))\n@@ -3776,13 +3774,13 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     v\n }\n \n-pub fn trait_method(cx: ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n+pub fn trait_method(cx: &ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n     let method_def_id = *ty::trait_method_def_ids(cx, trait_did).get(idx);\n     ty::method(cx, method_def_id)\n }\n \n \n-pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n+pub fn trait_methods(cx: &ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n     let mut trait_methods_cache = cx.trait_methods_cache.borrow_mut();\n     match trait_methods_cache.get().find(&trait_did) {\n         Some(&methods) => methods,\n@@ -3795,14 +3793,14 @@ pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n     }\n }\n \n-pub fn method(cx: ctxt, id: ast::DefId) -> @Method {\n+pub fn method(cx: &ctxt, id: ast::DefId) -> @Method {\n     let mut methods = cx.methods.borrow_mut();\n     lookup_locally_or_in_crate_store(\"methods\", id, methods.get(), || {\n         @csearch::get_method(cx, id)\n     })\n }\n \n-pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @Vec<DefId> {\n+pub fn trait_method_def_ids(cx: &ctxt, id: ast::DefId) -> @Vec<DefId> {\n     let mut trait_method_def_ids = cx.trait_method_def_ids.borrow_mut();\n     lookup_locally_or_in_crate_store(\"trait_method_def_ids\",\n                                      id,\n@@ -3812,7 +3810,7 @@ pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @Vec<DefId> {\n     })\n }\n \n-pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n+pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<@TraitRef> {\n     {\n         let mut impl_trait_cache = cx.impl_trait_cache.borrow_mut();\n         match impl_trait_cache.get().find(&id) {\n@@ -3848,15 +3846,15 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n     return ret;\n }\n \n-pub fn trait_ref_to_def_id(tcx: ctxt, tr: &ast::TraitRef) -> ast::DefId {\n+pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     let def_map = tcx.def_map.borrow();\n     let def = def_map.get()\n                      .find(&tr.ref_id)\n                      .expect(\"no def-map entry for trait\");\n     ast_util::def_id_of_def(*def)\n }\n \n-pub fn try_add_builtin_trait(tcx: ctxt,\n+pub fn try_add_builtin_trait(tcx: &ctxt,\n                              trait_def_id: ast::DefId,\n                              builtin_bounds: &mut BuiltinBounds) -> bool {\n     //! Checks whether `trait_ref` refers to one of the builtin\n@@ -3894,7 +3892,7 @@ impl VariantInfo {\n     /// Creates a new VariantInfo from the corresponding ast representation.\n     ///\n     /// Does not do any caching of the value in the type context.\n-    pub fn from_ast_variant(cx: ctxt,\n+    pub fn from_ast_variant(cx: &ctxt,\n                             ast_variant: &ast::Variant,\n                             discriminant: Disr) -> VariantInfo {\n         let ctor_ty = node_id_to_type(cx, ast_variant.node.id);\n@@ -3946,7 +3944,7 @@ impl VariantInfo {\n     }\n }\n \n-pub fn substd_enum_variants(cx: ctxt,\n+pub fn substd_enum_variants(cx: &ctxt,\n                             id: ast::DefId,\n                             substs: &substs)\n                          -> Vec<@VariantInfo> {\n@@ -3964,7 +3962,7 @@ pub fn substd_enum_variants(cx: ctxt,\n     }).collect()\n }\n \n-pub fn item_path_str(cx: ctxt, id: ast::DefId) -> ~str {\n+pub fn item_path_str(cx: &ctxt, id: ast::DefId) -> ~str {\n     with_path(cx, id, |path| ast_map::path_to_str(path))\n }\n \n@@ -3995,7 +3993,7 @@ impl DtorKind {\n \n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n-pub fn ty_dtor(cx: ctxt, struct_id: DefId) -> DtorKind {\n+pub fn ty_dtor(cx: &ctxt, struct_id: DefId) -> DtorKind {\n     let destructor_for_type = cx.destructor_for_type.borrow();\n     match destructor_for_type.get().find(&struct_id) {\n         Some(&method_def_id) => {\n@@ -4007,30 +4005,30 @@ pub fn ty_dtor(cx: ctxt, struct_id: DefId) -> DtorKind {\n     }\n }\n \n-pub fn has_dtor(cx: ctxt, struct_id: DefId) -> bool {\n+pub fn has_dtor(cx: &ctxt, struct_id: DefId) -> bool {\n     ty_dtor(cx, struct_id).is_present()\n }\n \n-pub fn with_path<T>(cx: ctxt, id: ast::DefId, f: |ast_map::PathElems| -> T) -> T {\n+pub fn with_path<T>(cx: &ctxt, id: ast::DefId, f: |ast_map::PathElems| -> T) -> T {\n     if id.krate == ast::LOCAL_CRATE {\n         cx.map.with_path(id.node, f)\n     } else {\n         f(ast_map::Values(csearch::get_item_path(cx, id).iter()).chain(None))\n     }\n }\n \n-pub fn enum_is_univariant(cx: ctxt, id: ast::DefId) -> bool {\n+pub fn enum_is_univariant(cx: &ctxt, id: ast::DefId) -> bool {\n     enum_variants(cx, id).len() == 1\n }\n \n-pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n+pub fn type_is_empty(cx: &ctxt, t: t) -> bool {\n     match ty::get(t).sty {\n        ty_enum(did, _) => (*enum_variants(cx, did)).is_empty(),\n        _ => false\n      }\n }\n \n-pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n+pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n     {\n         let enum_var_cache = cx.enum_var_cache.borrow();\n         match enum_var_cache.get().find(&id) {\n@@ -4061,7 +4059,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n                             };\n \n                             match variant.node.disr_expr {\n-                                Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n+                                Some(e) => match const_eval::eval_const_expr_partial(cx, e) {\n                                     Ok(const_eval::const_int(val)) => {\n                                         discriminant = val as Disr\n                                     }\n@@ -4113,7 +4111,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n \n \n // Returns information about the enum variant with the given ID:\n-pub fn enum_variant_with_id(cx: ctxt,\n+pub fn enum_variant_with_id(cx: &ctxt,\n                             enum_id: ast::DefId,\n                             variant_id: ast::DefId)\n                          -> @VariantInfo {\n@@ -4132,7 +4130,7 @@ pub fn enum_variant_with_id(cx: ctxt,\n \n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n-pub fn lookup_item_type(cx: ctxt,\n+pub fn lookup_item_type(cx: &ctxt,\n                         did: ast::DefId)\n                      -> ty_param_bounds_and_ty {\n     let mut tcache = cx.tcache.borrow_mut();\n@@ -4141,7 +4139,7 @@ pub fn lookup_item_type(cx: ctxt,\n         || csearch::get_type(cx, did))\n }\n \n-pub fn lookup_impl_vtables(cx: ctxt,\n+pub fn lookup_impl_vtables(cx: &ctxt,\n                            did: ast::DefId)\n                      -> typeck::impl_res {\n     let mut impl_vtables = cx.impl_vtables.borrow_mut();\n@@ -4151,7 +4149,7 @@ pub fn lookup_impl_vtables(cx: ctxt,\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n-pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n+pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> @ty::TraitDef {\n     let mut trait_defs = cx.trait_defs.borrow_mut();\n     match trait_defs.get().find(&did) {\n         Some(&trait_def) => {\n@@ -4171,7 +4169,7 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n /// Iterate over meta_items of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n+pub fn each_attr(tcx: &ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n         item.attrs.iter().advance(|attr| f(attr.node.value))\n@@ -4187,7 +4185,7 @@ pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n }\n \n /// Determine whether an item is annotated with an attribute\n-pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n+pub fn has_attr(tcx: &ctxt, did: DefId, attr: &str) -> bool {\n     let mut found = false;\n     each_attr(tcx, did, |item| {\n         if item.name().equiv(&attr) {\n@@ -4201,17 +4199,17 @@ pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n }\n \n /// Determine whether an item is annotated with `#[packed]`\n-pub fn lookup_packed(tcx: ctxt, did: DefId) -> bool {\n+pub fn lookup_packed(tcx: &ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"packed\")\n }\n \n /// Determine whether an item is annotated with `#[simd]`\n-pub fn lookup_simd(tcx: ctxt, did: DefId) -> bool {\n+pub fn lookup_simd(tcx: &ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"simd\")\n }\n \n // Obtain the representation annotation for a definition.\n-pub fn lookup_repr_hint(tcx: ctxt, did: DefId) -> attr::ReprAttr {\n+pub fn lookup_repr_hint(tcx: &ctxt, did: DefId) -> attr::ReprAttr {\n     let mut acc = attr::ReprAny;\n     ty::each_attr(tcx, did, |meta| {\n         acc = attr::find_repr_attr(tcx.sess.diagnostic(), meta, acc);\n@@ -4222,7 +4220,7 @@ pub fn lookup_repr_hint(tcx: ctxt, did: DefId) -> attr::ReprAttr {\n \n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n-pub fn lookup_field_type(tcx: ctxt,\n+pub fn lookup_field_type(tcx: &ctxt,\n                          struct_id: DefId,\n                          id: DefId,\n                          substs: &substs)\n@@ -4247,7 +4245,7 @@ pub fn lookup_field_type(tcx: ctxt,\n \n // Look up the list of field names and IDs for a given struct\n // Fails if the id is not bound to a struct.\n-pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> Vec<field_ty> {\n+pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n   if did.krate == ast::LOCAL_CRATE {\n       {\n           match cx.map.find(did.node) {\n@@ -4282,7 +4280,7 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> Vec<field_ty> {\n   }\n }\n \n-pub fn lookup_struct_field(cx: ctxt,\n+pub fn lookup_struct_field(cx: &ctxt,\n                            parent: ast::DefId,\n                            field_id: ast::DefId)\n                         -> field_ty {\n@@ -4317,7 +4315,7 @@ fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n \n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n-pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n+pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &substs)\n                      -> Vec<field> {\n     lookup_struct_fields(cx, did).map(|f| {\n        field {\n@@ -4331,7 +4329,7 @@ pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n     })\n }\n \n-pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n+pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n     static tycat_other: int = 0;\n     static tycat_bool: int = 1;\n     static tycat_char: int = 2;\n@@ -4372,7 +4370,7 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n         }\n     }\n \n-    fn tycat(cx: ctxt, ty: t) -> int {\n+    fn tycat(cx: &ctxt, ty: t) -> int {\n         if type_is_simd(cx, ty) {\n             return tycat(cx, simd_type(cx, ty))\n         }\n@@ -4403,22 +4401,22 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n     return tbl[tycat(cx, ty)][opcat(op)];\n }\n \n-pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> Vec<t> {\n+pub fn ty_params_to_tys(tcx: &ctxt, generics: &ast::Generics) -> Vec<t> {\n     Vec::from_fn(generics.ty_params.len(), |i| {\n         let id = generics.ty_params.get(i).id;\n         ty::mk_param(tcx, i, ast_util::local_def(id))\n     })\n }\n \n /// Returns an equivalent type with all the typedefs and self regions removed.\n-pub fn normalize_ty(cx: ctxt, t: t) -> t {\n+pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     let u = TypeNormalizer(cx).fold_ty(t);\n     return u;\n \n-    struct TypeNormalizer(ctxt);\n+    struct TypeNormalizer<'a>(&'a ctxt);\n \n-    impl TypeFolder for TypeNormalizer {\n-        fn tcx(&self) -> ty::ctxt { let TypeNormalizer(c) = *self; c }\n+    impl<'a> TypeFolder for TypeNormalizer<'a> {\n+        fn tcx<'a>(&'a self) -> &'a ctxt { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n             let normalized_opt = {\n@@ -4476,16 +4474,16 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n \n pub trait ExprTyProvider {\n     fn expr_ty(&self, ex: &ast::Expr) -> t;\n-    fn ty_ctxt(&self) -> ctxt;\n+    fn ty_ctxt<'a>(&'a self) -> &'a ctxt;\n }\n \n impl ExprTyProvider for ctxt {\n     fn expr_ty(&self, ex: &ast::Expr) -> t {\n-        expr_ty(*self, ex)\n+        expr_ty(self, ex)\n     }\n \n-    fn ty_ctxt(&self) -> ctxt {\n-        *self\n+    fn ty_ctxt<'a>(&'a self) -> &'a ctxt {\n+        self\n     }\n }\n \n@@ -4555,7 +4553,7 @@ pub fn determine_inherited_purity(parent: (ast::Purity, ast::NodeId),\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n-pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n+pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n                                         bounds: &[@TraitRef],\n                                         f: |@TraitRef| -> bool)\n                                         -> bool {\n@@ -4598,7 +4596,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n     return true;\n }\n \n-pub fn count_traits_and_supertraits(tcx: ctxt,\n+pub fn count_traits_and_supertraits(tcx: &ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n     for type_param_def in type_param_defs.iter() {\n@@ -4611,23 +4609,23 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n     return total;\n }\n \n-pub fn get_tydesc_ty(tcx: ctxt) -> Result<t, ~str> {\n+pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         let intrinsic_defs = tcx.intrinsic_defs.borrow();\n         intrinsic_defs.get().find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n     })\n }\n \n-pub fn get_opaque_ty(tcx: ctxt) -> Result<t, ~str> {\n+pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n         let intrinsic_defs = tcx.intrinsic_defs.borrow();\n         intrinsic_defs.get().find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n     })\n }\n \n-pub fn visitor_object_ty(tcx: ctxt,\n+pub fn visitor_object_ty(tcx: &ctxt,\n                          region: ty::Region) -> Result<(@TraitRef, t), ~str> {\n     let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n         Ok(id) => id,\n@@ -4648,15 +4646,15 @@ pub fn visitor_object_ty(tcx: ctxt,\n                  EmptyBuiltinBounds())))\n }\n \n-pub fn item_variances(tcx: ctxt, item_id: ast::DefId) -> @ItemVariances {\n+pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> @ItemVariances {\n     let mut item_variance_map = tcx.item_variance_map.borrow_mut();\n     lookup_locally_or_in_crate_store(\n         \"item_variance_map\", item_id, item_variance_map.get(),\n         || @csearch::get_item_variances(tcx.cstore, item_id))\n }\n \n /// Records a trait-to-implementation mapping.\n-fn record_trait_implementation(tcx: ctxt,\n+fn record_trait_implementation(tcx: &ctxt,\n                                trait_def_id: DefId,\n                                implementation: @Impl) {\n     let implementation_list;\n@@ -4677,7 +4675,7 @@ fn record_trait_implementation(tcx: ctxt,\n \n /// Populates the type context with all the implementations for the given type\n /// if necessary.\n-pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n+pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n                                                       type_id: ast::DefId) {\n     if type_id.krate == LOCAL_CRATE {\n         return\n@@ -4745,7 +4743,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n /// Populates the type context with all the implementations for the given\n /// trait if necessary.\n pub fn populate_implementations_for_trait_if_necessary(\n-        tcx: ctxt,\n+        tcx: &ctxt,\n         trait_id: ast::DefId) {\n     if trait_id.krate == LOCAL_CRATE {\n         return\n@@ -4787,7 +4785,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n /// Given the def_id of an impl, return the def_id of the trait it implements.\n /// If it implements no trait, return `None`.\n-pub fn trait_id_of_impl(tcx: ctxt,\n+pub fn trait_id_of_impl(tcx: &ctxt,\n                         def_id: ast::DefId) -> Option<ast::DefId> {\n     let node = match tcx.map.find(def_id.node) {\n         Some(node) => node,\n@@ -4809,7 +4807,7 @@ pub fn trait_id_of_impl(tcx: ctxt,\n /// If the given def ID describes a method belonging to a trait (either a\n /// default method or an implementation of a trait method), return the ID of\n /// the trait that the method belongs to. Otherwise, return `None`.\n-pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n+pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n                        -> Option<ast::DefId> {\n     if def_id.krate != LOCAL_CRATE {\n         return csearch::get_trait_of_method(tcx.cstore, def_id, tcx);\n@@ -4836,7 +4834,7 @@ pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n /// is already that of the original trait method, then the return value is\n /// the same).\n /// Otherwise, return `None`.\n-pub fn trait_method_of_method(tcx: ctxt,\n+pub fn trait_method_of_method(tcx: &ctxt,\n                               def_id: ast::DefId) -> Option<ast::DefId> {\n     let method;\n     {\n@@ -4860,7 +4858,7 @@ pub fn trait_method_of_method(tcx: ctxt,\n \n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n-pub fn hash_crate_independent(tcx: ctxt, t: t, svh: &Svh) -> u64 {\n+pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n     macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n     macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n@@ -5014,7 +5012,7 @@ impl Variance {\n }\n \n pub fn construct_parameter_environment(\n-    tcx: ctxt,\n+    tcx: &ctxt,\n     self_bound: Option<@TraitRef>,\n     item_type_params: &[TypeParameterDef],\n     method_type_params: &[TypeParameterDef],"}, {"sha": "2456c6073177d89aafa962ef24ad29ed42112e29", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -16,7 +16,7 @@ use util::ppaux::Repr;\n use std::vec_ng::Vec;\n \n pub trait TypeFolder {\n-    fn tcx(&self) -> ty::ctxt;\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n \n     fn fold_ty(&mut self, t: ty::t) -> ty::t {\n         super_fold_ty(self, t)\n@@ -93,7 +93,8 @@ pub fn fold_ty_vec<T:TypeFolder>(this: &mut T, tys: &[ty::t]) -> Vec<ty::t> {\n pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n                                    t: ty::t)\n                                    -> ty::t {\n-    ty::mk_t(this.tcx(), this.fold_sty(&ty::get(t).sty))\n+    let sty = this.fold_sty(&ty::get(t).sty);\n+    ty::mk_t(this.tcx(), sty)\n }\n \n pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n@@ -218,12 +219,12 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n // Some sample folders\n \n pub struct BottomUpFolder<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     fldop: 'a |ty::t| -> ty::t,\n }\n \n impl<'a> TypeFolder for BottomUpFolder<'a> {\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n         let t1 = super_fold_ty(self, ty);\n@@ -235,13 +236,13 @@ impl<'a> TypeFolder for BottomUpFolder<'a> {\n // Region folder\n \n pub struct RegionFolder<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     fld_t: 'a |ty::t| -> ty::t,\n     fld_r: 'a |ty::Region| -> ty::Region,\n }\n \n impl<'a> RegionFolder<'a> {\n-    pub fn general(tcx: ty::ctxt,\n+    pub fn general(tcx: &'a ty::ctxt,\n                    fld_r: 'a |ty::Region| -> ty::Region,\n                    fld_t: 'a |ty::t| -> ty::t)\n                    -> RegionFolder<'a> {\n@@ -252,7 +253,7 @@ impl<'a> RegionFolder<'a> {\n         }\n     }\n \n-    pub fn regions(tcx: ty::ctxt, fld_r: 'a |ty::Region| -> ty::Region)\n+    pub fn regions(tcx: &'a ty::ctxt, fld_r: 'a |ty::Region| -> ty::Region)\n                    -> RegionFolder<'a> {\n         fn noop(t: ty::t) -> ty::t { t }\n \n@@ -265,7 +266,7 @@ impl<'a> RegionFolder<'a> {\n }\n \n impl<'a> TypeFolder for RegionFolder<'a> {\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n         debug!(\"RegionFolder.fold_ty({})\", ty.repr(self.tcx()));"}, {"sha": "5e8d5917dca3ed823d508f5cb315190a51d0d3ff", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -69,15 +69,15 @@ use syntax::opt_vec;\n use syntax::print::pprust::{lifetime_to_str, path_to_str};\n \n pub trait AstConv {\n-    fn tcx(&self) -> ty::ctxt;\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty;\n     fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef;\n \n     // what type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> ty::t;\n }\n \n-pub fn ast_region_to_region(tcx: ty::ctxt, lifetime: &ast::Lifetime)\n+pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n                             -> ty::Region {\n     let named_region_map = tcx.named_region_map.borrow();\n     let r = match named_region_map.get().find(&lifetime.id) {\n@@ -304,7 +304,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n pub static NO_REGIONS: uint = 1;\n pub static NO_TPS: uint = 2;\n \n-fn check_path_args(tcx: ty::ctxt,\n+fn check_path_args(tcx: &ty::ctxt,\n                    path: &ast::Path,\n                    flags: uint) {\n     if (flags & NO_TPS) != 0u {\n@@ -324,7 +324,7 @@ fn check_path_args(tcx: ty::ctxt,\n     }\n }\n \n-pub fn ast_ty_to_prim_ty(tcx: ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n+pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n             let def_map = tcx.def_map.borrow();\n@@ -393,7 +393,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         VStore(ty::vstore)\n     }\n     impl PointerTy {\n-        fn expect_vstore(&self, tcx: ty::ctxt, span: Span, ty: &str) -> ty::vstore {\n+        fn expect_vstore(&self, tcx: &ty::ctxt, span: Span, ty: &str) -> ty::vstore {\n             match *self {\n                 Box => {\n                     tcx.sess.span_err(span, format!(\"managed {} are not supported\", ty));\n@@ -614,7 +614,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 }\n             }\n             ast::TyFixedLengthVec(ty, e) => {\n-                match const_eval::eval_const_expr_partial(&tcx, e) {\n+                match const_eval::eval_const_expr_partial(tcx, e) {\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n@@ -818,7 +818,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     }\n }\n \n-fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBound>>,\n+fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBound>>,\n                        store: ty::TraitStore)\n                        -> ty::BuiltinBounds {\n     //! Converts a list of bounds from the AST into a `BuiltinBounds`"}, {"sha": "d883ee98796a9543c64ad344be7cbe4a215ad772", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -103,8 +103,8 @@ pub fn check_match(fcx: @FnCtxt,\n     fcx.write_ty(expr.id, result_ty);\n }\n \n-pub struct pat_ctxt {\n-    fcx: @FnCtxt,\n+pub struct pat_ctxt<'a> {\n+    fcx: @FnCtxt<'a>,\n     map: PatIdMap,\n }\n "}, {"sha": "60f3e3c2e57e25d77a54b0a779cce58031ab11b6", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -199,7 +199,7 @@ pub fn lookup_in_trait<'a>(\n }\n \n struct LookupContext<'a> {\n-    fcx: @FnCtxt,\n+    fcx: @FnCtxt<'a>,\n     span: Span,\n \n     // The receiver to the method call. Only `None` in the case of\n@@ -1422,11 +1422,11 @@ impl<'a> LookupContext<'a> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn infcx(&'a self) -> &'a infer::InferCtxt {\n+    fn infcx(&'a self) -> &'a infer::InferCtxt<'a> {\n         &self.fcx.inh.infcx\n     }\n \n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx(&'a self) -> &'a ty::ctxt {\n         self.fcx.tcx()\n     }\n \n@@ -1445,7 +1445,7 @@ impl<'a> LookupContext<'a> {\n }\n \n impl Repr for Candidate {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, origin={:?})\",\n                 self.rcvr_match_condition.repr(tcx),\n                 self.rcvr_substs.repr(tcx),\n@@ -1454,7 +1454,7 @@ impl Repr for Candidate {\n }\n \n impl Repr for RcvrMatchCondition {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             RcvrMatchesIfObject(d) => {\n                 format!(\"RcvrMatchesIfObject({})\", d.repr(tcx))"}, {"sha": "44b633e1486d7e867fc8ba203e3719980fb0312e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -155,8 +155,8 @@ pub mod method;\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n-pub struct Inherited {\n-    infcx: infer::InferCtxt,\n+pub struct Inherited<'a> {\n+    infcx: infer::InferCtxt<'a>,\n     locals: @RefCell<NodeMap<ty::t>>,\n     param_env: ty::ParameterEnvironment,\n \n@@ -221,7 +221,7 @@ enum IsBinopAssignment{\n }\n \n #[deriving(Clone)]\n-pub struct FnCtxt {\n+pub struct FnCtxt<'a> {\n     // Number of errors that had been reported when we started\n     // checking this function. On exit, if we find that *more* errors\n     // have been reported, we will skip regionck and other work that\n@@ -251,15 +251,15 @@ pub struct FnCtxt {\n     // function return type.\n     fn_kind: FnKind,\n \n-    inh: @Inherited,\n+    inh: @Inherited<'a>,\n \n-    ccx: @CrateCtxt,\n+    ccx: @CrateCtxt<'a>,\n }\n \n-impl Inherited {\n-    fn new(tcx: ty::ctxt,\n+impl<'a> Inherited<'a> {\n+    fn new(tcx: &'a ty::ctxt,\n            param_env: ty::ParameterEnvironment)\n-           -> Inherited {\n+           -> Inherited<'a> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n             locals: @RefCell::new(NodeMap::new()),\n@@ -275,10 +275,10 @@ impl Inherited {\n }\n \n // Used by check_const and check_enum_variants\n-pub fn blank_fn_ctxt(ccx: @CrateCtxt,\n-                     rty: ty::t,\n-                     region_bnd: ast::NodeId)\n-                     -> @FnCtxt {\n+pub fn blank_fn_ctxt<'a>(ccx: @CrateCtxt<'a>,\n+                         rty: ty::t,\n+                         region_bnd: ast::NodeId)\n+                         -> @FnCtxt<'a> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n@@ -295,19 +295,19 @@ pub fn blank_fn_ctxt(ccx: @CrateCtxt,\n     }\n }\n \n-impl ExprTyProvider for FnCtxt {\n+impl<'a> ExprTyProvider for FnCtxt<'a> {\n     fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n         self.expr_ty(ex)\n     }\n \n-    fn ty_ctxt(&self) -> ty::ctxt {\n+    fn ty_ctxt<'a>(&'a self) -> &'a ty::ctxt {\n         self.ccx.tcx\n     }\n }\n \n-struct CheckItemTypesVisitor { ccx: @CrateCtxt }\n+struct CheckItemTypesVisitor<'a> { ccx: @CrateCtxt<'a> }\n \n-impl Visitor<()> for CheckItemTypesVisitor {\n+impl<'a> Visitor<()> for CheckItemTypesVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         check_item(self.ccx, i);\n         visit::walk_item(self, i, ());\n@@ -340,12 +340,11 @@ fn check_bare_fn(ccx: @CrateCtxt,\n     }\n }\n \n-struct GatherLocalsVisitor {\n-                     fcx: @FnCtxt,\n-                     tcx: ty::ctxt,\n+struct GatherLocalsVisitor<'a> {\n+    fcx: @FnCtxt<'a>\n }\n \n-impl GatherLocalsVisitor {\n+impl<'a> GatherLocalsVisitor<'a> {\n     fn assign(&mut self, nid: ast::NodeId, ty_opt: Option<ty::t>) {\n             match ty_opt {\n                 None => {\n@@ -364,7 +363,7 @@ impl GatherLocalsVisitor {\n     }\n }\n \n-impl Visitor<()> for GatherLocalsVisitor {\n+impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n         // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &ast::Local, _: ()) {\n             let o_ty = match local.ty.node {\n@@ -416,14 +415,14 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n }\n \n-fn check_fn(ccx: @CrateCtxt,\n-            purity: ast::Purity,\n-            fn_sig: &ty::FnSig,\n-            decl: &ast::FnDecl,\n-            id: ast::NodeId,\n-            body: &ast::Block,\n-            fn_kind: FnKind,\n-            inherited: @Inherited) -> @FnCtxt\n+fn check_fn<'a>(ccx: @CrateCtxt<'a>,\n+                purity: ast::Purity,\n+                fn_sig: &ty::FnSig,\n+                decl: &ast::FnDecl,\n+                id: ast::NodeId,\n+                body: &ast::Block,\n+                fn_kind: FnKind,\n+                inherited: @Inherited<'a>) -> @FnCtxt<'a>\n {\n     /*!\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n@@ -467,7 +466,7 @@ fn check_fn(ccx: @CrateCtxt,\n \n     {\n \n-        let mut visit = GatherLocalsVisitor { fcx: fcx, tcx: tcx, };\n+        let mut visit = GatherLocalsVisitor { fcx: fcx, };\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n@@ -512,8 +511,8 @@ fn check_fn(ccx: @CrateCtxt,\n     fcx\n }\n \n-pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n-                                 fields: Vec<(ast::Ident, Span)> ) {\n+pub fn check_no_duplicate_fields(tcx: &ty::ctxt,\n+                                 fields: Vec<(ast::Ident, Span)>) {\n     let mut field_names = HashMap::new();\n \n     for p in fields.iter() {\n@@ -769,7 +768,7 @@ fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n  * - trait_m: the method in the trait\n  * - trait_substs: the substitutions used on the type of the trait\n  */\n-fn compare_impl_method(tcx: ty::ctxt,\n+fn compare_impl_method(tcx: &ty::ctxt,\n                        impl_generics: &ty::Generics,\n                        impl_m: @ty::Method,\n                        impl_m_span: Span,\n@@ -956,8 +955,8 @@ fn compare_impl_method(tcx: ty::ctxt,\n     }\n }\n \n-impl AstConv for FnCtxt {\n-    fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n+impl<'a> AstConv for FnCtxt<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.ccx.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         ty::lookup_item_type(self.tcx(), id)\n@@ -972,8 +971,8 @@ impl AstConv for FnCtxt {\n     }\n }\n \n-impl FnCtxt {\n-    pub fn infcx<'a>(&'a self) -> &'a infer::InferCtxt {\n+impl<'a> FnCtxt<'a> {\n+    pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a> {\n         &self.inh.infcx\n     }\n \n@@ -989,7 +988,7 @@ impl FnCtxt {\n     }\n }\n \n-impl RegionScope for infer::InferCtxt {\n+impl<'a> RegionScope for infer::InferCtxt<'a> {\n     fn anon_regions(&self, span: Span, count: uint)\n                     -> Result<Vec<ty::Region> , ()> {\n         Ok(Vec::from_fn(count, |_| {\n@@ -998,7 +997,7 @@ impl RegionScope for infer::InferCtxt {\n     }\n }\n \n-impl FnCtxt {\n+impl<'a> FnCtxt<'a> {\n     pub fn tag(&self) -> ~str {\n         format!(\"{}\", self as *FnCtxt)\n     }\n@@ -1444,7 +1443,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n \n // Only for fields! Returns <none> for methods>\n // Indifferent to privacy flags\n-pub fn lookup_field_ty(tcx: ty::ctxt,\n+pub fn lookup_field_ty(tcx: &ty::ctxt,\n                        class_id: ast::DefId,\n                        items: &[ty::field_ty],\n                        fieldname: ast::Name,\n@@ -1463,7 +1462,7 @@ pub enum DerefArgs {\n \n // Given the provenance of a static method, returns the generics of the static\n // method's container.\n-fn generics_of_static_method_container(type_context: ty::ctxt,\n+fn generics_of_static_method_container(type_context: &ty::ctxt,\n                                        provenance: ast::MethodProvenance)\n                                        -> ty::Generics {\n     match provenance {\n@@ -3413,7 +3412,7 @@ pub fn check_const_with_ty(fcx: @FnCtxt,\n /// pointer, which would mean their size is unbounded. This is different from\n /// the question of whether a type can be instantiated. See the definition of\n /// `check_instantiable`.\n-pub fn check_representable(tcx: ty::ctxt,\n+pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n                            designation: &str) {\n@@ -3446,7 +3445,7 @@ pub fn check_representable(tcx: ty::ctxt,\n ///     enum foo { Some(@foo) }\n ///\n /// is representable, but not instantiable.\n-pub fn check_instantiable(tcx: ty::ctxt,\n+pub fn check_instantiable(tcx: &ty::ctxt,\n                           sp: Span,\n                           item_id: ast::NodeId) {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n@@ -3458,7 +3457,7 @@ pub fn check_instantiable(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_simd(tcx: ty::ctxt, sp: Span, id: ast::NodeId) {\n+pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     let t = ty::node_id_to_type(tcx, id);\n     if ty::type_needs_subst(t) {\n         tcx.sess.span_err(sp, \"SIMD vector cannot be generic\");\n@@ -3550,7 +3549,7 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n                     // that the expression is in an form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n \n-                    match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n+                    match const_eval::eval_const_expr_partial(ccx.tcx, e) {\n                         Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                         Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n@@ -3939,7 +3938,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(cx: ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n+pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(b, |e| {"}, {"sha": "61243cb4ed1ed61228c2767660aebd45616ec16f", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -154,15 +154,15 @@ macro_rules! ignore_err(\n     )\n )\n \n-pub struct Rcx {\n-    fcx: @FnCtxt,\n+pub struct Rcx<'a> {\n+    fcx: &'a FnCtxt<'a>,\n     errors_reported: uint,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n }\n \n-fn region_of_def(fcx: @FnCtxt, def: ast::Def) -> ty::Region {\n+fn region_of_def(fcx: &FnCtxt, def: ast::Def) -> ty::Region {\n     /*!\n      * Returns the validity region of `def` -- that is, how long\n      * is `def` valid?\n@@ -187,8 +187,8 @@ fn region_of_def(fcx: @FnCtxt, def: ast::Def) -> ty::Region {\n     }\n }\n \n-impl Rcx {\n-    pub fn tcx(&self) -> ty::ctxt {\n+impl<'a> Rcx<'a> {\n+    pub fn tcx(&self) -> &'a ty::ctxt {\n         self.fcx.ccx.tcx\n     }\n \n@@ -198,7 +198,7 @@ impl Rcx {\n         old_scope\n     }\n \n-    pub fn resolve_type(&mut self, unresolved_ty: ty::t) -> ty::t {\n+    pub fn resolve_type(&self, unresolved_ty: ty::t) -> ty::t {\n         /*!\n          * Try to resolve the type for the given node, returning\n          * t_err if an error results.  Note that we never care\n@@ -240,7 +240,7 @@ impl Rcx {\n         self.resolve_type(t)\n     }\n \n-    fn resolve_method_type(&mut self, method_call: MethodCall) -> Option<ty::t> {\n+    fn resolve_method_type(&self, method_call: MethodCall) -> Option<ty::t> {\n         let method_ty = self.fcx.inh.method_map.borrow().get()\n                             .find(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n@@ -260,8 +260,8 @@ impl Rcx {\n     }\n }\n \n-impl<'a> mc::Typer for &'a mut Rcx {\n-    fn tcx(&self) -> ty::ctxt {\n+impl<'a, 'b> mc::Typer for &'a mut Rcx<'b> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.fcx.tcx()\n     }\n \n@@ -270,7 +270,7 @@ impl<'a> mc::Typer for &'a mut Rcx {\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n \n-    fn node_method_ty(&mut self, method_call: MethodCall) -> Option<ty::t> {\n+    fn node_method_ty(&self, method_call: MethodCall) -> Option<ty::t> {\n         self.resolve_method_type(method_call)\n     }\n \n@@ -315,7 +315,7 @@ pub fn regionck_fn(fcx: @FnCtxt, blk: &ast::Block) {\n     fcx.infcx().resolve_regions();\n }\n \n-impl Visitor<()> for Rcx {\n+impl<'a> Visitor<()> for Rcx<'a> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the"}, {"sha": "45eab7c7e62fde5608c5673aa4c2e9945e64a51c", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -22,7 +22,7 @@ use util::ppaux;\n // Helper functions related to manipulating region types.\n \n pub fn replace_late_bound_regions_in_fn_sig(\n-        tcx: ty::ctxt,\n+        tcx: &ty::ctxt,\n         fn_sig: &ty::FnSig,\n         mapf: |ty::BoundRegion| -> ty::Region)\n         -> (HashMap<ty::BoundRegion,ty::Region>, ty::FnSig) {\n@@ -45,7 +45,7 @@ pub fn replace_late_bound_regions_in_fn_sig(\n     (map, fn_sig)\n }\n \n-pub fn relate_nested_regions(tcx: ty::ctxt,\n+pub fn relate_nested_regions(tcx: &ty::ctxt,\n                              opt_region: Option<ty::Region>,\n                              ty: ty::t,\n                              relate_op: |ty::Region, ty::Region|) {\n@@ -85,8 +85,8 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n     rr.fold_ty(ty);\n \n     struct RegionRelator<'a> {\n-        tcx: ty::ctxt,\n-        stack: Vec<ty::Region> ,\n+        tcx: &'a ty::ctxt,\n+        stack: Vec<ty::Region>,\n         relate_op: 'a |ty::Region, ty::Region|,\n     }\n \n@@ -95,7 +95,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n     // well.\n \n     impl<'a> TypeFolder for RegionRelator<'a> {\n-        fn tcx(&self) -> ty::ctxt {\n+        fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n             self.tcx\n         }\n \n@@ -134,7 +134,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n     }\n }\n \n-pub fn relate_free_regions(tcx: ty::ctxt, fn_sig: &ty::FnSig) {\n+pub fn relate_free_regions(tcx: &ty::ctxt, fn_sig: &ty::FnSig) {\n     /*!\n      * This function populates the region map's `free_region_map`.\n      * It walks over the transformed self type and argument types"}, {"sha": "30bbdabbc718f42da9c687ed82a9cd872fa25543", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -66,12 +66,12 @@ use syntax::visit::Visitor;\n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n pub struct VtableContext<'a> {\n-    infcx: &'a infer::InferCtxt,\n+    infcx: &'a infer::InferCtxt<'a>,\n     param_env: &'a ty::ParameterEnvironment,\n }\n \n impl<'a> VtableContext<'a> {\n-    pub fn tcx(&self) -> ty::ctxt { self.infcx.tcx }\n+    pub fn tcx(&self) -> &'a ty::ctxt { self.infcx.tcx }\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n@@ -726,7 +726,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     }\n }\n \n-pub fn resolve_impl(tcx: ty::ctxt,\n+pub fn resolve_impl(tcx: &ty::ctxt,\n                     impl_item: &ast::Item,\n                     impl_generics: &ty::Generics,\n                     impl_trait_ref: &ty::TraitRef) {\n@@ -783,7 +783,7 @@ pub fn resolve_impl(tcx: ty::ctxt,\n \n /// Resolve vtables for a method call after typeck has finished.\n /// Used by trans to monomorphize artificial method callees (e.g. drop).\n-pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n+pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n                             substs: &ty::substs) -> Option<vtable_res> {\n     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n     let type_param_defs = generics.type_param_defs.deref();\n@@ -803,7 +803,7 @@ pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n     }\n }\n \n-impl<'a> visit::Visitor<()> for &'a FnCtxt {\n+impl<'a, 'b> visit::Visitor<()> for &'a FnCtxt<'b> {\n     fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n         early_resolve_expr(ex, *self, false);\n         visit::walk_expr(self, ex, ());"}, {"sha": "962c67c42d702099b9abb8b79d60f4ffbcdc02c1", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -254,8 +254,8 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n     }\n }\n \n-struct WbCtxt {\n-    fcx: @FnCtxt,\n+struct WbCtxt<'a> {\n+    fcx: @FnCtxt<'a>,\n \n     // As soon as we hit an error we have to stop resolving\n     // the entire function.\n@@ -338,7 +338,7 @@ fn visit_item(_item: &ast::Item, _wbcx: &mut WbCtxt) {\n     // Ignore items\n }\n \n-impl Visitor<()> for WbCtxt {\n+impl<'a> Visitor<()> for WbCtxt<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) { visit_item(i, self); }\n     fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) { visit_stmt(s, self); }\n     fn visit_expr(&mut self, ex:&ast::Expr, _: ()) { visit_expr(ex, self); }"}, {"sha": "02c90635a21cada7b520cce6f42e489849cf60c9", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -144,13 +144,13 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n     }\n }\n \n-struct CoherenceChecker {\n-    crate_context: @CrateCtxt,\n-    inference_context: InferCtxt,\n+struct CoherenceChecker<'a> {\n+    crate_context: @CrateCtxt<'a>,\n+    inference_context: InferCtxt<'a>,\n }\n \n struct CoherenceCheckVisitor<'a> {\n-    cc: &'a CoherenceChecker\n+    cc: &'a CoherenceChecker<'a>\n }\n \n impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n@@ -176,7 +176,7 @@ impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n     }\n }\n \n-struct PrivilegedScopeVisitor<'a> { cc: &'a CoherenceChecker }\n+struct PrivilegedScopeVisitor<'a> { cc: &'a CoherenceChecker<'a> }\n \n impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n@@ -226,8 +226,8 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n     }\n }\n \n-impl CoherenceChecker {\n-    fn new(crate_context: @CrateCtxt) -> CoherenceChecker {\n+impl<'a> CoherenceChecker<'a> {\n+    fn new(crate_context: @CrateCtxt<'a>) -> CoherenceChecker<'a> {\n         CoherenceChecker {\n             crate_context: crate_context,\n             inference_context: new_infer_ctxt(crate_context.tcx),\n@@ -762,7 +762,7 @@ impl CoherenceChecker {\n     }\n }\n \n-pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n+pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n                                       impl_id: ast::DefId,\n                                       trait_ref: &ty::TraitRef,\n                                       method: &ty::Method)\n@@ -810,7 +810,7 @@ pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n     };\n }\n \n-fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n+fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n                                      impl_id: ast::DefId,\n                                      trait_ref: &ty::TraitRef,\n                                      new_def_id: ast::DefId,"}, {"sha": "5542c8ec17e56d163ebd8964c438303f72672186", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -61,11 +61,11 @@ use syntax::print::pprust::{path_to_str};\n use syntax::visit;\n use syntax::opt_vec::OptVec;\n \n-struct CollectItemTypesVisitor {\n-    ccx: @CrateCtxt\n+struct CollectItemTypesVisitor<'a> {\n+    ccx: @CrateCtxt<'a>\n }\n \n-impl visit::Visitor<()> for CollectItemTypesVisitor {\n+impl<'a> visit::Visitor<()> for CollectItemTypesVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         convert(self.ccx, i);\n         visit::walk_item(self, i, ());\n@@ -100,14 +100,14 @@ pub trait ToTy {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n }\n \n-impl ToTy for CrateCtxt {\n+impl<'a> ToTy for CrateCtxt<'a> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl AstConv for CrateCtxt {\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+impl<'a> AstConv for CrateCtxt<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         if id.krate != ast::LOCAL_CRATE {"}, {"sha": "f6894f44099889c66865679b5d9c3d669e0f8403", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -70,7 +70,7 @@ use syntax::opt_vec;\n use syntax::abi::AbiSet;\n \n pub trait Combine {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt;\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a>;\n     fn tag(&self) -> ~str;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n@@ -331,7 +331,7 @@ pub trait Combine {\n }\n \n pub struct CombineFields<'a> {\n-    infcx: &'a InferCtxt,\n+    infcx: &'a InferCtxt<'a>,\n     a_is_expected: bool,\n     trace: TypeTrace,\n }"}, {"sha": "b0cd5e361e9acd8e8db7e0aa1b8544580d4bc7f3", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -150,7 +150,7 @@ trait ErrorReportingHelpers {\n                                 generics: ast::Generics);\n }\n \n-impl ErrorReporting for InferCtxt {\n+impl<'a> ErrorReporting for InferCtxt<'a> {\n     fn report_region_errors(&self,\n                             errors: &OptVec<RegionResolutionError>) {\n         let p_errors = self.process_errors(errors);\n@@ -255,7 +255,7 @@ impl ErrorReporting for InferCtxt {\n             scope_id: ast::NodeId\n         }\n \n-        fn free_regions_from_same_fn(tcx: ty::ctxt,\n+        fn free_regions_from_same_fn(tcx: &ty::ctxt,\n                                      sub: Region,\n                                      sup: Region)\n                                      -> Option<FreeRegionsFromSameFn> {\n@@ -672,7 +672,7 @@ impl ErrorReporting for InferCtxt {\n }\n \n struct Rebuilder<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     fn_decl: ast::P<ast::FnDecl>,\n     generics: &'a ast::Generics,\n     same_regions: &'a [SameRegions],\n@@ -682,7 +682,7 @@ struct Rebuilder<'a> {\n }\n \n impl<'a> Rebuilder<'a> {\n-    fn new(tcx: ty::ctxt,\n+    fn new(tcx: &'a ty::ctxt,\n            fn_decl: ast::P<ast::FnDecl>,\n            generics: &'a ast::Generics,\n            same_regions: &'a [SameRegions])\n@@ -1006,7 +1006,7 @@ impl<'a> Rebuilder<'a> {\n     }\n }\n \n-impl ErrorReportingHelpers for InferCtxt {\n+impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n     fn give_expl_lifetime_param(&self,\n                                 inputs: Vec<ast::Arg>,\n                                 output: ast::P<ast::Ty>,"}, {"sha": "e846e3621bd46137fee75ea740fcd9aceb0f7f75", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -35,7 +35,7 @@ impl<'f> Glb<'f> {\n }\n \n impl<'f> Combine for Glb<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }"}, {"sha": "e63ad7322b9aebfb2dd5b533fdcb47985a305602", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -38,7 +38,7 @@ impl<'f> Lub<'f> {\n }\n \n impl<'f> Combine for Lub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }"}, {"sha": "07948477800a18637bff9fb2f86bd8776e371716", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -75,8 +75,8 @@ pub type ures = cres<()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n pub type CoerceResult = cres<Option<@ty::AutoAdjustment>>;\n \n-pub struct InferCtxt {\n-    tcx: ty::ctxt,\n+pub struct InferCtxt<'a> {\n+    tcx: &'a ty::ctxt,\n \n     // We instantiate ValsAndBindings with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n@@ -95,7 +95,7 @@ pub struct InferCtxt {\n     float_var_counter: Cell<uint>,\n \n     // For region variables.\n-    region_vars: RegionVarBindings,\n+    region_vars: RegionVarBindings<'a>,\n }\n \n /// Why did we require that the two types be related?\n@@ -267,7 +267,7 @@ fn new_ValsAndBindings<V:Clone,T:Clone>() -> ValsAndBindings<V, T> {\n     }\n }\n \n-pub fn new_infer_ctxt(tcx: ty::ctxt) -> InferCtxt {\n+pub fn new_infer_ctxt<'a>(tcx: &'a ty::ctxt) -> InferCtxt<'a> {\n     InferCtxt {\n         tcx: tcx,\n \n@@ -510,7 +510,7 @@ pub struct Snapshot {\n     region_vars_snapshot: uint,\n }\n \n-impl InferCtxt {\n+impl<'a> InferCtxt<'a> {\n     pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace)\n                               -> CombineFields<'a> {\n         CombineFields {infcx: self,\n@@ -609,7 +609,7 @@ fn next_simple_var<V:Clone,T:Clone>(counter: &mut uint,\n     return id;\n }\n \n-impl InferCtxt {\n+impl<'a> InferCtxt<'a> {\n     pub fn next_ty_var_id(&self) -> TyVid {\n         let id = self.ty_var_counter.get();\n         self.ty_var_counter.set(id + 1);\n@@ -840,7 +840,7 @@ impl InferCtxt {\n     }\n }\n \n-pub fn fold_regions_in_sig(tcx: ty::ctxt,\n+pub fn fold_regions_in_sig(tcx: &ty::ctxt,\n                            fn_sig: &ty::FnSig,\n                            fldr: |r: ty::Region| -> ty::Region)\n                            -> ty::FnSig {\n@@ -854,7 +854,7 @@ impl TypeTrace {\n }\n \n impl Repr for TypeTrace {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"TypeTrace({})\", self.origin.repr(tcx))\n     }\n }\n@@ -874,7 +874,7 @@ impl TypeOrigin {\n }\n \n impl Repr for TypeOrigin {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             MethodCompatCheck(a) => format!(\"MethodCompatCheck({})\", a.repr(tcx)),\n             ExprAssignable(a) => format!(\"ExprAssignable({})\", a.repr(tcx)),\n@@ -911,7 +911,7 @@ impl SubregionOrigin {\n }\n \n impl Repr for SubregionOrigin {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             Subtype(a) => format!(\"Subtype({})\", a.repr(tcx)),\n             InfStackClosure(a) => format!(\"InfStackClosure({})\", a.repr(tcx)),\n@@ -954,7 +954,7 @@ impl RegionVariableOrigin {\n }\n \n impl Repr for RegionVariableOrigin {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             MiscVariable(a) => format!(\"MiscVariable({})\", a.repr(tcx)),\n             PatternRegion(a) => format!(\"PatternRegion({})\", a.repr(tcx)),"}, {"sha": "415367eea6205f83a008272db3ea1fd602ce32fb", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -123,9 +123,9 @@ impl SameRegions {\n \n pub type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n-pub struct RegionVarBindings {\n-    tcx: ty::ctxt,\n-    var_origins: RefCell<Vec<RegionVariableOrigin> >,\n+pub struct RegionVarBindings<'a> {\n+    tcx: &'a ty::ctxt,\n+    var_origins: RefCell<Vec<RegionVariableOrigin>>,\n     constraints: RefCell<HashMap<Constraint, SubregionOrigin>>,\n     lubs: RefCell<CombineMap>,\n     glbs: RefCell<CombineMap>,\n@@ -147,7 +147,7 @@ pub struct RegionVarBindings {\n     values: RefCell<Option<Vec<VarValue> >>,\n }\n \n-pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n+pub fn RegionVarBindings<'a>(tcx: &'a ty::ctxt) -> RegionVarBindings<'a> {\n     RegionVarBindings {\n         tcx: tcx,\n         var_origins: RefCell::new(Vec::new()),\n@@ -161,7 +161,7 @@ pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     }\n }\n \n-impl RegionVarBindings {\n+impl<'a> RegionVarBindings<'a> {\n     pub fn in_snapshot(&self) -> bool {\n         let undo_log = self.undo_log.borrow();\n         undo_log.get().len() > 0\n@@ -572,7 +572,7 @@ impl RegionVarBindings {\n     }\n }\n \n-impl RegionVarBindings {\n+impl<'a> RegionVarBindings<'a> {\n     fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n         self.tcx.region_maps.is_subregion_of(sub, sup)\n     }\n@@ -814,7 +814,7 @@ struct RegionAndOrigin {\n \n type RegionGraph = graph::Graph<(), Constraint>;\n \n-impl RegionVarBindings {\n+impl<'a> RegionVarBindings<'a> {\n     fn infer_variable_values(&self,\n                              errors: &mut OptVec<RegionResolutionError>)\n                              -> Vec<VarValue> {\n@@ -1359,7 +1359,7 @@ impl RegionVarBindings {\n }\n \n impl Repr for Constraint {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             ConstrainVarSubVar(a, b) => format!(\"ConstrainVarSubVar({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),"}, {"sha": "f91e20a649b560acec8cb1d435711f9fd212c06a", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -81,7 +81,7 @@ pub static resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n pub struct ResolveState<'a> {\n-    infcx: &'a InferCtxt,\n+    infcx: &'a InferCtxt<'a>,\n     modes: uint,\n     err: Option<fixup_err>,\n     v_seen: Vec<TyVid> ,\n@@ -99,7 +99,7 @@ pub fn resolver<'a>(infcx: &'a InferCtxt, modes: uint) -> ResolveState<'a> {\n }\n \n impl<'a> ty_fold::TypeFolder for ResolveState<'a> {\n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.infcx.tcx\n     }\n "}, {"sha": "ef17a593654842dbc0666162bd45ba52f6685d90", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -34,7 +34,7 @@ impl<'f> Sub<'f> {\n }\n \n impl<'f> Combine for Sub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }"}, {"sha": "57a08d211c76c346724309bea0f7249a2c2d17f4", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -61,7 +61,7 @@ pub trait UnifyInferCtxtMethods {\n              -> (V, uint);\n }\n \n-impl UnifyInferCtxtMethods for InferCtxt {\n+impl<'a> UnifyInferCtxtMethods for InferCtxt<'a> {\n     fn get<T:Clone,\n            V:Clone + Eq + Vid + UnifyVid<T>>(\n            &self,\n@@ -80,7 +80,7 @@ impl UnifyInferCtxtMethods for InferCtxt {\n         return helper(tcx, vb.get(), vid);\n \n         fn helper<T:Clone, V:Clone+Eq+Vid>(\n-            tcx: ty::ctxt,\n+            tcx: &ty::ctxt,\n             vb: &mut ValsAndBindings<V,T>,\n             vid: V) -> Node<V, T>\n         {\n@@ -200,7 +200,7 @@ pub trait InferCtxtMethods {\n                     -> ures;\n }\n \n-impl InferCtxtMethods for InferCtxt {\n+impl<'a> InferCtxtMethods for InferCtxt<'a> {\n     fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n                    &self,"}, {"sha": "d992337f9685975c58111637cc3d1f3e097c2830", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -200,7 +200,7 @@ pub enum vtable_origin {\n }\n \n impl Repr for vtable_origin {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n                 format!(\"vtable_static({:?}:{}, {}, {})\",\n@@ -232,7 +232,7 @@ pub struct impl_res {\n }\n \n impl Repr for impl_res {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"impl_res \\\\{trait_vtables={}, self_vtables={}\\\\}\",\n              self.trait_vtables.repr(tcx),\n              self.self_vtables.repr(tcx))\n@@ -241,22 +241,22 @@ impl Repr for impl_res {\n \n pub type impl_vtable_map = RefCell<DefIdMap<impl_res>>;\n \n-pub struct CrateCtxt {\n+pub struct CrateCtxt<'a> {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: resolve::TraitMap,\n     method_map: MethodMap,\n     vtable_map: vtable_map,\n-    tcx: ty::ctxt\n+    tcx: &'a ty::ctxt\n }\n \n // Functions that write types into the node type table\n-pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n+pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_str(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     let mut node_types = tcx.node_types.borrow_mut();\n     node_types.get().insert(node_id as uint, ty);\n }\n-pub fn write_substs_to_tcx(tcx: ty::ctxt,\n+pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n                            node_id: ast::NodeId,\n                            substs: Vec<ty::t> ) {\n     if substs.len() > 0u {\n@@ -268,7 +268,7 @@ pub fn write_substs_to_tcx(tcx: ty::ctxt,\n         node_type_substs.get().insert(node_id, substs);\n     }\n }\n-pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n+pub fn write_tpt_to_tcx(tcx: &ty::ctxt,\n                         node_id: ast::NodeId,\n                         tpt: &ty::ty_param_substs_and_ty) {\n     write_ty_to_tcx(tcx, node_id, tpt.ty);\n@@ -277,7 +277,7 @@ pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n     }\n }\n \n-pub fn lookup_def_tcx(tcx: ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     let def_map = tcx.def_map.borrow();\n     match def_map.get().find(&id) {\n         Some(&x) => x,\n@@ -300,7 +300,7 @@ pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     }\n }\n \n-pub fn require_same_types(tcx: ty::ctxt,\n+pub fn require_same_types(tcx: &ty::ctxt,\n                           maybe_infcx: Option<&infer::InferCtxt>,\n                           t1_is_expected: bool,\n                           span: Span,\n@@ -457,7 +457,7 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    trait_map: resolve::TraitMap,\n                    krate: &ast::Crate)\n                 -> (MethodMap, vtable_map) {"}, {"sha": "468d97a83925f20d89dd2e71d951cfde21d46e2b", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -205,7 +205,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use util::ppaux::Repr;\n \n-pub fn infer_variance(tcx: ty::ctxt,\n+pub fn infer_variance(tcx: &ty::ctxt,\n                       krate: &ast::Crate) {\n     let mut arena = arena::Arena::new();\n     let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, krate);\n@@ -251,7 +251,7 @@ impl<'a> fmt::Show for VarianceTerm<'a> {\n  */\n \n struct TermsContext<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     arena: &'a Arena,\n \n     empty_variances: @ty::ItemVariances,\n@@ -274,7 +274,7 @@ struct InferredInfo<'a> {\n     term: VarianceTermPtr<'a>,\n }\n \n-fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n+fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n                                            arena: &'a mut Arena,\n                                            krate: &ast::Crate)\n                                            -> TermsContext<'a> {\n@@ -522,7 +522,7 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n }\n \n impl<'a> ConstraintContext<'a> {\n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx(&self) -> &'a ty::ctxt {\n         self.terms_cx.tcx\n     }\n "}, {"sha": "b80fb2fa491f867809a4aa958a6b99d2a269c17d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b1fee898f03b50113549b74da4c6d19eca4728e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9b1fee898f03b50113549b74da4c6d19eca4728e", "patch": "@@ -35,15 +35,15 @@ use syntax::opt_vec::OptVec;\n \n /// Produces a string suitable for debugging output.\n pub trait Repr {\n-    fn repr(&self, tcx: ctxt) -> ~str;\n+    fn repr(&self, tcx: &ctxt) -> ~str;\n }\n \n /// Produces a string suitable for showing to the user.\n pub trait UserString {\n-    fn user_string(&self, tcx: ctxt) -> ~str;\n+    fn user_string(&self, tcx: &ctxt) -> ~str;\n }\n \n-pub fn note_and_explain_region(cx: ctxt,\n+pub fn note_and_explain_region(cx: &ctxt,\n                                prefix: &str,\n                                region: ty::Region,\n                                suffix: &str) {\n@@ -62,13 +62,13 @@ pub fn note_and_explain_region(cx: ctxt,\n \n /// Returns a string like \"the block at 27:31\" that attempts to explain a\n /// lifetime in a way it might plausibly be understood.\n-pub fn explain_region(cx: ctxt, region: ty::Region) -> ~str {\n+pub fn explain_region(cx: &ctxt, region: ty::Region) -> ~str {\n   let (res, _) = explain_region_and_span(cx, region);\n   return res;\n }\n \n \n-pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n+pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n                             -> (~str, Option<Span>) {\n     return match region {\n       ReScope(node_id) => {\n@@ -138,7 +138,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       }\n     };\n \n-    fn explain_span(cx: ctxt, heading: &str, span: Span)\n+    fn explain_span(cx: &ctxt, heading: &str, span: Span)\n         -> (~str, Option<Span>)\n     {\n         let lo = cx.sess.codemap.lookup_char_pos_adj(span.lo);\n@@ -147,11 +147,11 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n     }\n }\n \n-pub fn bound_region_ptr_to_str(cx: ctxt, br: BoundRegion) -> ~str {\n+pub fn bound_region_ptr_to_str(cx: &ctxt, br: BoundRegion) -> ~str {\n     bound_region_to_str(cx, \"&\", true, br)\n }\n \n-pub fn bound_region_to_str(cx: ctxt,\n+pub fn bound_region_to_str(cx: &ctxt,\n                            prefix: &str, space: bool,\n                            br: BoundRegion) -> ~str {\n     let space_str = if space { \" \" } else { \"\" };\n@@ -168,7 +168,7 @@ pub fn bound_region_to_str(cx: ctxt,\n     }\n }\n \n-pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n+pub fn ReScope_id_to_str(cx: &ctxt, node_id: ast::NodeId) -> ~str {\n     match cx.map.find(node_id) {\n       Some(ast_map::NodeBlock(ref blk)) => {\n         format!(\"<block at {}>\",\n@@ -207,11 +207,11 @@ pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n // In general, if you are giving a region error message,\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n-pub fn region_ptr_to_str(cx: ctxt, region: Region) -> ~str {\n+pub fn region_ptr_to_str(cx: &ctxt, region: Region) -> ~str {\n     region_to_str(cx, \"&\", true, region)\n }\n \n-pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~str {\n+pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> ~str {\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n@@ -243,31 +243,31 @@ pub fn mutability_to_str(m: ast::Mutability) -> ~str {\n     }\n }\n \n-pub fn mt_to_str(cx: ctxt, m: &mt) -> ~str {\n+pub fn mt_to_str(cx: &ctxt, m: &mt) -> ~str {\n     mt_to_str_wrapped(cx, \"\", m, \"\")\n }\n \n-pub fn mt_to_str_wrapped(cx: ctxt, before: &str, m: &mt, after: &str) -> ~str {\n+pub fn mt_to_str_wrapped(cx: &ctxt, before: &str, m: &mt, after: &str) -> ~str {\n     let mstr = mutability_to_str(m.mutbl);\n     return format!(\"{}{}{}{}\", mstr, before, ty_to_str(cx, m.ty), after);\n }\n \n-pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n+pub fn vstore_to_str(cx: &ctxt, vs: ty::vstore) -> ~str {\n     match vs {\n       ty::vstore_fixed(n) => format!(\"{}\", n),\n       ty::vstore_uniq => ~\"~\",\n       ty::vstore_slice(r) => region_ptr_to_str(cx, r)\n     }\n }\n \n-pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n+pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> ~str {\n     match s {\n       ty::UniqTraitStore => ~\"~\",\n       ty::RegionTraitStore(r) => region_ptr_to_str(cx, r)\n     }\n }\n \n-pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n+pub fn vstore_ty_to_str(cx: &ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     match vs {\n         ty::vstore_fixed(_) => {\n             format!(\"[{}, .. {}]\", mt_to_str(cx, mt), vstore_to_str(cx, vs))\n@@ -283,26 +283,26 @@ pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> ~str) -> ~str {\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n+pub fn tys_to_str(cx: &ctxt, ts: &[t]) -> ~str {\n     vec_map_to_str(ts, |t| ty_to_str(cx, *t))\n }\n \n-pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n+pub fn fn_sig_to_str(cx: &ctxt, typ: &ty::FnSig) -> ~str {\n     format!(\"fn{}{} -> {}\",\n             typ.binder_id,\n             typ.inputs.repr(cx),\n             typ.output.repr(cx))\n }\n \n-pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n+pub fn trait_ref_to_str(cx: &ctxt, trait_ref: &ty::TraitRef) -> ~str {\n     trait_ref.user_string(cx)\n }\n \n-pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n-    fn fn_input_to_str(cx: ctxt, input: ty::t) -> ~str {\n+pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n+    fn fn_input_to_str(cx: &ctxt, input: ty::t) -> ~str {\n         ty_to_str(cx, input)\n     }\n-    fn bare_fn_to_str(cx: ctxt,\n+    fn bare_fn_to_str(cx: &ctxt,\n                       purity: ast::Purity,\n                       abis: AbiSet,\n                       ident: Option<ast::Ident>,\n@@ -336,7 +336,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n \n         return s;\n     }\n-    fn closure_to_str(cx: ctxt, cty: &ty::ClosureTy) -> ~str {\n+    fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> ~str {\n         let is_proc =\n             (cty.sigil, cty.onceness) == (ast::OwnedSigil, ast::Once);\n         let is_borrowed_closure = cty.sigil == ast::BorrowedSigil;\n@@ -402,7 +402,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n \n         return s;\n     }\n-    fn push_sig_to_str(cx: ctxt,\n+    fn push_sig_to_str(cx: &ctxt,\n                        s: &mut ~str,\n                        bra: char,\n                        ket: char,\n@@ -501,7 +501,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n }\n \n-pub fn parameterized(cx: ctxt,\n+pub fn parameterized(cx: &ctxt,\n                      base: &str,\n                      regions: &ty::RegionSubsts,\n                      tps: &[ty::t],\n@@ -554,14 +554,14 @@ pub fn parameterized(cx: ctxt,\n     }\n }\n \n-pub fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n+pub fn ty_to_short_str(cx: &ctxt, typ: t) -> ~str {\n     let mut s = encoder::encoded_ty(cx, typ);\n     if s.len() >= 32u { s = s.slice(0u, 32u).to_owned(); }\n     return s;\n }\n \n impl<T:Repr> Repr for Option<T> {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match self {\n             &None => ~\"None\",\n             &Some(ref t) => t.repr(tcx),\n@@ -570,7 +570,7 @@ impl<T:Repr> Repr for Option<T> {\n }\n \n impl<T:Repr,U:Repr> Repr for Result<T,U> {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match self {\n             &Ok(ref t) => t.repr(tcx),\n             &Err(ref u) => format!(\"Err({})\", u.repr(tcx))\n@@ -579,35 +579,35 @@ impl<T:Repr,U:Repr> Repr for Result<T,U> {\n }\n \n impl Repr for () {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         ~\"()\"\n     }\n }\n \n impl<T:Repr> Repr for @T {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         (&**self).repr(tcx)\n     }\n }\n \n impl<T:Repr> Repr for ~T {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         (&**self).repr(tcx)\n     }\n }\n \n-fn repr_vec<T:Repr>(tcx: ctxt, v: &[T]) -> ~str {\n+fn repr_vec<T:Repr>(tcx: &ctxt, v: &[T]) -> ~str {\n     vec_map_to_str(v, |t| t.repr(tcx))\n }\n \n impl<'a, T:Repr> Repr for &'a [T] {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         repr_vec(tcx, *self)\n     }\n }\n \n impl<T:Repr> Repr for OptVec<T> {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             opt_vec::Empty => ~\"[]\",\n             opt_vec::Vec(ref v) => repr_vec(tcx, v.as_slice())\n@@ -618,35 +618,35 @@ impl<T:Repr> Repr for OptVec<T> {\n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<T:Repr> Repr for Vec<T> {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n impl Repr for ty::TypeParameterDef {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"TypeParameterDef({:?}, {})\",\n                 self.def_id,\n                 self.bounds.repr(tcx))\n     }\n }\n \n impl Repr for ty::RegionParameterDef {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"RegionParameterDef({}, {:?})\",\n                 token::get_name(self.name),\n                 self.def_id)\n     }\n }\n \n impl Repr for ty::t {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         ty_to_str(tcx, *self)\n     }\n }\n \n impl Repr for ty::substs {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"substs(regions={}, self_ty={}, tps={})\",\n              self.regions.repr(tcx),\n              self.self_ty.repr(tcx),\n@@ -655,7 +655,7 @@ impl Repr for ty::substs {\n }\n \n impl Repr for ty::RegionSubsts {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             ty::ErasedRegions => ~\"erased\",\n             ty::NonerasedRegions(ref regions) => regions.repr(tcx)\n@@ -664,7 +664,7 @@ impl Repr for ty::RegionSubsts {\n }\n \n impl Repr for ty::ParamBounds {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         let mut res = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             res.push(match b {\n@@ -683,41 +683,41 @@ impl Repr for ty::ParamBounds {\n }\n \n impl Repr for ty::TraitRef {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         trait_ref_to_str(tcx, self)\n     }\n }\n \n impl Repr for ast::Expr {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"expr({}: {})\", self.id, pprust::expr_to_str(self))\n     }\n }\n \n impl Repr for ast::Item {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"item({})\", tcx.map.node_to_str(self.id))\n     }\n }\n \n impl Repr for ast::Stmt {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"stmt({}: {})\",\n                 ast_util::stmt_id(self),\n                 pprust::stmt_to_str(self))\n     }\n }\n \n impl Repr for ast::Pat {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"pat({}: {})\",\n              self.id,\n              pprust::pat_to_str(self))\n     }\n }\n \n impl Repr for ty::BoundRegion {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n             ty::BrNamed(id, name) => format!(\"BrNamed({}, {})\",\n@@ -729,7 +729,7 @@ impl Repr for ty::BoundRegion {\n }\n \n impl Repr for ty::Region {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             ty::ReEarlyBound(id, index, name) => {\n                 format!(\"ReEarlyBound({}, {}, {})\",\n@@ -772,7 +772,7 @@ impl Repr for ty::Region {\n }\n \n impl Repr for ast::DefId {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n@@ -798,23 +798,23 @@ impl Repr for ast::DefId {\n }\n \n impl Repr for ty::ty_param_bounds_and_ty {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"ty_param_bounds_and_ty \\\\{generics: {}, ty: {}\\\\}\",\n              self.generics.repr(tcx),\n              self.ty.repr(tcx))\n     }\n }\n \n impl Repr for ty::Generics {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"Generics(type_param_defs: {}, region_param_defs: {})\",\n                 self.type_param_defs().repr(tcx),\n                 self.region_param_defs().repr(tcx))\n     }\n }\n \n impl Repr for ty::ItemVariances {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"IterVariances(self_param={}, type_params={}, region_params={})\",\n                 self.self_param.repr(tcx),\n                 self.type_params.repr(tcx),\n@@ -823,13 +823,13 @@ impl Repr for ty::ItemVariances {\n }\n \n impl Repr for ty::Variance {\n-    fn repr(&self, _: ctxt) -> ~str {\n+    fn repr(&self, _: &ctxt) -> ~str {\n         self.to_str().to_owned()\n     }\n }\n \n impl Repr for ty::Method {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"method(ident: {}, generics: {}, fty: {}, \\\n                 explicit_self: {}, vis: {}, def_id: {})\",\n                 self.ident.repr(tcx),\n@@ -842,31 +842,31 @@ impl Repr for ty::Method {\n }\n \n impl Repr for ast::Name {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         token::get_name(*self).get().to_str()\n     }\n }\n \n impl Repr for ast::Ident {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         token::get_ident(*self).get().to_str()\n     }\n }\n \n impl Repr for ast::ExplicitSelf_ {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ast::Visibility {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BareFnTy {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"BareFnTy \\\\{purity: {:?}, abis: {}, sig: {}\\\\}\",\n              self.purity,\n              self.abis.to_str(),\n@@ -875,13 +875,13 @@ impl Repr for ty::BareFnTy {\n }\n \n impl Repr for ty::FnSig {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         fn_sig_to_str(tcx, self)\n     }\n }\n \n impl Repr for typeck::MethodCallee {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"MethodCallee \\\\{origin: {}, ty: {}, {}\\\\}\",\n             self.origin.repr(tcx),\n             self.ty.repr(tcx),\n@@ -890,7 +890,7 @@ impl Repr for typeck::MethodCallee {\n }\n \n impl Repr for typeck::MethodOrigin {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match self {\n             &typeck::MethodStatic(def_id) => {\n                 format!(\"MethodStatic({})\", def_id.repr(tcx))\n@@ -906,7 +906,7 @@ impl Repr for typeck::MethodOrigin {\n }\n \n impl Repr for typeck::MethodParam {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"MethodParam({},{:?},{:?},{:?})\",\n              self.trait_id.repr(tcx),\n              self.method_num,\n@@ -916,7 +916,7 @@ impl Repr for typeck::MethodParam {\n }\n \n impl Repr for typeck::MethodObject {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"MethodObject({},{:?},{:?})\",\n              self.trait_id.repr(tcx),\n              self.method_num,\n@@ -926,13 +926,13 @@ impl Repr for typeck::MethodObject {\n \n \n impl Repr for ty::RegionVid {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::TraitStore {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match self {\n             &ty::UniqTraitStore => ~\"~Trait\",\n             &ty::RegionTraitStore(r) => format!(\"&{} Trait\", r.repr(tcx))\n@@ -941,19 +941,19 @@ impl Repr for ty::TraitStore {\n }\n \n impl Repr for ty::vstore {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         vstore_to_str(tcx, *self)\n     }\n }\n \n impl Repr for ty::BuiltinBound {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl UserString for ty::BuiltinBound {\n-    fn user_string(&self, _tcx: ctxt) -> ~str {\n+    fn user_string(&self, _tcx: &ctxt) -> ~str {\n         match *self {\n             ty::BoundStatic => ~\"'static\",\n             ty::BoundSend => ~\"Send\",\n@@ -965,26 +965,26 @@ impl UserString for ty::BuiltinBound {\n }\n \n impl Repr for ty::BuiltinBounds {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         self.user_string(tcx)\n     }\n }\n \n impl Repr for Span {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         tcx.sess.codemap.span_to_str(*self)\n     }\n }\n \n impl<A:UserString> UserString for @A {\n-    fn user_string(&self, tcx: ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> ~str {\n         let this: &A = &**self;\n         this.user_string(tcx)\n     }\n }\n \n impl UserString for ty::BuiltinBounds {\n-    fn user_string(&self, tcx: ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> ~str {\n         if self.is_empty() { ~\"<no-bounds>\" } else {\n             let mut result = Vec::new();\n             for bb in self.iter() {\n@@ -996,7 +996,7 @@ impl UserString for ty::BuiltinBounds {\n }\n \n impl UserString for ty::TraitRef {\n-    fn user_string(&self, tcx: ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> ~str {\n         let base = ty::item_path_str(tcx, self.def_id);\n         if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n             let mut all_tps = self.substs.tps.clone();\n@@ -1011,31 +1011,31 @@ impl UserString for ty::TraitRef {\n }\n \n impl UserString for ty::t {\n-    fn user_string(&self, tcx: ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> ~str {\n         ty_to_str(tcx, *self)\n     }\n }\n \n impl UserString for ast::Ident {\n-    fn user_string(&self, _tcx: ctxt) -> ~str {\n+    fn user_string(&self, _tcx: &ctxt) -> ~str {\n         token::get_name(self.name).get().to_owned()\n     }\n }\n \n impl Repr for AbiSet {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         self.to_str()\n     }\n }\n \n impl UserString for AbiSet {\n-    fn user_string(&self, _tcx: ctxt) -> ~str {\n+    fn user_string(&self, _tcx: &ctxt) -> ~str {\n         self.to_str()\n     }\n }\n \n impl Repr for ty::UpvarId {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"UpvarId({};`{}`;{})\",\n              self.var_id,\n              ty::local_var_name_str(tcx, self.var_id),\n@@ -1044,19 +1044,19 @@ impl Repr for ty::UpvarId {\n }\n \n impl Repr for ast::Mutability {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BorrowKind {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::UpvarBorrow {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"UpvarBorrow({}, {})\",\n              self.kind.repr(tcx),\n              self.region.repr(tcx))"}]}