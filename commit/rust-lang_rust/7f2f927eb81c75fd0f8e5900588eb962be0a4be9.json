{"sha": "7f2f927eb81c75fd0f8e5900588eb962be0a4be9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMmY5MjdlYjgxYzc1ZmQwZjhlNTkwMDU4OGViOTYyYmUwYTRiZTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-26T16:01:55Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-09-17T22:42:44Z"}, "message": "ty::layout: propagate errors up to (but not out of) `FnAbi::of_*`.", "tree": {"sha": "2db7ece4d0fd4d766708aef948e35ba621df1ad7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2db7ece4d0fd4d766708aef948e35ba621df1ad7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f2f927eb81c75fd0f8e5900588eb962be0a4be9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2f927eb81c75fd0f8e5900588eb962be0a4be9", "html_url": "https://github.com/rust-lang/rust/commit/7f2f927eb81c75fd0f8e5900588eb962be0a4be9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f2f927eb81c75fd0f8e5900588eb962be0a4be9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d36faf9ef10bda32c606517d0f2007fd53b16ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d36faf9ef10bda32c606517d0f2007fd53b16ac", "html_url": "https://github.com/rust-lang/rust/commit/4d36faf9ef10bda32c606517d0f2007fd53b16ac"}], "stats": {"total": 156, "additions": 129, "deletions": 27}, "files": [{"sha": "e11993c758099c48b667b45f310f5463b4129bde", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 104, "deletions": 25, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7f2f927eb81c75fd0f8e5900588eb962be0a4be9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2f927eb81c75fd0f8e5900588eb962be0a4be9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=7f2f927eb81c75fd0f8e5900588eb962be0a4be9", "patch": "@@ -18,7 +18,7 @@ use rustc_target::abi::call::{\n     ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, Conv, FnAbi, PassMode, Reg, RegKind,\n };\n use rustc_target::abi::*;\n-use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy};\n+use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy, Target};\n \n use std::cmp;\n use std::fmt;\n@@ -2015,6 +2015,12 @@ impl<'tcx> HasDataLayout for TyCtxt<'tcx> {\n     }\n }\n \n+impl<'tcx> HasTargetSpec for TyCtxt<'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.sess.target\n+    }\n+}\n+\n impl<'tcx> HasTyCtxt<'tcx> for TyCtxt<'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -2048,6 +2054,12 @@ impl<'tcx, T: HasDataLayout> HasDataLayout for LayoutCx<'tcx, T> {\n     }\n }\n \n+impl<'tcx, T: HasTargetSpec> HasTargetSpec for LayoutCx<'tcx, T> {\n+    fn target_spec(&self) -> &Target {\n+        self.tcx.target_spec()\n+    }\n+}\n+\n impl<'tcx, T: HasTyCtxt<'tcx>> HasTyCtxt<'tcx> for LayoutCx<'tcx, T> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.tcx()\n@@ -2788,9 +2800,39 @@ pub fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n     }\n }\n \n+/// Error produced by attempting to compute or adjust a `FnAbi`.\n+enum FnAbiError<'tcx> {\n+    /// Error produced by a `layout_of` call, while computing `FnAbi` initially.\n+    Layout(LayoutError<'tcx>),\n+\n+    /// Error produced by attempting to adjust a `FnAbi`, for a \"foreign\" ABI.\n+    AdjustForForeignAbi(call::AdjustForForeignAbiError),\n+}\n+\n+impl From<LayoutError<'tcx>> for FnAbiError<'tcx> {\n+    fn from(err: LayoutError<'tcx>) -> Self {\n+        Self::Layout(err)\n+    }\n+}\n+\n+impl From<call::AdjustForForeignAbiError> for FnAbiError<'_> {\n+    fn from(err: call::AdjustForForeignAbiError) -> Self {\n+        Self::AdjustForForeignAbi(err)\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for FnAbiError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Layout(err) => err.fmt(f),\n+            Self::AdjustForForeignAbi(err) => err.fmt(f),\n+        }\n+    }\n+}\n+\n pub trait FnAbiExt<'tcx, C>\n where\n-    C: LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>> + HasTargetSpec,\n+    C: HasTyCtxt<'tcx> + HasParamEnv<'tcx>,\n {\n     /// Compute a `FnAbi` suitable for indirect calls, i.e. to `fn` pointers.\n     ///\n@@ -2808,10 +2850,26 @@ where\n \n impl<'tcx, C> FnAbiExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n where\n-    C: LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>> + HasTargetSpec,\n+    C: HasTyCtxt<'tcx> + HasParamEnv<'tcx>,\n {\n     fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        call::FnAbi::new_internal(cx, sig, extra_args, None, CodegenFnAttrFlags::empty(), false)\n+        call::FnAbi::new_internal(\n+            &LayoutCx { tcx: cx.tcx(), param_env: cx.param_env() },\n+            sig,\n+            extra_args,\n+            None,\n+            CodegenFnAttrFlags::empty(),\n+            false,\n+        )\n+        .unwrap_or_else(|err| {\n+            // FIXME(eddyb) get a better `span` here.\n+            let span = DUMMY_SP;\n+            if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n+                cx.tcx().sess.span_fatal(span, &err.to_string())\n+            } else {\n+                span_bug!(span, \"`FnAbi::of_fn_ptr({}, {:?})` failed: {}\", sig, extra_args, err);\n+            }\n+        })\n     }\n \n     fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n@@ -2826,35 +2884,57 @@ where\n         let attrs = cx.tcx().codegen_fn_attrs(instance.def_id()).flags;\n \n         call::FnAbi::new_internal(\n-            cx,\n+            &LayoutCx { tcx: cx.tcx(), param_env: cx.param_env() },\n             sig,\n             extra_args,\n             caller_location,\n             attrs,\n             matches!(instance.def, ty::InstanceDef::Virtual(..)),\n         )\n+        .unwrap_or_else(|err| {\n+            // FIXME(eddyb) get a better `span` here.\n+            let span = cx.tcx().def_span(instance.def_id());\n+            if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n+                cx.tcx().sess.span_fatal(span, &err.to_string())\n+            } else {\n+                span_bug!(\n+                    span,\n+                    \"`FnAbi::of_instance({}, {:?})` failed: {}\",\n+                    instance,\n+                    extra_args,\n+                    err\n+                );\n+            }\n+        })\n     }\n }\n \n /// Implementation detail of computing `FnAbi`s, shouldn't be exported.\n-trait FnAbiInternalExt<'tcx, C>\n+// FIXME(eddyb) move this off of being generic on `C: LayoutOf`, and\n+// explicitly take `LayoutCx` *or* `TyCtxt` and `ParamEnvAnd<...>`.\n+trait FnAbiInternalExt<'tcx, C>: Sized\n where\n-    C: LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>> + HasTargetSpec,\n+    C: LayoutOf<'tcx, LayoutOfResult = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>>\n+        + HasTargetSpec,\n {\n+    // FIXME(eddyb) perhaps group the signature/type-containing (or all of them?)\n+    // arguments of this method, into a separate `struct`.\n     fn new_internal(\n         cx: &C,\n         sig: ty::PolyFnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         caller_location: Option<Ty<'tcx>>,\n         codegen_fn_attr_flags: CodegenFnAttrFlags,\n+        // FIXME(eddyb) replace this with something typed, like an `enum`.\n         make_self_ptr_thin: bool,\n-    ) -> Self;\n-    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n+    ) -> Result<Self, FnAbiError<'tcx>>;\n+    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi) -> Result<(), FnAbiError<'tcx>>;\n }\n \n impl<'tcx, C> FnAbiInternalExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n where\n-    C: LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>> + HasTargetSpec,\n+    C: LayoutOf<'tcx, LayoutOfResult = Result<TyAndLayout<'tcx>, LayoutError<'tcx>>>\n+        + HasTargetSpec,\n {\n     fn new_internal(\n         cx: &C,\n@@ -2863,10 +2943,10 @@ where\n         caller_location: Option<Ty<'tcx>>,\n         codegen_fn_attr_flags: CodegenFnAttrFlags,\n         force_thin_self_ptr: bool,\n-    ) -> Self {\n+    ) -> Result<Self, FnAbiError<'tcx>> {\n         debug!(\"FnAbi::new_internal({:?}, {:?})\", sig, extra_args);\n \n-        let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n+        let sig = cx.tcx().normalize_erasing_late_bound_regions(cx.param_env(), sig);\n \n         let conv = conv_from_spec_abi(cx.tcx(), sig.abi);\n \n@@ -2972,10 +3052,10 @@ where\n             }\n         };\n \n-        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n+        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| -> Result<_, FnAbiError<'tcx>> {\n             let is_return = arg_idx.is_none();\n \n-            let layout = cx.layout_of(ty);\n+            let layout = cx.layout_of(ty)?;\n             let layout = if force_thin_self_ptr && arg_idx == Some(0) {\n                 // Don't pass the vtable, it's not an argument of the virtual fn.\n                 // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n@@ -3006,32 +3086,32 @@ where\n                 }\n             }\n \n-            arg\n+            Ok(arg)\n         };\n \n         let mut fn_abi = FnAbi {\n-            ret: arg_of(sig.output(), None),\n+            ret: arg_of(sig.output(), None)?,\n             args: inputs\n                 .iter()\n                 .cloned()\n                 .chain(extra_args)\n                 .chain(caller_location)\n                 .enumerate()\n                 .map(|(i, ty)| arg_of(ty, Some(i)))\n-                .collect(),\n+                .collect::<Result<_, _>>()?,\n             c_variadic: sig.c_variadic,\n             fixed_count: inputs.len(),\n             conv,\n             can_unwind: fn_can_unwind(cx.tcx(), codegen_fn_attr_flags, sig.abi),\n         };\n-        fn_abi.adjust_for_abi(cx, sig.abi);\n+        fn_abi.adjust_for_abi(cx, sig.abi)?;\n         debug!(\"FnAbi::new_internal = {:?}\", fn_abi);\n-        fn_abi\n+        Ok(fn_abi)\n     }\n \n-    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi) {\n+    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi) -> Result<(), FnAbiError<'tcx>> {\n         if abi == SpecAbi::Unadjusted {\n-            return;\n+            return Ok(());\n         }\n \n         if abi == SpecAbi::Rust\n@@ -3095,12 +3175,11 @@ where\n             for arg in &mut self.args {\n                 fixup(arg);\n             }\n-            return;\n+        } else {\n+            self.adjust_for_foreign_abi(cx, abi)?;\n         }\n \n-        if let Err(msg) = self.adjust_for_foreign_abi(cx, abi) {\n-            cx.tcx().sess.fatal(&msg);\n-        }\n+        Ok(())\n     }\n }\n "}, {"sha": "75c526c97414fd235bca74ca0d998a721055f51c", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7f2f927eb81c75fd0f8e5900588eb962be0a4be9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2f927eb81c75fd0f8e5900588eb962be0a4be9/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=7f2f927eb81c75fd0f8e5900588eb962be0a4be9", "patch": "@@ -1,6 +1,7 @@\n use crate::abi::{self, Abi, Align, FieldsShape, Size};\n use crate::abi::{HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::{self, HasTargetSpec};\n+use std::fmt;\n \n mod aarch64;\n mod amdgpu;\n@@ -599,8 +600,28 @@ pub struct FnAbi<'a, Ty> {\n     pub can_unwind: bool,\n }\n \n+/// Error produced by attempting to adjust a `FnAbi`, for a \"foreign\" ABI.\n+pub enum AdjustForForeignAbiError {\n+    /// Target architecture doesn't support \"foreign\" (i.e. non-Rust) ABIs.\n+    Unsupported { arch: String, abi: spec::abi::Abi },\n+}\n+\n+impl fmt::Display for AdjustForForeignAbiError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Unsupported { arch, abi } => {\n+                write!(f, \"target architecture {:?} does not support `extern {}` ABI\", arch, abi)\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, Ty> FnAbi<'a, Ty> {\n-    pub fn adjust_for_foreign_abi<C>(&mut self, cx: &C, abi: spec::abi::Abi) -> Result<(), String>\n+    pub fn adjust_for_foreign_abi<C>(\n+        &mut self,\n+        cx: &C,\n+        abi: spec::abi::Abi,\n+    ) -> Result<(), AdjustForForeignAbiError>\n     where\n         Ty: TyAbiInterface<'a, C> + Copy,\n         C: HasDataLayout + HasTargetSpec,\n@@ -655,7 +676,9 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             }\n             \"asmjs\" => wasm::compute_c_abi_info(cx, self),\n             \"bpf\" => bpf::compute_abi_info(self),\n-            a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)),\n+            arch => {\n+                return Err(AdjustForForeignAbiError::Unsupported { arch: arch.to_string(), abi });\n+            }\n         }\n \n         Ok(())"}]}