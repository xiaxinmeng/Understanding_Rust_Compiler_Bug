{"sha": "9723a3bc379c208bd0d872cbf9d8b23888d404ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MjNhM2JjMzc5YzIwOGJkMGQ4NzJjYmY5ZDhiMjM4ODhkNDA0ZWU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T19:06:32Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T15:51:58Z"}, "message": "Move simd_ffi gating from trans to typeck.", "tree": {"sha": "beb668ba15946aa0483bcb70e77b388d5c997515", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beb668ba15946aa0483bcb70e77b388d5c997515"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9723a3bc379c208bd0d872cbf9d8b23888d404ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9723a3bc379c208bd0d872cbf9d8b23888d404ee", "html_url": "https://github.com/rust-lang/rust/commit/9723a3bc379c208bd0d872cbf9d8b23888d404ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9723a3bc379c208bd0d872cbf9d8b23888d404ee/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b47fcb8375921f6bc198fe38a397a79609933e8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b47fcb8375921f6bc198fe38a397a79609933e8e", "html_url": "https://github.com/rust-lang/rust/commit/b47fcb8375921f6bc198fe38a397a79609933e8e"}], "stats": {"total": 56, "additions": 24, "deletions": 32}, "files": [{"sha": "37de40efd3ddd9468c2c4a7565b62630647a472e", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9723a3bc379c208bd0d872cbf9d8b23888d404ee/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9723a3bc379c208bd0d872cbf9d8b23888d404ee/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=9723a3bc379c208bd0d872cbf9d8b23888d404ee", "patch": "@@ -463,30 +463,6 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     return bcx;\n }\n \n-// feature gate SIMD types in FFI, since I (huonw) am not sure the\n-// ABIs are handled at all correctly.\n-fn gate_simd_ffi(tcx: &TyCtxt, decl: &hir::FnDecl, ty: &ty::BareFnTy) {\n-    if !tcx.sess.features.borrow().simd_ffi {\n-        let check = |ast_ty: &hir::Ty, ty: ty::Ty| {\n-            if ty.is_simd() {\n-                tcx.sess.struct_span_err(ast_ty.span,\n-                              &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n-                                        may result in invalid code\",\n-                                       pprust::ty_to_string(ast_ty)))\n-                    .fileline_help(ast_ty.span,\n-                                   \"add #![feature(simd_ffi)] to the crate attributes to enable\")\n-                    .emit();\n-            }\n-        };\n-        let sig = &ty.sig.0;\n-        for (input, ty) in decl.inputs.iter().zip(&sig.inputs) {\n-            check(&input.ty, *ty)\n-        }\n-        if let hir::Return(ref ty) = decl.output {\n-            check(&ty, sig.output.unwrap())\n-        }\n-    }\n-}\n \n pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &hir::ForeignMod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n@@ -498,13 +474,6 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &hir::ForeignMod) {\n                 Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic => {}\n                 abi => {\n                     let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n-                    match ty.sty {\n-                        ty::TyFnDef(_, _, bft) |\n-                        ty::TyFnPtr(bft) => gate_simd_ffi(ccx.tcx(), &decl, bft),\n-                        _ => ccx.tcx().sess.span_bug(foreign_item.span,\n-                                                     \"foreign fn's sty isn't a bare_fn_ty?\")\n-                    }\n-\n                     register_foreign_item_fn(ccx, abi, ty, &lname, &foreign_item.attrs);\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have"}, {"sha": "258c7af1316eb1b9d5bf72466840fc1bda1c5029", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9723a3bc379c208bd0d872cbf9d8b23888d404ee/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9723a3bc379c208bd0d872cbf9d8b23888d404ee/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9723a3bc379c208bd0d872cbf9d8b23888d404ee", "patch": "@@ -2155,7 +2155,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     let input_tys = decl.inputs\n                         .iter()\n                         .map(|a| ty_of_arg(&ccx.icx(ast_generics), &rb, a, None))\n-                        .collect();\n+                        .collect::<Vec<_>>();\n \n     let output = match decl.output {\n         hir::Return(ref ty) =>\n@@ -2166,6 +2166,29 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n             ty::FnDiverging\n     };\n \n+    // feature gate SIMD types in FFI, since I (huonw) am not sure the\n+    // ABIs are handled at all correctly.\n+    if abi != abi::Abi::RustIntrinsic && abi != abi::Abi::PlatformIntrinsic\n+            && !ccx.tcx.sess.features.borrow().simd_ffi {\n+        let check = |ast_ty: &hir::Ty, ty: ty::Ty| {\n+            if ty.is_simd() {\n+                ccx.tcx.sess.struct_span_err(ast_ty.span,\n+                              &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n+                                        may result in invalid code\",\n+                                       pprust::ty_to_string(ast_ty)))\n+                    .fileline_help(ast_ty.span,\n+                                   \"add #![feature(simd_ffi)] to the crate attributes to enable\")\n+                    .emit();\n+            }\n+        };\n+        for (input, ty) in decl.inputs.iter().zip(&input_tys) {\n+            check(&input.ty, ty)\n+        }\n+        if let hir::Return(ref ty) = decl.output {\n+            check(&ty, output.unwrap())\n+        }\n+    }\n+\n     let substs = ccx.tcx.mk_substs(mk_item_substs(ccx, &ty_generics));\n     let t_fn = ccx.tcx.mk_fn_def(id, substs, ty::BareFnTy {\n         abi: abi,"}]}