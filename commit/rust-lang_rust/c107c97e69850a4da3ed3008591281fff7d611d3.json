{"sha": "c107c97e69850a4da3ed3008591281fff7d611d3", "node_id": "C_kwDOAAsO6NoAKGMxMDdjOTdlNjk4NTBhNGRhM2VkMzAwODU5MTI4MWZmZjdkNjExZDM", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-25T21:26:30Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:47:26Z"}, "message": "Better support projection types when finding the signature for an expression", "tree": {"sha": "34e3aae63232a6641b86c10ff1972b2bced80323", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34e3aae63232a6641b86c10ff1972b2bced80323"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c107c97e69850a4da3ed3008591281fff7d611d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c107c97e69850a4da3ed3008591281fff7d611d3", "html_url": "https://github.com/rust-lang/rust/commit/c107c97e69850a4da3ed3008591281fff7d611d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c107c97e69850a4da3ed3008591281fff7d611d3/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b776fb82941cadfc752368901f210831d5184d95", "url": "https://api.github.com/repos/rust-lang/rust/commits/b776fb82941cadfc752368901f210831d5184d95", "html_url": "https://github.com/rust-lang/rust/commit/b776fb82941cadfc752368901f210831d5184d95"}], "stats": {"total": 170, "additions": 107, "deletions": 63}, "files": [{"sha": "12831ea43554289bcb7e8526296edf9ade9f3ffb", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 107, "deletions": 63, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/c107c97e69850a4da3ed3008591281fff7d611d3/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c107c97e69850a4da3ed3008591281fff7d611d3/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=c107c97e69850a4da3ed3008591281fff7d611d3", "patch": "@@ -14,8 +14,8 @@ use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, BoundRegion, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, Region, RegionKind, Ty,\n-    TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVisitor, UintTy, VariantDiscr,\n+    self, AdtDef, Binder, BoundRegion, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, ProjectionTy, Region,\n+    RegionKind, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVisitor, UintTy, VariantDiscr,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n@@ -530,74 +530,118 @@ pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnS\n     if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = path_res(cx, expr) {\n         Some(ExprFnSig::Sig(cx.tcx.fn_sig(id)))\n     } else {\n-        let ty = cx.typeck_results().expr_ty_adjusted(expr).peel_refs();\n-        match *ty.kind() {\n-            ty::Closure(_, subs) => Some(ExprFnSig::Closure(subs.as_closure().sig())),\n-            ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs))),\n-            ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n-            ty::Dynamic(bounds, _) => {\n-                let lang_items = cx.tcx.lang_items();\n-                match bounds.principal() {\n-                    Some(bound)\n-                        if Some(bound.def_id()) == lang_items.fn_trait()\n-                            || Some(bound.def_id()) == lang_items.fn_once_trait()\n-                            || Some(bound.def_id()) == lang_items.fn_mut_trait() =>\n-                    {\n-                        let output = bounds\n-                            .projection_bounds()\n-                            .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n-                            .map(|p| p.map_bound(|p| p.term.ty().expect(\"return type was a const\")));\n-                        Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n-                    },\n-                    _ => None,\n+        ty_sig(cx, cx.typeck_results().expr_ty_adjusted(expr).peel_refs())\n+    }\n+}\n+\n+fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+    match *ty.kind() {\n+        ty::Closure(_, subs) => Some(ExprFnSig::Closure(subs.as_closure().sig())),\n+        ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs))),\n+        ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n+        ty::Dynamic(bounds, _) => {\n+            let lang_items = cx.tcx.lang_items();\n+            match bounds.principal() {\n+                Some(bound)\n+                    if Some(bound.def_id()) == lang_items.fn_trait()\n+                        || Some(bound.def_id()) == lang_items.fn_once_trait()\n+                        || Some(bound.def_id()) == lang_items.fn_mut_trait() =>\n+                {\n+                    let output = bounds\n+                        .projection_bounds()\n+                        .find(|p| lang_items.fn_once_output().map_or(false, |id| id == p.item_def_id()))\n+                        .map(|p| p.map_bound(|p| p.term.ty().unwrap()));\n+                    Some(ExprFnSig::Trait(bound.map_bound(|b| b.substs.type_at(0)), output))\n+                },\n+                _ => None,\n+            }\n+        },\n+        ty::Projection(proj) => match cx.tcx.try_normalize_erasing_regions(cx.param_env, ty) {\n+            Ok(normalized_ty) if normalized_ty != ty => ty_sig(cx, normalized_ty),\n+            _ => sig_for_projection(cx, proj).or_else(|| sig_from_bounds(cx, ty)),\n+        },\n+        ty::Param(_) => sig_from_bounds(cx, ty),\n+        _ => None,\n+    }\n+}\n+\n+fn sig_from_bounds<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+    let mut inputs = None;\n+    let mut output = None;\n+    let lang_items = cx.tcx.lang_items();\n+\n+    for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n+        match pred.kind().skip_binder() {\n+            PredicateKind::Trait(p)\n+                if (lang_items.fn_trait() == Some(p.def_id())\n+                    || lang_items.fn_mut_trait() == Some(p.def_id())\n+                    || lang_items.fn_once_trait() == Some(p.def_id()))\n+                    && p.self_ty() == ty =>\n+            {\n+                if inputs.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n                 }\n+                inputs = Some(pred.kind().rebind(p.trait_ref.substs.type_at(1)));\n             },\n-            ty::Param(_) | ty::Projection(..) => {\n-                let mut inputs = None;\n-                let mut output = None;\n-                let lang_items = cx.tcx.lang_items();\n-\n-                for (pred, _) in all_predicates_of(cx.tcx, cx.typeck_results().hir_owner.to_def_id()) {\n-                    let mut is_input = false;\n-                    if let Some(ty) = pred\n-                        .kind()\n-                        .map_bound(|pred| match pred {\n-                            PredicateKind::Trait(p)\n-                                if (lang_items.fn_trait() == Some(p.def_id())\n-                                    || lang_items.fn_mut_trait() == Some(p.def_id())\n-                                    || lang_items.fn_once_trait() == Some(p.def_id()))\n-                                    && p.self_ty() == ty =>\n-                            {\n-                                is_input = true;\n-                                Some(p.trait_ref.substs.type_at(1))\n-                            },\n-                            PredicateKind::Projection(p)\n-                                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n-                                    && p.projection_ty.self_ty() == ty =>\n-                            {\n-                                is_input = false;\n-                                p.term.ty()\n-                            },\n-                            _ => None,\n-                        })\n-                        .transpose()\n-                    {\n-                        if is_input && inputs.is_none() {\n-                            inputs = Some(ty);\n-                        } else if !is_input && output.is_none() {\n-                            output = Some(ty);\n-                        } else {\n-                            // Multiple different fn trait impls. Is this even allowed?\n-                            return None;\n-                        }\n-                    }\n+            PredicateKind::Projection(p)\n+                if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output()\n+                    && p.projection_ty.self_ty() == ty =>\n+            {\n+                if output.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n                 }\n+                output = Some(pred.kind().rebind(p.term.ty().unwrap()));\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+}\n+\n+fn sig_for_projection<'tcx>(cx: &LateContext<'tcx>, ty: ProjectionTy<'tcx>) -> Option<ExprFnSig<'tcx>> {\n+    let mut inputs = None;\n+    let mut output = None;\n+    let lang_items = cx.tcx.lang_items();\n \n-                inputs.map(|ty| ExprFnSig::Trait(ty, output))\n+    for pred in cx\n+        .tcx\n+        .bound_explicit_item_bounds(ty.item_def_id)\n+        .transpose_iter()\n+        .map(|x| x.map_bound(|(p, _)| p))\n+    {\n+        match pred.0.kind().skip_binder() {\n+            PredicateKind::Trait(p)\n+                if (lang_items.fn_trait() == Some(p.def_id())\n+                    || lang_items.fn_mut_trait() == Some(p.def_id())\n+                    || lang_items.fn_once_trait() == Some(p.def_id())) =>\n+            {\n+                if inputs.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n+                }\n+                inputs = Some(\n+                    pred.map_bound(|pred| pred.kind().rebind(p.trait_ref.substs.type_at(1)))\n+                        .subst(cx.tcx, ty.substs),\n+                );\n             },\n-            _ => None,\n+            PredicateKind::Projection(p) if Some(p.projection_ty.item_def_id) == lang_items.fn_once_output() => {\n+                if output.is_some() {\n+                    // Multiple different fn trait impls. Is this even allowed?\n+                    return None;\n+                }\n+                output = Some(\n+                    pred.map_bound(|pred| pred.kind().rebind(p.term.ty().unwrap()))\n+                        .subst(cx.tcx, ty.substs),\n+                );\n+            },\n+            _ => (),\n         }\n     }\n+\n+    inputs.map(|ty| ExprFnSig::Trait(ty, output))\n }\n \n #[derive(Clone, Copy)]"}]}