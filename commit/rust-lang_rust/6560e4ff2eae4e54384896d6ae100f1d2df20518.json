{"sha": "6560e4ff2eae4e54384896d6ae100f1d2df20518", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NjBlNGZmMmVhZTRlNTQzODQ4OTZkNmFlMTAwZjFkMmRmMjA1MTg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-26T14:45:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-26T14:45:31Z"}, "message": "Merge #2413\n\n2413: Remove another helper r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4d6767c90e5ac4ec5d6f6149e434ebf09dfa82be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d6767c90e5ac4ec5d6f6149e434ebf09dfa82be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6560e4ff2eae4e54384896d6ae100f1d2df20518", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd3TqLCRBK7hj4Ov3rIwAAdHIIAGCYgxB4uBBYELlZeaeekTq+\nkGLAHfZUKHGycKj19zg3fYt/l/DyaB7/+41zBROwGTSDz1RVVyT00vMukz3QVGUL\nCnXSoOvfUmPt9fT1ibGs8iioH+211RF/gg1P4+oW56WmtM+bO9HWoZiA8ocn4u4k\ncZJB5MKqRQL2W6kHIVy+EpxyrJr+qCK/UTMGz5WQIZlVIXasFPeCBo7v7U2Q6w/i\nadHn0JQRU+34cNkIuuFsMpVoZ2LbCEuAIaTM6nS2MaC3XJqp7efvcq/XNkdJTiDF\nLLa+tPgaWi+fuQmibxiCchdCL0Hpb+v5Bh+ZPMwCxurOtK3kuYDRI5EuhwMdD3s=\n=FUpM\n-----END PGP SIGNATURE-----\n", "payload": "tree 4d6767c90e5ac4ec5d6f6149e434ebf09dfa82be\nparent 4d753fa6f514ea1105c25ace91201c5324ee0b92\nparent 24b1e79af51f5af76047a5eee2fe90baf100afca\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574779531 +0000\ncommitter GitHub <noreply@github.com> 1574779531 +0000\n\nMerge #2413\n\n2413: Remove another helper r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6560e4ff2eae4e54384896d6ae100f1d2df20518", "html_url": "https://github.com/rust-lang/rust/commit/6560e4ff2eae4e54384896d6ae100f1d2df20518", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6560e4ff2eae4e54384896d6ae100f1d2df20518/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d753fa6f514ea1105c25ace91201c5324ee0b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d753fa6f514ea1105c25ace91201c5324ee0b92", "html_url": "https://github.com/rust-lang/rust/commit/4d753fa6f514ea1105c25ace91201c5324ee0b92"}, {"sha": "24b1e79af51f5af76047a5eee2fe90baf100afca", "url": "https://api.github.com/repos/rust-lang/rust/commits/24b1e79af51f5af76047a5eee2fe90baf100afca", "html_url": "https://github.com/rust-lang/rust/commit/24b1e79af51f5af76047a5eee2fe90baf100afca"}], "stats": {"total": 280, "additions": 156, "deletions": 124}, "files": [{"sha": "9578c20b0817898d9d9c19261838e485d641cf71", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 59, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=6560e4ff2eae4e54384896d6ae100f1d2df20518", "patch": "@@ -9,7 +9,7 @@ use hir_def::{\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     per_ns::PerNs,\n-    resolver::{HasResolver, TypeNs},\n+    resolver::HasResolver,\n     type_ref::{Mutability, TypeRef},\n     AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericDefId,\n     HasModule, ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId,\n@@ -737,64 +737,7 @@ impl Trait {\n     }\n \n     pub fn items(self, db: &impl DefDatabase) -> Vec<AssocItem> {\n-        db.trait_data(self.id).items.iter().map(|it| (*it).into()).collect()\n-    }\n-\n-    fn direct_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n-        let resolver = self.id.resolver(db);\n-        // returning the iterator directly doesn't easily work because of\n-        // lifetime problems, but since there usually shouldn't be more than a\n-        // few direct traits this should be fine (we could even use some kind of\n-        // SmallVec if performance is a concern)\n-        db.generic_params(self.id.into())\n-            .where_predicates\n-            .iter()\n-            .filter_map(|pred| match &pred.type_ref {\n-                TypeRef::Path(p) if p.as_ident() == Some(&name::SELF_TYPE) => pred.bound.as_path(),\n-                _ => None,\n-            })\n-            .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n-                Some(TypeNs::TraitId(t)) => Some(t),\n-                _ => None,\n-            })\n-            .map(Trait::from)\n-            .collect()\n-    }\n-\n-    /// Returns an iterator over the whole super trait hierarchy (including the\n-    /// trait itself).\n-    pub fn all_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n-        // we need to take care a bit here to avoid infinite loops in case of cycles\n-        // (i.e. if we have `trait A: B; trait B: A;`)\n-        let mut result = vec![self];\n-        let mut i = 0;\n-        while i < result.len() {\n-            let t = result[i];\n-            // yeah this is quadratic, but trait hierarchies should be flat\n-            // enough that this doesn't matter\n-            for tt in t.direct_super_traits(db) {\n-                if !result.contains(&tt) {\n-                    result.push(tt);\n-                }\n-            }\n-            i += 1;\n-        }\n-        result\n-    }\n-\n-    pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n-        let trait_data = db.trait_data(self.id);\n-        let res =\n-            trait_data.associated_types().map(TypeAlias::from).find(|t| &t.name(db) == name)?;\n-        Some(res)\n-    }\n-\n-    pub fn associated_type_by_name_including_super_traits(\n-        self,\n-        db: &impl HirDatabase,\n-        name: &Name,\n-    ) -> Option<TypeAlias> {\n-        self.all_super_traits(db).into_iter().find_map(|t| t.associated_type_by_name(db, name))\n+        db.trait_data(self.id).items.iter().map(|(_name, it)| (*it).into()).collect()\n     }\n \n     pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {"}, {"sha": "2a2dc26b493c05a389b21012b6fef44ca31c3127", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=6560e4ff2eae4e54384896d6ae100f1d2df20518", "patch": "@@ -9,6 +9,7 @@ mod op;\n mod lower;\n mod infer;\n pub(crate) mod display;\n+pub(crate) mod utils;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "ae68234aca2edf57bb49a45ebc728ca93575fe18", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=6560e4ff2eae4e54384896d6ae100f1d2df20518", "patch": "@@ -10,7 +10,7 @@ use hir_expand::name;\n use log::{info, warn};\n use ra_db::CrateId;\n \n-use crate::{db::HirDatabase, Trait};\n+use crate::db::HirDatabase;\n \n use super::{\n     traits::{InEnvironment, Solution},\n@@ -49,12 +49,12 @@ fn deref_by_trait(\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n     let deref_trait = match db.lang_item(krate.into(), \"deref\".into())? {\n-        LangItemTarget::TraitId(t) => Trait::from(t),\n+        LangItemTarget::TraitId(it) => it,\n         _ => return None,\n     };\n-    let target = deref_trait.associated_type_by_name(db, &name::TARGET_TYPE)?;\n+    let target = db.trait_data(deref_trait).associated_type_by_name(&name::TARGET_TYPE)?;\n \n-    let generic_params = db.generic_params(target.id.into());\n+    let generic_params = db.generic_params(target.into());\n     if generic_params.count_params_including_parent() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,\n         // namely Deref's Self type\n@@ -69,7 +69,7 @@ fn deref_by_trait(\n \n     let projection = super::traits::ProjectionPredicate {\n         ty: Ty::Bound(0),\n-        projection_ty: super::ProjectionTy { associated_ty: target.id, parameters },\n+        projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n     };\n \n     let obligation = super::Obligation::Projection(projection);"}, {"sha": "b023ae69014b6bd3ec148615f8e6b5076c74548e", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=6560e4ff2eae4e54384896d6ae100f1d2df20518", "patch": "@@ -43,7 +43,7 @@ use crate::{\n     db::HirDatabase,\n     expr::{BindingAnnotation, Body, ExprId, PatId},\n     ty::infer::diagnostics::InferenceDiagnostic,\n-    Adt, AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, Trait, VariantDef,\n+    Adt, AssocItem, DefWithBody, FloatTy, Function, IntTy, Path, StructField, VariantDef,\n };\n \n macro_rules! ty_app {\n@@ -582,20 +582,20 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAlias> {\n         let path = known::std_iter_into_iterator();\n-        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n-        trait_.associated_type_by_name(self.db, &name::ITEM_TYPE)\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::ITEM_TYPE).map(TypeAlias::from)\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAlias> {\n         let path = known::std_ops_try();\n-        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n-        trait_.associated_type_by_name(self.db, &name::OK_TYPE)\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OK_TYPE).map(TypeAlias::from)\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAlias> {\n         let path = known::std_future_future();\n-        let trait_: Trait = self.resolver.resolve_known_trait(self.db, &path)?.into();\n-        trait_.associated_type_by_name(self.db, &name::OUTPUT_TYPE)\n+        let trait_ = self.resolver.resolve_known_trait(self.db, &path)?;\n+        self.db.trait_data(trait_).associated_type_by_name(&name::OUTPUT_TYPE).map(TypeAlias::from)\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {"}, {"sha": "805a73ff5ea3354b9e865c40f0d71cd67bae94be", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=6560e4ff2eae4e54384896d6ae100f1d2df20518", "patch": "@@ -28,6 +28,7 @@ use crate::{\n     db::HirDatabase,\n     ty::{\n         primitive::{FloatTy, IntTy},\n+        utils::{all_super_traits, associated_type_by_name_including_super_traits},\n         Adt,\n     },\n     util::make_mut_slice,\n@@ -169,14 +170,16 @@ impl Ty {\n                 );\n                 return if remaining_segments.len() == 1 {\n                     let segment = &remaining_segments[0];\n-                    match trait_ref\n-                        .trait_\n-                        .associated_type_by_name_including_super_traits(db, &segment.name)\n-                    {\n+                    let associated_ty = associated_type_by_name_including_super_traits(\n+                        db,\n+                        trait_ref.trait_.id,\n+                        &segment.name,\n+                    );\n+                    match associated_ty {\n                         Some(associated_ty) => {\n                             // FIXME handle type parameters on the segment\n                             Ty::Projection(ProjectionTy {\n-                                associated_ty: associated_ty.id,\n+                                associated_ty,\n                                 parameters: trait_ref.substs,\n                             })\n                         }\n@@ -260,18 +263,16 @@ impl Ty {\n             GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n             _ => None,\n         });\n-        let traits = traits_from_env.flat_map(|t| t.all_super_traits(db));\n+        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t.id)).map(Trait::from);\n         for t in traits {\n-            if let Some(associated_ty) = t.associated_type_by_name(db, &segment.name) {\n+            if let Some(associated_ty) = db.trait_data(t.id).associated_type_by_name(&segment.name)\n+            {\n                 let substs = Substs::build_for_def(db, t.id)\n                     .push(self_ty.clone())\n                     .fill_with_unknown()\n                     .build();\n                 // FIXME handle type parameters on the segment\n-                return Ty::Projection(ProjectionTy {\n-                    associated_ty: associated_ty.id,\n-                    parameters: substs,\n-                });\n+                return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n             }\n         }\n         Ty::Unknown\n@@ -509,10 +510,11 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n             let associated_ty =\n-                match trait_ref.trait_.associated_type_by_name_including_super_traits(db, &name) {\n-                    None => return GenericPredicate::Error,\n-                    Some(t) => t.id,\n-                };\n+                associated_type_by_name_including_super_traits(db, trait_ref.trait_.id, &name);\n+            let associated_ty = match associated_ty {\n+                None => return GenericPredicate::Error,\n+                Some(t) => t,\n+            };\n             let projection_ty =\n                 ProjectionTy { associated_ty, parameters: trait_ref.substs.clone() };\n             let ty = Ty::from_hir(db, resolver, type_ref);"}, {"sha": "9988570e834dec97401966428a653ee8b4d342f4", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=6560e4ff2eae4e54384896d6ae100f1d2df20518", "patch": "@@ -16,7 +16,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     db::HirDatabase,\n     ty::primitive::{FloatBitness, Uncertain},\n-    ty::{Ty, TypeCtor},\n+    ty::{utils::all_super_traits, Ty, TypeCtor},\n     AssocItem, Crate, Function, Mutability, Name, Trait,\n };\n \n@@ -249,7 +249,8 @@ fn iterate_trait_method_candidates<T>(\n     let traits_from_env = env\n         .trait_predicates_for_self_ty(&ty.value)\n         .map(|tr| tr.trait_)\n-        .flat_map(|t| t.all_super_traits(db));\n+        .flat_map(|t| all_super_traits(db, t.id))\n+        .map(Trait::from);\n     let traits = inherent_trait\n         .chain(traits_from_env)\n         .chain(resolver.traits_in_scope(db).into_iter().map(Trait::from));\n@@ -260,8 +261,8 @@ fn iterate_trait_method_candidates<T>(\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n         let mut known_implemented = false;\n-        for &item in data.items.iter() {\n-            if !is_valid_candidate(db, name, mode, item.into()) {\n+        for (_name, item) in data.items.iter() {\n+            if !is_valid_candidate(db, name, mode, (*item).into()) {\n                 continue;\n             }\n             if !known_implemented {\n@@ -271,7 +272,7 @@ fn iterate_trait_method_candidates<T>(\n                 }\n             }\n             known_implemented = true;\n-            if let Some(result) = callback(&ty.value, item.into()) {\n+            if let Some(result) = callback(&ty.value, (*item).into()) {\n                 return Some(result);\n             }\n         }"}, {"sha": "78f4b3e27e693df9c5319aaecad6f4969a8b3d14", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=6560e4ff2eae4e54384896d6ae100f1d2df20518", "patch": "@@ -9,7 +9,7 @@ use chalk_ir::{\n };\n use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n \n-use hir_def::{lang_item::LangItemTarget, ContainerId, GenericDefId, Lookup, TypeAliasId};\n+use hir_def::{lang_item::LangItemTarget, ContainerId, GenericDefId, Lookup, TraitId, TypeAliasId};\n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n@@ -459,7 +459,7 @@ where\n                 [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n             {\n                 if let Some(actual_trait) = get_fn_trait(self.db, self.krate, fn_trait) {\n-                    if trait_ == actual_trait {\n+                    if trait_.id == actual_trait {\n                         let impl_ = super::ClosureFnTraitImplData { def, expr, fn_trait };\n                         result.push(Impl::ClosureFnTraitImpl(impl_).to_chalk(self.db));\n                     }\n@@ -661,6 +661,7 @@ fn impl_block_datum(\n     };\n \n     let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses };\n+    let trait_data = db.trait_data(trait_.id);\n     let associated_ty_value_ids = impl_block\n         .items(db)\n         .into_iter()\n@@ -670,7 +671,7 @@ fn impl_block_datum(\n         })\n         .filter(|type_alias| {\n             // don't include associated types that don't exist in the trait\n-            trait_.associated_type_by_name(db, &type_alias.name(db)).is_some()\n+            trait_data.associated_type_by_name(&type_alias.name(db)).is_some()\n         })\n         .map(|type_alias| AssocTyValue::TypeAlias(type_alias).to_chalk(db))\n         .collect();\n@@ -713,7 +714,7 @@ fn closure_fn_trait_impl_datum(\n     // and don't want to return a valid value only to find out later that FnOnce\n     // is broken\n     let fn_once_trait = get_fn_trait(db, krate, super::FnTrait::FnOnce)?;\n-    fn_once_trait.associated_type_by_name(db, &name::OUTPUT_TYPE)?;\n+    let _output = db.trait_data(fn_once_trait).associated_type_by_name(&name::OUTPUT_TYPE)?;\n \n     let num_args: u16 = match &db.body(data.def.into())[data.expr] {\n         crate::expr::Expr::Lambda { args, .. } => args.len() as u16,\n@@ -735,8 +736,8 @@ fn closure_fn_trait_impl_datum(\n     let self_ty = Ty::apply_one(TypeCtor::Closure { def: data.def, expr: data.expr }, sig_ty);\n \n     let trait_ref = TraitRef {\n-        trait_,\n-        substs: Substs::build_for_def(db, trait_.id).push(self_ty).push(arg_ty).build(),\n+        trait_: trait_.into(),\n+        substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n     };\n \n     let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data.clone()).to_chalk(db);\n@@ -783,10 +784,10 @@ fn type_alias_associated_ty_value(\n         .target_trait_ref(db)\n         .expect(\"assoc ty value should not exist\") // we don't return any assoc ty values if the impl'd trait can't be resolved\n         .trait_;\n-    let assoc_ty = trait_\n-        .associated_type_by_name(db, &type_alias.name(db))\n-        .expect(\"assoc ty value should not exist\") // validated when building the impl data as well\n-        .id;\n+    let assoc_ty = db\n+        .trait_data(trait_.id)\n+        .associated_type_by_name(&type_alias.name(db))\n+        .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n     let generic_params = db.generic_params(impl_block.id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let ty = db.type_for_def(type_alias.into(), crate::ty::Namespace::Types).subst(&bound_vars);\n@@ -819,10 +820,10 @@ fn closure_fn_trait_output_assoc_ty_value(\n     let fn_once_trait =\n         get_fn_trait(db, krate, super::FnTrait::FnOnce).expect(\"assoc ty value should not exist\");\n \n-    let output_ty_id = fn_once_trait\n-        .associated_type_by_name(db, &name::OUTPUT_TYPE)\n-        .expect(\"assoc ty value should not exist\")\n-        .id;\n+    let output_ty_id = db\n+        .trait_data(fn_once_trait)\n+        .associated_type_by_name(&name::OUTPUT_TYPE)\n+        .expect(\"assoc ty value should not exist\");\n \n     let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: output_ty.to_chalk(db) };\n \n@@ -834,10 +835,10 @@ fn closure_fn_trait_output_assoc_ty_value(\n     Arc::new(value)\n }\n \n-fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<Trait> {\n+fn get_fn_trait(db: &impl HirDatabase, krate: Crate, fn_trait: super::FnTrait) -> Option<TraitId> {\n     let target = db.lang_item(krate.crate_id, fn_trait.lang_item_name().into())?;\n     match target {\n-        LangItemTarget::TraitId(t) => Some(t.into()),\n+        LangItemTarget::TraitId(t) => Some(t),\n         _ => None,\n     }\n }"}, {"sha": "52994b9e3498624875fd69f5af682bad72a3fff0", "filename": "crates/ra_hir/src/ty/utils.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs?ref=6560e4ff2eae4e54384896d6ae100f1d2df20518", "patch": "@@ -0,0 +1,63 @@\n+//! Helper functions for working with def, which don't need to be a separate\n+//! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n+\n+use hir_def::{\n+    db::DefDatabase,\n+    resolver::{HasResolver, TypeNs},\n+    type_ref::TypeRef,\n+    TraitId, TypeAliasId,\n+};\n+use hir_expand::name::{self, Name};\n+\n+// FIXME: this is wrong, b/c it can't express `trait T: PartialEq<()>`.\n+// We should return a `TraitREf` here.\n+fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+    let resolver = trait_.resolver(db);\n+    // returning the iterator directly doesn't easily work because of\n+    // lifetime problems, but since there usually shouldn't be more than a\n+    // few direct traits this should be fine (we could even use some kind of\n+    // SmallVec if performance is a concern)\n+    db.generic_params(trait_.into())\n+        .where_predicates\n+        .iter()\n+        .filter_map(|pred| match &pred.type_ref {\n+            TypeRef::Path(p) if p.as_ident() == Some(&name::SELF_TYPE) => pred.bound.as_path(),\n+            _ => None,\n+        })\n+        .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n+            Some(TypeNs::TraitId(t)) => Some(t),\n+            _ => None,\n+        })\n+        .collect()\n+}\n+\n+/// Returns an iterator over the whole super trait hierarchy (including the\n+/// trait itself).\n+pub(crate) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+    // we need to take care a bit here to avoid infinite loops in case of cycles\n+    // (i.e. if we have `trait A: B; trait B: A;`)\n+    let mut result = vec![trait_];\n+    let mut i = 0;\n+    while i < result.len() {\n+        let t = result[i];\n+        // yeah this is quadratic, but trait hierarchies should be flat\n+        // enough that this doesn't matter\n+        for tt in direct_super_traits(db, t) {\n+            if !result.contains(&tt) {\n+                result.push(tt);\n+            }\n+        }\n+        i += 1;\n+    }\n+    result\n+}\n+\n+pub(crate) fn associated_type_by_name_including_super_traits(\n+    db: &impl DefDatabase,\n+    trait_: TraitId,\n+    name: &Name,\n+) -> Option<TypeAliasId> {\n+    all_super_traits(db, trait_)\n+        .into_iter()\n+        .find_map(|t| db.trait_data(t).associated_type_by_name(name))\n+}"}, {"sha": "813099a058ba69f3f7389535cefe04e295c345f6", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6560e4ff2eae4e54384896d6ae100f1d2df20518/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=6560e4ff2eae4e54384896d6ae100f1d2df20518", "patch": "@@ -87,7 +87,7 @@ impl TypeAliasData {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TraitData {\n     pub name: Option<Name>,\n-    pub items: Vec<AssocItemId>,\n+    pub items: Vec<(Name, AssocItemId)>,\n     pub auto: bool,\n }\n \n@@ -97,28 +97,42 @@ impl TraitData {\n         let name = src.value.name().map(|n| n.as_name());\n         let auto = src.value.is_auto();\n         let ast_id_map = db.ast_id_map(src.file_id);\n+\n+        let container = ContainerId::TraitId(tr);\n         let items = if let Some(item_list) = src.value.item_list() {\n             item_list\n                 .impl_items()\n                 .map(|item_node| match item_node {\n-                    ast::ImplItem::FnDef(it) => FunctionLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    ast::ImplItem::FnDef(it) => {\n+                        let name = it.name().map(|it| it.as_name()).unwrap_or_else(Name::missing);\n+                        let def = FunctionLoc {\n+                            container,\n+                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                        }\n+                        .intern(db)\n+                        .into();\n+                        (name, def)\n                     }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::ConstDef(it) => ConstLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    ast::ImplItem::ConstDef(it) => {\n+                        let name = it.name().map(|it| it.as_name()).unwrap_or_else(Name::missing);\n+                        let def = ConstLoc {\n+                            container,\n+                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                        }\n+                        .intern(db)\n+                        .into();\n+                        (name, def)\n                     }\n-                    .intern(db)\n-                    .into(),\n-                    ast::ImplItem::TypeAliasDef(it) => TypeAliasLoc {\n-                        container: ContainerId::TraitId(tr),\n-                        ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                    ast::ImplItem::TypeAliasDef(it) => {\n+                        let name = it.name().map(|it| it.as_name()).unwrap_or_else(Name::missing);\n+                        let def = TypeAliasLoc {\n+                            container,\n+                            ast_id: AstId::new(src.file_id, ast_id_map.ast_id(&it)),\n+                        }\n+                        .intern(db)\n+                        .into();\n+                        (name, def)\n                     }\n-                    .intern(db)\n-                    .into(),\n                 })\n                 .collect()\n         } else {\n@@ -128,11 +142,18 @@ impl TraitData {\n     }\n \n     pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n-        self.items.iter().filter_map(|item| match item {\n+        self.items.iter().filter_map(|(_name, item)| match item {\n             AssocItemId::TypeAliasId(t) => Some(*t),\n             _ => None,\n         })\n     }\n+\n+    pub fn associated_type_by_name(&self, name: &Name) -> Option<TypeAliasId> {\n+        self.items.iter().find_map(|(item_name, item)| match item {\n+            AssocItemId::TypeAliasId(t) if item_name == name => Some(*t),\n+            _ => None,\n+        })\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}]}