{"sha": "9b2d80a197453001f9acd40020c1db6c0178c7fe", "node_id": "C_kwDOAAsO6NoAKDliMmQ4MGExOTc0NTMwMDFmOWFjZDQwMDIwYzFkYjZjMDE3OGM3ZmU", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-05-28T02:53:31Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-06-01T17:41:50Z"}, "message": "Provide more context when denying invalid type params", "tree": {"sha": "876dc00b0a3a0aacea42246bf805ff2a4dd9b178", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/876dc00b0a3a0aacea42246bf805ff2a4dd9b178"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b2d80a197453001f9acd40020c1db6c0178c7fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b2d80a197453001f9acd40020c1db6c0178c7fe", "html_url": "https://github.com/rust-lang/rust/commit/9b2d80a197453001f9acd40020c1db6c0178c7fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b2d80a197453001f9acd40020c1db6c0178c7fe/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f023b920b195477b65945550a2c5949ca7e7cf3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f023b920b195477b65945550a2c5949ca7e7cf3e", "html_url": "https://github.com/rust-lang/rust/commit/f023b920b195477b65945550a2c5949ca7e7cf3e"}], "stats": {"total": 674, "additions": 564, "deletions": 110}, "files": [{"sha": "56a4025f2972a0ec3ca739244c5e870b04df9e7c", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 144, "deletions": 25, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::{self, Const, DefIdTree, EarlyBinder, Ty, TyCtxt, TypeFold\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n-use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n@@ -653,7 +653,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             span, item_def_id, item_segment\n         );\n         if tcx.generics_of(item_def_id).params.is_empty() {\n-            self.prohibit_generics(slice::from_ref(item_segment).iter());\n+            self.prohibit_generics(slice::from_ref(item_segment).iter(), |_| {});\n \n             parent_substs\n         } else {\n@@ -681,7 +681,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_ref: &hir::TraitRef<'_>,\n         self_ty: Ty<'tcx>,\n     ) -> ty::TraitRef<'tcx> {\n-        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter());\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter(), |_| {});\n \n         self.ast_path_to_mono_trait_ref(\n             trait_ref.path.span,\n@@ -784,7 +784,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let args = trait_segment.args();\n         let infer_args = trait_segment.infer_args;\n \n-        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter());\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter(), |_| {});\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, false);\n \n         self.instantiate_poly_trait_ref_inner(\n@@ -1776,12 +1776,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         hir_ref_id: hir::HirId,\n         span: Span,\n         qself_ty: Ty<'tcx>,\n-        qself_res: Res,\n+        qself: &hir::Ty<'_>,\n         assoc_segment: &hir::PathSegment<'_>,\n         permit_variants: bool,\n     ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorGuaranteed> {\n         let tcx = self.tcx();\n         let assoc_ident = assoc_segment.ident;\n+        let qself_res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n+            path.res\n+        } else {\n+            Res::Err\n+        };\n \n         debug!(\"associated_path_to_ty: {:?}::{}\", qself_ty, assoc_ident);\n \n@@ -1796,7 +1801,55 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if let Some(variant_def) = variant_def {\n                     if permit_variants {\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span, None);\n-                        self.prohibit_generics(slice::from_ref(assoc_segment).iter());\n+                        self.prohibit_generics(slice::from_ref(assoc_segment).iter(), |err| {\n+                            err.note(\"enum variants can't have type parameters\");\n+                            let type_name = tcx.opt_item_name(adt_def.did());\n+                            let the_enum = type_name.map(|n| format!(\"enum `{n}`\")).unwrap_or_else(|| \"the enum\".to_string());\n+                            let msg = format!(\"you might have meant to specity type parameters on {the_enum}\");\n+                            let Some(args) = assoc_segment.args else { return; };\n+                            let args_span = assoc_segment.ident.span.shrink_to_hi().to(args.span_ext);\n+                            let Ok(snippet) = tcx.sess.source_map().span_to_snippet(args_span) else {\n+                                err.note(&msg);\n+                                return;\n+                            };\n+                            let (qself_sugg_span, is_self) = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n+                                // If the path segment already has type params, we want to overwrite\n+                                // them.\n+                                match &path.segments[..] {\n+                                    [.., segment, _] => (\n+                                        segment.ident.span.shrink_to_hi().to(segment.args.map_or(\n+                                            segment.ident.span.shrink_to_hi(),\n+                                            |a| a.span_ext)),\n+                                        false,\n+                                    ),\n+                                    [segment] => (\n+                                        segment.ident.span.shrink_to_hi().to(segment.args.map_or(\n+                                            segment.ident.span.shrink_to_hi(),\n+                                            |a| a.span_ext)),\n+                                        kw::SelfUpper == segment.ident.name,\n+                                    ),\n+                                    _ => unreachable!(),\n+                                }\n+                            } else {\n+                                err.note(&msg);\n+                                return;\n+                            };\n+                            let Some(type_name) = type_name else {\n+                                err.note(&msg);\n+                                return;\n+                            };\n+                            let suggestion = vec![\n+                                if is_self {\n+                                    // Account for people writing `Self::Variant::<Args>`, where\n+                                    // `Self` is the enum.\n+                                    (qself.span, format!(\"{type_name}{snippet}\"))\n+                                } else {\n+                                    (qself_sugg_span, snippet)\n+                                },\n+                                (args_span, String::new()),\n+                            ];\n+                            err.multipart_suggestion_verbose(&msg, suggestion, Applicability::MaybeIncorrect);\n+                        });\n                         return Ok((qself_ty, DefKind::Variant, variant_def.def_id));\n                     } else {\n                         variant_resolution = Some(variant_def.def_id);\n@@ -2017,9 +2070,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n     }\n \n-    pub fn prohibit_generics<'a, T: Iterator<Item = &'a hir::PathSegment<'a>> + Clone>(\n+    pub fn prohibit_generics<'a>(\n         &self,\n-        segments: T,\n+        segments: impl Iterator<Item = &'a hir::PathSegment<'a>> + Clone,\n+        extend: impl Fn(&mut DiagnosticBuilder<'tcx, ErrorGuaranteed>),\n     ) -> bool {\n         let args = segments.clone().flat_map(|segment| segment.args().args);\n \n@@ -2078,6 +2132,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 \"{kind} arguments are not allowed for this type\",\n             );\n             err.span_label(last_span, format!(\"{kind} argument{s} not allowed\"));\n+            extend(&mut err);\n             err.emit();\n             emitted = true;\n         }\n@@ -2239,7 +2294,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Check for desugared `impl Trait`.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n-                self.prohibit_generics(item_segment.1.iter());\n+                self.prohibit_generics(item_segment.1.iter(), |err| {\n+                    err.note(\"`impl Trait` types can't have type parameters\");\n+                });\n                 let substs = self.ast_path_substs_for_ty(span, did, item_segment.0);\n                 self.normalize_ty(span, tcx.mk_opaque(did, substs))\n             }\n@@ -2252,7 +2309,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 did,\n             ) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.split_last().unwrap().1.iter());\n+                self.prohibit_generics(path.segments.split_last().unwrap().1.iter(), |_| {});\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Res::Def(kind @ DefKind::Variant, def_id) if permit_variants => {\n@@ -2264,18 +2321,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     self.def_ids_for_value_path_segments(path.segments, None, kind, def_id);\n                 let generic_segs: FxHashSet<_> =\n                     path_segs.iter().map(|PathSeg(_, index)| index).collect();\n-                self.prohibit_generics(path.segments.iter().enumerate().filter_map(\n-                    |(index, seg)| {\n+                self.prohibit_generics(\n+                    path.segments.iter().enumerate().filter_map(|(index, seg)| {\n                         if !generic_segs.contains(&index) { Some(seg) } else { None }\n+                    }),\n+                    |err| {\n+                        err.note(\"enum variants can't have type parameters\");\n                     },\n-                ));\n+                );\n \n                 let PathSeg(def_id, index) = path_segs.last().unwrap();\n                 self.ast_path_to_ty(span, *def_id, &path.segments[*index])\n             }\n             Res::Def(DefKind::TyParam, def_id) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.iter());\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    if let Some(span) = tcx.def_ident_span(def_id) {\n+                        let name = tcx.item_name(def_id);\n+                        err.span_note(span, &format!(\"type parameter `{name}` defined here\"));\n+                    }\n+                });\n \n                 let def_id = def_id.expect_local();\n                 let item_def_id = tcx.hir().ty_param_owner(def_id);\n@@ -2286,15 +2351,63 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::SelfTy { trait_: Some(_), alias_to: None } => {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.iter());\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    if let [hir::PathSegment { args: Some(args), ident, .. }] = &path.segments[..] {\n+                        err.span_suggestion_verbose(\n+                            ident.span.shrink_to_hi().to(args.span_ext),\n+                            \"the `Self` type doesn't accept type parameters\",\n+                            String::new(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                });\n                 tcx.types.self_param\n             }\n             Res::SelfTy { trait_: _, alias_to: Some((def_id, forbid_generic)) } => {\n                 // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.iter());\n                 // Try to evaluate any array length constants.\n                 let ty = tcx.at(span).type_of(def_id);\n+                let span_of_impl = tcx.span_of_impl(def_id);\n+                // TODO: confirm that `def_id`'s type accepts type params at all before suggesting\n+                // using that instead.\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    let def_id = match *ty.kind() {\n+                        ty::Adt(self_def, _) => self_def.did(),\n+                        _ => return,\n+                    };\n+\n+                    let type_name = tcx.item_name(def_id);\n+                    let span_of_ty = tcx.def_ident_span(def_id);\n+\n+                    let msg = format!(\"the `Self` type is `{ty}`\");\n+                    if let (Ok(i_sp), Some(t_sp)) = (span_of_impl, span_of_ty) {\n+                        let i_sp = tcx.sess.source_map().guess_head_span(i_sp);\n+                        let mut span: MultiSpan = vec![t_sp].into();\n+                        span.push_span_label(\n+                            i_sp,\n+                            &format!(\"`Self` is `{type_name}` in this `impl`\"),\n+                        );\n+                        span.push_span_label(t_sp, \"`Self` corresponds to this type\");\n+                        err.span_note(span, &msg);\n+                    } else {\n+                        err.note(&msg);\n+                    }\n+                    for segment in path.segments {\n+                        if let Some(_args) = segment.args && segment.ident.name == kw::SelfUpper {\n+                            err.span_suggestion_verbose(\n+                                segment.ident.span,\n+                                format!(\n+                                    \"the `Self` type doesn't accept type parameters, use the \\\n+                                     concrete type's name `{type_name}` instead if you want to \\\n+                                     specify its type parameters\"\n+                                ),\n+                                type_name.to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                });\n                 // HACK(min_const_generics): Forbid generic `Self` types\n                 // here as we can't easily do that during nameres.\n                 //\n@@ -2334,7 +2447,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Def(DefKind::AssocTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n-                self.prohibit_generics(path.segments[..path.segments.len() - 2].iter());\n+                self.prohibit_generics(path.segments[..path.segments.len() - 2].iter(), |_| {});\n                 self.qpath_to_ty(\n                     span,\n                     opt_self_ty,\n@@ -2345,7 +2458,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.iter());\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    let name = prim_ty.name_str();\n+                    for segment in path.segments {\n+                        if let Some(args) = segment.args {\n+                            err.span_suggestion_verbose(\n+                                segment.ident.span.shrink_to_hi().to(args.span_ext),\n+                                &format!(\"primitive type `{name}` doesn't have type parameters\"),\n+                                String::new(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                });\n                 match prim_ty {\n                     hir::PrimTy::Bool => tcx.types.bool,\n                     hir::PrimTy::Char => tcx.types.char,\n@@ -2436,13 +2561,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(?qself, ?segment);\n                 let ty = self.ast_ty_to_ty_inner(qself, false, true);\n-\n-                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = qself.kind {\n-                    path.res\n-                } else {\n-                    Res::Err\n-                };\n-                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, res, segment, false)\n+                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, qself, segment, false)\n                     .map(|(ty, _, _)| ty)\n                     .unwrap_or_else(|_| tcx.ty_error())\n             }"}, {"sha": "c28c041e78dff9c9709211b3f784363cfd417f2f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -1228,6 +1228,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     None\n                 }\n             }),\n+            |_| {},\n         );\n \n         if let Res::Local(hid) = res {"}, {"sha": "83afbfa54b1dda8dbe272df87ffb2045d8901990", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -1564,13 +1564,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.kind {\n-                    path.res\n-                } else {\n-                    Res::Err\n-                };\n                 let result = <dyn AstConv<'_>>::associated_path_to_ty(\n-                    self, hir_id, path_span, ty, res, segment, true,\n+                    self, hir_id, path_span, ty, qself, segment, true,\n                 );\n                 let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));"}, {"sha": "cb12bcd1ba402a17677ccef0964f4e0f87361c08", "filename": "src/test/ui/error-codes/E0109.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -3,6 +3,12 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL | type X = u32<i32>;\n    |              ^^^ type argument not allowed\n+   |\n+help: primitive type `u32` doesn't have type parameters\n+   |\n+LL - type X = u32<i32>;\n+LL + type X = u32;\n+   | \n \n error: aborting due to previous error\n "}, {"sha": "5140f72b3ce2148a9c3ae7e8434bf1bb334656af", "filename": "src/test/ui/error-codes/E0110.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -3,6 +3,12 @@ error[E0109]: lifetime arguments are not allowed for this type\n    |\n LL | type X = u32<'static>;\n    |              ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `u32` doesn't have type parameters\n+   |\n+LL - type X = u32<'static>;\n+LL + type X = u32;\n+   | \n \n error: aborting due to previous error\n "}, {"sha": "f8b85559db844ecbedea5e4ad551cd8fabfeb23e", "filename": "src/test/ui/structs/struct-path-self.stderr", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -9,6 +9,12 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |         let z = Self::<u8> {};\n    |                        ^^ type argument not allowed\n+   |\n+help: the `Self` type doesn't accept type parameters\n+   |\n+LL -         let z = Self::<u8> {};\n+LL +         let z = Self {};\n+   | \n \n error[E0071]: expected struct, variant or union type, found type parameter `Self`\n   --> $DIR/struct-path-self.rs:7:17\n@@ -27,12 +33,38 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |         let z = Self::<u8> {};\n    |                        ^^ type argument not allowed\n+   |\n+note: the `Self` type is `S`\n+  --> $DIR/struct-path-self.rs:1:8\n+   |\n+LL | struct S;\n+   |        ^ `Self` corresponds to this type\n+...\n+LL | impl Tr for S {\n+   | ------------- `Self` is `S` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `S` instead if you want to specify its type parameters\n+   |\n+LL |         let z = S::<u8> {};\n+   |                 ~\n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/struct-path-self.rs:30:24\n    |\n LL |         let z = Self::<u8> {};\n    |                        ^^ type argument not allowed\n+   |\n+note: the `Self` type is `S`\n+  --> $DIR/struct-path-self.rs:1:8\n+   |\n+LL | struct S;\n+   |        ^ `Self` corresponds to this type\n+...\n+LL | impl S {\n+   | ------ `Self` is `S` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `S` instead if you want to specify its type parameters\n+   |\n+LL |         let z = S::<u8> {};\n+   |                 ~\n \n error: aborting due to 6 previous errors\n "}, {"sha": "a0df5c416b26b564ec35c53bad2b1f4d1ce0d8c6", "filename": "src/test/ui/type-alias-enum-variants/enum-variant-generic-args.stderr", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -28,6 +28,19 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |         Self::<()>::TSVariant(());\n    |                ^^ type argument not allowed\n+   |\n+note: the `Self` type is `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::TSVariant(());\n+   |         ~~~~\n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:17:31\n@@ -53,6 +66,19 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |         Self::<()>::TSVariant::<()>(());\n    |                ^^ type argument not allowed\n+   |\n+note: the `Self` type is `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::TSVariant::<()>(());\n+   |         ~~~~\n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/enum-variant-generic-args.rs:20:33\n@@ -77,6 +103,13 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |         Self::SVariant::<()> { v: () };\n    |                          ^^ type argument not allowed\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -         Self::SVariant::<()> { v: () };\n+LL +         Enum::<()>::SVariant { v: () };\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:28:35\n@@ -95,6 +128,19 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |         Self::<()>::SVariant { v: () };\n    |                ^^ type argument not allowed\n+   |\n+note: the `Self` type is `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::SVariant { v: () };\n+   |         ~~~~\n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:31:35\n@@ -113,12 +159,32 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |         Self::<()>::SVariant::<()> { v: () };\n    |                ^^ type argument not allowed\n+   |\n+note: the `Self` type is `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::SVariant::<()> { v: () };\n+   |         ~~~~\n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/enum-variant-generic-args.rs:34:32\n    |\n LL |         Self::<()>::SVariant::<()> { v: () };\n    |                                ^^ type argument not allowed\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -         Self::<()>::SVariant::<()> { v: () };\n+LL +         Enum::<()>::SVariant { v: () };\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:34:41\n@@ -143,12 +209,38 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |         Self::<()>::UVariant;\n    |                ^^ type argument not allowed\n+   |\n+note: the `Self` type is `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::UVariant;\n+   |         ~~~~\n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/enum-variant-generic-args.rs:45:16\n    |\n LL |         Self::<()>::UVariant::<()>;\n    |                ^^ type argument not allowed\n+   |\n+note: the `Self` type is `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::UVariant::<()>;\n+   |         ~~~~\n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/enum-variant-generic-args.rs:45:32\n@@ -219,24 +311,47 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |     Enum::<()>::SVariant::<()> { v: () };\n    |                            ^^ type argument not allowed\n+   |\n+   = note: enum variants can't have type parameters\n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/enum-variant-generic-args.rs:75:23\n    |\n LL |     Alias::SVariant::<()> { v: () };\n    |                       ^^ type argument not allowed\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     Alias::SVariant::<()> { v: () };\n+LL +     Alias::<()>::SVariant { v: () };\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/enum-variant-generic-args.rs:77:29\n    |\n LL |     Alias::<()>::SVariant::<()> { v: () };\n    |                             ^^ type argument not allowed\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     Alias::<()>::SVariant::<()> { v: () };\n+LL +     Alias::<()>::SVariant { v: () };\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/enum-variant-generic-args.rs:80:28\n    |\n LL |     AliasFixed::SVariant::<()> { v: () };\n    |                            ^^ type argument not allowed\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     AliasFixed::SVariant::<()> { v: () };\n+LL +     AliasFixed::<()>::SVariant { v: () };\n+   | \n \n error[E0107]: this type alias takes 0 generic arguments but 1 generic argument was supplied\n   --> $DIR/enum-variant-generic-args.rs:82:5\n@@ -271,6 +386,13 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |     AliasFixed::<()>::SVariant::<()> { v: () };\n    |                                  ^^ type argument not allowed\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     AliasFixed::<()>::SVariant::<()> { v: () };\n+LL +     AliasFixed::<()>::SVariant { v: () };\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/enum-variant-generic-args.rs:90:28"}, {"sha": "9e86fd3aa7d6daf9a3700582f36955cf1853f212", "filename": "src/test/ui/type/issue-91268.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftype%2Fissue-91268.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftype%2Fissue-91268.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-91268.stderr?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -35,6 +35,12 @@ error[E0109]: type arguments are not allowed for this type\n    |\n LL |     0: u8(\u0163\n    |           ^ type argument not allowed\n+   |\n+help: primitive type `u8` doesn't have type parameters\n+   |\n+LL -     0: u8(\u0163\n+LL +     0: u8\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/issue-91268.rs:9:5"}, {"sha": "0fd4a0f984e1ecfba9394a17721eec09eeb8a942", "filename": "src/test/ui/typeck/prim-with-args.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.fixed?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+fn main() {\n+\n+let _x: isize; //~ ERROR type arguments are not allowed for this type\n+let _x: i8; //~ ERROR type arguments are not allowed for this type\n+let _x: i16; //~ ERROR type arguments are not allowed for this type\n+let _x: i32; //~ ERROR type arguments are not allowed for this type\n+let _x: i64; //~ ERROR type arguments are not allowed for this type\n+let _x: usize; //~ ERROR type arguments are not allowed for this type\n+let _x: u8; //~ ERROR type arguments are not allowed for this type\n+let _x: u16; //~ ERROR type arguments are not allowed for this type\n+let _x: u32; //~ ERROR type arguments are not allowed for this type\n+let _x: u64; //~ ERROR type arguments are not allowed for this type\n+let _x: char; //~ ERROR type arguments are not allowed for this type\n+\n+let _x: isize; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: i8; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: i16; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: i32; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: i64; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: usize; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: u8; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: u16; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: u32; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: u64; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: char; //~ ERROR lifetime arguments are not allowed for this type\n+\n+}"}, {"sha": "a21fe69dc6a878e929eda919e068898be357a134", "filename": "src/test/ui/typeck/prim-with-args.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.rs?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -1,27 +1,28 @@\n+// run-rustfix\n fn main() {\n \n-let x: isize<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i8<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i16<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i32<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i64<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: usize<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u8<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u16<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u32<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u64<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: char<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: isize<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: i8<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: i16<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: i32<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: i64<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: usize<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: u8<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: u16<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: u32<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: u64<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: char<isize>; //~ ERROR type arguments are not allowed for this type\n \n-let x: isize<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i8<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i16<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i32<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i64<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: usize<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u8<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u16<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u32<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u64<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: char<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: isize<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: i8<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: i16<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: i32<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: i64<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: usize<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: u8<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: u16<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: u32<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: u64<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: char<'static>; //~ ERROR lifetime arguments are not allowed for this type\n \n }"}, {"sha": "d7c32cf8ecf405ded02d1463ed48e2aad1627b49", "filename": "src/test/ui/typeck/prim-with-args.stderr", "status": "modified", "additions": 189, "deletions": 57, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.stderr?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -1,134 +1,266 @@\n error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:3:14\n+  --> $DIR/prim-with-args.rs:4:15\n    |\n-LL | let x: isize<isize>;\n-   |              ^^^^^ type argument not allowed\n-\n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:4:11\n+LL | let _x: isize<isize>;\n+   |               ^^^^^ type argument not allowed\n    |\n-LL | let x: i8<isize>;\n-   |           ^^^^^ type argument not allowed\n+help: primitive type `isize` doesn't have type parameters\n+   |\n+LL - let _x: isize<isize>;\n+LL + let _x: isize;\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/prim-with-args.rs:5:12\n    |\n-LL | let x: i16<isize>;\n+LL | let _x: i8<isize>;\n    |            ^^^^^ type argument not allowed\n+   |\n+help: primitive type `i8` doesn't have type parameters\n+   |\n+LL - let _x: i8<isize>;\n+LL + let _x: i8;\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:6:12\n+  --> $DIR/prim-with-args.rs:6:13\n    |\n-LL | let x: i32<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: i16<isize>;\n+   |             ^^^^^ type argument not allowed\n+   |\n+help: primitive type `i16` doesn't have type parameters\n+   |\n+LL - let _x: i16<isize>;\n+LL + let _x: i16;\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:7:12\n+  --> $DIR/prim-with-args.rs:7:13\n    |\n-LL | let x: i64<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: i32<isize>;\n+   |             ^^^^^ type argument not allowed\n+   |\n+help: primitive type `i32` doesn't have type parameters\n+   |\n+LL - let _x: i32<isize>;\n+LL + let _x: i32;\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:8:14\n+  --> $DIR/prim-with-args.rs:8:13\n    |\n-LL | let x: usize<isize>;\n-   |              ^^^^^ type argument not allowed\n+LL | let _x: i64<isize>;\n+   |             ^^^^^ type argument not allowed\n+   |\n+help: primitive type `i64` doesn't have type parameters\n+   |\n+LL - let _x: i64<isize>;\n+LL + let _x: i64;\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:9:11\n+  --> $DIR/prim-with-args.rs:9:15\n+   |\n+LL | let _x: usize<isize>;\n+   |               ^^^^^ type argument not allowed\n    |\n-LL | let x: u8<isize>;\n-   |           ^^^^^ type argument not allowed\n+help: primitive type `usize` doesn't have type parameters\n+   |\n+LL - let _x: usize<isize>;\n+LL + let _x: usize;\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/prim-with-args.rs:10:12\n    |\n-LL | let x: u16<isize>;\n+LL | let _x: u8<isize>;\n    |            ^^^^^ type argument not allowed\n+   |\n+help: primitive type `u8` doesn't have type parameters\n+   |\n+LL - let _x: u8<isize>;\n+LL + let _x: u8;\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:11:12\n+  --> $DIR/prim-with-args.rs:11:13\n    |\n-LL | let x: u32<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: u16<isize>;\n+   |             ^^^^^ type argument not allowed\n+   |\n+help: primitive type `u16` doesn't have type parameters\n+   |\n+LL - let _x: u16<isize>;\n+LL + let _x: u16;\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:12:12\n+  --> $DIR/prim-with-args.rs:12:13\n    |\n-LL | let x: u64<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: u32<isize>;\n+   |             ^^^^^ type argument not allowed\n+   |\n+help: primitive type `u32` doesn't have type parameters\n+   |\n+LL - let _x: u32<isize>;\n+LL + let _x: u32;\n+   | \n \n error[E0109]: type arguments are not allowed for this type\n   --> $DIR/prim-with-args.rs:13:13\n    |\n-LL | let x: char<isize>;\n+LL | let _x: u64<isize>;\n    |             ^^^^^ type argument not allowed\n+   |\n+help: primitive type `u64` doesn't have type parameters\n+   |\n+LL - let _x: u64<isize>;\n+LL + let _x: u64;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:15:14\n+error[E0109]: type arguments are not allowed for this type\n+  --> $DIR/prim-with-args.rs:14:14\n    |\n-LL | let x: isize<'static>;\n-   |              ^^^^^^^ lifetime argument not allowed\n+LL | let _x: char<isize>;\n+   |              ^^^^^ type argument not allowed\n+   |\n+help: primitive type `char` doesn't have type parameters\n+   |\n+LL - let _x: char<isize>;\n+LL + let _x: char;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:16:11\n+  --> $DIR/prim-with-args.rs:16:15\n+   |\n+LL | let _x: isize<'static>;\n+   |               ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `isize` doesn't have type parameters\n    |\n-LL | let x: i8<'static>;\n-   |           ^^^^^^^ lifetime argument not allowed\n+LL - let _x: isize<'static>;\n+LL + let _x: isize;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n   --> $DIR/prim-with-args.rs:17:12\n    |\n-LL | let x: i16<'static>;\n+LL | let _x: i8<'static>;\n    |            ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `i8` doesn't have type parameters\n+   |\n+LL - let _x: i8<'static>;\n+LL + let _x: i8;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:18:12\n+  --> $DIR/prim-with-args.rs:18:13\n    |\n-LL | let x: i32<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: i16<'static>;\n+   |             ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `i16` doesn't have type parameters\n+   |\n+LL - let _x: i16<'static>;\n+LL + let _x: i16;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:19:12\n+  --> $DIR/prim-with-args.rs:19:13\n    |\n-LL | let x: i64<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: i32<'static>;\n+   |             ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `i32` doesn't have type parameters\n+   |\n+LL - let _x: i32<'static>;\n+LL + let _x: i32;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:20:14\n+  --> $DIR/prim-with-args.rs:20:13\n    |\n-LL | let x: usize<'static>;\n-   |              ^^^^^^^ lifetime argument not allowed\n+LL | let _x: i64<'static>;\n+   |             ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `i64` doesn't have type parameters\n+   |\n+LL - let _x: i64<'static>;\n+LL + let _x: i64;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:21:11\n+  --> $DIR/prim-with-args.rs:21:15\n+   |\n+LL | let _x: usize<'static>;\n+   |               ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `usize` doesn't have type parameters\n    |\n-LL | let x: u8<'static>;\n-   |           ^^^^^^^ lifetime argument not allowed\n+LL - let _x: usize<'static>;\n+LL + let _x: usize;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n   --> $DIR/prim-with-args.rs:22:12\n    |\n-LL | let x: u16<'static>;\n+LL | let _x: u8<'static>;\n    |            ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `u8` doesn't have type parameters\n+   |\n+LL - let _x: u8<'static>;\n+LL + let _x: u8;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:23:12\n+  --> $DIR/prim-with-args.rs:23:13\n    |\n-LL | let x: u32<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: u16<'static>;\n+   |             ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `u16` doesn't have type parameters\n+   |\n+LL - let _x: u16<'static>;\n+LL + let _x: u16;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:24:12\n+  --> $DIR/prim-with-args.rs:24:13\n    |\n-LL | let x: u64<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: u32<'static>;\n+   |             ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `u32` doesn't have type parameters\n+   |\n+LL - let _x: u32<'static>;\n+LL + let _x: u32;\n+   | \n \n error[E0109]: lifetime arguments are not allowed for this type\n   --> $DIR/prim-with-args.rs:25:13\n    |\n-LL | let x: char<'static>;\n+LL | let _x: u64<'static>;\n    |             ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `u64` doesn't have type parameters\n+   |\n+LL - let _x: u64<'static>;\n+LL + let _x: u64;\n+   | \n+\n+error[E0109]: lifetime arguments are not allowed for this type\n+  --> $DIR/prim-with-args.rs:26:14\n+   |\n+LL | let _x: char<'static>;\n+   |              ^^^^^^^ lifetime argument not allowed\n+   |\n+help: primitive type `char` doesn't have type parameters\n+   |\n+LL - let _x: char<'static>;\n+LL + let _x: char;\n+   | \n \n error: aborting due to 22 previous errors\n "}, {"sha": "98505d7bbe8b05a4a2cfa9c12ec1839d0a93b7fd", "filename": "src/test/ui/usize-generic-argument-parent.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Fusize-generic-argument-parent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b2d80a197453001f9acd40020c1db6c0178c7fe/src%2Ftest%2Fui%2Fusize-generic-argument-parent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fusize-generic-argument-parent.stderr?ref=9b2d80a197453001f9acd40020c1db6c0178c7fe", "patch": "@@ -3,6 +3,12 @@ error[E0109]: const arguments are not allowed for this type\n    |\n LL |     let x: usize<foo>;\n    |                  ^^^ const argument not allowed\n+   |\n+help: primitive type `usize` doesn't have type parameters\n+   |\n+LL -     let x: usize<foo>;\n+LL +     let x: usize;\n+   | \n \n error: aborting due to previous error\n "}]}