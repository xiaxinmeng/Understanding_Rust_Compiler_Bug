{"sha": "e1de70b04548b2e899fcf0da09c29600cc05325e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZGU3MGIwNDU0OGIyZTg5OWZjZjBkYTA5YzI5NjAwY2MwNTMyNWU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-25T21:21:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-25T21:21:00Z"}, "message": "Rollup merge of #62735 - petrochenkov:galloc, r=alexcrichton\n\nTurn `#[global_allocator]` into a regular attribute macro\n\nIt was a 99% macro with exception of some diagnostic details.\n\nAs a result of the change, `#[global_allocator]` now works in nested modules and even in nameless blocks.\n\nFixes https://github.com/rust-lang/rust/issues/44113\nFixes https://github.com/rust-lang/rust/issues/58072", "tree": {"sha": "a74148f96104c5972f121069a0cfcab089d8082e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a74148f96104c5972f121069a0cfcab089d8082e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1de70b04548b2e899fcf0da09c29600cc05325e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdOh08CRBK7hj4Ov3rIwAAdHIIAHHqPtueMS5EbDeer6Moiw/t\nMvk/yX5vvCAoRrmUg7PXDMVKfY++GP2oZuyK18w0eQJGk4YB7x8uXeEhyrU1+jWS\ncHmiMdjMVEX28XFFWnXbqMqI58XLIKUcf+Vm1gtmk6cwiqndNwLjBFwzGxVKo6zN\n3sB4E/LaPcEnxYYFGR84G4pH5BdMY4Jf/WL1CtCusGeGZxpxj5ptETZ3NM9nOl5H\n9x7+CjJNWD6TgkLZfDil8wTZgvJDkCiI2fdaMCcnPH2E220ZHelEDVlpiSvBNKfA\nFFy7Pcm3ZiqkuTMISVPfOLDc5Ieda4lEQtjvyu+gNtkKRF/jxVqRJ01Oqvm5814=\n=OyBr\n-----END PGP SIGNATURE-----\n", "payload": "tree a74148f96104c5972f121069a0cfcab089d8082e\nparent 6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c\nparent a0c2c640d54fa1622c2fea4accae1025bf109c47\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564089660 +0200\ncommitter GitHub <noreply@github.com> 1564089660 +0200\n\nRollup merge of #62735 - petrochenkov:galloc, r=alexcrichton\n\nTurn `#[global_allocator]` into a regular attribute macro\n\nIt was a 99% macro with exception of some diagnostic details.\n\nAs a result of the change, `#[global_allocator]` now works in nested modules and even in nameless blocks.\n\nFixes https://github.com/rust-lang/rust/issues/44113\nFixes https://github.com/rust-lang/rust/issues/58072\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1de70b04548b2e899fcf0da09c29600cc05325e", "html_url": "https://github.com/rust-lang/rust/commit/e1de70b04548b2e899fcf0da09c29600cc05325e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1de70b04548b2e899fcf0da09c29600cc05325e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c", "html_url": "https://github.com/rust-lang/rust/commit/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c"}, {"sha": "a0c2c640d54fa1622c2fea4accae1025bf109c47", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c2c640d54fa1622c2fea4accae1025bf109c47", "html_url": "https://github.com/rust-lang/rust/commit/a0c2c640d54fa1622c2fea4accae1025bf109c47"}], "stats": {"total": 1106, "additions": 513, "deletions": 593}, "files": [{"sha": "8993254627863540e842d6ebb48e3f91b2319cea", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -2751,20 +2751,6 @@ dependencies = [\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc_allocator\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc 0.0.0\",\n- \"rustc_data_structures 0.0.0\",\n- \"rustc_errors 0.0.0\",\n- \"rustc_target 0.0.0\",\n- \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntax 0.0.0\",\n- \"syntax_pos 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc_apfloat\"\n version = \"0.0.0\"\n@@ -2822,7 +2808,6 @@ dependencies = [\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_allocator 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -2883,7 +2868,6 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_allocator 0.0.0\",\n  \"rustc_ast_borrowck 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -2904,7 +2888,6 @@ dependencies = [\n  \"serialize 0.0.0\",\n  \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n- \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n@@ -2948,7 +2931,6 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_allocator 0.0.0\",\n  \"rustc_ast_borrowck 0.0.0\",\n  \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\","}, {"sha": "17781798946ed8d71f86b467ca18e09208a619ef", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -1281,6 +1281,13 @@ mod builtin {\n     #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test_case($item:item) { /* compiler built-in */ }\n \n+    /// Attribute macro applied to a static to register it as a global allocator.\n+    #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n+    #[allow_internal_unstable(rustc_attrs)]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro global_allocator($item:item) { /* compiler built-in */ }\n+\n     /// Derive macro generating an impl of the trait `Clone`.\n     #[rustc_builtin_macro]\n     #[rustc_macro_transparency = \"semitransparent\"]"}, {"sha": "79f60778d3cf397e65ebbb2a311fa965e99f6771", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -104,7 +104,6 @@ pub mod infer;\n pub mod lint;\n \n pub mod middle {\n-    pub mod allocator;\n     pub mod borrowck;\n     pub mod expr_use_visitor;\n     pub mod cstore;"}, {"sha": "bb2e3b4ec19715c7f2bc830dce78b164a56addb3", "filename": "src/librustc/middle/allocator.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Flibrustc%2Fmiddle%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Flibrustc%2Fmiddle%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fallocator.rs?ref=6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c", "patch": "@@ -1,16 +0,0 @@\n-#[derive(Clone, Copy)]\n-pub enum AllocatorKind {\n-    Global,\n-    DefaultLib,\n-    DefaultExe,\n-}\n-\n-impl AllocatorKind {\n-    pub fn fn_name(&self, base: &str) -> String {\n-        match *self {\n-            AllocatorKind::Global => format!(\"__rg_{}\", base),\n-            AllocatorKind::DefaultLib => format!(\"__rdl_{}\", base),\n-            AllocatorKind::DefaultExe => format!(\"__rde_{}\", base),\n-        }\n-    }\n-}"}, {"sha": "88de77829a6e06fc28da53a50f331fd61fec1b5a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -320,11 +320,6 @@ fn has_allow_dead_code_or_lang_attr(\n         return true;\n     }\n \n-    // Don't lint about global allocators\n-    if attr::contains_name(attrs, sym::global_allocator) {\n-        return true;\n-    }\n-\n     let def_id = tcx.hir().local_def_id(id);\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n "}, {"sha": "61dac678912dff657868accb27c0a620c1168778", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::fingerprint::Fingerprint;\n \n use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::middle::allocator::AllocatorKind;\n use crate::middle::dependency_format;\n use crate::session::config::{OutputType, PrintRequest, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n@@ -27,6 +26,7 @@ use errors::emitter::HumanReadableErrorType;\n use errors::annotate_snippet_emitter_writer::{AnnotateSnippetEmitterWriter};\n use syntax::ast::{self, NodeId};\n use syntax::edition::Edition;\n+use syntax::ext::allocator::AllocatorKind;\n use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n use syntax::source_map;"}, {"sha": "a964f323c9e7d06214eb8831b2fbbc81a13bee58", "filename": "src/librustc_allocator/Cargo.toml", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Flibrustc_allocator%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Flibrustc_allocator%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2FCargo.toml?ref=6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c", "patch": "@@ -1,19 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_allocator\"\n-version = \"0.0.0\"\n-edition = \"2018\"\n-\n-[lib]\n-path = \"lib.rs\"\n-test = false\n-\n-[dependencies]\n-rustc = { path = \"../librustc\" }\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n-rustc_target = { path = \"../librustc_target\" }\n-syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n-log = \"0.4\"\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "af63fffc0f9b4074a7fd32b0f9ed733d40e6c562", "filename": "src/librustc_allocator/expand.rs", "status": "removed", "additions": 0, "deletions": 298, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c", "patch": "@@ -1,298 +0,0 @@\n-use log::debug;\n-use rustc::middle::allocator::AllocatorKind;\n-use smallvec::{smallvec, SmallVec};\n-use syntax::{\n-    ast::{\n-        self, Arg, Attribute, Crate, Expr, FnHeader, Generics, Ident, Item, ItemKind,\n-        Mac, Mod, Mutability, Ty, TyKind, Unsafety, VisibilityKind,\n-    },\n-    attr,\n-    source_map::{\n-        respan, ExpnInfo, ExpnKind,\n-    },\n-    ext::{\n-        base::{ExtCtxt, MacroKind, Resolver},\n-        build::AstBuilder,\n-        expand::ExpansionConfig,\n-        hygiene::ExpnId,\n-    },\n-    mut_visit::{self, MutVisitor},\n-    parse::ParseSess,\n-    ptr::P,\n-    symbol::{kw, sym}\n-};\n-use syntax_pos::Span;\n-\n-use crate::{AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n-\n-pub fn modify(\n-    sess: &ParseSess,\n-    resolver: &mut dyn Resolver,\n-    krate: &mut Crate,\n-    crate_name: String,\n-    handler: &rustc_errors::Handler,\n-) {\n-    ExpandAllocatorDirectives {\n-        handler,\n-        sess,\n-        resolver,\n-        found: false,\n-        crate_name: Some(crate_name),\n-        in_submod: -1, // -1 to account for the \"root\" module\n-    }.visit_crate(krate);\n-}\n-\n-struct ExpandAllocatorDirectives<'a> {\n-    found: bool,\n-    handler: &'a rustc_errors::Handler,\n-    sess: &'a ParseSess,\n-    resolver: &'a mut dyn Resolver,\n-    crate_name: Option<String>,\n-\n-    // For now, we disallow `global_allocator` in submodules because hygiene is hard. Keep track of\n-    // whether we are in a submodule or not. If `in_submod > 0` we are in a submodule.\n-    in_submod: isize,\n-}\n-\n-impl MutVisitor for ExpandAllocatorDirectives<'_> {\n-    fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n-        debug!(\"in submodule {}\", self.in_submod);\n-\n-        if !attr::contains_name(&item.attrs, sym::global_allocator) {\n-            return mut_visit::noop_flat_map_item(item, self);\n-        }\n-\n-        match item.node {\n-            ItemKind::Static(..) => {}\n-            _ => {\n-                self.handler\n-                    .span_err(item.span, \"allocators must be statics\");\n-                return smallvec![item];\n-            }\n-        }\n-\n-        if self.in_submod > 0 {\n-            self.handler\n-                .span_err(item.span, \"`global_allocator` cannot be used in submodules\");\n-            return smallvec![item];\n-        }\n-\n-        if self.found {\n-            self.handler\n-                .span_err(item.span, \"cannot define more than one `#[global_allocator]`\");\n-            return smallvec![item];\n-        }\n-        self.found = true;\n-\n-        // Create a new expansion for the generated allocator code.\n-        let span = item.span.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n-            ExpnKind::Macro(MacroKind::Attr, sym::global_allocator), item.span, self.sess.edition,\n-            [sym::rustc_attrs][..].into(),\n-        ));\n-\n-        // Create an expansion config\n-        let ecfg = ExpansionConfig::default(self.crate_name.take().unwrap());\n-\n-        // Generate a bunch of new items using the AllocFnFactory\n-        let mut f = AllocFnFactory {\n-            span,\n-            kind: AllocatorKind::Global,\n-            global: item.ident,\n-            core: Ident::with_empty_ctxt(sym::core),\n-            cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n-        };\n-\n-        // We will generate a new submodule. To `use` the static from that module, we need to get\n-        // the `super::...` path.\n-        let super_path = f.cx.path(f.span, vec![Ident::with_empty_ctxt(kw::Super), f.global]);\n-\n-        // Generate the items in the submodule\n-        let mut items = vec![\n-            // import `core` to use allocators\n-            f.cx.item_extern_crate(f.span, f.core),\n-            // `use` the `global_allocator` in `super`\n-            f.cx.item_use_simple(\n-                f.span,\n-                respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n-                super_path,\n-            ),\n-        ];\n-\n-        // Add the allocator methods to the submodule\n-        items.extend(\n-            ALLOCATOR_METHODS\n-                .iter()\n-                .map(|method| f.allocator_fn(method)),\n-        );\n-\n-        // Generate the submodule itself\n-        let name = f.kind.fn_name(\"allocator_abi\");\n-        let allocator_abi = Ident::from_str(&name).gensym();\n-        let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n-        let module = f.cx.monotonic_expander().flat_map_item(module).pop().unwrap();\n-\n-        // Return the item and new submodule\n-        smallvec![item, module]\n-    }\n-\n-    // If we enter a submodule, take note.\n-    fn visit_mod(&mut self, m: &mut Mod) {\n-        debug!(\"enter submodule\");\n-        self.in_submod += 1;\n-        mut_visit::noop_visit_mod(m, self);\n-        self.in_submod -= 1;\n-        debug!(\"exit submodule\");\n-    }\n-\n-    // `visit_mac` is disabled by default. Enable it here.\n-    fn visit_mac(&mut self, mac: &mut Mac) {\n-        mut_visit::noop_visit_mac(mac, self)\n-    }\n-}\n-\n-struct AllocFnFactory<'a> {\n-    span: Span,\n-    kind: AllocatorKind,\n-    global: Ident,\n-    core: Ident,\n-    cx: ExtCtxt<'a>,\n-}\n-\n-impl AllocFnFactory<'_> {\n-    fn allocator_fn(&self, method: &AllocatorMethod) -> P<Item> {\n-        let mut abi_args = Vec::new();\n-        let mut i = 0;\n-        let ref mut mk = || {\n-            let name = Ident::from_str(&format!(\"arg{}\", i));\n-            i += 1;\n-            name\n-        };\n-        let args = method\n-            .inputs\n-            .iter()\n-            .map(|ty| self.arg_ty(ty, &mut abi_args, mk))\n-            .collect();\n-        let result = self.call_allocator(method.name, args);\n-        let (output_ty, output_expr) = self.ret_ty(&method.output, result);\n-        let kind = ItemKind::Fn(\n-            self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n-            FnHeader {\n-                unsafety: Unsafety::Unsafe,\n-                ..FnHeader::default()\n-            },\n-            Generics::default(),\n-            self.cx.block_expr(output_expr),\n-        );\n-        self.cx.item(\n-            self.span,\n-            Ident::from_str(&self.kind.fn_name(method.name)),\n-            self.attrs(),\n-            kind,\n-        )\n-    }\n-\n-    fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n-        let method = self.cx.path(\n-            self.span,\n-            vec![\n-                self.core,\n-                Ident::from_str(\"alloc\"),\n-                Ident::from_str(\"GlobalAlloc\"),\n-                Ident::from_str(method),\n-            ],\n-        );\n-        let method = self.cx.expr_path(method);\n-        let allocator = self.cx.path_ident(self.span, self.global);\n-        let allocator = self.cx.expr_path(allocator);\n-        let allocator = self.cx.expr_addr_of(self.span, allocator);\n-        args.insert(0, allocator);\n-\n-        self.cx.expr_call(self.span, method, args)\n-    }\n-\n-    fn attrs(&self) -> Vec<Attribute> {\n-        let special = sym::rustc_std_internal_symbol;\n-        let special = self.cx.meta_word(self.span, special);\n-        vec![self.cx.attribute(self.span, special)]\n-    }\n-\n-    fn arg_ty(\n-        &self,\n-        ty: &AllocatorTy,\n-        args: &mut Vec<Arg>,\n-        ident: &mut dyn FnMut() -> Ident,\n-    ) -> P<Expr> {\n-        match *ty {\n-            AllocatorTy::Layout => {\n-                let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n-                let ty_usize = self.cx.ty_path(usize);\n-                let size = ident();\n-                let align = ident();\n-                args.push(self.cx.arg(self.span, size, ty_usize.clone()));\n-                args.push(self.cx.arg(self.span, align, ty_usize));\n-\n-                let layout_new = self.cx.path(\n-                    self.span,\n-                    vec![\n-                        self.core,\n-                        Ident::from_str(\"alloc\"),\n-                        Ident::from_str(\"Layout\"),\n-                        Ident::from_str(\"from_size_align_unchecked\"),\n-                    ],\n-                );\n-                let layout_new = self.cx.expr_path(layout_new);\n-                let size = self.cx.expr_ident(self.span, size);\n-                let align = self.cx.expr_ident(self.span, align);\n-                let layout = self.cx.expr_call(self.span, layout_new, vec![size, align]);\n-                layout\n-            }\n-\n-            AllocatorTy::Ptr => {\n-                let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n-                let arg = self.cx.expr_ident(self.span, ident);\n-                self.cx.expr_cast(self.span, arg, self.ptr_u8())\n-            }\n-\n-            AllocatorTy::Usize => {\n-                let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.usize()));\n-                self.cx.expr_ident(self.span, ident)\n-            }\n-\n-            AllocatorTy::ResultPtr | AllocatorTy::Unit => {\n-                panic!(\"can't convert AllocatorTy to an argument\")\n-            }\n-        }\n-    }\n-\n-    fn ret_ty(&self, ty: &AllocatorTy, expr: P<Expr>) -> (P<Ty>, P<Expr>) {\n-        match *ty {\n-            AllocatorTy::ResultPtr => {\n-                // We're creating:\n-                //\n-                //      #expr as *mut u8\n-\n-                let expr = self.cx.expr_cast(self.span, expr, self.ptr_u8());\n-                (self.ptr_u8(), expr)\n-            }\n-\n-            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr),\n-\n-            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n-                panic!(\"can't convert `AllocatorTy` to an output\")\n-            }\n-        }\n-    }\n-\n-    fn usize(&self) -> P<Ty> {\n-        let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n-        self.cx.ty_path(usize)\n-    }\n-\n-    fn ptr_u8(&self) -> P<Ty> {\n-        let u8 = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::u8));\n-        let ty_u8 = self.cx.ty_path(u8);\n-        self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n-    }\n-}"}, {"sha": "8d380c47bc4a371360b12198f7901b82dd9cd860", "filename": "src/librustc_allocator/lib.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c", "patch": "@@ -1,44 +0,0 @@\n-#![feature(nll)]\n-#![feature(rustc_private)]\n-\n-#![deny(rust_2018_idioms)]\n-#![deny(unused_lifetimes)]\n-\n-pub mod expand;\n-\n-pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n-    AllocatorMethod {\n-        name: \"alloc\",\n-        inputs: &[AllocatorTy::Layout],\n-        output: AllocatorTy::ResultPtr,\n-    },\n-    AllocatorMethod {\n-        name: \"dealloc\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n-        output: AllocatorTy::Unit,\n-    },\n-    AllocatorMethod {\n-        name: \"realloc\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Usize],\n-        output: AllocatorTy::ResultPtr,\n-    },\n-    AllocatorMethod {\n-        name: \"alloc_zeroed\",\n-        inputs: &[AllocatorTy::Layout],\n-        output: AllocatorTy::ResultPtr,\n-    },\n-];\n-\n-pub struct AllocatorMethod {\n-    pub name: &'static str,\n-    pub inputs: &'static [AllocatorTy],\n-    pub output: AllocatorTy,\n-}\n-\n-pub enum AllocatorTy {\n-    Layout,\n-    Ptr,\n-    ResultPtr,\n-    Unit,\n-    Usize,\n-}"}, {"sha": "5d43bf6ae28bf662c208365f483ac7732bf4790d", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -2,9 +2,8 @@ use std::ffi::CString;\n \n use crate::attributes;\n use libc::c_uint;\n-use rustc::middle::allocator::AllocatorKind;\n use rustc::ty::TyCtxt;\n-use rustc_allocator::{ALLOCATOR_METHODS, AllocatorTy};\n+use syntax::ext::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n \n use crate::ModuleLlvm;\n use crate::llvm::{self, False, True};"}, {"sha": "8dd241bd81a0a1490cb0da0b6af4e42d8225c8e5", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -32,7 +32,6 @@ extern crate flate2;\n #[macro_use] extern crate bitflags;\n extern crate libc;\n #[macro_use] extern crate rustc;\n-extern crate rustc_allocator;\n extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n extern crate rustc_incremental;\n@@ -52,13 +51,13 @@ use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinModul\n use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n+use syntax::ext::allocator::AllocatorKind;\n use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n \n use rustc::dep_graph::DepGraph;\n-use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::session::Session;\n use rustc::session::config::{OutputFilenames, OutputType, PrintRequest, OptLevel};"}, {"sha": "89a6ec27fe595b65c14a1ceb1d53c79d8f60322b", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -24,7 +24,6 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc = { path = \"../librustc\" }\n-rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_data_structures = { path = \"../librustc_data_structures\"}"}, {"sha": "2d9220f897cff63f43c9c42dfdd0f9a466ee8b5f", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -1,3 +1,4 @@\n+use std::collections::hash_map::Entry::*;\n use std::sync::Arc;\n \n use rustc::ty::Instance;\n@@ -12,9 +13,8 @@ use rustc::ty::{TyCtxt, SymbolName};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::util::nodemap::{FxHashMap, DefIdMap};\n-use rustc_allocator::ALLOCATOR_METHODS;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use std::collections::hash_map::Entry::*;\n+use syntax::ext::allocator::ALLOCATOR_METHODS;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,"}, {"sha": "9fbb44dcc9959dfc627f5b441c744d5e9b7c526f", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -3,12 +3,12 @@ use rustc::ty::Ty;\n \n use super::write::WriteBackendMethods;\n use super::CodegenObject;\n-use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::session::{Session, config};\n use rustc::ty::TyCtxt;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use std::sync::Arc;\n+use syntax::ext::allocator::AllocatorKind;\n use syntax_pos::symbol::InternedString;\n \n pub trait BackendTypes {"}, {"sha": "e8c9828a202efdc4e0ca0a96427cb0010a3bd995", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -16,7 +16,6 @@ log = \"0.4\"\n env_logger = { version = \"0.5\", default-features = false }\n rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n rustc = { path = \"../librustc\" }\n-rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n@@ -37,5 +36,4 @@ rustc_interface = { path = \"../librustc_interface\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n-syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "4937801d311ff82eb72ba5eb87f24be15551e5c7", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -18,7 +18,6 @@ syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc = { path = \"../librustc\" }\n-rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_traits = { path = \"../librustc_traits\" }"}, {"sha": "1cc7cfda0120af5a1d90d8a5aa257afd40f04671", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -469,7 +469,7 @@ fn configure_and_expand_inner<'a>(\n         util::ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n     }\n \n-    let (has_proc_macro_decls, has_global_allocator) = time(sess, \"AST validation\", || {\n+    let has_proc_macro_decls = time(sess, \"AST validation\", || {\n         ast_validation::check_crate(sess, &krate)\n     });\n \n@@ -495,19 +495,6 @@ fn configure_and_expand_inner<'a>(\n         });\n     }\n \n-    if has_global_allocator {\n-        // Expand global allocators, which are treated as an in-tree proc macro\n-        time(sess, \"creating allocators\", || {\n-            allocator::expand::modify(\n-                &sess.parse_sess,\n-                &mut resolver,\n-                &mut krate,\n-                crate_name.to_string(),\n-                sess.diagnostic(),\n-            )\n-        });\n-    }\n-\n     // Done with macro expansion!\n \n     if sess.opts.debugging_opts.input_stats {"}, {"sha": "b63d14ca949ee6b7b8189e5d71c068f0d75e480d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -36,10 +36,10 @@ use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::ast::Expr;\n-use syntax::attr::{self, HasAttrs};\n+use syntax::attr::{self, HasAttrs, AttributeTemplate};\n use syntax::source_map::Spanned;\n use syntax::edition::Edition;\n-use syntax::feature_gate::{AttributeGate, AttributeTemplate, AttributeType};\n+use syntax::feature_gate::{AttributeGate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span, SyntaxContext};\n use syntax::symbol::{Symbol, kw, sym};"}, {"sha": "3404ec5e173bdfd93aed4325d61c8da79d86c8d9", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -8,7 +8,6 @@ use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n-use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::DepKind;\n use rustc::mir::interpret::AllocDecodingState;\n use rustc::session::{Session, CrateDisambiguator};\n@@ -26,9 +25,9 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::allocator::{global_allocator_spans, AllocatorKind};\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n-use syntax::visit;\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n@@ -888,7 +887,14 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n-        let has_global_allocator = has_global_allocator(krate);\n+        let has_global_allocator = match &*global_allocator_spans(krate) {\n+            [span1, span2, ..] => {\n+                self.sess.struct_span_err(*span2, \"cannot define multiple global allocators\")\n+                         .span_note(*span1, \"the previous global allocator is defined here\").emit();\n+                true\n+            }\n+            spans => !spans.is_empty()\n+        };\n         self.sess.has_global_allocator.set(has_global_allocator);\n \n         // Check to see if we actually need an allocator. This desire comes\n@@ -975,25 +981,8 @@ impl<'a> CrateLoader<'a> {\n                            that implements the GlobalAlloc trait.\");\n         }\n         self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n-\n-        fn has_global_allocator(krate: &ast::Crate) -> bool {\n-            struct Finder(bool);\n-            let mut f = Finder(false);\n-            visit::walk_crate(&mut f, krate);\n-            return f.0;\n-\n-            impl<'ast> visit::Visitor<'ast> for Finder {\n-                fn visit_item(&mut self, i: &'ast ast::Item) {\n-                    if attr::contains_name(&i.attrs, sym::global_allocator) {\n-                        self.0 = true;\n-                    }\n-                    visit::walk_item(self, i)\n-                }\n-            }\n-        }\n     }\n \n-\n     fn inject_dependency_if(&self,\n                             krate: CrateNum,\n                             what: &str,"}, {"sha": "8db3ec491df8331d0e3ab58ce7c8b2291cf5f284", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -1,16 +1,17 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(box_patterns)]\n+#![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(libc)]\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(crate_visibility_modifier)]\n-#![feature(specialization)]\n #![feature(rustc_private)]\n+#![feature(slice_patterns)]\n+#![feature(specialization)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "b550029d9786d33bdc962ac0e3f718825d2525df", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -51,7 +51,6 @@ impl OuterImplTrait {\n struct AstValidator<'a> {\n     session: &'a Session,\n     has_proc_macro_decls: bool,\n-    has_global_allocator: bool,\n \n     /// Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n     /// Nested `impl Trait` _is_ allowed in associated type position,\n@@ -539,10 +538,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if attr::contains_name(&item.attrs, sym::global_allocator) {\n-            self.has_global_allocator = true;\n-        }\n-\n         match item.node {\n             ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, None);\n@@ -848,11 +843,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n }\n \n-pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n+pub fn check_crate(session: &Session, krate: &Crate) -> bool {\n     let mut validator = AstValidator {\n         session,\n         has_proc_macro_decls: false,\n-        has_global_allocator: false,\n         outer_impl_trait: None,\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n@@ -861,5 +855,5 @@ pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n     };\n     visit::walk_crate(&mut validator, krate);\n \n-    (validator.has_proc_macro_decls, validator.has_global_allocator)\n+    validator.has_proc_macro_decls\n }"}, {"sha": "dbf31ad0148325a1e3eda47eea8cfb9d1bd2de33", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -1,6 +1,9 @@\n //! Parsing and validation of builtin attributes\n \n use crate::ast::{self, Attribute, MetaItem, NestedMetaItem};\n+use crate::early_buffered_lints::BufferedEarlyLintId;\n+use crate::ext::base::ExtCtxt;\n+use crate::ext::build::AstBuilder;\n use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n@@ -19,6 +22,27 @@ enum AttrError {\n     UnsupportedLiteral(&'static str, /* is_bytestr */ bool),\n }\n \n+/// A template that the attribute input must match.\n+/// Only top-level shape (`#[attr]` vs `#[attr(...)]` vs `#[attr = ...]`) is considered now.\n+#[derive(Clone, Copy)]\n+pub struct AttributeTemplate {\n+    crate word: bool,\n+    crate list: Option<&'static str>,\n+    crate name_value_str: Option<&'static str>,\n+}\n+\n+impl AttributeTemplate {\n+    /// Checks that the given meta-item is compatible with this template.\n+    fn compatible(&self, meta_item_kind: &ast::MetaItemKind) -> bool {\n+        match meta_item_kind {\n+            ast::MetaItemKind::Word => self.word,\n+            ast::MetaItemKind::List(..) => self.list.is_some(),\n+            ast::MetaItemKind::NameValue(lit) if lit.node.is_str() => self.name_value_str.is_some(),\n+            ast::MetaItemKind::NameValue(..) => false,\n+        }\n+    }\n+}\n+\n fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n     let diag = &sess.span_diagnostic;\n     match error {\n@@ -901,3 +925,76 @@ pub fn find_transparency(\n     let fallback = if is_legacy { Transparency::SemiTransparent } else { Transparency::Opaque };\n     (transparency.map_or(fallback, |t| t.0), error)\n }\n+\n+pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, name: Symbol) {\n+    // All the built-in macro attributes are \"words\" at the moment.\n+    let template = AttributeTemplate { word: true, list: None, name_value_str: None };\n+    let attr = ecx.attribute(meta_item.span, meta_item.clone());\n+    check_builtin_attribute(ecx.parse_sess, &attr, name, template);\n+}\n+\n+crate fn check_builtin_attribute(\n+    sess: &ParseSess, attr: &ast::Attribute, name: Symbol, template: AttributeTemplate\n+) {\n+    // Some special attributes like `cfg` must be checked\n+    // before the generic check, so we skip them here.\n+    let should_skip = |name| name == sym::cfg;\n+    // Some of previously accepted forms were used in practice,\n+    // report them as warnings for now.\n+    let should_warn = |name| name == sym::doc || name == sym::ignore ||\n+                             name == sym::inline || name == sym::link ||\n+                             name == sym::test || name == sym::bench;\n+\n+    match attr.parse_meta(sess) {\n+        Ok(meta) => if !should_skip(name) && !template.compatible(&meta.node) {\n+            let error_msg = format!(\"malformed `{}` attribute input\", name);\n+            let mut msg = \"attribute must be of the form \".to_owned();\n+            let mut suggestions = vec![];\n+            let mut first = true;\n+            if template.word {\n+                first = false;\n+                let code = format!(\"#[{}]\", name);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if let Some(descr) = template.list {\n+                if !first {\n+                    msg.push_str(\" or \");\n+                }\n+                first = false;\n+                let code = format!(\"#[{}({})]\", name, descr);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if let Some(descr) = template.name_value_str {\n+                if !first {\n+                    msg.push_str(\" or \");\n+                }\n+                let code = format!(\"#[{} = \\\"{}\\\"]\", name, descr);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if should_warn(name) {\n+                sess.buffer_lint(\n+                    BufferedEarlyLintId::IllFormedAttributeInput,\n+                    meta.span,\n+                    ast::CRATE_NODE_ID,\n+                    &msg,\n+                );\n+            } else {\n+                sess.span_diagnostic.struct_span_err(meta.span, &error_msg)\n+                    .span_suggestions(\n+                        meta.span,\n+                        if suggestions.len() == 1 {\n+                            \"must be of the form\"\n+                        } else {\n+                            \"the following are the possible correct uses\"\n+                        },\n+                        suggestions.into_iter(),\n+                        Applicability::HasPlaceholders,\n+                    ).emit();\n+            }\n+        }\n+        Err(mut err) => err.emit(),\n+    }\n+}"}, {"sha": "99aeb5414c5d8d5b62057d8c6ae2499ce906146a", "filename": "src/libsyntax/ext/allocator.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax%2Fext%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax%2Fext%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fallocator.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -0,0 +1,75 @@\n+use crate::{ast, attr, visit};\n+use crate::symbol::{sym, Symbol};\n+use syntax_pos::Span;\n+\n+#[derive(Clone, Copy)]\n+pub enum AllocatorKind {\n+    Global,\n+    DefaultLib,\n+    DefaultExe,\n+}\n+\n+impl AllocatorKind {\n+    pub fn fn_name(&self, base: &str) -> String {\n+        match *self {\n+            AllocatorKind::Global => format!(\"__rg_{}\", base),\n+            AllocatorKind::DefaultLib => format!(\"__rdl_{}\", base),\n+            AllocatorKind::DefaultExe => format!(\"__rde_{}\", base),\n+        }\n+    }\n+}\n+\n+pub enum AllocatorTy {\n+    Layout,\n+    Ptr,\n+    ResultPtr,\n+    Unit,\n+    Usize,\n+}\n+\n+pub struct AllocatorMethod {\n+    pub name: &'static str,\n+    pub inputs: &'static [AllocatorTy],\n+    pub output: AllocatorTy,\n+}\n+\n+pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n+    AllocatorMethod {\n+        name: \"alloc\",\n+        inputs: &[AllocatorTy::Layout],\n+        output: AllocatorTy::ResultPtr,\n+    },\n+    AllocatorMethod {\n+        name: \"dealloc\",\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n+        output: AllocatorTy::Unit,\n+    },\n+    AllocatorMethod {\n+        name: \"realloc\",\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Usize],\n+        output: AllocatorTy::ResultPtr,\n+    },\n+    AllocatorMethod {\n+        name: \"alloc_zeroed\",\n+        inputs: &[AllocatorTy::Layout],\n+        output: AllocatorTy::ResultPtr,\n+    },\n+];\n+\n+pub fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder { name: Symbol, spans: Vec<Span> }\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n+        fn visit_item(&mut self, item: &'ast ast::Item) {\n+            if item.ident.name == self.name &&\n+               attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol) {\n+                self.spans.push(item.span);\n+            }\n+            visit::walk_item(self, item)\n+        }\n+    }\n+\n+    let name = Symbol::intern(&AllocatorKind::Global.fn_name(\"alloc\"));\n+    let mut f = Finder { name, spans: Vec::new() };\n+    visit::walk_crate(&mut f, krate);\n+    f.spans\n+}"}, {"sha": "72184b0bd6400374f59ad582793a44c6707a9b25", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 89, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -19,8 +19,7 @@ use crate::ast::{\n     self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n     PatKind, RangeEnd,\n };\n-use crate::attr;\n-use crate::early_buffered_lints::BufferedEarlyLintId;\n+use crate::attr::{self, check_builtin_attribute, AttributeTemplate};\n use crate::source_map::Spanned;\n use crate::edition::{ALL_EDITIONS, Edition};\n use crate::visit::{self, FnKind, Visitor};\n@@ -906,27 +905,6 @@ pub enum AttributeGate {\n     Ungated,\n }\n \n-/// A template that the attribute input must match.\n-/// Only top-level shape (`#[attr]` vs `#[attr(...)]` vs `#[attr = ...]`) is considered now.\n-#[derive(Clone, Copy)]\n-pub struct AttributeTemplate {\n-    word: bool,\n-    list: Option<&'static str>,\n-    name_value_str: Option<&'static str>,\n-}\n-\n-impl AttributeTemplate {\n-    /// Checks that the given meta-item is compatible with this template.\n-    fn compatible(&self, meta_item_kind: &ast::MetaItemKind) -> bool {\n-        match meta_item_kind {\n-            ast::MetaItemKind::Word => self.word,\n-            ast::MetaItemKind::List(..) => self.list.is_some(),\n-            ast::MetaItemKind::NameValue(lit) if lit.node.is_str() => self.name_value_str.is_some(),\n-            ast::MetaItemKind::NameValue(..) => false,\n-        }\n-    }\n-}\n-\n /// A convenience macro for constructing attribute templates.\n /// E.g., `template!(Word, List: \"description\")` means that the attribute\n /// supports forms `#[attr]` and `#[attr(description)]`.\n@@ -1117,7 +1095,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                             \"the `#[rustc_const_unstable]` attribute \\\n                                             is an internal feature\",\n                                             cfg_fn!(rustc_const_unstable))),\n-    (sym::global_allocator, Normal, template!(Word), Ungated),\n     (sym::default_lib_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n                                             sym::allocator_internals,\n                                             \"the `#[default_lib_allocator]` \\\n@@ -1902,70 +1879,6 @@ impl<'a> PostExpansionVisitor<'a> {\n             Abi::System => {}\n         }\n     }\n-\n-    fn check_builtin_attribute(&mut self, attr: &ast::Attribute, name: Symbol,\n-                               template: AttributeTemplate) {\n-        // Some special attributes like `cfg` must be checked\n-        // before the generic check, so we skip them here.\n-        let should_skip = |name| name == sym::cfg;\n-        // Some of previously accepted forms were used in practice,\n-        // report them as warnings for now.\n-        let should_warn = |name| name == sym::doc || name == sym::ignore ||\n-                                 name == sym::inline || name == sym::link;\n-\n-        match attr.parse_meta(self.context.parse_sess) {\n-            Ok(meta) => if !should_skip(name) && !template.compatible(&meta.node) {\n-                let error_msg = format!(\"malformed `{}` attribute input\", name);\n-                let mut msg = \"attribute must be of the form \".to_owned();\n-                let mut suggestions = vec![];\n-                let mut first = true;\n-                if template.word {\n-                    first = false;\n-                    let code = format!(\"#[{}]\", name);\n-                    msg.push_str(&format!(\"`{}`\", &code));\n-                    suggestions.push(code);\n-                }\n-                if let Some(descr) = template.list {\n-                    if !first {\n-                        msg.push_str(\" or \");\n-                    }\n-                    first = false;\n-                    let code = format!(\"#[{}({})]\", name, descr);\n-                    msg.push_str(&format!(\"`{}`\", &code));\n-                    suggestions.push(code);\n-                }\n-                if let Some(descr) = template.name_value_str {\n-                    if !first {\n-                        msg.push_str(\" or \");\n-                    }\n-                    let code = format!(\"#[{} = \\\"{}\\\"]\", name, descr);\n-                    msg.push_str(&format!(\"`{}`\", &code));\n-                    suggestions.push(code);\n-                }\n-                if should_warn(name) {\n-                    self.context.parse_sess.buffer_lint(\n-                        BufferedEarlyLintId::IllFormedAttributeInput,\n-                        meta.span,\n-                        ast::CRATE_NODE_ID,\n-                        &msg,\n-                    );\n-                } else {\n-                    self.context.parse_sess.span_diagnostic.struct_span_err(meta.span, &error_msg)\n-                        .span_suggestions(\n-                            meta.span,\n-                            if suggestions.len() == 1 {\n-                                \"must be of the form\"\n-                            } else {\n-                                \"the following are the possible correct uses\"\n-                            },\n-                            suggestions.into_iter(),\n-                            Applicability::HasPlaceholders,\n-                        ).emit();\n-                }\n-            }\n-            Err(mut err) => err.emit(),\n-        }\n-    }\n }\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n@@ -2006,7 +1919,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match attr_info {\n             // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n             Some(&(name, _, template, _)) if name != sym::rustc_dummy =>\n-                self.check_builtin_attribute(attr, name, template),\n+                check_builtin_attribute(self.context.parse_sess, attr, name, template),\n             _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n                 if token == token::Eq {\n                     // All key-value attributes are restricted to meta-item syntax."}, {"sha": "75b4e89ec01c259572a5322e20ca94aa355a88f8", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -162,6 +162,7 @@ pub mod print {\n \n pub mod ext {\n     pub use syntax_pos::hygiene;\n+    pub mod allocator;\n     pub mod base;\n     pub mod build;\n     pub mod derive;"}, {"sha": "33072487e19f4b520b42dabe66ff2d380b602f1d", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -0,0 +1,191 @@\n+use syntax::ast::{ItemKind, Mutability, Stmt, Ty, TyKind, Unsafety};\n+use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident};\n+use syntax::attr::check_builtin_macro_attribute;\n+use syntax::ext::allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::hygiene::SyntaxContext;\n+use syntax::ptr::P;\n+use syntax::symbol::{kw, sym, Symbol};\n+use syntax_pos::Span;\n+\n+pub fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n+\n+    let not_static = |item: Annotatable| {\n+        ecx.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+        vec![item]\n+    };\n+    let item = match item {\n+        Annotatable::Item(item) => match item.node {\n+            ItemKind::Static(..) => item,\n+            _ => return not_static(Annotatable::Item(item)),\n+        }\n+        _ => return not_static(item),\n+    };\n+\n+    // Generate a bunch of new items using the AllocFnFactory\n+    let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let f = AllocFnFactory {\n+        span,\n+        kind: AllocatorKind::Global,\n+        global: item.ident,\n+        cx: ecx,\n+    };\n+\n+    // Generate item statements for the allocator methods.\n+    let stmts = ALLOCATOR_METHODS.iter().map(|method| f.allocator_fn(method)).collect();\n+\n+    // Generate anonymous constant serving as container for the allocator methods.\n+    let const_ty = ecx.ty(span, TyKind::Tup(Vec::new()));\n+    let const_body = ecx.expr_block(ecx.block(span, stmts));\n+    let const_item =\n+        ecx.item_const(span, Ident::with_empty_ctxt(kw::Underscore), const_ty, const_body);\n+\n+    // Return the original item and the new methods.\n+    vec![Annotatable::Item(item), Annotatable::Item(const_item)]\n+}\n+\n+struct AllocFnFactory<'a, 'b> {\n+    span: Span,\n+    kind: AllocatorKind,\n+    global: Ident,\n+    cx: &'b ExtCtxt<'a>,\n+}\n+\n+impl AllocFnFactory<'_, '_> {\n+    fn allocator_fn(&self, method: &AllocatorMethod) -> Stmt {\n+        let mut abi_args = Vec::new();\n+        let mut i = 0;\n+        let ref mut mk = || {\n+            let name = Ident::from_str(&format!(\"arg{}\", i));\n+            i += 1;\n+            name\n+        };\n+        let args = method\n+            .inputs\n+            .iter()\n+            .map(|ty| self.arg_ty(ty, &mut abi_args, mk))\n+            .collect();\n+        let result = self.call_allocator(method.name, args);\n+        let (output_ty, output_expr) = self.ret_ty(&method.output, result);\n+        let kind = ItemKind::Fn(\n+            self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n+            FnHeader {\n+                unsafety: Unsafety::Unsafe,\n+                ..FnHeader::default()\n+            },\n+            Generics::default(),\n+            self.cx.block_expr(output_expr),\n+        );\n+        let item = self.cx.item(\n+            self.span,\n+            Ident::from_str(&self.kind.fn_name(method.name)),\n+            self.attrs(),\n+            kind,\n+        );\n+        self.cx.stmt_item(self.span, item)\n+    }\n+\n+    fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n+        let method = self.cx.std_path(&[\n+            Symbol::intern(\"alloc\"),\n+            Symbol::intern(\"GlobalAlloc\"),\n+            Symbol::intern(method),\n+        ]);\n+        let method = self.cx.expr_path(self.cx.path(self.span, method));\n+        let allocator = self.cx.path_ident(self.span, self.global);\n+        let allocator = self.cx.expr_path(allocator);\n+        let allocator = self.cx.expr_addr_of(self.span, allocator);\n+        args.insert(0, allocator);\n+\n+        self.cx.expr_call(self.span, method, args)\n+    }\n+\n+    fn attrs(&self) -> Vec<Attribute> {\n+        let special = sym::rustc_std_internal_symbol;\n+        let special = self.cx.meta_word(self.span, special);\n+        vec![self.cx.attribute(self.span, special)]\n+    }\n+\n+    fn arg_ty(\n+        &self,\n+        ty: &AllocatorTy,\n+        args: &mut Vec<Arg>,\n+        ident: &mut dyn FnMut() -> Ident,\n+    ) -> P<Expr> {\n+        match *ty {\n+            AllocatorTy::Layout => {\n+                let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n+                let ty_usize = self.cx.ty_path(usize);\n+                let size = ident();\n+                let align = ident();\n+                args.push(self.cx.arg(self.span, size, ty_usize.clone()));\n+                args.push(self.cx.arg(self.span, align, ty_usize));\n+\n+                let layout_new = self.cx.std_path(&[\n+                    Symbol::intern(\"alloc\"),\n+                    Symbol::intern(\"Layout\"),\n+                    Symbol::intern(\"from_size_align_unchecked\"),\n+                ]);\n+                let layout_new = self.cx.expr_path(self.cx.path(self.span, layout_new));\n+                let size = self.cx.expr_ident(self.span, size);\n+                let align = self.cx.expr_ident(self.span, align);\n+                let layout = self.cx.expr_call(self.span, layout_new, vec![size, align]);\n+                layout\n+            }\n+\n+            AllocatorTy::Ptr => {\n+                let ident = ident();\n+                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n+                let arg = self.cx.expr_ident(self.span, ident);\n+                self.cx.expr_cast(self.span, arg, self.ptr_u8())\n+            }\n+\n+            AllocatorTy::Usize => {\n+                let ident = ident();\n+                args.push(self.cx.arg(self.span, ident, self.usize()));\n+                self.cx.expr_ident(self.span, ident)\n+            }\n+\n+            AllocatorTy::ResultPtr | AllocatorTy::Unit => {\n+                panic!(\"can't convert AllocatorTy to an argument\")\n+            }\n+        }\n+    }\n+\n+    fn ret_ty(&self, ty: &AllocatorTy, expr: P<Expr>) -> (P<Ty>, P<Expr>) {\n+        match *ty {\n+            AllocatorTy::ResultPtr => {\n+                // We're creating:\n+                //\n+                //      #expr as *mut u8\n+\n+                let expr = self.cx.expr_cast(self.span, expr, self.ptr_u8());\n+                (self.ptr_u8(), expr)\n+            }\n+\n+            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr),\n+\n+            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                panic!(\"can't convert `AllocatorTy` to an output\")\n+            }\n+        }\n+    }\n+\n+    fn usize(&self) -> P<Ty> {\n+        let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n+        self.cx.ty_path(usize)\n+    }\n+\n+    fn ptr_u8(&self) -> P<Ty> {\n+        let u8 = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::u8));\n+        let ty_u8 = self.cx.ty_path(u8);\n+        self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n+    }\n+}"}, {"sha": "400bfe796bb0765793019b5bb7f51045cfbcf816", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -29,6 +29,7 @@ mod concat_idents;\n mod env;\n mod format;\n mod format_foreign;\n+mod global_allocator;\n mod global_asm;\n mod log_syntax;\n mod proc_macro_server;\n@@ -151,6 +152,12 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n             SyntaxExtensionKind::LegacyAttr(Box::new(test::expand_bench)), edition\n         )\n     });\n+    register(sym::global_allocator, SyntaxExtension {\n+        allow_internal_unstable: Some([sym::rustc_attrs][..].into()),\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyAttr(Box::new(global_allocator::expand)), edition\n+        )\n+    });\n \n     let allow_internal_unstable = Some([sym::fmt_internals][..].into());\n     register(sym::format_args, SyntaxExtension {"}, {"sha": "d381c42f9ce84a1b543912144a35272f90c1e7d1", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -1,31 +1,34 @@\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n \n+use syntax::ast;\n+use syntax::attr::{self, check_builtin_macro_attribute};\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n-use syntax::attr;\n-use syntax::ast;\n use syntax::print::pprust;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n+\n use std::iter;\n \n pub fn expand_test(\n     cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n-    _meta_item: &ast::MetaItem,\n+    meta_item: &ast::MetaItem,\n     item: Annotatable,\n ) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(cx, meta_item, sym::test);\n     expand_test_or_bench(cx, attr_sp, item, false)\n }\n \n pub fn expand_bench(\n     cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n-    _meta_item: &ast::MetaItem,\n+    meta_item: &ast::MetaItem,\n     item: Annotatable,\n ) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(cx, meta_item, sym::bench);\n     expand_test_or_bench(cx, attr_sp, item, true)\n }\n "}, {"sha": "ea4a8d541ab9928f8636bdde77b24a1adfc17532", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -9,20 +9,23 @@\n // We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n // logic will pick up on.\n \n+use syntax::ast;\n+use syntax::attr::check_builtin_macro_attribute;\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n-use syntax::ast;\n use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n-    _meta_item: &ast::MetaItem,\n+    meta_item: &ast::MetaItem,\n     anno_item: Annotatable\n ) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::test_case);\n+\n     if !ecx.ecfg.should_test { return vec![]; }\n \n     let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));"}, {"sha": "12813a1fc8bd4088818ab205bd9035ffe94b6e02", "filename": "src/test/run-pass/allocator/custom-in-block.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -0,0 +1,22 @@\n+// run-pass\n+// no-prefer-dynamic\n+// aux-build:custom.rs\n+// aux-build:helper.rs\n+\n+extern crate custom;\n+extern crate helper;\n+\n+use custom::A;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+fn main() {\n+    #[global_allocator]\n+    pub static GLOBAL: A = A(AtomicUsize::new(0));\n+\n+    let n = GLOBAL.0.load(Ordering::SeqCst);\n+    let s = Box::new(0);\n+    helper::work_with(&s);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n+    drop(s);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n+}"}, {"sha": "ea341b1ac14aeee096f1340fa316f50d39752a0b", "filename": "src/test/run-pass/allocator/custom-in-submodule.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -0,0 +1,26 @@\n+// run-pass\n+// no-prefer-dynamic\n+// aux-build:custom.rs\n+// aux-build:helper.rs\n+\n+extern crate custom;\n+extern crate helper;\n+\n+use custom::A;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+mod submodule {\n+    use super::*;\n+\n+    #[global_allocator]\n+    pub static GLOBAL: A = A(AtomicUsize::new(0));\n+}\n+\n+fn main() {\n+    let n = submodule::GLOBAL.0.load(Ordering::SeqCst);\n+    let s = Box::new(0);\n+    helper::work_with(&s);\n+    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), n + 1);\n+    drop(s);\n+    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), n + 2);\n+}"}, {"sha": "7a8d86b8da18cf08df1f0225a654fd40851a15d6", "filename": "src/test/ui/allocator-submodule.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Ftest%2Fui%2Fallocator-submodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Ftest%2Fui%2Fallocator-submodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-submodule.rs?ref=6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c", "patch": "@@ -1,28 +0,0 @@\n-// Tests that it is possible to create a global allocator in a submodule, rather than in the crate\n-// root.\n-\n-extern crate alloc;\n-\n-use std::{\n-    alloc::{GlobalAlloc, Layout},\n-    ptr,\n-};\n-\n-struct MyAlloc;\n-\n-unsafe impl GlobalAlloc for MyAlloc {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        ptr::null_mut()\n-    }\n-\n-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {}\n-}\n-\n-mod submod {\n-    use super::MyAlloc;\n-\n-    #[global_allocator]\n-    static MY_HEAP: MyAlloc = MyAlloc; //~ ERROR global_allocator\n-}\n-\n-fn main() {}"}, {"sha": "91c7c0f6b8e24fd3f8035c093b706d0011f6a284", "filename": "src/test/ui/allocator-submodule.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Ftest%2Fui%2Fallocator-submodule.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c/src%2Ftest%2Fui%2Fallocator-submodule.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-submodule.stderr?ref=6f0e57fb1dc3b30126e6ec6c9dd2ad0309da2c0c", "patch": "@@ -1,8 +0,0 @@\n-error: `global_allocator` cannot be used in submodules\n-  --> $DIR/allocator-submodule.rs:25:5\n-   |\n-LL |     static MY_HEAP: MyAlloc = MyAlloc;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "1033f947c5f5b68a72f4b4bde656114a7c9ad63b", "filename": "src/test/ui/allocator/allocator-args.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -0,0 +1,13 @@\n+use std::alloc::{GlobalAlloc, Layout};\n+\n+struct A;\n+\n+unsafe impl GlobalAlloc for A {\n+    unsafe fn alloc(&self, _: Layout) -> *mut u8 { panic!() }\n+    unsafe fn dealloc(&self, _: *mut u8, _: Layout) { panic!() }\n+}\n+\n+#[global_allocator(malloc)] //~ ERROR malformed `global_allocator` attribute input\n+static S: A = A;\n+\n+fn main() {}"}, {"sha": "dfff2a7e7094d368a9a83a8854c3a429557fdcb9", "filename": "src/test/ui/allocator/allocator-args.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -0,0 +1,8 @@\n+error: malformed `global_allocator` attribute input\n+  --> $DIR/allocator-args.rs:10:1\n+   |\n+LL | #[global_allocator(malloc)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[global_allocator]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "aa1291e77aecbb3a495210ef3b318af7078208fc", "filename": "src/test/ui/allocator/two-allocators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -4,6 +4,6 @@ use std::alloc::System;\n static A: System = System;\n #[global_allocator]\n static B: System = System;\n-//~^ ERROR: cannot define more than one `#[global_allocator]`\n+//~^ ERROR: cannot define multiple global allocators\n \n fn main() {}"}, {"sha": "ed0aa13eb8078e6bce1bace25afc41b5c8d7d210", "filename": "src/test/ui/allocator/two-allocators.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -1,8 +1,14 @@\n-error: cannot define more than one `#[global_allocator]`\n+error: cannot define multiple global allocators\n   --> $DIR/two-allocators.rs:6:1\n    |\n LL | static B: System = System;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the previous global allocator is defined here\n+  --> $DIR/two-allocators.rs:4:1\n+   |\n+LL | static A: System = System;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "37b5e792dc239f6a9ee3eaac800260afe30bea1b", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-bench.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -1,3 +1,13 @@\n+warning: attribute must be of the form `#[bench]`\n+  --> $DIR/issue-43106-gating-of-bench.rs:15:1\n+   |\n+LL | #![bench                   = \"4100\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(ill_formed_attribute_input)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>\n+\n error[E0601]: `main` function not found in crate `issue_43106_gating_of_bench`\n    |\n    = note: consider adding a `main` function to `$DIR/issue-43106-gating-of-bench.rs`"}, {"sha": "dbffabf3e02f93045198648d7104c4840a4fee53", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-test.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -1,3 +1,13 @@\n+warning: attribute must be of the form `#[test]`\n+  --> $DIR/issue-43106-gating-of-test.rs:10:1\n+   |\n+LL | #![test                    = \"4200\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(ill_formed_attribute_input)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>\n+\n error[E0601]: `main` function not found in crate `issue_43106_gating_of_test`\n    |\n    = note: consider adding a `main` function to `$DIR/issue-43106-gating-of-test.rs`"}, {"sha": "335c1aa0175edd9e6d658eae24231df36dbc2372", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1de70b04548b2e899fcf0da09c29600cc05325e/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=e1de70b04548b2e899fcf0da09c29600cc05325e", "patch": "@@ -344,7 +344,7 @@ fn get_and_check_lib_features(base_src_path: &Path,\n                 Ok((name, f)) => {\n                     let mut check_features = |f: &Feature, list: &Features, display: &str| {\n                         if let Some(ref s) = list.get(name) {\n-                            if f.tracking_issue != s.tracking_issue {\n+                            if f.tracking_issue != s.tracking_issue && f.level != Status::Stable {\n                                 tidy_error!(bad,\n                                             \"{}:{}: mismatches the `issue` in {}\",\n                                             file.display(),"}]}