{"sha": "231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzMWQ5ZTdlNWQ4N2VkNTQwMTVjMjJiYjFhMDdkMGYzZDRjMGJlZmE=", "commit": {"author": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2017-09-08T19:08:01Z"}, "committer": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2017-09-17T18:19:24Z"}, "message": "Remove rustc_bitflags; use the bitflags crate", "tree": {"sha": "6d9f4a927e17e9517da61f06dccca35286becdec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d9f4a927e17e9517da61f06dccca35286becdec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE/uKQcsWiEQj1Z6uEHB6YzI4Xu4kFAlm+vKwACgkQHB6YzI4X\nu4mtbBAAoOfWFU5uw2NIeMKQLD2klcSFx/tP9jhYqAlwKdijxQfSeJmtoHUHIvqv\nHQ1vlxVL4gwlQOFjuPE8s0dbhk4TuEcjsHs8D3DXVev6NISTi9iN++f7Y8yXPMna\nwV95LFVetip05sROkSx1TywmD6JbOrlI0N+J0Uau8qcNQcrbFRS/iUgYDC6pmSqL\nom0Av0T+d5b7eNE26qTWcVnv473rN3vaJM90eEZM36bmismBZo6e2O3JqtlFXWwS\na0673ibsEYI17C19MhUPAVj8U9DIYcp/OIgDaYD9ujAiA9a6Mj5Eo08u9xzo49Pv\nYb3BNbso8j/LbP+WFZBQkI7QYPoLgMMyl+xnEUZsOKHCiX/mXGkQnNKe/VKloD6p\n1ebJQ/AMs8Ds2CPHl+psKxAP9JCblcT3jBBrlnvd9m4rlsENR+yK0sqDbRd0bork\nGY0lP4VGMfaVoSdnnSZa7i8JloId7KJyRwtvGh8AF4KLX+kpKbtWwMmXlijvE1OO\nweckjlMzStYNYSOgFKQ9x1MAVdWniAUvZRBlW2z5L3ImaTEkvJVwufM0Q+RQXnc2\nJC8Gm9Wk+zp95r8uHQ5Kf/dxobYnQcT/F+BubV1zeMavNn89xxnl3p4d7y2aBxZB\nN+qcfief+15AbrsjXs+OL+hY3or6oDX/YG/dZP5cfplSnNyFTMo=\n=7Rlm\n-----END PGP SIGNATURE-----", "payload": "tree 6d9f4a927e17e9517da61f06dccca35286becdec\nparent e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae\nauthor Tamir Duberstein <tamird@gmail.com> 1504897681 -0400\ncommitter Tamir Duberstein <tamird@gmail.com> 1505672364 -0400\n\nRemove rustc_bitflags; use the bitflags crate\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "html_url": "https://github.com/rust-lang/rust/commit/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/comments", "author": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae", "url": "https://api.github.com/repos/rust-lang/rust/commits/e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae", "html_url": "https://github.com/rust-lang/rust/commit/e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae"}], "stats": {"total": 836, "additions": 190, "deletions": 646}, "files": [{"sha": "3a9d9ad9c5456c2c97bfb022d184054d0ba88541", "filename": "src/Cargo.lock", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -130,6 +130,11 @@ name = \"bitflags\"\n version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"bitflags\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"bootstrap\"\n version = \"0.0.0\"\n@@ -1418,14 +1423,14 @@ name = \"rustc\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n+ \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_back 0.0.0\",\n- \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -1466,7 +1471,8 @@ dependencies = [\n name = \"rustc_apfloat\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc_bitflags 0.0.0\",\n+ \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_cratesio_shim 0.0.0\",\n ]\n \n [[package]]\n@@ -1489,10 +1495,6 @@ dependencies = [\n  \"syntax 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_bitflags\"\n-version = \"0.0.0\"\n-\n [[package]]\n name = \"rustc_borrowck\"\n version = \"0.0.0\"\n@@ -1530,6 +1532,13 @@ dependencies = [\n  \"syntax 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_cratesio_shim\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustc_data_structures\"\n version = \"0.0.0\"\n@@ -1610,9 +1619,10 @@ dependencies = [\n name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"build_helper 0.1.0\",\n  \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_bitflags 0.0.0\",\n+ \"rustc_cratesio_shim 0.0.0\",\n ]\n \n [[package]]\n@@ -1648,10 +1658,10 @@ dependencies = [\n name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_bitflags 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -1740,6 +1750,7 @@ dependencies = [\n name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1750,7 +1761,6 @@ dependencies = [\n  \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_back 0.0.0\",\n- \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -2073,8 +2083,9 @@ dependencies = [\n name = \"syntax\"\n version = \"0.0.0\"\n dependencies = [\n- \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_cratesio_shim 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -2451,6 +2462,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n \"checksum bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1370e9fc2a6ae53aea8b7a5110edbd08836ed87c88736dfabccade1c2b44bff4\"\n \"checksum bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4efd02e230a02e18f92fc2735f44597385ed02ad8f831e7c1c1156ee5e1ab3a5\"\n+\"checksum bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5cde24d1b2e2216a726368b2363a273739c91f4e3eb4e0dd12d672d396ad989\"\n \"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n \"checksum clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2267a8fdd4dce6956ba6649e130f62fb279026e5e84b92aa939ac8f85ce3f9f0\""}, {"sha": "0b62e1bd5afbfb7493b5688e7783bb16531a789e", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -10,13 +10,13 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n arena = { path = \"../libarena\" }\n+bitflags = \"1.0\"\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n log = \"0.3\"\n owning_ref = \"0.3.3\"\n rustc_back = { path = \"../librustc_back\" }\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "abe35cb383a94bb76b7e59002067d11efd8e9d75", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -41,6 +41,7 @@\n #![recursion_limit=\"256\"]\n \n extern crate arena;\n+#[macro_use] extern crate bitflags;\n extern crate core;\n extern crate fmt_macros;\n extern crate getopts;\n@@ -56,7 +57,6 @@ extern crate rustc_errors as errors;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n-#[macro_use] #[no_link] extern crate rustc_bitflags;\n extern crate jobserver;\n \n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "a89165ce04f6d8e58f3d4c711e8fbfdb4286a747", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -399,35 +399,35 @@ pub struct CReaderCacheKey {\n // check whether the type has various kinds of types in it without\n // recursing over the type itself.\n bitflags! {\n-    flags TypeFlags: u32 {\n-        const HAS_PARAMS         = 1 << 0,\n-        const HAS_SELF           = 1 << 1,\n-        const HAS_TY_INFER       = 1 << 2,\n-        const HAS_RE_INFER       = 1 << 3,\n-        const HAS_RE_SKOL        = 1 << 4,\n-        const HAS_RE_EARLY_BOUND = 1 << 5,\n-        const HAS_FREE_REGIONS   = 1 << 6,\n-        const HAS_TY_ERR         = 1 << 7,\n-        const HAS_PROJECTION     = 1 << 8,\n+    pub struct TypeFlags: u32 {\n+        const HAS_PARAMS         = 1 << 0;\n+        const HAS_SELF           = 1 << 1;\n+        const HAS_TY_INFER       = 1 << 2;\n+        const HAS_RE_INFER       = 1 << 3;\n+        const HAS_RE_SKOL        = 1 << 4;\n+        const HAS_RE_EARLY_BOUND = 1 << 5;\n+        const HAS_FREE_REGIONS   = 1 << 6;\n+        const HAS_TY_ERR         = 1 << 7;\n+        const HAS_PROJECTION     = 1 << 8;\n \n         // FIXME: Rename this to the actual property since it's used for generators too\n-        const HAS_TY_CLOSURE     = 1 << 9,\n+        const HAS_TY_CLOSURE     = 1 << 9;\n \n         // true if there are \"names\" of types and regions and so forth\n         // that are local to a particular fn\n-        const HAS_LOCAL_NAMES    = 1 << 10,\n+        const HAS_LOCAL_NAMES    = 1 << 10;\n \n         // Present if the type belongs in a local type context.\n         // Only set for TyInfer other than Fresh.\n-        const KEEP_IN_LOCAL_TCX  = 1 << 11,\n+        const KEEP_IN_LOCAL_TCX  = 1 << 11;\n \n         // Is there a projection that does not involve a bound region?\n         // Currently we can't normalize projections w/ bound regions.\n-        const HAS_NORMALIZABLE_PROJECTION = 1 << 12,\n+        const HAS_NORMALIZABLE_PROJECTION = 1 << 12;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n-                                   TypeFlags::HAS_RE_EARLY_BOUND.bits,\n+                                   TypeFlags::HAS_RE_EARLY_BOUND.bits;\n \n         // Flags representing the nominal content of a type,\n         // computed by FlagsComputation. If you add a new nominal\n@@ -443,7 +443,7 @@ bitflags! {\n                                   TypeFlags::HAS_PROJECTION.bits |\n                                   TypeFlags::HAS_TY_CLOSURE.bits |\n                                   TypeFlags::HAS_LOCAL_NAMES.bits |\n-                                  TypeFlags::KEEP_IN_LOCAL_TCX.bits,\n+                                  TypeFlags::KEEP_IN_LOCAL_TCX.bits;\n     }\n }\n \n@@ -1259,13 +1259,13 @@ pub struct Destructor {\n }\n \n bitflags! {\n-    flags AdtFlags: u32 {\n-        const NO_ADT_FLAGS        = 0,\n-        const IS_ENUM             = 1 << 0,\n-        const IS_PHANTOM_DATA     = 1 << 1,\n-        const IS_FUNDAMENTAL      = 1 << 2,\n-        const IS_UNION            = 1 << 3,\n-        const IS_BOX              = 1 << 4,\n+    pub struct AdtFlags: u32 {\n+        const NO_ADT_FLAGS        = 0;\n+        const IS_ENUM             = 1 << 0;\n+        const IS_PHANTOM_DATA     = 1 << 1;\n+        const IS_FUNDAMENTAL      = 1 << 2;\n+        const IS_UNION            = 1 << 3;\n+        const IS_BOX              = 1 << 4;\n     }\n }\n \n@@ -1358,18 +1358,18 @@ pub enum AdtKind { Struct, Union, Enum }\n \n bitflags! {\n     #[derive(RustcEncodable, RustcDecodable, Default)]\n-    flags ReprFlags: u8 {\n-        const IS_C               = 1 << 0,\n-        const IS_PACKED          = 1 << 1,\n-        const IS_SIMD            = 1 << 2,\n+    pub struct ReprFlags: u8 {\n+        const IS_C               = 1 << 0;\n+        const IS_PACKED          = 1 << 1;\n+        const IS_SIMD            = 1 << 2;\n         // Internal only for now. If true, don't reorder fields.\n-        const IS_LINEAR          = 1 << 3,\n+        const IS_LINEAR          = 1 << 3;\n \n         // Any of these flags being set prevent field reordering optimisation.\n         const IS_UNOPTIMISABLE   = ReprFlags::IS_C.bits |\n                                    ReprFlags::IS_PACKED.bits |\n                                    ReprFlags::IS_SIMD.bits |\n-                                   ReprFlags::IS_LINEAR.bits,\n+                                   ReprFlags::IS_LINEAR.bits;\n     }\n }\n "}, {"sha": "a203e290dbaeb0b613e79b5235af47a6b5ee2818", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -19,7 +19,6 @@ use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n use ty::subst::Kind;\n \n-use std::fmt;\n use std::iter;\n use std::cmp::Ordering;\n use syntax::abi;\n@@ -577,12 +576,6 @@ impl<T> Binder<T> {\n     }\n }\n \n-impl fmt::Debug for TypeFlags {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:x}\", self.bits)\n-    }\n-}\n-\n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "735b74f156500356c1e66759ec55fe6de32510de", "filename": "src/librustc_apfloat/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2FCargo.toml?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -8,4 +8,5 @@ name = \"rustc_apfloat\"\n path = \"lib.rs\"\n \n [dependencies]\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n+bitflags = \"1.0\"\n+rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }"}, {"sha": "9e3e622e2526098f6fdfdce0ce0994d34fa5cf36", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -53,34 +53,31 @@\n #![cfg_attr(not(stage0), feature(const_min_value))]\n #![cfg_attr(not(stage0), feature(const_max_value))]\n \n+// See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n+#[allow(unused_extern_crates)]\n+extern crate rustc_cratesio_shim;\n+\n #[macro_use]\n-extern crate rustc_bitflags;\n+extern crate bitflags;\n \n use std::cmp::Ordering;\n use std::fmt;\n use std::ops::{Neg, Add, Sub, Mul, Div, Rem};\n-use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign, BitOrAssign};\n+use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n use std::str::FromStr;\n \n bitflags! {\n     /// IEEE-754R 7: Default exception handling.\n     ///\n     /// UNDERFLOW or OVERFLOW are always returned or-ed with INEXACT.\n     #[must_use]\n-    #[derive(Debug)]\n-    flags Status: u8 {\n-        const OK = 0x00,\n-        const INVALID_OP = 0x01,\n-        const DIV_BY_ZERO = 0x02,\n-        const OVERFLOW = 0x04,\n-        const UNDERFLOW = 0x08,\n-        const INEXACT = 0x10\n-    }\n-}\n-\n-impl BitOrAssign for Status {\n-    fn bitor_assign(&mut self, rhs: Self) {\n-        *self = *self | rhs;\n+    pub struct Status: u8 {\n+        const OK = 0x00;\n+        const INVALID_OP = 0x01;\n+        const DIV_BY_ZERO = 0x02;\n+        const OVERFLOW = 0x04;\n+        const UNDERFLOW = 0x08;\n+        const INEXACT = 0x10;\n     }\n }\n "}, {"sha": "d82a72994ca6f55303fe41f66caaa45c52ce76d5", "filename": "src/librustc_bitflags/Cargo.toml", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae/src%2Flibrustc_bitflags%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae/src%2Flibrustc_bitflags%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2FCargo.toml?ref=e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae", "patch": "@@ -1,9 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_bitflags\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rustc_bitflags\"\n-path = \"lib.rs\"\n-doctest = false"}, {"sha": "eb47144d1f995f5431ad9d366776afdcd4767175", "filename": "src/librustc_bitflags/lib.rs", "status": "removed", "additions": 0, "deletions": 494, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=e788fa7b6cf07860eb0ff3e90ff32fc4f9d26cae", "patch": "@@ -1,494 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#![no_std]\n-#![deny(warnings)]\n-\n-//! A typesafe bitmask flag generator.\n-\n-#[cfg(test)]\n-#[macro_use]\n-extern crate std;\n-\n-/// The `bitflags!` macro generates a `struct` that holds a set of C-style\n-/// bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n-///\n-/// The flags should only be defined for integer types, otherwise unexpected\n-/// type errors may occur at compile time.\n-///\n-/// # Examples\n-///\n-/// ```{.rust}\n-/// #![feature(rustc_private)]\n-/// #[macro_use] extern crate rustc_bitflags;\n-///\n-/// bitflags! {\n-///     flags Flags: u32 {\n-///         const FLAG_A       = 0b00000001,\n-///         const FLAG_B       = 0b00000010,\n-///         const FLAG_C       = 0b00000100,\n-///         const FLAG_ABC     = Flags::FLAG_A.bits\n-///                            | Flags::FLAG_B.bits\n-///                            | Flags::FLAG_C.bits,\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let e1 = Flags::FLAG_A | Flags::FLAG_C;\n-///     let e2 = Flags::FLAG_B | Flags::FLAG_C;\n-///     assert!((e1 | e2) == Flags::FLAG_ABC); // union\n-///     assert!((e1 & e2) == Flags::FLAG_C);   // intersection\n-///     assert!((e1 - e2) == Flags::FLAG_A);   // set difference\n-///     assert!(!e2 == Flags::FLAG_A);         // set complement\n-/// }\n-/// ```\n-///\n-/// The generated `struct`s can also be extended with type and trait implementations:\n-///\n-/// ```{.rust}\n-/// #![feature(rustc_private)]\n-/// #[macro_use] extern crate rustc_bitflags;\n-///\n-/// use std::fmt;\n-///\n-/// bitflags! {\n-///     flags Flags: u32 {\n-///         const FLAG_A   = 0b00000001,\n-///         const FLAG_B   = 0b00000010,\n-///     }\n-/// }\n-///\n-/// impl Flags {\n-///     pub fn clear(&mut self) {\n-///         self.bits = 0;  // The `bits` field can be accessed from within the\n-///                         // same module where the `bitflags!` macro was invoked.\n-///     }\n-/// }\n-///\n-/// impl fmt::Debug for Flags {\n-///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-///         write!(f, \"hi!\")\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let mut flags = Flags::FLAG_A | Flags::FLAG_B;\n-///     flags.clear();\n-///     assert!(flags.is_empty());\n-///     assert_eq!(format!(\"{:?}\", flags), \"hi!\");\n-/// }\n-/// ```\n-///\n-/// # Attributes\n-///\n-/// Attributes can be attached to the generated `struct` by placing them\n-/// before the `flags` keyword.\n-///\n-/// # Derived traits\n-///\n-/// The `PartialEq` and `Clone` traits are automatically derived for the `struct` using\n-/// the `deriving` attribute. Additional traits can be derived by providing an\n-/// explicit `deriving` attribute on `flags`.\n-///\n-/// # Operators\n-///\n-/// The following operator traits are implemented for the generated `struct`:\n-///\n-/// - `BitOr`: union\n-/// - `BitAnd`: intersection\n-/// - `BitXor`: toggle\n-/// - `Sub`: set difference\n-/// - `Not`: set complement\n-///\n-/// # Methods\n-///\n-/// The following methods are defined for the generated `struct`:\n-///\n-/// - `empty`: an empty set of flags\n-/// - `all`: the set of all flags\n-/// - `bits`: the raw value of the flags currently stored\n-/// - `from_bits`: convert from underlying bit representation, unless that\n-///                representation contains bits that do not correspond to a flag\n-/// - `from_bits_truncate`: convert from underlying bit representation, dropping\n-///                         any bits that do not correspond to flags\n-/// - `is_empty`: `true` if no flags are currently stored\n-/// - `is_all`: `true` if all flags are currently set\n-/// - `intersects`: `true` if there are flags common to both `self` and `other`\n-/// - `contains`: `true` all of the flags in `other` are contained within `self`\n-/// - `insert`: inserts the specified flags in-place\n-/// - `remove`: removes the specified flags in-place\n-/// - `toggle`: the specified flags will be inserted if not present, and removed\n-///             if they are.\n-#[macro_export]\n-macro_rules! bitflags {\n-    ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n-        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr),+\n-    }) => {\n-        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n-        $(#[$attr])*\n-        pub struct $BitFlags {\n-            bits: $T,\n-        }\n-\n-        impl $BitFlags {\n-            $($(#[$Flag_attr])* pub const $Flag: $BitFlags = $BitFlags { bits: $value };)+\n-\n-            /// Returns an empty set of flags.\n-            #[inline]\n-            pub fn empty() -> $BitFlags {\n-                $BitFlags { bits: 0 }\n-            }\n-\n-            /// Returns the set containing all flags.\n-            #[inline]\n-            pub fn all() -> $BitFlags {\n-                $BitFlags { bits: $($value)|+ }\n-            }\n-\n-            /// Returns the raw value of the flags currently stored.\n-            #[inline]\n-            pub fn bits(&self) -> $T {\n-                self.bits\n-            }\n-\n-            /// Convert from underlying bit representation, unless that\n-            /// representation contains bits that do not correspond to a flag.\n-            #[inline]\n-            pub fn from_bits(bits: $T) -> ::std::option::Option<$BitFlags> {\n-                if (bits & !$BitFlags::all().bits()) != 0 {\n-                    ::std::option::Option::None\n-                } else {\n-                    ::std::option::Option::Some($BitFlags { bits: bits })\n-                }\n-            }\n-\n-            /// Convert from underlying bit representation, dropping any bits\n-            /// that do not correspond to flags.\n-            #[inline]\n-            pub fn from_bits_truncate(bits: $T) -> $BitFlags {\n-                $BitFlags { bits: bits } & $BitFlags::all()\n-            }\n-\n-            /// Returns `true` if no flags are currently stored.\n-            #[inline]\n-            pub fn is_empty(&self) -> bool {\n-                *self == $BitFlags::empty()\n-            }\n-\n-            /// Returns `true` if all flags are currently set.\n-            #[inline]\n-            pub fn is_all(&self) -> bool {\n-                *self == $BitFlags::all()\n-            }\n-\n-            /// Returns `true` if there are flags common to both `self` and `other`.\n-            #[inline]\n-            pub fn intersects(&self, other: $BitFlags) -> bool {\n-                !(*self & other).is_empty()\n-            }\n-\n-            /// Returns `true` if all of the flags in `other` are contained within `self`.\n-            #[inline]\n-            pub fn contains(&self, other: $BitFlags) -> bool {\n-                (*self & other) == other\n-            }\n-\n-            /// Inserts the specified flags in-place.\n-            #[inline]\n-            pub fn insert(&mut self, other: $BitFlags) {\n-                self.bits |= other.bits;\n-            }\n-\n-            /// Removes the specified flags in-place.\n-            #[inline]\n-            pub fn remove(&mut self, other: $BitFlags) {\n-                self.bits &= !other.bits;\n-            }\n-\n-            /// Toggles the specified flags in-place.\n-            #[inline]\n-            pub fn toggle(&mut self, other: $BitFlags) {\n-                self.bits ^= other.bits;\n-            }\n-        }\n-\n-        impl ::std::ops::BitOr for $BitFlags {\n-            type Output = $BitFlags;\n-\n-            /// Returns the union of the two sets of flags.\n-            #[inline]\n-            fn bitor(self, other: $BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits | other.bits }\n-            }\n-        }\n-\n-        impl ::std::ops::BitXor for $BitFlags {\n-            type Output = $BitFlags;\n-\n-            /// Returns the left flags, but with all the right flags toggled.\n-            #[inline]\n-            fn bitxor(self, other: $BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits ^ other.bits }\n-            }\n-        }\n-\n-        impl ::std::ops::BitAnd for $BitFlags {\n-            type Output = $BitFlags;\n-\n-            /// Returns the intersection between the two sets of flags.\n-            #[inline]\n-            fn bitand(self, other: $BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits & other.bits }\n-            }\n-        }\n-\n-        impl ::std::ops::Sub for $BitFlags {\n-            type Output = $BitFlags;\n-\n-            /// Returns the set difference of the two sets of flags.\n-            #[inline]\n-            fn sub(self, other: $BitFlags) -> $BitFlags {\n-                $BitFlags { bits: self.bits & !other.bits }\n-            }\n-        }\n-\n-        impl ::std::ops::Not for $BitFlags {\n-            type Output = $BitFlags;\n-\n-            /// Returns the complement of this set of flags.\n-            #[inline]\n-            fn not(self) -> $BitFlags {\n-                $BitFlags { bits: !self.bits } & $BitFlags::all()\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n-        $($(#[$Flag_attr:meta])* const $Flag:ident = $value:expr),+,\n-    }) => {\n-        bitflags! {\n-            $(#[$attr])*\n-            flags $BitFlags: $T {\n-                $($(#[$Flag_attr])* const $Flag = $value),+\n-            }\n-        }\n-    };\n-}\n-\n-#[cfg(test)]\n-#[allow(non_upper_case_globals)]\n-mod tests {\n-    use std::hash::{Hash, Hasher};\n-    use std::collections::hash_map::DefaultHasher;\n-    use std::option::Option::{None, Some};\n-\n-    bitflags! {\n-        #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]\n-        #[doc = \"> you are the easiest person to fool.\"]\n-        #[doc = \"> \"]\n-        #[doc = \"> - Richard Feynman\"]\n-        flags Flags: u32 {\n-            const FlagA       = 0b00000001,\n-            #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n-            const FlagB       = 0b00000010,\n-            const FlagC       = 0b00000100,\n-            #[doc = \"* cmr bed\"]\n-            #[doc = \"* strcat table\"]\n-            #[doc = \"<strcat> wait what?\"]\n-            const FlagABC     = Flags::FlagA.bits\n-                               | Flags::FlagB.bits\n-                               | Flags::FlagC.bits,\n-        }\n-    }\n-\n-    bitflags! {\n-        flags AnotherSetOfFlags: i8 {\n-            const AnotherFlag = -1,\n-        }\n-    }\n-\n-    #[test]\n-    fn test_bits() {\n-        assert_eq!(Flags::empty().bits(), 0b00000000);\n-        assert_eq!(Flags::FlagA.bits(), 0b00000001);\n-        assert_eq!(Flags::FlagABC.bits(), 0b00000111);\n-\n-        assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n-        assert_eq!(AnotherSetOfFlags::AnotherFlag.bits(), !0);\n-    }\n-\n-    #[test]\n-    fn test_from_bits() {\n-        assert!(Flags::from_bits(0) == Some(Flags::empty()));\n-        assert!(Flags::from_bits(0b1) == Some(Flags::FlagA));\n-        assert!(Flags::from_bits(0b10) == Some(Flags::FlagB));\n-        assert!(Flags::from_bits(0b11) == Some(Flags::FlagA | Flags::FlagB));\n-        assert!(Flags::from_bits(0b1000) == None);\n-\n-        assert!(AnotherSetOfFlags::from_bits(!0) == Some(AnotherSetOfFlags::AnotherFlag));\n-    }\n-\n-    #[test]\n-    fn test_from_bits_truncate() {\n-        assert!(Flags::from_bits_truncate(0) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0b1) == Flags::FlagA);\n-        assert!(Flags::from_bits_truncate(0b10) == Flags::FlagB);\n-        assert!(Flags::from_bits_truncate(0b11) == (Flags::FlagA | Flags::FlagB));\n-        assert!(Flags::from_bits_truncate(0b1000) == Flags::empty());\n-        assert!(Flags::from_bits_truncate(0b1001) == Flags::FlagA);\n-\n-        assert!(AnotherSetOfFlags::from_bits_truncate(0) == AnotherSetOfFlags::empty());\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        assert!(Flags::empty().is_empty());\n-        assert!(!Flags::FlagA.is_empty());\n-        assert!(!Flags::FlagABC.is_empty());\n-\n-        assert!(!AnotherSetOfFlags::AnotherFlag.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_is_all() {\n-        assert!(Flags::all().is_all());\n-        assert!(!Flags::FlagA.is_all());\n-        assert!(Flags::FlagABC.is_all());\n-\n-        assert!(AnotherSetOfFlags::AnotherFlag.is_all());\n-    }\n-\n-    #[test]\n-    fn test_two_empties_do_not_intersect() {\n-        let e1 = Flags::empty();\n-        let e2 = Flags::empty();\n-        assert!(!e1.intersects(e2));\n-\n-        assert!(AnotherSetOfFlags::AnotherFlag.intersects(AnotherSetOfFlags::AnotherFlag));\n-    }\n-\n-    #[test]\n-    fn test_empty_does_not_intersect_with_full() {\n-        let e1 = Flags::empty();\n-        let e2 = Flags::FlagABC;\n-        assert!(!e1.intersects(e2));\n-    }\n-\n-    #[test]\n-    fn test_disjoint_intersects() {\n-        let e1 = Flags::FlagA;\n-        let e2 = Flags::FlagB;\n-        assert!(!e1.intersects(e2));\n-    }\n-\n-    #[test]\n-    fn test_overlapping_intersects() {\n-        let e1 = Flags::FlagA;\n-        let e2 = Flags::FlagA | Flags::FlagB;\n-        assert!(e1.intersects(e2));\n-    }\n-\n-    #[test]\n-    fn test_contains() {\n-        let e1 = Flags::FlagA;\n-        let e2 = Flags::FlagA | Flags::FlagB;\n-        assert!(!e1.contains(e2));\n-        assert!(e2.contains(e1));\n-        assert!(Flags::FlagABC.contains(e2));\n-\n-        assert!(AnotherSetOfFlags::AnotherFlag.contains(AnotherSetOfFlags::AnotherFlag));\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut e1 = Flags::FlagA;\n-        let e2 = Flags::FlagA | Flags::FlagB;\n-        e1.insert(e2);\n-        assert!(e1 == e2);\n-\n-        let mut e3 = AnotherSetOfFlags::empty();\n-        e3.insert(AnotherSetOfFlags::AnotherFlag);\n-        assert!(e3 == AnotherSetOfFlags::AnotherFlag);\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut e1 = Flags::FlagA | Flags::FlagB;\n-        let e2 = Flags::FlagA | Flags::FlagC;\n-        e1.remove(e2);\n-        assert!(e1 == Flags::FlagB);\n-\n-        let mut e3 = AnotherSetOfFlags::AnotherFlag;\n-        e3.remove(AnotherSetOfFlags::AnotherFlag);\n-        assert!(e3 == AnotherSetOfFlags::empty());\n-    }\n-\n-    #[test]\n-    fn test_operators() {\n-        let e1 = Flags::FlagA | Flags::FlagC;\n-        let e2 = Flags::FlagB | Flags::FlagC;\n-        assert!((e1 | e2) == Flags::FlagABC);     // union\n-        assert!((e1 & e2) == Flags::FlagC);       // intersection\n-        assert!((e1 - e2) == Flags::FlagA);       // set difference\n-        assert!(!e2 == Flags::FlagA);             // set complement\n-        assert!(e1 ^ e2 == Flags::FlagA | Flags::FlagB); // toggle\n-        let mut e3 = e1;\n-        e3.toggle(e2);\n-        assert!(e3 == Flags::FlagA | Flags::FlagB);\n-\n-        let mut m4 = AnotherSetOfFlags::empty();\n-        m4.toggle(AnotherSetOfFlags::empty());\n-        assert!(m4 == AnotherSetOfFlags::empty());\n-    }\n-\n-    #[test]\n-    fn test_lt() {\n-        let mut a = Flags::empty();\n-        let mut b = Flags::empty();\n-\n-        assert!(!(a < b) && !(b < a));\n-        b = Flags::FlagB;\n-        assert!(a < b);\n-        a = Flags::FlagC;\n-        assert!(!(a < b) && b < a);\n-        b = Flags::FlagC | Flags::FlagB;\n-        assert!(a < b);\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let mut a = Flags::empty();\n-        let mut b = Flags::empty();\n-\n-        assert!(a <= b && a >= b);\n-        a = Flags::FlagA;\n-        assert!(a > b && a >= b);\n-        assert!(b < a && b <= a);\n-        b = Flags::FlagB;\n-        assert!(b > a && b >= a);\n-        assert!(a < b && a <= b);\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let mut x = Flags::empty();\n-        let mut y = Flags::empty();\n-        assert!(hash(&x) == hash(&y));\n-        x = Flags::all();\n-        y = Flags::FlagABC;\n-        assert!(hash(&x) == hash(&y));\n-    }\n-\n-    fn hash<T: Hash>(t: &T) -> u64 {\n-        let mut s = DefaultHasher::new();\n-        t.hash(&mut s);\n-        s.finish()\n-    }\n-}"}, {"sha": "143f88e8f4b8e163aa42afc30a14f78581928679", "filename": "src/librustc_cratesio_shim/Cargo.toml", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_cratesio_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_cratesio_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_cratesio_shim%2FCargo.toml?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -0,0 +1,23 @@\n+# This crate exists to allow rustc to link certain crates from crates.io into\n+# the distribution. This doesn't work normally because:\n+#\n+# - Cargo always builds dependencies as rlibs:\n+#   https://github.com/rust-lang/cargo/issues/629\n+# - rustc wants to avoid multiple definitions of the same symbol, so it refuses\n+#   to link multiple dylibs containing the same rlib\n+# - multiple dylibs depend on the same crates.io crates\n+#\n+# This solution works by including all the conflicting rlibs in a single dylib,\n+# which is then linked into all dylibs that depend on these crates.io crates.\n+# The result is that each rlib only appears once, and things work!\n+\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_cratesio_shim\"\n+version = \"0.0.0\"\n+\n+[lib]\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+bitflags = \"1.0\""}, {"sha": "769b4f57206ecb2329f11e9527b7b607dbdd3202", "filename": "src/librustc_cratesio_shim/src/lib.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_cratesio_shim%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_cratesio_shim%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_cratesio_shim%2Fsrc%2Flib.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See Cargo.toml for a comment explaining this crate.\n+#![allow(unused_extern_crates)]\n+\n+extern crate bitflags;"}, {"sha": "1ed2cbab65fc4e02986636677d1fa828184915dd", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -13,7 +13,8 @@ crate-type = [\"dylib\"]\n static-libstdcpp = []\n \n [dependencies]\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n+bitflags = \"1.0\"\n+rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }"}, {"sha": "d91c706e24e36517d7a492f39c3ef80413ffc5f1", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -454,26 +454,26 @@ pub mod debuginfo {\n     // These values **must** match with LLVMRustDIFlags!!\n     bitflags! {\n         #[repr(C)]\n-        #[derive(Debug, Default)]\n-        flags DIFlags: ::libc::uint32_t {\n-            const FlagZero                = 0,\n-            const FlagPrivate             = 1,\n-            const FlagProtected           = 2,\n-            const FlagPublic              = 3,\n-            const FlagFwdDecl             = (1 << 2),\n-            const FlagAppleBlock          = (1 << 3),\n-            const FlagBlockByrefStruct    = (1 << 4),\n-            const FlagVirtual             = (1 << 5),\n-            const FlagArtificial          = (1 << 6),\n-            const FlagExplicit            = (1 << 7),\n-            const FlagPrototyped          = (1 << 8),\n-            const FlagObjcClassComplete   = (1 << 9),\n-            const FlagObjectPointer       = (1 << 10),\n-            const FlagVector              = (1 << 11),\n-            const FlagStaticMember        = (1 << 12),\n-            const FlagLValueReference     = (1 << 13),\n-            const FlagRValueReference     = (1 << 14),\n-            const FlagMainSubprogram      = (1 << 21),\n+        #[derive(Default)]\n+        pub struct DIFlags: ::libc::uint32_t {\n+            const FlagZero                = 0;\n+            const FlagPrivate             = 1;\n+            const FlagProtected           = 2;\n+            const FlagPublic              = 3;\n+            const FlagFwdDecl             = (1 << 2);\n+            const FlagAppleBlock          = (1 << 3);\n+            const FlagBlockByrefStruct    = (1 << 4);\n+            const FlagVirtual             = (1 << 5);\n+            const FlagArtificial          = (1 << 6);\n+            const FlagExplicit            = (1 << 7);\n+            const FlagPrototyped          = (1 << 8);\n+            const FlagObjcClassComplete   = (1 << 9);\n+            const FlagObjectPointer       = (1 << 10);\n+            const FlagVector              = (1 << 11);\n+            const FlagStaticMember        = (1 << 12);\n+            const FlagLValueReference     = (1 << 13);\n+            const FlagRValueReference     = (1 << 14);\n+            const FlagMainSubprogram      = (1 << 21);\n         }\n     }\n }"}, {"sha": "9be5f5b54867b41826646cd1063077bf2db0b744", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -24,10 +24,13 @@\n #![feature(link_args)]\n #![feature(static_nobundle)]\n \n-extern crate libc;\n+// See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n+#[allow(unused_extern_crates)]\n+extern crate rustc_cratesio_shim;\n+\n #[macro_use]\n-#[no_link]\n-extern crate rustc_bitflags;\n+extern crate bitflags;\n+extern crate libc;\n \n pub use self::IntPredicate::*;\n pub use self::RealPredicate::*;"}, {"sha": "936fd5a774d3c1f56530c0c3192b258c7196d6a9", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -9,13 +9,13 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+bitflags = \"1.0\"\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.3\"\n rustc = { path = \"../librustc\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "d0b9849986b82e6788b99fb3ff604edc77d11c41", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -24,16 +24,15 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(collection_placement)]\n #![feature(nonzero)]\n \n+#[macro_use]\n+extern crate bitflags;\n #[macro_use] extern crate log;\n extern crate graphviz as dot;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n #[macro_use]\n-#[no_link]\n-extern crate rustc_bitflags;\n-#[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_const_math;"}, {"sha": "3f3b9d177d70c03a72c62e5cdfe5de68b423117b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -41,38 +41,38 @@ use std::usize;\n use super::promote_consts::{self, Candidate, TempState};\n \n bitflags! {\n-    flags Qualif: u8 {\n+    struct Qualif: u8 {\n         // Constant containing interior mutability (UnsafeCell).\n-        const MUTABLE_INTERIOR  = 1 << 0,\n+        const MUTABLE_INTERIOR  = 1 << 0;\n \n         // Constant containing an ADT that implements Drop.\n-        const NEEDS_DROP        = 1 << 1,\n+        const NEEDS_DROP        = 1 << 1;\n \n         // Function argument.\n-        const FN_ARGUMENT       = 1 << 2,\n+        const FN_ARGUMENT       = 1 << 2;\n \n         // Static lvalue or move from a static.\n-        const STATIC            = 1 << 3,\n+        const STATIC            = 1 << 3;\n \n         // Reference to a static.\n-        const STATIC_REF        = 1 << 4,\n+        const STATIC_REF        = 1 << 4;\n \n         // Not constant at all - non-`const fn` calls, asm!,\n         // pointer comparisons, ptr-to-int casts, etc.\n-        const NOT_CONST         = 1 << 5,\n+        const NOT_CONST         = 1 << 5;\n \n         // Refers to temporaries which cannot be promoted as\n         // promote_consts decided they weren't simple enough.\n-        const NOT_PROMOTABLE    = 1 << 6,\n+        const NOT_PROMOTABLE    = 1 << 6;\n \n         // Borrows of temporaries can be promoted only\n         // if they have none of the above qualifications.\n-        const NEVER_PROMOTE     = 0b111_1111,\n+        const NEVER_PROMOTE     = 0b111_1111;\n \n         // Const items can only have MUTABLE_INTERIOR\n         // and NOT_PROMOTABLE without producing an error.\n         const CONST_ERROR       = !Qualif::MUTABLE_INTERIOR.bits &\n-                                  !Qualif::NOT_PROMOTABLE.bits\n+                                  !Qualif::NOT_PROMOTABLE.bits;\n     }\n }\n "}, {"sha": "6f1f5b4a123d8bc885fc664c26ad122a1e94dda9", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -10,6 +10,7 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n+bitflags = \"1.0\"\n num_cpus = \"1.0\"\n flate2 = \"0.2\"\n jobserver = \"0.1.5\"\n@@ -19,7 +20,6 @@ rustc-demangle = \"0.1.4\"\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_back = { path = \"../librustc_back\" }\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "6243850d7368e1da387b7c694d9969baa3473459", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -65,17 +65,17 @@ pub use self::attr_impl::ArgAttribute;\n mod attr_impl {\n     // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n     bitflags! {\n-        #[derive(Default, Debug)]\n-        flags ArgAttribute : u16 {\n-            const ByVal     = 1 << 0,\n-            const NoAlias   = 1 << 1,\n-            const NoCapture = 1 << 2,\n-            const NonNull   = 1 << 3,\n-            const ReadOnly  = 1 << 4,\n-            const SExt      = 1 << 5,\n-            const StructRet = 1 << 6,\n-            const ZExt      = 1 << 7,\n-            const InReg     = 1 << 8,\n+        #[derive(Default)]\n+        pub struct ArgAttribute: u16 {\n+            const ByVal     = 1 << 0;\n+            const NoAlias   = 1 << 1;\n+            const NoCapture = 1 << 2;\n+            const NonNull   = 1 << 3;\n+            const ReadOnly  = 1 << 4;\n+            const SExt      = 1 << 5;\n+            const StructRet = 1 << 6;\n+            const ZExt      = 1 << 7;\n+            const InReg     = 1 << 8;\n         }\n     }\n }"}, {"sha": "d40ad6254d2c3984f926b7fef9c85572ba63bfcf", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -37,6 +37,8 @@\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n \n+#[macro_use]\n+extern crate bitflags;\n extern crate flate2;\n extern crate libc;\n extern crate owning_ref;\n@@ -48,9 +50,6 @@ extern crate rustc_incremental;\n extern crate rustc_llvm as llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_const_math;\n-#[macro_use]\n-#[no_link]\n-extern crate rustc_bitflags;\n extern crate rustc_demangle;\n extern crate jobserver;\n extern crate num_cpus;"}, {"sha": "fb1f300f63cc320e469f8b8e6061219c99cbc43d", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -9,9 +9,10 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+bitflags = \"1.0\"\n serialize = { path = \"../libserialize\" }\n log = \"0.3\"\n-bitflags = \"0.8\"\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "9e4f134e2bd569371dd82c4e4bd8a018a40fd33c", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -24,9 +24,13 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(i128_type)]\n \n+// See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n+#[allow(unused_extern_crates)]\n+extern crate rustc_cratesio_shim;\n+\n+#[macro_use] extern crate bitflags;\n extern crate serialize;\n #[macro_use] extern crate log;\n-#[macro_use] extern crate bitflags;\n extern crate std_unicode;\n pub extern crate rustc_errors as errors;\n extern crate syntax_pos;"}, {"sha": "a2514a0425429f0a160e62d92052ec9b54ca8485", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=231d9e7e5d87ed54015c22bb1a07d0f3d4c0befa", "patch": "@@ -64,9 +64,9 @@ use std::path::{self, Path, PathBuf};\n use std::slice;\n \n bitflags! {\n-    pub flags Restrictions: u8 {\n-        const RESTRICTION_STMT_EXPR         = 1 << 0,\n-        const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n+    pub struct Restrictions: u8 {\n+        const STMT_EXPR         = 1 << 0;\n+        const NO_STRUCT_LITERAL = 1 << 1;\n     }\n }\n \n@@ -2240,7 +2240,7 @@ impl<'a> Parser<'a> {\n                     let e = if self.token.can_begin_expr()\n                                && !(self.token == token::OpenDelim(token::Brace)\n                                     && self.restrictions.contains(\n-                                           RESTRICTION_NO_STRUCT_LITERAL)) {\n+                                           Restrictions::NO_STRUCT_LITERAL)) {\n                         Some(self.parse_expr()?)\n                     } else {\n                         None\n@@ -2275,7 +2275,7 @@ impl<'a> Parser<'a> {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n                         let prohibited = self.restrictions.contains(\n-                            RESTRICTION_NO_STRUCT_LITERAL\n+                            Restrictions::NO_STRUCT_LITERAL\n                         );\n                         if !prohibited {\n                             return self.parse_struct_expr(lo, pth, attrs);\n@@ -2669,7 +2669,7 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n                 let place = self.parse_expr_res(\n-                    RESTRICTION_NO_STRUCT_LITERAL,\n+                    Restrictions::NO_STRUCT_LITERAL,\n                     None,\n                 )?;\n                 let blk = self.parse_block()?;\n@@ -2737,7 +2737,7 @@ impl<'a> Parser<'a> {\n \n             let cur_op_span = self.span;\n             let restrictions = if op.is_assign_like() {\n-                self.restrictions & RESTRICTION_NO_STRUCT_LITERAL\n+                self.restrictions & Restrictions::NO_STRUCT_LITERAL\n             } else {\n                 self.restrictions\n             };\n@@ -2800,21 +2800,21 @@ impl<'a> Parser<'a> {\n \n             let rhs = match op.fixity() {\n                 Fixity::Right => self.with_res(\n-                    restrictions - RESTRICTION_STMT_EXPR,\n+                    restrictions - Restrictions::STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence(),\n                             LhsExpr::NotYetParsed)\n                 }),\n                 Fixity::Left => self.with_res(\n-                    restrictions - RESTRICTION_STMT_EXPR,\n+                    restrictions - Restrictions::STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n                 }),\n                 // We currently have no non-associative operators that are not handled above by\n                 // the special cases. The code is here only for future convenience.\n                 Fixity::None => self.with_res(\n-                    restrictions - RESTRICTION_STMT_EXPR,\n+                    restrictions - Restrictions::STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n@@ -2989,7 +2989,7 @@ impl<'a> Parser<'a> {\n         if self.token.can_begin_expr() {\n             // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n             if self.token == token::OpenDelim(token::Brace) {\n-                return !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL);\n+                return !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n             }\n             true\n         } else {\n@@ -3003,7 +3003,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_let_expr(attrs);\n         }\n         let lo = self.prev_span;\n-        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n \n         // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n         // verify that the last statement is either an implicit return (no `;`) or an explicit\n@@ -3034,7 +3034,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let (hi, els) = if self.eat_keyword(keywords::Else) {\n             let expr = self.parse_else_expr()?;\n@@ -3056,7 +3056,7 @@ impl<'a> Parser<'a> {\n         let decl_hi = self.prev_span;\n         let body = match decl.output {\n             FunctionRetTy::Default(_) => {\n-                let restrictions = self.restrictions - RESTRICTION_STMT_EXPR;\n+                let restrictions = self.restrictions - Restrictions::STMT_EXPR;\n                 self.parse_expr_res(restrictions, None)?\n             },\n             _ => {\n@@ -3091,7 +3091,7 @@ impl<'a> Parser<'a> {\n \n         let pat = self.parse_pat()?;\n         self.expect_keyword(keywords::In)?;\n-        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n@@ -3106,7 +3106,7 @@ impl<'a> Parser<'a> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n-        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n@@ -3120,7 +3120,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n@@ -3150,7 +3150,7 @@ impl<'a> Parser<'a> {\n     fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n         let lo = self.prev_span;\n-        let discriminant = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL,\n+        let discriminant = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL,\n                                                None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n@@ -3198,7 +3198,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n         self.expect(&token::FatArrow)?;\n-        let expr = self.parse_expr_res(RESTRICTION_STMT_EXPR, None)?;\n+        let expr = self.parse_expr_res(Restrictions::STMT_EXPR, None)?;\n \n         let require_comma = classify::expr_requires_semi_to_be_stmt(&expr)\n             && self.token != token::CloseDelim(token::Brace);\n@@ -3789,7 +3789,7 @@ impl<'a> Parser<'a> {\n         self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n \n         // prevent `while catch {} {}`, `if catch {} {} else {}`, etc.\n-        !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL)\n+        !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n \n     fn is_union_item(&self) -> bool {\n@@ -3911,7 +3911,7 @@ impl<'a> Parser<'a> {\n                     self.mk_expr(lo.to(hi), ExprKind::Path(None, pth), ThinVec::new())\n                 };\n \n-                let expr = self.with_res(RESTRICTION_STMT_EXPR, |this| {\n+                let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n                     let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n                     this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n                 })?;\n@@ -4052,7 +4052,7 @@ impl<'a> Parser<'a> {\n \n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(\n-                        RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n+                        Restrictions::STMT_EXPR, Some(attrs.into()))?;\n                     Stmt {\n                         id: ast::DUMMY_NODE_ID,\n                         span: lo.to(e.span),\n@@ -4065,7 +4065,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restrictions.contains(RESTRICTION_STMT_EXPR) &&\n+        self.restrictions.contains(Restrictions::STMT_EXPR) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n "}]}