{"sha": "9aaa7c770c976e35b1614f1f6bf120204c5727c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhYWE3Yzc3MGM5NzZlMzViMTYxNGYxZjZiZjEyMDIwNGM1NzI3Yzg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-08T19:38:39Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-08T19:38:39Z"}, "message": "syntax: Move some `Token` methods around", "tree": {"sha": "c110ff1db3fee0276ec54d6d9dceabd252a9a894", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c110ff1db3fee0276ec54d6d9dceabd252a9a894"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aaa7c770c976e35b1614f1f6bf120204c5727c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aaa7c770c976e35b1614f1f6bf120204c5727c8", "html_url": "https://github.com/rust-lang/rust/commit/9aaa7c770c976e35b1614f1f6bf120204c5727c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aaa7c770c976e35b1614f1f6bf120204c5727c8/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25b05147b3ec0a1ed9df9614910a10171b8cf211", "url": "https://api.github.com/repos/rust-lang/rust/commits/25b05147b3ec0a1ed9df9614910a10171b8cf211", "html_url": "https://github.com/rust-lang/rust/commit/25b05147b3ec0a1ed9df9614910a10171b8cf211"}], "stats": {"total": 88, "additions": 40, "deletions": 48}, "files": [{"sha": "cc34883e2e8151fde9b682c6635c59995dae2f46", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 40, "deletions": 48, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9aaa7c770c976e35b1614f1f6bf120204c5727c8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aaa7c770c976e35b1614f1f6bf120204c5727c8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9aaa7c770c976e35b1614f1f6bf120204c5727c8", "patch": "@@ -240,12 +240,51 @@ pub struct Token {\n     pub span: Span,\n }\n \n+impl TokenKind {\n+    pub fn lit(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> TokenKind {\n+        Literal(Lit::new(kind, symbol, suffix))\n+    }\n+\n+    /// Returns tokens that are likely to be typed accidentally instead of the current token.\n+    /// Enables better error recovery when the wrong token is found.\n+    crate fn similar_tokens(&self) -> Option<Vec<TokenKind>> {\n+        match *self {\n+            Comma => Some(vec![Dot, Lt, Semi]),\n+            Semi => Some(vec![Colon, Comma]),\n+            _ => None\n+        }\n+    }\n+}\n+\n impl Token {\n+    crate fn new(kind: TokenKind, span: Span) -> Self {\n+        Token { kind, span }\n+    }\n+\n+    /// Some token that will be thrown away later.\n+    crate fn dummy() -> Self {\n+        Token::new(TokenKind::Whitespace, DUMMY_SP)\n+    }\n+\n     /// Recovers a `Token` from an `ast::Ident`. This creates a raw identifier if necessary.\n-    crate fn from_ast_ident(ident: ast::Ident) -> Token {\n+    crate fn from_ast_ident(ident: ast::Ident) -> Self {\n         Token::new(Ident(ident.name, ident.is_raw_guess()), ident.span)\n     }\n \n+    /// Return this token by value and leave a dummy token in its place.\n+    crate fn take(&mut self) -> Self {\n+        mem::replace(self, Token::dummy())\n+    }\n+\n+    crate fn is_op(&self) -> bool {\n+        match self.kind {\n+            OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) |\n+            Ident(..) | Lifetime(..) | Interpolated(..) |\n+            Whitespace | Comment | Shebang(..) | Eof => false,\n+            _ => true,\n+        }\n+    }\n+\n     crate fn is_like_plus(&self) -> bool {\n         match self.kind {\n             BinOp(Plus) | BinOpEq(Plus) => true,\n@@ -327,15 +366,7 @@ impl Token {\n         self.is_path_start() || self.is_lifetime() || self.is_keyword(kw::For) ||\n         self == &Question || self == &OpenDelim(Paren)\n     }\n-}\n-\n-impl TokenKind {\n-    pub fn lit(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> TokenKind {\n-        Literal(Lit::new(kind, symbol, suffix))\n-    }\n-}\n \n-impl Token {\n     /// Returns `true` if the token is any literal\n     crate fn is_lit(&self) -> bool {\n         match self.kind {\n@@ -535,21 +566,7 @@ impl Token {\n \n         Some(Token::new(kind, self.span.to(joint.span)))\n     }\n-}\n-\n-impl TokenKind {\n-    /// Returns tokens that are likely to be typed accidentally instead of the current token.\n-    /// Enables better error recovery when the wrong token is found.\n-    crate fn similar_tokens(&self) -> Option<Vec<TokenKind>> {\n-        match *self {\n-            Comma => Some(vec![Dot, Lt, Semi]),\n-            Semi => Some(vec![Colon, Comma]),\n-            _ => None\n-        }\n-    }\n-}\n \n-impl Token {\n     // See comments in `Nonterminal::to_tokenstream` for why we care about\n     // *probably* equal here rather than actual equality\n     crate fn probably_equal_for_proc_macro(&self, other: &Token) -> bool {\n@@ -608,20 +625,6 @@ impl Token {\n             _ => panic!(\"forgot to add a token?\"),\n         }\n     }\n-\n-    crate fn new(kind: TokenKind, span: Span) -> Self {\n-        Token { kind, span }\n-    }\n-\n-    /// Some token that will be thrown away later.\n-    crate fn dummy() -> Self {\n-        Token::new(TokenKind::Whitespace, DUMMY_SP)\n-    }\n-\n-    /// Return this token by value and leave a dummy token in its place.\n-    crate fn take(&mut self) -> Self {\n-        mem::replace(self, Token::dummy())\n-    }\n }\n \n impl PartialEq<TokenKind> for Token {\n@@ -769,17 +772,6 @@ impl Nonterminal {\n     }\n }\n \n-impl Token {\n-    crate fn is_op(&self) -> bool {\n-        match self.kind {\n-            OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) |\n-            Ident(..) | Lifetime(..) | Interpolated(..) |\n-            Whitespace | Comment | Shebang(..) | Eof => false,\n-            _ => true,\n-        }\n-    }\n-}\n-\n fn prepend_attrs(sess: &ParseSess,\n                  attrs: &[ast::Attribute],\n                  tokens: Option<&tokenstream::TokenStream>,"}]}