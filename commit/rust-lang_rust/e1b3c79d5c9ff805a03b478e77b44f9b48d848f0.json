{"sha": "e1b3c79d5c9ff805a03b478e77b44f9b48d848f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYjNjNzlkNWM5ZmY4MDVhMDNiNDc4ZTc3YjQ0ZjliNDhkODQ4ZjA=", "commit": {"author": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-05-14T09:50:29Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-05-14T09:50:29Z"}, "message": "refactor complete", "tree": {"sha": "e8bcfb120f3e9e935db3327e6befcd1f20fbb011", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8bcfb120f3e9e935db3327e6befcd1f20fbb011"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0", "html_url": "https://github.com/rust-lang/rust/commit/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0/comments", "author": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30317050092cc7a469f0815d40d400a812749564", "url": "https://api.github.com/repos/rust-lang/rust/commits/30317050092cc7a469f0815d40d400a812749564", "html_url": "https://github.com/rust-lang/rust/commit/30317050092cc7a469f0815d40d400a812749564"}], "stats": {"total": 389, "additions": 12, "deletions": 377}, "files": [{"sha": "16e5695c8319585841f5f2ac1c36d33774ff0310", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 7, "deletions": 372, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=e1b3c79d5c9ff805a03b478e77b44f9b48d848f0", "patch": "@@ -11,9 +11,9 @@ use rustc_target::abi::call::ArgType;\n \n use rustc_codegen_ssa::traits::*;\n \n-use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n+use rustc_target::abi::{HasDataLayout, LayoutOf};\n use rustc::ty::{self, Ty, Instance};\n-use rustc::ty::layout::{self, PointerKind};\n+use rustc::ty::layout::{self, FnTypeExt};\n \n use libc::c_uint;\n \n@@ -294,380 +294,15 @@ impl ArgTypeMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-pub trait FnTypeExt<'tcx> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self;\n-    fn new(cx: &CodegenCx<'ll, 'tcx>,\n-           sig: ty::FnSig<'tcx>,\n-           extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n-                  sig: ty::FnSig<'tcx>,\n-                  extra_args: &[Ty<'tcx>]) -> Self;\n-    fn new_internal(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self;\n-    fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'ll, 'tcx>,\n-                      abi: Abi);\n+pub trait FnTypeLlvmExt<'tcx> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn ptr_to_llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type;\n     fn llvm_cconv(&self) -> llvm::CallConv;\n     fn apply_attrs_llfn(&self, llfn: &'ll Value);\n     fn apply_attrs_callsite(&self, bx: &mut Builder<'a, 'll, 'tcx>, callsite: &'ll Value);\n }\n \n-impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n-    fn of_instance(cx: &CodegenCx<'ll, 'tcx>, instance: &ty::Instance<'tcx>) -> Self {\n-        let sig = instance.fn_sig(cx.tcx);\n-        let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        FnTypeExt::new(cx, sig, &[])\n-    }\n-\n-    fn new(cx: &CodegenCx<'ll, 'tcx>,\n-           sig: ty::FnSig<'tcx>,\n-           extra_args: &[Ty<'tcx>]) -> Self {\n-        FnTypeExt::new_internal(cx, sig, extra_args, |ty, _| {\n-            ArgType::new(cx.layout_of(ty))\n-        })\n-    }\n-\n-    fn new_vtable(cx: &CodegenCx<'ll, 'tcx>,\n-                  sig: ty::FnSig<'tcx>,\n-                  extra_args: &[Ty<'tcx>]) -> Self {\n-        FnTypeExt::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n-            let mut layout = cx.layout_of(ty);\n-            // Don't pass the vtable, it's not an argument of the virtual fn.\n-            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n-            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-            if arg_idx == Some(0) {\n-                let fat_pointer_ty = if layout.is_unsized() {\n-                    // unsized `self` is passed as a pointer to `self`\n-                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n-                    cx.tcx.mk_mut_ptr(layout.ty)\n-                } else {\n-                    match layout.abi {\n-                        LayoutAbi::ScalarPair(..) => (),\n-                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout)\n-                    }\n-\n-                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n-                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n-                    // elsewhere in the compiler as a method on a `dyn Trait`.\n-                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n-                    // get a built-in pointer type\n-                    let mut fat_pointer_layout = layout;\n-                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n-                        && !fat_pointer_layout.ty.is_region_ptr()\n-                    {\n-                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n-                            let field_layout = fat_pointer_layout.field(cx, i);\n-\n-                            if !field_layout.is_zst() {\n-                                fat_pointer_layout = field_layout;\n-                                continue 'descend_newtypes\n-                            }\n-                        }\n-\n-                        bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n-                    }\n-\n-                    fat_pointer_layout.ty\n-                };\n-\n-                // we now have a type like `*mut RcBox<dyn Trait>`\n-                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n-                // this is understood as a special case elsewhere in the compiler\n-                let unit_pointer_ty = cx.tcx.mk_mut_ptr(cx.tcx.mk_unit());\n-                layout = cx.layout_of(unit_pointer_ty);\n-                layout.ty = fat_pointer_ty;\n-            }\n-            ArgType::new(layout)\n-        })\n-    }\n-\n-    fn new_internal(\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        sig: ty::FnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>],\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgType<'tcx, Ty<'tcx>>,\n-    ) -> Self {\n-        debug!(\"FnType::new_internal({:?}, {:?})\", sig, extra_args);\n-\n-        use self::Abi::*;\n-        let conv = match cx.sess().target.target.adjust_abi(sig.abi) {\n-            RustIntrinsic | PlatformIntrinsic |\n-            Rust | RustCall => Conv::C,\n-\n-            // It's the ABI's job to select this, not ours.\n-            System => bug!(\"system abi should be selected elsewhere\"),\n-\n-            Stdcall => Conv::X86Stdcall,\n-            Fastcall => Conv::X86Fastcall,\n-            Vectorcall => Conv::X86VectorCall,\n-            Thiscall => Conv::X86ThisCall,\n-            C => Conv::C,\n-            Unadjusted => Conv::C,\n-            Win64 => Conv::X86_64Win64,\n-            SysV64 => Conv::X86_64SysV,\n-            Aapcs => Conv::ArmAapcs,\n-            PtxKernel => Conv::PtxKernel,\n-            Msp430Interrupt => Conv::Msp430Intr,\n-            X86Interrupt => Conv::X86Intr,\n-            AmdGpuKernel => Conv::AmdGpuKernel,\n-\n-            // These API constants ought to be more specific...\n-            Cdecl => Conv::C,\n-        };\n-\n-        let mut inputs = sig.inputs();\n-        let extra_args = if sig.abi == RustCall {\n-            assert!(!sig.c_variadic && extra_args.is_empty());\n-\n-            match sig.inputs().last().unwrap().sty {\n-                ty::Tuple(tupled_arguments) => {\n-                    inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n-                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n-                }\n-                _ => {\n-                    bug!(\"argument to function with \\\"rust-call\\\" ABI \\\n-                          is not a tuple\");\n-                }\n-            }\n-        } else {\n-            assert!(sig.c_variadic || extra_args.is_empty());\n-            extra_args.to_vec()\n-        };\n-\n-        let target = &cx.sess().target.target;\n-        let win_x64_gnu = target.target_os == \"windows\"\n-                       && target.arch == \"x86_64\"\n-                       && target.target_env == \"gnu\";\n-        let linux_s390x = target.target_os == \"linux\"\n-                       && target.arch == \"s390x\"\n-                       && target.target_env == \"gnu\";\n-        let linux_sparc64 = target.target_os == \"linux\"\n-                       && target.arch == \"sparc64\"\n-                       && target.target_env == \"gnu\";\n-        let rust_abi = match sig.abi {\n-            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n-            _ => false\n-        };\n-\n-        // Handle safe Rust thin and fat pointers.\n-        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n-                                      scalar: &layout::Scalar,\n-                                      layout: TyLayout<'tcx, Ty<'tcx>>,\n-                                      offset: Size,\n-                                      is_return: bool| {\n-            // Booleans are always an i1 that needs to be zero-extended.\n-            if scalar.is_bool() {\n-                attrs.set(ArgAttribute::ZExt);\n-                return;\n-            }\n-\n-            // Only pointer types handled below.\n-            if scalar.value != layout::Pointer {\n-                return;\n-            }\n-\n-            if scalar.valid_range.start() < scalar.valid_range.end() {\n-                if *scalar.valid_range.start() > 0 {\n-                    attrs.set(ArgAttribute::NonNull);\n-                }\n-            }\n-\n-            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n-                if let Some(kind) = pointee.safe {\n-                    attrs.pointee_size = pointee.size;\n-                    attrs.pointee_align = Some(pointee.align);\n-\n-                    // `Box` pointer parameters never alias because ownership is transferred\n-                    // `&mut` pointer parameters never alias other parameters,\n-                    // or mutable global data\n-                    //\n-                    // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n-                    // and can be marked as both `readonly` and `noalias`, as\n-                    // LLVM's definition of `noalias` is based solely on memory\n-                    // dependencies rather than pointer equality\n-                    let no_alias = match kind {\n-                        PointerKind::Shared => false,\n-                        PointerKind::UniqueOwned => true,\n-                        PointerKind::Frozen |\n-                        PointerKind::UniqueBorrowed => !is_return\n-                    };\n-                    if no_alias {\n-                        attrs.set(ArgAttribute::NoAlias);\n-                    }\n-\n-                    if kind == PointerKind::Frozen && !is_return {\n-                        attrs.set(ArgAttribute::ReadOnly);\n-                    }\n-                }\n-            }\n-        };\n-\n-        // Store the index of the last argument. This is useful for working with\n-        // C-compatible variadic arguments.\n-        let last_arg_idx = if sig.inputs().is_empty() {\n-            None\n-        } else {\n-            Some(sig.inputs().len() - 1)\n-        };\n-\n-        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n-            let is_return = arg_idx.is_none();\n-            let mut arg = mk_arg_type(ty, arg_idx);\n-            if arg.layout.is_zst() {\n-                // For some forsaken reason, x86_64-pc-windows-gnu\n-                // doesn't ignore zero-sized struct arguments.\n-                // The same is true for s390x-unknown-linux-gnu\n-                // and sparc64-unknown-linux-gnu.\n-                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n-                    arg.mode = PassMode::Ignore(IgnoreMode::Zst);\n-                }\n-            }\n-\n-            // If this is a C-variadic function, this is not the return value,\n-            // and there is one or more fixed arguments; ensure that the `VaList`\n-            // is ignored as an argument.\n-            if sig.c_variadic {\n-                match (last_arg_idx, arg_idx) {\n-                    (Some(last_idx), Some(cur_idx)) if last_idx == cur_idx => {\n-                        let va_list_did = match cx.tcx.lang_items().va_list() {\n-                            Some(did) => did,\n-                            None => bug!(\"`va_list` lang item required for C-variadic functions\"),\n-                        };\n-                        match ty.sty {\n-                            ty::Adt(def, _) if def.did == va_list_did => {\n-                                // This is the \"spoofed\" `VaList`. Set the arguments mode\n-                                // so that it will be ignored.\n-                                arg.mode = PassMode::Ignore(IgnoreMode::CVarArgs);\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n-            if !is_return && rust_abi {\n-                if let layout::Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n-                    let mut a_attrs = ArgAttributes::new();\n-                    let mut b_attrs = ArgAttributes::new();\n-                    adjust_for_rust_scalar(&mut a_attrs,\n-                                           a,\n-                                           arg.layout,\n-                                           Size::ZERO,\n-                                           false);\n-                    adjust_for_rust_scalar(&mut b_attrs,\n-                                           b,\n-                                           arg.layout,\n-                                           a.value.size(cx).align_to(b.value.align(cx).abi),\n-                                           false);\n-                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n-                    return arg;\n-                }\n-            }\n-\n-            if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n-                if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    adjust_for_rust_scalar(attrs,\n-                                           scalar,\n-                                           arg.layout,\n-                                           Size::ZERO,\n-                                           is_return);\n-                }\n-            }\n-\n-            arg\n-        };\n-\n-        let mut fn_ty = FnType {\n-            ret: arg_of(sig.output(), None),\n-            args: inputs.iter().cloned().chain(extra_args).enumerate().map(|(i, ty)| {\n-                arg_of(ty, Some(i))\n-            }).collect(),\n-            c_variadic: sig.c_variadic,\n-            conv,\n-        };\n-        FnTypeExt::adjust_for_abi(&mut fn_ty, cx, sig.abi);\n-        fn_ty\n-    }\n-\n-    fn adjust_for_abi(&mut self,\n-                      cx: &CodegenCx<'ll, 'tcx>,\n-                      abi: Abi) {\n-        if abi == Abi::Unadjusted { return }\n-\n-        if abi == Abi::Rust || abi == Abi::RustCall ||\n-           abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            let fixup = |arg: &mut ArgType<'tcx, Ty<'tcx>>| {\n-                if arg.is_ignore() { return; }\n-\n-                match arg.layout.abi {\n-                    layout::Abi::Aggregate { .. } => {}\n-\n-                    // This is a fun case! The gist of what this is doing is\n-                    // that we want callers and callees to always agree on the\n-                    // ABI of how they pass SIMD arguments. If we were to *not*\n-                    // make these arguments indirect then they'd be immediates\n-                    // in LLVM, which means that they'd used whatever the\n-                    // appropriate ABI is for the callee and the caller. That\n-                    // means, for example, if the caller doesn't have AVX\n-                    // enabled but the callee does, then passing an AVX argument\n-                    // across this boundary would cause corrupt data to show up.\n-                    //\n-                    // This problem is fixed by unconditionally passing SIMD\n-                    // arguments through memory between callers and callees\n-                    // which should get them all to agree on ABI regardless of\n-                    // target feature sets. Some more information about this\n-                    // issue can be found in #44367.\n-                    //\n-                    // Note that the platform intrinsic ABI is exempt here as\n-                    // that's how we connect up to LLVM and it's unstable\n-                    // anyway, we control all calls to it in libstd.\n-                    layout::Abi::Vector { .. }\n-                        if abi != Abi::PlatformIntrinsic &&\n-                            cx.sess().target.target.options.simd_types_indirect =>\n-                    {\n-                        arg.make_indirect();\n-                        return\n-                    }\n-\n-                    _ => return\n-                }\n-\n-                let size = arg.layout.size;\n-                if arg.layout.is_unsized() || size > layout::Pointer.size(cx) {\n-                    arg.make_indirect();\n-                } else {\n-                    // We want to pass small aggregates as immediates, but using\n-                    // a LLVM aggregate type for this leads to bad optimizations,\n-                    // so we pick an appropriately sized integer type instead.\n-                    arg.cast_to(Reg {\n-                        kind: RegKind::Integer,\n-                        size\n-                    });\n-                }\n-            };\n-            fixup(&mut self.ret);\n-            for arg in &mut self.args {\n-                fixup(arg);\n-            }\n-            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n-                attrs.set(ArgAttribute::StructRet);\n-            }\n-            return;\n-        }\n-\n-        if let Err(msg) = self.adjust_for_cabi(cx, abi) {\n-            cx.sess().fatal(&msg);\n-        }\n-    }\n-\n+impl<'tcx> FnTypeLlvmExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         let args_capacity: usize = self.args.iter().map(|arg|\n             if arg.pad.is_some() { 1 } else { 0 } +\n@@ -838,17 +473,17 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n \n impl AbiMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn new_fn_type(&self, sig: ty::FnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> FnType<'tcx, Ty<'tcx>> {\n-        FnTypeExt::new(&self, sig, extra_args)\n+        FnType::new(self, sig, extra_args)\n     }\n     fn new_vtable(\n         &self,\n         sig: ty::FnSig<'tcx>,\n         extra_args: &[Ty<'tcx>]\n     ) -> FnType<'tcx, Ty<'tcx>> {\n-        FnTypeExt::new_vtable(&self, sig, extra_args)\n+        FnType::new_vtable(self, sig, extra_args)\n     }\n     fn fn_type_of_instance(&self, instance: &Instance<'tcx>) -> FnType<'tcx, Ty<'tcx>> {\n-        FnTypeExt::of_instance(&self, instance)\n+        FnType::of_instance(self, instance)\n     }\n }\n "}, {"sha": "89fdec076c6d640f83afaa61fbb76a0050f1c126", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=e1b3c79d5c9ff805a03b478e77b44f9b48d848f0", "patch": "@@ -13,13 +13,13 @@\n \n use crate::llvm;\n use crate::llvm::AttributePlace::Function;\n-use crate::abi::{FnType, FnTypeExt};\n+use crate::abi::{FnType, FnTypeLlvmExt};\n use crate::attributes;\n use crate::context::CodegenCx;\n use crate::type_::Type;\n use crate::value::Value;\n-use rustc::ty::{self, PolyFnSig, Ty};\n-use rustc::ty::layout::{FnTypeExt as FnTypeExt1, LayoutOf};\n+use rustc::ty::{self, PolyFnSig};\n+use rustc::ty::layout::{FnTypeExt, LayoutOf};\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_codegen_ssa::traits::*;\n@@ -100,7 +100,7 @@ impl DeclareMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let sig = self.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-        let fty: FnType<'tcx, Ty<'tcx>> = FnTypeExt1::new(self, sig, &[]);\n+        let fty= FnType::new(self, sig, &[]);\n         let llfn = declare_raw_fn(self, name, fty.llvm_cconv(), fty.llvm_type(self));\n \n         if self.layout_of(sig.output()).abi.is_uninhabited() {"}, {"sha": "a3d3f0756a5f3997405faf73485934f3bd9987de", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b3c79d5c9ff805a03b478e77b44f9b48d848f0/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=e1b3c79d5c9ff805a03b478e77b44f9b48d848f0", "patch": "@@ -10,7 +10,7 @@ use rustc_codegen_ssa::traits::*;\n \n use crate::common;\n use crate::type_of::LayoutLlvmExt;\n-use crate::abi::{LlvmType, FnTypeExt};\n+use crate::abi::{LlvmType, FnTypeLlvmExt};\n use syntax::ast;\n use rustc::ty::Ty;\n use rustc::ty::layout::{self, Align, Size, TyLayout};"}]}