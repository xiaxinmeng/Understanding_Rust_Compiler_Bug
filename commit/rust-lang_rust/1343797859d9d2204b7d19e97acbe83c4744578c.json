{"sha": "1343797859d9d2204b7d19e97acbe83c4744578c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNDM3OTc4NTlkOWQyMjA0YjdkMTllOTdhY2JlODNjNDc0NDU3OGM=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-19T18:02:35Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-23T18:01:56Z"}, "message": "Lazily run dataflow for const qualification", "tree": {"sha": "ff926757e4cf1bed09e083d4457ffa3e305ab610", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff926757e4cf1bed09e083d4457ffa3e305ab610"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1343797859d9d2204b7d19e97acbe83c4744578c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1343797859d9d2204b7d19e97acbe83c4744578c", "html_url": "https://github.com/rust-lang/rust/commit/1343797859d9d2204b7d19e97acbe83c4744578c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1343797859d9d2204b7d19e97acbe83c4744578c/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "274c85f5c80f6a8ae800bf9054e49bb111824278", "url": "https://api.github.com/repos/rust-lang/rust/commits/274c85f5c80f6a8ae800bf9054e49bb111824278", "html_url": "https://github.com/rust-lang/rust/commit/274c85f5c80f6a8ae800bf9054e49bb111824278"}], "stats": {"total": 99, "additions": 56, "deletions": 43}, "files": [{"sha": "f47fd8239dea5a75d206cd8567fe618250f08c66", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 56, "deletions": 43, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1343797859d9d2204b7d19e97acbe83c4744578c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1343797859d9d2204b7d19e97acbe83c4744578c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=1343797859d9d2204b7d19e97acbe83c4744578c", "patch": "@@ -33,42 +33,72 @@ type IndirectlyMutableResults<'mir, 'tcx> =\n type QualifResults<'mir, 'tcx, Q> =\n     dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'mir, 'mir, 'tcx, Q>>;\n \n+#[derive(Default)]\n pub struct Qualifs<'mir, 'tcx> {\n-    has_mut_interior: QualifResults<'mir, 'tcx, HasMutInterior>,\n-    needs_drop: QualifResults<'mir, 'tcx, NeedsDrop>,\n-    indirectly_mutable: IndirectlyMutableResults<'mir, 'tcx>,\n+    has_mut_interior: Option<QualifResults<'mir, 'tcx, HasMutInterior>>,\n+    needs_drop: Option<QualifResults<'mir, 'tcx, NeedsDrop>>,\n+    indirectly_mutable: Option<IndirectlyMutableResults<'mir, 'tcx>>,\n }\n \n impl Qualifs<'mir, 'tcx> {\n     fn indirectly_mutable(\n         &mut self,\n-        _: &Item<'mir, 'tcx>,\n+        ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n         location: Location,\n     ) -> bool {\n-        self.indirectly_mutable.seek_before(location);\n-        self.indirectly_mutable.get().contains(local)\n+        let indirectly_mutable = self.indirectly_mutable.get_or_insert_with(|| {\n+            let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n+\n+            // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n+            // allowed in a const.\n+            //\n+            // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n+            // without breaking stable code?\n+            MaybeMutBorrowedLocals::mut_borrows_only(tcx, &body, param_env)\n+                .unsound_ignore_borrow_on_drop()\n+                .into_engine(tcx, &body, def_id)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(&body)\n+        });\n+\n+        indirectly_mutable.seek_before(location);\n+        indirectly_mutable.get().contains(local)\n     }\n \n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n-    fn needs_drop(&mut self, item: &Item<'mir, 'tcx>, local: Local, location: Location) -> bool {\n-        let ty = item.body.local_decls[local].ty;\n-        if !NeedsDrop::in_any_value_of_ty(item, ty) {\n+    fn needs_drop(\n+        &mut self,\n+        ccx: &'mir ConstCx<'mir, 'tcx>,\n+        local: Local,\n+        location: Location,\n+    ) -> bool {\n+        let ty = ccx.body.local_decls[local].ty;\n+        if !NeedsDrop::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n-        self.needs_drop.seek_before(location);\n-        self.needs_drop.get().contains(local) || self.indirectly_mutable(item, local, location)\n+        let needs_drop = self.needs_drop.get_or_insert_with(|| {\n+            let ConstCx { tcx, body, def_id, .. } = *ccx;\n+\n+            FlowSensitiveAnalysis::new(NeedsDrop, ccx)\n+                .into_engine(tcx, &body, def_id)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(&body)\n+        });\n+\n+        needs_drop.seek_before(location);\n+        needs_drop.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n \n     /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary.\n     fn has_mut_interior(\n         &mut self,\n-        item: &Item<'mir, 'tcx>,\n+        ccx: &'mir ConstCx<'mir, 'tcx>,\n         local: Local,\n         location: Location,\n     ) -> bool {\n@@ -77,12 +107,20 @@ impl Qualifs<'mir, 'tcx> {\n             return false;\n         }\n \n-        self.has_mut_interior.seek_before(location);\n-        self.has_mut_interior.get().contains(local)\n-            || self.indirectly_mutable(item, local, location)\n+        let has_mut_interior = self.has_mut_interior.get_or_insert_with(|| {\n+            let ConstCx { tcx, body, def_id, .. } = *ccx;\n+\n+            FlowSensitiveAnalysis::new(HasMutInterior, ccx)\n+                .into_engine(tcx, &body, def_id)\n+                .iterate_to_fixpoint()\n+                .into_results_cursor(&body)\n+        });\n+\n+        has_mut_interior.seek_before(location);\n+        has_mut_interior.get().contains(local) || self.indirectly_mutable(ccx, local, location)\n     }\n \n-    fn in_return_place(&mut self, item: &Item<'mir, 'tcx>) -> ConstQualifs {\n+    fn in_return_place(&mut self, ccx: &'mir ConstCx<'mir, 'tcx>) -> ConstQualifs {\n         // Find the `Return` terminator if one exists.\n         //\n         // If no `Return` terminator exists, this MIR is divergent. Just return the conservative\n@@ -128,33 +166,8 @@ impl Deref for Validator<'mir, 'tcx> {\n }\n \n impl Validator<'mir, 'tcx> {\n-    pub fn new(item: &'mir Item<'mir, 'tcx>) -> Self {\n-        let Item { tcx, body, def_id, param_env, .. } = *item;\n-\n-        // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n-        // allowed in a const.\n-        //\n-        // FIXME(ecstaticmorse): Someday we want to allow custom drop impls. How do we do this\n-        // without breaking stable code?\n-        let indirectly_mutable = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n-            .unsound_ignore_borrow_on_drop()\n-            .into_engine(tcx, body, def_id)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(body);\n-\n-        let needs_drop = FlowSensitiveAnalysis::new(NeedsDrop, item)\n-            .into_engine(item.tcx, &item.body, item.def_id)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(*item.body);\n-\n-        let has_mut_interior = FlowSensitiveAnalysis::new(HasMutInterior, item)\n-            .into_engine(item.tcx, &item.body, item.def_id)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(*item.body);\n-\n-        let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n-\n-        Validator { span: ccx.body.span, ccx, qualifs }\n+    pub fn new(ccx: &'mir ConstCx<'mir, 'tcx>) -> Self {\n+        Validator { span: ccx.body.span, ccx, qualifs: Default::default() }\n     }\n \n     pub fn check_body(&mut self) {"}]}