{"sha": "c53aa2989a2553398a1d223811222fd65fb369d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1M2FhMjk4OWEyNTUzMzk4YTFkMjIzODExMjIyZmQ2NWZiMzY5ZDc=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-30T13:59:00Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-08-01T13:29:35Z"}, "message": "Address stylistic review comments and rebase fallout", "tree": {"sha": "2a03eb6af6f7f4d30d05bb98ad369cc1b7bd3317", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a03eb6af6f7f4d30d05bb98ad369cc1b7bd3317"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c53aa2989a2553398a1d223811222fd65fb369d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c53aa2989a2553398a1d223811222fd65fb369d7", "html_url": "https://github.com/rust-lang/rust/commit/c53aa2989a2553398a1d223811222fd65fb369d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c53aa2989a2553398a1d223811222fd65fb369d7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32eb10f54d33e7d907975fd1a859d987280c6c48", "url": "https://api.github.com/repos/rust-lang/rust/commits/32eb10f54d33e7d907975fd1a859d987280c6c48", "html_url": "https://github.com/rust-lang/rust/commit/32eb10f54d33e7d907975fd1a859d987280c6c48"}], "stats": {"total": 127, "additions": 44, "deletions": 83}, "files": [{"sha": "74d7186b90a8674f71558344ed3aee35e828d462", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=c53aa2989a2553398a1d223811222fd65fb369d7", "patch": "@@ -28,8 +28,11 @@ impl<'tcx> ConstValue<'tcx> {\n     pub fn from_byval_value(val: Value) -> EvalResult<'static, Self> {\n         Ok(match val {\n             Value::ByRef(..) => bug!(),\n-            Value::ScalarPair(a, b) => ConstValue::ScalarPair(a.read()?, b.read()?),\n-            Value::Scalar(val) => ConstValue::Scalar(val.read()?),\n+            Value::ScalarPair(a, b) => ConstValue::ScalarPair(\n+                a.unwrap_or_err()?,\n+                b.unwrap_or_err()?,\n+            ),\n+            Value::Scalar(val) => ConstValue::Scalar(val.unwrap_or_err()?),\n         })\n     }\n \n@@ -197,7 +200,7 @@ impl From<Scalar> for ScalarMaybeUndef {\n }\n \n impl ScalarMaybeUndef {\n-    pub fn read(self) -> EvalResult<'static, Scalar> {\n+    pub fn unwrap_or_err(self) -> EvalResult<'static, Scalar> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUndef::Undef => err!(ReadUndefBytes),"}, {"sha": "2e4ed7afc22e8a71456355415e57d1bfd3301f25", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=c53aa2989a2553398a1d223811222fd65fb369d7", "patch": "@@ -88,8 +88,8 @@ pub fn value_to_const_value<'tcx>(\n     }\n     let val = (|| {\n         match val {\n-            Value::Scalar(val) => Ok(ConstValue::Scalar(val.read()?)),\n-            Value::ScalarPair(a, b) => Ok(ConstValue::ScalarPair(a.read()?, b.read()?)),\n+            Value::Scalar(val) => Ok(ConstValue::Scalar(val.unwrap_or_err()?)),\n+            Value::ScalarPair(a, b) => Ok(ConstValue::ScalarPair(a.unwrap_or_err()?, b.unwrap_or_err()?)),\n             Value::ByRef(ptr, align) => {\n                 let ptr = ptr.to_ptr().unwrap();\n                 let alloc = ecx.memory.get(ptr.alloc_id)?;\n@@ -441,7 +441,7 @@ pub fn const_val_field<'a, 'tcx>(\n         let place = ecx.allocate_place_for_value(value, layout, variant)?;\n         let (place, layout) = ecx.place_field(place, field, layout)?;\n         let (ptr, align) = place.to_ptr_align();\n-        let mut new_value = Value::ByRef(ptr.read()?, align);\n+        let mut new_value = Value::ByRef(ptr.unwrap_or_err()?, align);\n         new_value = ecx.try_read_by_ref(new_value, layout.ty)?;\n         use rustc_data_structures::indexed_vec::Idx;\n         match (value, new_value) {\n@@ -485,7 +485,7 @@ pub fn const_variant_index<'a, 'tcx>(\n         },\n         Value::ByRef(ptr, align) => (ptr, align),\n     };\n-    let place = Place::from_scalar_ptr(ptr, align);\n+    let place = Place::from_scalar_ptr(ptr.into(), align);\n     ecx.read_discriminant_as_variant_index(place, layout)\n }\n "}, {"sha": "7f32156592c9caee3d0a3f4ebc07b57531d175c0", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 22, "deletions": 64, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c53aa2989a2553398a1d223811222fd65fb369d7", "patch": "@@ -616,7 +616,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 if let Place::Ptr { ptr, .. } = frame.return_place {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n                     self.memory.mark_static_initialized(\n-                        ptr.read()?.to_ptr()?.alloc_id,\n+                        ptr.unwrap_or_err()?.to_ptr()?.alloc_id,\n                         mutable,\n                     )?\n                 } else {\n@@ -744,7 +744,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let (dest, dest_align) = self.force_allocation(dest)?.to_ptr_align();\n \n                 if length > 0 {\n-                    let dest = dest.read()?;\n+                    let dest = dest.unwrap_or_err()?;\n                     //write the first value\n                     self.write_value_to_ptr(value, dest, dest_align, elem_ty)?;\n \n@@ -1082,7 +1082,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             },\n         };\n         Ok(Place::Ptr {\n-            ptr,\n+            ptr: ptr.into(),\n             align,\n             extra: variant.map_or(PlaceExtra::None, PlaceExtra::DowncastVariant),\n         })\n@@ -1120,7 +1120,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     /// ensures this Value is not a ByRef\n     pub fn follow_by_ref_value(\n-        &mut self,\n+        &self,\n         value: Value,\n         ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n@@ -1133,13 +1133,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     pub fn value_to_scalar(\n-        &mut self,\n+        &self,\n         ValTy { value, ty } : ValTy<'tcx>,\n     ) -> EvalResult<'tcx, Scalar> {\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef { .. } => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n-            Value::Scalar(scalar) => Ok(scalar),\n+            Value::Scalar(scalar) => scalar.unwrap_or_err(),\n \n             Value::ScalarPair(..) => bug!(\"value_to_scalar can't work with fat pointers\"),\n         }\n@@ -1179,7 +1179,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         match dest {\n             Place::Ptr { ptr, align, extra } => {\n                 assert_eq!(extra, PlaceExtra::None);\n-                self.write_value_to_ptr(src_val, ptr.read()?, align, dest_ty)\n+                self.write_value_to_ptr(src_val, ptr.unwrap_or_err()?, align, dest_ty)\n             }\n \n             Place::Local { frame, local } => {\n@@ -1288,37 +1288,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub(crate) fn read_ptr(\n-        &self,\n-        ptr: Pointer,\n-        ptr_align: Align,\n-        pointee_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Value> {\n-        let ptr_size = self.memory.pointer_size();\n-        let p: ScalarMaybeUndef = self.memory.read_ptr_sized(ptr, ptr_align)?;\n-        if self.type_is_sized(pointee_ty) {\n-            Ok(Value::Scalar(p))\n-        } else {\n-            trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n-            let extra = ptr.offset(ptr_size, self)?;\n-            match self.tcx.struct_tail(pointee_ty).sty {\n-                ty::TyDynamic(..) => Ok(Value::ScalarPair(\n-                    p,\n-                    self.memory.read_ptr_sized(extra, ptr_align)?,\n-                )),\n-                ty::TySlice(..) | ty::TyStr => {\n-                    let len = self\n-                        .memory\n-                        .read_ptr_sized(extra, ptr_align)?\n-                        .read()?\n-                        .to_bits(ptr_size)?;\n-                    Ok(p.to_value_with_len(len as u64, self.tcx.tcx))\n-                },\n-                _ => bug!(\"unsized scalar ptr read from {:?}\", pointee_ty),\n-            }\n-        }\n-    }\n-\n     fn validate_scalar(\n         &self,\n         value: Scalar,\n@@ -1330,8 +1299,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n         let (lo, hi) = scalar.valid_range.clone().into_inner();\n \n-        let (bits, defined) = match value {\n-            Scalar::Bits { bits, defined } => (bits, defined),\n+        let bits = match value {\n+            Scalar::Bits { bits, size: value_size } => {\n+                assert_eq!(value_size as u64, size.bytes());\n+                bits\n+            },\n             Scalar::Ptr(_) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n@@ -1374,30 +1346,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n \n         use std::ops::RangeInclusive;\n-        let in_range = |bound: RangeInclusive<u128>| {\n-            defined as u64 >= size.bits() && bound.contains(&bits)\n-        };\n+        let in_range = |bound: RangeInclusive<u128>| bound.contains(&bits);\n         if lo > hi {\n             if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n                 Ok(())\n-            } else if defined as u64 >= size.bits() {\n-                validation_failure!(\n-                    bits,\n-                    path,\n-                    format!(\"something in the range {:?} or {:?}\", ..=hi, lo..)\n-                )\n             } else {\n                 validation_failure!(\"undefined bytes\", path)\n             }\n         } else {\n             if in_range(scalar.valid_range.clone()) {\n                 Ok(())\n-            } else if defined as u64 >= size.bits() {\n-                validation_failure!(\n-                    bits,\n-                    path,\n-                    format!(\"something in the range {:?}\", scalar.valid_range)\n-                )\n             } else {\n                 validation_failure!(\"undefined bytes\", path)\n             }\n@@ -1455,7 +1413,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     // expectation.\n                     layout::Abi::Scalar(ref scalar) => {\n                         let size = scalar.value.size(self);\n-                        let value = self.memory.read_scalar(ptr, ptr_align, size)?;\n+                        let value = self.memory.read_scalar(ptr, ptr_align, size)?.unwrap_or_err()?;\n                         self.validate_scalar(value, size, scalar, &path, layout.ty)?;\n                         if scalar.value == Primitive::Pointer {\n                             // ignore integer pointers, we can't reason about the final hardware\n@@ -1538,7 +1496,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub fn try_read_by_ref(&mut self, mut val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn try_read_by_ref(&self, mut val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         // Convert to ByVal or ScalarPair if possible\n         if let Value::ByRef(ptr, align) = val {\n             if let Some(read_val) = self.try_read_value(ptr, align, ty)? {\n@@ -1548,7 +1506,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(val)\n     }\n \n-    pub fn try_read_value(&mut self, ptr: Scalar, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn try_read_value(&self, ptr: Scalar, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         let mut layout = self.layout_of(ty)?;\n         self.memory.check_align(ptr, ptr_align)?;\n \n@@ -1563,9 +1521,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             layout::Variants::Tagged { .. } => {\n                 let variant_index = self.read_discriminant_as_variant_index(\n                     Place::from_ptr(ptr, ptr_align),\n-                    layout.ty,\n+                    layout,\n                 )?;\n-                layout = layout.for_variant(&self, variant_index);\n+                layout = layout.for_variant(self, variant_index);\n                 trace!(\"variant layout: {:#?}\", layout);\n             },\n             layout::Variants::Single { .. } => {},\n@@ -1578,10 +1536,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 let (a, b) = (&a.value, &b.value);\n-                let (a_size, b_size) = (a.size(&self), b.size(&self));\n+                let (a_size, b_size) = (a.size(self), b.size(self));\n                 let a_ptr = ptr;\n-                let b_offset = a_size.abi_align(b.align(&self));\n-                let b_ptr = ptr.offset(b_offset, &self)?.into();\n+                let b_offset = a_size.abi_align(b.align(self));\n+                let b_ptr = ptr.offset(b_offset, self)?.into();\n                 let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n                 let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n                 Ok(Some(Value::ScalarPair(a_val, b_val)))\n@@ -1929,7 +1887,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 ScalarMaybeUndef::Undef,\n                 ScalarMaybeUndef::Undef,\n             ),\n-            _ => Value::ByRef(self.alloc_ptr(ty)?.into(), layout.align),\n+            _ => Value::ByRef(self.alloc_ptr(layout)?.into(), layout.align),\n         })\n     }\n }"}, {"sha": "f120e0f73383e772c3ecb18859da41fb8ac56814", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c53aa2989a2553398a1d223811222fd65fb369d7", "patch": "@@ -1011,11 +1011,11 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n                 let vtable = mem.read_ptr_sized(\n                     ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n-                )?.read()?.to_ptr()?;\n+                )?.unwrap_or_err()?.to_ptr()?;\n                 Ok((ptr, vtable))\n             }\n \n-            Value::ScalarPair(ptr, vtable) => Ok((ptr, vtable.read()?.to_ptr()?)),\n+            Value::ScalarPair(ptr, vtable) => Ok((ptr, vtable.unwrap_or_err()?.to_ptr()?)),\n             _ => bug!(\"expected ptr and vtable, got {:?}\", value),\n         }\n     }\n@@ -1031,11 +1031,11 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n                 let len = mem.read_ptr_sized(\n                     ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n-                )?.read()?.to_bits(mem.pointer_size())? as u64;\n+                )?.unwrap_or_err()?.to_bits(mem.pointer_size())? as u64;\n                 Ok((ptr, len))\n             }\n             Value::ScalarPair(ptr, val) => {\n-                let len = val.read()?.to_bits(self.memory().pointer_size())?;\n+                let len = val.unwrap_or_err()?.to_bits(self.memory().pointer_size())?;\n                 Ok((ptr, len as u64))\n             }\n             Value::Scalar(_) => bug!(\"expected ptr and length, got {:?}\", value),"}, {"sha": "006343424efcf6ecb310045107565992fc0dcbfc", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c53aa2989a2553398a1d223811222fd65fb369d7", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match place {\n             Place::Ptr { ptr, align, extra } => {\n                 assert_eq!(extra, PlaceExtra::None);\n-                Ok(Value::ByRef(ptr.read()?, align))\n+                Ok(Value::ByRef(ptr.unwrap_or_err()?, align))\n             }\n             Place::Local { frame, local } => self.stack[frame].locals[local].access(),\n         }"}, {"sha": "fe8071897c34874bd2b4ecc7178f6f3bd08af670", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=c53aa2989a2553398a1d223811222fd65fb369d7", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let instance = match ty.sty {\n             ty::TyDynamic(..) => {\n                 if let Value::ScalarPair(_, vtable) = arg {\n-                    self.read_drop_type_from_vtable(vtable.read()?.to_ptr()?)?\n+                    self.read_drop_type_from_vtable(vtable.unwrap_or_err()?.to_ptr()?)?\n                 } else {\n                     bug!(\"expected fat ptr, got {:?}\", arg);\n                 }"}, {"sha": "682e384da3936eb6caae8af7039e019d40805556", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=c53aa2989a2553398a1d223811222fd65fb369d7", "patch": "@@ -392,7 +392,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                     ptr_align\n-                )?.read()?.to_ptr()?;\n+                )?.unwrap_or_err()?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();\n                 let ty = self.layout_of(args[0].ty)?.field(&self, 0)?.ty;"}, {"sha": "84583680988b7c093c368eeb93cfd8d3c2aad59e", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=c53aa2989a2553398a1d223811222fd65fb369d7", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.read()?.to_ptr()?;\n+        let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.unwrap_or_err()?.to_ptr()?;\n         self.memory.get_fn(drop_fn)\n     }\n \n@@ -82,11 +82,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.read()?.to_bits(pointer_size)? as u64;\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.unwrap_or_err()?.to_bits(pointer_size)? as u64;\n         let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n-        )?.read()?.to_bits(pointer_size)? as u64;\n+        )?.unwrap_or_err()?.to_bits(pointer_size)? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n     }\n }"}, {"sha": "05e51c5430d7fe5aafd0f4b9741974e09722dc70", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c53aa2989a2553398a1d223811222fd65fb369d7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c53aa2989a2553398a1d223811222fd65fb369d7", "patch": "@@ -369,7 +369,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     Value::Scalar(Scalar::Bits {\n                         bits: n as u128,\n                         size: self.tcx.data_layout.pointer_size.bytes() as u8,\n-                    }),\n+                    }.into()),\n                     self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n                     span,\n                 )))\n@@ -391,7 +391,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     this.ecx.value_to_scalar(ValTy { value: val.0, ty: val.1.ty })\n                 })?;\n                 let val = self.use_ecx(source_info, |this| this.ecx.unary_op(op, prim, val.1))?;\n-                Some((Value::Scalar(val), place_layout, span))\n+                Some((Value::Scalar(val.into()), place_layout, span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {"}]}