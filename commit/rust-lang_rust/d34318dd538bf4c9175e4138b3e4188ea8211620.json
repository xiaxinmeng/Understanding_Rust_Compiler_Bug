{"sha": "d34318dd538bf4c9175e4138b3e4188ea8211620", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNDMxOGRkNTM4YmY0YzkxNzVlNDEzOGIzZTQxODhlYTgyMTE2MjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-12T21:42:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-12T21:42:12Z"}, "message": "Auto merge of #37118 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 17 pull requests\n\n- Successful merges: #36762, #36831, #36973, #36991, #36995, #37023, #37049, #37050, #37056, #37064, #37066, #37067, #37084, #37089, #37091, #37092, #37110\n- Failed merges:", "tree": {"sha": "a18e44fe88822453f71d47bfa3b4c89e9d8ed58d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a18e44fe88822453f71d47bfa3b4c89e9d8ed58d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d34318dd538bf4c9175e4138b3e4188ea8211620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d34318dd538bf4c9175e4138b3e4188ea8211620", "html_url": "https://github.com/rust-lang/rust/commit/d34318dd538bf4c9175e4138b3e4188ea8211620", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d34318dd538bf4c9175e4138b3e4188ea8211620/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cb01365eed598811aef847a8ee414dab576f3c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb01365eed598811aef847a8ee414dab576f3c8", "html_url": "https://github.com/rust-lang/rust/commit/9cb01365eed598811aef847a8ee414dab576f3c8"}, {"sha": "27043b15af9b1720bdcb6c355df849ebd51e7f8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/27043b15af9b1720bdcb6c355df849ebd51e7f8a", "html_url": "https://github.com/rust-lang/rust/commit/27043b15af9b1720bdcb6c355df849ebd51e7f8a"}], "stats": {"total": 2266, "additions": 1321, "deletions": 945}, "files": [{"sha": "d0c85c0a008be71362a82d16701c180d397220da", "filename": "configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/configure", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -1635,8 +1635,8 @@ do\n         (\"ccache gcc\")\n             LLVM_CXX_32=\"ccache\"\n             LLVM_CC_32=\"ccache\"\n-            LLVM_CXX_32_ARG1=\"clang++\"\n-            LLVM_CC_32_ARG1=\"clang\"\n+            LLVM_CXX_32_ARG1=\"g++\"\n+            LLVM_CC_32_ARG1=\"gcc\"\n \n             LLVM_CXX_64=\"ccache\"\n             LLVM_CC_64=\"ccache\""}, {"sha": "84f459bf8724fd40d10034d0ece03d002f8b07f4", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -2472,8 +2472,7 @@ The currently implemented features of the reference compiler are:\n * - `default_type_parameter_fallback` - Allows type parameter defaults to\n                                         influence type inference.\n \n-* - `stmt_expr_attributes` - Allows attributes on expressions and\n-                             non-item statements.\n+* - `stmt_expr_attributes` - Allows attributes on expressions.\n \n * - `type_ascription` - Allows type ascription expressions `expr: Type`.\n "}, {"sha": "f7edcb998a927328a8c33dadeea5841fc43ac5c8", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -73,7 +73,6 @@\n \n use fmt;\n use intrinsics;\n-use marker::Reflect;\n \n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n@@ -86,7 +85,7 @@ use marker::Reflect;\n ///\n /// [mod]: index.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Any: Reflect + 'static {\n+pub trait Any: 'static {\n     /// Gets the `TypeId` of `self`.\n     ///\n     /// # Examples\n@@ -112,7 +111,7 @@ pub trait Any: Reflect + 'static {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Reflect + 'static + ?Sized > Any for T {\n+impl<T: 'static + ?Sized > Any for T {\n     fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }\n }\n \n@@ -366,7 +365,7 @@ impl TypeId {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn of<T: ?Sized + Reflect + 'static>() -> TypeId {\n+    pub fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },\n         }"}, {"sha": "28101d21fc25ecd691ae7eae8e91f43b270f652d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -89,7 +89,7 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(never_type)]\n #![feature(prelude_import)]\n "}, {"sha": "6e08abd34614386c41479764b91248ea788f23d0", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -255,6 +255,9 @@ macro_rules! debug_assert_ne {\n /// Helper macro for reducing boilerplate code for matching `Result` together\n /// with converting downstream errors.\n ///\n+/// Prefer using `?` syntax to `try!`. `?` is built in to the language and is\n+/// more succinct than `try!`. It is the standard method for error propagation.\n+///\n /// `try!` matches the given `Result`. In case of the `Ok` variant, the\n /// expression has the value of the wrapped value.\n ///"}, {"sha": "03d8af1563d6de1e639bd7fc4ea73068acb077d9", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -587,11 +587,14 @@ mod impls {\n #[unstable(feature = \"reflect_marker\",\n            reason = \"requires RFC and more experience\",\n            issue = \"27749\")]\n+#[rustc_deprecated(since = \"1.14.0\", reason = \"Specialization makes parametricity impossible\")]\n #[rustc_on_unimplemented = \"`{Self}` does not implement `Any`; \\\n                             ensure all type parameters are bounded by `Any`\"]\n pub trait Reflect {}\n \n #[unstable(feature = \"reflect_marker\",\n            reason = \"requires RFC and more experience\",\n            issue = \"27749\")]\n+#[rustc_deprecated(since = \"1.14.0\", reason = \"Specialization makes parametricity impossible\")]\n+#[allow(deprecated)]\n impl Reflect for .. { }"}, {"sha": "95c46ec5715e742740963b414c75195050a4ba6c", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -295,7 +295,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(str_escape)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n \n use self::LabelText::*;\n "}, {"sha": "ebeab042e6bb14a447627b57ed9a493e2cc0e095", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -1 +1 @@\n-Subproject commit 5a17b4a733a22d445fdd63326f826fcd8a584328\n+Subproject commit ebeab042e6bb14a447627b57ed9a493e2cc0e095"}, {"sha": "12a1a4255246a43ad64fdd77b39d5180cac56aab", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -1327,30 +1327,6 @@ let x: i32 = \"I am not a number!\";\n //      |\n //    type `i32` assigned to variable `x`\n ```\n-\n-Another situation in which this occurs is when you attempt to use the `try!`\n-macro inside a function that does not return a `Result<T, E>`:\n-\n-```compile_fail,E0308\n-use std::fs::File;\n-\n-fn main() {\n-    let mut f = try!(File::create(\"foo.txt\"));\n-}\n-```\n-\n-This code gives an error like this:\n-\n-```text\n-<std macros>:5:8: 6:42 error: mismatched types:\n- expected `()`,\n-     found `core::result::Result<_, _>`\n- (expected (),\n-     found enum `core::result::Result`) [E0308]\n-```\n-\n-`try!` returns a `Result<T, E>`, and so the function must. But `main()` has\n-`()` as its return type, hence the error.\n \"##,\n \n E0309: r##\""}, {"sha": "137c6b58dc99817cde20d652f6f747b579391398", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -94,13 +94,7 @@ pub fn lower_crate(sess: &Session,\n     let _ignore = sess.dep_graph.in_ignore();\n \n     LoweringContext {\n-        crate_root: if std_inject::no_core(krate) {\n-            None\n-        } else if std_inject::no_std(krate) {\n-            Some(\"core\")\n-        } else {\n-            Some(\"std\")\n-        },\n+        crate_root: std_inject::injected_crate_name(krate),\n         sess: sess,\n         parent_def: None,\n         resolver: resolver,"}, {"sha": "25731df47785392ce6b91a28f278bf683ce2810a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -40,7 +40,7 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "d002aba595bcac22f70fc8215c4eb1febd36c2e6", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -118,6 +118,8 @@ pub struct PerfStats {\n     pub incr_comp_hashes_time: Cell<Duration>,\n     // The number of incr. comp. hash computations performed\n     pub incr_comp_hashes_count: Cell<u64>,\n+    // The number of bytes hashed when computing ICH values\n+    pub incr_comp_bytes_hashed: Cell<u64>,\n     // The accumulated time spent on computing symbol hashes\n     pub symbol_hash_time: Cell<Duration>,\n }\n@@ -439,6 +441,11 @@ impl Session {\n                  duration_to_secs_str(self.perf_stats.incr_comp_hashes_time.get()));\n         println!(\"Total number of incr. comp. hashes computed:   {}\",\n                  self.perf_stats.incr_comp_hashes_count.get());\n+        println!(\"Total number of bytes hashed for incr. comp.:  {}\",\n+                 self.perf_stats.incr_comp_bytes_hashed.get());\n+        println!(\"Average bytes hashed per incr. comp. HIR node: {}\",\n+                 self.perf_stats.incr_comp_bytes_hashed.get() /\n+                 self.perf_stats.incr_comp_hashes_count.get());\n         println!(\"Total time spent computing symbol hashes:      {}\",\n                  duration_to_secs_str(self.perf_stats.symbol_hash_time.get()));\n     }\n@@ -571,6 +578,7 @@ pub fn build_session_(sopts: config::Options,\n             svh_time: Cell::new(Duration::from_secs(0)),\n             incr_comp_hashes_time: Cell::new(Duration::from_secs(0)),\n             incr_comp_hashes_count: Cell::new(0),\n+            incr_comp_bytes_hashed: Cell::new(0),\n             symbol_hash_time: Cell::new(Duration::from_secs(0)),\n         }\n     };"}, {"sha": "e6d1982d31c2d3370adaac3ceafe3e2ccfc6111c", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -37,7 +37,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(step_by)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;"}, {"sha": "f6260527039d0129823fa91d1678d1cc721dfc07", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -12,6 +12,8 @@\n \n use syntax::ast::NodeId;\n use rustc::mir::repr::{BasicBlock, Mir};\n+use rustc_data_structures::bitslice::bits_to_string;\n+use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n use dot;\n@@ -27,8 +29,6 @@ use std::path::Path;\n \n use super::super::MoveDataParamEnv;\n use super::super::MirBorrowckCtxtPreDataflow;\n-use bitslice::bits_to_string;\n-use indexed_set::{IdxSet};\n use super::{BitDenotation, DataflowState};\n \n impl<O: BitDenotation> DataflowState<O> {"}, {"sha": "dce167975cf34d0fb7d8f749b77839da40d24ebb", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -10,6 +10,9 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::repr::{self, Mir, Location};\n+use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n+use rustc_data_structures::bitslice::{BitwiseOperator};\n+use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::super::gather_moves::{MoveOutIndex, MovePathIndex};\n@@ -21,10 +24,6 @@ use super::super::on_lookup_result_bits;\n \n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n-use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n-use bitslice::{BitwiseOperator};\n-use indexed_set::{IdxSet};\n-\n // Dataflow analyses are built upon some interpretation of the\n // bitvectors attached to each basic block, represented via a\n // zero-sized structure."}, {"sha": "0c510e95b67fe26b6402037d5cbdc444cd9484d5", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n \n use rustc::ty::TyCtxt;\n use rustc::mir::repr::{self, Mir};\n@@ -22,9 +24,6 @@ use std::usize;\n use super::MirBorrowckCtxtPreDataflow;\n use super::MoveDataParamEnv;\n \n-use bitslice::{bitwise, BitwiseOperator};\n-use indexed_set::{IdxSet, IdxSetBuf};\n-\n pub use self::sanity_check::sanity_check_via_rustc_peek;\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};"}, {"sha": "25986b85f7b3a3d0cf603a9105ebb0800cd128fc", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use indexed_set::IdxSetBuf;\n use super::gather_moves::{MoveData, MovePathIndex, LookupResult};\n use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use super::dataflow::{DataflowResults};\n@@ -23,6 +22,7 @@ use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::lang_items;\n use rustc::util::nodemap::FnvHashMap;\n+use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n "}, {"sha": "da899714e935138704b63ca6321a3f42e7e98daa", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -26,7 +26,7 @@\n #![feature(staged_api)]\n #![feature(associated_consts)]\n #![feature(nonzero)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n@@ -50,8 +50,6 @@ pub use borrowck::{AnalysisData, BorrowckCtxt, ElaborateDrops};\n pub mod diagnostics;\n \n mod borrowck;\n-mod bitslice;\n-mod indexed_set;\n \n pub mod graphviz;\n "}, {"sha": "81dd642de5d275c33df5f3a578cc7512e47dc12a", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -732,6 +732,10 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               hir::BiBitOr => a | b,\n               hir::BiEq => a == b,\n               hir::BiNe => a != b,\n+              hir::BiLt => a < b,\n+              hir::BiLe => a <= b,\n+              hir::BiGe => a >= b,\n+              hir::BiGt => a > b,\n               _ => signal!(e, InvalidOpForBools(op.node)),\n              })\n           }"}, {"sha": "7b40269ba56ad271ac459e55c88c1d111fbdd762", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -27,7 +27,7 @@\n #![feature(staged_api)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n "}, {"sha": "31fccb41ce573840ec8bcbbed5c5534e0ca07504", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -25,7 +25,7 @@\n \n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "ba53578e5791852ccc56486325bda181fff1f2e7", "filename": "src/librustc_data_structures/bitslice.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_data_structures%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_data_structures%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitslice.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: move this to `rustc_data_structures` and potentially merge\n-// with `bitvec` there.\n+// FIXME: merge with `bitvec`\n \n use std::mem;\n ", "previous_filename": "src/librustc_borrowck/bitslice.rs"}, {"sha": "2e9e054e97eafe7dd0172d5f116710d65f1c7669", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,16 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: move this to `rustc_data_structures`\n-\n use std::fmt;\n use std::marker::PhantomData;\n use std::mem;\n use std::ops::{Deref, DerefMut, Range};\n use bitslice::{BitSlice, Word};\n use bitslice::{bitwise, Union, Subtract};\n-\n-use rustc_data_structures::indexed_vec::Idx;\n+use indexed_vec::Idx;\n \n /// Represents a set (or packed family of sets), of some element type\n /// E, where each E is identified by some unique index type `T`.", "previous_filename": "src/librustc_borrowck/indexed_set.rs"}, {"sha": "c8f4d766153cf9788b26ff8d00963b5a7abc5340", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -41,9 +41,11 @@ extern crate serialize as rustc_serialize; // used by deriving\n #[cfg(unix)]\n extern crate libc;\n \n+pub mod bitslice;\n pub mod bitvec;\n pub mod graph;\n pub mod ivar;\n+pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;\n pub mod snapshot_map;"}, {"sha": "e8ab2f3a2405b541553dfa908585ca297c4b998f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -649,7 +649,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver =\n         Resolver::new(sess, &krate, make_glob_map, &mut crate_loader, &resolver_arenas);\n-    syntax_ext::register_builtins(&mut resolver, sess.features.borrow().quote);\n+    syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features.borrow().quote);\n \n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n@@ -686,11 +686,17 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n         let mut ecx = ExtCtxt::new(&sess.parse_sess, krate.config.clone(), cfg, &mut resolver);\n-        let ret = syntax::ext::expand::expand_crate(&mut ecx, syntax_exts, krate);\n+        let err_count = ecx.parse_sess.span_diagnostic.err_count();\n+\n+        let krate = ecx.monotonic_expander().expand_crate(krate);\n+\n+        if ecx.parse_sess.span_diagnostic.err_count() - ecx.resolve_err_count > err_count {\n+            ecx.parse_sess.span_diagnostic.abort_if_errors();\n+        }\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n-        ret\n+        krate\n     });\n \n     krate.exported_macros = mem::replace(&mut resolver.exported_macros, Vec::new());"}, {"sha": "f051c8692491f0d4b51923033e4aa300432a2785", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -31,7 +31,7 @@\n #![feature(rustc_private)]\n #![feature(set_stdio)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n \n extern crate arena;\n extern crate flate;\n@@ -1110,7 +1110,7 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n                              errors::Level::Note);\n             }\n \n-            println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());\n+            writeln!(io::stderr(), \"{}\", str::from_utf8(&data.lock().unwrap()).unwrap()).unwrap();\n         }\n \n         exit_on_err();"}, {"sha": "af8ac81b4fbb1d916f979e7fdee76bf4bdb68c2f", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -21,7 +21,7 @@\n #![allow(unused_attributes)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(range_contains)]\n #![feature(libc)]\n #![feature(unicode)]"}, {"sha": "28db39d667c4c864012fc34c8537b4b8af05bc53", "filename": "src/librustc_incremental/calculate_svh/hasher.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fhasher.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::hash::Hasher;\n+use std::collections::hash_map::DefaultHasher;\n+\n+#[derive(Debug)]\n+pub struct IchHasher {\n+    // FIXME: this should use SHA1, not DefaultHasher. DefaultHasher is not\n+    // built to avoid collisions.\n+    state: DefaultHasher,\n+    bytes_hashed: u64,\n+}\n+\n+impl IchHasher {\n+    pub fn new() -> IchHasher {\n+        IchHasher {\n+            state: DefaultHasher::new(),\n+            bytes_hashed: 0\n+        }\n+    }\n+\n+    pub fn bytes_hashed(&self) -> u64 {\n+        self.bytes_hashed\n+    }\n+}\n+\n+impl Hasher for IchHasher {\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.state.finish()\n+    }\n+\n+    #[inline]\n+    fn write(&mut self, bytes: &[u8]) {\n+        self.state.write(bytes);\n+        self.bytes_hashed += bytes.len() as u64;\n+    }\n+}"}, {"sha": "12627e02debd0d723427d028e1cad35a042a8603", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -30,7 +30,6 @@\n use syntax::ast;\n use std::cell::RefCell;\n use std::hash::{Hash, Hasher};\n-use std::collections::hash_map::DefaultHasher;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n@@ -43,10 +42,12 @@ use rustc::session::config::DebugInfoLevel::NoDebugInfo;\n use self::def_path_hash::DefPathHashes;\n use self::svh_visitor::StrictVersionHashVisitor;\n use self::caching_codemap_view::CachingCodemapView;\n+use self::hasher::IchHasher;\n \n mod def_path_hash;\n mod svh_visitor;\n mod caching_codemap_view;\n+mod hasher;\n \n pub struct IncrementalHashesMap {\n     hashes: FnvHashMap<DepNode<DefId>, u64>,\n@@ -74,6 +75,10 @@ impl IncrementalHashesMap {\n     pub fn iter<'a>(&'a self) -> ::std::collections::hash_map::Iter<'a, DepNode<DefId>, u64> {\n         self.hashes.iter()\n     }\n+\n+    pub fn len(&self) -> usize {\n+        self.hashes.len()\n+    }\n }\n \n impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n@@ -102,6 +107,9 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                  |v| visit::walk_crate(v, krate));\n         krate.visit_all_items(&mut visitor);\n     });\n+\n+    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n+\n     record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n     visitor.hashes\n }\n@@ -127,9 +135,7 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n     {\n         assert!(def_id.is_local());\n         debug!(\"HashItemsVisitor::calculate(def_id={:?})\", def_id);\n-        // FIXME: this should use SHA1, not DefaultHasher. DefaultHasher is not\n-        // built to avoid collisions.\n-        let mut state = DefaultHasher::new();\n+        let mut state = IchHasher::new();\n         walk_op(&mut StrictVersionHashVisitor::new(&mut state,\n                                                    self.tcx,\n                                                    &mut self.def_path_hashes,\n@@ -138,12 +144,16 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n         let item_hash = state.finish();\n         self.hashes.insert(DepNode::Hir(def_id), item_hash);\n         debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, item_hash);\n+\n+        let bytes_hashed = self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n+                           state.bytes_hashed();\n+        self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n     }\n \n     fn compute_crate_hash(&mut self) {\n         let krate = self.tcx.map.krate();\n \n-        let mut crate_state = DefaultHasher::new();\n+        let mut crate_state = IchHasher::new();\n \n         let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n         \"crate_disambiguator\".hash(&mut crate_state);"}, {"sha": "584e5598b9f9ffec78ecb6e9f9f4233dcc14c119", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -31,10 +31,10 @@ use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv;\n use std::hash::Hash;\n-use std::collections::hash_map::DefaultHasher;\n \n use super::def_path_hash::DefPathHashes;\n use super::caching_codemap_view::CachingCodemapView;\n+use super::hasher::IchHasher;\n \n const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n     \"cfg\",\n@@ -48,15 +48,15 @@ const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n \n pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n     pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n-    pub st: &'a mut DefaultHasher,\n+    pub st: &'a mut IchHasher,\n     // collect a deterministic hash of def-ids that we have seen\n     def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n     hash_spans: bool,\n     codemap: &'a mut CachingCodemapView<'tcx>,\n }\n \n impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    pub fn new(st: &'a mut DefaultHasher,\n+    pub fn new(st: &'a mut IchHasher,\n                tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n                def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n                codemap: &'a mut CachingCodemapView<'tcx>,"}, {"sha": "67104e912f90ecc9a0a7ecfa9739b5eb1c584976", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -20,7 +20,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(dotdot_in_tuple_patterns)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]"}, {"sha": "acb92bec7c7971bd7ab305148ad6329c428156fe", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 95, "deletions": 67, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -24,19 +24,21 @@ use rustc::hir::intravisit::FnKind;\n pub enum MethodLateContext {\n     TraitDefaultImpl,\n     TraitImpl,\n-    PlainImpl\n+    PlainImpl,\n }\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     let def_id = cx.tcx.map.local_def_id(id);\n     match cx.tcx.impl_or_trait_items.borrow().get(&def_id) {\n         None => span_bug!(span, \"missing method descriptor?!\"),\n-        Some(item) => match item.container() {\n-            ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n-            ty::ImplContainer(cid) => {\n-                match cx.tcx.impl_trait_ref(cid) {\n-                    Some(_) => MethodLateContext::TraitImpl,\n-                    None => MethodLateContext::PlainImpl\n+        Some(item) => {\n+            match item.container() {\n+                ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n+                ty::ImplContainer(cid) => {\n+                    match cx.tcx.impl_trait_ref(cid) {\n+                        Some(_) => MethodLateContext::TraitImpl,\n+                        None => MethodLateContext::PlainImpl,\n+                    }\n                 }\n             }\n         }\n@@ -63,29 +65,35 @@ impl NonCamelCaseTypes {\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n-            !name.is_empty() &&\n-                !name.chars().next().unwrap().is_lowercase() &&\n-                !name.contains('_')\n+            !name.is_empty() && !name.chars().next().unwrap().is_lowercase() && !name.contains('_')\n         }\n \n         fn to_camel_case(s: &str) -> String {\n-            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-                if i == 0 {\n-                    c.to_uppercase().collect::<String>()\n-                } else {\n-                    c.to_lowercase().collect()\n-                }\n-            )).collect::<Vec<_>>().concat()\n+            s.split('_')\n+                .flat_map(|word| {\n+                    word.chars().enumerate().map(|(i, c)| if i == 0 {\n+                        c.to_uppercase().collect::<String>()\n+                    } else {\n+                        c.to_lowercase().collect()\n+                    })\n+                })\n+                .collect::<Vec<_>>()\n+                .concat()\n         }\n \n         let s = name.as_str();\n \n         if !is_camel_case(name) {\n             let c = to_camel_case(&s);\n             let m = if c.is_empty() {\n-                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n+                format!(\"{} `{}` should have a camel case name such as `CamelCase`\",\n+                        sort,\n+                        s)\n             } else {\n-                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n+                format!(\"{} `{}` should have a camel case name such as `{}`\",\n+                        sort,\n+                        s,\n+                        c)\n             };\n             cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n         }\n@@ -100,23 +108,25 @@ impl LintPass for NonCamelCaseTypes {\n \n impl LateLintPass for NonCamelCaseTypes {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        let extern_repr_count = it.attrs.iter().filter(|attr| {\n-            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n-                .any(|r| r == &attr::ReprExtern)\n-        }).count();\n+        let extern_repr_count = it.attrs\n+            .iter()\n+            .filter(|attr| {\n+                attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr)\n+                    .iter()\n+                    .any(|r| r == &attr::ReprExtern)\n+            })\n+            .count();\n         let has_extern_repr = extern_repr_count > 0;\n \n         if has_extern_repr {\n             return;\n         }\n \n         match it.node {\n-            hir::ItemTy(..) | hir::ItemStruct(..) | hir::ItemUnion(..) => {\n-                self.check_case(cx, \"type\", it.name, it.span)\n-            }\n-            hir::ItemTrait(..) => {\n-                self.check_case(cx, \"trait\", it.name, it.span)\n-            }\n+            hir::ItemTy(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) => self.check_case(cx, \"type\", it.name, it.span),\n+            hir::ItemTrait(..) => self.check_case(cx, \"trait\", it.name, it.span),\n             hir::ItemEnum(ref enum_definition, _) => {\n                 if has_extern_repr {\n                     return;\n@@ -126,7 +136,7 @@ impl LateLintPass for NonCamelCaseTypes {\n                     self.check_case(cx, \"variant\", variant.node.name, variant.span);\n                 }\n             }\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -165,9 +175,7 @@ impl NonSnakeCase {\n                 continue;\n             }\n             for ch in s.chars() {\n-                if !buf.is_empty() && buf != \"'\"\n-                                   && ch.is_uppercase()\n-                                   && !last_upper {\n+                if !buf.is_empty() && buf != \"'\" && ch.is_uppercase() && !last_upper {\n                     words.push(buf);\n                     buf = String::new();\n                 }\n@@ -205,10 +213,11 @@ impl NonSnakeCase {\n             let sc = NonSnakeCase::to_snake_case(name);\n             let msg = if sc != name {\n                 format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, name, sc)\n+                        sort,\n+                        name,\n+                        sc)\n             } else {\n-                format!(\"{} `{}` should have a snake case name\",\n-                        sort, name)\n+                format!(\"{} `{}` should have a snake case name\", sort, name)\n             };\n             match span {\n                 Some(span) => cx.span_lint(NON_SNAKE_CASE, span, &msg),\n@@ -226,31 +235,39 @@ impl LintPass for NonSnakeCase {\n \n impl LateLintPass for NonSnakeCase {\n     fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n-        let attr_crate_name = cr.attrs.iter().find(|at| at.check_name(\"crate_name\"))\n-                                      .and_then(|at| at.value_str().map(|s| (at, s)));\n+        let attr_crate_name = cr.attrs\n+            .iter()\n+            .find(|at| at.check_name(\"crate_name\"))\n+            .and_then(|at| at.value_str().map(|s| (at, s)));\n         if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n             self.check_snake_case(cx, \"crate\", name, None);\n         } else if let Some((attr, ref name)) = attr_crate_name {\n             self.check_snake_case(cx, \"crate\", name, Some(attr.span));\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &LateContext,\n-                fk: FnKind, _: &hir::FnDecl,\n-                _: &hir::Block, span: Span, id: ast::NodeId) {\n+    fn check_fn(&mut self,\n+                cx: &LateContext,\n+                fk: FnKind,\n+                _: &hir::FnDecl,\n+                _: &hir::Block,\n+                span: Span,\n+                id: ast::NodeId) {\n         match fk {\n-            FnKind::Method(name, ..) => match method_context(cx, id, span) {\n-                MethodLateContext::PlainImpl => {\n-                    self.check_snake_case(cx, \"method\", &name.as_str(), Some(span))\n-                },\n-                MethodLateContext::TraitDefaultImpl => {\n-                    self.check_snake_case(cx, \"trait method\", &name.as_str(), Some(span))\n-                },\n-                _ => (),\n-            },\n+            FnKind::Method(name, ..) => {\n+                match method_context(cx, id, span) {\n+                    MethodLateContext::PlainImpl => {\n+                        self.check_snake_case(cx, \"method\", &name.as_str(), Some(span))\n+                    }\n+                    MethodLateContext::TraitDefaultImpl => {\n+                        self.check_snake_case(cx, \"trait method\", &name.as_str(), Some(span))\n+                    }\n+                    _ => (),\n+                }\n+            }\n             FnKind::ItemFn(name, ..) => {\n                 self.check_snake_case(cx, \"function\", &name.as_str(), Some(span))\n-            },\n+            }\n             FnKind::Closure(_) => (),\n         }\n     }\n@@ -263,13 +280,17 @@ impl LateLintPass for NonSnakeCase {\n \n     fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(_, None) = trait_item.node {\n-            self.check_snake_case(cx, \"trait method\", &trait_item.name.as_str(),\n+            self.check_snake_case(cx,\n+                                  \"trait method\",\n+                                  &trait_item.name.as_str(),\n                                   Some(trait_item.span));\n         }\n     }\n \n     fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n-        self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n+        self.check_snake_case(cx,\n+                              \"lifetime\",\n+                              &t.lifetime.name.as_str(),\n                               Some(t.lifetime.span));\n     }\n \n@@ -282,8 +303,12 @@ impl LateLintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::VariantData,\n-                        _: ast::Name, _: &hir::Generics, _: ast::NodeId) {\n+    fn check_struct_def(&mut self,\n+                        cx: &LateContext,\n+                        s: &hir::VariantData,\n+                        _: ast::Name,\n+                        _: &hir::Generics,\n+                        _: ast::NodeId) {\n         for sf in s.fields() {\n             self.check_snake_case(cx, \"structure field\", &sf.name.as_str(), Some(sf.span));\n         }\n@@ -306,13 +331,16 @@ impl NonUpperCaseGlobals {\n         if s.chars().any(|c| c.is_lowercase()) {\n             let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n             if uc != &s[..] {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name such as `{}`\",\n-                             sort, s, uc));\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS,\n+                             span,\n+                             &format!(\"{} `{}` should have an upper case name such as `{}`\",\n+                                      sort,\n+                                      s,\n+                                      uc));\n             } else {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name\",\n-                             sort, s));\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS,\n+                             span,\n+                             &format!(\"{} `{}` should have an upper case name\", sort, s));\n             }\n         }\n     }\n@@ -341,8 +369,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n     fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n         match ti.node {\n             hir::ConstTraitItem(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ti.name, ti.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ti.name, ti.span);\n             }\n             _ => {}\n         }\n@@ -351,8 +378,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n     fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Const(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ii.name, ii.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ii.name, ii.span);\n             }\n             _ => {}\n         }\n@@ -363,8 +389,10 @@ impl LateLintPass for NonUpperCaseGlobals {\n         if let PatKind::Path(None, ref path) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n                 if let Def::Const(..) = cx.tcx.expect_def(p.id) {\n-                    NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                          path.segments[0].name, path.span);\n+                    NonUpperCaseGlobals::check_upper_case(cx,\n+                                                          \"constant in pattern\",\n+                                                          path.segments[0].name,\n+                                                          path.span);\n                 }\n             }\n         }"}, {"sha": "3428ec8d4c9602ffc2ac2a41a16778499da31832", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 176, "deletions": 126, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -37,15 +37,15 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment;\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n-use util::nodemap::{NodeSet};\n+use util::nodemap::NodeSet;\n use lint::{Level, LateContext, LintContext, LintArray, Lint};\n use lint::{LintPass, LateLintPass};\n \n use std::collections::HashSet;\n \n-use syntax::{ast};\n+use syntax::ast;\n use syntax::attr;\n-use syntax_pos::{Span};\n+use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::FnKind;\n@@ -75,7 +75,8 @@ impl LateLintPass for WhileTrue {\n         if let hir::ExprWhile(ref cond, ..) = e.node {\n             if let hir::ExprLit(ref lit) = cond.node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n-                    cx.span_lint(WHILE_TRUE, e.span,\n+                    cx.span_lint(WHILE_TRUE,\n+                                 e.span,\n                                  \"denote infinite loops with loop { ... }\");\n                 }\n             }\n@@ -93,8 +94,7 @@ declare_lint! {\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'a, 'tcx>,\n-                                 span: Span, ty: Ty<'tcx>) {\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'a, 'tcx>, span: Span, ty: Ty<'tcx>) {\n         for leaf_ty in ty.walk() {\n             if let ty::TyBox(_) = leaf_ty.sty {\n                 let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n@@ -117,22 +117,21 @@ impl LateLintPass for BoxPointers {\n             hir::ItemTy(..) |\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n-            hir::ItemUnion(..) =>\n-                self.check_heap_type(cx, it.span,\n-                                     cx.tcx.node_id_to_type(it.id)),\n-            _ => ()\n+            hir::ItemUnion(..) => self.check_heap_type(cx, it.span, cx.tcx.node_id_to_type(it.id)),\n+            _ => (),\n         }\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n             hir::ItemStruct(ref struct_def, _) |\n             hir::ItemUnion(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n-                    self.check_heap_type(cx, struct_field.span,\n+                    self.check_heap_type(cx,\n+                                         struct_field.span,\n                                          cx.tcx.node_id_to_type(struct_field.id));\n                 }\n             }\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -166,9 +165,11 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                 }\n                 if let PatKind::Binding(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node == fieldpat.node.name {\n-                        cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n+                        cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n+                                     fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node))\n+                                              be removed\",\n+                                              ident.node))\n                     }\n                 }\n             }\n@@ -203,27 +204,35 @@ impl LateLintPass for UnsafeCode {\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemTrait(hir::Unsafety::Unsafe, ..) =>\n-                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\"),\n+            hir::ItemTrait(hir::Unsafety::Unsafe, ..) => {\n+                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\")\n+            }\n \n-            hir::ItemImpl(hir::Unsafety::Unsafe, ..) =>\n-                cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\"),\n+            hir::ItemImpl(hir::Unsafety::Unsafe, ..) => {\n+                cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\")\n+            }\n \n             _ => return,\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &LateContext, fk: FnKind, _: &hir::FnDecl,\n-                _: &hir::Block, span: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self,\n+                cx: &LateContext,\n+                fk: FnKind,\n+                _: &hir::FnDecl,\n+                _: &hir::Block,\n+                span: Span,\n+                _: ast::NodeId) {\n         match fk {\n-            FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, ..) =>\n-                cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n+            FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, ..) => {\n+                cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\")\n+            }\n \n             FnKind::Method(_, sig, ..) => {\n                 if sig.unsafety == hir::Unsafety::Unsafe {\n                     cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n                 }\n-            },\n+            }\n \n             _ => (),\n         }\n@@ -232,7 +241,8 @@ impl LateLintPass for UnsafeCode {\n     fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             if sig.unsafety == hir::Unsafety::Unsafe {\n-                cx.span_lint(UNSAFE_CODE, trait_item.span,\n+                cx.span_lint(UNSAFE_CODE,\n+                             trait_item.span,\n                              \"declaration of an `unsafe` method\")\n             }\n         }\n@@ -263,9 +273,9 @@ pub struct MissingDoc {\n impl MissingDoc {\n     pub fn new() -> MissingDoc {\n         MissingDoc {\n-            struct_def_stack: vec!(),\n+            struct_def_stack: vec![],\n             in_variant: false,\n-            doc_hidden_stack: vec!(false),\n+            doc_hidden_stack: vec![false],\n             private_traits: HashSet::new(),\n         }\n     }\n@@ -275,11 +285,11 @@ impl MissingDoc {\n     }\n \n     fn check_missing_docs_attrs(&self,\n-                               cx: &LateContext,\n-                               id: Option<ast::NodeId>,\n-                               attrs: &[ast::Attribute],\n-                               sp: Span,\n-                               desc: &'static str) {\n+                                cx: &LateContext,\n+                                id: Option<ast::NodeId>,\n+                                attrs: &[ast::Attribute],\n+                                sp: Span,\n+                                desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -302,7 +312,8 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n         if !has_doc {\n-            cx.span_lint(MISSING_DOCS, sp,\n+            cx.span_lint(MISSING_DOCS,\n+                         sp,\n                          &format!(\"missing documentation for {}\", desc));\n         }\n     }\n@@ -316,8 +327,10 @@ impl LintPass for MissingDoc {\n \n impl LateLintPass for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n-        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") && match attr.meta_item_list() {\n+        let doc_hidden = self.doc_hidden() ||\n+                         attrs.iter().any(|attr| {\n+            attr.check_name(\"doc\") &&\n+            match attr.meta_item_list() {\n                 None => false,\n                 Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n             }\n@@ -329,13 +342,21 @@ impl LateLintPass for MissingDoc {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_struct_def(&mut self, _: &LateContext, _: &hir::VariantData,\n-                        _: ast::Name, _: &hir::Generics, item_id: ast::NodeId) {\n+    fn check_struct_def(&mut self,\n+                        _: &LateContext,\n+                        _: &hir::VariantData,\n+                        _: ast::Name,\n+                        _: &hir::Generics,\n+                        item_id: ast::NodeId) {\n         self.struct_def_stack.push(item_id);\n     }\n \n-    fn check_struct_def_post(&mut self, _: &LateContext, _: &hir::VariantData,\n-                             _: ast::Name, _: &hir::Generics, item_id: ast::NodeId) {\n+    fn check_struct_def_post(&mut self,\n+                             _: &LateContext,\n+                             _: &hir::VariantData,\n+                             _: ast::Name,\n+                             _: &hir::Generics,\n+                             item_id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n         assert!(popped == item_id);\n     }\n@@ -358,47 +379,53 @@ impl LateLintPass for MissingDoc {\n                     for itm in items {\n                         self.private_traits.insert(itm.id);\n                     }\n-                    return\n+                    return;\n                 }\n                 \"a trait\"\n-            },\n+            }\n             hir::ItemTy(..) => \"a type alias\",\n             hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_items) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n                 if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n                     match cx.tcx.map.find(node_id) {\n-                        Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n-                            for itm in impl_items {\n-                                self.private_traits.insert(itm.id);\n+                        Some(hir_map::NodeItem(item)) => {\n+                            if item.vis == hir::Visibility::Inherited {\n+                                for itm in impl_items {\n+                                    self.private_traits.insert(itm.id);\n+                                }\n                             }\n-                        },\n-                        _ => { }\n+                        }\n+                        _ => {}\n                     }\n                 }\n-                return\n-            },\n+                return;\n+            }\n             hir::ItemConst(..) => \"a constant\",\n             hir::ItemStatic(..) => \"a static\",\n-            _ => return\n+            _ => return,\n         };\n \n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n-        if self.private_traits.contains(&trait_item.id) { return }\n+        if self.private_traits.contains(&trait_item.id) {\n+            return;\n+        }\n \n         let desc = match trait_item.node {\n             hir::ConstTraitItem(..) => \"an associated constant\",\n             hir::MethodTraitItem(..) => \"a trait method\",\n             hir::TypeTraitItem(..) => \"an associated type\",\n         };\n \n-        self.check_missing_docs_attrs(cx, Some(trait_item.id),\n+        self.check_missing_docs_attrs(cx,\n+                                      Some(trait_item.id),\n                                       &trait_item.attrs,\n-                                      trait_item.span, desc);\n+                                      trait_item.span,\n+                                      desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n@@ -412,26 +439,34 @@ impl LateLintPass for MissingDoc {\n             hir::ImplItemKind::Method(..) => \"a method\",\n             hir::ImplItemKind::Type(_) => \"an associated type\",\n         };\n-        self.check_missing_docs_attrs(cx, Some(impl_item.id),\n+        self.check_missing_docs_attrs(cx,\n+                                      Some(impl_item.id),\n                                       &impl_item.attrs,\n-                                      impl_item.span, desc);\n+                                      impl_item.span,\n+                                      desc);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n         if !sf.is_positional() {\n             if sf.vis == hir::Public || self.in_variant {\n-                let cur_struct_def = *self.struct_def_stack.last()\n+                let cur_struct_def = *self.struct_def_stack\n+                    .last()\n                     .expect(\"empty struct_def_stack\");\n-                self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              &sf.attrs, sf.span,\n+                self.check_missing_docs_attrs(cx,\n+                                              Some(cur_struct_def),\n+                                              &sf.attrs,\n+                                              sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.data.id()),\n-                                      &v.node.attrs, v.span, \"a variant\");\n+        self.check_missing_docs_attrs(cx,\n+                                      Some(v.node.data.id()),\n+                                      &v.node.attrs,\n+                                      v.span,\n+                                      \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n     }\n@@ -486,7 +521,9 @@ impl LateLintPass for MissingCopyImplementations {\n             }\n             _ => return,\n         };\n-        if def.has_dtor() { return; }\n+        if def.has_dtor() {\n+            return;\n+        }\n         let parameter_environment = cx.tcx.empty_parameter_environment();\n         // FIXME (@jroesch) should probably inver this so that the parameter env still impls this\n         // method\n@@ -514,9 +551,7 @@ pub struct MissingDebugImplementations {\n \n impl MissingDebugImplementations {\n     pub fn new() -> MissingDebugImplementations {\n-        MissingDebugImplementations {\n-            impling_types: None,\n-        }\n+        MissingDebugImplementations { impling_types: None }\n     }\n }\n \n@@ -533,7 +568,9 @@ impl LateLintPass for MissingDebugImplementations {\n         }\n \n         match item.node {\n-            hir::ItemStruct(..) | hir::ItemUnion(..) | hir::ItemEnum(..) => {},\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) |\n+            hir::ItemEnum(..) => {}\n             _ => return,\n         }\n \n@@ -585,12 +622,13 @@ pub struct Deprecated {\n \n impl Deprecated {\n     pub fn new() -> Deprecated {\n-        Deprecated {\n-            current_item: ast::CRATE_NODE_ID,\n-        }\n+        Deprecated { current_item: ast::CRATE_NODE_ID }\n     }\n \n-    fn lint(&self, cx: &LateContext, _id: DefId, span: Span,\n+    fn lint(&self,\n+            cx: &LateContext,\n+            _id: DefId,\n+            span: Span,\n             stability: &Option<&attr::Stability>,\n             deprecation: &Option<stability::DeprecationEntry>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n@@ -641,37 +679,41 @@ impl LintPass for Deprecated {\n impl LateLintPass for Deprecated {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         self.push_item(item.id);\n-        stability::check_item(cx.tcx, item, false,\n-                              &mut |id, sp, stab, depr|\n-                                self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_item(cx.tcx,\n+                              item,\n+                              false,\n+                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_item_post(&mut self, cx: &LateContext, item: &hir::Item) {\n         self.item_post(cx, item.id);\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        stability::check_expr(cx.tcx, e,\n-                              &mut |id, sp, stab, depr|\n-                                self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_expr(cx.tcx,\n+                              e,\n+                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_path(&mut self, cx: &LateContext, path: &hir::Path, id: ast::NodeId) {\n-        stability::check_path(cx.tcx, path, id,\n-                              &mut |id, sp, stab, depr|\n-                                self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_path(cx.tcx,\n+                              path,\n+                              id,\n+                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_path_list_item(&mut self, cx: &LateContext, item: &hir::PathListItem) {\n-        stability::check_path_list_item(cx.tcx, item,\n-                                         &mut |id, sp, stab, depr|\n-                                           self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_path_list_item(cx.tcx,\n+                                        item,\n+                                        &mut |id, sp, stab, depr| {\n+                                            self.lint(cx, id, sp, &stab, &depr)\n+                                        });\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n-        stability::check_pat(cx.tcx, pat,\n-                             &mut |id, sp, stab, depr|\n-                                self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_pat(cx.tcx,\n+                             pat,\n+                             &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_impl_item(&mut self, _: &LateContext, item: &hir::ImplItem) {\n@@ -716,15 +758,20 @@ impl LintPass for UnconditionalRecursion {\n }\n \n impl LateLintPass for UnconditionalRecursion {\n-    fn check_fn(&mut self, cx: &LateContext, fn_kind: FnKind, _: &hir::FnDecl,\n-                blk: &hir::Block, sp: Span, id: ast::NodeId) {\n+    fn check_fn(&mut self,\n+                cx: &LateContext,\n+                fn_kind: FnKind,\n+                _: &hir::FnDecl,\n+                blk: &hir::Block,\n+                sp: Span,\n+                id: ast::NodeId) {\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {\n                 cx.tcx.impl_or_trait_item(cx.tcx.map.local_def_id(id)).as_opt_method()\n             }\n             // closures can't recur, so they don't matter.\n-            FnKind::Closure(_) => return\n+            FnKind::Closure(_) => return,\n         };\n \n         // Walk through this function (say `f`) looking to see if\n@@ -779,10 +826,8 @@ impl LateLintPass for UnconditionalRecursion {\n             // is this a recursive call?\n             let self_recursive = if node_id != ast::DUMMY_NODE_ID {\n                 match method {\n-                    Some(ref method) => {\n-                        expr_refers_to_this_method(cx.tcx, method, node_id)\n-                    }\n-                    None => expr_refers_to_this_fn(cx.tcx, id, node_id)\n+                    Some(ref method) => expr_refers_to_this_method(cx.tcx, method, node_id),\n+                    None => expr_refers_to_this_fn(cx.tcx, id, node_id),\n                 }\n             } else {\n                 false\n@@ -808,7 +853,8 @@ impl LateLintPass for UnconditionalRecursion {\n         // no break */ }`) shouldn't be linted unless it actually\n         // recurs.\n         if !reached_exit_without_self_call && !self_call_spans.is_empty() {\n-            let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION, sp,\n+            let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION,\n+                                             sp,\n                                              \"function cannot return without recurring\");\n \n             // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n@@ -829,23 +875,21 @@ impl LateLintPass for UnconditionalRecursion {\n         // Functions for identifying if the given Expr NodeId `id`\n         // represents a call to the function `fn_id`/method `method`.\n \n-        fn expr_refers_to_this_fn(tcx: TyCtxt,\n-                                  fn_id: ast::NodeId,\n-                                  id: ast::NodeId) -> bool {\n+        fn expr_refers_to_this_fn(tcx: TyCtxt, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    tcx.expect_def_or_none(callee.id).map_or(false, |def| {\n-                        def.def_id() == tcx.map.local_def_id(fn_id)\n-                    })\n+                    tcx.expect_def_or_none(callee.id)\n+                        .map_or(false, |def| def.def_id() == tcx.map.local_def_id(fn_id))\n                 }\n-                _ => false\n+                _ => false,\n             }\n         }\n \n         // Check if the expression `id` performs a call to `method`.\n         fn expr_refers_to_this_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 method: &ty::Method,\n-                                                id: ast::NodeId) -> bool {\n+                                                id: ast::NodeId)\n+                                                -> bool {\n             // Check for method calls and overloaded operators.\n             let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n@@ -859,9 +903,11 @@ impl LateLintPass for UnconditionalRecursion {\n             if let Some(adjustment::AdjustDerefRef(adj)) = opt_adj {\n                 for i in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tcx.tables.borrow().method_map\n-                                                        .get(&method_call)\n-                                                        .cloned() {\n+                    if let Some(m) = tcx.tables\n+                        .borrow()\n+                        .method_map\n+                        .get(&method_call)\n+                        .cloned() {\n                         if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n@@ -877,13 +923,16 @@ impl LateLintPass for UnconditionalRecursion {\n                     match tcx.expect_def_or_none(callee.id) {\n                         Some(Def::Method(def_id)) => {\n                             let item_substs = tcx.node_id_item_substs(callee.id);\n-                            method_call_refers_to_method(\n-                                tcx, method, def_id, &item_substs.substs, id)\n+                            method_call_refers_to_method(tcx,\n+                                                         method,\n+                                                         def_id,\n+                                                         &item_substs.substs,\n+                                                         id)\n                         }\n-                        _ => false\n+                        _ => false,\n                     }\n                 }\n-                _ => false\n+                _ => false,\n             }\n         }\n \n@@ -893,15 +942,14 @@ impl LateLintPass for UnconditionalRecursion {\n                                                   method: &ty::Method,\n                                                   callee_id: DefId,\n                                                   callee_substs: &Substs<'tcx>,\n-                                                  expr_id: ast::NodeId) -> bool {\n+                                                  expr_id: ast::NodeId)\n+                                                  -> bool {\n             let callee_item = tcx.impl_or_trait_item(callee_id);\n \n             match callee_item.container() {\n                 // This is an inherent method, so the `def_id` refers\n                 // directly to the method definition.\n-                ty::ImplContainer(_) => {\n-                    callee_id == method.def_id\n-                }\n+                ty::ImplContainer(_) => callee_id == method.def_id,\n \n                 // A trait method, from any number of possible sources.\n                 // Attempt to select a concrete impl before checking.\n@@ -939,13 +987,12 @@ impl LateLintPass for UnconditionalRecursion {\n                                 let container = ty::ImplContainer(vtable_impl.impl_def_id);\n                                 // It matches if it comes from the same impl,\n                                 // and has the same method name.\n-                                container == method.container\n-                                    && callee_item.name() == method.name\n+                                container == method.container && callee_item.name() == method.name\n                             }\n \n                             // There's no way to know if this call is\n                             // recursive, so we assume it's not.\n-                            _ => false\n+                            _ => false,\n                         }\n                     })\n                 }\n@@ -992,7 +1039,8 @@ impl LateLintPass for PluginAsLibrary {\n         };\n \n         if prfn.is_some() {\n-            cx.span_lint(PLUGIN_AS_LIBRARY, it.span,\n+            cx.span_lint(PLUGIN_AS_LIBRARY,\n+                         it.span,\n                          \"compiler plugin used as an ordinary library\");\n         }\n     }\n@@ -1050,15 +1098,15 @@ impl LateLintPass for InvalidNoMangleItems {\n                                      \"generic functions must be mangled\");\n                     }\n                 }\n-            },\n+            }\n             hir::ItemStatic(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n-                       !cx.access_levels.is_reachable(it.id) {\n+                   !cx.access_levels.is_reachable(it.id) {\n                     let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n                                       it.name);\n                     cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, &msg);\n                 }\n-            },\n+            }\n             hir::ItemConst(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") {\n                     // Const items do not refer to a particular location in memory, and therefore\n@@ -1068,7 +1116,7 @@ impl LateLintPass for InvalidNoMangleItems {\n                     cx.span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n                 }\n             }\n-            _ => {},\n+            _ => {}\n         }\n     }\n }\n@@ -1096,19 +1144,21 @@ impl LateLintPass for MutableTransmutes {\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr) {\n             Some((&ty::TyRef(_, from_mt), &ty::TyRef(_, to_mt))) => {\n-                if to_mt.mutbl == hir::Mutability::MutMutable\n-                    && from_mt.mutbl == hir::Mutability::MutImmutable {\n+                if to_mt.mutbl == hir::Mutability::MutMutable &&\n+                   from_mt.mutbl == hir::Mutability::MutImmutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n                 }\n             }\n-            _ => ()\n+            _ => (),\n         }\n \n-        fn get_transmute_from_to<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr)\n-            -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n+        fn get_transmute_from_to<'a, 'tcx>\n+            (cx: &LateContext<'a, 'tcx>,\n+             expr: &hir::Expr)\n+             -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             match expr.node {\n                 hir::ExprPath(..) => (),\n-                _ => return None\n+                _ => return None,\n             }\n             if let Def::Fn(did) = cx.tcx.expect_def(expr.id) {\n                 if !def_id_is_transmute(cx, did) {\n@@ -1120,8 +1170,8 @@ impl LateLintPass for MutableTransmutes {\n                         let from = bare_fn.sig.0.inputs[0];\n                         let to = bare_fn.sig.0.output;\n                         return Some((&from.sty, &to.sty));\n-                    },\n-                    _ => ()\n+                    }\n+                    _ => (),\n                 }\n             }\n             None\n@@ -1130,7 +1180,7 @@ impl LateLintPass for MutableTransmutes {\n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n             match cx.tcx.lookup_item_type(def_id).ty.sty {\n                 ty::TyFnDef(.., ref bfty) if bfty.abi == RustIntrinsic => (),\n-                _ => return false\n+                _ => return false,\n             }\n             cx.tcx.item_name(def_id).as_str() == \"transmute\"\n         }"}, {"sha": "74483b89cea22f1671b75cc8840dbe6cd79cba55", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -48,10 +48,10 @@ extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n-pub use rustc::lint as lint;\n-pub use rustc::middle as middle;\n-pub use rustc::session as session;\n-pub use rustc::util as util;\n+pub use rustc::lint;\n+pub use rustc::middle;\n+pub use rustc::session;\n+pub use rustc::util;\n \n use session::Session;\n use lint::LintId;\n@@ -139,13 +139,24 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                           MissingDebugImplementations,\n                           );\n \n-    add_lint_group!(sess, \"bad_style\",\n-                    NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPER_CASE_GLOBALS);\n-\n-    add_lint_group!(sess, \"unused\",\n-                    UNUSED_IMPORTS, UNUSED_VARIABLES, UNUSED_ASSIGNMENTS, DEAD_CODE,\n-                    UNUSED_MUT, UNREACHABLE_CODE, UNUSED_MUST_USE,\n-                    UNUSED_UNSAFE, PATH_STATEMENTS, UNUSED_ATTRIBUTES);\n+    add_lint_group!(sess,\n+                    \"bad_style\",\n+                    NON_CAMEL_CASE_TYPES,\n+                    NON_SNAKE_CASE,\n+                    NON_UPPER_CASE_GLOBALS);\n+\n+    add_lint_group!(sess,\n+                    \"unused\",\n+                    UNUSED_IMPORTS,\n+                    UNUSED_VARIABLES,\n+                    UNUSED_ASSIGNMENTS,\n+                    DEAD_CODE,\n+                    UNUSED_MUT,\n+                    UNREACHABLE_CODE,\n+                    UNUSED_MUST_USE,\n+                    UNUSED_UNSAFE,\n+                    PATH_STATEMENTS,\n+                    UNUSED_ATTRIBUTES);\n \n     // Guidelines for creating a future incompatibility lint:\n     //\n@@ -155,7 +166,8 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     //   and include the full URL.\n     // - Later, change lint to error\n     // - Eventually, remove lint\n-    store.register_future_incompatible(sess, vec![\n+    store.register_future_incompatible(sess,\n+                                       vec![\n         FutureIncompatibleInfo {\n             id: LintId::of(PRIVATE_IN_PUBLIC),\n             reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n@@ -204,11 +216,13 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n \n     // Register renamed and removed lints\n     store.register_renamed(\"unknown_features\", \"unused_features\");\n-    store.register_removed(\"unsigned_negation\", \"replaced by negate_unsigned feature gate\");\n+    store.register_removed(\"unsigned_negation\",\n+                           \"replaced by negate_unsigned feature gate\");\n     store.register_removed(\"negate_unsigned\", \"cast a signed value instead\");\n     store.register_removed(\"raw_pointer_derive\", \"using derive with raw pointers is ok\");\n     // This was renamed to raw_pointer_derive, which was then removed,\n     // so it is also considered removed\n-    store.register_removed(\"raw_pointer_deriving\", \"using derive with raw pointers is ok\");\n+    store.register_removed(\"raw_pointer_deriving\",\n+                           \"using derive with raw pointers is ok\");\n     store.register_removed(\"drop_with_repr_extern\", \"drop flags have been removed\");\n }"}, {"sha": "9464bf30b693fd86dcedad02e5157c94a123fbb4", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 246, "deletions": 228, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -18,7 +18,7 @@ use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use util::nodemap::{FnvHashSet};\n+use util::nodemap::FnvHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n \n@@ -91,15 +91,15 @@ pub struct TypeLimits {\n \n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n-        TypeLimits {\n-            negated_expr_id: ast::DUMMY_NODE_ID,\n-        }\n+        TypeLimits { negated_expr_id: ast::DUMMY_NODE_ID }\n     }\n }\n \n impl LintPass for TypeLimits {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_COMPARISONS, OVERFLOWING_LITERALS, EXCEEDING_BITSHIFTS)\n+        lint_array!(UNUSED_COMPARISONS,\n+                    OVERFLOWING_LITERALS,\n+                    EXCEEDING_BITSHIFTS)\n     }\n }\n \n@@ -111,13 +111,13 @@ impl LateLintPass for TypeLimits {\n                     match lit.node {\n                         ast::LitKind::Int(_, ast::LitIntType::Unsigned(_)) => {\n                             forbid_unsigned_negation(cx, e.span);\n-                        },\n+                        }\n                         ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n                             if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n                                 forbid_unsigned_negation(cx, e.span);\n                             }\n-                        },\n-                        _ => ()\n+                        }\n+                        _ => (),\n                     }\n                 } else {\n                     let t = cx.tcx.node_id_to_type(expr.id);\n@@ -129,41 +129,47 @@ impl LateLintPass for TypeLimits {\n                 if self.negated_expr_id != e.id {\n                     self.negated_expr_id = expr.id;\n                 }\n-            },\n+            }\n             hir::ExprBinary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx.tcx, binop, &l, &r) {\n-                    cx.span_lint(UNUSED_COMPARISONS, e.span,\n+                    cx.span_lint(UNUSED_COMPARISONS,\n+                                 e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n \n                 if binop.node.is_shift() {\n                     let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n-                        _ => None\n+                        _ => None,\n                     };\n \n                     if let Some(bits) = opt_ty_bits {\n                         let exceeding = if let hir::ExprLit(ref lit) = r.node {\n-                            if let ast::LitKind::Int(shift, _) = lit.node { shift >= bits }\n-                            else { false }\n+                            if let ast::LitKind::Int(shift, _) = lit.node {\n+                                shift >= bits\n+                            } else {\n+                                false\n+                            }\n                         } else {\n                             match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked, None) {\n                                 Ok(ConstVal::Integral(i)) => {\n-                                    i.is_negative() || i.to_u64()\n-                                                        .map(|i| i >= bits)\n-                                                        .unwrap_or(true)\n-                                },\n-                                _ => { false }\n+                                    i.is_negative() ||\n+                                    i.to_u64()\n+                                        .map(|i| i >= bits)\n+                                        .unwrap_or(true)\n+                                }\n+                                _ => false,\n                             }\n                         };\n                         if exceeding {\n-                            cx.span_lint(EXCEEDING_BITSHIFTS, e.span,\n+                            cx.span_lint(EXCEEDING_BITSHIFTS,\n+                                         e.span,\n                                          \"bitshift exceeds the type's number of bits\");\n                         }\n                     };\n                 }\n-            },\n+            }\n             hir::ExprLit(ref lit) => {\n                 match cx.tcx.node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n@@ -182,14 +188,15 @@ impl LateLintPass for TypeLimits {\n                                 // avoiding use of -min to prevent overflow/panic\n                                 if (negative && v > max as u64 + 1) ||\n                                    (!negative && v > max as u64) {\n-                                    cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                                    cx.span_lint(OVERFLOWING_LITERALS,\n+                                                 e.span,\n                                                  &format!(\"literal out of range for {:?}\", t));\n                                     return;\n                                 }\n                             }\n-                            _ => bug!()\n+                            _ => bug!(),\n                         };\n-                    },\n+                    }\n                     ty::TyUint(t) => {\n                         let uint_type = if let ast::UintTy::Us = t {\n                             cx.sess().target.uint_type\n@@ -201,84 +208,86 @@ impl LateLintPass for TypeLimits {\n                             // _v is u8, within range by definition\n                             ast::LitKind::Byte(_v) => return,\n                             ast::LitKind::Int(v, _) => v,\n-                            _ => bug!()\n+                            _ => bug!(),\n                         };\n                         if lit_val < min || lit_val > max {\n-                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                            cx.span_lint(OVERFLOWING_LITERALS,\n+                                         e.span,\n                                          &format!(\"literal out of range for {:?}\", t));\n                         }\n-                    },\n+                    }\n                     ty::TyFloat(t) => {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n                             ast::LitKind::Float(ref v, _) |\n                             ast::LitKind::FloatUnsuffixed(ref v) => {\n                                 match v.parse() {\n                                     Ok(f) => f,\n-                                    Err(_) => return\n+                                    Err(_) => return,\n                                 }\n                             }\n-                            _ => bug!()\n+                            _ => bug!(),\n                         };\n                         if lit_val < min || lit_val > max {\n-                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                            cx.span_lint(OVERFLOWING_LITERALS,\n+                                         e.span,\n                                          &format!(\"literal out of range for {:?}\", t));\n                         }\n-                    },\n-                    _ => ()\n+                    }\n+                    _ => (),\n                 };\n-            },\n-            _ => ()\n+            }\n+            _ => (),\n         };\n \n-        fn is_valid<T:cmp::PartialOrd>(binop: hir::BinOp, v: T,\n-                                min: T, max: T) -> bool {\n+        fn is_valid<T: cmp::PartialOrd>(binop: hir::BinOp, v: T, min: T, max: T) -> bool {\n             match binop.node {\n-                hir::BiLt => v >  min && v <= max,\n-                hir::BiLe => v >= min && v <  max,\n-                hir::BiGt => v >= min && v <  max,\n-                hir::BiGe => v >  min && v <= max,\n+                hir::BiLt => v > min && v <= max,\n+                hir::BiLe => v >= min && v < max,\n+                hir::BiGt => v >= min && v < max,\n+                hir::BiGe => v > min && v <= max,\n                 hir::BiEq | hir::BiNe => v >= min && v <= max,\n-                _ => bug!()\n+                _ => bug!(),\n             }\n         }\n \n         fn rev_binop(binop: hir::BinOp) -> hir::BinOp {\n-            codemap::respan(binop.span, match binop.node {\n-                hir::BiLt => hir::BiGt,\n-                hir::BiLe => hir::BiGe,\n-                hir::BiGt => hir::BiLt,\n-                hir::BiGe => hir::BiLe,\n-                _ => return binop\n-            })\n+            codemap::respan(binop.span,\n+                            match binop.node {\n+                                hir::BiLt => hir::BiGt,\n+                                hir::BiLe => hir::BiGe,\n+                                hir::BiGt => hir::BiLt,\n+                                hir::BiGe => hir::BiLe,\n+                                _ => return binop,\n+                            })\n         }\n \n         // for isize & usize, be conservative with the warnings, so that the\n         // warnings are consistent between 32- and 64-bit platforms\n         fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n             match int_ty {\n-                ast::IntTy::Is => (i64::MIN,        i64::MAX),\n-                ast::IntTy::I8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n-                ast::IntTy::I16 =>   (i16::MIN as i64, i16::MAX as i64),\n-                ast::IntTy::I32 =>   (i32::MIN as i64, i32::MAX as i64),\n-                ast::IntTy::I64 =>   (i64::MIN,        i64::MAX)\n+                ast::IntTy::Is => (i64::MIN, i64::MAX),\n+                ast::IntTy::I8 => (i8::MIN as i64, i8::MAX as i64),\n+                ast::IntTy::I16 => (i16::MIN as i64, i16::MAX as i64),\n+                ast::IntTy::I32 => (i32::MIN as i64, i32::MAX as i64),\n+                ast::IntTy::I64 => (i64::MIN, i64::MAX),\n             }\n         }\n \n         fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                ast::UintTy::Us => (u64::MIN,         u64::MAX),\n-                ast::UintTy::U8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n-                ast::UintTy::U16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n-                ast::UintTy::U32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n-                ast::UintTy::U64 =>   (u64::MIN,         u64::MAX)\n+                ast::UintTy::Us => (u64::MIN, u64::MAX),\n+                ast::UintTy::U8 => (u8::MIN as u64, u8::MAX as u64),\n+                ast::UintTy::U16 => (u16::MIN as u64, u16::MAX as u64),\n+                ast::UintTy::U32 => (u32::MIN as u64, u32::MAX as u64),\n+                ast::UintTy::U64 => (u64::MIN, u64::MAX),\n             }\n         }\n \n         fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n             match float_ty {\n                 ast::FloatTy::F32 => (f32::MIN as f64, f32::MAX as f64),\n-                ast::FloatTy::F64 => (f64::MIN,        f64::MAX)\n+                ast::FloatTy::F64 => (f64::MIN, f64::MAX),\n             }\n         }\n \n@@ -305,60 +314,60 @@ impl LateLintPass for TypeLimits {\n         fn check_limits<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   binop: hir::BinOp,\n                                   l: &hir::Expr,\n-                                  r: &hir::Expr) -> bool {\n+                                  r: &hir::Expr)\n+                                  -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n                 (&hir::ExprLit(_), _) => (l, r, true),\n                 (_, &hir::ExprLit(_)) => (r, l, false),\n-                _ => return true\n+                _ => return true,\n             };\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n-            let norm_binop = if swap {\n-                rev_binop(binop)\n-            } else {\n-                binop\n-            };\n+            let norm_binop = if swap { rev_binop(binop) } else { binop };\n             match tcx.node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n-                        hir::ExprLit(ref li) => match li.node {\n-                            ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n-                            ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i64,\n-                            _ => return true\n-                        },\n-                        _ => bug!()\n+                        hir::ExprLit(ref li) => {\n+                            match li.node {\n+                                ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n+                                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i64,\n+                                _ => return true,\n+                            }\n+                        }\n+                        _ => bug!(),\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n                 ty::TyUint(uint_ty) => {\n                     let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                     let lit_val: u64 = match lit.node {\n-                        hir::ExprLit(ref li) => match li.node {\n-                            ast::LitKind::Int(v, _) => v,\n-                            _ => return true\n-                        },\n-                        _ => bug!()\n+                        hir::ExprLit(ref li) => {\n+                            match li.node {\n+                                ast::LitKind::Int(v, _) => v,\n+                                _ => return true,\n+                            }\n+                        }\n+                        _ => bug!(),\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n-                _ => true\n+                _ => true,\n             }\n         }\n \n         fn is_comparison(binop: hir::BinOp) -> bool {\n             match binop.node {\n-                hir::BiEq | hir::BiLt | hir::BiLe |\n-                hir::BiNe | hir::BiGe | hir::BiGt => true,\n-                _ => false\n+                hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => true,\n+                _ => false,\n             }\n         }\n \n         fn forbid_unsigned_negation(cx: &LateContext, span: Span) {\n             cx.sess()\n-              .struct_span_err_with_code(span, \"unary negation of unsigned integer\", \"E0519\")\n-              .span_help(span, \"use a cast or the `!` operator\")\n-              .emit();\n+                .struct_span_err_with_code(span, \"unary negation of unsigned integer\", \"E0519\")\n+                .span_help(span, \"use a cast or the `!` operator\")\n+                .emit();\n         }\n     }\n }\n@@ -370,7 +379,7 @@ declare_lint! {\n }\n \n struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n enum FfiResult {\n@@ -403,9 +412,13 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         if def.variants[data_idx].fields.len() == 1 {\n             match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n-                ty::TyFnPtr(_) => { return true; }\n-                ty::TyRef(..) => { return true; }\n-                _ => { }\n+                ty::TyFnPtr(_) => {\n+                    return true;\n+                }\n+                ty::TyRef(..) => {\n+                    return true;\n+                }\n+                _ => {}\n             }\n         }\n     }\n@@ -415,10 +428,7 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n-    fn check_type_for_ffi(&self,\n-                          cache: &mut FnvHashSet<Ty<'tcx>>,\n-                          ty: Ty<'tcx>)\n-                          -> FfiResult {\n+    fn check_type_for_ffi(&self, cache: &mut FnvHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult {\n         use self::FfiResult::*;\n         let cx = self.cx.tcx;\n \n@@ -431,121 +441,126 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.sty {\n-            ty::TyAdt(def, substs) => match def.adt_kind() {\n-                AdtKind::Struct => {\n-                    if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n-                        return FfiUnsafe(\n-                            \"found struct without foreign-function-safe \\\n-                            representation annotation in foreign module, \\\n-                            consider adding a #[repr(C)] attribute to \\\n-                            the type\");\n-                    }\n+            ty::TyAdt(def, substs) => {\n+                match def.adt_kind() {\n+                    AdtKind::Struct => {\n+                        if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                            return FfiUnsafe(\"found struct without foreign-function-safe \\\n+                                              representation annotation in foreign module, \\\n+                                              consider adding a #[repr(C)] attribute to the type\");\n+                        }\n \n-                    // We can't completely trust repr(C) markings; make sure the\n-                    // fields are actually safe.\n-                    if def.struct_variant().fields.is_empty() {\n-                        return FfiUnsafe(\n-                            \"found zero-size struct in foreign module, consider \\\n-                            adding a member to this struct\");\n-                    }\n+                        // We can't completely trust repr(C) markings; make sure the\n+                        // fields are actually safe.\n+                        if def.struct_variant().fields.is_empty() {\n+                            return FfiUnsafe(\"found zero-size struct in foreign module, consider \\\n+                                              adding a member to this struct\");\n+                        }\n \n-                    for field in &def.struct_variant().fields {\n-                        let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n-                        let r = self.check_type_for_ffi(cache, field_ty);\n-                        match r {\n-                            FfiSafe => {}\n-                            FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n-                            FfiUnsafe(s) => { return FfiBadStruct(def.did, s); }\n+                        for field in &def.struct_variant().fields {\n+                            let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n+                            let r = self.check_type_for_ffi(cache, field_ty);\n+                            match r {\n+                                FfiSafe => {}\n+                                FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n+                                    return r;\n+                                }\n+                                FfiUnsafe(s) => {\n+                                    return FfiBadStruct(def.did, s);\n+                                }\n+                            }\n                         }\n+                        FfiSafe\n                     }\n-                    FfiSafe\n-                }\n-                AdtKind::Union => {\n-                    if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n-                        return FfiUnsafe(\n-                            \"found union without foreign-function-safe \\\n-                            representation annotation in foreign module, \\\n-                            consider adding a #[repr(C)] attribute to \\\n-                            the type\");\n-                    }\n+                    AdtKind::Union => {\n+                        if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                            return FfiUnsafe(\"found union without foreign-function-safe \\\n+                                              representation annotation in foreign module, \\\n+                                              consider adding a #[repr(C)] attribute to the type\");\n+                        }\n \n-                    for field in &def.struct_variant().fields {\n-                        let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n-                        let r = self.check_type_for_ffi(cache, field_ty);\n-                        match r {\n-                            FfiSafe => {}\n-                            FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n-                            FfiUnsafe(s) => { return FfiBadUnion(def.did, s); }\n+                        for field in &def.struct_variant().fields {\n+                            let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n+                            let r = self.check_type_for_ffi(cache, field_ty);\n+                            match r {\n+                                FfiSafe => {}\n+                                FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n+                                    return r;\n+                                }\n+                                FfiUnsafe(s) => {\n+                                    return FfiBadUnion(def.did, s);\n+                                }\n+                            }\n                         }\n+                        FfiSafe\n                     }\n-                    FfiSafe\n-                }\n-                AdtKind::Enum => {\n-                    if def.variants.is_empty() {\n-                        // Empty enums are okay... although sort of useless.\n-                        return FfiSafe\n-                    }\n+                    AdtKind::Enum => {\n+                        if def.variants.is_empty() {\n+                            // Empty enums are okay... although sort of useless.\n+                            return FfiSafe;\n+                        }\n \n-                    // Check for a repr() attribute to specify the size of the\n-                    // discriminant.\n-                    let repr_hints = cx.lookup_repr_hints(def.did);\n-                    match &repr_hints[..] {\n-                        &[] => {\n-                            // Special-case types like `Option<extern fn()>`.\n-                            if !is_repr_nullable_ptr(cx, def, substs) {\n-                                return FfiUnsafe(\n-                                    \"found enum without foreign-function-safe \\\n-                                    representation annotation in foreign module, \\\n-                                    consider adding a #[repr(...)] attribute to \\\n-                                    the type\")\n+                        // Check for a repr() attribute to specify the size of the\n+                        // discriminant.\n+                        let repr_hints = cx.lookup_repr_hints(def.did);\n+                        match &repr_hints[..] {\n+                            &[] => {\n+                                // Special-case types like `Option<extern fn()>`.\n+                                if !is_repr_nullable_ptr(cx, def, substs) {\n+                                    return FfiUnsafe(\"found enum without foreign-function-safe \\\n+                                                      representation annotation in foreign \\\n+                                                      module, consider adding a #[repr(...)] \\\n+                                                      attribute to the type\");\n+                                }\n                             }\n-                        }\n-                        &[ref hint] => {\n-                            if !hint.is_ffi_safe() {\n+                            &[ref hint] => {\n+                                if !hint.is_ffi_safe() {\n+                                    // FIXME: This shouldn't be reachable: we should check\n+                                    // this earlier.\n+                                    return FfiUnsafe(\"enum has unexpected #[repr(...)] attribute\");\n+                                }\n+\n+                                // Enum with an explicitly sized discriminant; either\n+                                // a C-style enum or a discriminated union.\n+\n+                                // The layout of enum variants is implicitly repr(C).\n+                                // FIXME: Is that correct?\n+                            }\n+                            _ => {\n                                 // FIXME: This shouldn't be reachable: we should check\n                                 // this earlier.\n-                                return FfiUnsafe(\n-                                    \"enum has unexpected #[repr(...)] attribute\")\n+                                return FfiUnsafe(\"enum has too many #[repr(...)] attributes\");\n                             }\n-\n-                            // Enum with an explicitly sized discriminant; either\n-                            // a C-style enum or a discriminated union.\n-\n-                            // The layout of enum variants is implicitly repr(C).\n-                            // FIXME: Is that correct?\n                         }\n-                        _ => {\n-                            // FIXME: This shouldn't be reachable: we should check\n-                            // this earlier.\n-                            return FfiUnsafe(\n-                                \"enum has too many #[repr(...)] attributes\");\n-                        }\n-                    }\n \n-                    // Check the contained variants.\n-                    for variant in &def.variants {\n-                        for field in &variant.fields {\n-                            let arg = cx.normalize_associated_type(&field.ty(cx, substs));\n-                            let r = self.check_type_for_ffi(cache, arg);\n-                            match r {\n-                                FfiSafe => {}\n-                                FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n-                                FfiUnsafe(s) => { return FfiBadEnum(def.did, s); }\n+                        // Check the contained variants.\n+                        for variant in &def.variants {\n+                            for field in &variant.fields {\n+                                let arg = cx.normalize_associated_type(&field.ty(cx, substs));\n+                                let r = self.check_type_for_ffi(cache, arg);\n+                                match r {\n+                                    FfiSafe => {}\n+                                    FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n+                                        return r;\n+                                    }\n+                                    FfiUnsafe(s) => {\n+                                        return FfiBadEnum(def.did, s);\n+                                    }\n+                                }\n                             }\n                         }\n+                        FfiSafe\n                     }\n-                    FfiSafe\n                 }\n-            },\n+            }\n \n             ty::TyChar => {\n                 FfiUnsafe(\"found Rust type `char` in foreign module, while \\\n                            `u32` or `libc::wchar_t` should be used\")\n             }\n \n             // Primitive types with a stable representation.\n-            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) |\n-            ty::TyFloat(..) | ty::TyNever => FfiSafe,\n+            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) | ty::TyFloat(..) | ty::TyNever => FfiSafe,\n \n             ty::TyBox(..) => {\n                 FfiUnsafe(\"found Rust type Box<_> in foreign module, \\\n@@ -572,24 +587,17 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                            consider using a struct instead\")\n             }\n \n-            ty::TyRawPtr(ref m) | ty::TyRef(_, ref m) => {\n-                self.check_type_for_ffi(cache, m.ty)\n-            }\n+            ty::TyRawPtr(ref m) |\n+            ty::TyRef(_, ref m) => self.check_type_for_ffi(cache, m.ty),\n \n-            ty::TyArray(ty, _) => {\n-                self.check_type_for_ffi(cache, ty)\n-            }\n+            ty::TyArray(ty, _) => self.check_type_for_ffi(cache, ty),\n \n             ty::TyFnPtr(bare_fn) => {\n                 match bare_fn.abi {\n-                    Abi::Rust |\n-                    Abi::RustIntrinsic |\n-                    Abi::PlatformIntrinsic |\n-                    Abi::RustCall => {\n-                        return FfiUnsafe(\n-                            \"found function pointer with Rust calling \\\n-                             convention in foreign module; consider using an \\\n-                             `extern` function pointer\")\n+                    Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n+                        return FfiUnsafe(\"found function pointer with Rust calling convention in \\\n+                                          foreign module; consider using an `extern` function \\\n+                                          pointer\")\n                     }\n                     _ => {}\n                 }\n@@ -599,24 +607,30 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     let r = self.check_type_for_ffi(cache, sig.output);\n                     match r {\n                         FfiSafe => {}\n-                        _ => { return r; }\n+                        _ => {\n+                            return r;\n+                        }\n                     }\n                 }\n                 for arg in sig.inputs {\n                     let r = self.check_type_for_ffi(cache, arg);\n                     match r {\n                         FfiSafe => {}\n-                        _ => { return r; }\n+                        _ => {\n+                            return r;\n+                        }\n                     }\n                 }\n                 FfiSafe\n             }\n \n-            ty::TyParam(..) | ty::TyInfer(..) | ty::TyError |\n-            ty::TyClosure(..) | ty::TyProjection(..) | ty::TyAnon(..) |\n-            ty::TyFnDef(..) => {\n-                bug!(\"Unexpected type in foreign function\")\n-            }\n+            ty::TyParam(..) |\n+            ty::TyInfer(..) |\n+            ty::TyError |\n+            ty::TyClosure(..) |\n+            ty::TyProjection(..) |\n+            ty::TyAnon(..) |\n+            ty::TyFnDef(..) => bug!(\"Unexpected type in foreign function\"),\n         }\n     }\n \n@@ -633,23 +647,28 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             FfiResult::FfiBadStruct(_, s) => {\n                 // FIXME: This diagnostic is difficult to read, and doesn't\n                 // point at the relevant field.\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                    &format!(\"found non-foreign-function-safe member in \\\n-                              struct marked #[repr(C)]: {}\", s));\n+                self.cx.span_lint(IMPROPER_CTYPES,\n+                                  sp,\n+                                  &format!(\"found non-foreign-function-safe member in struct \\\n+                                            marked #[repr(C)]: {}\",\n+                                           s));\n             }\n             FfiResult::FfiBadUnion(_, s) => {\n                 // FIXME: This diagnostic is difficult to read, and doesn't\n                 // point at the relevant field.\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                    &format!(\"found non-foreign-function-safe member in \\\n-                              union marked #[repr(C)]: {}\", s));\n+                self.cx.span_lint(IMPROPER_CTYPES,\n+                                  sp,\n+                                  &format!(\"found non-foreign-function-safe member in union \\\n+                                            marked #[repr(C)]: {}\",\n+                                           s));\n             }\n             FfiResult::FfiBadEnum(_, s) => {\n                 // FIXME: This diagnostic is difficult to read, and doesn't\n                 // point at the relevant variant.\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                    &format!(\"found non-foreign-function-safe member in \\\n-                              enum: {}\", s));\n+                self.cx.span_lint(IMPROPER_CTYPES,\n+                                  sp,\n+                                  &format!(\"found non-foreign-function-safe member in enum: {}\",\n+                                           s));\n             }\n         }\n     }\n@@ -719,13 +738,13 @@ impl LintPass for VariantSizeDifferences {\n impl LateLintPass for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n-            if gens.ty_params.is_empty() {  // sizes only make sense for non-generic types\n+            if gens.ty_params.is_empty() {\n+                // sizes only make sense for non-generic types\n                 let t = cx.tcx.node_id_to_type(it.id);\n                 let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n-                    ty.layout(&infcx).unwrap_or_else(|e| {\n-                        bug!(\"failed to get layout for `{}`: {}\", t, e)\n-                    })\n+                    ty.layout(&infcx)\n+                        .unwrap_or_else(|e| bug!(\"failed to get layout for `{}`: {}\", t, e))\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n@@ -738,31 +757,30 @@ impl LateLintPass for VariantSizeDifferences {\n                         .zip(variants)\n                         .map(|(variant, variant_layout)| {\n                             // Subtract the size of the enum discriminant\n-                            let bytes = variant_layout.min_size.bytes()\n-                                                                 .saturating_sub(discr_size);\n+                            let bytes = variant_layout.min_size\n+                                .bytes()\n+                                .saturating_sub(discr_size);\n \n                             debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);\n                             bytes\n                         })\n                         .enumerate()\n-                        .fold((0, 0, 0),\n-                            |(l, s, li), (idx, size)|\n-                                if size > l {\n-                                    (size, l, idx)\n-                                } else if size > s {\n-                                    (l, size, li)\n-                                } else {\n-                                    (l, s, li)\n-                                }\n-                        );\n+                        .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n+                            (size, l, idx)\n+                        } else if size > s {\n+                            (l, size, li)\n+                        } else {\n+                            (l, s, li)\n+                        });\n \n                     // we only warn if the largest variant is at least thrice as large as\n                     // the second-largest.\n                     if largest > slargest * 3 && slargest > 0 {\n                         cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n                                      enum_definition.variants[largest_index].span,\n                                      &format!(\"enum variant is more than three times larger \\\n-                                               ({} bytes) than the next largest\", largest));\n+                                               ({} bytes) than the next largest\",\n+                                              largest));\n                     }\n                 }\n             }"}, {"sha": "a29ff18ab53188311c9ff13343fa7268c10222e0", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -49,8 +49,12 @@ impl UnusedMut {\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {\n                         match mutables.entry(name.0 as usize) {\n-                            Vacant(entry) => { entry.insert(vec![id]); },\n-                            Occupied(mut entry) => { entry.get_mut().push(id); },\n+                            Vacant(entry) => {\n+                                entry.insert(vec![id]);\n+                            }\n+                            Occupied(mut entry) => {\n+                                entry.get_mut().push(id);\n+                            }\n                         }\n                     }\n                 }\n@@ -60,7 +64,8 @@ impl UnusedMut {\n         let used_mutables = cx.tcx.used_mut_nodes.borrow();\n         for (_, v) in &mutables {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n-                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n+                cx.span_lint(UNUSED_MUT,\n+                             cx.tcx.map.span(v[0]),\n                              \"variable does not need to be mutable\");\n             }\n         }\n@@ -90,9 +95,13 @@ impl LateLintPass for UnusedMut {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &LateContext,\n-                _: FnKind, decl: &hir::FnDecl,\n-                _: &hir::Block, _: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self,\n+                cx: &LateContext,\n+                _: FnKind,\n+                decl: &hir::FnDecl,\n+                _: &hir::Block,\n+                _: Span,\n+                _: ast::NodeId) {\n         for a in &decl.inputs {\n             self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n@@ -124,7 +133,7 @@ impl LateLintPass for UnusedResults {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n             hir::StmtSemi(ref expr, _) => &**expr,\n-            _ => return\n+            _ => return,\n         };\n \n         if let hir::ExprRet(..) = expr.node {\n@@ -184,8 +193,8 @@ impl LateLintPass for UnusedUnsafe {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n-                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n+               !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+                cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n             }\n         }\n     }\n@@ -210,8 +219,7 @@ impl LateLintPass for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         if let hir::StmtSemi(ref expr, _) = s.node {\n             if let hir::ExprPath(..) = expr.node {\n-                cx.span_lint(PATH_STATEMENTS, s.span,\n-                             \"path statement with no effect\");\n+                cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n             }\n         }\n     }\n@@ -242,8 +250,8 @@ impl LateLintPass for UnusedAttributes {\n                 AttributeType::Whitelisted if attr.check_name(name) => {\n                     debug!(\"{:?} is Whitelisted\", name);\n                     break;\n-                },\n-                _ => ()\n+                }\n+                _ => (),\n             }\n         }\n \n@@ -259,24 +267,22 @@ impl LateLintPass for UnusedAttributes {\n             debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n-            let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n-                attr.name() == name &&\n-                ty == AttributeType::CrateLevel\n-            }).is_some();\n+            let known_crate = KNOWN_ATTRIBUTES.iter()\n+                .find(|&&(name, ty, _)| attr.name() == name && ty == AttributeType::CrateLevel)\n+                .is_some();\n \n             // Has a plugin registered this attribute as one which must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                                                .find(|&&(ref x, t)| {\n-                                                        &*attr.name() == x &&\n-                                                        AttributeType::CrateLevel == t\n-                                                    }).is_some();\n-            if  known_crate || plugin_crate {\n+                .find(|&&(ref x, t)| &*attr.name() == x && AttributeType::CrateLevel == t)\n+                .is_some();\n+            if known_crate || plugin_crate {\n                 let msg = match attr.node.style {\n-                    ast::AttrStyle::Outer => \"crate-level attribute should be an inner \\\n-                                              attribute: add an exclamation mark: #![foo]\",\n-                    ast::AttrStyle::Inner => \"crate-level attribute should be in the \\\n-                                              root module\",\n+                    ast::AttrStyle::Outer => {\n+                        \"crate-level attribute should be an inner attribute: add an exclamation \\\n+                         mark: #![foo]\"\n+                    }\n+                    ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n                 };\n                 cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n             }\n@@ -296,12 +302,16 @@ declare_lint! {\n pub struct UnusedParens;\n \n impl UnusedParens {\n-    fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n+    fn check_unused_parens_core(&self,\n+                                cx: &EarlyContext,\n+                                value: &ast::Expr,\n+                                msg: &str,\n                                 struct_lit_needs_parens: bool) {\n         if let ast::ExprKind::Paren(ref inner) = value.node {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&inner);\n             if !necessary {\n-                cx.span_lint(UNUSED_PARENS, value.span,\n+                cx.span_lint(UNUSED_PARENS,\n+                             value.span,\n                              &format!(\"unnecessary parentheses around {}\", msg))\n             }\n         }\n@@ -319,8 +329,7 @@ impl UnusedParens {\n                 ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n                 ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n                     // X { y: 1 } + X { y: 2 }\n-                    contains_exterior_struct_lit(&lhs) ||\n-                        contains_exterior_struct_lit(&rhs)\n+                    contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n                 }\n                 ast::ExprKind::Unary(_, ref x) |\n                 ast::ExprKind::Cast(ref x, _) |\n@@ -337,7 +346,7 @@ impl UnusedParens {\n                     contains_exterior_struct_lit(&exprs[0])\n                 }\n \n-                _ => false\n+                _ => false,\n             }\n         }\n     }\n@@ -363,18 +372,20 @@ impl EarlyLintPass for UnusedParens {\n             Assign(_, ref value) => (value, \"assigned value\", false),\n             AssignOp(.., ref value) => (value, \"assigned value\", false),\n             InPlace(_, ref value) => (value, \"emplacement value\", false),\n-            _ => return\n+            _ => return,\n         };\n         self.check_unused_parens_core(cx, &value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n         let (value, msg) = match s.node {\n-            ast::StmtKind::Local(ref local) => match local.init {\n-                Some(ref value) => (value, \"assigned value\"),\n-                None => return\n-            },\n-            _ => return\n+            ast::StmtKind::Local(ref local) => {\n+                match local.init {\n+                    Some(ref value) => (value, \"assigned value\"),\n+                    None => return,\n+                }\n+            }\n+            _ => return,\n         };\n         self.check_unused_parens_core(cx, &value, msg, false);\n     }\n@@ -427,23 +438,24 @@ impl LateLintPass for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprBox(_) => {}\n-            _ => return\n+            _ => return,\n         }\n \n         if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                ref autoref, ..\n-            }) = *adjustment {\n+            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef { ref autoref, .. }) =\n+                *adjustment {\n                 match autoref {\n                     &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                        cx.span_lint(UNUSED_ALLOCATION,\n+                                     e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n                     &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                        cx.span_lint(UNUSED_ALLOCATION,\n+                                     e.span,\n                                      \"unnecessary allocation, use &mut instead\");\n                     }\n-                    _ => ()\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "bdb4d383cee7d70776088839357f7a2aff9375f1", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -32,6 +32,7 @@ use rustc_const_math::ConstInt;\n \n use rustc::mir::repr::Mir;\n \n+use std::borrow::Cow;\n use std::cell::Ref;\n use std::io;\n use std::mem;\n@@ -202,7 +203,7 @@ impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n         read_f64 -> f64;\n         read_f32 -> f32;\n         read_char -> char;\n-        read_str -> String;\n+        read_str -> Cow<str>;\n     }\n \n     fn error(&mut self, err: &str) -> Self::Error {"}, {"sha": "3d8a10f6c31fcc2a24febf28c3e6878844da6f7c", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -23,7 +23,7 @@\n #![feature(dotdot_in_tuple_patterns)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_lib)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "02f15602d708b3472a39f42aa391282213a7f8c8", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -26,7 +26,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n \n #[macro_use] extern crate log;\n extern crate graphviz as dot;"}, {"sha": "5600669d45fb97988583fb08e6e6b300a77dacc9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -13,7 +13,7 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use macros;\n+use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use {Module, ModuleS, ModuleKind};\n use Namespace::{self, TypeNS, ValueNS};\n@@ -200,16 +200,16 @@ impl<'b> Resolver<'b> {\n                         LoadedMacroKind::Def(mut def) => {\n                             let name = def.ident.name;\n                             if def.use_locally {\n-                                let ext = macro_rules::compile(&self.session.parse_sess, &def);\n-                                let shadowing =\n-                                    self.resolve_macro_name(Mark::root(), name, false).is_some();\n-                                self.expansion_data[&Mark::root()].module.macros.borrow_mut()\n-                                    .insert(name, macros::NameBinding {\n-                                        ext: Rc::new(ext),\n-                                        expansion: expansion,\n-                                        shadowing: shadowing,\n-                                        span: loaded_macro.import_site,\n-                                    });\n+                                let ext =\n+                                    Rc::new(macro_rules::compile(&self.session.parse_sess, &def));\n+                                if self.builtin_macros.insert(name, ext).is_some() &&\n+                                   expansion != Mark::root() {\n+                                    let msg = format!(\"`{}` is already in scope\", name);\n+                                    self.session.struct_span_err(loaded_macro.import_site, &msg)\n+                                        .note(\"macro-expanded `#[macro_use]`s may not shadow \\\n+                                               existing macros (see RFC 1560)\")\n+                                        .emit();\n+                                }\n                                 self.macro_names.insert(name);\n                             }\n                             if def.export {\n@@ -250,7 +250,6 @@ impl<'b> Resolver<'b> {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n-                    macros_escape: self.contains_macro_use(&item.attrs),\n                     ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n@@ -520,45 +519,62 @@ impl<'b> Resolver<'b> {\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n     pub resolver: &'a mut Resolver<'b>,\n+    pub legacy_scope: LegacyScope<'b>,\n     pub expansion: Mark,\n }\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n-    fn visit_invoc(&mut self, id: ast::NodeId) {\n-        self.resolver.expansion_data.get_mut(&Mark::from_placeholder_id(id)).unwrap().module =\n-            self.resolver.current_module;\n+    fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n+        let invocation = self.resolver.invocations[&Mark::from_placeholder_id(id)];\n+        invocation.module.set(self.resolver.current_module);\n+        invocation.legacy_scope.set(self.legacy_scope);\n+        invocation\n     }\n }\n \n macro_rules! method {\n     ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n         fn $visit(&mut self, node: &$ty) {\n-            match node.node {\n-                $invoc(..) => self.visit_invoc(node.id),\n-                _ => visit::$walk(self, node),\n+            if let $invoc(..) = node.node {\n+                self.visit_invoc(node.id);\n+            } else {\n+                visit::$walk(self, node);\n             }\n         }\n     }\n }\n \n impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     method!(visit_impl_item: ast::ImplItem, ast::ImplItemKind::Macro, walk_impl_item);\n-    method!(visit_stmt:      ast::Stmt,     ast::StmtKind::Mac,       walk_stmt);\n     method!(visit_expr:      ast::Expr,     ast::ExprKind::Mac,       walk_expr);\n     method!(visit_pat:       ast::Pat,      ast::PatKind::Mac,        walk_pat);\n     method!(visit_ty:        ast::Ty,       ast::TyKind::Mac,         walk_ty);\n \n     fn visit_item(&mut self, item: &Item) {\n-        match item.node {\n+        let macro_use = match item.node {\n             ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n-            ItemKind::Mac(..) => return self.visit_invoc(item.id),\n-            _ => {}\n-        }\n+            ItemKind::Mac(..) => {\n+                return self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+            }\n+            ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n+            _ => false,\n+        };\n \n-        let parent = self.resolver.current_module;\n+        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n         self.resolver.build_reduced_graph_for_item(item, self.expansion);\n         visit::walk_item(self, item);\n         self.resolver.current_module = parent;\n+        if !macro_use {\n+            self.legacy_scope = legacy_scope;\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &ast::Stmt) {\n+        if let ast::StmtKind::Mac(..) = stmt.node {\n+            self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(stmt.id));\n+        } else {\n+            visit::walk_stmt(self, stmt);\n+        }\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n@@ -567,18 +583,20 @@ impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n-        let parent = self.resolver.current_module;\n+        let (parent, legacy_scope) = (self.resolver.current_module, self.legacy_scope);\n         self.resolver.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n         self.resolver.current_module = parent;\n+        self.legacy_scope = legacy_scope;\n     }\n \n     fn visit_trait_item(&mut self, item: &TraitItem) {\n         let parent = self.resolver.current_module;\n         let def_id = parent.def_id().unwrap();\n \n         if let TraitItemKind::Macro(_) = item.node {\n-            return self.visit_invoc(item.id);\n+            self.visit_invoc(item.id);\n+            return\n         }\n \n         // Add the item to the trait info."}, {"sha": "6db844c1d0376ca2ceb3c853cf321e8bf3cc5218", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -57,6 +57,7 @@ use syntax::ext::base::MultiItemModifier;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -77,6 +78,7 @@ use std::mem::replace;\n use std::rc::Rc;\n \n use resolve_imports::{ImportDirective, NameResolution};\n+use macros::{InvocationData, LegacyBinding, LegacyScope};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -791,9 +793,6 @@ pub struct ModuleS<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n-\n-    macros: RefCell<FnvHashMap<Name, macros::NameBinding>>,\n-    macros_escape: bool,\n }\n \n pub type Module<'a> = &'a ModuleS<'a>;\n@@ -811,8 +810,6 @@ impl<'a> ModuleS<'a> {\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n             populated: Cell::new(true),\n-            macros: RefCell::new(FnvHashMap()),\n-            macros_escape: false,\n         }\n     }\n \n@@ -1076,7 +1073,7 @@ pub struct Resolver<'a> {\n \n     privacy_errors: Vec<PrivacyError<'a>>,\n     ambiguity_errors: Vec<AmbiguityError<'a>>,\n-    macro_shadowing_errors: FnvHashSet<Span>,\n+    disallowed_shadowing: Vec<(Name, Span, LegacyScope<'a>)>,\n \n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n@@ -1086,9 +1083,10 @@ pub struct Resolver<'a> {\n     pub derive_modes: FnvHashMap<Name, Rc<MultiItemModifier>>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FnvHashSet<Name>,\n+    builtin_macros: FnvHashMap<Name, Rc<SyntaxExtension>>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n-    expansion_data: FnvHashMap<Mark, macros::ExpansionData<'a>>,\n+    invocations: FnvHashMap<Mark, &'a InvocationData<'a>>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1097,6 +1095,8 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n+    invocation_data: arena::TypedArena<InvocationData<'a>>,\n+    legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -1120,6 +1120,13 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n+    fn alloc_invocation_data(&'a self, expansion_data: InvocationData<'a>)\n+                             -> &'a InvocationData<'a> {\n+        self.invocation_data.alloc(expansion_data)\n+    }\n+    fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n+        self.legacy_bindings.alloc(binding)\n+    }\n }\n \n impl<'a> ty::NodeIdTree for Resolver<'a> {\n@@ -1205,8 +1212,9 @@ impl<'a> Resolver<'a> {\n         let mut definitions = Definitions::new();\n         DefCollector::new(&mut definitions).collect_root();\n \n-        let mut expansion_data = FnvHashMap();\n-        expansion_data.insert(Mark::root(), macros::ExpansionData::root(graph_root));\n+        let mut invocations = FnvHashMap();\n+        invocations.insert(Mark::root(),\n+                           arenas.alloc_invocation_data(InvocationData::root(graph_root)));\n \n         Resolver {\n             session: session,\n@@ -1252,7 +1260,7 @@ impl<'a> Resolver<'a> {\n \n             privacy_errors: Vec::new(),\n             ambiguity_errors: Vec::new(),\n-            macro_shadowing_errors: FnvHashSet(),\n+            disallowed_shadowing: Vec::new(),\n \n             arenas: arenas,\n             dummy_binding: arenas.alloc_name_binding(NameBinding {\n@@ -1266,7 +1274,8 @@ impl<'a> Resolver<'a> {\n             derive_modes: FnvHashMap(),\n             crate_loader: crate_loader,\n             macro_names: FnvHashSet(),\n-            expansion_data: expansion_data,\n+            builtin_macros: FnvHashMap(),\n+            invocations: invocations,\n         }\n     }\n \n@@ -1277,6 +1286,8 @@ impl<'a> Resolver<'a> {\n             name_bindings: arena::TypedArena::new(),\n             import_directives: arena::TypedArena::new(),\n             name_resolutions: arena::TypedArena::new(),\n+            invocation_data: arena::TypedArena::new(),\n+            legacy_bindings: arena::TypedArena::new(),\n         }\n     }\n \n@@ -3338,7 +3349,8 @@ impl<'a> Resolver<'a> {\n         vis.is_accessible_from(module.normal_ancestor_id.unwrap(), self)\n     }\n \n-    fn report_errors(&self) {\n+    fn report_errors(&mut self) {\n+        self.report_shadowing_errors();\n         let mut reported_spans = FnvHashSet();\n \n         for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n@@ -3366,6 +3378,20 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn report_shadowing_errors(&mut self) {\n+        let mut reported_errors = FnvHashSet();\n+        for (name, span, scope) in replace(&mut self.disallowed_shadowing, Vec::new()) {\n+            if self.resolve_macro_name(scope, name, false).is_some() &&\n+               reported_errors.insert((name, span)) {\n+                let msg = format!(\"`{}` is already in scope\", name);\n+                self.session.struct_span_err(span, &msg)\n+                    .note(\"macro-expanded `macro_rules!`s may not shadow \\\n+                           existing macros (see RFC 1560)\")\n+                    .emit();\n+            }\n+        }\n+    }\n+\n     fn report_conflict(&self,\n                        parent: Module,\n                        name: Name,"}, {"sha": "86ab077191eefd9429fcb24eb6a4e6d16e85eb58", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 129, "deletions": 82, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -12,47 +12,76 @@ use {Module, Resolver};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n use rustc::hir::map::{self, DefCollector};\n+use rustc::util::nodemap::FnvHashMap;\n+use std::cell::Cell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, MultiModifier, MultiDecorator, MultiItemModifier};\n+use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator, MultiItemModifier};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n+use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token::intern;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{Span, DUMMY_SP};\n-\n-// FIXME(jseyfried) Merge with `::NameBinding`.\n-pub struct NameBinding {\n-    pub ext: Rc<SyntaxExtension>,\n-    pub expansion: Mark,\n-    pub shadowing: bool,\n-    pub span: Span,\n-}\n+use syntax_pos::Span;\n \n #[derive(Clone)]\n-pub struct ExpansionData<'a> {\n-    backtrace: SyntaxContext,\n-    pub module: Module<'a>,\n+pub struct InvocationData<'a> {\n+    pub module: Cell<Module<'a>>,\n     def_index: DefIndex,\n     // True if this expansion is in a `const_integer` position, for example `[u32; m!()]`.\n     // c.f. `DefCollector::visit_ast_const_integer`.\n     const_integer: bool,\n+    // The scope in which the invocation path is resolved.\n+    pub legacy_scope: Cell<LegacyScope<'a>>,\n+    // The smallest scope that includes this invocation's expansion,\n+    // or `Empty` if this invocation has not been expanded yet.\n+    pub expansion: Cell<LegacyScope<'a>>,\n }\n \n-impl<'a> ExpansionData<'a> {\n+impl<'a> InvocationData<'a> {\n     pub fn root(graph_root: Module<'a>) -> Self {\n-        ExpansionData {\n-            backtrace: SyntaxContext::empty(),\n-            module: graph_root,\n+        InvocationData {\n+            module: Cell::new(graph_root),\n             def_index: CRATE_DEF_INDEX,\n             const_integer: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum LegacyScope<'a> {\n+    Empty,\n+    Invocation(&'a InvocationData<'a>), // The scope of the invocation, not including its expansion\n+    Expansion(&'a InvocationData<'a>), // The scope of the invocation, including its expansion\n+    Binding(&'a LegacyBinding<'a>),\n+}\n+\n+impl<'a> LegacyScope<'a> {\n+    fn simplify_expansion(mut invoc: &'a InvocationData<'a>) -> Self {\n+        while let LegacyScope::Invocation(_) = invoc.expansion.get() {\n+            match invoc.legacy_scope.get() {\n+                LegacyScope::Expansion(new_invoc) => invoc = new_invoc,\n+                LegacyScope::Binding(_) => break,\n+                scope @ _ => return scope,\n+            }\n         }\n+        LegacyScope::Expansion(invoc)\n     }\n }\n \n+pub struct LegacyBinding<'a> {\n+    parent: LegacyScope<'a>,\n+    name: ast::Name,\n+    ext: Rc<SyntaxExtension>,\n+    span: Span,\n+}\n+\n+pub type LegacyImports = FnvHashMap<ast::Name, (Rc<SyntaxExtension>, Span)>;\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -61,37 +90,43 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn get_module_scope(&mut self, id: ast::NodeId) -> Mark {\n         let mark = Mark::fresh();\n         let module = self.module_map[&id];\n-        self.expansion_data.insert(mark, ExpansionData {\n-            backtrace: SyntaxContext::empty(),\n-            module: module,\n+        self.invocations.insert(mark, self.arenas.alloc_invocation_data(InvocationData {\n+            module: Cell::new(module),\n             def_index: module.def_id().unwrap().index,\n             const_integer: false,\n-        });\n+            legacy_scope: Cell::new(LegacyScope::Empty),\n+            expansion: Cell::new(LegacyScope::Empty),\n+        }));\n         mark\n     }\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n-        self.collect_def_ids(mark, expansion);\n-        self.current_module = self.expansion_data[&mark].module;\n-        expansion.visit_with(&mut BuildReducedGraphVisitor { resolver: self, expansion: mark });\n+        let invocation = self.invocations[&mark];\n+        self.collect_def_ids(invocation, expansion);\n+\n+        self.current_module = invocation.module.get();\n+        let mut visitor = BuildReducedGraphVisitor {\n+            resolver: self,\n+            legacy_scope: LegacyScope::Invocation(invocation),\n+            expansion: mark,\n+        };\n+        expansion.visit_with(&mut visitor);\n+        invocation.expansion.set(visitor.legacy_scope);\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef) {\n         if &def.ident.name.as_str() == \"macro_rules\" {\n             self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n         if def.use_locally {\n-            let ExpansionData { mut module, backtrace, .. } = self.expansion_data[&scope];\n-            while module.macros_escape {\n-                module = module.parent.unwrap();\n-            }\n-            let binding = NameBinding {\n+            let invocation = self.invocations[&scope];\n+            let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n+                parent: invocation.legacy_scope.get(),\n+                name: def.ident.name,\n                 ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-                expansion: backtrace.data().prev_ctxt.data().outer_mark,\n-                shadowing: self.resolve_macro_name(scope, def.ident.name, false).is_some(),\n                 span: def.span,\n-            };\n-            module.macros.borrow_mut().insert(def.ident.name, binding);\n+            });\n+            invocation.legacy_scope.set(LegacyScope::Binding(binding));\n             self.macro_names.insert(def.ident.name);\n         }\n         if def.export {\n@@ -104,12 +139,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n         }\n-        self.graph_root.macros.borrow_mut().insert(ident.name, NameBinding {\n-            ext: ext,\n-            expansion: Mark::root(),\n-            shadowing: false,\n-            span: DUMMY_SP,\n-        });\n+        self.builtin_macros.insert(ident.name, ext);\n     }\n \n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n@@ -119,8 +149,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n-            match self.expansion_data[&Mark::root()].module.macros.borrow().get(&name) {\n-                Some(binding) => match *binding.ext {\n+            match self.builtin_macros.get(&name) {\n+                Some(ext) => match **ext {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n                     }\n@@ -132,27 +162,36 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n+    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let (name, span) = match invoc.kind {\n             InvocationKind::Bang { ref mac, .. } => {\n                 let path = &mac.node.path;\n                 if path.segments.len() > 1 || path.global ||\n                    !path.segments[0].parameters.is_empty() {\n                     self.session.span_err(path.span,\n                                           \"expected macro name without module separators\");\n-                    return None;\n+                    return Err(Determinacy::Determined);\n                 }\n                 (path.segments[0].identifier.name, path.span)\n             }\n             InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n         };\n \n-        self.resolve_macro_name(scope, name, true).or_else(|| {\n-            let mut err =\n-                self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n-            self.suggest_macro_name(&name.as_str(), &mut err);\n-            err.emit();\n-            None\n+        let invocation = self.invocations[&scope];\n+        if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n+            invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n+        }\n+        self.resolve_macro_name(invocation.legacy_scope.get(), name, true).ok_or_else(|| {\n+            if force {\n+                let mut err =\n+                    self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n+                self.suggest_macro_name(&name.as_str(), &mut err);\n+                err.emit();\n+                Determinacy::Determined\n+            } else {\n+                Determinacy::Undetermined\n+            }\n         })\n     }\n \n@@ -162,36 +201,40 @@ impl<'a> base::Resolver for Resolver<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn resolve_macro_name(&mut self, scope: Mark, name: ast::Name, record_used: bool)\n+    pub fn resolve_macro_name(&mut self,\n+                              mut scope: LegacyScope<'a>,\n+                              name: ast::Name,\n+                              record_used: bool)\n                               -> Option<Rc<SyntaxExtension>> {\n-        let ExpansionData { mut module, backtrace, .. } = self.expansion_data[&scope];\n+        let mut relative_depth: u32 = 0;\n         loop {\n-            if let Some(binding) = module.macros.borrow().get(&name) {\n-                let mut backtrace = backtrace.data();\n-                while binding.expansion != backtrace.outer_mark {\n-                    if backtrace.outer_mark != Mark::root() {\n-                        backtrace = backtrace.prev_ctxt.data();\n-                        continue\n+            scope = match scope {\n+                LegacyScope::Empty => break,\n+                LegacyScope::Expansion(invocation) => {\n+                    if let LegacyScope::Empty = invocation.expansion.get() {\n+                        invocation.legacy_scope.get()\n+                    } else {\n+                        relative_depth += 1;\n+                        invocation.expansion.get()\n                     }\n-\n-                    if record_used && binding.shadowing &&\n-                       self.macro_shadowing_errors.insert(binding.span) {\n-                        let msg = format!(\"`{}` is already in scope\", name);\n-                        self.session.struct_span_err(binding.span, &msg)\n-                            .note(\"macro-expanded `macro_rules!`s and `#[macro_use]`s \\\n-                                   may not shadow existing macros (see RFC 1560)\")\n-                            .emit();\n+                }\n+                LegacyScope::Invocation(invocation) => {\n+                    relative_depth = relative_depth.saturating_sub(1);\n+                    invocation.legacy_scope.get()\n+                }\n+                LegacyScope::Binding(binding) => {\n+                    if binding.name == name {\n+                        if record_used && relative_depth > 0 {\n+                            self.disallowed_shadowing.push((name, binding.span, binding.parent));\n+                        }\n+                        return Some(binding.ext.clone());\n                     }\n-                    break\n+                    binding.parent\n                 }\n-                return Some(binding.ext.clone());\n-            }\n-            match module.parent {\n-                Some(parent) => module = parent,\n-                None => break,\n-            }\n+            };\n         }\n-        None\n+\n+        self.builtin_macros.get(&name).cloned()\n     }\n \n     fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n@@ -204,15 +247,19 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn collect_def_ids(&mut self, mark: Mark, expansion: &Expansion) {\n-        let expansion_data = &mut self.expansion_data;\n-        let ExpansionData { backtrace, def_index, const_integer, module } = expansion_data[&mark];\n+    fn collect_def_ids(&mut self, invocation: &'a InvocationData<'a>, expansion: &Expansion) {\n+        let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n+        let InvocationData { def_index, const_integer, .. } = *invocation;\n+\n         let visit_macro_invoc = &mut |invoc: map::MacroInvocationData| {\n-            expansion_data.entry(invoc.mark).or_insert(ExpansionData {\n-                backtrace: backtrace.apply_mark(invoc.mark),\n-                def_index: invoc.def_index,\n-                const_integer: invoc.const_integer,\n-                module: module,\n+            invocations.entry(invoc.mark).or_insert_with(|| {\n+                arenas.alloc_invocation_data(InvocationData {\n+                    def_index: invoc.def_index,\n+                    const_integer: invoc.const_integer,\n+                    module: Cell::new(graph_root),\n+                    expansion: Cell::new(LegacyScope::Empty),\n+                    legacy_scope: Cell::new(LegacyScope::Empty),\n+                })\n             });\n         };\n "}, {"sha": "0939e6f1644de8fb496b8d565da955c0c5105459", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::Determinacy::*;\n use self::ImportDirectiveSubclass::*;\n \n use Module;\n@@ -26,6 +25,7 @@ use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n use syntax::ast::{NodeId, Name};\n+use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n@@ -37,12 +37,6 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum Determinacy {\n-    Determined,\n-    Undetermined,\n-}\n-\n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {\n@@ -197,7 +191,8 @@ impl<'a> Resolver<'a> {\n         // If the resolution doesn't depend on glob definability, check privacy and return.\n         if let Some(result) = self.try_result(&resolution, ns) {\n             return result.and_then(|binding| {\n-                if self.is_accessible(binding.vis) && !is_disallowed_private_import(binding) {\n+                if self.is_accessible(binding.vis) && !is_disallowed_private_import(binding) ||\n+                   binding.is_extern_crate() { // c.f. issue #37020\n                     Success(binding)\n                 } else {\n                     Failed(None)"}, {"sha": "9b893e19894e858d5ed2d46ee029ce6cd1f5b65f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -114,7 +114,8 @@ pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n             if tys.len() != 2 {\n                 return None;\n             }\n-            Some([tys[0], tys[1]])\n+            Some([ccx.tcx().normalize_associated_type(&tys[0]),\n+                  ccx.tcx().normalize_associated_type(&tys[1])])\n         }\n         _ => None\n     }"}, {"sha": "81c0c184f66b2e76441d1c79ae9443060cbbe449", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -36,7 +36,7 @@\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(unicode)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n \n use rustc::dep_graph::WorkProduct;\n "}, {"sha": "cb9b162cabe11911e3180c4acee2ad39c4ad0034", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -82,7 +82,7 @@ This API is completely unstable and subject to change.\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "d78f00497ca557694b44a8f19b82218f382c6342", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -11,64 +11,79 @@\n use std::fs::File;\n use std::io::prelude::*;\n use std::io;\n-use std::path::{PathBuf, Path};\n+use std::path::Path;\n use std::str;\n \n #[derive(Clone)]\n pub struct ExternalHtml{\n+    /// Content that will be included inline in the <head> section of a\n+    /// rendered Markdown file or generated documentation\n     pub in_header: String,\n+    /// Content that will be included inline between <body> and the content of\n+    /// a rendered Markdown file or generated documentation\n     pub before_content: String,\n+    /// Content that will be included inline between the content and </body> of\n+    /// a rendered Markdown file or generated documentation\n     pub after_content: String\n }\n \n impl ExternalHtml {\n     pub fn load(in_header: &[String], before_content: &[String], after_content: &[String])\n             -> Option<ExternalHtml> {\n-        match (load_external_files(in_header),\n-               load_external_files(before_content),\n-               load_external_files(after_content)) {\n-            (Some(ih), Some(bc), Some(ac)) => Some(ExternalHtml {\n-                in_header: ih,\n-                before_content: bc,\n-                after_content: ac\n-            }),\n-            _ => None\n-        }\n+        load_external_files(in_header)\n+            .and_then(|ih|\n+                load_external_files(before_content)\n+                    .map(|bc| (ih, bc))\n+            )\n+            .and_then(|(ih, bc)|\n+                load_external_files(after_content)\n+                    .map(|ac| (ih, bc, ac))\n+            )\n+            .map(|(ih, bc, ac)|\n+                ExternalHtml {\n+                    in_header: ih,\n+                    before_content: bc,\n+                    after_content: ac,\n+                }\n+            )\n     }\n }\n \n-pub fn load_string(input: &Path) -> io::Result<Option<String>> {\n-    let mut f = File::open(input)?;\n-    let mut d = Vec::new();\n-    f.read_to_end(&mut d)?;\n-    Ok(str::from_utf8(&d).map(|s| s.to_string()).ok())\n+pub enum LoadStringError {\n+    ReadFail,\n+    BadUtf8,\n }\n \n-macro_rules! load_or_return {\n-    ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n-        {\n-            let input = PathBuf::from(&$input[..]);\n-            match ::externalfiles::load_string(&input) {\n-                Err(e) => {\n-                    let _ = writeln!(&mut io::stderr(),\n-                                     \"error reading `{}`: {}\", input.display(), e);\n-                    return $cant_read;\n-                }\n-                Ok(None) => {\n-                    let _ = writeln!(&mut io::stderr(),\n-                                     \"error reading `{}`: not UTF-8\", input.display());\n-                    return $not_utf8;\n-                }\n-                Ok(Some(s)) => s\n-            }\n+pub fn load_string<P: AsRef<Path>>(file_path: P) -> Result<String, LoadStringError> {\n+    let file_path = file_path.as_ref();\n+    let mut contents = vec![];\n+    let result = File::open(file_path)\n+                      .and_then(|mut f| f.read_to_end(&mut contents));\n+    if let Err(e) = result {\n+        let _ = writeln!(&mut io::stderr(),\n+                         \"error reading `{}`: {}\",\n+                         file_path.display(), e);\n+        return Err(LoadStringError::ReadFail);\n+    }\n+    match str::from_utf8(&contents) {\n+        Ok(s) => Ok(s.to_string()),\n+        Err(_) => {\n+            let _ = writeln!(&mut io::stderr(),\n+                             \"error reading `{}`: not UTF-8\",\n+                             file_path.display());\n+            Err(LoadStringError::BadUtf8)\n         }\n     }\n }\n \n-pub fn load_external_files(names: &[String]) -> Option<String> {\n+fn load_external_files(names: &[String]) -> Option<String> {\n     let mut out = String::new();\n     for name in names {\n-        out.push_str(&*load_or_return!(&name, None, None));\n+        let s = match load_string(name) {\n+            Ok(s) => s,\n+            Err(_) => return None,\n+        };\n+        out.push_str(&s);\n         out.push('\\n');\n     }\n     Some(out)"}, {"sha": "0be36eb3a85088d7dd7125e95e88fa21468cfd0e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -28,7 +28,7 @@\n #![feature(staged_api)]\n #![feature(test)]\n #![feature(unicode)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "f708aa5461999be4de11f6e424e78f849dee9e6e", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -19,7 +19,7 @@ use testing;\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::Externs;\n \n-use externalfiles::ExternalHtml;\n+use externalfiles::{ExternalHtml, LoadStringError, load_string};\n \n use html::render::reset_ids;\n use html::escape::Escape;\n@@ -58,7 +58,11 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n         css.push_str(&s)\n     }\n \n-    let input_str = load_or_return!(input, 1, 2);\n+    let input_str = match load_string(input) {\n+        Ok(s) => s,\n+        Err(LoadStringError::ReadFail) => return 1,\n+        Err(LoadStringError::BadUtf8) => return 2,\n+    };\n     let playground = matches.opt_str(\"markdown-playground-url\");\n     if playground.is_some() {\n         markdown::PLAYGROUND_KRATE.with(|s| { *s.borrow_mut() = Some(None); });\n@@ -144,7 +148,11 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n /// Run any tests/code examples in the markdown file `input`.\n pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>) -> isize {\n-    let input_str = load_or_return!(input, 1, 2);\n+    let input_str = match load_string(input) {\n+        Ok(s) => s,\n+        Err(LoadStringError::ReadFail) => return 1,\n+        Err(LoadStringError::BadUtf8) => return 2,\n+    };\n \n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;"}, {"sha": "3e976c90628308c25669c2a80b337ab6ab7e6bd8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -199,6 +199,7 @@ use self::DecoderError::*;\n use self::ParserState::*;\n use self::InternalStackElement::*;\n \n+use std::borrow::Cow;\n use std::collections::{HashMap, BTreeMap};\n use std::io::prelude::*;\n use std::io;\n@@ -2081,9 +2082,7 @@ impl Decoder {\n     pub fn new(json: Json) -> Decoder {\n         Decoder { stack: vec![json] }\n     }\n-}\n \n-impl Decoder {\n     fn pop(&mut self) -> Json {\n         self.stack.pop().unwrap()\n     }\n@@ -2182,8 +2181,8 @@ impl ::Decoder for Decoder {\n         Err(ExpectedError(\"single character string\".to_owned(), format!(\"{}\", s)))\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<string::String> {\n-        expect!(self.pop(), String)\n+    fn read_str(&mut self) -> DecodeResult<Cow<str>> {\n+        expect!(self.pop(), String).map(Cow::Owned)\n     }\n \n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> DecodeResult<T> where"}, {"sha": "884f24ddc4c75a8b739c83096d9322bc30998007", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -35,7 +35,7 @@ Core encoding and decoding interfaces.\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unicode)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![cfg_attr(test, feature(test))]\n \n // test harness access"}, {"sha": "a2c0ca954472c3d36676336fbc9b9f20e76e08ef", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use leb128::{read_signed_leb128, read_unsigned_leb128, write_signed_leb128, write_unsigned_leb128};\n+use std::borrow::Cow;\n use std::io::{self, Write};\n use serialize;\n \n@@ -246,11 +247,11 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         Ok(::std::char::from_u32(bits).unwrap())\n     }\n \n-    fn read_str(&mut self) -> Result<String, Self::Error> {\n+    fn read_str(&mut self) -> Result<Cow<str>, Self::Error> {\n         let len = self.read_usize()?;\n         let s = ::std::str::from_utf8(&self.data[self.position..self.position + len]).unwrap();\n         self.position += len;\n-        Ok(s.to_string())\n+        Ok(Cow::Borrowed(s))\n     }\n \n     fn error(&mut self, err: &str) -> Self::Error {"}, {"sha": "c4613c661a84bf26b8a3ca8bc840de91a5bc75cb", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -14,6 +14,7 @@\n Core encoding and decoding interfaces.\n */\n \n+use std::borrow::Cow;\n use std::intrinsics;\n use std::path;\n use std::rc::Rc;\n@@ -156,7 +157,7 @@ pub trait Decoder {\n     fn read_f64(&mut self) -> Result<f64, Self::Error>;\n     fn read_f32(&mut self) -> Result<f32, Self::Error>;\n     fn read_char(&mut self) -> Result<char, Self::Error>;\n-    fn read_str(&mut self) -> Result<String, Self::Error>;\n+    fn read_str(&mut self) -> Result<Cow<str>, Self::Error>;\n \n     // Compound types:\n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n@@ -401,7 +402,7 @@ impl Encodable for String {\n \n impl Decodable for String {\n     fn decode<D: Decoder>(d: &mut D) -> Result<String, D::Error> {\n-        d.read_str()\n+        Ok(d.read_str()?.into_owned())\n     }\n }\n "}, {"sha": "398bb55ea1bf69f65a5f037212d0d3381d069824", "filename": "src/libstd/error.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -55,15 +55,14 @@ use any::TypeId;\n use cell;\n use char;\n use fmt::{self, Debug, Display};\n-use marker::Reflect;\n use mem::transmute;\n use num;\n use str;\n use string;\n \n /// Base functionality for all errors in Rust.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Error: Debug + Display + Reflect {\n+pub trait Error: Debug + Display {\n     /// A short description of the error.\n     ///\n     /// The description should not contain newlines or sentence-ending"}, {"sha": "39b64e723933bed9d196298beafcd2391f4649f6", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -12,7 +12,6 @@\n \n use io::prelude::*;\n \n-use marker::Reflect;\n use cmp;\n use error;\n use fmt;\n@@ -578,7 +577,7 @@ impl<W> From<IntoInnerError<W>> for Error {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Reflect + Send + fmt::Debug> error::Error for IntoInnerError<W> {\n+impl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> {\n     fn description(&self) -> &str {\n         error::Error::description(self.error())\n     }"}, {"sha": "14d046ab0520b4cf5b66282fa128fd1434a8f176", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -12,18 +12,15 @@\n //!\n //! The `std::io` module contains a number of common things you'll need\n //! when doing input and output. The most core part of this module is\n-//! the [`Read`][read] and [`Write`][write] traits, which provide the\n+//! the [`Read`] and [`Write`] traits, which provide the\n //! most general interface for reading and writing input and output.\n //!\n-//! [read]: trait.Read.html\n-//! [write]: trait.Write.html\n-//!\n //! # Read and Write\n //!\n-//! Because they are traits, `Read` and `Write` are implemented by a number\n+//! Because they are traits, [`Read`] and [`Write`] are implemented by a number\n //! of other types, and you can implement them for your types too. As such,\n //! you'll see a few different types of I/O throughout the documentation in\n-//! this module: `File`s, `TcpStream`s, and sometimes even `Vec<T>`s. For\n+//! this module: [`File`]s, [`TcpStream`]s, and sometimes even [`Vec<T>`]s. For\n //! example, `Read` adds a `read()` method, which we can use on `File`s:\n //!\n //! ```\n@@ -43,15 +40,15 @@\n //! # }\n //! ```\n //!\n-//! `Read` and `Write` are so important, implementors of the two traits have a\n+//! [`Read`] and [`Write`] are so important, implementors of the two traits have a\n //! nickname: readers and writers. So you'll sometimes see 'a reader' instead\n-//! of 'a type that implements the `Read` trait'. Much easier!\n+//! of 'a type that implements the [`Read`] trait'. Much easier!\n //!\n //! ## Seek and BufRead\n //!\n-//! Beyond that, there are two important traits that are provided: [`Seek`][seek]\n-//! and [`BufRead`][bufread]. Both of these build on top of a reader to control\n-//! how the reading happens. `Seek` lets you control where the next byte is\n+//! Beyond that, there are two important traits that are provided: [`Seek`]\n+//! and [`BufRead`]. Both of these build on top of a reader to control\n+//! how the reading happens. [`Seek`] lets you control where the next byte is\n //! coming from:\n //!\n //! ```\n@@ -75,21 +72,18 @@\n //! # }\n //! ```\n //!\n-//! [seek]: trait.Seek.html\n-//! [bufread]: trait.BufRead.html\n-//!\n-//! `BufRead` uses an internal buffer to provide a number of other ways to read, but\n+//! [`BufRead`] uses an internal buffer to provide a number of other ways to read, but\n //! to show it off, we'll need to talk about buffers in general. Keep reading!\n //!\n //! ## BufReader and BufWriter\n //!\n //! Byte-based interfaces are unwieldy and can be inefficient, as we'd need to be\n //! making near-constant calls to the operating system. To help with this,\n-//! `std::io` comes with two structs, `BufReader` and `BufWriter`, which wrap\n+//! `std::io` comes with two structs, [`BufReader`] and [`BufWriter`], which wrap\n //! readers and writers. The wrapper uses a buffer, reducing the number of\n //! calls and providing nicer methods for accessing exactly what you want.\n //!\n-//! For example, `BufReader` works with the `BufRead` trait to add extra\n+//! For example, [`BufReader`] works with the [`BufRead`] trait to add extra\n //! methods to any reader:\n //!\n //! ```\n@@ -111,8 +105,8 @@\n //! # }\n //! ```\n //!\n-//! `BufWriter` doesn't add any new ways of writing; it just buffers every call\n-//! to [`write()`][write()]:\n+//! [`BufWriter`] doesn't add any new ways of writing; it just buffers every call\n+//! to [`write()`]:\n //!\n //! ```\n //! use std::io;\n@@ -134,8 +128,6 @@\n //! # }\n //! ```\n //!\n-//! [write()]: trait.Write.html#tymethod.write\n-//!\n //! ## Standard input and output\n //!\n //! A very common source of input is standard input:\n@@ -165,13 +157,13 @@\n //! # }\n //! ```\n //!\n-//! Of course, using `io::stdout()` directly is less common than something like\n-//! `println!`.\n+//! Of course, using [`io::stdout()`] directly is less common than something like\n+//! [`println!`].\n //!\n //! ## Iterator types\n //!\n //! A large number of the structures provided by `std::io` are for various\n-//! ways of iterating over I/O. For example, `Lines` is used to split over\n+//! ways of iterating over I/O. For example, [`Lines`] is used to split over\n //! lines:\n //!\n //! ```\n@@ -211,10 +203,10 @@\n //!\n //! ## io::Result\n //!\n-//! Last, but certainly not least, is [`io::Result`][result]. This type is used\n+//! Last, but certainly not least, is [`io::Result`]. This type is used\n //! as the return type of many `std::io` functions that can cause an error, and\n //! can be returned from your own functions as well. Many of the examples in this\n-//! module use the [`try!`][try] macro:\n+//! module use the [`try!`] macro:\n //!\n //! ```\n //! use std::io;\n@@ -230,14 +222,11 @@\n //! }\n //! ```\n //!\n-//! The return type of `read_input()`, `io::Result<()>`, is a very common type\n-//! for functions which don't have a 'real' return value, but do want to return\n-//! errors if they happen. In this case, the only purpose of this function is\n+//! The return type of `read_input()`, [`io::Result<()>`][`io::Result`], is a very\n+//! common type for functions which don't have a 'real' return value, but do want to\n+//! return errors if they happen. In this case, the only purpose of this function is\n //! to read the line and print it, so we use `()`.\n //!\n-//! [result]: type.Result.html\n-//! [try]: ../macro.try.html\n-//!\n //! ## Platform-specific behavior\n //!\n //! Many I/O functions throughout the standard library are documented to indicate\n@@ -246,6 +235,22 @@\n //! any possibly unclear semantics. Note, however, that this is informative, not a binding\n //! contract. The implementation of many of these functions are subject to change over\n //! time and may call fewer or more syscalls/library functions.\n+//!\n+//! [`Read`]: trait.Read.html\n+//! [`Write`]: trait.Write.html\n+//! [`Seek`]: trait.Seek.html\n+//! [`BufRead`]: trait.BufRead.html\n+//! [`File`]: ../fs/struct.File.html\n+//! [`TcpStream`]: ../net/struct.TcpStream.html\n+//! [`Vec<T>`]: ../vec/struct.Vec.html\n+//! [`BufReader`]: struct.BufReader.html\n+//! [`BufWriter`]: struct.BufWriter.html\n+//! [`write()`]: trait.Write.html#tymethod.write\n+//! [`io::stdout()`]: fn.stdout.html\n+//! [`println!`]: ../macro.println.html\n+//! [`Lines`]: struct.Lines.html\n+//! [`io::Result`]: type.Result.html\n+//! [`try!`]: ../macro.try.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "c2f6a6f660c48c4971cd04b809d228a2417cda7f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -255,10 +255,9 @@\n #![feature(panic_unwind)]\n #![feature(placement_in_syntax)]\n #![feature(prelude_import)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(rand)]\n #![feature(raw)]\n-#![feature(reflect_marker)]\n #![feature(repr_simd)]\n #![feature(rustc_attrs)]\n #![feature(shared)]"}, {"sha": "fce640e7c7a2c4e504c64138c596b70c7372d89f", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -270,7 +270,6 @@ use error;\n use fmt;\n use mem;\n use cell::UnsafeCell;\n-use marker::Reflect;\n use time::{Duration, Instant};\n \n #[unstable(feature = \"mpsc_select\", issue = \"27800\")]\n@@ -1163,7 +1162,7 @@ impl<T> fmt::Display for SendError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send + Reflect> error::Error for SendError<T> {\n+impl<T: Send> error::Error for SendError<T> {\n     fn description(&self) -> &str {\n         \"sending on a closed channel\"\n     }\n@@ -1198,7 +1197,7 @@ impl<T> fmt::Display for TrySendError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send + Reflect> error::Error for TrySendError<T> {\n+impl<T: Send> error::Error for TrySendError<T> {\n \n     fn description(&self) -> &str {\n         match *self {"}, {"sha": "bdc727f1dfcfe0f20536ce50054f7ec5e6cff3e7", "filename": "src/libstd/sys/common/poison.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -10,7 +10,6 @@\n \n use error::{Error};\n use fmt;\n-use marker::Reflect;\n use sync::atomic::{AtomicBool, Ordering};\n use thread;\n \n@@ -117,7 +116,7 @@ impl<T> fmt::Display for PoisonError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Reflect> Error for PoisonError<T> {\n+impl<T> Error for PoisonError<T> {\n     fn description(&self) -> &str {\n         \"poisoned lock: another task failed inside\"\n     }\n@@ -174,7 +173,7 @@ impl<T> fmt::Display for TryLockError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Reflect> Error for TryLockError<T> {\n+impl<T> Error for TryLockError<T> {\n     fn description(&self) -> &str {\n         match *self {\n             TryLockError::Poisoned(ref p) => p.description(),"}, {"sha": "30fc4c3dd8045137865da8d779cff1fb65335ba3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -71,7 +71,7 @@ impl Encodable for Name {\n \n impl Decodable for Name {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n-        Ok(token::intern(&d.read_str()?[..]))\n+        Ok(token::intern(&d.read_str()?))\n     }\n }\n "}, {"sha": "3b81ea4917f2bf9e496981d0f5f1050016d635f0", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -153,7 +153,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     // Visit attributes on expression and statements (but not attributes on items in blocks).\n-    fn visit_stmt_or_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn visit_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n         // flag the offending attributes\n         for attr in attrs.iter() {\n             if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n@@ -227,7 +227,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     pub fn configure_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        self.visit_stmt_or_expr_attrs(expr.attrs());\n+        self.visit_expr_attrs(expr.attrs());\n \n         // If an expr is valid to cfg away it will have been removed by the\n         // outer stmt or expression folder before descending in here.\n@@ -245,7 +245,6 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     pub fn configure_stmt(&mut self, stmt: ast::Stmt) -> Option<ast::Stmt> {\n-        self.visit_stmt_or_expr_attrs(stmt.attrs());\n         self.configure(stmt)\n     }\n }"}, {"sha": "f7c88073c9d405425e431db0f0110d156ffc6ca6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -22,7 +22,6 @@ use parse::{self, parser};\n use parse::token;\n use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n-use std_inject;\n use util::small_vector::SmallVector;\n \n use std::path::PathBuf;\n@@ -523,10 +522,17 @@ pub trait Resolver {\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation) -> Option<Rc<SyntaxExtension>>;\n+    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy>;\n     fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>>;\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum Determinacy {\n+    Determined,\n+    Undetermined,\n+}\n+\n pub struct DummyResolver;\n \n impl Resolver for DummyResolver {\n@@ -540,8 +546,9 @@ impl Resolver for DummyResolver {\n \n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n     fn resolve_derive_mode(&mut self, _ident: ast::Ident) -> Option<Rc<MultiItemModifier>> { None }\n-    fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n-        None\n+    fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation, _force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        Err(Determinacy::Determined)\n     }\n }\n \n@@ -737,28 +744,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn name_of(&self, st: &str) -> ast::Name {\n         token::intern(st)\n     }\n-\n-    pub fn initialize(&mut self, user_exts: Vec<NamedSyntaxExtension>, krate: &ast::Crate) {\n-        if std_inject::no_core(&krate) {\n-            self.crate_root = None;\n-        } else if std_inject::no_std(&krate) {\n-            self.crate_root = Some(\"core\");\n-        } else {\n-            self.crate_root = Some(\"std\");\n-        }\n-\n-        for (name, extension) in user_exts {\n-            let ident = ast::Ident::with_empty_ctxt(name);\n-            self.resolver.add_ext(ident, Rc::new(extension));\n-        }\n-\n-        let mut module = ModuleData {\n-            mod_path: vec![token::str_to_ident(&self.ecfg.crate_name)],\n-            directory: PathBuf::from(self.parse_sess.codemap().span_to_filename(krate.span)),\n-        };\n-        module.directory.pop();\n-        self.current_expansion.module = Rc::new(module);\n-    }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,"}, {"sha": "363ceebf0f4750e23b75ac0aa2d58c3d79b285c8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, Ident, Mac_, PatKind};\n+use ast::{Block, Ident, Mac_, PatKind};\n use ast::{Name, MacStmtStyle, StmtKind, ItemKind};\n use ast;\n use ext::hygiene::Mark;\n@@ -26,6 +26,7 @@ use parse::parser::Parser;\n use parse::token::{self, intern, keywords};\n use print::pprust;\n use ptr::P;\n+use std_inject;\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -186,8 +187,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         MacroExpander { cx: cx, monotonic: monotonic }\n     }\n \n-    fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n-        let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n+    pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n+        self.cx.crate_root = std_inject::injected_crate_name(&krate);\n+        let mut module = ModuleData {\n+            mod_path: vec![token::str_to_ident(&self.cx.ecfg.crate_name)],\n+            directory: PathBuf::from(self.cx.codemap().span_to_filename(krate.span)),\n+        };\n+        module.directory.pop();\n+        self.cx.current_expansion.module = Rc::new(module);\n \n         let krate_item = Expansion::Items(SmallVector::one(P(ast::Item {\n             attrs: krate.attrs,\n@@ -206,10 +213,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if self.cx.parse_sess.span_diagnostic.err_count() - self.cx.resolve_err_count > err_count {\n-            self.cx.parse_sess.span_diagnostic.abort_if_errors();\n-        }\n-\n         krate\n     }\n \n@@ -221,25 +224,47 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let (expansion, mut invocations) = self.collect_invocations(expansion);\n         invocations.reverse();\n \n-        let mut expansions = vec![vec![(0, expansion)]];\n-        while let Some(invoc) = invocations.pop() {\n+        let mut expansions = Vec::new();\n+        let mut undetermined_invocations = Vec::new();\n+        let (mut progress, mut force) = (false, !self.monotonic);\n+        loop {\n+            let invoc = if let Some(invoc) = invocations.pop() {\n+                invoc\n+            } else if undetermined_invocations.is_empty() {\n+                break\n+            } else {\n+                invocations = mem::replace(&mut undetermined_invocations, Vec::new());\n+                force = !mem::replace(&mut progress, false);\n+                continue\n+            };\n+\n+            let scope =\n+                if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n+            let ext = match self.cx.resolver.resolve_invoc(scope, &invoc, force) {\n+                Ok(ext) => Some(ext),\n+                Err(Determinacy::Determined) => None,\n+                Err(Determinacy::Undetermined) => {\n+                    undetermined_invocations.push(invoc);\n+                    continue\n+                }\n+            };\n+\n+            progress = true;\n             let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n-            let scope = if self.monotonic { mark } else { orig_expansion_data.mark };\n             self.cx.current_expansion.mark = scope;\n-            let expansion = match self.cx.resolver.resolve_invoc(scope, &invoc) {\n+            let expansion = match ext {\n                 Some(ext) => self.expand_invoc(invoc, ext),\n                 None => invoc.expansion_kind.dummy(invoc.span()),\n             };\n \n-            self.cx.current_expansion.depth = depth + 1;\n             let (expansion, new_invocations) = self.collect_invocations(expansion);\n \n-            if expansions.len() == depth {\n+            if expansions.len() < depth {\n                 expansions.push(Vec::new());\n             }\n-            expansions[depth].push((mark.as_u32(), expansion));\n+            expansions[depth - 1].push((mark.as_u32(), expansion));\n             if !self.cx.ecfg.single_step {\n                 invocations.extend(new_invocations.into_iter().rev());\n             }\n@@ -250,12 +275,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n-                let expansion = expansion.fold_with(&mut placeholder_expander);\n                 placeholder_expander.add(ast::NodeId::from_u32(mark), expansion);\n             }\n         }\n \n-        placeholder_expander.remove(ast::NodeId::from_u32(0))\n+        expansion.fold_with(&mut placeholder_expander)\n     }\n \n     fn collect_invocations(&mut self, expansion: Expansion) -> (Expansion, Vec<Invocation>) {\n@@ -538,7 +562,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.invocations.push(Invocation {\n             kind: kind,\n             expansion_kind: expansion_kind,\n-            expansion_data: ExpansionData { mark: mark, ..self.cx.current_expansion.clone() },\n+            expansion_data: ExpansionData {\n+                mark: mark,\n+                depth: self.cx.current_expansion.depth + 1,\n+                ..self.cx.current_expansion.clone()\n+            },\n         });\n         placeholder(expansion_kind, ast::NodeId::from_u32(mark.as_u32()))\n     }\n@@ -866,22 +894,6 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n }\n \n-pub fn expand_crate(cx: &mut ExtCtxt,\n-                    user_exts: Vec<NamedSyntaxExtension>,\n-                    c: Crate) -> Crate {\n-    cx.initialize(user_exts, &c);\n-    cx.monotonic_expander().expand_crate(c)\n-}\n-\n-// Expands crate using supplied MacroExpander - allows for\n-// non-standard expansion behaviour (e.g. step-wise).\n-pub fn expand_crate_with_expander(expander: &mut MacroExpander,\n-                                  user_exts: Vec<NamedSyntaxExtension>,\n-                                  c: Crate) -> Crate {\n-    expander.cx.initialize(user_exts, &c);\n-    expander.expand_crate(c)\n-}\n-\n // A Marker adds the given mark to the syntax context and\n // sets spans' `expn_id` to the given expn_id (unless it is `None`).\n struct Marker { mark: Mark, expn_id: Option<ExpnId> }"}, {"sha": "e323dd2f623276c16de3cfd6682194867f5c1ec1", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -88,10 +88,11 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     }\n \n     pub fn add(&mut self, id: ast::NodeId, expansion: Expansion) {\n+        let expansion = expansion.fold_with(self);\n         self.expansions.insert(id, expansion);\n     }\n \n-    pub fn remove(&mut self, id: ast::NodeId) -> Expansion {\n+    fn remove(&mut self, id: ast::NodeId) -> Expansion {\n         self.expansions.remove(&id).unwrap()\n     }\n }"}, {"sha": "62b88888fc878849f041d6051c7f9b9b88a43e80", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -253,9 +253,6 @@ declare_features! (\n     // a...b and ...b\n     (active, inclusive_range_syntax, \"1.7.0\", Some(28237)),\n \n-    // `expr?`\n-    (active, question_mark, \"1.9.0\", Some(31436)),\n-\n     // impl specialization (RFC 1210)\n     (active, specialization, \"1.7.0\", Some(31844)),\n \n@@ -348,6 +345,8 @@ declare_features! (\n     (accepted, while_let, \"1.0.0\", None),\n     // Allows `#[deprecated]` attribute\n     (accepted, deprecated, \"1.9.0\", Some(29935)),\n+    // `expr?`\n+    (accepted, question_mark, \"1.14.0\", Some(31436)),\n );\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -1072,9 +1071,6 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                                   e.span,\n                                   \"inclusive range syntax is experimental\");\n             }\n-            ast::ExprKind::Try(..) => {\n-                gate_feature_post!(&self, question_mark, e.span, \"the `?` operator is not stable\");\n-            }\n             ast::ExprKind::InPlace(..) => {\n                 gate_feature_post!(&self, placement_in_syntax, e.span, EXPLAIN_PLACEMENT_IN);\n             }"}, {"sha": "6e671c9efdcf87b2a5e3abfa0ebd64b9c0f164f5", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -31,7 +31,7 @@\n #![feature(staged_api)]\n #![feature(str_escape)]\n #![feature(unicode)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(rustc_diagnostic_macros)]\n #![feature(specialization)]\n "}, {"sha": "73d9695a9906b2de92aade848832ea81f8d5cbd1", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -566,7 +566,7 @@ impl PartialEq<InternedString> for str {\n \n impl Decodable for InternedString {\n     fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(intern(d.read_str()?.as_ref()).as_str())\n+        Ok(intern(&d.read_str()?).as_str())\n     }\n }\n "}, {"sha": "ecb437f31a5ad03d6462ed034d20a3a86a49fa28", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -112,7 +112,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                                       out,\n                                       ann,\n                                       is_expanded);\n-    if is_expanded && !std_inject::no_std(krate) {\n+    if is_expanded && !std_inject::injected_crate_name(krate).is_none() {\n         // We need to print `#![no_std]` (and its feature gate) so that\n         // compiling pretty-printed source won't inject libstd again.\n         // However we don't want these attributes in the AST because"}, {"sha": "1b63a2b70763aff5da297077c8134a958490c0d9", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -34,23 +34,25 @@ fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n     return sp;\n }\n \n-pub fn no_core(krate: &ast::Crate) -> bool {\n-    attr::contains_name(&krate.attrs, \"no_core\")\n-}\n-\n-pub fn no_std(krate: &ast::Crate) -> bool {\n-    attr::contains_name(&krate.attrs, \"no_std\") || no_core(krate)\n+pub fn injected_crate_name(krate: &ast::Crate) -> Option<&'static str> {\n+    if attr::contains_name(&krate.attrs, \"no_core\") {\n+        None\n+    } else if attr::contains_name(&krate.attrs, \"no_std\") {\n+        Some(\"core\")\n+    } else {\n+        Some(\"std\")\n+    }\n }\n \n pub fn maybe_inject_crates_ref(sess: &ParseSess,\n                                mut krate: ast::Crate,\n                                alt_std_name: Option<String>)\n                                -> ast::Crate {\n-    if no_core(&krate) {\n-        return krate;\n-    }\n+    let name = match injected_crate_name(&krate) {\n+        Some(name) => name,\n+        None => return krate,\n+    };\n \n-    let name = if no_std(&krate) { \"core\" } else { \"std\" };\n     let crate_name = token::intern(&alt_std_name.unwrap_or(name.to_string()));\n \n     krate.module.items.insert(0, P(ast::Item {"}, {"sha": "9f99919c895058ee3ccc955d7f5e4c025cbdbbdb", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -11,6 +11,7 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use syntax::ast::{self, MetaItem};\n+use syntax::attr::HasAttrs;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n@@ -104,13 +105,37 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         }\n     };\n \n-    if mitem.value_str().is_some() {\n-        cx.span_err(mitem.span, \"unexpected value in `derive`\");\n+    let mut derive_attrs = Vec::new();\n+    item = item.map_attrs(|attrs| {\n+        let partition = attrs.into_iter().partition(|attr| &attr.name() == \"derive\");\n+        derive_attrs = partition.0;\n+        partition.1\n+    });\n+\n+    // Expand `#[derive]`s after other attribute macro invocations.\n+    if cx.resolver.find_attr_invoc(&mut item.attrs.clone()).is_some() {\n+        return vec![Annotatable::Item(item.map_attrs(|mut attrs| {\n+            attrs.push(cx.attribute(span, P(mitem.clone())));\n+            attrs.extend(derive_attrs);\n+            attrs\n+        }))];\n     }\n \n-    let mut traits = mitem.meta_item_list().unwrap_or(&[]).to_owned();\n-    if traits.is_empty() {\n-        cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n+    let get_traits = |mitem: &MetaItem, cx: &ExtCtxt| {\n+        if mitem.value_str().is_some() {\n+            cx.span_err(mitem.span, \"unexpected value in `derive`\");\n+        }\n+\n+        let traits = mitem.meta_item_list().unwrap_or(&[]).to_owned();\n+        if traits.is_empty() {\n+            cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n+        }\n+        traits\n+    };\n+\n+    let mut traits = get_traits(mitem, cx);\n+    for derive_attr in derive_attrs {\n+        traits.extend(get_traits(&derive_attr.node.value, cx));\n     }\n \n     // First, weed out malformed #[derive]"}, {"sha": "f336b26ae41f2f3b63dc4cbcc99cc13ab2af94e0", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -50,20 +50,23 @@ pub mod deriving;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier};\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier, NamedSyntaxExtension};\n use syntax::ext::tt::macro_rules::MacroRulesExpander;\n use syntax::parse::token::intern;\n \n-pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quotes: bool) {\n+pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n+                         user_exts: Vec<NamedSyntaxExtension>,\n+                         enable_quotes: bool) {\n     let mut register = |name, ext| {\n-        resolver.add_ext(ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n+        resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n-    register(\"macro_rules\", IdentTT(Box::new(MacroRulesExpander), None, false));\n+    register(intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n \n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(stringify!($name), NormalTT(Box::new($f as MacroExpanderFn), None, false));\n+            register(intern(stringify!($name)),\n+                     NormalTT(Box::new($f as MacroExpanderFn), None, false));\n         )* }\n     }\n \n@@ -108,7 +111,11 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quot\n     }\n \n     // format_args uses `unstable` things internally.\n-    register(\"format_args\", NormalTT(Box::new(format::expand_format_args), None, true));\n+    register(intern(\"format_args\"), NormalTT(Box::new(format::expand_format_args), None, true));\n \n-    register(\"derive\", MultiModifier(Box::new(deriving::expand_derive)));\n+    register(intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n+\n+    for (name, ext) in user_exts {\n+        register(name, ext);\n+    }\n }"}, {"sha": "e3feaee5369d1c92474bcaebce3387bbcbcca8a0", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -27,7 +27,7 @@\n #![allow(unused_attributes)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(specialization)]\n \n use std::cell::{Cell, RefCell};"}, {"sha": "caef808f474ec9553fb436adaa39d402aa57a9ee", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -59,7 +59,7 @@\n #![cfg_attr(windows, feature(libc))]\n // Handle rustfmt skips\n #![feature(custom_attribute)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![allow(unused_attributes)]\n \n use std::io::prelude::*;"}, {"sha": "625666e641c6bed6ece2bda4dd1d3f3983a06f6d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -38,7 +38,7 @@\n #![feature(rustc_private)]\n #![feature(set_stdio)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(panic_unwind)]\n \n extern crate getopts;"}, {"sha": "09538818dcdf9ccf85fc692de32f51bc9e3f43aa", "filename": "src/test/compile-fail/issue-32709.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fissue-32709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fissue-32709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32709.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(question_mark)]\n-\n // Make sure that the span of try shorthand does not include the trailing\n // semicolon;\n fn a() -> Result<i32, ()> {\n-    Err(5)?; //~ ERROR 16:5: 16:12\n+    Err(5)?; //~ ERROR 14:5: 14:12\n     Ok(1)\n }\n "}, {"sha": "87747d2851f5e3aa32fe464d516d91ba5b591b35", "filename": "src/test/compile-fail/issue-33876.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fissue-33876.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fissue-33876.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-33876.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(reflect_marker)]\n-\n-use std::marker::Reflect;\n use std::any::Any;\n \n struct Foo;"}, {"sha": "8381dc34a6a15f695630b44de9be358fdbdfc825", "filename": "src/test/compile-fail/macro-shadowing.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -12,31 +12,28 @@\n \n macro_rules! foo { () => {} }\n macro_rules! macro_one { () => {} }\n+#[macro_use(macro_two)] extern crate two_macros;\n \n macro_rules! m1 { () => {\n     macro_rules! foo { () => {} } //~ ERROR `foo` is already in scope\n-    //~^ NOTE macro-expanded `macro_rules!`s and `#[macro_use]`s may not shadow existing macros\n+    //~^ NOTE macro-expanded `macro_rules!`s may not shadow existing macros\n \n-    #[macro_use] //~ ERROR `macro_one` is already in scope\n-    //~^ NOTE macro-expanded `macro_rules!`s and `#[macro_use]`s may not shadow existing macros\n-    extern crate two_macros;\n+    #[macro_use] //~ ERROR `macro_two` is already in scope\n+    //~^ NOTE macro-expanded `#[macro_use]`s may not shadow existing macros\n+    extern crate two_macros as __;\n }}\n m1!(); //~ NOTE in this expansion\n        //~| NOTE in this expansion\n        //~| NOTE in this expansion\n        //~| NOTE in this expansion\n \n-fn f() { macro_one!(); }\n foo!();\n \n macro_rules! m2 { () => {\n     macro_rules! foo { () => {} }\n-    #[macro_use] extern crate two_macros as __;\n-\n-    fn g() { macro_one!(); }\n     foo!();\n }}\n m2!();\n-//^ Since `foo` and `macro_one` are not used outside this expansion, they are not shadowing errors.\n+//^ Since `foo` is not used outside this expansion, it is not a shadowing error.\n \n fn main() {}"}, {"sha": "9d389413ba9adb0319e964d7cd3fae7bfd883aa6", "filename": "src/test/compile-fail/macro-use-scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmacro-use-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmacro-use-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-scope.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -19,10 +19,10 @@ fn f() {\n #[macro_use(macro_one)] // Check that this macro is usable in the above function\n extern crate two_macros;\n \n+fn g() {\n+    macro_two!();\n+}\n macro_rules! m { () => {\n-    fn g() {\n-        macro_two!();\n-    }\n     #[macro_use(macro_two)] // Check that this macro is usable in the above function\n     extern crate two_macros as _two_macros;\n } }"}, {"sha": "1ba1bb35bb5f3b679eec4f749415025bc347402d", "filename": "src/test/compile-fail/mir-dataflow/def-inits-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Fdef-inits-1.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -11,7 +11,6 @@\n // General test of maybe_uninits state computed by MIR dataflow.\n \n #![feature(rustc_attrs)]\n-#![feature(stmt_expr_attributes)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};"}, {"sha": "c8cf44adb97199d9ad0bafa8595c52254617fd54", "filename": "src/test/compile-fail/mir-dataflow/inits-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Finits-1.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -11,7 +11,6 @@\n // General test of maybe_inits state computed by MIR dataflow.\n \n #![feature(rustc_attrs)]\n-#![feature(stmt_expr_attributes)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};"}, {"sha": "a82bfc896988075ac0a718b75833473ce78d8872", "filename": "src/test/compile-fail/mir-dataflow/uninits-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-1.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -11,7 +11,6 @@\n // General test of maybe_uninits state computed by MIR dataflow.\n \n #![feature(rustc_attrs)]\n-#![feature(stmt_expr_attributes)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};"}, {"sha": "8cfdae506625e3d47d26db6065499f4614b2d6d6", "filename": "src/test/compile-fail/mir-dataflow/uninits-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir-dataflow%2Funinits-2.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -11,7 +11,6 @@\n // General test of maybe_uninits state computed by MIR dataflow.\n \n #![feature(rustc_attrs)]\n-#![feature(stmt_expr_attributes)]\n \n use std::intrinsics::rustc_peek;\n use std::mem::{drop, replace};"}, {"sha": "2fda2ee0900c7470ea82f045817f7cd223e54532", "filename": "src/test/compile-fail/stmt_expr_attrs_no_feature.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -21,15 +21,15 @@ fn main() {\n     #[attr]\n     fn a() {}\n \n-    #[attr] //~ ERROR 15701\n+    #[attr]\n     {\n \n     }\n \n-    #[attr] //~ ERROR 15701\n+    #[attr]\n     5;\n \n-    #[attr] //~ ERROR 15701\n+    #[attr]\n     stmt_mac!();\n }\n \n@@ -43,7 +43,7 @@ fn c() {\n \n #[cfg(not(unset))]\n fn j() {\n-    #[attr] //~ ERROR 15701\n+    #[attr]\n     5;\n }\n \n@@ -55,7 +55,7 @@ fn d() {\n \n #[cfg_attr(not(unset), cfg(not(unset)))]\n fn i() {\n-    #[attr] //~ ERROR 15701\n+    #[attr]\n     8;\n }\n \n@@ -64,7 +64,7 @@ fn i() {\n macro_rules! item_mac {\n     ($e:ident) => {\n         fn $e() {\n-            #[attr] //~ ERROR 15701\n+            #[attr]\n             42;\n \n             #[cfg(unset)]\n@@ -75,7 +75,7 @@ macro_rules! item_mac {\n \n             #[cfg(not(unset))]\n             fn k() {\n-                #[attr] //~ ERROR 15701\n+                #[attr]\n                 5;\n             }\n \n@@ -87,7 +87,7 @@ macro_rules! item_mac {\n \n             #[cfg_attr(not(unset), cfg(not(unset)))]\n             fn h() {\n-                #[attr] //~ ERROR 15701\n+                #[attr]\n                 8;\n             }\n "}, {"sha": "2d79987823f2036c1c944fdd412c6e22b9a39b13", "filename": "src/test/incremental/hashes/struct_defs.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -236,3 +236,74 @@ struct Visibility;\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub struct Visibility;\n+\n+\n+\n+\n+struct ReferencedType1;\n+struct ReferencedType2;\n+\n+// Tuple Struct Change Field Type Indirectly -----------------------------------\n+mod tuple_struct_change_field_type_indirectly {\n+    #[cfg(cfail1)]\n+    use super::ReferencedType1 as FieldType;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedType2 as FieldType;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    struct TupleStruct(FieldType);\n+}\n+\n+\n+// Record Struct Change Field Type Indirectly -----------------------------------\n+mod record_struct_change_field_type_indirectly {\n+    #[cfg(cfail1)]\n+    use super::ReferencedType1 as FieldType;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedType2 as FieldType;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    struct RecordStruct {\n+        _x: FieldType\n+    }\n+}\n+\n+\n+\n+\n+trait ReferencedTrait1 {}\n+trait ReferencedTrait2 {}\n+\n+// Change Trait Bound Indirectly -----------------------------------------------\n+mod change_trait_bound_indirectly {\n+    #[cfg(cfail1)]\n+    use super::ReferencedTrait1 as Trait;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedTrait2 as Trait;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    struct Struct<T: Trait>(T);\n+}\n+\n+// Change Trait Bound Indirectly In Where Clause -------------------------------\n+mod change_trait_bound_indirectly_in_where_clause {\n+    #[cfg(cfail1)]\n+    use super::ReferencedTrait1 as Trait;\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedTrait2 as Trait;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    struct Struct<T>(T) where T : Trait;\n+}"}, {"sha": "9b2e36c8cea15c7c463fd290b355f2639019ca4e", "filename": "src/test/run-pass-fulldeps/macro-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -17,8 +17,8 @@\n #[macro_use] #[no_link]\n extern crate macro_crate_test;\n \n-#[into_multi_foo]\n #[derive(PartialEq, Clone, Debug)]\n+#[into_multi_foo]\n fn foo() -> AnotherFakeTypeThatHadBetterGoAway {}\n \n // Check that the `#[into_multi_foo]`-generated `foo2` is configured away"}, {"sha": "a942adc4c80203d163136ec6f477e6bf8336b8e1", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-atob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -21,6 +21,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert_eq!(input, \"struct A;\\n\");\n+    assert_eq!(input, \"#[derive(Copy, Clone)]\\nstruct A;\\n\");\n     \"struct B;\".parse().unwrap()\n }"}, {"sha": "431c8c5902749f69476e340c74b3f7b1b2db0689", "filename": "src/test/run-pass-fulldeps/proc-macro/load-two.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fload-two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fload-two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fload-two.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -18,6 +18,7 @@ extern crate derive_atob;\n #[macro_use]\n extern crate derive_ctod;\n \n+#[derive(Copy, Clone)]\n #[derive(AToB)]\n struct A;\n "}, {"sha": "a1c9ff8a21edb4b45341181130892a66f50a9e87", "filename": "src/test/run-pass/const-err.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-err.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -17,4 +17,8 @@ const X: *const u8 = b\"\" as _;\n fn main() {\n     let _ = ((-1 as i8) << 8 - 1) as f32;\n     let _ = 0u8 as char;\n+    let _ = true > false;\n+    let _ = true >= false;\n+    let _ = true < false;\n+    let _ = true >= false;\n }"}, {"sha": "012fe0d95ec49c7a554201a1c3c46eba539051d5", "filename": "src/test/run-pass/const-negation.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fconst-negation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-negation.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(stmt_expr_attributes)]\n-\n #[deny(const_err)]\n \n fn main() {"}, {"sha": "c85ab535fc16b4b69e46791149367ad5d60ad714", "filename": "src/test/run-pass/enum-discrim-autosizing.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fenum-discrim-autosizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fenum-discrim-autosizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-autosizing.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(stmt_expr_attributes)]\n-\n use std::mem::size_of;\n \n enum Ei8 {"}, {"sha": "0ebe1ca07c77180259d1b97e61ae3a154a256520", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -14,7 +14,6 @@\n #![allow(unused_must_use)]\n #![allow(unused_features)]\n #![feature(box_syntax)]\n-#![feature(question_mark)]\n \n use std::fmt::{self, Write};\n use std::usize;"}, {"sha": "e9326ed286aff9c49f880c069f1ea6362e1c1932", "filename": "src/test/run-pass/impl-trait/example-st.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-st.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-st.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-st.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(conservative_impl_trait, question_mark)]\n+#![feature(conservative_impl_trait)]\n \n struct State;\n type Error = ();"}, {"sha": "dcbcc2d44b5dd803464e625f0642bd376b10a9d4", "filename": "src/test/run-pass/issue-17121.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-17121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-17121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17121.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -10,8 +10,6 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(question_mark)]\n-\n use std::fs::File;\n use std::io::{self, BufReader, Read};\n "}, {"sha": "c0f13b0b6c7ad35f60f562e26496e0dc2a0da010", "filename": "src/test/run-pass/issue-19404.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-19404.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-19404.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19404.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,17 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(reflect_marker)]\n-\n use std::any::TypeId;\n-use std::marker::Reflect;\n use std::rc::Rc;\n \n type Fp<T> = Rc<T>;\n \n struct Engine;\n \n-trait Component: 'static + Reflect {}\n+trait Component: 'static {}\n impl Component for Engine {}\n \n trait Env {"}, {"sha": "e45582dc2d39a09b11e6c95e4ea11ef5b3368d36", "filename": "src/test/run-pass/issue-20797.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20797.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -10,8 +10,6 @@\n \n // Regression test for #20797.\n \n-#![feature(question_mark)]\n-\n use std::default::Default;\n use std::io;\n use std::fs;"}, {"sha": "6715b71a5f506eb162792c22a5714e1d4e945ec7", "filename": "src/test/run-pass/issue-21400.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-21400.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-21400.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21400.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -11,8 +11,6 @@\n // Regression test for #21400 which itself was extracted from\n // stackoverflow.com/questions/28031155/is-my-borrow-checker-drunk/28031580\n \n-#![feature(question_mark)]\n-\n fn main() {\n     let mut t = Test;\n     assert_eq!(t.method1(\"one\"), Ok(1));"}, {"sha": "7d0d20269aba766253de3c35b3939afab1fa8674", "filename": "src/test/run-pass/issue-37020.rs", "status": "renamed", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-37020.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-37020.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37020.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,11 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! id {\n-    ($e:expr) => { $e }\n+#![allow(private_in_public)]\n+\n+mod foo {\n+    pub mod bar {\n+        extern crate core;\n+    }\n+}\n+\n+mod baz {\n+    pub use foo::bar::core;\n }\n \n fn main() {\n-    id!(x?);  //~ error: the `?` operator is not stable (see issue #31436)\n-    y?;  //~ error: the `?` operator is not stable (see issue #31436)\n+    baz::core::cell::Cell::new(0u32);\n }", "previous_filename": "src/test/compile-fail/feature-gate-try-operator.rs"}, {"sha": "1c893071d558907d175fbfd7c5741aaf7caa70d4", "filename": "src/test/run-pass/issue-37109.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-37109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-37109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37109.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait ToRef<'a> {\n+    type Ref: 'a;\n+}\n+\n+impl<'a, U: 'a> ToRef<'a> for U {\n+    type Ref = &'a U;\n+}\n+\n+fn example<'a, T>(value: &'a T) -> (<T as ToRef<'a>>::Ref, u32) {\n+    (value, 0)\n+}\n+\n+fn main() {\n+    example(&0);\n+}"}, {"sha": "f16057ccab16cbbae5f37db9c44e6c30f457d21b", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -11,7 +11,7 @@\n // ignore-emscripten no threads support\n // ignore-pretty : (#23623) problems when  ending with // comments\n \n-#![feature(rustc_attrs, stmt_expr_attributes, zero_one)]\n+#![feature(rustc_attrs, zero_one)]\n \n use std::num::Zero;\n use std::thread;"}, {"sha": "53d6185020a0235ffb5f16b691780e4d66548f20", "filename": "src/test/run-pass/try-operator-hygiene.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Ftry-operator-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Ftry-operator-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftry-operator-hygiene.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -18,8 +18,6 @@\n // This test verifies that the expansion is hygienic, i.e. it's not affected by other `val` and\n // `err` bindings that may be in scope.\n \n-#![feature(question_mark)]\n-\n use std::num::ParseIntError;\n \n fn main() {"}, {"sha": "29de6364bf14760b6059cc58b143c8c812116919", "filename": "src/test/run-pass/try-operator.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Ftry-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftest%2Frun-pass%2Ftry-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftry-operator.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(question_mark)]\n-\n use std::fs::File;\n use std::io::{Read, self};\n use std::num::ParseIntError;"}, {"sha": "81478c18d7b24ddac0b102c2b4d28a016299dd5e", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -13,7 +13,6 @@\n #![feature(box_syntax)]\n #![feature(rustc_private)]\n #![feature(test)]\n-#![feature(question_mark)]\n #![feature(libc)]\n \n #![deny(warnings)]"}, {"sha": "7bdf1343aa9ccc70a2687c460d1bc081031a0db7", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![feature(rustc_private, rustdoc)]\n-#![feature(question_mark)]\n \n extern crate syntax;\n extern crate rustdoc;"}, {"sha": "f79cc76e67d0045509a8a1520343f12c9288b6d6", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -24,8 +24,6 @@\n //! A few whitelisted exceptions are allowed as there's known bugs in rustdoc,\n //! but this should catch the majority of \"broken link\" cases.\n \n-#![feature(question_mark)]\n-\n extern crate url;\n \n use std::env;"}, {"sha": "906251db1c2f216a4643a5cbd6f15c3b746f2a0d", "filename": "src/tools/rustbook/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftools%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34318dd538bf4c9175e4138b3e4188ea8211620/src%2Ftools%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2Fmain.rs?ref=d34318dd538bf4c9175e4138b3e4188ea8211620", "patch": "@@ -12,7 +12,6 @@\n \n #![feature(rustc_private)]\n #![feature(rustdoc)]\n-#![feature(question_mark)]\n \n extern crate rustdoc;\n extern crate rustc_back;"}]}