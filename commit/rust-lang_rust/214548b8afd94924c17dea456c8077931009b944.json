{"sha": "214548b8afd94924c17dea456c8077931009b944", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNDU0OGI4YWZkOTQ5MjRjMTdkZWE0NTZjODA3NzkzMTAwOWI5NDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-30T02:05:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-30T02:05:24Z"}, "message": "Auto merge of #67631 - oli-obk:polymorphic_promotion, r=wesleywiser\n\nWork around a resolve bug in const prop\n\nr? @wesleywiser @anp\n\nThis isn't exposed right now, but further changes to rustc may start causing bugs without this.", "tree": {"sha": "9480be2547ff446587c3f0ed078b4127a6db9398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9480be2547ff446587c3f0ed078b4127a6db9398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/214548b8afd94924c17dea456c8077931009b944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/214548b8afd94924c17dea456c8077931009b944", "html_url": "https://github.com/rust-lang/rust/commit/214548b8afd94924c17dea456c8077931009b944", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/214548b8afd94924c17dea456c8077931009b944/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ba0d2acbd6cb01fb07619628882120d5b66bd59", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba0d2acbd6cb01fb07619628882120d5b66bd59", "html_url": "https://github.com/rust-lang/rust/commit/2ba0d2acbd6cb01fb07619628882120d5b66bd59"}, {"sha": "5fd8abd2278624dd7e3b08a46a5599850c81b40d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fd8abd2278624dd7e3b08a46a5599850c81b40d", "html_url": "https://github.com/rust-lang/rust/commit/5fd8abd2278624dd7e3b08a46a5599850c81b40d"}], "stats": {"total": 256, "additions": 223, "deletions": 33}, "files": [{"sha": "c593a51e457b8179d2dc027ad2da1ddf8bcc6834", "filename": "src/librustc/mir/interpret/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fqueries.rs?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -18,7 +18,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let substs = InternalSubsts::identity_for_item(self, def_id);\n         let instance = ty::Instance::new(def_id, substs);\n         let cid = GlobalId { instance, promoted: None };\n-        let param_env = self.param_env(def_id);\n+        let param_env = self.param_env(def_id).with_reveal_all();\n         self.const_eval_validated(param_env.and(cid))\n     }\n "}, {"sha": "bcb012ea51494e3e8fb740958d7e67dd901f39ff", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -1028,6 +1028,9 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // In either case, we handle this by not adding a\n                 // candidate for an impl if it contains a `default`\n                 // type.\n+                //\n+                // NOTE: This should be kept in sync with the similar code in\n+                // `rustc::ty::instance::resolve_associated_item()`.\n                 let node_item =\n                     assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id);\n "}, {"sha": "cfd1779c080ecc3388671479a5378c71fbf30207", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -346,6 +346,25 @@ fn resolve_associated_item<'tcx>(\n         traits::VtableImpl(impl_data) => {\n             let (def_id, substs) =\n                 traits::find_associated_item(tcx, param_env, trait_item, rcvr_substs, &impl_data);\n+\n+            let resolved_item = tcx.associated_item(def_id);\n+\n+            // Since this is a trait item, we need to see if the item is either a trait default item\n+            // or a specialization because we can't resolve those unless we can `Reveal::All`.\n+            // NOTE: This should be kept in sync with the similar code in\n+            // `rustc::traits::project::assemble_candidates_from_impls()`.\n+            let eligible = if !resolved_item.defaultness.is_default() {\n+                true\n+            } else if param_env.reveal == traits::Reveal::All {\n+                !trait_ref.needs_subst()\n+            } else {\n+                false\n+            };\n+\n+            if !eligible {\n+                return None;\n+            }\n+\n             let substs = tcx.erase_regions(&substs);\n             Some(ty::Instance::new(def_id, substs))\n         }"}, {"sha": "6c4b69d9d767e3eb32c604a1c5724e05904115c7", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -212,11 +212,7 @@ pub fn const_eval_validated_provider<'tcx>(\n         key.param_env.reveal = Reveal::UserFacing;\n         match tcx.const_eval_validated(key) {\n             // try again with reveal all as requested\n-            Err(ErrorHandled::TooGeneric) => {\n-                // Promoteds should never be \"too generic\" when getting evaluated.\n-                // They either don't get evaluated, or we are in a monomorphic context\n-                assert!(key.value.promoted.is_none());\n-            }\n+            Err(ErrorHandled::TooGeneric) => {}\n             // dedupliate calls\n             other => return other,\n         }\n@@ -301,10 +297,18 @@ pub fn const_eval_raw_provider<'tcx>(\n                 // Ensure that if the above error was either `TooGeneric` or `Reported`\n                 // an error must be reported.\n                 let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n-                tcx.sess.delay_span_bug(\n-                    err.span,\n-                    &format!(\"static eval failure did not emit an error: {:#?}\", v),\n-                );\n+\n+                // If this is `Reveal:All`, then we need to make sure an error is reported but if\n+                // this is `Reveal::UserFacing`, then it's expected that we could get a\n+                // `TooGeneric` error. When we fall back to `Reveal::All`, then it will either\n+                // succeed or we'll report this error then.\n+                if key.param_env.reveal == Reveal::All {\n+                    tcx.sess.delay_span_bug(\n+                        err.span,\n+                        &format!(\"static eval failure did not emit an error: {:#?}\", v),\n+                    );\n+                }\n+\n                 v\n             } else if def_id.is_local() {\n                 // constant defined in this crate, we can figure out a lint level!"}, {"sha": "3c0bdd00391c549f6ce703fbb8f2eee4a39f4449", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -742,7 +742,13 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         let kind = match res {\n             Res::Def(DefKind::Const, def_id) | Res::Def(DefKind::AssocConst, def_id) => {\n                 let substs = self.tables.node_substs(id);\n-                match self.tcx.const_eval_resolve(self.param_env, def_id, substs, Some(span)) {\n+                // Use `Reveal::All` here because patterns are always monomorphic even if their function isn't.\n+                match self.tcx.const_eval_resolve(\n+                    self.param_env.with_reveal_all(),\n+                    def_id,\n+                    substs,\n+                    Some(span),\n+                ) {\n                     Ok(value) => {\n                         let pattern = self.const_to_pat(value, id, span);\n                         if !is_associated_const {"}, {"sha": "c36f7935115536b22d53c7529b39ebe8928b324a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -6,6 +6,7 @@ use std::cell::Cell;\n \n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::HirId;\n use rustc::mir::interpret::{InterpResult, PanicInfo, Scalar};\n use rustc::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n@@ -20,7 +21,7 @@ use rustc::ty::layout::{\n     HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyLayout,\n };\n use rustc::ty::subst::InternalSubsts;\n-use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n+use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n use syntax::ast::Mutability;\n@@ -260,6 +261,9 @@ struct ConstPropagator<'mir, 'tcx> {\n     source_scopes: IndexVec<SourceScope, SourceScopeData>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     ret: Option<OpTy<'tcx, ()>>,\n+    // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n+    // the last known `SourceInfo` here and just keep revisiting it.\n+    source_info: Option<SourceInfo>,\n }\n \n impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n@@ -293,13 +297,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'mir, 'tcx> {\n         let def_id = source.def_id();\n-        let param_env = tcx.param_env(def_id);\n+        let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n+        let mut param_env = tcx.param_env(def_id);\n+\n+        // If we're evaluating inside a monomorphic function, then use `Reveal::All` because\n+        // we want to see the same instances that codegen will see. This allows us to `resolve()`\n+        // specializations.\n+        if !substs.needs_subst() {\n+            param_env = param_env.with_reveal_all();\n+        }\n+\n         let span = tcx.def_span(def_id);\n         let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n         let can_const_prop = CanConstProp::check(body);\n \n-        let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n-\n         let ret = ecx\n             .layout_of(body.return_ty().subst(tcx, substs))\n             .ok()\n@@ -331,6 +342,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n             ret: ret.map(Into::into),\n+            source_info: None,\n         }\n     }\n \n@@ -352,6 +364,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) };\n     }\n \n+    fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n+        match &self.source_scopes[source_info.scope].local_data {\n+            ClearCrossCrate::Set(data) => Some(data.lint_root),\n+            ClearCrossCrate::Clear => None,\n+        }\n+    }\n+\n     fn use_ecx<F, T>(&mut self, source_info: SourceInfo, f: F) -> Option<T>\n     where\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n@@ -360,10 +379,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         // FIXME(eddyb) move this to the `Panic(_)` error case, so that\n         // `f(self)` is always called, and that the only difference when the\n         // scope's `local_data` is missing, is that the lint isn't emitted.\n-        let lint_root = match &self.source_scopes[source_info.scope].local_data {\n-            ClearCrossCrate::Set(data) => data.lint_root,\n-            ClearCrossCrate::Clear => return None,\n-        };\n+        let lint_root = self.lint_root(source_info)?;\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n@@ -409,13 +425,31 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         r\n     }\n \n-    fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<Const<'tcx>> {\n+    fn eval_constant(\n+        &mut self,\n+        c: &Constant<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = c.span;\n         match self.ecx.eval_const_to_op(c.literal, None) {\n             Ok(op) => Some(op),\n             Err(error) => {\n                 let err = error_to_const_error(&self.ecx, error);\n-                err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                match self.lint_root(source_info) {\n+                    Some(lint_root) if c.literal.needs_subst() => {\n+                        // Out of backwards compatibility we cannot report hard errors in unused\n+                        // generic functions using associated constants of the generic parameters.\n+                        err.report_as_lint(\n+                            self.ecx.tcx,\n+                            \"erroneous constant used\",\n+                            lint_root,\n+                            Some(c.span),\n+                        );\n+                    }\n+                    _ => {\n+                        err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n+                    }\n+                }\n                 None\n             }\n         }\n@@ -428,7 +462,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c),\n+            Operand::Constant(ref c) => self.eval_constant(c, source_info),\n             Operand::Move(ref place) | Operand::Copy(ref place) => {\n                 self.eval_place(place, source_info)\n             }\n@@ -495,10 +529,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     let right_size = r.layout.size;\n                     let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n                     if r_bits.map_or(false, |b| b >= left_bits as u128) {\n-                        let lint_root = match &self.source_scopes[source_info.scope].local_data {\n-                            ClearCrossCrate::Set(data) => data.lint_root,\n-                            ClearCrossCrate::Clear => return None,\n-                        };\n+                        let lint_root = self.lint_root(source_info)?;\n                         let dir = if *op == BinOp::Shr { \"right\" } else { \"left\" };\n                         self.tcx.lint_hir(\n                             ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n@@ -748,18 +779,19 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     fn visit_constant(&mut self, constant: &mut Constant<'tcx>, location: Location) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n-        self.eval_constant(constant);\n+        self.eval_constant(constant, self.source_info.unwrap());\n     }\n \n     fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n+        let source_info = statement.source_info;\n+        self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (ref place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(local) = place.as_local() {\n-                    let source = statement.source_info;\n                     let can_const_prop = self.can_const_prop[local];\n-                    if let Some(()) = self.const_prop(rval, place_layout, source, place) {\n+                    if let Some(()) = self.const_prop(rval, place_layout, source_info, place) {\n                         if can_const_prop == ConstPropMode::FullConstProp\n                             || can_const_prop == ConstPropMode::OnlyPropagateInto\n                         {\n@@ -802,8 +834,9 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n     }\n \n     fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n-        self.super_terminator(terminator, location);\n         let source_info = terminator.source_info;\n+        self.source_info = Some(source_info);\n+        self.super_terminator(terminator, location);\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref msg, ref mut cond, .. } => {\n                 if let Some(value) = self.eval_operand(&cond, source_info) {"}, {"sha": "98cd34177096569015fbe45df43ade961b805f62", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -8,8 +8,8 @@ use rustc_index::vec::{Idx, IndexVec};\n \n use rustc::mir::visit::*;\n use rustc::mir::*;\n-use rustc::ty::subst::{Subst, SubstsRef};\n-use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n+use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n use crate::transform::{MirPass, MirSource};\n@@ -66,7 +66,14 @@ impl Inliner<'tcx> {\n \n         let mut callsites = VecDeque::new();\n \n-        let param_env = self.tcx.param_env(self.source.def_id());\n+        let mut param_env = self.tcx.param_env(self.source.def_id());\n+\n+        let substs = &InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n+\n+        // For monomorphic functions, we can use `Reveal::All` to resolve specialized instances.\n+        if !substs.needs_subst() {\n+            param_env = param_env.with_reveal_all();\n+        }\n \n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();"}, {"sha": "9591019bb4f70670f84d2cae174d9ce7a8cef9e6", "filename": "src/test/mir-opt/inline/inline-specialization.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Ftest%2Fmir-opt%2Finline%2Finline-specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Ftest%2Fmir-opt%2Finline%2Finline-specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-specialization.rs?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -0,0 +1,48 @@\n+#![feature(specialization)]\n+\n+fn main() {\n+    let x = <Vec::<()> as Foo>::bar();\n+}\n+\n+trait Foo {\n+    fn bar() -> u32;\n+}\n+\n+impl<T> Foo for Vec<T> {\n+    #[inline(always)]\n+    default fn bar() -> u32 { 123 }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.Inline.before.mir\n+// let mut _0: ();\n+// let _1: u32;\n+// scope 1 {\n+//   debug x => _1;\n+// }\n+// bb0: {\n+//   StorageLive(_1);\n+//   _1 = const <std::vec::Vec<()> as Foo>::bar() -> bb1;\n+// }\n+// bb1: {\n+//   _0 = ();\n+//   StorageDead(_1);\n+//   return;\n+// }\n+// END rustc.main.Inline.before.mir\n+// START rustc.main.Inline.after.mir\n+// let mut _0: ();\n+// let _1: u32;\n+// scope 1 {\n+//   debug x => _1;\n+// }\n+// scope 2 {\n+// }\n+// bb0: {\n+//   StorageLive(_1);\n+//   _1 = const 123u32;\n+//   _0 = ();\n+//   StorageDead(_1);\n+//   return;\n+// }\n+// END rustc.main.Inline.after.mir"}, {"sha": "8010d2fe1aee933983eb901a15c14c686385e70a", "filename": "src/test/ui/consts/trait_specialization.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Ftest%2Fui%2Fconsts%2Ftrait_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Ftest%2Fui%2Fconsts%2Ftrait_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftrait_specialization.rs?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -0,0 +1,65 @@\n+// ignore-wasm32-bare which doesn't support `std::process:exit()`\n+// compile-flags: -Zmir-opt-level=2\n+// run-pass\n+\n+// Tests that specialization does not cause optimizations running on polymorphic MIR to resolve\n+// to a `default` implementation.\n+\n+#![feature(specialization)]\n+\n+trait Marker {}\n+\n+trait SpecializedTrait {\n+    const CONST_BOOL: bool;\n+    const CONST_STR: &'static str;\n+    fn method() -> &'static str;\n+}\n+impl <T> SpecializedTrait for T {\n+    default const CONST_BOOL: bool = false;\n+    default const CONST_STR: &'static str = \"in default impl\";\n+    #[inline(always)]\n+    default fn method() -> &'static str {\n+        \"in default impl\"\n+    }\n+}\n+impl <T: Marker> SpecializedTrait for T {\n+    const CONST_BOOL: bool = true;\n+    const CONST_STR: &'static str = \"in specialized impl\";\n+    fn method() -> &'static str {\n+        \"in specialized impl\"\n+    }\n+}\n+\n+fn const_bool<T>() -> &'static str {\n+    if <T as SpecializedTrait>::CONST_BOOL {\n+        \"in specialized impl\"\n+    } else {\n+        \"in default impl\"\n+    }\n+}\n+fn const_str<T>() -> &'static str {\n+    <T as SpecializedTrait>::CONST_STR\n+}\n+fn run_method<T>() -> &'static str {\n+    <T as SpecializedTrait>::method()\n+}\n+\n+struct TypeA;\n+impl Marker for TypeA {}\n+struct TypeB;\n+\n+#[inline(never)]\n+fn exit_if_not_eq(left: &str, right: &str) {\n+    if left != right {\n+        std::process::exit(1);\n+    }\n+}\n+\n+pub fn main() {\n+    exit_if_not_eq(\"in specialized impl\", const_bool::<TypeA>());\n+    exit_if_not_eq(\"in default impl\", const_bool::<TypeB>());\n+    exit_if_not_eq(\"in specialized impl\", const_str::<TypeA>());\n+    exit_if_not_eq(\"in default impl\", const_str::<TypeB>());\n+    exit_if_not_eq(\"in specialized impl\", run_method::<TypeA>());\n+    exit_if_not_eq(\"in default impl\", run_method::<TypeB>());\n+}"}, {"sha": "db535b53fcf3743aa727baca240afca29f822e5d", "filename": "src/test/ui/type-alias-enum-variants/self-in-enum-definition.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/214548b8afd94924c17dea456c8077931009b944/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/214548b8afd94924c17dea456c8077931009b944/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fself-in-enum-definition.stderr?ref=214548b8afd94924c17dea456c8077931009b944", "patch": "@@ -4,6 +4,11 @@ error[E0391]: cycle detected when const-evaluating + checking `Alpha::V3::{{cons\n LL |     V3 = Self::V1 {} as u8 + 2,\n    |          ^^^^^^^^\n    |\n+note: ...which requires const-evaluating + checking `Alpha::V3::{{constant}}#0`...\n+  --> $DIR/self-in-enum-definition.rs:5:10\n+   |\n+LL |     V3 = Self::V1 {} as u8 + 2,\n+   |          ^^^^^^^^\n note: ...which requires const-evaluating `Alpha::V3::{{constant}}#0`...\n   --> $DIR/self-in-enum-definition.rs:5:10\n    |"}]}