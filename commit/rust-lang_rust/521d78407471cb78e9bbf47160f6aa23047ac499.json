{"sha": "521d78407471cb78e9bbf47160f6aa23047ac499", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMWQ3ODQwNzQ3MWNiNzhlOWJiZjQ3MTYwZjZhYTIzMDQ3YWM0OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-25T19:20:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-25T19:20:20Z"}, "message": "Auto merge of #61613 - sinkuu:impl_trait_inline, r=ollie27\n\nSupport `impl Trait` in inlined documentation\n\n`impl Trait` in argument position was not properly rendered when inlined from other crates. ([a live example on docs.rs](https://docs.rs/libp2p/0.8.1/libp2p/floodsub/struct.Floodsub.html#method.unsubscribe))\n\n![old](https://user-images.githubusercontent.com/7091080/59089838-14ba9900-8946-11e9-830b-53b317bdecb4.png)\n\u2193\n![new](https://user-images.githubusercontent.com/7091080/59089844-16845c80-8946-11e9-9fe3-8998af9d73ce.png)", "tree": {"sha": "67a4c4b1d529c76a3c9daa0e3a06a60256dafa26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67a4c4b1d529c76a3c9daa0e3a06a60256dafa26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/521d78407471cb78e9bbf47160f6aa23047ac499", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/521d78407471cb78e9bbf47160f6aa23047ac499", "html_url": "https://github.com/rust-lang/rust/commit/521d78407471cb78e9bbf47160f6aa23047ac499", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/521d78407471cb78e9bbf47160f6aa23047ac499/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1522e6023d80faf8ea334ef50ef05528ed806bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1522e6023d80faf8ea334ef50ef05528ed806bc", "html_url": "https://github.com/rust-lang/rust/commit/b1522e6023d80faf8ea334ef50ef05528ed806bc"}, {"sha": "1fe6160c7e4b584795c66f21683064f62803acf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe6160c7e4b584795c66f21683064f62803acf0", "html_url": "https://github.com/rust-lang/rust/commit/1fe6160c7e4b584795c66f21683064f62803acf0"}], "stats": {"total": 331, "additions": 264, "deletions": 67}, "files": [{"sha": "bcabefa51fab1eb6b985cf7f9ae5ab5870483659", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=521d78407471cb78e9bbf47160f6aa23047ac499", "patch": "@@ -217,8 +217,9 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     };\n \n     let predicates = cx.tcx.predicates_of(did);\n-    let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n-    let decl = (did, sig).clean(cx);\n+    let (generics, decl) = clean::enter_impl_trait(cx, || {\n+        ((cx.tcx.generics_of(did), &predicates).clean(cx), (did, sig).clean(cx))\n+    });\n     let (all_types, ret_types) = clean::get_all_types(&generics, &decl, cx);\n     clean::Function {\n         decl,\n@@ -372,7 +373,9 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>,\n                     None\n                 }\n             }).collect::<Vec<_>>(),\n-            (tcx.generics_of(did), &predicates).clean(cx),\n+            clean::enter_impl_trait(cx, || {\n+                (tcx.generics_of(did), &predicates).clean(cx)\n+            }),\n         )\n     };\n     let polarity = tcx.impl_polarity(did);"}, {"sha": "ba792a413b3c44a1f0840d694b43d2e59251c244", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 135, "deletions": 17, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=521d78407471cb78e9bbf47160f6aa23047ac499", "patch": "@@ -45,7 +45,7 @@ use std::cell::RefCell;\n use std::sync::Arc;\n use std::u32;\n \n-use crate::core::{self, DocContext};\n+use crate::core::{self, DocContext, ImplTraitParam};\n use crate::doctree;\n use crate::html::render::{cache, ExternalLocation};\n use crate::html::item_type::ItemType;\n@@ -1540,7 +1540,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n             ty::GenericParamDefKind::Lifetime => {\n                 (self.name.to_string(), GenericParamDefKind::Lifetime)\n             }\n-            ty::GenericParamDefKind::Type { has_default, .. } => {\n+            ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n                 cx.renderinfo.borrow_mut().external_param_names\n                              .insert(self.def_id, self.name.clean(cx));\n                 let default = if has_default {\n@@ -1552,7 +1552,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n                     did: self.def_id,\n                     bounds: vec![], // These are filled in from the where-clauses.\n                     default,\n-                    synthetic: None,\n+                    synthetic,\n                 })\n             }\n             ty::GenericParamDefKind::Const { .. } => {\n@@ -1641,7 +1641,7 @@ impl Clean<Generics> for hir::Generics {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => unreachable!(),\n                     GenericParamDefKind::Type { did, ref bounds, .. } => {\n-                        cx.impl_trait_bounds.borrow_mut().insert(did, bounds.clone());\n+                        cx.impl_trait_bounds.borrow_mut().insert(did.into(), bounds.clone());\n                     }\n                     GenericParamDefKind::Const { .. } => unreachable!(),\n                 }\n@@ -1693,26 +1693,123 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                                     &'a &'tcx ty::GenericPredicates<'tcx>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Generics {\n         use self::WherePredicate as WP;\n+        use std::collections::BTreeMap;\n \n         let (gens, preds) = *self;\n \n+        // Don't populate `cx.impl_trait_bounds` before `clean`ning `where` clauses,\n+        // since `Clean for ty::Predicate` would consume them.\n+        let mut impl_trait = BTreeMap::<ImplTraitParam, Vec<GenericBound>>::default();\n+\n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens.params.iter().filter_map(|param| match param.kind {\n-            ty::GenericParamDefKind::Lifetime => None,\n-            ty::GenericParamDefKind::Type { .. } => {\n-                if param.name.as_symbol() == kw::SelfUpper {\n-                    assert_eq!(param.index, 0);\n-                    return None;\n+        let stripped_typarams = gens.params.iter()\n+            .filter_map(|param| match param.kind {\n+                ty::GenericParamDefKind::Lifetime => None,\n+                ty::GenericParamDefKind::Type { synthetic, .. } => {\n+                    if param.name.as_symbol() == kw::SelfUpper {\n+                        assert_eq!(param.index, 0);\n+                        return None;\n+                    }\n+                    if synthetic == Some(hir::SyntheticTyParamKind::ImplTrait) {\n+                        impl_trait.insert(param.index.into(), vec![]);\n+                        return None;\n+                    }\n+                    Some(param.clean(cx))\n+                }\n+                ty::GenericParamDefKind::Const { .. } => None,\n+            }).collect::<Vec<GenericParamDef>>();\n+\n+        // param index -> [(DefId of trait, associated type name, type)]\n+        let mut impl_trait_proj =\n+            FxHashMap::<u32, Vec<(DefId, String, Ty<'tcx>)>>::default();\n+\n+        let where_predicates = preds.predicates.iter()\n+            .flat_map(|(p, _)| {\n+                let mut projection = None;\n+                let param_idx = (|| {\n+                    if let Some(trait_ref) = p.to_opt_poly_trait_ref() {\n+                        if let ty::Param(param) = trait_ref.self_ty().sty {\n+                            return Some(param.index);\n+                        }\n+                    } else if let Some(outlives) = p.to_opt_type_outlives() {\n+                        if let ty::Param(param) = outlives.skip_binder().0.sty {\n+                            return Some(param.index);\n+                        }\n+                    } else if let ty::Predicate::Projection(p) = p {\n+                        if let ty::Param(param) = p.skip_binder().projection_ty.self_ty().sty {\n+                            projection = Some(p);\n+                            return Some(param.index);\n+                        }\n+                    }\n+\n+                    None\n+                })();\n+\n+                if let Some(param_idx) = param_idx {\n+                    if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n+                        let p = p.clean(cx)?;\n+\n+                        b.extend(\n+                            p.get_bounds()\n+                                .into_iter()\n+                                .flatten()\n+                                .cloned()\n+                                .filter(|b| !b.is_sized_bound(cx))\n+                        );\n+\n+                        let proj = projection\n+                            .map(|p| (p.skip_binder().projection_ty.clean(cx), p.skip_binder().ty));\n+                        if let Some(((_, trait_did, name), rhs)) =\n+                            proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n+                        {\n+                            impl_trait_proj\n+                                .entry(param_idx)\n+                                .or_default()\n+                                .push((trait_did, name.to_string(), rhs));\n+                        }\n+\n+                        return None;\n+                    }\n+                }\n+\n+                Some(p)\n+            })\n+            .collect::<Vec<_>>();\n+\n+        for (param, mut bounds) in impl_trait {\n+            // Move trait bounds to the front.\n+            bounds.sort_by_key(|b| if let GenericBound::TraitBound(..) = b {\n+                false\n+            } else {\n+                true\n+            });\n+\n+            if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n+                if let Some(proj) = impl_trait_proj.remove(&idx) {\n+                    for (trait_did, name, rhs) in proj {\n+                        simplify::merge_bounds(\n+                            cx,\n+                            &mut bounds,\n+                            trait_did,\n+                            &name,\n+                            &rhs.clean(cx),\n+                        );\n+                    }\n                 }\n-                Some(param.clean(cx))\n+            } else {\n+                unreachable!();\n             }\n-            ty::GenericParamDefKind::Const { .. } => None,\n-        }).collect::<Vec<GenericParamDef>>();\n \n-        let mut where_predicates = preds.predicates.iter()\n-            .flat_map(|(p, _)| p.clean(cx))\n+            cx.impl_trait_bounds.borrow_mut().insert(param, bounds);\n+        }\n+\n+        // Now that `cx.impl_trait_bounds` is populated, we can process\n+        // remaining predicates which could contain `impl Trait`.\n+        let mut where_predicates = where_predicates\n+            .into_iter()\n+            .flat_map(|p| p.clean(cx))\n             .collect::<Vec<_>>();\n \n         // Type parameters and have a Sized bound by default unless removed with\n@@ -2613,6 +2710,21 @@ impl Type {\n             _ => false,\n         }\n     }\n+\n+    pub fn projection(&self) -> Option<(&Type, DefId, &str)> {\n+        let (self_, trait_, name) = match self {\n+            QPath { ref self_type, ref trait_, ref name } => {\n+                (self_type, trait_, name)\n+            }\n+            _ => return None,\n+        };\n+        let trait_did = match **trait_ {\n+            ResolvedPath { did, .. } => did,\n+            _ => return None,\n+        };\n+        Some((&self_, trait_did, name))\n+    }\n+\n }\n \n impl GetDefId for Type {\n@@ -2791,7 +2903,7 @@ impl Clean<Type> for hir::Ty {\n                     if let Some(new_ty) = cx.ty_substs.borrow().get(&did).cloned() {\n                         return new_ty;\n                     }\n-                    if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did) {\n+                    if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did.into()) {\n                         return ImplTrait(bounds);\n                     }\n                 }\n@@ -3082,7 +3194,13 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n             ty::Projection(ref data) => data.clean(cx),\n \n-            ty::Param(ref p) => Generic(p.name.to_string()),\n+            ty::Param(ref p) => {\n+                if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&p.index.into()) {\n+                    ImplTrait(bounds)\n+                } else {\n+                    Generic(p.name.to_string())\n+                }\n+            }\n \n             ty::Opaque(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,"}, {"sha": "8758ab19691163ab4f93e847ed21d0c31d08b459", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=521d78407471cb78e9bbf47160f6aa23047ac499", "patch": "@@ -53,58 +53,21 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     // Look for equality predicates on associated types that can be merged into\n     // general bound predicates\n     equalities.retain(|&(ref lhs, ref rhs)| {\n-        let (self_, trait_, name) = match *lhs {\n-            clean::QPath { ref self_type, ref trait_, ref name } => {\n-                (self_type, trait_, name)\n-            }\n-            _ => return true,\n-        };\n-        let generic = match **self_ {\n-            clean::Generic(ref s) => s,\n-            _ => return true,\n+        let (self_, trait_did, name) = if let Some(p) = lhs.projection() {\n+            p\n+        } else {\n+            return true;\n         };\n-        let trait_did = match **trait_ {\n-            clean::ResolvedPath { did, .. } => did,\n+        let generic = match self_ {\n+            clean::Generic(s) => s,\n             _ => return true,\n         };\n         let bounds = match params.get_mut(generic) {\n             Some(bound) => bound,\n             None => return true,\n         };\n-        !bounds.iter_mut().any(|b| {\n-            let trait_ref = match *b {\n-                clean::GenericBound::TraitBound(ref mut tr, _) => tr,\n-                clean::GenericBound::Outlives(..) => return false,\n-            };\n-            let (did, path) = match trait_ref.trait_ {\n-                clean::ResolvedPath { did, ref mut path, ..} => (did, path),\n-                _ => return false,\n-            };\n-            // If this QPath's trait `trait_did` is the same as, or a supertrait\n-            // of, the bound's trait `did` then we can keep going, otherwise\n-            // this is just a plain old equality bound.\n-            if !trait_is_same_or_supertrait(cx, did, trait_did) {\n-                return false\n-            }\n-            let last = path.segments.last_mut().expect(\"segments were empty\");\n-            match last.args {\n-                PP::AngleBracketed { ref mut bindings, .. } => {\n-                    bindings.push(clean::TypeBinding {\n-                        name: name.clone(),\n-                        kind: clean::TypeBindingKind::Equality {\n-                            ty: rhs.clone(),\n-                        },\n-                    });\n-                }\n-                PP::Parenthesized { ref mut output, .. } => {\n-                    assert!(output.is_none());\n-                    if *rhs != clean::Type::Tuple(Vec::new()) {\n-                        *output = Some(rhs.clone());\n-                    }\n-                }\n-            };\n-            true\n-        })\n+\n+        merge_bounds(cx, bounds, trait_did, name, rhs)\n     });\n \n     // And finally, let's reassemble everything\n@@ -127,6 +90,49 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     clauses\n }\n \n+pub fn merge_bounds(\n+    cx: &clean::DocContext<'_>,\n+    bounds: &mut Vec<clean::GenericBound>,\n+    trait_did: DefId,\n+    name: &str,\n+    rhs: &clean::Type,\n+) -> bool {\n+    !bounds.iter_mut().any(|b| {\n+        let trait_ref = match *b {\n+            clean::GenericBound::TraitBound(ref mut tr, _) => tr,\n+            clean::GenericBound::Outlives(..) => return false,\n+        };\n+        let (did, path) = match trait_ref.trait_ {\n+            clean::ResolvedPath { did, ref mut path, ..} => (did, path),\n+            _ => return false,\n+        };\n+        // If this QPath's trait `trait_did` is the same as, or a supertrait\n+        // of, the bound's trait `did` then we can keep going, otherwise\n+        // this is just a plain old equality bound.\n+        if !trait_is_same_or_supertrait(cx, did, trait_did) {\n+            return false\n+        }\n+        let last = path.segments.last_mut().expect(\"segments were empty\");\n+        match last.args {\n+            PP::AngleBracketed { ref mut bindings, .. } => {\n+                bindings.push(clean::TypeBinding {\n+                    name: name.to_string(),\n+                    kind: clean::TypeBindingKind::Equality {\n+                        ty: rhs.clone(),\n+                    },\n+                });\n+            }\n+            PP::Parenthesized { ref mut output, .. } => {\n+                assert!(output.is_none());\n+                if *rhs != clean::Type::Tuple(Vec::new()) {\n+                    *output = Some(rhs.clone());\n+                }\n+            }\n+        };\n+        true\n+    })\n+}\n+\n pub fn ty_params(mut params: Vec<clean::GenericParamDef>) -> Vec<clean::GenericParamDef> {\n     for param in &mut params {\n         match param.kind {"}, {"sha": "04e69613d4b0f145daf8f465ded97b33f6ced855", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=521d78407471cb78e9bbf47160f6aa23047ac499", "patch": "@@ -61,8 +61,8 @@ pub struct DocContext<'tcx> {\n     pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n     /// Table `DefId` of const parameter -> substituted const\n     pub ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n-    /// Table DefId of `impl Trait` in argument position -> bounds\n-    pub impl_trait_bounds: RefCell<FxHashMap<DefId, Vec<clean::GenericBound>>>,\n+    /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n+    pub impl_trait_bounds: RefCell<FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>>,\n     pub fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n     pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n@@ -459,3 +459,23 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         })\n     })\n }\n+\n+/// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter\n+/// for `impl Trait` in argument position.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum ImplTraitParam {\n+    DefId(DefId),\n+    ParamIndex(u32),\n+}\n+\n+impl From<DefId> for ImplTraitParam {\n+    fn from(did: DefId) -> Self {\n+        ImplTraitParam::DefId(did)\n+    }\n+}\n+\n+impl From<u32> for ImplTraitParam {\n+    fn from(idx: u32) -> Self {\n+        ImplTraitParam::ParamIndex(idx)\n+    }\n+}"}, {"sha": "21c733a9bc98e8d4f799390ff93f41aa9af6bd3a", "filename": "src/test/rustdoc/inline_cross/auxiliary/impl_trait_aux.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fimpl_trait_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fimpl_trait_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fimpl_trait_aux.rs?ref=521d78407471cb78e9bbf47160f6aa23047ac499", "patch": "@@ -0,0 +1,18 @@\n+use std::ops::Deref;\n+\n+pub fn func<'a>(_x: impl Clone + Into<Vec<u8>> + 'a) {}\n+\n+pub fn func2<T>(\n+    _x: impl Deref<Target = Option<T>> + Iterator<Item = T>,\n+    _y: impl Iterator<Item = u8>,\n+) {}\n+\n+pub fn func3(_x: impl Iterator<Item = impl Iterator<Item = u8>> + Clone) {}\n+\n+pub fn func4<T: Iterator<Item = impl Clone>>(_x: T) {}\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn method<'a>(_x: impl Clone + Into<Vec<u8>> + 'a) {}\n+}"}, {"sha": "b1e3f8d145b5f2c203a2c6a0302d04836d9c4175", "filename": "src/test/rustdoc/inline_cross/impl_trait.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521d78407471cb78e9bbf47160f6aa23047ac499/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fimpl_trait.rs?ref=521d78407471cb78e9bbf47160f6aa23047ac499", "patch": "@@ -0,0 +1,32 @@\n+// aux-build:impl_trait_aux.rs\n+\n+extern crate impl_trait_aux;\n+\n+// @has impl_trait/fn.func.html\n+// @has - '//pre[@class=\"rust fn\"]' \"pub fn func<'a>(_x: impl Clone + Into<Vec<u8>> + 'a)\"\n+// @!has - '//pre[@class=\"rust fn\"]' 'where'\n+pub use impl_trait_aux::func;\n+\n+// @has impl_trait/fn.func2.html\n+// @has - '//pre[@class=\"rust fn\"]' \"func2<T>(\"\n+// @has - '//pre[@class=\"rust fn\"]' \"_x: impl Deref<Target = Option<T>> + Iterator<Item = T>,\"\n+// @has - '//pre[@class=\"rust fn\"]' \"_y: impl Iterator<Item = u8>)\"\n+// @!has - '//pre[@class=\"rust fn\"]' 'where'\n+pub use impl_trait_aux::func2;\n+\n+// @has impl_trait/fn.func3.html\n+// @has - '//pre[@class=\"rust fn\"]' \"func3(\"\n+// @has - '//pre[@class=\"rust fn\"]' \"_x: impl Clone + Iterator<Item = impl Iterator<Item = u8>>)\"\n+// @!has - '//pre[@class=\"rust fn\"]' 'where'\n+pub use impl_trait_aux::func3;\n+\n+\n+// @has impl_trait/fn.func4.html\n+// @has - '//pre[@class=\"rust fn\"]' \"func4<T>(\"\n+// @has - '//pre[@class=\"rust fn\"]' \"T: Iterator<Item = impl Clone>,\"\n+pub use impl_trait_aux::func4;\n+\n+// @has impl_trait/struct.Foo.html\n+// @has - '//code[@id=\"method.v\"]' \"pub fn method<'a>(_x: impl Clone + Into<Vec<u8>> + 'a)\"\n+// @!has - '//code[@id=\"method.v\"]' 'where'\n+pub use impl_trait_aux::Foo;"}]}