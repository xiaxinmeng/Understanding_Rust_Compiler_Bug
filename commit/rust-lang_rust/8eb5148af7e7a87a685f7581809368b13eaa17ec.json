{"sha": "8eb5148af7e7a87a685f7581809368b13eaa17ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYjUxNDhhZjdlN2E4N2E2ODVmNzU4MTgwOTM2OGIxM2VhYTE3ZWM=", "commit": {"author": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-04T23:00:30Z"}, "committer": {"name": "Seivan Heidari", "email": "seivan.heidari@icloud.com", "date": "2019-11-04T23:00:30Z"}, "message": "Merge branch 'master' into feature/themes", "tree": {"sha": "7f0ac4da3fa6e487fe1692a041d4d1144fd3d8db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f0ac4da3fa6e487fe1692a041d4d1144fd3d8db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8eb5148af7e7a87a685f7581809368b13eaa17ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb5148af7e7a87a685f7581809368b13eaa17ec", "html_url": "https://github.com/rust-lang/rust/commit/8eb5148af7e7a87a685f7581809368b13eaa17ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8eb5148af7e7a87a685f7581809368b13eaa17ec/comments", "author": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seivan", "id": 55424, "node_id": "MDQ6VXNlcjU1NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/55424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seivan", "html_url": "https://github.com/seivan", "followers_url": "https://api.github.com/users/seivan/followers", "following_url": "https://api.github.com/users/seivan/following{/other_user}", "gists_url": "https://api.github.com/users/seivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/seivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seivan/subscriptions", "organizations_url": "https://api.github.com/users/seivan/orgs", "repos_url": "https://api.github.com/users/seivan/repos", "events_url": "https://api.github.com/users/seivan/events{/privacy}", "received_events_url": "https://api.github.com/users/seivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c60f9bf4c6d6ddd341c673b228b6aa1add3da62b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c60f9bf4c6d6ddd341c673b228b6aa1add3da62b", "html_url": "https://github.com/rust-lang/rust/commit/c60f9bf4c6d6ddd341c673b228b6aa1add3da62b"}, {"sha": "38f2bd21fbecf1c997a4ab9a8913e8b5487088e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/38f2bd21fbecf1c997a4ab9a8913e8b5487088e3", "html_url": "https://github.com/rust-lang/rust/commit/38f2bd21fbecf1c997a4ab9a8913e8b5487088e3"}], "stats": {"total": 665, "additions": 323, "deletions": 342}, "files": [{"sha": "a8f8446cb637455120290576f9f4262c9ebb73c3", "filename": "crates/ra_assists/src/doc_tests.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -5,13 +5,14 @@\n \n mod generated;\n \n-use hir::mock::MockDatabase;\n-use ra_db::FileRange;\n+use ra_db::{fixture::WithFixture, FileRange};\n use test_utils::{assert_eq_text, extract_range_or_offset};\n \n+use crate::test_db::TestDB;\n+\n fn check(assist_id: &str, before: &str, after: &str) {\n     let (selection, before) = extract_range_or_offset(before);\n-    let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+    let (db, file_id) = TestDB::with_single_file(&before);\n     let frange = FileRange { file_id, range: selection.into() };\n \n     let (_assist_id, action) = crate::assists(&db, frange)"}, {"sha": "39c1c283f47527463658ed1ee75cc3a2ed2a8992", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -9,6 +9,8 @@ mod assist_ctx;\n mod marks;\n #[cfg(test)]\n mod doc_tests;\n+#[cfg(test)]\n+mod test_db;\n \n use hir::db::HirDatabase;\n use ra_db::FileRange;\n@@ -146,20 +148,19 @@ mod assists {\n \n #[cfg(test)]\n mod helpers {\n-    use hir::mock::MockDatabase;\n-    use ra_db::FileRange;\n+    use ra_db::{fixture::WithFixture, FileRange};\n     use ra_syntax::TextRange;\n     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n-    use crate::{Assist, AssistCtx};\n+    use crate::{test_db::TestDB, Assist, AssistCtx};\n \n     pub(crate) fn check_assist(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n         after: &str,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n@@ -182,12 +183,12 @@ mod helpers {\n     }\n \n     pub(crate) fn check_assist_range(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n         after: &str,\n     ) {\n         let (range, before) = extract_range(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n@@ -204,12 +205,12 @@ mod helpers {\n     }\n \n     pub(crate) fn check_assist_target(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n         target: &str,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist =\n@@ -224,12 +225,12 @@ mod helpers {\n     }\n \n     pub(crate) fn check_assist_range_target(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n         target: &str,\n     ) {\n         let (range, before) = extract_range(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist =\n             AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n@@ -243,23 +244,23 @@ mod helpers {\n     }\n \n     pub(crate) fn check_assist_not_applicable(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assist = AssistCtx::with_ctx(&db, frange, true, assist);\n         assert!(assist.is_none());\n     }\n \n     pub(crate) fn check_assist_range_not_applicable(\n-        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n         before: &str,\n     ) {\n         let (range, before) = extract_range(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assist = AssistCtx::with_ctx(&db, frange, true, assist);\n         assert!(assist.is_none());\n@@ -268,16 +269,17 @@ mod helpers {\n \n #[cfg(test)]\n mod tests {\n-    use hir::mock::MockDatabase;\n-    use ra_db::FileRange;\n+    use ra_db::{fixture::WithFixture, FileRange};\n     use ra_syntax::TextRange;\n     use test_utils::{extract_offset, extract_range};\n \n+    use crate::test_db::TestDB;\n+\n     #[test]\n     fn assist_order_field_struct() {\n         let before = \"struct Foo { <|>bar: u32 }\";\n         let (before_cursor_pos, before) = extract_offset(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n         let assists = super::assists(&db, frange);\n@@ -298,7 +300,7 @@ mod tests {\n             }\n         }\";\n         let (range, before) = extract_range(before);\n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let (db, file_id) = TestDB::with_single_file(&before);\n         let frange = FileRange { file_id, range };\n         let assists = super::assists(&db, frange);\n         let mut assists = assists.iter();"}, {"sha": "5be7383edcd7f50bd32a626fb5a2fb32bfb7fcb5", "filename": "crates/ra_assists/src/test_db.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_assists%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftest_db.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -0,0 +1,45 @@\n+//! Database used for testing `ra_assists`.\n+\n+use std::sync::Arc;\n+\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n+\n+#[salsa::database(\n+    ra_db::SourceDatabaseExtStorage,\n+    ra_db::SourceDatabaseStorage,\n+    hir::db::InternDatabaseStorage,\n+    hir::db::AstDatabaseStorage,\n+    hir::db::DefDatabaseStorage,\n+    hir::db::DefDatabase2Storage,\n+    hir::db::HirDatabaseStorage\n+)]\n+#[derive(Debug, Default)]\n+pub struct TestDB {\n+    runtime: salsa::Runtime<TestDB>,\n+}\n+\n+impl salsa::Database for TestDB {\n+    fn salsa_runtime(&self) -> &salsa::Runtime<Self> {\n+        &self.runtime\n+    }\n+}\n+\n+impl std::panic::RefUnwindSafe for TestDB {}\n+\n+impl FileLoader for TestDB {\n+    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+        FileLoaderDelegate(self).file_text(file_id)\n+    }\n+    fn resolve_relative_path(\n+        &self,\n+        anchor: FileId,\n+        relative_path: &RelativePath,\n+    ) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    }\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+        FileLoaderDelegate(self).relevant_crates(file_id)\n+    }\n+}\n+\n+impl hir::debug::HirDebugHelper for TestDB {}"}, {"sha": "4e273d9e407fd822a9829638d45c1a4364930fd4", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -30,8 +30,8 @@ use crate::{\n     impl_block::ImplBlock,\n     resolve::{Resolver, Scope, TypeNs},\n     traits::TraitData,\n-    ty::{InferenceResult, TraitRef},\n-    Either, HasSource, Name, ScopeDef, Ty, {ImportId, Namespace},\n+    ty::{InferenceResult, Namespace, TraitRef},\n+    Either, HasSource, ImportId, Name, ScopeDef, Ty,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which"}, {"sha": "11b3f94ae91b97acb60a79d09584a1867032407e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -14,10 +14,10 @@ use crate::{\n     traits::TraitData,\n     ty::{\n         method_resolution::CrateImplBlocks, traits::Impl, CallableDef, FnSig, GenericPredicate,\n-        InferenceResult, Substs, Ty, TypableDef, TypeCtor,\n+        InferenceResult, Namespace, Substs, Ty, TypableDef, TypeCtor,\n     },\n     type_alias::TypeAliasData,\n-    Const, ConstData, Crate, DefWithBody, ExprScopes, FnData, Function, Module, Namespace, Static,\n+    Const, ConstData, Crate, DefWithBody, ExprScopes, FnData, Function, Module, Static,\n     StructField, Trait, TypeAlias,\n };\n "}, {"sha": "c14c2ab663087357259666e060a31fdb74b79c7a", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -174,11 +174,11 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::SourceDatabase;\n+    use ra_db::{fixture::WithFixture, SourceDatabase};\n     use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n     use test_utils::{assert_eq_text, extract_offset};\n \n-    use crate::{mock::MockDatabase, source_binder::SourceAnalyzer};\n+    use crate::{source_binder::SourceAnalyzer, test_db::TestDB};\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let (off, code) = extract_offset(code);\n@@ -191,7 +191,7 @@ mod tests {\n             buf\n         };\n \n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n+        let (db, file_id) = TestDB::with_single_file(&code);\n         let file = db.parse(file_id).ok().unwrap();\n         let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n         let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n@@ -288,7 +288,7 @@ mod tests {\n     fn do_check_local_name(code: &str, expected_offset: u32) {\n         let (off, code) = extract_offset(code);\n \n-        let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n+        let (db, file_id) = TestDB::with_single_file(&code);\n         let file = db.parse(file_id).ok().unwrap();\n         let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n             .expect(\"failed to find a name at the target offset\");"}, {"sha": "5f2a05e76ff98ff47c1548b70118503d1088e015", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -29,8 +29,6 @@ macro_rules! impl_froms {\n pub mod debug;\n \n pub mod db;\n-#[macro_use]\n-pub mod mock;\n pub mod source_binder;\n \n mod ids;\n@@ -51,6 +49,8 @@ mod code_model;\n \n pub mod from_source;\n \n+#[cfg(test)]\n+mod test_db;\n #[cfg(test)]\n mod marks;\n \n@@ -81,10 +81,7 @@ pub use crate::{\n \n pub use hir_def::{\n     builtin_type::BuiltinType,\n-    nameres::{\n-        per_ns::{Namespace, PerNs},\n-        raw::ImportId,\n-    },\n+    nameres::{per_ns::PerNs, raw::ImportId},\n     path::{Path, PathKind},\n     type_ref::Mutability,\n };"}, {"sha": "ab97a09b9114c7b901507d0520b9abf15d74f8a2", "filename": "crates/ra_hir/src/mock.rs", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/c60f9bf4c6d6ddd341c673b228b6aa1add3da62b/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c60f9bf4c6d6ddd341c673b228b6aa1add3da62b/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=c60f9bf4c6d6ddd341c673b228b6aa1add3da62b", "patch": "@@ -1,262 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use std::{panic, sync::Arc};\n-\n-use hir_expand::diagnostics::DiagnosticSink;\n-use parking_lot::Mutex;\n-use ra_cfg::CfgOptions;\n-use ra_db::{\n-    salsa, CrateGraph, CrateId, Edition, FileId, FileLoader, FileLoaderDelegate, FilePosition,\n-    RelativePath, RelativePathBuf, SourceDatabase, SourceDatabaseExt, SourceRoot, SourceRootId,\n-};\n-use rustc_hash::FxHashMap;\n-use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n-\n-use crate::{db, debug::HirDebugHelper};\n-\n-pub const WORKSPACE: SourceRootId = SourceRootId(0);\n-\n-#[salsa::database(\n-    ra_db::SourceDatabaseExtStorage,\n-    ra_db::SourceDatabaseStorage,\n-    db::InternDatabaseStorage,\n-    db::AstDatabaseStorage,\n-    db::DefDatabaseStorage,\n-    db::DefDatabase2Storage,\n-    db::HirDatabaseStorage\n-)]\n-#[derive(Debug)]\n-pub struct MockDatabase {\n-    events: Mutex<Option<Vec<salsa::Event<MockDatabase>>>>,\n-    runtime: salsa::Runtime<MockDatabase>,\n-    files: FxHashMap<String, FileId>,\n-    crate_names: Arc<FxHashMap<CrateId, String>>,\n-    file_paths: Arc<FxHashMap<FileId, String>>,\n-}\n-\n-impl panic::RefUnwindSafe for MockDatabase {}\n-\n-impl FileLoader for MockDatabase {\n-    fn file_text(&self, file_id: FileId) -> Arc<String> {\n-        FileLoaderDelegate(self).file_text(file_id)\n-    }\n-    fn resolve_relative_path(\n-        &self,\n-        anchor: FileId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n-    }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n-        FileLoaderDelegate(self).relevant_crates(file_id)\n-    }\n-}\n-\n-impl HirDebugHelper for MockDatabase {\n-    fn crate_name(&self, krate: CrateId) -> Option<String> {\n-        self.crate_names.get(&krate).cloned()\n-    }\n-\n-    fn file_path(&self, file_id: FileId) -> Option<String> {\n-        self.file_paths.get(&file_id).cloned()\n-    }\n-}\n-\n-impl MockDatabase {\n-    pub fn with_files(fixture: &str) -> MockDatabase {\n-        let (db, position) = MockDatabase::from_fixture(fixture);\n-        assert!(position.is_none());\n-        db\n-    }\n-\n-    pub fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n-        let mut db = MockDatabase::default();\n-        let mut source_root = SourceRoot::default();\n-        let file_id = db.add_file(WORKSPACE, \"/\", &mut source_root, \"/main.rs\", text);\n-        db.set_source_root(WORKSPACE, Arc::new(source_root.clone()));\n-        (db, source_root, file_id)\n-    }\n-\n-    pub fn file_id_of(&self, path: &str) -> FileId {\n-        match self.files.get(path) {\n-            Some(it) => *it,\n-            None => panic!(\"unknown file: {:?}\\nexisting files:\\n{:#?}\", path, self.files),\n-        }\n-    }\n-\n-    pub fn diagnostics(&self) -> String {\n-        let mut buf = String::new();\n-        let mut files: Vec<FileId> = self.files.values().copied().collect();\n-        files.sort();\n-        for file in files {\n-            let src = crate::Source {\n-                file_id: file.into(),\n-                ast: crate::ModuleSource::new(self, Some(file), None),\n-            };\n-            let module = crate::Module::from_definition(self, src).unwrap();\n-            module.diagnostics(\n-                self,\n-                &mut DiagnosticSink::new(|d| {\n-                    buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-                }),\n-            )\n-        }\n-        buf\n-    }\n-\n-    fn from_fixture(fixture: &str) -> (MockDatabase, Option<FilePosition>) {\n-        let mut db = MockDatabase::default();\n-\n-        let pos = db.add_fixture(fixture);\n-\n-        (db, pos)\n-    }\n-\n-    fn add_fixture(&mut self, fixture: &str) -> Option<FilePosition> {\n-        let mut position = None;\n-        let mut source_root = SourceRoot::default();\n-        let mut source_root_id = WORKSPACE;\n-        let mut source_root_prefix = \"/\".to_string();\n-        for entry in parse_fixture(fixture) {\n-            if entry.meta.starts_with(\"root\") {\n-                self.set_source_root(source_root_id, Arc::new(source_root));\n-                source_root = SourceRoot::default();\n-\n-                source_root_id = SourceRootId(source_root_id.0 + 1);\n-                source_root_prefix = entry.meta[\"root\".len()..].trim().to_string();\n-                continue;\n-            }\n-            if entry.text.contains(CURSOR_MARKER) {\n-                assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n-                position = Some(self.add_file_with_position(\n-                    source_root_id,\n-                    &source_root_prefix,\n-                    &mut source_root,\n-                    &entry.meta,\n-                    &entry.text,\n-                ));\n-            } else {\n-                self.add_file(\n-                    source_root_id,\n-                    &source_root_prefix,\n-                    &mut source_root,\n-                    &entry.meta,\n-                    &entry.text,\n-                );\n-            }\n-        }\n-        self.set_source_root(source_root_id, Arc::new(source_root));\n-        position\n-    }\n-\n-    fn add_file(\n-        &mut self,\n-        source_root_id: SourceRootId,\n-        source_root_prefix: &str,\n-        source_root: &mut SourceRoot,\n-        path: &str,\n-        text: &str,\n-    ) -> FileId {\n-        assert!(source_root_prefix.starts_with('/'));\n-        assert!(source_root_prefix.ends_with('/'));\n-        assert!(path.starts_with(source_root_prefix));\n-        let rel_path = RelativePathBuf::from_path(&path[source_root_prefix.len()..]).unwrap();\n-\n-        let is_crate_root = rel_path == \"lib.rs\" || rel_path == \"/main.rs\";\n-\n-        let file_id = FileId(self.files.len() as u32);\n-\n-        let prev = self.files.insert(path.to_string(), file_id);\n-        assert!(prev.is_none(), \"duplicate files in the text fixture\");\n-        Arc::make_mut(&mut self.file_paths).insert(file_id, path.to_string());\n-\n-        let text = Arc::new(text.to_string());\n-        self.set_file_text(file_id, text);\n-        self.set_file_relative_path(file_id, rel_path.clone());\n-        self.set_file_source_root(file_id, source_root_id);\n-        source_root.insert_file(rel_path, file_id);\n-\n-        if is_crate_root {\n-            let mut crate_graph = CrateGraph::default();\n-            crate_graph.add_crate_root(file_id, Edition::Edition2018, CfgOptions::default());\n-            self.set_crate_graph(Arc::new(crate_graph));\n-        }\n-        file_id\n-    }\n-\n-    fn add_file_with_position(\n-        &mut self,\n-        source_root_id: SourceRootId,\n-        source_root_prefix: &str,\n-        source_root: &mut SourceRoot,\n-        path: &str,\n-        text: &str,\n-    ) -> FilePosition {\n-        let (offset, text) = extract_offset(text);\n-        let file_id = self.add_file(source_root_id, source_root_prefix, source_root, path, &text);\n-        FilePosition { file_id, offset }\n-    }\n-}\n-\n-impl salsa::Database for MockDatabase {\n-    fn salsa_runtime(&self) -> &salsa::Runtime<MockDatabase> {\n-        &self.runtime\n-    }\n-\n-    fn salsa_event(&self, event: impl Fn() -> salsa::Event<MockDatabase>) {\n-        let mut events = self.events.lock();\n-        if let Some(events) = &mut *events {\n-            events.push(event());\n-        }\n-    }\n-}\n-\n-impl Default for MockDatabase {\n-    fn default() -> MockDatabase {\n-        let mut db = MockDatabase {\n-            events: Default::default(),\n-            runtime: salsa::Runtime::default(),\n-            files: FxHashMap::default(),\n-            crate_names: Default::default(),\n-            file_paths: Default::default(),\n-        };\n-        db.set_crate_graph(Default::default());\n-        db\n-    }\n-}\n-\n-impl salsa::ParallelDatabase for MockDatabase {\n-    fn snapshot(&self) -> salsa::Snapshot<MockDatabase> {\n-        salsa::Snapshot::new(MockDatabase {\n-            events: Default::default(),\n-            runtime: self.runtime.snapshot(self),\n-            // only the root database can be used to get file_id by path.\n-            files: FxHashMap::default(),\n-            file_paths: Arc::clone(&self.file_paths),\n-            crate_names: Arc::clone(&self.crate_names),\n-        })\n-    }\n-}\n-\n-impl MockDatabase {\n-    pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<MockDatabase>> {\n-        *self.events.lock() = Some(Vec::new());\n-        f();\n-        self.events.lock().take().unwrap()\n-    }\n-\n-    pub fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {\n-        let events = self.log(f);\n-        events\n-            .into_iter()\n-            .filter_map(|e| match e.kind {\n-                // This pretty horrible, but `Debug` is the only way to inspect\n-                // QueryDescriptor at the moment.\n-                salsa::EventKind::WillExecute { database_key } => {\n-                    Some(format!(\"{:?}\", database_key))\n-                }\n-                _ => None,\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "5237b303af4c0a399c3c96a2180540fd9dd01b9e", "filename": "crates/ra_hir/src/test_db.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftest_db.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -0,0 +1,120 @@\n+//! Database used for testing `hir`.\n+\n+use std::{panic, sync::Arc};\n+\n+use hir_def::{db::DefDatabase2, ModuleId};\n+use hir_expand::diagnostics::DiagnosticSink;\n+use parking_lot::Mutex;\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath, SourceDatabase};\n+\n+use crate::{db, debug::HirDebugHelper};\n+\n+#[salsa::database(\n+    ra_db::SourceDatabaseExtStorage,\n+    ra_db::SourceDatabaseStorage,\n+    db::InternDatabaseStorage,\n+    db::AstDatabaseStorage,\n+    db::DefDatabaseStorage,\n+    db::DefDatabase2Storage,\n+    db::HirDatabaseStorage\n+)]\n+#[derive(Debug, Default)]\n+pub struct TestDB {\n+    events: Mutex<Option<Vec<salsa::Event<TestDB>>>>,\n+    runtime: salsa::Runtime<TestDB>,\n+}\n+\n+impl salsa::Database for TestDB {\n+    fn salsa_runtime(&self) -> &salsa::Runtime<TestDB> {\n+        &self.runtime\n+    }\n+\n+    fn salsa_event(&self, event: impl Fn() -> salsa::Event<TestDB>) {\n+        let mut events = self.events.lock();\n+        if let Some(events) = &mut *events {\n+            events.push(event());\n+        }\n+    }\n+}\n+\n+impl salsa::ParallelDatabase for TestDB {\n+    fn snapshot(&self) -> salsa::Snapshot<TestDB> {\n+        salsa::Snapshot::new(TestDB {\n+            events: Default::default(),\n+            runtime: self.runtime.snapshot(self),\n+        })\n+    }\n+}\n+\n+impl panic::RefUnwindSafe for TestDB {}\n+\n+impl FileLoader for TestDB {\n+    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+        FileLoaderDelegate(self).file_text(file_id)\n+    }\n+    fn resolve_relative_path(\n+        &self,\n+        anchor: FileId,\n+        relative_path: &RelativePath,\n+    ) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    }\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+        FileLoaderDelegate(self).relevant_crates(file_id)\n+    }\n+}\n+\n+// FIXME: improve `WithFixture` to bring useful hir debugging back\n+impl HirDebugHelper for TestDB {\n+    fn crate_name(&self, _krate: CrateId) -> Option<String> {\n+        None\n+    }\n+\n+    fn file_path(&self, _file_id: FileId) -> Option<String> {\n+        None\n+    }\n+}\n+\n+impl TestDB {\n+    pub fn diagnostics(&self) -> String {\n+        let mut buf = String::new();\n+        let crate_graph = self.crate_graph();\n+        for krate in crate_graph.iter().next() {\n+            let crate_def_map = self.crate_def_map(krate);\n+            for (module_id, _) in crate_def_map.modules.iter() {\n+                let module_id = ModuleId { krate, module_id };\n+                let module = crate::Module::from(module_id);\n+                module.diagnostics(\n+                    self,\n+                    &mut DiagnosticSink::new(|d| {\n+                        buf += &format!(\"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                    }),\n+                )\n+            }\n+        }\n+        buf\n+    }\n+}\n+\n+impl TestDB {\n+    pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<TestDB>> {\n+        *self.events.lock() = Some(Vec::new());\n+        f();\n+        self.events.lock().take().unwrap()\n+    }\n+\n+    pub fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {\n+        let events = self.log(f);\n+        events\n+            .into_iter()\n+            .filter_map(|e| match e.kind {\n+                // This pretty horrible, but `Debug` is the only way to inspect\n+                // QueryDescriptor at the moment.\n+                salsa::EventKind::WillExecute { database_key } => {\n+                    Some(format!(\"{:?}\", database_key))\n+                }\n+                _ => None,\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "cd2ac0e8bd388fe9013b943db7da9f87f66dbb0a", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -27,7 +27,7 @@ pub(crate) use infer::{infer_query, InferTy, InferenceResult};\n pub use lower::CallableDef;\n pub(crate) use lower::{\n     callable_item_sig, generic_defaults_query, generic_predicates_for_param_query,\n-    generic_predicates_query, type_for_def, type_for_field, TypableDef,\n+    generic_predicates_query, type_for_def, type_for_field, Namespace, TypableDef,\n };\n pub(crate) use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n "}, {"sha": "4af1d65ee445468d9c9a0b9e6f07b23b0c774eee", "filename": "crates/ra_hir/src/ty/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fexpr.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -12,10 +12,10 @@ use crate::{\n     expr::{self, Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::{GenericParams, HasGenericParams},\n     ty::{\n-        autoderef, method_resolution, op, primitive, CallableDef, InferTy, Mutability, Obligation,\n-        ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n+        autoderef, method_resolution, op, primitive, CallableDef, InferTy, Mutability, Namespace,\n+        Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n     },\n-    Adt, Name, Namespace,\n+    Adt, Name,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {"}, {"sha": "865ced5a13326f5d768c676024dfebc02a30c834", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -6,8 +6,8 @@ use super::{ExprOrPatId, InferenceContext, TraitRef};\n use crate::{\n     db::HirDatabase,\n     resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n-    ty::{method_resolution, Substs, Ty, TypableDef, TypeWalk},\n-    AssocItem, Container, HasGenericParams, Name, Namespace, Path,\n+    ty::{method_resolution, Namespace, Substs, Ty, TypableDef, TypeWalk},\n+    AssocItem, Container, HasGenericParams, Name, Path,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {"}, {"sha": "d26b16cb2f8cd67a90420e1fc58bf8bdb91fbb23", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -29,10 +29,21 @@ use crate::{\n         Adt,\n     },\n     util::make_mut_slice,\n-    Const, Enum, EnumVariant, Function, ModuleDef, Namespace, Path, Static, Struct, StructField,\n-    Trait, TypeAlias, Union,\n+    Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField, Trait,\n+    TypeAlias, Union,\n };\n \n+// FIXME: this is only really used in `type_for_def`, which contains a bunch of\n+// impossible cases. Perhaps we should recombine `TypeableDef` and `Namespace`\n+// into a `AsTypeDef`, `AsValueDef` enums?\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum Namespace {\n+    Types,\n+    Values,\n+    // Note that only type inference uses this enum, and it doesn't care about macros.\n+    // Macro,\n+}\n+\n impl Ty {\n     pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n         match type_ref {"}, {"sha": "e56b9356e9bae590cd20e143d6af1ad8102c19dc", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n use test_utils::covers;\n \n use crate::{\n-    expr::BodySourceMap, mock::MockDatabase, ty::display::HirDisplay, ty::InferenceResult,\n+    expr::BodySourceMap, test_db::TestDB, ty::display::HirDisplay, ty::InferenceResult,\n     SourceAnalyzer,\n };\n \n@@ -24,7 +24,7 @@ mod coercion;\n \n #[test]\n fn cfg_impl_block() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:foo cfg:test\n use foo::S as T;\n@@ -64,7 +64,7 @@ impl S {\n \n #[test]\n fn infer_await() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:std\n \n@@ -95,7 +95,7 @@ mod future {\n \n #[test]\n fn infer_box() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:std\n \n@@ -122,7 +122,7 @@ mod boxed {\n \n #[test]\n fn infer_adt_self() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs\n enum Nat { Succ(Self), Demo(Nat), Zero }\n@@ -141,7 +141,7 @@ fn test() {\n \n #[test]\n fn infer_try() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:std\n \n@@ -181,7 +181,7 @@ mod result {\n \n #[test]\n fn infer_for_loop() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:std\n \n@@ -223,7 +223,7 @@ mod collections {\n #[test]\n fn infer_while_let() {\n     covers!(infer_while_let);\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs\n enum Option<T> { Some(T), None }\n@@ -2484,7 +2484,7 @@ pub fn main_loop() {\n \n #[test]\n fn cross_crate_associated_method_call() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:other_crate\n fn test() {\n@@ -3378,7 +3378,7 @@ fn test() { S.foo()<|>; }\n \n #[test]\n fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:foo\n fn test() {\n@@ -3482,7 +3482,7 @@ fn test() { (&S).foo()<|>; }\n \n #[test]\n fn method_resolution_trait_from_prelude() {\n-    let (db, pos) = MockDatabase::with_position(\n+    let (db, pos) = TestDB::with_position(\n         r#\"\n //- /main.rs crate:main deps:other_crate\n struct S;\n@@ -4651,7 +4651,7 @@ fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n     assert_eq!(t, \"{unknown}\");\n }\n \n-fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n+fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n     let analyzer = SourceAnalyzer::new(db, pos.file_id, expr.syntax(), Some(pos.offset));\n@@ -4660,12 +4660,12 @@ fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n }\n \n fn type_at(content: &str) -> String {\n-    let (db, file_pos) = MockDatabase::with_position(content);\n+    let (db, file_pos) = TestDB::with_position(content);\n     type_at_pos(&db, file_pos)\n }\n \n fn infer(content: &str) -> String {\n-    let (db, _, file_id) = MockDatabase::with_single_file(content);\n+    let (db, file_id) = TestDB::with_single_file(content);\n     let source_file = db.parse(file_id).ok().unwrap();\n \n     let mut acc = String::new();\n@@ -4748,7 +4748,7 @@ fn ellipsize(mut text: String, max_len: usize) -> String {\n \n #[test]\n fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n-    let (mut db, pos) = MockDatabase::with_position(\n+    let (mut db, pos) = TestDB::with_position(\n         \"\n         //- /lib.rs\n         fn foo() -> i32 {\n@@ -4788,7 +4788,7 @@ fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n \n #[test]\n fn no_such_field_diagnostics() {\n-    let diagnostics = MockDatabase::with_files(\n+    let diagnostics = TestDB::with_files(\n         r\"\n         //- /lib.rs\n         struct S { foo: i32, bar: () }"}, {"sha": "c694952f3cc1ff49cc3174a5775d31176f88cb88", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -18,7 +18,10 @@ use crate::{\n     db::HirDatabase,\n     generics::GenericDef,\n     ty::display::HirDisplay,\n-    ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n+    ty::{\n+        ApplicationTy, GenericPredicate, Namespace, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+        TypeWalk,\n+    },\n     AssocItem, Crate, HasGenericParams, ImplBlock, Trait, TypeAlias,\n };\n \n@@ -652,7 +655,7 @@ fn impl_block_datum(\n         })\n         .filter_map(|t| {\n             let assoc_ty = trait_.associated_type_by_name(db, &t.name(db))?;\n-            let ty = db.type_for_def(t.into(), crate::Namespace::Types).subst(&bound_vars);\n+            let ty = db.type_for_def(t.into(), Namespace::Types).subst(&bound_vars);\n             Some(chalk_rust_ir::AssociatedTyValue {\n                 impl_id,\n                 associated_ty_id: assoc_ty.to_chalk(db),"}, {"sha": "e1959cdb9e97b193d7d93c7c00578d00cc45dd05", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -50,8 +50,8 @@\n // FIXME: review privacy of submodules\n pub mod raw;\n pub mod per_ns;\n-pub mod collector;\n-pub mod mod_resolution;\n+mod collector;\n+mod mod_resolution;\n \n #[cfg(test)]\n mod tests;\n@@ -196,7 +196,7 @@ pub struct Resolution {\n }\n \n impl Resolution {\n-    pub(crate) fn from_macro(macro_: MacroDefId) -> Self {\n+    fn from_macro(macro_: MacroDefId) -> Self {\n         Resolution { def: PerNs::macros(macro_), import: None }\n     }\n }\n@@ -460,7 +460,7 @@ impl CrateDefMap {\n         from_crate_root.or(from_extern_prelude)\n     }\n \n-    pub(crate) fn resolve_name_in_module(\n+    fn resolve_name_in_module(\n         &self,\n         db: &impl DefDatabase2,\n         module: CrateModuleId,"}, {"sha": "b3b1379d024e2a9add2b8bcfef3da61ecb748292", "filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::SmolStr;\n use crate::{db::DefDatabase2, HirFileId};\n \n #[derive(Clone, Debug)]\n-pub struct ModDir {\n+pub(super) struct ModDir {\n     /// `.` for `mod.rs`, `lib.rs`\n     /// `./foo` for `foo.rs`\n     /// `./foo/bar` for `mod bar { mod x; }` nested in `foo.rs`\n@@ -16,11 +16,15 @@ pub struct ModDir {\n }\n \n impl ModDir {\n-    pub fn root() -> ModDir {\n+    pub(super) fn root() -> ModDir {\n         ModDir { path: RelativePathBuf::default(), root_non_dir_owner: false }\n     }\n \n-    pub fn descend_into_definition(&self, name: &Name, attr_path: Option<&SmolStr>) -> ModDir {\n+    pub(super) fn descend_into_definition(\n+        &self,\n+        name: &Name,\n+        attr_path: Option<&SmolStr>,\n+    ) -> ModDir {\n         let mut path = self.path.clone();\n         match attr_to_path(attr_path) {\n             None => path.push(&name.to_string()),\n@@ -34,7 +38,7 @@ impl ModDir {\n         ModDir { path, root_non_dir_owner: false }\n     }\n \n-    pub fn resolve_declaration(\n+    pub(super) fn resolve_declaration(\n         &self,\n         db: &impl DefDatabase2,\n         file_id: HirFileId,"}, {"sha": "717ed1ef905a4ebfef8d034c17a29f5ffe2c7f70", "filename": "crates/ra_hir_def/src/nameres/per_ns.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fper_ns.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -4,14 +4,6 @@ use hir_expand::MacroDefId;\n \n use crate::ModuleDefId;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum Namespace {\n-    Types,\n-    Values,\n-    // Note that only type inference uses this enum, and it doesn't care about macros.\n-    // Macro,\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct PerNs {\n     pub types: Option<ModuleDefId>,"}, {"sha": "15f000175559d8581c3cfed09e7b16f91e71d641", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -42,6 +42,8 @@ pub use crate::syntax_bridge::{\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct MacroRules {\n     pub(crate) rules: Vec<Rule>,\n+    /// Highest id of the token we have in TokenMap\n+    pub(crate) shift: u32,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -50,6 +52,38 @@ pub(crate) struct Rule {\n     pub(crate) rhs: tt::Subtree,\n }\n \n+// Find the max token id inside a subtree\n+fn max_id(subtree: &tt::Subtree) -> Option<u32> {\n+    subtree\n+        .token_trees\n+        .iter()\n+        .filter_map(|tt| match tt {\n+            tt::TokenTree::Subtree(subtree) => max_id(subtree),\n+            tt::TokenTree::Leaf(tt::Leaf::Ident(ident))\n+                if ident.id != tt::TokenId::unspecified() =>\n+            {\n+                Some(ident.id.0)\n+            }\n+            _ => None,\n+        })\n+        .max()\n+}\n+\n+/// Shift given TokenTree token id\n+fn shift_subtree(tt: &mut tt::Subtree, shift: u32) {\n+    for t in tt.token_trees.iter_mut() {\n+        match t {\n+            tt::TokenTree::Leaf(leaf) => match leaf {\n+                tt::Leaf::Ident(ident) if ident.id != tt::TokenId::unspecified() => {\n+                    ident.id.0 += shift;\n+                }\n+                _ => (),\n+            },\n+            tt::TokenTree::Subtree(tt) => shift_subtree(tt, shift),\n+        }\n+    }\n+}\n+\n impl MacroRules {\n     pub fn parse(tt: &tt::Subtree) -> Result<MacroRules, ParseError> {\n         // Note: this parsing can be implemented using mbe machinery itself, by\n@@ -72,10 +106,17 @@ impl MacroRules {\n             validate(&rule.lhs)?;\n         }\n \n-        Ok(MacroRules { rules })\n+        // Note that TokenId is started from zero,\n+        // We have to add 1 to prevent duplication.\n+        let shift = max_id(tt).map_or(0, |it| it + 1);\n+        Ok(MacroRules { rules, shift })\n     }\n+\n     pub fn expand(&self, tt: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n-        mbe_expander::expand(self, tt)\n+        // apply shift\n+        let mut tt = tt.clone();\n+        shift_subtree(&mut tt, self.shift);\n+        mbe_expander::expand(self, &tt)\n     }\n }\n "}, {"sha": "a23e3afe3e7afe10a02ae7a95327e5ba78321880", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8eb5148af7e7a87a685f7581809368b13eaa17ec/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=8eb5148af7e7a87a685f7581809368b13eaa17ec", "patch": "@@ -58,6 +58,33 @@ mod rule_parsing {\n // * Port the test to rust and add it to this module\n // * Make it pass :-)\n \n+#[test]\n+fn test_token_id_shift() {\n+    let macro_definition = r#\"\n+macro_rules! foobar {\n+    ($e:ident) => { foo bar $e }\n+}\n+\"#;\n+    let rules = create_rules(macro_definition);\n+    let expansion = expand(&rules, \"foobar!(baz);\");\n+\n+    fn get_id(t: &tt::TokenTree) -> Option<u32> {\n+        if let tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) = t {\n+            return Some(ident.id.0);\n+        }\n+        None\n+    }\n+\n+    assert_eq!(expansion.token_trees.len(), 3);\n+    // ($e:ident) => { foo bar $e }\n+    //   0 1            2   3   4\n+    assert_eq!(get_id(&expansion.token_trees[0]), Some(2));\n+    assert_eq!(get_id(&expansion.token_trees[1]), Some(3));\n+\n+    // So baz should be 5\n+    assert_eq!(get_id(&expansion.token_trees[2]), Some(5));\n+}\n+\n #[test]\n fn test_convert_tt() {\n     let macro_definition = r#\""}]}