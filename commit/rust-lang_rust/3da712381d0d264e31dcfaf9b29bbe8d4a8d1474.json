{"sha": "3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYTcxMjM4MWQwZDI2NGUzMWRjZmFmOWIyOWJiZThkNGE4ZDE0NzQ=", "commit": {"author": {"name": "toidiu", "email": "toidiu@protonmail.com", "date": "2018-04-19T02:26:21Z"}, "committer": {"name": "toidiu", "email": "apoorv@toidiu.com", "date": "2018-05-25T13:58:00Z"}, "message": "Implement outlives requirements inference for dyn and projections.\nAdd tests, documentation and attr for feature.", "tree": {"sha": "3168a9993ed19ecd3a73336f642c4ff4c97c6f69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3168a9993ed19ecd3a73336f642c4ff4c97c6f69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "html_url": "https://github.com/rust-lang/rust/commit/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/comments", "author": null, "committer": {"login": "toidiu", "id": 4350690, "node_id": "MDQ6VXNlcjQzNTA2OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/4350690?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toidiu", "html_url": "https://github.com/toidiu", "followers_url": "https://api.github.com/users/toidiu/followers", "following_url": "https://api.github.com/users/toidiu/following{/other_user}", "gists_url": "https://api.github.com/users/toidiu/gists{/gist_id}", "starred_url": "https://api.github.com/users/toidiu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toidiu/subscriptions", "organizations_url": "https://api.github.com/users/toidiu/orgs", "repos_url": "https://api.github.com/users/toidiu/repos", "events_url": "https://api.github.com/users/toidiu/events{/privacy}", "received_events_url": "https://api.github.com/users/toidiu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b86d909f8635f82710c1bf74647c957051cbb23a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b86d909f8635f82710c1bf74647c957051cbb23a", "html_url": "https://github.com/rust-lang/rust/commit/b86d909f8635f82710c1bf74647c957051cbb23a"}], "stats": {"total": 1401, "additions": 676, "deletions": 725}, "files": [{"sha": "73c7eafdb98d583b24f65201714e3ba07d5babb0", "filename": "src/doc/unstable-book/src/language-features/infer-outlives-requirements.md", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-outlives-requirements.md", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-outlives-requirements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-outlives-requirements.md?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,67 @@\n+# `infer_outlives_requirements`\n+\n+The tracking issue for this feature is: [#44493]\n+\n+[#44493]: https://github.com/rust-lang/rust/issues/44493\n+\n+------------------------\n+The `infer_outlives_requirements` feature indicates that certain\n+outlives requirements can be infered by the compiler rather than\n+stating them explicitly.\n+\n+For example, currently generic struct definitions that contain\n+references, require where-clauses of the form T: 'a. By using\n+this feature the outlives predicates will be infered, although\n+they may still be written explicitly.\n+\n+```rust,ignore (pseudo-Rust)\n+struct Foo<'a, T>\n+  where T: 'a // <-- currently required\n+  {\n+      bar: &'a T,\n+  }\n+```\n+\n+\n+## Examples:\n+\n+\n+```rust,ignore (pseudo-Rust)\n+#![feature(infer_outlives_requirements)]\n+\n+// Implicitly infer T: 'a\n+struct Foo<'a, T> {\n+    bar: &'a T,\n+}\n+```\n+\n+```rust,ignore (pseudo-Rust)\n+#![feature(infer_outlives_requirements)]\n+\n+// Implicitly infer `U: 'b`\n+struct Foo<'b, U> {\n+    bar: Bar<'b, U>\n+}\n+\n+struct Bar<'a, T> where T: 'a {\n+    x: &'a (),\n+    y: T,\n+}\n+```\n+\n+```rust,ignore (pseudo-Rust)\n+#![feature(infer_outlives_requirements)]\n+\n+// Implicitly infer `b': 'a`\n+struct Foo<'a, 'b, T> {\n+    x: &'a &'b T\n+}\n+```\n+\n+```rust,ignore (pseudo-Rust)\n+#![feature(infer_outlives_requirements)]\n+\n+// Implicitly infer `<T as std::iter::Iterator>::Item : 'a`\n+struct Foo<'a, T: Iterator> {\n+    bar: &'a T::Item\n+```"}, {"sha": "bbe47ecee7907793859a0843097d93e677413e07", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,21 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::map as hir_map;\n use rustc::hir;\n-use rustc::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::ty::maps::Providers;\n-use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n-use rustc_data_structures::sync::Lrc;\n+use rustc::ty::{self, TyCtxt};\n use util::nodemap::FxHashMap;\n \n+use super::utils::*;\n+\n pub fn explicit_predicates<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     crate_num: CrateNum,\n-) -> FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>> {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-    let mut predicates: FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>> = FxHashMap();\n+) -> FxHashMap<DefId, RequiredPredicates<'tcx>> {\n+    let mut predicates = FxHashMap::default();\n \n     // iterate over the entire crate\n     tcx.hir.krate().visit_all_item_likes(&mut ExplicitVisitor {\n@@ -36,7 +34,7 @@ pub fn explicit_predicates<'tcx>(\n \n pub struct ExplicitVisitor<'cx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-    explicit_predicates: &'cx mut FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+    explicit_predicates: &'cx mut FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     crate_num: CrateNum,\n }\n \n@@ -47,36 +45,40 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for ExplicitVisitor<'cx, 'tcx> {\n             index: item.hir_id.owner,\n         };\n \n-        let local_explicit_predicate = self.tcx.explicit_predicates_of(def_id);\n+        let mut required_predicates = RequiredPredicates::default();\n+        let local_explicit_predicate = self.tcx.explicit_predicates_of(def_id).predicates;\n+\n+        for pred in local_explicit_predicate.into_iter() {\n+            match pred {\n+                ty::Predicate::TypeOutlives(predicate) => {\n+                    let ty::OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n+                    insert_outlives_predicate(self.tcx, (*ty).into(), reg, &mut required_predicates)\n+                }\n \n-        let filtered_predicates = local_explicit_predicate\n-            .predicates\n-            .into_iter()\n-            .filter(|pred| match pred {\n-                ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => true,\n+                ty::Predicate::RegionOutlives(predicate) => {\n+                    let ty::OutlivesPredicate(ref reg1, ref reg2) = predicate.skip_binder();\n+                    insert_outlives_predicate(\n+                        self.tcx,\n+                        (*reg1).into(),\n+                        reg2,\n+                        &mut required_predicates,\n+                    )\n+                }\n \n                 ty::Predicate::Trait(..)\n                 | ty::Predicate::Projection(..)\n                 | ty::Predicate::WellFormed(..)\n                 | ty::Predicate::ObjectSafe(..)\n                 | ty::Predicate::ClosureKind(..)\n                 | ty::Predicate::Subtype(..)\n-                | ty::Predicate::ConstEvaluatable(..) => false,\n-            })\n-            .collect();\n-\n-        match item.node {\n-            hir::ItemStruct(..) | hir::ItemEnum(..) => {\n-                self.tcx.adt_def(def_id);\n+                | ty::Predicate::ConstEvaluatable(..) => (),\n             }\n-            _ => {}\n         }\n \n-        self.explicit_predicates\n-            .insert(def_id, Lrc::new(filtered_predicates));\n+        self.explicit_predicates.insert(def_id, required_predicates);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {}\n+    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem) {}\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {}\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) {}\n }"}, {"sha": "b2259c63683c6b98d14a3c3061ca4149b9d6235b", "filename": "src/librustc_typeck/outlives/implicit_empty.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_empty.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use hir::map as hir_map;\n-use rustc::hir;\n-use rustc::hir::def_id::{self, CrateNum, DefId, LOCAL_CRATE};\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::ty::maps::Providers;\n-use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n-use rustc_data_structures::sync::Lrc;\n-use util::nodemap::FxHashMap;\n-\n-// Create the sets of inferred predicates for each type. These sets\n-// are initially empty but will grow during the inference step.\n-pub fn empty_predicate_map<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-) -> FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>> {\n-    let mut predicates = FxHashMap();\n-\n-    // iterate over the entire crate\n-    tcx.hir\n-        .krate()\n-        .visit_all_item_likes(&mut EmptyImplicitVisitor {\n-            tcx,\n-            predicates: &mut predicates,\n-        });\n-\n-    predicates\n-}\n-\n-pub struct EmptyImplicitVisitor<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-    predicates: &'cx mut FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n-}\n-\n-impl<'a, 'p, 'v> ItemLikeVisitor<'v> for EmptyImplicitVisitor<'a, 'p> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        self.predicates\n-            .insert(self.tcx.hir.local_def_id(item.id), Lrc::new(Vec::new()));\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {}\n-\n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {}\n-}"}, {"sha": "c966db98c8e170de3947b220f90e74ed8f32abb2", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 87, "deletions": 221, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,24 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unused)]\n-\n use rustc::hir;\n-use rustc::hir::def::{CtorKind, Def};\n-use rustc::hir::def_id::{self, CrateNum, DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::map as hir_map;\n-use rustc::ty::Slice;\n-use rustc::ty::maps::Providers;\n-use rustc::ty::outlives::Component;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n-use rustc::ty::{self, AdtKind, CratePredicatesMap, Region, RegionKind, ReprOptions,\n-                ToPolyTraitRef, ToPredicate, Ty, TyCtxt};\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::Lrc;\n-use rustc_target::spec::abi;\n-use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::util::nodemap::FxHashMap;\n+\n+use super::utils::*;\n \n /// Infer predicates for the items in the crate.\n ///\n@@ -34,7 +24,7 @@ use syntax_pos::{Span, DUMMY_SP};\n ///     now be filled with inferred predicates.\n pub fn infer_predicates<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    explicit_map: &FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+    explicit_map: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n ) -> FxHashMap<DefId, RequiredPredicates<'tcx>> {\n     debug!(\"infer_predicates\");\n \n@@ -65,20 +55,17 @@ pub struct InferVisitor<'cx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n     global_inferred_outlives: &'cx mut FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     predicates_added: &'cx mut bool,\n-    explicit_map: &'cx FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+    explicit_map: &'cx FxHashMap<DefId, RequiredPredicates<'tcx>>,\n }\n \n-/// Tracks the `T: 'a` or `'a: 'a` predicates that we have inferred\n-/// must be added to the struct header.\n-type RequiredPredicates<'tcx> = FxHashSet<ty::OutlivesPredicate<Kind<'tcx>, ty::Region<'tcx>>>;\n-\n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let item_did = self.tcx.hir.local_def_id(item.id);\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n-        let node_id = self.tcx\n+        let node_id = self\n+            .tcx\n             .hir\n             .as_local_node_id(item_did)\n             .expect(\"expected local def-id\");\n@@ -120,7 +107,8 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n         // Therefore mark `predicates_added` as true and which will ensure\n         // we walk the crates again and re-calculate predicates for all\n         // items.\n-        let item_predicates_len: usize = self.global_inferred_outlives\n+        let item_predicates_len: usize = self\n+            .global_inferred_outlives\n             .get(&item_did)\n             .map(|p| p.len())\n             .unwrap_or(0);\n@@ -131,17 +119,17 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {}\n+    fn visit_trait_item(&mut self, _trait_item: &'tcx hir::TraitItem) {}\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {}\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) {}\n }\n \n fn insert_required_predicates_to_be_wf<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     field_ty: Ty<'tcx>,\n     global_inferred_outlives: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n     required_predicates: &mut RequiredPredicates<'tcx>,\n-    explicit_map: &FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n+    explicit_map: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n ) {\n     for ty in field_ty.walk() {\n         match ty.sty {\n@@ -150,14 +138,14 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n             //\n             // We also want to calculate potential predicates for the T\n             ty::TyRef(region, rty, _) => {\n+                debug!(\"TyRef\");\n                 insert_outlives_predicate(tcx, rty.into(), region, required_predicates);\n             }\n \n             // For each TyAdt (struct/enum/union) type `Foo<'a, T>`, we\n             // can load the current set of inferred and explicit\n             // predicates from `global_inferred_outlives` and filter the\n             // ones that are TypeOutlives.\n-            //\n             ty::TyAdt(def, substs) => {\n                 // First check the inferred predicates\n                 //\n@@ -177,6 +165,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // round we will get `U: 'b`. We then apply the substitution\n                 // `['b => 'a, U => T]` and thus get the requirement that `T:\n                 // 'a` holds for `Foo`.\n+                debug!(\"TyAdt\");\n                 if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did) {\n                     for unsubstituted_predicate in unsubstituted_predicates {\n                         // `unsubstituted_predicate` is `U: 'b` in the\n@@ -195,33 +184,51 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // Check if the type has any explicit predicates that need\n                 // to be added to `required_predicates`\n                 // let _: () = substs.region_at(0);\n-                check_explicit_predicates(tcx, &def.did, substs, required_predicates, explicit_map);\n+                check_explicit_predicates(\n+                    tcx,\n+                    &def.did,\n+                    substs,\n+                    required_predicates,\n+                    explicit_map,\n+                    false,\n+                );\n             }\n \n-            ty::TyDynamic(obj, region) => {\n-                // FIXME This corresponds to `dyn Trait<..>`. In this\n-                // case, we should use the explicit predicates as\n-                // well.\n-                if let Some(p) = obj.principal() {\n+            ty::TyDynamic(obj, ..) => {\n+                // This corresponds to `dyn Trait<..>`. In this case, we should\n+                // use the explicit predicates as well.\n+\n+                // We are passing type `ty` as a placeholder value with the function\n+                // `with_self_ty`, since there is no concrete type `Self` for a\n+                // `dyn Trait` at this stage. Therefore when checking explicit\n+                // predicates in `check_explicit_predicates` we need to ignore\n+                // checking the explicit_map for Self type.\n+                debug!(\"TyDynamic\");\n+                debug!(\"field_ty = {}\", &field_ty);\n+                debug!(\"ty in field = {}\", &ty);\n+                if let Some(ex_trait_ref) = obj.principal() {\n                     check_explicit_predicates(\n                         tcx,\n-                        &p.skip_binder().def_id,\n-                        &[region.into()],\n+                        &ex_trait_ref.skip_binder().def_id,\n+                        ex_trait_ref.with_self_ty(tcx, ty).skip_binder().substs,\n                         required_predicates,\n                         explicit_map,\n+                        true,\n                     );\n                 }\n             }\n \n             ty::TyProjection(obj) => {\n-                // FIXME This corresponds to `<T as Foo<'a>>::Bar`. In this case, we should use the\n+                // This corresponds to `<T as Foo<'a>>::Bar`. In this case, we should use the\n                 // explicit predicates as well.\n+                debug!(\"TyProjection\");\n                 check_explicit_predicates(\n                     tcx,\n-                    &obj.item_def_id,\n+                    &tcx.associated_item(obj.item_def_id).container.id(),\n                     obj.substs,\n                     required_predicates,\n                     explicit_map,\n+                    false,\n                 );\n             }\n \n@@ -245,199 +252,58 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n /// will give us `U: 'static` and `U: Foo`. The latter we\n /// can ignore, but we will want to process `U: 'static`,\n /// applying the substitution as above.\n-fn check_explicit_predicates<'tcx>(\n+pub fn check_explicit_predicates<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     def_id: &DefId,\n     substs: &[Kind<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,\n-    explicit_map: &FxHashMap<DefId, Lrc<Vec<ty::Predicate<'tcx>>>>,\n-) {\n-    if let Some(general_predicates) = explicit_map.get(def_id) {\n-        for general_predicate in general_predicates.iter() {\n-            match general_predicate {\n-                // `poly` is `PolyTypeOutlivesPredicate<OutlivesPredicate<Ty>>`\n-                // where OutlivesPredicate<type1, region1> is the predicate\n-                // we want to add.\n-                ty::Predicate::TypeOutlives(poly) => {\n-                    let predicate = poly.skip_binder().subst(tcx, substs);\n-                    insert_outlives_predicate(\n-                        tcx,\n-                        predicate.0.into(),\n-                        predicate.1,\n-                        required_predicates,\n-                    );\n-                }\n-\n-                // `poly` is `PolyRegionOutlivesPredicate<OutlivesPredicate<Ty>>`\n-                // where OutlivesPredicate<region1, region2> is the predicate\n-                // we want to add.\n-                ty::Predicate::RegionOutlives(poly) => {\n-                    let predicate = poly.skip_binder().subst(tcx, substs);\n-                    insert_outlives_predicate(\n-                        tcx,\n-                        predicate.0.into(),\n-                        predicate.1,\n-                        required_predicates,\n-                    );\n-                }\n-\n-                ty::Predicate::Trait(..)\n-                | ty::Predicate::Projection(..)\n-                | ty::Predicate::WellFormed(..)\n-                | ty::Predicate::ObjectSafe(..)\n-                | ty::Predicate::ClosureKind(..)\n-                | ty::Predicate::Subtype(..)\n-                | ty::Predicate::ConstEvaluatable(..) => (),\n-            }\n-        }\n-    }\n-}\n-\n-/// Given a requirement `T: 'a` or `'b: 'a`, deduce the\n-/// outlives_component and add it to `required_predicates`\n-fn insert_outlives_predicate<'tcx>(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    kind: Kind<'tcx>,\n-    outlived_region: Region<'tcx>,\n-    required_predicates: &mut RequiredPredicates<'tcx>,\n+    explicit_map: &FxHashMap<DefId, RequiredPredicates<'tcx>>,\n+    ignore_self_ty: bool,\n ) {\n-    // If the `'a` region is bound within the field type itself, we\n-    // don't want to propagate this constraint to the header.\n-    if !is_free_region(outlived_region) {\n-        return;\n-    }\n-\n-    match kind.unpack() {\n-        UnpackedKind::Type(ty) => {\n-            // `T: 'outlived_region` for some type `T`\n-            // But T could be a lot of things:\n-            // e.g., if `T = &'b u32`, then `'b: 'outlived_region` is\n-            // what we want to add.\n+    debug!(\"def_id = {:?}\", &def_id);\n+    debug!(\"substs = {:?}\", &substs);\n+    debug!(\"explicit_map =  {:?}\", explicit_map);\n+    debug!(\"required_predicates = {:?}\", required_predicates);\n+    if let Some(explicit_predicates) = explicit_map.get(def_id) {\n+        for outlives_predicate in explicit_predicates.iter() {\n+            debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n+\n+            // Careful: If we are inferring the effects of a `dyn Trait<..>`\n+            // type, then when we look up the predicates for `Trait`,\n+            // we may find some that reference `Self`. e.g., perhaps the\n+            // definition of `Trait` was:\n             //\n-            // Or if within `struct Foo<U>` you had `T = Vec<U>`, then\n-            // we would want to add `U: 'outlived_region`\n-            for component in tcx.outlives_components(ty) {\n-                match component {\n-                    Component::Region(r) => {\n-                        // This would arise from something like:\n-                        //\n-                        // ```\n-                        // struct Foo<'a, 'b> {\n-                        //    x:  &'a &'b u32\n-                        // }\n-                        // ```\n-                        //\n-                        // Here `outlived_region = 'a` and `kind = &'b\n-                        // u32`.  Decomposing `&'b u32` into\n-                        // components would yield `'b`, and we add the\n-                        // where clause that `'b: 'a`.\n-                        insert_outlives_predicate(\n-                            tcx,\n-                            r.into(),\n-                            outlived_region,\n-                            required_predicates,\n-                        );\n-                    }\n-\n-                    Component::Param(param_ty) => {\n-                        // param_ty: ty::ParamTy\n-                        // This would arise from something like:\n-                        //\n-                        // ```\n-                        // struct Foo<'a, U> {\n-                        //    x:  &'a Vec<U>\n-                        // }\n-                        // ```\n-                        //\n-                        // Here `outlived_region = 'a` and `kind =\n-                        // Vec<U>`.  Decomposing `Vec<U>` into\n-                        // components would yield `U`, and we add the\n-                        // where clause that `U: 'a`.\n-                        let ty: Ty<'tcx> = tcx.mk_ty_param(param_ty.idx, param_ty.name);\n-                        required_predicates\n-                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n-                    }\n-\n-                    Component::Projection(proj_ty) => {\n-                        // This would arise from something like:\n-                        //\n-                        // ```\n-                        // struct Foo<'a, T: Iterator> {\n-                        //    x:  &'a <T as Iterator>::Item\n-                        // }\n-                        // ```\n-                        //\n-                        // Here we want to add an explicit `where <T as Iterator>::Item: 'a`.\n-                        let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.item_def_id, proj_ty.substs);\n-                        required_predicates\n-                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n-                    }\n-\n-                    Component::EscapingProjection(_) => {\n-                        // As above, but the projection involves\n-                        // late-bound regions.  Therefore, the WF\n-                        // requirement is not checked in type definition\n-                        // but at fn call site, so ignore it.\n-                        //\n-                        // ```\n-                        // struct Foo<'a, T: Iterator> {\n-                        //    x: for<'b> fn(<&'b T as Iterator>::Item)\n-                        //              //  ^^^^^^^^^^^^^^^^^^^^^^^^^\n-                        // }\n-                        // ```\n-                        //\n-                        // Since `'b` is not in scope on `Foo`, can't\n-                        // do anything here, ignore it.\n-                    }\n-\n-                    Component::UnresolvedInferenceVariable(_) => bug!(\"not using infcx\"),\n+            // ```\n+            // trait Trait<'a, T> where Self: 'a  { .. }\n+            // ```\n+            //\n+            // we want to ignore such predicates here, because\n+            // there is no type parameter for them to affect. Consider\n+            // a struct containing `dyn Trait`:\n+            //\n+            // ```\n+            // struct MyStruct<'x, X> { field: Box<dyn Trait<'x, X>> }\n+            // ```\n+            //\n+            // The `where Self: 'a` predicate refers to the *existential, hidden type*\n+            // that is represented by the `dyn Trait`, not to the `X` type parameter\n+            // (or any other generic parameter) declared on `MyStruct`.\n+            //\n+            // Note that we do this check for self **before** applying `substs`. In the\n+            // case that `substs` come from a `dyn Trait` type, our caller will have\n+            // included `Self = dyn Trait<'x, X>` as the value for `Self`. If we were\n+            // to apply the substs, and not filter this predicate, we might then falsely\n+            // conclude that e.g. `X: 'x` was a reasonable inferred requirement.\n+            if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n+                if ty.is_self() && ignore_self_ty {\n+                    debug!(\"skipping self ty = {:?}\", &ty);\n+                    continue;\n                 }\n             }\n-        }\n-\n-        UnpackedKind::Lifetime(r) => {\n-            if !is_free_region(r) {\n-                return;\n-            }\n-            required_predicates.insert(ty::OutlivesPredicate(kind, outlived_region));\n-        }\n-    }\n-}\n-\n-fn is_free_region(region: Region<'_>) -> bool {\n-    // First, screen for regions that might appear in a type header.\n-    match region {\n-        // *These* correspond to `T: 'a` relationships where `'a` is\n-        // either declared on the type or `'static`:\n-        //\n-        //     struct Foo<'a, T> {\n-        //         field: &'a T, // this would generate a ReEarlyBound referencing `'a`\n-        //         field2: &'static T, // this would generate a ReStatic\n-        //     }\n-        //\n-        // We care about these, so fall through.\n-        RegionKind::ReStatic | RegionKind::ReEarlyBound(_) => true,\n-\n-        // Late-bound regions can appear in `fn` types:\n-        //\n-        //     struct Foo<T> {\n-        //         field: for<'b> fn(&'b T) // e.g., 'b here\n-        //     }\n-        //\n-        // The type above might generate a `T: 'b` bound, but we can\n-        // ignore it.  We can't put it on the struct header anyway.\n-        RegionKind::ReLateBound(..) => false,\n \n-        // These regions don't appear in types from type declarations:\n-        RegionKind::ReEmpty\n-        | RegionKind::ReErased\n-        | RegionKind::ReClosureBound(..)\n-        | RegionKind::ReCanonical(..)\n-        | RegionKind::ReScope(..)\n-        | RegionKind::ReVar(..)\n-        | RegionKind::ReSkolemized(..)\n-        | RegionKind::ReFree(..) => {\n-            bug!(\"unexpected region in outlives inference: {:?}\", region);\n+            let predicate = outlives_predicate.subst(tcx, substs);\n+            debug!(\"predicate = {:?}\", &predicate);\n+            insert_outlives_predicate(tcx, predicate.0.into(), predicate.1, required_predicates);\n         }\n     }\n }"}, {"sha": "b5ba59d64cdc45d099549ace529532d9ad40e4a5", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -7,24 +7,20 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![allow(unused)]\n-#[allow(dead_code)]\n+\n use hir::map as hir_map;\n-use rustc::dep_graph::DepKind;\n use rustc::hir;\n-use rustc::hir::Ty_::*;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::maps::Providers;\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n-use util::nodemap::FxHashMap;\n \n mod explicit;\n-mod implicit_empty;\n mod implicit_infer;\n /// Code to write unit test for outlives.\n pub mod test;\n+mod utils;\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -38,22 +34,43 @@ fn inferred_outlives_of<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     item_def_id: DefId,\n ) -> Lrc<Vec<ty::Predicate<'tcx>>> {\n-    let id = tcx.hir\n+    let id = tcx\n+        .hir\n         .as_local_node_id(item_def_id)\n         .expect(\"expected local def-id\");\n \n     match tcx.hir.get(id) {\n         hir_map::NodeItem(item) => match item.node {\n             hir::ItemStruct(..) | hir::ItemEnum(..) | hir::ItemUnion(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n-                let dep_node = item_def_id.to_dep_node(tcx, DepKind::InferredOutlivesOf);\n-                tcx.dep_graph.read(dep_node);\n \n-                crate_map\n+                let predicates = crate_map\n                     .predicates\n                     .get(&item_def_id)\n                     .unwrap_or(&crate_map.empty_predicate)\n-                    .clone()\n+                    .clone();\n+\n+                if tcx.has_attr(item_def_id, \"rustc_outlives\") {\n+                    let mut pred: Vec<String> = predicates\n+                        .iter()\n+                        .map(|out_pred| match out_pred {\n+                            ty::Predicate::RegionOutlives(p) => format!(\"{}\", &p),\n+\n+                            ty::Predicate::TypeOutlives(p) => format!(\"{}\", &p),\n+\n+                            err => bug!(\"unexpected predicate {:?}\", err),\n+                        })\n+                        .collect();\n+                    pred.sort();\n+\n+                    let span = tcx.def_span(item_def_id);\n+                    let mut err = tcx.sess.struct_span_err(span, \"rustc_outlives\");\n+                    for p in &pred {\n+                        err.note(p);\n+                    }\n+                    err.emit();\n+                }\n+                predicates\n             }\n \n             _ => Lrc::new(Vec::new()),\n@@ -76,17 +93,18 @@ fn inferred_outlives_crate<'tcx>(\n \n     // Compute the inferred predicates\n     let exp = explicit::explicit_predicates(tcx, crate_num);\n-    let mut global_inferred_outlives = implicit_infer::infer_predicates(tcx, &exp);\n+    let global_inferred_outlives = implicit_infer::infer_predicates(tcx, &exp);\n \n     // Convert the inferred predicates into the \"collected\" form the\n     // global data structure expects.\n     //\n     // FIXME -- consider correcting impedance mismatch in some way,\n     // probably by updating the global data structure.\n-    let mut predicates = global_inferred_outlives\n+    let predicates = global_inferred_outlives\n         .iter()\n         .map(|(&def_id, set)| {\n-            let vec: Vec<ty::Predicate<'tcx>> = set.iter()\n+            let vec: Vec<ty::Predicate<'tcx>> = set\n+                .iter()\n                 .map(\n                     |ty::OutlivesPredicate(kind1, region2)| match kind1.unpack() {\n                         UnpackedKind::Type(ty1) => ty::Predicate::TypeOutlives(ty::Binder::bind("}, {"sha": "5cb1822b04e9d0d8c63dbecfa4f41d275da7da10", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::outlives::Component;\n+use rustc::ty::subst::{Kind, UnpackedKind};\n+use rustc::ty::{self, Region, RegionKind, Ty, TyCtxt};\n+use std::collections::BTreeSet;\n+\n+/// Tracks the `T: 'a` or `'a: 'a` predicates that we have inferred\n+/// must be added to the struct header.\n+pub type RequiredPredicates<'tcx> = BTreeSet<ty::OutlivesPredicate<Kind<'tcx>, ty::Region<'tcx>>>;\n+\n+/// Given a requirement `T: 'a` or `'b: 'a`, deduce the\n+/// outlives_component and add it to `required_predicates`\n+pub fn insert_outlives_predicate<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    kind: Kind<'tcx>,\n+    outlived_region: Region<'tcx>,\n+    required_predicates: &mut RequiredPredicates<'tcx>,\n+) {\n+    // If the `'a` region is bound within the field type itself, we\n+    // don't want to propagate this constraint to the header.\n+    if !is_free_region(outlived_region) {\n+        return;\n+    }\n+\n+    match kind.unpack() {\n+        UnpackedKind::Type(ty) => {\n+            // `T: 'outlived_region` for some type `T`\n+            // But T could be a lot of things:\n+            // e.g., if `T = &'b u32`, then `'b: 'outlived_region` is\n+            // what we want to add.\n+            //\n+            // Or if within `struct Foo<U>` you had `T = Vec<U>`, then\n+            // we would want to add `U: 'outlived_region`\n+            for component in tcx.outlives_components(ty) {\n+                match component {\n+                    Component::Region(r) => {\n+                        // This would arise from something like:\n+                        //\n+                        // ```\n+                        // struct Foo<'a, 'b> {\n+                        //    x:  &'a &'b u32\n+                        // }\n+                        // ```\n+                        //\n+                        // Here `outlived_region = 'a` and `kind = &'b\n+                        // u32`.  Decomposing `&'b u32` into\n+                        // components would yield `'b`, and we add the\n+                        // where clause that `'b: 'a`.\n+                        insert_outlives_predicate(\n+                            tcx,\n+                            r.into(),\n+                            outlived_region,\n+                            required_predicates,\n+                        );\n+                    }\n+\n+                    Component::Param(param_ty) => {\n+                        // param_ty: ty::ParamTy\n+                        // This would arise from something like:\n+                        //\n+                        // ```\n+                        // struct Foo<'a, U> {\n+                        //    x:  &'a Vec<U>\n+                        // }\n+                        // ```\n+                        //\n+                        // Here `outlived_region = 'a` and `kind =\n+                        // Vec<U>`.  Decomposing `Vec<U>` into\n+                        // components would yield `U`, and we add the\n+                        // where clause that `U: 'a`.\n+                        let ty: Ty<'tcx> = param_ty.to_ty(tcx);\n+                        required_predicates\n+                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n+                    }\n+\n+                    Component::Projection(proj_ty) => {\n+                        // This would arise from something like:\n+                        //\n+                        // ```\n+                        // struct Foo<'a, T: Iterator> {\n+                        //    x:  &'a <T as Iterator>::Item\n+                        // }\n+                        // ```\n+                        //\n+                        // Here we want to add an explicit `where <T as Iterator>::Item: 'a`.\n+                        let ty: Ty<'tcx> = tcx.mk_projection(proj_ty.item_def_id, proj_ty.substs);\n+                        required_predicates\n+                            .insert(ty::OutlivesPredicate(ty.into(), outlived_region));\n+                    }\n+\n+                    Component::EscapingProjection(_) => {\n+                        // As above, but the projection involves\n+                        // late-bound regions.  Therefore, the WF\n+                        // requirement is not checked in type definition\n+                        // but at fn call site, so ignore it.\n+                        //\n+                        // ```\n+                        // struct Foo<'a, T: Iterator> {\n+                        //    x: for<'b> fn(<&'b T as Iterator>::Item)\n+                        //              //  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+                        // }\n+                        // ```\n+                        //\n+                        // Since `'b` is not in scope on `Foo`, can't\n+                        // do anything here, ignore it.\n+                    }\n+\n+                    Component::UnresolvedInferenceVariable(_) => bug!(\"not using infcx\"),\n+                }\n+            }\n+        }\n+\n+        UnpackedKind::Lifetime(r) => {\n+            if !is_free_region(r) {\n+                return;\n+            }\n+            required_predicates.insert(ty::OutlivesPredicate(kind, outlived_region));\n+        }\n+    }\n+}\n+\n+fn is_free_region(region: Region<'_>) -> bool {\n+    // First, screen for regions that might appear in a type header.\n+    match region {\n+        // *These* correspond to `T: 'a` relationships where `'a` is\n+        // either declared on the type or `'static`:\n+        //\n+        //     struct Foo<'a, T> {\n+        //         field: &'a T, // this would generate a ReEarlyBound referencing `'a`\n+        //         field2: &'static T, // this would generate a ReStatic\n+        //     }\n+        //\n+        // We care about these, so fall through.\n+        RegionKind::ReStatic | RegionKind::ReEarlyBound(_) => true,\n+\n+        // Late-bound regions can appear in `fn` types:\n+        //\n+        //     struct Foo<T> {\n+        //         field: for<'b> fn(&'b T) // e.g., 'b here\n+        //     }\n+        //\n+        // The type above might generate a `T: 'b` bound, but we can\n+        // ignore it.  We can't put it on the struct header anyway.\n+        RegionKind::ReLateBound(..) => false,\n+\n+        // These regions don't appear in types from type declarations:\n+        RegionKind::ReEmpty\n+        | RegionKind::ReErased\n+        | RegionKind::ReClosureBound(..)\n+        | RegionKind::ReCanonical(..)\n+        | RegionKind::ReScope(..)\n+        | RegionKind::ReVar(..)\n+        | RegionKind::ReSkolemized(..)\n+        | RegionKind::ReFree(..) => {\n+            bug!(\"unexpected region in outlives inference: {:?}\", region);\n+        }\n+    }\n+}"}, {"sha": "4293fe9125dd3213f0722aea33f9ecfe3e47b4a0", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -795,6 +795,12 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                 attribute is an experimental \\\n                                                 feature\",\n                                                cfg_fn!(needs_panic_runtime))),\n+    (\"rustc_outlives\", Normal, Gated(Stability::Unstable,\n+                                     \"rustc_attrs\",\n+                                     \"the `#[rustc_outlives]` attribute \\\n+                                      is just used for rustc unit tests \\\n+                                      and will never be stable\",\n+                                     cfg_fn!(rustc_attrs))),\n     (\"rustc_variance\", Normal, Gated(Stability::Unstable,\n                                      \"rustc_attrs\",\n                                      \"the `#[rustc_variance]` attribute \\"}, {"sha": "5c392223f88b7dccc1a96e105fcd63dc4ac6c8da", "filename": "src/test/compile-fail/outlives-associated-types.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fcompile-fail%2Foutlives-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fcompile-fail%2Foutlives-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foutlives-associated-types.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-// Test that the outlives computation runs for now...\n-\n-#![feature(rustc_attrs)]\n-\n-//todo add all the test cases\n-// https://github.com/rust-lang/rfcs/blob/master/text/2093-infer-outlives.md#example-1-a-reference\n-\n-#[rustc_outlives]\n-struct Direct<'a, T> { //~ ERROR 21:1: 23:2: [Binder(OutlivesPredicate(T, ReEarlyBound(0, 'a)))] [E0640]\n-    field: &'a T\n-}\n-\n-fn main() { }"}, {"sha": "445c246a1206726243a59690964e163e40bf486c", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-dyn.rs", "status": "renamed", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-dyn.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,12 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+#![feature(infer_outlives_requirements)]\n \n-// Lifetime 'b needs to outlive lifetime 'a\n-struct Foo<'a,'b,T> {\n-    x: &'a &'b T //~ ERROR reference has a longer lifetime than the data it references [E0491]\n+trait Trait<'x, T> where T: 'x {\n }\n \n-fn main() {}\n+#[rustc_outlives]\n+struct Foo<'a, A> //~ ERROR 19:1: 22:2: rustc_outlives\n+{\n+    foo: Box<dyn Trait<'a, A>>\n+}\n \n+fn main() {}", "previous_filename": "src/test/ui/rfc-2093-infer-outlives/multiple-regions.rs"}, {"sha": "4bb5d90e9644ec30ff553243626d1e18a8930ad5", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-dyn.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-dyn.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,13 @@\n+error: rustc_outlives\n+  --> $DIR/explicit-dyn.rs:19:1\n+   |\n+LL | / struct Foo<'a, A> //~ ERROR 19:1: 22:2: rustc_outlives\n+LL | | {\n+LL | |     foo: Box<dyn Trait<'a, A>>\n+LL | | }\n+   | |_^\n+   |\n+   = note: A : 'a\n+\n+error: aborting due to previous error\n+"}, {"sha": "e85b49bb0bf2391caefc237a67aa53f2057cb018", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-enum.rs", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-enum.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n+#![feature(rustc_attrs)]\n #![feature(infer_outlives_requirements)]\n-// Outlives requirementes are inferred (RFC 2093)\n \n-// projections: infer <Iterator>::Item: 'a\n-struct ProjFoo<'a, T: Iterator> {\n-    bar: &'a T::Item\n+#[rustc_outlives]\n+enum Foo<'a, U> { //~ ERROR 15:1: 17:2: rustc_outlives\n+    One(Bar<'a, U>)\n }\n \n+struct Bar<'x, T> where T: 'x {\n+    x: &'x (),\n+    y: T,\n+}\n \n fn main() {}\n ", "previous_filename": "src/test/ui/rfc-2093-infer-outlives/projections-pass.rs"}, {"sha": "d7438758d77af350e60a16b4ec954322aec6f747", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-enum.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-enum.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,12 @@\n+error: rustc_outlives\n+  --> $DIR/explicit-enum.rs:15:1\n+   |\n+LL | / enum Foo<'a, U> { //~ ERROR 15:1: 17:2: rustc_outlives\n+LL | |     One(Bar<'a, U>)\n+LL | | }\n+   | |_^\n+   |\n+   = note: U : 'a\n+\n+error: aborting due to previous error\n+"}, {"sha": "45449fa0cf82d7906fe8a6388a182c4df7ed5739", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-impl-lifetime-pass.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-lifetime-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-lifetime-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-lifetime-pass.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-test\n-// compile-pass\n-\n-#![feature(infer_outlives_requirements)]\n-// Outlives requirementes are inferred (RFC 2093)\n-\n-trait MakeRef<'a>: 'a {\n-    type Type;\n-}\n-impl<'a, T> MakeRef<'a> for Vec<T>\n-where T: 'a,\n-{\n-    type Type = &'a T;\n-}\n-// explicit-impl: T: 'a\n-struct Foo<'a, T> {\n-    foo: <Vec<T> as MakeRef<'a>>::Type,\n-}\n-\n-fn main() {}"}, {"sha": "bfd6db1eb5d4e5f74318a3eb7d9e800cdc356275", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-impl-pass.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl-pass.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-test\n-// compile-pass\n-\n-#![feature(infer_outlives_requirements)]\n-// Outlives requirementes are inferred (RFC 2093)\n-\n-trait MakeRef<'a> {\n-    type Type;\n-}\n-impl<'a, T> MakeRef<'a> for Vec<T>\n-where T: 'a,\n-{\n-    type Type = &'a T;\n-}\n-// explicit-impl: T: 'a\n-struct Foo<'a, T> {\n-    foo: <Vec<T> as MakeRef<'a>>::Type,\n-}\n-\n-fn main() {}"}, {"sha": "3a10087551c4e8c2295957f5a10fc6c390204ef3", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-impl.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-// Needs an explicit where clause stating outlives condition. (RFC 2093)\n-\n-trait MakeRef<'a> {\n-    type Type;\n-}\n-\n-impl<'a, T> MakeRef<'a> for Vec<T>\n-  where T: 'a\n-{\n-    type Type = &'a T;\n-}\n-\n-// Type T needs to outlive lifetime 'a, as stated in impl.\n-struct Foo<'a, T> {\n-    foo: <Vec<T> as MakeRef<'a>>::Type //~ Error the parameter type `T` may not live long enough [E0309]\n-}\n-\n-fn main() { }"}, {"sha": "498d66ef9a542be9a580f6f0b01d919d5e935bba", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-impl.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-impl.stderr?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,17 +0,0 @@\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/explicit-impl.rs:27:5\n-   |\n-LL | struct Foo<'a, T> {\n-   |                - help: consider adding an explicit lifetime bound `T: 'a`...\n-LL |     foo: <Vec<T> as MakeRef<'a>>::Type //~ Error the parameter type `T` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/explicit-impl.rs:27:5\n-   |\n-LL |     foo: <Vec<T> as MakeRef<'a>>::Type //~ Error the parameter type `T` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0309`."}, {"sha": "2662043c36d59c9e01a461a9d712fc78bd2e10f5", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-projection.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-projection.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![feature(infer_outlives_requirements)]\n+\n+trait Trait<'x, T> where T: 'x {\n+    type Type;\n+}\n+\n+#[rustc_outlives]\n+struct Foo<'a, A, B> where A: Trait<'a, B> //~ ERROR rustc_outlives\n+{\n+    foo: <A as Trait<'a, B>>::Type\n+}\n+\n+fn main() {}"}, {"sha": "43ab02d01ed57293862b3a099219bd22b60fe641", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-projection.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-projection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-projection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-projection.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,13 @@\n+error: rustc_outlives\n+  --> $DIR/explicit-projection.rs:19:1\n+   |\n+LL | / struct Foo<'a, A, B> where A: Trait<'a, B> //~ ERROR rustc_outlives\n+LL | | {\n+LL | |     foo: <A as Trait<'a, B>>::Type\n+LL | | }\n+   | |_^\n+   |\n+   = note: B : 'a\n+\n+error: aborting due to previous error\n+"}, {"sha": "d42c9160e1e751c554906ab989f29ee66a7e5fc4", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-struct.rs", "status": "renamed", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-struct.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,20 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n+#![feature(rustc_attrs)]\n #![feature(infer_outlives_requirements)]\n-// Outlives requirementes are inferred (RFC 2093)\n \n-// explicit-where: infer U: 'b\n-struct ExFoo<'b, U> {\n-    bar: ExBar<'b, U>\n+#[rustc_outlives]\n+struct Foo<'b, U> { //~ ERROR 15:1: 17:2: rustc_outlives\n+    bar: Bar<'b, U>\n }\n-struct ExBar<'a, T> where T: 'a {\n+\n+struct Bar<'a, T> where T: 'a {\n     x: &'a (),\n     y: T,\n }\n \n-\n fn main() {}\n ", "previous_filename": "src/test/ui/rfc-2093-infer-outlives/explicit-where-pass.rs"}, {"sha": "0223f707e8d9bc449059eba59ae23e177af0e67d", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-struct.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-struct.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,12 @@\n+error: rustc_outlives\n+  --> $DIR/explicit-struct.rs:15:1\n+   |\n+LL | / struct Foo<'b, U> { //~ ERROR 15:1: 17:2: rustc_outlives\n+LL | |     bar: Bar<'b, U>\n+LL | | }\n+   | |_^\n+   |\n+   = note: U : 'b\n+\n+error: aborting due to previous error\n+"}, {"sha": "e548b24719383cb0697a5a50278922205408b845", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-union.rs", "status": "renamed", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,17 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n+#![feature(rustc_attrs)]\n #![feature(infer_outlives_requirements)]\n-// Outlives requirementes are inferred (RFC 2093)\n+#![feature(untagged_unions)]\n+#![allow(unions_with_drop_fields)]\n+\n \n-// nested-structs: infer U: 'b and therefore T: 'a\n-struct NestFoo<'a, T> {\n-    field1: NestBar<'a, T>\n+#[rustc_outlives]\n+union Foo<'b, U> { //~ ERROR 18:1: 20:2: rustc_outlives\n+    bar: Bar<'b, U>\n }\n-struct NestBar<'b, U> {\n-    field2: &'b U\n+\n+union Bar<'a, T> where T: 'a {\n+    x: &'a (),\n+    y: T,\n }\n \n fn main() {}", "previous_filename": "src/test/ui/rfc-2093-infer-outlives/nested-structs-pass.rs"}, {"sha": "8622ae12aa10cb95a63cfabb6f20276e964540fa", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-union.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,12 @@\n+error: rustc_outlives\n+  --> $DIR/explicit-union.rs:18:1\n+   |\n+LL | / union Foo<'b, U> { //~ ERROR 18:1: 20:2: rustc_outlives\n+LL | |     bar: Bar<'b, U>\n+LL | | }\n+   | |_^\n+   |\n+   = note: U : 'b\n+\n+error: aborting due to previous error\n+"}, {"sha": "81734bf514ef3e214bba2e3ce2d3e9f69b149a91", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-where.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Needs an explicit where clause stating outlives condition. (RFC 2093)\n-\n-// Type U needs to outlive lifetime 'b.\n-struct Foo<'b, U> {\n-    bar: Bar<'b, U> //~ Error the parameter type `U` may not live long enough [E0309]\n-}\n-\n-struct Bar<'a, T> where T: 'a {\n-    x: &'a (),\n-    y: T,\n-}\n-\n-fn main() { }"}, {"sha": "436754c7dc1cd1235ac9afc63b5f4d2c24cc38e2", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-where.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-where.stderr?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,17 +0,0 @@\n-error[E0309]: the parameter type `U` may not live long enough\n-  --> $DIR/explicit-where.rs:15:5\n-   |\n-LL | struct Foo<'b, U> {\n-   |                - help: consider adding an explicit lifetime bound `U: 'b`...\n-LL |     bar: Bar<'b, U> //~ Error the parameter type `U` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `U` will meet its required lifetime bounds\n-  --> $DIR/explicit-where.rs:15:5\n-   |\n-LL |     bar: Bar<'b, U> //~ Error the parameter type `U` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0309`."}, {"sha": "3722abd5ad6484b0f3049bc7ad763d13ceb9d787", "filename": "src/test/ui/rfc-2093-infer-outlives/multiple-regions.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fmultiple-regions.stderr?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,20 +0,0 @@\n-error[E0491]: in type `&'a &'b T`, reference has a longer lifetime than the data it references\n-  --> $DIR/multiple-regions.rs:15:5\n-   |\n-LL |     x: &'a &'b T //~ ERROR reference has a longer lifetime than the data it references [E0491]\n-   |     ^^^^^^^^^^^^\n-   |\n-note: the pointer is valid for the lifetime 'a as defined on the struct at 14:1\n-  --> $DIR/multiple-regions.rs:14:1\n-   |\n-LL | struct Foo<'a,'b,T> {\n-   | ^^^^^^^^^^^^^^^^^^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the struct at 14:1\n-  --> $DIR/multiple-regions.rs:14:1\n-   |\n-LL | struct Foo<'a,'b,T> {\n-   | ^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0491`."}, {"sha": "85f381ea515c33e93b4a90274b04b34334aacd69", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-enum.rs", "status": "renamed", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-enum.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,31 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n+#![feature(rustc_attrs)]\n #![feature(infer_outlives_requirements)]\n \n-// Type T needs to outlive lifetime 'a.\n-enum Foo<'a, T> {\n+\n+#[rustc_outlives]\n+enum Foo<'a, T> { //~ ERROR 16:1: 19:2: rustc_outlives\n \n     One(Bar<'a, T>)\n }\n \n-// Type U needs to outlive lifetime 'b\n struct Bar<'b, U> {\n     field2: &'b U\n }\n \n-\n-\n-// Type K needs to outlive lifetime 'c.\n-enum Ying<'c, K> {\n-    One(&'c Yang<K>)\n-}\n-\n-struct Yang<V> {\n-    field2: V\n-}\n-\n fn main() {}\n-", "previous_filename": "src/test/ui/rfc-2093-infer-outlives/enum-pass.rs"}, {"sha": "54a886a92fd409d3d47624bac3e1c5ac56fbb401", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-enum.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-enum.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,13 @@\n+error: rustc_outlives\n+  --> $DIR/nested-enum.rs:16:1\n+   |\n+LL | / enum Foo<'a, T> { //~ ERROR 16:1: 19:2: rustc_outlives\n+LL | |\n+LL | |     One(Bar<'a, T>)\n+LL | | }\n+   | |_^\n+   |\n+   = note: T : 'a\n+\n+error: aborting due to previous error\n+"}, {"sha": "792d2a02962dcc54e01f8e69a228a0c3e779b219", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-regions.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-regions.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,15 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n+#![feature(rustc_attrs)]\n #![feature(infer_outlives_requirements)]\n-// Outlives requirementes are inferred (RFC 2093)\n \n-// multiple-regions: infer 'b: 'a\n-struct MultiFoo<'a, 'b, T> {\n+#[rustc_outlives]\n+struct Foo<'a, 'b, T> { //~ ERROR 15:1: 17:2: rustc_outlives\n     x: &'a &'b T\n }\n \n fn main() {}\n-", "previous_filename": "src/test/ui/rfc-2093-infer-outlives/multiple-regions-pass.rs"}, {"sha": "04fe4814a0415fb800a682a2c1c490d0d6a8ec87", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-regions.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-regions.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,14 @@\n+error: rustc_outlives\n+  --> $DIR/nested-regions.rs:15:1\n+   |\n+LL | / struct Foo<'a, 'b, T> { //~ ERROR 15:1: 17:2: rustc_outlives\n+LL | |     x: &'a &'b T\n+LL | | }\n+   | |_^\n+   |\n+   = note: 'b : 'a\n+   = note: T : 'a\n+   = note: T : 'b\n+\n+error: aborting due to previous error\n+"}, {"sha": "71a36dfb344233b048c8f985fb98e3f813891b97", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-structs.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,19 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+#![feature(rustc_attrs)]\n+#![feature(infer_outlives_requirements)]\n \n-\n-// Type T needs to outlive lifetime 'a. This is not reported due to\n-// a compilation error in Bar.\n-struct Foo<'a, T> {\n+#[rustc_outlives]\n+struct Foo<'a, T> { //~ ERROR 15:1: 17:2: rustc_outlives\n     field1: Bar<'a, T>\n }\n \n-// Type U needs to outlive lifetime 'b\n struct Bar<'b, U> {\n-    field2: &'b U //~ ERROR the parameter type `U` may not live long enough [E0309]\n+    field2: &'b U\n }\n \n fn main() {}\n-"}, {"sha": "abea71f2d12fcf77dfc556b7af27f45c90f128dc", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-structs.stderr", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-structs.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -1,17 +1,12 @@\n-error[E0309]: the parameter type `U` may not live long enough\n-  --> $DIR/nested-structs.rs:22:5\n+error: rustc_outlives\n+  --> $DIR/nested-structs.rs:15:1\n    |\n-LL | struct Bar<'b, U> {\n-   |                - help: consider adding an explicit lifetime bound `U: 'b`...\n-LL |     field2: &'b U //~ ERROR the parameter type `U` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^\n+LL | / struct Foo<'a, T> { //~ ERROR 15:1: 17:2: rustc_outlives\n+LL | |     field1: Bar<'a, T>\n+LL | | }\n+   | |_^\n    |\n-note: ...so that the reference type `&'b U` does not outlive the data it points at\n-  --> $DIR/nested-structs.rs:22:5\n-   |\n-LL |     field2: &'b U //~ ERROR the parameter type `U` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^\n+   = note: T : 'a\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0309`."}, {"sha": "0720e581e2c5b8783df95b3e3f2ec0d642abec7e", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-union.rs", "status": "renamed", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n+#![feature(rustc_attrs)]\n #![feature(infer_outlives_requirements)]\n #![feature(untagged_unions)]\n #![allow(unions_with_drop_fields)]\n \n-// Type T needs to outlive lifetime 'a. This is not reported due to\n-// a compilation error in Bar.\n-union Foo<'a, T> {\n+\n+#[rustc_outlives]\n+union Foo<'a, T> { //~ ERROR 18:1: 20:2: rustc_outlives\n     field1: Bar<'a, T>\n }\n \n@@ -25,15 +24,4 @@ union Bar<'b, U> {\n     field2: &'b U\n }\n \n-\n-// Type K needs to outlive lifetime 'c.\n-union Ying<'c, K> {\n-    field1: &'c Yang<K>\n-}\n-\n-union Yang<V> {\n-    field2: V\n-}\n-\n fn main() {}\n-", "previous_filename": "src/test/ui/rfc-2093-infer-outlives/union-pass.rs"}, {"sha": "b7b50c1506146a0e80401a886dd09a86b2af304f", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-union.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,12 @@\n+error: rustc_outlives\n+  --> $DIR/nested-union.rs:18:1\n+   |\n+LL | / union Foo<'a, T> { //~ ERROR 18:1: 20:2: rustc_outlives\n+LL | |     field1: Bar<'a, T>\n+LL | | }\n+   | |_^\n+   |\n+   = note: T : 'a\n+\n+error: aborting due to previous error\n+"}, {"sha": "3abce873b28f9967d2f05ce3ca77aaed734a44ad", "filename": "src/test/ui/rfc-2093-infer-outlives/projection.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojection.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -8,16 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-pass\n-\n+#![feature(rustc_attrs)]\n #![feature(infer_outlives_requirements)]\n-// Outlives requirementes are inferred (RFC 2093)\n \n-// reference: infer T: 'a\n-struct RefFoo<'a, T> {\n-    bar: &'a [T]\n+#[rustc_outlives]\n+struct Foo<'a, T: Iterator> { //~ ERROR rustc_outlives\n+    bar: &'a T::Item\n }\n \n-\n fn main() {}\n ", "previous_filename": "src/test/ui/rfc-2093-infer-outlives/reference-pass.rs"}, {"sha": "dfaf7793a51f26f23e684825739580d272eb285c", "filename": "src/test/ui/rfc-2093-infer-outlives/projection.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojection.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,12 @@\n+error: rustc_outlives\n+  --> $DIR/projection.rs:15:1\n+   |\n+LL | / struct Foo<'a, T: Iterator> { //~ ERROR rustc_outlives\n+LL | |     bar: &'a T::Item\n+LL | | }\n+   | |_^\n+   |\n+   = note: <T as std::iter::Iterator>::Item : 'a\n+\n+error: aborting due to previous error\n+"}, {"sha": "f6a557c174c19115da92b32465c6e1037e003561", "filename": "src/test/ui/rfc-2093-infer-outlives/projections.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-// Needs an explicit where clause stating outlives condition. RFC 2093\n-\n-// Associated type <Iterator>::Item  needs to outlives lifetime 'a.\n-struct Foo<'a, T: Iterator> {\n-    bar: &'a T::Item //~ Error the associated type `<T as std::iter::Iterator>::Item` may not live long enough [E0309]\n-}\n-\n-fn main() { }"}, {"sha": "9969cf48ecd3b735aa9ca00f2cdcf20078fbf7cf", "filename": "src/test/ui/rfc-2093-infer-outlives/projections.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fprojections.stderr?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,16 +0,0 @@\n-error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n-  --> $DIR/projections.rs:17:5\n-   |\n-LL |     bar: &'a T::Item //~ Error the associated type `<T as std::iter::Iterator>::Item` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: 'a`...\n-note: ...so that the reference type `&'a <T as std::iter::Iterator>::Item` does not outlive the data it points at\n-  --> $DIR/projections.rs:17:5\n-   |\n-LL |     bar: &'a T::Item //~ Error the associated type `<T as std::iter::Iterator>::Item` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0309`."}, {"sha": "56b1bc3c7d11ee0999247b209389cf33246db5c3", "filename": "src/test/ui/rfc-2093-infer-outlives/reference.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Needs an explicit where clause stating outlives condition. (RFC 2093)\n+#![feature(rustc_attrs)]\n+#![feature(infer_outlives_requirements)]\n \n-// Type T needs to outlive lifetime 'a.\n-struct Foo<'a, T> {\n-    bar: &'a [T] //~ ERROR the parameter type `T` may not live long enough [E0309]\n+#[rustc_outlives]\n+struct Foo<'a, T> { //~ ERROR rustc_outlives\n+    bar: &'a T,\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "785d76e8f22756c49da849289424f6fa281a7a0c", "filename": "src/test/ui/rfc-2093-infer-outlives/reference.stderr", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Freference.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -1,17 +1,12 @@\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/reference.rs:15:5\n+error: rustc_outlives\n+  --> $DIR/reference.rs:15:1\n    |\n-LL | struct Foo<'a, T> {\n-   |                - help: consider adding an explicit lifetime bound `T: 'a`...\n-LL |     bar: &'a [T] //~ ERROR the parameter type `T` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^\n+LL | / struct Foo<'a, T> { //~ ERROR rustc_outlives\n+LL | |     bar: &'a T,\n+LL | | }\n+   | |_^\n    |\n-note: ...so that the reference type `&'a [T]` does not outlive the data it points at\n-  --> $DIR/reference.rs:15:5\n-   |\n-LL |     bar: &'a [T] //~ ERROR the parameter type `T` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^\n+   = note: T : 'a\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0309`."}, {"sha": "a19bcf8afff9a8d35fad799e6ad81745c0ac505c", "filename": "src/test/ui/rfc-2093-infer-outlives/self-dyn.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-dyn.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+#![feature(infer_outlives_requirements)]\n+\n+trait Trait<'x, 's, T> where T: 'x,\n+      's: {\n+}\n+\n+#[rustc_outlives]\n+struct Foo<'a, 'b, A> //~ ERROR 20:1: 23:2: rustc_outlives\n+{\n+    foo: Box<dyn Trait<'a, 'b, A>>\n+}\n+\n+fn main() {}"}, {"sha": "546ba9db6446007a211b060726807b6c898b18d0", "filename": "src/test/ui/rfc-2093-infer-outlives/self-dyn.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-dyn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-dyn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-dyn.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,13 @@\n+error: rustc_outlives\n+  --> $DIR/self-dyn.rs:20:1\n+   |\n+LL | / struct Foo<'a, 'b, A> //~ ERROR 20:1: 23:2: rustc_outlives\n+LL | | {\n+LL | |     foo: Box<dyn Trait<'a, 'b, A>>\n+LL | | }\n+   | |_^\n+   |\n+   = note: A : 'a\n+\n+error: aborting due to previous error\n+"}, {"sha": "c4f8f83bdcefd0d77d547d477d568b22c373e267", "filename": "src/test/ui/rfc-2093-infer-outlives/self-structs.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-structs.rs?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![feature(infer_outlives_requirements)]\n+\n+#[rustc_outlives]\n+struct Foo<'a, 'b, T> { //~ ERROR 15:1: 17:2: rustc_outlives\n+    field1: Bar<'a, 'b, T>\n+}\n+\n+trait Bar<'x, 's, U>\n+    where U: 'x,\n+    Self:'s\n+{}\n+\n+fn main() {}"}, {"sha": "04284577a07467c25052be427031df1afece9ba2", "filename": "src/test/ui/rfc-2093-infer-outlives/self-structs.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3da712381d0d264e31dcfaf9b29bbe8d4a8d1474/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fself-structs.stderr?ref=3da712381d0d264e31dcfaf9b29bbe8d4a8d1474", "patch": "@@ -0,0 +1,12 @@\n+error: rustc_outlives\n+  --> $DIR/self-structs.rs:15:1\n+   |\n+LL | / struct Foo<'a, 'b, T> { //~ ERROR 15:1: 17:2: rustc_outlives\n+LL | |     field1: Bar<'a, 'b, T>\n+LL | | }\n+   | |_^\n+   |\n+   = note: T : 'a\n+\n+error: aborting due to previous error\n+"}, {"sha": "36b1dccb13ebb7907daa8e2f08c422fe8975aa18", "filename": "src/test/ui/rfc-2093-infer-outlives/union.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,40 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-// Needs an explicit where clause stating outlives condition. (RFC 2093)\n-\n-#![feature(untagged_unions)]\n-\n-// Type T needs to outlive lifetime 'a. This is not reported due to\n-// a compilation error in Bar.\n-union Foo<'a, T> {\n-    field1: Bar<'a, T>\n-}\n-\n-// Type U needs to outlive lifetime 'b\n-union Bar<'b, U> {\n-    field2: &'b U //~ ERROR 25:5: 25:18: the parameter type `U` may not live long enough [E0309]\n-}\n-\n-\n-// Type K needs to outlive lifetime 'c.\n-union Ying<'c, K> {\n-    field1: &'c Yang<K> //~ ERROR 31:5: 31:24: the parameter type `K` may not live long enough [E0309]\n-}\n-\n-union Yang<V> {\n-    field2: V\n-}\n-\n-\n-fn main() {}\n-"}, {"sha": "cd13c423293329c9730d8b785e53a8e86881d51b", "filename": "src/test/ui/rfc-2093-infer-outlives/union.stderr", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Funion.stderr?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1,31 +0,0 @@\n-error[E0309]: the parameter type `U` may not live long enough\n-  --> $DIR/union.rs:25:5\n-   |\n-LL | union Bar<'b, U> {\n-   |               - help: consider adding an explicit lifetime bound `U: 'b`...\n-LL |     field2: &'b U //~ ERROR 25:5: 25:18: the parameter type `U` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'b U` does not outlive the data it points at\n-  --> $DIR/union.rs:25:5\n-   |\n-LL |     field2: &'b U //~ ERROR 25:5: 25:18: the parameter type `U` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^\n-\n-error[E0309]: the parameter type `K` may not live long enough\n-  --> $DIR/union.rs:31:5\n-   |\n-LL | union Ying<'c, K> {\n-   |                - help: consider adding an explicit lifetime bound `K: 'c`...\n-LL |     field1: &'c Yang<K> //~ ERROR 31:5: 31:24: the parameter type `K` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'c Yang<K>` does not outlive the data it points at\n-  --> $DIR/union.rs:31:5\n-   |\n-LL |     field1: &'c Yang<K> //~ ERROR 31:5: 31:24: the parameter type `K` may not live long enough [E0309]\n-   |     ^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0309`."}]}