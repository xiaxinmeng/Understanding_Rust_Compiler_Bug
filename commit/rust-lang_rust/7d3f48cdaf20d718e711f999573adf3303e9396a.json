{"sha": "7d3f48cdaf20d718e711f999573adf3303e9396a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkM2Y0OGNkYWYyMGQ3MThlNzExZjk5OTU3M2FkZjMzMDNlOTM5NmE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-17T09:59:04Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-17T09:59:04Z"}, "message": "Merge #968\n\n968: Macro aware name resoltion r=matklad a=matklad\n\nThe first commit lays the ground work for new name resolution, including\r\n\r\n* extracting position-indendent items from parse trees\r\n* walking the tree of modules\r\n* old-style macro_rules resolve\r\n\r\ncc @pnkfelix: this looks like an API name resolution should interact with. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "df584fbb044cad23e196da5ae0b3636b06bfeeff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df584fbb044cad23e196da5ae0b3636b06bfeeff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d3f48cdaf20d718e711f999573adf3303e9396a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d3f48cdaf20d718e711f999573adf3303e9396a", "html_url": "https://github.com/rust-lang/rust/commit/7d3f48cdaf20d718e711f999573adf3303e9396a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d3f48cdaf20d718e711f999573adf3303e9396a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "65e763fa84ae70ec9cee13f434acaae5371ad8e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/65e763fa84ae70ec9cee13f434acaae5371ad8e5", "html_url": "https://github.com/rust-lang/rust/commit/65e763fa84ae70ec9cee13f434acaae5371ad8e5"}, {"sha": "3a770233652cbf3e48688dd5f1d9f3c363eda5a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a770233652cbf3e48688dd5f1d9f3c363eda5a8", "html_url": "https://github.com/rust-lang/rust/commit/3a770233652cbf3e48688dd5f1d9f3c363eda5a8"}], "stats": {"total": 4007, "additions": 2053, "deletions": 1954}, "files": [{"sha": "2b1001d488b18682a6b7053aa30b01e645f3deb1", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -124,6 +124,10 @@ impl CrateGraph {\n         self.arena.is_empty()\n     }\n \n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = CrateId> + 'a {\n+        self.arena.keys().map(|it| *it)\n+    }\n+\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n         self.arena[&crate_id].file_id\n     }"}, {"sha": "b00481cd592df1b5662f5370f9382276a3540903", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -8,13 +8,12 @@ use crate::{\n     Name, ScopesWithSourceMap, Ty, HirFileId,\n     HirDatabase, PersistentHirDatabase,\n     type_ref::TypeRef,\n-    nameres::{ModuleScope, Namespace, lower::ImportId},\n+    nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n     expr::{Body, BodySourceMap},\n     ty::InferenceResult,\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::GenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n-    module_tree::ModuleId,\n     ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n     impl_block::ImplBlock,\n     resolve::Resolver,\n@@ -65,7 +64,7 @@ impl Crate {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Module {\n     pub(crate) krate: Crate,\n-    pub(crate) module_id: ModuleId,\n+    pub(crate) module_id: CrateModuleId,\n }\n \n /// The defs which can be visible in the module.\n@@ -173,24 +172,24 @@ impl Module {\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(&self, db: &impl HirDatabase) -> ModuleScope {\n-        db.item_map(self.krate)[self.module_id].clone()\n+        db.crate_def_map(self.krate)[self.module_id].scope.clone()\n     }\n \n     pub fn problems(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n         self.problems_impl(db)\n     }\n \n     pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n-        let item_map = db.item_map(self.krate);\n-        Resolver::default().push_module_scope(item_map, *self)\n+        let def_map = db.crate_def_map(self.krate);\n+        Resolver::default().push_module_scope(def_map, self.module_id)\n     }\n \n     pub fn declarations(self, db: &impl HirDatabase) -> Vec<ModuleDef> {\n-        let lowered_module = db.lower_module(self);\n-        lowered_module\n-            .declarations\n-            .values()\n-            .cloned()\n+        let def_map = db.crate_def_map(self.krate);\n+        def_map[self.module_id]\n+            .scope\n+            .entries()\n+            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n             .flat_map(|per_ns| {\n                 per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n             })"}, {"sha": "cc87c6f14027e60def963950cd6e74c244832119", "filename": "crates/ra_hir/src/code_model_impl/krate.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -18,9 +18,7 @@ impl Crate {\n             .collect()\n     }\n     pub(crate) fn root_module_impl(&self, db: &impl PersistentHirDatabase) -> Option<Module> {\n-        let module_tree = db.module_tree(*self);\n-        let module_id = module_tree.modules().next()?;\n-\n+        let module_id = db.crate_def_map(*self).root();\n         let module = Module { krate: *self, module_id };\n         Some(module)\n     }"}, {"sha": "f7d15c55e9242874d7bccc0f1e24ad2d7cb97fd8", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 69, "deletions": 35, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -1,95 +1,129 @@\n-use ra_syntax::{ast, SyntaxNode, TreeArc};\n+use ra_db::FileId;\n+use ra_syntax::{ast, SyntaxNode, TreeArc, AstNode};\n \n use crate::{\n-    Module, ModuleSource, Problem,\n-    Name,\n-    module_tree::ModuleId,\n-    nameres::lower::ImportId,\n+    Module, ModuleSource, Problem, Name,\n+    nameres::{CrateModuleId, ImportId},\n     HirDatabase, PersistentHirDatabase,\n-    HirFileId\n+    HirFileId, SourceItemId,\n };\n \n+impl ModuleSource {\n+    pub(crate) fn new(\n+        db: &impl PersistentHirDatabase,\n+        file_id: Option<FileId>,\n+        decl_id: Option<SourceItemId>,\n+    ) -> ModuleSource {\n+        match (file_id, decl_id) {\n+            (Some(file_id), _) => {\n+                let source_file = db.parse(file_id);\n+                ModuleSource::SourceFile(source_file)\n+            }\n+            (None, Some(item_id)) => {\n+                let module = db.file_item(item_id);\n+                let module = ast::Module::cast(&*module).unwrap();\n+                assert!(module.item_list().is_some(), \"expected inline module\");\n+                ModuleSource::Module(module.to_owned())\n+            }\n+            (None, None) => panic!(),\n+        }\n+    }\n+}\n+\n impl Module {\n-    fn with_module_id(&self, module_id: ModuleId) -> Module {\n+    fn with_module_id(&self, module_id: CrateModuleId) -> Module {\n         Module { module_id, krate: self.krate }\n     }\n \n     pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Option<Name> {\n-        let module_tree = db.module_tree(self.krate);\n-        let link = self.module_id.parent_link(&module_tree)?;\n-        Some(link.name(&module_tree).clone())\n+        let def_map = db.crate_def_map(self.krate);\n+        let parent = def_map[self.module_id].parent?;\n+        def_map[parent].children.iter().find_map(|(name, module_id)| {\n+            if *module_id == self.module_id {\n+                Some(name.clone())\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     pub(crate) fn definition_source_impl(\n         &self,\n         db: &impl PersistentHirDatabase,\n     ) -> (HirFileId, ModuleSource) {\n-        let module_tree = db.module_tree(self.krate);\n-        let file_id = self.module_id.file_id(&module_tree);\n-        let decl_id = self.module_id.decl_id(&module_tree);\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl_id = def_map[self.module_id].declaration;\n+        let file_id = def_map[self.module_id].definition;\n         let module_source = ModuleSource::new(db, file_id, decl_id);\n+        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id);\n         (file_id, module_source)\n     }\n \n     pub(crate) fn declaration_source_impl(\n         &self,\n         db: &impl HirDatabase,\n     ) -> Option<(HirFileId, TreeArc<ast::Module>)> {\n-        let module_tree = db.module_tree(self.krate);\n-        let link = self.module_id.parent_link(&module_tree)?;\n-        let file_id = link.owner(&module_tree).file_id(&module_tree);\n-        let src = link.source(&module_tree, db);\n-        Some((file_id, src))\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl = def_map[self.module_id].declaration?;\n+        let syntax_node = db.file_item(decl);\n+        let ast = ast::Module::cast(&syntax_node).unwrap().to_owned();\n+        Some((decl.file_id, ast))\n     }\n \n     pub(crate) fn import_source_impl(\n         &self,\n         db: &impl HirDatabase,\n         import: ImportId,\n     ) -> TreeArc<ast::PathSegment> {\n-        let (_, source_map) = db.lower_module_with_source_map(*self);\n-        let (_, source) = self.definition_source(db);\n+        let (file_id, source) = self.definition_source(db);\n+        let (_, source_map) = db.raw_items_with_source_map(file_id.original_file(db));\n         source_map.get(&source, import)\n     }\n \n     pub(crate) fn crate_root_impl(&self, db: &impl PersistentHirDatabase) -> Module {\n-        let module_tree = db.module_tree(self.krate);\n-        let module_id = self.module_id.crate_root(&module_tree);\n-        self.with_module_id(module_id)\n+        let def_map = db.crate_def_map(self.krate);\n+        self.with_module_id(def_map.root())\n     }\n \n     /// Finds a child module with the specified name.\n     pub(crate) fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let module_tree = db.module_tree(self.krate);\n-        let child_id = self.module_id.child(&module_tree, name)?;\n-        Some(self.with_module_id(child_id))\n+        let def_map = db.crate_def_map(self.krate);\n+        let child_id = def_map[self.module_id].children.get(name)?;\n+        Some(self.with_module_id(*child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub(crate) fn children_impl(\n         &self,\n         db: &impl PersistentHirDatabase,\n     ) -> impl Iterator<Item = Module> {\n-        let module_tree = db.module_tree(self.krate);\n-        let children = self\n-            .module_id\n-            .children(&module_tree)\n-            .map(|(_, module_id)| self.with_module_id(module_id))\n+        let def_map = db.crate_def_map(self.krate);\n+        let children = def_map[self.module_id]\n+            .children\n+            .iter()\n+            .map(|(_, module_id)| self.with_module_id(*module_id))\n             .collect::<Vec<_>>();\n         children.into_iter()\n     }\n \n     pub(crate) fn parent_impl(&self, db: &impl PersistentHirDatabase) -> Option<Module> {\n-        let module_tree = db.module_tree(self.krate);\n-        let parent_id = self.module_id.parent(&module_tree)?;\n+        let def_map = db.crate_def_map(self.krate);\n+        let parent_id = def_map[self.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n \n     pub(crate) fn problems_impl(\n         &self,\n         db: &impl HirDatabase,\n     ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        let module_tree = db.module_tree(self.krate);\n-        self.module_id.problems(&module_tree, db)\n+        let def_map = db.crate_def_map(self.krate);\n+        let (my_file_id, _) = self.definition_source(db);\n+        // FIXME: not entirely corret filterint by module\n+        def_map\n+            .problems()\n+            .iter()\n+            .filter(|(source_item_id, _problem)| my_file_id == source_item_id.file_id)\n+            .map(|(source_item_id, problem)| (db.file_item(*source_item_id), problem.clone()))\n+            .collect()\n     }\n }"}, {"sha": "c7bad7e2b4fc570c9609f946e1ec3e2d562fb2c5", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -1,23 +1,18 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceDatabase, salsa};\n+use ra_db::{SourceDatabase, salsa, FileId};\n \n use crate::{\n-    MacroCallId, HirFileId,\n-    SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n+    HirFileId, SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     Function, FnSignature, ExprScopes, TypeAlias,\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n-    macros::MacroExpansion,\n-    module_tree::ModuleTree,\n-    nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n+    nameres::{Namespace, ImportSourceMap, RawItems, CrateDefMap},\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig},\n     adt::{StructData, EnumData},\n     impl_block::{ModuleImplBlocks, ImplSourceMap},\n     generics::{GenericParams, GenericDef},\n-    ids::SourceFileItemId,\n-    nameres::Namespace,\n     type_ref::TypeRef,\n };\n \n@@ -26,9 +21,6 @@ pub trait PersistentHirDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(HirFileId::hir_parse)]\n     fn hir_parse(&self, file_id: HirFileId) -> TreeArc<SourceFile>;\n \n-    #[salsa::invoke(crate::macros::expand_macro_invocation)]\n-    fn expand_macro_invocation(&self, invoc: MacroCallId) -> Option<Arc<MacroExpansion>>;\n-\n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n     fn struct_data(&self, s: Struct) -> Arc<StructData>;\n \n@@ -41,27 +33,14 @@ pub trait PersistentHirDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::ids::SourceFileItems::file_item_query)]\n     fn file_item(&self, source_item_id: SourceItemId) -> TreeArc<SyntaxNode>;\n \n-    #[salsa::invoke(crate::module_tree::Submodule::submodules_query)]\n-    fn submodules(\n-        &self,\n-        file_id: HirFileId,\n-        delc_id: Option<SourceFileItemId>,\n-    ) -> Arc<Vec<crate::module_tree::Submodule>>;\n-\n-    #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_with_source_map_query)]\n-    fn lower_module_with_source_map(\n-        &self,\n-        module: Module,\n-    ) -> (Arc<LoweredModule>, Arc<ImportSourceMap>);\n-\n-    #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_query)]\n-    fn lower_module(&self, module: Module) -> Arc<LoweredModule>;\n+    #[salsa::invoke(RawItems::raw_items_query)]\n+    fn raw_items(&self, file_id: FileId) -> Arc<RawItems>;\n \n-    #[salsa::invoke(crate::nameres::ItemMap::item_map_query)]\n-    fn item_map(&self, krate: Crate) -> Arc<ItemMap>;\n+    #[salsa::invoke(RawItems::raw_items_with_source_map_query)]\n+    fn raw_items_with_source_map(&self, file_id: FileId) -> (Arc<RawItems>, Arc<ImportSourceMap>);\n \n-    #[salsa::invoke(crate::module_tree::ModuleTree::module_tree_query)]\n-    fn module_tree(&self, krate: Crate) -> Arc<ModuleTree>;\n+    #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n+    fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;\n \n     #[salsa::invoke(crate::impl_block::impls_in_module)]\n     fn impls_in_module(&self, module: Module) -> Arc<ModuleImplBlocks>;"}, {"sha": "9596488d3f4694b8ab4acc5ac6f11a239d28d84c", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -83,30 +83,37 @@ impl HirFileId {\n         }\n     }\n \n-    pub(crate) fn as_macro_call_id(self) -> Option<MacroCallId> {\n-        match self.0 {\n-            HirFileIdRepr::Macro(it) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n     pub(crate) fn hir_parse(\n         db: &impl PersistentHirDatabase,\n         file_id: HirFileId,\n     ) -> TreeArc<SourceFile> {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.parse(file_id),\n-            HirFileIdRepr::Macro(m) => {\n-                if let Some(exp) = db.expand_macro_invocation(m) {\n-                    return exp.file();\n-                }\n+            HirFileIdRepr::Macro(macro_call_id) => {\n                 // returning an empty string looks fishy...\n-                SourceFile::parse(\"\")\n+                parse_macro(db, macro_call_id).unwrap_or_else(|| SourceFile::parse(\"\"))\n             }\n         }\n     }\n }\n \n+fn parse_macro(\n+    db: &impl PersistentHirDatabase,\n+    macro_call_id: MacroCallId,\n+) -> Option<TreeArc<SourceFile>> {\n+    let loc = macro_call_id.loc(db);\n+    let syntax = db.file_item(loc.source_item_id);\n+    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n+    let (macro_arg, _) = macro_call.token_tree().and_then(mbe::ast_to_token_tree)?;\n+\n+    let def_map = db.crate_def_map(loc.module.krate);\n+    let (krate, macro_id) = def_map.resolve_macro(macro_call_id)?;\n+    let def_map = db.crate_def_map(krate);\n+    let macro_rules = &def_map[macro_id];\n+    let tt = macro_rules.expand(&macro_arg).ok()?;\n+    Some(mbe::token_tree_to_ast_item_list(&tt))\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n enum HirFileIdRepr {\n     File(FileId),\n@@ -200,8 +207,14 @@ pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n     fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<N>, Self>;\n     fn from_ast(ctx: LocationCtx<&impl PersistentHirDatabase>, ast: &N) -> Self {\n         let items = ctx.db.file_items(ctx.file_id);\n-        let raw =\n-            SourceItemId { file_id: ctx.file_id, item_id: items.id_of(ctx.file_id, ast.syntax()) };\n+        let item_id = items.id_of(ctx.file_id, ast.syntax());\n+        Self::from_source_item_id_unchecked(ctx, item_id)\n+    }\n+    fn from_source_item_id_unchecked(\n+        ctx: LocationCtx<&impl PersistentHirDatabase>,\n+        item_id: SourceFileItemId,\n+    ) -> Self {\n+        let raw = SourceItemId { file_id: ctx.file_id, item_id };\n         let loc = ItemLoc { module: ctx.module, raw, _ty: PhantomData };\n \n         Self::interner(ctx.db.as_ref()).loc2id(&loc)\n@@ -290,6 +303,12 @@ impl AstItemDef<ast::TypeAliasDef> for TypeId {\n pub struct SourceFileItemId(RawId);\n impl_arena_id!(SourceFileItemId);\n \n+impl SourceFileItemId {\n+    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n+        SourceItemId { file_id, item_id: self }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct SourceItemId {\n     pub(crate) file_id: HirFileId,\n@@ -309,9 +328,7 @@ impl SourceFileItems {\n         file_id: HirFileId,\n     ) -> Arc<SourceFileItems> {\n         let source_file = db.hir_parse(file_id);\n-        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n-        res.init(&source_file);\n-        Arc::new(res)\n+        Arc::new(SourceFileItems::from_source_file(&source_file, file_id))\n     }\n \n     pub(crate) fn file_item_query(\n@@ -324,18 +341,23 @@ impl SourceFileItems {\n             .to_owned()\n     }\n \n-    fn init(&mut self, source_file: &SourceFile) {\n+    pub(crate) fn from_source_file(\n+        source_file: &SourceFile,\n+        file_id: HirFileId,\n+    ) -> SourceFileItems {\n+        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n         // By walking the tree in bread-first order we make sure that parents\n         // get lower ids then children. That is, adding a new child does not\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching.\n         bfs(source_file.syntax(), |it| {\n             if let Some(module_item) = ast::ModuleItem::cast(it) {\n-                self.alloc(module_item.syntax());\n+                res.alloc(module_item.syntax());\n             } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                self.alloc(macro_call.syntax());\n+                res.alloc(macro_call.syntax());\n             }\n-        })\n+        });\n+        res\n     }\n \n     fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {"}, {"sha": "8807a4b56884c2775f8f706053ebe250541d3a22", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -4,7 +4,8 @@ use rustc_hash::FxHashMap;\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_syntax::{\n     AstPtr, SourceFile, TreeArc,\n-ast::{self, AstNode}};\n+    ast::{self, AstNode}\n+};\n \n use crate::{\n     Const, TypeAlias, Function, HirFileId,\n@@ -13,7 +14,7 @@ use crate::{\n     type_ref::TypeRef,\n     ids::LocationCtx,\n     resolve::Resolver,\n-    ty::Ty, generics::GenericParams\n+    ty::Ty, generics::GenericParams,\n };\n \n use crate::code_model_api::{Module, ModuleSource};"}, {"sha": "75c977d3284bc43a0127cd9fd5b237f95216ecca", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -24,9 +24,7 @@ mod path;\n pub mod source_binder;\n \n mod ids;\n-mod macros;\n mod name;\n-mod module_tree;\n mod nameres;\n mod adt;\n mod type_alias;\n@@ -54,8 +52,7 @@ pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n-    macros::{MacroDef, MacroInput, MacroExpansion},\n-    nameres::{ItemMap, PerNs, Namespace},\n+    nameres::{PerNs, Namespace},\n     ty::{Ty, Substs, display::HirDisplay},\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},"}, {"sha": "45128c7dfd54b0f615f6c2ed3e54750727a99a5d", "filename": "crates/ra_hir/src/macros.rs", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/65e763fa84ae70ec9cee13f434acaae5371ad8e5/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e763fa84ae70ec9cee13f434acaae5371ad8e5/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=65e763fa84ae70ec9cee13f434acaae5371ad8e5", "patch": "@@ -1,135 +0,0 @@\n-/// Machinery for macro expansion.\n-///\n-/// One of the more complicated things about macros is managing the source code\n-/// that is produced after expansion. See `HirFileId` and `MacroCallId` for how\n-/// do we do that.\n-///\n-/// When the file-management question is resolved, all that is left is a\n-/// token-tree-to-token-tree transformation plus hygiene. We don't have either of\n-/// those yet, so all macros are string based at the moment!\n-use std::sync::Arc;\n-\n-use ra_syntax::{\n-    TextRange, TextUnit, SourceFile, AstNode, SyntaxNode, TreeArc, SyntaxNodePtr,\n-    ast,\n-};\n-\n-use crate::{MacroCallId, PersistentHirDatabase};\n-\n-// Hard-coded defs for now :-(\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum MacroDef {\n-    Vec,\n-}\n-\n-impl MacroDef {\n-    /// Expands macro call, returning the expansion and offset to be used to\n-    /// convert ranges between expansion and original source.\n-    pub fn ast_expand(macro_call: &ast::MacroCall) -> Option<(TextUnit, MacroExpansion)> {\n-        let (def, input) = MacroDef::from_call(macro_call)?;\n-        let exp = def.expand(input)?;\n-        let off = macro_call.token_tree()?.syntax().range().start();\n-        Some((off, exp))\n-    }\n-\n-    fn from_call(macro_call: &ast::MacroCall) -> Option<(MacroDef, MacroInput)> {\n-        let def = {\n-            let path = macro_call.path()?;\n-            let name_ref = path.segment()?.name_ref()?;\n-            if name_ref.text() == \"vec\" {\n-                MacroDef::Vec\n-            } else {\n-                return None;\n-            }\n-        };\n-\n-        let input = {\n-            let arg = macro_call.token_tree()?.syntax();\n-            MacroInput { text: arg.text().to_string() }\n-        };\n-        Some((def, input))\n-    }\n-\n-    fn expand(self, input: MacroInput) -> Option<MacroExpansion> {\n-        match self {\n-            MacroDef::Vec => self.expand_vec(input),\n-        }\n-    }\n-    fn expand_vec(self, input: MacroInput) -> Option<MacroExpansion> {\n-        let text = format!(r\"fn dummy() {{ {}; }}\", input.text);\n-        let file = SourceFile::parse(&text);\n-        let array_expr = file.syntax().descendants().find_map(ast::ArrayExpr::cast)?;\n-        let ptr = SyntaxNodePtr::new(array_expr.syntax());\n-        let src_range = TextRange::offset_len(0.into(), TextUnit::of_str(&input.text));\n-        let ranges_map = vec![(src_range, array_expr.syntax().range())];\n-        let res = MacroExpansion { text, ranges_map, ptr };\n-        Some(res)\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct MacroInput {\n-    // Should be token trees\n-    pub text: String,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct MacroExpansion {\n-    /// The result of macro expansion. Should be token tree as well.\n-    text: String,\n-    /// Correspondence between ranges in the original source code and ranges in\n-    /// the macro.\n-    ranges_map: Vec<(TextRange, TextRange)>,\n-    /// Implementation detail: internally, a macro is expanded to the whole file,\n-    /// even if it is an expression. This `ptr` selects the actual expansion from\n-    /// the expanded file.\n-    ptr: SyntaxNodePtr,\n-}\n-\n-impl MacroExpansion {\n-    // FIXME: does not really make sense, macro expansion is not necessary a\n-    // whole file. See `MacroExpansion::ptr` as well.\n-    pub(crate) fn file(&self) -> TreeArc<SourceFile> {\n-        SourceFile::parse(&self.text)\n-    }\n-\n-    pub fn syntax(&self) -> TreeArc<SyntaxNode> {\n-        self.ptr.to_node(&self.file()).to_owned()\n-    }\n-    /// Maps range in the source code to the range in the expanded code.\n-    pub fn map_range_forward(&self, src_range: TextRange) -> Option<TextRange> {\n-        for (s_range, t_range) in self.ranges_map.iter() {\n-            if src_range.is_subrange(&s_range) {\n-                let src_at_zero_range = src_range - src_range.start();\n-                let src_range_offset = src_range.start() - s_range.start();\n-                let src_range = src_at_zero_range + src_range_offset + t_range.start();\n-                return Some(src_range);\n-            }\n-        }\n-        None\n-    }\n-    /// Maps range in the expanded code to the range in the source code.\n-    pub fn map_range_back(&self, tgt_range: TextRange) -> Option<TextRange> {\n-        for (s_range, t_range) in self.ranges_map.iter() {\n-            if tgt_range.is_subrange(&t_range) {\n-                let tgt_at_zero_range = tgt_range - tgt_range.start();\n-                let tgt_range_offset = tgt_range.start() - t_range.start();\n-                let src_range = tgt_at_zero_range + tgt_range_offset + s_range.start();\n-                return Some(src_range);\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-pub(crate) fn expand_macro_invocation(\n-    db: &impl PersistentHirDatabase,\n-    invoc: MacroCallId,\n-) -> Option<Arc<MacroExpansion>> {\n-    let loc = invoc.loc(db);\n-    let syntax = db.file_item(loc.source_item_id);\n-    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n-\n-    let (def, input) = MacroDef::from_call(macro_call)?;\n-    def.expand(input).map(Arc::new)\n-}"}, {"sha": "bbf57004d5b57d5204399546325bf6d23ff47b32", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -1,6 +1,7 @@\n test_utils::marks!(\n+    bogus_paths\n     name_res_works_for_broken_modules\n-    item_map_enum_importing\n+    can_import_enum_variant\n     type_var_cycles_resolve_completely\n     type_var_cycles_resolve_as_possible\n     type_var_resolves_to_int_var"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -1,331 +0,0 @@\n-use std::sync::Arc;\n-\n-use arrayvec::ArrayVec;\n-use relative_path::RelativePathBuf;\n-use ra_db::{FileId, SourceRoot};\n-use ra_syntax::{\n-    SyntaxNode, TreeArc,\n-    algo::generate,\n-    ast::{self, AstNode, NameOwner},\n-};\n-use ra_arena::{Arena, RawId, impl_arena_id};\n-use test_utils::tested_by;\n-\n-use crate::{\n-    Name, AsName, HirDatabase, SourceItemId, HirFileId, Problem, SourceFileItems, ModuleSource,\n-    PersistentHirDatabase,\n-    Crate,\n-    ids::SourceFileItemId,\n-};\n-\n-impl ModuleSource {\n-    pub(crate) fn new(\n-        db: &impl PersistentHirDatabase,\n-        file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n-    ) -> ModuleSource {\n-        match decl_id {\n-            Some(item_id) => {\n-                let module = db.file_item(SourceItemId { file_id, item_id });\n-                let module = ast::Module::cast(&*module).unwrap();\n-                assert!(module.item_list().is_some(), \"expected inline module\");\n-                ModuleSource::Module(module.to_owned())\n-            }\n-            None => {\n-                let source_file = db.hir_parse(file_id);\n-                ModuleSource::SourceFile(source_file)\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub struct Submodule {\n-    name: Name,\n-    is_declaration: bool,\n-    decl_id: SourceFileItemId,\n-}\n-\n-impl Submodule {\n-    pub(crate) fn submodules_query(\n-        db: &impl PersistentHirDatabase,\n-        file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n-    ) -> Arc<Vec<Submodule>> {\n-        db.check_canceled();\n-        let file_items = db.file_items(file_id);\n-        let module_source = ModuleSource::new(db, file_id, decl_id);\n-        let submodules = match module_source {\n-            ModuleSource::SourceFile(source_file) => {\n-                collect_submodules(file_id, &file_items, &*source_file)\n-            }\n-            ModuleSource::Module(module) => {\n-                collect_submodules(file_id, &file_items, module.item_list().unwrap())\n-            }\n-        };\n-\n-        return Arc::new(submodules);\n-\n-        fn collect_submodules(\n-            file_id: HirFileId,\n-            file_items: &SourceFileItems,\n-            root: &impl ast::ModuleItemOwner,\n-        ) -> Vec<Submodule> {\n-            root.items()\n-                .filter_map(|item| match item.kind() {\n-                    ast::ModuleItemKind::Module(m) => Some(m),\n-                    _ => None,\n-                })\n-                .filter_map(|module| {\n-                    let name = module.name()?.as_name();\n-                    if !module.has_semi() && module.item_list().is_none() {\n-                        tested_by!(name_res_works_for_broken_modules);\n-                        return None;\n-                    }\n-                    let sub = Submodule {\n-                        name,\n-                        is_declaration: module.has_semi(),\n-                        decl_id: file_items.id_of(file_id, module.syntax()),\n-                    };\n-                    Some(sub)\n-                })\n-                .collect()\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ModuleId(RawId);\n-impl_arena_id!(ModuleId);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct LinkId(RawId);\n-impl_arena_id!(LinkId);\n-\n-/// Physically, rust source is organized as a set of files, but logically it is\n-/// organized as a tree of modules. Usually, a single file corresponds to a\n-/// single module, but it is not neccessarily always the case.\n-///\n-/// `ModuleTree` encapsulates the logic of transitioning from the fuzzy world of files\n-/// (which can have multiple parents) to the precise world of modules (which\n-/// always have one parent).\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub struct ModuleTree {\n-    mods: Arena<ModuleId, ModuleData>,\n-    links: Arena<LinkId, LinkData>,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct ModuleData {\n-    file_id: HirFileId,\n-    /// Points to `ast::Module`, `None` for the whole file.\n-    decl_id: Option<SourceFileItemId>,\n-    parent: Option<LinkId>,\n-    children: Vec<LinkId>,\n-}\n-\n-#[derive(Hash, Debug, PartialEq, Eq)]\n-struct LinkData {\n-    source: SourceItemId,\n-    owner: ModuleId,\n-    name: Name,\n-    points_to: Vec<ModuleId>,\n-    problem: Option<Problem>,\n-}\n-\n-impl ModuleTree {\n-    pub(crate) fn module_tree_query(\n-        db: &impl PersistentHirDatabase,\n-        krate: Crate,\n-    ) -> Arc<ModuleTree> {\n-        db.check_canceled();\n-        let mut res = ModuleTree::default();\n-        res.init_crate(db, krate);\n-        Arc::new(res)\n-    }\n-\n-    pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n-        self.mods.iter().map(|(id, _)| id)\n-    }\n-\n-    pub(crate) fn find_module_by_source(\n-        &self,\n-        file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n-    ) -> Option<ModuleId> {\n-        let (res, _) =\n-            self.mods.iter().find(|(_, m)| (m.file_id, m.decl_id) == (file_id, decl_id))?;\n-        Some(res)\n-    }\n-\n-    fn init_crate(&mut self, db: &impl PersistentHirDatabase, krate: Crate) {\n-        let crate_graph = db.crate_graph();\n-        let file_id = crate_graph.crate_root(krate.crate_id);\n-        let source_root_id = db.file_source_root(file_id);\n-\n-        let source_root = db.source_root(source_root_id);\n-        self.init_subtree(db, &source_root, None, file_id.into(), None);\n-    }\n-\n-    fn init_subtree(\n-        &mut self,\n-        db: &impl PersistentHirDatabase,\n-        source_root: &SourceRoot,\n-        parent: Option<LinkId>,\n-        file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n-    ) -> ModuleId {\n-        let is_root = parent.is_none();\n-        let id = self.alloc_mod(ModuleData { file_id, decl_id, parent, children: Vec::new() });\n-        for sub in db.submodules(file_id, decl_id).iter() {\n-            let link = self.alloc_link(LinkData {\n-                source: SourceItemId { file_id, item_id: sub.decl_id },\n-                name: sub.name.clone(),\n-                owner: id,\n-                points_to: Vec::new(),\n-                problem: None,\n-            });\n-\n-            let (points_to, problem) = if sub.is_declaration {\n-                let (points_to, problem) = resolve_submodule(db, file_id, &sub.name, is_root);\n-                let points_to = points_to\n-                    .into_iter()\n-                    .map(|file_id| {\n-                        self.init_subtree(db, source_root, Some(link), file_id.into(), None)\n-                    })\n-                    .collect::<Vec<_>>();\n-                (points_to, problem)\n-            } else {\n-                let points_to =\n-                    self.init_subtree(db, source_root, Some(link), file_id, Some(sub.decl_id));\n-                (vec![points_to], None)\n-            };\n-\n-            self.links[link].points_to = points_to;\n-            self.links[link].problem = problem;\n-        }\n-        id\n-    }\n-\n-    fn alloc_mod(&mut self, data: ModuleData) -> ModuleId {\n-        self.mods.alloc(data)\n-    }\n-\n-    fn alloc_link(&mut self, data: LinkData) -> LinkId {\n-        let owner = data.owner;\n-        let id = self.links.alloc(data);\n-        self.mods[owner].children.push(id);\n-        id\n-    }\n-}\n-\n-impl ModuleId {\n-    pub(crate) fn file_id(self, tree: &ModuleTree) -> HirFileId {\n-        tree.mods[self].file_id\n-    }\n-    pub(crate) fn decl_id(self, tree: &ModuleTree) -> Option<SourceFileItemId> {\n-        tree.mods[self].decl_id\n-    }\n-    pub(crate) fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n-        tree.mods[self].parent\n-    }\n-    pub(crate) fn parent(self, tree: &ModuleTree) -> Option<ModuleId> {\n-        let link = self.parent_link(tree)?;\n-        Some(tree.links[link].owner)\n-    }\n-    pub(crate) fn crate_root(self, tree: &ModuleTree) -> ModuleId {\n-        generate(Some(self), move |it| it.parent(tree)).last().unwrap()\n-    }\n-    pub(crate) fn child(self, tree: &ModuleTree, name: &Name) -> Option<ModuleId> {\n-        let link = tree.mods[self]\n-            .children\n-            .iter()\n-            .map(|&it| &tree.links[it])\n-            .find(|it| it.name == *name)?;\n-        Some(*link.points_to.first()?)\n-    }\n-    pub(crate) fn children<'a>(\n-        self,\n-        tree: &'a ModuleTree,\n-    ) -> impl Iterator<Item = (Name, ModuleId)> + 'a {\n-        tree.mods[self].children.iter().filter_map(move |&it| {\n-            let link = &tree.links[it];\n-            let module = *link.points_to.first()?;\n-            Some((link.name.clone(), module))\n-        })\n-    }\n-    pub(crate) fn problems(\n-        self,\n-        tree: &ModuleTree,\n-        db: &impl HirDatabase,\n-    ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        tree.mods[self]\n-            .children\n-            .iter()\n-            .filter_map(|&link| {\n-                let p = tree.links[link].problem.clone()?;\n-                let s = link.source(tree, db);\n-                let s = s.name().unwrap().syntax().to_owned();\n-                Some((s, p))\n-            })\n-            .collect()\n-    }\n-}\n-\n-impl LinkId {\n-    pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n-        tree.links[self].owner\n-    }\n-    pub(crate) fn name(self, tree: &ModuleTree) -> &Name {\n-        &tree.links[self].name\n-    }\n-    pub(crate) fn source(\n-        self,\n-        tree: &ModuleTree,\n-        db: &impl PersistentHirDatabase,\n-    ) -> TreeArc<ast::Module> {\n-        let syntax_node = db.file_item(tree.links[self].source);\n-        ast::Module::cast(&syntax_node).unwrap().to_owned()\n-    }\n-}\n-\n-fn resolve_submodule(\n-    db: &impl PersistentHirDatabase,\n-    file_id: HirFileId,\n-    name: &Name,\n-    is_root: bool,\n-) -> (Vec<FileId>, Option<Problem>) {\n-    // FIXME: handle submodules of inline modules properly\n-    let file_id = file_id.original_file(db);\n-    let source_root_id = db.file_source_root(file_id);\n-    let path = db.file_relative_path(file_id);\n-    let root = RelativePathBuf::default();\n-    let dir_path = path.parent().unwrap_or(&root);\n-    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n-    let is_dir_owner = is_root || mod_name == \"mod\";\n-\n-    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n-    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n-    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n-    let mut candidates = ArrayVec::<[_; 2]>::new();\n-    if is_dir_owner {\n-        candidates.push(file_mod.clone());\n-        candidates.push(dir_mod);\n-    } else {\n-        candidates.push(file_dir_mod.clone());\n-    };\n-    let sr = db.source_root(source_root_id);\n-    let points_to = candidates\n-        .into_iter()\n-        .filter_map(|path| sr.files.get(&path))\n-        .map(|&it| it)\n-        .collect::<Vec<_>>();\n-    let problem = if points_to.is_empty() {\n-        Some(Problem::UnresolvedModule {\n-            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n-        })\n-    } else {\n-        None\n-    };\n-    (points_to, problem)\n-}"}, {"sha": "06bafa6f068270756a2ae19e28e73e2d50dfd791", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -64,6 +64,7 @@ impl Name {\n             \"str\" => KnownName::Str,\n             \"Self\" => KnownName::SelfType,\n             \"self\" => KnownName::SelfParam,\n+            \"macro_rules\" => KnownName::MacroRules,\n             _ => return None,\n         };\n         Some(name)\n@@ -122,4 +123,6 @@ pub(crate) enum KnownName {\n \n     SelfType,\n     SelfParam,\n+\n+    MacroRules,\n }"}, {"sha": "edd2f25f7eacc97e57a164d1b93d5fb5f5ebc4d1", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 252, "deletions": 491, "changes": 743, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -1,60 +1,148 @@\n-//! Name resolution algorithm. The end result of the algorithm is an `ItemMap`:\n-//! a map which maps each module to its scope: the set of items visible in the\n-//! module. That is, we only resolve imports here, name resolution of item\n-//! bodies will be done in a separate step.\n-//!\n-//! Like Rustc, we use an interactive per-crate algorithm: we start with scopes\n-//! containing only directly defined items, and then iteratively resolve\n-//! imports.\n-//!\n-//! To make this work nicely in the IDE scenario, we place `InputModuleItems`\n-//! in between raw syntax and name resolution. `InputModuleItems` are computed\n-//! using only the module's syntax, and it is all directly defined items plus\n-//! imports. The plan is to make `InputModuleItems` independent of local\n-//! modifications (that is, typing inside a function should not change IMIs),\n-//! so that the results of name resolution can be preserved unless the module\n-//! structure itself is modified.\n-pub(crate) mod lower;\n-\n-use std::{time, sync::Arc};\n-\n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use ra_arena::map::ArenaMap;\n-use ra_db::Edition;\n+/// This module implements import-resolution/macro expansion algorithm.\n+///\n+/// The result of this module is `CrateDefMap`: a datastructure which contains:\n+///\n+///   * a tree of modules for the crate\n+///   * for each module, a set of items visible in the module (directly declared\n+///     or imported)\n+///\n+/// Note that `CrateDefMap` contains fully macro expanded code.\n+///\n+/// Computing `CrateDefMap` can be partitioned into several logically\n+/// independent \"phases\". The phases are mutually recursive though, there's no\n+/// strict ordering.\n+///\n+/// ## Collecting RawItems\n+///\n+///  This happens in the `raw` module, which parses a single source file into a\n+///  set of top-level items. Nested imports are desugared to flat imports in\n+///  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n+///  TokenTree).\n+///\n+/// ## Collecting Modules\n+///\n+/// This happens in the `collector` module. In this phase, we recursively walk\n+/// tree of modules, collect raw items from submodules, populate module scopes\n+/// with defined items (so, we assign item ids in this phase) and record the set\n+/// of unresolved imports and macros.\n+///\n+/// While we walk tree of modules, we also record macro_rules definitions and\n+/// expand calls to macro_rules defined macros.\n+///\n+/// ## Resolving Imports\n+///\n+/// We maintain a list of currently unresolved imports. On every iteration, we\n+/// try to resolve some imports from this list. If the import is resolved, we\n+/// record it, by adding an item to current module scope and, if necessary, by\n+/// recursively populating glob imports.\n+///\n+/// ## Resolving Macros\n+///\n+/// macro_rules from the same crate use a global mutable namespace. We expand\n+/// them immediately, when we collect modules.\n+///\n+/// Macros from other crates (including proc-macros) can be used with\n+/// `foo::bar!` syntax. We handle them similarly to imports. There's a list of\n+/// unexpanded macros. On every iteration, we try to resolve each macro call\n+/// path and, upon success, we run macro expansion and \"collect module\" phase\n+/// on the result\n+\n+mod per_ns;\n+mod raw;\n+mod collector;\n+#[cfg(test)]\n+mod tests;\n+\n+use std::sync::Arc;\n+\n+use rustc_hash::FxHashMap;\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n \n use crate::{\n-    Module, ModuleDef,\n-    Path, PathKind, PersistentHirDatabase,\n-    Crate, Name,\n-    module_tree::{ModuleId, ModuleTree},\n-    nameres::lower::{ImportId, LoweredModule, ImportData},\n+    ModuleDef, Name, Crate, Module, Problem,\n+    PersistentHirDatabase, Path, PathKind, HirFileId,\n+    ids::{SourceItemId, SourceFileItemId, MacroCallId},\n };\n \n-/// `ItemMap` is the result of module name resolution. It contains, for each\n-/// module, the set of visible items.\n+pub(crate) use self::raw::{RawItems, ImportId, ImportSourceMap};\n+\n+pub use self::per_ns::{PerNs, Namespace};\n+\n+/// Contans all top-level defs from a macro-expanded crate\n #[derive(Debug, PartialEq, Eq)]\n-pub struct ItemMap {\n+pub struct CrateDefMap {\n+    krate: Crate,\n     edition: Edition,\n     /// The prelude module for this crate. This either comes from an import\n     /// marked with the `prelude_import` attribute, or (in the normal case) from\n     /// a dependency (`std` or `core`).\n-    pub(crate) prelude: Option<Module>,\n-    pub(crate) extern_prelude: FxHashMap<Name, ModuleDef>,\n-    per_module: ArenaMap<ModuleId, ModuleScope>,\n+    prelude: Option<Module>,\n+    extern_prelude: FxHashMap<Name, ModuleDef>,\n+    root: CrateModuleId,\n+    modules: Arena<CrateModuleId, ModuleData>,\n+    macros: Arena<CrateMacroId, mbe::MacroRules>,\n+    public_macros: FxHashMap<Name, CrateMacroId>,\n+    macro_resolutions: FxHashMap<MacroCallId, (Crate, CrateMacroId)>,\n+    problems: CrateDefMapProblems,\n+}\n+\n+impl std::ops::Index<CrateModuleId> for CrateDefMap {\n+    type Output = ModuleData;\n+    fn index(&self, id: CrateModuleId) -> &ModuleData {\n+        &self.modules[id]\n+    }\n+}\n+\n+impl std::ops::Index<CrateMacroId> for CrateDefMap {\n+    type Output = mbe::MacroRules;\n+    fn index(&self, id: CrateMacroId) -> &mbe::MacroRules {\n+        &self.macros[id]\n+    }\n+}\n+\n+/// An ID of a macro, **local** to a specific crate\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub(crate) struct CrateMacroId(RawId);\n+impl_arena_id!(CrateMacroId);\n+\n+/// An ID of a module, **local** to a specific crate\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub(crate) struct CrateModuleId(RawId);\n+impl_arena_id!(CrateModuleId);\n+\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub(crate) struct ModuleData {\n+    pub(crate) parent: Option<CrateModuleId>,\n+    pub(crate) children: FxHashMap<Name, CrateModuleId>,\n+    pub(crate) scope: ModuleScope,\n+    /// None for root\n+    pub(crate) declaration: Option<SourceItemId>,\n+    /// None for inline modules.\n+    ///\n+    /// Note that non-inline modules, by definition, live inside non-macro file.\n+    pub(crate) definition: Option<FileId>,\n+}\n+\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub(crate) struct CrateDefMapProblems {\n+    problems: Vec<(SourceItemId, Problem)>,\n }\n \n-impl std::ops::Index<ModuleId> for ItemMap {\n-    type Output = ModuleScope;\n-    fn index(&self, id: ModuleId) -> &ModuleScope {\n-        &self.per_module[id]\n+impl CrateDefMapProblems {\n+    fn add(&mut self, source_item_id: SourceItemId, problem: Problem) {\n+        self.problems.push((source_item_id, problem))\n+    }\n+\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (&'a SourceItemId, &'a Problem)> + 'a {\n+        self.problems.iter().map(|(s, p)| (s, p))\n     }\n }\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n-    pub(crate) items: FxHashMap<Name, Resolution>,\n+    items: FxHashMap<Name, Resolution>,\n }\n \n impl ModuleScope {\n@@ -66,8 +154,6 @@ impl ModuleScope {\n     }\n }\n \n-/// `Resolution` is basically `DefId` atm, but it should account for stuff like\n-/// multiple namespaces, ambiguity and errors.\n #[derive(Debug, Clone, PartialEq, Eq, Default)]\n pub struct Resolution {\n     /// None for unresolved\n@@ -76,372 +162,6 @@ pub struct Resolution {\n     pub import: Option<ImportId>,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub enum Namespace {\n-    Types,\n-    Values,\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct PerNs<T> {\n-    pub types: Option<T>,\n-    pub values: Option<T>,\n-}\n-\n-impl<T> Default for PerNs<T> {\n-    fn default() -> Self {\n-        PerNs { types: None, values: None }\n-    }\n-}\n-\n-impl<T> PerNs<T> {\n-    pub fn none() -> PerNs<T> {\n-        PerNs { types: None, values: None }\n-    }\n-\n-    pub fn values(t: T) -> PerNs<T> {\n-        PerNs { types: None, values: Some(t) }\n-    }\n-\n-    pub fn types(t: T) -> PerNs<T> {\n-        PerNs { types: Some(t), values: None }\n-    }\n-\n-    pub fn both(types: T, values: T) -> PerNs<T> {\n-        PerNs { types: Some(types), values: Some(values) }\n-    }\n-\n-    pub fn is_none(&self) -> bool {\n-        self.types.is_none() && self.values.is_none()\n-    }\n-\n-    pub fn is_both(&self) -> bool {\n-        self.types.is_some() && self.values.is_some()\n-    }\n-\n-    pub fn take(self, namespace: Namespace) -> Option<T> {\n-        match namespace {\n-            Namespace::Types => self.types,\n-            Namespace::Values => self.values,\n-        }\n-    }\n-\n-    pub fn take_types(self) -> Option<T> {\n-        self.take(Namespace::Types)\n-    }\n-\n-    pub fn take_values(self) -> Option<T> {\n-        self.take(Namespace::Values)\n-    }\n-\n-    pub fn get(&self, namespace: Namespace) -> Option<&T> {\n-        self.as_ref().take(namespace)\n-    }\n-\n-    pub fn as_ref(&self) -> PerNs<&T> {\n-        PerNs { types: self.types.as_ref(), values: self.values.as_ref() }\n-    }\n-\n-    pub fn or(self, other: PerNs<T>) -> PerNs<T> {\n-        PerNs { types: self.types.or(other.types), values: self.values.or(other.values) }\n-    }\n-\n-    pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n-        PerNs { types: self.types.and_then(&f), values: self.values.and_then(&f) }\n-    }\n-\n-    pub fn map<U>(self, f: impl Fn(T) -> U) -> PerNs<U> {\n-        PerNs { types: self.types.map(&f), values: self.values.map(&f) }\n-    }\n-}\n-\n-struct Resolver<'a, DB> {\n-    db: &'a DB,\n-    input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n-    krate: Crate,\n-    module_tree: Arc<ModuleTree>,\n-    processed_imports: FxHashSet<(ModuleId, ImportId)>,\n-    /// If module `a` has `use b::*`, then this contains the mapping b -> a (and the import)\n-    glob_imports: FxHashMap<ModuleId, Vec<(ModuleId, ImportId)>>,\n-    result: ItemMap,\n-}\n-\n-impl<'a, DB> Resolver<'a, DB>\n-where\n-    DB: PersistentHirDatabase,\n-{\n-    fn new(\n-        db: &'a DB,\n-        input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n-        krate: Crate,\n-    ) -> Resolver<'a, DB> {\n-        let module_tree = db.module_tree(krate);\n-        Resolver {\n-            db,\n-            input,\n-            krate,\n-            module_tree,\n-            processed_imports: FxHashSet::default(),\n-            glob_imports: FxHashMap::default(),\n-            result: ItemMap {\n-                edition: krate.edition(db),\n-                prelude: None,\n-                extern_prelude: FxHashMap::default(),\n-                per_module: ArenaMap::default(),\n-            },\n-        }\n-    }\n-\n-    pub(crate) fn resolve(mut self) -> ItemMap {\n-        self.populate_extern_prelude();\n-        for (&module_id, items) in self.input.iter() {\n-            self.populate_module(module_id, Arc::clone(items));\n-        }\n-\n-        let mut iter = 0;\n-        loop {\n-            iter += 1;\n-            if iter > 1000 {\n-                panic!(\"failed to reach fixedpoint after 1000 iters\")\n-            }\n-            let processed_imports_count = self.processed_imports.len();\n-            for &module_id in self.input.keys() {\n-                self.db.check_canceled();\n-                self.resolve_imports(module_id);\n-            }\n-            if processed_imports_count == self.processed_imports.len() {\n-                // no new imports resolved\n-                break;\n-            }\n-        }\n-        self.result\n-    }\n-\n-    fn populate_extern_prelude(&mut self) {\n-        for dep in self.krate.dependencies(self.db) {\n-            log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.krate);\n-            if let Some(module) = dep.krate.root_module(self.db) {\n-                self.result.extern_prelude.insert(dep.name.clone(), module.into());\n-            }\n-            // look for the prelude\n-            if self.result.prelude.is_none() {\n-                let item_map = self.db.item_map(dep.krate);\n-                if item_map.prelude.is_some() {\n-                    self.result.prelude = item_map.prelude;\n-                }\n-            }\n-        }\n-    }\n-\n-    fn populate_module(&mut self, module_id: ModuleId, input: Arc<LoweredModule>) {\n-        let mut module_items = ModuleScope::default();\n-        for (import_id, import_data) in input.imports.iter() {\n-            if let Some(last_segment) = import_data.path.segments.iter().last() {\n-                if !import_data.is_glob {\n-                    let name =\n-                        import_data.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n-                    module_items\n-                        .items\n-                        .insert(name, Resolution { def: PerNs::none(), import: Some(import_id) });\n-                }\n-            }\n-        }\n-        // Populate explicitly declared items, except modules\n-        for (name, &def) in input.declarations.iter() {\n-            let resolution = Resolution { def, import: None };\n-            module_items.items.insert(name.clone(), resolution);\n-        }\n-\n-        // Populate modules\n-        for (name, module_id) in module_id.children(&self.module_tree) {\n-            let module = Module { module_id, krate: self.krate };\n-            self.add_module_item(&mut module_items, name, PerNs::types(module.into()));\n-        }\n-\n-        self.result.per_module.insert(module_id, module_items);\n-    }\n-\n-    fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def: PerNs<ModuleDef>) {\n-        let resolution = Resolution { def, import: None };\n-        module_items.items.insert(name, resolution);\n-    }\n-\n-    fn resolve_imports(&mut self, module_id: ModuleId) {\n-        for (import_id, import_data) in self.input[&module_id].imports.iter() {\n-            if self.processed_imports.contains(&(module_id, import_id)) {\n-                // already done\n-                continue;\n-            }\n-            if self.resolve_import(module_id, import_id, import_data) == ReachedFixedPoint::Yes {\n-                log::debug!(\"import {:?} resolved (or definite error)\", import_id);\n-                self.processed_imports.insert((module_id, import_id));\n-            }\n-        }\n-    }\n-\n-    fn resolve_import(\n-        &mut self,\n-        module_id: ModuleId,\n-        import_id: ImportId,\n-        import: &ImportData,\n-    ) -> ReachedFixedPoint {\n-        log::debug!(\"resolving import: {:?} ({:?})\", import, self.result.edition);\n-        let original_module = Module { krate: self.krate, module_id };\n-\n-        let (def, reached_fixedpoint) = if import.is_extern_crate {\n-            let res = self.result.resolve_name_in_extern_prelude(\n-                &import\n-                    .path\n-                    .as_ident()\n-                    .expect(\"extern crate should have been desugared to one-element path\"),\n-            );\n-            (res, if res.is_none() { ReachedFixedPoint::No } else { ReachedFixedPoint::Yes })\n-        } else {\n-            let res = self.result.resolve_path_fp(\n-                self.db,\n-                ResolveMode::Import,\n-                original_module,\n-                &import.path,\n-            );\n-\n-            (res.resolved_def, res.reached_fixedpoint)\n-        };\n-\n-        if reached_fixedpoint != ReachedFixedPoint::Yes {\n-            return reached_fixedpoint;\n-        }\n-\n-        if import.is_glob {\n-            log::debug!(\"glob import: {:?}\", import);\n-            match def.take_types() {\n-                Some(ModuleDef::Module(m)) => {\n-                    if import.is_prelude {\n-                        tested_by!(std_prelude);\n-                        self.result.prelude = Some(m);\n-                    } else if m.krate != self.krate {\n-                        tested_by!(glob_across_crates);\n-                        // glob import from other crate => we can just import everything once\n-                        let item_map = self.db.item_map(m.krate);\n-                        let scope = &item_map[m.module_id];\n-                        let items = scope\n-                            .items\n-                            .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n-                        self.update(module_id, Some(import_id), &items);\n-                    } else {\n-                        // glob import from same crate => we do an initial\n-                        // import, and then need to propagate any further\n-                        // additions\n-                        let scope = &self.result[m.module_id];\n-                        let items = scope\n-                            .items\n-                            .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n-                        self.update(module_id, Some(import_id), &items);\n-                        // record the glob import in case we add further items\n-                        self.glob_imports\n-                            .entry(m.module_id)\n-                            .or_default()\n-                            .push((module_id, import_id));\n-                    }\n-                }\n-                Some(ModuleDef::Enum(e)) => {\n-                    tested_by!(glob_enum);\n-                    // glob import from enum => just import all the variants\n-                    let variants = e.variants(self.db);\n-                    let resolutions = variants\n-                        .into_iter()\n-                        .filter_map(|variant| {\n-                            let res = Resolution {\n-                                def: PerNs::both(variant.into(), variant.into()),\n-                                import: Some(import_id),\n-                            };\n-                            let name = variant.name(self.db)?;\n-                            Some((name, res))\n-                        })\n-                        .collect::<Vec<_>>();\n-                    self.update(module_id, Some(import_id), &resolutions);\n-                }\n-                Some(d) => {\n-                    log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n-                }\n-                None => {\n-                    log::debug!(\"glob import {:?} didn't resolve as type\", import);\n-                }\n-            }\n-        } else {\n-            let last_segment = import.path.segments.last().unwrap();\n-            let name = import.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n-            log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n-\n-            // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n-            if let Some(root_module) = self.krate.root_module(self.db) {\n-                if import.is_extern_crate && module_id == root_module.module_id {\n-                    if let Some(def) = def.take_types() {\n-                        self.result.extern_prelude.insert(name.clone(), def);\n-                    }\n-                }\n-            }\n-            let resolution = Resolution { def, import: Some(import_id) };\n-            self.update(module_id, None, &[(name, resolution)]);\n-        }\n-        reached_fixedpoint\n-    }\n-\n-    fn update(\n-        &mut self,\n-        module_id: ModuleId,\n-        import: Option<ImportId>,\n-        resolutions: &[(Name, Resolution)],\n-    ) {\n-        self.update_recursive(module_id, import, resolutions, 0)\n-    }\n-\n-    fn update_recursive(\n-        &mut self,\n-        module_id: ModuleId,\n-        import: Option<ImportId>,\n-        resolutions: &[(Name, Resolution)],\n-        depth: usize,\n-    ) {\n-        if depth > 100 {\n-            // prevent stack overflows (but this shouldn't be possible)\n-            panic!(\"infinite recursion in glob imports!\");\n-        }\n-        let module_items = self.result.per_module.get_mut(module_id).unwrap();\n-        let mut changed = false;\n-        for (name, res) in resolutions {\n-            let existing = module_items.items.entry(name.clone()).or_default();\n-            if existing.def.types.is_none() && res.def.types.is_some() {\n-                existing.def.types = res.def.types;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-            if existing.def.values.is_none() && res.def.values.is_some() {\n-                existing.def.values = res.def.values;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-        }\n-        if !changed {\n-            return;\n-        }\n-        let glob_imports = self\n-            .glob_imports\n-            .get(&module_id)\n-            .into_iter()\n-            .flat_map(|v| v.iter())\n-            .cloned()\n-            .collect::<Vec<_>>();\n-        for (glob_importing_module, glob_import) in glob_imports {\n-            // We pass the glob import so that the tracked import in those modules is that glob import\n-            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone)]\n struct ResolvePathResult {\n     resolved_def: PerNs<ModuleDef>,\n@@ -475,84 +195,85 @@ enum ReachedFixedPoint {\n     No,\n }\n \n-impl ItemMap {\n-    pub(crate) fn item_map_query(db: &impl PersistentHirDatabase, krate: Crate) -> Arc<ItemMap> {\n-        let start = time::Instant::now();\n-        let module_tree = db.module_tree(krate);\n-        let input = module_tree\n-            .modules()\n-            .map(|module_id| (module_id, db.lower_module(Module { krate, module_id })))\n-            .collect::<FxHashMap<_, _>>();\n-\n-        let resolver = Resolver::new(db, &input, krate);\n-        let res = resolver.resolve();\n-        let elapsed = start.elapsed();\n-        log::info!(\"item_map: {:?}\", elapsed);\n-        Arc::new(res)\n+impl CrateDefMap {\n+    pub(crate) fn crate_def_map_query(\n+        db: &impl PersistentHirDatabase,\n+        krate: Crate,\n+    ) -> Arc<CrateDefMap> {\n+        let start = std::time::Instant::now();\n+        let def_map = {\n+            let edition = krate.edition(db);\n+            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let root = modules.alloc(ModuleData::default());\n+            CrateDefMap {\n+                krate,\n+                edition,\n+                extern_prelude: FxHashMap::default(),\n+                prelude: None,\n+                root,\n+                modules,\n+                macros: Arena::default(),\n+                public_macros: FxHashMap::default(),\n+                macro_resolutions: FxHashMap::default(),\n+                problems: CrateDefMapProblems::default(),\n+            }\n+        };\n+        let def_map = collector::collect_defs(db, def_map);\n+        log::info!(\"crate_def_map_query: {:?}\", start.elapsed());\n+        Arc::new(def_map)\n     }\n \n-    pub(crate) fn resolve_path(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        original_module: Module,\n-        path: &Path,\n-    ) -> (PerNs<ModuleDef>, Option<usize>) {\n-        let res = self.resolve_path_fp(db, ResolveMode::Other, original_module, path);\n-        (res.resolved_def, res.segment_index)\n+    pub(crate) fn root(&self) -> CrateModuleId {\n+        self.root\n     }\n \n-    fn resolve_in_prelude(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        original_module: Module,\n-        name: &Name,\n-    ) -> PerNs<ModuleDef> {\n-        if let Some(prelude) = self.prelude {\n-            let resolution = if prelude.krate == original_module.krate {\n-                self[prelude.module_id].items.get(name).cloned()\n-            } else {\n-                db.item_map(prelude.krate)[prelude.module_id].items.get(name).cloned()\n-            };\n-            resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n-        } else {\n-            PerNs::none()\n-        }\n+    pub(crate) fn problems(&self) -> &CrateDefMapProblems {\n+        &self.problems\n     }\n \n-    pub(crate) fn resolve_name_in_module(\n-        &self,\n-        db: &impl PersistentHirDatabase,\n-        module: Module,\n-        name: &Name,\n-    ) -> PerNs<ModuleDef> {\n-        // Resolve in:\n-        //  - current module / scope\n-        //  - extern prelude\n-        //  - std prelude\n-        let from_scope = self[module.module_id].items.get(name).map_or(PerNs::none(), |it| it.def);\n-        let from_extern_prelude =\n-            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n-        let from_prelude = self.resolve_in_prelude(db, module, name);\n+    pub(crate) fn mk_module(&self, module_id: CrateModuleId) -> Module {\n+        Module { krate: self.krate, module_id }\n+    }\n \n-        from_scope.or(from_extern_prelude).or(from_prelude)\n+    pub(crate) fn prelude(&self) -> Option<Module> {\n+        self.prelude\n     }\n \n-    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n-        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+    pub(crate) fn extern_prelude(&self) -> &FxHashMap<Name, ModuleDef> {\n+        &self.extern_prelude\n     }\n \n-    fn resolve_name_in_crate_root_or_extern_prelude(\n+    pub(crate) fn resolve_macro(\n         &self,\n-        db: &impl PersistentHirDatabase,\n-        module: Module,\n-        name: &Name,\n-    ) -> PerNs<ModuleDef> {\n-        let crate_root = module.crate_root(db);\n-        let from_crate_root =\n-            self[crate_root.module_id].items.get(name).map_or(PerNs::none(), |it| it.def);\n-        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n+        macro_call_id: MacroCallId,\n+    ) -> Option<(Crate, CrateMacroId)> {\n+        self.macro_resolutions.get(&macro_call_id).map(|&it| it)\n+    }\n \n-        from_crate_root.or(from_extern_prelude)\n+    pub(crate) fn find_module_by_source(\n+        &self,\n+        file_id: HirFileId,\n+        decl_id: Option<SourceFileItemId>,\n+    ) -> Option<CrateModuleId> {\n+        let decl_id = decl_id.map(|it| it.with_file_id(file_id));\n+        let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n+            if decl_id.is_some() {\n+                module_data.declaration == decl_id\n+            } else {\n+                module_data.definition.map(|it| it.into()) == Some(file_id)\n+            }\n+        })?;\n+        Some(module_id)\n+    }\n+\n+    pub(crate) fn resolve_path(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        original_module: CrateModuleId,\n+        path: &Path,\n+    ) -> (PerNs<ModuleDef>, Option<usize>) {\n+        let res = self.resolve_path_fp(db, ResolveMode::Other, original_module, path);\n+        (res.resolved_def, res.segment_index)\n     }\n \n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n@@ -561,13 +282,17 @@ impl ItemMap {\n         &self,\n         db: &impl PersistentHirDatabase,\n         mode: ResolveMode,\n-        original_module: Module,\n+        original_module: CrateModuleId,\n         path: &Path,\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n-            PathKind::Crate => PerNs::types(original_module.crate_root(db).into()),\n-            PathKind::Self_ => PerNs::types(original_module.into()),\n+            PathKind::Crate => {\n+                PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n+            }\n+            PathKind::Self_ => {\n+                PerNs::types(Module { krate: self.krate, module_id: original_module }.into())\n+            }\n             // plain import or absolute path in 2015: crate-relative with\n             // fallback to extern prelude (with the simplification in\n             // rust-lang/rust#57745)\n@@ -581,11 +306,7 @@ impl ItemMap {\n                     None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n-                self.resolve_name_in_crate_root_or_extern_prelude(\n-                    db,\n-                    original_module,\n-                    &segment.name,\n-                )\n+                self.resolve_name_in_crate_root_or_extern_prelude(&segment.name)\n             }\n             PathKind::Plain => {\n                 let segment = match segments.next() {\n@@ -596,8 +317,8 @@ impl ItemMap {\n                 self.resolve_name_in_module(db, original_module, &segment.name)\n             }\n             PathKind::Super => {\n-                if let Some(p) = original_module.parent(db) {\n-                    PerNs::types(p.into())\n+                if let Some(p) = self.modules[original_module].parent {\n+                    PerNs::types(Module { krate: self.krate, module_id: p }.into())\n                 } else {\n                     log::debug!(\"super path in root module\");\n                     return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n@@ -634,22 +355,22 @@ impl ItemMap {\n \n             curr_per_ns = match curr {\n                 ModuleDef::Module(module) => {\n-                    if module.krate != original_module.krate {\n+                    if module.krate != self.krate {\n                         let path = Path {\n                             segments: path.segments[i..].iter().cloned().collect(),\n                             kind: PathKind::Self_,\n                         };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n-                        let item_map = db.item_map(module.krate);\n-                        let (def, s) = item_map.resolve_path(db, *module, &path);\n+                        let defp_map = db.crate_def_map(module.krate);\n+                        let (def, s) = defp_map.resolve_path(db, module.module_id, &path);\n                         return ResolvePathResult::with(\n                             def,\n                             ReachedFixedPoint::Yes,\n                             s.map(|s| s + i),\n                         );\n                     }\n \n-                    match self[module.module_id].items.get(&segment.name) {\n+                    match self[module.module_id].scope.items.get(&segment.name) {\n                         Some(res) if !res.def.is_none() => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n@@ -659,7 +380,7 @@ impl ItemMap {\n                 }\n                 ModuleDef::Enum(e) => {\n                     // enum variant\n-                    tested_by!(item_map_enum_importing);\n+                    tested_by!(can_import_enum_variant);\n                     match e.variant(db, &segment.name) {\n                         Some(variant) => PerNs::both(variant.into(), variant.into()),\n                         None => {\n@@ -690,7 +411,47 @@ impl ItemMap {\n         }\n         ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n     }\n-}\n \n-#[cfg(test)]\n-mod tests;\n+    fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n+        let from_crate_root =\n+            self[self.root].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n+\n+        from_crate_root.or(from_extern_prelude)\n+    }\n+\n+    pub(crate) fn resolve_name_in_module(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        module: CrateModuleId,\n+        name: &Name,\n+    ) -> PerNs<ModuleDef> {\n+        // Resolve in:\n+        //  - current module / scope\n+        //  - extern prelude\n+        //  - std prelude\n+        let from_scope = self[module].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_extern_prelude =\n+            self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_prelude = self.resolve_in_prelude(db, name);\n+\n+        from_scope.or(from_extern_prelude).or(from_prelude)\n+    }\n+\n+    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n+        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+    }\n+\n+    fn resolve_in_prelude(&self, db: &impl PersistentHirDatabase, name: &Name) -> PerNs<ModuleDef> {\n+        if let Some(prelude) = self.prelude {\n+            let resolution = if prelude.krate == self.krate {\n+                self[prelude.module_id].scope.items.get(name).cloned()\n+            } else {\n+                db.crate_def_map(prelude.krate)[prelude.module_id].scope.items.get(name).cloned()\n+            };\n+            resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n+        } else {\n+            PerNs::none()\n+        }\n+    }\n+}"}, {"sha": "12ed49a0a5c3e719ed28ecded4a0f4b93693e366", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "added", "additions": 564, "deletions": 0, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -0,0 +1,564 @@\n+use arrayvec::ArrayVec;\n+use rustc_hash::FxHashMap;\n+use relative_path::RelativePathBuf;\n+use test_utils::tested_by;\n+use ra_db::FileId;\n+\n+use crate::{\n+    Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n+    PersistentHirDatabase, HirFileId, Name, Path, Problem, Crate,\n+    KnownName,\n+    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode, raw},\n+    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n+};\n+\n+use super::{CrateDefMap, CrateModuleId, ModuleData, CrateMacroId};\n+\n+pub(super) fn collect_defs(\n+    db: &impl PersistentHirDatabase,\n+    mut def_map: CrateDefMap,\n+) -> CrateDefMap {\n+    // populate external prelude\n+    for dep in def_map.krate.dependencies(db) {\n+        log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.krate);\n+        if let Some(module) = dep.krate.root_module(db) {\n+            def_map.extern_prelude.insert(dep.name.clone(), module.into());\n+        }\n+        // look for the prelude\n+        if def_map.prelude.is_none() {\n+            let map = db.crate_def_map(dep.krate);\n+            if map.prelude.is_some() {\n+                def_map.prelude = map.prelude;\n+            }\n+        }\n+    }\n+\n+    let mut collector = DefCollector {\n+        db,\n+        def_map,\n+        glob_imports: FxHashMap::default(),\n+        unresolved_imports: Vec::new(),\n+        unexpanded_macros: Vec::new(),\n+        global_macro_scope: FxHashMap::default(),\n+    };\n+    collector.collect();\n+    collector.finish()\n+}\n+\n+/// Walks the tree of module recursively\n+struct DefCollector<DB> {\n+    db: DB,\n+    def_map: CrateDefMap,\n+    glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n+    unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n+    unexpanded_macros: Vec<(CrateModuleId, MacroCallId, Path, tt::Subtree)>,\n+    global_macro_scope: FxHashMap<Name, CrateMacroId>,\n+}\n+\n+impl<'a, DB> DefCollector<&'a DB>\n+where\n+    DB: PersistentHirDatabase,\n+{\n+    fn collect(&mut self) {\n+        let crate_graph = self.db.crate_graph();\n+        let file_id = crate_graph.crate_root(self.def_map.krate.crate_id());\n+        let raw_items = self.db.raw_items(file_id);\n+        let module_id = self.def_map.root;\n+        self.def_map.modules[module_id].definition = Some(file_id);\n+        ModCollector {\n+            def_collector: &mut *self,\n+            module_id,\n+            file_id: file_id.into(),\n+            raw_items: &raw_items,\n+        }\n+        .collect(raw_items.items());\n+\n+        // main name resolution fixed-point loop.\n+        let mut i = 0;\n+        loop {\n+            match (self.resolve_imports(), self.resolve_macros()) {\n+                (ReachedFixedPoint::Yes, ReachedFixedPoint::Yes) => break,\n+                _ => i += 1,\n+            }\n+            if i == 1000 {\n+                log::error!(\"diverging name resolution\");\n+                break;\n+            }\n+        }\n+\n+        let unresolved_imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+        // show unresolved imports in completion, etc\n+        for (module_id, import, import_data) in unresolved_imports {\n+            self.record_resolved_import(module_id, PerNs::none(), import, &import_data)\n+        }\n+    }\n+\n+    fn define_macro(&mut self, name: Name, tt: &tt::Subtree, export: bool) {\n+        if let Ok(rules) = mbe::MacroRules::parse(tt) {\n+            let macro_id = self.def_map.macros.alloc(rules);\n+            if export {\n+                self.def_map.public_macros.insert(name.clone(), macro_id);\n+            }\n+            self.global_macro_scope.insert(name, macro_id);\n+        }\n+    }\n+\n+    fn resolve_imports(&mut self) -> ReachedFixedPoint {\n+        let mut imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+        let mut resolved = Vec::new();\n+        imports.retain(|(module_id, import, import_data)| {\n+            let (def, fp) = self.resolve_import(*module_id, import_data);\n+            if fp == ReachedFixedPoint::Yes {\n+                resolved.push((*module_id, def, *import, import_data.clone()))\n+            }\n+            fp == ReachedFixedPoint::No\n+        });\n+        self.unresolved_imports = imports;\n+        // Resolves imports, filling-in module scopes\n+        let result =\n+            if resolved.is_empty() { ReachedFixedPoint::Yes } else { ReachedFixedPoint::No };\n+        for (module_id, def, import, import_data) in resolved {\n+            self.record_resolved_import(module_id, def, import, &import_data)\n+        }\n+        result\n+    }\n+\n+    fn resolve_import(\n+        &mut self,\n+        module_id: CrateModuleId,\n+        import: &raw::ImportData,\n+    ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n+        log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n+        if import.is_extern_crate {\n+            let res = self.def_map.resolve_name_in_extern_prelude(\n+                &import\n+                    .path\n+                    .as_ident()\n+                    .expect(\"extern crate should have been desugared to one-element path\"),\n+            );\n+            (res, ReachedFixedPoint::Yes)\n+        } else {\n+            let res =\n+                self.def_map.resolve_path_fp(self.db, ResolveMode::Import, module_id, &import.path);\n+\n+            (res.resolved_def, res.reached_fixedpoint)\n+        }\n+    }\n+\n+    fn record_resolved_import(\n+        &mut self,\n+        module_id: CrateModuleId,\n+        def: PerNs<ModuleDef>,\n+        import_id: raw::ImportId,\n+        import: &raw::ImportData,\n+    ) {\n+        if import.is_glob {\n+            log::debug!(\"glob import: {:?}\", import);\n+            match def.take_types() {\n+                Some(ModuleDef::Module(m)) => {\n+                    if import.is_prelude {\n+                        tested_by!(std_prelude);\n+                        self.def_map.prelude = Some(m);\n+                    } else if m.krate != self.def_map.krate {\n+                        tested_by!(glob_across_crates);\n+                        // glob import from other crate => we can just import everything once\n+                        let item_map = self.db.crate_def_map(m.krate);\n+                        let scope = &item_map[m.module_id].scope;\n+                        let items = scope\n+                            .items\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n+                        self.update(module_id, Some(import_id), &items);\n+                    } else {\n+                        // glob import from same crate => we do an initial\n+                        // import, and then need to propagate any further\n+                        // additions\n+                        let scope = &self.def_map[m.module_id].scope;\n+                        let items = scope\n+                            .items\n+                            .iter()\n+                            .map(|(name, res)| (name.clone(), res.clone()))\n+                            .collect::<Vec<_>>();\n+                        self.update(module_id, Some(import_id), &items);\n+                        // record the glob import in case we add further items\n+                        self.glob_imports\n+                            .entry(m.module_id)\n+                            .or_default()\n+                            .push((module_id, import_id));\n+                    }\n+                }\n+                Some(ModuleDef::Enum(e)) => {\n+                    tested_by!(glob_enum);\n+                    // glob import from enum => just import all the variants\n+                    let variants = e.variants(self.db);\n+                    let resolutions = variants\n+                        .into_iter()\n+                        .filter_map(|variant| {\n+                            let res = Resolution {\n+                                def: PerNs::both(variant.into(), variant.into()),\n+                                import: Some(import_id),\n+                            };\n+                            let name = variant.name(self.db)?;\n+                            Some((name, res))\n+                        })\n+                        .collect::<Vec<_>>();\n+                    self.update(module_id, Some(import_id), &resolutions);\n+                }\n+                Some(d) => {\n+                    log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n+                }\n+                None => {\n+                    log::debug!(\"glob import {:?} didn't resolve as type\", import);\n+                }\n+            }\n+        } else {\n+            match import.path.segments.last() {\n+                Some(last_segment) => {\n+                    let name = import.alias.clone().unwrap_or_else(|| last_segment.name.clone());\n+                    log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n+\n+                    // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n+                    if import.is_extern_crate && module_id == self.def_map.root {\n+                        if let Some(def) = def.take_types() {\n+                            self.def_map.extern_prelude.insert(name.clone(), def);\n+                        }\n+                    }\n+                    let resolution = Resolution { def, import: Some(import_id) };\n+                    self.update(module_id, Some(import_id), &[(name, resolution)]);\n+                }\n+                None => tested_by!(bogus_paths),\n+            }\n+        }\n+    }\n+\n+    fn update(\n+        &mut self,\n+        module_id: CrateModuleId,\n+        import: Option<raw::ImportId>,\n+        resolutions: &[(Name, Resolution)],\n+    ) {\n+        self.update_recursive(module_id, import, resolutions, 0)\n+    }\n+\n+    fn update_recursive(\n+        &mut self,\n+        module_id: CrateModuleId,\n+        import: Option<raw::ImportId>,\n+        resolutions: &[(Name, Resolution)],\n+        depth: usize,\n+    ) {\n+        if depth > 100 {\n+            // prevent stack overflows (but this shouldn't be possible)\n+            panic!(\"infinite recursion in glob imports!\");\n+        }\n+        let module_items = &mut self.def_map.modules[module_id].scope;\n+        let mut changed = false;\n+        for (name, res) in resolutions {\n+            let existing = module_items.items.entry(name.clone()).or_default();\n+            if existing.def.types.is_none() && res.def.types.is_some() {\n+                existing.def.types = res.def.types;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+            if existing.def.values.is_none() && res.def.values.is_some() {\n+                existing.def.values = res.def.values;\n+                existing.import = import.or(res.import);\n+                changed = true;\n+            }\n+            if existing.def.is_none()\n+                && res.def.is_none()\n+                && existing.import.is_none()\n+                && res.import.is_some()\n+            {\n+                existing.import = res.import;\n+            }\n+        }\n+        if !changed {\n+            return;\n+        }\n+        let glob_imports = self\n+            .glob_imports\n+            .get(&module_id)\n+            .into_iter()\n+            .flat_map(|v| v.iter())\n+            .cloned()\n+            .collect::<Vec<_>>();\n+        for (glob_importing_module, glob_import) in glob_imports {\n+            // We pass the glob import so that the tracked import in those modules is that glob import\n+            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n+        }\n+    }\n+\n+    // XXX: this is just a pile of hacks now, because `PerNs` does not handle\n+    // macro namespace.\n+    fn resolve_macros(&mut self) -> ReachedFixedPoint {\n+        let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n+        let mut resolved = Vec::new();\n+        let mut res = ReachedFixedPoint::Yes;\n+        macros.retain(|(module_id, call_id, path, tt)| {\n+            if path.segments.len() != 2 {\n+                return true;\n+            }\n+            let crate_name = &path.segments[0].name;\n+            let krate = match self.def_map.resolve_name_in_extern_prelude(crate_name).take_types() {\n+                Some(ModuleDef::Module(m)) => m.krate(self.db),\n+                _ => return true,\n+            };\n+            let krate = match krate {\n+                Some(it) => it,\n+                _ => return true,\n+            };\n+            res = ReachedFixedPoint::No;\n+            let def_map = self.db.crate_def_map(krate);\n+            if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n+                resolved.push((*module_id, *call_id, (krate, macro_id), tt.clone()));\n+            }\n+            false\n+        });\n+\n+        for (module_id, macro_call_id, macro_def_id, arg) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id, arg);\n+        }\n+        res\n+    }\n+\n+    fn collect_macro_expansion(\n+        &mut self,\n+        module_id: CrateModuleId,\n+        macro_call_id: MacroCallId,\n+        macro_def_id: (Crate, CrateMacroId),\n+        macro_arg: tt::Subtree,\n+    ) {\n+        let (macro_krate, macro_id) = macro_def_id;\n+        let dm;\n+        let rules = if macro_krate == self.def_map.krate {\n+            &self.def_map[macro_id]\n+        } else {\n+            dm = self.db.crate_def_map(macro_krate);\n+            &dm[macro_id]\n+        };\n+        if let Ok(expansion) = rules.expand(&macro_arg) {\n+            self.def_map.macro_resolutions.insert(macro_call_id, macro_def_id);\n+            // XXX: this **does not** go through a database, because we can't\n+            // identify macro_call without adding the whole state of name resolution\n+            // as a parameter to the query.\n+            //\n+            // So, we run the queries \"manually\" and we must ensure that\n+            // `db.hir_parse(macro_call_id)` returns the same source_file.\n+            let file_id: HirFileId = macro_call_id.into();\n+            let source_file = mbe::token_tree_to_ast_item_list(&expansion);\n+\n+            let raw_items = raw::RawItems::from_source_file(&source_file, file_id);\n+            ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n+                .collect(raw_items.items())\n+        }\n+    }\n+\n+    fn finish(self) -> CrateDefMap {\n+        self.def_map\n+    }\n+}\n+\n+/// Walks a single module, populating defs, imports and macros\n+struct ModCollector<'a, D> {\n+    def_collector: D,\n+    module_id: CrateModuleId,\n+    file_id: HirFileId,\n+    raw_items: &'a raw::RawItems,\n+}\n+\n+impl<DB> ModCollector<'_, &'_ mut DefCollector<&'_ DB>>\n+where\n+    DB: PersistentHirDatabase,\n+{\n+    fn collect(&mut self, items: &[raw::RawItem]) {\n+        for item in items {\n+            match *item {\n+                raw::RawItem::Module(m) => self.collect_module(&self.raw_items[m]),\n+                raw::RawItem::Import(import) => self.def_collector.unresolved_imports.push((\n+                    self.module_id,\n+                    import,\n+                    self.raw_items[import].clone(),\n+                )),\n+                raw::RawItem::Def(def) => self.define_def(&self.raw_items[def]),\n+                raw::RawItem::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n+            }\n+        }\n+    }\n+\n+    fn collect_module(&mut self, module: &raw::ModuleData) {\n+        match module {\n+            // inline module, just recurse\n+            raw::ModuleData::Definition { name, items, source_item_id } => {\n+                let module_id = self.push_child_module(\n+                    name.clone(),\n+                    source_item_id.with_file_id(self.file_id),\n+                    None,\n+                );\n+                ModCollector {\n+                    def_collector: &mut *self.def_collector,\n+                    module_id,\n+                    file_id: self.file_id,\n+                    raw_items: self.raw_items,\n+                }\n+                .collect(&*items);\n+            }\n+            // out of line module, resovle, parse and recurse\n+            raw::ModuleData::Declaration { name, source_item_id } => {\n+                let source_item_id = source_item_id.with_file_id(self.file_id);\n+                let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n+                let (file_ids, problem) =\n+                    resolve_submodule(self.def_collector.db, self.file_id, name, is_root);\n+\n+                if let Some(problem) = problem {\n+                    self.def_collector.def_map.problems.add(source_item_id, problem)\n+                }\n+\n+                if let Some(&file_id) = file_ids.first() {\n+                    let module_id =\n+                        self.push_child_module(name.clone(), source_item_id, Some(file_id));\n+                    let raw_items = self.def_collector.db.raw_items(file_id);\n+                    ModCollector {\n+                        def_collector: &mut *self.def_collector,\n+                        module_id,\n+                        file_id: file_id.into(),\n+                        raw_items: &raw_items,\n+                    }\n+                    .collect(raw_items.items())\n+                }\n+            }\n+        }\n+    }\n+\n+    fn push_child_module(\n+        &mut self,\n+        name: Name,\n+        declaration: SourceItemId,\n+        definition: Option<FileId>,\n+    ) -> CrateModuleId {\n+        let modules = &mut self.def_collector.def_map.modules;\n+        let res = modules.alloc(ModuleData::default());\n+        modules[res].parent = Some(self.module_id);\n+        modules[res].declaration = Some(declaration);\n+        modules[res].definition = definition;\n+        modules[self.module_id].children.insert(name.clone(), res);\n+        let resolution = Resolution {\n+            def: PerNs::types(\n+                Module { krate: self.def_collector.def_map.krate, module_id: res }.into(),\n+            ),\n+            import: None,\n+        };\n+        self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n+        res\n+    }\n+\n+    fn define_def(&mut self, def: &raw::DefData) {\n+        let module = Module { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n+        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id.into());\n+        macro_rules! id {\n+            () => {\n+                AstItemDef::from_source_item_id_unchecked(ctx, def.source_item_id)\n+            };\n+        }\n+        let name = def.name.clone();\n+        let def: PerNs<ModuleDef> = match def.kind {\n+            raw::DefKind::Function => PerNs::values(Function { id: id!() }.into()),\n+            raw::DefKind::Struct => {\n+                let s = Struct { id: id!() }.into();\n+                PerNs::both(s, s)\n+            }\n+            raw::DefKind::Enum => PerNs::types(Enum { id: id!() }.into()),\n+            raw::DefKind::Const => PerNs::values(Const { id: id!() }.into()),\n+            raw::DefKind::Static => PerNs::values(Static { id: id!() }.into()),\n+            raw::DefKind::Trait => PerNs::types(Trait { id: id!() }.into()),\n+            raw::DefKind::TypeAlias => PerNs::types(TypeAlias { id: id!() }.into()),\n+        };\n+        let resolution = Resolution { def, import: None };\n+        self.def_collector.update(self.module_id, None, &[(name, resolution)])\n+    }\n+\n+    fn collect_macro(&mut self, mac: &raw::MacroData) {\n+        // Case 1: macro rules, define a macro in crate-global mutable scope\n+        if is_macro_rules(&mac.path) {\n+            if let Some(name) = &mac.name {\n+                self.def_collector.define_macro(name.clone(), &mac.arg, mac.export)\n+            }\n+            return;\n+        }\n+\n+        let source_item_id = SourceItemId { file_id: self.file_id, item_id: mac.source_item_id };\n+        let macro_call_id = MacroCallLoc {\n+            module: Module { krate: self.def_collector.def_map.krate, module_id: self.module_id },\n+            source_item_id,\n+        }\n+        .id(self.def_collector.db);\n+\n+        // Case 2: try to expand macro_rules from this crate, triggering\n+        // recursive item collection.\n+        if let Some(&macro_id) =\n+            mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n+        {\n+            self.def_collector.collect_macro_expansion(\n+                self.module_id,\n+                macro_call_id,\n+                (self.def_collector.def_map.krate, macro_id),\n+                mac.arg.clone(),\n+            );\n+            return;\n+        }\n+\n+        // Case 3: path to a macro from another crate, expand during name resolution\n+        self.def_collector.unexpanded_macros.push((\n+            self.module_id,\n+            macro_call_id,\n+            mac.path.clone(),\n+            mac.arg.clone(),\n+        ))\n+    }\n+}\n+\n+fn is_macro_rules(path: &Path) -> bool {\n+    path.as_ident().and_then(Name::as_known_name) == Some(KnownName::MacroRules)\n+}\n+\n+fn resolve_submodule(\n+    db: &impl PersistentHirDatabase,\n+    file_id: HirFileId,\n+    name: &Name,\n+    is_root: bool,\n+) -> (Vec<FileId>, Option<Problem>) {\n+    // FIXME: handle submodules of inline modules properly\n+    let file_id = file_id.original_file(db);\n+    let source_root_id = db.file_source_root(file_id);\n+    let path = db.file_relative_path(file_id);\n+    let root = RelativePathBuf::default();\n+    let dir_path = path.parent().unwrap_or(&root);\n+    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n+    let is_dir_owner = is_root || mod_name == \"mod\";\n+\n+    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n+    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n+    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n+    let mut candidates = ArrayVec::<[_; 2]>::new();\n+    if is_dir_owner {\n+        candidates.push(file_mod.clone());\n+        candidates.push(dir_mod);\n+    } else {\n+        candidates.push(file_dir_mod.clone());\n+    };\n+    let sr = db.source_root(source_root_id);\n+    let points_to = candidates\n+        .into_iter()\n+        .filter_map(|path| sr.files.get(&path))\n+        .map(|&it| it)\n+        .collect::<Vec<_>>();\n+    let problem = if points_to.is_empty() {\n+        Some(Problem::UnresolvedModule {\n+            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n+        })\n+    } else {\n+        None\n+    };\n+    (points_to, problem)\n+}"}, {"sha": "56262ad6d70f041a4bdad4250ee5312462c4c18c", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/65e763fa84ae70ec9cee13f434acaae5371ad8e5/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65e763fa84ae70ec9cee13f434acaae5371ad8e5/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=65e763fa84ae70ec9cee13f434acaae5371ad8e5", "patch": "@@ -1,222 +0,0 @@\n-use std::sync::Arc;\n-\n-use ra_syntax::{\n-    AstNode, SourceFile, TreeArc, AstPtr,\n-    ast::{self, ModuleItemOwner, NameOwner, AttrsOwner},\n-};\n-use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n-use rustc_hash::FxHashMap;\n-\n-use crate::{\n-    SourceItemId, Path, ModuleSource, Name,\n-    HirFileId, MacroCallLoc, AsName, PerNs, Function,\n-    ModuleDef, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    ids::LocationCtx, PersistentHirDatabase,\n-};\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ImportId(RawId);\n-impl_arena_id!(ImportId);\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) struct ImportData {\n-    pub(super) path: Path,\n-    pub(super) alias: Option<Name>,\n-    pub(super) is_glob: bool,\n-    pub(super) is_prelude: bool,\n-    pub(super) is_extern_crate: bool,\n-}\n-\n-/// A set of items and imports declared inside a module, without relation to\n-/// other modules.\n-///\n-/// This sits in-between raw syntax and name resolution and allows us to avoid\n-/// recomputing name res: if two instance of `InputModuleItems` are the same, we\n-/// can avoid redoing name resolution.\n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct LoweredModule {\n-    pub(crate) declarations: FxHashMap<Name, PerNs<ModuleDef>>,\n-    pub(super) imports: Arena<ImportId, ImportData>,\n-}\n-\n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct ImportSourceMap {\n-    map: ArenaMap<ImportId, AstPtr<ast::PathSegment>>,\n-}\n-\n-impl ImportSourceMap {\n-    fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n-        self.map.insert(import, AstPtr::new(segment))\n-    }\n-\n-    pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n-        let file = match source {\n-            ModuleSource::SourceFile(file) => &*file,\n-            ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n-        };\n-\n-        self.map[import].to_node(file).to_owned()\n-    }\n-}\n-\n-impl LoweredModule {\n-    pub(crate) fn lower_module_query(\n-        db: &impl PersistentHirDatabase,\n-        module: Module,\n-    ) -> Arc<LoweredModule> {\n-        db.lower_module_with_source_map(module).0\n-    }\n-\n-    pub(crate) fn lower_module_with_source_map_query(\n-        db: &impl PersistentHirDatabase,\n-        module: Module,\n-    ) -> (Arc<LoweredModule>, Arc<ImportSourceMap>) {\n-        let (file_id, source) = module.definition_source(db);\n-        let file_id: HirFileId = file_id.into();\n-        let mut source_map = ImportSourceMap::default();\n-        let mut res = LoweredModule::default();\n-        match source {\n-            ModuleSource::SourceFile(it) => {\n-                res.fill(&mut source_map, db, module, file_id, &mut it.items_with_macros())\n-            }\n-            ModuleSource::Module(it) => {\n-                if let Some(item_list) = it.item_list() {\n-                    res.fill(\n-                        &mut source_map,\n-                        db,\n-                        module,\n-                        file_id,\n-                        &mut item_list.items_with_macros(),\n-                    )\n-                }\n-            }\n-        };\n-        (Arc::new(res), Arc::new(source_map))\n-    }\n-\n-    fn fill(\n-        &mut self,\n-        source_map: &mut ImportSourceMap,\n-        db: &impl PersistentHirDatabase,\n-        module: Module,\n-        file_id: HirFileId,\n-        items: &mut Iterator<Item = ast::ItemOrMacro>,\n-    ) {\n-        let file_items = db.file_items(file_id);\n-\n-        for item in items {\n-            match item {\n-                ast::ItemOrMacro::Item(it) => {\n-                    self.add_def_id(source_map, db, module, file_id, it);\n-                }\n-                ast::ItemOrMacro::Macro(macro_call) => {\n-                    let item_id = file_items.id_of_unchecked(macro_call.syntax());\n-                    let loc =\n-                        MacroCallLoc { module, source_item_id: SourceItemId { file_id, item_id } };\n-                    let id = loc.id(db);\n-                    let file_id = HirFileId::from(id);\n-                    //FIXME: expand recursively\n-                    for item in db.hir_parse(file_id).items() {\n-                        self.add_def_id(source_map, db, module, file_id, item);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn add_def_id(\n-        &mut self,\n-        source_map: &mut ImportSourceMap,\n-        db: &impl PersistentHirDatabase,\n-        module: Module,\n-        file_id: HirFileId,\n-        item: &ast::ModuleItem,\n-    ) {\n-        let ctx = LocationCtx::new(db, module, file_id);\n-        match item.kind() {\n-            ast::ModuleItemKind::StructDef(it) => {\n-                if let Some(name) = it.name() {\n-                    let s = Struct { id: ctx.to_def(it) };\n-                    let s: ModuleDef = s.into();\n-                    self.declarations.insert(name.as_name(), PerNs::both(s, s));\n-                }\n-            }\n-            ast::ModuleItemKind::EnumDef(it) => {\n-                if let Some(name) = it.name() {\n-                    let e = Enum { id: ctx.to_def(it) };\n-                    let e: ModuleDef = e.into();\n-                    self.declarations.insert(name.as_name(), PerNs::types(e));\n-                }\n-            }\n-            ast::ModuleItemKind::FnDef(it) => {\n-                if let Some(name) = it.name() {\n-                    let func = Function { id: ctx.to_def(it) };\n-                    self.declarations.insert(name.as_name(), PerNs::values(func.into()));\n-                }\n-            }\n-            ast::ModuleItemKind::TraitDef(it) => {\n-                if let Some(name) = it.name() {\n-                    let t = Trait { id: ctx.to_def(it) };\n-                    self.declarations.insert(name.as_name(), PerNs::types(t.into()));\n-                }\n-            }\n-            ast::ModuleItemKind::TypeAliasDef(it) => {\n-                if let Some(name) = it.name() {\n-                    let t = TypeAlias { id: ctx.to_def(it) };\n-                    self.declarations.insert(name.as_name(), PerNs::types(t.into()));\n-                }\n-            }\n-            ast::ModuleItemKind::ImplBlock(_) => {\n-                // impls don't define items\n-            }\n-            ast::ModuleItemKind::UseItem(it) => {\n-                self.add_use_item(source_map, it);\n-            }\n-            ast::ModuleItemKind::ExternCrateItem(it) => {\n-                if let Some(name_ref) = it.name_ref() {\n-                    let path = Path::from_name_ref(name_ref);\n-                    let alias = it.alias().and_then(|a| a.name()).map(AsName::as_name);\n-                    self.imports.alloc(ImportData {\n-                        path,\n-                        alias,\n-                        is_glob: false,\n-                        is_prelude: false,\n-                        is_extern_crate: true,\n-                    });\n-                }\n-            }\n-            ast::ModuleItemKind::ConstDef(it) => {\n-                if let Some(name) = it.name() {\n-                    let c = Const { id: ctx.to_def(it) };\n-                    self.declarations.insert(name.as_name(), PerNs::values(c.into()));\n-                }\n-            }\n-            ast::ModuleItemKind::StaticDef(it) => {\n-                if let Some(name) = it.name() {\n-                    let s = Static { id: ctx.to_def(it) };\n-                    self.declarations.insert(name.as_name(), PerNs::values(s.into()));\n-                }\n-            }\n-            ast::ModuleItemKind::Module(_) => {\n-                // modules are handled separately directly by name res\n-            }\n-        };\n-    }\n-\n-    fn add_use_item(&mut self, source_map: &mut ImportSourceMap, item: &ast::UseItem) {\n-        let is_prelude =\n-            item.attrs().any(|attr| attr.as_atom().map(|s| s == \"prelude_import\").unwrap_or(false));\n-        Path::expand_use_item(item, |path, segment, alias| {\n-            let import = self.imports.alloc(ImportData {\n-                path,\n-                alias,\n-                is_glob: segment.is_none(),\n-                is_prelude,\n-                is_extern_crate: false,\n-            });\n-            if let Some(segment) = segment {\n-                source_map.insert(import, segment)\n-            }\n-        })\n-    }\n-}"}, {"sha": "c40a3ff9d934cb4e205cb29eab697f64588ea56b", "filename": "crates/ra_hir/src/nameres/per_ns.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -0,0 +1,78 @@\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum Namespace {\n+    Types,\n+    Values,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct PerNs<T> {\n+    pub types: Option<T>,\n+    pub values: Option<T>,\n+}\n+\n+impl<T> Default for PerNs<T> {\n+    fn default() -> Self {\n+        PerNs { types: None, values: None }\n+    }\n+}\n+\n+impl<T> PerNs<T> {\n+    pub fn none() -> PerNs<T> {\n+        PerNs { types: None, values: None }\n+    }\n+\n+    pub fn values(t: T) -> PerNs<T> {\n+        PerNs { types: None, values: Some(t) }\n+    }\n+\n+    pub fn types(t: T) -> PerNs<T> {\n+        PerNs { types: Some(t), values: None }\n+    }\n+\n+    pub fn both(types: T, values: T) -> PerNs<T> {\n+        PerNs { types: Some(types), values: Some(values) }\n+    }\n+\n+    pub fn is_none(&self) -> bool {\n+        self.types.is_none() && self.values.is_none()\n+    }\n+\n+    pub fn is_both(&self) -> bool {\n+        self.types.is_some() && self.values.is_some()\n+    }\n+\n+    pub fn take(self, namespace: Namespace) -> Option<T> {\n+        match namespace {\n+            Namespace::Types => self.types,\n+            Namespace::Values => self.values,\n+        }\n+    }\n+\n+    pub fn take_types(self) -> Option<T> {\n+        self.take(Namespace::Types)\n+    }\n+\n+    pub fn take_values(self) -> Option<T> {\n+        self.take(Namespace::Values)\n+    }\n+\n+    pub fn get(&self, namespace: Namespace) -> Option<&T> {\n+        self.as_ref().take(namespace)\n+    }\n+\n+    pub fn as_ref(&self) -> PerNs<&T> {\n+        PerNs { types: self.types.as_ref(), values: self.values.as_ref() }\n+    }\n+\n+    pub fn or(self, other: PerNs<T>) -> PerNs<T> {\n+        PerNs { types: self.types.or(other.types), values: self.values.or(other.values) }\n+    }\n+\n+    pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n+        PerNs { types: self.types.and_then(&f), values: self.values.and_then(&f) }\n+    }\n+\n+    pub fn map<U>(self, f: impl Fn(T) -> U) -> PerNs<U> {\n+        PerNs { types: self.types.map(&f), values: self.values.map(&f) }\n+    }\n+}"}, {"sha": "3226bbf0dfff3d21fa0487aa978edeebd8e1a94f", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -0,0 +1,322 @@\n+use std::{\n+    sync::Arc,\n+    ops::Index,\n+};\n+\n+use test_utils::tested_by;\n+use ra_db::FileId;\n+use ra_arena::{Arena, impl_arena_id, RawId, map::ArenaMap};\n+use ra_syntax::{\n+    AstNode, SourceFile, AstPtr, TreeArc,\n+    ast::{self, NameOwner, AttrsOwner},\n+};\n+\n+use crate::{\n+    PersistentHirDatabase, Name, AsName, Path, HirFileId, ModuleSource,\n+    ids::{SourceFileItemId, SourceFileItems},\n+};\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct RawItems {\n+    modules: Arena<Module, ModuleData>,\n+    imports: Arena<ImportId, ImportData>,\n+    defs: Arena<Def, DefData>,\n+    macros: Arena<Macro, MacroData>,\n+    /// items for top-level module\n+    items: Vec<RawItem>,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct ImportSourceMap {\n+    map: ArenaMap<ImportId, AstPtr<ast::PathSegment>>,\n+}\n+\n+impl ImportSourceMap {\n+    pub(crate) fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n+        self.map.insert(import, AstPtr::new(segment))\n+    }\n+\n+    pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n+        let file = match source {\n+            ModuleSource::SourceFile(file) => &*file,\n+            ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n+        };\n+\n+        self.map[import].to_node(file).to_owned()\n+    }\n+}\n+\n+impl RawItems {\n+    pub(crate) fn raw_items_query(\n+        db: &impl PersistentHirDatabase,\n+        file_id: FileId,\n+    ) -> Arc<RawItems> {\n+        db.raw_items_with_source_map(file_id).0\n+    }\n+\n+    pub(crate) fn raw_items_with_source_map_query(\n+        db: &impl PersistentHirDatabase,\n+        file_id: FileId,\n+    ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n+        let mut collector = RawItemsCollector {\n+            raw_items: RawItems::default(),\n+            source_file_items: db.file_items(file_id.into()),\n+            source_map: ImportSourceMap::default(),\n+        };\n+        let source_file = db.parse(file_id);\n+        collector.process_module(None, &*source_file);\n+        (Arc::new(collector.raw_items), Arc::new(collector.source_map))\n+    }\n+\n+    pub(crate) fn items(&self) -> &[RawItem] {\n+        &self.items\n+    }\n+\n+    // We can't use queries during name resolution for fear of cycles, so this\n+    // is a query-less variant of the above function.\n+    pub(crate) fn from_source_file(source_file: &SourceFile, file_id: HirFileId) -> RawItems {\n+        let source_file_items = SourceFileItems::from_source_file(source_file, file_id);\n+        let mut collector = RawItemsCollector {\n+            raw_items: RawItems::default(),\n+            source_file_items: Arc::new(source_file_items),\n+            source_map: ImportSourceMap::default(),\n+        };\n+        collector.process_module(None, &*source_file);\n+        collector.raw_items\n+    }\n+}\n+\n+impl Index<Module> for RawItems {\n+    type Output = ModuleData;\n+    fn index(&self, idx: Module) -> &ModuleData {\n+        &self.modules[idx]\n+    }\n+}\n+\n+impl Index<ImportId> for RawItems {\n+    type Output = ImportData;\n+    fn index(&self, idx: ImportId) -> &ImportData {\n+        &self.imports[idx]\n+    }\n+}\n+\n+impl Index<Def> for RawItems {\n+    type Output = DefData;\n+    fn index(&self, idx: Def) -> &DefData {\n+        &self.defs[idx]\n+    }\n+}\n+\n+impl Index<Macro> for RawItems {\n+    type Output = MacroData;\n+    fn index(&self, idx: Macro) -> &MacroData {\n+        &self.macros[idx]\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub(crate) enum RawItem {\n+    Module(Module),\n+    Import(ImportId),\n+    Def(Def),\n+    Macro(Macro),\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct Module(RawId);\n+impl_arena_id!(Module);\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) enum ModuleData {\n+    Declaration { name: Name, source_item_id: SourceFileItemId },\n+    Definition { name: Name, source_item_id: SourceFileItemId, items: Vec<RawItem> },\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ImportId(RawId);\n+impl_arena_id!(ImportId);\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImportData {\n+    pub(crate) path: Path,\n+    pub(crate) alias: Option<Name>,\n+    pub(crate) is_glob: bool,\n+    pub(crate) is_prelude: bool,\n+    pub(crate) is_extern_crate: bool,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct Def(RawId);\n+impl_arena_id!(Def);\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct DefData {\n+    pub(crate) source_item_id: SourceFileItemId,\n+    pub(crate) name: Name,\n+    pub(crate) kind: DefKind,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub(crate) enum DefKind {\n+    Function,\n+    Struct,\n+    Enum,\n+    Const,\n+    Static,\n+    Trait,\n+    TypeAlias,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct Macro(RawId);\n+impl_arena_id!(Macro);\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) struct MacroData {\n+    pub(crate) source_item_id: SourceFileItemId,\n+    pub(crate) path: Path,\n+    pub(crate) name: Option<Name>,\n+    pub(crate) arg: tt::Subtree,\n+    pub(crate) export: bool,\n+}\n+\n+struct RawItemsCollector {\n+    raw_items: RawItems,\n+    source_file_items: Arc<SourceFileItems>,\n+    source_map: ImportSourceMap,\n+}\n+\n+impl RawItemsCollector {\n+    fn process_module(&mut self, current_module: Option<Module>, body: &impl ast::ModuleItemOwner) {\n+        for item_or_macro in body.items_with_macros() {\n+            match item_or_macro {\n+                ast::ItemOrMacro::Macro(m) => self.add_macro(current_module, m),\n+                ast::ItemOrMacro::Item(item) => self.add_item(current_module, item),\n+            }\n+        }\n+    }\n+\n+    fn add_item(&mut self, current_module: Option<Module>, item: &ast::ModuleItem) {\n+        let (kind, name) = match item.kind() {\n+            ast::ModuleItemKind::Module(module) => {\n+                self.add_module(current_module, module);\n+                return;\n+            }\n+            ast::ModuleItemKind::UseItem(use_item) => {\n+                self.add_use_item(current_module, use_item);\n+                return;\n+            }\n+            ast::ModuleItemKind::ExternCrateItem(extern_crate) => {\n+                self.add_extern_crate_item(current_module, extern_crate);\n+                return;\n+            }\n+            ast::ModuleItemKind::ImplBlock(_) => {\n+                // impls don't participate in name resolution\n+                return;\n+            }\n+            ast::ModuleItemKind::StructDef(it) => (DefKind::Struct, it.name()),\n+            ast::ModuleItemKind::EnumDef(it) => (DefKind::Enum, it.name()),\n+            ast::ModuleItemKind::FnDef(it) => (DefKind::Function, it.name()),\n+            ast::ModuleItemKind::TraitDef(it) => (DefKind::Trait, it.name()),\n+            ast::ModuleItemKind::TypeAliasDef(it) => (DefKind::TypeAlias, it.name()),\n+            ast::ModuleItemKind::ConstDef(it) => (DefKind::Const, it.name()),\n+            ast::ModuleItemKind::StaticDef(it) => (DefKind::Static, it.name()),\n+        };\n+        if let Some(name) = name {\n+            let name = name.as_name();\n+            let source_item_id = self.source_file_items.id_of_unchecked(item.syntax());\n+            let def = self.raw_items.defs.alloc(DefData { name, kind, source_item_id });\n+            self.push_item(current_module, RawItem::Def(def))\n+        }\n+    }\n+\n+    fn add_module(&mut self, current_module: Option<Module>, module: &ast::Module) {\n+        let name = match module.name() {\n+            Some(it) => it.as_name(),\n+            None => return,\n+        };\n+        let source_item_id = self.source_file_items.id_of_unchecked(module.syntax());\n+        if module.has_semi() {\n+            let item =\n+                self.raw_items.modules.alloc(ModuleData::Declaration { name, source_item_id });\n+            self.push_item(current_module, RawItem::Module(item));\n+            return;\n+        }\n+\n+        if let Some(item_list) = module.item_list() {\n+            let item = self.raw_items.modules.alloc(ModuleData::Definition {\n+                name,\n+                source_item_id,\n+                items: Vec::new(),\n+            });\n+            self.process_module(Some(item), item_list);\n+            self.push_item(current_module, RawItem::Module(item));\n+            return;\n+        }\n+        tested_by!(name_res_works_for_broken_modules);\n+    }\n+\n+    fn add_use_item(&mut self, current_module: Option<Module>, use_item: &ast::UseItem) {\n+        let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n+\n+        Path::expand_use_item(use_item, |path, segment, alias| {\n+            let import = self.raw_items.imports.alloc(ImportData {\n+                path,\n+                alias,\n+                is_glob: segment.is_none(),\n+                is_prelude,\n+                is_extern_crate: false,\n+            });\n+            if let Some(segment) = segment {\n+                self.source_map.insert(import, segment)\n+            }\n+            self.push_item(current_module, RawItem::Import(import))\n+        })\n+    }\n+\n+    fn add_extern_crate_item(\n+        &mut self,\n+        current_module: Option<Module>,\n+        extern_crate: &ast::ExternCrateItem,\n+    ) {\n+        if let Some(name_ref) = extern_crate.name_ref() {\n+            let path = Path::from_name_ref(name_ref);\n+            let alias = extern_crate.alias().and_then(|a| a.name()).map(AsName::as_name);\n+            let import = self.raw_items.imports.alloc(ImportData {\n+                path,\n+                alias,\n+                is_glob: false,\n+                is_prelude: false,\n+                is_extern_crate: true,\n+            });\n+            self.push_item(current_module, RawItem::Import(import))\n+        }\n+    }\n+\n+    fn add_macro(&mut self, current_module: Option<Module>, m: &ast::MacroCall) {\n+        let (path, arg) = match (\n+            m.path().and_then(Path::from_ast),\n+            m.token_tree().and_then(mbe::ast_to_token_tree),\n+        ) {\n+            (Some(path), Some((token_tree, _token_map))) => (path, token_tree),\n+            _ => return,\n+        };\n+\n+        let name = m.name().map(|it| it.as_name());\n+        let source_item_id = self.source_file_items.id_of_unchecked(m.syntax());\n+        let export = m.has_atom_attr(\"macro_export\");\n+        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, arg, name, export });\n+        self.push_item(current_module, RawItem::Macro(m));\n+    }\n+\n+    fn push_item(&mut self, current_module: Option<Module>, item: RawItem) {\n+        match current_module {\n+            Some(module) => match &mut self.raw_items.modules[module] {\n+                ModuleData::Definition { items, .. } => items,\n+                ModuleData::Declaration { .. } => unreachable!(),\n+            },\n+            None => &mut self.raw_items.items,\n+        }\n+        .push(item)\n+    }\n+}"}, {"sha": "ac9b88520e03bfa38ed087cf6bbd0c43d72cd75a", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 285, "deletions": 499, "changes": 784, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -1,34 +1,43 @@\n+mod macros;\n+mod globs;\n+mod incremental;\n+\n use std::sync::Arc;\n \n use ra_db::SourceDatabase;\n-use test_utils::{assert_eq_text, covers};\n-\n-use crate::{\n-    ItemMap,\n-    PersistentHirDatabase,\n-    mock::MockDatabase,\n-    module_tree::ModuleId,\n-};\n-use super::Resolution;\n-\n-fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n-    let (db, pos) = MockDatabase::with_position(fixture);\n-    let module = crate::source_binder::module_from_position(&db, pos).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let module_id = module.module_id;\n-    (db.item_map(krate), module_id)\n+use test_utils::covers;\n+use insta::assert_snapshot_matches;\n+\n+use crate::{Crate, mock::{MockDatabase, CrateGraphFixture}, nameres::Resolution};\n+\n+use super::*;\n+\n+fn compute_crate_def_map(fixture: &str, graph: Option<CrateGraphFixture>) -> Arc<CrateDefMap> {\n+    let mut db = MockDatabase::with_files(fixture);\n+    if let Some(graph) = graph {\n+        db.set_crate_graph_from_fixture(graph);\n+    }\n+    let crate_id = db.crate_graph().iter().next().unwrap();\n+    let krate = Crate { crate_id };\n+    db.crate_def_map(krate)\n }\n \n-fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n-    let mut lines = map[module_id]\n-        .items\n-        .iter()\n-        .map(|(name, res)| format!(\"{}: {}\", name, dump_resolution(res)))\n-        .collect::<Vec<_>>();\n-    lines.sort();\n-    let actual = lines.join(\"\\n\");\n-    let expected = expected.trim().lines().map(|it| it.trim()).collect::<Vec<_>>().join(\"\\n\");\n-    assert_eq_text!(&expected, &actual);\n+fn render_crate_def_map(map: &CrateDefMap) -> String {\n+    let mut buf = String::new();\n+    go(&mut buf, map, \"\\ncrate\", map.root);\n+    return buf;\n+\n+    fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: CrateModuleId) {\n+        *buf += path;\n+        *buf += \"\\n\";\n+        for (name, res) in map.modules[module].scope.items.iter() {\n+            *buf += &format!(\"{}: {}\\n\", name, dump_resolution(res))\n+        }\n+        for (name, child) in map.modules[module].children.iter() {\n+            let path = path.to_string() + &format!(\"::{}\", name);\n+            go(buf, map, &path, *child);\n+        }\n+    }\n \n     fn dump_resolution(resolution: &Resolution) -> &'static str {\n         match (resolution.def.types.is_some(), resolution.def.values.is_some()) {\n@@ -40,95 +49,146 @@ fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n     }\n }\n \n+fn def_map(fixtute: &str) -> String {\n+    let dm = compute_crate_def_map(fixtute, None);\n+    render_crate_def_map(&dm)\n+}\n+\n+fn def_map_with_crate_graph(fixtute: &str, graph: CrateGraphFixture) -> String {\n+    let dm = compute_crate_def_map(fixtute, Some(graph));\n+    render_crate_def_map(&dm)\n+}\n+\n #[test]\n-fn item_map_smoke_test() {\n-    let (item_map, module_id) = item_map(\n+fn crate_def_map_smoke_test() {\n+    let map = def_map(\n         \"\n         //- /lib.rs\n         mod foo;\n-\n-        use crate::foo::bar::Baz;\n-        <|>\n+        struct S;\n+        use crate::foo::bar::E;\n+        use self::E::V;\n \n         //- /foo/mod.rs\n         pub mod bar;\n+        fn f() {}\n \n         //- /foo/bar.rs\n         pub struct Baz;\n-    \",\n+        enum E { V }\n+        \",\n     );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+V: t v\n+E: t\n+foo: t\n+S: t v\n+\n+crate::foo\n+bar: t\n+f: v\n+\n+crate::foo::bar\n+Baz: t v\n+E: t\n+\"###\n+    )\n+}\n+\n+#[test]\n+fn bogus_paths() {\n+    covers!(bogus_paths);\n+    let map = def_map(\n         \"\n-            Baz: t v\n-            foo: t\n+        //- /lib.rs\n+        mod foo;\n+        struct S;\n+        use self;\n+\n+        //- /foo/mod.rs\n+        use super;\n+        use crate;\n+\n         \",\n     );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+foo: t\n+S: t v\n+\n+crate::foo\n+\"###\n+    )\n }\n \n #[test]\n fn use_as() {\n-    let (item_map, module_id) = item_map(\n+    let map = def_map(\n         \"\n         //- /lib.rs\n         mod foo;\n \n         use crate::foo::Baz as Foo;\n-        <|>\n \n         //- /foo/mod.rs\n         pub struct Baz;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Foo: t v\n-            foo: t\n         \",\n     );\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Foo: t v\n+foo: t\n+\n+crate::foo\n+Baz: t v\n+\"###\n+    );\n }\n \n #[test]\n fn use_trees() {\n-    let (item_map, module_id) = item_map(\n+    let map = def_map(\n         \"\n         //- /lib.rs\n         mod foo;\n \n         use crate::foo::bar::{Baz, Quux};\n-        <|>\n \n         //- /foo/mod.rs\n         pub mod bar;\n \n         //- /foo/bar.rs\n         pub struct Baz;\n         pub enum Quux {};\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            Quux: t\n-            foo: t\n         \",\n     );\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Quux: t\n+Baz: t v\n+foo: t\n+\n+crate::foo\n+bar: t\n+\n+crate::foo::bar\n+Quux: t\n+Baz: t v\n+\"###\n+    );\n }\n \n #[test]\n fn re_exports() {\n-    let (item_map, module_id) = item_map(\n+    let map = def_map(\n         \"\n         //- /lib.rs\n         mod foo;\n \n         use self::foo::Baz;\n-        <|>\n \n         //- /foo/mod.rs\n         pub mod bar;\n@@ -137,137 +197,73 @@ fn re_exports() {\n \n         //- /foo/bar.rs\n         pub struct Baz;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            foo: t\n         \",\n     );\n-}\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Baz: t v\n+foo: t\n \n-#[test]\n-fn glob_1() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-        <|>\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::Baz;\n-        pub struct Foo;\n+crate::foo\n+bar: t\n+Baz: t v\n \n-        //- /foo/bar.rs\n-        pub struct Baz;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            Foo: t v\n-            bar: t\n-            foo: t\n-        \",\n+crate::foo::bar\n+Baz: t v\n+\"###\n     );\n }\n \n #[test]\n-fn glob_2() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        use foo::*;\n-        <|>\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-        pub use self::bar::*;\n-        pub struct Foo;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        pub use super::*;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n+fn std_prelude() {\n+    covers!(std_prelude);\n+    let map = def_map_with_crate_graph(\n         \"\n-            Baz: t v\n-            Foo: t v\n-            bar: t\n-            foo: t\n-        \",\n-    );\n-}\n+        //- /main.rs\n+        use Foo::*;\n \n-#[test]\n-fn glob_enum() {\n-    covers!(glob_enum);\n-    let (item_map, module_id) = item_map(\n-        \"\n         //- /lib.rs\n-        enum Foo {\n-            Bar, Baz\n-        }\n-        use self::Foo::*;\n-        <|>\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Bar: t v\n-            Baz: t v\n-            Foo: t\n+        mod prelude;\n+        #[prelude_import]\n+        use prelude::*;\n+\n+        //- /prelude.rs\n+        pub enum Foo { Bar, Baz };\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n     );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Bar: t v\n+Baz: t v\n+\"###);\n }\n \n #[test]\n-fn glob_across_crates() {\n-    covers!(glob_across_crates);\n-    let mut db = MockDatabase::with_files(\n+fn can_import_enum_variant() {\n+    covers!(can_import_enum_variant);\n+    let map = def_map(\n         \"\n-        //- /main.rs\n-        use test_crate::*;\n-\n         //- /lib.rs\n-        pub struct Baz;\n+        enum E { V }\n+        use self::E::V;\n         \",\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-            Baz: t v\n-        \",\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+V: t v\n+E: t\n+\"###\n     );\n }\n \n #[test]\n fn edition_2015_imports() {\n-    let mut db = MockDatabase::with_files(\n+    let map = def_map_with_crate_graph(\n         \"\n         //- /main.rs\n         mod foo;\n@@ -282,31 +278,32 @@ fn edition_2015_imports() {\n \n         //- /lib.rs\n         struct FromLib;\n-    \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", \"2015\", [\"other_crate\"]),\n-        \"other_crate\": (\"/lib.rs\", \"2018\", []),\n-    });\n-    let foo_id = db.file_id_of(\"/foo.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, foo_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-            Bar: t v\n-            FromLib: t v\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", \"2015\", [\"other_crate\"]),\n+            \"other_crate\": (\"/lib.rs\", \"2018\", []),\n+        },\n+    );\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+bar: t\n+foo: t\n+\n+crate::bar\n+Bar: t v\n+\n+crate::foo\n+FromLib: t v\n+Bar: t v\n+\"###\n     );\n }\n \n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n-    let mut db = MockDatabase::with_files(\n+    let map = def_map_with_crate_graph(\n         \"\n         //- /my_library.rs\n         mod foo;\n@@ -315,73 +312,32 @@ fn module_resolution_works_for_non_standard_filenames() {\n         //- /foo/mod.rs\n         pub struct Bar;\n         \",\n+        crate_graph! {\n+            \"my_library\": (\"/my_library.rs\", []),\n+        },\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"my_library\": (\"/my_library.rs\", []),\n-    });\n-    let file_id = db.file_id_of(\"/my_library.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, file_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let module_id = module.module_id;\n-    let item_map = db.item_map(krate);\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-        Bar: t v\n-        foo: t\n-        \",\n-    );\n-}\n \n-#[test]\n-fn std_prelude() {\n-    covers!(std_prelude);\n-    let mut db = MockDatabase::with_files(\n-        \"\n-        //- /main.rs\n-        use Foo::*;\n-\n-        //- /lib.rs\n-        mod prelude;\n-        #[prelude_import]\n-        use prelude::*;\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Bar: t v\n+foo: t\n \n-        //- /prelude.rs\n-        pub enum Foo { Bar, Baz };\n-    \",\n-    );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-            Bar: t v\n-            Baz: t v\n-        \",\n+crate::foo\n+Bar: t v\n+\"###\n     );\n }\n \n #[test]\n fn name_res_works_for_broken_modules() {\n     covers!(name_res_works_for_broken_modules);\n-    let (item_map, module_id) = item_map(\n+    let map = def_map(\n         \"\n         //- /lib.rs\n         mod foo // no `;`, no body\n \n         use self::foo::Baz;\n-        <|>\n \n         //- /foo/mod.rs\n         pub mod bar;\n@@ -390,95 +346,71 @@ fn name_res_works_for_broken_modules() {\n \n         //- /foo/bar.rs\n         pub struct Baz;\n-    \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: _\n         \",\n     );\n-}\n-\n-#[test]\n-fn item_map_using_self() {\n-    let (item_map, module_id) = item_map(\n-        \"\n-            //- /lib.rs\n-            mod foo;\n-            use crate::foo::bar::Baz::{self};\n-            <|>\n-            //- /foo/mod.rs\n-            pub mod bar;\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-    );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-            Baz: t v\n-            foo: t\n-        \",\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Baz: _\n+\"###\n     );\n }\n \n #[test]\n-fn item_map_enum_importing() {\n-    covers!(item_map_enum_importing);\n-    let (item_map, module_id) = item_map(\n+fn item_map_using_self() {\n+    let map = def_map(\n         \"\n         //- /lib.rs\n-        enum E { V }\n-        use self::E::V;\n-        <|>\n+        mod foo;\n+        use crate::foo::bar::Baz::{self};\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        //- /foo/bar.rs\n+        pub struct Baz;\n         \",\n     );\n-    check_module_item_map(\n-        &item_map,\n-        module_id,\n-        \"\n-        E: t\n-        V: t v\n-        \",\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Baz: t v\n+foo: t\n+\n+crate::foo\n+bar: t\n+\n+crate::foo::bar\n+Baz: t v\n+\"###\n     );\n }\n \n #[test]\n fn item_map_across_crates() {\n-    let mut db = MockDatabase::with_files(\n+    let map = def_map_with_crate_graph(\n         \"\n         //- /main.rs\n         use test_crate::Baz;\n \n         //- /lib.rs\n         pub struct Baz;\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Baz: t v\n-        \",\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Baz: t v\n+\"###\n     );\n }\n \n #[test]\n fn extern_crate_rename() {\n-    let mut db = MockDatabase::with_files(\n+    let map = def_map_with_crate_graph(\n         \"\n         //- /main.rs\n         extern crate alloc as alloc_crate;\n@@ -492,29 +424,23 @@ fn extern_crate_rename() {\n         //- /lib.rs\n         struct Arc;\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"alloc\"]),\n+            \"alloc\": (\"/lib.rs\", []),\n+        },\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"alloc\"]),\n-        \"alloc\": (\"/lib.rs\", []),\n-    });\n-    let sync_id = db.file_id_of(\"/sync.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, sync_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Arc: t v\n-        \",\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Arc: t v\n+\"###\n     );\n }\n \n #[test]\n fn extern_crate_rename_2015_edition() {\n-    let mut db = MockDatabase::with_files(\n+    let map = def_map_with_crate_graph(\n         \"\n         //- /main.rs\n         extern crate alloc as alloc_crate;\n@@ -528,29 +454,23 @@ fn extern_crate_rename_2015_edition() {\n         //- /lib.rs\n         struct Arc;\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", \"2015\", [\"alloc\"]),\n+            \"alloc\": (\"/lib.rs\", []),\n+        },\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", \"2015\", [\"alloc\"]),\n-        \"alloc\": (\"/lib.rs\", []),\n-    });\n-    let sync_id = db.file_id_of(\"/sync.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, sync_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Arc: t v\n-        \",\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Arc: t v\n+\"###\n     );\n }\n \n #[test]\n fn import_across_source_roots() {\n-    let mut db = MockDatabase::with_files(\n+    let map = def_map_with_crate_graph(\n         \"\n         //- /lib.rs\n         pub mod a {\n@@ -564,29 +484,23 @@ fn import_across_source_roots() {\n         //- /main/main.rs\n         use test_crate::a::b::C;\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-            C: t v\n-        \",\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+C: t v\n+\"###\n     );\n }\n \n #[test]\n fn reexport_across_crates() {\n-    let mut db = MockDatabase::with_files(\n+    let map = def_map_with_crate_graph(\n         \"\n         //- /main.rs\n         use test_crate::Baz;\n@@ -599,29 +513,23 @@ fn reexport_across_crates() {\n         //- /foo.rs\n         pub struct Baz;\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"test_crate\"]),\n-        \"test_crate\": (\"/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Baz: t v\n-        \",\n+\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Baz: t v\n+\"###\n     );\n }\n \n #[test]\n fn values_dont_shadow_extern_crates() {\n-    let mut db = MockDatabase::with_files(\n+    let map = def_map_with_crate_graph(\n         \"\n         //- /main.rs\n         fn foo() {}\n@@ -630,139 +538,17 @@ fn values_dont_shadow_extern_crates() {\n         //- /foo/lib.rs\n         pub struct Bar;\n         \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"foo\"]),\n+            \"foo\": (\"/foo/lib.rs\", []),\n+        },\n     );\n-    db.set_crate_graph_from_fixture(crate_graph! {\n-        \"main\": (\"/main.rs\", [\"foo\"]),\n-        \"foo\": (\"/foo/lib.rs\", []),\n-    });\n-    let main_id = db.file_id_of(\"/main.rs\");\n-\n-    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    let item_map = db.item_map(krate);\n-\n-    check_module_item_map(\n-        &item_map,\n-        module.module_id,\n-        \"\n-        Bar: t v\n-        foo: v\n-        \",\n-    );\n-}\n-\n-fn check_item_map_is_not_recomputed(initial: &str, file_change: &str) {\n-    let (mut db, pos) = MockDatabase::with_position(initial);\n-    let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n-    let krate = module.krate(&db).unwrap();\n-    {\n-        let events = db.log_executed(|| {\n-            db.item_map(krate);\n-        });\n-        assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n-    }\n-    db.set_file_text(pos.file_id, Arc::new(file_change.to_string()));\n-\n-    {\n-        let events = db.log_executed(|| {\n-            db.item_map(krate);\n-        });\n-        assert!(!format!(\"{:?}\", events).contains(\"item_map\"), \"{:#?}\", events)\n-    }\n-}\n-\n-#[test]\n-fn typing_inside_a_function_should_not_invalidate_item_map() {\n-    check_item_map_is_not_recomputed(\n-        \"\n-        //- /lib.rs\n-        mod foo;<|>\n-\n-        use crate::foo::bar::Baz;\n-\n-        fn foo() -> i32 {\n-            1 + 1\n-        }\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n-        \"\n-        mod foo;\n-\n-        use crate::foo::bar::Baz;\n-\n-        fn foo() -> i32 { 92 }\n-        \",\n-    );\n-}\n-\n-#[test]\n-fn adding_inner_items_should_not_invalidate_item_map() {\n-    check_item_map_is_not_recomputed(\n-        \"\n-        //- /lib.rs\n-        struct S { a: i32}\n-        enum E { A }\n-        trait T {\n-            fn a() {}\n-        }\n-        mod foo;<|>\n-        impl S {\n-            fn a() {}\n-        }\n-        use crate::foo::bar::Baz;\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n-        \"\n-        struct S { a: i32, b: () }\n-        enum E { A, B }\n-        trait T {\n-            fn a() {}\n-            fn b() {}\n-        }\n-        mod foo;<|>\n-        impl S {\n-            fn a() {}\n-            fn b() {}\n-        }\n-        use crate::foo::bar::Baz;\n-        \",\n-    );\n-}\n \n-#[test]\n-fn typing_inside_a_function_inside_a_macro_should_not_invalidate_item_map() {\n-    check_item_map_is_not_recomputed(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-\n-        use crate::foo::bar::Baz;\n-\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        //- /foo/bar.rs\n-        <|>\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 1 + 1 }\n-            }\n-        }\n-        \",\n-        \"\n-        salsa::query_group! {\n-            trait Baz {\n-                fn foo() -> i32 { 92 }\n-            }\n-        }\n-        \",\n+    assert_snapshot_matches!(map,\n+        @r###\"\n+crate\n+Bar: t v\n+foo: v\n+\"###\n     );\n }"}, {"sha": "6e50c7ff6e931b1e0b4f480bd0609a02983f950c", "filename": "crates/ra_hir/src/nameres/tests/globs.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -0,0 +1,118 @@\n+use super::*;\n+\n+#[test]\n+fn glob_1() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        pub use self::bar::Baz;\n+        pub struct Foo;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+bar: t\n+Foo: t v\n+Baz: t v\n+foo: t\n+\n+crate::foo\n+bar: t\n+Foo: t v\n+Baz: t v\n+\n+crate::foo::bar\n+Baz: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn glob_2() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+        use foo::*;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+        pub use self::bar::*;\n+        pub struct Foo;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        pub use super::*;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+bar: t\n+Foo: t v\n+Baz: t v\n+foo: t\n+\n+crate::foo\n+bar: t\n+Foo: t v\n+Baz: t v\n+\n+crate::foo::bar\n+bar: t\n+Foo: t v\n+Baz: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn glob_across_crates() {\n+    covers!(glob_across_crates);\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        use test_crate::*;\n+\n+        //- /lib.rs\n+        pub struct Baz;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"test_crate\"]),\n+            \"test_crate\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Baz: t v\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn glob_enum() {\n+    covers!(glob_enum);\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        enum Foo {\n+            Bar, Baz\n+        }\n+        use self::Foo::*;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+Foo: t\n+Bar: t v\n+Baz: t v\n+\"###\n+    );\n+}"}, {"sha": "6987819233bdfda886741c3f441d6338dada1d2b", "filename": "crates/ra_hir/src/nameres/tests/incremental.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -0,0 +1,123 @@\n+use super::*;\n+\n+use std::sync::Arc;\n+\n+use ra_db::SourceDatabase;\n+\n+fn check_def_map_is_not_recomputed(initial: &str, file_change: &str) {\n+    let (mut db, pos) = MockDatabase::with_position(initial);\n+    let crate_id = db.crate_graph().iter().next().unwrap();\n+    let krate = Crate { crate_id };\n+    {\n+        let events = db.log_executed(|| {\n+            db.crate_def_map(krate);\n+        });\n+        assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+    }\n+    db.set_file_text(pos.file_id, Arc::new(file_change.to_string()));\n+\n+    {\n+        let events = db.log_executed(|| {\n+            db.crate_def_map(krate);\n+        });\n+        assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n+    }\n+}\n+\n+#[test]\n+fn typing_inside_a_function_should_not_invalidate_def_map() {\n+    check_def_map_is_not_recomputed(\n+        \"\n+        //- /lib.rs\n+        mod foo;<|>\n+\n+        use crate::foo::bar::Baz;\n+\n+        fn foo() -> i32 {\n+            1 + 1\n+        }\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \",\n+        \"\n+        mod foo;\n+\n+        use crate::foo::bar::Baz;\n+\n+        fn foo() -> i32 { 92 }\n+        \",\n+    );\n+}\n+\n+#[test]\n+fn adding_inner_items_should_not_invalidate_def_map() {\n+    check_def_map_is_not_recomputed(\n+        \"\n+        //- /lib.rs\n+        struct S { a: i32}\n+        enum E { A }\n+        trait T {\n+            fn a() {}\n+        }\n+        mod foo;<|>\n+        impl S {\n+            fn a() {}\n+        }\n+        use crate::foo::bar::Baz;\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        pub struct Baz;\n+        \",\n+        \"\n+        struct S { a: i32, b: () }\n+        enum E { A, B }\n+        trait T {\n+            fn a() {}\n+            fn b() {}\n+        }\n+        mod foo;<|>\n+        impl S {\n+            fn a() {}\n+            fn b() {}\n+        }\n+        use crate::foo::bar::Baz;\n+        \",\n+    );\n+}\n+\n+// It would be awesome to make this work, but it's unclear how\n+#[test]\n+#[ignore]\n+fn typing_inside_a_function_inside_a_macro_should_not_invalidate_def_map() {\n+    check_def_map_is_not_recomputed(\n+        \"\n+        //- /lib.rs\n+        mod foo;\n+\n+        use crate::foo::bar::Baz;\n+\n+        //- /foo/mod.rs\n+        pub mod bar;\n+\n+        //- /foo/bar.rs\n+        <|>\n+        salsa::query_group! {\n+            trait Baz {\n+                fn foo() -> i32 { 1 + 1 }\n+            }\n+        }\n+        \",\n+        \"\n+        salsa::query_group! {\n+            trait Baz {\n+                fn foo() -> i32 { 92 }\n+            }\n+        }\n+        \",\n+    );\n+}"}, {"sha": "8781b026b6fb3ef1294a5a8013daa5b4442e6ae5", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -0,0 +1,94 @@\n+use super::*;\n+\n+#[test]\n+fn macro_rules_are_globally_visible() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        macro_rules! structs {\n+            ($($i:ident),*) => {\n+                $(struct $i { field: u32 } )*\n+            }\n+        }\n+        structs!(Foo);\n+        mod nested;\n+\n+        //- /nested.rs\n+        structs!(Bar, Baz);\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+nested: t\n+Foo: t v\n+\n+crate::nested\n+Bar: t v\n+Baz: t v\n+\"###);\n+}\n+\n+#[test]\n+fn macro_rules_can_define_modules() {\n+    let map = def_map(\n+        \"\n+        //- /lib.rs\n+        macro_rules! m {\n+            ($name:ident) => { mod $name;  }\n+        }\n+        m!(n1);\n+\n+        //- /n1.rs\n+        m!(n2)\n+        //- /n1/n2.rs\n+        struct X;\n+        \",\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+n1: t\n+\n+crate::n1\n+n2: t\n+\n+crate::n1::n2\n+X: t v\n+\"###);\n+}\n+\n+#[test]\n+fn macro_rules_from_other_crates_are_visible() {\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        foo::structs!(Foo, Bar)\n+        mod bar;\n+\n+        //- /bar.rs\n+        use crate::*;\n+\n+        //- /lib.rs\n+        #[macro_export]\n+        macro_rules! structs {\n+            ($($i:ident),*) => {\n+                $(struct $i { field: u32 } )*\n+            }\n+        }\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"foo\"]),\n+            \"foo\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot_matches!(map, @r###\"\n+crate\n+bar: t\n+Foo: t v\n+Bar: t v\n+\n+crate::bar\n+bar: t\n+Foo: t v\n+Bar: t v\n+\"###);\n+}"}, {"sha": "59af4ec60f4f4cf02dcef9bd22be7098a3651b63", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -4,10 +4,10 @@ use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    ModuleDef, Module,\n+    ModuleDef,\n     db::HirDatabase,\n     name::{Name, KnownName},\n-    nameres::{PerNs, ItemMap},\n+    nameres::{PerNs, CrateDefMap, CrateModuleId},\n     generics::GenericParams,\n     expr::{scope::{ExprScopes, ScopeId}, PatId, Body},\n     impl_block::ImplBlock,\n@@ -22,8 +22,8 @@ pub struct Resolver {\n // TODO how to store these best\n #[derive(Debug, Clone)]\n pub(crate) struct ModuleItemMap {\n-    item_map: Arc<ItemMap>,\n-    module: Module,\n+    crate_def_map: Arc<CrateDefMap>,\n+    module_id: CrateModuleId,\n }\n \n #[derive(Debug, Clone)]\n@@ -175,9 +175,9 @@ impl Resolver {\n         names\n     }\n \n-    fn module(&self) -> Option<(&ItemMap, Module)> {\n+    fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n-            Scope::ModuleScope(m) => Some((&*m.item_map, m.module.clone())),\n+            Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n \n             _ => None,\n         })\n@@ -206,8 +206,12 @@ impl Resolver {\n         self.push_scope(Scope::ImplBlockScope(impl_block))\n     }\n \n-    pub(crate) fn push_module_scope(self, item_map: Arc<ItemMap>, module: Module) -> Resolver {\n-        self.push_scope(Scope::ModuleScope(ModuleItemMap { item_map, module }))\n+    pub(crate) fn push_module_scope(\n+        self,\n+        crate_def_map: Arc<CrateDefMap>,\n+        module_id: CrateModuleId,\n+    ) -> Resolver {\n+        self.push_scope(Scope::ModuleScope(ModuleItemMap { crate_def_map, module_id }))\n     }\n \n     pub(crate) fn push_expr_scope(\n@@ -224,9 +228,11 @@ impl Scope {\n         match self {\n             Scope::ModuleScope(m) => {\n                 if let Some(KnownName::SelfParam) = name.as_known_name() {\n-                    PerNs::types(Resolution::Def(m.module.into()))\n+                    PerNs::types(Resolution::Def(m.crate_def_map.mk_module(m.module_id).into()))\n                 } else {\n-                    m.item_map.resolve_name_in_module(db, m.module, name).map(Resolution::Def)\n+                    m.crate_def_map\n+                        .resolve_name_in_module(db, m.module_id, name)\n+                        .map(Resolution::Def)\n                 }\n             }\n             Scope::GenericParams(gp) => match gp.find_by_name(name) {\n@@ -261,15 +267,15 @@ impl Scope {\n                 //         def: m.module.into(),\n                 //     }),\n                 // );\n-                m.item_map[m.module.module_id].entries().for_each(|(name, res)| {\n+                m.crate_def_map[m.module_id].scope.entries().for_each(|(name, res)| {\n                     f(name.clone(), res.def.map(Resolution::Def));\n                 });\n-                m.item_map.extern_prelude.iter().for_each(|(name, def)| {\n+                m.crate_def_map.extern_prelude().iter().for_each(|(name, def)| {\n                     f(name.clone(), PerNs::types(Resolution::Def(*def)));\n                 });\n-                if let Some(prelude) = m.item_map.prelude {\n-                    let prelude_item_map = db.item_map(prelude.krate);\n-                    prelude_item_map[prelude.module_id].entries().for_each(|(name, res)| {\n+                if let Some(prelude) = m.crate_def_map.prelude() {\n+                    let prelude_def_map = db.crate_def_map(prelude.krate);\n+                    prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n                         f(name.clone(), res.def.map(Resolution::Def));\n                     });\n                 }"}, {"sha": "9021109139bd45825f0a2f19dbb8c44c38b00325", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 4, "deletions": 42, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -7,13 +7,13 @@\n /// purely for \"IDE needs\".\n use ra_db::{FileId, FilePosition};\n use ra_syntax::{\n-    SmolStr, TextRange, SyntaxNode,\n+    SyntaxNode,\n     ast::{self, AstNode, NameOwner},\n     algo::{find_node_at_offset, find_leaf_at_offset},\n };\n \n use crate::{\n-    HirDatabase, Function, ModuleDef, Struct, Enum,\n+    HirDatabase, Function, Struct, Enum,\n     AsName, Module, HirFileId, Crate, Trait, Resolver,\n     ids::{LocationCtx, SourceFileItemId},\n     expr\n@@ -80,8 +80,8 @@ fn module_from_source(\n     let source_root_id = db.file_source_root(file_id.as_original_file());\n     db.source_root_crates(source_root_id).iter().map(|&crate_id| Crate { crate_id }).find_map(\n         |krate| {\n-            let module_tree = db.module_tree(krate);\n-            let module_id = module_tree.find_module_by_source(file_id, decl_id)?;\n+            let def_map = db.crate_def_map(krate);\n+            let module_id = def_map.find_module_by_source(file_id, decl_id)?;\n             Some(Module { krate, module_id })\n         },\n     )\n@@ -152,44 +152,6 @@ pub fn trait_from_module(\n     Trait { id: ctx.to_def(trait_def) }\n }\n \n-pub fn macro_symbols(db: &impl HirDatabase, file_id: FileId) -> Vec<(SmolStr, TextRange)> {\n-    let module = match module_from_file_id(db, file_id) {\n-        Some(it) => it,\n-        None => return Vec::new(),\n-    };\n-    let items = db.lower_module(module);\n-    let mut res = Vec::new();\n-\n-    for macro_call_id in items\n-        .declarations\n-        .iter()\n-        .filter_map(|(_, it)| it.clone().take_types())\n-        .filter_map(|it| match it {\n-            ModuleDef::Trait(it) => Some(it),\n-            _ => None,\n-        })\n-        .filter_map(|it| it.source(db).0.as_macro_call_id())\n-    {\n-        if let Some(exp) = db.expand_macro_invocation(macro_call_id) {\n-            let loc = macro_call_id.loc(db);\n-            let syntax = db.file_item(loc.source_item_id);\n-            let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n-            let off = macro_call.token_tree().unwrap().syntax().range().start();\n-            let file = exp.file();\n-            for trait_def in file.syntax().descendants().filter_map(ast::TraitDef::cast) {\n-                if let Some(name) = trait_def.name() {\n-                    let dst_range = name.syntax().range();\n-                    if let Some(src_range) = exp.map_range_back(dst_range) {\n-                        res.push((name.text().clone(), src_range + off))\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    res\n-}\n-\n pub fn resolver_for_position(db: &impl HirDatabase, position: FilePosition) -> Resolver {\n     let file_id = position.file_id;\n     let file = db.parse(file_id);"}, {"sha": "804824868505e27b197c545ff12f814585817de1", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -7,10 +7,12 @@ use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    HirDatabase, module_tree::ModuleId, Module, Crate, Name, Function, Trait,\n+    HirDatabase, Module, Crate, Name, Function, Trait,\n     ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n     ty::{AdtDef, Ty},\n+    nameres::CrateModuleId,\n+\n };\n \n /// This is used as a key for indexing impls.\n@@ -33,10 +35,10 @@ impl TyFingerprint {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct CrateImplBlocks {\n-    /// To make sense of the ModuleIds, we need the source root.\n+    /// To make sense of the CrateModuleIds, we need the source root.\n     krate: Crate,\n-    impls: FxHashMap<TyFingerprint, Vec<(ModuleId, ImplId)>>,\n-    impls_by_trait: FxHashMap<TraitId, Vec<(ModuleId, ImplId)>>,\n+    impls: FxHashMap<TyFingerprint, Vec<(CrateModuleId, ImplId)>>,\n+    impls_by_trait: FxHashMap<TraitId, Vec<(CrateModuleId, ImplId)>>,\n }\n \n impl CrateImplBlocks {"}, {"sha": "26fde91bcf012ea1e84b268c3085ca25f5370025", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -223,7 +223,7 @@ impl RootDatabase {\n         self.query(hir::db::FileItemsQuery).sweep(sweep);\n         self.query(hir::db::FileItemQuery).sweep(sweep);\n \n-        self.query(hir::db::LowerModuleWithSourceMapQuery).sweep(sweep);\n+        self.query(hir::db::RawItemsWithSourceMapQuery).sweep(sweep);\n         self.query(hir::db::BodyWithSourceMapQuery).sweep(sweep);\n     }\n }"}, {"sha": "d23290b74b29086bd7a54a3c54651df68a21aec2", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -1,55 +1,13 @@\n use ra_db::SourceDatabase;\n-use ra_syntax::{\n-    SyntaxNode, AstNode, SourceFile,\n-    ast, algo::find_covering_node,\n-};\n+use ra_syntax::AstNode;\n \n use crate::{\n     TextRange, FileRange,\n     db::RootDatabase,\n };\n \n+// FIXME: restore macro support\n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n     let source_file = db.parse(frange.file_id);\n-    if let Some(range) = extend_selection_in_macro(db, &source_file, frange) {\n-        return range;\n-    }\n     ra_ide_api_light::extend_selection(source_file.syntax(), frange.range).unwrap_or(frange.range)\n }\n-\n-fn extend_selection_in_macro(\n-    _db: &RootDatabase,\n-    source_file: &SourceFile,\n-    frange: FileRange,\n-) -> Option<TextRange> {\n-    let macro_call = find_macro_call(source_file.syntax(), frange.range)?;\n-    let (off, exp) = hir::MacroDef::ast_expand(macro_call)?;\n-    let dst_range = exp.map_range_forward(frange.range - off)?;\n-    let dst_range = ra_ide_api_light::extend_selection(&exp.syntax(), dst_range)?;\n-    let src_range = exp.map_range_back(dst_range)? + off;\n-    Some(src_range)\n-}\n-\n-fn find_macro_call(node: &SyntaxNode, range: TextRange) -> Option<&ast::MacroCall> {\n-    find_covering_node(node, range).ancestors().find_map(ast::MacroCall::cast)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_syntax::TextRange;\n-\n-    use crate::mock_analysis::single_file_with_range;\n-\n-    #[test]\n-    fn extend_selection_inside_macros() {\n-        let (analysis, frange) = single_file_with_range(\n-            \"\n-            fn main() {\n-                vec![foo(|x| <|>x<|>)];\n-            }\n-        \",\n-        );\n-        let r = analysis.extend_selection(frange).unwrap();\n-        assert_eq!(r, TextRange::from_to(50.into(), 55.into()));\n-    }\n-}"}, {"sha": "2395930f0d765f07f90d7515511c938740238c0d", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -1,7 +1,7 @@\n use itertools::Itertools;\n use ra_syntax::{\n     TextRange, SyntaxNode,\n-    ast::{self, AstNode, NameOwner, ModuleItemOwner},\n+    ast::{self, AstNode, NameOwner, ModuleItemOwner, AttrsOwner},\n };\n use ra_db::SourceDatabase;\n "}, {"sha": "23c743bef214910ddbdd3aa6593b2281a22de5a5", "filename": "crates/ra_ide_api/src/symbol_index.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsymbol_index.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -30,7 +30,7 @@ use std::{\n use fst::{self, Streamer};\n use ra_syntax::{\n     SyntaxNode, SyntaxNodePtr, SourceFile, SmolStr, TreeArc, AstNode,\n-    algo::{visit::{visitor, Visitor}, find_covering_node},\n+    algo::{visit::{visitor, Visitor}},\n     SyntaxKind::{self, *},\n     ast::{self, NameOwner},\n     WalkEvent,\n@@ -66,14 +66,9 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n     db.check_canceled();\n     let source_file = db.parse(file_id);\n \n-    let mut symbols = source_file_to_file_symbols(&source_file, file_id);\n+    let symbols = source_file_to_file_symbols(&source_file, file_id);\n \n-    for (name, text_range) in hir::source_binder::macro_symbols(db, file_id) {\n-        let node = find_covering_node(source_file.syntax(), text_range);\n-        let ptr = SyntaxNodePtr::new(node);\n-        // TODO: Should we get container name for macro symbols?\n-        symbols.push(FileSymbol { file_id, name, ptr, name_range: None, container_name: None })\n-    }\n+    // TODO: add macros here\n \n     Arc::new(SymbolIndex::new(symbols))\n }"}, {"sha": "fdd87bcfffc9a39d5b27c8f7721b1d27518a5ddd", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{ast, AstNode,};\n+use ra_syntax::AstNode;\n use ra_db::SourceDatabase;\n \n use crate::{\n@@ -8,37 +8,5 @@ use crate::{\n \n pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRange> {\n     let source_file = db.parse(file_id);\n-    let mut res = ra_ide_api_light::highlight(source_file.syntax());\n-    for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n-        if let Some((off, exp)) = hir::MacroDef::ast_expand(macro_call) {\n-            let mapped_ranges =\n-                ra_ide_api_light::highlight(&exp.syntax()).into_iter().filter_map(|r| {\n-                    let mapped_range = exp.map_range_back(r.range)?;\n-                    let res = HighlightedRange { range: mapped_range + off, tag: r.tag };\n-                    Some(res)\n-                });\n-            res.extend(mapped_ranges);\n-        }\n-    }\n-    res\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::mock_analysis::single_file;\n-\n-    use insta::assert_debug_snapshot_matches;\n-\n-    #[test]\n-    fn highlights_code_inside_macros() {\n-        let (analysis, file_id) = single_file(\n-            \"\n-            fn main() {\n-                vec![{ let x = 92; x}];\n-            }\n-            \",\n-        );\n-        let highlights = analysis.highlight(file_id).unwrap();\n-        assert_debug_snapshot_matches!(\"highlights_code_inside_macros\", &highlights);\n-    }\n+    ra_ide_api_light::highlight(source_file.syntax())\n }"}, {"sha": "5bb9538922312ebadc85efca82ae623c143649fa", "filename": "crates/ra_ide_api/tests/test/snapshots/test__unresolved_module_diagnostic.snap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Ftests%2Ftest%2Fsnapshots%2Ftest__unresolved_module_diagnostic.snap", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_ide_api%2Ftests%2Ftest%2Fsnapshots%2Ftest__unresolved_module_diagnostic.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Ftests%2Ftest%2Fsnapshots%2Ftest__unresolved_module_diagnostic.snap?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -7,7 +7,7 @@ source: \"crates\\\\ra_ide_api\\\\tests\\\\test\\\\main.rs\"\n [\n     Diagnostic {\n         message: \"unresolved module\",\n-        range: [4; 7),\n+        range: [0; 8),\n         fix: Some(\n             SourceChange {\n                 label: \"create module\","}, {"sha": "989308626b14db36fa837c81d521dd8e14e73e89", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -42,7 +42,7 @@ pub use crate::syntax_bridge::{ast_to_token_tree, token_tree_to_ast_item_list};\n /// be very confusing is that AST has almost exactly the same shape as\n /// `tt::TokenTree`, but there's a crucial difference: in macro rules, `$ident`\n /// and `$()*` have special meaning (see `Var` and `Repeat` data structures)\n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct MacroRules {\n     pub(crate) rules: Vec<Rule>,\n }\n@@ -56,21 +56,21 @@ impl MacroRules {\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Rule {\n     pub(crate) lhs: Subtree,\n     pub(crate) rhs: Subtree,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum TokenTree {\n     Leaf(Leaf),\n     Subtree(Subtree),\n     Repeat(Repeat),\n }\n impl_froms!(TokenTree: Leaf, Subtree, Repeat);\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Leaf {\n     Literal(Literal),\n     Punct(Punct),\n@@ -79,37 +79,37 @@ pub(crate) enum Leaf {\n }\n impl_froms!(Leaf: Literal, Punct, Ident, Var);\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Subtree {\n     pub(crate) delimiter: Delimiter,\n     pub(crate) token_trees: Vec<TokenTree>,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Repeat {\n     pub(crate) subtree: Subtree,\n     pub(crate) kind: RepeatKind,\n     pub(crate) separator: Option<char>,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum RepeatKind {\n     ZeroOrMore,\n     OneOrMore,\n     ZeroOrOne,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Literal {\n     pub(crate) text: SmolStr,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Ident {\n     pub(crate) text: SmolStr,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Var {\n     pub(crate) text: SmolStr,\n     pub(crate) kind: Option<SmolStr>,"}, {"sha": "2dafd68f624e53a4e5b2d6b7576da177d92525bc", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -155,7 +155,14 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                 _ => return Err(ExpandError::UnexpectedToken),\n             },\n             crate::TokenTree::Repeat(crate::Repeat { subtree, kind: _, separator }) => {\n+                // Dirty hack to make macro-expansion terminate.\n+                // This should be replaced by a propper macro-by-example implementation\n+                let mut limit = 128;\n                 while let Ok(nested) = match_lhs(subtree, input) {\n+                    limit -= 1;\n+                    if limit == 0 {\n+                        break;\n+                    }\n                     res.push_nested(nested)?;\n                     if let Some(separator) = *separator {\n                         if !input.is_eof() {\n@@ -196,7 +203,14 @@ fn expand_tt(\n         crate::TokenTree::Repeat(repeat) => {\n             let mut token_trees = Vec::new();\n             nesting.push(0);\n+            // Dirty hack to make macro-expansion terminate.\n+            // This should be replaced by a propper macro-by-example implementation\n+            let mut limit = 128;\n             while let Ok(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n+                limit -= 1;\n+                if limit == 0 {\n+                    break;\n+                }\n                 let idx = nesting.pop().unwrap();\n                 nesting.push(idx + 1);\n                 token_trees.push(t.into())"}, {"sha": "d8c2cb063f1ac03475901ba2c52bcb93a70b5f75", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -114,6 +114,9 @@ pub trait AttrsOwner: AstNode {\n     fn attrs(&self) -> AstChildren<Attr> {\n         children(self)\n     }\n+    fn has_atom_attr(&self, atom: &str) -> bool {\n+        self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n+    }\n }\n \n pub trait DocCommentsOwner: AstNode {\n@@ -153,12 +156,6 @@ pub trait DocCommentsOwner: AstNode {\n     }\n }\n \n-impl FnDef {\n-    pub fn has_atom_attr(&self, atom: &str) -> bool {\n-        self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n-    }\n-}\n-\n impl Attr {\n     pub fn is_inner(&self) -> bool {\n         let tt = match self.value() {"}, {"sha": "54b72f8c57bb971cb2e701a2d3131485ba610440", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -2108,6 +2108,7 @@ impl ToOwned for MacroCall {\n \n \n impl ast::NameOwner for MacroCall {}\n+impl ast::AttrsOwner for MacroCall {}\n impl MacroCall {\n     pub fn token_tree(&self) -> Option<&TokenTree> {\n         super::child_opt(self)"}, {"sha": "4f8e19bd00e48968c39ba0e77e7b7c8ef2b8c260", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -557,7 +557,7 @@ Grammar(\n         \"Name\": (),\n         \"NameRef\": (),\n         \"MacroCall\": (\n-            traits: [ \"NameOwner\" ],\n+            traits: [ \"NameOwner\", \"AttrsOwner\" ],\n             options: [ \"TokenTree\", \"Path\" ],\n         ),\n         \"Attr\": ( options: [ [\"value\", \"TokenTree\"] ] ),"}, {"sha": "1c268b49cd75b6f22bd6fd02efdc4512ceca6ba8", "filename": "crates/test_utils/src/marks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3f48cdaf20d718e711f999573adf3303e9396a/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmarks.rs?ref=7d3f48cdaf20d718e711f999573adf3303e9396a", "patch": "@@ -30,13 +30,13 @@ use std::sync::atomic::{AtomicUsize, Ordering};\n \n #[macro_export]\n macro_rules! tested_by {\n-    ($ident:ident) => {\n+    ($ident:ident) => {{\n         #[cfg(test)]\n         {\n             // sic! use call-site crate\n             crate::marks::$ident.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n         }\n-    };\n+    }};\n }\n \n #[macro_export]"}]}