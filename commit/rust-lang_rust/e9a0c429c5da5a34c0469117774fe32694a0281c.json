{"sha": "e9a0c429c5da5a34c0469117774fe32694a0281c", "node_id": "C_kwDOAAsO6NoAKGU5YTBjNDI5YzVkYTVhMzRjMDQ2OTExNzc3NGZlMzI2OTRhMDI4MWM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-01-25T03:13:38Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-15T05:03:24Z"}, "message": "Overhaul `TyS` and `Ty`.\n\nSpecifically, change `Ty` from this:\n```\npub type Ty<'tcx> = &'tcx TyS<'tcx>;\n```\nto this\n```\npub struct Ty<'tcx>(Interned<'tcx, TyS<'tcx>>);\n```\nThere are two benefits to this.\n- It's now a first class type, so we can define methods on it. This\n  means we can move a lot of methods away from `TyS`, leaving `TyS` as a\n  barely-used type, which is appropriate given that it's not meant to\n  be used directly.\n- The uniqueness requirement is now explicit, via the `Interned` type.\n  E.g. the pointer-based `Eq` and `Hash` comes from `Interned`, rather\n  than via `TyS`, which wasn't obvious at all.\n\nMuch of this commit is boring churn. The interesting changes are in\nthese files:\n- compiler/rustc_middle/src/arena.rs\n- compiler/rustc_middle/src/mir/visit.rs\n- compiler/rustc_middle/src/ty/context.rs\n- compiler/rustc_middle/src/ty/mod.rs\n\nSpecifically:\n- Most mentions of `TyS` are removed. It's very much a dumb struct now;\n  `Ty` has all the smarts.\n- `TyS` now has `crate` visibility instead of `pub`.\n- `TyS::make_for_test` is removed in favour of the static `BOOL_TY`,\n  which just works better with the new structure.\n- The `Eq`/`Ord`/`Hash` impls are removed from `TyS`. `Interned`s impls\n  of `Eq`/`Hash` now suffice. `Ord` is now partly on `Interned`\n  (pointer-based, for the `Equal` case) and partly on `TyS`\n  (contents-based, for the other cases).\n- There are many tedious sigil adjustments, i.e. adding or removing `*`\n  or `&`. They seem to be unavoidable.", "tree": {"sha": "0314a2f30fb7ef50142fa623abcb66ff515986d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0314a2f30fb7ef50142fa623abcb66ff515986d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9a0c429c5da5a34c0469117774fe32694a0281c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9a0c429c5da5a34c0469117774fe32694a0281c", "html_url": "https://github.com/rust-lang/rust/commit/e9a0c429c5da5a34c0469117774fe32694a0281c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9a0c429c5da5a34c0469117774fe32694a0281c/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c2ebbd412362ce3e9f1cce099f72eabf92d6217", "html_url": "https://github.com/rust-lang/rust/commit/0c2ebbd412362ce3e9f1cce099f72eabf92d6217"}], "stats": {"total": 1054, "additions": 521, "deletions": 533}, "files": [{"sha": "fce5ed0ef42390539b10fbdc8d97373ab3269061", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -2324,7 +2324,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // This is also case 2 from above but for functions, return type is still an\n                 // anonymous reference so we select the first argument.\n                 let argument_span = fn_decl.inputs.first()?.span;\n-                let argument_ty = sig.inputs().skip_binder().first()?;\n+                let argument_ty = *sig.inputs().skip_binder().first()?;\n \n                 let return_span = fn_decl.output.span();\n                 let return_ty = sig.output().skip_binder();\n@@ -2379,27 +2379,27 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> String {\n         match self {\n-            AnnotatedBorrowFnSignature::Closure { argument_ty, argument_span } => {\n+            &AnnotatedBorrowFnSignature::Closure { argument_ty, argument_span } => {\n                 diag.span_label(\n-                    *argument_span,\n+                    argument_span,\n                     format!(\"has type `{}`\", cx.get_name_for_ty(argument_ty, 0)),\n                 );\n \n                 cx.get_region_name_for_ty(argument_ty, 0)\n             }\n-            AnnotatedBorrowFnSignature::AnonymousFunction {\n+            &AnnotatedBorrowFnSignature::AnonymousFunction {\n                 argument_ty,\n                 argument_span,\n                 return_ty,\n                 return_span,\n             } => {\n                 let argument_ty_name = cx.get_name_for_ty(argument_ty, 0);\n-                diag.span_label(*argument_span, format!(\"has type `{}`\", argument_ty_name));\n+                diag.span_label(argument_span, format!(\"has type `{}`\", argument_ty_name));\n \n                 let return_ty_name = cx.get_name_for_ty(return_ty, 0);\n                 let types_equal = return_ty_name == argument_ty_name;\n                 diag.span_label(\n-                    *return_span,\n+                    return_span,\n                     format!(\n                         \"{}has type `{}`\",\n                         if types_equal { \"also \" } else { \"\" },\n@@ -2419,7 +2419,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n             }\n             AnnotatedBorrowFnSignature::NamedFunction { arguments, return_ty, return_span } => {\n                 // Region of return type and arguments checked to be the same earlier.\n-                let region_name = cx.get_region_name_for_ty(return_ty, 0);\n+                let region_name = cx.get_region_name_for_ty(*return_ty, 0);\n                 for (_, argument_span) in arguments {\n                     diag.span_label(*argument_span, format!(\"has lifetime `{}`\", region_name));\n                 }"}, {"sha": "0624156817ddca2f1250932a3a0a47f54e724ae7", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -331,18 +331,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef { local, projection: [] } => {\n                 let local = &self.body.local_decls[local];\n-                self.describe_field_from_ty(&local.ty, field, None)\n+                self.describe_field_from_ty(local.ty, field, None)\n             }\n             PlaceRef { local, projection: [proj_base @ .., elem] } => match elem {\n                 ProjectionElem::Deref => {\n                     self.describe_field(PlaceRef { local, projection: proj_base }, field)\n                 }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty = place.ty(self.body, self.infcx.tcx).ty;\n-                    self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n+                    self.describe_field_from_ty(base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n-                    self.describe_field_from_ty(&field_type, field, None)\n+                    self.describe_field_from_ty(*field_type, field, None)\n                 }\n                 ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n@@ -362,7 +362,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> String {\n         if ty.is_box() {\n             // If the type is a box, the field is described from the boxed type\n-            self.describe_field_from_ty(&ty.boxed_ty(), field, variant_index)\n+            self.describe_field_from_ty(ty.boxed_ty(), field, variant_index)\n         } else {\n             match *ty.kind() {\n                 ty::Adt(def, _) => {\n@@ -376,10 +376,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ty::Tuple(_) => field.index().to_string(),\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    self.describe_field_from_ty(&ty, field, variant_index)\n+                    self.describe_field_from_ty(ty, field, variant_index)\n                 }\n                 ty::Array(ty, _) | ty::Slice(ty) => {\n-                    self.describe_field_from_ty(&ty, field, variant_index)\n+                    self.describe_field_from_ty(ty, field, variant_index)\n                 }\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                     // We won't be borrowck'ing here if the closure came from another crate,"}, {"sha": "cc6566882ad5d800e21098dec46b597e1fb2fa8d", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -246,18 +246,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             );\n             (\n                 match kind {\n-                    IllegalMoveOriginKind::BorrowedContent { target_place } => self\n+                    &IllegalMoveOriginKind::BorrowedContent { target_place } => self\n                         .report_cannot_move_from_borrowed_content(\n                             original_path,\n-                            *target_place,\n+                            target_place,\n                             span,\n                             use_spans,\n                         ),\n-                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n+                    &IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n                         self.cannot_move_out_of_interior_of_drop(span, ty)\n                     }\n-                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => {\n-                        self.cannot_move_out_of_interior_noncopy(span, ty, Some(*is_index))\n+                    &IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } => {\n+                        self.cannot_move_out_of_interior_noncopy(span, ty, Some(is_index))\n                     }\n                 },\n                 span,"}, {"sha": "fa2b52bc6c4848c6af7d17b5898d98f318e6435b", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -500,7 +500,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     }\n \n                     // Otherwise, let's descend into the referent types.\n-                    search_stack.push((referent_ty, &referent_hir_ty.ty));\n+                    search_stack.push((*referent_ty, &referent_hir_ty.ty));\n                 }\n \n                 // Match up something like `Foo<'1>`\n@@ -539,7 +539,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n                 (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))\n                 | (ty::Array(elem_ty, _), hir::TyKind::Array(elem_hir_ty, _)) => {\n-                    search_stack.push((elem_ty, elem_hir_ty));\n+                    search_stack.push((*elem_ty, elem_hir_ty));\n                 }\n \n                 (ty::RawPtr(mut_ty), hir::TyKind::Ptr(mut_hir_ty)) => {"}, {"sha": "62b68f004ba8a55551e4496e4bc3c1b62b6a726a", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1169,7 +1169,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         match verify_bound {\n             VerifyBound::IfEq(test_ty, verify_bound1) => {\n-                self.eval_if_eq(tcx, body, generic_ty, lower_bound, test_ty, verify_bound1)\n+                self.eval_if_eq(tcx, body, generic_ty, lower_bound, *test_ty, verify_bound1)\n             }\n \n             VerifyBound::IsEmpty => {"}, {"sha": "9706bf88ab33a787196ddff35fa7c0a696362f30", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n-        *ty = self.renumber_regions(ty);\n+        *ty = self.renumber_regions(*ty);\n \n         debug!(?ty);\n     }"}, {"sha": "a9c6e043e6c64e377825bd54ff534b08c75334d3", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                 // create new region variables, which can't be done later when\n                 // verifying these bounds.\n                 if t1.has_placeholders() {\n-                    t1 = tcx.fold_regions(&t1, &mut false, |r, _| match *r {\n+                    t1 = tcx.fold_regions(t1, &mut false, |r, _| match *r {\n                         ty::RegionKind::RePlaceholder(placeholder) => {\n                             self.constraints.placeholder_region(self.infcx, placeholder)\n                         }"}, {"sha": "28fbe6227e2fcba3e3416993b0a53c17b7f11630", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -482,7 +482,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     // then remove the outermost reference so we can check the\n                     // type annotation for the remaining type.\n                     if let ty::Ref(_, rty, _) = local_decl.ty.kind() {\n-                        rty\n+                        *rty\n                     } else {\n                         bug!(\"{:?} with ref binding has wrong type {}\", local, local_decl.ty);\n                     }\n@@ -716,7 +716,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 PlaceTy::from_ty(match base_ty.kind() {\n                     ty::Array(inner, _) => {\n                         assert!(!from_end, \"array subslices should not use from_end\");\n-                        tcx.mk_array(inner, to - from)\n+                        tcx.mk_array(*inner, to - from)\n                     }\n                     ty::Slice(..) => {\n                         assert!(from_end, \"slice subslices should use from_end\");\n@@ -1737,7 +1737,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 ConstraintCategory::Boring\n             };\n             if let Err(terr) =\n-                self.sub_types(op_arg_ty, fn_arg, term_location.to_locations(), category)\n+                self.sub_types(op_arg_ty, *fn_arg, term_location.to_locations(), category)\n             {\n                 span_mirbug!(\n                     self,\n@@ -2048,7 +2048,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n \n-            Rvalue::NullaryOp(_, ty) => {\n+            &Rvalue::NullaryOp(_, ty) => {\n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n                     substs: tcx.mk_substs_trait(ty, &[]),\n@@ -2066,7 +2066,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.require_lang_item(LangItem::Sized, Some(self.last_span)),\n-                    substs: tcx.mk_substs_trait(ty, &[]),\n+                    substs: tcx.mk_substs_trait(*ty, &[]),\n                 };\n \n                 self.prove_trait_ref(\n@@ -2093,7 +2093,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n                         if let Err(terr) = self.eq_types(\n-                            ty,\n+                            *ty,\n                             ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n@@ -2117,7 +2117,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.mk_fn_ptr(tcx.signature_unclosure(sig, *unsafety));\n \n                         if let Err(terr) = self.eq_types(\n-                            ty,\n+                            *ty,\n                             ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n@@ -2146,7 +2146,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n \n                         if let Err(terr) = self.eq_types(\n-                            ty,\n+                            *ty,\n                             ty_fn_ptr_from,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n@@ -2209,8 +2209,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             }\n                         };\n                         if let Err(terr) = self.sub_types(\n-                            ty_from,\n-                            ty_to,\n+                            *ty_from,\n+                            *ty_to,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2278,8 +2278,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         }\n \n                         if let Err(terr) = self.sub_types(\n-                            ty_elem,\n-                            ty_to,\n+                            *ty_elem,\n+                            *ty_to,\n                             location.to_locations(),\n                             ConstraintCategory::Cast,\n                         ) {\n@@ -2297,7 +2297,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     CastKind::Misc => {\n                         let ty_from = op.ty(body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n-                        let cast_ty_to = CastTy::from_ty(ty);\n+                        let cast_ty_to = CastTy::from_ty(*ty);\n                         match (cast_ty_from, cast_ty_to) {\n                             (None, _)\n                             | (_, None | Some(CastTy::FnPtr))"}, {"sha": "b508bb1112e64c004ca0fe61ad1ceb0acb3e0c20", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -512,7 +512,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             first_local_index,\n             num_universals,\n             defining_ty,\n-            unnormalized_output_ty,\n+            unnormalized_output_ty: *unnormalized_output_ty,\n             unnormalized_input_tys,\n             yield_ty,\n         }"}, {"sha": "fe33a1f9b092879c0cf1de69e3f2115e08ef4b76", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -79,7 +79,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     let arg_uninhabited = fx\n         .mir\n         .args_iter()\n-        .any(|arg| fx.layout_of(fx.monomorphize(&fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n+        .any(|arg| fx.layout_of(fx.monomorphize(fx.mir.local_decls[arg].ty)).abi.is_uninhabited());\n \n     if !crate::constant::check_constants(&mut fx) {\n         fx.bcx.append_block_params_for_function_params(fx.block_map[START_BLOCK]);\n@@ -818,16 +818,16 @@ pub(crate) fn codegen_place<'tcx>(\n                 match cplace.layout().ty.kind() {\n                     ty::Array(elem_ty, _len) => {\n                         assert!(!from_end, \"array subslices are never `from_end`\");\n-                        let elem_layout = fx.layout_of(elem_ty);\n+                        let elem_layout = fx.layout_of(*elem_ty);\n                         let ptr = cplace.to_ptr();\n                         cplace = CPlace::for_ptr(\n                             ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * (from as i64)),\n-                            fx.layout_of(fx.tcx.mk_array(elem_ty, to - from)),\n+                            fx.layout_of(fx.tcx.mk_array(*elem_ty, to - from)),\n                         );\n                     }\n                     ty::Slice(elem_ty) => {\n                         assert!(from_end, \"slice subslices should be `from_end`\");\n-                        let elem_layout = fx.layout_of(elem_ty);\n+                        let elem_layout = fx.layout_of(*elem_ty);\n                         let (ptr, len) = cplace.to_ptr_maybe_unsized();\n                         let len = len.unwrap();\n                         cplace = CPlace::for_ptr_with_extra("}, {"sha": "50f98965ab5d22ac31f735a56e18385e87bd2f69", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -61,7 +61,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n         },\n         ty::FnPtr(_) => pointer_ty(tcx),\n         ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n-            if has_ptr_meta(tcx, pointee_ty) {\n+            if has_ptr_meta(tcx, *pointee_ty) {\n                 return None;\n             } else {\n                 pointer_ty(tcx)\n@@ -100,7 +100,7 @@ fn clif_pair_type_from_ty<'tcx>(\n             (a, b)\n         }\n         ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n-            if has_ptr_meta(tcx, pointee_ty) {\n+            if has_ptr_meta(tcx, *pointee_ty) {\n                 (pointer_ty(tcx), pointer_ty(tcx))\n             } else {\n                 return None;"}, {"sha": "9df6c7766c68fdaddd33a08d7f1efe1362fb1416", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -490,7 +490,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                                         return None;\n                                     }\n                                     let const_val = mir_operand_get_const_val(fx, operand)?;\n-                                    if fx.layout_of(ty).size\n+                                    if fx.layout_of(*ty).size\n                                         != const_val.try_to_scalar_int()?.size()\n                                     {\n                                         return None;"}, {"sha": "693092ba543ea947c5b448520fac7984935e697c", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> DebugContext<'tcx> {\n     }\n \n     fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n-        if let Some(type_id) = self.types.get(ty) {\n+        if let Some(type_id) = self.types.get(&ty) {\n             return *type_id;\n         }\n \n@@ -143,7 +143,7 @@ impl<'tcx> DebugContext<'tcx> {\n                 // Ensure that type is inserted before recursing to avoid duplicates\n                 self.types.insert(ty, type_id);\n \n-                let pointee = self.dwarf_ty(pointee_ty);\n+                let pointee = self.dwarf_ty(*pointee_ty);\n \n                 let type_entry = self.dwarf.unit.get_mut(type_id);\n "}, {"sha": "8cae506e0cb62362eb56b626d02814f3d69395b2", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -66,7 +66,7 @@ fn unsize_ptr<'tcx>(\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _))\n         | (&ty::Ref(_, a, _), &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            (src, unsized_info(fx, a, b, old_info))\n+            (src, unsized_info(fx, *a, *b, old_info))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_layout.ty.boxed_ty(), dst_layout.ty.boxed_ty());"}, {"sha": "b016af5174e018630eddbb3b1ef5ae9bac8398ab", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -514,7 +514,7 @@ impl<'tcx> CPlace<'tcx> {\n                     // Can only happen for vector types\n                     let len =\n                         u16::try_from(len.eval_usize(fx.tcx, ParamEnv::reveal_all())).unwrap();\n-                    let vector_ty = fx.clif_type(element).unwrap().by(len).unwrap();\n+                    let vector_ty = fx.clif_type(*element).unwrap().by(len).unwrap();\n \n                     let data = match from.0 {\n                         CValueInner::ByRef(ptr, None) => {\n@@ -721,8 +721,8 @@ impl<'tcx> CPlace<'tcx> {\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind() {\n-            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_ptr()),\n-            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_ptr_maybe_unsized().0),\n+            ty::Array(elem_ty, _) => (fx.layout_of(*elem_ty), self.to_ptr()),\n+            ty::Slice(elem_ty) => (fx.layout_of(*elem_ty), self.to_ptr_maybe_unsized().0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n@@ -781,11 +781,11 @@ pub(crate) fn assert_assignable<'tcx>(\n             ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n             ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n         ) => {\n-            assert_assignable(fx, a, b);\n+            assert_assignable(fx, *a, *b);\n         }\n         (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n         | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n-            assert_assignable(fx, a, b);\n+            assert_assignable(fx, *a, *b);\n         }\n         (ty::FnPtr(_), ty::FnPtr(_)) => {\n             let from_sig = fx.tcx.normalize_erasing_late_bound_regions("}, {"sha": "1abc3fb523d1bce25955f2790d6df5a1961f2a6d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -185,9 +185,9 @@ impl<'ll, 'tcx> TypeMap<'ll, 'tcx> {\n     ///\n     /// This function is used to remove the temporary metadata\n     /// mapping after we've computed the actual metadata.\n-    fn remove_type(&mut self, type_: Ty<'tcx>) {\n-        if self.type_to_metadata.remove(type_).is_none() {\n-            bug!(\"type metadata `Ty` '{}' is not in the `TypeMap`!\", type_);\n+    fn remove_type(&mut self, ty: Ty<'tcx>) {\n+        if self.type_to_metadata.remove(&ty).is_none() {\n+            bug!(\"type metadata `Ty` '{}' is not in the `TypeMap`!\", ty);\n         }\n     }\n \n@@ -397,7 +397,7 @@ fn fixed_size_array_metadata<'ll, 'tcx>(\n         bug!(\"fixed_size_array_metadata() called with non-ty::Array type `{:?}`\", array_type)\n     };\n \n-    let element_type_metadata = type_metadata(cx, element_type);\n+    let element_type_metadata = type_metadata(cx, *element_type);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n@@ -546,7 +546,7 @@ fn subroutine_type_metadata<'ll, 'tcx>(\n     )\n     .chain(\n         // regular arguments\n-        signature.inputs().iter().map(|argument_type| Some(type_metadata(cx, argument_type))),\n+        signature.inputs().iter().map(|&argument_type| Some(type_metadata(cx, argument_type))),\n     )\n     .collect();\n \n@@ -601,7 +601,7 @@ fn slice_type_metadata<'ll, 'tcx>(\n     unique_type_id: UniqueTypeId,\n ) -> MetadataCreationResult<'ll> {\n     let element_type = match slice_type.kind() {\n-        ty::Slice(element_type) => element_type,\n+        ty::Slice(element_type) => *element_type,\n         ty::Str => cx.tcx.types.u8,\n         _ => {\n             bug!("}, {"sha": "247cb9ee6e8c9f2e475a4c70238b9f4bdd02437a", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -430,9 +430,9 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     let t = arg.layout.ty;\n                     let t = match t.kind() {\n                         ty::Array(ct, _)\n-                            if (*ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() =>\n+                            if (*ct == cx.tcx.types.u8) || cx.layout_of(*ct).is_zst() =>\n                         {\n-                            cx.tcx.mk_imm_ptr(ct)\n+                            cx.tcx.mk_imm_ptr(*ct)\n                         }\n                         _ => t,\n                     };"}, {"sha": "cfd23f5c24e05a817234a0463d4073bdf1b041af", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1132,8 +1132,8 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n \n     fn simd_simple_float_intrinsic<'ll, 'tcx>(\n         name: Symbol,\n-        in_elem: &::rustc_middle::ty::TyS<'_>,\n-        in_ty: &::rustc_middle::ty::TyS<'_>,\n+        in_elem: Ty<'_>,\n+        in_ty: Ty<'_>,\n         in_len: u64,\n         bx: &mut Builder<'_, 'll, 'tcx>,\n         span: Span,"}, {"sha": "9d28e8db2fdb389eea0ae9db1029a075a76579db", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -343,7 +343,7 @@ fn push_debuginfo_type_name<'tcx>(\n             // We only care about avoiding recursing\n             // directly back to the type we're currently\n             // processing\n-            visited.remove(t);\n+            visited.remove(&t);\n         }\n         ty::Closure(def_id, substs) | ty::Generator(def_id, substs, ..) => {\n             // Name will be \"{closure_env#0}<T1, T2, ...>\", \"{generator_env#0}<T1, T2, ...>\", or"}, {"sha": "87377009dd50ea69e1a57439b090560610556e9d", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -194,7 +194,7 @@ pub(crate) fn deref_const<'tcx>(\n         // In case of unsized types, figure out the real type behind.\n         MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n             ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n-            ty::Slice(elem_ty) => tcx.mk_array(elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n+            ty::Slice(elem_ty) => tcx.mk_array(*elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n             _ => bug!(\n                 \"type {} should not have metadata, but had {:?}\",\n                 mplace.layout.ty,"}, {"sha": "e2c4eb1dadc83facbfe202c929681901e4ad2ced", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -315,7 +315,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match (&src.layout.ty.kind(), &cast_ty.ty.kind()) {\n             (&ty::Ref(_, s, _), &ty::Ref(_, c, _) | &ty::RawPtr(TypeAndMut { ty: c, .. }))\n             | (&ty::RawPtr(TypeAndMut { ty: s, .. }), &ty::RawPtr(TypeAndMut { ty: c, .. })) => {\n-                self.unsize_into_ptr(src, dest, s, c)\n+                self.unsize_into_ptr(src, dest, *s, *c)\n             }\n             (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n                 assert_eq!(def_a, def_b);"}, {"sha": "b1a3cc1808245e62196b5bfab4558c63be84512f", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -585,7 +585,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         match val {\n             mir::ConstantKind::Ty(ct) => self.const_to_op(ct, layout),\n-            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, ty, layout),\n+            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, *ty, layout),\n         }\n     }\n "}, {"sha": "7b06ffaf15d02f86f7917d36750cf663878805ef", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -462,7 +462,7 @@ where\n         let (meta, ty) = match base.layout.ty.kind() {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n-            ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(inner, inner_len)),\n+            ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(*inner, inner_len)),\n             ty::Slice(..) => {\n                 let len = Scalar::from_machine_usize(inner_len, self);\n                 (MemPlaceMeta::Meta(len), base.layout.ty)"}, {"sha": "4060bee7e056c1c61554069927610d644a52521e", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -553,7 +553,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 {\n                     // A mutable reference inside a const? That does not seem right (except if it is\n                     // a ZST).\n-                    let layout = self.ecx.layout_of(ty)?;\n+                    let layout = self.ecx.layout_of(*ty)?;\n                     if !layout.is_zst() {\n                         throw_validation_failure!(self.path, { \"mutable reference in a `const`\" });\n                     }\n@@ -837,7 +837,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // This is the length of the array/slice.\n                 let len = mplace.len(self.ecx)?;\n                 // This is the element type size.\n-                let layout = self.ecx.layout_of(tys)?;\n+                let layout = self.ecx.layout_of(*tys)?;\n                 // This is the size in bytes of the whole array. (This checks for overflow.)\n                 let size = layout.size * len;\n \n@@ -896,7 +896,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             // Fast path for arrays and slices of ZSTs. We only need to check a single ZST element\n             // of an array and not all of them, because there's only a single value of a specific\n             // ZST type, so either validation fails for all elements or none.\n-            ty::Array(tys, ..) | ty::Slice(tys) if self.ecx.layout_of(tys)?.is_zst() => {\n+            ty::Array(tys, ..) | ty::Slice(tys) if self.ecx.layout_of(*tys)?.is_zst() => {\n                 // Validate just the first element (if any).\n                 self.walk_aggregate(op, fields.take(1))?\n             }"}, {"sha": "8c3f8e8816464d156eddd3235cd4f119fb365f36", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -233,7 +233,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                             let mut tmp_ty = self_ty;\n                             while let rustc_middle::ty::Ref(_, inner_ty, _) = tmp_ty.kind() {\n                                 num_refs += 1;\n-                                tmp_ty = inner_ty;\n+                                tmp_ty = *inner_ty;\n                             }\n                             let deref = \"*\".repeat(num_refs);\n "}, {"sha": "f73c30c9a55728fa3cd3abaf241eda2baab9350a", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -496,7 +496,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 if matches!(kind, CastKind::Misc) {\n                     let operand_ty = operand.ty(self.body, self.tcx);\n                     let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                    let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                    let cast_out = CastTy::from_ty(*cast_ty).expect(\"bad output type for cast\");\n                     if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n                         // ptr-to-int casts are not possible in consts and thus not promotable\n                         return Err(Unpromotable);"}, {"sha": "23a1d7d9f1dbbff0a118e56fa7de810185c96b01", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -915,13 +915,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> Option<()> {\n         for (i, ta) in sub.types().enumerate() {\n             if ta == other_ty {\n-                self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n+                self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, other_ty);\n                 return Some(());\n             }\n             if let ty::Adt(def, _) = ta.kind() {\n                 let path_ = self.tcx.def_path_str(def.did);\n                 if path_ == other_path {\n-                    self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n+                    self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, other_ty);\n                     return Some(());\n                 }\n             }\n@@ -1036,7 +1036,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let len2 = sig2.inputs().len();\n         if len1 == len2 {\n             for (i, (l, r)) in iter::zip(sig1.inputs(), sig2.inputs()).enumerate() {\n-                let (x1, x2) = self.cmp(l, r);\n+                let (x1, x2) = self.cmp(*l, *r);\n                 (values.0).0.extend(x1.0);\n                 (values.1).0.extend(x2.0);\n                 self.push_comma(&mut values.0, &mut values.1, len1, i);\n@@ -1263,7 +1263,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             path1.clone(),\n                             sub_no_defaults_1,\n                             path2.clone(),\n-                            &t2,\n+                            t2,\n                         )\n                         .is_some()\n                     {\n@@ -1281,7 +1281,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             path2,\n                             sub_no_defaults_2,\n                             path1,\n-                            &t1,\n+                            t1,\n                         )\n                         .is_some()\n                     {\n@@ -1333,13 +1333,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             // When finding T != &T, highlight only the borrow\n-            (&ty::Ref(r1, ref_ty1, mutbl1), _) if equals(&ref_ty1, &t2) => {\n+            (&ty::Ref(r1, ref_ty1, mutbl1), _) if equals(ref_ty1, t2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n                 values.1.push_normal(t2.to_string());\n                 values\n             }\n-            (_, &ty::Ref(r2, ref_ty2, mutbl2)) if equals(&t1, &ref_ty2) => {\n+            (_, &ty::Ref(r2, ref_ty2, mutbl2)) if equals(t1, ref_ty2) => {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 values.0.push_normal(t1.to_string());\n                 push_ty_ref(&r2, ref_ty2, mutbl2, &mut values.1);\n@@ -1348,7 +1348,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             // When encountering &T != &mut T, highlight only the borrow\n             (&ty::Ref(r1, ref_ty1, mutbl1), &ty::Ref(r2, ref_ty2, mutbl2))\n-                if equals(&ref_ty1, &ref_ty2) =>\n+                if equals(ref_ty1, ref_ty2) =>\n             {\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 push_ty_ref(&r1, ref_ty1, mutbl1, &mut values.0);\n@@ -1923,7 +1923,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .iter()\n                 .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n                 .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n-                .find(|(_, ty)| same_type_modulo_infer(ty, exp_found.found))\n+                .find(|(_, ty)| same_type_modulo_infer(*ty, exp_found.found))\n             {\n                 if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n@@ -2116,7 +2116,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let [expected_tup_elem] = &expected.tuple_fields().collect::<Vec<_>>()[..]\n             else { return };\n \n-        if !same_type_modulo_infer(expected_tup_elem, found) {\n+        if !same_type_modulo_infer(*expected_tup_elem, found) {\n             return;\n         }\n "}, {"sha": "598ca9e9a093698a0c649fbc7e65d5d1288236ff", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -985,7 +985,7 @@ impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n                 }\n             }\n             ty::Ref(_, ty, _) => {\n-                let ty = self.fold_ty(ty);\n+                let ty = self.fold_ty(*ty);\n                 match ty.kind() {\n                     // Avoid `&_`, these can be safely presented as `_`.\n                     ty::Error(_) => self.tcx().ty_error(),\n@@ -1002,7 +1002,7 @@ impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n             | ty::Projection(_)\n             | ty::Never => t.super_fold_with(self),\n             ty::Array(ty, c) => {\n-                self.tcx().mk_ty(ty::Array(self.fold_ty(ty), self.replace_infers(c, 0, sym::N)))\n+                self.tcx().mk_ty(ty::Array(self.fold_ty(*ty), self.replace_infers(c, 0, sym::N)))\n             }\n             // We don't want to hide type params that haven't been resolved yet.\n             // This would be the type that will be written out with the type param"}, {"sha": "3b620ced1ecd94b522214b6159eabd3fd31ee605", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -42,8 +42,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     if sup_expected_found == sub_expected_found {\n                         self.emit_err(\n                             var_origin.span(),\n-                            sub_expected,\n-                            sub_found,\n+                            *sub_expected,\n+                            *sub_found,\n                             *trait_item_def_id,\n                         );\n                         return Some(ErrorReported);"}, {"sha": "6381609753aa7c009494e5dd7b39a2c7bd1ba897", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n                 // Recreate it with a fresh variable here.\n                 let idx = (vid.index - self.const_vars.0.start.index) as usize;\n                 let origin = self.const_vars.1[idx];\n-                self.infcx.next_const_var(ty, origin)\n+                self.infcx.next_const_var(*ty, origin)\n             } else {\n                 ct\n             }"}, {"sha": "d236c773f2a24ecb1bf73336e686df69eceb1b8d", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -382,7 +382,7 @@ impl<'tcx> ValuePairs<'tcx> {\n             found: ty::Term::Ty(found),\n         }) = self\n         {\n-            Some((expected, found))\n+            Some((*expected, *found))\n         } else {\n             None\n         }"}, {"sha": "8006419d1d757a2f3d7533f1738287489587a71f", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -450,7 +450,7 @@ impl<'tcx> VidValuePair<'tcx> for (ty::TyVid, Ty<'tcx>) {\n     where\n         D: TypeRelatingDelegate<'tcx>,\n     {\n-        relate.relate(&generalized_ty, &self.value_ty())\n+        relate.relate(generalized_ty, self.value_ty())\n     }\n }\n \n@@ -482,7 +482,7 @@ impl<'tcx> VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n     where\n         D: TypeRelatingDelegate<'tcx>,\n     {\n-        relate.relate(&self.value_ty(), &generalized_ty)\n+        relate.relate(self.value_ty(), generalized_ty)\n     }\n }\n "}, {"sha": "7009e892fef62a02d413b5157fd23bdf550991eb", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -2896,25 +2896,21 @@ impl ClashingExternDeclarations {\n                         (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n                             // For arrays, we also check the constness of the type.\n                             a_const.val == b_const.val\n-                                && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                                && structurally_same_type_impl(seen_types, cx, *a_ty, *b_ty, ckind)\n                         }\n                         (Slice(a_ty), Slice(b_ty)) => {\n-                            structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                            structurally_same_type_impl(seen_types, cx, *a_ty, *b_ty, ckind)\n                         }\n                         (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n                             a_tymut.mutbl == b_tymut.mutbl\n                                 && structurally_same_type_impl(\n-                                    seen_types,\n-                                    cx,\n-                                    &a_tymut.ty,\n-                                    &b_tymut.ty,\n-                                    ckind,\n+                                    seen_types, cx, a_tymut.ty, b_tymut.ty, ckind,\n                                 )\n                         }\n                         (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n                             // For structural sameness, we don't need the region to be same.\n                             a_mut == b_mut\n-                                && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                                && structurally_same_type_impl(seen_types, cx, *a_ty, *b_ty, ckind)\n                         }\n                         (FnDef(..), FnDef(..)) => {\n                             let a_poly_sig = a.fn_sig(tcx);\n@@ -2927,7 +2923,7 @@ impl ClashingExternDeclarations {\n                             (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n                                 == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n                                 && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n-                                    structurally_same_type_impl(seen_types, cx, a, b, ckind)\n+                                    structurally_same_type_impl(seen_types, cx, *a, *b, ckind)\n                                 })\n                                 && structurally_same_type_impl(\n                                     seen_types,"}, {"sha": "c47fdc063a96544d22a4f2dbac7f0dcc1d4ab517", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -7,9 +7,10 @@ use rustc_middle::ty;\n use rustc_span::symbol::sym;\n \n declare_tool_lint! {\n-    /// The `rustc_pass_by_value` lint marks a type with `#[rustc_pass_by_value]` requiring it to always be passed by value.\n-    /// This is usually used for types that are thin wrappers around references, so there is no benefit to an extra\n-    /// layer of indirection. (Example: `Ty` which is a reference to a `TyS`)\n+    /// The `rustc_pass_by_value` lint marks a type with `#[rustc_pass_by_value]` requiring it to\n+    /// always be passed by value. This is usually used for types that are thin wrappers around\n+    /// references, so there is no benefit to an extra layer of indirection. (Example: `Ty` which\n+    /// is a reference to an `Interned<TyS>`)\n     pub rustc::PASS_BY_VALUE,\n     Warn,\n     \"pass by reference of a type flagged as `#[rustc_pass_by_value]`\","}, {"sha": "fc88e8cd912ea92aed4f12f3303582f4e7e06db9", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -249,7 +249,7 @@ fn report_bin_hex_error(\n             ));\n         }\n         if let Some(sugg_ty) =\n-            get_type_suggestion(&cx.typeck_results().node_type(expr.hir_id), val, negative)\n+            get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n         {\n             if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n                 let (sans_suffix, _) = repr_str.split_at(pos);\n@@ -367,7 +367,7 @@ fn lint_int_literal<'tcx>(\n                 max,\n             ));\n             if let Some(sugg_ty) =\n-                get_type_suggestion(&cx.typeck_results().node_type(e.hir_id), v, negative)\n+                get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n             {\n                 err.help(&format!(\"consider using the type `{}` instead\", sugg_ty));\n             }\n@@ -1095,7 +1095,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     }\n                 }\n                 for arg in sig.inputs() {\n-                    let r = self.check_type_for_ffi(cache, arg);\n+                    let r = self.check_type_for_ffi(cache, *arg);\n                     match r {\n                         FfiSafe => {}\n                         _ => {\n@@ -1257,7 +1257,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         let sig = self.cx.tcx.erase_late_bound_regions(sig);\n \n         for (input_ty, input_hir) in iter::zip(sig.inputs(), decl.inputs) {\n-            self.check_type_for_ffi_and_report_errors(input_hir.span, input_ty, false, false);\n+            self.check_type_for_ffi_and_report_errors(input_hir.span, *input_ty, false, false);\n         }\n \n         if let hir::FnRetTy::Return(ref ret_hir) = decl.output {"}, {"sha": "82e8b81c38e036fdf03f00de7be034f82c46e75d", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -2558,7 +2558,7 @@ impl<'tcx> ConstantKind<'tcx> {\n     pub fn ty(&self) -> Ty<'tcx> {\n         match self {\n             ConstantKind::Ty(c) => c.ty,\n-            ConstantKind::Val(_, ty) => ty,\n+            ConstantKind::Val(_, ty) => *ty,\n         }\n     }\n "}, {"sha": "f8084bf95e7fa1382d06d6f7608dbdafe98daf22", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::mir::interpret::{\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::MirSource;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, TyCtxt, TyS, TypeFoldable, TypeVisitor};\n+use rustc_middle::ty::{self, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_target::abi::Size;\n use std::ops::ControlFlow;\n \n@@ -427,12 +427,12 @@ impl<'tcx> ExtraComments<'tcx> {\n     }\n }\n \n-fn use_verbose<'tcx>(ty: &&TyS<'tcx>, fn_def: bool) -> bool {\n-    match ty.kind() {\n+fn use_verbose<'tcx>(ty: Ty<'tcx>, fn_def: bool) -> bool {\n+    match *ty.kind() {\n         ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char | ty::Float(_) => false,\n         // Unit type\n         ty::Tuple(g_args) if g_args.is_empty() => false,\n-        ty::Tuple(g_args) => g_args.iter().any(|g_arg| use_verbose(&g_arg.expect_ty(), fn_def)),\n+        ty::Tuple(g_args) => g_args.iter().any(|g_arg| use_verbose(g_arg.expect_ty(), fn_def)),\n         ty::Array(ty, _) => use_verbose(ty, fn_def),\n         ty::FnDef(..) => fn_def,\n         _ => true,\n@@ -443,7 +443,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n         let Constant { span, user_ty, literal } = constant;\n-        if use_verbose(&literal.ty(), true) {\n+        if use_verbose(literal.ty(), true) {\n             self.push(\"mir::Constant\");\n             self.push(&format!(\n                 \"+ span: {}\",\n@@ -465,7 +465,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n         self.super_const(constant);\n         let ty::Const { ty, val, .. } = constant;\n-        if use_verbose(ty, false) {\n+        if use_verbose(*ty, false) {\n             self.push(\"ty::Const\");\n             self.push(&format!(\"+ ty: {:?}\", ty));\n             let val = match val {"}, {"sha": "302921cc4aa721fb30da49259460fe1a969e05d2", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n     pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n-        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty)\n+        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, &ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n@@ -93,11 +93,11 @@ impl<'tcx> PlaceTy<'tcx> {\n             ProjectionElem::Subslice { from, to, from_end } => {\n                 PlaceTy::from_ty(match self.ty.kind() {\n                     ty::Slice(..) => self.ty,\n-                    ty::Array(inner, _) if !from_end => tcx.mk_array(inner, (to - from) as u64),\n+                    ty::Array(inner, _) if !from_end => tcx.mk_array(*inner, (to - from) as u64),\n                     ty::Array(inner, size) if from_end => {\n                         let size = size.eval_usize(tcx, param_env);\n                         let len = size - (from as u64) - (to as u64);\n-                        tcx.mk_array(inner, len)\n+                        tcx.mk_array(*inner, len)\n                     }\n                     _ => bug!(\"cannot subslice non-array type: `{:?}`\", self),\n                 })"}, {"sha": "ae94bd121f9535bac46429ea4075e3bbf678afe2", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -430,7 +430,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n     pub fn as_switch(&self) -> Option<(&Operand<'tcx>, Ty<'tcx>, &SwitchTargets)> {\n         match self {\n             TerminatorKind::SwitchInt { discr, switch_ty, targets } => {\n-                Some((discr, switch_ty, targets))\n+                Some((discr, *switch_ty, targets))\n             }\n             _ => None,\n         }"}, {"sha": "16490ebaf77f5675dcd90cdafda157fdac27ae87", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -242,7 +242,7 @@ macro_rules! make_mir_visitor {\n             ) {\n                 let span = body.span;\n                 if let Some(gen) = &$($mutability)? body.generator {\n-                    if let Some(yield_ty) = &$($mutability)? gen.yield_ty {\n+                    if let Some(yield_ty) = $(& $mutability)? gen.yield_ty {\n                         self.visit_ty(\n                             yield_ty,\n                             TyContext::YieldTy(SourceInfo::outermost(span))\n@@ -266,7 +266,7 @@ macro_rules! make_mir_visitor {\n                 }\n \n                 self.visit_ty(\n-                    &$($mutability)? body.return_ty(),\n+                    $(& $mutability)? body.return_ty(),\n                     TyContext::ReturnTy(SourceInfo::outermost(body.span))\n                 );\n \n@@ -355,7 +355,7 @@ macro_rules! make_mir_visitor {\n                         ty::InstanceDef::DropGlue(_def_id, Some(ty)) |\n                         ty::InstanceDef::CloneShim(_def_id, ty) => {\n                             // FIXME(eddyb) use a better `TyContext` here.\n-                            self.visit_ty(ty, TyContext::Location(location));\n+                            self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                         }\n                     }\n                     self.visit_substs(callee_substs, location);\n@@ -487,7 +487,7 @@ macro_rules! make_mir_visitor {\n                         targets: _\n                     } => {\n                         self.visit_operand(discr, location);\n-                        self.visit_ty(switch_ty, TyContext::Location(location));\n+                        self.visit_ty($(& $mutability)? *switch_ty, TyContext::Location(location));\n                     }\n \n                     TerminatorKind::Drop {\n@@ -680,7 +680,7 @@ macro_rules! make_mir_visitor {\n \n                     Rvalue::Cast(_cast_kind, operand, ty) => {\n                         self.visit_operand(operand, location);\n-                        self.visit_ty(ty, TyContext::Location(location));\n+                        self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                     }\n \n                     Rvalue::BinaryOp(_bin_op, box(lhs, rhs))\n@@ -702,14 +702,14 @@ macro_rules! make_mir_visitor {\n                     }\n \n                     Rvalue::NullaryOp(_op, ty) => {\n-                        self.visit_ty(ty, TyContext::Location(location));\n+                        self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                     }\n \n                     Rvalue::Aggregate(kind, operands) => {\n                         let kind = &$($mutability)? **kind;\n                         match kind {\n                             AggregateKind::Array(ty) => {\n-                                self.visit_ty(ty, TyContext::Location(location));\n+                                self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                             }\n                             AggregateKind::Tuple => {\n                             }\n@@ -744,7 +744,7 @@ macro_rules! make_mir_visitor {\n \n                     Rvalue::ShallowInitBox(operand, ty) => {\n                         self.visit_operand(operand, location);\n-                        self.visit_ty(ty, TyContext::Location(location));\n+                        self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                     }\n                 }\n             }\n@@ -815,7 +815,7 @@ macro_rules! make_mir_visitor {\n                     is_block_tail: _,\n                 } = local_decl;\n \n-                self.visit_ty(ty, TyContext::LocalDecl {\n+                self.visit_ty($(& $mutability)? *ty, TyContext::LocalDecl {\n                     local,\n                     source_info: *source_info,\n                 });\n@@ -865,7 +865,7 @@ macro_rules! make_mir_visitor {\n                 drop(user_ty); // no visit method for this\n                 match literal {\n                     ConstantKind::Ty(ct) => self.visit_const(ct, location),\n-                    ConstantKind::Val(_, t) => self.visit_ty(t, TyContext::Location(location)),\n+                    ConstantKind::Val(_, ty) => self.visit_ty($(& $mutability)? *ty, TyContext::Location(location)),\n                 }\n             }\n \n@@ -894,7 +894,7 @@ macro_rules! make_mir_visitor {\n                 ty: & $($mutability)? CanonicalUserTypeAnnotation<'tcx>,\n             ) {\n                 self.visit_span(& $($mutability)? ty.span);\n-                self.visit_ty(& $($mutability)? ty.inferred_ty, TyContext::UserTy(ty.span));\n+                self.visit_ty($(& $mutability)? ty.inferred_ty, TyContext::UserTy(ty.span));\n             }\n \n             fn super_ty(&mut self, _ty: $(& $mutability)? Ty<'tcx>) {"}, {"sha": "feb892f0781db8c7649412c8b37c809abe8f7b7e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1146,33 +1146,33 @@ rustc_queries! {\n         desc { \"computing whether `{}` is `Copy`\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::is_sized`.\n+    /// Query backing `Ty::is_sized`.\n     query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` is `Sized`\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::is_freeze`.\n+    /// Query backing `Ty::is_freeze`.\n     query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` is freeze\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::is_unpin`.\n+    /// Query backing `Ty::is_unpin`.\n     query is_unpin_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` is `Unpin`\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::needs_drop`.\n+    /// Query backing `Ty::needs_drop`.\n     query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` needs drop\", env.value }\n         remap_env_constness\n     }\n-    /// Query backing `TyS::has_significant_drop_raw`.\n+    /// Query backing `Ty::has_significant_drop_raw`.\n     query has_significant_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n         desc { \"computing whether `{}` has a significant drop\", env.value }\n         remap_env_constness\n     }\n \n-    /// Query backing `TyS::is_structural_eq_shallow`.\n+    /// Query backing `Ty::is_structural_eq_shallow`.\n     ///\n     /// This is only correct for ADTs. Call `is_structural_eq_shallow` to handle all types\n     /// correctly."}, {"sha": "c263df2718f25cba0964214b7d44ebfbc3b80a55", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n             ) => Ok(a),\n \n             (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n-                Err(TypeError::Sorts(relate::expected_found(self, &a, &b)))\n+                Err(TypeError::Sorts(relate::expected_found(self, a, b)))\n             }\n \n             (&ty::Error(_), _) | (_, &ty::Error(_)) => Ok(self.tcx().ty_error()),"}, {"sha": "8ba6c1f67c94cc79046ec17e7005d1995081b4b5", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> ClosureKind {\n     }\n \n     /// Returns the representative scalar type for this closure kind.\n-    /// See `TyS::to_opt_closure_kind` for more details.\n+    /// See `Ty::to_opt_closure_kind` for more details.\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self {\n             ty::ClosureKind::Fn => tcx.types.i8,"}, {"sha": "e65a938d647b182eea4a30e1f52b3a9b35c6ad2c", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -26,6 +26,7 @@ use crate::ty::{\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n@@ -151,19 +152,21 @@ impl<'tcx> CtxtInterners<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n     fn intern_ty(&self, kind: TyKind<'tcx>) -> Ty<'tcx> {\n-        self.type_\n-            .intern(kind, |kind| {\n-                let flags = super::flags::FlagComputation::for_kind(&kind);\n-\n-                let ty_struct = TyS {\n-                    kind,\n-                    flags: flags.flags,\n-                    outer_exclusive_binder: flags.outer_exclusive_binder,\n-                };\n+        Ty(Interned::new_unchecked(\n+            self.type_\n+                .intern(kind, |kind| {\n+                    let flags = super::flags::FlagComputation::for_kind(&kind);\n+\n+                    let ty_struct = TyS {\n+                        kind,\n+                        flags: flags.flags,\n+                        outer_exclusive_binder: flags.outer_exclusive_binder,\n+                    };\n \n-                InternedInSet(self.arena.alloc(ty_struct))\n-            })\n-            .0\n+                    InternedInSet(self.arena.alloc(ty_struct))\n+                })\n+                .0,\n+        ))\n     }\n \n     #[inline(never)]\n@@ -1628,7 +1631,8 @@ pub trait Lift<'tcx>: fmt::Debug {\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n }\n \n-macro_rules! nop_lift {\n+// Deprecated: we are in the process of converting all uses to `nop_lift`.\n+macro_rules! nop_lift_old {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n@@ -1643,6 +1647,21 @@ macro_rules! nop_lift {\n     };\n }\n \n+macro_rules! nop_lift {\n+    ($set:ident; $ty:ty => $lifted:ty) => {\n+        impl<'a, 'tcx> Lift<'tcx> for $ty {\n+            type Lifted = $lifted;\n+            fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+                if tcx.interners.$set.contains_pointer_to(&InternedInSet(self.0.0)) {\n+                    Some(unsafe { mem::transmute(self) })\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    };\n+}\n+\n macro_rules! nop_list_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n@@ -1662,10 +1681,10 @@ macro_rules! nop_list_lift {\n }\n \n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n-nop_lift! {region; Region<'a> => Region<'tcx>}\n-nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n-nop_lift! {const_allocation; &'a Allocation => &'tcx Allocation}\n-nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n+nop_lift_old! {region; Region<'a> => Region<'tcx>}\n+nop_lift_old! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n+nop_lift_old! {const_allocation; &'a Allocation => &'tcx Allocation}\n+nop_lift_old! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate<'a>> => ty::Binder<'tcx, ExistentialPredicate<'tcx>>}\n@@ -1882,15 +1901,15 @@ macro_rules! sty_debug_print {\n                 let shards = tcx.interners.type_.lock_shards();\n                 let types = shards.iter().flat_map(|shard| shard.keys());\n                 for &InternedInSet(t) in types {\n-                    let variant = match t.kind() {\n+                    let variant = match t.kind {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n                         ty::Error(_) => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let lt = t.flags().intersects(ty::TypeFlags::HAS_RE_INFER);\n-                    let ty = t.flags().intersects(ty::TypeFlags::HAS_TY_INFER);\n-                    let ct = t.flags().intersects(ty::TypeFlags::HAS_CT_INFER);\n+                    let lt = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n+                    let ct = t.flags.intersects(ty::TypeFlags::HAS_CT_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;\n@@ -2000,15 +2019,15 @@ impl<'tcx, T: 'tcx + ?Sized> IntoPointer for InternedInSet<'tcx, T> {\n #[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> Borrow<TyKind<'tcx>> for InternedInSet<'tcx, TyS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n-        &self.0.kind()\n+        &self.0.kind\n     }\n }\n \n impl<'tcx> PartialEq for InternedInSet<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &InternedInSet<'tcx, TyS<'tcx>>) -> bool {\n         // The `Borrow` trait requires that `x.borrow() == y.borrow()` equals\n         // `x == y`.\n-        self.0.kind() == other.0.kind()\n+        self.0.kind == other.0.kind\n     }\n }\n \n@@ -2017,7 +2036,7 @@ impl<'tcx> Eq for InternedInSet<'tcx, TyS<'tcx>> {}\n impl<'tcx> Hash for InternedInSet<'tcx, TyS<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         // The `Borrow` trait requires that `x.borrow().hash(s) == x.hash(s)`.\n-        self.0.kind().hash(s)\n+        self.0.kind.hash(s)\n     }\n }\n "}, {"sha": "86efd7fb8ab4af4306d948b6f1a6bd8a6a03dab7", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1,10 +1,10 @@\n-//! Diagnostics related methods for `TyS`.\n+//! Diagnostics related methods for `Ty`.\n \n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::TyKind::*;\n use crate::ty::{\n     ConstKind, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, InferTy,\n-    ProjectionTy, Term, TyCtxt, TyS, TypeAndMut,\n+    ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n };\n \n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -13,9 +13,9 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n use rustc_span::Span;\n \n-impl<'tcx> TyS<'tcx> {\n-    /// Similar to `TyS::is_primitive`, but also considers inferred numeric values to be primitive.\n-    pub fn is_primitive_ty(&self) -> bool {\n+impl<'tcx> Ty<'tcx> {\n+    /// Similar to `Ty::is_primitive`, but also considers inferred numeric values to be primitive.\n+    pub fn is_primitive_ty(self) -> bool {\n         matches!(\n             self.kind(),\n             Bool | Char\n@@ -34,7 +34,7 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Whether the type is succinctly representable as a type instead of just referred to with a\n     /// description in error messages. This is used in the main error message.\n-    pub fn is_simple_ty(&self) -> bool {\n+    pub fn is_simple_ty(self) -> bool {\n         match self.kind() {\n             Bool\n             | Char\n@@ -58,7 +58,7 @@ impl<'tcx> TyS<'tcx> {\n     /// description in error messages. This is used in the primary span label. Beyond what\n     /// `is_simple_ty` includes, it also accepts ADTs with no type arguments and references to\n     /// ADTs with no type arguments.\n-    pub fn is_simple_text(&self) -> bool {\n+    pub fn is_simple_text(self) -> bool {\n         match self.kind() {\n             Adt(_, substs) => substs.non_erasable_generics().next().is_none(),\n             Ref(_, ty, _) => ty.is_simple_text(),\n@@ -67,7 +67,7 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     /// Whether the type can be safely suggested during error recovery.\n-    pub fn is_suggestable(&self) -> bool {\n+    pub fn is_suggestable(self) -> bool {\n         fn generic_arg_is_suggestible(arg: GenericArg<'_>) -> bool {\n             match arg.unpack() {\n                 GenericArgKind::Type(ty) => ty.is_suggestable(),"}, {"sha": "ca37c1c5bdb16adf229b1433c7f1c55711633b2a", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -239,8 +239,8 @@ impl<'tcx> TypeError<'tcx> {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n-    pub fn sort_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n+impl<'tcx> Ty<'tcx> {\n+    pub fn sort_string(self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n         match *self.kind() {\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => {\n                 format!(\"`{}`\", self).into()\n@@ -306,7 +306,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n-    pub fn prefix_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n+    pub fn prefix_string(self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n         match *self.kind() {\n             ty::Infer(_)\n             | ty::Error(_)"}, {"sha": "83cfd5f352f9d542781069479f7687245300cd0f", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -6,7 +6,7 @@ use std::slice;\n pub struct FlagComputation {\n     pub flags: TypeFlags,\n \n-    // see `TyS::outer_exclusive_binder` for details\n+    // see `Ty::outer_exclusive_binder` for details\n     pub outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n@@ -270,7 +270,7 @@ impl FlagComputation {\n \n     fn add_ty(&mut self, ty: Ty<'_>) {\n         self.add_flags(ty.flags());\n-        self.add_exclusive_binder(ty.outer_exclusive_binder);\n+        self.add_exclusive_binder(ty.outer_exclusive_binder());\n     }\n \n     fn add_tys(&mut self, tys: &[Ty<'_>]) {"}, {"sha": "c13982d69b5040eac598a2caeafca3a725c60d81", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -627,7 +627,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n                 if let Some(fld_t) = self.fld_t.as_mut() {\n                     let ty = fld_t(bound_ty);\n-                    return ty::fold::shift_vars(self.tcx, &ty, self.current_index.as_u32());\n+                    return ty::fold::shift_vars(self.tcx, ty, self.current_index.as_u32());\n                 }\n             }\n             _ if t.has_vars_bound_at_or_above(self.current_index) => {\n@@ -926,7 +926,7 @@ impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if t.outer_exclusive_binder < self.binder_index\n+        if t.outer_exclusive_binder() < self.binder_index\n             || !self.visited.insert((self.binder_index, t))\n         {\n             return ControlFlow::BREAK;\n@@ -1146,7 +1146,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         // bound at `outer_index` or above (because\n         // `outer_exclusive_binder` is always 1 higher than the\n         // content in `t`). Therefore, `t` has some escaping vars.\n-        if t.outer_exclusive_binder > self.outer_index {\n+        if t.outer_exclusive_binder() > self.outer_index {\n             ControlFlow::Break(FoundEscapingVars)\n         } else {\n             ControlFlow::CONTINUE"}, {"sha": "f2682b8bcd838178a28f0f87510b950c5394b839", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -3,7 +3,7 @@ pub use self::def_id_forest::DefIdForest;\n use crate::ty;\n use crate::ty::context::TyCtxt;\n use crate::ty::TyKind::*;\n-use crate::ty::{AdtDef, FieldDef, Ty, TyS, VariantDef};\n+use crate::ty::{AdtDef, FieldDef, Ty, VariantDef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::{DefId, SubstsRef};\n \n@@ -184,10 +184,10 @@ impl<'tcx> FieldDef {\n     }\n }\n \n-impl<'tcx> TyS<'tcx> {\n+impl<'tcx> Ty<'tcx> {\n     /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n     fn uninhabited_from(\n-        &'tcx self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest<'tcx> {"}, {"sha": "99c595fcdf18507072f3c5b530ce3357903a8f96", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -101,7 +101,7 @@ impl<'tcx> Instance<'tcx> {\n     /// lifetimes erased, allowing a `ParamEnv` to be specified for use during normalization.\n     pub fn ty(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> Ty<'tcx> {\n         let ty = tcx.type_of(self.def.def_id());\n-        tcx.subst_and_normalize_erasing_regions(self.substs, param_env, &ty)\n+        tcx.subst_and_normalize_erasing_regions(self.substs, param_env, ty)\n     }\n \n     /// Finds a crate that contains a monomorphization of this instance that\n@@ -642,7 +642,7 @@ fn polymorphize<'tcx>(\n \n         fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n             debug!(\"fold_ty: ty={:?}\", ty);\n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::Closure(def_id, substs) => {\n                     let polymorphized_substs = polymorphize(\n                         self.tcx,"}, {"sha": "812c5018459b6b5da691db8eb7d36e616b5dc610", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 57, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -29,6 +29,7 @@ use crate::ty::util::Discr;\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n@@ -42,7 +43,6 @@ use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{sym, Span};\n use rustc_target::abi::Align;\n \n-use std::cmp::Ordering;\n use std::hash::{Hash, Hasher};\n use std::ops::ControlFlow;\n use std::{fmt, ptr, str};\n@@ -380,21 +380,25 @@ pub struct CReaderCacheKey {\n \n /// Represents a type.\n ///\n-/// IMPORTANT: Every `TyS` is *required* to have unique contents. The type's\n-/// correctness relies on this, *but it does not enforce it*. Therefore, any\n-/// code that creates a `TyS` must ensure uniqueness itself. In practice this\n-/// is achieved by interning.\n+/// IMPORTANT:\n+/// - This is a very \"dumb\" struct (with no derives and no `impls`).\n+/// - Values of this type are always interned and thus unique, and are stored\n+///   as an `Interned<TyS>`.\n+/// - `Ty` (which contains a reference to a `Interned<TyS>`) or `Interned<TyS>`\n+///   should be used everywhere instead of `TyS`. In particular, `Ty` has most\n+///   of the relevant methods.\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n #[allow(rustc::usage_of_ty_tykind)]\n-pub struct TyS<'tcx> {\n+crate struct TyS<'tcx> {\n     /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `TyS::kind()` instead.\n+    /// Use `Ty::kind()` instead.\n     kind: TyKind<'tcx>,\n \n     /// This field provides fast access to information that is also contained\n     /// in `kind`.\n     ///\n     /// This field shouldn't be used directly and may be removed in the future.\n-    /// Use `TyS::flags()` instead.\n+    /// Use `Ty::flags()` instead.\n     flags: TypeFlags,\n \n     /// This field provides fast access to information that is also contained\n@@ -420,72 +424,40 @@ pub struct TyS<'tcx> {\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n-impl<'tcx> TyS<'tcx> {\n-    /// A constructor used only for internal testing.\n-    #[allow(rustc::usage_of_ty_tykind)]\n-    pub fn make_for_test(\n-        kind: TyKind<'tcx>,\n-        flags: TypeFlags,\n-        outer_exclusive_binder: ty::DebruijnIndex,\n-    ) -> TyS<'tcx> {\n-        TyS { kind, flags, outer_exclusive_binder }\n-    }\n-}\n-\n // `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(TyS<'_>, 40);\n \n-impl<'tcx> Ord for TyS<'tcx> {\n-    fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n-        self.kind().cmp(other.kind())\n-    }\n-}\n-\n-impl<'tcx> PartialOrd for TyS<'tcx> {\n-    fn partial_cmp(&self, other: &TyS<'tcx>) -> Option<Ordering> {\n-        Some(self.kind().cmp(other.kind()))\n-    }\n-}\n-\n-impl<'tcx> PartialEq for TyS<'tcx> {\n-    #[inline]\n-    fn eq(&self, other: &TyS<'tcx>) -> bool {\n-        // Pointer equality implies equality (due to the unique contents\n-        // assumption).\n-        ptr::eq(self, other)\n-    }\n-}\n-impl<'tcx> Eq for TyS<'tcx> {}\n-\n-impl<'tcx> Hash for TyS<'tcx> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        // Pointer hashing is sufficient (due to the unique contents\n-        // assumption).\n-        (self as *const TyS<'_>).hash(s)\n-    }\n-}\n+/// Use this rather than `TyS`, whenever possible.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[rustc_diagnostic_item = \"Ty\"]\n+#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n+pub struct Ty<'tcx>(Interned<'tcx, TyS<'tcx>>);\n+\n+// Statics only used for internal testing.\n+pub static BOOL_TY: Ty<'static> = Ty(Interned::new_unchecked(&BOOL_TYS));\n+static BOOL_TYS: TyS<'static> = TyS {\n+    kind: ty::Bool,\n+    flags: TypeFlags::empty(),\n+    outer_exclusive_binder: DebruijnIndex::from_usize(0),\n+};\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Ty<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let ty::TyS {\n+        let TyS {\n             ref kind,\n \n             // The other fields just provide fast access to information that is\n             // also contained in `kind`, so no need to hash them.\n             flags: _,\n \n             outer_exclusive_binder: _,\n-        } = *self;\n+        } = self.0.0;\n \n         kind.hash_stable(hcx, hasher);\n     }\n }\n \n-#[rustc_diagnostic_item = \"Ty\"]\n-#[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n-pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n-\n impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`).\n@@ -864,7 +836,7 @@ impl<'tcx> From<&'tcx Const<'tcx>> for Term<'tcx> {\n \n impl<'tcx> Term<'tcx> {\n     pub fn ty(&self) -> Option<Ty<'tcx>> {\n-        if let Term::Ty(ty) = self { Some(ty) } else { None }\n+        if let Term::Ty(ty) = self { Some(*ty) } else { None }\n     }\n     pub fn ct(&self) -> Option<&'tcx Const<'tcx>> {\n         if let Term::Const(c) = self { Some(c) } else { None }"}, {"sha": "4815dc61771362fdf0bf6e86df1e2849d04ee614", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -346,7 +346,7 @@ impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n     type Output = P::Type;\n     type Error = P::Error;\n     fn print(&self, cx: P) -> Result<Self::Output, Self::Error> {\n-        cx.print_type(self)\n+        cx.print_type(*self)\n     }\n }\n "}, {"sha": "ec7ecdfa5050ad58710dd1b627b926d04ee21535", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -3,6 +3,7 @@ use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Term, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n@@ -1232,16 +1233,20 @@ pub trait PrettyPrinter<'tcx>:\n             // Byte strings (&[u8; N])\n             ty::Ref(\n                 _,\n-                ty::TyS {\n-                    kind:\n-                        ty::Array(\n-                            ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. },\n-                            ty::Const {\n-                                val: ty::ConstKind::Value(ConstValue::Scalar(int)), ..\n-                            },\n-                        ),\n-                    ..\n-                },\n+                Ty(Interned(\n+                    ty::TyS {\n+                        kind:\n+                            ty::Array(\n+                                Ty(Interned(ty::TyS { kind: ty::Uint(ty::UintTy::U8), .. }, _)),\n+                                ty::Const {\n+                                    val: ty::ConstKind::Value(ConstValue::Scalar(int)),\n+                                    ..\n+                                },\n+                            ),\n+                        ..\n+                    },\n+                    _,\n+                )),\n                 _,\n             ) => match self.tcx().get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Memory(alloc)) => {\n@@ -1399,7 +1404,7 @@ pub trait PrettyPrinter<'tcx>:\n             // Byte/string slices, printed as (byte) string literals.\n             (\n                 ConstValue::Slice { data, start, end },\n-                ty::Ref(_, ty::TyS { kind: ty::Slice(t), .. }, _),\n+                ty::Ref(_, Ty(Interned(ty::TyS { kind: ty::Slice(t), .. }, _)), _),\n             ) if *t == u8_type => {\n                 // The `inspect` here is okay since we checked the bounds, and there are\n                 // no relocations (we have an active slice reference here). We don't use\n@@ -1409,7 +1414,7 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             (\n                 ConstValue::Slice { data, start, end },\n-                ty::Ref(_, ty::TyS { kind: ty::Str, .. }, _),\n+                ty::Ref(_, Ty(Interned(ty::TyS { kind: ty::Str, .. }, _)), _),\n             ) => {\n                 // The `inspect` here is okay since we checked the bounds, and there are no\n                 // relocations (we have an active `str` reference here). We don't use this"}, {"sha": "721026b8e37488ca91800b4d5dcad1d66a592782", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -149,8 +149,8 @@ pub fn relate_substs<'tcx, R: TypeRelation<'tcx>>(\n             Some((ty_def_id, variances)) => {\n                 let variance = variances[i];\n                 let variance_info = if variance == ty::Invariant {\n-                    let ty =\n-                        cached_ty.get_or_insert_with(|| tcx.type_of(ty_def_id).subst(tcx, a_subst));\n+                    let ty = *cached_ty\n+                        .get_or_insert_with(|| tcx.type_of(ty_def_id).subst(tcx, a_subst));\n                     ty::VarianceDiagInfo::Invariant { ty, param_index: i.try_into().unwrap() }\n                 } else {\n                     ty::VarianceDiagInfo::default()"}, {"sha": "ddd102695bdd8b55949a087a0c6090efefa274b3", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1078,7 +1078,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        visitor.visit_ty(self)\n+        visitor.visit_ty(*self)\n     }\n }\n "}, {"sha": "b37a4489d2db233e6767412025386c8519a005d7", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -9,7 +9,7 @@ use crate::ty::fold::ValidateBoundVars;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::InferTy::{self, *};\n use crate::ty::{self, AdtDef, DefIdTree, Discr, Term, Ty, TyCtxt, TypeFlags, TypeFoldable};\n-use crate::ty::{DelaySpanBugEmitted, List, ParamEnv, TyS};\n+use crate::ty::{DelaySpanBugEmitted, List, ParamEnv};\n use polonius_engine::Atom;\n use rustc_data_structures::captures::Captures;\n use rustc_hir as hir;\n@@ -196,7 +196,7 @@ pub enum TyKind<'tcx> {\n     Never,\n \n     /// A tuple type. For example, `(i32, bool)`.\n-    /// Use `TyS::tuple_fields` to iterate over the field types.\n+    /// Use `Ty::tuple_fields` to iterate over the field types.\n     Tuple(SubstsRef<'tcx>),\n \n     /// The projection of an associated type. For example,\n@@ -282,7 +282,7 @@ static_assert_size!(TyKind<'_>, 32);\n ///   in scope on the function that defined the closure,\n /// - CK represents the *closure kind* (Fn vs FnMut vs FnOnce). This\n ///   is rather hackily encoded via a scalar type. See\n-///   `TyS::to_opt_closure_kind` for details.\n+///   `Ty::to_opt_closure_kind` for details.\n /// - CS represents the *closure signature*, representing as a `fn()`\n ///   type. For example, `fn(u32, u32) -> u32` would mean that the closure\n ///   implements `CK<(u32, u32), Output = u32>`, where `CK` is the trait\n@@ -1756,117 +1756,117 @@ impl RegionKind {\n }\n \n /// Type utilities\n-impl<'tcx> TyS<'tcx> {\n+impl<'tcx> Ty<'tcx> {\n     #[inline(always)]\n-    pub fn kind(&self) -> &TyKind<'tcx> {\n-        &self.kind\n+    pub fn kind(self) -> &'tcx TyKind<'tcx> {\n+        &self.0.0.kind\n     }\n \n     #[inline(always)]\n-    pub fn flags(&self) -> TypeFlags {\n-        self.flags\n+    pub fn flags(self) -> TypeFlags {\n+        self.0.0.flags\n     }\n \n     #[inline]\n-    pub fn is_unit(&self) -> bool {\n+    pub fn is_unit(self) -> bool {\n         match self.kind() {\n             Tuple(ref tys) => tys.is_empty(),\n             _ => false,\n         }\n     }\n \n     #[inline]\n-    pub fn is_never(&self) -> bool {\n+    pub fn is_never(self) -> bool {\n         matches!(self.kind(), Never)\n     }\n \n     #[inline]\n-    pub fn is_primitive(&self) -> bool {\n+    pub fn is_primitive(self) -> bool {\n         self.kind().is_primitive()\n     }\n \n     #[inline]\n-    pub fn is_adt(&self) -> bool {\n+    pub fn is_adt(self) -> bool {\n         matches!(self.kind(), Adt(..))\n     }\n \n     #[inline]\n-    pub fn is_ref(&self) -> bool {\n+    pub fn is_ref(self) -> bool {\n         matches!(self.kind(), Ref(..))\n     }\n \n     #[inline]\n-    pub fn is_ty_var(&self) -> bool {\n+    pub fn is_ty_var(self) -> bool {\n         matches!(self.kind(), Infer(TyVar(_)))\n     }\n \n     #[inline]\n-    pub fn ty_vid(&self) -> Option<ty::TyVid> {\n+    pub fn ty_vid(self) -> Option<ty::TyVid> {\n         match self.kind() {\n             &Infer(TyVar(vid)) => Some(vid),\n             _ => None,\n         }\n     }\n \n     #[inline]\n-    pub fn is_ty_infer(&self) -> bool {\n+    pub fn is_ty_infer(self) -> bool {\n         matches!(self.kind(), Infer(_))\n     }\n \n     #[inline]\n-    pub fn is_phantom_data(&self) -> bool {\n+    pub fn is_phantom_data(self) -> bool {\n         if let Adt(def, _) = self.kind() { def.is_phantom_data() } else { false }\n     }\n \n     #[inline]\n-    pub fn is_bool(&self) -> bool {\n+    pub fn is_bool(self) -> bool {\n         *self.kind() == Bool\n     }\n \n     /// Returns `true` if this type is a `str`.\n     #[inline]\n-    pub fn is_str(&self) -> bool {\n+    pub fn is_str(self) -> bool {\n         *self.kind() == Str\n     }\n \n     #[inline]\n-    pub fn is_param(&self, index: u32) -> bool {\n+    pub fn is_param(self, index: u32) -> bool {\n         match self.kind() {\n             ty::Param(ref data) => data.index == index,\n             _ => false,\n         }\n     }\n \n     #[inline]\n-    pub fn is_slice(&self) -> bool {\n+    pub fn is_slice(self) -> bool {\n         match self.kind() {\n             RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => matches!(ty.kind(), Slice(_) | Str),\n             _ => false,\n         }\n     }\n \n     #[inline]\n-    pub fn is_array(&self) -> bool {\n+    pub fn is_array(self) -> bool {\n         matches!(self.kind(), Array(..))\n     }\n \n     #[inline]\n-    pub fn is_simd(&self) -> bool {\n+    pub fn is_simd(self) -> bool {\n         match self.kind() {\n             Adt(def, _) => def.repr.simd(),\n             _ => false,\n         }\n     }\n \n-    pub fn sequence_element_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.kind() {\n-            Array(ty, _) | Slice(ty) => ty,\n+            Array(ty, _) | Slice(ty) => *ty,\n             Str => tcx.types.u8,\n             _ => bug!(\"`sequence_element_type` called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n+    pub fn simd_size_and_type(self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {\n                 assert!(def.repr.simd(), \"`simd_size_and_type` called on non-SIMD type\");\n@@ -1881,7 +1881,7 @@ impl<'tcx> TyS<'tcx> {\n                         // The way we evaluate the `N` in `[T; N]` here only works since we use\n                         // `simd_size_and_type` post-monomorphization. It will probably start to ICE\n                         // if we use it in generic code. See the `simd-array-trait` ui test.\n-                        (f0_len.eval_usize(tcx, ParamEnv::empty()) as u64, f0_elem_ty)\n+                        (f0_len.eval_usize(tcx, ParamEnv::empty()) as u64, *f0_elem_ty)\n                     }\n                     // Otherwise, the fields of this Adt are the SIMD components (and we assume they\n                     // all have the same type).\n@@ -1893,12 +1893,12 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_region_ptr(&self) -> bool {\n+    pub fn is_region_ptr(self) -> bool {\n         matches!(self.kind(), Ref(..))\n     }\n \n     #[inline]\n-    pub fn is_mutable_ptr(&self) -> bool {\n+    pub fn is_mutable_ptr(self) -> bool {\n         matches!(\n             self.kind(),\n             RawPtr(TypeAndMut { mutbl: hir::Mutability::Mut, .. })\n@@ -1908,34 +1908,34 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Get the mutability of the reference or `None` when not a reference\n     #[inline]\n-    pub fn ref_mutability(&self) -> Option<hir::Mutability> {\n+    pub fn ref_mutability(self) -> Option<hir::Mutability> {\n         match self.kind() {\n             Ref(_, _, mutability) => Some(*mutability),\n             _ => None,\n         }\n     }\n \n     #[inline]\n-    pub fn is_unsafe_ptr(&self) -> bool {\n+    pub fn is_unsafe_ptr(self) -> bool {\n         matches!(self.kind(), RawPtr(_))\n     }\n \n     /// Tests if this is any kind of primitive pointer type (reference, raw pointer, fn pointer).\n     #[inline]\n-    pub fn is_any_ptr(&self) -> bool {\n+    pub fn is_any_ptr(self) -> bool {\n         self.is_region_ptr() || self.is_unsafe_ptr() || self.is_fn_ptr()\n     }\n \n     #[inline]\n-    pub fn is_box(&self) -> bool {\n+    pub fn is_box(self) -> bool {\n         match self.kind() {\n             Adt(def, _) => def.is_box(),\n             _ => false,\n         }\n     }\n \n     /// Panics if called on any type other than `Box<T>`.\n-    pub fn boxed_ty(&self) -> Ty<'tcx> {\n+    pub fn boxed_ty(self) -> Ty<'tcx> {\n         match self.kind() {\n             Adt(def, substs) if def.is_box() => substs.type_at(0),\n             _ => bug!(\"`boxed_ty` is called on non-box type {:?}\", self),\n@@ -1946,7 +1946,7 @@ impl<'tcx> TyS<'tcx> {\n     /// (A RawPtr is scalar because it represents a non-managed pointer, so its\n     /// contents are abstract to rustc.)\n     #[inline]\n-    pub fn is_scalar(&self) -> bool {\n+    pub fn is_scalar(self) -> bool {\n         matches!(\n             self.kind(),\n             Bool | Char\n@@ -1962,99 +1962,99 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Returns `true` if this type is a floating point type.\n     #[inline]\n-    pub fn is_floating_point(&self) -> bool {\n+    pub fn is_floating_point(self) -> bool {\n         matches!(self.kind(), Float(_) | Infer(FloatVar(_)))\n     }\n \n     #[inline]\n-    pub fn is_trait(&self) -> bool {\n+    pub fn is_trait(self) -> bool {\n         matches!(self.kind(), Dynamic(..))\n     }\n \n     #[inline]\n-    pub fn is_enum(&self) -> bool {\n+    pub fn is_enum(self) -> bool {\n         matches!(self.kind(), Adt(adt_def, _) if adt_def.is_enum())\n     }\n \n     #[inline]\n-    pub fn is_union(&self) -> bool {\n+    pub fn is_union(self) -> bool {\n         matches!(self.kind(), Adt(adt_def, _) if adt_def.is_union())\n     }\n \n     #[inline]\n-    pub fn is_closure(&self) -> bool {\n+    pub fn is_closure(self) -> bool {\n         matches!(self.kind(), Closure(..))\n     }\n \n     #[inline]\n-    pub fn is_generator(&self) -> bool {\n+    pub fn is_generator(self) -> bool {\n         matches!(self.kind(), Generator(..))\n     }\n \n     #[inline]\n-    pub fn is_integral(&self) -> bool {\n+    pub fn is_integral(self) -> bool {\n         matches!(self.kind(), Infer(IntVar(_)) | Int(_) | Uint(_))\n     }\n \n     #[inline]\n-    pub fn is_fresh_ty(&self) -> bool {\n+    pub fn is_fresh_ty(self) -> bool {\n         matches!(self.kind(), Infer(FreshTy(_)))\n     }\n \n     #[inline]\n-    pub fn is_fresh(&self) -> bool {\n+    pub fn is_fresh(self) -> bool {\n         matches!(self.kind(), Infer(FreshTy(_) | FreshIntTy(_) | FreshFloatTy(_)))\n     }\n \n     #[inline]\n-    pub fn is_char(&self) -> bool {\n+    pub fn is_char(self) -> bool {\n         matches!(self.kind(), Char)\n     }\n \n     #[inline]\n-    pub fn is_numeric(&self) -> bool {\n+    pub fn is_numeric(self) -> bool {\n         self.is_integral() || self.is_floating_point()\n     }\n \n     #[inline]\n-    pub fn is_signed(&self) -> bool {\n+    pub fn is_signed(self) -> bool {\n         matches!(self.kind(), Int(_))\n     }\n \n     #[inline]\n-    pub fn is_ptr_sized_integral(&self) -> bool {\n+    pub fn is_ptr_sized_integral(self) -> bool {\n         matches!(self.kind(), Int(ty::IntTy::Isize) | Uint(ty::UintTy::Usize))\n     }\n \n     #[inline]\n-    pub fn has_concrete_skeleton(&self) -> bool {\n+    pub fn has_concrete_skeleton(self) -> bool {\n         !matches!(self.kind(), Param(_) | Infer(_) | Error(_))\n     }\n \n     /// Returns the type and mutability of `*ty`.\n     ///\n     /// The parameter `explicit` indicates if this is an *explicit* dereference.\n     /// Some types -- notably unsafe ptrs -- can only be dereferenced explicitly.\n-    pub fn builtin_deref(&self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n+    pub fn builtin_deref(self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n         match self.kind() {\n             Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut { ty: self.boxed_ty(), mutbl: hir::Mutability::Not })\n             }\n-            Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl: *mutbl }),\n+            Ref(_, ty, mutbl) => Some(TypeAndMut { ty: *ty, mutbl: *mutbl }),\n             RawPtr(mt) if explicit => Some(*mt),\n             _ => None,\n         }\n     }\n \n     /// Returns the type of `ty[i]`.\n-    pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n+    pub fn builtin_index(self) -> Option<Ty<'tcx>> {\n         match self.kind() {\n-            Array(ty, _) | Slice(ty) => Some(ty),\n+            Array(ty, _) | Slice(ty) => Some(*ty),\n             _ => None,\n         }\n     }\n \n-    pub fn fn_sig(&self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n+    pub fn fn_sig(self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n         match self.kind() {\n             FnDef(def_id, substs) => tcx.fn_sig(*def_id).subst(tcx, substs),\n             FnPtr(f) => *f,\n@@ -2070,22 +2070,22 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_fn(&self) -> bool {\n+    pub fn is_fn(self) -> bool {\n         matches!(self.kind(), FnDef(..) | FnPtr(_))\n     }\n \n     #[inline]\n-    pub fn is_fn_ptr(&self) -> bool {\n+    pub fn is_fn_ptr(self) -> bool {\n         matches!(self.kind(), FnPtr(_))\n     }\n \n     #[inline]\n-    pub fn is_impl_trait(&self) -> bool {\n+    pub fn is_impl_trait(self) -> bool {\n         matches!(self.kind(), Opaque(..))\n     }\n \n     #[inline]\n-    pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n+    pub fn ty_adt_def(self) -> Option<&'tcx AdtDef> {\n         match self.kind() {\n             Adt(adt, _) => Some(adt),\n             _ => None,\n@@ -2094,7 +2094,7 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Iterates over tuple fields.\n     /// Panics when called on anything but a tuple.\n-    pub fn tuple_fields(&self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> {\n+    pub fn tuple_fields(self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> {\n         match self.kind() {\n             Tuple(substs) => substs.iter().map(|field| field.expect_ty()),\n             _ => bug!(\"tuple_fields called on non-tuple\"),\n@@ -2103,7 +2103,7 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Get the `i`-th element of a tuple.\n     /// Panics when called on anything but a tuple.\n-    pub fn tuple_element_ty(&self, i: usize) -> Option<Ty<'tcx>> {\n+    pub fn tuple_element_ty(self, i: usize) -> Option<Ty<'tcx>> {\n         match self.kind() {\n             Tuple(substs) => substs.iter().nth(i).map(|field| field.expect_ty()),\n             _ => bug!(\"tuple_fields called on non-tuple\"),\n@@ -2114,7 +2114,7 @@ impl<'tcx> TyS<'tcx> {\n     //\n     // FIXME: This requires the optimized MIR in the case of generators.\n     #[inline]\n-    pub fn variant_range(&self, tcx: TyCtxt<'tcx>) -> Option<Range<VariantIdx>> {\n+    pub fn variant_range(self, tcx: TyCtxt<'tcx>) -> Option<Range<VariantIdx>> {\n         match self.kind() {\n             TyKind::Adt(adt, _) => Some(adt.variant_range()),\n             TyKind::Generator(def_id, substs, _) => {\n@@ -2130,7 +2130,7 @@ impl<'tcx> TyS<'tcx> {\n     // FIXME: This requires the optimized MIR in the case of generators.\n     #[inline]\n     pub fn discriminant_for_variant(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n@@ -2151,7 +2151,7 @@ impl<'tcx> TyS<'tcx> {\n     }\n \n     /// Returns the type of the discriminant of this type.\n-    pub fn discriminant_ty(&'tcx self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn discriminant_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.kind() {\n             ty::Adt(adt, _) if adt.is_enum() => adt.repr.discr_type().to_ty(tcx),\n             ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n@@ -2195,7 +2195,7 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Returns the type of metadata for (potentially fat) pointers to this type.\n     pub fn ptr_metadata_ty(\n-        &'tcx self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n         normalize: impl FnMut(Ty<'tcx>) -> Ty<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -2256,7 +2256,7 @@ impl<'tcx> TyS<'tcx> {\n     /// to represent the closure kind, because it has not yet been\n     /// inferred. Once upvar inference (in `rustc_typeck/src/check/upvar.rs`)\n     /// is complete, that type variable will be unified.\n-    pub fn to_opt_closure_kind(&self) -> Option<ty::ClosureKind> {\n+    pub fn to_opt_closure_kind(self) -> Option<ty::ClosureKind> {\n         match self.kind() {\n             Int(int_ty) => match int_ty {\n                 ty::IntTy::I8 => Some(ty::ClosureKind::Fn),\n@@ -2285,7 +2285,7 @@ impl<'tcx> TyS<'tcx> {\n     /// bound such as `[_]: Copy`. A function with such a bound obviously never\n     /// can be called, but that doesn't mean it shouldn't typecheck. This is why\n     /// this method doesn't return `Option<bool>`.\n-    pub fn is_trivially_sized(&self, tcx: TyCtxt<'tcx>) -> bool {\n+    pub fn is_trivially_sized(self, tcx: TyCtxt<'tcx>) -> bool {\n         match self.kind() {\n             ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Uint(_)"}, {"sha": "a696d45dc14d4c74b8823914126eef1b1ae6f956", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -6,6 +6,7 @@ use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeVisitor}\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n+use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_serialize::{self, Decodable, Encodable};\n@@ -49,17 +50,17 @@ impl<'tcx> GenericArgKind<'tcx> {\n             GenericArgKind::Lifetime(lt) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(lt) & TAG_MASK, 0);\n-                (REGION_TAG, lt as *const _ as usize)\n+                (REGION_TAG, lt as *const ty::RegionKind as usize)\n             }\n             GenericArgKind::Type(ty) => {\n                 // Ensure we can use the tag bits.\n-                assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n-                (TYPE_TAG, ty as *const _ as usize)\n+                assert_eq!(mem::align_of_val(ty.0.0) & TAG_MASK, 0);\n+                (TYPE_TAG, ty.0.0 as *const ty::TyS<'tcx> as usize)\n             }\n             GenericArgKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(ct) & TAG_MASK, 0);\n-                (CONST_TAG, ct as *const _ as usize)\n+                (CONST_TAG, ct as *const ty::Const<'tcx> as usize)\n             }\n         };\n \n@@ -111,11 +112,18 @@ impl<'tcx> GenericArg<'tcx> {\n     #[inline]\n     pub fn unpack(self) -> GenericArgKind<'tcx> {\n         let ptr = self.ptr.get();\n+        // SAFETY: use of `Interned::new_unchecked` here is ok because these\n+        // pointers were originally created from `Interned` types in `pack()`,\n+        // and this is just going in the other direction.\n         unsafe {\n             match ptr & TAG_MASK {\n-                REGION_TAG => GenericArgKind::Lifetime(&*((ptr & !TAG_MASK) as *const _)),\n-                TYPE_TAG => GenericArgKind::Type(&*((ptr & !TAG_MASK) as *const _)),\n-                CONST_TAG => GenericArgKind::Const(&*((ptr & !TAG_MASK) as *const _)),\n+                REGION_TAG => {\n+                    GenericArgKind::Lifetime(&*((ptr & !TAG_MASK) as *const ty::RegionKind))\n+                }\n+                TYPE_TAG => GenericArgKind::Type(Ty(Interned::new_unchecked(\n+                    &*((ptr & !TAG_MASK) as *const ty::TyS<'tcx>),\n+                ))),\n+                CONST_TAG => GenericArgKind::Const(&*((ptr & !TAG_MASK) as *const ty::Const<'tcx>)),\n                 _ => intrinsics::unreachable(),\n             }\n         }"}, {"sha": "7f8a4020859f930f9824c778d458d2f5d0f347f5", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -11,6 +11,7 @@ use rustc_apfloat::Float as _;\n use rustc_ast as ast;\n use rustc_attr::{self as attr, SignedInt, UnsignedInt};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -392,9 +393,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                     GenericArgKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {\n                         !impl_generics.region_param(ebr, self).pure_wrt_drop\n                     }\n-                    GenericArgKind::Type(&ty::TyS { kind: ty::Param(ref pt), .. }) => {\n-                        !impl_generics.type_param(pt, self).pure_wrt_drop\n-                    }\n+                    GenericArgKind::Type(Ty(Interned(\n+                        ty::TyS { kind: ty::Param(ref pt), .. },\n+                        _,\n+                    ))) => !impl_generics.type_param(pt, self).pure_wrt_drop,\n                     GenericArgKind::Const(&ty::Const {\n                         val: ty::ConstKind::Param(ref pc), ..\n                     }) => !impl_generics.const_param(pc, self).pure_wrt_drop,\n@@ -577,7 +579,7 @@ impl<'tcx> OpaqueTypeExpander<'tcx> {\n         let substs = substs.fold_with(self);\n         if !self.check_recursion || self.seen_opaque_tys.insert(def_id) {\n             let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n-                Some(expanded_ty) => expanded_ty,\n+                Some(expanded_ty) => *expanded_ty,\n                 None => {\n                     let generic_ty = self.tcx.type_of(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx, substs);\n@@ -606,7 +608,7 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if let ty::Opaque(def_id, substs) = t.kind {\n+        if let ty::Opaque(def_id, substs) = *t.kind() {\n             self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n         } else if t.has_opaque_types() {\n             t.super_fold_with(self)\n@@ -616,10 +618,10 @@ impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n+impl<'tcx> Ty<'tcx> {\n     /// Returns the maximum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n-    pub fn numeric_max_val(&'tcx self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n+    pub fn numeric_max_val(self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n@@ -639,7 +641,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n     /// Returns the minimum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n-    pub fn numeric_min_val(&'tcx self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n+    pub fn numeric_min_val(self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n@@ -664,7 +666,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// full requirements for the `Copy` trait (cc #29149) -- this\n     /// winds up being reported as an error during NLL borrow check.\n     pub fn is_copy_modulo_regions(\n-        &'tcx self,\n+        self,\n         tcx_at: TyCtxtAt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n@@ -677,7 +679,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// over-approximation in generic contexts, where one can have\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n-    pub fn is_sized(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+    pub fn is_sized(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         self.is_trivially_sized(tcx_at.tcx) || tcx_at.is_sized_raw(param_env.and(self))\n     }\n \n@@ -688,15 +690,15 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n-    pub fn is_freeze(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+    pub fn is_freeze(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         self.is_trivially_freeze() || tcx_at.is_freeze_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Freeze`.\n     ///\n     /// Returning true means the type is known to be `Freeze`. Returning\n     /// `false` means nothing -- could be `Freeze`, might not be.\n-    fn is_trivially_freeze(&self) -> bool {\n+    fn is_trivially_freeze(self) -> bool {\n         match self.kind() {\n             ty::Int(_)\n             | ty::Uint(_)\n@@ -710,7 +712,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             | ty::FnDef(..)\n             | ty::Error(_)\n             | ty::FnPtr(_) => true,\n-            ty::Tuple(_) => self.tuple_fields().all(Self::is_trivially_freeze),\n+            ty::Tuple(_) => self.tuple_fields().all(|f| Self::is_trivially_freeze(f)),\n             ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_freeze(),\n             ty::Adt(..)\n             | ty::Bound(..)\n@@ -728,15 +730,15 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     /// Checks whether values of this type `T` implement the `Unpin` trait.\n-    pub fn is_unpin(&'tcx self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+    pub fn is_unpin(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         self.is_trivially_unpin() || tcx_at.is_unpin_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Unpin`.\n     ///\n     /// Returning true means the type is known to be `Unpin`. Returning\n     /// `false` means nothing -- could be `Unpin`, might not be.\n-    fn is_trivially_unpin(&self) -> bool {\n+    fn is_trivially_unpin(self) -> bool {\n         match self.kind() {\n             ty::Int(_)\n             | ty::Uint(_)\n@@ -750,7 +752,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             | ty::FnDef(..)\n             | ty::Error(_)\n             | ty::FnPtr(_) => true,\n-            ty::Tuple(_) => self.tuple_fields().all(Self::is_trivially_unpin),\n+            ty::Tuple(_) => self.tuple_fields().all(|f| Self::is_trivially_unpin(f)),\n             ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_unpin(),\n             ty::Adt(..)\n             | ty::Bound(..)\n@@ -776,7 +778,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     ///\n     /// Note that this method is used to check eligible types in unions.\n     #[inline]\n-    pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+    pub fn needs_drop(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         // Avoid querying in simple cases.\n         match needs_drop_components(self, &tcx.data_layout) {\n             Err(AlwaysRequiresDrop) => true,\n@@ -809,11 +811,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// Note that this method is used to check for change in drop order for\n     /// 2229 drop reorder migration analysis.\n     #[inline]\n-    pub fn has_significant_drop(\n-        &'tcx self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n+    pub fn has_significant_drop(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         // Avoid querying in simple cases.\n         match needs_drop_components(self, &tcx.data_layout) {\n             Err(AlwaysRequiresDrop) => true,\n@@ -858,7 +856,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// want to know whether a given call to `PartialEq::eq` will proceed structurally all the way\n     /// down, you will need to use a type visitor.\n     #[inline]\n-    pub fn is_structural_eq_shallow(&'tcx self, tcx: TyCtxt<'tcx>) -> bool {\n+    pub fn is_structural_eq_shallow(self, tcx: TyCtxt<'tcx>) -> bool {\n         match self.kind() {\n             // Look for an impl of both `PartialStructuralEq` and `StructuralEq`.\n             Adt(..) => tcx.has_structural_eq_impls(self),\n@@ -903,16 +901,16 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// - `&'a mut u8` -> `u8`\n     /// - `&'a &'b u8` -> `u8`\n     /// - `&'a *const &'b u8 -> *const &'b u8`\n-    pub fn peel_refs(&'tcx self) -> Ty<'tcx> {\n+    pub fn peel_refs(self) -> Ty<'tcx> {\n         let mut ty = self;\n         while let Ref(_, inner_ty, _) = ty.kind() {\n-            ty = inner_ty;\n+            ty = *inner_ty;\n         }\n         ty\n     }\n \n-    pub fn outer_exclusive_binder(&'tcx self) -> DebruijnIndex {\n-        self.outer_exclusive_binder\n+    pub fn outer_exclusive_binder(self) -> DebruijnIndex {\n+        self.0.outer_exclusive_binder\n     }\n }\n \n@@ -993,9 +991,9 @@ pub fn needs_drop_components<'tcx>(\n \n         ty::Dynamic(..) | ty::Error(_) => Err(AlwaysRequiresDrop),\n \n-        ty::Slice(ty) => needs_drop_components(ty, target_layout),\n+        ty::Slice(ty) => needs_drop_components(*ty, target_layout),\n         ty::Array(elem_ty, size) => {\n-            match needs_drop_components(elem_ty, target_layout) {\n+            match needs_drop_components(*elem_ty, target_layout) {\n                 Ok(v) if v.is_empty() => Ok(v),\n                 res => match size.val.try_to_bits(target_layout.pointer_size) {\n                     // Arrays of size zero don't need drop, even if their element"}, {"sha": "1357cb25d071e2c9b98ae3b9c3b0a6f2ecb3c6f3", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1,8 +1,8 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n-use crate::ty;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n+use crate::ty::{self, Ty};\n use rustc_data_structures::sso::SsoHashSet;\n use smallvec::{self, SmallVec};\n \n@@ -96,7 +96,7 @@ impl<'tcx> GenericArg<'tcx> {\n     }\n }\n \n-impl<'tcx> super::TyS<'tcx> {\n+impl<'tcx> Ty<'tcx> {\n     /// Iterator that walks `self` and any types reachable from\n     /// `self`, in depth-first order. Note that just walks the types\n     /// that appear in `self`, it does not descend into the fields of\n@@ -107,7 +107,7 @@ impl<'tcx> super::TyS<'tcx> {\n     /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n     /// [isize] => { [isize], isize }\n     /// ```\n-    pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n+    pub fn walk(self) -> TypeWalker<'tcx> {\n         TypeWalker::new(self.into())\n     }\n }"}, {"sha": "c706e6ef1d4664eacb472ce3f01c0a2577d20f9c", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -348,7 +348,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 let place_builder = place_builder.clone();\n                                 this.consume_by_copy_or_move(\n                                     place_builder\n-                                        .field(n, ty)\n+                                        .field(n, *ty)\n                                         .into_place(this.tcx, this.typeck_results),\n                                 )\n                             }"}, {"sha": "0beae4a215dcd835120bde6bdede04f6531b5652", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             (Some((region, elem_ty, _)), _) | (None, Some((region, elem_ty, _))) => {\n                 let tcx = self.tcx;\n                 // make both a slice\n-                ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n+                ty = tcx.mk_imm_ref(region, tcx.mk_slice(*elem_ty));\n                 if opt_ref_ty.is_some() {\n                     let temp = self.temp(ty, source_info.span);\n                     self.cfg.push_assign("}, {"sha": "fb403615e572f51755aab74c341b65a84fbc6d16", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -903,7 +903,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let mut closure_ty = self.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty;\n             if let ty::Ref(_, ty, _) = closure_ty.kind() {\n                 closure_env_projs.push(ProjectionElem::Deref);\n-                closure_ty = ty;\n+                closure_ty = *ty;\n             }\n             let upvar_substs = match closure_ty.kind() {\n                 ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),"}, {"sha": "d357ac6930266914bd84de97c4ef3f63125002b2", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -556,7 +556,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n         }\n     }\n     if let ty::Ref(_, sub_ty, _) = scrut_ty.kind() {\n-        if cx.tcx.is_ty_uninhabited_from(cx.module, sub_ty, cx.param_env) {\n+        if cx.tcx.is_ty_uninhabited_from(cx.module, *sub_ty, cx.param_env) {\n             err.note(\"references are always considered inhabited\");\n         }\n     }"}, {"sha": "4c6d07487b7880cf9b3070ac431766e1468c0825", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -420,7 +420,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                                 suffix: vec![],\n                             }),\n                             span,\n-                            ty: pointee_ty,\n+                            ty: *pointee_ty,\n                         },\n                     };\n                     self.behind_reference.set(old);\n@@ -457,7 +457,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // this pattern to a `PartialEq::eq` comparison and `PartialEq::eq` takes a\n                 // reference. This makes the rest of the matching logic simpler as it doesn't have\n                 // to figure out how to get a reference again.\n-                ty::Adt(adt_def, _) if !self.type_marked_structural(pointee_ty) => {\n+                ty::Adt(adt_def, _) if !self.type_marked_structural(*pointee_ty) => {\n                     if self.behind_reference.get() {\n                         if self.include_lint_checks\n                             && !self.saw_const_match_error.get()"}, {"sha": "5f8f21f55f8afc65b748231c7311a33e038a97ac", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -929,15 +929,15 @@ impl<'tcx> SplitWildcard<'tcx> {\n             ty::Bool => smallvec![make_range(0, 1)],\n             ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n                 let len = len.eval_usize(cx.tcx, cx.param_env) as usize;\n-                if len != 0 && cx.is_uninhabited(sub_ty) {\n+                if len != 0 && cx.is_uninhabited(*sub_ty) {\n                     smallvec![]\n                 } else {\n                     smallvec![Slice(Slice::new(Some(len), VarLen(0, 0)))]\n                 }\n             }\n             // Treat arrays of a constant but unknown length like slices.\n             ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n-                let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n+                let kind = if cx.is_uninhabited(*sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n                 smallvec![Slice(Slice::new(None, kind))]\n             }\n             ty::Adt(def, substs) if def.is_enum() => {\n@@ -1386,7 +1386,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                             // fields.\n                             // Note: `t` is `str`, not `&str`.\n                             let subpattern =\n-                                DeconstructedPat::new(Str(value), Fields::empty(), t, pat.span);\n+                                DeconstructedPat::new(Str(value), Fields::empty(), *t, pat.span);\n                             ctor = Single;\n                             fields = Fields::singleton(cx, subpattern)\n                         }"}, {"sha": "b9841a49d94c006d440552fc7ad7a9d7996c9ab9", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n                 Pat {\n                     span: pat.span,\n-                    ty: ref_ty,\n+                    ty: *ref_ty,\n                     kind: Box::new(PatKind::Deref { subpattern: pat }),\n                 }\n             },\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let var_ty = ty;\n                 if let ty::BindByReference(_) = bm {\n                     if let ty::Ref(_, rty, _) = ty.kind() {\n-                        ty = rty;\n+                        ty = *rty;\n                     } else {\n                         bug!(\"`ref {}` has wrong type {}\", ident, ty);\n                     }"}, {"sha": "3e1013b0351525841acc9931ffa1baeac10f7561", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -880,9 +880,9 @@ where\n             ty::Dynamic(..) => self.complete_drop(self.succ, self.unwind),\n             ty::Array(ety, size) => {\n                 let size = size.try_eval_usize(self.tcx(), self.elaborator.param_env());\n-                self.open_drop_for_array(ety, size)\n+                self.open_drop_for_array(*ety, size)\n             }\n-            ty::Slice(ety) => self.open_drop_for_array(ety, None),\n+            ty::Slice(ety) => self.open_drop_for_array(*ety, None),\n \n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty),\n         }"}, {"sha": "804415f2805dde78ae808bee91700884ccc61749", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -841,7 +841,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     // Found a value represented as a pair. For now only do const-prop if the type\n                     // of `rvalue` is also a tuple with two scalars.\n                     // FIXME: enable the general case stated above ^.\n-                    let ty = &value.layout.ty;\n+                    let ty = value.layout.ty;\n                     // Only do it for tuples\n                     if let ty::Tuple(substs) = ty.kind() {\n                         // Only do it if tuple is also a pair with two scalars"}, {"sha": "d787443f6aa4e87669522cd1d7fe6ad77720e19e", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -37,24 +37,12 @@ use rustc_data_structures::graph::WithSuccessors;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::coverage::CoverageKind;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, DebruijnIndex, TyS, TypeFlags};\n+use rustc_middle::ty::{self, BOOL_TY};\n use rustc_span::{self, BytePos, Pos, Span, DUMMY_SP};\n \n // All `TEMP_BLOCK` targets should be replaced before calling `to_body() -> mir::Body`.\n const TEMP_BLOCK: BasicBlock = BasicBlock::MAX;\n \n-fn dummy_ty() -> &'static TyS<'static> {\n-    thread_local! {\n-        static DUMMY_TYS: &'static TyS<'static> = Box::leak(Box::new(TyS::make_for_test(\n-            ty::Bool,\n-            TypeFlags::empty(),\n-            DebruijnIndex::from_usize(0),\n-        )));\n-    }\n-\n-    &DUMMY_TYS.with(|tys| *tys)\n-}\n-\n struct MockBlocks<'tcx> {\n     blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     dummy_place: Place<'tcx>,\n@@ -166,7 +154,7 @@ impl<'tcx> MockBlocks<'tcx> {\n     fn switchint(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n         let switchint_kind = TerminatorKind::SwitchInt {\n             discr: Operand::Move(Place::from(self.new_temp())),\n-            switch_ty: dummy_ty(),\n+            switch_ty: BOOL_TY, // just a dummy value\n             targets: SwitchTargets::static_if(0, TEMP_BLOCK, TEMP_BLOCK),\n         };\n         self.add_block_from(some_from_block, switchint_kind)"}, {"sha": "ba234dccaa63e39710000a04f38b008c044bbc97", "filename": "compiler/rustc_mir_transform/src/early_otherwise_branch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -153,7 +153,7 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n             // create temp to store inequality comparison between the two discriminants, `_t` in\n             // example above\n             let nequal = BinOp::Ne;\n-            let comp_res_type = nequal.ty(tcx, parent_ty, opt_data.child_ty);\n+            let comp_res_type = nequal.ty(tcx, *parent_ty, opt_data.child_ty);\n             let comp_temp = patch.new_temp(comp_res_type, opt_data.child_source.span);\n             patch.add_statement(parent_end, StatementKind::StorageLive(comp_temp));\n \n@@ -343,7 +343,7 @@ fn evaluate_candidate<'tcx>(\n     Some(OptimizationData {\n         destination,\n         child_place: *child_place,\n-        child_ty,\n+        child_ty: *child_ty,\n         child_source: child_terminator.source_info,\n     })\n }"}, {"sha": "8ea550fa123b6d4196947fefad7f21bcaf4b7e8d", "filename": "compiler/rustc_mir_transform/src/reveal_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -39,6 +39,6 @@ impl<'tcx> MutVisitor<'tcx> for RevealAllVisitor<'tcx> {\n         // We have to use `try_normalize_erasing_regions` here, since it's\n         // possible that we visit impossible-to-satisfy where clauses here,\n         // see #91745\n-        *ty = self.tcx.try_normalize_erasing_regions(self.param_env, *ty).unwrap_or(ty);\n+        *ty = self.tcx.try_normalize_erasing_regions(self.param_env, *ty).unwrap_or(*ty);\n     }\n }"}, {"sha": "b8feeb993e7c8a6a45ebcef69cbb7c7c6b8aa2a4", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -68,7 +68,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n         ty::InstanceDef::DropGlue(def_id, ty) => {\n             // FIXME(#91576): Drop shims for generators aren't subject to the MIR passes at the end\n             // of this function. Is this intentional?\n-            if let Some(ty::Generator(gen_def_id, substs, _)) = ty.map(ty::TyS::kind) {\n+            if let Some(ty::Generator(gen_def_id, substs, _)) = ty.map(Ty::kind) {\n                 let body = tcx.optimized_mir(*gen_def_id).generator_drop().unwrap();\n                 let body = body.clone().subst(tcx, substs);\n                 debug!(\"make_shim({:?}) = {:?}\", instance, body);\n@@ -137,7 +137,7 @@ fn local_decls_for_sig<'tcx>(\n     span: Span,\n ) -> IndexVec<Local, LocalDecl<'tcx>> {\n     iter::once(LocalDecl::new(sig.output(), span))\n-        .chain(sig.inputs().iter().map(|ity| LocalDecl::new(ity, span).immutable()))\n+        .chain(sig.inputs().iter().map(|ity| LocalDecl::new(*ity, span).immutable()))\n         .collect()\n }\n "}, {"sha": "8dde2bb0ea61146f9c057309c35fae7774aa7e2d", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1042,7 +1042,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     match (&source_ty.kind(), &target_ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _) | &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n-            ptr_vtable(a, b)\n+            ptr_vtable(*a, *b)\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             ptr_vtable(source_ty.boxed_ty(), target_ty.boxed_ty())"}, {"sha": "718a2971c403d02b494f653e61be9f89cb8e7766", "filename": "compiler/rustc_query_impl/src/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_query_impl%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_query_impl%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fvalues.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1,5 +1,5 @@\n use super::QueryCtxt;\n-use rustc_middle::ty::{self, AdtSizedConstraint, Ty, TyS};\n+use rustc_middle::ty::{self, AdtSizedConstraint, Ty};\n \n pub(super) trait Value<'tcx>: Sized {\n     fn from_cycle_error(tcx: QueryCtxt<'tcx>) -> Self;\n@@ -12,7 +12,7 @@ impl<'tcx, T> Value<'tcx> for T {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for &'_ TyS<'_> {\n+impl<'tcx> Value<'tcx> for Ty<'_> {\n     fn from_cycle_error(tcx: QueryCtxt<'tcx>) -> Self {\n         // SAFETY: This is never called when `Self` is not `Ty<'tcx>`.\n         // FIXME: Represent the above fact in the trait system somehow."}, {"sha": "b2aa72e0e67416e4f2b36713e0bcdda14c769440", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -626,7 +626,7 @@ fn orphan_check_trait_ref<'tcx>(\n                 .substs\n                 .types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .find(|ty| ty_is_local_constructor(ty, in_crate));\n+                .find(|ty| ty_is_local_constructor(*ty, in_crate));\n \n             debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n "}, {"sha": "f22b4e8d072a81f243d8b0d5687a1e4b548868de", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1251,7 +1251,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n \n     fn is_recursive_obligation(\n         &self,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        obligated_types: &mut Vec<Ty<'tcx>>,\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool;\n }\n@@ -1506,7 +1506,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             loop {\n                 match t.kind() {\n                     ty::Ref(_, inner, _) | ty::RawPtr(ty::TypeAndMut { ty: inner, .. }) => {\n-                        t = inner\n+                        t = *inner\n                     }\n                     _ => break t,\n                 }\n@@ -2054,7 +2054,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Param(ty::ParamTy { name, .. }) = *ty.kind() {\n                     let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(|| {\n+                    *self.var_map.entry(ty).or_insert_with(|| {\n                         infcx.next_ty_var(TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n                             span: DUMMY_SP,\n@@ -2245,7 +2245,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn is_recursive_obligation(\n         &self,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        obligated_types: &mut Vec<Ty<'tcx>>,\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {"}, {"sha": "40cb9647a355541b505577e5e181876bcba28a79", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -167,7 +167,7 @@ pub trait InferCtxtExt<'tcx> {\n         predicate: &T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n         T: fmt::Display;\n@@ -839,7 +839,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let ty::Ref(_, inner_ty, _) = suggested_ty.kind() else {\n                     break;\n                 };\n-                suggested_ty = inner_ty;\n+                suggested_ty = *inner_ty;\n \n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n@@ -1597,7 +1597,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Some(cause) =\n                 typeck_results.generator_interior_types.as_ref().skip_binder().iter().find(\n                     |ty::GeneratorInteriorTypeCause { ty, .. }| {\n-                        ty_matches(typeck_results.generator_interior_types.rebind(ty))\n+                        ty_matches(typeck_results.generator_interior_types.rebind(*ty))\n                     },\n                 )\n             {\n@@ -1904,7 +1904,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         predicate: &T,\n         param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        obligated_types: &mut Vec<Ty<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n     ) where\n         T: fmt::Display,"}, {"sha": "55903a3c36a29ae09b82d291e72e6f43411005e9", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -104,7 +104,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Error(_) => true,\n \n         // [T; N] and [T] have same properties as T.\n-        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n+        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, *ty),\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial."}, {"sha": "1b3d1918fcb6b22c9fce785818fed7654b0e392d", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -188,7 +188,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n         }\n \n         if let Some(ty) = self.cache.get(&ty) {\n-            return Ok(ty);\n+            return Ok(*ty);\n         }\n \n         // See note in `rustc_trait_selection::traits::project` about why we"}, {"sha": "2b7eff49e41aae5045b9216d232fc85405e22060", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -2033,7 +2033,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip_binder() // binder moved -\\\n             .iter()\n             .flat_map(|ty| {\n-                let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(ty); // <----/\n+                let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(*ty); // <----/\n \n                 self.infcx.commit_unconditionally(|_| {\n                     let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);"}, {"sha": "38a6220082ff6318678f9c8aaaf6f2f4307a5e00", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -510,7 +510,7 @@ crate fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<St\n     for (mut p, _) in predicates {\n         if let Some(poly_trait_ref) = p.to_opt_poly_trait_pred() {\n             if Some(poly_trait_ref.def_id()) == sized_trait {\n-                types_without_default_bounds.remove(poly_trait_ref.self_ty().skip_binder());\n+                types_without_default_bounds.remove(&poly_trait_ref.self_ty().skip_binder());\n                 continue;\n             }\n "}, {"sha": "455fc46a42e84476f0a70d05cfdaae0e055939b8", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -192,7 +192,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n         ty::Array(ety, _) | ty::Slice(ety) => {\n             // single-element containers, behave like their element\n             rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ety, constraints)\n+                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, *ety, constraints)\n             })?;\n         }\n "}, {"sha": "b08f8f6230837685c2898fb7e22467eba9597ce4", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -92,7 +92,7 @@ fn are_inner_types_recursive<'tcx>(\n             seen,\n             shadow_seen,\n             representable_cache,\n-            ty,\n+            *ty,\n             force_result,\n         ),\n         ty::Adt(def, substs) => {\n@@ -255,7 +255,7 @@ fn is_type_structurally_recursive<'tcx>(\n     force_result: &mut bool,\n ) -> Representability {\n     debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n-    if let Some(representability) = representable_cache.get(ty) {\n+    if let Some(representability) = representable_cache.get(&ty) {\n         debug!(\n             \"is_type_structurally_recursive: {:?} {:?} - (cached) {:?}\",\n             ty, sp, representability"}, {"sha": "04a62ed2e465bb4e7ffd99141ab3febd738d7edd", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -474,7 +474,7 @@ pub fn conservative_is_privately_uninhabited_raw<'tcx>(\n                 Some(0) | None => false,\n                 // If the array is definitely non-empty, it's uninhabited if\n                 // the type of its elements is uninhabited.\n-                Some(1..) => tcx.conservative_is_privately_uninhabited(param_env.and(ty)),\n+                Some(1..) => tcx.conservative_is_privately_uninhabited(param_env.and(*ty)),\n             }\n         }\n         ty::Ref(..) => {"}, {"sha": "3701b255b756bfe48be2cacad3b9cae6b5e7551b", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyS};\n+use rustc_middle::ty::{self, ToPredicate, Ty};\n use rustc_span::{MultiSpan, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n         span: Span,\n-        outer_ty: &'tcx TyS<'tcx>,\n+        outer_ty: Ty<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n         match (orig_expected, self.ret_coercion_impl_trait.map(|ty| (self.body_id.owner, ty))) {"}, {"sha": "23bb47a6908b7bac7fdfbc3866b148b2bea0bfce", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -628,7 +628,7 @@ impl<'a, 'tcx> DeferredCallResolution<'tcx> {\n                 for (method_arg_ty, self_arg_ty) in\n                     iter::zip(method_sig.inputs().iter().skip(1), self.fn_sig.inputs())\n                 {\n-                    fcx.demand_eqtype(self.call_expr.span, &self_arg_ty, &method_arg_ty);\n+                    fcx.demand_eqtype(self.call_expr.span, *self_arg_ty, *method_arg_ty);\n                 }\n \n                 fcx.demand_eqtype(self.call_expr.span, method_sig.output(), self.fn_sig.output());"}, {"sha": "b31b1540e5c214d17dc40c3a7e4d4438d1ceb1a3", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -885,7 +885,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     });\n \n                 // this will report a type mismatch if needed\n-                fcx.demand_eqtype(self.span, ety, m_cast.ty);\n+                fcx.demand_eqtype(self.span, *ety, m_cast.ty);\n                 return Ok(CastKind::ArrayPtrCast);\n             }\n         }"}, {"sha": "3c626837ef1a327b73cf74c2e7e31a27236932a5", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -450,7 +450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .skip_binder()\n             .inputs()\n             .iter()\n-            .map(|ty| ArgKind::from_expected_ty(ty, None))\n+            .map(|ty| ArgKind::from_expected_ty(*ty, None))\n             .collect();\n         let (closure_span, found_args) = match self.get_fn_like_arguments(expr_map_node) {\n             Some((sp, args)) => (Some(sp), args),"}, {"sha": "3aa933d093156ad736c3680e7182e17dc7507f13", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -142,7 +142,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     where\n         F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     {\n-        self.unify(&a, &b)\n+        self.unify(a, b)\n             .and_then(|InferOk { value: ty, obligations }| success(f(ty), ty, obligations))\n     }\n "}, {"sha": "d0e96e7538cf046de0341566083cf4d57d90530e", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -734,7 +734,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n                 _,\n                 &ty::Ref(_, checked, _),\n-            ) if self.infcx.can_sub(self.param_env, checked, &expected).is_ok() => {\n+            ) if self.infcx.can_sub(self.param_env, checked, expected).is_ok() => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {"}, {"sha": "56cb80df61c0f5972135032139b59f69c0a7bc02", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -421,9 +421,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // Places may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n                         // the last field of a struct can be unsized.\n-                        ExpectHasType(ty)\n+                        ExpectHasType(*ty)\n                     } else {\n-                        Expectation::rvalue_hint(self, ty)\n+                        Expectation::rvalue_hint(self, *ty)\n                     }\n                 }\n                 _ => NoExpectation,\n@@ -2216,7 +2216,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn no_such_field_err(\n         &self,\n         field: Ident,\n-        expr_t: &'tcx ty::TyS<'tcx>,\n+        expr_t: Ty<'tcx>,\n         id: HirId,\n     ) -> DiagnosticBuilder<'_> {\n         let span = field.span;\n@@ -2233,7 +2233,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         // try to add a suggestion in case the field is a nested field of a field of the Adt\n-        if let Some((fields, substs)) = self.get_field_candidates(span, &expr_t) {\n+        if let Some((fields, substs)) = self.get_field_candidates(span, expr_t) {\n             for candidate_field in fields.iter() {\n                 if let Some(field_path) = self.check_for_nested_field(\n                     span,\n@@ -2312,7 +2312,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             field_path.push(candidate_field.ident(self.tcx).normalize_to_macros_2_0());\n             let field_ty = candidate_field.ty(self.tcx, subst);\n-            if let Some((nested_fields, subst)) = self.get_field_candidates(span, &field_ty) {\n+            if let Some((nested_fields, subst)) = self.get_field_candidates(span, field_ty) {\n                 for field in nested_fields.iter() {\n                     let accessible = field.vis.is_accessible_from(id, self.tcx);\n                     if accessible {\n@@ -2449,7 +2449,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // allows them to be inferred based on how they are used later in the\n         // function.\n         if is_input {\n-            let ty = self.structurally_resolved_type(expr.span, &ty);\n+            let ty = self.structurally_resolved_type(expr.span, ty);\n             match *ty.kind() {\n                 ty::FnDef(..) => {\n                     let fnptr_ty = self.tcx.mk_fn_ptr(ty.fn_sig(self.tcx));"}, {"sha": "7214cdf3312a78998c9374b15ae800f7cc6ca265", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // unconstrained opaque type variables, in addition to performing\n         // other kinds of fallback.\n         for ty in &self.unsolved_variables() {\n-            fallback_has_occurred |= self.fallback_opaque_type_vars(ty);\n+            fallback_has_occurred |= self.fallback_opaque_type_vars(*ty);\n         }\n \n         // See if we can make any more progress.\n@@ -176,7 +176,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             .type_var_origin(ty)\n             .map(|origin| origin.span)\n             .unwrap_or(rustc_span::DUMMY_SP);\n-        let oty = self.inner.borrow().opaque_types_vars.get(ty).copied();\n+        let oty = self.inner.borrow().opaque_types_vars.get(&ty).copied();\n         if let Some(opaque_ty) = oty {\n             debug!(\n                 \"fallback_opaque_type_vars(ty={:?}): falling back to opaque type {:?}\","}, {"sha": "c173e2aa65bb3b8b87c2738cc959661560602eba", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -605,7 +605,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: &'tcx ty::FieldDef,\n         substs: SubstsRef<'tcx>,\n     ) -> Ty<'tcx> {\n-        self.normalize_associated_types_in(span, &field.ty(self.tcx, substs))\n+        self.normalize_associated_types_in(span, field.ty(self.tcx, substs))\n     }\n \n     pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, &formal_ret);\n+                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n \n                 // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n                 // to identity so the resulting type is not constrained."}, {"sha": "abf2135eec64f2aec4fe2acd63d70ae540b9a43c", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         if ty.has_escaping_bound_vars() {\n             ty // FIXME: normalization and escaping regions\n         } else {\n-            self.normalize_associated_types_in(span, &ty)\n+            self.normalize_associated_types_in(span, ty)\n         }\n     }\n "}, {"sha": "576dc6f127cbda11e8674189937c4824c5c72fc9", "filename": "compiler/rustc_typeck/src/check/gather_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n         debug!(\n             \"local variable {:?} is assigned type {}\",\n             decl.pat,\n-            self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&decl.hir_id).unwrap().decl_ty)\n+            self.fcx.ty_to_string(self.fcx.locals.borrow().get(&decl.hir_id).unwrap().decl_ty)\n         );\n     }\n }\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n             debug!(\n                 \"pattern binding {} is assigned to {} with type {:?}\",\n                 ident,\n-                self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&p.hir_id).unwrap().decl_ty),\n+                self.fcx.ty_to_string(self.fcx.locals.borrow().get(&p.hir_id).unwrap().decl_ty),\n                 var_ty\n             );\n         }"}, {"sha": "21c8ea54621989da95259a8b46c9c3df3372478d", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n \n                 self.types.insert(ty::GeneratorInteriorTypeCause {\n                     span: source_span,\n-                    ty: &ty,\n+                    ty,\n                     scope_span,\n                     yield_span: yield_data.span,\n                     expr: expr.map(|e| e.hir_id),"}, {"sha": "fdc3ba17e3ccf4284e4727e3a2e8b3f4b477a74b", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n                 if unsize {\n                     let unsized_ty = if let ty::Array(elem_ty, _) = base_ty.kind() {\n-                        self.tcx.mk_slice(elem_ty)\n+                        self.tcx.mk_slice(*elem_ty)\n                     } else {\n                         bug!(\n                             \"AutorefOrPtrAdjustment's unsize flag should only be set for array ty, found {}\",\n@@ -201,8 +201,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             }\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) => {\n                 target = match target.kind() {\n-                    ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n-                        assert_eq!(*mutbl, hir::Mutability::Mut);\n+                    &ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n+                        assert_eq!(mutbl, hir::Mutability::Mut);\n                         self.tcx.mk_ptr(ty::TypeAndMut { mutbl: hir::Mutability::Not, ty })\n                     }\n                     other => panic!(\"Cannot adjust receiver type {:?} to const ptr\", other),"}, {"sha": "0aed15295fce47bf2a237dc387261dea7bbf1923", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let ty::Ref(region, t_type, mutability) = self_ty.kind() {\n                 let trait_type = self\n                     .tcx\n-                    .mk_ref(region, ty::TypeAndMut { ty: t_type, mutbl: mutability.invert() });\n+                    .mk_ref(region, ty::TypeAndMut { ty: *t_type, mutbl: mutability.invert() });\n                 // We probe again to see if there might be a borrow mutability discrepancy.\n                 match self.lookup_probe(\n                     span,"}, {"sha": "c429e0f165370227d3b1dd2d3ace973b91757bc3", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -515,7 +515,7 @@ fn method_autoderef_steps<'tcx>(\n                 steps.push(CandidateStep {\n                     self_ty: infcx.make_query_response_ignoring_pending_obligations(\n                         inference_vars,\n-                        infcx.tcx.mk_slice(elem_ty),\n+                        infcx.tcx.mk_slice(*elem_ty),\n                     ),\n                     autoderefs: dereferences,\n                     // this could be from an unsafe deref if we had\n@@ -1247,7 +1247,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n \n         let ty = match self_ty.kind() {\n-            ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut }) => ty,\n+            &ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::Mutability::Mut }) => ty,\n             _ => return None,\n         };\n "}, {"sha": "06fcad25d3c0c5731fff66aaf505540fb3901413", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1087,7 +1087,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if needs_mut {\n                         let trait_type = self.tcx.mk_ref(\n                             region,\n-                            ty::TypeAndMut { ty: t_type, mutbl: mutability.invert() },\n+                            ty::TypeAndMut { ty: *t_type, mutbl: mutability.invert() },\n                         );\n                         err.note(&format!(\"you need `{}` instead of `{}`\", trait_type, rcvr_ty));\n                     }\n@@ -1468,7 +1468,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Ok(pick) = self.lookup_probe(\n                     span,\n                     item_name,\n-                    rcvr_ty,\n+                    *rcvr_ty,\n                     rcvr,\n                     crate::check::method::probe::ProbeScope::AllTraits,\n                 ) {\n@@ -1487,10 +1487,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     break;\n                 }\n                 for (rcvr_ty, pre) in &[\n-                    (self.tcx.mk_lang_item(rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n-                    (self.tcx.mk_lang_item(rcvr_ty, LangItem::Pin), \"Pin::new\"),\n-                    (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Arc), \"Arc::new\"),\n-                    (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Rc), \"Rc::new\"),\n+                    (self.tcx.mk_lang_item(*rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n+                    (self.tcx.mk_lang_item(*rcvr_ty, LangItem::Pin), \"Pin::new\"),\n+                    (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Arc), \"Arc::new\"),\n+                    (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n                     if let Some(new_rcvr_t) = *rcvr_ty {\n                         if let Ok(pick) = self.lookup_probe("}, {"sha": "aaf80064ce7e20064037422636f4ba036cdf471f", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -399,8 +399,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n                 if let Ref(_, rty, _) = lhs_ty.kind() {\n-                    if self.infcx.type_is_copy_modulo_regions(self.param_env, rty, lhs_expr.span)\n-                        && self.lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign)).is_ok()\n+                    if self.infcx.type_is_copy_modulo_regions(self.param_env, *rty, lhs_expr.span)\n+                        && self.lookup_op_method(*rty, &[rhs_ty], Op::Binary(op, is_assign)).is_ok()\n                     {\n                         if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n                             let msg = &format!(\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     self.tcx,\n                                     self.body_id,\n                                     &mut err,\n-                                    ty,\n+                                    *ty,\n                                     rhs_ty,\n                                     missing_trait,\n                                     p,\n@@ -878,7 +878,7 @@ enum Op {\n /// Dereferences a single level of immutable referencing.\n fn deref_ty_if_possible<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.kind() {\n-        ty::Ref(_, ty, hir::Mutability::Not) => ty,\n+        ty::Ref(_, ty, hir::Mutability::Not) => *ty,\n         _ => ty,\n     }\n }"}, {"sha": "6d93e9f103d29cd9caec1feed8a3271f4ee8b31a", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if unsize {\n                 // We only unsize arrays here.\n                 if let ty::Array(element_ty, _) = adjusted_ty.kind() {\n-                    self_ty = self.tcx.mk_slice(element_ty);\n+                    self_ty = self.tcx.mk_slice(*element_ty);\n                 } else {\n                     continue;\n                 }"}, {"sha": "768daa71a1e358d6785db5b5251b09a064dfe706", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1499,7 +1499,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If the data will be moved out of this place, then the place will be truncated\n             // at the first Deref in `adjust_upvar_borrow_kind_for_consume` and then moved into\n             // the closure.\n-            hir::CaptureBy::Value if !place.deref_tys().any(ty::TyS::is_ref) => {\n+            hir::CaptureBy::Value if !place.deref_tys().any(Ty::is_ref) => {\n                 ty::UpvarCapture::ByValue\n             }\n             hir::CaptureBy::Value | hir::CaptureBy::Ref => ty::UpvarCapture::ByRef(ty::ImmBorrow),\n@@ -1813,7 +1813,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         );\n \n         // Raw pointers don't inherit mutability\n-        if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n+        if place_with_id.place.deref_tys().any(Ty::is_unsafe_ptr) {\n             capture_kind = ty::UpvarCapture::ByRef(ty::BorrowKind::ImmBorrow);\n         }\n "}, {"sha": "fda93057f18cbe1ba58014cb84b3a4c512201fe1", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -2591,7 +2591,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n             }\n         };\n         for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {\n-            check(input, ty)\n+            check(input, *ty)\n         }\n         if let hir::FnRetTy::Return(ref ty) = decl.output {\n             check(ty, fty.output().skip_binder())"}, {"sha": "e8e4a0be9699b5087437977cb4eb1833c31550cf", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -639,7 +639,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n                         err.emit();\n                     }\n                 } else {\n-                    self.found = Some((span, concrete_type));\n+                    self.found = Some((span, *concrete_type));\n                 }\n             }\n         }"}, {"sha": "1bbd6d29294a60e62fe6e067177d036f3da50c45", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -192,7 +192,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         if let Some(vec) = self.typeck_results.pat_adjustments().get(pat.hir_id) {\n             if let Some(first_ty) = vec.first() {\n                 debug!(\"pat_ty(pat={:?}) found adjusted ty `{:?}`\", pat, first_ty);\n-                return Ok(first_ty);\n+                return Ok(*first_ty);\n             }\n         }\n "}, {"sha": "8bf770954b0fd2db6c3e8fa9ed794fb682758f36", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1460,7 +1460,7 @@ fn normalize<'tcx>(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n impl<'tcx> Clean<Type> for Ty<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         trace!(\"cleaning type: {:?}\", self);\n-        let ty = normalize(cx, self).unwrap_or(self);\n+        let ty = normalize(cx, *self).unwrap_or(*self);\n         match *ty.kind() {\n             ty::Never => Primitive(PrimitiveType::Never),\n             ty::Bool => Primitive(PrimitiveType::Bool),"}, {"sha": "7637666d059ef319be896210e2e7e0c6cb0feca5", "filename": "src/tools/clippy/clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -47,7 +47,7 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n         then {\n             let mut ty = ctx.typeck_results().expr_ty(obj);\n             ty = match ty.kind() {\n-                ty::Ref(_, ty, ..) => ty,\n+                ty::Ref(_, ty, ..) => *ty,\n                 _ => ty\n             };\n "}, {"sha": "b80d55dd192a10201dc0fa67c4c49fd7cbdbdbea", "filename": "src/tools/clippy/clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(fn_sig) = fn_sig_opt(self.cx, func.hir_id) {\n                     for (expr, bound) in iter::zip(*args, fn_sig.skip_binder().inputs()) {\n                         // Push found arg type, then visit arg.\n-                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n                     for (expr, bound) in iter::zip(*args, fn_sig.inputs()) {\n-                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -210,7 +210,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n \n fn fn_sig_opt<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<PolyFnSig<'tcx>> {\n     let node_ty = cx.typeck_results().node_type_opt(hir_id)?;\n-    // We can't use `TyS::fn_sig` because it automatically performs substs, this may result in FNs.\n+    // We can't use `Ty::fn_sig` because it automatically performs substs, this may result in FNs.\n     match node_ty.kind() {\n         ty::FnDef(def_id, _) => Some(cx.tcx.fn_sig(*def_id)),\n         ty::FnPtr(fn_sig) => Some(*fn_sig),"}, {"sha": "ea547793b1ea2528a0a6662e972b68041d9c4174", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -7,10 +7,10 @@ use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_tes\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n-    def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, Ty, TyKind,\n+    def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -279,7 +279,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n     }\n }\n \n-fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Option<(&'tcx Ty<'tcx>, &'tcx Ty<'tcx>)> {\n+fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n     if_chain! {\n         if let Some(block) = get_enclosing_block(cx, e.hir_id);\n         if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n@@ -301,7 +301,7 @@ fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Op\n     }\n }\n \n-fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: &TyS<'_>, hir_ty: &Ty<'_>) -> bool {\n+fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n     if_chain! {\n         if let ty::Adt(adt_def, _) = middle_ty.kind();\n         if let Some(local_did) = adt_def.did.as_local();"}, {"sha": "503aac8ccd02628a8702a8db7958e3b151896c0e", "filename": "src/tools/clippy/clippy_lints/src/format_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat_args.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -211,7 +211,7 @@ where\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;\n             }\n-            ty = target;\n+            ty = *target;\n         } else {\n             return (n_needed, ty);\n         }"}, {"sha": "6b62748ffef2e2812195961768e5d416197d6a26", "filename": "src/tools/clippy/clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -118,7 +118,7 @@ fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxIndexMap<hir\n                 // The values need to use the `ref` keyword if they can't be copied.\n                 // This will need to be adjusted if the lint want to support multable access in the future\n                 let src_is_ref = bound_ty.is_ref() && binding != hir::BindingAnnotation::Ref;\n-                let needs_ref = !(src_is_ref || is_copy(cx, inner_ty));\n+                let needs_ref = !(src_is_ref || is_copy(cx, *inner_ty));\n \n                 let slice_info = slices\n                     .entry(value_hir_id)"}, {"sha": "663977a57a07cd8949bdacfd01977e6d822090f1", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if let ty::Array(element_type, cst) = ty.kind();\n             if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n-            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n \n             then {"}, {"sha": "b9e246290ff794ace419c4225e36f12c1b2e0e0d", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n             if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n             if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n-            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n             then {\n                 span_lint_and_help("}, {"sha": "35d10d53112ec6c3591555833dcace76f3c9ed6c", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -294,7 +294,7 @@ impl LenOutput<'_> {\n /// Checks if the given signature matches the expectations for `is_empty`\n fn check_is_empty_sig(sig: FnSig<'_>, self_kind: ImplicitSelfKind, len_output: LenOutput<'_>) -> bool {\n     match &**sig.inputs_and_output {\n-        [arg, res] if len_output.matches_is_empty_output(res) => {\n+        [arg, res] if len_output.matches_is_empty_output(*res) => {\n             matches!(\n                 (arg.kind(), self_kind),\n                 (ty::Ref(_, _, Mutability::Not), ImplicitSelfKind::ImmRef)"}, {"sha": "fc50e8addccec8f84e87c03fffedd10a92daa3dd", "filename": "src/tools/clippy/clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr};\n use rustc_hir::{Expr, Pat};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, UintTy};\n+use rustc_middle::ty::{self, Ty, UintTy};\n \n // To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n // incremented exactly once in the loop body, and initialized to zero\n@@ -36,7 +36,7 @@ pub(super) fn check<'tcx>(\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    let int_name = match ty.map(ty::TyS::kind) {\n+                    let int_name = match ty.map(Ty::kind) {\n                         // usize or inferred\n                         Some(ty::Uint(UintTy::Usize)) | None => {\n                             span_lint_and_sugg("}, {"sha": "f6ef87264c0a6f3b8f2a70cf3f3e3a44164c3f85", "filename": "src/tools/clippy/clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -335,8 +335,8 @@ struct Start<'hir> {\n fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.kind() {\n         ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Vec, adt.did) => Some(subs.type_at(0)),\n-        ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, subty),\n-        ty::Slice(ty) | ty::Array(ty, _) => Some(ty),\n+        ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, *subty),\n+        ty::Slice(ty) | ty::Array(ty, _) => Some(*ty),\n         _ => None,\n     }\n }"}, {"sha": "06190850bb003ebe1ef2d772e462dd35289e7a12", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node,\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n@@ -334,8 +334,8 @@ fn detect_iter_and_into_iters<'tcx: 'a, 'a>(\n     }\n }\n \n-fn get_captured_ids(cx: &LateContext<'_>, ty: &'_ TyS<'_>) -> HirIdSet {\n-    fn get_captured_ids_recursive(cx: &LateContext<'_>, ty: &'_ TyS<'_>, set: &mut HirIdSet) {\n+fn get_captured_ids(cx: &LateContext<'_>, ty: Ty<'_>) -> HirIdSet {\n+    fn get_captured_ids_recursive(cx: &LateContext<'_>, ty: Ty<'_>, set: &mut HirIdSet) {\n         match ty.kind() {\n             ty::Adt(_, generics) => {\n                 for generic in *generics {"}, {"sha": "772d251b620a80f45a96ef89b3972a2f16572727", "filename": "src/tools/clippy/clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -334,7 +334,7 @@ pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic\n         // (&mut x).into_iter() ==> x.iter_mut()\n         let arg_ty = cx.typeck_results().expr_ty_adjusted(arg);\n         match &arg_ty.kind() {\n-            ty::Ref(_, inner_ty, mutbl) if has_iter_method(cx, inner_ty).is_some() => {\n+            ty::Ref(_, inner_ty, mutbl) if has_iter_method(cx, *inner_ty).is_some() => {\n                 let method_name = match mutbl {\n                     Mutability::Mut => \"iter_mut\",\n                     Mutability::Not => \"iter\","}, {"sha": "e233300e26ab898e94efcdbd13b5bee37b6dbcf7", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -100,7 +100,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                     let obj_ty = cx.typeck_results().expr_ty(obj);\n                                     if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n                                         if matches!(mutability, Mutability::Not) {\n-                                            let copy = is_copy(cx, ty);\n+                                            let copy = is_copy(cx, *ty);\n                                             self.lint_explicit_closure(cx, e.span, args[0].span, copy);\n                                         }\n                                     } else {"}, {"sha": "e195fddefaba32a1010d5727daeaa015fac577ae", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -59,7 +59,7 @@ fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, see\n         // Check if any component type has any.\n         match ty.kind() {\n             ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n+            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, *ty, seen),\n             ty::Adt(adt, subs) => adt\n                 .all_fields()\n                 .map(|f| f.ty(cx.tcx, subs))"}, {"sha": "0c4cb45d147cae84cd16e949c6e783e436a842f8", "filename": "src/tools/clippy/clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -8,7 +8,7 @@ use core::cmp::max;\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty};\n \n use super::{MATCH_BOOL, SINGLE_MATCH, SINGLE_MATCH_ELSE};\n \n@@ -162,10 +162,10 @@ fn check_opt_like<'a>(\n         return;\n     }\n \n-    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n+    let in_candidate_enum = |path_info: &(String, Ty<'_>)| -> bool {\n         let (path, ty) = path_info;\n         for &(ty_path, pat_path) in candidates {\n-            if path == pat_path && match_type(cx, ty, ty_path) {\n+            if path == pat_path && match_type(cx, *ty, ty_path) {\n                 return true;\n             }\n         }"}, {"sha": "67a585edc2550615aa610d2c958f0a2591582c14", "filename": "src/tools/clippy/clippy_lints/src/methods/cloned_instead_of_copied.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -30,7 +30,7 @@ pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span,\n     };\n     match inner_ty.kind() {\n         // &T where T: Copy\n-        ty::Ref(_, ty, _) if is_copy(cx, ty) => {},\n+        ty::Ref(_, ty, _) if is_copy(cx, *ty) => {},\n         _ => return,\n     };\n     span_lint_and_sugg("}, {"sha": "b93f1399eaeed8e9c13692355049678cf450cb42", "filename": "src/tools/clippy/clippy_lints/src/methods/iter_overeager_cloned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -26,7 +26,7 @@ pub(super) fn check<'tcx>(\n     };\n \n     match inner_ty.kind() {\n-        ty::Ref(_, ty, _) if !is_copy(cx, ty) => {},\n+        ty::Ref(_, ty, _) if !is_copy(cx, *ty) => {},\n         _ => return,\n     };\n "}, {"sha": "68a75667914aa0f8f6ab34c80d408ba3a812741a", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n use std::borrow::Cow;\n \n@@ -37,8 +37,8 @@ fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n     } else {\n         let ty = cx.typeck_results().expr_ty(e);\n         if is_type_diagnostic_item(cx, ty, sym::String)\n-            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, TyS::is_str))\n-            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, TyS::is_str))\n+            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, Ty::is_str))\n+            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, Ty::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {"}, {"sha": "3021a40fae142a03bfd4d3cdea0a83810f1c8387", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -2106,7 +2106,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n \n-            let first_arg_ty = &method_sig.inputs().iter().next();\n+            let first_arg_ty = method_sig.inputs().iter().next();\n \n             // check conventions w.r.t. conversion method names and predicates\n             if let Some(first_arg_ty) = first_arg_ty;\n@@ -2119,7 +2119,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                         if name == method_config.method_name &&\n                             sig.decl.inputs.len() == method_config.param_count &&\n                             method_config.output_type.matches(&sig.decl.output) &&\n-                            method_config.self_kind.matches(cx, self_ty, first_arg_ty) &&\n+                            method_config.self_kind.matches(cx, self_ty, *first_arg_ty) &&\n                             fn_header_equals(method_config.fn_header, sig.header) &&\n                             method_config.lifetime_param_cond(impl_item)\n                         {\n@@ -2151,7 +2151,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                         cx,\n                         name,\n                         self_ty,\n-                        first_arg_ty,\n+                        *first_arg_ty,\n                         first_arg.pat.span,\n                         implements_trait,\n                         false"}, {"sha": "7916fb8e3b45ca2739f6efc35a6c079bfd864ed7", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -105,7 +105,7 @@ fn check_addr_of_expr(\n         if is_copy(cx, receiver_ty) || is_cow_into_owned(cx, method_name, method_def_id);\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n-            let (target_ty, n_target_refs) = peel_mid_ty_refs(target_ty);\n+            let (target_ty, n_target_refs) = peel_mid_ty_refs(*target_ty);\n             let (receiver_ty, n_receiver_refs) = peel_mid_ty_refs(receiver_ty);\n             if receiver_ty == target_ty && n_target_refs >= n_receiver_refs {\n                 span_lint_and_sugg(\n@@ -228,7 +228,7 @@ fn check_other_call_arg<'tcx>(\n         let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n         if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n         if let Some(input) = fn_sig.inputs().get(i);\n-        let (input, n_refs) = peel_mid_ty_refs(input);\n+        let (input, n_refs) = peel_mid_ty_refs(*input);\n         if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n         if let Some(sized_def_id) = cx.tcx.lang_items().sized_trait();\n         if let [trait_predicate] = trait_predicates"}, {"sha": "63c3273bd6816c1e27e237f5a31854967ad7920e", "filename": "src/tools/clippy/clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -19,7 +19,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym::Vec),\n             ty::Array(_, size) => size.try_eval_usize(cx.tcx, cx.param_env).is_some(),\n-            ty::Ref(_, inner, _) => may_slice(cx, inner),\n+            ty::Ref(_, inner, _) => may_slice(cx, *inner),\n             _ => false,\n         }\n     }\n@@ -35,7 +35,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n             ty::Slice(_) => Some(expr),\n             ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n             ty::Ref(_, inner, _) => {\n-                if may_slice(cx, inner) {\n+                if may_slice(cx, *inner) {\n                     Some(expr)\n                 } else {\n                     None"}, {"sha": "aecfea9c141cfad801b75fedc45472f76d0be272", "filename": "src/tools/clippy/clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -2,7 +2,7 @@ use crate::methods::SelfKind;\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::is_copy;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::TyS;\n+use rustc_middle::ty::Ty;\n use rustc_span::source_map::Span;\n use std::fmt;\n \n@@ -41,7 +41,7 @@ impl Convention {\n     fn check<'tcx>(\n         &self,\n         cx: &LateContext<'tcx>,\n-        self_ty: &'tcx TyS<'tcx>,\n+        self_ty: Ty<'tcx>,\n         other: &str,\n         implements_trait: bool,\n         is_trait_item: bool,\n@@ -84,8 +84,8 @@ impl fmt::Display for Convention {\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     item_name: &str,\n-    self_ty: &'tcx TyS<'tcx>,\n-    first_arg_ty: &'tcx TyS<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    first_arg_ty: Ty<'tcx>,\n     first_arg_span: Span,\n     implements_trait: bool,\n     is_trait_item: bool,"}, {"sha": "e9f268da691565c926ce31e9ab98ce5486a5ed08", "filename": "src/tools/clippy/clippy_lints/src/methods/zst_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -9,7 +9,7 @@ use super::ZST_OFFSET;\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n         if let ty::RawPtr(ty::TypeAndMut { ty, .. }) = cx.typeck_results().expr_ty(recv).kind();\n-        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n+        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(*ty));\n         if layout.is_zst();\n         then {\n             span_lint(cx, ZST_OFFSET, expr.span, \"offset calculation on zero-sized value\");"}, {"sha": "195b2e5c2ee0a0ff722e1f39bbccadc1ed649b17", "filename": "src/tools/clippy/clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::sext;\n use if_chain::if_chain;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::fmt::Display;\n \n@@ -77,7 +77,7 @@ fn floating_point_operand_info<T: Display + PartialOrd + From<f32>>(f: &T) -> Op\n     }\n }\n \n-fn might_have_negative_value(t: &ty::TyS<'_>) -> bool {\n+fn might_have_negative_value(t: Ty<'_>) -> bool {\n     t.is_signed() || t.is_floating_point()\n }\n "}, {"sha": "b4e29101b396185c2f70cf6e7f71d18e3d8550fb", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -113,7 +113,7 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::\n     let fn_def_id = cx.tcx.hir().local_def_id(item_hir_id);\n     let fn_sig = cx.tcx.fn_sig(fn_def_id);\n     for (hir_ty, ty) in iter::zip(decl.inputs, fn_sig.inputs().skip_binder()) {\n-        check_ty(cx, hir_ty.span, ty);\n+        check_ty(cx, hir_ty.span, *ty);\n     }\n     check_ty(cx, decl.output.span(), cx.tcx.erase_late_bound_regions(fn_sig.output()));\n }"}, {"sha": "b7f981faa2d42c6491d8745fc9b76168bd4a2fe6", "filename": "src/tools/clippy/clippy_lints/src/mut_mutex_lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n             if path.ident.name == sym!(lock);\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, inner_ty, Mutability::Mut) = ty.kind();\n-            if is_type_diagnostic_item(cx, inner_ty, sym::Mutex);\n+            if is_type_diagnostic_item(cx, *inner_ty, sym::Mutex);\n             then {\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "f4de999a9281a3391149ac7fbf1842f9dd45eb09", "filename": "src/tools/clippy/clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -205,7 +205,7 @@ fn ty_allowed_with_raw_pointer_heuristic<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'t\n         ty::Tuple(_) => ty\n             .tuple_fields()\n             .all(|ty| ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait)),\n-        ty::Array(ty, _) | ty::Slice(ty) => ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait),\n+        ty::Array(ty, _) | ty::Slice(ty) => ty_allowed_with_raw_pointer_heuristic(cx, *ty, send_trait),\n         ty::Adt(_, substs) => {\n             if contains_pointer_like(cx, ty) {\n                 // descends only if ADT contains any raw pointers"}, {"sha": "d59249d7f13d32343bcb237ae44bb5afd860e0a1", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -167,8 +167,8 @@ impl<'tcx> PassByRefOrValue {\n \n                     if_chain! {\n                         if !output_lts.contains(input_lt);\n-                        if is_copy(cx, ty);\n-                        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                        if is_copy(cx, *ty);\n+                        if let Some(size) = cx.layout_of(*ty).ok().map(|l| l.size.bytes());\n                         if size <= self.ref_min_size;\n                         if let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind;\n                         then {"}, {"sha": "f3515ea3c2dde19addc39a4519dbbcc8990b5833", "filename": "src/tools/clippy/clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -116,7 +116,7 @@ fn get_pointee_ty_and_count_expr<'tcx>(\n         if let ty::RawPtr(TypeAndMut { ty: pointee_ty, .. }) =\n             cx.typeck_results().expr_ty(ptr_self).kind();\n         then {\n-            return Some((pointee_ty, count));\n+            return Some((*pointee_ty, count));\n         }\n     };\n     None"}, {"sha": "f3653199b3758b2ecf4d68ef22832da4c298e8c6", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -38,7 +38,7 @@ pub(super) fn check<'tcx>(\n                     let arg = if from_ptr_ty.ty == *to_ref_ty {\n                         arg\n                     } else {\n-                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n+                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, *to_ref_ty)))\n                     };\n \n                     diag.span_suggestion("}, {"sha": "7570bc2a7a8f0d8195e2f8d560f29f36a06c97b3", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ref_to_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -56,10 +56,10 @@ pub(super) fn check<'tcx>(\n                         \"transmute from a reference to a reference\",\n                         |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                             let ty_from_and_mut = ty::TypeAndMut {\n-                                ty: ty_from,\n+                                ty: *ty_from,\n                                 mutbl: *from_mutbl\n                             };\n-                            let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: *to_mutbl };\n+                            let ty_to_and_mut = ty::TypeAndMut { ty: *ty_to, mutbl: *to_mutbl };\n                             let sugg_paren = arg\n                                 .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n                                 .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));"}, {"sha": "9ed5952a109a5a4cb827fbe87c6342ae093fa981", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -200,27 +200,27 @@ fn reduce_refs<'tcx>(\n     loop {\n         return match (from_ty.kind(), to_ty.kind()) {\n             (\n-                ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. }),\n-                ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. }),\n+                &ty::Ref(_, from_sub_ty, _) | &ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. }),\n+                &ty::Ref(_, to_sub_ty, _) | &ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. }),\n             ) => {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n             },\n-            (ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n+            (&ty::Ref(_, unsized_ty, _) | &ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n                 ReducedTys::FromFatPtr { unsized_ty }\n             },\n-            (_, ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n+            (_, &ty::Ref(_, unsized_ty, _) | &ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n                 ReducedTys::ToFatPtr { unsized_ty }\n             },\n-            (ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n+            (&ty::Ref(_, from_ty, _) | &ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n                 ReducedTys::FromPtr { from_ty, to_ty }\n             },\n-            (_, ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. })) => {\n+            (_, &ty::Ref(_, to_ty, _) | &ty::RawPtr(TypeAndMut { ty: to_ty, .. })) => {\n                 ReducedTys::ToPtr { from_ty, to_ty }\n             },\n             _ => ReducedTys::Other { from_ty, to_ty },\n@@ -247,7 +247,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n             },\n             ty::Tuple(args) => {\n                 let mut iter = args.iter().map(GenericArg::expect_ty);\n-                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, *ty)) else {\n                     return ReducedTy::OrderedFields(ty);\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n@@ -265,7 +265,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     .fields\n                     .iter()\n                     .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n-                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, *ty)) else {\n                     return ReducedTy::OrderedFields(ty);\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {"}, {"sha": "3cc3d40a143dc1c96ca8d535e866968187b0eb48", "filename": "src/tools/clippy/clippy_lints/src/transmute/useless_transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -34,7 +34,7 @@ pub(super) fn check<'tcx>(\n                 |diag| {\n                     if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                         let rty_and_mut = ty::TypeAndMut {\n-                            ty: rty,\n+                            ty: *rty,\n                             mutbl: *rty_mutbl,\n                         };\n "}, {"sha": "7c39a08a336b6565c984e7cfb37c07d35a94e343", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -84,7 +84,8 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n         let partial_ord_preds =\n             get_trait_predicates_for_trait_id(cx, generics, cx.tcx.lang_items().partial_ord_trait());\n         // Trying to call erase_late_bound_regions on fn_sig.inputs() gives the following error\n-        // The trait `rustc::ty::TypeFoldable<'_>` is not implemented for `&[&rustc::ty::TyS<'_>]`\n+        // The trait `rustc::ty::TypeFoldable<'_>` is not implemented for\n+        // `&[rustc_middle::ty::Ty<'_>]`\n         let inputs_output = cx.tcx.erase_late_bound_regions(fn_sig.inputs_and_output());\n         inputs_output\n             .iter()"}, {"sha": "4bb401273c4002b535178f015c28f4540d13cef6", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -1911,10 +1911,10 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<S\n     let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n     let expr_kind = expr_type.kind();\n     let is_primitive = match expr_kind {\n-        rustc_ty::Slice(element_type) => is_recursively_primitive_type(element_type),\n+        rustc_ty::Slice(element_type) => is_recursively_primitive_type(*element_type),\n         rustc_ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), &rustc_ty::Slice(_)) => {\n             if let rustc_ty::Slice(element_type) = inner_ty.kind() {\n-                is_recursively_primitive_type(element_type)\n+                is_recursively_primitive_type(*element_type)\n             } else {\n                 unreachable!()\n             }"}, {"sha": "c039fec955db9d2641fc86e43ce772da69f04021", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -149,7 +149,7 @@ fn check_rvalue<'tcx>(\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc_middle::ty::cast::CastTy;\n             let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n-            let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+            let cast_out = CastTy::from_ty(*cast_ty).expect(\"bad output type for cast\");\n             match (cast_in, cast_out) {\n                 (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n                     Err((span, \"casting pointers to ints is unstable in const fn\".into()))"}, {"sha": "b44899e6bd587235a64fbbb5fc2f4e066ec5759e", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -103,7 +103,7 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n     ];\n \n     let ty_to_check = match probably_ref_ty.kind() {\n-        ty::Ref(_, ty_to_check, _) => ty_to_check,\n+        ty::Ref(_, ty_to_check, _) => *ty_to_check,\n         _ => probably_ref_ty,\n     };\n \n@@ -209,7 +209,7 @@ fn is_normalizable_helper<'tcx>(\n     ty: Ty<'tcx>,\n     cache: &mut FxHashMap<Ty<'tcx>, bool>,\n ) -> bool {\n-    if let Some(&cached_result) = cache.get(ty) {\n+    if let Some(&cached_result) = cache.get(&ty) {\n         return cached_result;\n     }\n     // prevent recursive loops, false-negative is better than endless loop leading to stack overflow\n@@ -252,7 +252,7 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n     match ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n         ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(*inner_type),\n         ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n         _ => false,\n     }\n@@ -318,7 +318,7 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n         if let ty::Ref(_, ty, _) = ty.kind() {\n-            peel(ty, count + 1)\n+            peel(*ty, count + 1)\n         } else {\n             (ty, count)\n         }\n@@ -331,8 +331,8 @@ pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n     fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {\n         match ty.kind() {\n-            ty::Ref(_, ty, Mutability::Mut) => f(ty, count + 1, mutability),\n-            ty::Ref(_, ty, Mutability::Not) => f(ty, count + 1, Mutability::Not),\n+            ty::Ref(_, ty, Mutability::Mut) => f(*ty, count + 1, mutability),\n+            ty::Ref(_, ty, Mutability::Not) => f(*ty, count + 1, Mutability::Not),\n             _ => (ty, count, mutability),\n         }\n     }\n@@ -360,7 +360,7 @@ pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n         match ty.kind() {\n-            ty::Ref(_, ty, _) => inner(ty, depth + 1),\n+            ty::Ref(_, ty, _) => inner(*ty, depth + 1),\n             _ => (ty, depth),\n         }\n     }\n@@ -394,7 +394,7 @@ pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n /// Checks if a given type looks safe to be uninitialized.\n pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     match ty.kind() {\n-        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n+        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, *component),\n         ty::Tuple(types) => types.types().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n         ty::Adt(adt, _) => cx.tcx.lang_items().maybe_uninit() == Some(adt.did),\n         _ => false,"}, {"sha": "828bf4cbef9481526edc8840762be8421397dbe7", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/e9a0c429c5da5a34c0469117774fe32694a0281c/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=e9a0c429c5da5a34c0469117774fe32694a0281c", "patch": "@@ -26,7 +26,7 @@ Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for ex\n - does it implement a trait?\n \n This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckResults`][TypeckResults] struct,\n-that gives you access to the underlying structure [`TyS`][TyS].\n+that gives you access to the underlying structure [`Ty`][Ty].\n \n Example of use:\n ```rust\n@@ -259,7 +259,7 @@ expression with a different context from `a`.\n    assert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n    ```\n \n-[TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html\n+[Ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html\n [TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n [TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n [expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty"}]}