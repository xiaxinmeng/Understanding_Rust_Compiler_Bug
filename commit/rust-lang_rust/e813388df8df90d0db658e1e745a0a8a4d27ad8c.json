{"sha": "e813388df8df90d0db658e1e745a0a8a4d27ad8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MTMzODhkZjhkZjkwZDBkYjY1OGUxZTc0NWEwYThhNGQyN2FkOGM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-07T06:18:29Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-07T06:18:29Z"}, "message": "Numerous bug fixes to typestate algorithm.", "tree": {"sha": "7920e0bc4d38fdb418c452388afda0e4b6f55f63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7920e0bc4d38fdb418c452388afda0e4b6f55f63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e813388df8df90d0db658e1e745a0a8a4d27ad8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e813388df8df90d0db658e1e745a0a8a4d27ad8c", "html_url": "https://github.com/rust-lang/rust/commit/e813388df8df90d0db658e1e745a0a8a4d27ad8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e813388df8df90d0db658e1e745a0a8a4d27ad8c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3cfbdadddd3252afa2d61a4273cc68684c47308", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3cfbdadddd3252afa2d61a4273cc68684c47308", "html_url": "https://github.com/rust-lang/rust/commit/d3cfbdadddd3252afa2d61a4273cc68684c47308"}], "stats": {"total": 222, "additions": 139, "deletions": 83}, "files": [{"sha": "6f7a300f5a536af957130f17c5d424bae86399ab", "filename": "src/boot/me/typestate.ml", "status": "modified", "additions": 116, "deletions": 83, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/e813388df8df90d0db658e1e745a0a8a4d27ad8c/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/e813388df8df90d0db658e1e745a0a8a4d27ad8c/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=e813388df8df90d0db658e1e745a0a8a4d27ad8c", "patch": "@@ -304,6 +304,11 @@ let condition_assigning_visitor\n       raise_bits bitv keys\n   in\n \n+  let raise_pre_post_cond (id:node_id) (keys:constr_key array) : unit =\n+    raise_precondition id keys;\n+    raise_postcondition id keys;\n+  in\n+\n   let resolve_constr_to_key\n       (formal_base:node_id option)\n       (constr:Ast.constr)\n@@ -355,7 +360,7 @@ let condition_assigning_visitor\n       inner.Walk.visit_obj_drop_pre obj b\n   in\n \n-  let visit_callable_pre s dst lv args =\n+  let visit_callable_pre id dst_slot_ids lv args =\n     let referent_ty = lval_ty cx lv in\n       begin\n         match referent_ty with\n@@ -376,15 +381,13 @@ let condition_assigning_visitor\n                            slot_inits (atom_slots cx arg))\n                         args))\n               in\n-                raise_precondition s.id arg_init_keys;\n-                raise_precondition s.id constr_keys\n+                raise_pre_post_cond id arg_init_keys;\n+                raise_pre_post_cond id constr_keys\n           | _ -> ()\n       end;\n       begin\n-        let postcond =\n-          slot_inits (lval_slots cx dst)\n-        in\n-          raise_postcondition s.id postcond\n+        let postcond = slot_inits dst_slot_ids in\n+          raise_postcondition id postcond\n       end\n   in\n \n@@ -398,15 +401,15 @@ let condition_assigning_visitor\n         | Ast.STMT_recv (dst, src) ->\n             let precond = slot_inits (lval_slots cx src) in\n             let postcond = slot_inits (lval_slots cx dst) in\n-              raise_precondition s.id precond;\n+              raise_pre_post_cond s.id precond;\n               raise_postcondition s.id postcond\n \n         | Ast.STMT_send (dst, src) ->\n             let precond = Array.append\n               (slot_inits (lval_slots cx dst))\n               (slot_inits (lval_slots cx src))\n             in\n-              raise_precondition s.id precond;\n+              raise_pre_post_cond s.id precond;\n \n         | Ast.STMT_init_rec (dst, entries, base) ->\n             let base_slots =\n@@ -420,21 +423,21 @@ let condition_assigning_visitor\n               (Array.append (rec_inputs_slots cx entries) base_slots)\n             in\n             let postcond = slot_inits (lval_slots cx dst) in\n-              raise_precondition s.id precond;\n+              raise_pre_post_cond s.id precond;\n               raise_postcondition s.id postcond\n \n         | Ast.STMT_init_tup (dst, modes_atoms) ->\n             let precond = slot_inits\n               (tup_inputs_slots cx modes_atoms)\n             in\n             let postcond = slot_inits (lval_slots cx dst) in\n-              raise_precondition s.id precond;\n+              raise_pre_post_cond s.id precond;\n               raise_postcondition s.id postcond\n \n         | Ast.STMT_init_vec (dst, atoms) ->\n             let precond = slot_inits (atoms_slots cx atoms) in\n             let postcond = slot_inits (lval_slots cx dst) in\n-              raise_precondition s.id precond;\n+              raise_pre_post_cond s.id precond;\n               raise_postcondition s.id postcond\n \n         | Ast.STMT_init_str (dst, _) ->\n@@ -448,59 +451,59 @@ let condition_assigning_visitor\n         | Ast.STMT_init_chan (dst, port) ->\n             let precond = slot_inits (lval_option_slots cx port) in\n             let postcond = slot_inits (lval_slots cx dst) in\n-              raise_precondition s.id precond;\n+              raise_pre_post_cond s.id precond;\n               raise_postcondition s.id postcond\n \n         | Ast.STMT_init_box (dst, src) ->\n             let precond = slot_inits (atom_slots cx src) in\n             let postcond = slot_inits (lval_slots cx dst) in\n-              raise_precondition s.id precond;\n+              raise_pre_post_cond s.id precond;\n               raise_postcondition s.id postcond\n \n         | Ast.STMT_copy (dst, src) ->\n             let precond = slot_inits (expr_slots cx src) in\n             let postcond = slot_inits (lval_slots cx dst) in\n-              raise_precondition s.id precond;\n+              raise_pre_post_cond s.id precond;\n               raise_postcondition s.id postcond\n \n         | Ast.STMT_copy_binop (dst, _, src) ->\n             let dst_init = slot_inits (lval_slots cx dst) in\n             let src_init = slot_inits (atom_slots cx src) in\n             let precond = Array.append dst_init src_init in\n-              raise_precondition s.id precond;\n+              raise_pre_post_cond s.id precond;\n \n         | Ast.STMT_spawn (dst, _, lv, args)\n         | Ast.STMT_call (dst, lv, args) ->\n-            visit_callable_pre s dst lv args\n+            visit_callable_pre s.id (lval_slots cx dst) lv args\n \n         | Ast.STMT_bind (dst, lv, args_opt) ->\n             let args = arr_map_partial args_opt (fun a -> a) in\n-            visit_callable_pre s dst lv args\n+            visit_callable_pre s.id (lval_slots cx dst) lv args\n \n         | Ast.STMT_ret (Some at) ->\n             let precond = slot_inits (atom_slots cx at) in\n-              raise_precondition s.id precond\n+              raise_pre_post_cond s.id precond\n \n         | Ast.STMT_put (Some at) ->\n             let precond = slot_inits (atom_slots cx at) in\n-              raise_precondition s.id precond\n+              raise_pre_post_cond s.id precond\n \n         | Ast.STMT_join lval ->\n             let precond = slot_inits (lval_slots cx lval) in\n-              raise_precondition s.id precond\n+              raise_pre_post_cond s.id precond\n \n         | Ast.STMT_log atom ->\n             let precond = slot_inits (atom_slots cx atom) in\n-              raise_precondition s.id precond\n+              raise_pre_post_cond s.id precond\n \n         | Ast.STMT_check_expr expr ->\n             let precond = slot_inits (expr_slots cx expr) in\n-              raise_precondition s.id precond\n+              raise_pre_post_cond s.id precond\n \n         | Ast.STMT_while sw ->\n             let (_, expr) = sw.Ast.while_lval in\n             let precond = slot_inits (expr_slots cx expr) in\n-              raise_precondition s.id precond\n+              raise_pre_post_cond s.id precond\n \n         | Ast.STMT_alt_tag at ->\n             let precond = slot_inits (lval_slots cx at.Ast.alt_tag_lval) in\n@@ -519,17 +522,21 @@ let condition_assigning_visitor\n               in\n               raise_entry_state input_keys init_keys block\n             in\n-            raise_precondition s.id precond;\n+            raise_pre_post_cond s.id precond;\n             Array.iter visit_arm at.Ast.alt_tag_arms\n \n         | Ast.STMT_for_each fe ->\n             let (si, _) = fe.Ast.for_each_slot in\n-            let block_entry_state = [| Constr_init si.id |] in\n-              raise_postcondition fe.Ast.for_each_body.id block_entry_state\n+            let (callee, args) = fe.Ast.for_each_call in\n+              visit_callable_pre\n+                fe.Ast.for_each_body.id [| si.id |] callee args\n \n         | Ast.STMT_for fo ->\n             let (si, _) = fo.Ast.for_slot in\n+            let (_, lval) = fo.Ast.for_seq in\n+            let precond = slot_inits (lval_slots cx lval) in\n             let block_entry_state = [| Constr_init si.id |] in\n+              raise_pre_post_cond s.id precond;\n               raise_postcondition fo.Ast.for_body.id block_entry_state\n \n         | _ -> ()\n@@ -569,11 +576,20 @@ let lset_fmt lset =\n     \"]\"\n ;;\n \n+let show_node cx graph s i =\n+  iflog cx\n+    (fun _ ->\n+       log cx \"node '%s' = %d -> %s\"\n+         s (int_of_node i) (lset_fmt (Hashtbl.find graph i)))\n+;;\n+\n type node_graph = (node_id, (node_id list)) Hashtbl.t;;\n+type sibling_map = (node_id, node_id) Hashtbl.t;;\n \n let graph_sequence_building_visitor\n     (cx:ctxt)\n     (graph:node_graph)\n+    (sibs:sibling_map)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n \n@@ -586,7 +602,8 @@ let graph_sequence_building_visitor\n         let next = stmts.(i+1) in\n           log cx \"sequential stmt edge %d -> %d\"\n             (int_of_node stmt.id) (int_of_node next.id);\n-          htab_put graph stmt.id [next.id]\n+          htab_put graph stmt.id [next.id];\n+          htab_put sibs stmt.id next.id;\n       done;\n       (* Flow last node to nowhere. *)\n       if len > 0\n@@ -643,8 +660,9 @@ let last_id_or_block_id (block:Ast.block) : node_id =\n ;;\n \n let graph_general_block_structure_building_visitor\n-    ((*cx*)_:ctxt)\n+    (cx:ctxt)\n     (graph:node_graph)\n+    (sibs:sibling_map)\n     (inner:Walk.visitor)\n     : Walk.visitor =\n \n@@ -660,20 +678,14 @@ let graph_general_block_structure_building_visitor\n     ignore (Stack.pop stmts)\n   in\n \n+  let show_node = show_node cx graph in\n+\n   let visit_block_pre b =\n     begin\n-    let len = Array.length b.node in\n-\n-    (* Flow container-stmt to block, save existing out-edges for below. *)\n-    let dsts =\n-      if Stack.is_empty stmts\n-      then []\n-      else\n-        let s = Stack.top stmts in\n-        let dsts = Hashtbl.find graph s.id in\n-          add_flow_edges graph s.id [b.id];\n-          dsts\n-    in\n+      let len = Array.length b.node in\n+      let _ = htab_put graph b.id\n+        (if len > 0 then [b.node.(0).id] else [])\n+      in\n \n       (*\n        * If block has len, \n@@ -690,16 +702,21 @@ let graph_general_block_structure_building_visitor\n        *   block#n -> stmt#0 -> ... -> stmt#k -> stmt#j\n        * \n        *)\n-\n-      if len > 0\n-      then\n-        begin\n-          htab_put graph b.id [b.node.(0).id];\n-          add_flow_edges graph (last_id b.node) dsts\n-        end\n-      else\n-        htab_put graph b.id dsts\n+        if Stack.is_empty stmts\n+        then ()\n+        else\n+          let s = Stack.top stmts in\n+            add_flow_edges graph s.id [b.id];\n+            match htab_search sibs s.id with\n+                None -> ()\n+              | Some sib_id ->\n+                  if len > 0\n+                  then\n+                    add_flow_edges graph (last_id b.node) [sib_id]\n+                  else\n+                    add_flow_edges graph b.id [sib_id]\n     end;\n+    show_node \"block\" b.id;\n     inner.Walk.visit_block_pre b\n   in\n \n@@ -724,12 +741,7 @@ let graph_special_block_structure_building_visitor\n             let cond_id = s.id in\n             let then_id = sif.Ast.if_then.id in\n             let then_end_id = last_id_or_block_id sif.Ast.if_then in\n-            let show_node s i =\n-              iflog cx\n-                (fun _ ->\n-                   log cx \"node '%s' = %d -> %s\"\n-                     s (int_of_node i) (lset_fmt (Hashtbl.find graph i)))\n-            in\n+            let show_node = show_node cx graph in\n               show_node \"initial cond\" cond_id;\n               show_node \"initial then\" then_id;\n               show_node \"initial then_end\" then_end_id;\n@@ -834,7 +846,7 @@ let find_roots\n     roots\n ;;\n \n-let run_dataflow cx graph : unit =\n+let run_dataflow cx idref graph : unit =\n   let roots = find_roots graph in\n   let nodes = Queue.create () in\n   let progress = ref true in\n@@ -857,42 +869,62 @@ let run_dataflow cx graph : unit =\n           iflog cx (fun _ -> log cx\n                       \"made progress intersecting bits\"))\n   in\n-  let raise_bits dst src =\n-    if Bits.union dst src\n-    then (progress := true;\n-          iflog cx (fun _ -> log cx\n-                      \"made progress unioning bits\"))\n-  in\n   let iter = ref 0 in\n   let written = Hashtbl.create 0 in\n+  let tmp_diff = (Bits.create (!idref) false) in\n+  let tmp_poststate = (Bits.create (!idref) false) in\n     Hashtbl.iter (fun n _ -> Queue.push n nodes) roots;\n     while !progress do\n       incr iter;\n       progress := false;\n-      iflog cx (fun _ -> log cx \"dataflow pass %d\" (!iter));\n+      iflog cx (fun _ ->\n+                  log cx \"\";\n+                  log cx \"--------------------\";\n+                  log cx \"dataflow pass %d\" (!iter));\n       Queue.iter\n         begin\n           fun node ->\n             let prestate = Hashtbl.find cx.ctxt_prestates node in\n+            let precond = Hashtbl.find cx.ctxt_preconditions node in\n             let postcond = Hashtbl.find cx.ctxt_postconditions node in\n             let poststate = Hashtbl.find cx.ctxt_poststates node in\n-              iflog cx (fun _ -> log cx \"stmt %d: '%s'\" (int_of_node node)\n-                       (match htab_search cx.ctxt_all_stmts node with\n-                            None -> \"??\"\n-                          | Some stmt -> Fmt.fmt_to_str Ast.fmt_stmt stmt));\n-              iflog cx (fun _ -> log cx \"stmt %d:\" (int_of_node node));\n-              iflog cx (fun _ -> log cx\n-                          \"    prestate %s\" (fmt_constr_bitv prestate));\n-              raise_bits poststate prestate;\n-              raise_bits poststate postcond;\n-              iflog cx (fun _ -> log cx\n-                          \"    poststate %s\" (fmt_constr_bitv poststate));\n+\n+              Bits.clear tmp_poststate;\n+              ignore (Bits.union tmp_poststate prestate);\n+              ignore (Bits.union tmp_poststate precond);\n+              ignore (Bits.union tmp_poststate postcond);\n+\n+              ignore (Bits.copy tmp_diff precond);\n+              ignore (Bits.difference tmp_diff postcond);\n+              ignore (Bits.difference tmp_poststate tmp_diff);\n+\n+              iflog cx\n+                begin\n+                  fun _ ->\n+                    log cx \"stmt %d: '%s'\" (int_of_node node)\n+                      (match htab_search cx.ctxt_all_stmts node with\n+                           None -> \"??\"\n+                         | Some stmt -> Fmt.fmt_to_str Ast.fmt_stmt stmt);\n+                    log cx \"stmt %d:\" (int_of_node node);\n+\n+                    log cx \"    prestate %s\" (fmt_constr_bitv prestate);\n+                    log cx \"    precond %s\" (fmt_constr_bitv precond);\n+                    log cx \"    postcond %s\" (fmt_constr_bitv postcond);\n+                    log cx \"    poststate %s\" (fmt_constr_bitv poststate);\n+                    log cx\n+                      \"    precond - postcond %s\" (fmt_constr_bitv tmp_diff);\n+                    log cx\n+                      \"    new poststate %s\" (fmt_constr_bitv tmp_poststate)\n+                end;\n+\n+              set_bits poststate tmp_poststate;\n+\n               Hashtbl.replace written node ();\n-            let successors = Hashtbl.find graph node in\n-            let i = int_of_node node in\n-              iflog cx (fun _ -> log cx\n-                          \"out-edges for %d: %s\" i (lset_fmt successors));\n-              List.iter\n+              let successors = Hashtbl.find graph node in\n+              let i = int_of_node node in\n+                iflog cx (fun _ -> log cx\n+                            \"out-edges for %d: %s\" i (lset_fmt successors));\n+                List.iter\n                 begin\n                   fun succ ->\n                     let succ_prestates =\n@@ -1107,6 +1139,7 @@ let process_crate\n   let (scopes:(scope list) ref) = ref [] in\n   let constr_id = ref 0 in\n   let (graph:(node_id, (node_id list)) Hashtbl.t) = Hashtbl.create 0 in\n+  let sibs = Hashtbl.create 0 in\n   let setup_passes =\n     [|\n       (scope_stack_managing_visitor scopes\n@@ -1117,9 +1150,9 @@ let process_crate\n       (scope_stack_managing_visitor scopes\n          (condition_assigning_visitor cx scopes\n             Walk.empty_visitor));\n-      (graph_sequence_building_visitor cx graph\n+      (graph_sequence_building_visitor cx graph sibs\n          Walk.empty_visitor);\n-      (graph_general_block_structure_building_visitor cx graph\n+      (graph_general_block_structure_building_visitor cx graph sibs\n          Walk.empty_visitor);\n       (graph_special_block_structure_building_visitor cx graph\n          Walk.empty_visitor);\n@@ -1139,7 +1172,7 @@ let process_crate\n     |]\n   in\n     run_passes cx \"typestate setup\" path setup_passes (log cx \"%s\") crate;\n-    run_dataflow cx graph;\n+    run_dataflow cx constr_id graph;\n     run_passes cx \"typestate verify\" path verify_passes (log cx \"%s\") crate;\n     run_passes cx \"typestate aux\" path aux_passes (log cx \"%s\") crate\n ;;"}, {"sha": "27bb49021af5a3362d36a5765b775638d0a5afba", "filename": "src/boot/util/bits.ml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e813388df8df90d0db658e1e745a0a8a4d27ad8c/src%2Fboot%2Futil%2Fbits.ml", "raw_url": "https://github.com/rust-lang/rust/raw/e813388df8df90d0db658e1e745a0a8a4d27ad8c/src%2Fboot%2Futil%2Fbits.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Futil%2Fbits.ml?ref=e813388df8df90d0db658e1e745a0a8a4d27ad8c", "patch": "@@ -67,6 +67,15 @@ let invert (v:t) : unit =\n   done\n ;;\n \n+(* dst = dst - src *)\n+let difference (dst:t) (src:t) : bool =\n+  invert src;\n+  let b = intersect dst src in\n+    invert src;\n+    b\n+;;\n+\n+\n let set (v:t) (i:int) (x:bool) : unit =\n   assert (i >= 0);\n   assert (i < v.nbits);"}, {"sha": "5790bfbda6c3cff18e514aeb69a3203ee4ee4f19", "filename": "src/test/compile-fail/use-uninit.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e813388df8df90d0db658e1e745a0a8a4d27ad8c/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e813388df8df90d0db658e1e745a0a8a4d27ad8c/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-uninit.rs?ref=e813388df8df90d0db658e1e745a0a8a4d27ad8c", "patch": "@@ -0,0 +1,14 @@\n+// error-pattern:Unsatisfied precondition\n+\n+fn foo(int x) {\n+  log x;\n+}\n+\n+fn main() {\n+  let int x;\n+  if (1 > 2) {\n+    x = 10;\n+  } else {\n+  }\n+  foo(x);\n+}\n\\ No newline at end of file"}]}