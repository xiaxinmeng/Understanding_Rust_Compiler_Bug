{"sha": "06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YzYzZjZlOWUwMTU0MmQ4YzAxNzlkOTQ5OGU0ZWNjM2IyODdiNjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-03T00:14:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-03T00:14:10Z"}, "message": "Auto merge of #39927 - nikomatsakis:incr-comp-skip-borrowck-2, r=eddyb\n\ntransition borrowck to visit all **bodies** and not item-likes\n\nThis is a better structure for incremental compilation and also more compatible with the eventual borrowck mir. It also fixes #38520 as a drive-by fix.\n\nr? @eddyb", "tree": {"sha": "88b3644d5d5fb978b64ab8684e47771b51f77d17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88b3644d5d5fb978b64ab8684e47771b51f77d17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "html_url": "https://github.com/rust-lang/rust/commit/06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0b7112ba246d96f253ba845d91f36c0b7398e42", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b7112ba246d96f253ba845d91f36c0b7398e42", "html_url": "https://github.com/rust-lang/rust/commit/c0b7112ba246d96f253ba845d91f36c0b7398e42"}, {"sha": "d572aa2fd4012698097efa00db6331197f3e44ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/d572aa2fd4012698097efa00db6331197f3e44ac", "html_url": "https://github.com/rust-lang/rust/commit/d572aa2fd4012698097efa00db6331197f3e44ac"}], "stats": {"total": 667, "additions": 266, "deletions": 401}, "files": [{"sha": "4567795184e4dccf168c6a8ddf6f0f8c63ea1f20", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -32,7 +32,7 @@ struct LoopScope {\n }\n \n pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           body: &hir::Expr) -> CFG {\n+                           body: &hir::Body) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n \n@@ -43,26 +43,18 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let fn_exit = graph.add_node(CFGNodeData::Exit);\n     let body_exit;\n \n-    // Find the function this expression is from.\n-    let mut node_id = body.id;\n-    loop {\n-        let node = tcx.hir.get(node_id);\n-        if hir::map::blocks::FnLikeNode::from_node(node).is_some() {\n-            break;\n-        }\n-        let parent = tcx.hir.get_parent_node(node_id);\n-        assert!(node_id != parent);\n-        node_id = parent;\n-    }\n+    // Find the tables for this body.\n+    let owner_def_id = tcx.hir.local_def_id(tcx.hir.body_owner(body.id()));\n+    let tables = tcx.item_tables(owner_def_id);\n \n     let mut cfg_builder = CFGBuilder {\n         tcx: tcx,\n-        tables: tcx.item_tables(tcx.hir.local_def_id(node_id)),\n+        tables: tables,\n         graph: graph,\n         fn_exit: fn_exit,\n         loop_scopes: Vec::new()\n     };\n-    body_exit = cfg_builder.expr(body, entry);\n+    body_exit = cfg_builder.expr(&body.value, entry);\n     cfg_builder.add_contained_edge(body_exit, fn_exit);\n     let CFGBuilder {graph, ..} = cfg_builder;\n     CFG {graph: graph,"}, {"sha": "1473dbb1676f32411eb6e2d6b4393f5d33e4a178", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -59,7 +59,7 @@ pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n     pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         body: &hir::Expr) -> CFG {\n+                         body: &hir::Body) -> CFG {\n         construct::construct(tcx, body)\n     }\n "}, {"sha": "2777c4d248710c42c0177608b62e5224ba6db2d3", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -89,8 +89,10 @@ pub enum DepNode<D: Clone + Debug> {\n \n     // Represents the MIR for a fn; also used as the task node for\n     // things read/modify that MIR.\n+    MirKrate,\n     Mir(D),\n \n+    BorrowCheckKrate,\n     BorrowCheck(D),\n     RvalueCheck(D),\n     Reachability,\n@@ -114,6 +116,7 @@ pub enum DepNode<D: Clone + Debug> {\n     SizedConstraint(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n+    TypeckBodiesKrate,\n     TypeckTables(D),\n     UsedTraitImports(D),\n     MonomorphicConstEval(D),\n@@ -209,6 +212,9 @@ impl<D: Clone + Debug> DepNode<D> {\n \n         match *self {\n             Krate => Some(Krate),\n+            BorrowCheckKrate => Some(BorrowCheckKrate),\n+            MirKrate => Some(MirKrate),\n+            TypeckBodiesKrate => Some(TypeckBodiesKrate),\n             CollectLanguageItems => Some(CollectLanguageItems),\n             CheckStaticRecursion => Some(CheckStaticRecursion),\n             ResolveLifetimes => Some(ResolveLifetimes),"}, {"sha": "7331756f35b8e95da63c8e6667f02de9a7b0caf1", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -25,5 +25,6 @@ pub use self::dep_node::WorkProductId;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n+pub use self::visit::visit_all_bodies_in_krate;\n pub use self::visit::visit_all_item_likes_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "a34a3591c151d0e87e805a53d8b3c1cab9638d94", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -74,3 +74,13 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     };\n     krate.visit_all_item_likes(&mut tracking_visitor)\n }\n+\n+pub fn visit_all_bodies_in_krate<'a, 'tcx, C>(tcx: TyCtxt<'a, 'tcx, 'tcx>, callback: C)\n+    where C: Fn(/* body_owner */ DefId, /* body id */ hir::BodyId),\n+{\n+    let krate = tcx.hir.krate();\n+    for &body_id in &krate.body_ids {\n+        let body_owner_def_id = tcx.hir.body_owner_def_id(body_id);\n+        callback(body_owner_def_id, body_id);\n+    }\n+}"}, {"sha": "257cdb960d5293ba3e9c4fd4b7a1a21270916915", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -46,7 +46,7 @@ use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n-use util::nodemap::{DefIdMap, NodeMap, FxHashMap};\n+use util::nodemap::{DefIdMap, NodeMap};\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -78,7 +78,7 @@ pub struct LoweringContext<'a> {\n \n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n-    bodies: FxHashMap<hir::BodyId, hir::Body>,\n+    bodies: BTreeMap<hir::BodyId, hir::Body>,\n \n     trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n     trait_default_impl: BTreeMap<DefId, NodeId>,\n@@ -118,7 +118,7 @@ pub fn lower_crate(sess: &Session,\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n-        bodies: FxHashMap(),\n+        bodies: BTreeMap::new(),\n         trait_impls: BTreeMap::new(),\n         trait_default_impl: BTreeMap::new(),\n         loop_scopes: Vec::new(),\n@@ -196,6 +196,7 @@ impl<'a> LoweringContext<'a> {\n         let module = self.lower_mod(&c.module);\n         let attrs = self.lower_attrs(&c.attrs);\n         let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n+        let body_ids = body_ids(&self.bodies);\n \n         hir::Crate {\n             module: module,\n@@ -206,6 +207,7 @@ impl<'a> LoweringContext<'a> {\n             trait_items: self.trait_items,\n             impl_items: self.impl_items,\n             bodies: self.bodies,\n+            body_ids: body_ids,\n             trait_impls: self.trait_impls,\n             trait_default_impl: self.trait_default_impl,\n         }\n@@ -2524,3 +2526,11 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n }\n+\n+fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {\n+    // Sorting by span ensures that we get things in order within a\n+    // file, and also puts the files in a sensible order.\n+    let mut body_ids: Vec<_> = bodies.keys().cloned().collect();\n+    body_ids.sort_by_key(|b| bodies[b].value.span);\n+    body_ids\n+}"}, {"sha": "425953c0f4f66424902a69e01836100364948a80", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -259,6 +259,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TyKind::ImplTrait(..) => {\n                 self.create_def(ty.id, DefPathData::ImplTrait);\n             }\n+            TyKind::Typeof(ref expr) => self.visit_ast_const_integer(expr),\n             _ => {}\n         }\n         visit::walk_ty(self, ty);"}, {"sha": "bf52a036cc8b6b6b223f15bf1bc2cd53ec2068dc", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -260,7 +260,9 @@ pub enum DefPathData {\n     /// Pattern binding\n     Binding(InternedString),\n     /// An `impl Trait` type node.\n-    ImplTrait\n+    ImplTrait,\n+    /// A `typeof` type node.\n+    Typeof,\n }\n \n impl Definitions {\n@@ -387,7 +389,8 @@ impl DefPathData {\n             ClosureExpr |\n             StructCtor |\n             Initializer |\n-            ImplTrait => None\n+            ImplTrait |\n+            Typeof => None\n         }\n     }\n \n@@ -415,6 +418,7 @@ impl DefPathData {\n             StructCtor => \"{{constructor}}\",\n             Initializer => \"{{initializer}}\",\n             ImplTrait => \"{{impl-Trait}}\",\n+            Typeof => \"{{typeof}}\",\n         };\n \n         Symbol::intern(s).as_str()"}, {"sha": "5d074903b2b992c838aeb571fe5f6ba2d5dfc633", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -168,43 +168,48 @@ impl<'hir> MapEntry<'hir> {\n         })\n     }\n \n-    fn is_body_owner(self, node_id: NodeId) -> bool {\n+    fn associated_body(self) -> Option<BodyId> {\n         match self {\n             EntryItem(_, item) => {\n                 match item.node {\n                     ItemConst(_, body) |\n                     ItemStatic(.., body) |\n-                    ItemFn(_, _, _, _, _, body) => body.node_id == node_id,\n-                    _ => false\n+                    ItemFn(_, _, _, _, _, body) => Some(body),\n+                    _ => None,\n                 }\n             }\n \n             EntryTraitItem(_, item) => {\n                 match item.node {\n                     TraitItemKind::Const(_, Some(body)) |\n-                    TraitItemKind::Method(_, TraitMethod::Provided(body)) => {\n-                        body.node_id == node_id\n-                    }\n-                    _ => false\n+                    TraitItemKind::Method(_, TraitMethod::Provided(body)) => Some(body),\n+                    _ => None\n                 }\n             }\n \n             EntryImplItem(_, item) => {\n                 match item.node {\n                     ImplItemKind::Const(_, body) |\n-                    ImplItemKind::Method(_, body) => body.node_id == node_id,\n-                    _ => false\n+                    ImplItemKind::Method(_, body) => Some(body),\n+                    _ => None,\n                 }\n             }\n \n             EntryExpr(_, expr) => {\n                 match expr.node {\n-                    ExprClosure(.., body, _) => body.node_id == node_id,\n-                    _ => false\n+                    ExprClosure(.., body, _) => Some(body),\n+                    _ => None,\n                 }\n             }\n \n-            _ => false\n+            _ => None\n+        }\n+    }\n+\n+    fn is_body_owner(self, node_id: NodeId) -> bool {\n+        match self.associated_body() {\n+            Some(b) => b.node_id == node_id,\n+            None => false,\n         }\n     }\n }"}, {"sha": "c1ba688974be88a2cc94badcd2dd850d865dcb27", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -31,7 +31,7 @@ pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use util::nodemap::{NodeMap, FxHashMap, FxHashSet};\n+use util::nodemap::{NodeMap, FxHashSet};\n \n use syntax_pos::{Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n@@ -409,10 +409,15 @@ pub struct Crate {\n \n     pub trait_items: BTreeMap<TraitItemId, TraitItem>,\n     pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n-    pub bodies: FxHashMap<BodyId, Body>,\n-\n+    pub bodies: BTreeMap<BodyId, Body>,\n     pub trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n     pub trait_default_impl: BTreeMap<DefId, NodeId>,\n+\n+    /// A list of the body ids written out in the order in which they\n+    /// appear in the crate. If you're going to process all the bodies\n+    /// in the crate, you should iterate over this list rather than the keys\n+    /// of bodies.\n+    pub body_ids: Vec<BodyId>,\n }\n \n impl Crate {"}, {"sha": "cdb081ab40098655ab325fec2aa5bc29a0c2a3d2", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -19,7 +19,7 @@ use ty::{self, TyCtxt, FreeRegion, Region};\n use ty::wf::ImpliedBound;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct FreeRegionMap {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n     relation: TransitiveRelation<Region>\n@@ -30,6 +30,10 @@ impl FreeRegionMap {\n         FreeRegionMap { relation: TransitiveRelation::new() }\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        self.relation.is_empty()\n+    }\n+\n     pub fn relate_free_regions_from_implied_bounds<'tcx>(&mut self,\n                                                         implied_bounds: &[ImpliedBound<'tcx>])\n     {"}, {"sha": "a0aeb4107c156c17dd4c19cea5762942fc517a9d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -248,6 +248,11 @@ pub struct TypeckTables<'tcx> {\n     /// If any errors occurred while type-checking this body,\n     /// this field will be set to `true`.\n     pub tainted_by_errors: bool,\n+\n+    /// Stores the free-region relationships that were deduced from\n+    /// its where clauses and parameter types. These are then\n+    /// read-again by borrowck.\n+    pub free_region_map: FreeRegionMap,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -267,6 +272,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             lints: lint::LintTable::new(),\n             used_trait_imports: DefIdSet(),\n             tainted_by_errors: false,\n+            free_region_map: FreeRegionMap::new(),\n         }\n     }\n \n@@ -414,13 +420,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub region_maps: RegionMaps,\n \n-    // For each fn declared in the local crate, type check stores the\n-    // free-region relationships that were deduced from its where\n-    // clauses and parameter types. These are then read-again by\n-    // borrowck. (They are not used during trans, and hence are not\n-    // serialized or needed for cross-crate fns.)\n-    free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n-\n     pub hir: hir_map::Map<'tcx>,\n     pub maps: maps::Maps<'tcx>,\n \n@@ -645,16 +644,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n-    pub fn store_free_region_map(self, id: NodeId, map: FreeRegionMap) {\n-        if self.free_region_maps.borrow_mut().insert(id, map).is_some() {\n-            bug!(\"Tried to overwrite interned FreeRegionMap for NodeId {:?}\", id)\n-        }\n-    }\n-\n-    pub fn free_region_map(self, id: NodeId) -> FreeRegionMap {\n-        self.free_region_maps.borrow()[&id].clone()\n-    }\n-\n     pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n         value.lift_to_tcx(self)\n     }\n@@ -707,7 +696,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             types: common_types,\n             named_region_map: named_region_map,\n             region_maps: region_maps,\n-            free_region_maps: RefCell::new(FxHashMap()),\n             variance_computed: Cell::new(false),\n             trait_map: resolutions.trait_map,\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),"}, {"sha": "448be7fe9a14988bbd993520f15d0b6fdae3eea5", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -180,7 +180,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::MacroDef(..) |\n             data @ DefPathData::ClosureExpr |\n             data @ DefPathData::Binding(..) |\n-            data @ DefPathData::ImplTrait => {\n+            data @ DefPathData::ImplTrait |\n+            data @ DefPathData::Typeof => {\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n                 self.push_item_path(buffer, parent_def_id);\n                 buffer.push(&data.as_interned_str());"}, {"sha": "2559a6709440a88f5d4a7f3a5dc40843e7de907c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -2602,6 +2602,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         dep_graph::visit_all_item_likes_in_krate(self.global_tcx(), dep_node_fn, visitor);\n     }\n \n+    /// Invokes `callback` for each body in the krate. This will\n+    /// create a read edge from `DepNode::Krate` to the current task;\n+    /// it is meant to be run in the context of some global task like\n+    /// `BorrowckCrate`. The callback would then create a task like\n+    /// `BorrowckBody(DefId)` to process each individual item.\n+    pub fn visit_all_bodies_in_krate<C>(self, callback: C)\n+        where C: Fn(/* body_owner */ DefId, /* body id */ hir::BodyId),\n+    {\n+        dep_graph::visit_all_bodies_in_krate(self.global_tcx(), callback)\n+    }\n+\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "c0f681680a967b0350e27146d28486ae89a6c48b", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -27,7 +27,7 @@ use rustc::middle::mem_categorization as mc;\n use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::DUMMY_SP;\n \n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n enum Fragment {\n@@ -200,14 +200,15 @@ impl FragmentSets {\n \n pub fn instrument_move_fragments<'a, 'tcx>(this: &MoveData<'tcx>,\n                                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           sp: Span,\n                                            id: ast::NodeId) {\n     let span_err = tcx.hir.attrs(id).iter()\n                           .any(|a| a.check_name(\"rustc_move_fragments\"));\n     let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n \n     if !span_err && !print { return; }\n \n+    let sp = tcx.hir.span(id);\n+\n     let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n         for (i, mpi) in vec_rc.iter().enumerate() {\n             let lp = || this.path_loan_path(*mpi);"}, {"sha": "28b6c7a13f1713cb2c4bea107725d2e80cc4081a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -28,9 +28,6 @@ use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n-use rustc::hir::Expr;\n-use rustc::hir::intravisit;\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n use self::restrictions::RestrictionResult;\n \n@@ -514,47 +511,3 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     }\n }\n \n-/// Context used while gathering loans on static initializers\n-///\n-/// This visitor walks static initializer's expressions and makes\n-/// sure the loans being taken are sound.\n-struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    body_id: hir::BodyId,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n-        if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let infcx = self.bccx.tcx.borrowck_fake_infer_ctxt(self.body_id);\n-            let mc = mc::MemCategorizationContext::new(&infcx);\n-            let base_cmt = mc.cat_expr(&base).unwrap();\n-            let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n-            // Check that we don't allow borrows of unsafe static items.\n-            let err = check_aliasability(self.bccx, ex.span,\n-                                         BorrowViolation(euv::AddrOf),\n-                                         base_cmt, borrow_kind).is_err();\n-            if err {\n-                return; // reported an error, no sense in reporting more.\n-            }\n-        }\n-\n-        intravisit::walk_expr(self, ex);\n-    }\n-}\n-\n-pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, body: hir::BodyId) {\n-    debug!(\"gather_loans_in_static_initializer(expr={:?})\", body);\n-\n-    let mut sicx = StaticInitializerCtxt {\n-        bccx: bccx,\n-        body_id: body\n-    };\n-\n-    let body = sicx.bccx.tcx.hir.body(body);\n-    sicx.visit_body(body);\n-}"}, {"sha": "47b614a81ae251e9009fbb0543832a0082d2e19f", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 50, "deletions": 159, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -32,22 +32,20 @@ use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::hir::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n \n use std::fmt;\n-use std::mem;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n use syntax::ast;\n use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n \n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n+use rustc::hir::intravisit::{self, Visitor};\n \n pub mod check_loans;\n \n@@ -62,93 +60,14 @@ pub struct LoanDataFlowOperator;\n \n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n-impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n-    }\n-\n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n-                b: hir::BodyId, s: Span, id: ast::NodeId) {\n-        match fk {\n-            FnKind::ItemFn(..) |\n-            FnKind::Method(..) => {\n-                self.with_temp_region_map(id, |this| {\n-                    borrowck_fn(this, fk, fd, b, s, id, fk.attrs())\n-                });\n-            }\n-\n-            FnKind::Closure(..) => {\n-                borrowck_fn(self, fk, fd, b, s, id, fk.attrs());\n-            }\n-        }\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        borrowck_item(self, item);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        if let hir::TraitItemKind::Const(_, Some(expr)) = ti.node {\n-            gather_loans::gather_loans_in_static_initializer(self, expr);\n-        }\n-        intravisit::walk_trait_item(self, ti);\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        if let hir::ImplItemKind::Const(_, expr) = ii.node {\n-            gather_loans::gather_loans_in_static_initializer(self, expr);\n-        }\n-        intravisit::walk_impl_item(self, ii);\n-    }\n-}\n-\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut bccx = BorrowckCtxt {\n-        tcx: tcx,\n-        free_region_map: FreeRegionMap::new(),\n-        stats: BorrowStats {\n-            loaned_paths_same: 0,\n-            loaned_paths_imm: 0,\n-            stable_paths: 0,\n-            guaranteed_paths: 0\n-        }\n-    };\n-\n-    tcx.visit_all_item_likes_in_krate(DepNode::BorrowCheck, &mut bccx.as_deep_visitor());\n-\n-    if tcx.sess.borrowck_stats() {\n-        println!(\"--- borrowck stats ---\");\n-        println!(\"paths requiring guarantees: {}\",\n-                 bccx.stats.guaranteed_paths);\n-        println!(\"paths requiring loans     : {}\",\n-                 make_stat(&bccx, bccx.stats.loaned_paths_same));\n-        println!(\"paths requiring imm loans : {}\",\n-                 make_stat(&bccx, bccx.stats.loaned_paths_imm));\n-        println!(\"stable paths              : {}\",\n-                 make_stat(&bccx, bccx.stats.stable_paths));\n-    }\n-\n-    fn make_stat(bccx: &BorrowckCtxt, stat: usize) -> String {\n-        let total = bccx.stats.guaranteed_paths as f64;\n-        let perc = if total == 0.0 { 0.0 } else { stat as f64 * 100.0 / total };\n-        format!(\"{} ({:.0}%)\", stat, perc)\n-    }\n-}\n-\n-fn borrowck_item<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>, item: &'tcx hir::Item) {\n-    // Gather loans for items. Note that we don't need\n-    // to check loans for single expressions. The check\n-    // loan step is intended for things that have a data\n-    // flow dependent conditions.\n-    match item.node {\n-        hir::ItemStatic(.., ex) |\n-        hir::ItemConst(_, ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, ex);\n-        }\n-        _ => { }\n-    }\n-\n-    intravisit::walk_item(this, item);\n+    tcx.dep_graph.with_task(DepNode::BorrowCheckKrate, || {\n+        tcx.visit_all_bodies_in_krate(|body_owner_def_id, body_id| {\n+            tcx.dep_graph.with_task(DepNode::BorrowCheck(body_owner_def_id), || {\n+                borrowck_fn(tcx, body_id);\n+            });\n+        });\n+    });\n }\n \n /// Collection of conclusions determined via borrow checker analyses.\n@@ -158,40 +77,39 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n     pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n \n-fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                         fk: FnKind<'tcx>,\n-                         decl: &'tcx hir::FnDecl,\n-                         body_id: hir::BodyId,\n-                         sp: Span,\n-                         id: ast::NodeId,\n-                         attributes: &[ast::Attribute]) {\n-    debug!(\"borrowck_fn(id={})\", id);\n+fn borrowck_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, body_id: hir::BodyId) {\n+    debug!(\"borrowck_fn(body_id={:?})\", body_id);\n \n-    let body = this.tcx.hir.body(body_id);\n+    let owner_id = tcx.hir.body_owner(body_id);\n+    let owner_def_id = tcx.hir.local_def_id(owner_id);\n+    let attributes = tcx.get_attrs(owner_def_id);\n+    let tables = tcx.item_tables(owner_def_id);\n \n-    if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n-        this.with_temp_region_map(id, |this| {\n-            mir::borrowck_mir(this, id, attributes)\n-        });\n+    let mut bccx = &mut BorrowckCtxt {\n+        tcx: tcx,\n+        tables: tables,\n+    };\n+\n+    let body = bccx.tcx.hir.body(body_id);\n+\n+    if bccx.tcx.has_attr(owner_def_id, \"rustc_mir_borrowck\") {\n+        mir::borrowck_mir(bccx, owner_id, &attributes);\n     }\n \n-    let cfg = cfg::CFG::new(this.tcx, &body.value);\n+    let cfg = cfg::CFG::new(bccx.tcx, &body);\n     let AnalysisData { all_loans,\n                        loans: loan_dfcx,\n                        move_data: flowed_moves } =\n-        build_borrowck_dataflow_data(this, &cfg, body_id);\n+        build_borrowck_dataflow_data(bccx, &cfg, body_id);\n \n     move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n-                                                    this.tcx,\n-                                                    sp,\n-                                                    id);\n-    move_data::fragments::build_unfragmented_map(this,\n+                                                    bccx.tcx,\n+                                                    owner_id);\n+    move_data::fragments::build_unfragmented_map(bccx,\n                                                  &flowed_moves.move_data,\n-                                                 id);\n-\n-    check_loans::check_loans(this, &loan_dfcx, &flowed_moves, &all_loans[..], body);\n+                                                 owner_id);\n \n-    intravisit::walk_fn(this, fk, decl, body_id, sp, id);\n+    check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans[..], body);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n@@ -241,23 +159,20 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    body: hir::BodyId,\n+    body_id: hir::BodyId,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n+    let owner_id = tcx.hir.body_owner(body_id);\n+    let owner_def_id = tcx.hir.local_def_id(owner_id);\n+    let tables = tcx.item_tables(owner_def_id);\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        free_region_map: FreeRegionMap::new(),\n-        stats: BorrowStats {\n-            loaned_paths_same: 0,\n-            loaned_paths_imm: 0,\n-            stable_paths: 0,\n-            guaranteed_paths: 0\n-        }\n+        tables: tables,\n     };\n \n-    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, cfg, body);\n+    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, cfg, body_id);\n     (bccx, dataflow_data)\n }\n \n@@ -267,28 +182,9 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n-    // Hacky. As we visit various fns, we have to load up the\n-    // free-region map for each one. This map is computed by during\n-    // typeck for each fn item and stored -- closures just use the map\n-    // from the fn item that encloses them. Since we walk the fns in\n-    // order, we basically just overwrite this field as we enter a fn\n-    // item and restore it afterwards in a stack-like fashion. Then\n-    // the borrow checking code can assume that `free_region_map` is\n-    // always the correct map for the current fn. Feels like it'd be\n-    // better to just recompute this, rather than store it, but it's a\n-    // bit of a pain to factor that code out at the moment.\n-    free_region_map: FreeRegionMap,\n-\n-    // Statistics:\n-    stats: BorrowStats\n-}\n-\n-#[derive(Clone)]\n-struct BorrowStats {\n-    loaned_paths_same: usize,\n-    loaned_paths_imm: usize,\n-    stable_paths: usize,\n-    guaranteed_paths: usize\n+    // tables for the current thing we are checking; set to\n+    // Some in `borrowck_fn` and cleared later\n+    tables: &'a ty::TypeckTables<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -574,19 +470,12 @@ pub enum MovedValueUseKind {\n // Misc\n \n impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n-    fn with_temp_region_map<F>(&mut self, id: ast::NodeId, f: F)\n-        where F: for <'b> FnOnce(&'b mut BorrowckCtxt<'a, 'tcx>)\n-    {\n-        let new_free_region_map = self.tcx.free_region_map(id);\n-        let old_free_region_map = mem::replace(&mut self.free_region_map, new_free_region_map);\n-        f(self);\n-        self.free_region_map = old_free_region_map;\n-    }\n-\n-    pub fn is_subregion_of(&self, r_sub: &'tcx ty::Region, r_sup: &'tcx ty::Region)\n+    pub fn is_subregion_of(&self,\n+                           r_sub: &'tcx ty::Region,\n+                           r_sup: &'tcx ty::Region)\n                            -> bool\n     {\n-        self.free_region_map.is_subregion_of(self.tcx, r_sub, r_sup)\n+        self.tables.free_region_map.is_subregion_of(self.tcx, r_sub, r_sup)\n     }\n \n     pub fn report(&self, err: BckError<'tcx>) {\n@@ -912,11 +801,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n             mc::AliasableStatic |\n             mc::AliasableStaticMut => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, span, E0388,\n-                    \"{} in a static location\", prefix);\n-                err.span_label(span, &format!(\"cannot write data in a static definition\"));\n-                err\n+                // This path cannot occur. It happens when we have an\n+                // `&mut` or assignment to a static. But in the case\n+                // of `static X`, we get a mutability violation first,\n+                // and never get here. In the case of `static mut X`,\n+                // that is unsafe and hence the aliasability error is\n+                // ignored.\n+                span_bug!(span, \"aliasability violation for static `{}`\", prefix)\n             }\n             mc::AliasableBorrowed => {\n                 let mut e = struct_span_err!("}, {"sha": "db4a1701e976b9ec4f9ff1506c05265986157675", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -287,27 +287,7 @@ https://doc.rust-lang.org/std/cell/\n \"##,\n \n E0388: r##\"\n-A mutable borrow was attempted in a static location.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0388\n-static X: i32 = 1;\n-\n-static STATIC_REF: &'static mut i32 = &mut X;\n-// error: cannot borrow data mutably in a static location\n-\n-const CONST_REF: &'static mut i32 = &mut X;\n-// error: cannot borrow data mutably in a static location\n-```\n-\n-To fix this error, you have to use constant borrow:\n-\n-```\n-static X: i32 = 1;\n-\n-static STATIC_REF: &'static i32 = &X;\n-```\n+E0388 was removed and is no longer issued.\n \"##,\n \n E0389: r##\""}, {"sha": "3dce4398f3b91838a6eec3ef2a3ae3d93ca02c81", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -28,6 +28,7 @@\n #![feature(shared)]\n #![feature(collections_range)]\n #![feature(collections_bound)]\n+#![cfg_attr(stage0,feature(field_init_shorthand))]\n #![feature(nonzero)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "2bce7faf08cec45b91c9654ed4244b0d64383ef3", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use bitvec::BitMatrix;\n+use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use std::cell::RefCell;\n use std::fmt::Debug;\n use std::mem;\n@@ -36,10 +37,10 @@ pub struct TransitiveRelation<T: Debug + PartialEq> {\n     closure: RefCell<Option<BitMatrix>>,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd)]\n+#[derive(Clone, PartialEq, PartialOrd, RustcEncodable, RustcDecodable)]\n struct Index(usize);\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n struct Edge {\n     source: Index,\n     target: Index,\n@@ -54,6 +55,10 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n         }\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        self.edges.is_empty()\n+    }\n+\n     fn index(&self, a: &T) -> Option<Index> {\n         self.elements.iter().position(|e| *e == *a).map(Index)\n     }\n@@ -305,6 +310,30 @@ fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n     }\n }\n \n+impl<T> Encodable for TransitiveRelation<T>\n+    where T: Encodable + Debug + PartialEq\n+{\n+    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.emit_struct(\"TransitiveRelation\", 2, |s| {\n+            s.emit_struct_field(\"elements\", 0, |s| self.elements.encode(s))?;\n+            s.emit_struct_field(\"edges\", 1, |s| self.edges.encode(s))?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<T> Decodable for TransitiveRelation<T>\n+    where T: Decodable + Debug + PartialEq\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        d.read_struct(\"TransitiveRelation\", 2, |d| {\n+            let elements = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n+            let edges = d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?;\n+            Ok(TransitiveRelation { elements, edges, closure: RefCell::new(None) })\n+        })\n+    }\n+}\n+\n #[test]\n fn test_one_step() {\n     let mut relation = TransitiveRelation::new();"}, {"sha": "9810f121ef2c125570c4df911f625e6b7ae2510a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -24,6 +24,7 @@\n #![deny(warnings)]\n \n #![feature(box_syntax)]\n+#![feature(loop_break_value)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "b6978478085d5b224607c90a0acc898c17ad712b", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -718,13 +718,24 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                                        mode: PpFlowGraphMode,\n                                        mut out: W)\n                                        -> io::Result<()> {\n-    let cfg = match code {\n-        blocks::Code::Expr(expr) => cfg::CFG::new(tcx, expr),\n-        blocks::Code::FnLike(fn_like) => {\n-            let body = tcx.hir.body(fn_like.body());\n-            cfg::CFG::new(tcx, &body.value)\n-        },\n+    let body_id = match code {\n+        blocks::Code::Expr(expr) => {\n+            // Find the function this expression is from.\n+            let mut node_id = expr.id;\n+            loop {\n+                let node = tcx.hir.get(node_id);\n+                if let Some(n) = hir::map::blocks::FnLikeNode::from_node(node) {\n+                    break n.body();\n+                }\n+                let parent = tcx.hir.get_parent_node(node_id);\n+                assert!(node_id != parent);\n+                node_id = parent;\n+            }\n+        }\n+        blocks::Code::FnLike(fn_like) => fn_like.body(),\n     };\n+    let body = tcx.hir.body(body_id);\n+    let cfg = cfg::CFG::new(tcx, &body);\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n         hir_map: &tcx.hir,"}, {"sha": "8a8d2bd512b25e2f018409a966b3c34a0d82f0b8", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -1143,9 +1143,9 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             trait_items: _,\n             impl_items: _,\n             bodies: _,\n-\n             trait_impls: _,\n             trait_default_impl: _,\n+            body_ids: _,\n         } = *krate;\n \n         visit::Visitor::visit_mod(self, module, span, ast::CRATE_NODE_ID);"}, {"sha": "58336f939d1228e4f550d603ddc93d8f29c5dc7c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -712,7 +712,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n         // to have behaviour like the above, rather than\n         // e.g. accidentally recurring after an assert.\n \n-        let cfg = cfg::CFG::new(cx.tcx, &body.value);\n+        let cfg = cfg::CFG::new(cx.tcx, &body);\n \n         let mut work_queue = vec![cfg.entry];\n         let mut reached_exit_without_self_call = false;"}, {"sha": "a41489ff89ff46a24d804ebb4f1fca59966f5d3d", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -30,7 +30,6 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::subst::Substs;\n use rustc::hir;\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -39,9 +38,11 @@ use std::cell::RefCell;\n use std::mem;\n \n pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_item_likes_in_krate(DepNode::Mir, &mut BuildMir {\n-        tcx: tcx\n-    }.as_deep_visitor());\n+    tcx.dep_graph.with_task(DepNode::MirKrate, || {\n+        tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n+            tcx.item_mir(body_owner_def_id);\n+        });\n+    });\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -180,23 +181,6 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-struct BuildMir<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        self.tcx.item_mir(self.tcx.hir.body_owner_def_id(body_id));\n-\n-        let body = self.tcx.hir.body(body_id);\n-        self.visit_body(body);\n-    }\n-}\n-\n fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: hir::BodyId)"}, {"sha": "ec94e1f75e08c7691be467b0cf999efc0bb0bd21", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 70, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -515,76 +515,13 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n-struct CheckItemBodiesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n-\n-impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir)\n-    }\n \n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_type(self.tcx, i);\n-        intravisit::walk_item(self, i);\n-    }\n-\n-    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        match t.node {\n-            hir::TyArray(_, length) => {\n-                self.tcx.item_tables(self.tcx.hir.local_def_id(length.node_id));\n-            }\n-            _ => {}\n-        }\n-\n-        intravisit::walk_ty(self, t);\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n-        match e.node {\n-            hir::ExprRepeat(_, count) => {\n-                self.tcx.item_tables(self.tcx.hir.local_def_id(count.node_id));\n-            }\n-            _ => {}\n-        }\n-\n-        intravisit::walk_expr(self, e);\n-    }\n-}\n-\n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        match item.node {\n-            hir::ItemFn(..) => {\n-                self.tcx.item_tables(self.tcx.hir.local_def_id(item.id));\n-            }\n-            _ => { }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        match trait_item.node {\n-            hir::TraitItemKind::Const(_, Some(_)) |\n-            hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => {\n-                self.tcx.item_tables(self.tcx.hir.local_def_id(trait_item.id));\n-            }\n-            hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n-            hir::TraitItemKind::Const(_, None) |\n-            hir::TraitItemKind::Type(..) => {\n-                // Nothing to do.\n-            }\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        match impl_item.node {\n-            hir::ImplItemKind::Const(..) |\n-            hir::ImplItemKind::Method(..) => {\n-                self.tcx.item_tables(self.tcx.hir.local_def_id(impl_item.id));\n-            }\n-            hir::ImplItemKind::Type(_) => {\n-                // Nothing to do here.\n-            }\n-        }\n     }\n+    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) { }\n+    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) { }\n }\n \n pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n@@ -596,16 +533,18 @@ pub fn check_wf_new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n \n pub fn check_item_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n     tcx.sess.track_errors(|| {\n-        let mut visit = CheckItemTypesVisitor { tcx: tcx };\n         tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemType,\n-                                              &mut visit.as_deep_visitor());\n+                                          &mut CheckItemTypesVisitor { tcx });\n     })\n }\n \n pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n     tcx.sess.track_errors(|| {\n-        let mut visit = CheckItemBodiesVisitor { tcx: tcx };\n-        tcx.visit_all_item_likes_in_krate(DepNode::TypeckTables, &mut visit);\n+        tcx.dep_graph.with_task(DepNode::TypeckBodiesKrate, || {\n+            tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n+                tcx.item_tables(body_owner_def_id);\n+            });\n+        });\n     })\n }\n "}, {"sha": "8bfb390bd2a5514d76727cc528c2c6b968c4dec8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -120,6 +120,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             rcx.visit_region_obligations(id);\n         }\n         rcx.resolve_regions_and_report_errors();\n+\n+        assert!(self.tables.borrow().free_region_map.is_empty());\n+        self.tables.borrow_mut().free_region_map = rcx.free_region_map;\n     }\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n@@ -154,10 +157,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         rcx.resolve_regions_and_report_errors();\n \n-        // For the top-level fn, store the free-region-map. We don't store\n-        // any map for closures; they just share the same map as the\n-        // function that created them.\n-        self.tcx.store_free_region_map(fn_id, rcx.free_region_map);\n+        // In this mode, we also copy the free-region-map into the\n+        // tables of the enclosing fcx. In the other regionck modes\n+        // (e.g., `regionck_item`), we don't have an enclosing tables.\n+        assert!(self.tables.borrow().free_region_map.is_empty());\n+        self.tables.borrow_mut().free_region_map = rcx.free_region_map;\n     }\n }\n "}, {"sha": "7fffbd14e216056b71596c1a95ec092d9c31a1a7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -50,6 +50,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_type_nodes();\n         wbcx.visit_cast_types();\n         wbcx.visit_lints();\n+        wbcx.visit_free_region_map();\n \n         let used_trait_imports = mem::replace(&mut self.tables.borrow_mut().used_trait_imports,\n                                               DefIdSet());\n@@ -274,6 +275,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tables.borrow_mut().lints.transfer(&mut self.tables.lints);\n     }\n \n+    fn visit_free_region_map(&mut self) {\n+        self.tables.free_region_map = self.fcx.tables.borrow().free_region_map.clone();\n+    }\n+\n     fn visit_anon_types(&mut self) {\n         let gcx = self.tcx().global_tcx();\n         for (&node_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {"}, {"sha": "1f622235af4b07c8502dbf621e300b954dfa9def", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -1147,6 +1147,7 @@ fn ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeExpr(_) => match tcx.hir.get(tcx.hir.get_parent_node(node_id)) {\n             NodeTy(&hir::Ty { node: TyArray(_, body), .. }) |\n+            NodeTy(&hir::Ty { node: TyTypeof(body), .. }) |\n             NodeExpr(&hir::Expr { node: ExprRepeat(_, body), .. })\n                 if body.node_id == node_id => tcx.types.usize,\n "}, {"sha": "c6bec6090f242a1024ecb22d46eca907e20ad33a", "filename": "src/test/compile-fail/E0017.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fcompile-fail%2FE0017.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fcompile-fail%2FE0017.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0017.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -19,8 +19,7 @@ static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n                                               //~| NOTE statics require immutable values\n                                               //~| ERROR E0017\n                                               //~| NOTE statics require immutable values\n-                                              //~| ERROR E0388\n-                                              //~| NOTE cannot write data in a static definition\n+                                              //~| ERROR cannot borrow\n static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n                                              //~| NOTE statics require immutable values\n                                              //~| ERROR E0017"}, {"sha": "2c88039d373e59ef77ecc11fc195fc883dec494f", "filename": "src/test/compile-fail/E0388.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fcompile-fail%2FE0388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fcompile-fail%2FE0388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0388.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -15,7 +15,7 @@ const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n                                      //~| ERROR E0017\n static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n                                               //~| ERROR E0017\n-                                              //~| ERROR E0388\n+                                              //~| ERROR cannot borrow\n static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0017\n                                              //~| ERROR E0017\n "}, {"sha": "3c1980e5b366cc9894c92e3f3307ee75e7174e14", "filename": "src/test/compile-fail/borrowck/move-in-static-initializer-issue-38520.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fmove-in-static-initializer-issue-38520.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fmove-in-static-initializer-issue-38520.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fmove-in-static-initializer-issue-38520.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #38520. Check that moves of `Foo` are not\n+// permitted as `Foo` is not copy (even in a static/const\n+// initializer).\n+\n+#![feature(const_fn)]\n+\n+struct Foo(usize);\n+\n+const fn get(x: Foo) -> usize {\n+    x.0\n+}\n+\n+const X: Foo = Foo(22);\n+static Y: usize = get(*&X); //~ ERROR E0507\n+const Z: usize = get(*&X); //~ ERROR E0507\n+\n+fn main() {\n+}"}, {"sha": "35e57dffb6c455c776dab8084a221f197cb22ba1", "filename": "src/test/compile-fail/issue-18118.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -13,6 +13,6 @@ pub fn main() {\n         //~^ ERROR blocks in constants are limited to items and tail expressions\n         let p = 3;\n         //~^ ERROR blocks in constants are limited to items and tail expressions\n-        &p\n+        &p //~ ERROR `p` does not live long enough\n     };\n }"}, {"sha": "01364c0714407a029e76bd967554e341a2c11f8a", "filename": "src/test/ui/span/mut-arg-hint.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06c63f6e9e01542d8c0179d9498e4ecc3b287b66/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.stderr?ref=06c63f6e9e01542d8c0179d9498e4ecc3b287b66", "patch": "@@ -1,11 +1,3 @@\n-error: cannot borrow immutable borrowed content `*a` as mutable\n-  --> $DIR/mut-arg-hint.rs:18:5\n-   |\n-17 | pub fn foo<'a>(mut a: &'a String) {\n-   |                       ---------- use `&'a mut String` here to make mutable\n-18 |     a.push_str(\"foo\");\n-   |     ^ cannot borrow as mutable\n-\n error: cannot borrow immutable borrowed content `*a` as mutable\n   --> $DIR/mut-arg-hint.rs:13:9\n    |\n@@ -14,6 +6,14 @@ error: cannot borrow immutable borrowed content `*a` as mutable\n 13 |         a.push_str(\"bar\");\n    |         ^ cannot borrow as mutable\n \n+error: cannot borrow immutable borrowed content `*a` as mutable\n+  --> $DIR/mut-arg-hint.rs:18:5\n+   |\n+17 | pub fn foo<'a>(mut a: &'a String) {\n+   |                       ---------- use `&'a mut String` here to make mutable\n+18 |     a.push_str(\"foo\");\n+   |     ^ cannot borrow as mutable\n+\n error: cannot borrow immutable borrowed content `*a` as mutable\n   --> $DIR/mut-arg-hint.rs:25:9\n    |"}]}