{"sha": "9529ab0e7e469940db890604060c073179db8464", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MjlhYjBlN2U0Njk5NDBkYjg5MDYwNDA2MGMwNzMxNzlkYjg0NjQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-02T18:56:55Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-02T18:56:55Z"}, "message": "rollup merge of #21710: alfie/libsyntax\n\nConflicts:\n\tsrc/libsyntax/parse/parser.rs", "tree": {"sha": "ba8b6878fdc2b35faaa3a970e978820dca950db7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba8b6878fdc2b35faaa3a970e978820dca950db7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9529ab0e7e469940db890604060c073179db8464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9529ab0e7e469940db890604060c073179db8464", "html_url": "https://github.com/rust-lang/rust/commit/9529ab0e7e469940db890604060c073179db8464", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9529ab0e7e469940db890604060c073179db8464/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c468b69aed6c85ca4c15e178ade44633acedce6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c468b69aed6c85ca4c15e178ade44633acedce6", "html_url": "https://github.com/rust-lang/rust/commit/8c468b69aed6c85ca4c15e178ade44633acedce6"}, {"sha": "9683745fed09daf7f8acc55d679b41d3bc660ec4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9683745fed09daf7f8acc55d679b41d3bc660ec4", "html_url": "https://github.com/rust-lang/rust/commit/9683745fed09daf7f8acc55d679b41d3bc660ec4"}], "stats": {"total": 284, "additions": 142, "deletions": 142}, "files": [{"sha": "252dbfd964a6b96029fd1869e519819ff5b54a4a", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -322,21 +322,21 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n pub fn operator_prec(op: ast::BinOp_) -> usize {\n   match op {\n       // 'as' sits here with 12\n-      BiMul | BiDiv | BiRem     => 11us,\n-      BiAdd | BiSub             => 10us,\n-      BiShl | BiShr             =>  9us,\n-      BiBitAnd                  =>  8us,\n-      BiBitXor                  =>  7us,\n-      BiBitOr                   =>  6us,\n-      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3us,\n-      BiAnd                     =>  2us,\n-      BiOr                      =>  1us\n+      BiMul | BiDiv | BiRem     => 11,\n+      BiAdd | BiSub             => 10,\n+      BiShl | BiShr             =>  9,\n+      BiBitAnd                  =>  8,\n+      BiBitXor                  =>  7,\n+      BiBitOr                   =>  6,\n+      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3,\n+      BiAnd                     =>  2,\n+      BiOr                      =>  1\n   }\n }\n \n /// Precedence of the `as` operator, which is a binary operator\n /// not appearing in the prior table.\n-pub const AS_PREC: usize = 12us;\n+pub const AS_PREC: usize = 12;\n \n pub fn empty_generics() -> Generics {\n     Generics {"}, {"sha": "13b6a7a037a6c01f0ea268ca88b705be4ebf7e96", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -431,7 +431,7 @@ impl CodeMap {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = Vec::new();\n-        for i in lo.line - 1us..hi.line as usize {\n+        for i in lo.line - 1..hi.line as usize {\n             lines.push(i);\n         };\n         FileLines {file: lo.file, lines: lines}\n@@ -499,10 +499,10 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let files = &*files;\n         let len = files.len();\n-        let mut a = 0us;\n+        let mut a = 0;\n         let mut b = len;\n-        while b - a > 1us {\n-            let m = (a + b) / 2us;\n+        while b - a > 1 {\n+            let m = (a + b) / 2;\n             if files[m].start_pos > pos {\n                 b = m;\n             } else {\n@@ -538,12 +538,12 @@ impl CodeMap {\n \n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n-        let mut a = 0us;\n+        let mut a = 0;\n         {\n             let lines = f.lines.borrow();\n             let mut b = lines.len();\n-            while b - a > 1us {\n-                let m = (a + b) / 2us;\n+            while b - a > 1 {\n+                let m = (a + b) / 2;\n                 if (*lines)[m] > pos { b = m; } else { a = m; }\n             }\n         }\n@@ -552,7 +552,7 @@ impl CodeMap {\n \n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n-        let line = a + 1us; // Line numbers start at 1\n+        let line = a + 1; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n         let linebpos = (*f.lines.borrow())[a];\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n@@ -763,7 +763,7 @@ mod test {\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(file_lines.lines[0], 1us);\n+        assert_eq!(file_lines.lines[0], 1);\n     }\n \n     #[test]"}, {"sha": "f920ca9e233c9d303d6fd8edee9d5aecb6ee1a0b", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -25,7 +25,7 @@ use term::WriterWrapper;\n use term;\n \n /// maximum number of lines we will print for each error; arbitrary.\n-static MAX_LINES: usize = 6us;\n+static MAX_LINES: usize = 6;\n \n #[derive(Clone, Copy)]\n pub enum RenderSpan {\n@@ -155,19 +155,19 @@ impl Handler {\n         self.bump_err_count();\n     }\n     pub fn bump_err_count(&self) {\n-        self.err_count.set(self.err_count.get() + 1us);\n+        self.err_count.set(self.err_count.get() + 1);\n     }\n     pub fn err_count(&self) -> usize {\n         self.err_count.get()\n     }\n     pub fn has_errors(&self) -> bool {\n-        self.err_count.get() > 0us\n+        self.err_count.get() > 0\n     }\n     pub fn abort_if_errors(&self) {\n         let s;\n         match self.err_count.get() {\n-          0us => return,\n-          1us => s = \"aborting due to previous error\".to_string(),\n+          0 => return,\n+          1 => s = \"aborting due to previous error\".to_string(),\n           _   => {\n             s = format!(\"aborting due to {} previous errors\",\n                         self.err_count.get());\n@@ -457,7 +457,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let mut elided = false;\n     let mut display_lines = &lines.lines[];\n     if display_lines.len() > MAX_LINES {\n-        display_lines = &display_lines[0us..MAX_LINES];\n+        display_lines = &display_lines[0..MAX_LINES];\n         elided = true;\n     }\n     // Print the offending lines\n@@ -468,32 +468,32 @@ fn highlight_lines(err: &mut EmitterWriter,\n         }\n     }\n     if elided {\n-        let last_line = display_lines[display_lines.len() - 1us];\n-        let s = format!(\"{}:{} \", fm.name, last_line + 1us);\n+        let last_line = display_lines[display_lines.len() - 1];\n+        let s = format!(\"{}:{} \", fm.name, last_line + 1);\n         try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n     // FIXME (#3260)\n     // If there's one line at fault we can easily point to the problem\n-    if lines.lines.len() == 1us {\n+    if lines.lines.len() == 1 {\n         let lo = cm.lookup_char_pos(sp.lo);\n-        let mut digits = 0us;\n-        let mut num = (lines.lines[0] + 1us) / 10us;\n+        let mut digits = 0;\n+        let mut num = (lines.lines[0] + 1) / 10;\n \n         // how many digits must be indent past?\n-        while num > 0us { num /= 10us; digits += 1us; }\n+        while num > 0 { num /= 10; digits += 1; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let left = fm.name.len() + digits + lo.col.to_usize() + 3us;\n+        let left = fm.name.len() + digits + lo.col.to_usize() + 3;\n         let mut s = String::new();\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n-        let skip = fm.name.len() + digits + 3us;\n+        let skip = fm.name.len() + digits + 3;\n         for _ in 0..skip {\n             s.push(' ');\n         }\n         if let Some(orig) = fm.get_line(lines.lines[0]) {\n-            for pos in 0us..left - skip {\n+            for pos in 0..left - skip {\n                 let cur_char = orig.as_bytes()[pos] as char;\n                 // Whenever a tab occurs on the previous line, we insert one on\n                 // the error-point-squiggly-line as well (instead of a space).\n@@ -511,7 +511,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n-            let num_squigglies = hi.col.to_usize() - lo.col.to_usize() - 1us;\n+            let num_squigglies = hi.col.to_usize() - lo.col.to_usize() - 1;\n             for _ in 0..num_squigglies {\n                 s.push('~');\n             }"}, {"sha": "dc88ce6d1907cebd2a5d25c1c3d432603e35f182", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -770,7 +770,7 @@ impl<'a> MethodDef<'a> {\n         let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = Vec::new();\n-        for i in 0us..self_args.len() {\n+        for i in 0..self_args.len() {\n             let struct_path= cx.path(DUMMY_SP, vec!( type_ident ));\n             let (pat, ident_expr) =\n                 trait_.create_struct_pattern(cx,\n@@ -859,8 +859,8 @@ impl<'a> MethodDef<'a> {\n     ///             (&A2(ref __self_0),\n     ///              &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n     ///             _ => {\n-    ///                 let __self_vi = match *self { A1(..) => 0us, A2(..) => 1us };\n-    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0us, A2(..) => 1us };\n+    ///                 let __self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n+    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0, A2(..) => 1 };\n     ///                 false\n     ///             }\n     ///         }\n@@ -904,8 +904,8 @@ impl<'a> MethodDef<'a> {\n     ///   (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n     ///   ...\n     ///   _ => {\n-    ///     let __this_vi = match this { Variant1 => 0us, Variant2 => 1us, ... };\n-    ///     let __that_vi = match that { Variant1 => 0us, Variant2 => 1us, ... };\n+    ///     let __this_vi = match this { Variant1 => 0, Variant2 => 1, ... };\n+    ///     let __that_vi = match that { Variant1 => 0, Variant2 => 1, ... };\n     ///     ... // catch-all remainder can inspect above variant index values.\n     ///   }\n     /// }\n@@ -1067,13 +1067,13 @@ impl<'a> MethodDef<'a> {\n             //\n             // ```\n             // let __self0_vi = match   self {\n-            //     A => 0us, B(..) => 1us, C(..) => 2us\n+            //     A => 0, B(..) => 1, C(..) => 2\n             // };\n             // let __self1_vi = match __arg1 {\n-            //     A => 0us, B(..) => 1us, C(..) => 2us\n+            //     A => 0, B(..) => 1, C(..) => 2\n             // };\n             // let __self2_vi = match __arg2 {\n-            //     A => 0us, B(..) => 1us, C(..) => 2us\n+            //     A => 0, B(..) => 1, C(..) => 2\n             // };\n             // ```\n             let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();"}, {"sha": "68723d327393dfdc6619ad9a5fc4a9361a03d3d9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -362,7 +362,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n         // in this file.\n         // Token-tree macros:\n         MacInvocTT(pth, tts, _) => {\n-            if pth.segments.len() > 1us {\n+            if pth.segments.len() > 1 {\n                 fld.cx.span_err(pth.span,\n                                 \"expected macro name without module \\\n                                 separators\");\n@@ -931,7 +931,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             },\n             _ => unreachable!()\n         };\n-        if pth.segments.len() > 1us {\n+        if pth.segments.len() > 1 {\n             fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n             return DummyResult::raw_pat(span);\n         }"}, {"sha": "1d22f79bfb291ddcfc0b967ef048cc91e26956c0", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -709,7 +709,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     // try removing it when enough of them are gone.\n \n     let mut p = cx.new_parser_from_tts(tts);\n-    p.quote_depth += 1us;\n+    p.quote_depth += 1;\n \n     let cx_expr = p.parse_expr();\n     if !p.eat(&token::Comma) {"}, {"sha": "69c7d10a82c9a3316de23fd0e26df65b5bf08a2e", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -171,11 +171,11 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n         stack: vec![],\n         top_elts: TtSeq(ms),\n         sep: sep,\n-        idx: 0us,\n+        idx: 0,\n         up: None,\n         matches: matches,\n-        match_lo: 0us,\n-        match_cur: 0us,\n+        match_lo: 0,\n+        match_cur: 0,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n     }\n@@ -238,7 +238,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    let mut idx = 0us;\n+    let mut idx = 0;\n     for m in ms.iter() { n_rec(p_s, m, res, &mut ret_val, &mut idx) }\n     ret_val\n }\n@@ -383,7 +383,7 @@ pub fn parse(sess: &ParseSess,\n                         if seq.op == ast::ZeroOrMore {\n                             let mut new_ei = ei.clone();\n                             new_ei.match_cur += seq.num_captures;\n-                            new_ei.idx += 1us;\n+                            new_ei.idx += 1;\n                             //we specifically matched zero repeats.\n                             for idx in ei.match_cur..ei.match_cur + seq.num_captures {\n                                 (&mut new_ei.matches[idx]).push(Rc::new(MatchedSeq(vec![], sp)));\n@@ -398,7 +398,7 @@ pub fn parse(sess: &ParseSess,\n                         cur_eis.push(box MatcherPos {\n                             stack: vec![],\n                             sep: seq.separator.clone(),\n-                            idx: 0us,\n+                            idx: 0,\n                             matches: matches,\n                             match_lo: ei_t.match_cur,\n                             match_cur: ei_t.match_cur,\n@@ -442,20 +442,20 @@ pub fn parse(sess: &ParseSess,\n \n         /* error messages here could be improved with links to orig. rules */\n         if token_name_eq(&tok, &token::Eof) {\n-            if eof_eis.len() == 1us {\n+            if eof_eis.len() == 1 {\n                 let mut v = Vec::new();\n                 for dv in (&mut eof_eis[0]).matches.iter_mut() {\n                     v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, &v[]));\n-            } else if eof_eis.len() > 1us {\n+            } else if eof_eis.len() > 1 {\n                 return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {\n                 return Failure(sp, \"unexpected end of macro invocation\".to_string());\n             }\n         } else {\n-            if (bb_eis.len() > 0us && next_eis.len() > 0us)\n-                || bb_eis.len() > 1us {\n+            if (bb_eis.len() > 0 && next_eis.len() > 0)\n+                || bb_eis.len() > 1 {\n                 let nts = bb_eis.iter().map(|ei| {\n                     match ei.top_elts.get_tt(ei.idx) {\n                       TtToken(_, MatchNt(bind, name, _, _)) => {\n@@ -469,12 +469,12 @@ pub fn parse(sess: &ParseSess,\n                     \"local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\",\n                     nts, next_eis.len()).to_string());\n-            } else if bb_eis.len() == 0us && next_eis.len() == 0us {\n+            } else if bb_eis.len() == 0 && next_eis.len() == 0 {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n                             pprust::token_to_string(&tok)).to_string());\n-            } else if next_eis.len() > 0us {\n+            } else if next_eis.len() > 0 {\n                 /* Now process the next token */\n-                while next_eis.len() > 0us {\n+                while next_eis.len() > 0 {\n                     cur_eis.push(next_eis.pop().unwrap());\n                 }\n                 rdr.next_token();\n@@ -488,7 +488,7 @@ pub fn parse(sess: &ParseSess,\n                     let match_cur = ei.match_cur;\n                     (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n                         parse_nt(&mut rust_parser, span, name_string.get()))));\n-                    ei.idx += 1us;\n+                    ei.idx += 1;\n                     ei.match_cur += 1;\n                   }\n                   _ => panic!()\n@@ -501,16 +501,16 @@ pub fn parse(sess: &ParseSess,\n             }\n         }\n \n-        assert!(cur_eis.len() > 0us);\n+        assert!(cur_eis.len() > 0);\n     }\n }\n \n pub fn parse_nt(p: &mut Parser, sp: Span, name: &str) -> Nonterminal {\n     match name {\n         \"tt\" => {\n-            p.quote_depth += 1us; //but in theory, non-quoted tts might be useful\n+            p.quote_depth += 1; //but in theory, non-quoted tts might be useful\n             let res = token::NtTT(P(p.parse_token_tree()));\n-            p.quote_depth -= 1us;\n+            p.quote_depth -= 1;\n             return res;\n         }\n         _ => {}"}, {"sha": "83234e3b7a5d8468b55ff442a74c6df9f3e92cfe", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -223,7 +223,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.repeat_len.pop();\n             }\n         } else { /* repeat */\n-            *r.repeat_idx.last_mut().unwrap() += 1us;\n+            *r.repeat_idx.last_mut().unwrap() += 1;\n             r.stack.last_mut().unwrap().idx = 0;\n             match r.stack.last().unwrap().sep.clone() {\n                 Some(tk) => {"}, {"sha": "a026b8feee1d002c3b9d31289b2e86a48a1a2669", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -62,7 +62,7 @@ pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: Vec<String> ) -> Vec<String> {\n-        let mut i = 0us;\n+        let mut i = 0;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n         if lines.len() > 0 &&\n@@ -158,7 +158,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader,\n                                            comments: &mut Vec<Comment>) {\n     while is_whitespace(rdr.curr) && !rdr.is_eof() {\n-        if rdr.col == CharPos(0us) && rdr.curr_is('\\n') {\n+        if rdr.col == CharPos(0) && rdr.curr_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         rdr.bump();\n@@ -305,7 +305,7 @@ fn read_block_comment(rdr: &mut StringReader,\n \n     let mut style = if code_to_the_left { Trailing } else { Isolated };\n     rdr.consume_non_eol_whitespace();\n-    if !rdr.is_eof() && !rdr.curr_is('\\n') && lines.len() == 1us {\n+    if !rdr.is_eof() && !rdr.curr_is('\\n') && lines.len() == 1 {\n         style = Mixed;\n     }\n     debug!(\"<<< block comment\");"}, {"sha": "65051ff8360b7e598e5955b5a82a77d427c6c91f", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -279,7 +279,7 @@ impl<'a> StringReader<'a> {\n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n     fn translate_crlf<'b>(&self, start: BytePos,\n                           s: &'b str, errmsg: &'b str) -> CowString<'b> {\n-        let mut i = 0us;\n+        let mut i = 0;\n         while i < s.len() {\n             let str::CharRange { ch, next } = s.char_range_at(i);\n             if ch == '\\r' {\n@@ -331,10 +331,10 @@ impl<'a> StringReader<'a> {\n             let byte_offset_diff = next.next - current_byte_offset;\n             self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n             self.curr = Some(next.ch);\n-            self.col = self.col + CharPos(1us);\n+            self.col = self.col + CharPos(1);\n             if last_char == '\\n' {\n                 self.filemap.next_line(self.last_pos);\n-                self.col = CharPos(0us);\n+                self.col = CharPos(0);\n             }\n \n             if byte_offset_diff > 1 {\n@@ -472,7 +472,7 @@ impl<'a> StringReader<'a> {\n                 cmap.files.borrow_mut().push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.last_pos);\n                 debug!(\"Skipping a shebang\");\n-                if loc.line == 1us && loc.col == CharPos(0us) {\n+                if loc.line == 1 && loc.col == CharPos(0) {\n                     // FIXME: Add shebang \"token\", return it\n                     let start = self.last_pos;\n                     while !self.curr_is('\\n') && !self.is_eof() { self.bump(); }\n@@ -646,7 +646,7 @@ impl<'a> StringReader<'a> {\n     /// Scan through any digits (base `radix`) or underscores, and return how\n     /// many digits there were.\n     fn scan_digits(&mut self, radix: usize) -> usize {\n-        let mut len = 0us;\n+        let mut len = 0;\n         loop {\n             let c = self.curr;\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n@@ -799,14 +799,14 @@ impl<'a> StringReader<'a> {\n                                 if self.curr == Some('{') {\n                                     self.scan_unicode_escape(delim)\n                                 } else {\n-                                    let res = self.scan_hex_digits(4us, delim, false);\n+                                    let res = self.scan_hex_digits(4, delim, false);\n                                     let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n                                     self.old_escape_warning(sp);\n                                     res\n                                 }\n                             }\n                             'U' if !ascii_only => {\n-                                let res = self.scan_hex_digits(8us, delim, false);\n+                                let res = self.scan_hex_digits(8, delim, false);\n                                 let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n                                 self.old_escape_warning(sp);\n                                 res\n@@ -877,7 +877,7 @@ impl<'a> StringReader<'a> {\n     fn scan_unicode_escape(&mut self, delim: char) -> bool {\n         self.bump(); // past the {\n         let start_bpos = self.last_pos;\n-        let mut count = 0us;\n+        let mut count = 0;\n         let mut accum_int = 0;\n \n         while !self.curr_is('}') && count <= 6 {\n@@ -937,10 +937,10 @@ impl<'a> StringReader<'a> {\n     /// error if it isn't.\n     fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: usize) {\n         match base {\n-            16us => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n+            16 => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n                                    supported\"),\n-            8us => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n-            2us => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n+            8 => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n+            2 => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n             _   => ()\n         }\n     }\n@@ -1189,7 +1189,7 @@ impl<'a> StringReader<'a> {\n           'r' => {\n             let start_bpos = self.last_pos;\n             self.bump();\n-            let mut hash_count = 0us;\n+            let mut hash_count = 0;\n             while self.curr_is('#') {\n                 self.bump();\n                 hash_count += 1;\n@@ -1374,7 +1374,7 @@ impl<'a> StringReader<'a> {\n     fn scan_raw_byte_string(&mut self) -> token::Lit {\n         let start_bpos = self.last_pos;\n         self.bump();\n-        let mut hash_count = 0us;\n+        let mut hash_count = 0;\n         while self.curr_is('#') {\n             self.bump();\n             hash_count += 1;"}, {"sha": "af594ce7ca2227e063a9d34abdd021a3acd6b20f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -181,7 +181,7 @@ pub fn parse_tts_from_source_str(name: String,\n         name,\n         source\n     );\n-    p.quote_depth += 1us;\n+    p.quote_depth += 1;\n     // right now this is re-creating the token trees from ... token trees.\n     maybe_aborted(p.parse_all_token_trees(),p)\n }\n@@ -324,7 +324,7 @@ pub mod with_hygiene {\n             name,\n             source\n         );\n-        p.quote_depth += 1us;\n+        p.quote_depth += 1;\n         // right now this is re-creating the token trees from ... token trees.\n         maybe_aborted(p.parse_all_token_trees(),p)\n     }\n@@ -683,9 +683,9 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     match suffix {\n         Some(suf) if looks_like_width_suffix(&['f'], suf) => {\n             match base {\n-                16us => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n-                8us => sd.span_err(sp, \"octal float literal is not supported\"),\n-                2us => sd.span_err(sp, \"binary float literal is not supported\"),\n+                16 => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n+                8 => sd.span_err(sp, \"octal float literal is not supported\"),\n+                2 => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n             let ident = token::intern_and_get_ident(&*s);"}, {"sha": "49df6a361c5a582394b98e8248975292ba5d0ad2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -746,7 +746,7 @@ impl<'a> Parser<'a> {\n         // would encounter a `>` and stop. This lets the parser handle trailing\n         // commas in generic parameters, because it can stop either after\n         // parsing a type or after parsing a comma.\n-        for i in iter::count(0us, 1) {\n+        for i in iter::count(0, 1) {\n             if self.check(&token::Gt)\n                 || self.token == token::BinOp(token::Shr)\n                 || self.token == token::Ge\n@@ -923,7 +923,7 @@ impl<'a> Parser<'a> {\n         };\n         self.span = next.sp;\n         self.token = next.tok;\n-        self.tokens_consumed += 1us;\n+        self.tokens_consumed += 1;\n         self.expected_tokens.clear();\n         // check after each token\n         self.check_unknown_macro_variable();\n@@ -2632,7 +2632,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn check_unknown_macro_variable(&mut self) {\n-        if self.quote_depth == 0us {\n+        if self.quote_depth == 0 {\n             match self.token {\n                 token::SubstNt(name, _) =>\n                     self.fatal(&format!(\"unknown macro variable `{}`\",\n@@ -2701,7 +2701,7 @@ impl<'a> Parser<'a> {\n                                     token_str)[])\n                 },\n                 /* we ought to allow different depths of unquotation */\n-                token::Dollar | token::SubstNt(..) if p.quote_depth > 0us => {\n+                token::Dollar | token::SubstNt(..) if p.quote_depth > 0 => {\n                     p.parse_unquoted()\n                 }\n                 _ => {\n@@ -5638,7 +5638,7 @@ impl<'a> Parser<'a> {\n             return Ok(item);\n         }\n         if self.check_keyword(keywords::Unsafe) &&\n-            self.look_ahead(1us, |t| t.is_keyword(keywords::Trait))\n+            self.look_ahead(1, |t| t.is_keyword(keywords::Trait))\n         {\n             // UNSAFE TRAIT ITEM\n             self.expect_keyword(keywords::Unsafe);\n@@ -5655,7 +5655,7 @@ impl<'a> Parser<'a> {\n             return Ok(item);\n         }\n         if self.check_keyword(keywords::Unsafe) &&\n-            self.look_ahead(1us, |t| t.is_keyword(keywords::Impl))\n+            self.look_ahead(1, |t| t.is_keyword(keywords::Impl))\n         {\n             // IMPL ITEM\n             self.expect_keyword(keywords::Unsafe);\n@@ -5685,7 +5685,7 @@ impl<'a> Parser<'a> {\n             return Ok(item);\n         }\n         if self.check_keyword(keywords::Unsafe)\n-            && self.look_ahead(1us, |t| *t != token::OpenDelim(token::Brace)) {\n+            && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n             // UNSAFE FUNCTION ITEM\n             self.bump();\n             let abi = if self.eat_keyword(keywords::Extern) {\n@@ -5963,7 +5963,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n         }\n-        let mut rename_to = path[path.len() - 1us];\n+        let mut rename_to = path[path.len() - 1];\n         let path = ast::Path {\n             span: mk_sp(lo, self.last_span.hi),\n             global: false,"}, {"sha": "707b3c72ecdd7368d6f412de63621750d2f65195", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -132,15 +132,15 @@ pub fn buf_str(toks: &[Token],\n     let mut i = left;\n     let mut l = lim;\n     let mut s = string::String::from_str(\"[\");\n-    while i != right && l != 0us {\n-        l -= 1us;\n+    while i != right && l != 0 {\n+        l -= 1;\n         if i != left {\n             s.push_str(\", \");\n         }\n         s.push_str(&format!(\"{}={}\",\n                            szs[i],\n                            tok_str(&toks[i]))[]);\n-        i += 1us;\n+        i += 1;\n         i %= n;\n     }\n     s.push(']');\n@@ -326,8 +326,8 @@ impl Printer {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n-                self.left = 0us;\n-                self.right = 0us;\n+                self.left = 0;\n+                self.right = 0;\n             } else { self.advance_right(); }\n             debug!(\"pp Begin({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n@@ -355,8 +355,8 @@ impl Printer {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n-                self.left = 0us;\n-                self.right = 0us;\n+                self.left = 0;\n+                self.right = 0;\n             } else { self.advance_right(); }\n             debug!(\"pp Break({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n@@ -410,7 +410,7 @@ impl Printer {\n         if self.scan_stack_empty {\n             self.scan_stack_empty = false;\n         } else {\n-            self.top += 1us;\n+            self.top += 1;\n             self.top %= self.buf_len;\n             assert!((self.top != self.bottom));\n         }\n@@ -422,7 +422,7 @@ impl Printer {\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n-            self.top += self.buf_len - 1us; self.top %= self.buf_len;\n+            self.top += self.buf_len - 1; self.top %= self.buf_len;\n         }\n         return x;\n     }\n@@ -436,12 +436,12 @@ impl Printer {\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n-            self.bottom += 1us; self.bottom %= self.buf_len;\n+            self.bottom += 1; self.bottom %= self.buf_len;\n         }\n         return x;\n     }\n     pub fn advance_right(&mut self) {\n-        self.right += 1us;\n+        self.right += 1;\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n@@ -471,7 +471,7 @@ impl Printer {\n                 break;\n             }\n \n-            self.left += 1us;\n+            self.left += 1;\n             self.left %= self.buf_len;\n \n             left_size = self.size[self.left];\n@@ -520,7 +520,7 @@ impl Printer {\n     pub fn get_top(&mut self) -> PrintStackElem {\n         let print_stack = &mut self.print_stack;\n         let n = print_stack.len();\n-        if n != 0us {\n+        if n != 0 {\n             (*print_stack)[n - 1]\n         } else {\n             PrintStackElem {\n@@ -565,7 +565,7 @@ impl Printer {\n           Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n-            assert!((print_stack.len() != 0us));\n+            assert!((print_stack.len() != 0));\n             print_stack.pop().unwrap();\n             Ok(())\n           }\n@@ -667,11 +667,11 @@ pub fn spaces(p: &mut Printer, n: usize) -> old_io::IoResult<()> {\n }\n \n pub fn zerobreak(p: &mut Printer) -> old_io::IoResult<()> {\n-    spaces(p, 0us)\n+    spaces(p, 0)\n }\n \n pub fn space(p: &mut Printer) -> old_io::IoResult<()> {\n-    spaces(p, 1us)\n+    spaces(p, 1)\n }\n \n pub fn hardbreak(p: &mut Printer) -> old_io::IoResult<()> {"}, {"sha": "a7ff486c634c57ad0437bae35e94ae778d14d67c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -92,10 +92,10 @@ pub fn rust_printer_annotated<'a>(writer: Box<old_io::Writer+'static>,\n }\n \n #[allow(non_upper_case_globals)]\n-pub const indent_unit: usize = 4us;\n+pub const indent_unit: usize = 4;\n \n #[allow(non_upper_case_globals)]\n-pub const default_columns: usize = 78us;\n+pub const default_columns: usize = 78;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments and literals to\n@@ -377,7 +377,7 @@ pub fn block_to_string(blk: &ast::Block) -> String {\n         // containing cbox, will be closed by print-block at }\n         try!(s.cbox(indent_unit));\n         // head-ibox, will be closed by print-block after {\n-        try!(s.ibox(0us));\n+        try!(s.ibox(0));\n         s.print_block(blk)\n     })\n }\n@@ -516,7 +516,7 @@ impl<'a> State<'a> {\n     pub fn bclose_maybe_open (&mut self, span: codemap::Span,\n                               indented: usize, close_box: bool) -> IoResult<()> {\n         try!(self.maybe_print_comment(span.hi));\n-        try!(self.break_offset_if_not_bol(1us, -(indented as isize)));\n+        try!(self.break_offset_if_not_bol(1, -(indented as isize)));\n         try!(word(&mut self.s, \"}\"));\n         if close_box {\n             try!(self.end()); // close the outer-box\n@@ -591,7 +591,7 @@ impl<'a> State<'a> {\n     pub fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> IoResult<()> where\n         F: FnMut(&mut State, &T) -> IoResult<()>,\n     {\n-        try!(self.rbox(0us, b));\n+        try!(self.rbox(0, b));\n         let mut first = true;\n         for elt in elts.iter() {\n             if first { first = false; } else { try!(self.word_space(\",\")); }\n@@ -609,13 +609,13 @@ impl<'a> State<'a> {\n         F: FnMut(&mut State, &T) -> IoResult<()>,\n         G: FnMut(&T) -> codemap::Span,\n     {\n-        try!(self.rbox(0us, b));\n+        try!(self.rbox(0, b));\n         let len = elts.len();\n-        let mut i = 0us;\n+        let mut i = 0;\n         for elt in elts.iter() {\n             try!(self.maybe_print_comment(get_span(elt).hi));\n             try!(op(self, elt));\n-            i += 1us;\n+            i += 1;\n             if i < len {\n                 try!(word(&mut self.s, \",\"));\n                 try!(self.maybe_print_trailing_comment(get_span(elt),\n@@ -660,7 +660,7 @@ impl<'a> State<'a> {\n \n     pub fn print_type(&mut self, ty: &ast::Ty) -> IoResult<()> {\n         try!(self.maybe_print_comment(ty.span.lo));\n-        try!(self.ibox(0us));\n+        try!(self.ibox(0));\n         match ty.node {\n             ast::TyVec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n@@ -880,7 +880,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemTy(ref ty, ref params) => {\n                 try!(self.ibox(indent_unit));\n-                try!(self.ibox(0us));\n+                try!(self.ibox(0));\n                 try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")[]));\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(params));\n@@ -1277,7 +1277,7 @@ impl<'a> State<'a> {\n \n     pub fn print_outer_attributes(&mut self,\n                                   attrs: &[ast::Attribute]) -> IoResult<()> {\n-        let mut count = 0us;\n+        let mut count = 0;\n         for attr in attrs.iter() {\n             match attr.node.style {\n                 ast::AttrOuter => {\n@@ -1295,7 +1295,7 @@ impl<'a> State<'a> {\n \n     pub fn print_inner_attributes(&mut self,\n                                   attrs: &[ast::Attribute]) -> IoResult<()> {\n-        let mut count = 0us;\n+        let mut count = 0;\n         for attr in attrs.iter() {\n             match attr.node.style {\n                 ast::AttrInner => {\n@@ -1416,8 +1416,8 @@ impl<'a> State<'a> {\n                 match _else.node {\n                     // \"another else-if\"\n                     ast::ExprIf(ref i, ref then, ref e) => {\n-                        try!(self.cbox(indent_unit - 1us));\n-                        try!(self.ibox(0us));\n+                        try!(self.cbox(indent_unit - 1));\n+                        try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if \"));\n                         try!(self.print_expr(&**i));\n                         try!(space(&mut self.s));\n@@ -1426,8 +1426,8 @@ impl<'a> State<'a> {\n                     }\n                     // \"another else-if-let\"\n                     ast::ExprIfLet(ref pat, ref expr, ref then, ref e) => {\n-                        try!(self.cbox(indent_unit - 1us));\n-                        try!(self.ibox(0us));\n+                        try!(self.cbox(indent_unit - 1));\n+                        try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if let \"));\n                         try!(self.print_pat(&**pat));\n                         try!(space(&mut self.s));\n@@ -1439,8 +1439,8 @@ impl<'a> State<'a> {\n                     }\n                     // \"final else\"\n                     ast::ExprBlock(ref b) => {\n-                        try!(self.cbox(indent_unit - 1us));\n-                        try!(self.ibox(0us));\n+                        try!(self.cbox(indent_unit - 1));\n+                        try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else \"));\n                         self.print_block(&**b)\n                     }\n@@ -1606,7 +1606,7 @@ impl<'a> State<'a> {\n         try!(self.print_expr(&*args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_ident(ident.node));\n-        if tys.len() > 0us {\n+        if tys.len() > 0 {\n             try!(word(&mut self.s, \"::<\"));\n             try!(self.commasep(Inconsistent, tys,\n                                |s, ty| s.print_type(&**ty)));\n@@ -1777,7 +1777,7 @@ impl<'a> State<'a> {\n                 // containing cbox, will be closed by print-block at }\n                 try!(self.cbox(indent_unit));\n                 // head-box, will be closed by print-block after {\n-                try!(self.ibox(0us));\n+                try!(self.ibox(0));\n                 try!(self.print_block(&**blk));\n             }\n             ast::ExprAssign(ref lhs, ref rhs) => {\n@@ -2154,7 +2154,7 @@ impl<'a> State<'a> {\n                     },\n                     |f| f.node.pat.span));\n                 if etc {\n-                    if fields.len() != 0us { try!(self.word_space(\",\")); }\n+                    if fields.len() != 0 { try!(self.word_space(\",\")); }\n                     try!(word(&mut self.s, \"..\"));\n                 }\n                 try!(space(&mut self.s));\n@@ -2221,7 +2221,7 @@ impl<'a> State<'a> {\n             try!(space(&mut self.s));\n         }\n         try!(self.cbox(indent_unit));\n-        try!(self.ibox(0us));\n+        try!(self.ibox(0));\n         try!(self.print_outer_attributes(&arm.attrs[]));\n         let mut first = true;\n         for p in arm.pats.iter() {\n@@ -2307,7 +2307,7 @@ impl<'a> State<'a> {\n         -> IoResult<()> {\n         // It is unfortunate to duplicate the commasep logic, but we want the\n         // self type and the args all in the same box.\n-        try!(self.rbox(0us, Inconsistent));\n+        try!(self.rbox(0, Inconsistent));\n         let mut first = true;\n         for &explicit_self in opt_explicit_self.iter() {\n             let m = match explicit_self {\n@@ -2457,7 +2457,7 @@ impl<'a> State<'a> {\n         try!(word(&mut self.s, \"<\"));\n \n         let mut ints = Vec::new();\n-        for i in 0us..total {\n+        for i in 0..total {\n             ints.push(i);\n         }\n \n@@ -2707,7 +2707,7 @@ impl<'a> State<'a> {\n                 if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n                     span_line.line == comment_line.line {\n                         try!(self.print_comment(cmnt));\n-                        self.cur_cmnt_and_lit.cur_cmnt += 1us;\n+                        self.cur_cmnt_and_lit.cur_cmnt += 1;\n                     }\n             }\n             _ => ()\n@@ -2725,7 +2725,7 @@ impl<'a> State<'a> {\n             match self.next_comment() {\n                 Some(ref cmnt) => {\n                     try!(self.print_comment(cmnt));\n-                    self.cur_cmnt_and_lit.cur_cmnt += 1us;\n+                    self.cur_cmnt_and_lit.cur_cmnt += 1;\n                 }\n                 _ => break\n             }\n@@ -2807,7 +2807,7 @@ impl<'a> State<'a> {\n                 while self.cur_cmnt_and_lit.cur_lit < lits.len() {\n                     let ltrl = (*lits)[self.cur_cmnt_and_lit.cur_lit].clone();\n                     if ltrl.pos > pos { return None; }\n-                    self.cur_cmnt_and_lit.cur_lit += 1us;\n+                    self.cur_cmnt_and_lit.cur_lit += 1;\n                     if ltrl.pos == pos { return Some(ltrl); }\n                 }\n                 None\n@@ -2822,7 +2822,7 @@ impl<'a> State<'a> {\n                 Some(ref cmnt) => {\n                     if (*cmnt).pos < pos {\n                         try!(self.print_comment(cmnt));\n-                        self.cur_cmnt_and_lit.cur_cmnt += 1us;\n+                        self.cur_cmnt_and_lit.cur_cmnt += 1;\n                     } else { break; }\n                 }\n                 _ => break\n@@ -2835,7 +2835,7 @@ impl<'a> State<'a> {\n                          cmnt: &comments::Comment) -> IoResult<()> {\n         match cmnt.style {\n             comments::Mixed => {\n-                assert_eq!(cmnt.lines.len(), 1us);\n+                assert_eq!(cmnt.lines.len(), 1);\n                 try!(zerobreak(&mut self.s));\n                 try!(word(&mut self.s, &cmnt.lines[0][]));\n                 zerobreak(&mut self.s)\n@@ -2854,11 +2854,11 @@ impl<'a> State<'a> {\n             }\n             comments::Trailing => {\n                 try!(word(&mut self.s, \" \"));\n-                if cmnt.lines.len() == 1us {\n+                if cmnt.lines.len() == 1 {\n                     try!(word(&mut self.s, &cmnt.lines[0][]));\n                     hardbreak(&mut self.s)\n                 } else {\n-                    try!(self.ibox(0us));\n+                    try!(self.ibox(0));\n                     for line in cmnt.lines.iter() {\n                         if !line.is_empty() {\n                             try!(word(&mut self.s, &line[]));"}, {"sha": "61ce664d2c79036a45dfd433a7c93ab411dc8ae8", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9529ab0e7e469940db890604060c073179db8464/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=9529ab0e7e469940db890604060c073179db8464", "patch": "@@ -356,8 +356,8 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n                 let tparm_cnt = generics.ty_params.len();\n                 // NB: inadequate check, but we're running\n                 // well before resolve, can't get too deep.\n-                input_cnt == 1us\n-                    && no_output && tparm_cnt == 0us\n+                input_cnt == 1\n+                    && no_output && tparm_cnt == 0\n             }\n           _ => false\n         }"}]}