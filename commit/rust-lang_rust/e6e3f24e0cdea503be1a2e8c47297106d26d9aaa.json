{"sha": "e6e3f24e0cdea503be1a2e8c47297106d26d9aaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZTNmMjRlMGNkZWE1MDNiZTFhMmU4YzQ3Mjk3MTA2ZDI2ZDlhYWE=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-05-12T08:18:38Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-05-12T08:18:38Z"}, "message": "Fix #4019", "tree": {"sha": "2301c51b0ad01e3f5f79be72d23070c9950d41b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2301c51b0ad01e3f5f79be72d23070c9950d41b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa", "html_url": "https://github.com/rust-lang/rust/commit/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa/comments", "author": null, "committer": null, "parents": [{"sha": "c44a882a84313877b48ff3793288fa4b69c6220b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c44a882a84313877b48ff3793288fa4b69c6220b", "html_url": "https://github.com/rust-lang/rust/commit/c44a882a84313877b48ff3793288fa4b69c6220b"}], "stats": {"total": 108, "additions": 80, "deletions": 28}, "files": [{"sha": "be2b7a26e570abee18bada34e82e5c3743f4eb74", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=e6e3f24e0cdea503be1a2e8c47297106d26d9aaa", "patch": "@@ -9,6 +9,7 @@ use if_chain::if_chain;\n use matches::matches;\n use rustc::hir;\n use rustc::hir::def::{DefKind, Res};\n+use rustc::hir::intravisit::{self, Visitor};\n use rustc::lint::{in_external_macro, LateContext, LateLintPass, Lint, LintArray, LintContext, LintPass};\n use rustc::ty::{self, Predicate, Ty};\n use rustc::{declare_lint_pass, declare_tool_lint};\n@@ -1044,7 +1045,49 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n \n /// Checks for the `OR_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n-fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+fn lint_or_fun_call<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &hir::Expr,\n+    method_span: Span,\n+    name: &str,\n+    args: &'tcx [hir::Expr],\n+) {\n+    // Searches an expression for method calls or function calls that aren't ctors\n+    struct FunCallFinder<'a, 'tcx: 'a> {\n+        cx: &'a LateContext<'a, 'tcx>,\n+        found: bool,\n+    }\n+\n+    impl<'a, 'tcx> intravisit::Visitor<'tcx> for FunCallFinder<'a, 'tcx> {\n+        fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+            let found = match &expr.node {\n+                hir::ExprKind::Call(..) => !is_ctor_function(self.cx, expr),\n+                hir::ExprKind::MethodCall(..) => true,\n+                _ => false,\n+            };\n+\n+            if found {\n+                let owner_def = self.cx.tcx.hir().get_parent_did_by_hir_id(expr.hir_id);\n+                let promotable = self\n+                    .cx\n+                    .tcx\n+                    .rvalue_promotable_map(owner_def)\n+                    .contains(&expr.hir_id.local_id);\n+                if !promotable {\n+                    self.found |= true;\n+                }\n+            }\n+\n+            if !self.found {\n+                intravisit::walk_expr(self, expr);\n+            }\n+        }\n+\n+        fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+    }\n+\n     /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(\n         cx: &LateContext<'_, '_>,\n@@ -1096,13 +1139,13 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n \n     /// Checks for `*or(foo())`.\n     #[allow(clippy::too_many_arguments)]\n-    fn check_general_case(\n-        cx: &LateContext<'_, '_>,\n+    fn check_general_case<'a, 'tcx: 'a>(\n+        cx: &LateContext<'a, 'tcx>,\n         name: &str,\n         method_span: Span,\n         fun_span: Span,\n         self_expr: &hir::Expr,\n-        arg: &hir::Expr,\n+        arg: &'tcx hir::Expr,\n         or_has_args: bool,\n         span: Span,\n     ) {\n@@ -1120,14 +1163,9 @@ fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Spa\n         }\n \n         // ignore enum and struct constructors\n-        if is_ctor_function(cx, &arg) {\n-            return;\n-        }\n-\n-        // don't lint for constant values\n-        let owner_def = cx.tcx.hir().get_parent_did_by_hir_id(arg.hir_id);\n-        let promotable = cx.tcx.rvalue_promotable_map(owner_def).contains(&arg.hir_id.local_id);\n-        if promotable {\n+        let mut finder = FunCallFinder { cx: &cx, found: false };\n+        finder.visit_expr(&arg);\n+        if !finder.found {\n             return;\n         }\n "}, {"sha": "f339bae8ac6da4939e75f54a88918834a46616f0", "filename": "tests/ui/or_fun_call.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa/tests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa/tests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.rs?ref=e6e3f24e0cdea503be1a2e8c47297106d26d9aaa", "patch": "@@ -2,6 +2,7 @@\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;\n+use std::time::Duration;\n \n /// Checks implementation of the `OR_FUN_CALL` lint.\n fn or_fun_call() {\n@@ -24,8 +25,8 @@ fn or_fun_call() {\n     let with_enum = Some(Enum::A(1));\n     with_enum.unwrap_or(Enum::A(5));\n \n-    let with_const_fn = Some(::std::time::Duration::from_secs(1));\n-    with_const_fn.unwrap_or(::std::time::Duration::from_secs(5));\n+    let with_const_fn = Some(Duration::from_secs(1));\n+    with_const_fn.unwrap_or(Duration::from_secs(5));\n \n     let with_constructor = Some(vec![1]);\n     with_constructor.unwrap_or(make());\n@@ -71,6 +72,7 @@ fn or_fun_call() {\n }\n \n struct Foo(u8);\n+struct Bar(String, Duration);\n #[rustfmt::skip]\n fn test_or_with_ctors() {\n     let opt = Some(1);\n@@ -86,6 +88,12 @@ fn test_or_with_ctors() {\n     let _ = opt.ok_or(Foo(two));\n     let _ = opt.or(Some(2));\n     let _ = opt.or(Some(two));\n+\n+    let _ = Some(\"a\".to_string()).or(Some(\"b\".to_string()));\n+\n+    let b = \"b\".to_string();\n+    let _ = Some(Bar(\"a\".to_string(), Duration::from_secs(1)))\n+        .or(Some(Bar(b, Duration::from_secs(2))));\n }\n \n fn main() {}"}, {"sha": "f6e5d202e0c124dbb2e307106157f5e0f5f655dc", "filename": "tests/ui/or_fun_call.stderr", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa/tests%2Fui%2For_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e6e3f24e0cdea503be1a2e8c47297106d26d9aaa/tests%2Fui%2For_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.stderr?ref=e6e3f24e0cdea503be1a2e8c47297106d26d9aaa", "patch": "@@ -1,82 +1,88 @@\n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:31:22\n+  --> $DIR/or_fun_call.rs:32:22\n    |\n LL |     with_constructor.unwrap_or(make());\n    |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n    |\n    = note: `-D clippy::or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n-  --> $DIR/or_fun_call.rs:34:5\n+  --> $DIR/or_fun_call.rs:35:5\n    |\n LL |     with_new.unwrap_or(Vec::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_new.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:37:21\n+  --> $DIR/or_fun_call.rs:38:21\n    |\n LL |     with_const_args.unwrap_or(Vec::with_capacity(12));\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:40:14\n+  --> $DIR/or_fun_call.rs:41:14\n    |\n LL |     with_err.unwrap_or(make());\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| make())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:43:19\n+  --> $DIR/or_fun_call.rs:44:19\n    |\n LL |     with_err_args.unwrap_or(Vec::with_capacity(12));\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/or_fun_call.rs:46:5\n+  --> $DIR/or_fun_call.rs:47:5\n    |\n LL |     with_default_trait.unwrap_or(Default::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_trait.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `default`\n-  --> $DIR/or_fun_call.rs:49:5\n+  --> $DIR/or_fun_call.rs:50:5\n    |\n LL |     with_default_type.unwrap_or(u64::default());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_type.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:52:14\n+  --> $DIR/or_fun_call.rs:53:14\n    |\n LL |     with_vec.unwrap_or(vec![]);\n    |              ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| vec![])`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:57:21\n+  --> $DIR/or_fun_call.rs:58:21\n    |\n LL |     without_default.unwrap_or(Foo::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(Foo::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:60:19\n+  --> $DIR/or_fun_call.rs:61:19\n    |\n LL |     map.entry(42).or_insert(String::new());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:63:21\n+  --> $DIR/or_fun_call.rs:64:21\n    |\n LL |     btree.entry(42).or_insert(String::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:66:21\n+  --> $DIR/or_fun_call.rs:67:21\n    |\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n error: use of `ok_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:70:17\n+  --> $DIR/or_fun_call.rs:71:17\n    |\n LL |     let _ = opt.ok_or(format!(\"{} world.\", hello));\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `ok_or_else(|| format!(\"{} world.\", hello))`\n \n-error: aborting due to 13 previous errors\n+error: use of `or` followed by a function call\n+  --> $DIR/or_fun_call.rs:92:35\n+   |\n+LL |     let _ = Some(\"a\".to_string()).or(Some(\"b\".to_string()));\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(\"b\".to_string()))`\n+\n+error: aborting due to 14 previous errors\n "}]}