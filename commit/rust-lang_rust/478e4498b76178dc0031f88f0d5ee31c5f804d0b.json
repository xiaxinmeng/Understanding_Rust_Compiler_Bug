{"sha": "478e4498b76178dc0031f88f0d5ee31c5f804d0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3OGU0NDk4Yjc2MTc4ZGMwMDMxZjg4ZjBkNWVlMzFjNWY4MDRkMGI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-26T22:26:05Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-03-27T14:04:12Z"}, "message": "std: add option type directly to serialize::{En,De}code", "tree": {"sha": "e21be7cccf5b3fa4c2d05f2719e6679936096ab0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e21be7cccf5b3fa4c2d05f2719e6679936096ab0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/478e4498b76178dc0031f88f0d5ee31c5f804d0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/478e4498b76178dc0031f88f0d5ee31c5f804d0b", "html_url": "https://github.com/rust-lang/rust/commit/478e4498b76178dc0031f88f0d5ee31c5f804d0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/478e4498b76178dc0031f88f0d5ee31c5f804d0b/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d995e66a274511d70eb02abdb80da43ccf70aee", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d995e66a274511d70eb02abdb80da43ccf70aee", "html_url": "https://github.com/rust-lang/rust/commit/4d995e66a274511d70eb02abdb80da43ccf70aee"}], "stats": {"total": 186, "additions": 138, "deletions": 48}, "files": [{"sha": "90389602bc4a24b5a5533b8ce806c5e7be8118bf", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=478e4498b76178dc0031f88f0d5ee31c5f804d0b", "patch": "@@ -399,8 +399,20 @@ pub mod reader {\n             debug!(\"read_tup_elt(idx=%u)\", idx);\n             f()\n         }\n-    }\n \n+        fn read_option<T>(&self, f: &fn() -> T) -> Option<T> {\n+            debug!(\"read_option()\");\n+            do self.read_enum(\"Option\") || {\n+                do self.read_enum_variant |idx| {\n+                    match idx {\n+                        0 => None,\n+                        1 => Some(f()),\n+                        _ => fail!(),\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n pub mod writer {\n@@ -666,9 +678,19 @@ pub mod writer {\n \n         fn emit_tup(&self, _len: uint, f: &fn()) { f() }\n         fn emit_tup_elt(&self, _idx: uint, f: &fn()) { f() }\n-    }\n \n+        fn emit_option(&self, f: &fn()) {\n+            self.emit_enum(\"Option\", f);\n+        }\n+        fn emit_option_none(&self) {\n+            self.emit_enum_variant(\"None\", 0, 0, || ())\n+        }\n+        fn emit_option_some(&self, f: &fn()) {\n+            self.emit_enum_variant(\"Some\", 1, 1, f)\n+        }\n+    }\n }\n+\n // ___________________________________________________________________________\n // Testing\n "}, {"sha": "bb1102be9f7401d7f7b9c64135e92677689dfffe", "filename": "src/libstd/json.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=478e4498b76178dc0031f88f0d5ee31c5f804d0b", "patch": "@@ -120,24 +120,11 @@ impl serialize::Encoder for Encoder {\n     }\n \n     fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n-        // encoding of enums is special-cased for Option. Specifically:\n-        // Some(34) => 34\n-        // None => null\n-\n-        // other enums are encoded as strings or vectors:\n+        // enums are encoded as strings or vectors:\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => [\"Kangaroo\",[34,\"William\"]]\n \n-        // FIXME #4872: this would be more precise and less frightening\n-        // with fully-qualified option names. To get that information,\n-        // we'd have to change the expansion of auto-encode to pass\n-        // those along.\n-\n-        if name == ~\"Some\" {\n-            f();\n-        } else if name == ~\"None\" {\n-            self.wr.write_str(~\"null\");\n-        } else if cnt == 0 {\n+        if cnt == 0 {\n             self.wr.write_str(escape_str(name));\n         } else {\n             self.wr.write_char('[');\n@@ -193,6 +180,10 @@ impl serialize::Encoder for Encoder {\n     fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         self.emit_vec_elt(idx, f)\n     }\n+\n+    fn emit_option(&self, f: &fn()) { f(); }\n+    fn emit_option_none(&self) { self.emit_nil(); }\n+    fn emit_option_some(&self, f: &fn()) { f(); }\n }\n \n pub struct PrettyEncoder {\n@@ -245,11 +236,7 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n     fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n-        if name == ~\"Some\" {\n-            f();\n-        } else if name == ~\"None\" {\n-            self.emit_nil();\n-        } else if cnt == 0 {\n+        if cnt == 0 {\n             self.wr.write_str(escape_str(name));\n         } else {\n             self.wr.write_char('[');\n@@ -335,6 +322,10 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         self.emit_vec_elt(idx, f)\n     }\n+\n+    fn emit_option(&self, f: &fn()) { f(); }\n+    fn emit_option_none(&self) { self.emit_nil(); }\n+    fn emit_option_some(&self, f: &fn()) { f(); }\n }\n \n impl<S:serialize::Encoder> serialize::Encodable<S> for Json {\n@@ -966,6 +957,13 @@ impl<'self> serialize::Decoder for Decoder<'self> {\n             _ => fail!(~\"not a list\")\n         }\n     }\n+\n+    fn read_option<T>(&self, f: &fn() -> T) -> Option<T> {\n+        match *self.peek() {\n+            Null => { self.pop(); None }\n+            _ => Some(f()),\n+        }\n+    }\n }\n \n impl Eq for Json {"}, {"sha": "ed4f3e957c02af8258f6762569a0039730ec3420", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=478e4498b76178dc0031f88f0d5ee31c5f804d0b", "patch": "@@ -182,4 +182,18 @@ impl serialize::Encoder for Serializer {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n+\n+    fn emit_option(&self, f: &fn()) {\n+        f();\n+    }\n+\n+    fn emit_option_none(&self) {\n+        self.wr.write_str(\"None\");\n+    }\n+\n+    fn emit_option_some(&self, f: &fn()) {\n+        self.wr.write_str(\"Some(\");\n+        f();\n+        self.wr.write_char(')');\n+    }\n }"}, {"sha": "69977c6e4fe0181cc4a3528a0f06ed75adf16419", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=478e4498b76178dc0031f88f0d5ee31c5f804d0b", "patch": "@@ -62,6 +62,11 @@ pub trait Encoder {\n \n     fn emit_tup(&self, len: uint, f: &fn());\n     fn emit_tup_elt(&self, idx: uint, f: &fn());\n+\n+    // Specialized types:\n+    fn emit_option(&self, f: &fn());\n+    fn emit_option_none(&self);\n+    fn emit_option_some(&self, f: &fn());\n }\n \n pub trait Decoder {\n@@ -103,6 +108,9 @@ pub trait Decoder {\n \n     fn read_tup<T>(&self, sz: uint, f: &fn() -> T) -> T;\n     fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+\n+    // Specialized types:\n+    fn read_option<T>(&self, f: &fn() -> T) -> Option<T>;\n }\n \n pub trait Encodable<S:Encoder> {\n@@ -368,31 +376,18 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &S) {\n-        do s.emit_enum(~\"Option\") {\n+        do s.emit_option {\n             match *self {\n-              None => do s.emit_enum_variant(~\"None\", 0u, 0u) {\n-              },\n-\n-              Some(ref v) => do s.emit_enum_variant(~\"Some\", 1u, 1u) {\n-                s.emit_enum_variant_arg(0u, || v.encode(s))\n-              }\n+                None => s.emit_option_none(),\n+                Some(ref v) => s.emit_option_some(|| v.encode(s)),\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     fn decode(d: &D) -> Option<T> {\n-        do d.read_enum(~\"Option\") {\n-            do d.read_enum_variant |i| {\n-                match i {\n-                  0 => None,\n-                  1 => Some(d.read_enum_variant_arg(\n-                      0u, || Decodable::decode(d))),\n-                  _ => fail!(fmt!(\"Bad variant for option: %u\", i))\n-                }\n-            }\n-        }\n+        d.read_option(|| Decodable::decode(d))\n     }\n }\n "}, {"sha": "bafd2bb6adbcd3181812a2ed28f1364ac473dc4c", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478e4498b76178dc0031f88f0d5ee31c5f804d0b/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=478e4498b76178dc0031f88f0d5ee31c5f804d0b", "patch": "@@ -1177,6 +1177,7 @@ fn mk_enum_deser_body(\n \n #[cfg(test)]\n mod test {\n+    use core::option::{None, Some};\n     use std::serialize::Encodable;\n     use std::serialize::Encoder;\n \n@@ -1190,6 +1191,9 @@ mod test {\n         CallToEmitNil,\n         CallToEmitStruct(~str,uint),\n         CallToEmitField(~str,uint),\n+        CallToEmitOption,\n+        CallToEmitOptionNone,\n+        CallToEmitOptionSome,\n         // all of the ones I was too lazy to handle:\n         CallToOther\n     }\n@@ -1281,6 +1285,18 @@ mod test {\n         fn emit_tup_elt(&self, +_idx: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n+\n+        fn emit_option(&self, f: &fn()) {\n+            self.add_to_log(CallToEmitOption);\n+            f();\n+        }\n+        fn emit_option_none(&self) {\n+            self.add_to_log(CallToEmitOptionNone);\n+        }\n+        fn emit_option_some(&self, f: &fn()) {\n+            self.add_to_log(CallToEmitOptionSome);\n+            f();\n+        }\n     }\n \n \n@@ -1296,13 +1312,58 @@ mod test {\n         Magazine(~str)\n     }\n \n-    #[test] fn encode_enum_test () {\n-        assert_eq!(to_call_log(Book(34,44)),\n-                     ~[CallToEmitEnum (~\"Written\"),\n-                       CallToEmitEnumVariant (~\"Book\",0,2),\n-                       CallToEmitEnumVariantArg (0),\n-                       CallToEmitUint (34),\n-                       CallToEmitEnumVariantArg (1),\n-                       CallToEmitUint (44)]);\n-        }\n+    #[test]\n+    fn test_encode_enum() {\n+        assert_eq!(\n+            to_call_log(Book(34,44)),\n+            ~[\n+                CallToEmitEnum(~\"Written\"),\n+                CallToEmitEnumVariant(~\"Book\",0,2),\n+                CallToEmitEnumVariantArg(0),\n+                CallToEmitUint(34),\n+                CallToEmitEnumVariantArg(1),\n+                CallToEmitUint(44),\n+            ]\n+        );\n+    }\n+\n+    pub struct BPos(uint);\n+\n+    #[auto_encode]\n+    pub struct HasPos { pos : BPos }\n+\n+    #[test]\n+    fn test_encode_newtype() {\n+        assert_eq!(\n+            to_call_log(HasPos { pos:BPos(48) }),\n+            ~[\n+                CallToEmitStruct(~\"HasPos\",1),\n+                CallToEmitField(~\"pos\",0),\n+                CallToEmitUint(48),\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_encode_option() {\n+        let mut v = None;\n+\n+        assert_eq!(\n+            to_call_log(v),\n+            ~[\n+                CallToEmitOption,\n+                CallToEmitOptionNone,\n+            ]\n+        );\n+\n+        v = Some(54u);\n+        assert_eq!(\n+            to_call_log(v),\n+            ~[\n+                CallToEmitOption,\n+                CallToEmitOptionSome,\n+                CallToEmitUint(54)\n+            ]\n+        );\n+    }\n }"}]}