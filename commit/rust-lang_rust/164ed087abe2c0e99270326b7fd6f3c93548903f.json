{"sha": "164ed087abe2c0e99270326b7fd6f3c93548903f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NGVkMDg3YWJlMmMwZTk5MjcwMzI2YjdmZDZmM2M5MzU0ODkwM2Y=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-06-14T00:20:14Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-06-21T01:12:10Z"}, "message": "[const-prop] Move local storage into a `Frame` on `InterpCx`\n\nThis moves us closer to just using `InterpCx` for interpretation.", "tree": {"sha": "319238a7e8a76207154efd0d22bcd5bd39db8729", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/319238a7e8a76207154efd0d22bcd5bd39db8729"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/164ed087abe2c0e99270326b7fd6f3c93548903f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/164ed087abe2c0e99270326b7fd6f3c93548903f", "html_url": "https://github.com/rust-lang/rust/commit/164ed087abe2c0e99270326b7fd6f3c93548903f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/164ed087abe2c0e99270326b7fd6f3c93548903f/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "573b61ae265c54a94fc33d9db6005a4c74a238da", "url": "https://api.github.com/repos/rust-lang/rust/commits/573b61ae265c54a94fc33d9db6005a4c74a238da", "html_url": "https://github.com/rust-lang/rust/commit/573b61ae265c54a94fc33d9db6005a4c74a238da"}], "stats": {"total": 111, "additions": 88, "deletions": 23}, "files": [{"sha": "fbba8d10326a9d9057282b2d562f4e8dfaed4315", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/164ed087abe2c0e99270326b7fd6f3c93548903f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164ed087abe2c0e99270326b7fd6f3c93548903f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=164ed087abe2c0e99270326b7fd6f3c93548903f", "patch": "@@ -319,7 +319,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         t: T,\n     ) -> InterpResult<'tcx, T> {\n         match self.stack.last() {\n-            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)),\n+            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n             None => if t.needs_subst() {\n                 err!(TooGeneric).into()\n             } else {\n@@ -332,11 +332,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         &self,\n         t: T,\n         substs: SubstsRef<'tcx>\n-    ) -> T {\n+    ) -> InterpResult<'tcx, T> {\n         // miri doesn't care about lifetimes, and will choke on some crazy ones\n         // let's simply get rid of them\n         let substituted = t.subst(*self.tcx, substs);\n-        self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted)\n+\n+        if substituted.needs_subst() {\n+            return err!(TooGeneric);\n+        }\n+\n+        Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n     }\n \n     pub fn layout_of_local(\n@@ -349,7 +354,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n-                    let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n+                    let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs)?;\n                     self.layout_of(local_ty)\n                 })?;\n                 // Layouts of locals are requested a lot, so we cache them."}, {"sha": "1471e15baa58ef9c566e3d653c72e999404adcd4", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 79, "deletions": 19, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/164ed087abe2c0e99270326b7fd6f3c93548903f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/164ed087abe2c0e99270326b7fd6f3c93548903f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=164ed087abe2c0e99270326b7fd6f3c93548903f", "patch": "@@ -1,6 +1,8 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n+use std::cell::Cell;\n+\n use rustc::hir::def::DefKind;\n use rustc::mir::{\n     AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue,\n@@ -21,7 +23,8 @@ use rustc::ty::layout::{\n };\n \n use crate::interpret::{\n-    self, InterpretCx, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind,\n+    self, InterpretCx, ScalarMaybeUndef, Immediate, OpTy,\n+    ImmTy, MemoryKind, StackPopCleanup, LocalValue, LocalState,\n };\n use crate::const_eval::{\n     CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n@@ -56,21 +59,54 @@ impl MirPass for ConstProp {\n \n         trace!(\"ConstProp starting for {:?}\", source.def_id());\n \n+        // steal some data we need from `body`\n+        let source_scope_local_data = std::mem::replace(\n+            &mut body.source_scope_local_data,\n+            ClearCrossCrate::Clear\n+        );\n+        let promoted = std::mem::replace(\n+            &mut body.promoted,\n+            IndexVec::new()\n+        );\n+\n+        let dummy_body =\n+            &Body::new(\n+                body.basic_blocks().clone(),\n+                Default::default(),\n+                ClearCrossCrate::Clear,\n+                Default::default(),\n+                None,\n+                body.local_decls.clone(),\n+                Default::default(),\n+                body.arg_count,\n+                Default::default(),\n+                tcx.def_span(source.def_id()),\n+                Default::default(),\n+            );\n+\n         // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n         // constants, instead of just checking for const-folding succeeding.\n         // That would require an uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n-        let mut optimization_finder = ConstPropagator::new(body, tcx, source);\n+        let mut optimization_finder = ConstPropagator::new(\n+            body,\n+            dummy_body,\n+            source_scope_local_data,\n+            promoted,\n+            tcx,\n+            source\n+        );\n         optimization_finder.visit_body(body);\n \n         // put back the data we stole from `mir`\n+        let (source_scope_local_data, promoted) = optimization_finder.release_stolen_data();\n         std::mem::replace(\n             &mut body.source_scope_local_data,\n-            optimization_finder.source_scope_local_data\n+            source_scope_local_data\n         );\n         std::mem::replace(\n             &mut body.promoted,\n-            optimization_finder.promoted\n+            promoted\n         );\n \n         trace!(\"ConstProp done for {:?}\", source.def_id());\n@@ -84,7 +120,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n-    places: IndexVec<Local, Option<Const<'tcx>>>,\n     can_const_prop: IndexVec<Local, bool>,\n     param_env: ParamEnv<'tcx>,\n     source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n@@ -117,42 +152,67 @@ impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n-        body: &mut Body<'tcx>,\n+        body: &Body<'tcx>,\n+        dummy_body: &'mir Body<'tcx>,\n+        source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n+        promoted: IndexVec<Promoted, Body<'tcx>>,\n         tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'mir, 'tcx> {\n-        let param_env = tcx.param_env(source.def_id());\n-        let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id()), param_env);\n+        let def_id = source.def_id();\n+        let param_env = tcx.param_env(def_id);\n+        let span = tcx.def_span(def_id);\n+        let mut ecx = mk_eval_cx(tcx, span, param_env);\n         let can_const_prop = CanConstProp::check(body);\n-        let source_scope_local_data = std::mem::replace(\n-            &mut body.source_scope_local_data,\n-            ClearCrossCrate::Clear\n-        );\n-        let promoted = std::mem::replace(\n-            &mut body.promoted,\n-            IndexVec::new()\n-        );\n+\n+        ecx.push_stack_frame(\n+            Instance::new(def_id, &InternalSubsts::identity_for_item(tcx, def_id)),\n+            span,\n+            dummy_body,\n+            None,\n+            StackPopCleanup::None {\n+                cleanup: false,\n+            },\n+        ).expect(\"failed to push initial stack frame\");\n \n         ConstPropagator {\n             ecx,\n             tcx,\n             source,\n             param_env,\n             can_const_prop,\n-            places: IndexVec::from_elem(None, &body.local_decls),\n             source_scope_local_data,\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n             promoted,\n         }\n     }\n \n+    fn release_stolen_data(self) ->\n+        (ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n+         IndexVec<Promoted, Body<'tcx>>)\n+    {\n+        (self.source_scope_local_data, self.promoted)\n+    }\n+\n     fn get_const(&self, local: Local) -> Option<Const<'tcx>> {\n-        self.places[local]\n+        let l = &self.ecx.frame().locals[local];\n+        if l.value == LocalValue::Uninitialized || l.value == LocalValue::Dead {\n+            return None;\n+        }\n+\n+        self.ecx.access_local(self.ecx.frame(), local, None).ok()\n     }\n \n     fn set_const(&mut self, local: Local, c: Option<Const<'tcx>>) {\n-        self.places[local] = c;\n+        self.ecx.frame_mut().locals[local] =\n+            match c {\n+                Some(op_ty) => LocalState {\n+                    value: LocalValue::Live(*op_ty),\n+                    layout: Cell::new(Some(op_ty.layout)),\n+                },\n+                None => LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) },\n+            };\n     }\n \n     fn use_ecx<F, T>("}]}