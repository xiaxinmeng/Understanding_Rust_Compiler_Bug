{"sha": "513cf8664ab074d0fa540f1e1661193aeff0d358", "node_id": "C_kwDOAAsO6NoAKDUxM2NmODY2NGFiMDc0ZDBmYTU0MGYxZTE2NjExOTNhZWZmMGQzNTg", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-08-04T19:13:16Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-08-04T20:12:27Z"}, "message": "rustdoc: use a more compact encoding for implementors/trait.*.js\n\nThe exact amount that this reduces the size of an implementors file depends\non whether most of the impls are synthetic or not. For `Send`, it reduces\nthe file from 128K to 116K, while for `Clone` it went from 64K to 52K.", "tree": {"sha": "9da7c4e837e61993998ee163b8812d974f01b5a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9da7c4e837e61993998ee163b8812d974f01b5a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/513cf8664ab074d0fa540f1e1661193aeff0d358", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/513cf8664ab074d0fa540f1e1661193aeff0d358", "html_url": "https://github.com/rust-lang/rust/commit/513cf8664ab074d0fa540f1e1661193aeff0d358", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/513cf8664ab074d0fa540f1e1661193aeff0d358/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3830ecaa8db798d2727cbdfa4ddf314ff938f268", "url": "https://api.github.com/repos/rust-lang/rust/commits/3830ecaa8db798d2727cbdfa4ddf314ff938f268", "html_url": "https://github.com/rust-lang/rust/commit/3830ecaa8db798d2727cbdfa4ddf314ff938f268"}], "stats": {"total": 104, "additions": 83, "deletions": 21}, "files": [{"sha": "246121bd7e3e120209ce864c659ff7520749618b", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/513cf8664ab074d0fa540f1e1661193aeff0d358/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513cf8664ab074d0fa540f1e1661193aeff0d358/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=513cf8664ab074d0fa540f1e1661193aeff0d358", "patch": "@@ -1,5 +1,4 @@\n use std::ffi::OsStr;\n-use std::fmt::Write;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n@@ -10,7 +9,6 @@ use std::sync::LazyLock as Lazy;\n use itertools::Itertools;\n use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use serde::Serialize;\n \n use super::{collect_paths_for_type, ensure_trailing_slash, Context, BASIC_KEYWORDS};\n use crate::clean::Crate;\n@@ -284,25 +282,43 @@ pub(super) fn write_shared(\n         cx.write_shared(SharedResource::Unversioned { name }, contents, &options.emit)?;\n     }\n \n-    fn collect(path: &Path, krate: &str, key: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n+    /// Read a file and return all lines that match the `\"{crate}\":{data},` format,\n+    /// and return a tuple `(Vec<DataString>, Vec<CrateNameString>)`.\n+    ///\n+    /// This forms the payload of files that look like this:\n+    ///\n+    /// ```javascript\n+    /// var data = {\n+    /// \"{crate1}\":{data},\n+    /// \"{crate2}\":{data}\n+    /// };\n+    /// use_data(data);\n+    /// ```\n+    ///\n+    /// The file needs to be formatted so that *only crate data lines start with `\"`*.\n+    fn collect(path: &Path, krate: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n         let mut ret = Vec::new();\n         let mut krates = Vec::new();\n \n         if path.exists() {\n-            let prefix = format!(r#\"{}[\"{}\"]\"#, key, krate);\n+            let prefix = format!(\"\\\"{}\\\"\", krate);\n             for line in BufReader::new(File::open(path)?).lines() {\n                 let line = line?;\n-                if !line.starts_with(key) {\n+                if !line.starts_with('\"') {\n                     continue;\n                 }\n                 if line.starts_with(&prefix) {\n                     continue;\n                 }\n-                ret.push(line.to_string());\n+                if line.ends_with(\",\") {\n+                    ret.push(line[..line.len() - 1].to_string());\n+                } else {\n+                    // No comma (it's the case for the last added crate line)\n+                    ret.push(line.to_string());\n+                }\n                 krates.push(\n-                    line[key.len() + 2..]\n-                        .split('\"')\n-                        .next()\n+                    line.split('\"')\n+                        .find(|s| !s.is_empty())\n                         .map(|s| s.to_owned())\n                         .unwrap_or_else(String::new),\n                 );\n@@ -311,6 +327,20 @@ pub(super) fn write_shared(\n         Ok((ret, krates))\n     }\n \n+    /// Read a file and return all lines that match the <code>\"{crate}\":{data},\\</code> format,\n+    /// and return a tuple `(Vec<DataString>, Vec<CrateNameString>)`.\n+    ///\n+    /// This forms the payload of files that look like this:\n+    ///\n+    /// ```javascript\n+    /// var data = JSON.parse('{\\\n+    /// \"{crate1}\":{data},\\\n+    /// \"{crate2}\":{data}\\\n+    /// }');\n+    /// use_data(data);\n+    /// ```\n+    ///\n+    /// The file needs to be formatted so that *only crate data lines start with `\"`*.\n     fn collect_json(path: &Path, krate: &str) -> io::Result<(Vec<String>, Vec<String>)> {\n         let mut ret = Vec::new();\n         let mut krates = Vec::new();\n@@ -526,13 +556,40 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n             },\n         };\n \n-        #[derive(Serialize)]\n         struct Implementor {\n             text: String,\n             synthetic: bool,\n             types: Vec<String>,\n         }\n \n+        impl Implementor {\n+            fn to_js_string(&self) -> String {\n+                fn single_quote_string(s: &str) -> String {\n+                    let mut result = String::with_capacity(s.len() + 2);\n+                    result.push_str(\"'\");\n+                    for c in s.chars() {\n+                        if c == '\"' {\n+                            result.push_str(\"\\\"\");\n+                        } else {\n+                            result.extend(c.escape_default());\n+                        }\n+                    }\n+                    result.push_str(\"'\");\n+                    result\n+                }\n+                let text_esc = single_quote_string(&self.text);\n+                if self.synthetic {\n+                    let types = self.types.iter().map(|type_| single_quote_string(type_)).join(\",\");\n+                    // use `1` to represent a synthetic, because it's fewer bytes than `true`\n+                    format!(\"[{text_esc},1,[{types}]]\")\n+                } else {\n+                    // The types list is only used for synthetic impls.\n+                    // If this changes, `main.js` and `write_shared.rs` both need changed.\n+                    format!(\"[{text_esc}]\")\n+                }\n+            }\n+        }\n+\n         let implementors = imps\n             .iter()\n             .filter_map(|imp| {\n@@ -563,9 +620,9 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n         }\n \n         let implementors = format!(\n-            r#\"implementors[\"{}\"] = {};\"#,\n+            r#\"\"{}\":[{}]\"#,\n             krate.name(cx.tcx()),\n-            serde_json::to_string(&implementors).unwrap()\n+            implementors.iter().map(Implementor::to_js_string).join(\",\")\n         );\n \n         let mut mydst = dst.clone();\n@@ -576,16 +633,15 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n         mydst.push(&format!(\"{}.{}.js\", remote_item_type, remote_path[remote_path.len() - 1]));\n \n         let (mut all_implementors, _) =\n-            try_err!(collect(&mydst, krate.name(cx.tcx()).as_str(), \"implementors\"), &mydst);\n+            try_err!(collect(&mydst, krate.name(cx.tcx()).as_str()), &mydst);\n         all_implementors.push(implementors);\n         // Sort the implementors by crate so the file will be generated\n         // identically even with rustdoc running in parallel.\n         all_implementors.sort();\n \n-        let mut v = String::from(\"(function() {var implementors = {};\\n\");\n-        for implementor in &all_implementors {\n-            writeln!(v, \"{}\", *implementor).unwrap();\n-        }\n+        let mut v = String::from(\"(function() {var implementors = {\\n\");\n+        v.push_str(&all_implementors.join(\",\\n\"));\n+        v.push_str(\"\\n};\");\n         v.push_str(\n             \"if (window.register_implementors) {\\\n                  window.register_implementors(implementors);\\"}, {"sha": "2e05c4be2f3e9b857b4b5ebb9bdb5dfbf14f5666", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/513cf8664ab074d0fa540f1e1661193aeff0d358/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/513cf8664ab074d0fa540f1e1661193aeff0d358/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=513cf8664ab074d0fa540f1e1661193aeff0d358", "patch": "@@ -501,6 +501,10 @@ function loadCss(cssFileName) {\n         const synthetic_implementors = document.getElementById(\"synthetic-implementors-list\");\n         const inlined_types = new Set();\n \n+        const TEXT_IDX = 0;\n+        const SYNTHETIC_IDX = 1;\n+        const TYPES_IDX = 2;\n+\n         if (synthetic_implementors) {\n             // This `inlined_types` variable is used to avoid having the same implementation\n             // showing up twice. For example \"String\" in the \"Sync\" doc page.\n@@ -536,10 +540,12 @@ function loadCss(cssFileName) {\n \n             struct_loop:\n             for (const struct of structs) {\n-                const list = struct.synthetic ? synthetic_implementors : implementors;\n+                const list = struct[SYNTHETIC_IDX] ? synthetic_implementors : implementors;\n \n-                if (struct.synthetic) {\n-                    for (const struct_type of struct.types) {\n+                // The types list is only used for synthetic impls.\n+                // If this changes, `main.js` and `write_shared.rs` both need changed.\n+                if (struct[SYNTHETIC_IDX]) {\n+                    for (const struct_type of struct[TYPES_IDX]) {\n                         if (inlined_types.has(struct_type)) {\n                             continue struct_loop;\n                         }\n@@ -548,7 +554,7 @@ function loadCss(cssFileName) {\n                 }\n \n                 const code = document.createElement(\"h3\");\n-                code.innerHTML = struct.text;\n+                code.innerHTML = struct[TEXT_IDX];\n                 addClass(code, \"code-header\");\n                 addClass(code, \"in-band\");\n "}]}