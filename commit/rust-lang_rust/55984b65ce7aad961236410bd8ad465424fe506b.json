{"sha": "55984b65ce7aad961236410bd8ad465424fe506b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1OTg0YjY1Y2U3YWFkOTYxMjM2NDEwYmQ4YWQ0NjU0MjRmZTUwNmI=", "commit": {"author": {"name": "Philippe Nadon", "email": "phil@nadon.io", "date": "2020-07-21T21:17:32Z"}, "committer": {"name": "Philippe Nadon", "email": "phil@nadon.io", "date": "2020-07-23T04:58:11Z"}, "message": "renamed ScalarMaybeUninit::not_undef to check_init\n\nRenamed the function ScalarMaybeUninit::not_undef to ScalarMaybeUninit::check_init in the file src/librustc_middle/mir/interpret/value.rs, to reflect changes in terminology used.\n\nRelated issue rust-lang#71193", "tree": {"sha": "3d39420244716ad80ce11b511c696fe9799ffe51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d39420244716ad80ce11b511c696fe9799ffe51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55984b65ce7aad961236410bd8ad465424fe506b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55984b65ce7aad961236410bd8ad465424fe506b", "html_url": "https://github.com/rust-lang/rust/commit/55984b65ce7aad961236410bd8ad465424fe506b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55984b65ce7aad961236410bd8ad465424fe506b/comments", "author": {"login": "pnadon", "id": 12490688, "node_id": "MDQ6VXNlcjEyNDkwNjg4", "avatar_url": "https://avatars.githubusercontent.com/u/12490688?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnadon", "html_url": "https://github.com/pnadon", "followers_url": "https://api.github.com/users/pnadon/followers", "following_url": "https://api.github.com/users/pnadon/following{/other_user}", "gists_url": "https://api.github.com/users/pnadon/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnadon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnadon/subscriptions", "organizations_url": "https://api.github.com/users/pnadon/orgs", "repos_url": "https://api.github.com/users/pnadon/repos", "events_url": "https://api.github.com/users/pnadon/events{/privacy}", "received_events_url": "https://api.github.com/users/pnadon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnadon", "id": 12490688, "node_id": "MDQ6VXNlcjEyNDkwNjg4", "avatar_url": "https://avatars.githubusercontent.com/u/12490688?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnadon", "html_url": "https://github.com/pnadon", "followers_url": "https://api.github.com/users/pnadon/followers", "following_url": "https://api.github.com/users/pnadon/following{/other_user}", "gists_url": "https://api.github.com/users/pnadon/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnadon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnadon/subscriptions", "organizations_url": "https://api.github.com/users/pnadon/orgs", "repos_url": "https://api.github.com/users/pnadon/repos", "events_url": "https://api.github.com/users/pnadon/events{/privacy}", "received_events_url": "https://api.github.com/users/pnadon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8b55a4ad230ebec762fdfc4f241ba98a98560af", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8b55a4ad230ebec762fdfc4f241ba98a98560af", "html_url": "https://github.com/rust-lang/rust/commit/e8b55a4ad230ebec762fdfc4f241ba98a98560af"}], "stats": {"total": 72, "additions": 36, "deletions": 36}, "files": [{"sha": "e829ba5dfce9e584599eab1f9efbb3bf9b6eb391", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -888,7 +888,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 let ptr = Pointer::new(AllocId(0), offset);\n                                 alloc\n                                     .read_scalar(&bx, ptr, size)\n-                                    .and_then(|s| s.not_undef())\n+                                    .and_then(|s| s.check_init())\n                                     .unwrap_or_else(|e| {\n                                         bx.tcx().sess.span_err(\n                                             span,"}, {"sha": "9de2d17457ab16e1d9172dc87a95ca4a0936eeaa", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -606,7 +606,7 @@ impl<'tcx, Tag> ScalarMaybeUninit<Tag> {\n     }\n \n     #[inline]\n-    pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n+    pub fn check_init(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUninit::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUninit::Uninit => throw_ub!(InvalidUninitBytes(None)),\n@@ -615,72 +615,72 @@ impl<'tcx, Tag> ScalarMaybeUninit<Tag> {\n \n     #[inline(always)]\n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n-        self.not_undef()?.to_bool()\n+        self.check_init()?.to_bool()\n     }\n \n     #[inline(always)]\n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n-        self.not_undef()?.to_char()\n+        self.check_init()?.to_char()\n     }\n \n     #[inline(always)]\n     pub fn to_f32(self) -> InterpResult<'tcx, Single> {\n-        self.not_undef()?.to_f32()\n+        self.check_init()?.to_f32()\n     }\n \n     #[inline(always)]\n     pub fn to_f64(self) -> InterpResult<'tcx, Double> {\n-        self.not_undef()?.to_f64()\n+        self.check_init()?.to_f64()\n     }\n \n     #[inline(always)]\n     pub fn to_u8(self) -> InterpResult<'tcx, u8> {\n-        self.not_undef()?.to_u8()\n+        self.check_init()?.to_u8()\n     }\n \n     #[inline(always)]\n     pub fn to_u16(self) -> InterpResult<'tcx, u16> {\n-        self.not_undef()?.to_u16()\n+        self.check_init()?.to_u16()\n     }\n \n     #[inline(always)]\n     pub fn to_u32(self) -> InterpResult<'tcx, u32> {\n-        self.not_undef()?.to_u32()\n+        self.check_init()?.to_u32()\n     }\n \n     #[inline(always)]\n     pub fn to_u64(self) -> InterpResult<'tcx, u64> {\n-        self.not_undef()?.to_u64()\n+        self.check_init()?.to_u64()\n     }\n \n     #[inline(always)]\n     pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n-        self.not_undef()?.to_machine_usize(cx)\n+        self.check_init()?.to_machine_usize(cx)\n     }\n \n     #[inline(always)]\n     pub fn to_i8(self) -> InterpResult<'tcx, i8> {\n-        self.not_undef()?.to_i8()\n+        self.check_init()?.to_i8()\n     }\n \n     #[inline(always)]\n     pub fn to_i16(self) -> InterpResult<'tcx, i16> {\n-        self.not_undef()?.to_i16()\n+        self.check_init()?.to_i16()\n     }\n \n     #[inline(always)]\n     pub fn to_i32(self) -> InterpResult<'tcx, i32> {\n-        self.not_undef()?.to_i32()\n+        self.check_init()?.to_i32()\n     }\n \n     #[inline(always)]\n     pub fn to_i64(self) -> InterpResult<'tcx, i64> {\n-        self.not_undef()?.to_i64()\n+        self.check_init()?.to_i64()\n     }\n \n     #[inline(always)]\n     pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n-        self.not_undef()?.to_machine_isize(cx)\n+        self.check_init()?.to_machine_isize(cx)\n     }\n }\n "}, {"sha": "42fba8982d23c3d0c91f1bd9771bf13904120699", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -154,7 +154,7 @@ pub(super) fn op_to_const<'tcx>(\n                 ScalarMaybeUninit::Uninit => to_const_value(op.assert_mem_place(ecx)),\n             },\n             Immediate::ScalarPair(a, b) => {\n-                let (data, start) = match a.not_undef().unwrap() {\n+                let (data, start) = match a.check_init().unwrap() {\n                     Scalar::Ptr(ptr) => {\n                         (ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(), ptr.offset.bytes())\n                     }"}, {"sha": "39ed3b607934b2a0f10f701845a95cea5d35f831", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -150,7 +150,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::bitreverse => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n-                let val = self.read_scalar(args[0])?.not_undef()?;\n+                let val = self.read_scalar(args[0])?.check_init()?;\n                 let bits = self.force_bits(val, layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     Abi::Scalar(ref scalar) => scalar.value,\n@@ -281,9 +281,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n-                let val = self.read_scalar(args[0])?.not_undef()?;\n+                let val = self.read_scalar(args[0])?.check_init()?;\n                 let val_bits = self.force_bits(val, layout.size)?;\n-                let raw_shift = self.read_scalar(args[1])?.not_undef()?;\n+                let raw_shift = self.read_scalar(args[1])?.check_init()?;\n                 let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n                 let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n@@ -298,15 +298,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(result, dest)?;\n             }\n             sym::offset => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.check_init()?;\n                 let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n             sym::arith_offset => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.check_init()?;\n                 let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n "}, {"sha": "0ddbd3a249ccfbc1ce105c25884efc8d90a67bd6", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -72,14 +72,14 @@ impl<'tcx, Tag> Immediate<Tag> {\n \n     #[inline]\n     pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n-        self.to_scalar_or_undef().not_undef()\n+        self.to_scalar_or_undef().check_init()\n     }\n \n     #[inline]\n     pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n         match self {\n             Immediate::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n-            Immediate::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?)),\n+            Immediate::ScalarPair(a, b) => Ok((a.check_init()?, b.check_init()?)),\n         }\n     }\n }"}, {"sha": "80a5e56059d0906b0a6cee559bb7ad644a61c460", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -292,9 +292,9 @@ where\n             val.layout.ty.builtin_deref(true).expect(\"`ref_to_mplace` called on non-ptr type\").ty;\n         let layout = self.layout_of(pointee_type)?;\n         let (ptr, meta) = match *val {\n-            Immediate::Scalar(ptr) => (ptr.not_undef()?, MemPlaceMeta::None),\n+            Immediate::Scalar(ptr) => (ptr.check_init()?, MemPlaceMeta::None),\n             Immediate::ScalarPair(ptr, meta) => {\n-                (ptr.not_undef()?, MemPlaceMeta::Meta(meta.not_undef()?))\n+                (ptr.check_init()?, MemPlaceMeta::Meta(meta.check_init()?))\n             }\n         };\n \n@@ -541,7 +541,7 @@ where\n                 let n = self.access_local(self.frame(), local, Some(layout))?;\n                 let n = self.read_scalar(n)?;\n                 let n = u64::try_from(\n-                    self.force_bits(n.not_undef()?, self.tcx.data_layout.pointer_size)?,\n+                    self.force_bits(n.check_init()?, self.tcx.data_layout.pointer_size)?,\n                 )\n                 .unwrap();\n                 self.mplace_index(base, n)?"}, {"sha": "9a036a0f299e47bd7c6621b91b58f3c1496bd289", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -58,7 +58,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (fn_val, abi) = match func.layout.ty.kind {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n-                        let fn_ptr = self.read_scalar(func)?.not_undef()?;\n+                        let fn_ptr = self.read_scalar(func)?.check_init()?;\n                         let fn_val = self.memory.get_fn(fn_ptr)?;\n                         (fn_val, caller_abi)\n                     }"}, {"sha": "589da04d6a387468b50049143057e67821b7ce4f", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -118,7 +118,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .memory\n             .get_raw(vtable_slot.alloc_id)?\n             .read_ptr_sized(self, vtable_slot)?\n-            .not_undef()?;\n+            .check_init()?;\n         Ok(self.memory.get_fn(fn_ptr)?)\n     }\n \n@@ -137,7 +137,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )?\n             .expect(\"cannot be a ZST\");\n         let drop_fn =\n-            self.memory.get_raw(vtable.alloc_id)?.read_ptr_sized(self, vtable)?.not_undef()?;\n+            self.memory.get_raw(vtable.alloc_id)?.read_ptr_sized(self, vtable)?.check_init()?;\n         // We *need* an instance here, no other kind of function value, to be able\n         // to determine the type.\n         let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n@@ -165,10 +165,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .check_ptr_access(vtable, 3 * pointer_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n         let alloc = self.memory.get_raw(vtable.alloc_id)?;\n-        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?.not_undef()?;\n+        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?.check_init()?;\n         let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();\n         let align =\n-            alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.not_undef()?;\n+            alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.check_init()?;\n         let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n         if size >= self.tcx.data_layout.obj_size_bound() {"}, {"sha": "f1c5a67ed33f163ae497fa022d80492f78891f9d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -500,7 +500,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // types below!\n                 if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n-                    let is_bits = value.not_undef().map_or(false, |v| v.is_bits());\n+                    let is_bits = value.check_init().map_or(false, |v| v.is_bits());\n                     if !is_bits {\n                         throw_validation_failure!(self.path,\n                             { \"{}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n@@ -537,7 +537,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             ty::FnPtr(_sig) => {\n                 let value = self.ecx.read_scalar(value)?;\n                 let _fn = try_validation!(\n-                    value.not_undef().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n+                    value.check_init().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n                     self.path,\n                     err_ub!(DanglingIntPointer(..)) |\n                     err_ub!(InvalidFunctionPointer(..)) |\n@@ -596,7 +596,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         }\n         // At least one value is excluded. Get the bits.\n         let value = try_validation!(\n-            value.not_undef(),\n+            value.check_init(),\n             self.path,\n             err_ub!(InvalidUninitBytes(None)) => { \"{}\", value }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },"}, {"sha": "3202f7d1b1b88a036598e159d7c37c7a5c88c40c", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55984b65ce7aad961236410bd8ad465424fe506b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=55984b65ce7aad961236410bd8ad465424fe506b", "patch": "@@ -2614,7 +2614,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n             let pats = cx.pattern_arena.alloc_from_iter((0..n).filter_map(|i| {\n                 let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n                 let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n-                let scalar = scalar.not_undef().ok()?;\n+                let scalar = scalar.check_init().ok()?;\n                 let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n                 let pattern = Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n                 Some(pattern)"}]}