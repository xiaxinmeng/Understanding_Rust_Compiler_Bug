{"sha": "c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NGY5ODM4NWEyOGVlYjc1OTVmMzhiN2NmYWY4NjFhNmUwNmY0ZWE=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-06T01:30:52Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-14T10:12:26Z"}, "message": "Refactor SSR so that placeholders store a Var\n\nThis allows lookup of placeholder bindings given a placeholder without\nneeding to create a Var instance.", "tree": {"sha": "6f8c4a1770aeefde182e365e0d249ed12bc61fdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f8c4a1770aeefde182e365e0d249ed12bc61fdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "html_url": "https://github.com/rust-lang/rust/commit/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "674af600f105abe1dcb6c7654058e7df5a402429", "url": "https://api.github.com/repos/rust-lang/rust/commits/674af600f105abe1dcb6c7654058e7df5a402429", "html_url": "https://github.com/rust-lang/rust/commit/674af600f105abe1dcb6c7654058e7df5a402429"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "7f0b5061e29aabd0353f0f7e61105d2120c5c53b", "filename": "crates/ssr/src/matching.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea/crates%2Fssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea/crates%2Fssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fmatching.rs?ref=c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "patch": "@@ -2,7 +2,7 @@\n //! process of matching, placeholder values are recorded.\n \n use crate::{\n-    parsing::{Constraint, NodeKind, Placeholder},\n+    parsing::{Constraint, NodeKind, Placeholder, Var},\n     resolving::{ResolvedPattern, ResolvedRule, UfcsCallInfo},\n     SsrMatches,\n };\n@@ -56,10 +56,6 @@ pub struct Match {\n     pub(crate) rendered_template_paths: FxHashMap<SyntaxNode, hir::ModPath>,\n }\n \n-/// Represents a `$var` in an SSR query.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub(crate) struct Var(pub String);\n-\n /// Information about a placeholder bound in a match.\n #[derive(Debug)]\n pub(crate) struct PlaceholderMatch {\n@@ -182,10 +178,9 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                 // We validated the range for the node when we started the match, so the placeholder\n                 // probably can't fail range validation, but just to be safe...\n                 self.validate_range(&original_range)?;\n-                matches_out.placeholder_values.insert(\n-                    Var(placeholder.ident.to_string()),\n-                    PlaceholderMatch::new(code, original_range),\n-                );\n+                matches_out\n+                    .placeholder_values\n+                    .insert(placeholder.ident.clone(), PlaceholderMatch::new(code, original_range));\n             }\n             return Ok(());\n         }\n@@ -487,7 +482,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                 }\n                 if let Phase::Second(match_out) = phase {\n                     match_out.placeholder_values.insert(\n-                        Var(placeholder.ident.to_string()),\n+                        placeholder.ident.clone(),\n                         PlaceholderMatch::from_range(FileRange {\n                             file_id: self.sema.original_range(code).file_id,\n                             range: first_matched_token"}, {"sha": "05b66dcd780e511181e809528e5b343473e45d5e", "filename": "crates/ssr/src/parsing.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea/crates%2Fssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea/crates%2Fssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fparsing.rs?ref=c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "patch": "@@ -8,7 +8,7 @@\n use crate::errors::bail;\n use crate::{SsrError, SsrPattern, SsrRule};\n use rustc_hash::{FxHashMap, FxHashSet};\n-use std::str::FromStr;\n+use std::{fmt::Display, str::FromStr};\n use syntax::{ast, AstNode, SmolStr, SyntaxKind, SyntaxNode, T};\n use test_utils::mark;\n \n@@ -34,12 +34,16 @@ pub(crate) enum PatternElement {\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Placeholder {\n     /// The name of this placeholder. e.g. for \"$a\", this would be \"a\"\n-    pub(crate) ident: SmolStr,\n+    pub(crate) ident: Var,\n     /// A unique name used in place of this placeholder when we parse the pattern as Rust code.\n     stand_in_name: String,\n     pub(crate) constraints: Vec<Constraint>,\n }\n \n+/// Represents a `$var` in an SSR query.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct Var(pub String);\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Constraint {\n     Kind(NodeKind),\n@@ -205,7 +209,7 @@ fn parse_pattern(pattern_str: &str) -> Result<Vec<PatternElement>, SsrError> {\n         if token.kind == T![$] {\n             let placeholder = parse_placeholder(&mut tokens)?;\n             if !placeholder_names.insert(placeholder.ident.clone()) {\n-                bail!(\"Name `{}` repeats more than once\", placeholder.ident);\n+                bail!(\"Placeholder `{}` repeats more than once\", placeholder.ident);\n             }\n             res.push(PatternElement::Placeholder(placeholder));\n         } else {\n@@ -228,7 +232,7 @@ fn validate_rule(rule: &SsrRule) -> Result<(), SsrError> {\n     for p in &rule.template.tokens {\n         if let PatternElement::Placeholder(placeholder) = p {\n             if !defined_placeholders.contains(&placeholder.ident) {\n-                undefined.push(format!(\"${}\", placeholder.ident));\n+                undefined.push(placeholder.ident.to_string());\n             }\n             if !placeholder.constraints.is_empty() {\n                 bail!(\"Replacement placeholders cannot have constraints\");\n@@ -344,7 +348,17 @@ impl NodeKind {\n \n impl Placeholder {\n     fn new(name: SmolStr, constraints: Vec<Constraint>) -> Self {\n-        Self { stand_in_name: format!(\"__placeholder_{}\", name), constraints, ident: name }\n+        Self {\n+            stand_in_name: format!(\"__placeholder_{}\", name),\n+            constraints,\n+            ident: Var(name.to_string()),\n+        }\n+    }\n+}\n+\n+impl Display for Var {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"${}\", self.0)\n     }\n }\n "}, {"sha": "496a21e6e17310d29ca1caad38506ac72311019f", "filename": "crates/ssr/src/replacing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea/crates%2Fssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea/crates%2Fssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Freplacing.rs?ref=c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "patch": "@@ -1,6 +1,5 @@\n //! Code for applying replacement templates for matches that have previously been found.\n \n-use crate::matching::Var;\n use crate::{resolving::ResolvedRule, Match, SsrMatches};\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast::{self, AstToken};\n@@ -114,7 +113,7 @@ impl ReplacementRenderer<'_> {\n     fn render_token(&mut self, token: &SyntaxToken) {\n         if let Some(placeholder) = self.rule.get_placeholder(&token) {\n             if let Some(placeholder_value) =\n-                self.match_info.placeholder_values.get(&Var(placeholder.ident.to_string()))\n+                self.match_info.placeholder_values.get(&placeholder.ident)\n             {\n                 let range = &placeholder_value.range.range;\n                 let mut matched_text ="}, {"sha": "65cd387530dd866fef7741f1ffaadb79b3b95d57", "filename": "crates/ssr/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea/crates%2Fssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c84f98385a28eeb7595f38b7cfaf861a6e06f4ea/crates%2Fssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Ftests.rs?ref=c84f98385a28eeb7595f38b7cfaf861a6e06f4ea", "patch": "@@ -31,7 +31,7 @@ fn parser_two_delimiters() {\n fn parser_repeated_name() {\n     assert_eq!(\n         parse_error_text(\"foo($a, $a) ==>>\"),\n-        \"Parse error: Name `a` repeats more than once\"\n+        \"Parse error: Placeholder `$a` repeats more than once\"\n     );\n }\n "}]}