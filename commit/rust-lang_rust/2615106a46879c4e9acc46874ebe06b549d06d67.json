{"sha": "2615106a46879c4e9acc46874ebe06b549d06d67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MTUxMDZhNDY4NzljNGU5YWNjNDY4NzRlYmUwNmI1NDlkMDZkNjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-03T12:59:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-03T12:59:11Z"}, "message": "Auto merge of #23938 - nikomatsakis:invariant, r=pnkfelix\n\nThere are still some remnants we could remove from the compiler (e.g. references to \"subtraitrefs\"; traits still have variance entries in the variance table), but this removes all user-visible bits I believe.\r\n\r\nr? @pnkfelix \r\n\r\nFixes #22806 (since such traits would no longer exist)", "tree": {"sha": "ff0db692eea6e665abce78542b5017a2c94c6129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff0db692eea6e665abce78542b5017a2c94c6129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2615106a46879c4e9acc46874ebe06b549d06d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2615106a46879c4e9acc46874ebe06b549d06d67", "html_url": "https://github.com/rust-lang/rust/commit/2615106a46879c4e9acc46874ebe06b549d06d67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2615106a46879c4e9acc46874ebe06b549d06d67/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82dcec7ee4a8a71fdfb8e8771ae6785261ec1d5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/82dcec7ee4a8a71fdfb8e8771ae6785261ec1d5b", "html_url": "https://github.com/rust-lang/rust/commit/82dcec7ee4a8a71fdfb8e8771ae6785261ec1d5b"}, {"sha": "c2dba8580a5e472cc3344792030306130b1e5636", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2dba8580a5e472cc3344792030306130b1e5636", "html_url": "https://github.com/rust-lang/rust/commit/c2dba8580a5e472cc3344792030306130b1e5636"}], "stats": {"total": 915, "additions": 332, "deletions": 583}, "files": [{"sha": "3f85af9719778ea780a7fd983b09674e732fe607", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -192,13 +192,16 @@ struct TyDesc {\n     align: usize\n }\n \n+trait AllTypes { fn dummy(&self) { } }\n+impl<T:?Sized> AllTypes for T { }\n+\n unsafe fn get_tydesc<T>() -> *const TyDesc {\n     use std::raw::TraitObject;\n \n     let ptr = &*(1 as *const T);\n \n     // Can use any trait that is implemented for all types.\n-    let obj = mem::transmute::<&marker::MarkerTrait, TraitObject>(ptr);\n+    let obj = mem::transmute::<&AllTypes, TraitObject>(ptr);\n     obj.vtable as *const TyDesc\n }\n "}, {"sha": "352f7d869774c3c18ed5feeefeedf8a149c73633", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 34, "deletions": 73, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -35,6 +35,7 @@ use hash::Hasher;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n+#[allow(deprecated)]\n pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n@@ -50,6 +51,7 @@ impl !Send for Managed { }\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n+#[allow(deprecated)]\n pub trait Sized : MarkerTrait {\n     // Empty.\n }\n@@ -203,6 +205,7 @@ pub trait Copy : Clone {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n+#[allow(deprecated)]\n pub unsafe trait Sync : MarkerTrait {\n     // Empty\n }\n@@ -269,84 +272,41 @@ macro_rules! impls{\n         )\n }\n \n-/// `MarkerTrait` is intended to be used as the supertrait for traits\n-/// that don't have any methods but instead serve just to designate\n-/// categories of types. An example would be the `Send` trait, which\n-/// indicates types that are sendable: `Send` does not itself offer\n-/// any methods, but instead is used to gate access to data.\n-///\n-/// FIXME. Better documentation needed here!\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+/// `MarkerTrait` is deprecated and no longer needed.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n+#[allow(deprecated)]\n+#[cfg(stage0)]\n pub trait MarkerTrait : PhantomFn<Self,Self> { }\n-//                                    ~~~~~ <-- FIXME(#22806)?\n-//\n-// Marker trait has been made invariant so as to avoid inf recursion,\n-// but we should ideally solve the underlying problem. That's a bit\n-// complicated.\n \n+/// `MarkerTrait` is deprecated and no longer needed.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n+#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+pub trait MarkerTrait { }\n+\n+#[allow(deprecated)]\n impl<T:?Sized> MarkerTrait for T { }\n \n-/// `PhantomFn` is a marker trait for use with traits that contain\n-/// type or lifetime parameters that do not appear in any of their\n-/// methods. In that case, you can either remove those parameters, or\n-/// add a `PhantomFn` supertrait that reflects the signature of\n-/// methods that compiler should \"pretend\" exists. This most commonly\n-/// occurs for traits with no methods: in that particular case, you\n-/// can extend `MarkerTrait`, which is equivalent to\n-/// `PhantomFn<Self>`.\n-///\n-/// # Examples\n-///\n-/// As an example, consider a trait with no methods like `Even`, meant\n-/// to represent types that are \"even\":\n-///\n-/// ```rust,ignore\n-/// trait Even { }\n-/// ```\n-///\n-/// In this case, because the implicit parameter `Self` is unused, the\n-/// compiler will issue an error. The only purpose of this trait is to\n-/// categorize types (and hence instances of those types) as \"even\" or\n-/// not, so if we *were* going to have a method, it might look like:\n-///\n-/// ```rust,ignore\n-/// trait Even {\n-///     fn is_even(self) -> bool { true }\n-/// }\n-/// ```\n-///\n-/// Therefore, we can model a method like this as follows:\n-///\n-/// ```\n-/// use std::marker::PhantomFn;\n-/// trait Even : PhantomFn<Self> { }\n-/// ```\n-///\n-/// Another equivalent, but clearer, option would be to use\n-/// `MarkerTrait`:\n-///\n-/// ```\n-/// # #![feature(core)]\n-/// use std::marker::MarkerTrait;\n-/// trait Even : MarkerTrait { }\n-/// ```\n-///\n-/// # Parameters\n-///\n-/// - `A` represents the type of the method's argument. You can use a\n-///   tuple to represent \"multiple\" arguments. Any types appearing here\n-///   will be considered \"contravariant\".\n-/// - `R`, if supplied, represents the method's return type. This defaults\n-///   to `()` as it is rarely needed.\n-///\n-/// # Additional reading\n-///\n-/// More details and background can be found in [RFC 738][738].\n-///\n-/// [738]: https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\n+/// `PhantomFn` is a deprecated marker trait that is no longer needed.\n #[lang=\"phantom_fn\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n+#[cfg(stage0)]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n+}\n+\n+/// `PhantomFn` is a deprecated marker trait that is no longer needed.\n+#[unstable(feature = \"core\", reason = \"deprecated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"No longer needed\")]\n+#[cfg(not(stage0))]\n+pub trait PhantomFn<A:?Sized,R:?Sized=()> {\n+}\n+\n+#[allow(deprecated)]\n+#[cfg(not(stage0))]\n+impl<A:?Sized,R:?Sized,T:?Sized> PhantomFn<A,R> for T { }\n \n /// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n /// even though it does not. This allows you to inform the compiler about certain safety properties\n@@ -444,6 +404,7 @@ mod impls {\n /// [1]: http://en.wikipedia.org/wiki/Parametricity\n #[rustc_reflect_like]\n #[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n+#[allow(deprecated)]\n pub trait Reflect : MarkerTrait {\n }\n "}, {"sha": "3df4d00f60cc4c941e5007d872d6de64bc624c84", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -14,6 +14,7 @@ use marker::{Sized, MarkerTrait};\n use ops::Deref;\n \n /// Unsafe trait to indicate what types are usable with the NonZero struct\n+#[allow(deprecated)]\n pub unsafe trait Zeroable : MarkerTrait {}\n \n unsafe impl<T:?Sized> Zeroable for *const T {}"}, {"sha": "89a8625856c2c61851d1e5258e63899677ea2ab0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -321,7 +321,6 @@ lets_do_this! {\n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n     OwnedBoxLangItem,                \"owned_box\",               owned_box;\n \n-    PhantomFnItem,                   \"phantom_fn\",              phantom_fn;\n     PhantomDataItem,                 \"phantom_data\",            phantom_data;\n \n     // Deprecated:"}, {"sha": "a2ff86cd065901d4115458f6a4fb323bde8541cb", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -138,11 +138,10 @@ fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n             match predicate {\n                 ty::Predicate::Trait(ref data) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n-                    Some(data.def_id()) != tcx.lang_items.phantom_fn() &&\n-                        data.0.trait_ref.substs.types.get_slice(TypeSpace)\n-                                                     .iter()\n-                                                     .cloned()\n-                                                     .any(is_self)\n+                    data.0.trait_ref.substs.types.get_slice(TypeSpace)\n+                                                 .iter()\n+                                                 .cloned()\n+                                                 .any(is_self)\n                 }\n                 ty::Predicate::Projection(..) |\n                 ty::Predicate::TypeOutlives(..) |"}, {"sha": "ad7d96c652d9ba670be1df207c598d0c235df1b0", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -836,14 +836,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ambiguous: false\n         };\n \n-        // Check for the `PhantomFn` trait. This is really just a\n-        // special annotation that is *always* considered to match, no\n-        // matter what the type parameters are etc.\n-        if self.tcx().lang_items.phantom_fn() == Some(obligation.predicate.def_id()) {\n-            candidates.vec.push(PhantomFnCandidate);\n-            return Ok(candidates);\n-        }\n-\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n "}, {"sha": "3a55a64314ed9293ada85b6d6a7714edd06c2c93", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -122,11 +122,11 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n     relate_substs(relation, opt_variances, a_subst, b_subst)\n }\n \n-fn relate_substs<'a,'tcx,R>(relation: &mut R,\n-                            variances: Option<&ty::ItemVariances>,\n-                            a_subst: &Substs<'tcx>,\n-                            b_subst: &Substs<'tcx>)\n-                            -> RelateResult<'tcx, Substs<'tcx>>\n+fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n+                               variances: Option<&ty::ItemVariances>,\n+                               a_subst: &Substs<'tcx>,\n+                               b_subst: &Substs<'tcx>)\n+                               -> RelateResult<'tcx, Substs<'tcx>>\n     where R: TypeRelation<'a,'tcx>\n {\n     let mut substs = Substs::empty();\n@@ -161,11 +161,11 @@ fn relate_substs<'a,'tcx,R>(relation: &mut R,\n     Ok(substs)\n }\n \n-fn relate_type_params<'a,'tcx,R>(relation: &mut R,\n-                                 variances: Option<&[ty::Variance]>,\n-                                 a_tys: &[Ty<'tcx>],\n-                                 b_tys: &[Ty<'tcx>])\n-                                 -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+fn relate_type_params<'a,'tcx:'a,R>(relation: &mut R,\n+                                    variances: Option<&[ty::Variance]>,\n+                                    a_tys: &[Ty<'tcx>],\n+                                    b_tys: &[Ty<'tcx>])\n+                                    -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n     where R: TypeRelation<'a,'tcx>\n {\n     if a_tys.len() != b_tys.len() {\n@@ -264,10 +264,10 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n     }\n }\n \n-fn relate_arg_vecs<'a,'tcx,R>(relation: &mut R,\n-                              a_args: &[Ty<'tcx>],\n-                              b_args: &[Ty<'tcx>])\n-                              -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+fn relate_arg_vecs<'a,'tcx:'a,R>(relation: &mut R,\n+                                 a_args: &[Ty<'tcx>],\n+                                 b_args: &[Ty<'tcx>])\n+                                 -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n     where R: TypeRelation<'a,'tcx>\n {\n     if a_args.len() != b_args.len() {\n@@ -629,10 +629,10 @@ impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n \n-pub fn expected_found<'a,'tcx,R,T>(relation: &mut R,\n-                                   a: &T,\n-                                   b: &T)\n-                                   -> ty::expected_found<T>\n+pub fn expected_found<'a,'tcx:'a,R,T>(relation: &mut R,\n+                                      a: &T,\n+                                      b: &T)\n+                                      -> ty::expected_found<T>\n     where R: TypeRelation<'a,'tcx>, T: Clone\n {\n     expected_found_bool(relation.a_is_expected(), a, b)"}, {"sha": "eb06caf7d5a63ecb9a3f53b886620fa4fa817531", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 7, "deletions": 35, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -117,15 +117,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n                 self.check_variances_for_type_defn(item, ast_generics);\n             }\n-            ast::ItemTrait(_, ref ast_generics, _, ref items) => {\n+            ast::ItemTrait(_, _, _, ref items) => {\n                 let trait_predicates =\n                     ty::lookup_predicates(ccx.tcx, local_def(item.id));\n-                reject_non_type_param_bounds(\n-                    ccx.tcx,\n-                    item.span,\n-                    &trait_predicates);\n-                self.check_variances(item, ast_generics, &trait_predicates,\n-                                     self.tcx().lang_items.phantom_fn());\n+                reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n                 if ty::trait_has_default_impl(ccx.tcx, local_def(item.id)) {\n                     if !items.is_empty() {\n                         ccx.tcx.sess.span_err(\n@@ -287,30 +282,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                      ast_generics: &ast::Generics)\n     {\n         let item_def_id = local_def(item.id);\n-        let predicates = ty::lookup_predicates(self.tcx(), item_def_id);\n-        self.check_variances(item,\n-                             ast_generics,\n-                             &predicates,\n-                             self.tcx().lang_items.phantom_data());\n-    }\n-\n-    fn check_variances(&self,\n-                       item: &ast::Item,\n-                       ast_generics: &ast::Generics,\n-                       ty_predicates: &ty::GenericPredicates<'tcx>,\n-                       suggested_marker_id: Option<ast::DefId>)\n-    {\n-        let variance_lang_items = &[\n-            self.tcx().lang_items.phantom_fn(),\n-            self.tcx().lang_items.phantom_data(),\n-        ];\n-\n-        let item_def_id = local_def(item.id);\n-        let is_lang_item = variance_lang_items.iter().any(|n| *n == Some(item_def_id));\n-        if is_lang_item {\n-            return;\n-        }\n-\n+        let ty_predicates = ty::lookup_predicates(self.tcx(), item_def_id);\n         let variances = ty::item_variances(self.tcx(), item_def_id);\n \n         let mut constrained_parameters: HashSet<_> =\n@@ -331,7 +303,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 continue;\n             }\n             let span = self.ty_param_span(ast_generics, item, space, index);\n-            self.report_bivariance(span, param_ty.name, suggested_marker_id);\n+            self.report_bivariance(span, param_ty.name);\n         }\n \n         for (space, index, &variance) in variances.regions.iter_enumerated() {\n@@ -342,7 +314,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             assert_eq!(space, TypeSpace);\n             let span = ast_generics.lifetimes[index].lifetime.span;\n             let name = ast_generics.lifetimes[index].lifetime.name;\n-            self.report_bivariance(span, name, suggested_marker_id);\n+            self.report_bivariance(span, name);\n         }\n     }\n \n@@ -377,14 +349,14 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn report_bivariance(&self,\n                          span: Span,\n-                         param_name: ast::Name,\n-                         suggested_marker_id: Option<ast::DefId>)\n+                         param_name: ast::Name)\n     {\n         self.tcx().sess.span_err(\n             span,\n             &format!(\"parameter `{}` is never used\",\n                      param_name.user_string(self.tcx())));\n \n+        let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n             Some(def_id) => {\n                 self.tcx().sess.fileline_help("}, {"sha": "da2de731d648a570a8e06174a12eb882445e13b1", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 127, "deletions": 211, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -18,34 +18,121 @@\n //! defined on type `X`, we only consider the definition of the type `X`\n //! and the definitions of any types it references.\n //!\n-//! We only infer variance for type parameters found on *types*: structs,\n-//! enums, and traits. We do not infer variance for type parameters found\n-//! on fns or impls. This is because those things are not type definitions\n-//! and variance doesn't really make sense in that context.\n-//!\n-//! It is worth covering what variance means in each case. For structs and\n-//! enums, I think it is fairly straightforward. The variance of the type\n+//! We only infer variance for type parameters found on *data types*\n+//! like structs and enums. In these cases, there is fairly straightforward\n+//! explanation for what variance means. The variance of the type\n //! or lifetime parameters defines whether `T<A>` is a subtype of `T<B>`\n //! (resp. `T<'a>` and `T<'b>`) based on the relationship of `A` and `B`\n-//! (resp. `'a` and `'b`). (FIXME #3598 -- we do not currently make use of\n-//! the variances we compute for type parameters.)\n+//! (resp. `'a` and `'b`).\n+//!\n+//! We do not infer variance for type parameters found on traits, fns,\n+//! or impls. Variance on trait parameters can make indeed make sense\n+//! (and we used to compute it) but it is actually rather subtle in\n+//! meaning and not that useful in practice, so we removed it. See the\n+//! addendum for some details. Variances on fn/impl parameters, otoh,\n+//! doesn't make sense because these parameters are instantiated and\n+//! then forgotten, they don't persist in types or compiled\n+//! byproducts.\n+//!\n+//! ### The algorithm\n+//!\n+//! The basic idea is quite straightforward. We iterate over the types\n+//! defined and, for each use of a type parameter X, accumulate a\n+//! constraint indicating that the variance of X must be valid for the\n+//! variance of that use site. We then iteratively refine the variance of\n+//! X until all constraints are met. There is *always* a sol'n, because at\n+//! the limit we can declare all type parameters to be invariant and all\n+//! constraints will be satisfied.\n+//!\n+//! As a simple example, consider:\n+//!\n+//!     enum Option<A> { Some(A), None }\n+//!     enum OptionalFn<B> { Some(|B|), None }\n+//!     enum OptionalMap<C> { Some(|C| -> C), None }\n+//!\n+//! Here, we will generate the constraints:\n+//!\n+//!     1. V(A) <= +\n+//!     2. V(B) <= -\n+//!     3. V(C) <= +\n+//!     4. V(C) <= -\n+//!\n+//! These indicate that (1) the variance of A must be at most covariant;\n+//! (2) the variance of B must be at most contravariant; and (3, 4) the\n+//! variance of C must be at most covariant *and* contravariant. All of these\n+//! results are based on a variance lattice defined as follows:\n+//!\n+//!       *      Top (bivariant)\n+//!    -     +\n+//!       o      Bottom (invariant)\n+//!\n+//! Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n+//! optimal solution. Note that there is always a naive solution which\n+//! just declares all variables to be invariant.\n+//!\n+//! You may be wondering why fixed-point iteration is required. The reason\n+//! is that the variance of a use site may itself be a function of the\n+//! variance of other type parameters. In full generality, our constraints\n+//! take the form:\n+//!\n+//!     V(X) <= Term\n+//!     Term := + | - | * | o | V(X) | Term x Term\n+//!\n+//! Here the notation V(X) indicates the variance of a type/region\n+//! parameter `X` with respect to its defining class. `Term x Term`\n+//! represents the \"variance transform\" as defined in the paper:\n+//!\n+//!   If the variance of a type variable `X` in type expression `E` is `V2`\n+//!   and the definition-site variance of the [corresponding] type parameter\n+//!   of a class `C` is `V1`, then the variance of `X` in the type expression\n+//!   `C<E>` is `V3 = V1.xform(V2)`.\n+//!\n+//! ### Constraints\n+//!\n+//! If I have a struct or enum with where clauses:\n+//!\n+//!     struct Foo<T:Bar> { ... }\n+//!\n+//! you might wonder whether the variance of `T` with respect to `Bar`\n+//! affects the variance `T` with respect to `Foo`. I claim no.  The\n+//! reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n+//! `Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n+//! `X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n+//! case, the upcast will be illegal, but not because of a variance\n+//! failure, but rather because the target type `Foo<Y>` is itself just\n+//! not well-formed. Basically we get to assume well-formedness of all\n+//! types involved before considering variance.\n+//!\n+//! ### Addendum: Variance on traits\n //!\n-//! ### Variance on traits\n+//! As mentioned above, we used to permit variance on traits. This was\n+//! computed based on the appearance of trait type parameters in\n+//! method signatures and was used to represent the compatibility of\n+//! vtables in trait objects (and also \"virtual\" vtables or dictionary\n+//! in trait bounds). One complication was that variance for\n+//! associated types is less obvious, since they can be projected out\n+//! and put to myriad uses, so it's not clear when it is safe to allow\n+//! `X<A>::Bar` to vary (or indeed just what that means). Moreover (as\n+//! covered below) all inputs on any trait with an associated type had\n+//! to be invariant, limiting the applicability. Finally, the\n+//! annotations (`MarkerTrait`, `PhantomFn`) needed to ensure that all\n+//! trait type parameters had a variance were confusing and annoying\n+//! for little benefit.\n //!\n-//! The meaning of variance for trait parameters is more subtle and worth\n-//! expanding upon. There are in fact two uses of the variance values we\n-//! compute.\n+//! Just for historical reference,I am going to preserve some text indicating\n+//! how one could interpret variance and trait matching.\n //!\n-//! #### Trait variance and object types\n+//! #### Variance and object types\n //!\n-//! The first is for object types. Just as with structs and enums, we can\n-//! decide the subtyping relationship between two object types `&Trait<A>`\n-//! and `&Trait<B>` based on the relationship of `A` and `B`. Note that\n-//! for object types we ignore the `Self` type parameter -- it is unknown,\n-//! and the nature of dynamic dispatch ensures that we will always call a\n+//! Just as with structs and enums, we can decide the subtyping\n+//! relationship between two object types `&Trait<A>` and `&Trait<B>`\n+//! based on the relationship of `A` and `B`. Note that for object\n+//! types we ignore the `Self` type parameter -- it is unknown, and\n+//! the nature of dynamic dispatch ensures that we will always call a\n //! function that is expected the appropriate `Self` type. However, we\n-//! must be careful with the other type parameters, or else we could end\n-//! up calling a function that is expecting one type but provided another.\n+//! must be careful with the other type parameters, or else we could\n+//! end up calling a function that is expecting one type but provided\n+//! another.\n //!\n //! To see what I mean, consider a trait like so:\n //!\n@@ -135,104 +222,24 @@\n //!\n //! These conditions are satisfied and so we are happy.\n //!\n-//! ### The algorithm\n+//! #### Variance and associated types\n //!\n-//! The basic idea is quite straightforward. We iterate over the types\n-//! defined and, for each use of a type parameter X, accumulate a\n-//! constraint indicating that the variance of X must be valid for the\n-//! variance of that use site. We then iteratively refine the variance of\n-//! X until all constraints are met. There is *always* a sol'n, because at\n-//! the limit we can declare all type parameters to be invariant and all\n-//! constraints will be satisfied.\n-//!\n-//! As a simple example, consider:\n-//!\n-//!     enum Option<A> { Some(A), None }\n-//!     enum OptionalFn<B> { Some(|B|), None }\n-//!     enum OptionalMap<C> { Some(|C| -> C), None }\n-//!\n-//! Here, we will generate the constraints:\n-//!\n-//!     1. V(A) <= +\n-//!     2. V(B) <= -\n-//!     3. V(C) <= +\n-//!     4. V(C) <= -\n-//!\n-//! These indicate that (1) the variance of A must be at most covariant;\n-//! (2) the variance of B must be at most contravariant; and (3, 4) the\n-//! variance of C must be at most covariant *and* contravariant. All of these\n-//! results are based on a variance lattice defined as follows:\n-//!\n-//!       *      Top (bivariant)\n-//!    -     +\n-//!       o      Bottom (invariant)\n-//!\n-//! Based on this lattice, the solution V(A)=+, V(B)=-, V(C)=o is the\n-//! optimal solution. Note that there is always a naive solution which\n-//! just declares all variables to be invariant.\n-//!\n-//! You may be wondering why fixed-point iteration is required. The reason\n-//! is that the variance of a use site may itself be a function of the\n-//! variance of other type parameters. In full generality, our constraints\n-//! take the form:\n-//!\n-//!     V(X) <= Term\n-//!     Term := + | - | * | o | V(X) | Term x Term\n-//!\n-//! Here the notation V(X) indicates the variance of a type/region\n-//! parameter `X` with respect to its defining class. `Term x Term`\n-//! represents the \"variance transform\" as defined in the paper:\n-//!\n-//!   If the variance of a type variable `X` in type expression `E` is `V2`\n-//!   and the definition-site variance of the [corresponding] type parameter\n-//!   of a class `C` is `V1`, then the variance of `X` in the type expression\n-//!   `C<E>` is `V3 = V1.xform(V2)`.\n-//!\n-//! ### Constraints\n-//!\n-//! If I have a struct or enum with where clauses:\n-//!\n-//!     struct Foo<T:Bar> { ... }\n-//!\n-//! you might wonder whether the variance of `T` with respect to `Bar`\n-//! affects the variance `T` with respect to `Foo`. I claim no.  The\n-//! reason: assume that `T` is invariant w/r/t `Bar` but covariant w/r/t\n-//! `Foo`. And then we have a `Foo<X>` that is upcast to `Foo<Y>`, where\n-//! `X <: Y`. However, while `X : Bar`, `Y : Bar` does not hold.  In that\n-//! case, the upcast will be illegal, but not because of a variance\n-//! failure, but rather because the target type `Foo<Y>` is itself just\n-//! not well-formed. Basically we get to assume well-formedness of all\n-//! types involved before considering variance.\n-//!\n-//! ### Associated types\n-//!\n-//! Any trait with an associated type is invariant with respect to all\n-//! of its inputs. To see why this makes sense, consider what\n-//! subtyping for a trait reference means:\n+//! Traits with associated types -- or at minimum projection\n+//! expressions -- must be invariant with respect to all of their\n+//! inputs. To see why this makes sense, consider what subtyping for a\n+//! trait reference means:\n //!\n //!    <T as Trait> <: <U as Trait>\n //!\n-//! means that if I know that `T as Trait`,\n-//! I also know that `U as\n-//! Trait`. Moreover, if you think of it as\n-//! dictionary passing style, it means that\n-//! a dictionary for `<T as Trait>` is safe\n-//! to use where a dictionary for `<U as\n-//! Trait>` is expected.\n-//!\n-//! The problem is that when you can\n-//! project types out from `<T as Trait>`,\n-//! the relationship to types projected out\n-//! of `<U as Trait>` is completely unknown\n-//! unless `T==U` (see #21726 for more\n-//! details). Making `Trait` invariant\n-//! ensures that this is true.\n+//! means that if I know that `T as Trait`, I also know that `U as\n+//! Trait`. Moreover, if you think of it as dictionary passing style,\n+//! it means that a dictionary for `<T as Trait>` is safe to use where\n+//! a dictionary for `<U as Trait>` is expected.\n //!\n-//! *Historical note: we used to preserve this invariant another way,\n-//! by tweaking the subtyping rules and requiring that when a type `T`\n-//! appeared as part of a projection, that was considered an invariant\n-//! location, but this version does away with the need for those\n-//! somewhat \"special-case-feeling\" rules.*\n+//! The problem is that when you can project types out from `<T as\n+//! Trait>`, the relationship to types projected out of `<U as Trait>`\n+//! is completely unknown unless `T==U` (see #21726 for more\n+//! details). Making `Trait` invariant ensures that this is true.\n //!\n //! Another related reason is that if we didn't make traits with\n //! associated types invariant, then projection is no longer a\n@@ -383,7 +390,6 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n \n fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n     let all = vec![\n-        (tcx.lang_items.phantom_fn(), vec![ty::Contravariant, ty::Covariant]),\n         (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n         (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n \n@@ -520,6 +526,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n                 self.add_inferreds_for_item(item.id, false, generics);\n             }\n             ast::ItemTrait(_, ref generics, _, _) => {\n+                // Note: all inputs for traits are ultimately\n+                // constrained to be invariant. See `visit_item` in\n+                // the impl for `ConstraintContext` below.\n                 self.add_inferreds_for_item(item.id, true, generics);\n                 visit::walk_item(self, item);\n             }\n@@ -644,39 +653,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n             ast::ItemTrait(..) => {\n                 let trait_def = ty::lookup_trait_def(tcx, did);\n-                let predicates = ty::lookup_super_predicates(tcx, did);\n-                self.add_constraints_from_predicates(&trait_def.generics,\n-                                                     predicates.predicates.as_slice(),\n-                                                     self.covariant);\n-\n-                let trait_items = ty::trait_items(tcx, did);\n-                for trait_item in &*trait_items {\n-                    match *trait_item {\n-                        ty::MethodTraitItem(ref method) => {\n-                            self.add_constraints_from_predicates(\n-                                &method.generics,\n-                                method.predicates.predicates.get_slice(FnSpace),\n-                                self.contravariant);\n-\n-                            self.add_constraints_from_sig(\n-                                &method.generics,\n-                                &method.fty.sig,\n-                                self.covariant);\n-                        }\n-                        ty::TypeTraitItem(ref data) => {\n-                            // Any trait with an associated type is\n-                            // invariant with respect to all of its\n-                            // inputs. See length discussion in the comment\n-                            // on this module.\n-                            let projection_ty = ty::mk_projection(tcx,\n-                                                                  trait_def.trait_ref.clone(),\n-                                                                  data.name);\n-                            self.add_constraints_from_ty(&trait_def.generics,\n-                                                         projection_ty,\n-                                                         self.invariant);\n-                        }\n-                    }\n-                }\n+                self.add_constraints_from_trait_ref(&trait_def.generics,\n+                                                    &trait_def.trait_ref,\n+                                                    self.invariant);\n             }\n \n             ast::ItemExternCrate(_) |\n@@ -1045,69 +1024,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n-    fn add_constraints_from_predicates(&mut self,\n-                                       generics: &ty::Generics<'tcx>,\n-                                       predicates: &[ty::Predicate<'tcx>],\n-                                       variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraints_from_generics({})\",\n-               generics.repr(self.tcx()));\n-\n-        for predicate in predicates.iter() {\n-            match *predicate {\n-                ty::Predicate::Trait(ty::Binder(ref data)) => {\n-                    self.add_constraints_from_trait_ref(generics, &*data.trait_ref, variance);\n-                }\n-\n-                ty::Predicate::Equate(ty::Binder(ref data)) => {\n-                    // A == B is only true if A and B are the same\n-                    // types, not subtypes of one another, so this is\n-                    // an invariant position:\n-                    self.add_constraints_from_ty(generics, data.0, self.invariant);\n-                    self.add_constraints_from_ty(generics, data.1, self.invariant);\n-                }\n-\n-                ty::Predicate::TypeOutlives(ty::Binder(ref data)) => {\n-                    // Why contravariant on both? Let's consider:\n-                    //\n-                    // Under what conditions is `(T:'t) <: (U:'u)`,\n-                    // meaning that `(T:'t) => (U:'u)`. The answer is\n-                    // if `U <: T` or `'u <= 't`. Let's see some examples:\n-                    //\n-                    //   (T: 'big) => (T: 'small)\n-                    //   where 'small <= 'big\n-                    //\n-                    //   (&'small Foo: 't) => (&'big Foo: 't)\n-                    //   where 'small <= 'big\n-                    //   note that &'big Foo <: &'small Foo\n-\n-                    let variance_r = self.xform(variance, self.contravariant);\n-                    self.add_constraints_from_ty(generics, data.0, variance_r);\n-                    self.add_constraints_from_region(generics, data.1, variance_r);\n-                }\n-\n-                ty::Predicate::RegionOutlives(ty::Binder(ref data)) => {\n-                    // `'a : 'b` is still true if 'a gets bigger\n-                    self.add_constraints_from_region(generics, data.0, variance);\n-\n-                    // `'a : 'b` is still true if 'b gets smaller\n-                    let variance_r = self.xform(variance, self.contravariant);\n-                    self.add_constraints_from_region(generics, data.1, variance_r);\n-                }\n-\n-                ty::Predicate::Projection(ty::Binder(ref data)) => {\n-                    self.add_constraints_from_trait_ref(generics,\n-                                                        &*data.projection_ty.trait_ref,\n-                                                        variance);\n-\n-                    // as the equality predicate above, a binder is a\n-                    // type equality relation, not a subtyping\n-                    // relation\n-                    self.add_constraints_from_ty(generics, data.ty, self.invariant);\n-                }\n-            }\n-        }\n-    }\n-\n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,"}, {"sha": "d3d389c6a8bd52da51a2579ea7bf4c6408ee2c69", "filename": "src/test/auxiliary/coherence_copy_like_lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fauxiliary%2Fcoherence_copy_like_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fauxiliary%2Fcoherence_copy_like_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence_copy_like_lib.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -11,9 +11,7 @@\n #![crate_type = \"rlib\"]\n #![feature(fundamental)]\n \n-use std::marker::MarkerTrait;\n-\n-pub trait MyCopy : MarkerTrait { }\n+pub trait MyCopy { }\n impl MyCopy for i32 { }\n \n pub struct MyStruct<T>(T);"}, {"sha": "b22d12300c7d1297a05884baba7349503dc7923a", "filename": "src/test/auxiliary/coherence_orphan_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fauxiliary%2Fcoherence_orphan_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fauxiliary%2Fcoherence_orphan_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence_orphan_lib.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait TheTrait<T> : ::std::marker::PhantomFn<T> {\n+pub trait TheTrait<T> {\n     fn the_fn(&self);\n }"}, {"sha": "d195bd7e77bd8bb9ae335f9ad155f9c816abe413", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -12,12 +12,8 @@\n #![no_std]\n #![feature(lang_items)]\n \n-#[lang=\"phantom_fn\"]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n-impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n-\n #[lang=\"sized\"]\n-pub trait Sized : PhantomFn<Self> {}\n+pub trait Sized { }\n \n #[lang=\"panic\"]\n fn panic(_: &(&'static str, &'static str, usize)) -> ! { loop {} }\n@@ -29,7 +25,7 @@ extern fn stack_exhausted() {}\n extern fn eh_personality() {}\n \n #[lang=\"copy\"]\n-pub trait Copy : PhantomFn<Self> {\n+pub trait Copy {\n     // Empty.\n }\n "}, {"sha": "0e083e4723634fa623ca4c4408adb2254175119a", "filename": "src/test/compile-fail/associated-types-ICE-when-projecting-out-of-err.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -16,12 +16,8 @@\n #![feature(no_std)]\n #![no_std]\n \n-#[lang=\"phantom_fn\"]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n-impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n-\n #[lang=\"sized\"]\n-pub trait Sized : PhantomFn<Self> {\n+pub trait Sized {\n     // Empty.\n }\n "}, {"sha": "fcd6e5c4952074807d0ed8abe876b71956282b0a", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -18,11 +18,9 @@\n \n extern crate coherence_copy_like_lib as lib;\n \n-use std::marker::MarkerTrait;\n-\n struct MyType { x: i32 }\n \n-trait MyTrait : MarkerTrait { }\n+trait MyTrait { }\n impl<T: lib::MyCopy> MyTrait for T { }\n \n // `MyFundamentalStruct` is declared fundamental, so we can test that"}, {"sha": "b5c0a7fb5f564829fda4f13331cb4089ec3ed696", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_ref.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -18,11 +18,9 @@\n \n extern crate coherence_copy_like_lib as lib;\n \n-use std::marker::MarkerTrait;\n-\n struct MyType { x: i32 }\n \n-trait MyTrait : MarkerTrait { }\n+trait MyTrait { }\n impl<T: lib::MyCopy> MyTrait for T { }\n \n // `MyFundamentalStruct` is declared fundamental, so we can test that"}, {"sha": "ea0d880f4a1cc6a04f9da5415257a3a780e97379", "filename": "src/test/compile-fail/issue-13853-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853-2.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::marker::PhantomFn;\n-\n-trait FromStructReader<'a> : PhantomFn<(Self,&'a ())> { }\n+trait FromStructReader<'a> { }\n trait ResponseHook {\n      fn get<'a, T: FromStructReader<'a>>(&'a self);\n }"}, {"sha": "a4a8eac682dc3c35b888f7c64d0ecd8c739801f2", "filename": "src/test/compile-fail/issue-19660.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fissue-19660.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fissue-19660.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19660.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -13,12 +13,8 @@\n #![feature(lang_items, start, no_std)]\n #![no_std]\n \n-#[lang=\"phantom_fn\"]\n-trait PhantomFn<A:?Sized,R:?Sized=()> { }\n-impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n-\n #[lang = \"sized\"]\n-trait Sized : PhantomFn<Self> {}\n+trait Sized { }\n \n #[start]\n fn main(_: isize, _: *const *const u8) -> isize {"}, {"sha": "d4ee93e9ca5d665df18e742aa256643c3de90c07", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -41,7 +41,7 @@ fn g<T>(val: T) {\n fn foo<'a>() {\n     let t: S<&'a isize> = S(marker::PhantomData);\n     let a = &t as &Gettable<&'a isize>;\n-    //~^ ERROR cannot infer\n+    //~^ ERROR does not fulfill\n }\n \n fn foo2<'a>() {"}, {"sha": "10f245aaaf9d742566d8f427bc1d778b4c5a1a9e", "filename": "src/test/compile-fail/lint-unsafe-code.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Flint-unsafe-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Flint-unsafe-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unsafe-code.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -12,18 +12,15 @@\n #![allow(dead_code)]\n #![deny(unsafe_code)]\n \n-use std::marker::PhantomFn;\n-\n struct Bar;\n struct Bar2;\n struct Bar3;\n \n #[allow(unsafe_code)]\n mod allowed_unsafe {\n-    use std::marker::PhantomFn;\n     fn allowed() { unsafe {} }\n     unsafe fn also_allowed() {}\n-    unsafe trait AllowedUnsafe : PhantomFn<Self> {}\n+    unsafe trait AllowedUnsafe { }\n     unsafe impl AllowedUnsafe for super::Bar {}\n }\n \n@@ -34,7 +31,7 @@ macro_rules! unsafe_in_macro {\n }\n \n unsafe fn baz() {} //~ ERROR: declaration of an `unsafe` function\n-unsafe trait Foo : PhantomFn<Self> {} //~ ERROR: declaration of an `unsafe` trait\n+unsafe trait Foo {} //~ ERROR: declaration of an `unsafe` trait\n unsafe impl Foo for Bar {} //~ ERROR: implementation of an `unsafe` trait\n \n trait Baz {"}, {"sha": "518c45ac9dff6d65a2f79f7464d45538557965bd", "filename": "src/test/compile-fail/object-safety-phantom-fn.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fobject-safety-phantom-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fobject-safety-phantom-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-phantom-fn.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -13,12 +13,10 @@\n #![feature(rustc_attrs)]\n #![allow(dead_code)]\n \n-use std::marker::PhantomFn;\n-\n-trait Baz : PhantomFn<Self> {\n+trait Baz {\n }\n \n-trait Bar<T> : PhantomFn<(Self, T)> {\n+trait Bar<T> {\n }\n \n fn make_bar<T:Bar<u32>>(t: &T) -> &Bar<u32> {"}, {"sha": "8580749084d22da1b39a356468d43611f01a0c57", "filename": "src/test/compile-fail/on-unimplemented-bad-anno.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fon-unimplemented-bad-anno.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fon-unimplemented-bad-anno.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented-bad-anno.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -13,11 +13,8 @@\n \n #![allow(unused)]\n \n-use std::marker;\n-\n #[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}` `{Baz}` `{Quux}`\"]\n trait Foo<Bar, Baz, Quux>\n-    : marker::PhantomFn<(Self,Bar,Baz,Quux)>\n {}\n \n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]\n@@ -28,19 +25,16 @@ trait MyFromIterator<A> {\n \n #[rustc_on_unimplemented] //~ ERROR this attribute must have a value\n trait BadAnnotation1\n-    : marker::MarkerTrait\n {}\n \n #[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{C}>`\"]\n //~^ ERROR there is no type parameter C on trait BadAnnotation2\n trait BadAnnotation2<A,B>\n-    : marker::PhantomFn<(Self,A,B)>\n {}\n \n #[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{}>`\"]\n //~^ only named substitution parameters are allowed\n trait BadAnnotation3<A,B>\n-    : marker::PhantomFn<(Self,A,B)>\n {}\n \n pub fn main() {"}, {"sha": "c4eb467c4f96143da28576de025979f19b89d101", "filename": "src/test/compile-fail/on-unimplemented.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -11,11 +11,8 @@\n \n #![feature(on_unimplemented)]\n \n-use std::marker;\n-\n #[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}` `{Baz}` `{Quux}`\"]\n trait Foo<Bar, Baz, Quux>\n-    : marker::PhantomFn<(Self,Bar,Baz,Quux)>\n {}\n \n fn foobar<U: Clone, T: Foo<u8, U, u32>>() -> T {"}, {"sha": "f728fdfaf9a80141e2311dac42ac67b4d47ac0ab", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -11,15 +11,11 @@\n #![feature(lang_items, start, no_std)]\n #![no_std] // makes debugging this test *a lot* easier (during resolve)\n \n-#[lang=\"phantom_fn\"]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n-impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n-\n #[lang=\"sized\"]\n-pub trait Sized : PhantomFn<Self> {}\n+pub trait Sized {}\n \n #[lang=\"copy\"]\n-pub trait Copy : PhantomFn<Self> {}\n+pub trait Copy {}\n \n mod bar {\n     // shouldn't bring in too much"}, {"sha": "bcb46663aa849da96e36e45d9275453948cdbff0", "filename": "src/test/compile-fail/privacy4.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -11,12 +11,8 @@\n #![feature(lang_items, start, no_std)]\n #![no_std] // makes debugging this test *a lot* easier (during resolve)\n \n-#[lang=\"phantom_fn\"]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n-impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n-\n-#[lang = \"sized\"] pub trait Sized : PhantomFn<Self> {}\n-#[lang=\"copy\"] pub trait Copy : PhantomFn<Self> {}\n+#[lang = \"sized\"] pub trait Sized {}\n+#[lang=\"copy\"] pub trait Copy {}\n \n // Test to make sure that private items imported through globs remain private\n // when  they're used."}, {"sha": "9a13541bd0b17a761997824f3b0f5d0f3fcdd757", "filename": "src/test/compile-fail/regions-assoc-type-in-supertrait-outlives-container.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-in-supertrait-outlives-container.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -15,11 +15,9 @@\n \n #![allow(dead_code)]\n \n-use std::marker::PhantomFn;\n-\n ///////////////////////////////////////////////////////////////////////////\n \n-pub trait TheTrait: PhantomFn<Self, Self> {\n+pub trait TheTrait {\n     type TheAssocType;\n }\n "}, {"sha": "0d3d2e296bec62e2026ad745a5ca4ab0dda52498", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container-hrtb.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-hrtb.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -14,11 +14,9 @@\n #![allow(dead_code)]\n #![feature(rustc_attrs)]\n \n-use std::marker::PhantomFn;\n-\n ///////////////////////////////////////////////////////////////////////////\n \n-pub trait TheTrait<'b> : PhantomFn<&'b Self,Self> {\n+pub trait TheTrait<'b> {\n     type TheAssocType;\n }\n "}, {"sha": "2ceaea98d279703f89aaf873deed387fca41e601", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container-wc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container-wc.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -15,11 +15,9 @@\n \n #![allow(dead_code)]\n \n-use std::marker::PhantomFn;\n-\n ///////////////////////////////////////////////////////////////////////////\n \n-pub trait TheTrait: PhantomFn<Self, Self> {\n+pub trait TheTrait {\n     type TheAssocType;\n }\n "}, {"sha": "e3e57ff17115cca9022f50950a3187e4111258b1", "filename": "src/test/compile-fail/regions-assoc-type-outlives-container.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-outlives-container.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -15,11 +15,9 @@\n #![allow(dead_code)]\n #![feature(rustc_attrs)]\n \n-use std::marker::PhantomFn;\n-\n ///////////////////////////////////////////////////////////////////////////\n \n-pub trait TheTrait: PhantomFn<Self, Self> {\n+pub trait TheTrait {\n     type TheAssocType;\n }\n "}, {"sha": "5472e09ba4be4b95f429820521c2878768ce0b11", "filename": "src/test/compile-fail/regions-close-object-into-object-1.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-1.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -11,12 +11,10 @@\n #![feature(box_syntax)]\n #![allow(warnings)]\n \n-use std::marker::PhantomFn;\n-\n-trait A<T> : PhantomFn<(Self,T)> { }\n+trait A<T> { }\n struct B<'a, T>(&'a (A<T>+'a));\n \n-trait X : ::std::marker::MarkerTrait {}\n+trait X { }\n \n impl<'a, T> X for B<'a, T> {}\n "}, {"sha": "1ef000852d561c2aa65c7c8d0af14b02373f6aab", "filename": "src/test/compile-fail/regions-close-object-into-object-2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-2.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -10,12 +10,10 @@\n \n #![feature(box_syntax)]\n \n-use std::marker::PhantomFn;\n-\n-trait A<T> : PhantomFn<(Self,T)> { }\n+trait A<T> { }\n struct B<'a, T>(&'a (A<T>+'a));\n \n-trait X : PhantomFn<Self> {}\n+trait X { }\n impl<'a, T> X for B<'a, T> {}\n \n fn g<'a, T: 'static>(v: Box<A<T>+'a>) -> Box<X+'static> {"}, {"sha": "b7dc759b2717f6c12f86a2fab99d3a61af190a7d", "filename": "src/test/compile-fail/regions-close-object-into-object-3.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-3.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -11,15 +11,13 @@\n #![feature(box_syntax)]\n #![allow(warnings)]\n \n-use std::marker::PhantomFn;\n-\n-trait A<T> : PhantomFn<(Self,T)> {}\n+trait A<T> { }\n struct B<'a, T>(&'a (A<T>+'a));\n \n-trait X : PhantomFn<Self> {}\n+trait X { }\n impl<'a, T> X for B<'a, T> {}\n \n-fn h<'a, T, U>(v: Box<A<U>+'static>) -> Box<X+'static> {\n+fn h<'a, T, U:'static>(v: Box<A<U>+'static>) -> Box<X+'static> {\n     box B(&*v) as Box<X> //~ ERROR `*v` does not live long enough\n }\n "}, {"sha": "247578d253ea0fc1961dff65b32eabf2e073326c", "filename": "src/test/compile-fail/regions-close-object-into-object-4.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-4.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -10,12 +10,10 @@\n \n #![feature(box_syntax)]\n \n-use std::marker::PhantomFn;\n-\n-trait A<T> : PhantomFn<(Self,T)> {}\n+trait A<T> { }\n struct B<'a, T>(&'a (A<T>+'a));\n \n-trait X : PhantomFn<Self> {}\n+trait X { }\n impl<'a, T> X for B<'a, T> {}\n \n fn i<'a, T, U>(v: Box<A<U>+'a>) -> Box<X+'static> {"}, {"sha": "bb80c763a8b39acc4325b718a76180198209691d", "filename": "src/test/compile-fail/required-lang-item.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frequired-lang-item.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -11,11 +11,7 @@\n #![feature(lang_items, no_std)]\n #![no_std]\n \n-#[lang=\"phantom_fn\"]\n-pub trait PhantomFn<T:?Sized> { }\n-impl<T:?Sized, U:?Sized> PhantomFn<T> for U { }\n-\n-#[lang=\"sized\"] pub trait Sized : PhantomFn<Self> {}\n+#[lang=\"sized\"] pub trait Sized { }\n \n // error-pattern:requires `start` lang_item\n "}, {"sha": "a2369f8ffb4f2ca4b3cdf4a9bd8e98b7128ded12", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-1.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -13,8 +13,7 @@\n \n use std::marker;\n \n-trait A : marker::PhantomFn<Self> {\n-}\n+trait A { }\n \n trait B: A {}\n "}, {"sha": "beabdcea2bbe9f5beb3571ebeb19eb9e84e07cc9", "filename": "src/test/compile-fail/trait-bounds-impl-comparison-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-impl-comparison-2.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -15,7 +15,6 @@ trait Iterator<A> {\n }\n \n trait IteratorUtil<A>\n-    : ::std::marker::PhantomFn<(),A>\n {\n     fn zip<B, U: Iterator<U>>(self, other: U) -> ZipIterator<Self, U>;\n }"}, {"sha": "dc5576aee650a56ed814b9bbcd9abc09d5f24723", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -16,14 +16,12 @@\n #![feature(unboxed_closures)]\n #![allow(dead_code)]\n \n-use std::marker::PhantomFn;\n-\n trait Foo<T> {\n     type Output;\n     fn dummy(&self, t: T, u: Self::Output);\n }\n \n-trait Eq<X: ?Sized> : PhantomFn<(Self,X)> { }\n+trait Eq<X: ?Sized> { }\n impl<X: ?Sized> Eq<X> for X { }\n fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n "}, {"sha": "a6f59b78823444d5ee4e9674d455dab9cf4bae82", "filename": "src/test/compile-fail/unboxed-closure-sugar-lifetime-elision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -23,7 +23,7 @@ trait Foo<T> {\n     fn dummy(&self, t: T);\n }\n \n-trait Eq<X: ?Sized> : marker::PhantomFn<(Self, X)> { }\n+trait Eq<X: ?Sized> { }\n impl<X: ?Sized> Eq<X> for X { }\n fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n "}, {"sha": "1795ac95358d7c6c29c2bde494f0212b16ad6076", "filename": "src/test/compile-fail/variance-contravariant-arg-object.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -10,6 +10,9 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `T` is only used in contravariant position, it\n+// is treated as invariant.\n+\n trait Get<T> : 'static {\n     fn get(&self, t: T);\n }\n@@ -25,7 +28,8 @@ fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n-    v\n+    // Previously OK:\n+    v //~ ERROR mismatched types\n }\n \n fn main() { }"}, {"sha": "9b6e3c9de3bbd26482d1d2c82d9d1acccc0308f9", "filename": "src/test/compile-fail/variance-contravariant-arg-trait-match.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-trait-match.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -10,6 +10,9 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `T` is only used in contravariant position, it\n+// is treated as invariant.\n+\n trait Get<T> {\n     fn get(&self, t: T);\n }\n@@ -23,7 +26,9 @@ fn get_min_from_max<'min, 'max, G>()\n fn get_max_from_min<'min, 'max, G>()\n     where 'max : 'min, G : Get<&'min i32>\n {\n-    impls_get::<G,&'max i32>()\n+    // Previously OK, but now an error because traits are invariant:\n+\n+    impls_get::<G,&'max i32>() //~ ERROR mismatched types\n }\n \n fn impls_get<G,T>() where G : Get<T> { }"}, {"sha": "6d9d1e61fed61165e7fd2578870367e052c9aa9b", "filename": "src/test/compile-fail/variance-contravariant-self-trait-match.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-self-trait-match.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -10,6 +10,9 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `Self` is only used in contravariant position, it\n+// is treated as invariant.\n+\n trait Get {\n     fn get(&self);\n }\n@@ -23,7 +26,10 @@ fn get_min_from_max<'min, 'max, G>()\n fn get_max_from_min<'min, 'max, G>()\n     where 'max : 'min, G : 'max, &'min G : Get\n {\n-    impls_get::<&'max G>();\n+    // Previously OK, but now error because traits are invariant with\n+    // respect to all inputs.\n+\n+    impls_get::<&'max G>(); //~ ERROR mismatched types\n }\n \n fn impls_get<G>() where G : Get { }"}, {"sha": "ad059a467f570bb2d4b9e5ef872d907ff1f8522c", "filename": "src/test/compile-fail/variance-covariant-arg-object.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -10,6 +10,9 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `T` is only used in covariant position, it\n+// is treated as invariant.\n+\n trait Get<T> : 'static {\n     fn get(&self) -> T;\n }\n@@ -18,7 +21,8 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n                                 -> Box<Get<&'min i32>>\n     where 'max : 'min\n {\n-    v\n+    // Previously OK, now an error as traits are invariant.\n+    v //~ ERROR mismatched types\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)"}, {"sha": "c42a845b3b504202b085664417e086e974dcccbf", "filename": "src/test/compile-fail/variance-covariant-arg-trait-match.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-trait-match.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -10,14 +10,18 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `T` is only used in covariant position, it\n+// is treated as invariant.\n+\n trait Get<T> {\n     fn get(&self) -> T;\n }\n \n fn get_min_from_max<'min, 'max, G>()\n     where 'max : 'min, G : Get<&'max i32>\n {\n-    impls_get::<G,&'min i32>()\n+    // Previously OK, now an error as traits are invariant.\n+    impls_get::<G,&'min i32>() //~ ERROR mismatched types\n }\n \n fn get_max_from_min<'min, 'max, G>()"}, {"sha": "25148dfc0208a672776bf3156ee56dc3700c7712", "filename": "src/test/compile-fail/variance-covariant-self-trait-match.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-self-trait-match.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -10,14 +10,18 @@\n \n #![allow(dead_code)]\n \n+// Test that even when `Self` is only used in covariant position, it\n+// is treated as invariant.\n+\n trait Get {\n     fn get() -> Self;\n }\n \n fn get_min_from_max<'min, 'max, G>()\n     where 'max : 'min, G : 'max, &'max G : Get\n {\n-    impls_get::<&'min G>();\n+    // Previously OK, now an error as traits are invariant.\n+    impls_get::<&'min G>(); //~ ERROR mismatched types\n }\n \n fn get_max_from_min<'min, 'max, G>()"}, {"sha": "dfa5dc1444151ac76e58cea7aa5a71443fd62657", "filename": "src/test/compile-fail/variance-region-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -13,11 +13,11 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-trait Foo: 'static { //~ ERROR types=[[];[-];[]]\n+trait Foo: 'static { //~ ERROR types=[[];[o];[]]\n }\n \n #[rustc_variance]\n-trait Bar<T> { //~ ERROR types=[[+];[-];[]]\n+trait Bar<T> { //~ ERROR types=[[o];[o];[]]\n     fn do_it(&self)\n         where T: 'static;\n }"}, {"sha": "037fff72c80228085d4bdc5b0c769de5d386ca99", "filename": "src/test/compile-fail/variance-regions-unused-direct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-unused-direct.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -18,7 +18,7 @@ struct Struct<'a, 'd> { //~ ERROR parameter `'d` is never used\n     field: &'a [i32]\n }\n \n-trait Trait<'a, 'd> { //~ ERROR parameter `'d` is never used\n+trait Trait<'a, 'd> { // OK on traits\n     fn method(&'a self);\n }\n "}, {"sha": "222d8338aa2c4c5ad0c282916cc039cdc9e9e2e5", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -16,12 +16,12 @@\n // influence variance.\n \n #[rustc_variance]\n-trait Getter<T> { //~ ERROR types=[[+];[-];[]]\n+trait Getter<T> { //~ ERROR types=[[o];[o];[]]\n     fn get(&self) -> T;\n }\n \n #[rustc_variance]\n-trait Setter<T> { //~ ERROR types=[[-];[-];[]]\n+trait Setter<T> { //~ ERROR types=[[o];[o];[]]\n     fn get(&self, T);\n }\n \n@@ -37,16 +37,16 @@ enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[[*, +];[];[]]\n }\n \n #[rustc_variance]\n-trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[[-, +];[-];[]]\n+trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[[o, o];[o];[]]\n     fn getter(&self, u: U) -> T;\n }\n \n #[rustc_variance]\n-trait TestTrait2<U> : Getter<U> { //~ ERROR types=[[+];[-];[]]\n+trait TestTrait2<U> : Getter<U> { //~ ERROR types=[[o];[o];[]]\n }\n \n #[rustc_variance]\n-trait TestTrait3<U> { //~ ERROR types=[[-];[-];[]]\n+trait TestTrait3<U> { //~ ERROR types=[[o];[o];[]]\n     fn getter<T:Getter<U>>(&self);\n }\n "}, {"sha": "49dc1e68c221f8302d9f1d20973c525d35b603c0", "filename": "src/test/compile-fail/variance-trait-matching.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,22 +8,43 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Issue #5781. Tests that subtyping is handled properly in trait matching.\n+// pretty-expanded FIXME #23616\n \n-trait Make<'a> {\n-    fn make(x: &'a mut isize) -> Self;\n+#![allow(dead_code)]\n+\n+// Get<T> is covariant in T\n+trait Get<T> {\n+    fn get(&self) -> T;\n+}\n+\n+struct Cloner<T:Clone> {\n+    t: T\n }\n \n-impl<'a> Make<'a> for &'a mut isize {\n-    fn make(x: &'a mut isize) -> &'a mut isize {\n-        x\n+impl<T:Clone> Get<T> for Cloner<T> {\n+    fn get(&self) -> T {\n+        self.t.clone()\n     }\n }\n \n-fn f() -> &'static mut isize {\n-    let mut x = 1;\n-    let y: &'static mut isize = Make::make(&mut x);   //~ ERROR `x` does not live long enough\n-    y\n+fn get<'a, G>(get: &G) -> i32\n+    where G : Get<&'a i32>\n+{\n+    // This fails to type-check because, without variance, we can't\n+    // use `G : Get<&'a i32>` as evidence that `G : Get<&'b i32>`,\n+    // even if `'a : 'b`.\n+    pick(get, &22) //~ ERROR cannot infer\n }\n \n-fn main() {}\n+fn pick<'b, G>(get: &'b G, if_odd: &'b i32) -> i32\n+    where G : Get<&'b i32>\n+{\n+    let v = *get.get();\n+    if v % 2 != 0 { v } else { *if_odd }\n+}\n+\n+fn main() {\n+    let x = Cloner { t: &23 };\n+    let y = get(&x);\n+    assert_eq!(y, 23);\n+}"}, {"sha": "a02f20656e7b579362431f2150b53c18aa9523dd", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -37,12 +37,12 @@ struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[[o, o];[];[]]\n }\n \n #[rustc_variance]\n-trait Getter<A> { //~ ERROR types=[[+];[-];[]]\n+trait Getter<A> { //~ ERROR types=[[o];[o];[]]\n     fn get(&self) -> A;\n }\n \n #[rustc_variance]\n-trait Setter<A> { //~ ERROR types=[[-];[o];[]]\n+trait Setter<A> { //~ ERROR types=[[o];[o];[]]\n     fn set(&mut self, a: A);\n }\n \n@@ -53,7 +53,7 @@ trait GetterSetter<A> { //~ ERROR types=[[o];[o];[]]\n }\n \n #[rustc_variance]\n-trait GetterInTypeBound<A> { //~ ERROR types=[[-];[-];[]]\n+trait GetterInTypeBound<A> { //~ ERROR types=[[o];[o];[]]\n     // Here, the use of `A` in the method bound *does* affect\n     // variance.  Think of it as if the method requested a dictionary\n     // for `T:Getter<A>`.  Since this dictionary is an input, it is\n@@ -63,12 +63,12 @@ trait GetterInTypeBound<A> { //~ ERROR types=[[-];[-];[]]\n }\n \n #[rustc_variance]\n-trait SetterInTypeBound<A> { //~ ERROR types=[[+];[-];[]]\n+trait SetterInTypeBound<A> { //~ ERROR types=[[o];[o];[]]\n     fn do_it<T:Setter<A>>(&self);\n }\n \n #[rustc_variance]\n-struct TestObject<A, R> { //~ ERROR types=[[-, +];[];[]]\n+struct TestObject<A, R> { //~ ERROR types=[[o, o];[];[]]\n     n: Box<Setter<A>+Send>,\n     m: Box<Getter<R>+Send>,\n }"}, {"sha": "407282e5ce0d4bf0356af0ef94dd22725b97fab3", "filename": "src/test/compile-fail/variance-unused-region-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-unused-region-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-unused-region-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-unused-region-param.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -12,6 +12,6 @@\n \n struct SomeStruct<'a> { x: u32 } //~ ERROR parameter `'a` is never used\n enum SomeEnum<'a> { Nothing } //~ ERROR parameter `'a` is never used\n-trait SomeTrait<'a> { fn foo(&self); } //~ ERROR parameter `'a` is never used\n+trait SomeTrait<'a> { fn foo(&self); } // OK on traits.\n \n fn main() {}"}, {"sha": "862d842d62c2316abdd7a1584fe5744a09182920", "filename": "src/test/compile-fail/variance-unused-type-param.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-unused-type-param.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -21,10 +21,6 @@ enum SomeEnum<A> { Nothing }\n //~^ ERROR parameter `A` is never used\n //~| HELP PhantomData\n \n-trait SomeTrait<A> { fn foo(&self); }\n-//~^ ERROR parameter `A` is never used\n-//~| HELP PhantomFn\n-\n // Here T might *appear* used, but in fact it isn't.\n enum ListCell<T> {\n //~^ ERROR parameter `T` is never used"}, {"sha": "563fe79e537321bc114eaefd7da0868b207be71e", "filename": "src/test/run-make/simd-ffi/simd.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-ffi%2Fsimd.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -70,14 +70,10 @@ pub fn bar(a: i32x4, b: i32x4) -> i32x4 {\n }\n \n #[lang = \"sized\"]\n-pub trait Sized : PhantomFn<Self> {}\n+pub trait Sized { }\n \n #[lang = \"copy\"]\n-pub trait Copy : PhantomFn<Self> {}\n-\n-#[lang=\"phantom_fn\"]\n-pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n-impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n+pub trait Copy { }\n \n mod core {\n     pub mod marker {"}, {"sha": "9dbae19338809ccfaad8eb382162c28dcf6c3b5b", "filename": "src/test/run-make/target-specs/foo.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Ffoo.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -11,15 +11,11 @@\n #![feature(lang_items, no_std)]\n #![no_std]\n \n-#[lang=\"phantom_fn\"]\n-trait PhantomFn<A:?Sized,R:?Sized=()> { }\n-impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n-\n #[lang=\"copy\"]\n-trait Copy : PhantomFn<Self> { }\n+trait Copy { }\n \n #[lang=\"sized\"]\n-trait Sized : PhantomFn<Self>  { }\n+trait Sized { }\n \n #[lang=\"start\"]\n fn start(_main: *const u8, _argc: isize, _argv: *const *const u8) -> isize { 0 }"}, {"sha": "082a39f56312ec5a56b5607a2509941289e95d56", "filename": "src/test/run-pass/coherence-subtyping.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-subtyping.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -16,7 +16,6 @@ trait Contravariant {\n }\n \n impl Contravariant for for<'a,'b> fn(&'a u8, &'b u8) {\n-    //~^ ERROR E0119\n }\n \n impl Contravariant for for<'a> fn(&'a u8, &'a u8) {\n@@ -29,7 +28,6 @@ trait Covariant {\n }\n \n impl Covariant for for<'a,'b> fn(&'a u8, &'b u8) {\n-    //~^ ERROR E0119\n }\n \n impl Covariant for for<'a> fn(&'a u8, &'a u8) {\n@@ -38,7 +36,7 @@ impl Covariant for for<'a> fn(&'a u8, &'a u8) {\n ///////////////////////////////////////////////////////////////////////////\n \n trait Invariant {\n-    fn foo(&self) -> Self { }\n+    fn foo(&self) { }\n }\n \n impl Invariant for for<'a,'b> fn(&'a u8, &'b u8) {", "previous_filename": "src/test/compile-fail/coherence-subtyping.rs"}, {"sha": "71db5225ecc08ddccfd7954c404336d66c60c85a", "filename": "src/test/run-pass/coherence_copy_like.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fcoherence_copy_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fcoherence_copy_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence_copy_like.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -15,11 +15,9 @@\n \n extern crate coherence_copy_like_lib as lib;\n \n-use std::marker::MarkerTrait;\n-\n struct MyType { x: i32 }\n \n-trait MyTrait : MarkerTrait { }\n+trait MyTrait { }\n impl<T: lib::MyCopy> MyTrait for T { }\n impl MyTrait for MyType { }\n impl<'a> MyTrait for &'a MyType { }"}, {"sha": "86b41284cdf35ad35e79cc658bc4511109c5b07d", "filename": "src/test/run-pass/cycle-generic-bound.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -12,9 +12,7 @@\n \n // pretty-expanded FIXME #23616\n \n-use std::marker::PhantomFn;\n-\n-trait Chromosome<X: Chromosome<i32>> : PhantomFn<(Self,X)> {\n+trait Chromosome<X: Chromosome<i32>> {\n }\n \n fn main() { }"}, {"sha": "51a871d59b3615fd50deb8bc912042dde8948bfd", "filename": "src/test/run-pass/issue-22356.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fissue-22356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fissue-22356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22356.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-use std::marker::{PhantomData, PhantomFn};\n+use std::marker::PhantomData;\n \n pub struct Handle<T, I>(T, I);\n \n@@ -34,7 +34,7 @@ impl<D: Device, T> BufferHandle<D, T> {\n \n pub type RawBufferHandle<D: Device> = Handle<<D as Device>::Buffer, String>;\n \n-pub trait Device: PhantomFn<Self> {\n+pub trait Device {\n     type Buffer;\n }\n "}, {"sha": "0ffbc432aaeb53e98e1b49ec9780aefe802b941b", "filename": "src/test/run-pass/regions-early-bound-lifetime-in-assoc-fn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fregions-early-bound-lifetime-in-assoc-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fregions-early-bound-lifetime-in-assoc-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-lifetime-in-assoc-fn.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -27,9 +27,7 @@ pub trait Decoder<'v> {\n     fn read(&mut self) -> Value<'v>;\n }\n \n-pub trait Decodable<'v, D: Decoder<'v>>\n-    : marker::PhantomFn<(), &'v isize>\n-{\n+pub trait Decodable<'v, D: Decoder<'v>> {\n     fn decode(d: &mut D) -> Self;\n }\n "}, {"sha": "0a6b9da74f218e1e60cf9c040924b0f820210631", "filename": "src/test/run-pass/traits-conditional-dispatch.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -17,13 +17,11 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-use std::marker::MarkerTrait;\n-\n trait Get {\n     fn get(&self) -> Self;\n }\n \n-trait MyCopy : MarkerTrait { fn copy(&self) -> Self; }\n+trait MyCopy { fn copy(&self) -> Self; }\n impl MyCopy for u16 { fn copy(&self) -> Self { *self } }\n impl MyCopy for u32 { fn copy(&self) -> Self { *self } }\n impl MyCopy for i32 { fn copy(&self) -> Self { *self } }"}, {"sha": "449d6b37e9f894183d336845f66993600876a5c1", "filename": "src/test/run-pass/unsized.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -12,17 +12,17 @@\n \n // pretty-expanded FIXME #23616\n \n-use std::marker::{PhantomData, PhantomFn};\n+use std::marker::PhantomData;\n \n-trait T1 : PhantomFn<Self> { }\n-pub trait T2 : PhantomFn<Self> { }\n-trait T3<X: T1> : T2 + PhantomFn<X> { }\n-trait T4<X: ?Sized> : PhantomFn<(Self,X)> {}\n-trait T5<X: ?Sized, Y> : PhantomFn<(Self,X,Y)> {}\n-trait T6<Y, X: ?Sized> : PhantomFn<(Self,X,Y)> {}\n-trait T7<X: ?Sized, Y: ?Sized> : PhantomFn<(Self,X,Y)> {}\n-trait T8<X: ?Sized+T2> : PhantomFn<(Self,X)> {}\n-trait T9<X: T2 + ?Sized> : PhantomFn<(Self,X)> {}\n+trait T1  { }\n+pub trait T2  { }\n+trait T3<X: T1> : T2 { }\n+trait T4<X: ?Sized> { }\n+trait T5<X: ?Sized, Y> { }\n+trait T6<Y, X: ?Sized> { }\n+trait T7<X: ?Sized, Y: ?Sized> { }\n+trait T8<X: ?Sized+T2> { }\n+trait T9<X: T2 + ?Sized> { }\n struct S1<X: ?Sized>(PhantomData<X>);\n enum E<X: ?Sized> { E1(PhantomData<X>) }\n impl <X: ?Sized> T1 for S1<X> {}"}, {"sha": "5a179bfc7d47f8b28c1384e822df68b2a660433d", "filename": "src/test/run-pass/variance-trait-matching.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/82dcec7ee4a8a71fdfb8e8771ae6785261ec1d5b/src%2Ftest%2Frun-pass%2Fvariance-trait-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82dcec7ee4a8a71fdfb8e8771ae6785261ec1d5b/src%2Ftest%2Frun-pass%2Fvariance-trait-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariance-trait-matching.rs?ref=82dcec7ee4a8a71fdfb8e8771ae6785261ec1d5b", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pretty-expanded FIXME #23616\n-\n-#![allow(dead_code)]\n-\n-// Get<T> is covariant in T\n-trait Get<T> {\n-    fn get(&self) -> T;\n-}\n-\n-struct Cloner<T:Clone> {\n-    t: T\n-}\n-\n-impl<T:Clone> Get<T> for Cloner<T> {\n-    fn get(&self) -> T {\n-        self.t.clone()\n-    }\n-}\n-\n-fn get<'a, G>(get: &G) -> i32\n-    where G : Get<&'a i32>\n-{\n-    // This call only type checks if we can use `G : Get<&'a i32>` as\n-    // evidence that `G : Get<&'b i32>` where `'a : 'b`.\n-    pick(get, &22)\n-}\n-\n-fn pick<'b, G>(get: &'b G, if_odd: &'b i32) -> i32\n-    where G : Get<&'b i32>\n-{\n-    let v = *get.get();\n-    if v % 2 != 0 { v } else { *if_odd }\n-}\n-\n-fn main() {\n-    let x = Cloner { t: &23 };\n-    let y = get(&x);\n-    assert_eq!(y, 23);\n-}"}, {"sha": "eb95b13d3fa5bed6249ff84e3b9faf0b03082c8e", "filename": "src/test/run-pass/where-for-self.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fwhere-for-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2615106a46879c4e9acc46874ebe06b549d06d67/src%2Ftest%2Frun-pass%2Fwhere-for-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-for-self.rs?ref=2615106a46879c4e9acc46874ebe06b549d06d67", "patch": "@@ -13,18 +13,13 @@\n \n // pretty-expanded FIXME #23616\n \n-use std::marker::PhantomFn;\n-\n static mut COUNT: u32 = 1;\n \n-trait Bar<'a>\n-    : PhantomFn<&'a ()>\n-{\n+trait Bar<'a> {\n     fn bar(&self);\n }\n \n trait Baz<'a>\n-    : PhantomFn<&'a ()>\n {\n     fn baz(&self);\n }"}]}