{"sha": "82da68c5caca6b534d77c01cbcf9d1ed0a6ef496", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZGE2OGM1Y2FjYTZiNTM0ZDc3YzAxY2JjZjlkMWVkMGE2ZWY0OTY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-24T14:22:48Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-03T13:01:04Z"}, "message": "implement all ptr comparisons through integer casts", "tree": {"sha": "e95eaad4a8454a0f16db0bd68185252abedd25f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e95eaad4a8454a0f16db0bd68185252abedd25f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82da68c5caca6b534d77c01cbcf9d1ed0a6ef496", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82da68c5caca6b534d77c01cbcf9d1ed0a6ef496", "html_url": "https://github.com/rust-lang/rust/commit/82da68c5caca6b534d77c01cbcf9d1ed0a6ef496", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82da68c5caca6b534d77c01cbcf9d1ed0a6ef496/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb6a91dc949218c4cc4990cc6f50bbdd58df7648", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb6a91dc949218c4cc4990cc6f50bbdd58df7648", "html_url": "https://github.com/rust-lang/rust/commit/bb6a91dc949218c4cc4990cc6f50bbdd58df7648"}], "stats": {"total": 223, "additions": 23, "deletions": 200}, "files": [{"sha": "f047f4f4fad01d64ff5fcff5766b16dd911f7ab1", "filename": "src/operator.rs", "status": "modified", "additions": 23, "deletions": 200, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/82da68c5caca6b534d77c01cbcf9d1ed0a6ef496/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82da68c5caca6b534d77c01cbcf9d1ed0a6ef496/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=82da68c5caca6b534d77c01cbcf9d1ed0a6ef496", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{Ty, layout::{Size, LayoutOf}};\n+use rustc::ty::{Ty, layout::LayoutOf};\n use rustc::mir;\n \n use crate::*;\n@@ -16,14 +16,6 @@ pub trait EvalContextExt<'tcx> {\n         right: ImmTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, (Scalar<Tag>, bool)>;\n \n-    fn ptr_int_arithmetic(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: Pointer<Tag>,\n-        right: u128,\n-        signed: bool,\n-    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)>;\n-\n     fn ptr_eq(\n         &self,\n         left: Scalar<Tag>,\n@@ -56,9 +48,9 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n-        // Operations that support fat pointers\n-        match bin_op {\n+        Ok(match bin_op {\n             Eq | Ne => {\n+                // This supports fat pointers.\n                 let eq = match (*left, *right) {\n                     (Immediate::Scalar(left), Immediate::Scalar(right)) =>\n                         self.ptr_eq(left.not_undef()?, right.not_undef()?)?,\n@@ -67,114 +59,38 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                         self.ptr_eq(left2.not_undef()?, right2.not_undef()?)?,\n                     _ => bug!(\"Type system should not allow comparing Scalar with ScalarPair\"),\n                 };\n-                return Ok((Scalar::from_bool(if bin_op == Eq { eq } else { !eq }), false));\n+                (Scalar::from_bool(if bin_op == Eq { eq } else { !eq }), false)\n             }\n-            _ => {},\n-        }\n \n-        // Now we expect no more fat pointers.\n-        let left_layout = left.layout;\n-        let left = left.to_scalar()?;\n-        let right_layout = right.layout;\n-        let right = right.to_scalar()?;\n+            Lt | Le | Gt | Ge => {\n+                // Just compare the integers.\n+                // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n+                let left = self.force_bits(left.to_scalar()?, left.layout.size)?;\n+                let right = self.force_bits(right.to_scalar()?, right.layout.size)?;\n+                let res = match bin_op {\n+                    Lt => left < right,\n+                    Le => left <= right,\n+                    Gt => left > right,\n+                    Ge => left >= right,\n+                    _ => bug!(\"We already established it has to be one of these operators.\"),\n+                };\n+                (Scalar::from_bool(res), false)\n+            }\n \n-        Ok(match bin_op {\n             Offset => {\n-                let pointee_ty = left_layout.ty\n+                let pointee_ty = left.layout.ty\n                     .builtin_deref(true)\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset_inbounds(\n-                    left,\n+                    left.to_scalar()?,\n                     pointee_ty,\n-                    right.to_isize(self)?,\n+                    right.to_scalar()?.to_isize(self)?,\n                 )?;\n                 (ptr, false)\n             }\n-            // These need both to be pointer, and fail if they are not in the same location\n-            Lt | Le | Gt | Ge | Sub if left.is_ptr() && right.is_ptr() => {\n-                let left = left.assert_ptr();\n-                let right = right.assert_ptr();\n-                if left.alloc_id == right.alloc_id {\n-                    let res = match bin_op {\n-                        Lt => left.offset < right.offset,\n-                        Le => left.offset <= right.offset,\n-                        Gt => left.offset > right.offset,\n-                        Ge => left.offset >= right.offset,\n-                        Sub => {\n-                            // subtract the offsets\n-                            let left_offset = Scalar::from_uint(left.offset.bytes(), self.memory().pointer_size());\n-                            let right_offset = Scalar::from_uint(right.offset.bytes(), self.memory().pointer_size());\n-                            let layout = self.layout_of(self.tcx.types.usize)?;\n-                            return self.binary_op(\n-                                Sub,\n-                                ImmTy::from_scalar(left_offset, layout),\n-                                ImmTy::from_scalar(right_offset, layout),\n-                            )\n-                        }\n-                        _ => bug!(\"We already established it has to be one of these operators.\"),\n-                    };\n-                    (Scalar::from_bool(res), false)\n-                } else {\n-                    // Both are pointers, but from different allocations.\n-                    throw_unsup!(InvalidPointerMath)\n-                }\n-            }\n-            Lt | Le | Gt | Ge if left.is_bits() && right.is_bits() => {\n-                let left = left.assert_bits(self.memory().pointer_size());\n-                let right = right.assert_bits(self.memory().pointer_size());\n-                let res = match bin_op {\n-                    Lt => left < right,\n-                    Le => left <= right,\n-                    Gt => left > right,\n-                    Ge => left >= right,\n-                    _ => bug!(\"We already established it has to be one of these operators.\"),\n-                };\n-                Ok((Scalar::from_bool(res), false))\n-            }\n-            Gt | Ge if left.is_ptr() && right.is_bits() => {\n-                // \"ptr >[=] integer\" can be tested if the integer is small enough.\n-                let left = left.assert_ptr();\n-                let right = right.assert_bits(self.memory().pointer_size());\n-                let (_alloc_size, alloc_align) = self.memory()\n-                    .get_size_and_align(left.alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\");\n-                let min_ptr_val = u128::from(alloc_align.bytes()) + u128::from(left.offset.bytes());\n-                let result = match bin_op {\n-                    Gt => min_ptr_val > right,\n-                    Ge => min_ptr_val >= right,\n-                    _ => bug!(),\n-                };\n-                if result {\n-                    // Definitely true!\n-                    (Scalar::from_bool(true), false)\n-                } else {\n-                    // Sorry, can't tell.\n-                    throw_unsup!(InvalidPointerMath)\n-                }\n-            }\n-            // These work if the left operand is a pointer, and the right an integer\n-            Add | BitAnd | Sub | Rem if left.is_ptr() && right.is_bits() => {\n-                // Cast to i128 is fine as we checked the kind to be ptr-sized\n-                self.ptr_int_arithmetic(\n-                    bin_op,\n-                    left.assert_ptr(),\n-                    right.assert_bits(self.memory().pointer_size()),\n-                    right_layout.abi.is_signed(),\n-                )?\n-            }\n-            // Commutative operators also work if the integer is on the left\n-            Add | BitAnd if left.is_bits() && right.is_ptr() => {\n-                // This is a commutative operation, just swap the operands\n-                self.ptr_int_arithmetic(\n-                    bin_op,\n-                    right.assert_ptr(),\n-                    left.assert_bits(self.memory().pointer_size()),\n-                    left_layout.abi.is_signed(),\n-                )?\n-            }\n-            // Nothing else works\n-            _ => throw_unsup!(InvalidPointerMath),\n+\n+            _ => bug!(\"Invalid operator on pointers: {:?}\", bin_op)\n         })\n     }\n \n@@ -191,99 +107,6 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         Ok(left == right)\n     }\n \n-    fn ptr_int_arithmetic(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: Pointer<Tag>,\n-        right: u128,\n-        signed: bool,\n-    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n-        use rustc::mir::BinOp::*;\n-\n-        fn map_to_primval((res, over): (Pointer<Tag>, bool)) -> (Scalar<Tag>, bool) {\n-            (Scalar::Ptr(res), over)\n-        }\n-\n-        Ok(match bin_op {\n-            Sub =>\n-                // The only way this can overflow is by underflowing, so signdeness of the right\n-                // operands does not matter.\n-                map_to_primval(left.overflowing_signed_offset(-(right as i128), self)),\n-            Add if signed =>\n-                map_to_primval(left.overflowing_signed_offset(right as i128, self)),\n-            Add if !signed =>\n-                map_to_primval(left.overflowing_offset(Size::from_bytes(right as u64), self)),\n-\n-            BitAnd if !signed => {\n-                let ptr_base_align = self.memory().get_size_and_align(left.alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\")\n-                    .1.bytes();\n-                let base_mask = {\n-                    // FIXME: use `interpret::truncate`, once that takes a `Size` instead of a `Layout`.\n-                    let shift = 128 - self.memory().pointer_size().bits();\n-                    let value = !(ptr_base_align as u128 - 1);\n-                    // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n-                    (value << shift) >> shift\n-                };\n-                let ptr_size = self.memory().pointer_size();\n-                trace!(\"ptr BitAnd, align {}, operand {:#010x}, base_mask {:#010x}\",\n-                    ptr_base_align, right, base_mask);\n-                if right & base_mask == base_mask {\n-                    // Case 1: the base address bits are all preserved, i.e., right is all-1 there.\n-                    let offset = (left.offset.bytes() as u128 & right) as u64;\n-                    (\n-                        Scalar::Ptr(Pointer::new_with_tag(\n-                            left.alloc_id,\n-                            Size::from_bytes(offset),\n-                            left.tag,\n-                        )),\n-                        false,\n-                    )\n-                } else if right & base_mask == 0 {\n-                    // Case 2: the base address bits are all taken away, i.e., right is all-0 there.\n-                    let v = Scalar::from_uint((left.offset.bytes() as u128) & right, ptr_size);\n-                    (v, false)\n-                } else {\n-                    throw_unsup!(ReadPointerAsBytes);\n-                }\n-            }\n-\n-            Rem if !signed => {\n-                // Doing modulo a divisor of the alignment is allowed.\n-                // (Intuition: modulo a divisor leaks less information.)\n-                let ptr_base_align = self.memory().get_size_and_align(left.alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\")\n-                    .1.bytes();\n-                let right = right as u64;\n-                let ptr_size = self.memory().pointer_size();\n-                if right == 1 {\n-                    // Modulo 1 is always 0.\n-                    (Scalar::from_uint(0u32, ptr_size), false)\n-                } else if ptr_base_align % right == 0 {\n-                    // The base address would be cancelled out by the modulo operation, so we can\n-                    // just take the modulo of the offset.\n-                    (\n-                        Scalar::from_uint((left.offset.bytes() % right) as u128, ptr_size),\n-                        false,\n-                    )\n-                } else {\n-                    throw_unsup!(ReadPointerAsBytes);\n-                }\n-            }\n-\n-            _ => {\n-                let msg = format!(\n-                    \"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\",\n-                    bin_op,\n-                    left,\n-                    right,\n-                    if signed { \"signed\" } else { \"unsigned\" }\n-                );\n-                throw_unsup!(Unimplemented(msg));\n-            }\n-        })\n-    }\n-\n     /// Raises an error if the offset moves the pointer outside of its allocation.\n     /// We consider ZSTs their own huge allocation that doesn't overlap with anything (and nothing\n     /// moves in there because the size is 0). We also consider the NULL pointer its own separate"}]}