{"sha": "765a4e9fe35014eed3c7f60f8c7030ecb537871b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NWE0ZTlmZTM1MDE0ZWVkM2M3ZjYwZjhjNzAzMGVjYjUzNzg3MWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-19T16:26:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-20T00:53:00Z"}, "message": "Fix sending/try_recv on channels off the runtime\n\nThe fairness yield mistakenly called `Local::take()` which meant that it would\nonly work if a local task was available. In theory sending on a channel (or\ncalling try_recv) requires no runtime because it never blocks, so there's no\nreason it shouldn't support such a use case.\n\nCloses #12391", "tree": {"sha": "94c665f6deba7ca162fbc9590180caddca18a9ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94c665f6deba7ca162fbc9590180caddca18a9ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/765a4e9fe35014eed3c7f60f8c7030ecb537871b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/765a4e9fe35014eed3c7f60f8c7030ecb537871b", "html_url": "https://github.com/rust-lang/rust/commit/765a4e9fe35014eed3c7f60f8c7030ecb537871b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/765a4e9fe35014eed3c7f60f8c7030ecb537871b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ace204a74548947914d08a7feca694941106175d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ace204a74548947914d08a7feca694941106175d", "html_url": "https://github.com/rust-lang/rust/commit/ace204a74548947914d08a7feca694941106175d"}], "stats": {"total": 59, "additions": 49, "deletions": 10}, "files": [{"sha": "145bee50a203696548b2b916eeb7262a8663e4ea", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/765a4e9fe35014eed3c7f60f8c7030ecb537871b/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/765a4e9fe35014eed3c7f60f8c7030ecb537871b/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=765a4e9fe35014eed3c7f60f8c7030ecb537871b", "patch": "@@ -385,17 +385,17 @@ impl<T: Send> Chan<T> {\n     pub fn try_send(&self, t: T) -> bool {\n         // In order to prevent starvation of other tasks in situations where\n         // a task sends repeatedly without ever receiving, we occassionally\n-        // yield instead of doing a send immediately.  Only doing this if\n-        // we're doing a rescheduling send, otherwise the caller is\n-        // expecting not to context switch.\n+        // yield instead of doing a send immediately.\n         //\n-        // Note that we don't unconditionally attempt to yield because the\n-        // TLS overhead can be a bit much.\n+        // Don't unconditionally attempt to yield because the TLS overhead can\n+        // be a bit much, and also use `try_take` instead of `take` because\n+        // there's no reason that this send shouldn't be usable off the\n+        // runtime.\n         let cnt = self.sends.get() + 1;\n         self.sends.set(cnt);\n         if cnt % (RESCHED_FREQ as uint) == 0 {\n-            let task: ~Task = Local::take();\n-            task.maybe_yield();\n+            let task: Option<~Task> = Local::try_take();\n+            task.map(|t| t.maybe_yield());\n         }\n \n         let (new_inner, ret) = match self.inner {\n@@ -521,12 +521,13 @@ impl<T: Send> Port<T> {\n     pub fn try_recv(&self) -> TryRecvResult<T> {\n         // If a thread is spinning in try_recv, we should take the opportunity\n         // to reschedule things occasionally. See notes above in scheduling on\n-        // sends for why this doesn't always hit TLS.\n+        // sends for why this doesn't always hit TLS, and also for why this uses\n+        // `try_take` instead of `take`.\n         let cnt = self.receives.get() + 1;\n         self.receives.set(cnt);\n         if cnt % (RESCHED_FREQ as uint) == 0 {\n-            let task: ~Task = Local::take();\n-            task.maybe_yield();\n+            let task: Option<~Task> = Local::try_take();\n+            task.map(|t| t.maybe_yield());\n         }\n \n         loop {\n@@ -1203,4 +1204,42 @@ mod test {\n         // wait for the child task to exit before we exit\n         p1.recv();\n     })\n+\n+    test!(fn sends_off_the_runtime() {\n+        use rt::thread::Thread;\n+\n+        let (p, c) = Chan::new();\n+        let t = Thread::start(proc() {\n+            for _ in range(0, 1000) {\n+                c.send(());\n+            }\n+        });\n+        for _ in range(0, 1000) {\n+            p.recv();\n+        }\n+        t.join();\n+    })\n+\n+    test!(fn try_recvs_off_the_runtime() {\n+        use rt::thread::Thread;\n+\n+        let (p, c) = Chan::new();\n+        let (pdone, cdone) = Chan::new();\n+        let t = Thread::start(proc() {\n+            let mut hits = 0;\n+            while hits < 10 {\n+                match p.try_recv() {\n+                    Data(()) => { hits += 1; }\n+                    Empty => { Thread::yield_now(); }\n+                    Disconnected => return,\n+                }\n+            }\n+            cdone.send(());\n+        });\n+        for _ in range(0, 10) {\n+            c.send(());\n+        }\n+        t.join();\n+        pdone.recv();\n+    })\n }"}]}