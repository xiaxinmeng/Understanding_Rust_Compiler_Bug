{"sha": "1e3b57ee7754702ce9fcef73686b5bcee405dd4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlM2I1N2VlNzc1NDcwMmNlOWZjZWY3MzY4NmI1YmNlZTQwNWRkNGE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-17T01:08:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-17T01:08:38Z"}, "message": "Rollup merge of #64500 - nnethercote:ObligForest-fixups, r=nikomatsakis\n\nVarious `ObligationForest` improvements\n\nThese commits make the code both nicer and faster.\n\nr? @nikomatsakis", "tree": {"sha": "4e64d8e3b7af39924ccf99a645f01fc07f90141b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e64d8e3b7af39924ccf99a645f01fc07f90141b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e3b57ee7754702ce9fcef73686b5bcee405dd4a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdgDIWCRBK7hj4Ov3rIwAAdHIIAKQ0WDEqGkJa2HxZBF4uyFTg\n+XZk2Lc8A2AT37A6Mx/9kM4uI08BTVjUafpFQHHI1azxmNZiIqKgDuwF8GqVN047\nngkNtk3N87MFANgniqXA/En3awZsOODiBjoVOXIF6gtn7Fb4GDNAAg/ztjtWW1gY\nPexDIsUdjd19h46Ldr1lXrxdj5vxlGPNHBcr2aL4xQx6dJnLZ2RD7AO+8CEtlvpu\ny7F9m3/fCCtorsVLAXFEqxMaGQ/zmYbhd//lPo4j/xmPZFik98FRoyAcuc7A/LE8\nLxEuCkciVTqO4cZ4AO2FKtxZsjF/DbQHwvccl2gGHRDjf2zSkv8oHGugGrEPaIg=\n=jg6S\n-----END PGP SIGNATURE-----\n", "payload": "tree 4e64d8e3b7af39924ccf99a645f01fc07f90141b\nparent 69e93e81792aec04dc5bf3f9832a24aa7e30ddbd\nparent 4ecd94e1215882efde5f003c0042bd72a5f8acb2\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1568682518 +0200\ncommitter GitHub <noreply@github.com> 1568682518 +0200\n\nRollup merge of #64500 - nnethercote:ObligForest-fixups, r=nikomatsakis\n\nVarious `ObligationForest` improvements\n\nThese commits make the code both nicer and faster.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e3b57ee7754702ce9fcef73686b5bcee405dd4a", "html_url": "https://github.com/rust-lang/rust/commit/1e3b57ee7754702ce9fcef73686b5bcee405dd4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e3b57ee7754702ce9fcef73686b5bcee405dd4a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "html_url": "https://github.com/rust-lang/rust/commit/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd"}, {"sha": "4ecd94e1215882efde5f003c0042bd72a5f8acb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ecd94e1215882efde5f003c0042bd72a5f8acb2", "html_url": "https://github.com/rust-lang/rust/commit/4ecd94e1215882efde5f003c0042bd72a5f8acb2"}], "stats": {"total": 315, "additions": 148, "deletions": 167}, "files": [{"sha": "6e80b48a6856016dadab3a7eb46bb2add06f0d6c", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e3b57ee7754702ce9fcef73686b5bcee405dd4a/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3b57ee7754702ce9fcef73686b5bcee405dd4a/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=1e3b57ee7754702ce9fcef73686b5bcee405dd4a", "patch": "@@ -149,7 +149,7 @@ macro_rules! newtype_index {\n \n             #[inline]\n             $v const unsafe fn from_u32_unchecked(value: u32) -> Self {\n-                unsafe { $type { private: value } }\n+                $type { private: value }\n             }\n \n             /// Extracts the value of this index as an integer."}, {"sha": "b2120b182fa7b72eb08acf7ebb179bfc91b88c07", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e3b57ee7754702ce9fcef73686b5bcee405dd4a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3b57ee7754702ce9fcef73686b5bcee405dd4a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=1e3b57ee7754702ce9fcef73686b5bcee405dd4a", "patch": "@@ -74,9 +74,9 @@ impl<'a, O: ForestObligation + 'a> dot::GraphWalk<'a> for &'a ObligationForest<O\n             .flat_map(|i| {\n                 let node = &self.nodes[i];\n \n-                node.parent.iter().map(|p| p.get())\n-                    .chain(node.dependents.iter().map(|p| p.get()))\n-                    .map(move |p| (p, i))\n+                node.parent.iter()\n+                    .chain(node.dependents.iter())\n+                    .map(move |p| (p.index(), i))\n             })\n             .collect()\n     }"}, {"sha": "189506bf8ab76c5aa2299aca687891567410d023", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 144, "deletions": 143, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/1e3b57ee7754702ce9fcef73686b5bcee405dd4a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e3b57ee7754702ce9fcef73686b5bcee405dd4a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=1e3b57ee7754702ce9fcef73686b5bcee405dd4a", "patch": "@@ -9,7 +9,7 @@\n //! `ObligationForest` supports two main public operations (there are a\n //! few others not discussed here):\n //!\n-//! 1. Add a new root obligations (`push_tree`).\n+//! 1. Add a new root obligations (`register_obligation`).\n //! 2. Process the pending obligations (`process_obligations`).\n //!\n //! When a new obligation `N` is added, it becomes the root of an\n@@ -20,21 +20,21 @@\n //! with every pending obligation (so that will include `N`, the first\n //! time). The callback also receives a (mutable) reference to the\n //! per-tree state `T`. The callback should process the obligation `O`\n-//! that it is given and return one of three results:\n+//! that it is given and return a `ProcessResult`:\n //!\n-//! - `Ok(None)` -> ambiguous result. Obligation was neither a success\n+//! - `Unchanged` -> ambiguous result. Obligation was neither a success\n //!   nor a failure. It is assumed that further attempts to process the\n //!   obligation will yield the same result unless something in the\n //!   surrounding environment changes.\n-//! - `Ok(Some(C))` - the obligation was *shallowly successful*. The\n+//! - `Changed(C)` - the obligation was *shallowly successful*. The\n //!   vector `C` is a list of subobligations. The meaning of this is that\n //!   `O` was successful on the assumption that all the obligations in `C`\n //!   are also successful. Therefore, `O` is only considered a \"true\"\n //!   success if `C` is empty. Otherwise, `O` is put into a suspended\n //!   state and the obligations in `C` become the new pending\n //!   obligations. They will be processed the next time you call\n //!   `process_obligations`.\n-//! - `Err(E)` -> obligation failed with error `E`. We will collect this\n+//! - `Error(E)` -> obligation failed with error `E`. We will collect this\n //!   error and return it from `process_obligations`, along with the\n //!   \"backtrace\" of obligations (that is, the list of obligations up to\n //!   and including the root of the failed obligation). No further\n@@ -47,55 +47,50 @@\n //! - `completed`: a list of obligations where processing was fully\n //!   completed without error (meaning that all transitive subobligations\n //!   have also been completed). So, for example, if the callback from\n-//!   `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n+//!   `process_obligations` returns `Changed(C)` for some obligation `O`,\n //!   then `O` will be considered completed right away if `C` is the\n //!   empty vector. Otherwise it will only be considered completed once\n //!   all the obligations in `C` have been found completed.\n //! - `errors`: a list of errors that occurred and associated backtraces\n //!   at the time of error, which can be used to give context to the user.\n //! - `stalled`: if true, then none of the existing obligations were\n-//!   *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n+//!   *shallowly successful* (that is, no callback returned `Changed(_)`).\n //!   This implies that all obligations were either errors or returned an\n //!   ambiguous result, which means that any further calls to\n //!   `process_obligations` would simply yield back further ambiguous\n //!   results. This is used by the `FulfillmentContext` to decide when it\n //!   has reached a steady state.\n //!\n-//! #### Snapshots\n-//!\n-//! The `ObligationForest` supports a limited form of snapshots; see\n-//! `start_snapshot`, `commit_snapshot`, and `rollback_snapshot`. In\n-//! particular, you can use a snapshot to roll back new root\n-//! obligations. However, it is an error to attempt to\n-//! `process_obligations` during a snapshot.\n-//!\n //! ### Implementation details\n //!\n //! For the most part, comments specific to the implementation are in the\n //! code. This file only contains a very high-level overview. Basically,\n //! the forest is stored in a vector. Each element of the vector is a node\n-//! in some tree. Each node in the vector has the index of an (optional)\n-//! parent and (for convenience) its root (which may be itself). It also\n-//! has a current state, described by `NodeState`. After each\n-//! processing step, we compress the vector to remove completed and error\n-//! nodes, which aren't needed anymore.\n+//! in some tree. Each node in the vector has the index of its dependents,\n+//! including the first dependent which is known as the parent. It also\n+//! has a current state, described by `NodeState`. After each processing\n+//! step, we compress the vector to remove completed and error nodes, which\n+//! aren't needed anymore.\n \n use crate::fx::{FxHashMap, FxHashSet};\n+use crate::indexed_vec::Idx;\n+use crate::newtype_index;\n \n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash;\n use std::marker::PhantomData;\n \n-mod node_index;\n-use self::node_index::NodeIndex;\n-\n mod graphviz;\n \n #[cfg(test)]\n mod tests;\n \n+newtype_index! {\n+    pub struct NodeIndex { .. }\n+}\n+\n pub trait ForestObligation : Clone + Debug {\n     type Predicate : Clone + hash::Hash + Eq + Debug;\n \n@@ -148,18 +143,22 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// At the end of processing, those nodes will be removed by a\n     /// call to `compress`.\n     ///\n-    /// At all times we maintain the invariant that every node appears\n-    /// at a higher index than its parent. This is needed by the\n-    /// backtrace iterator (which uses `split_at`).\n+    /// Ideally, this would be an `IndexVec<NodeIndex, Node<O>>`. But that is\n+    /// slower, because this vector is accessed so often that the\n+    /// `u32`-to-`usize` conversions required for accesses are significant.\n     nodes: Vec<Node<O>>,\n \n     /// A cache of predicates that have been successfully completed.\n     done_cache: FxHashSet<O::Predicate>,\n \n-    /// An cache of the nodes in `nodes`, indexed by predicate.\n+    /// A cache of the nodes in `nodes`, indexed by predicate. Unfortunately,\n+    /// its contents are not guaranteed to match those of `nodes`. See the\n+    /// comments in `process_obligation` for details.\n     waiting_cache: FxHashMap<O::Predicate, NodeIndex>,\n \n-    scratch: Option<Vec<usize>>,\n+    /// A scratch vector reused in various operations, to avoid allocating new\n+    /// vectors.\n+    scratch: RefCell<Vec<usize>>,\n \n     obligation_tree_id_generator: ObligationTreeIdGenerator,\n \n@@ -178,19 +177,41 @@ struct Node<O> {\n     obligation: O,\n     state: Cell<NodeState>,\n \n-    /// The parent of a node - the original obligation of\n-    /// which it is a subobligation. Except for error reporting,\n-    /// it is just like any member of `dependents`.\n+    /// The parent of a node - the original obligation of which it is a\n+    /// subobligation. Except for error reporting, it is just like any member\n+    /// of `dependents`.\n+    ///\n+    /// Unlike `ObligationForest::nodes`, this uses `NodeIndex` rather than\n+    /// `usize` for the index, because keeping the size down is more important\n+    /// than the cost of converting to a `usize` for indexing.\n     parent: Option<NodeIndex>,\n \n-    /// Obligations that depend on this obligation for their\n-    /// completion. They must all be in a non-pending state.\n+    /// Obligations that depend on this obligation for their completion. They\n+    /// must all be in a non-pending state.\n+    ///\n+    /// This uses `NodeIndex` for the same reason as `parent`.\n     dependents: Vec<NodeIndex>,\n \n     /// Identifier of the obligation tree to which this node belongs.\n     obligation_tree_id: ObligationTreeId,\n }\n \n+impl<O> Node<O> {\n+    fn new(\n+        parent: Option<NodeIndex>,\n+        obligation: O,\n+        obligation_tree_id: ObligationTreeId\n+    ) -> Node<O> {\n+        Node {\n+            obligation,\n+            state: Cell::new(NodeState::Pending),\n+            parent,\n+            dependents: vec![],\n+            obligation_tree_id,\n+        }\n+    }\n+}\n+\n /// The state of one node in some tree within the forest. This\n /// represents the current state of processing for the obligation (of\n /// type `O`) associated with this node.\n@@ -262,7 +283,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             nodes: vec![],\n             done_cache: Default::default(),\n             waiting_cache: Default::default(),\n-            scratch: Some(vec![]),\n+            scratch: RefCell::new(vec![]),\n             obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n         }\n@@ -275,14 +296,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n     }\n \n     /// Registers an obligation.\n-    ///\n-    /// This CAN be done in a snapshot\n     pub fn register_obligation(&mut self, obligation: O) {\n         // Ignore errors here - there is no guarantee of success.\n         let _ = self.register_obligation_at(obligation, None);\n     }\n \n-    // returns Err(()) if we already know this obligation failed.\n+    // Returns Err(()) if we already know this obligation failed.\n     fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>)\n                               -> Result<(), ()>\n     {\n@@ -294,15 +313,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n             Entry::Occupied(o) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n-                let node = &mut self.nodes[o.get().get()];\n-                if let Some(parent) = parent {\n+                let node = &mut self.nodes[o.get().index()];\n+                if let Some(parent_index) = parent {\n                     // If the node is already in `waiting_cache`, it's already\n                     // been marked with a parent. (It's possible that parent\n                     // has been cleared by `apply_rewrites`, though.) So just\n                     // dump `parent` into `node.dependents`... unless it's\n                     // already in `node.dependents` or `node.parent`.\n-                    if !node.dependents.contains(&parent) && Some(parent) != node.parent {\n-                        node.dependents.push(parent);\n+                    if !node.dependents.contains(&parent_index) &&\n+                       Some(parent_index) != node.parent {\n+                        node.dependents.push(parent_index);\n                     }\n                 }\n                 if let NodeState::Error = node.state.get() {\n@@ -316,9 +336,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                        obligation, parent, self.nodes.len());\n \n                 let obligation_tree_id = match parent {\n-                    Some(p) => {\n-                        let parent_node = &self.nodes[p.get()];\n-                        parent_node.obligation_tree_id\n+                    Some(parent_index) => {\n+                        self.nodes[parent_index.index()].obligation_tree_id\n                     }\n                     None => self.obligation_tree_id_generator.next().unwrap()\n                 };\n@@ -342,13 +361,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n     }\n \n     /// Converts all remaining obligations to the given error.\n-    ///\n-    /// This cannot be done during a snapshot.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n         let mut errors = vec![];\n-        for index in 0..self.nodes.len() {\n-            if let NodeState::Pending = self.nodes[index].state.get() {\n-                let backtrace = self.error_at(index);\n+        for (i, node) in self.nodes.iter().enumerate() {\n+            if let NodeState::Pending = node.state.get() {\n+                let backtrace = self.error_at(i);\n                 errors.push(Error {\n                     error: error.clone(),\n                     backtrace,\n@@ -373,7 +390,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     fn insert_into_error_cache(&mut self, node_index: usize) {\n         let node = &self.nodes[node_index];\n-\n         self.error_cache\n             .entry(node.obligation_tree_id)\n             .or_default()\n@@ -393,16 +409,22 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut errors = vec![];\n         let mut stalled = true;\n \n-        for index in 0..self.nodes.len() {\n-            debug!(\"process_obligations: node {} == {:?}\", index, self.nodes[index]);\n+        for i in 0..self.nodes.len() {\n+            let node = &mut self.nodes[i];\n \n-            let result = match self.nodes[index] {\n-                Node { ref state, ref mut obligation, .. } if state.get() == NodeState::Pending =>\n-                    processor.process_obligation(obligation),\n+            debug!(\"process_obligations: node {} == {:?}\", i, node);\n+\n+            // `processor.process_obligation` can modify the predicate within\n+            // `node.obligation`, and that predicate is the key used for\n+            // `self.waiting_cache`. This means that `self.waiting_cache` can\n+            // get out of sync with `nodes`. It's not very common, but it does\n+            // happen, and code in `compress` has to allow for it.\n+            let result = match node.state.get() {\n+                NodeState::Pending => processor.process_obligation(&mut node.obligation),\n                 _ => continue\n             };\n \n-            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n+            debug!(\"process_obligations: node {} got result {:?}\", i, result);\n \n             match result {\n                 ProcessResult::Unchanged => {\n@@ -411,23 +433,23 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n                     stalled = false;\n-                    self.nodes[index].state.set(NodeState::Success);\n+                    node.state.set(NodeState::Success);\n \n                     for child in children {\n                         let st = self.register_obligation_at(\n                             child,\n-                            Some(NodeIndex::new(index))\n+                            Some(NodeIndex::new(i))\n                         );\n                         if let Err(()) = st {\n-                            // error already reported - propagate it\n+                            // Error already reported - propagate it\n                             // to our node.\n-                            self.error_at(index);\n+                            self.error_at(i);\n                         }\n                     }\n                 }\n                 ProcessResult::Error(err) => {\n                     stalled = false;\n-                    let backtrace = self.error_at(index);\n+                    let backtrace = self.error_at(i);\n                     errors.push(Error {\n                         error: err,\n                         backtrace,\n@@ -448,8 +470,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         self.mark_as_waiting();\n         self.process_cycles(processor);\n-\n-        // Now we have to compress the result\n         let completed = self.compress(do_completed);\n \n         debug!(\"process_obligations: complete\");\n@@ -465,105 +485,100 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// report all cycles between them. This should be called\n     /// after `mark_as_waiting` marks all nodes with pending\n     /// subobligations as NodeState::Waiting.\n-    fn process_cycles<P>(&mut self, processor: &mut P)\n+    fn process_cycles<P>(&self, processor: &mut P)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let mut stack = self.scratch.take().unwrap();\n+        let mut stack = self.scratch.replace(vec![]);\n         debug_assert!(stack.is_empty());\n \n         debug!(\"process_cycles()\");\n \n-        for index in 0..self.nodes.len() {\n+        for (i, node) in self.nodes.iter().enumerate() {\n             // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n             // hot and the state is almost always `Pending` or `Waiting`. It's\n             // a win to handle the no-op cases immediately to avoid the cost of\n             // the function call.\n-            let state = self.nodes[index].state.get();\n-            match state {\n+            match node.state.get() {\n                 NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n-                _ => self.find_cycles_from_node(&mut stack, processor, index),\n+                _ => self.find_cycles_from_node(&mut stack, processor, i),\n             }\n         }\n \n         debug!(\"process_cycles: complete\");\n \n         debug_assert!(stack.is_empty());\n-        self.scratch = Some(stack);\n+        self.scratch.replace(stack);\n     }\n \n-    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>,\n-                                processor: &mut P, index: usize)\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, i: usize)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let node = &self.nodes[index];\n-        let state = node.state.get();\n-        match state {\n+        let node = &self.nodes[i];\n+        match node.state.get() {\n             NodeState::OnDfsStack => {\n-                let index =\n-                    stack.iter().rposition(|n| *n == index).unwrap();\n-                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n+                let i = stack.iter().rposition(|n| *n == i).unwrap();\n+                processor.process_backedge(stack[i..].iter().map(GetObligation(&self.nodes)),\n                                            PhantomData);\n             }\n             NodeState::Success => {\n                 node.state.set(NodeState::OnDfsStack);\n-                stack.push(index);\n-                for dependent in node.parent.iter().chain(node.dependents.iter()) {\n-                    self.find_cycles_from_node(stack, processor, dependent.get());\n+                stack.push(i);\n+                for index in node.parent.iter().chain(node.dependents.iter()) {\n+                    self.find_cycles_from_node(stack, processor, index.index());\n                 }\n                 stack.pop();\n                 node.state.set(NodeState::Done);\n             },\n             NodeState::Waiting | NodeState::Pending => {\n-                // this node is still reachable from some pending node. We\n+                // This node is still reachable from some pending node. We\n                 // will get to it when they are all processed.\n             }\n             NodeState::Done | NodeState::Error => {\n-                // already processed that node\n+                // Already processed that node.\n             }\n         };\n     }\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n-    fn error_at(&mut self, p: usize) -> Vec<O> {\n-        let mut error_stack = self.scratch.take().unwrap();\n+    fn error_at(&self, mut i: usize) -> Vec<O> {\n+        let mut error_stack = self.scratch.replace(vec![]);\n         let mut trace = vec![];\n \n-        let mut n = p;\n         loop {\n-            self.nodes[n].state.set(NodeState::Error);\n-            trace.push(self.nodes[n].obligation.clone());\n-            error_stack.extend(self.nodes[n].dependents.iter().map(|x| x.get()));\n+            let node = &self.nodes[i];\n+            node.state.set(NodeState::Error);\n+            trace.push(node.obligation.clone());\n+            error_stack.extend(node.dependents.iter().map(|index| index.index()));\n \n-            // loop to the parent\n-            match self.nodes[n].parent {\n-                Some(q) => n = q.get(),\n+            // Loop to the parent.\n+            match node.parent {\n+                Some(parent_index) => i = parent_index.index(),\n                 None => break\n             }\n         }\n \n         while let Some(i) = error_stack.pop() {\n-            match self.nodes[i].state.get() {\n+            let node = &self.nodes[i];\n+            match node.state.get() {\n                 NodeState::Error => continue,\n-                _ => self.nodes[i].state.set(NodeState::Error),\n+                _ => node.state.set(NodeState::Error),\n             }\n \n-            let node = &self.nodes[i];\n-\n             error_stack.extend(\n-                node.parent.iter().chain(node.dependents.iter()).map(|x| x.get())\n+                node.parent.iter().chain(node.dependents.iter()).map(|index| index.index())\n             );\n         }\n \n-        self.scratch = Some(error_stack);\n+        self.scratch.replace(error_stack);\n         trace\n     }\n \n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n     fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n         for dependent in node.parent.iter().chain(node.dependents.iter()) {\n-            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n+            self.mark_as_waiting_from(&self.nodes[dependent.index()]);\n         }\n     }\n \n@@ -609,7 +624,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     #[inline(never)]\n     fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let nodes_len = self.nodes.len();\n-        let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n+        let mut node_rewrites: Vec<_> = self.scratch.replace(vec![]);\n         node_rewrites.extend(0..nodes_len);\n         let mut dead_nodes = 0;\n \n@@ -620,21 +635,25 @@ impl<O: ForestObligation> ObligationForest<O> {\n         //     self.nodes[i - dead_nodes..i] are all dead\n         //     self.nodes[i..] are unchanged\n         for i in 0..self.nodes.len() {\n-            match self.nodes[i].state.get() {\n+            let node = &self.nodes[i];\n+            match node.state.get() {\n                 NodeState::Pending | NodeState::Waiting => {\n                     if dead_nodes > 0 {\n                         self.nodes.swap(i, i - dead_nodes);\n                         node_rewrites[i] -= dead_nodes;\n                     }\n                 }\n                 NodeState::Done => {\n-                    // Avoid cloning the key (predicate) in case it exists in the waiting cache\n+                    // This lookup can fail because the contents of\n+                    // `self.waiting_cache` is not guaranteed to match those of\n+                    // `self.nodes`. See the comment in `process_obligation`\n+                    // for more details.\n                     if let Some((predicate, _)) = self.waiting_cache\n-                        .remove_entry(self.nodes[i].obligation.as_predicate())\n+                        .remove_entry(node.obligation.as_predicate())\n                     {\n                         self.done_cache.insert(predicate);\n                     } else {\n-                        self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n+                        self.done_cache.insert(node.obligation.as_predicate().clone());\n                     }\n                     node_rewrites[i] = nodes_len;\n                     dead_nodes += 1;\n@@ -643,7 +662,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n-                    self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                    self.waiting_cache.remove(node.obligation.as_predicate());\n                     node_rewrites[i] = nodes_len;\n                     dead_nodes += 1;\n                     self.insert_into_error_cache(i);\n@@ -655,12 +674,11 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // No compression needed.\n         if dead_nodes == 0 {\n             node_rewrites.truncate(0);\n-            self.scratch = Some(node_rewrites);\n+            self.scratch.replace(node_rewrites);\n             return if do_completed == DoCompleted::Yes { Some(vec![]) } else { None };\n         }\n \n-        // Pop off all the nodes we killed and extract the success\n-        // stories.\n+        // Pop off all the nodes we killed and extract the success stories.\n         let successful = if do_completed == DoCompleted::Yes {\n             Some((0..dead_nodes)\n                 .map(|_| self.nodes.pop().unwrap())\n@@ -679,7 +697,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.apply_rewrites(&node_rewrites);\n \n         node_rewrites.truncate(0);\n-        self.scratch = Some(node_rewrites);\n+        self.scratch.replace(node_rewrites);\n \n         successful\n     }\n@@ -689,58 +707,41 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &mut self.nodes {\n             if let Some(index) = node.parent {\n-                let new_index = node_rewrites[index.get()];\n-                if new_index >= nodes_len {\n-                    // parent dead due to error\n+                let new_i = node_rewrites[index.index()];\n+                if new_i >= nodes_len {\n                     node.parent = None;\n                 } else {\n-                    node.parent = Some(NodeIndex::new(new_index));\n+                    node.parent = Some(NodeIndex::new(new_i));\n                 }\n             }\n \n             let mut i = 0;\n             while i < node.dependents.len() {\n-                let new_index = node_rewrites[node.dependents[i].get()];\n-                if new_index >= nodes_len {\n+                let new_i = node_rewrites[node.dependents[i].index()];\n+                if new_i >= nodes_len {\n                     node.dependents.swap_remove(i);\n                 } else {\n-                    node.dependents[i] = NodeIndex::new(new_index);\n+                    node.dependents[i] = NodeIndex::new(new_i);\n                     i += 1;\n                 }\n             }\n         }\n \n-        let mut kill_list = vec![];\n-        for (predicate, index) in &mut self.waiting_cache {\n-            let new_index = node_rewrites[index.get()];\n-            if new_index >= nodes_len {\n-                kill_list.push(predicate.clone());\n+        // This updating of `self.waiting_cache` is necessary because the\n+        // removal of nodes within `compress` can fail. See above.\n+        self.waiting_cache.retain(|_predicate, index| {\n+            let new_i = node_rewrites[index.index()];\n+            if new_i >= nodes_len {\n+                false\n             } else {\n-                *index = NodeIndex::new(new_index);\n+                *index = NodeIndex::new(new_i);\n+                true\n             }\n-        }\n-\n-        for predicate in kill_list { self.waiting_cache.remove(&predicate); }\n-    }\n-}\n-\n-impl<O> Node<O> {\n-    fn new(\n-        parent: Option<NodeIndex>,\n-        obligation: O,\n-        obligation_tree_id: ObligationTreeId\n-    ) -> Node<O> {\n-        Node {\n-            obligation,\n-            state: Cell::new(NodeState::Pending),\n-            parent,\n-            dependents: vec![],\n-            obligation_tree_id,\n-        }\n+        });\n     }\n }\n \n-// I need a Clone closure\n+// I need a Clone closure.\n #[derive(Clone)]\n struct GetObligation<'a, O>(&'a [Node<O>]);\n "}, {"sha": "69ea473e054618dabe8dc437e23c649f42517b5f", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e93e81792aec04dc5bf3f9832a24aa7e30ddbd/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=69e93e81792aec04dc5bf3f9832a24aa7e30ddbd", "patch": "@@ -1,20 +0,0 @@\n-use std::num::NonZeroU32;\n-use std::u32;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct NodeIndex {\n-    index: NonZeroU32,\n-}\n-\n-impl NodeIndex {\n-    #[inline]\n-    pub fn new(value: usize) -> NodeIndex {\n-        assert!(value < (u32::MAX as usize));\n-        NodeIndex { index: NonZeroU32::new((value as u32) + 1).unwrap() }\n-    }\n-\n-    #[inline]\n-    pub fn get(self) -> usize {\n-        (self.index.get() - 1) as usize\n-    }\n-}"}]}