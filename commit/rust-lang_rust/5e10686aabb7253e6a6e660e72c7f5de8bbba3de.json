{"sha": "5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMTA2ODZhYWJiNzI1M2U2YTZlNjYwZTcyYzdmNWRlOGJiYmEzZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T20:11:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T20:11:23Z"}, "message": "auto merge of #14233 : pcwalton/rust/detildestr-morelibs, r=alexcrichton\n\nr? @alexcrichton", "tree": {"sha": "c9201890e56ad79f87fdefd95f1f332d91fffa75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9201890e56ad79f87fdefd95f1f332d91fffa75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "html_url": "https://github.com/rust-lang/rust/commit/5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "url": "https://api.github.com/repos/rust-lang/rust/commits/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "html_url": "https://github.com/rust-lang/rust/commit/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d"}, {"sha": "b84c0dc2d695c99b64653d125c367fce2ae591c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b84c0dc2d695c99b64653d125c367fce2ae591c4", "html_url": "https://github.com/rust-lang/rust/commit/b84c0dc2d695c99b64653d125c367fce2ae591c4"}], "stats": {"total": 2355, "additions": 1350, "deletions": 1005}, "files": [{"sha": "a7f693da6cceceff6948bd85f6055cb14cce2ba2", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -56,10 +56,10 @@ impl fmt::Show for Mode {\n #[deriving(Clone)]\n pub struct Config {\n     // The library paths required for running the compiler\n-    pub compile_lib_path: ~str,\n+    pub compile_lib_path: StrBuf,\n \n     // The library paths required for running compiled programs\n-    pub run_lib_path: ~str,\n+    pub run_lib_path: StrBuf,\n \n     // The rustc executable\n     pub rustc_path: Path,\n@@ -80,7 +80,7 @@ pub struct Config {\n     pub aux_base: Path,\n \n     // The name of the stage being built (stage1, etc)\n-    pub stage_id: ~str,\n+    pub stage_id: StrBuf,\n \n     // The test mode, compile-fail, run-fail, run-pass\n     pub mode: Mode,\n@@ -110,37 +110,37 @@ pub struct Config {\n \n     // A command line to prefix program execution with,\n     // for running under valgrind\n-    pub runtool: Option<~str>,\n+    pub runtool: Option<StrBuf>,\n \n     // Flags to pass to the compiler when building for the host\n-    pub host_rustcflags: Option<~str>,\n+    pub host_rustcflags: Option<StrBuf>,\n \n     // Flags to pass to the compiler when building for the target\n-    pub target_rustcflags: Option<~str>,\n+    pub target_rustcflags: Option<StrBuf>,\n \n     // Run tests using the JIT\n     pub jit: bool,\n \n     // Target system to be tested\n-    pub target: ~str,\n+    pub target: StrBuf,\n \n     // Host triple for the compiler being invoked\n-    pub host: ~str,\n+    pub host: StrBuf,\n \n     // Path to the android tools\n     pub android_cross_path: Path,\n \n     // Extra parameter to run adb on arm-linux-androideabi\n-    pub adb_path: ~str,\n+    pub adb_path: StrBuf,\n \n     // Extra parameter to run test sute on arm-linux-androideabi\n-    pub adb_test_dir: ~str,\n+    pub adb_test_dir: StrBuf,\n \n     // status whether android device available or not\n     pub adb_device_status: bool,\n \n     // the path containing LLDB's Python module\n-    pub lldb_python_dir: Option<~str>,\n+    pub lldb_python_dir: Option<StrBuf>,\n \n     // Explain what's going on\n     pub verbose: bool"}, {"sha": "3fb354a786768250b688f9cad6e6089839766606", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 85, "deletions": 58, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -48,12 +48,14 @@ fn start(argc: int, argv: **u8) -> int {\n \n pub fn main() {\n     let args = os::args();\n-    let config = parse_config(args.move_iter().collect());\n+    let config = parse_config(args.move_iter()\n+                                  .map(|x| x.to_strbuf())\n+                                  .collect());\n     log_config(&config);\n     run_tests(&config);\n }\n \n-pub fn parse_config(args: Vec<~str> ) -> Config {\n+pub fn parse_config(args: Vec<StrBuf> ) -> Config {\n \n     let groups : Vec<getopts::OptGroup> =\n         vec!(reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n@@ -91,15 +93,15 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n     assert!(!args.is_empty());\n     let argv0 = (*args.get(0)).clone();\n     let args_ = args.tail();\n-    if *args.get(1) == \"-h\".to_owned() || *args.get(1) == \"--help\".to_owned() {\n+    if args.get(1).as_slice() == \"-h\" || args.get(1).as_slice() == \"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n         println!(\"{}\", getopts::usage(message, groups.as_slice()));\n         println!(\"\");\n         fail!()\n     }\n \n     let matches =\n-        &match getopts::getopts(args_, groups.as_slice()) {\n+        &match getopts::getopts(args_.as_slice(), groups.as_slice()) {\n           Ok(m) => m,\n           Err(f) => fail!(\"{}\", f.to_err_msg())\n         };\n@@ -129,39 +131,53 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n     };\n \n     Config {\n-        compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n-        run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n+        compile_lib_path: matches.opt_str(\"compile-lib-path\")\n+                                 .unwrap()\n+                                 .to_strbuf(),\n+        run_lib_path: matches.opt_str(\"run-lib-path\").unwrap().to_strbuf(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n         clang_path: matches.opt_str(\"clang-path\").map(|s| Path::new(s)),\n         llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| Path::new(s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n-        stage_id: matches.opt_str(\"stage-id\").unwrap(),\n-        mode: FromStr::from_str(matches.opt_str(\"mode\").unwrap()).expect(\"invalid mode\"),\n+        stage_id: matches.opt_str(\"stage-id\").unwrap().to_strbuf(),\n+        mode: FromStr::from_str(matches.opt_str(\"mode\")\n+                                       .unwrap()\n+                                       .as_slice()).expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: filter,\n         logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),\n         save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::new(s)),\n         ratchet_metrics:\n             matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n         ratchet_noise_percent:\n-            matches.opt_str(\"ratchet-noise-percent\").and_then(|s| from_str::<f64>(s)),\n-        runtool: matches.opt_str(\"runtool\"),\n-        host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n-        target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n+            matches.opt_str(\"ratchet-noise-percent\")\n+                   .and_then(|s| from_str::<f64>(s.as_slice())),\n+        runtool: matches.opt_str(\"runtool\").map(|x| x.to_strbuf()),\n+        host_rustcflags: matches.opt_str(\"host-rustcflags\")\n+                                .map(|x| x.to_strbuf()),\n+        target_rustcflags: matches.opt_str(\"target-rustcflags\")\n+                                  .map(|x| x.to_strbuf()),\n         jit: matches.opt_present(\"jit\"),\n-        target: opt_str2(matches.opt_str(\"target\")).to_str(),\n-        host: opt_str2(matches.opt_str(\"host\")).to_str(),\n+        target: opt_str2(matches.opt_str(\"target\").map(|x| x.to_strbuf())),\n+        host: opt_str2(matches.opt_str(\"host\").map(|x| x.to_strbuf())),\n         android_cross_path: opt_path(matches, \"android-cross-path\"),\n-        adb_path: opt_str2(matches.opt_str(\"adb-path\")).to_str(),\n-        adb_test_dir:\n-            opt_str2(matches.opt_str(\"adb-test-dir\")).to_str(),\n+        adb_path: opt_str2(matches.opt_str(\"adb-path\")\n+                                  .map(|x| x.to_strbuf())),\n+        adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")\n+                                      .map(|x| x.to_strbuf())),\n         adb_device_status:\n-            \"arm-linux-androideabi\" == opt_str2(matches.opt_str(\"target\")) &&\n-            \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\")) &&\n-            !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n-        lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n+            \"arm-linux-androideabi\" ==\n+                opt_str2(matches.opt_str(\"target\")\n+                                .map(|x| x.to_strbuf())).as_slice() &&\n+            \"(none)\" !=\n+                opt_str2(matches.opt_str(\"adb-test-dir\")\n+                                .map(|x| x.to_strbuf())).as_slice() &&\n+            !opt_str2(matches.opt_str(\"adb-test-dir\")\n+                             .map(|x| x.to_strbuf())).is_empty(),\n+        lldb_python_dir: matches.opt_str(\"lldb-python-dir\")\n+                                .map(|x| x.to_strbuf()),\n         test_shard: test::opt_shard(matches.opt_str(\"test-shard\")\n                                            .map(|x| x.to_strbuf())),\n         verbose: matches.opt_present(\"verbose\")\n@@ -170,50 +186,59 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n \n pub fn log_config(config: &Config) {\n     let c = config;\n-    logv(c, format!(\"configuration:\"));\n-    logv(c, format!(\"compile_lib_path: {}\", config.compile_lib_path));\n-    logv(c, format!(\"run_lib_path: {}\", config.run_lib_path));\n-    logv(c, format!(\"rustc_path: {}\", config.rustc_path.display()));\n-    logv(c, format!(\"src_base: {}\", config.src_base.display()));\n-    logv(c, format!(\"build_base: {}\", config.build_base.display()));\n-    logv(c, format!(\"stage_id: {}\", config.stage_id));\n-    logv(c, format!(\"mode: {}\", config.mode));\n-    logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n-    logv(c, format!(\"filter: {}\", opt_str(&config.filter.as_ref().map(|re| re.to_str()))));\n-    logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n-    logv(c, format!(\"host-rustcflags: {}\", opt_str(&config.host_rustcflags)));\n-    logv(c, format!(\"target-rustcflags: {}\", opt_str(&config.target_rustcflags)));\n-    logv(c, format!(\"jit: {}\", config.jit));\n-    logv(c, format!(\"target: {}\", config.target));\n-    logv(c, format!(\"host: {}\", config.host));\n-    logv(c, format!(\"android-cross-path: {}\", config.android_cross_path.display()));\n-    logv(c, format!(\"adb_path: {}\", config.adb_path));\n-    logv(c, format!(\"adb_test_dir: {}\", config.adb_test_dir));\n-    logv(c, format!(\"adb_device_status: {}\", config.adb_device_status));\n+    logv(c, format_strbuf!(\"configuration:\"));\n+    logv(c, format_strbuf!(\"compile_lib_path: {}\", config.compile_lib_path));\n+    logv(c, format_strbuf!(\"run_lib_path: {}\", config.run_lib_path));\n+    logv(c, format_strbuf!(\"rustc_path: {}\", config.rustc_path.display()));\n+    logv(c, format_strbuf!(\"src_base: {}\", config.src_base.display()));\n+    logv(c, format_strbuf!(\"build_base: {}\", config.build_base.display()));\n+    logv(c, format_strbuf!(\"stage_id: {}\", config.stage_id));\n+    logv(c, format_strbuf!(\"mode: {}\", config.mode));\n+    logv(c, format_strbuf!(\"run_ignored: {}\", config.run_ignored));\n+    logv(c, format_strbuf!(\"filter: {}\",\n+                           opt_str(&config.filter\n+                                          .as_ref()\n+                                          .map(|re| {\n+                                              re.to_str().into_strbuf()\n+                                          }))));\n+    logv(c, format_strbuf!(\"runtool: {}\", opt_str(&config.runtool)));\n+    logv(c, format_strbuf!(\"host-rustcflags: {}\",\n+                           opt_str(&config.host_rustcflags)));\n+    logv(c, format_strbuf!(\"target-rustcflags: {}\",\n+                           opt_str(&config.target_rustcflags)));\n+    logv(c, format_strbuf!(\"jit: {}\", config.jit));\n+    logv(c, format_strbuf!(\"target: {}\", config.target));\n+    logv(c, format_strbuf!(\"host: {}\", config.host));\n+    logv(c, format_strbuf!(\"android-cross-path: {}\",\n+                           config.android_cross_path.display()));\n+    logv(c, format_strbuf!(\"adb_path: {}\", config.adb_path));\n+    logv(c, format_strbuf!(\"adb_test_dir: {}\", config.adb_test_dir));\n+    logv(c, format_strbuf!(\"adb_device_status: {}\",\n+                           config.adb_device_status));\n     match config.test_shard {\n-        None => logv(c, \"test_shard: (all)\".to_owned()),\n-        Some((a,b)) => logv(c, format!(\"test_shard: {}.{}\", a, b))\n+        None => logv(c, \"test_shard: (all)\".to_strbuf()),\n+        Some((a,b)) => logv(c, format_strbuf!(\"test_shard: {}.{}\", a, b))\n     }\n-    logv(c, format!(\"verbose: {}\", config.verbose));\n-    logv(c, format!(\"\\n\"));\n+    logv(c, format_strbuf!(\"verbose: {}\", config.verbose));\n+    logv(c, format_strbuf!(\"\\n\"));\n }\n \n-pub fn opt_str<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+pub fn opt_str<'a>(maybestr: &'a Option<StrBuf>) -> &'a str {\n     match *maybestr {\n         None => \"(none)\",\n-        Some(ref s) => {\n-            let s: &'a str = *s;\n-            s\n-        }\n+        Some(ref s) => s.as_slice(),\n     }\n }\n \n-pub fn opt_str2(maybestr: Option<~str>) -> ~str {\n-    match maybestr { None => \"(none)\".to_owned(), Some(s) => { s } }\n+pub fn opt_str2(maybestr: Option<StrBuf>) -> StrBuf {\n+    match maybestr {\n+        None => \"(none)\".to_strbuf(),\n+        Some(s) => s,\n+    }\n }\n \n pub fn run_tests(config: &Config) {\n-    if config.target == \"arm-linux-androideabi\".to_owned() {\n+    if config.target.as_slice() == \"arm-linux-androideabi\" {\n         match config.mode {\n             DebugInfoGdb => {\n                 println!(\"arm-linux-androideabi debug-info \\\n@@ -321,11 +346,11 @@ pub fn make_test(config: &Config, testfile: &Path, f: || -> test::TestFn)\n pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n \n     // Try to elide redundant long paths\n-    fn shorten(path: &Path) -> ~str {\n+    fn shorten(path: &Path) -> StrBuf {\n         let filename = path.filename_str();\n         let p = path.dir_path();\n         let dir = p.filename_str();\n-        format!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n+        format_strbuf!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n     }\n \n     test::DynTestName(format_strbuf!(\"[{}] {}\",\n@@ -336,14 +361,16 @@ pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = testfile.as_str().unwrap().to_owned();\n-    test::DynTestFn(proc() { runtest::run(config, testfile) })\n+    let testfile = testfile.as_str().unwrap().to_strbuf();\n+    test::DynTestFn(proc() {\n+        runtest::run(config, testfile)\n+    })\n }\n \n pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let testfile = testfile.as_str().unwrap().to_owned();\n+    let testfile = testfile.as_str().unwrap().to_strbuf();\n     test::DynMetricFn(proc(mm) {\n         runtest::run_metrics(config, testfile, mm)\n     })"}, {"sha": "4e65115caa2bec6fcbeab9e8eee2cf9f563268a9", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -12,8 +12,8 @@ use std::io::{BufferedReader, File};\n \n pub struct ExpectedError {\n     pub line: uint,\n-    pub kind: ~str,\n-    pub msg: ~str,\n+    pub kind: StrBuf,\n+    pub msg: StrBuf,\n }\n \n // Load any test directives embedded in the file\n@@ -23,17 +23,18 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     let mut line_num = 1u;\n     for ln in rdr.lines() {\n-        error_patterns.push_all_move(parse_expected(line_num, ln.unwrap()));\n+        error_patterns.push_all_move(parse_expected(line_num,\n+                                                    ln.unwrap().to_strbuf()));\n         line_num += 1u;\n     }\n     return error_patterns;\n }\n \n-fn parse_expected(line_num: uint, line: ~str) -> Vec<ExpectedError> {\n-    let line = line.trim();\n-    let error_tag = \"//~\".to_owned();\n+fn parse_expected(line_num: uint, line: StrBuf) -> Vec<ExpectedError> {\n+    let line = line.as_slice().trim().to_strbuf();\n+    let error_tag = \"//~\".to_strbuf();\n     let mut idx;\n-    match line.find_str(error_tag) {\n+    match line.as_slice().find_str(error_tag.as_slice()) {\n       None => return Vec::new(),\n       Some(nn) => { idx = (nn as uint) + error_tag.len(); }\n     }\n@@ -42,25 +43,34 @@ fn parse_expected(line_num: uint, line: ~str) -> Vec<ExpectedError> {\n     // three lines above current line:\n     let mut adjust_line = 0u;\n     let len = line.len();\n-    while idx < len && line[idx] == ('^' as u8) {\n+    while idx < len && line.as_slice()[idx] == ('^' as u8) {\n         adjust_line += 1u;\n         idx += 1u;\n     }\n \n     // Extract kind:\n-    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n+    while idx < len && line.as_slice()[idx] == (' ' as u8) {\n+        idx += 1u;\n+    }\n     let start_kind = idx;\n-    while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n+    while idx < len && line.as_slice()[idx] != (' ' as u8) {\n+        idx += 1u;\n+    }\n \n-    let kind = line.slice(start_kind, idx);\n-    let kind = kind.to_ascii().to_lower().into_str();\n+    let kind = line.as_slice().slice(start_kind, idx);\n+    let kind = kind.to_ascii().to_lower().into_str().to_strbuf();\n \n     // Extract msg:\n-    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-    let msg = line.slice(idx, len).to_owned();\n+    while idx < len && line.as_slice()[idx] == (' ' as u8) {\n+        idx += 1u;\n+    }\n+    let msg = line.as_slice().slice(idx, len).to_strbuf();\n \n     debug!(\"line={} kind={} msg={}\", line_num - adjust_line, kind, msg);\n \n-    return vec!(ExpectedError{line: line_num - adjust_line, kind: kind,\n-                           msg: msg});\n+    return vec!(ExpectedError{\n+        line: line_num - adjust_line,\n+        kind: kind,\n+        msg: msg,\n+    });\n }"}, {"sha": "5729a11d7ad7ef0862131a798607612d810f396a", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -14,20 +14,20 @@ use util;\n \n pub struct TestProps {\n     // Lines that should be expected, in order, on standard out\n-    pub error_patterns: Vec<~str> ,\n+    pub error_patterns: Vec<StrBuf> ,\n     // Extra flags to pass to the compiler\n-    pub compile_flags: Option<~str>,\n+    pub compile_flags: Option<StrBuf>,\n     // Extra flags to pass when the compiled code is run (such as --bench)\n-    pub run_flags: Option<~str>,\n+    pub run_flags: Option<StrBuf>,\n     // If present, the name of a file that this test should match when\n     // pretty-printed\n     pub pp_exact: Option<Path>,\n     // Modules from aux directory that should be compiled\n-    pub aux_builds: Vec<~str> ,\n+    pub aux_builds: Vec<StrBuf> ,\n     // Environment settings to use during execution\n-    pub exec_env: Vec<(~str,~str)> ,\n+    pub exec_env: Vec<(StrBuf,StrBuf)> ,\n     // Lines to check if they appear in the expected debugger output\n-    pub check_lines: Vec<~str> ,\n+    pub check_lines: Vec<StrBuf> ,\n     // Flag to force a crate to be built with the host architecture\n     pub force_host: bool,\n     // Check stdout for error-pattern output as well as stderr\n@@ -119,22 +119,30 @@ pub fn load_props(testfile: &Path) -> TestProps {\n }\n \n pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n-    fn ignore_target(config: &Config) -> ~str {\n-        \"ignore-\".to_owned() + util::get_os(config.target)\n+    fn ignore_target(config: &Config) -> StrBuf {\n+        format_strbuf!(\"ignore-{}\", util::get_os(config.target.as_slice()))\n     }\n-    fn ignore_stage(config: &Config) -> ~str {\n-        \"ignore-\".to_owned() + config.stage_id.split('-').next().unwrap()\n+    fn ignore_stage(config: &Config) -> StrBuf {\n+        format_strbuf!(\"ignore-{}\",\n+                       config.stage_id.as_slice().split('-').next().unwrap())\n     }\n \n     let val = iter_header(testfile, |ln| {\n-        if parse_name_directive(ln, \"ignore-test\") { false }\n-        else if parse_name_directive(ln, ignore_target(config)) { false }\n-        else if parse_name_directive(ln, ignore_stage(config)) { false }\n-        else if config.mode == common::Pretty &&\n-            parse_name_directive(ln, \"ignore-pretty\") { false }\n-        else if config.target != config.host &&\n-            parse_name_directive(ln, \"ignore-cross-compile\") { false }\n-        else { true }\n+        if parse_name_directive(ln, \"ignore-test\") {\n+            false\n+        } else if parse_name_directive(ln, ignore_target(config).as_slice()) {\n+            false\n+        } else if parse_name_directive(ln, ignore_stage(config).as_slice()) {\n+            false\n+        } else if config.mode == common::Pretty &&\n+                parse_name_directive(ln, \"ignore-pretty\") {\n+            false\n+        } else if config.target != config.host &&\n+                parse_name_directive(ln, \"ignore-cross-compile\") {\n+            false\n+        } else {\n+            true\n+        }\n     });\n \n     !val\n@@ -156,24 +164,24 @@ fn iter_header(testfile: &Path, it: |&str| -> bool) -> bool {\n     return true;\n }\n \n-fn parse_error_pattern(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"error-pattern\".to_owned())\n+fn parse_error_pattern(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"error-pattern\".to_strbuf())\n }\n \n-fn parse_aux_build(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"aux-build\".to_owned())\n+fn parse_aux_build(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"aux-build\".to_strbuf())\n }\n \n-fn parse_compile_flags(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"compile-flags\".to_owned())\n+fn parse_compile_flags(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"compile-flags\".to_strbuf())\n }\n \n-fn parse_run_flags(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"run-flags\".to_owned())\n+fn parse_run_flags(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"run-flags\".to_strbuf())\n }\n \n-fn parse_check_line(line: &str) -> Option<~str> {\n-    parse_name_value_directive(line, \"check\".to_owned())\n+fn parse_check_line(line: &str) -> Option<StrBuf> {\n+    parse_name_value_directive(line, \"check\".to_strbuf())\n }\n \n fn parse_force_host(line: &str) -> bool {\n@@ -192,13 +200,16 @@ fn parse_no_pretty_expanded(line: &str) -> bool {\n     parse_name_directive(line, \"no-pretty-expanded\")\n }\n \n-fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n-    parse_name_value_directive(line, \"exec-env\".to_owned()).map(|nv| {\n+fn parse_exec_env(line: &str) -> Option<(StrBuf, StrBuf)> {\n+    parse_name_value_directive(line, \"exec-env\".to_strbuf()).map(|nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs: Vec<~str> = nv.splitn('=', 1).map(|s| s.to_owned()).collect();\n+        let mut strs: Vec<StrBuf> = nv.as_slice()\n+                                      .splitn('=', 1)\n+                                      .map(|s| s.to_strbuf())\n+                                      .collect();\n \n         match strs.len() {\n-          1u => (strs.pop().unwrap(), \"\".to_owned()),\n+          1u => (strs.pop().unwrap(), \"\".to_strbuf()),\n           2u => {\n               let end = strs.pop().unwrap();\n               (strs.pop().unwrap(), end)\n@@ -209,7 +220,7 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n }\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n-    match parse_name_value_directive(line, \"pp-exact\".to_owned()) {\n+    match parse_name_value_directive(line, \"pp-exact\".to_strbuf()) {\n       Some(s) => Some(Path::new(s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n@@ -225,14 +236,14 @@ fn parse_name_directive(line: &str, directive: &str) -> bool {\n     line.contains(directive)\n }\n \n-pub fn parse_name_value_directive(line: &str,\n-                              directive: ~str) -> Option<~str> {\n-    let keycolon = directive + \":\";\n-    match line.find_str(keycolon) {\n+pub fn parse_name_value_directive(line: &str, directive: StrBuf)\n+                                  -> Option<StrBuf> {\n+    let keycolon = format_strbuf!(\"{}:\", directive);\n+    match line.find_str(keycolon.as_slice()) {\n         Some(colon) => {\n             let value = line.slice(colon + keycolon.len(),\n-                                   line.len()).to_owned();\n-            debug!(\"{}: {}\", directive,  value);\n+                                   line.len()).to_strbuf();\n+            debug!(\"{}: {}\", directive, value);\n             Some(value)\n         }\n         None => None"}, {"sha": "9f62fd7096c1a62e8980da95e6bbdecf80f6d31c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -13,7 +13,7 @@ use std::str;\n use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n \n #[cfg(target_os = \"win32\")]\n-fn target_env(lib_path: &str, prog: &str) -> Vec<(~str, ~str)> {\n+fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf, StrBuf)> {\n     let env = os::env();\n \n     // Make sure we include the aux directory in the path\n@@ -22,50 +22,53 @@ fn target_env(lib_path: &str, prog: &str) -> Vec<(~str, ~str)> {\n \n     let mut new_env: Vec<_> = env.move_iter().map(|(k, v)| {\n         let new_v = if \"PATH\" == k {\n-            format!(\"{};{};{}\", v, lib_path, aux_path)\n+            format_strbuf!(\"{};{};{}\", v, lib_path, aux_path)\n         } else {\n-            v\n+            v.to_strbuf()\n         };\n-        (k, new_v)\n+        (k.to_strbuf(), new_v)\n     }).collect();\n     if prog.ends_with(\"rustc.exe\") {\n-        new_env.push((\"RUST_THREADS\".to_owned(), \"1\".to_owned()));\n+        new_env.push((\"RUST_THREADS\".to_strbuf(), \"1\".to_strbuf()));\n     }\n     return new_env;\n }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn target_env(lib_path: &str, prog: &str) -> Vec<(~str,~str)> {\n+fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf,StrBuf)> {\n     // Make sure we include the aux directory in the path\n     let aux_path = prog + \".libaux\";\n \n-    let mut env: Vec<(~str,~str)> = os::env().move_iter().collect();\n+    let mut env: Vec<(StrBuf,StrBuf)> =\n+        os::env().move_iter()\n+                 .map(|(ref k, ref v)| (k.to_strbuf(), v.to_strbuf()))\n+                 .collect();\n     let var = if cfg!(target_os = \"macos\") {\n         \"DYLD_LIBRARY_PATH\"\n     } else {\n         \"LD_LIBRARY_PATH\"\n     };\n     let prev = match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n         Some(i) => env.remove(i).unwrap().val1(),\n-        None => \"\".to_owned(),\n+        None => \"\".to_strbuf(),\n     };\n-    env.push((var.to_owned(), if prev.is_empty() {\n-        lib_path + \":\" + aux_path\n+    env.push((var.to_strbuf(), if prev.is_empty() {\n+        format_strbuf!(\"{}:{}\", lib_path, aux_path)\n     } else {\n-        lib_path + \":\" + aux_path + \":\" + prev\n+        format_strbuf!(\"{}:{}:{}\", lib_path, aux_path, prev)\n     }));\n     return env;\n }\n \n-pub struct Result {pub status: ProcessExit, pub out: ~str, pub err: ~str}\n+pub struct Result {pub status: ProcessExit, pub out: StrBuf, pub err: StrBuf}\n \n pub fn run(lib_path: &str,\n            prog: &str,\n-           args: &[~str],\n-           env: Vec<(~str, ~str)> ,\n-           input: Option<~str>) -> Option<Result> {\n+           args: &[StrBuf],\n+           env: Vec<(StrBuf, StrBuf)> ,\n+           input: Option<StrBuf>) -> Option<Result> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n     match Command::new(prog).args(args).env(env.as_slice()).spawn() {\n@@ -78,8 +81,8 @@ pub fn run(lib_path: &str,\n \n             Some(Result {\n                 status: status,\n-                out: str::from_utf8(output.as_slice()).unwrap().to_owned(),\n-                err: str::from_utf8(error.as_slice()).unwrap().to_owned()\n+                out: str::from_utf8(output.as_slice()).unwrap().to_strbuf(),\n+                err: str::from_utf8(error.as_slice()).unwrap().to_strbuf()\n             })\n         },\n         Err(..) => None\n@@ -88,9 +91,9 @@ pub fn run(lib_path: &str,\n \n pub fn run_background(lib_path: &str,\n            prog: &str,\n-           args: &[~str],\n-           env: Vec<(~str, ~str)> ,\n-           input: Option<~str>) -> Option<Process> {\n+           args: &[StrBuf],\n+           env: Vec<(StrBuf, StrBuf)> ,\n+           input: Option<StrBuf>) -> Option<Process> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n     match Command::new(prog).args(args).env(env.as_slice()).spawn() {"}, {"sha": "55c3b6a34e5a994381374a2563184549b4092c9a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 498, "deletions": 276, "changes": 774, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -31,7 +31,7 @@ use std::strbuf::StrBuf;\n use std::task;\n use test::MetricMap;\n \n-pub fn run(config: Config, testfile: ~str) {\n+pub fn run(config: Config, testfile: StrBuf) {\n \n     match config.target.as_slice() {\n \n@@ -48,7 +48,7 @@ pub fn run(config: Config, testfile: ~str) {\n     run_metrics(config, testfile, &mut _mm);\n }\n \n-pub fn run_metrics(config: Config, testfile: ~str, mm: &mut MetricMap) {\n+pub fn run_metrics(config: Config, testfile: StrBuf, mm: &mut MetricMap) {\n     if config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n         print!(\"\\n\\n\");\n@@ -72,15 +72,17 @@ fn run_cfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     let proc_res = compile_test(config, props, testfile);\n \n     if proc_res.status.success() {\n-        fatal_ProcRes(\"compile-fail test compiled successfully!\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"compile-fail test compiled successfully!\".to_strbuf(),\n+                      &proc_res);\n     }\n \n     check_correct_failure_status(&proc_res);\n \n     let expected_errors = errors::load_errors(testfile);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n-            fatal(\"both error pattern and expected errors specified\".to_owned());\n+            fatal(\"both error pattern and expected errors \\\n+                   specified\".to_strbuf());\n         }\n         check_expected_errors(expected_errors, testfile, &proc_res);\n     } else {\n@@ -94,7 +96,7 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n+            fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n         }\n \n         exec_compiled_test(config, props, testfile)\n@@ -105,7 +107,8 @@ fn run_rfail_test(config: &Config, props: &TestProps, testfile: &Path) {\n     // The value our Makefile configures valgrind to return on failure\n     static VALGRIND_ERR: int = 100;\n     if proc_res.status.matches_exit_status(VALGRIND_ERR) {\n-        fatal_ProcRes(\"run-fail test isn't valgrind-clean!\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"run-fail test isn't valgrind-clean!\".to_strbuf(),\n+                      &proc_res);\n     }\n \n     check_correct_failure_status(&proc_res);\n@@ -117,7 +120,8 @@ fn check_correct_failure_status(proc_res: &ProcRes) {\n     static RUST_ERR: int = 101;\n     if !proc_res.status.matches_exit_status(RUST_ERR) {\n         fatal_ProcRes(\n-            format!(\"failure produced the wrong error: {}\", proc_res.status),\n+            format_strbuf!(\"failure produced the wrong error: {}\",\n+                           proc_res.status),\n             proc_res);\n     }\n }\n@@ -127,40 +131,49 @@ fn run_rpass_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let mut proc_res = compile_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n+            fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n         }\n \n         proc_res = exec_compiled_test(config, props, testfile);\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(\"test run failed!\".to_owned(), &proc_res);\n+            fatal_ProcRes(\"test run failed!\".to_strbuf(), &proc_res);\n         }\n     } else {\n         let proc_res = jit_test(config, props, testfile);\n \n-        if !proc_res.status.success() { fatal_ProcRes(\"jit failed!\".to_owned(), &proc_res); }\n+        if !proc_res.status.success() {\n+            fatal_ProcRes(\"jit failed!\".to_strbuf(), &proc_res);\n+        }\n     }\n }\n \n fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n-        logv(config, \"testing for exact pretty-printing\".to_owned());\n-    } else { logv(config, \"testing for converging pretty-printing\".to_owned()); }\n+        logv(config, \"testing for exact pretty-printing\".to_strbuf());\n+    } else {\n+        logv(config, \"testing for converging pretty-printing\".to_strbuf());\n+    }\n \n     let rounds =\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n     let src = File::open(testfile).read_to_end().unwrap();\n-    let src = str::from_utf8(src.as_slice()).unwrap().to_owned();\n+    let src = str::from_utf8(src.as_slice()).unwrap().to_strbuf();\n     let mut srcs = vec!(src);\n \n     let mut round = 0;\n     while round < rounds {\n-        logv(config, format!(\"pretty-printing round {}\", round));\n-        let proc_res = print_source(config, props, testfile, (*srcs.get(round)).clone(), \"normal\");\n+        logv(config, format_strbuf!(\"pretty-printing round {}\", round));\n+        let proc_res = print_source(config,\n+                                    props,\n+                                    testfile,\n+                                    (*srcs.get(round)).to_strbuf(),\n+                                    \"normal\");\n \n         if !proc_res.status.success() {\n-            fatal_ProcRes(format!(\"pretty-printing failed in round {}\", round),\n+            fatal_ProcRes(format_strbuf!(\"pretty-printing failed in round {}\",\n+                                         round),\n                           &proc_res);\n         }\n \n@@ -173,70 +186,87 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n             let s = File::open(&filepath).read_to_end().unwrap();\n-            str::from_utf8(s.as_slice()).unwrap().to_owned()\n+            str::from_utf8(s.as_slice()).unwrap().to_strbuf()\n           }\n           None => { (*srcs.get(srcs.len() - 2u)).clone() }\n         };\n     let mut actual = (*srcs.get(srcs.len() - 1u)).clone();\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n-        let cr = \"\\r\".to_owned();\n-        actual = actual.replace(cr, \"\");\n-        expected = expected.replace(cr, \"\");\n+        let cr = \"\\r\".to_strbuf();\n+        actual = actual.replace(cr.as_slice(), \"\").to_strbuf();\n+        expected = expected.replace(cr.as_slice(), \"\").to_strbuf();\n     }\n \n-    compare_source(expected, actual);\n+    compare_source(expected.as_slice(), actual.as_slice());\n \n     // Finally, let's make sure it actually appears to remain valid code\n     let proc_res = typecheck_source(config, props, testfile, actual);\n \n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"pretty-printed source does not typecheck\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"pretty-printed source does not typecheck\".to_strbuf(),\n+                      &proc_res);\n     }\n     if props.no_pretty_expanded { return }\n \n     // additionally, run `--pretty expanded` and try to build it.\n     let proc_res = print_source(config, props, testfile, (*srcs.get(round)).clone(), \"expanded\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(format!(\"pretty-printing (expanded) failed\"), &proc_res);\n+        fatal_ProcRes(format_strbuf!(\"pretty-printing (expanded) failed\"),\n+                                     &proc_res);\n     }\n \n     let ProcRes{ stdout: expanded_src, .. } = proc_res;\n     let proc_res = typecheck_source(config, props, testfile, expanded_src);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(format!(\"pretty-printed source (expanded) does not typecheck\"), &proc_res);\n+        fatal_ProcRes(format_strbuf!(\"pretty-printed source (expanded) does \\\n+                                      not typecheck\"),\n+                      &proc_res);\n     }\n \n     return;\n \n     fn print_source(config: &Config,\n                     props: &TestProps,\n                     testfile: &Path,\n-                    src: ~str,\n+                    src: StrBuf,\n                     pretty_type: &str) -> ProcRes {\n-        compose_and_run(config, testfile,\n-                        make_pp_args(config, props, testfile, pretty_type.to_owned()),\n-                        props.exec_env.clone(), config.compile_lib_path, Some(src))\n+        compose_and_run(config,\n+                        testfile,\n+                        make_pp_args(config,\n+                                     props,\n+                                     testfile,\n+                                     pretty_type.to_strbuf()),\n+                        props.exec_env.clone(),\n+                        config.compile_lib_path.as_slice(),\n+                        Some(src))\n     }\n \n     fn make_pp_args(config: &Config,\n                     props: &TestProps,\n                     testfile: &Path,\n-                    pretty_type: ~str) -> ProcArgs {\n+                    pretty_type: StrBuf) -> ProcArgs {\n         let aux_dir = aux_output_dir_name(config, testfile);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_owned(), \"--pretty\".to_owned(), pretty_type,\n-                            \"--target=\".to_owned() + config.target,\n-                            \"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n+        let mut args = vec!(\"-\".to_strbuf(),\n+                            \"--pretty\".to_strbuf(),\n+                            pretty_type,\n+                            format_strbuf!(\"--target={}\", config.target),\n+                            \"-L\".to_strbuf(),\n+                            aux_dir.as_str().unwrap().to_strbuf());\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n         args.push_all_move(split_maybe_args(&props.compile_flags));\n-        return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n+        return ProcArgs {\n+            prog: config.rustc_path.as_str().unwrap().to_strbuf(),\n+            args: args,\n+        };\n     }\n \n     fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n-            error(\"pretty-printed source does not match expected source\".to_owned());\n+            error(\"pretty-printed source does not match expected \\\n+                   source\".to_strbuf());\n             println!(\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n@@ -253,7 +283,7 @@ actual:\\n\\\n     }\n \n     fn typecheck_source(config: &Config, props: &TestProps,\n-                        testfile: &Path, src: ~str) -> ProcRes {\n+                        testfile: &Path, src: StrBuf) -> ProcRes {\n         let args = make_typecheck_args(config, props, testfile);\n         compose_and_run_compiler(config, props, testfile, args, Some(src))\n     }\n@@ -266,16 +296,21 @@ actual:\\n\\\n             config.target.as_slice()\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec!(\"-\".to_owned(),\n-                         \"--no-trans\".to_owned(), \"--crate-type=lib\".to_owned(),\n-                         \"--target=\".to_owned() + target,\n-                         \"-L\".to_owned(), config.build_base.as_str().unwrap().to_owned(),\n-                         \"-L\".to_owned(),\n-                         aux_dir.as_str().unwrap().to_owned());\n+        let mut args = vec!(\"-\".to_strbuf(),\n+                            \"--no-trans\".to_strbuf(),\n+                            \"--crate-type=lib\".to_strbuf(),\n+                            format_strbuf!(\"--target={}\", target),\n+                            \"-L\".to_strbuf(),\n+                            config.build_base.as_str().unwrap().to_strbuf(),\n+                            \"-L\".to_strbuf(),\n+                            aux_dir.as_str().unwrap().to_strbuf());\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n         args.push_all_move(split_maybe_args(&props.compile_flags));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n+        return ProcArgs {\n+            prog: config.rustc_path.as_str().unwrap().to_strbuf(),\n+            args: args,\n+        };\n     }\n }\n \n@@ -288,12 +323,12 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n     let config = &mut config;\n     let DebuggerCommands { commands, check_lines, .. } = parse_debugger_commands(testfile, \"gdb\");\n-    let mut cmds = commands.connect(\"\\n\");\n+    let mut cmds = commands.connect(\"\\n\").to_strbuf();\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let compiler_run_result = compile_test(config, props, testfile);\n     if !compiler_run_result.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_owned(), &compiler_run_result);\n+        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &compiler_run_result);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n@@ -303,38 +338,64 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     match config.target.as_slice() {\n         \"arm-linux-androideabi\" => {\n \n-            cmds = cmds.replace(\"run\",\"continue\");\n+            cmds = cmds.replace(\"run\", \"continue\").to_strbuf();\n \n             // write debugger script\n-            let script_str = [\"set charset UTF-8\".to_owned(),\n-                              format!(\"file {}\",exe_file.as_str().unwrap().to_owned()),\n-                              \"target remote :5039\".to_owned(),\n+            let script_str = [\"set charset UTF-8\".to_strbuf(),\n+                              format_strbuf!(\"file {}\",\n+                                             exe_file.as_str()\n+                                                     .unwrap()\n+                                                     .to_strbuf()),\n+                              \"target remote :5039\".to_strbuf(),\n                               cmds,\n-                              \"quit\".to_owned()].connect(\"\\n\");\n+                              \"quit\".to_strbuf()].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n \n-            procsrv::run(\"\", config.adb_path,\n-                         [\"push\".to_owned(), exe_file.as_str().unwrap().to_owned(),\n-                          config.adb_test_dir.clone()],\n-                         vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path));\n-\n-            procsrv::run(\"\", config.adb_path,\n-                         [\"forward\".to_owned(), \"tcp:5039\".to_owned(), \"tcp:5039\".to_owned()],\n-                         vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path));\n-\n-            let adb_arg = format!(\"export LD_LIBRARY_PATH={}; gdbserver :5039 {}/{}\",\n-                                  config.adb_test_dir.clone(), config.adb_test_dir.clone(),\n-                                  str::from_utf8(exe_file.filename().unwrap()).unwrap());\n-\n-            let mut process = procsrv::run_background(\"\", config.adb_path,\n-                                                      [\"shell\".to_owned(),adb_arg.clone()],\n-                                                      vec!((\"\".to_owned(),\"\".to_owned())),\n-                                                      Some(\"\".to_owned()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+            procsrv::run(\"\",\n+                         config.adb_path.as_slice(),\n+                         [\n+                            \"push\".to_strbuf(),\n+                            exe_file.as_str().unwrap().to_strbuf(),\n+                            config.adb_test_dir.clone()\n+                         ],\n+                         vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                         Some(\"\".to_strbuf()))\n+                .expect(format_strbuf!(\"failed to exec `{}`\",\n+                                       config.adb_path));\n+\n+            procsrv::run(\"\",\n+                         config.adb_path.as_slice(),\n+                         [\n+                            \"forward\".to_strbuf(),\n+                            \"tcp:5039\".to_strbuf(),\n+                            \"tcp:5039\".to_strbuf()\n+                         ],\n+                         vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                         Some(\"\".to_strbuf()))\n+                .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n+\n+            let adb_arg = format_strbuf!(\"export LD_LIBRARY_PATH={}; \\\n+                                          gdbserver :5039 {}/{}\",\n+                                         config.adb_test_dir.clone(),\n+                                         config.adb_test_dir.clone(),\n+                                         str::from_utf8(\n+                                             exe_file.filename()\n+                                             .unwrap()).unwrap());\n+\n+            let mut process = procsrv::run_background(\"\",\n+                                                      config.adb_path\n+                                                            .as_slice(),\n+                                                      [\n+                                                        \"shell\".to_strbuf(),\n+                                                        adb_arg.clone()\n+                                                      ],\n+                                                      vec!((\"\".to_strbuf(),\n+                                                            \"\".to_strbuf())),\n+                                                      Some(\"\".to_strbuf()))\n+                .expect(format_strbuf!(\"failed to exec `{}`\",\n+                                       config.adb_path));\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(1000);\n@@ -349,27 +410,34 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             let tool_path = match config.android_cross_path.as_str() {\n                 Some(x) => x.to_strbuf(),\n-                None => fatal(\"cannot find android cross path\".to_owned())\n+                None => fatal(\"cannot find android cross path\".to_strbuf())\n             };\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let debugger_opts = vec!(\"-quiet\".to_owned(), \"-batch\".to_owned(), \"-nx\".to_owned(),\n-                                  \"-command=\" + debugger_script.as_str().unwrap().to_owned());\n+            let debugger_opts =\n+                vec!(\"-quiet\".to_strbuf(),\n+                     \"-batch\".to_strbuf(),\n+                     \"-nx\".to_strbuf(),\n+                     format_strbuf!(\"-command={}\",\n+                                    debugger_script.as_str().unwrap()));\n \n             let gdb_path = tool_path.append(\"/bin/arm-linux-androideabi-gdb\");\n-            let procsrv::Result{ out, err, status }=\n-                procsrv::run(\"\",\n+            let procsrv::Result {\n+                out,\n+                err,\n+                status\n+            } = procsrv::run(\"\",\n                              gdb_path.as_slice(),\n                              debugger_opts.as_slice(),\n-                             vec!((\"\".to_owned(),\"\".to_owned())),\n+                             vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n                              None)\n-                .expect(format!(\"failed to exec `{}`\", gdb_path));\n+                .expect(format_strbuf!(\"failed to exec `{}`\", gdb_path));\n             let cmdline = {\n                 let cmdline = make_cmdline(\"\",\n                                            \"arm-linux-androideabi-gdb\",\n                                            debugger_opts.as_slice());\n-                logv(config, format!(\"executing {}\", cmdline));\n+                logv(config, format_strbuf!(\"executing {}\", cmdline));\n                 cmdline\n             };\n \n@@ -384,25 +452,38 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n         _=> {\n             // write debugger script\n-            let script_str = [\"set charset UTF-8\".to_owned(),\n+            let script_str = [\n+                \"set charset UTF-8\".to_strbuf(),\n                 cmds,\n-                \"quit\\n\".to_owned()].connect(\"\\n\");\n+                \"quit\\n\".to_strbuf()\n+            ].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n             dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n             // run debugger script with gdb\n             #[cfg(windows)]\n-            fn debugger() -> ~str { \"gdb.exe\".to_owned() }\n+            fn debugger() -> StrBuf {\n+                \"gdb.exe\".to_strbuf()\n+            }\n             #[cfg(unix)]\n-            fn debugger() -> ~str { \"gdb\".to_owned() }\n+            fn debugger() -> StrBuf {\n+                \"gdb\".to_strbuf()\n+            }\n \n             let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let debugger_opts = vec!(\"-quiet\".to_owned(), \"-batch\".to_owned(), \"-nx\".to_owned(),\n-                \"-command=\" + debugger_script.as_str().unwrap().to_owned(),\n-                exe_file.as_str().unwrap().to_owned());\n-            proc_args = ProcArgs {prog: debugger(), args: debugger_opts};\n+            let debugger_opts =\n+                vec!(\"-quiet\".to_strbuf(),\n+                     \"-batch\".to_strbuf(),\n+                     \"-nx\".to_strbuf(),\n+                     format_strbuf!(\"-command={}\",\n+                                    debugger_script.as_str().unwrap()),\n+                     exe_file.as_str().unwrap().to_strbuf());\n+            proc_args = ProcArgs {\n+                prog: debugger(),\n+                args: debugger_opts,\n+            };\n             debugger_run_result = compose_and_run(config,\n                                                   testfile,\n                                                   proc_args,\n@@ -413,7 +494,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n     }\n \n     if !debugger_run_result.status.success() {\n-        fatal(\"gdb failed to execute\".to_owned());\n+        fatal(\"gdb failed to execute\".to_strbuf());\n     }\n \n     check_debugger_output(&debugger_run_result, check_lines.as_slice());\n@@ -423,7 +504,8 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     use std::io::process::{Command, ProcessOutput};\n \n     if config.lldb_python_dir.is_none() {\n-        fatal(\"Can't run LLDB test because LLDB's python path is not set.\".to_owned());\n+        fatal(\"Can't run LLDB test because LLDB's python path is not \\\n+               set.\".to_strbuf());\n     }\n \n     let mut config = Config {\n@@ -437,7 +519,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let compile_result = compile_test(config, props, testfile);\n     if !compile_result.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_owned(), &compile_result);\n+        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &compile_result);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n@@ -476,7 +558,8 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n     let debugger_run_result = run_lldb(config, &exe_file, &debugger_script);\n \n     if !debugger_run_result.status.success() {\n-        fatal_ProcRes(\"Error while running LLDB\".to_owned(), &debugger_run_result);\n+        fatal_ProcRes(\"Error while running LLDB\".to_strbuf(),\n+                      &debugger_run_result);\n     }\n \n     check_debugger_output(&debugger_run_result, check_lines.as_slice());\n@@ -495,32 +578,34 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                     process.wait_with_output().unwrap();\n \n                 (status,\n-                 str::from_utf8(output.as_slice()).unwrap().to_owned(),\n-                 str::from_utf8(error.as_slice()).unwrap().to_owned())\n+                 str::from_utf8(output.as_slice()).unwrap().to_strbuf(),\n+                 str::from_utf8(error.as_slice()).unwrap().to_strbuf())\n             },\n             Err(e) => {\n-                fatal(format!(\"Failed to setup Python process for LLDB script: {}\", e))\n+                fatal(format_strbuf!(\"Failed to setup Python process for \\\n+                                      LLDB script: {}\",\n+                                     e))\n             }\n         };\n \n-        dump_output(config, test_executable, out, err);\n+        dump_output(config, test_executable, out.as_slice(), err.as_slice());\n         return ProcRes {\n             status: status,\n             stdout: out,\n             stderr: err,\n-            cmdline: format!(\"{}\", cmd)\n+            cmdline: format_strbuf!(\"{}\", cmd)\n         };\n     }\n }\n \n-struct DebuggerCommands\n-{\n-    commands: Vec<~str>,\n-    check_lines: Vec<~str>,\n-    breakpoint_lines: Vec<uint>\n+struct DebuggerCommands {\n+    commands: Vec<StrBuf>,\n+    check_lines: Vec<StrBuf>,\n+    breakpoint_lines: Vec<uint>,\n }\n \n-fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str) -> DebuggerCommands {\n+fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n+                           -> DebuggerCommands {\n     use std::io::{BufferedReader, File};\n \n     let command_directive = debugger_prefix + \"-command\";\n@@ -538,14 +623,22 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str) -> DebuggerC\n                     breakpoint_lines.push(counter);\n                 }\n \n-                header::parse_name_value_directive(line, command_directive.clone())\n-                    .map(|cmd| commands.push(cmd));\n+                header::parse_name_value_directive(\n+                        line,\n+                        command_directive.to_strbuf()).map(|cmd| {\n+                    commands.push(cmd)\n+                });\n \n-                header::parse_name_value_directive(line, check_directive.clone())\n-                    .map(|cmd| check_lines.push(cmd));\n+                header::parse_name_value_directive(\n+                        line,\n+                        check_directive.to_strbuf()).map(|cmd| {\n+                    check_lines.push(cmd)\n+                });\n             }\n             Err(e) => {\n-                fatal(format!(\"Error while parsing debugger commands: {}\", e))\n+                fatal(format_strbuf!(\"Error while parsing debugger commands: \\\n+                                      {}\",\n+                                     e))\n             }\n         }\n         counter += 1;\n@@ -558,41 +651,55 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str) -> DebuggerC\n     }\n }\n \n-fn cleanup_debug_info_options(options: &Option<~str>) -> Option<~str> {\n+fn cleanup_debug_info_options(options: &Option<StrBuf>) -> Option<StrBuf> {\n     if options.is_none() {\n         return None;\n     }\n \n     // Remove options that are either unwanted (-O) or may lead to duplicates due to RUSTFLAGS.\n-    let options_to_remove = [\"-O\".to_owned(), \"-g\".to_owned(), \"--debuginfo\".to_owned()];\n-    let new_options = split_maybe_args(options).move_iter()\n-                                               .filter(|x| !options_to_remove.contains(x))\n-                                               .collect::<Vec<~str>>()\n-                                               .connect(\" \");\n+    let options_to_remove = [\n+        \"-O\".to_strbuf(),\n+        \"-g\".to_strbuf(),\n+        \"--debuginfo\".to_strbuf()\n+    ];\n+    let new_options =\n+        split_maybe_args(options).move_iter()\n+                                 .filter(|x| !options_to_remove.contains(x))\n+                                 .collect::<Vec<StrBuf>>()\n+                                 .connect(\" \")\n+                                 .to_strbuf();\n     Some(new_options)\n }\n \n-fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[~str]) {\n+fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[StrBuf]) {\n     let num_check_lines = check_lines.len();\n     if num_check_lines > 0 {\n         // Allow check lines to leave parts unspecified (e.g., uninitialized\n         // bits in the wrong case of an enum) with the notation \"[...]\".\n-        let check_fragments: Vec<Vec<~str>> =\n+        let check_fragments: Vec<Vec<StrBuf>> =\n             check_lines.iter().map(|s| {\n-                s.trim().split_str(\"[...]\").map(|x| x.to_str()).collect()\n+                s.as_slice()\n+                 .trim()\n+                 .split_str(\"[...]\")\n+                 .map(|x| x.to_strbuf())\n+                 .collect()\n             }).collect();\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for line in debugger_run_result.stdout.lines() {\n+        for line in debugger_run_result.stdout.as_slice().lines() {\n             let mut rest = line.trim();\n             let mut first = true;\n             let mut failed = false;\n             for frag in check_fragments.get(i).iter() {\n                 let found = if first {\n-                    if rest.starts_with(*frag) { Some(0) } else { None }\n+                    if rest.starts_with(frag.as_slice()) {\n+                        Some(0)\n+                    } else {\n+                        None\n+                    }\n                 } else {\n-                    rest.find_str(*frag)\n+                    rest.find_str(frag.as_slice())\n                 };\n                 match found {\n                     None => {\n@@ -614,8 +721,10 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[~str]) {\n             }\n         }\n         if i != num_check_lines {\n-            fatal_ProcRes(format!(\"line not found in debugger output: {}\",\n-                                  check_lines.get(i).unwrap()), debugger_run_result);\n+            fatal_ProcRes(format_strbuf!(\"line not found in debugger output: \\\n+                                          {}\",\n+                                         check_lines.get(i).unwrap()),\n+                          debugger_run_result);\n         }\n     }\n }\n@@ -624,24 +733,24 @@ fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n                         proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        fatal(\"no error pattern specified in \".to_owned() +\n-              testfile.display().as_maybe_owned().as_slice());\n+        fatal(format_strbuf!(\"no error pattern specified in {}\",\n+                             testfile.display().as_maybe_owned().as_slice()));\n     }\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\".to_owned());\n+        fatal(\"process did not return an error status\".to_strbuf());\n     }\n \n     let mut next_err_idx = 0u;\n     let mut next_err_pat = props.error_patterns.get(next_err_idx);\n     let mut done = false;\n     let output_to_check = if props.check_stdout {\n-        proc_res.stdout + proc_res.stderr\n+        format_strbuf!(\"{}{}\", proc_res.stdout, proc_res.stderr)\n     } else {\n         proc_res.stderr.clone()\n     };\n-    for line in output_to_check.lines() {\n-        if line.contains(*next_err_pat) {\n+    for line in output_to_check.as_slice().lines() {\n+        if line.contains(next_err_pat.as_slice()) {\n             debug!(\"found error pattern {}\", *next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == props.error_patterns.len() {\n@@ -657,20 +766,22 @@ fn check_error_patterns(props: &TestProps,\n     let missing_patterns =\n         props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n-        fatal_ProcRes(format!(\"error pattern '{}' not found!\",\n-                              missing_patterns[0]), proc_res);\n+        fatal_ProcRes(format_strbuf!(\"error pattern '{}' not found!\",\n+                                     missing_patterns[0]),\n+                      proc_res);\n     } else {\n         for pattern in missing_patterns.iter() {\n-            error(format!(\"error pattern '{}' not found!\", *pattern));\n+            error(format_strbuf!(\"error pattern '{}' not found!\", *pattern));\n         }\n-        fatal_ProcRes(\"multiple error patterns not found\".to_owned(), proc_res);\n+        fatal_ProcRes(\"multiple error patterns not found\".to_strbuf(),\n+                      proc_res);\n     }\n }\n \n fn check_no_compiler_crash(proc_res: &ProcRes) {\n-    for line in proc_res.stderr.lines() {\n+    for line in proc_res.stderr.as_slice().lines() {\n         if line.starts_with(\"error: internal compiler error:\") {\n-            fatal_ProcRes(\"compiler encountered internal error\".to_owned(),\n+            fatal_ProcRes(\"compiler encountered internal error\".to_strbuf(),\n                           proc_res);\n         }\n     }\n@@ -685,15 +796,15 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         expected_errors.len(), false);\n \n     if proc_res.status.success() {\n-        fatal(\"process did not return an error status\".to_owned());\n+        fatal(\"process did not return an error status\".to_strbuf());\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        format!(\"{}:{}:\", testfile.display(), ee.line)\n-    }).collect::<Vec<~str> >();\n+        format_strbuf!(\"{}:{}:\", testfile.display(), ee.line)\n+    }).collect::<Vec<StrBuf> >();\n \n     #[cfg(target_os = \"win32\")]\n-    fn to_lower( s : &str ) -> ~str {\n+    fn to_lower( s : &str ) -> StrBuf {\n         let i = s.chars();\n         let c : Vec<char> = i.map( |c| {\n             if c.is_ascii() {\n@@ -702,12 +813,12 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                 c\n             }\n         } ).collect();\n-        str::from_chars(c.as_slice())\n+        str::from_chars(c.as_slice()).to_strbuf()\n     }\n \n     #[cfg(target_os = \"win32\")]\n     fn prefix_matches( line : &str, prefix : &str ) -> bool {\n-        to_lower(line).starts_with( to_lower(prefix) )\n+        to_lower(line).as_slice().starts_with(to_lower(prefix).as_slice())\n     }\n \n     #[cfg(target_os = \"linux\")]\n@@ -723,15 +834,18 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for line in proc_res.stderr.lines() {\n+    for line in proc_res.stderr.as_slice().lines() {\n         let mut was_expected = false;\n         for (i, ee) in expected_errors.iter().enumerate() {\n             if !*found_flags.get(i) {\n                 debug!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n-                       *prefixes.get(i), ee.kind, ee.msg, line);\n-                if prefix_matches(line, *prefixes.get(i)) &&\n-                    line.contains(ee.kind) &&\n-                    line.contains(ee.msg) {\n+                       prefixes.get(i).as_slice(),\n+                       ee.kind,\n+                       ee.msg,\n+                       line);\n+                if prefix_matches(line, prefixes.get(i).as_slice()) &&\n+                    line.contains(ee.kind.as_slice()) &&\n+                    line.contains(ee.msg.as_slice()) {\n                     *found_flags.get_mut(i) = true;\n                     was_expected = true;\n                     break;\n@@ -745,17 +859,22 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         }\n \n         if !was_expected && is_compiler_error_or_warning(line) {\n-            fatal_ProcRes(format!(\"unexpected compiler error or warning: '{}'\",\n-                               line),\n+            fatal_ProcRes(format_strbuf!(\"unexpected compiler error or \\\n+                                          warning: '{}'\",\n+                                         line),\n                           proc_res);\n         }\n     }\n \n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n             let ee = expected_errors.get(i);\n-            fatal_ProcRes(format!(\"expected {} on line {} not found: {}\",\n-                               ee.kind, ee.line, ee.msg), proc_res);\n+            fatal_ProcRes(format_strbuf!(\"expected {} on line {} not found: \\\n+                                          {}\",\n+                                         ee.kind,\n+                                         ee.line,\n+                                         ee.msg),\n+                          proc_res);\n         }\n     }\n }\n@@ -835,24 +954,33 @@ fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n     return true;\n }\n \n-struct ProcArgs {prog: ~str, args: Vec<~str> }\n+struct ProcArgs {\n+    prog: StrBuf,\n+    args: Vec<StrBuf>,\n+}\n \n-struct ProcRes {status: ProcessExit, stdout: ~str, stderr: ~str, cmdline: ~str}\n+struct ProcRes {\n+    status: ProcessExit,\n+    stdout: StrBuf,\n+    stderr: StrBuf,\n+    cmdline: StrBuf,\n+}\n \n fn compile_test(config: &Config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [])\n }\n \n fn jit_test(config: &Config, props: &TestProps, testfile: &Path) -> ProcRes {\n-    compile_test_(config, props, testfile, [\"--jit\".to_owned()])\n+    compile_test_(config, props, testfile, [\"--jit\".to_strbuf()])\n }\n \n fn compile_test_(config: &Config, props: &TestProps,\n-                 testfile: &Path, extra_args: &[~str]) -> ProcRes {\n+                 testfile: &Path, extra_args: &[StrBuf]) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n+    let link_args = vec!(\"-L\".to_strbuf(),\n+                         aux_dir.as_str().unwrap().to_strbuf());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(extra_args),\n@@ -872,10 +1000,12 @@ fn exec_compiled_test(config: &Config, props: &TestProps,\n         }\n \n         _=> {\n-            compose_and_run(config, testfile,\n+            compose_and_run(config,\n+                            testfile,\n                             make_run_args(config, props, testfile),\n                             env,\n-                            config.run_lib_path, None)\n+                            config.run_lib_path.as_slice(),\n+                            None)\n         }\n     }\n }\n@@ -885,7 +1015,7 @@ fn compose_and_run_compiler(\n     props: &TestProps,\n     testfile: &Path,\n     args: ProcArgs,\n-    input: Option<~str>) -> ProcRes {\n+    input: Option<StrBuf>) -> ProcRes {\n \n     if !props.aux_builds.is_empty() {\n         ensure_dir(&aux_output_dir_name(config, testfile));\n@@ -901,37 +1031,48 @@ fn compose_and_run_compiler(\n         let crate_type = if aux_props.no_prefer_dynamic {\n             Vec::new()\n         } else {\n-            vec!(\"--crate-type=dylib\".to_owned())\n+            vec!(\"--crate-type=dylib\".to_strbuf())\n         };\n         let aux_args =\n             make_compile_args(config,\n                               &aux_props,\n-                              crate_type.append(extra_link_args.as_slice()),\n+                              crate_type.append(\n+                                  extra_link_args.iter()\n+                                                 .map(|x| x.to_strbuf())\n+                                                 .collect::<Vec<_>>()\n+                                                 .as_slice()),\n                               |a,b| {\n                                   let f = make_lib_name(a, b, testfile);\n                                   ThisDirectory(f.dir_path())\n-                              }, &abs_ab);\n-        let auxres = compose_and_run(config, &abs_ab, aux_args, Vec::new(),\n-                                     config.compile_lib_path, None);\n+                              },\n+                              &abs_ab);\n+        let auxres = compose_and_run(config,\n+                                     &abs_ab,\n+                                     aux_args,\n+                                     Vec::new(),\n+                                     config.compile_lib_path.as_slice(),\n+                                     None);\n         if !auxres.status.success() {\n             fatal_ProcRes(\n-                format!(\"auxiliary build of {} failed to compile: \",\n-                     abs_ab.display()),\n+                format_strbuf!(\"auxiliary build of {} failed to compile: \",\n+                               abs_ab.display()),\n                 &auxres);\n         }\n \n         match config.target.as_slice() {\n-\n             \"arm-linux-androideabi\" => {\n                 _arm_push_aux_shared_library(config, testfile);\n             }\n-\n-            _=> { }\n+            _ => {}\n         }\n     }\n \n-    compose_and_run(config, testfile, args, Vec::new(),\n-                    config.compile_lib_path, input)\n+    compose_and_run(config,\n+                    testfile,\n+                    args,\n+                    Vec::new(),\n+                    config.compile_lib_path.as_slice(),\n+                    input)\n }\n \n fn ensure_dir(path: &Path) {\n@@ -941,9 +1082,9 @@ fn ensure_dir(path: &Path) {\n \n fn compose_and_run(config: &Config, testfile: &Path,\n                    ProcArgs{ args, prog }: ProcArgs,\n-                   procenv: Vec<(~str, ~str)> ,\n+                   procenv: Vec<(StrBuf, StrBuf)> ,\n                    lib_path: &str,\n-                   input: Option<~str>) -> ProcRes {\n+                   input: Option<StrBuf>) -> ProcRes {\n     return program_output(config, testfile, lib_path,\n                           prog, args, procenv, input);\n }\n@@ -955,7 +1096,7 @@ enum TargetLocation {\n \n fn make_compile_args(config: &Config,\n                      props: &TestProps,\n-                     extras: Vec<~str> ,\n+                     extras: Vec<StrBuf> ,\n                      xform: |&Config, &Path| -> TargetLocation,\n                      testfile: &Path)\n                      -> ProcArgs {\n@@ -966,26 +1107,36 @@ fn make_compile_args(config: &Config,\n         config.target.as_slice()\n     };\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let mut args = vec!(testfile.as_str().unwrap().to_owned(),\n-                     \"-L\".to_owned(), config.build_base.as_str().unwrap().to_owned(),\n-                     \"--target=\".to_owned() + target);\n+    let mut args = vec!(testfile.as_str().unwrap().to_strbuf(),\n+                        \"-L\".to_strbuf(),\n+                        config.build_base.as_str().unwrap().to_strbuf(),\n+                        format_strbuf!(\"--target={}\", target));\n     args.push_all(extras.as_slice());\n     if !props.no_prefer_dynamic {\n-        args.push(\"-C\".to_owned());\n-        args.push(\"prefer-dynamic\".to_owned());\n+        args.push(\"-C\".to_strbuf());\n+        args.push(\"prefer-dynamic\".to_strbuf());\n     }\n     let path = match xform_file {\n-        ThisFile(path) => { args.push(\"-o\".to_owned()); path }\n-        ThisDirectory(path) => { args.push(\"--out-dir\".to_owned()); path }\n+        ThisFile(path) => {\n+            args.push(\"-o\".to_strbuf());\n+            path\n+        }\n+        ThisDirectory(path) => {\n+            args.push(\"--out-dir\".to_strbuf());\n+            path\n+        }\n     };\n-    args.push(path.as_str().unwrap().to_owned());\n+    args.push(path.as_str().unwrap().to_strbuf());\n     if props.force_host {\n         args.push_all_move(split_maybe_args(&config.host_rustcflags));\n     } else {\n         args.push_all_move(split_maybe_args(&config.target_rustcflags));\n     }\n     args.push_all_move(split_maybe_args(&props.compile_flags));\n-    return ProcArgs {prog: config.rustc_path.as_str().unwrap().to_owned(), args: args};\n+    return ProcArgs {\n+        prog: config.rustc_path.as_str().unwrap().to_strbuf(),\n+        args: args,\n+    };\n }\n \n fn make_lib_name(config: &Config, auxfile: &Path, testfile: &Path) -> Path {\n@@ -1014,64 +1165,88 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     let exe_file = make_exe_name(config, testfile);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    args.push(exe_file.as_str().unwrap().to_owned());\n+    args.push(exe_file.as_str().unwrap().to_strbuf());\n \n     // Add the arguments in the run_flags directive\n     args.push_all_move(split_maybe_args(&props.run_flags));\n \n     let prog = args.shift().unwrap();\n-    return ProcArgs {prog: prog, args: args};\n+    return ProcArgs {\n+        prog: prog,\n+        args: args,\n+    };\n }\n \n-fn split_maybe_args(argstr: &Option<~str>) -> Vec<~str> {\n+fn split_maybe_args(argstr: &Option<StrBuf>) -> Vec<StrBuf> {\n     match *argstr {\n         Some(ref s) => {\n-            s.split(' ')\n-                .filter_map(|s| if s.is_whitespace() {None} else {Some(s.to_owned())})\n-                .collect()\n+            s.as_slice()\n+             .split(' ')\n+             .filter_map(|s| {\n+                 if s.is_whitespace() {\n+                     None\n+                 } else {\n+                     Some(s.to_strbuf())\n+                 }\n+             }).collect()\n         }\n         None => Vec::new()\n     }\n }\n \n-fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: ~str,\n-                  args: Vec<~str> , env: Vec<(~str, ~str)> ,\n-                  input: Option<~str>) -> ProcRes {\n+fn program_output(config: &Config, testfile: &Path, lib_path: &str, prog: StrBuf,\n+                  args: Vec<StrBuf> , env: Vec<(StrBuf, StrBuf)> ,\n+                  input: Option<StrBuf>) -> ProcRes {\n     let cmdline =\n         {\n-            let cmdline = make_cmdline(lib_path, prog, args.as_slice());\n-            logv(config, format!(\"executing {}\", cmdline));\n+            let cmdline = make_cmdline(lib_path,\n+                                       prog.as_slice(),\n+                                       args.as_slice());\n+            logv(config, format_strbuf!(\"executing {}\", cmdline));\n             cmdline\n         };\n-    let procsrv::Result{ out, err, status } =\n-            procsrv::run(lib_path, prog, args.as_slice(), env, input)\n-            .expect(format!(\"failed to exec `{}`\", prog));\n-    dump_output(config, testfile, out, err);\n-    return ProcRes {status: status,\n-         stdout: out,\n-         stderr: err,\n-         cmdline: cmdline};\n+    let procsrv::Result {\n+        out,\n+        err,\n+        status\n+    } = procsrv::run(lib_path,\n+                     prog.as_slice(),\n+                     args.as_slice(),\n+                     env,\n+                     input).expect(format_strbuf!(\"failed to exec `{}`\",\n+                                                  prog));\n+    dump_output(config, testfile, out.as_slice(), err.as_slice());\n+    return ProcRes {\n+        status: status,\n+        stdout: out,\n+        stderr: err,\n+        cmdline: cmdline,\n+    };\n }\n \n // Linux and mac don't require adjusting the library search path\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn make_cmdline(_libpath: &str, prog: &str, args: &[~str]) -> ~str {\n-    format!(\"{} {}\", prog, args.connect(\" \"))\n+fn make_cmdline(_libpath: &str, prog: &str, args: &[StrBuf]) -> StrBuf {\n+    format_strbuf!(\"{} {}\", prog, args.connect(\" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n-fn make_cmdline(libpath: &str, prog: &str, args: &[~str]) -> ~str {\n-    format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog,\n-         args.connect(\" \"))\n+fn make_cmdline(libpath: &str, prog: &str, args: &[StrBuf]) -> StrBuf {\n+    format_strbuf!(\"{} {} {}\",\n+                   lib_path_cmd_prefix(libpath),\n+                   prog,\n+                   args.connect(\" \"))\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n #[cfg(target_os = \"win32\")]\n-fn lib_path_cmd_prefix(path: &str) -> ~str {\n-    format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n+fn lib_path_cmd_prefix(path: &str) -> StrBuf {\n+    format_strbuf!(\"{}=\\\"{}\\\"\",\n+                   util::lib_path_env_var(),\n+                   util::make_new_path(path))\n }\n \n fn dump_output(config: &Config, testfile: &Path, out: &str, err: &str) {\n@@ -1119,11 +1294,11 @@ fn maybe_dump_to_stdout(config: &Config, out: &str, err: &str) {\n     }\n }\n \n-fn error(err: ~str) { println!(\"\\nerror: {}\", err); }\n+fn error(err: StrBuf) { println!(\"\\nerror: {}\", err); }\n \n-fn fatal(err: ~str) -> ! { error(err); fail!(); }\n+fn fatal(err: StrBuf) -> ! { error(err); fail!(); }\n \n-fn fatal_ProcRes(err: ~str, proc_res: &ProcRes) -> ! {\n+fn fatal_ProcRes(err: StrBuf, proc_res: &ProcRes) -> ! {\n     print!(\"\\n\\\n error: {}\\n\\\n status: {}\\n\\\n@@ -1142,63 +1317,85 @@ stderr:\\n\\\n     fail!();\n }\n \n-fn _arm_exec_compiled_test(config: &Config, props: &TestProps,\n-                      testfile: &Path, env: Vec<(~str, ~str)> ) -> ProcRes {\n-\n+fn _arm_exec_compiled_test(config: &Config,\n+                           props: &TestProps,\n+                           testfile: &Path,\n+                           env: Vec<(StrBuf, StrBuf)>)\n+                           -> ProcRes {\n     let args = make_run_args(config, props, testfile);\n-    let cmdline = make_cmdline(\"\", args.prog, args.args.as_slice());\n+    let cmdline = make_cmdline(\"\",\n+                               args.prog.as_slice(),\n+                               args.args.as_slice());\n \n     // get bare program string\n-    let mut tvec: Vec<~str> = args.prog.split('/').map(|ts| ts.to_owned()).collect();\n+    let mut tvec: Vec<StrBuf> = args.prog\n+                                    .as_slice()\n+                                    .split('/')\n+                                    .map(|ts| ts.to_strbuf())\n+                                    .collect();\n     let prog_short = tvec.pop().unwrap();\n \n     // copy to target\n-    let copy_result = procsrv::run(\"\", config.adb_path,\n-        [\"push\".to_owned(), args.prog.clone(), config.adb_test_dir.clone()],\n-        vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+    let copy_result = procsrv::run(\"\",\n+                                   config.adb_path.as_slice(),\n+                                   [\n+                                    \"push\".to_strbuf(),\n+                                    args.prog.clone(),\n+                                    config.adb_test_dir.clone()\n+                                   ],\n+                                   vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                                   Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     if config.verbose {\n         println!(\"push ({}) {} {} {}\",\n-            config.target, args.prog,\n-            copy_result.out, copy_result.err);\n+                 config.target,\n+                 args.prog,\n+                 copy_result.out,\n+                 copy_result.err);\n     }\n \n-    logv(config, format!(\"executing ({}) {}\", config.target, cmdline));\n+    logv(config, format_strbuf!(\"executing ({}) {}\", config.target, cmdline));\n \n     let mut runargs = Vec::new();\n \n     // run test via adb_run_wrapper\n-    runargs.push(\"shell\".to_owned());\n+    runargs.push(\"shell\".to_strbuf());\n     for (key, val) in env.move_iter() {\n-        runargs.push(format!(\"{}={}\", key, val));\n+        runargs.push(format_strbuf!(\"{}={}\", key, val));\n     }\n-    runargs.push(format!(\"{}/adb_run_wrapper.sh\", config.adb_test_dir));\n-    runargs.push(format!(\"{}\", config.adb_test_dir));\n-    runargs.push(format!(\"{}\", prog_short));\n+    runargs.push(format_strbuf!(\"{}/adb_run_wrapper.sh\",\n+                                config.adb_test_dir));\n+    runargs.push(format_strbuf!(\"{}\", config.adb_test_dir));\n+    runargs.push(format_strbuf!(\"{}\", prog_short));\n \n     for tv in args.args.iter() {\n-        runargs.push(tv.to_owned());\n+        runargs.push(tv.to_strbuf());\n     }\n     procsrv::run(\"\",\n-                 config.adb_path,\n+                 config.adb_path.as_slice(),\n                  runargs.as_slice(),\n-                 vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+                 vec!((\"\".to_strbuf(), \"\".to_strbuf())), Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     // get exitcode of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_owned());\n-    runargs.push(\"cat\".to_owned());\n-    runargs.push(format!(\"{}/{}.exitcode\", config.adb_test_dir, prog_short));\n+    runargs.push(\"shell\".to_strbuf());\n+    runargs.push(\"cat\".to_strbuf());\n+    runargs.push(format_strbuf!(\"{}/{}.exitcode\",\n+                                config.adb_test_dir,\n+                                prog_short));\n \n     let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n-        procsrv::run(\"\", config.adb_path, runargs.as_slice(), vec!((\"\".to_owned(),\"\".to_owned())),\n-                     Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+        procsrv::run(\"\",\n+                     config.adb_path.as_slice(),\n+                     runargs.as_slice(),\n+                     vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                     Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n-    let mut exitcode : int = 0;\n-    for c in exitcode_out.chars() {\n+    let mut exitcode: int = 0;\n+    for c in exitcode_out.as_slice().chars() {\n         if !c.is_digit() { break; }\n         exitcode = exitcode * 10 + match c {\n             '0' .. '9' => c as int - ('0' as int),\n@@ -1208,31 +1405,40 @@ fn _arm_exec_compiled_test(config: &Config, props: &TestProps,\n \n     // get stdout of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_owned());\n-    runargs.push(\"cat\".to_owned());\n-    runargs.push(format!(\"{}/{}.stdout\", config.adb_test_dir, prog_short));\n+    runargs.push(\"shell\".to_strbuf());\n+    runargs.push(\"cat\".to_strbuf());\n+    runargs.push(format_strbuf!(\"{}/{}.stdout\",\n+                                config.adb_test_dir,\n+                                prog_short));\n \n     let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n         procsrv::run(\"\",\n-                     config.adb_path,\n+                     config.adb_path.as_slice(),\n                      runargs.as_slice(),\n-                     vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+                     vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                     Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n     // get stderr of result\n     runargs = Vec::new();\n-    runargs.push(\"shell\".to_owned());\n-    runargs.push(\"cat\".to_owned());\n-    runargs.push(format!(\"{}/{}.stderr\", config.adb_test_dir, prog_short));\n+    runargs.push(\"shell\".to_strbuf());\n+    runargs.push(\"cat\".to_strbuf());\n+    runargs.push(format_strbuf!(\"{}/{}.stderr\",\n+                                config.adb_test_dir,\n+                                prog_short));\n \n     let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n         procsrv::run(\"\",\n-                     config.adb_path,\n+                     config.adb_path.as_slice(),\n                      runargs.as_slice(),\n-                     vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+                     vec!((\"\".to_strbuf(), \"\".to_strbuf())),\n+                     Some(\"\".to_strbuf()))\n+        .expect(format_strbuf!(\"failed to exec `{}`\", config.adb_path));\n \n-    dump_output(config, testfile, stdout_out, stderr_out);\n+    dump_output(config,\n+                testfile,\n+                stdout_out.as_slice(),\n+                stderr_out.as_slice());\n \n     ProcRes {\n         status: process::ExitStatus(exitcode),\n@@ -1249,10 +1455,20 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n     for file in dirs.iter() {\n         if file.extension_str() == Some(\"so\") {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let copy_result = procsrv::run(\"\", config.adb_path,\n-                [\"push\".to_owned(), file.as_str().unwrap().to_owned(), config.adb_test_dir.clone()],\n-                vec!((\"\".to_owned(),\"\".to_owned())), Some(\"\".to_owned()))\n-                .expect(format!(\"failed to exec `{}`\", config.adb_path));\n+            let copy_result = procsrv::run(\"\",\n+                                           config.adb_path.as_slice(),\n+                                           [\n+                                            \"push\".to_strbuf(),\n+                                            file.as_str()\n+                                                .unwrap()\n+                                                .to_strbuf(),\n+                                            config.adb_test_dir.to_strbuf()\n+                                           ],\n+                                           vec!((\"\".to_strbuf(),\n+                                                 \"\".to_strbuf())),\n+                                           Some(\"\".to_strbuf()))\n+                .expect(format_strbuf!(\"failed to exec `{}`\",\n+                                       config.adb_path));\n \n             if config.verbose {\n                 println!(\"push ({}) {} {} {}\",\n@@ -1282,9 +1498,12 @@ fn compile_test_and_save_bitcode(config: &Config, props: &TestProps,\n                                  testfile: &Path) -> ProcRes {\n     let aux_dir = aux_output_dir_name(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let link_args = vec!(\"-L\".to_owned(), aux_dir.as_str().unwrap().to_owned());\n-    let llvm_args = vec!(\"--emit=obj\".to_owned(), \"--crate-type=lib\".to_owned(),\n-                         \"-C\".to_owned(), \"save-temps\".to_owned());\n+    let link_args = vec!(\"-L\".to_strbuf(),\n+                         aux_dir.as_str().unwrap().to_strbuf());\n+    let llvm_args = vec!(\"--emit=obj\".to_strbuf(),\n+                         \"--crate-type=lib\".to_strbuf(),\n+                         \"-C\".to_strbuf(),\n+                         \"save-temps\".to_strbuf());\n     let args = make_compile_args(config,\n                                  props,\n                                  link_args.append(llvm_args.as_slice()),\n@@ -1299,11 +1518,12 @@ fn compile_cc_with_clang_and_save_bitcode(config: &Config, _props: &TestProps,\n     let testcc = testfile.with_extension(\"cc\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: config.clang_path.get_ref().as_str().unwrap().to_owned(),\n-        args: vec!(\"-c\".to_owned(),\n-                \"-emit-llvm\".to_owned(),\n-                \"-o\".to_owned(), bitcodefile.as_str().unwrap().to_owned(),\n-                testcc.as_str().unwrap().to_owned() )\n+        prog: config.clang_path.get_ref().as_str().unwrap().to_strbuf(),\n+        args: vec!(\"-c\".to_strbuf(),\n+                   \"-emit-llvm\".to_strbuf(),\n+                   \"-o\".to_strbuf(),\n+                   bitcodefile.as_str().unwrap().to_strbuf(),\n+                   testcc.as_str().unwrap().to_strbuf())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n@@ -1317,10 +1537,10 @@ fn extract_function_from_bitcode(config: &Config, _props: &TestProps,\n     let prog = config.llvm_bin_path.get_ref().join(\"llvm-extract\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: prog.as_str().unwrap().to_owned(),\n-        args: vec!(\"-func=\" + fname,\n-                \"-o=\" + extracted_bc.as_str().unwrap(),\n-                bitcodefile.as_str().unwrap().to_owned() )\n+        prog: prog.as_str().unwrap().to_strbuf(),\n+        args: vec!(format_strbuf!(\"-func={}\", fname),\n+                   format_strbuf!(\"-o={}\", extracted_bc.as_str().unwrap()),\n+                   bitcodefile.as_str().unwrap().to_strbuf())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n@@ -1334,9 +1554,9 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n     let prog = config.llvm_bin_path.get_ref().join(\"llvm-dis\");\n     let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prog: prog.as_str().unwrap().to_owned(),\n-        args: vec!(\"-o=\" + extracted_ll.as_str().unwrap(),\n-                extracted_bc.as_str().unwrap().to_owned() )\n+        prog: prog.as_str().unwrap().to_strbuf(),\n+        args: vec!(format_strbuf!(\"-o={}\", extracted_ll.as_str().unwrap()),\n+                   extracted_bc.as_str().unwrap().to_strbuf())\n     };\n     compose_and_run(config, testfile, proc_args, Vec::new(), \"\", None)\n }\n@@ -1353,42 +1573,44 @@ fn run_codegen_test(config: &Config, props: &TestProps,\n                     testfile: &Path, mm: &mut MetricMap) {\n \n     if config.llvm_bin_path.is_none() {\n-        fatal(\"missing --llvm-bin-path\".to_owned());\n+        fatal(\"missing --llvm-bin-path\".to_strbuf());\n     }\n \n     if config.clang_path.is_none() {\n-        fatal(\"missing --clang-path\".to_owned());\n+        fatal(\"missing --clang-path\".to_strbuf());\n     }\n \n     let mut proc_res = compile_test_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"extracting 'test' function failed\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"extracting 'test' function failed\".to_strbuf(),\n+                      &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"disassembling extract failed\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"disassembling extract failed\".to_strbuf(), &proc_res);\n     }\n \n \n     let mut proc_res = compile_cc_with_clang_and_save_bitcode(config, props, testfile);\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"compilation failed!\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"compilation failed!\".to_strbuf(), &proc_res);\n     }\n \n     proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"extracting 'test' function failed\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"extracting 'test' function failed\".to_strbuf(),\n+                      &proc_res);\n     }\n \n     proc_res = disassemble_extract(config, props, testfile, \"clang\");\n     if !proc_res.status.success() {\n-        fatal_ProcRes(\"disassembling extract failed\".to_owned(), &proc_res);\n+        fatal_ProcRes(\"disassembling extract failed\".to_strbuf(), &proc_res);\n     }\n \n     let base = output_base_name(config, testfile);"}, {"sha": "942541c79eee7661b8c927ef8e5c165c95a49e81", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -33,25 +33,25 @@ pub fn get_os(triple: &str) -> &'static str {\n }\n \n #[cfg(target_os = \"win32\")]\n-pub fn make_new_path(path: &str) -> ~str {\n+pub fn make_new_path(path: &str) -> StrBuf {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n-    match getenv(lib_path_env_var()) {\n+    match getenv(lib_path_env_var().as_slice()) {\n       Some(curr) => {\n-        format!(\"{}{}{}\", path, path_div(), curr)\n+        format_strbuf!(\"{}{}{}\", path, path_div(), curr)\n       }\n-      None => path.to_str()\n+      None => path.to_str().to_strbuf()\n     }\n }\n \n #[cfg(target_os = \"win32\")]\n-pub fn lib_path_env_var() -> ~str { \"PATH\".to_owned() }\n+pub fn lib_path_env_var() -> StrBuf { \"PATH\".to_strbuf() }\n \n #[cfg(target_os = \"win32\")]\n-pub fn path_div() -> ~str { \";\".to_owned() }\n+pub fn path_div() -> StrBuf { \";\".to_strbuf() }\n \n-pub fn logv(config: &Config, s: ~str) {\n+pub fn logv(config: &Config, s: StrBuf) {\n     debug!(\"{}\", s);\n     if config.verbose { println!(\"{}\", s); }\n }"}, {"sha": "4670a2922cf8c6100bb51f6a4cf6548bc658484c", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -8,7 +8,7 @@ Use [`ToStr`](http://static.rust-lang.org/doc/master/std/to_str/trait.ToStr.html\n \n ~~~\n let x: int = 42;\n-let y: ~str = x.to_str();\n+let y: StrBuf = x.to_str().to_strbuf();\n ~~~\n \n **String to int**\n@@ -22,14 +22,14 @@ let y: int = x.unwrap();\n \n **Int to string, in non-base-10**\n \n-Use the `format!` syntax extension.\n+Use the `format_strbuf!` syntax extension.\n \n ~~~\n let x: int = 42;\n-let y: ~str = format!(\"{:t}\", x);   // binary\n-let y: ~str = format!(\"{:o}\", x);   // octal\n-let y: ~str = format!(\"{:x}\", x);   // lowercase hexadecimal\n-let y: ~str = format!(\"{:X}\", x);   // uppercase hexadecimal\n+let y: StrBuf = format_strbuf!(\"{:t}\", x);   // binary\n+let y: StrBuf = format_strbuf!(\"{:o}\", x);   // octal\n+let y: StrBuf = format_strbuf!(\"{:x}\", x);   // lowercase hexadecimal\n+let y: StrBuf = format_strbuf!(\"{:X}\", x);   // uppercase hexadecimal\n ~~~\n \n **String to int, in non-base-10**\n@@ -55,13 +55,14 @@ let x: Option<&str> = str::from_utf8(bytes);\n let y: &str = x.unwrap();\n ~~~\n \n-To return an Owned String (~str) use the str helper function [`from_utf8_owned`](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8_owned.html).\n+To return an Owned String (StrBuf) use the str helper function [`from_utf8_owned`](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8_owned.html).\n \n ~~~\n use std::str;\n \n-let x: Result<~str,~[u8]> = str::from_utf8_owned(~[104u8,105u8]);\n-let y: ~str = x.unwrap();\n+let x: Result<StrBuf,~[u8]> =\n+    str::from_utf8_owned(~[104u8,105u8]).map(|x| x.to_strbuf());\n+let y: StrBuf = x.unwrap();\n ~~~\n \n To return a [`MaybeOwned`](http://static.rust-lang.org/doc/master/std/str/enum.MaybeOwned.html) use the str helper function [`from_utf8_lossy`](http://static.rust-lang.org/doc/master/std/str/fn.from_utf8_owned.html).  This function also replaces non-valid utf-8 sequences with U+FFFD replacement character.\n@@ -181,7 +182,7 @@ enum Closed {}\n Phantom types are useful for enforcing state at compile time. For example:\n \n ~~~\n-struct Door<State>(~str);\n+struct Door<State>(StrBuf);\n \n struct Open;\n struct Closed;\n@@ -194,13 +195,13 @@ fn open(Door(name): Door<Closed>) -> Door<Open> {\n     Door::<Open>(name)\n }\n \n-let _ = close(Door::<Open>(\"front\".to_owned()));\n+let _ = close(Door::<Open>(\"front\".to_strbuf()));\n ~~~\n \n Attempting to close a closed door is prevented statically:\n \n ~~~ {.ignore}\n-let _ = close(Door::<Closed>(\"front\".to_owned())); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n+let _ = close(Door::<Closed>(\"front\".to_strbuf())); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n ~~~\n \n # FFI (Foreign Function Interface)"}, {"sha": "66935300f18d9ccc2bd5ec1855075cc85d32accf", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -85,7 +85,7 @@ To take as an argument a fragment of Rust code, write `$` followed by a name\n   `foo`.)\n * `expr` (an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`;\n   `f(42)`.)\n-* `ty` (a type. Examples: `int`, `~[(char, ~str)]`, `&T`.)\n+* `ty` (a type. Examples: `int`, `~[(char, StrBuf)]`, `&T`.)\n * `pat` (a pattern, usually appearing in a `match` or on the left-hand side of\n   a declaration. Examples: `Some(t)`; `(17, 'a')`; `_`.)\n * `block` (a sequence of actions. Example: `{ log(error, \"hi\"); return 12; }`)"}, {"sha": "8df11c59f60ef8271a0f0b25add20389feb311b4", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -463,11 +463,11 @@ Here is the function that implements the child task:\n ~~~\n extern crate sync;\n # fn main() {\n-fn stringifier(channel: &sync::DuplexStream<~str, uint>) {\n+fn stringifier(channel: &sync::DuplexStream<StrBuf, uint>) {\n     let mut value: uint;\n     loop {\n         value = channel.recv();\n-        channel.send(value.to_str());\n+        channel.send(value.to_str().to_strbuf());\n         if value == 0 { break; }\n     }\n }\n@@ -488,11 +488,11 @@ Here is the code for the parent task:\n extern crate sync;\n # use std::task::spawn;\n # use sync::DuplexStream;\n-# fn stringifier(channel: &sync::DuplexStream<~str, uint>) {\n+# fn stringifier(channel: &sync::DuplexStream<StrBuf, uint>) {\n #     let mut value: uint;\n #     loop {\n #         value = channel.recv();\n-#         channel.send(value.to_str());\n+#         channel.send(value.to_str().to_strbuf());\n #         if value == 0u { break; }\n #     }\n # }\n@@ -505,13 +505,13 @@ spawn(proc() {\n });\n \n from_child.send(22);\n-assert!(from_child.recv() == \"22\".to_owned());\n+assert!(from_child.recv().as_slice() == \"22\");\n \n from_child.send(23);\n from_child.send(0);\n \n-assert!(from_child.recv() == \"23\".to_owned());\n-assert!(from_child.recv() == \"0\".to_owned());\n+assert!(from_child.recv().as_slice() == \"23\");\n+assert!(from_child.recv().as_slice() == \"0\");\n \n # }\n ~~~"}, {"sha": "4ce4d1697be0bd94f1dfe21285fe96ad890a7c2d", "filename": "src/doc/po/ja/complement-cheatsheet.md.po", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -34,7 +34,7 @@ msgstr \"\"\n #, fuzzy\n #| msgid \"\"\n #| \"~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~\"\n-msgid \"~~~ let x: int = 42; let y: ~str = x.to_str(); ~~~\"\n+msgid \"~~~ let x: int = 42; let y: StrBuf = x.to_str(); ~~~\"\n msgstr \"\"\n \"~~~~\\n\"\n \"let x: f64 = 4.0;\\n\"\n@@ -96,7 +96,7 @@ msgstr \"\"\n #, fuzzy\n #| msgid \"\"\n #| \"~~~~ let x: f64 = 4.0; let y: uint = x as uint; assert!(y == 4u); ~~~~\"\n-msgid \"let x: int = 42; let y: ~str = x.to_str_radix(16); ~~~\"\n+msgid \"let x: int = 42; let y: StrBuf = x.to_str_radix(16); ~~~\"\n msgstr \"\"\n \"~~~~\\n\"\n \"let x: f64 = 4.0;\\n\""}, {"sha": "b23f130f2663887d0f5402d8448c294c13a726dd", "filename": "src/doc/po/ja/rust.md.po", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fpo%2Fja%2Frust.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fpo%2Fja%2Frust.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Frust.md.po?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -1641,7 +1641,7 @@ msgstr \"## \u6700\u5c0f\u9650\u306e\u4f8b\"\n msgid \"\"\n \"~~~~\\n\"\n \"trait Printable {\\n\"\n-\"  fn to_string(&self) -> ~str;\\n\"\n+\"  fn to_string(&self) -> StrBuf;\\n\"\n \"}\\n\"\n msgstr \"\"\n \"~~~~ {.ignore}\\n\"\n@@ -1656,7 +1656,7 @@ msgstr \"\"\n #| msgid \"~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"impl Printable for int {\\n\"\n-\"  fn to_string(&self) -> ~str { self.to_str() }\\n\"\n+\"  fn to_string(&self) -> StrBuf { self.to_str() }\\n\"\n \"}\\n\"\n msgstr \"\"\n \"~~~~ {.ignore}\\n\"\n@@ -1702,7 +1702,7 @@ msgstr \"# \u30af\u30ed\u30fc\u30b8\u30e3\"\n msgid \"\"\n \"~~~~\\n\"\n \"trait Printable {\\n\"\n-\"  fn make_string(&self) -> ~str;\\n\"\n+\"  fn make_string(&self) -> StrBuf;\\n\"\n \"}\\n\"\n msgstr \"\"\n \"~~~~ {.ignore}\\n\"\n@@ -1716,8 +1716,8 @@ msgstr \"\"\n #, fuzzy, no-wrap\n #| msgid \"~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n-\"impl Printable for ~str {\\n\"\n-\"    fn make_string(&self) -> ~str {\\n\"\n+\"impl Printable for StrBuf {\\n\"\n+\"    fn make_string(&self) -> StrBuf {\\n\"\n \"        (*self).clone()\\n\"\n \"    }\\n\"\n \"}\\n\""}, {"sha": "96514e99b86b1682eeda44ca65db46cdf524907d", "filename": "src/doc/po/ja/tutorial.md.po", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -3755,15 +3755,15 @@ msgstr \"\"\n #| msgid \"\"\n #| \"Traits may be implemented for specific types with [impls]. An impl that \"\n #| \"implements a trait includes the name of the trait at the start of the \"\n-#| \"definition, as in the following impls of `Printable` for `int` and `~str`.\"\n+#| \"definition, as in the following impls of `Printable` for `int` and `StrBuf`.\"\n msgid \"\"\n \"Traits may be implemented for specific types with [impls]. An impl for a \"\n \"particular trait gives an implementation of the methods that trait \"\n \"provides.  For instance, the following impls of `Printable` for `int` and \"\n-\"`~str` give implementations of the `print` method.\"\n+\"`StrBuf` give implementations of the `print` method.\"\n msgstr \"\"\n \"[impl][impls] \u306b\u3088\u308a\u7279\u5b9a\u306e\u578b\u306b\u30c8\u30ec\u30a4\u30c8\u3092\u5b9f\u88c5\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u30c8\u30ec\u30a4\u30c8\u3092\u5b9f\"\n-\"\u88c5\u3059\u308b impl \u306f\u3001\u4ee5\u4e0b\u306e `Printable` \u306e `int` \u3068 `~str` \u306b\u5bfe\u3059\u308b\u5b9f\u88c5\u306e\u3088\u3046\u306b\u3001\"\n+\"\u88c5\u3059\u308b impl \u306f\u3001\u4ee5\u4e0b\u306e `Printable` \u306e `int` \u3068 `StrBuf` \u306b\u5bfe\u3059\u308b\u5b9f\u88c5\u306e\u3088\u3046\u306b\u3001\"\n \"\u5b9a\u7fa9\u306e\u5148\u982d\u306b\u30c8\u30ec\u30a4\u30c8\u306e\u540d\u524d\u3092\u542b\u307f\u307e\u3059\u3002\"\n \n #. type: Plain text\n@@ -3776,7 +3776,7 @@ msgstr \"[impls]: #\u30e1\u30bd\u30c3\u30c9\"\n #, fuzzy, no-wrap\n #| msgid \"~~~~ {.ignore} // main.rs extern crate world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n-\"impl Printable for ~str {\\n\"\n+\"impl Printable for StrBuf {\\n\"\n \"    fn print(&self) { println!(\\\"{}\\\", *self) }\\n\"\n \"}\\n\"\n msgstr \"\""}, {"sha": "4986ad1ba99f55809a4d11b13bed018fd2ca909d", "filename": "src/doc/rust.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -473,7 +473,7 @@ Two examples of paths with type arguments:\n # struct HashMap<K, V>;\n # fn f() {\n # fn id<T>(t: T) -> T { t }\n-type T = HashMap<int,~str>;  // Type arguments used in a type expression\n+type T = HashMap<int,StrBuf>;  // Type arguments used in a type expression\n let x = id::<int>(10);       // Type arguments used in a call expression\n # }\n ~~~~\n@@ -1259,12 +1259,12 @@ Enumeration constructors can have either named or unnamed fields:\n \n ~~~~\n enum Animal {\n-    Dog (~str, f64),\n-    Cat { name: ~str, weight: f64 }\n+    Dog (StrBuf, f64),\n+    Cat { name: StrBuf, weight: f64 }\n }\n \n-let mut a: Animal = Dog(\"Cocoa\".to_owned(), 37.2);\n-a = Cat{ name: \"Spotty\".to_owned(), weight: 2.7 };\n+let mut a: Animal = Dog(\"Cocoa\".to_strbuf(), 37.2);\n+a = Cat { name: \"Spotty\".to_strbuf(), weight: 2.7 };\n ~~~~\n \n In this example, `Cat` is a _struct-like enum variant_,\n@@ -2081,7 +2081,7 @@ These are functions:\n * `str_eq`\n   : Compare two strings (`&str`) for equality.\n * `uniq_str_eq`\n-  : Compare two owned strings (`~str`) for equality.\n+  : Compare two owned strings (`StrBuf`) for equality.\n * `strdup_uniq`\n   : Return a new unique string\n     containing a copy of the contents of a unique string.\n@@ -3309,7 +3309,7 @@ A value of type `str` is a Unicode string,\n represented as a vector of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.\n Since `str` is of unknown size, it is not a _first class_ type,\n but can only be instantiated through a pointer type,\n-such as `&str` or `~str`.\n+such as `&str` or `StrBuf`.\n \n ### Tuple types\n \n@@ -3573,11 +3573,11 @@ An example of an object type:\n \n ~~~~\n trait Printable {\n-  fn to_string(&self) -> ~str;\n+  fn to_string(&self) -> StrBuf;\n }\n \n impl Printable for int {\n-  fn to_string(&self) -> ~str { self.to_str() }\n+  fn to_string(&self) -> StrBuf { self.to_str().to_strbuf() }\n }\n \n fn print(a: Box<Printable>) {\n@@ -3618,17 +3618,17 @@ example, in:\n \n ~~~~\n trait Printable {\n-  fn make_string(&self) -> ~str;\n+  fn make_string(&self) -> StrBuf;\n }\n \n-impl Printable for ~str {\n-    fn make_string(&self) -> ~str {\n+impl Printable for StrBuf {\n+    fn make_string(&self) -> StrBuf {\n         (*self).clone()\n     }\n }\n ~~~~\n \n-`self` refers to the value of type `~str` that is the receiver for a\n+`self` refers to the value of type `StrBuf` that is the receiver for a\n call to the method `make_string`.\n \n ## Type kinds"}, {"sha": "3b7f4e1bf5013940cbd34d081116dc8263abd2b8", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -26,7 +26,7 @@ comments\":\n pub struct Widget {\n \t/// All widgets have a purpose (this is a doc comment, and will show up\n \t/// the field's documentation).\n-\tpurpose: ~str,\n+\tpurpose: StrBuf,\n \t/// Humans are not allowed to understand some widgets\n \tunderstandable: bool\n }"}, {"sha": "ad77b90e79b7023110ca784fc020158c4dc7b47b", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -2213,7 +2213,7 @@ don't provide any methods.\n Traits may be implemented for specific types with [impls]. An impl for\n a particular trait gives an implementation of the methods that\n trait provides.  For instance, the following impls of\n-`Printable` for `int` and `~str` give implementations of the `print`\n+`Printable` for `int` and `StrBuf` give implementations of the `print`\n method.\n \n [impls]: #methods\n@@ -2224,12 +2224,12 @@ impl Printable for int {\n     fn print(&self) { println!(\"{:?}\", *self) }\n }\n \n-impl Printable for ~str {\n+impl Printable for StrBuf {\n     fn print(&self) { println!(\"{}\", *self) }\n }\n \n # 1.print();\n-# (\"foo\".to_owned()).print();\n+# (\"foo\".to_strbuf()).print();\n ~~~~\n \n Methods defined in an impl for a trait may be called just like\n@@ -2270,7 +2270,7 @@ trait Printable {\n \n impl Printable for int {}\n \n-impl Printable for ~str {\n+impl Printable for StrBuf {\n     fn print(&self) { println!(\"{}\", *self) }\n }\n \n@@ -2279,7 +2279,7 @@ impl Printable for bool {}\n impl Printable for f32 {}\n \n # 1.print();\n-# (\"foo\".to_owned()).print();\n+# (\"foo\".to_strbuf()).print();\n # true.print();\n # 3.14159.print();\n ~~~~\n@@ -2291,7 +2291,7 @@ provided in the trait definition.  Depending on the trait, default\n methods can save a great deal of boilerplate code from having to be\n written in impls.  Of course, individual impls can still override the\n default method for `print`, as is being done above in the impl for\n-`~str`.\n+`StrBuf`.\n \n ## Type-parameterized traits\n "}, {"sha": "e12026340d8285b06e4fde2bfa32c2f313755f76", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -203,7 +203,7 @@ pub struct Parser<'a> {\n     cur: str::CharOffsets<'a>,\n     depth: uint,\n     /// Error messages accumulated during parsing\n-    pub errors: Vec<~str>,\n+    pub errors: Vec<StrBuf>,\n }\n \n impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n@@ -246,10 +246,10 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Notifies of an error. The message doesn't actually need to be of type\n-    /// ~str, but I think it does when this eventually uses conditions so it\n+    /// StrBuf, but I think it does when this eventually uses conditions so it\n     /// might as well start using it now.\n     fn err(&mut self, msg: &str) {\n-        self.errors.push(msg.to_owned());\n+        self.errors.push(msg.to_strbuf());\n     }\n \n     /// Optionally consumes the specified character. If the character is not at"}, {"sha": "ba30e1a2e986bb12e8874627bb44a728acf316f0", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 227, "deletions": 204, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -34,7 +34,7 @@\n //! use getopts::{optopt,optflag,getopts,OptGroup};\n //! use std::os;\n //!\n-//! fn do_work(inp: &str, out: Option<~str>) {\n+//! fn do_work(inp: &str, out: Option<StrBuf>) {\n //!     println!(\"{}\", inp);\n //!     match out {\n //!         Some(x) => println!(\"{}\", x),\n@@ -49,7 +49,9 @@\n //! }\n //!\n //! fn main() {\n-//!     let args = os::args();\n+//!     let args: Vec<StrBuf> = os::args().iter()\n+//!                                       .map(|x| x.to_strbuf())\n+//!                                       .collect();\n //!\n //!     let program = args.get(0).clone();\n //!\n@@ -62,17 +64,17 @@\n //!         Err(f) => { fail!(f.to_err_msg()) }\n //!     };\n //!     if matches.opt_present(\"h\") {\n-//!         print_usage(program, opts);\n+//!         print_usage(program.as_slice(), opts);\n //!         return;\n //!     }\n //!     let output = matches.opt_str(\"o\");\n-//!     let input: &str = if !matches.free.is_empty() {\n+//!     let input = if !matches.free.is_empty() {\n //!         (*matches.free.get(0)).clone()\n //!     } else {\n-//!         print_usage(program, opts);\n+//!         print_usage(program.as_slice(), opts);\n //!         return;\n //!     };\n-//!     do_work(input, output);\n+//!     do_work(input.as_slice(), output);\n //! }\n //! ~~~\n \n@@ -99,7 +101,7 @@ use std::strbuf::StrBuf;\n pub enum Name {\n     /// A string representing the long name of an option.\n     /// For example: \"help\"\n-    Long(~str),\n+    Long(StrBuf),\n     /// A char representing the short name of an option.\n     /// For example: 'h'\n     Short(char),\n@@ -145,13 +147,13 @@ pub struct Opt {\n #[deriving(Clone, Eq)]\n pub struct OptGroup {\n     /// Short Name of the `OptGroup`\n-    pub short_name: ~str,\n+    pub short_name: StrBuf,\n     /// Long Name of the `OptGroup`\n-    pub long_name: ~str,\n+    pub long_name: StrBuf,\n     /// Hint\n-    pub hint: ~str,\n+    pub hint: StrBuf,\n     /// Description\n-    pub desc: ~str,\n+    pub desc: StrBuf,\n     /// Whether it has an argument\n     pub hasarg: HasArg,\n     /// How often it can occur\n@@ -161,7 +163,7 @@ pub struct OptGroup {\n /// Describes wether an option is given at all or has a value.\n #[deriving(Clone, Eq)]\n enum Optval {\n-    Val(~str),\n+    Val(StrBuf),\n     Given,\n }\n \n@@ -174,7 +176,7 @@ pub struct Matches {\n     /// Values of the Options that matched\n     vals: Vec<Vec<Optval> > ,\n     /// Free string fragments\n-    pub free: Vec<~str>,\n+    pub free: Vec<StrBuf>,\n }\n \n /// The type returned when the command line does not conform to the\n@@ -183,15 +185,15 @@ pub struct Matches {\n #[deriving(Clone, Eq, Show)]\n pub enum Fail_ {\n     /// The option requires an argument but none was passed.\n-    ArgumentMissing(~str),\n+    ArgumentMissing(StrBuf),\n     /// The passed option is not declared among the possible options.\n-    UnrecognizedOption(~str),\n+    UnrecognizedOption(StrBuf),\n     /// A required option is not present.\n-    OptionMissing(~str),\n+    OptionMissing(StrBuf),\n     /// A single occurence option is being used multiple times.\n-    OptionDuplicated(~str),\n+    OptionDuplicated(StrBuf),\n     /// There's an argument being passed to a non-argument option.\n-    UnexpectedArgument(~str),\n+    UnexpectedArgument(StrBuf),\n }\n \n /// The type of failure that occurred.\n@@ -213,14 +215,14 @@ impl Name {\n         if nm.len() == 1u {\n             Short(nm.char_at(0u))\n         } else {\n-            Long(nm.to_owned())\n+            Long(nm.to_strbuf())\n         }\n     }\n \n-    fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> StrBuf {\n         match *self {\n-            Short(ch) => ch.to_str(),\n-            Long(ref s) => s.to_owned()\n+            Short(ch) => ch.to_str().to_strbuf(),\n+            Long(ref s) => s.to_strbuf()\n         }\n     }\n }\n@@ -246,7 +248,7 @@ impl OptGroup {\n                 aliases: Vec::new()\n             },\n             (1,0) => Opt {\n-                name: Short(short_name.char_at(0)),\n+                name: Short(short_name.as_slice().char_at(0)),\n                 hasarg: hasarg,\n                 occur: occur,\n                 aliases: Vec::new()\n@@ -257,7 +259,7 @@ impl OptGroup {\n                 occur:  occur,\n                 aliases: vec!(\n                     Opt {\n-                        name: Short(short_name.char_at(0)),\n+                        name: Short(short_name.as_slice().char_at(0)),\n                         hasarg: hasarg,\n                         occur:  occur,\n                         aliases: Vec::new()\n@@ -297,9 +299,10 @@ impl Matches {\n     }\n \n     /// Returns true if any of several options were matched.\n-    pub fn opts_present(&self, names: &[~str]) -> bool {\n+    pub fn opts_present(&self, names: &[StrBuf]) -> bool {\n         for nm in names.iter() {\n-            match find_opt(self.opts.as_slice(), Name::from_str(*nm)) {\n+            match find_opt(self.opts.as_slice(),\n+                           Name::from_str(nm.as_slice())) {\n                 Some(id) if !self.vals.get(id).is_empty() => return true,\n                 _ => (),\n             };\n@@ -308,9 +311,9 @@ impl Matches {\n     }\n \n     /// Returns the string argument supplied to one of several matching options or `None`.\n-    pub fn opts_str(&self, names: &[~str]) -> Option<~str> {\n+    pub fn opts_str(&self, names: &[StrBuf]) -> Option<StrBuf> {\n         for nm in names.iter() {\n-            match self.opt_val(*nm) {\n+            match self.opt_val(nm.as_slice()) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -322,8 +325,8 @@ impl Matches {\n     /// option.\n     ///\n     /// Used when an option accepts multiple values.\n-    pub fn opt_strs(&self, nm: &str) -> Vec<~str> {\n-        let mut acc: Vec<~str> = Vec::new();\n+    pub fn opt_strs(&self, nm: &str) -> Vec<StrBuf> {\n+        let mut acc: Vec<StrBuf> = Vec::new();\n         let r = self.opt_vals(nm);\n         for v in r.iter() {\n             match *v {\n@@ -335,10 +338,10 @@ impl Matches {\n     }\n \n     /// Returns the string argument supplied to a matching option or `None`.\n-    pub fn opt_str(&self, nm: &str) -> Option<~str> {\n+    pub fn opt_str(&self, nm: &str) -> Option<StrBuf> {\n         let vals = self.opt_vals(nm);\n         if vals.is_empty() {\n-            return None::<~str>;\n+            return None::<StrBuf>;\n         }\n         match vals.get(0) {\n             &Val(ref s) => Some((*s).clone()),\n@@ -352,12 +355,14 @@ impl Matches {\n     /// Returns none if the option was not present, `def` if the option was\n     /// present but no argument was provided, and the argument if the option was\n     /// present and an argument was provided.\n-    pub fn opt_default(&self, nm: &str, def: &str) -> Option<~str> {\n+    pub fn opt_default(&self, nm: &str, def: &str) -> Option<StrBuf> {\n         let vals = self.opt_vals(nm);\n-        if vals.is_empty() { return None; }\n+        if vals.is_empty() {\n+            return None;\n+        }\n         match vals.get(0) {\n             &Val(ref s) => Some((*s).clone()),\n-            _ => Some(def.to_owned())\n+            _ => Some(def.to_strbuf())\n         }\n     }\n \n@@ -389,10 +394,10 @@ pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: Yes,\n         occur: Req\n     }\n@@ -403,10 +408,10 @@ pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptG\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: Yes,\n         occur: Optional\n     }\n@@ -417,10 +422,10 @@ pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: \"\".to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: No,\n         occur: Optional\n     }\n@@ -432,10 +437,10 @@ pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: \"\".to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: No,\n         occur: Multi\n     }\n@@ -446,10 +451,10 @@ pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) ->\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: Maybe,\n         occur: Optional\n     }\n@@ -461,10 +466,10 @@ pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> Op\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: Yes,\n         occur: Multi\n     }\n@@ -480,33 +485,33 @@ pub fn opt(short_name: &str,\n     let len = short_name.len();\n     assert!(len == 1 || len == 0);\n     OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n+        short_name: short_name.to_strbuf(),\n+        long_name: long_name.to_strbuf(),\n+        hint: hint.to_strbuf(),\n+        desc: desc.to_strbuf(),\n         hasarg: hasarg,\n         occur: occur\n     }\n }\n \n impl Fail_ {\n     /// Convert a `Fail_` enum into an error string.\n-    pub fn to_err_msg(self) -> ~str {\n+    pub fn to_err_msg(self) -> StrBuf {\n         match self {\n             ArgumentMissing(ref nm) => {\n-                format!(\"Argument to option '{}' missing.\", *nm)\n+                format_strbuf!(\"Argument to option '{}' missing.\", *nm)\n             }\n             UnrecognizedOption(ref nm) => {\n-                format!(\"Unrecognized option: '{}'.\", *nm)\n+                format_strbuf!(\"Unrecognized option: '{}'.\", *nm)\n             }\n             OptionMissing(ref nm) => {\n-                format!(\"Required option '{}' missing.\", *nm)\n+                format_strbuf!(\"Required option '{}' missing.\", *nm)\n             }\n             OptionDuplicated(ref nm) => {\n-                format!(\"Option '{}' given more than once.\", *nm)\n+                format_strbuf!(\"Option '{}' given more than once.\", *nm)\n             }\n             UnexpectedArgument(ref nm) => {\n-                format!(\"Option '{}' does not take an argument.\", *nm)\n+                format_strbuf!(\"Option '{}' does not take an argument.\", *nm)\n             }\n         }\n     }\n@@ -517,44 +522,44 @@ impl Fail_ {\n /// On success returns `Ok(Opt)`. Use methods such as `opt_present`\n /// `opt_str`, etc. to interrogate results.  Returns `Err(Fail_)` on failure.\n /// Use `to_err_msg` to get an error message.\n-pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n+pub fn getopts(args: &[StrBuf], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n     let n_opts = opts.len();\n \n     fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n \n     let mut vals = Vec::from_fn(n_opts, f);\n-    let mut free: Vec<~str> = Vec::new();\n+    let mut free: Vec<StrBuf> = Vec::new();\n     let l = args.len();\n     let mut i = 0;\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(cur) {\n+        if !is_arg(cur.as_slice()) {\n             free.push(cur);\n-        } else if cur == \"--\".to_owned() {\n+        } else if cur.as_slice() == \"--\" {\n             let mut j = i + 1;\n             while j < l { free.push(args[j].clone()); j += 1; }\n             break;\n         } else {\n             let mut names;\n             let mut i_arg = None;\n-            if cur[1] == '-' as u8 {\n-                let tail = cur.slice(2, curlen);\n+            if cur.as_slice()[1] == '-' as u8 {\n+                let tail = cur.as_slice().slice(2, curlen);\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n-                    names = vec!(Long(tail.to_owned()));\n+                    names = vec!(Long(tail.to_strbuf()));\n                 } else {\n                     names =\n-                        vec!(Long((*tail_eq.get(0)).to_owned()));\n-                    i_arg = Some((*tail_eq.get(1)).to_owned());\n+                        vec!(Long((*tail_eq.get(0)).to_strbuf()));\n+                    i_arg = Some((*tail_eq.get(1)).to_strbuf());\n                 }\n             } else {\n                 let mut j = 1;\n                 let mut last_valid_opt_id = None;\n                 names = Vec::new();\n                 while j < curlen {\n-                    let range = cur.char_range_at(j);\n+                    let range = cur.as_slice().char_range_at(j);\n                     let opt = Short(range.ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we\n@@ -576,7 +581,8 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n                               No => false\n                             };\n                         if arg_follows && j < curlen {\n-                            i_arg = Some(cur.slice(j, curlen).to_owned());\n+                            i_arg = Some(cur.as_slice()\n+                                            .slice(j, curlen).to_strbuf());\n                             break;\n                         } else {\n                             last_valid_opt_id = None;\n@@ -606,8 +612,8 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n                         vals.get_mut(optid)\n                             .push(Val((i_arg.clone())\n                             .unwrap()));\n-                    } else if name_pos < names.len() ||\n-                                  i + 1 == l || is_arg(args[i + 1]) {\n+                    } else if name_pos < names.len() || i + 1 == l ||\n+                            is_arg(args[i + 1].as_slice()) {\n                         vals.get_mut(optid).push(Given);\n                     } else {\n                         i += 1;\n@@ -653,7 +659,7 @@ pub fn getopts(args: &[~str], optgrps: &[OptGroup]) -> Result {\n }\n \n /// Derive a usage message from a set of long options.\n-pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n+pub fn usage(brief: &str, opts: &[OptGroup]) -> StrBuf {\n \n     let desc_sep = \"\\n\" + \" \".repeat(24);\n \n@@ -672,7 +678,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n             0 => {}\n             1 => {\n                 row.push_char('-');\n-                row.push_str(short_name);\n+                row.push_str(short_name.as_slice());\n                 row.push_char(' ');\n             }\n             _ => fail!(\"the short name should only be 1 ascii char long\"),\n@@ -683,18 +689,18 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(long_name);\n+                row.push_str(long_name.as_slice());\n                 row.push_char(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(hint),\n+            Yes => row.push_str(hint.as_slice()),\n             Maybe => {\n                 row.push_char('[');\n-                row.push_str(hint);\n+                row.push_str(hint.as_slice());\n                 row.push_char(']');\n             }\n         }\n@@ -712,7 +718,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n         // Normalize desc to contain words separated by one space character\n         let mut desc_normalized_whitespace = StrBuf::new();\n-        for word in desc.words() {\n+        for word in desc.as_slice().words() {\n             desc_normalized_whitespace.push_str(word);\n             desc_normalized_whitespace.push_char(' ');\n         }\n@@ -730,13 +736,15 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n         // wrapped description\n         row.push_str(desc_rows.connect(desc_sep));\n \n-        row.into_owned()\n+        row\n     });\n \n-    format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<Vec<~str> >().connect(\"\\n\"))\n+    format_strbuf!(\"{}\\n\\nOptions:\\n{}\\n\",\n+                   brief,\n+                   rows.collect::<Vec<StrBuf>>().connect(\"\\n\"))\n }\n \n-fn format_option(opt: &OptGroup) -> ~str {\n+fn format_option(opt: &OptGroup) -> StrBuf {\n     let mut line = StrBuf::new();\n \n     if opt.occur != Req {\n@@ -746,18 +754,18 @@ fn format_option(opt: &OptGroup) -> ~str {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push_char('-');\n-        line.push_str(opt.short_name);\n+        line.push_str(opt.short_name.as_slice());\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(opt.long_name);\n+        line.push_str(opt.long_name.as_slice());\n     }\n \n     if opt.hasarg != No {\n         line.push_char(' ');\n         if opt.hasarg == Maybe {\n             line.push_char('[');\n         }\n-        line.push_str(opt.hint);\n+        line.push_str(opt.hint.as_slice());\n         if opt.hasarg == Maybe {\n             line.push_char(']');\n         }\n@@ -770,14 +778,14 @@ fn format_option(opt: &OptGroup) -> ~str {\n         line.push_str(\"..\");\n     }\n \n-    line.into_owned()\n+    line\n }\n \n /// Derive a short one-line usage summary from a set of long options.\n-pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> ~str {\n-    let mut line = StrBuf::from_str(\"Usage: \" + program_name + \" \");\n-    line.push_str(opts.iter().map(format_option).collect::<Vec<~str>>().connect(\" \"));\n-    line.into_owned()\n+pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> StrBuf {\n+    let mut line = format_strbuf!(\"Usage: {} \", program_name);\n+    line.push_str(opts.iter().map(format_option).collect::<Vec<StrBuf>>().connect(\" \"));\n+    line\n }\n \n \n@@ -886,18 +894,21 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n \n #[test]\n fn test_split_within() {\n-    fn t(s: &str, i: uint, u: &[~str]) {\n+    fn t(s: &str, i: uint, u: &[StrBuf]) {\n         let mut v = Vec::new();\n-        each_split_within(s, i, |s| { v.push(s.to_owned()); true });\n+        each_split_within(s, i, |s| { v.push(s.to_strbuf()); true });\n         assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n     }\n     t(\"\", 0, []);\n     t(\"\", 15, []);\n-    t(\"hello\", 15, [\"hello\".to_owned()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n-        [\"Mary had a\".to_owned(), \"little lamb\".to_owned(), \"Little lamb\".to_owned()]);\n+    t(\"hello\", 15, [\"hello\".to_strbuf()]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15, [\n+        \"Mary had a\".to_strbuf(),\n+        \"little lamb\".to_strbuf(),\n+        \"Little lamb\".to_strbuf()\n+    ]);\n     t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n-        [\"Mary had a little lamb\\nLittle lamb\".to_owned()]);\n+        [\"Mary had a little lamb\\nLittle lamb\".to_strbuf()]);\n }\n \n #[cfg(test)]\n@@ -920,33 +931,33 @@ mod tests {\n     // Tests for reqopt\n     #[test]\n     fn test_reqopt() {\n-        let long_args = vec!(\"--test=20\".to_owned());\n+        let long_args = vec!(\"--test=20\".to_strbuf());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!(m.opt_present(\"t\"));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => { fail!(\"test_reqopt failed (long arg)\"); }\n         }\n-        let short_args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => { fail!(\"test_reqopt failed (short arg)\"); }\n         }\n     }\n \n     #[test]\n     fn test_reqopt_missing() {\n-        let args = vec!(\"blah\".to_owned());\n+        let args = vec!(\"blah\".to_strbuf());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -957,14 +968,14 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_owned());\n+        let long_args = vec!(\"--test\".to_strbuf());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -973,7 +984,7 @@ mod tests {\n \n     #[test]\n     fn test_reqopt_multi() {\n-        let args = vec!(\"--test=20\".to_owned(), \"-t\".to_owned(), \"30\".to_owned());\n+        let args = vec!(\"--test=20\".to_strbuf(), \"-t\".to_strbuf(), \"30\".to_strbuf());\n         let opts = vec!(reqopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -985,33 +996,33 @@ mod tests {\n     // Tests for optopt\n     #[test]\n     fn test_optopt() {\n-        let long_args = vec!(\"--test=20\".to_owned());\n+        let long_args = vec!(\"--test=20\".to_strbuf());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optopt_missing() {\n-        let args = vec!(\"blah\".to_owned());\n+        let args = vec!(\"blah\".to_strbuf());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1025,14 +1036,14 @@ mod tests {\n \n     #[test]\n     fn test_optopt_no_arg() {\n-        let long_args = vec!(\"--test\".to_owned());\n+        let long_args = vec!(\"--test\".to_strbuf());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -1041,7 +1052,7 @@ mod tests {\n \n     #[test]\n     fn test_optopt_multi() {\n-        let args = vec!(\"--test=20\".to_owned(), \"-t\".to_owned(), \"30\".to_owned());\n+        let args = vec!(\"--test=20\".to_strbuf(), \"-t\".to_strbuf(), \"30\".to_strbuf());\n         let opts = vec!(optopt(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1053,7 +1064,7 @@ mod tests {\n     // Tests for optflag\n     #[test]\n     fn test_optflag() {\n-        let long_args = vec!(\"--test\".to_owned());\n+        let long_args = vec!(\"--test\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1063,7 +1074,7 @@ mod tests {\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!(m.opt_present(\"test\"));\n@@ -1075,7 +1086,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_missing() {\n-        let args = vec!(\"blah\".to_owned());\n+        let args = vec!(\"blah\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1089,7 +1100,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_long_arg() {\n-        let args = vec!(\"--test=20\".to_owned());\n+        let args = vec!(\"--test=20\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1103,7 +1114,7 @@ mod tests {\n \n     #[test]\n     fn test_optflag_multi() {\n-        let args = vec!(\"--test\".to_owned(), \"-t\".to_owned());\n+        let args = vec!(\"--test\".to_strbuf(), \"-t\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1114,14 +1125,14 @@ mod tests {\n \n     #[test]\n     fn test_optflag_short_arg() {\n-        let args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n+        let args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n         let opts = vec!(optflag(\"t\", \"test\", \"testing\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             // The next variable after the flag is just a free argument\n \n-            assert!(*m.free.get(0) == \"20\".to_owned());\n+            assert!(*m.free.get(0) == \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n@@ -1130,7 +1141,7 @@ mod tests {\n     // Tests for optflagmulti\n     #[test]\n     fn test_optflagmulti_short1() {\n-        let args = vec!(\"-v\".to_owned());\n+        let args = vec!(\"-v\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1143,7 +1154,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2a() {\n-        let args = vec!(\"-v\".to_owned(), \"-v\".to_owned());\n+        let args = vec!(\"-v\".to_strbuf(), \"-v\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1156,7 +1167,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_short2b() {\n-        let args = vec!(\"-vv\".to_owned());\n+        let args = vec!(\"-vv\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1169,7 +1180,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long1() {\n-        let args = vec!(\"--verbose\".to_owned());\n+        let args = vec!(\"--verbose\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1182,7 +1193,7 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_long2() {\n-        let args = vec!(\"--verbose\".to_owned(), \"--verbose\".to_owned());\n+        let args = vec!(\"--verbose\".to_strbuf(), \"--verbose\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1195,8 +1206,8 @@ mod tests {\n \n     #[test]\n     fn test_optflagmulti_mix() {\n-        let args = vec!(\"--verbose\".to_owned(), \"-v\".to_owned(),\n-                        \"-vv\".to_owned(), \"verbose\".to_owned());\n+        let args = vec!(\"--verbose\".to_strbuf(), \"-v\".to_strbuf(),\n+                        \"-vv\".to_strbuf(), \"verbose\".to_strbuf());\n         let opts = vec!(optflagmulti(\"v\", \"verbose\", \"verbosity\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1211,33 +1222,33 @@ mod tests {\n     // Tests for optmulti\n     #[test]\n     fn test_optmulti() {\n-        let long_args = vec!(\"--test=20\".to_owned());\n+        let long_args = vec!(\"--test=20\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned(), \"20\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf(), \"20\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Ok(ref m) => {\n             assert!((m.opt_present(\"test\")));\n-            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n             assert!((m.opt_present(\"t\")));\n-            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+            assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optmulti_missing() {\n-        let args = vec!(\"blah\".to_owned());\n+        let args = vec!(\"blah\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n@@ -1251,14 +1262,14 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_no_arg() {\n-        let long_args = vec!(\"--test\".to_owned());\n+        let long_args = vec!(\"--test\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-t\".to_owned());\n+        let short_args = vec!(\"-t\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail!()\n@@ -1267,33 +1278,33 @@ mod tests {\n \n     #[test]\n     fn test_optmulti_multi() {\n-        let args = vec!(\"--test=20\".to_owned(), \"-t\".to_owned(), \"30\".to_owned());\n+        let args = vec!(\"--test=20\".to_strbuf(), \"-t\".to_strbuf(), \"30\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n               assert!(m.opt_present(\"test\"));\n-              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_owned());\n+              assert_eq!(m.opt_str(\"test\").unwrap(), \"20\".to_strbuf());\n               assert!(m.opt_present(\"t\"));\n-              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_owned());\n+              assert_eq!(m.opt_str(\"t\").unwrap(), \"20\".to_strbuf());\n               let pair = m.opt_strs(\"test\");\n-              assert!(*pair.get(0) == \"20\".to_owned());\n-              assert!(*pair.get(1) == \"30\".to_owned());\n+              assert!(*pair.get(0) == \"20\".to_strbuf());\n+              assert!(*pair.get(1) == \"30\".to_strbuf());\n           }\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_unrecognized_option() {\n-        let long_args = vec!(\"--untest\".to_owned());\n+        let long_args = vec!(\"--untest\".to_strbuf());\n         let opts = vec!(optmulti(\"t\", \"test\", \"testing\", \"TEST\"));\n         let rs = getopts(long_args.as_slice(), opts.as_slice());\n         match rs {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n         }\n-        let short_args = vec!(\"-u\".to_owned());\n+        let short_args = vec!(\"-u\".to_strbuf());\n         match getopts(short_args.as_slice(), opts.as_slice()) {\n           Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail!()\n@@ -1303,10 +1314,22 @@ mod tests {\n     #[test]\n     fn test_combined() {\n         let args =\n-            vec!(\"prog\".to_owned(), \"free1\".to_owned(), \"-s\".to_owned(), \"20\".to_owned(),\n-            \"free2\".to_owned(), \"--flag\".to_owned(), \"--long=30\".to_owned(), \"-f\".to_owned(),\n-            \"-m\".to_owned(), \"40\".to_owned(), \"-m\".to_owned(), \"50\".to_owned(), \"-n\".to_owned(),\n-            \"-A B\".to_owned(), \"-n\".to_owned(), \"-60 70\".to_owned());\n+            vec!(\"prog\".to_strbuf(),\n+                 \"free1\".to_strbuf(),\n+                 \"-s\".to_strbuf(),\n+                 \"20\".to_strbuf(),\n+                 \"free2\".to_strbuf(),\n+                 \"--flag\".to_strbuf(),\n+                 \"--long=30\".to_strbuf(),\n+                 \"-f\".to_strbuf(),\n+                 \"-m\".to_strbuf(),\n+                 \"40\".to_strbuf(),\n+                 \"-m\".to_strbuf(),\n+                 \"50\".to_strbuf(),\n+                 \"-n\".to_strbuf(),\n+                 \"-A B\".to_strbuf(),\n+                 \"-n\".to_strbuf(),\n+                 \"-60 70\".to_strbuf());\n         let opts =\n             vec!(optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n               optflag(\"\", \"flag\", \"a flag\"),\n@@ -1318,19 +1341,19 @@ mod tests {\n         let rs = getopts(args.as_slice(), opts.as_slice());\n         match rs {\n           Ok(ref m) => {\n-            assert!(*m.free.get(0) == \"prog\".to_owned());\n-            assert!(*m.free.get(1) == \"free1\".to_owned());\n-            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\".to_owned());\n-            assert!(*m.free.get(2) == \"free2\".to_owned());\n+            assert!(*m.free.get(0) == \"prog\".to_strbuf());\n+            assert!(*m.free.get(1) == \"free1\".to_strbuf());\n+            assert_eq!(m.opt_str(\"s\").unwrap(), \"20\".to_strbuf());\n+            assert!(*m.free.get(2) == \"free2\".to_strbuf());\n             assert!((m.opt_present(\"flag\")));\n-            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\".to_owned());\n+            assert_eq!(m.opt_str(\"long\").unwrap(), \"30\".to_strbuf());\n             assert!((m.opt_present(\"f\")));\n             let pair = m.opt_strs(\"m\");\n-            assert!(*pair.get(0) == \"40\".to_owned());\n-            assert!(*pair.get(1) == \"50\".to_owned());\n+            assert!(*pair.get(0) == \"40\".to_strbuf());\n+            assert!(*pair.get(1) == \"50\".to_strbuf());\n             let pair = m.opt_strs(\"n\");\n-            assert!(*pair.get(0) == \"-A B\".to_owned());\n-            assert!(*pair.get(1) == \"-60 70\".to_owned());\n+            assert!(*pair.get(0) == \"-A B\".to_strbuf());\n+            assert!(*pair.get(1) == \"-60 70\".to_strbuf());\n             assert!((!m.opt_present(\"notpresent\")));\n           }\n           _ => fail!()\n@@ -1343,68 +1366,68 @@ mod tests {\n                      optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n                      optopt(\"f\", \"\", \"flag\", \"FLAG\"));\n \n-        let args_single = vec!(\"-e\".to_owned(), \"foo\".to_owned());\n+        let args_single = vec!(\"-e\".to_strbuf(), \"foo\".to_strbuf());\n         let matches_single = &match getopts(args_single.as_slice(),\n                                             opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches_single.opts_present([\"e\".to_owned()]));\n-        assert!(matches_single.opts_present([\"encrypt\".to_owned(), \"e\".to_owned()]));\n-        assert!(matches_single.opts_present([\"e\".to_owned(), \"encrypt\".to_owned()]));\n-        assert!(!matches_single.opts_present([\"encrypt\".to_owned()]));\n-        assert!(!matches_single.opts_present([\"thing\".to_owned()]));\n+        assert!(matches_single.opts_present([\"e\".to_strbuf()]));\n+        assert!(matches_single.opts_present([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]));\n+        assert!(matches_single.opts_present([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]));\n+        assert!(!matches_single.opts_present([\"encrypt\".to_strbuf()]));\n+        assert!(!matches_single.opts_present([\"thing\".to_strbuf()]));\n         assert!(!matches_single.opts_present([]));\n \n-        assert_eq!(matches_single.opts_str([\"e\".to_owned()]).unwrap(), \"foo\".to_owned());\n-        assert_eq!(matches_single.opts_str([\"e\".to_owned(), \"encrypt\".to_owned()]).unwrap(),\n-                   \"foo\".to_owned());\n-        assert_eq!(matches_single.opts_str([\"encrypt\".to_owned(), \"e\".to_owned()]).unwrap(),\n-                   \"foo\".to_owned());\n+        assert_eq!(matches_single.opts_str([\"e\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n+        assert_eq!(matches_single.opts_str([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]).unwrap(),\n+                   \"foo\".to_strbuf());\n+        assert_eq!(matches_single.opts_str([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]).unwrap(),\n+                   \"foo\".to_strbuf());\n \n-        let args_both = vec!(\"-e\".to_owned(), \"foo\".to_owned(), \"--encrypt\".to_owned(),\n-                             \"foo\".to_owned());\n+        let args_both = vec!(\"-e\".to_strbuf(), \"foo\".to_strbuf(), \"--encrypt\".to_strbuf(),\n+                             \"foo\".to_strbuf());\n         let matches_both = &match getopts(args_both.as_slice(),\n                                           opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches_both.opts_present([\"e\".to_owned()]));\n-        assert!(matches_both.opts_present([\"encrypt\".to_owned()]));\n-        assert!(matches_both.opts_present([\"encrypt\".to_owned(), \"e\".to_owned()]));\n-        assert!(matches_both.opts_present([\"e\".to_owned(), \"encrypt\".to_owned()]));\n-        assert!(!matches_both.opts_present([\"f\".to_owned()]));\n-        assert!(!matches_both.opts_present([\"thing\".to_owned()]));\n+        assert!(matches_both.opts_present([\"e\".to_strbuf()]));\n+        assert!(matches_both.opts_present([\"encrypt\".to_strbuf()]));\n+        assert!(matches_both.opts_present([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]));\n+        assert!(matches_both.opts_present([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]));\n+        assert!(!matches_both.opts_present([\"f\".to_strbuf()]));\n+        assert!(!matches_both.opts_present([\"thing\".to_strbuf()]));\n         assert!(!matches_both.opts_present([]));\n \n-        assert_eq!(matches_both.opts_str([\"e\".to_owned()]).unwrap(), \"foo\".to_owned());\n-        assert_eq!(matches_both.opts_str([\"encrypt\".to_owned()]).unwrap(), \"foo\".to_owned());\n-        assert_eq!(matches_both.opts_str([\"e\".to_owned(), \"encrypt\".to_owned()]).unwrap(),\n-                   \"foo\".to_owned());\n-        assert_eq!(matches_both.opts_str([\"encrypt\".to_owned(), \"e\".to_owned()]).unwrap(),\n-                   \"foo\".to_owned());\n+        assert_eq!(matches_both.opts_str([\"e\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n+        assert_eq!(matches_both.opts_str([\"encrypt\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n+        assert_eq!(matches_both.opts_str([\"e\".to_strbuf(), \"encrypt\".to_strbuf()]).unwrap(),\n+                   \"foo\".to_strbuf());\n+        assert_eq!(matches_both.opts_str([\"encrypt\".to_strbuf(), \"e\".to_strbuf()]).unwrap(),\n+                   \"foo\".to_strbuf());\n     }\n \n     #[test]\n     fn test_nospace() {\n-        let args = vec!(\"-Lfoo\".to_owned(), \"-M.\".to_owned());\n+        let args = vec!(\"-Lfoo\".to_strbuf(), \"-M.\".to_strbuf());\n         let opts = vec!(optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n                      optmulti(\"M\", \"\", \"something\", \"MMMM\"));\n         let matches = &match getopts(args.as_slice(), opts.as_slice()) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(matches.opts_present([\"L\".to_owned()]));\n-        assert_eq!(matches.opts_str([\"L\".to_owned()]).unwrap(), \"foo\".to_owned());\n-        assert!(matches.opts_present([\"M\".to_owned()]));\n-        assert_eq!(matches.opts_str([\"M\".to_owned()]).unwrap(), \".\".to_owned());\n+        assert!(matches.opts_present([\"L\".to_strbuf()]));\n+        assert_eq!(matches.opts_str([\"L\".to_strbuf()]).unwrap(), \"foo\".to_strbuf());\n+        assert!(matches.opts_present([\"M\".to_strbuf()]));\n+        assert_eq!(matches.opts_str([\"M\".to_strbuf()]).unwrap(), \".\".to_strbuf());\n \n     }\n \n     #[test]\n     fn test_long_to_short() {\n         let mut short = Opt {\n-            name: Long(\"banana\".to_owned()),\n+            name: Long(\"banana\".to_strbuf()),\n             hasarg: Yes,\n             occur: Req,\n             aliases: Vec::new(),\n@@ -1423,7 +1446,7 @@ mod tests {\n         let opts = vec!(\n             optflagmulti(\"a\", \"apple\", \"Desc\"));\n \n-        let args = vec!(\"-a\".to_owned(), \"--apple\".to_owned(), \"-a\".to_owned());\n+        let args = vec!(\"-a\".to_strbuf(), \"--apple\".to_strbuf(), \"-a\".to_strbuf());\n \n         let matches = getopts(args.as_slice(), opts.as_slice()).unwrap();\n         assert_eq!(3, matches.opt_count(\"a\"));\n@@ -1450,7 +1473,7 @@ Options:\n     -k --kiwi           Desc\n     -p [VAL]            Desc\n     -l VAL              Desc\n-\".to_owned();\n+\".to_strbuf();\n \n         let generated_usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1477,7 +1500,7 @@ Options:\n     -k --kiwi           This is a long description which won't be wrapped..+..\n     -a --apple          This is a long description which _will_ be\n                         wrapped..+..\n-\".to_owned();\n+\".to_strbuf();\n \n         let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1503,7 +1526,7 @@ Options:\n     -a --apple          This \u201cdescription\u201d has some characters that could\n                         confuse the line wrapping; an apple costs 0.51\u20ac in\n                         some parts of Europe.\n-\".to_owned();\n+\".to_strbuf();\n \n         let usage = usage(\"Usage: fruits\", optgroups.as_slice());\n \n@@ -1522,7 +1545,7 @@ Options:\n             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n             optmulti(\"l\", \"\", \"Desc\", \"VAL\"));\n \n-        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_owned();\n+        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_strbuf();\n         let generated_usage = short_usage(\"fruits\", optgroups.as_slice());\n \n         debug!(\"expected: <<{}>>\", expected);"}, {"sha": "02f937af90d2d3a55a6667cf8fee6aabf99b78ca", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -319,7 +319,7 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n {\n     let mut cg = basic_codegen_options();\n     for option in matches.opt_strs(\"C\").move_iter() {\n-        let mut iter = option.splitn('=', 1);\n+        let mut iter = option.as_slice().splitn('=', 1);\n         let key = iter.next().unwrap();\n         let value = iter.next();\n         let option_to_lookup = key.replace(\"-\", \"_\");\n@@ -563,7 +563,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let mut crate_types: Vec<CrateType> = Vec::new();\n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     for unparsed_crate_type in unparsed_crate_types.iter() {\n-        for part in unparsed_crate_type.split(',') {\n+        for part in unparsed_crate_type.as_slice().split(',') {\n             let new_part = match part {\n                 \"lib\"       => default_lib_output(),\n                 \"rlib\"      => CrateTypeRlib,\n@@ -612,7 +612,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         let mut this_bit = 0;\n         for tuple in debug_map.iter() {\n             let (name, bit) = match *tuple { (ref a, _, b) => (a, b) };\n-            if *name == *debug_flag { this_bit = bit; break; }\n+            if *name == debug_flag.as_slice() {\n+                this_bit = bit;\n+                break;\n+            }\n         }\n         if this_bit == 0 {\n             early_error(format!(\"unknown debug flag: {}\", *debug_flag))\n@@ -628,7 +631,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     if !parse_only && !no_trans {\n         let unparsed_output_types = matches.opt_strs(\"emit\");\n         for unparsed_output_type in unparsed_output_types.iter() {\n-            for part in unparsed_output_type.split(',') {\n+            for part in unparsed_output_type.as_slice().split(',') {\n                 let output_type = match part.as_slice() {\n                     \"asm\"  => link::OutputTypeAssembly,\n                     \"ir\"   => link::OutputTypeLlvmAssembly,\n@@ -765,7 +768,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts([\"--test\".to_owned()], optgroups().as_slice()) {\n+            &match getopts([\"--test\".to_strbuf()], optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n@@ -780,7 +783,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            &match getopts([\"--test\".to_owned(), \"--cfg=test\".to_owned()],\n+            &match getopts([\"--test\".to_strbuf(), \"--cfg=test\".to_strbuf()],\n                            optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => {"}, {"sha": "c4c145f5bd66d7adaee9184e4282ba046b1122a4", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -35,7 +35,7 @@ pub mod session;\n pub mod config;\n \n \n-pub fn main_args(args: &[~str]) -> int {\n+pub fn main_args(args: &[StrBuf]) -> int {\n     let owned_args = args.to_owned();\n     monitor(proc() run_compiler(owned_args));\n     0\n@@ -44,7 +44,7 @@ pub fn main_args(args: &[~str]) -> int {\n static BUG_REPORT_URL: &'static str =\n     \"http://static.rust-lang.org/doc/master/complement-bugreport.html\";\n \n-fn run_compiler(args: &[~str]) {\n+fn run_compiler(args: &[StrBuf]) {\n     let matches = match handle_options(Vec::from_slice(args)) {\n         Some(matches) => matches,\n         None => return\n@@ -73,7 +73,7 @@ fn run_compiler(args: &[~str]) {\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n \n     let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        parse_pretty(&sess, a)\n+        parse_pretty(&sess, a.as_slice())\n     });\n     match pretty {\n         Some::<PpMode>(ppm) => {\n@@ -84,7 +84,7 @@ fn run_compiler(args: &[~str]) {\n     }\n \n     let r = matches.opt_strs(\"Z\");\n-    if r.contains(&(\"ls\".to_owned())) {\n+    if r.contains(&(\"ls\".to_strbuf())) {\n         match input {\n             FileInput(ref ifile) => {\n                 let mut stdout = io::stdout();\n@@ -191,17 +191,20 @@ fn describe_codegen_flags() {\n /// Process command line options. Emits messages as appropirate.If compilation\n /// should continue, returns a getopts::Matches object parsed from args, otherwise\n /// returns None.\n-pub fn handle_options(mut args: Vec<~str>) -> Option<getopts::Matches> {\n+pub fn handle_options(mut args: Vec<StrBuf>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n     let _binary = args.shift().unwrap();\n \n-    if args.is_empty() { usage(); return None; }\n+    if args.is_empty() {\n+        usage();\n+        return None;\n+    }\n \n     let matches =\n         match getopts::getopts(args.as_slice(), config::optgroups().as_slice()) {\n             Ok(m) => m,\n             Err(f) => {\n-                early_error(f.to_err_msg());\n+                early_error(f.to_err_msg().as_slice());\n             }\n         };\n \n@@ -212,24 +215,24 @@ pub fn handle_options(mut args: Vec<~str>) -> Option<getopts::Matches> {\n \n     let lint_flags = matches.opt_strs(\"W\").move_iter().collect::<Vec<_>>().append(\n                                     matches.opt_strs(\"warn\").as_slice());\n-    if lint_flags.iter().any(|x| x == &\"help\".to_owned()) {\n+    if lint_flags.iter().any(|x| x.as_slice() == \"help\") {\n         describe_warnings();\n         return None;\n     }\n \n     let r = matches.opt_strs(\"Z\");\n-    if r.iter().any(|x| x == &\"help\".to_owned()) {\n+    if r.iter().any(|x| x.as_slice() == \"help\") {\n         describe_debug_flags();\n         return None;\n     }\n \n     let cg_flags = matches.opt_strs(\"C\");\n-    if cg_flags.iter().any(|x| x == &\"help\".to_owned()) {\n+    if cg_flags.iter().any(|x| x.as_slice() == \"help\") {\n         describe_codegen_flags();\n         return None;\n     }\n \n-    if cg_flags.contains(&\"passes=list\".to_owned()) {\n+    if cg_flags.contains(&\"passes=list\".to_strbuf()) {\n         unsafe { ::lib::llvm::llvm::LLVMRustPrintPasses(); }\n         return None;\n     }"}, {"sha": "678d525ddcbb90b1121f4832c352cb66338423e4", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -121,5 +121,8 @@ pub mod lib {\n }\n \n pub fn main() {\n-    std::os::set_exit_status(driver::main_args(std::os::args().as_slice()));\n+    let args = std::os::args().iter()\n+                              .map(|x| x.to_strbuf())\n+                              .collect::<Vec<_>>();\n+    std::os::set_exit_status(driver::main_args(args.as_slice()));\n }"}, {"sha": "2a7808fdf77593c53c53a70278e3b964f85640e9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -137,12 +137,7 @@ pub fn usage(argv0: &str) {\n }\n \n pub fn main_args(args: &[StrBuf]) -> int {\n-    let matches = match getopts::getopts(args.tail()\n-                                             .iter()\n-                                             .map(|x| (*x).to_owned())\n-                                             .collect::<Vec<_>>()\n-                                             .as_slice(),\n-                                         opts().as_slice()) {\n+    let matches = match getopts::getopts(args.tail(), opts().as_slice()) {\n         Ok(m) => m,\n         Err(err) => {\n             println!(\"{}\", err.to_err_msg());\n@@ -170,7 +165,7 @@ pub fn main_args(args: &[StrBuf]) -> int {\n \n     let test_args = matches.opt_strs(\"test-args\");\n     let test_args: Vec<StrBuf> = test_args.iter()\n-                                          .flat_map(|s| s.words())\n+                                          .flat_map(|s| s.as_slice().words())\n                                           .map(|s| s.to_strbuf())\n                                           .collect();\n \n@@ -199,7 +194,7 @@ pub fn main_args(args: &[StrBuf]) -> int {\n         (false, false) => {}\n     }\n \n-    if matches.opt_strs(\"passes\").as_slice() == &[\"list\".to_owned()] {\n+    if matches.opt_strs(\"passes\").as_slice() == &[\"list\".to_strbuf()] {\n         println!(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n             println!(\"{:>20s} - {}\", name, description);\n@@ -306,7 +301,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n                     clean::NameValue(ref x, ref value)\n                             if \"passes\" == x.as_slice() => {\n                         for pass in value.as_slice().words() {\n-                            passes.push(pass.to_owned());\n+                            passes.push(pass.to_strbuf());\n                         }\n                     }\n                     clean::NameValue(ref x, ref value)\n@@ -323,15 +318,19 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     }\n     if default_passes {\n         for name in DEFAULT_PASSES.iter().rev() {\n-            passes.unshift(name.to_owned());\n+            passes.unshift(name.to_strbuf());\n         }\n     }\n \n     // Load all plugins/passes into a PluginManager\n-    let path = matches.opt_str(\"plugin-path\").unwrap_or(\"/tmp/rustdoc/plugins\".to_owned());\n+    let path = matches.opt_str(\"plugin-path\")\n+                      .unwrap_or(\"/tmp/rustdoc/plugins\".to_strbuf());\n     let mut pm = plugins::PluginManager::new(Path::new(path));\n     for pass in passes.iter() {\n-        let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n+        let plugin = match PASSES.iter()\n+                                 .position(|&(p, _, _)| {\n+                                     p == pass.as_slice()\n+                                 }) {\n             Some(i) => PASSES[i].val1(),\n             None => {\n                 error!(\"unknown pass {}, skipping\", *pass);\n@@ -364,7 +363,7 @@ fn json_input(input: &str) -> Result<Output, StrBuf> {\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n             // Make sure the schema is what we expect\n-            match obj.pop(&\"schema\".to_owned()) {\n+            match obj.pop(&\"schema\".to_strbuf()) {\n                 Some(json::String(version)) => {\n                     if version.as_slice() != SCHEMA_VERSION {\n                         return Err(format_strbuf!(\n@@ -375,7 +374,7 @@ fn json_input(input: &str) -> Result<Output, StrBuf> {\n                 Some(..) => return Err(\"malformed json\".to_strbuf()),\n                 None => return Err(\"expected a schema version\".to_strbuf()),\n             }\n-            let krate = match obj.pop(&\"crate\".to_str()) {\n+            let krate = match obj.pop(&\"crate\".to_strbuf()) {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d).unwrap()\n@@ -404,13 +403,14 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     //   \"plugins\": { output of plugins ... }\n     // }\n     let mut json = box collections::TreeMap::new();\n-    json.insert(\"schema\".to_owned(), json::String(SCHEMA_VERSION.to_owned()));\n+    json.insert(\"schema\".to_strbuf(),\n+                json::String(SCHEMA_VERSION.to_strbuf()));\n     let plugins_json = box res.move_iter()\n                               .filter_map(|opt| {\n                                   match opt {\n                                       None => None,\n                                       Some((string, json)) => {\n-                                          Some((string.to_owned(), json))\n+                                          Some((string.to_strbuf(), json))\n                                       }\n                                   }\n                               }).collect();\n@@ -423,15 +423,15 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             krate.encode(&mut encoder).unwrap();\n         }\n-        str::from_utf8(w.unwrap().as_slice()).unwrap().to_owned()\n+        str::from_utf8(w.unwrap().as_slice()).unwrap().to_strbuf()\n     };\n-    let crate_json = match json::from_str(crate_json_str) {\n+    let crate_json = match json::from_str(crate_json_str.as_slice()) {\n         Ok(j) => j,\n         Err(e) => fail!(\"Rust generated JSON is invalid: {:?}\", e)\n     };\n \n-    json.insert(\"crate\".to_owned(), crate_json);\n-    json.insert(\"plugins\".to_owned(), json::Object(plugins_json));\n+    json.insert(\"crate\".to_strbuf(), crate_json);\n+    json.insert(\"plugins\".to_strbuf(), json::Object(plugins_json));\n \n     let mut file = try!(File::create(&dst));\n     try!(json::Object(json).to_writer(&mut file));"}, {"sha": "a9b449e63be4c710628d123718cd93416c700755", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -353,21 +353,21 @@ impl Loop {\n pub struct UvError(c_int);\n \n impl UvError {\n-    pub fn name(&self) -> ~str {\n+    pub fn name(&self) -> StrBuf {\n         unsafe {\n             let inner = match self { &UvError(a) => a };\n             let name_str = uvll::uv_err_name(inner);\n             assert!(name_str.is_not_null());\n-            from_c_str(name_str)\n+            from_c_str(name_str).to_strbuf()\n         }\n     }\n \n-    pub fn desc(&self) -> ~str {\n+    pub fn desc(&self) -> StrBuf {\n         unsafe {\n             let inner = match self { &UvError(a) => a };\n             let desc_str = uvll::uv_strerror(inner);\n             assert!(desc_str.is_not_null());\n-            from_c_str(desc_str)\n+            from_c_str(desc_str).to_strbuf()\n         }\n     }\n "}, {"sha": "0b31010020be15e362364111fe240b0861165661", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -851,15 +851,15 @@ mod test {\n     fn connect_close_ip4() {\n         match TcpWatcher::connect(local_loop(), next_test_ip4(), None) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_owned()),\n+            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_strbuf()),\n         }\n     }\n \n     #[test]\n     fn connect_close_ip6() {\n         match TcpWatcher::connect(local_loop(), next_test_ip6(), None) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_owned()),\n+            Err(e) => assert_eq!(e.name(), \"ECONNREFUSED\".to_strbuf()),\n         }\n     }\n "}, {"sha": "cf3035c742c36d6e8ab1fc73235e622982d7174c", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -338,7 +338,7 @@ mod tests {\n     fn bind_err() {\n         match PipeListener::bind(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n             Ok(..) => fail!(),\n-            Err(e) => assert_eq!(e.name(), \"EACCES\".to_owned()),\n+            Err(e) => assert_eq!(e.name(), \"EACCES\".to_strbuf()),\n         }\n     }\n "}, {"sha": "2d938bc9ae77eceaa01b02bfb00c4f9450f88d9a", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -54,7 +54,7 @@ static URLSAFE_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n pub trait ToBase64 {\n     /// Converts the value of `self` to a base64 value following the specified\n     /// format configuration, returning the owned string.\n-    fn to_base64(&self, config: Config) -> ~str;\n+    fn to_base64(&self, config: Config) -> StrBuf;\n }\n \n impl<'a> ToBase64 for &'a [u8] {\n@@ -73,7 +73,7 @@ impl<'a> ToBase64 for &'a [u8] {\n      * }\n      * ```\n      */\n-    fn to_base64(&self, config: Config) -> ~str {\n+    fn to_base64(&self, config: Config) -> StrBuf {\n         let bytes = match config.char_set {\n             Standard => STANDARD_CHARS,\n             UrlSafe => URLSAFE_CHARS\n@@ -146,7 +146,7 @@ impl<'a> ToBase64 for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8(v.as_slice()).to_owned()\n+            str::raw::from_utf8(v.as_slice()).to_strbuf()\n         }\n     }\n }\n@@ -195,7 +195,7 @@ impl<'a> FromBase64 for &'a str {\n      * fn main () {\n      *     let hello_str = bytes!(\"Hello, World\").to_base64(STANDARD);\n      *     println!(\"base64 output: {}\", hello_str);\n-     *     let res = hello_str.from_base64();\n+     *     let res = hello_str.as_slice().from_base64();\n      *     if res.is_ok() {\n      *       let opt_bytes = StrBuf::from_utf8(res.unwrap());\n      *       if opt_bytes.is_ok() {\n@@ -267,34 +267,35 @@ mod tests {\n \n     #[test]\n     fn test_to_base64_basic() {\n-        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\".to_owned());\n-        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\".to_owned());\n-        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\".to_owned());\n-        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\".to_owned());\n-        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\".to_owned());\n-        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\".to_owned());\n-        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\".to_owned());\n+        assert_eq!(\"\".as_bytes().to_base64(STANDARD), \"\".to_strbuf());\n+        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), \"Zg==\".to_strbuf());\n+        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), \"Zm8=\".to_strbuf());\n+        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), \"Zm9v\".to_strbuf());\n+        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), \"Zm9vYg==\".to_strbuf());\n+        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), \"Zm9vYmE=\".to_strbuf());\n+        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), \"Zm9vYmFy\".to_strbuf());\n     }\n \n     #[test]\n     fn test_to_base64_line_break() {\n         assert!(![0u8, ..1000].to_base64(Config {line_length: None, ..STANDARD})\n-                .contains(\"\\r\\n\"));\n+                              .as_slice()\n+                              .contains(\"\\r\\n\"));\n         assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n                                                          ..STANDARD}),\n-                   \"Zm9v\\r\\nYmFy\".to_owned());\n+                   \"Zm9v\\r\\nYmFy\".to_strbuf());\n     }\n \n     #[test]\n     fn test_to_base64_padding() {\n-        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\".to_owned());\n-        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\".to_owned());\n+        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zg\".to_strbuf());\n+        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), \"Zm8\".to_strbuf());\n     }\n \n     #[test]\n     fn test_to_base64_url_safe() {\n-        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\".to_owned());\n-        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\".to_owned());\n+        assert_eq!([251, 255].to_base64(URL_SAFE), \"-_8\".to_strbuf());\n+        assert_eq!([251, 255].to_base64(STANDARD), \"+/8=\".to_strbuf());\n     }\n \n     #[test]\n@@ -339,7 +340,12 @@ mod tests {\n         for _ in range(0, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n             let v = Vec::from_fn(times, |_| random::<u8>());\n-            assert_eq!(v.as_slice().to_base64(STANDARD).from_base64().unwrap().as_slice(),\n+            assert_eq!(v.as_slice()\n+                        .to_base64(STANDARD)\n+                        .as_slice()\n+                        .from_base64()\n+                        .unwrap()\n+                        .as_slice(),\n                        v.as_slice());\n         }\n     }\n@@ -360,7 +366,7 @@ mod tests {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let sb = s.as_bytes().to_base64(STANDARD);\n         b.iter(|| {\n-            sb.from_base64().unwrap();\n+            sb.as_slice().from_base64().unwrap();\n         });\n         b.bytes = sb.len() as u64;\n     }"}, {"sha": "104efbeab0a3cd61ff45459399c8ca3a3311af93", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -34,8 +34,8 @@ impl<'doc> Doc<'doc> {\n         str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n     }\n \n-    pub fn as_str(&self) -> ~str {\n-        self.as_str_slice().to_owned()\n+    pub fn as_str(&self) -> StrBuf {\n+        self.as_str_slice().to_strbuf()\n     }\n }\n \n@@ -80,7 +80,7 @@ pub enum EbmlEncoderTag {\n #[deriving(Show)]\n pub enum Error {\n     IntTooBig(uint),\n-    Expected(~str),\n+    Expected(StrBuf),\n     IoError(io::IoError)\n }\n // --------------------------------------\n@@ -312,7 +312,10 @@ pub mod reader {\n                     self.pos = r_doc.end;\n                     let str = r_doc.as_str_slice();\n                     if lbl != str {\n-                        return Err(Expected(format!(\"Expected label {} but found {}\", lbl, str)));\n+                        return Err(Expected(format_strbuf!(\"Expected label \\\n+                                                            {} but found {}\",\n+                                                           lbl,\n+                                                           str)));\n                     }\n                 }\n             }\n@@ -322,7 +325,8 @@ pub mod reader {\n         fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n             debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n+                return Err(Expected(format_strbuf!(\"no more documents in \\\n+                                                    current node!\")));\n             }\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 try!(doc_at(self.parent.data, self.pos));\n@@ -334,12 +338,18 @@ pub mod reader {\n                    r_doc.start,\n                    r_doc.end);\n             if r_tag != (exp_tag as uint) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n-                       exp_tag, r_tag)));\n+                return Err(Expected(format_strbuf!(\"expected EBML doc with \\\n+                                                    tag {:?} but found tag \\\n+                                                    {:?}\",\n+                                                   exp_tag,\n+                                                   r_tag)));\n             }\n             if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n-                      r_doc.end, self.parent.end)));\n+                return Err(Expected(format_strbuf!(\"invalid EBML, child \\\n+                                                    extends to {:#x}, parent \\\n+                                                    to {:#x}\",\n+                                                   r_doc.end,\n+                                                   self.parent.end)));\n             }\n             self.pos = r_doc.end;\n             Ok(r_doc)\n@@ -433,7 +443,7 @@ pub mod reader {\n         fn read_char(&mut self) -> DecodeResult<char> {\n             Ok(char::from_u32(doc_as_u32(try!(self.next_doc(EsChar)))).unwrap())\n         }\n-        fn read_str(&mut self) -> DecodeResult<~str> {\n+        fn read_str(&mut self) -> DecodeResult<StrBuf> {\n             Ok(try!(self.next_doc(EsStr)).as_str())\n         }\n \n@@ -570,7 +580,10 @@ pub mod reader {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n-                        _ => Err(Expected(format!(\"Expected None or Some\"))),\n+                        _ => {\n+                            Err(Expected(format_strbuf!(\"Expected None or \\\n+                                                         Some\")))\n+                        }\n                     }\n                 })\n             })"}, {"sha": "3b8500753cb3f5170b7d3120152395413f9ddece", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -16,7 +16,7 @@ use std::fmt;\n pub trait ToHex {\n     /// Converts the value of `self` to a hex value, returning the owned\n     /// string.\n-    fn to_hex(&self) -> ~str;\n+    fn to_hex(&self) -> StrBuf;\n }\n \n static CHARS: &'static[u8] = bytes!(\"0123456789abcdef\");\n@@ -37,15 +37,15 @@ impl<'a> ToHex for &'a [u8] {\n      * }\n      * ```\n      */\n-    fn to_hex(&self) -> ~str {\n+    fn to_hex(&self) -> StrBuf {\n         let mut v = Vec::with_capacity(self.len() * 2);\n         for &byte in self.iter() {\n             v.push(CHARS[(byte >> 4) as uint]);\n             v.push(CHARS[(byte & 0xf) as uint]);\n         }\n \n         unsafe {\n-            str::raw::from_utf8(v.as_slice()).to_owned()\n+            str::raw::from_utf8(v.as_slice()).to_strbuf()\n         }\n     }\n }\n@@ -94,7 +94,7 @@ impl<'a> FromHex for &'a str {\n      * fn main () {\n      *     let hello_str = \"Hello, World\".as_bytes().to_hex();\n      *     println!(\"{}\", hello_str);\n-     *     let bytes = hello_str.from_hex().unwrap();\n+     *     let bytes = hello_str.as_slice().from_hex().unwrap();\n      *     println!(\"{:?}\", bytes);\n      *     let result_str = StrBuf::from_utf8(bytes).unwrap();\n      *     println!(\"{}\", result_str);\n@@ -143,7 +143,7 @@ mod tests {\n \n     #[test]\n     pub fn test_to_hex() {\n-        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\".to_owned());\n+        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\".to_strbuf());\n     }\n \n     #[test]\n@@ -174,7 +174,8 @@ mod tests {\n     #[test]\n     pub fn test_to_hex_all_bytes() {\n         for i in range(0, 256) {\n-            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as uint));\n+            assert_eq!([i as u8].to_hex(),\n+                       format_strbuf!(\"{:02x}\", i as uint));\n         }\n     }\n \n@@ -202,7 +203,7 @@ mod tests {\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let sb = s.as_bytes().to_hex();\n         b.iter(|| {\n-            sb.from_hex().unwrap();\n+            sb.as_slice().from_hex().unwrap();\n         });\n         b.bytes = sb.len() as u64;\n     }"}, {"sha": "422914b1405706bf60ff1d9681890c7009ca18c5", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 232, "deletions": 204, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -64,11 +64,11 @@ use serialize::{json, Encodable};\n \n  #[deriving(Encodable)]\n  pub struct TestStruct   {\n-    data_str: ~str,\n+    data_str: StrBuf,\n  }\n \n fn main() {\n-    let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_owned()};\n+    let to_encode_object = TestStruct{data_str:\"example of string to encode\".to_strbuf()};\n     let mut m = io::MemWriter::new();\n     {\n         let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n@@ -81,12 +81,12 @@ fn main() {\n ```\n \n Two wrapper functions are provided to encode a Encodable object\n-into a string (~str) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n+into a string (StrBuf) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n \n ```rust\n use serialize::json;\n-let to_encode_object = \"example of string to encode\".to_owned();\n-let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+let to_encode_object = \"example of string to encode\".to_strbuf();\n+let encoded_str: StrBuf = json::Encoder::str_encode(&to_encode_object);\n ```\n \n JSON API provide an enum `json::Json` and a trait `ToJson` to encode object.\n@@ -108,22 +108,22 @@ use collections::TreeMap;\n \n pub struct MyStruct  {\n     attr1: u8,\n-    attr2: ~str,\n+    attr2: StrBuf,\n }\n \n impl ToJson for MyStruct {\n     fn to_json( &self ) -> json::Json {\n         let mut d = box TreeMap::new();\n-        d.insert(\"attr1\".to_owned(), self.attr1.to_json());\n-        d.insert(\"attr2\".to_owned(), self.attr2.to_json());\n+        d.insert(\"attr1\".to_strbuf(), self.attr1.to_json());\n+        d.insert(\"attr2\".to_strbuf(), self.attr2.to_json());\n         json::Object(d)\n     }\n }\n \n fn main() {\n-    let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_owned()};\n+    let test2: MyStruct = MyStruct {attr1: 1, attr2:\"test\".to_strbuf()};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: ~str = tjson.to_str();\n+    let json_str: StrBuf = tjson.to_str().into_strbuf();\n }\n ```\n \n@@ -136,13 +136,13 @@ use serialize::{json, Decodable};\n #[deriving(Decodable)]\n pub struct MyStruct  {\n      attr1: u8,\n-     attr2: ~str,\n+     attr2: StrBuf,\n }\n \n fn main() {\n-    let json_str_to_decode: ~str =\n-            \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_owned();\n-    let json_object = json::from_str(json_str_to_decode);\n+    let json_str_to_decode: StrBuf =\n+            \"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\".to_strbuf();\n+    let json_object = json::from_str(json_str_to_decode.as_slice());\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n     let decoded_object: MyStruct = match Decodable::decode(&mut decoder) {\n         Ok(v) => v,\n@@ -165,20 +165,20 @@ use serialize::{json, Encodable, Decodable};\n  #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n  pub struct TestStruct1  {\n     data_int: u8,\n-    data_str: ~str,\n+    data_str: StrBuf,\n     data_vector: Vec<u8>,\n  }\n \n // To serialize use the `json::str_encode` to encode an object in a string.\n // It calls the generated `Encodable` impl.\n fn main() {\n     let to_encode_object = TestStruct1\n-         {data_int: 1, data_str:\"toto\".to_owned(), data_vector:vec![2,3,4,5]};\n-    let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+         {data_int: 1, data_str:\"toto\".to_strbuf(), data_vector:vec![2,3,4,5]};\n+    let encoded_str: StrBuf = json::Encoder::str_encode(&to_encode_object);\n \n     // To deserialize use the `json::from_str` and `json::Decoder`\n \n-    let json_object = json::from_str(encoded_str);\n+    let json_object = json::from_str(encoded_str.as_slice());\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n     let decoded1: TestStruct1 = Decodable::decode(&mut decoder).unwrap(); // create the final object\n }\n@@ -200,31 +200,32 @@ use collections::TreeMap;\n #[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n pub struct TestStruct1  {\n     data_int: u8,\n-    data_str: ~str,\n+    data_str: StrBuf,\n     data_vector: Vec<u8>,\n }\n \n impl ToJson for TestStruct1 {\n     fn to_json( &self ) -> json::Json {\n         let mut d = box TreeMap::new();\n-        d.insert(\"data_int\".to_owned(), self.data_int.to_json());\n-        d.insert(\"data_str\".to_owned(), self.data_str.to_json());\n-        d.insert(\"data_vector\".to_owned(), self.data_vector.to_json());\n+        d.insert(\"data_int\".to_strbuf(), self.data_int.to_json());\n+        d.insert(\"data_str\".to_strbuf(), self.data_str.to_json());\n+        d.insert(\"data_vector\".to_strbuf(), self.data_vector.to_json());\n         json::Object(d)\n     }\n }\n \n fn main() {\n     // Serialization using our impl of to_json\n \n-    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_owned(),\n+    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:\"toto\".to_strbuf(),\n                                           data_vector:vec![2,3,4,5]};\n     let tjson: json::Json = test2.to_json();\n-    let json_str: ~str = tjson.to_str();\n+    let json_str: StrBuf = tjson.to_str().into_strbuf();\n \n     // Deserialize like before.\n \n-    let mut decoder = json::Decoder::new(json::from_str(json_str).unwrap());\n+    let mut decoder =\n+        json::Decoder::new(json::from_str(json_str.as_slice()).unwrap());\n     // create the final object\n     let decoded2: TestStruct1 = Decodable::decode(&mut decoder).unwrap();\n }\n@@ -251,15 +252,15 @@ use collections::{HashMap, TreeMap};\n #[deriving(Clone, Eq)]\n pub enum Json {\n     Number(f64),\n-    String(~str),\n+    String(StrBuf),\n     Boolean(bool),\n     List(List),\n     Object(Box<Object>),\n     Null,\n }\n \n pub type List = Vec<Json>;\n-pub type Object = TreeMap<~str, Json>;\n+pub type Object = TreeMap<StrBuf, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n #[deriving(Clone, Eq)]\n@@ -295,9 +296,9 @@ pub type BuilderError = ParserError;\n #[deriving(Clone, Eq, Show)]\n pub enum DecoderError {\n     ParseError(ParserError),\n-    ExpectedError(~str, ~str),\n-    MissingFieldError(~str),\n-    UnknownVariantError(~str),\n+    ExpectedError(StrBuf, StrBuf),\n+    MissingFieldError(StrBuf),\n+    UnknownVariantError(StrBuf),\n }\n \n /// Returns a readable error string for a given error code.\n@@ -336,7 +337,7 @@ fn io_error_to_error(io: io::IoError) -> ParserError {\n pub type EncodeResult = io::IoResult<()>;\n pub type DecodeResult<T> = Result<T, DecoderError>;\n \n-fn escape_str(s: &str) -> ~str {\n+fn escape_str(s: &str) -> StrBuf {\n     let mut escaped = StrBuf::from_str(\"\\\"\");\n     for c in s.chars() {\n         match c {\n@@ -351,15 +352,15 @@ fn escape_str(s: &str) -> ~str {\n         }\n     };\n     escaped.push_char('\"');\n-    escaped.into_owned()\n+    escaped\n }\n \n-fn spaces(n: uint) -> ~str {\n+fn spaces(n: uint) -> StrBuf {\n     let mut ss = StrBuf::new();\n     for _ in range(0, n) {\n         ss.push_str(\" \");\n     }\n-    return ss.into_owned();\n+    return ss\n }\n \n /// A structure for implementing serialization to JSON.\n@@ -387,9 +388,12 @@ impl<'a> Encoder<'a> {\n     }\n \n     /// Encode the specified struct into a json str\n-    pub fn str_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> ~str  {\n+    pub fn str_encode<T:Encodable<Encoder<'a>,\n+                        io::IoError>>(\n+                      to_encode_object: &T)\n+                      -> StrBuf {\n         let buff = Encoder::buffer_encode(to_encode_object);\n-        str::from_utf8(buff.as_slice()).unwrap().to_owned()\n+        str::from_utf8(buff.as_slice()).unwrap().to_strbuf()\n     }\n }\n \n@@ -826,15 +830,15 @@ impl Json {\n     }\n \n     /// Encodes a json value into a string\n-    pub fn to_pretty_str(&self) -> ~str {\n+    pub fn to_pretty_str(&self) -> StrBuf {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        str::from_utf8(s.unwrap().as_slice()).unwrap().to_owned()\n+        str::from_utf8(s.unwrap().as_slice()).unwrap().to_strbuf()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n-    pub fn find<'a>(&'a self, key: &~str) -> Option<&'a Json>{\n+    pub fn find<'a>(&'a self, key: &StrBuf) -> Option<&'a Json>{\n         match self {\n             &Object(ref map) => map.find(key),\n             _ => None\n@@ -844,7 +848,7 @@ impl Json {\n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&~str]) -> Option<&'a Json>{\n+    pub fn find_path<'a>(&'a self, keys: &[&StrBuf]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys.iter() {\n             match target.find(*key) {\n@@ -858,7 +862,7 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n-    pub fn search<'a>(&'a self, key: &~str) -> Option<&'a Json> {\n+    pub fn search<'a>(&'a self, key: &StrBuf) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n                 match map.find(key) {\n@@ -973,7 +977,7 @@ pub enum JsonEvent {\n     ListEnd,\n     BooleanValue(bool),\n     NumberValue(f64),\n-    StringValue(~str),\n+    StringValue(StrBuf),\n     NullValue,\n     Error(ParserError),\n }\n@@ -1091,7 +1095,7 @@ impl Stack {\n     }\n \n     // Used by Parser to insert Key elements at the top of the stack.\n-    fn push_key(&mut self, key: ~str) {\n+    fn push_key(&mut self, key: StrBuf) {\n         self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n         for c in key.as_bytes().iter() {\n             self.str_buffer.push(*c);\n@@ -1378,7 +1382,7 @@ impl<T: Iterator<char>> Parser<T> {\n         Ok(n)\n     }\n \n-    fn parse_str(&mut self) -> Result<~str, ParserError> {\n+    fn parse_str(&mut self) -> Result<StrBuf, ParserError> {\n         let mut escape = false;\n         let mut res = StrBuf::new();\n \n@@ -1462,7 +1466,7 @@ impl<T: Iterator<char>> Parser<T> {\n                 match self.ch {\n                     Some('\"') => {\n                         self.bump();\n-                        return Ok(res.into_owned());\n+                        return Ok(res);\n                     },\n                     Some(c) => res.push_char(c),\n                     None => unreachable!()\n@@ -1738,7 +1742,7 @@ impl<T: Iterator<char>> Builder<T> {\n             Some(NumberValue(n)) => { Ok(Number(n)) }\n             Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n             Some(StringValue(ref mut s)) => {\n-                let mut temp = \"\".to_owned();\n+                let mut temp = StrBuf::new();\n                 swap(s, &mut temp);\n                 Ok(String(temp))\n             }\n@@ -1780,7 +1784,7 @@ impl<T: Iterator<char>> Builder<T> {\n                 _ => {}\n             }\n             let key = match self.parser.stack().top() {\n-                Some(Key(k)) => { k.into_owned() }\n+                Some(Key(k)) => { k.to_strbuf() }\n                 _ => { fail!(\"invalid state\"); }\n             };\n             match self.build_value() {\n@@ -1801,10 +1805,10 @@ pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n         Err(e) => return Err(io_error_to_error(e))\n     };\n     let s = match str::from_utf8(contents.as_slice()) {\n-        Some(s) => s.to_owned(),\n+        Some(s) => s.to_strbuf(),\n         None => return Err(SyntaxError(NotUtf8, 0, 0))\n     };\n-    let mut builder = Builder::new(s.chars());\n+    let mut builder = Builder::new(s.as_slice().chars());\n     builder.build()\n }\n \n@@ -1838,13 +1842,17 @@ macro_rules! expect(\n     ($e:expr, Null) => ({\n         match $e {\n             Null => Ok(()),\n-            other => Err(ExpectedError(\"Null\".to_owned(), format!(\"{}\", other)))\n+            other => Err(ExpectedError(\"Null\".to_strbuf(),\n+                                       format_strbuf!(\"{}\", other)))\n         }\n     });\n     ($e:expr, $t:ident) => ({\n         match $e {\n             $t(v) => Ok(v),\n-            other => Err(ExpectedError(stringify!($t).to_owned(), format!(\"{}\", other)))\n+            other => {\n+                Err(ExpectedError(stringify!($t).to_strbuf(),\n+                                  format_strbuf!(\"{}\", other)))\n+            }\n         }\n     })\n )\n@@ -1881,9 +1889,12 @@ impl ::Decoder<DecoderError> for Decoder {\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec..\n-                Ok(FromStr::from_str(s).unwrap())\n+                Ok(FromStr::from_str(s.as_slice()).unwrap())\n             },\n-            value => Err(ExpectedError(\"Number\".to_owned(), format!(\"{}\", value)))\n+            value => {\n+                Err(ExpectedError(\"Number\".to_strbuf(),\n+                                  format_strbuf!(\"{}\", value)))\n+            }\n         }\n     }\n \n@@ -1892,17 +1903,18 @@ impl ::Decoder<DecoderError> for Decoder {\n     fn read_char(&mut self) -> DecodeResult<char> {\n         let s = try!(self.read_str());\n         {\n-            let mut it = s.chars();\n+            let mut it = s.as_slice().chars();\n             match (it.next(), it.next()) {\n                 // exactly one character\n                 (Some(c), None) => return Ok(c),\n                 _ => ()\n             }\n         }\n-        Err(ExpectedError(\"single character string\".to_owned(), format!(\"{}\", s)))\n+        Err(ExpectedError(\"single character string\".to_strbuf(),\n+                          format_strbuf!(\"{}\", s)))\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<~str> {\n+    fn read_str(&mut self) -> DecodeResult<StrBuf> {\n         debug!(\"read_str\");\n         Ok(try!(expect!(self.pop(), String)))\n     }\n@@ -1922,25 +1934,41 @@ impl ::Decoder<DecoderError> for Decoder {\n         let name = match self.pop() {\n             String(s) => s,\n             Object(mut o) => {\n-                let n = match o.pop(&\"variant\".to_owned()) {\n+                let n = match o.pop(&\"variant\".to_strbuf()) {\n                     Some(String(s)) => s,\n-                    Some(val) => return Err(ExpectedError(\"String\".to_owned(), format!(\"{}\", val))),\n-                    None => return Err(MissingFieldError(\"variant\".to_owned()))\n+                    Some(val) => {\n+                        return Err(ExpectedError(\"String\".to_strbuf(),\n+                                                 format_strbuf!(\"{}\", val)))\n+                    }\n+                    None => {\n+                        return Err(MissingFieldError(\"variant\".to_strbuf()))\n+                    }\n                 };\n-                match o.pop(&\"fields\".to_owned()) {\n+                match o.pop(&\"fields\".to_strbuf()) {\n                     Some(List(l)) => {\n                         for field in l.move_iter().rev() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n-                    Some(val) => return Err(ExpectedError(\"List\".to_owned(), format!(\"{}\", val))),\n-                    None => return Err(MissingFieldError(\"fields\".to_owned()))\n+                    Some(val) => {\n+                        return Err(ExpectedError(\"List\".to_strbuf(),\n+                                                 format_strbuf!(\"{}\", val)))\n+                    }\n+                    None => {\n+                        return Err(MissingFieldError(\"fields\".to_strbuf()))\n+                    }\n                 }\n                 n\n             }\n-            json => return Err(ExpectedError(\"String or Object\".to_owned(), format!(\"{}\", json)))\n+            json => {\n+                return Err(ExpectedError(\"String or Object\".to_strbuf(),\n+                                         format_strbuf!(\"{}\", json)))\n+            }\n         };\n-        let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n+        let idx = match names.iter()\n+                             .position(|n| {\n+                                 str::eq_slice(*n, name.as_slice())\n+                             }) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -1990,8 +2018,8 @@ impl ::Decoder<DecoderError> for Decoder {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         let mut obj = try!(expect!(self.pop(), Object));\n \n-        let value = match obj.pop(&name.to_owned()) {\n-            None => return Err(MissingFieldError(name.to_owned())),\n+        let value = match obj.pop(&name.to_strbuf()) {\n+            None => return Err(MissingFieldError(name.to_strbuf())),\n             Some(json) => {\n                 self.stack.push(json);\n                 try!(f(self))\n@@ -2199,12 +2227,8 @@ impl ToJson for bool {\n     fn to_json(&self) -> Json { Boolean(*self) }\n }\n \n-impl ToJson for ~str {\n-    fn to_json(&self) -> Json { String((*self).clone()) }\n-}\n-\n impl ToJson for StrBuf {\n-    fn to_json(&self) -> Json { String((*self).as_slice().into_owned()) }\n+    fn to_json(&self) -> Json { String((*self).clone()) }\n }\n \n impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n@@ -2235,7 +2259,7 @@ impl<A:ToJson> ToJson for Vec<A> {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A:ToJson> ToJson for TreeMap<~str, A> {\n+impl<A:ToJson> ToJson for TreeMap<StrBuf, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2245,7 +2269,7 @@ impl<A:ToJson> ToJson for TreeMap<~str, A> {\n     }\n }\n \n-impl<A:ToJson> ToJson for HashMap<~str, A> {\n+impl<A:ToJson> ToJson for HashMap<StrBuf, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2291,22 +2315,22 @@ mod tests {\n     #[deriving(Eq, Encodable, Decodable, Show)]\n     enum Animal {\n         Dog,\n-        Frog(~str, int)\n+        Frog(StrBuf, int)\n     }\n \n     #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Inner {\n         a: (),\n         b: uint,\n-        c: Vec<~str>,\n+        c: Vec<StrBuf>,\n     }\n \n     #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Outer {\n         inner: Vec<Inner>,\n     }\n \n-    fn mk_object(items: &[(~str, Json)]) -> Json {\n+    fn mk_object(items: &[(StrBuf, Json)]) -> Json {\n         let mut d = box TreeMap::new();\n \n         for item in items.iter() {\n@@ -2320,67 +2344,67 @@ mod tests {\n \n     #[test]\n     fn test_write_null() {\n-        assert_eq!(Null.to_str(), \"null\".to_owned());\n-        assert_eq!(Null.to_pretty_str(), \"null\".to_owned());\n+        assert_eq!(Null.to_str().into_strbuf(), \"null\".to_strbuf());\n+        assert_eq!(Null.to_pretty_str().into_strbuf(), \"null\".to_strbuf());\n     }\n \n \n     #[test]\n     fn test_write_number() {\n-        assert_eq!(Number(3.0).to_str(), \"3\".to_owned());\n-        assert_eq!(Number(3.0).to_pretty_str(), \"3\".to_owned());\n+        assert_eq!(Number(3.0).to_str().into_strbuf(), \"3\".to_strbuf());\n+        assert_eq!(Number(3.0).to_pretty_str().into_strbuf(), \"3\".to_strbuf());\n \n-        assert_eq!(Number(3.1).to_str(), \"3.1\".to_owned());\n-        assert_eq!(Number(3.1).to_pretty_str(), \"3.1\".to_owned());\n+        assert_eq!(Number(3.1).to_str().into_strbuf(), \"3.1\".to_strbuf());\n+        assert_eq!(Number(3.1).to_pretty_str().into_strbuf(), \"3.1\".to_strbuf());\n \n-        assert_eq!(Number(-1.5).to_str(), \"-1.5\".to_owned());\n-        assert_eq!(Number(-1.5).to_pretty_str(), \"-1.5\".to_owned());\n+        assert_eq!(Number(-1.5).to_str().into_strbuf(), \"-1.5\".to_strbuf());\n+        assert_eq!(Number(-1.5).to_pretty_str().into_strbuf(), \"-1.5\".to_strbuf());\n \n-        assert_eq!(Number(0.5).to_str(), \"0.5\".to_owned());\n-        assert_eq!(Number(0.5).to_pretty_str(), \"0.5\".to_owned());\n+        assert_eq!(Number(0.5).to_str().into_strbuf(), \"0.5\".to_strbuf());\n+        assert_eq!(Number(0.5).to_pretty_str().into_strbuf(), \"0.5\".to_strbuf());\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert_eq!(String(\"\".to_owned()).to_str(), \"\\\"\\\"\".to_owned());\n-        assert_eq!(String(\"\".to_owned()).to_pretty_str(), \"\\\"\\\"\".to_owned());\n+        assert_eq!(String(\"\".to_strbuf()).to_str().into_strbuf(), \"\\\"\\\"\".to_strbuf());\n+        assert_eq!(String(\"\".to_strbuf()).to_pretty_str().into_strbuf(), \"\\\"\\\"\".to_strbuf());\n \n-        assert_eq!(String(\"foo\".to_owned()).to_str(), \"\\\"foo\\\"\".to_owned());\n-        assert_eq!(String(\"foo\".to_owned()).to_pretty_str(), \"\\\"foo\\\"\".to_owned());\n+        assert_eq!(String(\"foo\".to_strbuf()).to_str().into_strbuf(), \"\\\"foo\\\"\".to_strbuf());\n+        assert_eq!(String(\"foo\".to_strbuf()).to_pretty_str().into_strbuf(), \"\\\"foo\\\"\".to_strbuf());\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_str(), \"true\".to_owned());\n-        assert_eq!(Boolean(true).to_pretty_str(), \"true\".to_owned());\n+        assert_eq!(Boolean(true).to_str().into_strbuf(), \"true\".to_strbuf());\n+        assert_eq!(Boolean(true).to_pretty_str().into_strbuf(), \"true\".to_strbuf());\n \n-        assert_eq!(Boolean(false).to_str(), \"false\".to_owned());\n-        assert_eq!(Boolean(false).to_pretty_str(), \"false\".to_owned());\n+        assert_eq!(Boolean(false).to_str().into_strbuf(), \"false\".to_strbuf());\n+        assert_eq!(Boolean(false).to_pretty_str().into_strbuf(), \"false\".to_strbuf());\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert_eq!(List(vec![]).to_str(), \"[]\".to_owned());\n-        assert_eq!(List(vec![]).to_pretty_str(), \"[]\".to_owned());\n+        assert_eq!(List(vec![]).to_str().into_strbuf(), \"[]\".to_strbuf());\n+        assert_eq!(List(vec![]).to_pretty_str().into_strbuf(), \"[]\".to_strbuf());\n \n-        assert_eq!(List(vec![Boolean(true)]).to_str(), \"[true]\".to_owned());\n+        assert_eq!(List(vec![Boolean(true)]).to_str().into_strbuf(), \"[true]\".to_strbuf());\n         assert_eq!(\n-            List(vec![Boolean(true)]).to_pretty_str(),\n+            List(vec![Boolean(true)]).to_pretty_str().into_strbuf(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n-            ]\".to_owned()\n+            ]\".to_strbuf()\n         );\n \n         let long_test_list = List(vec![\n             Boolean(false),\n             Null,\n-            List(vec![String(\"foo\\nbar\".to_owned()), Number(3.5)])]);\n+            List(vec![String(\"foo\\nbar\".to_strbuf()), Number(3.5)])]);\n \n-        assert_eq!(long_test_list.to_str(),\n-            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_owned());\n+        assert_eq!(long_test_list.to_str().into_strbuf(),\n+            \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_strbuf());\n         assert_eq!(\n-            long_test_list.to_pretty_str(),\n+            long_test_list.to_pretty_str().into_strbuf(),\n             \"\\\n             [\\n  \\\n                 false,\\n  \\\n@@ -2389,45 +2413,47 @@ mod tests {\n                     \\\"foo\\\\nbar\\\",\\n    \\\n                     3.5\\n  \\\n                 ]\\n\\\n-            ]\".to_owned()\n+            ]\".to_strbuf()\n         );\n     }\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(mk_object([]).to_str(), \"{}\".to_owned());\n-        assert_eq!(mk_object([]).to_pretty_str(), \"{}\".to_owned());\n+        assert_eq!(mk_object([]).to_str().into_strbuf(), \"{}\".to_strbuf());\n+        assert_eq!(mk_object([]).to_pretty_str().into_strbuf(), \"{}\".to_strbuf());\n \n         assert_eq!(\n-            mk_object([(\"a\".to_owned(), Boolean(true))]).to_str(),\n-            \"{\\\"a\\\":true}\".to_owned()\n+            mk_object([\n+                (\"a\".to_strbuf(), Boolean(true))\n+            ]).to_str().into_strbuf(),\n+            \"{\\\"a\\\":true}\".to_strbuf()\n         );\n         assert_eq!(\n-            mk_object([(\"a\".to_owned(), Boolean(true))]).to_pretty_str(),\n+            mk_object([(\"a\".to_strbuf(), Boolean(true))]).to_pretty_str(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n-            }\".to_owned()\n+            }\".to_strbuf()\n         );\n \n         let complex_obj = mk_object([\n-                (\"b\".to_owned(), List(vec![\n-                    mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n-                    mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n+                (\"b\".to_strbuf(), List(vec![\n+                    mk_object([(\"c\".to_strbuf(), String(\"\\x0c\\r\".to_strbuf()))]),\n+                    mk_object([(\"d\".to_strbuf(), String(\"\".to_strbuf()))])\n                 ]))\n             ]);\n \n         assert_eq!(\n-            complex_obj.to_str(),\n+            complex_obj.to_str().into_strbuf(),\n             \"{\\\n                 \\\"b\\\":[\\\n                     {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n                     {\\\"d\\\":\\\"\\\"}\\\n                 ]\\\n-            }\".to_owned()\n+            }\".to_strbuf()\n         );\n         assert_eq!(\n-            complex_obj.to_pretty_str(),\n+            complex_obj.to_pretty_str().into_strbuf(),\n             \"\\\n             {\\n  \\\n                 \\\"b\\\": [\\n    \\\n@@ -2438,30 +2464,31 @@ mod tests {\n                         \\\"d\\\": \\\"\\\"\\n    \\\n                     }\\n  \\\n                 ]\\n\\\n-            }\".to_owned()\n+            }\".to_strbuf()\n         );\n \n         let a = mk_object([\n-            (\"a\".to_owned(), Boolean(true)),\n-            (\"b\".to_owned(), List(vec![\n-                mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n-                mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n+            (\"a\".to_strbuf(), Boolean(true)),\n+            (\"b\".to_strbuf(), List(vec![\n+                mk_object([(\"c\".to_strbuf(), String(\"\\x0c\\r\".to_strbuf()))]),\n+                mk_object([(\"d\".to_strbuf(), String(\"\".to_strbuf()))])\n             ]))\n         ]);\n \n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n         assert_eq!(a.clone(), from_str(a.to_str()).unwrap());\n-        assert_eq!(a.clone(), from_str(a.to_pretty_str()).unwrap());\n+        assert_eq!(a.clone(),\n+                   from_str(a.to_pretty_str().as_slice()).unwrap());\n     }\n \n-    fn with_str_writer(f: |&mut io::Writer|) -> ~str {\n+    fn with_str_writer(f: |&mut io::Writer|) -> StrBuf {\n         use std::io::MemWriter;\n         use std::str;\n \n         let mut m = MemWriter::new();\n         f(&mut m as &mut io::Writer);\n-        str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned()\n+        str::from_utf8(m.unwrap().as_slice()).unwrap().to_strbuf()\n     }\n \n     #[test]\n@@ -2472,23 +2499,23 @@ mod tests {\n                 let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"\\\"Dog\\\"\".to_owned()\n+            \"\\\"Dog\\\"\".to_strbuf()\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"\\\"Dog\\\"\".to_owned()\n+            \"\\\"Dog\\\"\".to_strbuf()\n         );\n \n-        let animal = Frog(\"Henry\".to_owned(), 349);\n+        let animal = Frog(\"Henry\".to_strbuf(), 349);\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = Encoder::new(wr);\n                 animal.encode(&mut encoder).unwrap();\n             }),\n-            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_owned()\n+            \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\".to_strbuf()\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n@@ -2500,41 +2527,41 @@ mod tests {\n                 \\\"Frog\\\",\\n  \\\n                 \\\"Henry\\\",\\n  \\\n                 349\\n\\\n-            ]\".to_owned()\n+            ]\".to_strbuf()\n         );\n     }\n \n     #[test]\n     fn test_write_some() {\n-        let value = Some(\"jodhpurs\".to_owned());\n+        let value = Some(\"jodhpurs\".to_strbuf());\n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_owned());\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_strbuf());\n \n-        let value = Some(\"jodhpurs\".to_owned());\n+        let value = Some(\"jodhpurs\".to_strbuf());\n         let s = with_str_writer(|wr| {\n             let mut encoder = PrettyEncoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_owned());\n+        assert_eq!(s, \"\\\"jodhpurs\\\"\".to_strbuf());\n     }\n \n     #[test]\n     fn test_write_none() {\n-        let value: Option<~str> = None;\n+        let value: Option<StrBuf> = None;\n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"null\".to_owned());\n+        assert_eq!(s, \"null\".to_strbuf());\n \n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n             value.encode(&mut encoder).unwrap();\n         });\n-        assert_eq!(s, \"null\".to_owned());\n+        assert_eq!(s, \"null\".to_strbuf());\n     }\n \n     #[test]\n@@ -2635,16 +2662,16 @@ mod tests {\n         assert_eq!(from_str(\"\\\"\"),    Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n         assert_eq!(from_str(\"\\\"lol\"), Err(SyntaxError(EOFWhileParsingString, 1, 5)));\n \n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_owned())));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_owned())));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_owned())));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_owned())));\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(\"\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(\"foo\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(\"\\\"\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(\"\\x08\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(\"\\n\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(\"\\r\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(\"\\t\".to_strbuf())));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(\"foo\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(\"\\u12ab\".to_strbuf())));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\uAB12\".to_strbuf())));\n     }\n \n     #[test]\n@@ -2665,8 +2692,8 @@ mod tests {\n             assert_eq!(v.as_slice(), o);\n \n             let mut decoder = Decoder::new(from_str(i).unwrap());\n-            let v: ~str = Decodable::decode(&mut decoder).unwrap();\n-            assert_eq!(v, o.to_owned());\n+            let v: StrBuf = Decodable::decode(&mut decoder).unwrap();\n+            assert_eq!(v, o.to_strbuf());\n         }\n     }\n \n@@ -2735,39 +2762,39 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(\"a\".to_owned(), Number(3.0))]));\n+                  mk_object([(\"a\".to_strbuf(), Number(3.0))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_owned(), Null),\n-                      (\"b\".to_owned(), Boolean(true))]));\n+                      (\"a\".to_strbuf(), Null),\n+                      (\"b\".to_strbuf(), Boolean(true))]));\n         assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_owned(), Null),\n-                      (\"b\".to_owned(), Boolean(true))]));\n+                      (\"a\".to_strbuf(), Null),\n+                      (\"b\".to_strbuf(), Boolean(true))]));\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_owned(), Number(1.0)),\n-                      (\"b\".to_owned(), List(vec![Boolean(true)]))\n+                      (\"a\".to_strbuf(), Number(1.0)),\n+                      (\"b\".to_strbuf(), List(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n-                      \"{\".to_owned() +\n-                          \"\\\"a\\\": 1.0, \" +\n-                          \"\\\"b\\\": [\" +\n-                              \"true,\" +\n-                              \"\\\"foo\\\\nbar\\\", \" +\n-                              \"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n-                          \"]\" +\n-                      \"}\").unwrap(),\n+                      \"{\\\n+                          \\\"a\\\": 1.0, \\\n+                          \\\"b\\\": [\\\n+                              true,\\\n+                              \\\"foo\\\\nbar\\\", \\\n+                              { \\\"c\\\": {\\\"d\\\": null} } \\\n+                          ]\\\n+                      }\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_owned(), Number(1.0)),\n-                      (\"b\".to_owned(), List(vec![\n+                      (\"a\".to_strbuf(), Number(1.0)),\n+                      (\"b\".to_strbuf(), List(vec![\n                           Boolean(true),\n-                          String(\"foo\\nbar\".to_owned()),\n+                          String(\"foo\\nbar\".to_strbuf()),\n                           mk_object([\n-                              (\"c\".to_owned(), mk_object([(\"d\".to_owned(), Null)]))\n+                              (\"c\".to_strbuf(), mk_object([(\"d\".to_strbuf(), Null)]))\n                           ])\n                       ]))\n                   ]));\n@@ -2779,14 +2806,14 @@ mod tests {\n             \\\"inner\\\": [\n                 { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n             ]\n-        }\".to_owned();\n+        }\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n         let v: Outer = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(\n             v,\n             Outer {\n                 inner: vec![\n-                    Inner { a: (), b: 2, c: vec![\"abc\".to_owned(), \"xyz\".to_owned()] }\n+                    Inner { a: (), b: 2, c: vec![\"abc\".to_strbuf(), \"xyz\".to_strbuf()] }\n                 ]\n             }\n         );\n@@ -2795,12 +2822,12 @@ mod tests {\n     #[test]\n     fn test_decode_option() {\n         let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&mut decoder).unwrap();\n+        let value: Option<StrBuf> = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(value, None);\n \n         let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(value, Some(\"jodhpurs\".to_owned()));\n+        let value: Option<StrBuf> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(value, Some(\"jodhpurs\".to_strbuf()));\n     }\n \n     #[test]\n@@ -2812,18 +2839,18 @@ mod tests {\n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n         let value: Animal = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(value, Frog(\"Henry\".to_owned(), 349));\n+        assert_eq!(value, Frog(\"Henry\".to_strbuf(), 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n-                  \\\"fields\\\":[\\\"Henry\\\", 349]}}\".to_owned();\n+                  \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder).unwrap();\n+        let mut map: TreeMap<StrBuf, Animal> = Decodable::decode(&mut decoder).unwrap();\n \n-        assert_eq!(map.pop(&\"a\".to_owned()), Some(Dog));\n-        assert_eq!(map.pop(&\"b\".to_owned()), Some(Frog(\"Henry\".to_owned(), 349)));\n+        assert_eq!(map.pop(&\"a\".to_strbuf()), Some(Dog));\n+        assert_eq!(map.pop(&\"b\".to_strbuf()), Some(Frog(\"Henry\".to_strbuf(), 349)));\n     }\n \n     #[test]\n@@ -2836,13 +2863,13 @@ mod tests {\n     struct DecodeStruct {\n         x: f64,\n         y: bool,\n-        z: ~str,\n+        z: StrBuf,\n         w: Vec<DecodeStruct>\n     }\n     #[deriving(Decodable)]\n     enum DecodeEnum {\n         A(f64),\n-        B(~str)\n+        B(StrBuf)\n     }\n     fn check_err<T: Decodable<Decoder, DecoderError>>(to_parse: &'static str,\n                                                       expected: DecoderError) {\n@@ -2862,51 +2889,51 @@ mod tests {\n     }\n     #[test]\n     fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_owned(), \"[]\".to_owned()));\n+        check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_strbuf(), \"[]\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Number\".to_owned(), \"true\".to_owned()));\n+                                  ExpectedError(\"Number\".to_strbuf(), \"true\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  ExpectedError(\"Boolean\".to_owned(), \"[]\".to_owned()));\n+                                  ExpectedError(\"Boolean\".to_strbuf(), \"[]\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  ExpectedError(\"String\".to_owned(), \"{}\".to_owned()));\n+                                  ExpectedError(\"String\".to_strbuf(), \"{}\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  ExpectedError(\"List\".to_owned(), \"null\".to_owned()));\n+                                  ExpectedError(\"List\".to_strbuf(), \"null\".to_strbuf()));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  MissingFieldError(\"w\".to_owned()));\n+                                  MissingFieldError(\"w\".to_strbuf()));\n     }\n     #[test]\n     fn test_decode_errors_enum() {\n         check_err::<DecodeEnum>(\"{}\",\n-                                MissingFieldError(\"variant\".to_owned()));\n+                                MissingFieldError(\"variant\".to_strbuf()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                ExpectedError(\"String\".to_owned(), \"1\".to_owned()));\n+                                ExpectedError(\"String\".to_strbuf(), \"1\".to_strbuf()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                MissingFieldError(\"fields\".to_owned()));\n+                                MissingFieldError(\"fields\".to_strbuf()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                ExpectedError(\"List\".to_owned(), \"null\".to_owned()));\n+                                ExpectedError(\"List\".to_strbuf(), \"null\".to_strbuf()));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                UnknownVariantError(\"C\".to_owned()));\n+                                UnknownVariantError(\"C\".to_strbuf()));\n     }\n \n     #[test]\n     fn test_find(){\n         let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(&\"dog\".to_owned());\n+        let found_str = json_value.find(&\"dog\".to_strbuf());\n         assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cat\");\n     }\n \n     #[test]\n     fn test_find_path(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[&\"dog\".to_owned(),\n-                                             &\"cat\".to_owned(), &\"mouse\".to_owned()]);\n+        let found_str = json_value.find_path(&[&\"dog\".to_strbuf(),\n+                                             &\"cat\".to_strbuf(), &\"mouse\".to_strbuf()]);\n         assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == \"cheese\");\n     }\n \n     #[test]\n     fn test_search(){\n         let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(&\"mouse\".to_owned()).and_then(|j| j.as_string());\n+        let found_str = json_value.search(&\"mouse\".to_strbuf()).and_then(|j| j.as_string());\n         assert!(found_str.is_some());\n         assert!(found_str.unwrap() == \"cheese\");\n     }\n@@ -3069,7 +3096,7 @@ mod tests {\n             r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2,3 ,4,5], \"idents\":[null,true,false]}\"#,\n             ~[\n                 (ObjectStart,             ~[]),\n-                  (StringValue(\"bar\".to_owned()),   ~[Key(\"foo\")]),\n+                  (StringValue(\"bar\".to_strbuf()),   ~[Key(\"foo\")]),\n                   (ListStart,             ~[Key(\"array\")]),\n                     (NumberValue(0.0),    ~[Key(\"array\"), Index(0)]),\n                     (NumberValue(1.0),    ~[Key(\"array\"), Index(1)]),\n@@ -3158,7 +3185,7 @@ mod tests {\n                   (NumberValue(1.0),            ~[Key(\"a\")]),\n                   (ListStart,                   ~[Key(\"b\")]),\n                     (BooleanValue(true),        ~[Key(\"b\"), Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_owned()),  ~[Key(\"b\"), Index(1)]),\n+                    (StringValue(\"foo\\nbar\".to_strbuf()),  ~[Key(\"b\"), Index(1)]),\n                     (ObjectStart,               ~[Key(\"b\"), Index(2)]),\n                       (ObjectStart,             ~[Key(\"b\"), Index(2), Key(\"c\")]),\n                         (NullValue,             ~[Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n@@ -3291,7 +3318,7 @@ mod tests {\n         assert!(stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n \n-        stack.push_key(\"foo\".to_owned());\n+        stack.push_key(\"foo\".to_strbuf());\n \n         assert!(stack.len() == 2);\n         assert!(stack.is_equal_to([Index(1), Key(\"foo\")]));\n@@ -3303,7 +3330,7 @@ mod tests {\n         assert!(stack.get(0) == Index(1));\n         assert!(stack.get(1) == Key(\"foo\"));\n \n-        stack.push_key(\"bar\".to_owned());\n+        stack.push_key(\"bar\".to_strbuf());\n \n         assert!(stack.len() == 3);\n         assert!(stack.is_equal_to([Index(1), Key(\"foo\"), Key(\"bar\")]));\n@@ -3366,20 +3393,21 @@ mod tests {\n         });\n     }\n \n-    fn big_json() -> ~str {\n-        let mut src = \"[\\n\".to_owned();\n+    fn big_json() -> StrBuf {\n+        let mut src = \"[\\n\".to_strbuf();\n         for _ in range(0, 500) {\n-            src = src + r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": [1,2,3]},\"#;\n+            src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n+                            [1,2,3]},\"#);\n         }\n-        src = src + \"{}]\";\n+        src.push_str(\"{}]\");\n         return src;\n     }\n \n     #[bench]\n     fn bench_streaming_large(b: &mut Bencher) {\n         let src = big_json();\n         b.iter( || {\n-            let mut parser = Parser::new(src.chars());\n+            let mut parser = Parser::new(src.as_slice().chars());\n             loop {\n                 match parser.next() {\n                     None => return,\n@@ -3391,6 +3419,6 @@ mod tests {\n     #[bench]\n     fn bench_large(b: &mut Bencher) {\n         let src = big_json();\n-        b.iter( || { let _ = from_str(src); });\n+        b.iter( || { let _ = from_str(src.as_slice()); });\n     }\n }"}, {"sha": "3189676ec1e24552d619b7e774248eadddb92835", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -108,7 +108,7 @@ pub trait Decoder<E> {\n     fn read_f64(&mut self) -> Result<f64, E>;\n     fn read_f32(&mut self) -> Result<f32, E>;\n     fn read_char(&mut self) -> Result<char, E>;\n-    fn read_str(&mut self) -> Result<~str, E>;\n+    fn read_str(&mut self) -> Result<StrBuf, E>;\n \n     // Compound types:\n     fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n@@ -301,18 +301,6 @@ impl<'a, E, S:Encoder<E>> Encodable<S, E> for &'a str {\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for ~str {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(*self)\n-    }\n-}\n-\n-impl<E, D:Decoder<E>> Decodable<D, E> for ~str {\n-    fn decode(d: &mut D) -> Result<~str, E> {\n-        d.read_str()\n-    }\n-}\n-\n impl<E, S:Encoder<E>> Encodable<S, E> for StrBuf {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_str(self.as_slice())\n@@ -321,7 +309,7 @@ impl<E, S:Encoder<E>> Encodable<S, E> for StrBuf {\n \n impl<E, D:Decoder<E>> Decodable<D, E> for StrBuf {\n     fn decode(d: &mut D) -> Result<StrBuf, E> {\n-        Ok(StrBuf::from_str(try!(d.read_str())))\n+        Ok(StrBuf::from_str(try!(d.read_str()).as_slice()))\n     }\n }\n "}, {"sha": "e7f892d77ceaaef7542d451a01fb3ddeeedd41a9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -106,7 +106,7 @@ impl<S: Encoder<E>, E> Encodable<S, E> for Ident {\n \n impl<D:Decoder<E>, E> Decodable<D, E> for Ident {\n     fn decode(d: &mut D) -> Result<Ident, E> {\n-        Ok(str_to_ident(try!(d.read_str())))\n+        Ok(str_to_ident(try!(d.read_str()).as_slice()))\n     }\n }\n "}, {"sha": "01124fdfa54df5d1941cae0e6e15c5a0fa40d426", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -886,7 +886,9 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n     match parser.errors.shift() {\n         Some(error) => {\n-            cx.ecx.span_err(efmt.span, \"invalid format string: \" + error);\n+            cx.ecx.span_err(efmt.span,\n+                            format_strbuf!(\"invalid format string: {}\",\n+                                           error).as_slice());\n             return DummyResult::raw_expr(sp);\n         }\n         None => {}"}, {"sha": "8758f109042f049b57bd885695604427d27bb1af", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -606,7 +606,8 @@ impl<'a> Equiv<&'a str> for InternedString {\n \n impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n     fn decode(d: &mut D) -> Result<InternedString, E> {\n-        Ok(get_name(get_ident_interner().intern(try!(d.read_str()))))\n+        Ok(get_name(get_ident_interner().intern(\n+                    try!(d.read_str()).as_slice())))\n     }\n }\n "}, {"sha": "4681c02d78e13ea12b33dba100363fddac56830c", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -354,11 +354,7 @@ Test Attributes:\n pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n     let args_ = args.tail();\n     let matches =\n-        match getopts::getopts(args_.iter()\n-                                    .map(|x| x.to_owned())\n-                                    .collect::<Vec<_>>()\n-                                    .as_slice(),\n-                               optgroups().as_slice()) {\n+        match getopts::getopts(args_.as_slice(), optgroups().as_slice()) {\n           Ok(m) => m,\n           Err(f) => return Some(Err(f.to_err_msg().to_strbuf()))\n         };\n@@ -388,7 +384,8 @@ pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n     let ratchet_metrics = ratchet_metrics.map(|s| Path::new(s));\n \n     let ratchet_noise_percent = matches.opt_str(\"ratchet-noise-percent\");\n-    let ratchet_noise_percent = ratchet_noise_percent.map(|s| from_str::<f64>(s).unwrap());\n+    let ratchet_noise_percent =\n+        ratchet_noise_percent.map(|s| from_str::<f64>(s.as_slice()).unwrap());\n \n     let save_metrics = matches.opt_str(\"save-metrics\");\n     let save_metrics = save_metrics.map(|s| Path::new(s));\n@@ -1068,8 +1065,8 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n         let mut map = box TreeMap::new();\n-        map.insert(\"value\".to_owned(), json::Number(self.value));\n-        map.insert(\"noise\".to_owned(), json::Number(self.noise));\n+        map.insert(\"value\".to_strbuf(), json::Number(self.value));\n+        map.insert(\"noise\".to_strbuf(), json::Number(self.noise));\n         json::Object(map)\n     }\n }\n@@ -1106,7 +1103,7 @@ impl MetricMap {\n         // FIXME(pcwalton): Yuck.\n         let mut new_map = TreeMap::new();\n         for (ref key, ref value) in map.iter() {\n-            new_map.insert(key.to_owned(), (*value).clone());\n+            new_map.insert(key.to_strbuf(), (*value).clone());\n         }\n \n         new_map.to_json().to_pretty_writer(&mut file)"}, {"sha": "b580626c9c36f284b4cb8fd5a048fb213f770926", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -192,7 +192,7 @@ pub fn tzset() {\n \n /// Holds a calendar date and time broken down into its components (year, month, day, and so on),\n /// also called a broken-down time value.\n-#[deriving(Clone, Eq, Encodable, Decodable, Show)]\n+#[deriving(Clone, Eq, Show)]\n pub struct Tm {\n     /// Seconds after the minute \u2013 [0, 60]\n     pub tm_sec: i32,"}, {"sha": "d2032b9d49281a7436149776718c389cae4e563b", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -500,7 +500,7 @@ impl<T: Encoder<E>, E> Encodable<T, E> for Uuid {\n impl<T: Decoder<E>, E> Decodable<T, E> for Uuid {\n     /// Decode a UUID from a string\n     fn decode(d: &mut T) -> Result<Uuid, E> {\n-        Ok(from_str(try!(d.read_str())).unwrap())\n+        Ok(from_str(try!(d.read_str()).as_slice()).unwrap())\n     }\n }\n "}, {"sha": "5ac45d75156b4442948109c39e366a1d1f76dd81", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -190,7 +190,7 @@ impl Database {\n         // FIXME(pcwalton): Yuck.\n         let mut new_db_cache = TreeMap::new();\n         for (ref k, ref v) in self.db_cache.iter() {\n-            new_db_cache.insert((*k).to_owned(), (*v).to_owned());\n+            new_db_cache.insert((*k).to_strbuf(), (*v).to_strbuf());\n         }\n \n         new_db_cache.to_json().to_pretty_writer(&mut f)\n@@ -513,10 +513,13 @@ fn test() {\n         let pth = pth.clone();\n \n         let contents = File::open(&pth).read_to_end().unwrap();\n-        let file_content = from_utf8(contents.as_slice()).unwrap().to_owned();\n+        let file_content = from_utf8(contents.as_slice()).unwrap()\n+                                                         .to_strbuf();\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n+        prep.declare_input(\"file\",\n+                           pth.as_str().unwrap(),\n+                           file_content.as_slice());\n         prep.exec(proc(_exe) {\n             let out = make_path(\"foo.o\".to_strbuf());\n             let compiler = if cfg!(windows) {\"gcc\"} else {\"cc\"};\n@@ -526,7 +529,7 @@ fn test() {\n             // Could run sub-rules inside here.\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            out.as_str().unwrap().to_owned()\n+            out.as_str().unwrap().to_strbuf()\n         })\n     });\n "}, {"sha": "313671448f8e9c71a91a82032871f9d9e2d69eaa", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -55,7 +55,7 @@ struct Config {\n fn parse_opts(argv: Vec<StrBuf> ) -> Config {\n     let opts = vec!(getopts::optflag(\"\", \"stress\", \"\"));\n \n-    let argv = argv.iter().map(|x| x.to_str()).collect::<Vec<_>>();\n+    let argv = argv.iter().map(|x| x.to_strbuf()).collect::<Vec<_>>();\n     let opt_args = argv.slice(1, argv.len());\n \n     match getopts::getopts(opt_args, opts.as_slice()) {"}, {"sha": "6aa5f6b09ecdefb9e426df4a73c2a176236de548", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e10686aabb7253e6a6e660e72c7f5de8bbba3de/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=5e10686aabb7253e6a6e660e72c7f5de8bbba3de", "patch": "@@ -23,7 +23,7 @@ enum object {\n \n fn lookup(table: Box<json::Object>, key: StrBuf, default: StrBuf) -> StrBuf\n {\n-    match table.find(&key.to_owned()) {\n+    match table.find(&key.to_strbuf()) {\n         option::Some(&json::String(ref s)) => {\n             (*s).to_strbuf()\n         }"}]}