{"sha": "eb8aa9759dc99b604145f94e5296b7add60e0a48", "node_id": "C_kwDOAAsO6NoAKGViOGFhOTc1OWRjOTliNjA0MTQ1Zjk0ZTUyOTZiN2FkZDYwZTBhNDg", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2022-10-19T03:46:26Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2022-10-19T13:08:00Z"}, "message": "Add testcase for next_point, fix more trivial issues in find_width_of_character_at_span", "tree": {"sha": "f4bcf4c6f5de2d125e70f2dae32a351a561d6bc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4bcf4c6f5de2d125e70f2dae32a351a561d6bc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb8aa9759dc99b604145f94e5296b7add60e0a48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb8aa9759dc99b604145f94e5296b7add60e0a48", "html_url": "https://github.com/rust-lang/rust/commit/eb8aa9759dc99b604145f94e5296b7add60e0a48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb8aa9759dc99b604145f94e5296b7add60e0a48/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0af255a5aa448efe6ab7e3252e85081128beaa9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0af255a5aa448efe6ab7e3252e85081128beaa9e", "html_url": "https://github.com/rust-lang/rust/commit/0af255a5aa448efe6ab7e3252e85081128beaa9e"}], "stats": {"total": 67, "additions": 59, "deletions": 8}, "files": [{"sha": "506ce6955d399f62760662a5e3260490bf019cdc", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eb8aa9759dc99b604145f94e5296b7add60e0a48/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb8aa9759dc99b604145f94e5296b7add60e0a48/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=eb8aa9759dc99b604145f94e5296b7add60e0a48", "patch": "@@ -853,16 +853,22 @@ impl SourceMap {\n     }\n \n     /// Returns a new span representing the next character after the end-point of this span.\n+    /// Special cases:\n+    /// - if span is a dummy one, returns the same span\n+    /// - if next_point reached the end of source, return span with lo = hi\n+    /// - respect multi-byte characters\n     pub fn next_point(&self, sp: Span) -> Span {\n         if sp.is_dummy() {\n             return sp;\n         }\n         let start_of_next_point = sp.hi().0;\n \n         let width = self.find_width_of_character_at_span(sp, true);\n-        debug_assert!(width > 0);\n-        // If the width is 1, then the next span should point to the same `lo` and `hi`. However,\n-        // in the case of a multibyte character, where the width != 1, the next span should\n+        if width == 0 {\n+            return Span::new(sp.hi(), sp.hi(), sp.ctxt(), None);\n+        }\n+        // If the width is 1, then the next span should only contain the next char besides current ending.\n+        // However, in the case of a multibyte character, where the width != 1, the next span should\n         // span multiple bytes to include the whole character.\n         let end_of_next_point =\n             start_of_next_point.checked_add(width).unwrap_or(start_of_next_point);\n@@ -875,7 +881,8 @@ impl SourceMap {\n     /// depending on the `forwards` parameter.\n     fn find_width_of_character_at_span(&self, sp: Span, forwards: bool) -> u32 {\n         let sp = sp.data();\n-        if sp.lo == sp.hi {\n+\n+        if sp.lo == sp.hi && !forwards {\n             debug!(\"find_width_of_character_at_span: early return empty span\");\n             return 1;\n         }\n@@ -909,9 +916,9 @@ impl SourceMap {\n         let source_len = (local_begin.sf.end_pos - local_begin.sf.start_pos).to_usize();\n         debug!(\"find_width_of_character_at_span: source_len=`{:?}`\", source_len);\n         // Ensure indexes are also not malformed.\n-        if start_index > end_index || end_index > source_len {\n+        if start_index > end_index || end_index > source_len - 1 {\n             debug!(\"find_width_of_character_at_span: source indexes are malformed\");\n-            return 1;\n+            return 0;\n         }\n \n         let src = local_begin.sf.external_src.borrow();"}, {"sha": "1fd81018fa05c2f99442867621df3020050f36b4", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/eb8aa9759dc99b604145f94e5296b7add60e0a48/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb8aa9759dc99b604145f94e5296b7add60e0a48/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=eb8aa9759dc99b604145f94e5296b7add60e0a48", "patch": "@@ -479,3 +479,48 @@ fn path_prefix_remapping_expand_to_absolute() {\n         RealFileName::Remapped { local_path: None, virtual_name: path(\"XYZ/src/main.rs\") }\n     );\n }\n+\n+#[test]\n+fn test_next_point() {\n+    let sm = SourceMap::new(FilePathMapping::empty());\n+    sm.new_source_file(PathBuf::from(\"example.rs\").into(), \"a\u2026b\".to_string());\n+\n+    // Dummy spans don't advance.\n+    let span = DUMMY_SP;\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 0);\n+    assert_eq!(span.hi().0, 0);\n+\n+    // Span advance respect multi-byte character\n+    let span = Span::with_root_ctxt(BytePos(0), BytePos(1));\n+    assert_eq!(sm.span_to_snippet(span), Ok(\"a\".to_string()));\n+    let span = sm.next_point(span);\n+    assert_eq!(sm.span_to_snippet(span), Ok(\"\u2026\".to_string()));\n+    assert_eq!(span.lo().0, 1);\n+    assert_eq!(span.hi().0, 4);\n+\n+    // An empty span pointing just before a multi-byte character should\n+    // advance to contain the multi-byte character.\n+    let span = Span::with_root_ctxt(BytePos(1), BytePos(1));\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 1);\n+    assert_eq!(span.hi().0, 4);\n+\n+    let span = Span::with_root_ctxt(BytePos(1), BytePos(4));\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 4);\n+    assert_eq!(span.hi().0, 5);\n+\n+    // A non-empty span at the last byte should advance to create an empty\n+    // span pointing at the end of the file.\n+    let span = Span::with_root_ctxt(BytePos(4), BytePos(5));\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 5);\n+    assert_eq!(span.hi().0, 5);\n+\n+    // Empty span pointing just past the last byte.\n+    let span = Span::with_root_ctxt(BytePos(5), BytePos(5));\n+    let span = sm.next_point(span);\n+    assert_eq!(span.lo().0, 5);\n+    assert_eq!(span.hi().0, 5);\n+}"}, {"sha": "3347342e412b64c788d639e796feeb9a2f443fc9", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eb8aa9759dc99b604145f94e5296b7add60e0a48/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb8aa9759dc99b604145f94e5296b7add60e0a48/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=eb8aa9759dc99b604145f94e5296b7add60e0a48", "patch": "@@ -769,8 +769,7 @@ impl<T: LintContext> DiagnosticExt<T> for rustc_errors::Diagnostic {\n \n     fn suggest_remove_item(&mut self, cx: &T, item: Span, msg: &str, applicability: Applicability) {\n         let mut remove_span = item;\n-        let hi = cx.sess().source_map().next_point(remove_span).hi();\n-        let fmpos = cx.sess().source_map().lookup_byte_offset(hi);\n+        let fmpos = cx.sess().source_map().lookup_byte_offset(remove_span.hi());\n \n         if let Some(ref src) = fmpos.sf.src {\n             let non_whitespace_offset = src[fmpos.pos.to_usize()..].find(|c| c != ' ' && c != '\\t' && c != '\\n');"}]}