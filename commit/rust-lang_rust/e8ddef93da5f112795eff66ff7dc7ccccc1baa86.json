{"sha": "e8ddef93da5f112795eff66ff7dc7ccccc1baa86", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZGRlZjkzZGE1ZjExMjc5NWVmZjY2ZmY3ZGM3Y2NjY2MxYmFhODY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-12T07:48:41Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-18T23:59:10Z"}, "message": "core: Cleanup rt::context", "tree": {"sha": "223fad2fcc8d4e8b654925003cc596409136d69f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/223fad2fcc8d4e8b654925003cc596409136d69f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8ddef93da5f112795eff66ff7dc7ccccc1baa86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ddef93da5f112795eff66ff7dc7ccccc1baa86", "html_url": "https://github.com/rust-lang/rust/commit/e8ddef93da5f112795eff66ff7dc7ccccc1baa86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8ddef93da5f112795eff66ff7dc7ccccc1baa86/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "087a015a727b11d46ff5a309ff37c7967e8636d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/087a015a727b11d46ff5a309ff37c7967e8636d1", "html_url": "https://github.com/rust-lang/rust/commit/087a015a727b11d46ff5a309ff37c7967e8636d1"}], "stats": {"total": 52, "additions": 35, "deletions": 17}, "files": [{"sha": "11512c3fe7acb7d7d380edc0813054df601a4089", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e8ddef93da5f112795eff66ff7dc7ccccc1baa86/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ddef93da5f112795eff66ff7dc7ccccc1baa86/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=e8ddef93da5f112795eff66ff7dc7ccccc1baa86", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use option::*;\n use super::stack::StackSegment;\n use libc::c_void;\n use cast::{transmute, transmute_mut_unsafe,\n@@ -16,17 +17,30 @@ use cast::{transmute, transmute_mut_unsafe,\n // XXX: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n // use an attribute on a struct.\n-pub struct Context(~Registers);\n+// XXX: It would be nice to define regs as `~Option<Registers>` since\n+// the registers are sometimes empty, but the discriminant would\n+// then misalign the regs again.\n+pub struct Context {\n+    /// The context entry point, saved here for later destruction\n+    start: Option<~~fn()>,\n+    /// Hold the registers while the task or scheduler is suspended\n+    regs: ~Registers\n+}\n \n pub impl Context {\n     static fn empty() -> Context {\n-        Context(new_regs())\n+        Context {\n+            start: None,\n+            regs: new_regs()\n+        }\n     }\n \n     /// Create a new context that will resume execution by running ~fn()\n-    /// # Safety Note\n-    /// The `start` closure must remain valid for the life of the Task\n-    static fn new(start: &~fn(), stack: &mut StackSegment) -> Context {\n+    static fn new(start: ~fn(), stack: &mut StackSegment) -> Context {\n+        // XXX: Putting main into a ~ so it's a thin pointer and can\n+        // be passed to the spawn function.  Another unfortunate\n+        // allocation\n+        let start = ~start;\n \n         // The C-ABI function that is the task entry point\n         extern fn task_start_wrapper(f: &~fn()) { (*f)() }\n@@ -46,15 +60,24 @@ pub impl Context {\n \n         initialize_call_frame(&mut *regs, fp, argp, sp);\n \n-        return Context(regs);\n+        return Context {\n+            start: Some(start),\n+            regs: regs\n+        }\n     }\n \n+    /* Switch contexts\n+\n+    Suspend the current execution context and resume another by\n+    saving the registers values of the executing thread to a Context\n+    then loading the registers from a previously saved Context.\n+    */\n     static fn swap(out_context: &mut Context, in_context: &Context) {\n         let out_regs: &mut Registers = match out_context {\n-            &Context(~ref mut r) => r\n+            &Context { regs: ~ref mut r, _ } => r\n         };\n         let in_regs: &Registers = match in_context {\n-            &Context(~ref r) => r\n+            &Context { regs: ~ref r, _ } => r\n         };\n \n         unsafe { swap_registers(out_regs, in_regs) };\n@@ -88,7 +111,7 @@ fn initialize_call_frame(regs: &mut Registers,\n                          fptr: *c_void, arg: *c_void, sp: *mut uint) {\n \n     let sp = align_down(sp);\n-    let sp = mut_offset(sp, -4); // XXX: -4 words? Needs this be done at all?\n+    let sp = mut_offset(sp, -4);\n \n     unsafe { *sp = arg as uint; }\n     let sp = mut_offset(sp, -1);"}, {"sha": "ff0b3d28e8d70b398ec9fd6e48e60ccdfd5e5757", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8ddef93da5f112795eff66ff7dc7ccccc1baa86/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ddef93da5f112795eff66ff7dc7ccccc1baa86/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=e8ddef93da5f112795eff66ff7dc7ccccc1baa86", "patch": "@@ -285,8 +285,6 @@ pub impl Scheduler {\n const TASK_MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n \n pub struct Task {\n-    /// The task entry point, saved here for later destruction\n-    priv start: ~~fn(),\n     /// The segment of stack on which the task is currently running or,\n     /// if the task is blocked, on which the task will resume execution\n     priv current_stack_segment: StackSegment,\n@@ -297,15 +295,11 @@ pub struct Task {\n \n impl Task {\n     static fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n-        // XXX: Putting main into a ~ so it's a thin pointer and can\n-        // be passed to the spawn function.  Another unfortunate\n-        // allocation\n-        let start = ~Task::build_start_wrapper(start);\n+        let start = Task::build_start_wrapper(start);\n         let mut stack = stack_pool.take_segment(TASK_MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n-        let initial_context = Context::new(&*start, &mut stack);\n+        let initial_context = Context::new(start, &mut stack);\n         return Task {\n-            start: start,\n             current_stack_segment: stack,\n             saved_context: initial_context,\n         };"}, {"sha": "ef48025ffe672d2b844a3b1a42dbb0b8f6ad74a7", "filename": "src/libcore/rt/stack.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8ddef93da5f112795eff66ff7dc7ccccc1baa86/src%2Flibcore%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ddef93da5f112795eff66ff7dc7ccccc1baa86/src%2Flibcore%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fstack.rs?ref=e8ddef93da5f112795eff66ff7dc7ccccc1baa86", "patch": "@@ -27,6 +27,7 @@ pub impl StackSegment {\n         }\n     }\n \n+    /// Point one word beyond the high end of the allocated stack\n     fn end(&self) -> *uint {\n         unsafe {\n             vec::raw::to_ptr(self.buf).offset(self.buf.len()) as *uint"}]}