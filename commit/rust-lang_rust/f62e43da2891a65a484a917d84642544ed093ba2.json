{"sha": "f62e43da2891a65a484a917d84642544ed093ba2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MmU0M2RhMjg5MWE2NWE0ODRhOTE3ZDg0NjQyNTQ0ZWQwOTNiYTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-26T11:41:06Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:33Z"}, "message": "rustc: track validity ranges for layout::Abi::Scalar values.", "tree": {"sha": "5b0338f9070e2cbe50dd8bde7b25d74e1b412e4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b0338f9070e2cbe50dd8bde7b25d74e1b412e4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f62e43da2891a65a484a917d84642544ed093ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f62e43da2891a65a484a917d84642544ed093ba2", "html_url": "https://github.com/rust-lang/rust/commit/f62e43da2891a65a484a917d84642544ed093ba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f62e43da2891a65a484a917d84642544ed093ba2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5df25c4aed68a4f761645f63e6ce34ec8c30a75e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5df25c4aed68a4f761645f63e6ce34ec8c30a75e", "html_url": "https://github.com/rust-lang/rust/commit/5df25c4aed68a4f761645f63e6ce34ec8c30a75e"}], "stats": {"total": 513, "additions": 294, "deletions": 219}, "files": [{"sha": "899245b22aaa9dfa292a3e8c569ed365dff060c4", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 186, "deletions": 115, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -416,7 +416,6 @@ impl Align {\n /// Integers, also used for enum discriminants.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum Integer {\n-    I1,\n     I8,\n     I16,\n     I32,\n@@ -427,7 +426,6 @@ pub enum Integer {\n impl<'a, 'tcx> Integer {\n     pub fn size(&self) -> Size {\n         match *self {\n-            I1 => Size::from_bits(1),\n             I8 => Size::from_bytes(1),\n             I16 => Size::from_bytes(2),\n             I32 => Size::from_bytes(4),\n@@ -440,7 +438,6 @@ impl<'a, 'tcx> Integer {\n         let dl = cx.data_layout();\n \n         match *self {\n-            I1 => dl.i1_align,\n             I8 => dl.i8_align,\n             I16 => dl.i16_align,\n             I32 => dl.i32_align,\n@@ -451,13 +448,11 @@ impl<'a, 'tcx> Integer {\n \n     pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, signed: bool) -> Ty<'tcx> {\n         match (*self, signed) {\n-            (I1, false) => tcx.types.u8,\n             (I8, false) => tcx.types.u8,\n             (I16, false) => tcx.types.u16,\n             (I32, false) => tcx.types.u32,\n             (I64, false) => tcx.types.u64,\n             (I128, false) => tcx.types.u128,\n-            (I1, true) => tcx.types.i8,\n             (I8, true) => tcx.types.i8,\n             (I16, true) => tcx.types.i16,\n             (I32, true) => tcx.types.i32,\n@@ -469,7 +464,6 @@ impl<'a, 'tcx> Integer {\n     /// Find the smallest Integer type which can represent the signed value.\n     pub fn fit_signed(x: i128) -> Integer {\n         match x {\n-            -0x0000_0000_0000_0001...0x0000_0000_0000_0000 => I1,\n             -0x0000_0000_0000_0080...0x0000_0000_0000_007f => I8,\n             -0x0000_0000_0000_8000...0x0000_0000_0000_7fff => I16,\n             -0x0000_0000_8000_0000...0x0000_0000_7fff_ffff => I32,\n@@ -481,7 +475,6 @@ impl<'a, 'tcx> Integer {\n     /// Find the smallest Integer type which can represent the unsigned value.\n     pub fn fit_unsigned(x: u128) -> Integer {\n         match x {\n-            0...0x0000_0000_0000_0001 => I1,\n             0...0x0000_0000_0000_00ff => I8,\n             0...0x0000_0000_0000_ffff => I16,\n             0...0x0000_0000_ffff_ffff => I32,\n@@ -621,6 +614,29 @@ impl<'a, 'tcx> Primitive {\n     }\n }\n \n+/// Information about one scalar component of a Rust type.\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Scalar {\n+    pub value: Primitive,\n+\n+    /// Inclusive wrap-around range of valid values, that is, if\n+    /// min > max, it represents min..=u128::MAX followed by 0..=max.\n+    // FIXME(eddyb) always use the shortest range, e.g. by finding\n+    // the largest space between two consecutive valid values and\n+    // taking everything else as the (shortest) valid range.\n+    pub valid_range: RangeInclusive<u128>,\n+}\n+\n+impl Scalar {\n+    pub fn is_bool(&self) -> bool {\n+        if let Int(I8, _) = self.value {\n+            self.valid_range == (0..=1)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n /// The first half of a fat pointer.\n /// - For a trait object, this is the address of the box.\n /// - For a slice, this is the base address.\n@@ -737,9 +753,9 @@ impl FieldPlacement {\n \n /// Describes how values of the type are passed by target ABIs,\n /// in terms of categories of C types there are ABI rules for.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Abi {\n-    Scalar(Primitive),\n+    Scalar(Scalar),\n     Vector,\n     Aggregate {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n@@ -777,13 +793,7 @@ pub enum Variants {\n     /// all space reserved for the discriminant, and their first field starts\n     /// at a non-0 offset, after where the discriminant would go.\n     Tagged {\n-        discr: Primitive,\n-        /// Inclusive wrap-around range of discriminant values, that is,\n-        /// if min > max, it represents min..=u128::MAX followed by 0..=max.\n-        // FIXME(eddyb) always use the shortest range, e.g. by finding\n-        // the largest space between two consecutive discriminants and\n-        // taking everything else as the (shortest) discriminant range.\n-        discr_range: RangeInclusive<u128>,\n+        discr: Scalar,\n         variants: Vec<CachedLayout>,\n     },\n \n@@ -797,7 +807,7 @@ pub enum Variants {\n     /// `Some` is the identity function (with a non-null reference).\n     NicheFilling {\n         dataful_variant: usize,\n-        niche: Primitive,\n+        niche: Scalar,\n         niche_value: u128,\n         variants: Vec<CachedLayout>,\n     }\n@@ -832,6 +842,21 @@ pub struct CachedLayout {\n     pub size: Size\n }\n \n+impl CachedLayout {\n+    fn scalar<C: HasDataLayout>(cx: C, scalar: Scalar) -> Self {\n+        let size = scalar.value.size(cx);\n+        let align = scalar.value.align(cx);\n+        CachedLayout {\n+            variants: Variants::Single { index: 0 },\n+            fields: FieldPlacement::Union(0),\n+            abi: Abi::Scalar(scalar),\n+            size,\n+            align,\n+            primitive_align: align\n+        }\n+    }\n+}\n+\n fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                         -> Result<&'tcx CachedLayout, LayoutError<'tcx>>\n@@ -867,16 +892,14 @@ impl<'a, 'tcx> CachedLayout {\n         let cx = (tcx, param_env);\n         let dl = cx.data_layout();\n         let scalar = |value: Primitive| {\n-            let align = value.align(dl);\n-            tcx.intern_layout(CachedLayout {\n-                variants: Variants::Single { index: 0 },\n-                fields: FieldPlacement::Union(0),\n-                abi: Abi::Scalar(value),\n-                size: value.size(dl),\n-                align,\n-                primitive_align: align\n-            })\n+            let bits = value.size(dl).bits();\n+            assert!(bits <= 128);\n+            tcx.intern_layout(CachedLayout::scalar(cx, Scalar {\n+                value,\n+                valid_range: 0..=(!0 >> (128 - bits))\n+            }))\n         };\n+\n         #[derive(Copy, Clone, Debug)]\n         enum StructKind {\n             /// A tuple, closure, or univariant which cannot be coerced to unsized.\n@@ -1030,7 +1053,12 @@ impl<'a, 'tcx> CachedLayout {\n         let ptr_layout = |pointee: Ty<'tcx>| {\n             let pointee = tcx.normalize_associated_type_in_env(&pointee, param_env);\n             if pointee.is_sized(tcx, param_env, DUMMY_SP) {\n-                return Ok(scalar(Pointer));\n+                let non_zero = !ty.is_unsafe_ptr();\n+                let bits = Pointer.size(dl).bits();\n+                return Ok(tcx.intern_layout(CachedLayout::scalar(cx, Scalar {\n+                    value: Pointer,\n+                    valid_range: (non_zero as u128)..=(!0 >> (128 - bits))\n+                })));\n             }\n \n             let unsized_part = tcx.struct_tail(pointee);\n@@ -1066,8 +1094,18 @@ impl<'a, 'tcx> CachedLayout {\n \n         Ok(match ty.sty {\n             // Basic scalars.\n-            ty::TyBool => scalar(Int(I1, false)),\n-            ty::TyChar => scalar(Int(I32, false)),\n+            ty::TyBool => {\n+                tcx.intern_layout(CachedLayout::scalar(cx, Scalar {\n+                    value: Int(I8, false),\n+                    valid_range: 0..=1\n+                }))\n+            }\n+            ty::TyChar => {\n+                tcx.intern_layout(CachedLayout::scalar(cx, Scalar {\n+                    value: Int(I32, false),\n+                    valid_range: 0..=0x10FFFF\n+                }))\n+            }\n             ty::TyInt(ity) => {\n                 scalar(Int(Integer::from_attr(dl, attr::SignedInt(ity)), true))\n             }\n@@ -1076,7 +1114,13 @@ impl<'a, 'tcx> CachedLayout {\n             }\n             ty::TyFloat(FloatTy::F32) => scalar(F32),\n             ty::TyFloat(FloatTy::F64) => scalar(F64),\n-            ty::TyFnPtr(_) => scalar(Pointer),\n+            ty::TyFnPtr(_) => {\n+                let bits = Pointer.size(dl).bits();\n+                tcx.intern_layout(CachedLayout::scalar(cx, Scalar {\n+                    value: Pointer,\n+                    valid_range: 1..=(!0 >> (128 - bits))\n+                }))\n+            }\n \n             // The never type.\n             ty::TyNever => {\n@@ -1330,22 +1374,26 @@ impl<'a, 'tcx> CachedLayout {\n                                 }\n                                 let offset = st[i].fields.offset(field_index) + offset;\n                                 let CachedLayout {\n-                                    mut abi,\n                                     size,\n                                     mut align,\n                                     mut primitive_align,\n                                     ..\n                                 } = st[i];\n \n-                                let mut niche_align = niche.align(dl);\n-                                if offset.bytes() == 0 && niche.size(dl) == size {\n-                                    abi = Abi::Scalar(niche);\n-                                } else if let Abi::Aggregate { ref mut packed, .. } = abi {\n+                                let mut niche_align = niche.value.align(dl);\n+                                let abi = if offset.bytes() == 0 && niche.value.size(dl) == size {\n+                                    Abi::Scalar(niche.clone())\n+                                } else {\n+                                    let mut packed = st[i].abi.is_packed();\n                                     if offset.abi_align(niche_align) != offset {\n-                                        *packed = true;\n+                                        packed = true;\n                                         niche_align = dl.i8_align;\n                                     }\n-                                }\n+                                    Abi::Aggregate {\n+                                       sized: true,\n+                                       packed\n+                                    }\n+                                };\n                                 align = align.max(niche_align);\n                                 primitive_align = primitive_align.max(niche_align);\n \n@@ -1468,25 +1516,28 @@ impl<'a, 'tcx> CachedLayout {\n                     }\n                 }\n \n-                let discr = Int(ity, signed);\n+                let discr = Scalar {\n+                    value: Int(ity, signed),\n+                    valid_range: (min as u128)..=(max as u128)\n+                };\n+                let abi = if discr.value.size(dl) == size {\n+                    Abi::Scalar(discr.clone())\n+                } else {\n+                    Abi::Aggregate {\n+                        sized: true,\n+                        packed: false\n+                    }\n+                };\n                 tcx.intern_layout(CachedLayout {\n                     variants: Variants::Tagged {\n                         discr,\n-                        discr_range: (min as u128)..=(max as u128),\n                         variants\n                     },\n                     // FIXME(eddyb): using `FieldPlacement::Arbitrary` here results\n                     // in lost optimizations, specifically around allocations, see\n                     // `test/codegen/{alloc-optimisation,vec-optimizes-away}.rs`.\n                     fields: FieldPlacement::Union(1),\n-                    abi: if discr.size(dl) == size {\n-                        Abi::Scalar(discr)\n-                    } else {\n-                        Abi::Aggregate {\n-                            sized: true,\n-                            packed: false\n-                        }\n-                    },\n+                    abi,\n                     align,\n                     primitive_align,\n                     size\n@@ -1650,7 +1701,7 @@ impl<'a, 'tcx> CachedLayout {\n                     })\n                     .collect();\n                 record(adt_kind.into(), match layout.variants {\n-                    Variants::Tagged { discr, .. } => Some(discr.size(tcx)),\n+                    Variants::Tagged { ref discr, .. } => Some(discr.value.size(tcx)),\n                     _ => None\n                 }, variant_infos);\n             }\n@@ -1852,16 +1903,23 @@ impl<'a, 'gcx, 'tcx, T: Copy> HasTyCtxt<'gcx> for (TyCtxt<'a, 'gcx, 'tcx>, T) {\n }\n \n pub trait MaybeResult<T> {\n+    fn from_ok(x: T) -> Self;\n     fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self;\n }\n \n impl<T> MaybeResult<T> for T {\n+    fn from_ok(x: T) -> Self {\n+        x\n+    }\n     fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self {\n         f(self)\n     }\n }\n \n impl<T, E> MaybeResult<T> for Result<T, E> {\n+    fn from_ok(x: T) -> Self {\n+        Ok(x)\n+    }\n     fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self {\n         self.map(f)\n     }\n@@ -1961,7 +2019,13 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n             // (which may have no non-DST form), and will work as long\n             // as the `Abi` or `FieldPlacement` is checked by users.\n             if i == 0 {\n-                return cx.layout_of(Pointer.to_ty(tcx)).map_same(|mut ptr_layout| {\n+                let nil = tcx.mk_nil();\n+                let ptr_ty = if self.ty.is_unsafe_ptr() {\n+                    tcx.mk_mut_ptr(nil)\n+                } else {\n+                    tcx.mk_mut_ref(tcx.types.re_static, nil)\n+                };\n+                return cx.layout_of(ptr_ty).map_same(|mut ptr_layout| {\n                     ptr_layout.ty = self.ty;\n                     ptr_layout\n                 });\n@@ -2042,9 +2106,14 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n                     }\n \n                     // Discriminant field for enums (where applicable).\n-                    Variants::Tagged { discr, .. } |\n-                    Variants::NicheFilling { niche: discr, .. } => {\n-                        return cx.layout_of([discr.to_ty(tcx)][i]);\n+                    Variants::Tagged { ref discr, .. } |\n+                    Variants::NicheFilling { niche: ref discr, .. } => {\n+                        assert_eq!(i, 0);\n+                        let layout = CachedLayout::scalar(tcx, discr.clone());\n+                        return MaybeResult::from_ok(TyLayout {\n+                            cached: tcx.intern_layout(layout),\n+                            ty: discr.value.to_ty(tcx)\n+                        });\n                     }\n                 }\n             }\n@@ -2081,79 +2150,74 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n \n     /// Find the offset of a niche leaf field, starting from\n     /// the given type and recursing through aggregates.\n-    /// The tuple is `(offset, primitive, niche_value)`.\n-    // FIXME(eddyb) track value ranges and traverse already optimized enums.\n+    /// The tuple is `(offset, scalar, niche_value)`.\n+    // FIXME(eddyb) traverse already optimized enums.\n     fn find_niche<C>(&self, cx: C)\n-        -> Result<Option<(Size, Primitive, u128)>, LayoutError<'tcx>>\n+        -> Result<Option<(Size, Scalar, u128)>, LayoutError<'tcx>>\n         where C: LayoutOf<Ty<'tcx>, TyLayout = Result<Self, LayoutError<'tcx>>> +\n                  HasTyCtxt<'tcx>\n     {\n-        let tcx = cx.tcx();\n-        match (&self.variants, self.abi, &self.ty.sty) {\n-            // FIXME(eddyb) check this via value ranges on scalars.\n-            (_, Abi::Scalar(Int(I1, _)), _) => {\n-                Ok(Some((Size::from_bytes(0), Int(I8, false), 2)))\n-            }\n-            (_, Abi::Scalar(Int(I32, _)), &ty::TyChar) => {\n-                Ok(Some((Size::from_bytes(0), Int(I32, false), 0x10FFFF+1)))\n-            }\n-            (_, Abi::Scalar(Pointer), &ty::TyRef(..)) |\n-            (_, Abi::Scalar(Pointer), &ty::TyFnPtr(..)) => {\n-                Ok(Some((Size::from_bytes(0), Pointer, 0)))\n-            }\n-            (_, Abi::Scalar(Pointer), &ty::TyAdt(def, _)) if def.is_box() => {\n-                Ok(Some((Size::from_bytes(0), Pointer, 0)))\n-            }\n-\n-            // FIXME(eddyb) check this via value ranges on scalars.\n-            (&Variants::Tagged { discr, ref discr_range, .. }, _, _) => {\n-                // FIXME(eddyb) support negative/wrap-around discriminant ranges.\n-                if discr_range.start < discr_range.end {\n-                    if discr_range.start > 0 {\n-                        Ok(Some((self.fields.offset(0), discr, 0)))\n-                    } else {\n-                        let bits = discr.size(tcx).bits();\n-                        assert!(bits <= 128);\n-                        let max_value = !0u128 >> (128 - bits);\n-                        if discr_range.end < max_value {\n-                            Ok(Some((self.fields.offset(0), discr, discr_range.end + 1)))\n-                        } else {\n-                            Ok(None)\n-                        }\n-                    }\n+        if let Abi::Scalar(Scalar { value, ref valid_range }) = self.abi {\n+            // FIXME(eddyb) support negative/wrap-around discriminant ranges.\n+            return if valid_range.start < valid_range.end {\n+                let bits = value.size(cx).bits();\n+                assert!(bits <= 128);\n+                let max_value = !0u128 >> (128 - bits);\n+                if valid_range.start > 0 {\n+                    let niche = valid_range.start - 1;\n+                    Ok(Some((self.fields.offset(0), Scalar {\n+                        value,\n+                        valid_range: niche..=valid_range.end\n+                    }, niche)))\n+                } else if valid_range.end < max_value {\n+                    let niche = valid_range.end + 1;\n+                    Ok(Some((self.fields.offset(0), Scalar {\n+                        value,\n+                        valid_range: valid_range.start..=niche\n+                    }, niche)))\n                 } else {\n                     Ok(None)\n                 }\n-            }\n+            } else {\n+                Ok(None)\n+            };\n+        }\n \n-            // Is this the NonZero lang item wrapping a pointer or integer type?\n-            (_, _, &ty::TyAdt(def, _)) if Some(def.did) == tcx.lang_items().non_zero() => {\n+        // Is this the NonZero lang item wrapping a pointer or integer type?\n+        if let ty::TyAdt(def, _) = self.ty.sty {\n+            if Some(def.did) == cx.tcx().lang_items().non_zero() {\n                 let field = self.field(cx, 0)?;\n                 let offset = self.fields.offset(0);\n-                if let Abi::Scalar(value) = field.abi {\n-                    Ok(Some((offset, value, 0)))\n-                } else {\n-                    Ok(None)\n+                if let Abi::Scalar(Scalar { value, ref valid_range }) = field.abi {\n+                    return Ok(Some((offset, Scalar {\n+                        value,\n+                        valid_range: 0..=valid_range.end\n+                    }, 0)));\n                 }\n             }\n+        }\n \n-            // Perhaps one of the fields is non-zero, let's recurse and find out.\n-            _ => {\n-                if let FieldPlacement::Array { count, .. } = self.fields {\n-                    if count > 0 {\n-                        return self.field(cx, 0)?.find_niche(cx);\n-                    }\n-                }\n-                for i in 0..self.fields.count() {\n-                    let r = self.field(cx, i)?.find_niche(cx)?;\n-                    if let Some((offset, primitive, niche_value)) = r {\n-                        let offset = self.fields.offset(i) + offset;\n-                        return Ok(Some((offset, primitive, niche_value)));\n-                    }\n-                }\n-                Ok(None)\n+        // Perhaps one of the fields is non-zero, let's recurse and find out.\n+        if let FieldPlacement::Union(_) = self.fields {\n+            // Only Rust enums have safe-to-inspect fields\n+            // (a discriminant), other unions are unsafe.\n+            if let Variants::Single { .. } = self.variants {\n+                return Ok(None);\n+            }\n+        }\n+        if let FieldPlacement::Array { count, .. } = self.fields {\n+            if count > 0 {\n+                return self.field(cx, 0)?.find_niche(cx);\n             }\n         }\n+        for i in 0..self.fields.count() {\n+            let r = self.field(cx, i)?.find_niche(cx)?;\n+            if let Some((offset, scalar, niche_value)) = r {\n+                let offset = self.fields.offset(i) + offset;\n+                return Ok(Some((offset, scalar, niche_value)));\n+            }\n+        }\n+        Ok(None)\n     }\n }\n \n@@ -2169,13 +2233,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Variants {\n                 index.hash_stable(hcx, hasher);\n             }\n             Tagged {\n-                discr,\n-                discr_range: RangeInclusive { start, end },\n+                ref discr,\n                 ref variants,\n             } => {\n                 discr.hash_stable(hcx, hasher);\n-                start.hash_stable(hcx, hasher);\n-                end.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n             }\n             NicheFilling {\n@@ -2236,6 +2297,17 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Scalar {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Scalar { value, valid_range: RangeInclusive { start, end } } = *self;\n+        value.hash_stable(hcx, hasher);\n+        start.hash_stable(hcx, hasher);\n+        end.hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl_stable_hash_for!(struct ::ty::layout::CachedLayout {\n     variants,\n     fields,\n@@ -2246,7 +2318,6 @@ impl_stable_hash_for!(struct ::ty::layout::CachedLayout {\n });\n \n impl_stable_hash_for!(enum ::ty::layout::Integer {\n-    I1,\n     I8,\n     I16,\n     I32,"}, {"sha": "1356574f646aa73b2ad026b60165661c39e21407", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -753,8 +753,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     bug!(\"failed to get layout for `{}`: {}\", t, e)\n                 });\n \n-                if let layout::Variants::Tagged { ref variants, discr, .. } = layout.variants {\n-                    let discr_size = discr.size(cx.tcx).bytes();\n+                if let layout::Variants::Tagged { ref variants, ref discr, .. } = layout.variants {\n+                    let discr_size = discr.value.size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n                       t, layout.size.bytes(), layout);"}, {"sha": "c87f856b0054efee1678b003be00bdda67f937c0", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -287,8 +287,8 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n     fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n         match self.abi {\n             // The primitive for this algorithm.\n-            layout::Abi::Scalar(value) => {\n-                let kind = match value {\n+            layout::Abi::Scalar(ref scalar) => {\n+                let kind = match scalar.value {\n                     layout::Int(..) |\n                     layout::Pointer => RegKind::Integer,\n                     layout::F32 |\n@@ -471,8 +471,8 @@ impl<'a, 'tcx> ArgType<'tcx> {\n \n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n-        match self.layout.abi {\n-            layout::Abi::Scalar(layout::Int(i, signed)) => {\n+        if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n+            if let layout::Int(i, signed) = scalar.value {\n                 if i.size().bits() < bits {\n                     self.attrs.set(if signed {\n                         ArgAttribute::SExt\n@@ -481,8 +481,6 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                     });\n                 }\n             }\n-\n-            _ => {}\n         }\n     }\n \n@@ -695,9 +693,12 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n         let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n             let mut arg = ArgType::new(ccx.layout_of(ty));\n-            if let layout::Abi::Scalar(layout::Int(layout::I1, _)) = arg.layout.abi {\n-                arg.attrs.set(ArgAttribute::ZExt);\n-            } else if arg.layout.is_zst() {\n+            if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+                if scalar.is_bool() {\n+                    arg.attrs.set(ArgAttribute::ZExt);\n+                }\n+            }\n+            if arg.layout.is_zst() {\n                 // For some forsaken reason, x86_64-pc-windows-gnu\n                 // doesn't ignore zero-sized struct arguments.\n                 // The same is true for s390x-unknown-linux-gnu."}, {"sha": "ff70184b26245cc7620e0c4d2718e6c8556be47a", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -375,11 +375,12 @@ pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n }\n \n pub fn to_immediate(bcx: &Builder, val: ValueRef, layout: layout::TyLayout) -> ValueRef {\n-    if let layout::Abi::Scalar(layout::Int(layout::I1, _)) = layout.abi {\n-        bcx.trunc(val, Type::i1(bcx.ccx))\n-    } else {\n-        val\n+    if let layout::Abi::Scalar(ref scalar) = layout.abi {\n+        if scalar.is_bool() {\n+            return bcx.trunc(val, Type::i1(bcx.ccx));\n+        }\n     }\n+    val\n }\n \n pub fn call_memcpy(b: &Builder,"}, {"sha": "9fb460043ae81d55490f25a3edae5f0054f57d65", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -27,8 +27,12 @@ fn classify_ret_ty(ret: &mut ArgType) {\n fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n-        layout::Abi::Scalar(layout::F32) |\n-        layout::Abi::Scalar(layout::F64) => true,\n+        layout::Abi::Scalar(ref scalar) => {\n+            match scalar.value {\n+                layout::F32 | layout::F64 => true,\n+                _ => false\n+            }\n+        }\n         layout::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(ccx, layout.field(ccx, 0))"}, {"sha": "dc9f681af52f09c2b56c897c96b15d94d70ff2e6", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -22,8 +22,12 @@ pub enum Flavor {\n fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   layout: TyLayout<'tcx>) -> bool {\n     match layout.abi {\n-        layout::Abi::Scalar(layout::F32) |\n-        layout::Abi::Scalar(layout::F64) => true,\n+        layout::Abi::Scalar(ref scalar) => {\n+            match scalar.value {\n+                layout::F32 | layout::F64 => true,\n+                _ => false\n+            }\n+        }\n         layout::Abi::Aggregate { .. } => {\n             if layout.fields.count() == 1 && layout.fields.offset(0).bytes() == 0 {\n                 is_single_fp_element(ccx, layout.field(ccx, 0))"}, {"sha": "bc445c7d2a76d36a350182e3bb4b1d5d4bfbcda0", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -65,8 +65,8 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n         }\n \n         match layout.abi {\n-            layout::Abi::Scalar(value) => {\n-                let reg = match value {\n+            layout::Abi::Scalar(ref scalar) => {\n+                let reg = match scalar.value {\n                     layout::Int(..) |\n                     layout::Pointer => Class::Int,\n                     layout::F32 |"}, {"sha": "e0822b96eeb06dc0bfe6fe69d95a9fdfcc3f9c6b", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -1429,11 +1429,13 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let discriminant_type_metadata = match layout.variants {\n         layout::Variants::Single { .. } |\n         layout::Variants::NicheFilling { .. } => None,\n-        layout::Variants::Tagged { discr, .. } => Some(discriminant_type_metadata(discr)),\n+        layout::Variants::Tagged { ref discr, .. } => {\n+            Some(discriminant_type_metadata(discr.value))\n+        }\n     };\n \n-    match (layout.abi, discriminant_type_metadata) {\n-        (layout::Abi::Scalar(_), Some(discr)) => return FinalMetadata(discr),\n+    match (&layout.abi, discriminant_type_metadata) {\n+        (&layout::Abi::Scalar(_), Some(discr)) => return FinalMetadata(discr),\n         _ => {}\n     }\n "}, {"sha": "f6c4153c183de7203ac492ba5c41c8c3acf2e763", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -26,6 +26,7 @@\n #![feature(i128_type)]\n #![feature(i128)]\n #![feature(inclusive_range)]\n+#![feature(inclusive_range_syntax)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "139c4c656db077832826eb67849f68a547d8494b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -671,10 +671,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                  (align | Alignment::Packed(arg.layout.align))\n                                     .non_abi());\n             } else {\n+                // We can't use `LvalueRef::load` here because the argument\n+                // may have a type we don't treat as immediate, but the ABI\n+                // used for this call is passing it by-value. In that case,\n+                // the load would just produce `OperandValue::Ref` instead\n+                // of the `OperandValue::Immediate` we need for the call.\n                 llval = bcx.load(llval, align.non_abi());\n-            }\n-            if let layout::Abi::Scalar(layout::Int(layout::I1, _)) = arg.layout.abi {\n-                bcx.range_metadata(llval, 0..2);\n+                if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+                    if scalar.is_bool() {\n+                        bcx.range_metadata(llval, 0..2);\n+                    }\n+                }\n                 // We store bools as i8 so we need to truncate to i1.\n                 llval = base::to_immediate(bcx, llval, arg.layout);\n             }"}, {"sha": "7e1569c8f8f5ee1dec53a22922b08aeeda9988c9", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -455,9 +455,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                           Value(base));\n                             }\n                             let layout = self.ccx.layout_of(projected_ty);\n-                            if let layout::Abi::Scalar(layout::Int(layout::I1, _)) = layout.abi {\n+                            if let layout::Abi::Scalar(ref scalar) = layout.abi {\n                                 let i1_type = Type::i1(self.ccx);\n-                                if val_ty(val) != i1_type {\n+                                if scalar.is_bool() && val_ty(val) != i1_type {\n                                     unsafe {\n                                         val = llvm::LLVMConstTrunc(val, i1_type.to_ref());\n                                     }\n@@ -685,10 +685,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         assert!(cast_layout.is_llvm_immediate());\n                         let ll_t_out = cast_layout.immediate_llvm_type(self.ccx);\n                         let llval = operand.llval;\n-                        let signed = match self.ccx.layout_of(operand.ty).abi {\n-                            layout::Abi::Scalar(layout::Int(_, signed)) => signed,\n-                            _ => false\n-                        };\n+\n+                        let mut signed = false;\n+                        let l = self.ccx.layout_of(operand.ty);\n+                        if let layout::Abi::Scalar(ref scalar) = l.abi {\n+                            if let layout::Int(_, true) = scalar.value {\n+                                signed = true;\n+                            }\n+                        }\n \n                         unsafe {\n                             match (r_t_in, r_t_out) {"}, {"sha": "f9a179ee0eeca4fc8c3f76663c9e582a1d6d0db4", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 27, "deletions": 44, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -148,16 +148,29 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 const_llval\n             } else {\n                 let load = bcx.load(self.llval, self.alignment.non_abi());\n-                if self.layout.ty.is_bool() {\n-                    bcx.range_metadata(load, 0..2);\n-                } else if self.layout.ty.is_char() {\n-                    // a char is a Unicode codepoint, and so takes values from 0\n-                    // to 0x10FFFF inclusive only.\n-                    bcx.range_metadata(load, 0..0x10FFFF+1);\n-                } else if self.layout.ty.is_region_ptr() ||\n-                        self.layout.ty.is_box() ||\n-                        self.layout.ty.is_fn() {\n-                    bcx.nonnull_metadata(load);\n+                if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n+                    let (min, max) = (scalar.valid_range.start, scalar.valid_range.end);\n+                    let max_next = max.wrapping_add(1);\n+                    let bits = scalar.value.size(bcx.ccx).bits();\n+                    assert!(bits <= 128);\n+                    let mask = !0u128 >> (128 - bits);\n+                    // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n+                    // However, that is fine here (it would still represent the full range),\n+                    // i.e., if the range is everything.  The lo==hi case would be\n+                    // rejected by the LLVM verifier (it would mean either an\n+                    // empty set, which is impossible, or the entire range of the\n+                    // type, which is pointless).\n+                    match scalar.value {\n+                        layout::Int(..) if max_next & mask != min & mask => {\n+                            // llvm::ConstantRange can deal with ranges that wrap around,\n+                            // so an overflow on (max + 1) is fine.\n+                            bcx.range_metadata(load, min..max_next);\n+                        }\n+                        layout::Pointer if 0 < min && min < max => {\n+                            bcx.nonnull_metadata(load);\n+                        }\n+                        _ => {}\n+                    }\n                 }\n                 load\n             };\n@@ -274,48 +287,18 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let cast_to = bcx.ccx.layout_of(cast_to).immediate_llvm_type(bcx.ccx);\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n-                assert_eq!(index, 0);\n-                return C_uint(cast_to, 0);\n+                return C_uint(cast_to, index as u64);\n             }\n             layout::Variants::Tagged { .. } |\n             layout::Variants::NicheFilling { .. } => {},\n         }\n \n         let discr = self.project_field(bcx, 0);\n-        let discr_scalar = match discr.layout.abi {\n-            layout::Abi::Scalar(discr) => discr,\n-            _ => bug!(\"discriminant not scalar: {:#?}\", discr.layout)\n-        };\n-        let (min, max) = match self.layout.variants {\n-            layout::Variants::Tagged { ref discr_range, .. } => {\n-                (discr_range.start, discr_range.end)\n-            }\n-            _ => (0, !0),\n-        };\n-        let max_next = max.wrapping_add(1);\n-        let bits = discr_scalar.size(bcx.ccx).bits();\n-        assert!(bits <= 128);\n-        let mask = !0u128 >> (128 - bits);\n-        let lldiscr = bcx.load(discr.llval, discr.alignment.non_abi());\n-        match discr_scalar {\n-            // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n-            // However, that is fine here (it would still represent the full range),\n-            layout::Int(..) if max_next & mask != min & mask => {\n-                // llvm::ConstantRange can deal with ranges that wrap around,\n-                // so an overflow on (max + 1) is fine.\n-                bcx.range_metadata(lldiscr, min..max_next);\n-            }\n-            _ => {\n-                // i.e., if the range is everything.  The lo==hi case would be\n-                // rejected by the LLVM verifier (it would mean either an\n-                // empty set, which is impossible, or the entire range of the\n-                // type, which is pointless).\n-            }\n-        };\n+        let lldiscr = discr.load(bcx).immediate();\n         match self.layout.variants {\n             layout::Variants::Single { .. } => bug!(),\n-            layout::Variants::Tagged { .. } => {\n-                let signed = match discr_scalar {\n+            layout::Variants::Tagged { ref discr, .. } => {\n+                let signed = match discr.value {\n                     layout::Int(_, signed) => signed,\n                     _ => false\n                 };"}, {"sha": "e52dcd0756211b395fd274be24d52c5a5b9a906d", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -119,6 +119,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n+                    let v = base::from_immediate(&bcx, v);\n                     if common::val_ty(v) == Type::i8(bcx.ccx) {\n                         base::call_memset(&bcx, start, v, size, align, false);\n                         return bcx;\n@@ -278,28 +279,25 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let ll_t_out = cast.immediate_llvm_type(bcx.ccx);\n                         let llval = operand.immediate();\n \n-                        match operand.layout.variants {\n-                            layout::Variants::Tagged {\n-                                ref discr_range, ..\n-                            } if discr_range.end > discr_range.start => {\n-                                // We want `table[e as usize]` to not\n-                                // have bound checks, and this is the most\n-                                // convenient place to put the `assume`.\n-\n-                                base::call_assume(&bcx, bcx.icmp(\n-                                    llvm::IntULE,\n-                                    llval,\n-                                    C_uint_big(ll_t_in, discr_range.end)\n-                                ));\n+                        let mut signed = false;\n+                        if let layout::Abi::Scalar(ref scalar) = operand.layout.abi {\n+                            if let layout::Int(_, s) = scalar.value {\n+                                signed = s;\n+\n+                                if scalar.valid_range.end > scalar.valid_range.start {\n+                                    // We want `table[e as usize]` to not\n+                                    // have bound checks, and this is the most\n+                                    // convenient place to put the `assume`.\n+\n+                                    base::call_assume(&bcx, bcx.icmp(\n+                                        llvm::IntULE,\n+                                        llval,\n+                                        C_uint_big(ll_t_in, scalar.valid_range.end)\n+                                    ));\n+                                }\n                             }\n-                            _ => {}\n                         }\n \n-                        let signed = match operand.layout.abi {\n-                            layout::Abi::Scalar(layout::Int(_, signed)) => signed,\n-                            _ => false\n-                        };\n-\n                         let newval = match (r_t_in, r_t_out) {\n                             (CastTy::Int(_), CastTy::Int(_)) => {\n                                 bcx.intcast(llval, ll_t_out, signed)"}, {"sha": "2774359c994a53d452c51fb7f813eac9b454ce60", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -268,7 +268,6 @@ impl Type {\n     pub fn from_integer(cx: &CrateContext, i: layout::Integer) -> Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n-            I1 => Type::i1(cx),\n             I8 => Type::i8(cx),\n             I16 => Type::i16(cx),\n             I32 => Type::i32(cx),"}, {"sha": "eab5cb159de39e86c57fa7dfa6fca8334ce94282", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62e43da2891a65a484a917d84642544ed093ba2/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=f62e43da2891a65a484a917d84642544ed093ba2", "patch": "@@ -176,14 +176,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n     fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n-        if let layout::Abi::Scalar(value) = self.abi {\n+        if let layout::Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n             if let Some(&llty) = ccx.scalar_lltypes().borrow().get(&self.ty) {\n                 return llty;\n             }\n-            let llty = match value {\n-                layout::Int(layout::I1, _) => Type::i8(ccx),\n+            let llty = match scalar.value {\n                 layout::Int(i, _) => Type::from_integer(ccx, i),\n                 layout::F32 => Type::f32(ccx),\n                 layout::F64 => Type::f64(ccx),\n@@ -249,11 +248,12 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     }\n \n     fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n-        if let layout::Abi::Scalar(layout::Int(layout::I1, _)) = self.abi {\n-            Type::i1(ccx)\n-        } else {\n-            self.llvm_type(ccx)\n+        if let layout::Abi::Scalar(ref scalar) = self.abi {\n+            if scalar.is_bool() {\n+                return Type::i1(ccx);\n+            }\n         }\n+        self.llvm_type(ccx)\n     }\n \n     fn over_align(&self) -> Option<Align> {"}]}