{"sha": "27c516970bea6bee9d6bca52ac9ad619412809ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YzUxNjk3MGJlYTZiZWU5ZDZiY2E1MmFjOWFkNjE5NDEyODA5ZWY=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-03-19T12:40:25Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-03-20T15:36:29Z"}, "message": "Add test for delim bug", "tree": {"sha": "a28fa39e9c72861524f9d6f263f960d9aab83272", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a28fa39e9c72861524f9d6f263f960d9aab83272"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27c516970bea6bee9d6bca52ac9ad619412809ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27c516970bea6bee9d6bca52ac9ad619412809ef", "html_url": "https://github.com/rust-lang/rust/commit/27c516970bea6bee9d6bca52ac9ad619412809ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27c516970bea6bee9d6bca52ac9ad619412809ef/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92b561b5c7da8303473792ba2bacb430614da2d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/92b561b5c7da8303473792ba2bacb430614da2d1", "html_url": "https://github.com/rust-lang/rust/commit/92b561b5c7da8303473792ba2bacb430614da2d1"}], "stats": {"total": 159, "additions": 147, "deletions": 12}, "files": [{"sha": "0678c37eebc988f0b30e0cf979616de34361a77f", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/27c516970bea6bee9d6bca52ac9ad619412809ef/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c516970bea6bee9d6bca52ac9ad619412809ef/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=27c516970bea6bee9d6bca52ac9ad619412809ef", "patch": "@@ -267,6 +267,108 @@ struct RawConvertor<'a> {\n     inner: std::slice::Iter<'a, Token>,\n }\n \n+trait SrcToken {\n+    fn kind() -> SyntaxKind;\n+}\n+\n+trait TokenConvertor  {\n+    type Token : SrcToken;\n+\n+    fn go(&mut self) -> Option<tt::Subtree> {\n+        let mut subtree = tt::Subtree::default();\n+        subtree.delimiter = None;\n+        while self.peek().is_some() {\n+            self.collect_leaf(&mut subtree.token_trees);\n+        }\n+        if subtree.token_trees.is_empty() {\n+            return None;\n+        }\n+        if subtree.token_trees.len() == 1 {\n+            if let tt::TokenTree::Subtree(first) = &subtree.token_trees[0] {\n+                return Some(first.clone());\n+            }\n+        }\n+        Some(subtree)\n+    }\n+\n+    fn bump(&mut self) -> Option<(Self::Token, TextRange)>;\n+\n+    fn peek(&self) -> Option<Self::Token>;\n+\n+    fn collect_leaf(&mut self, result: &mut Vec<tt::TokenTree>) {\n+        let (token, range) = match self.bump() {\n+            None => return,\n+            Some(it) => it,\n+        };\n+\n+        let k: SyntaxKind = token.kind();\n+        if k == COMMENT {\n+            let node = doc_comment(&self.text[range]);\n+            if let Some(tokens) = convert_doc_comment(&node) {\n+                result.extend(tokens);\n+            }\n+            return;\n+        }\n+\n+        result.push(if k.is_punct() {\n+            let delim = match k {\n+                T!['('] => Some((tt::DelimiterKind::Parenthesis, T![')'])),\n+                T!['{'] => Some((tt::DelimiterKind::Brace, T!['}'])),\n+                T!['['] => Some((tt::DelimiterKind::Bracket, T![']'])),\n+                _ => None,\n+            };\n+\n+            if let Some((kind, closed)) = delim {\n+                let mut subtree = tt::Subtree::default();\n+                let id = self.id_alloc.open_delim(range);\n+                subtree.delimiter = Some(tt::Delimiter { kind, id });\n+\n+                while self.peek().map(|it| it.kind != closed).unwrap_or(false) {\n+                    self.collect_leaf(&mut subtree.token_trees);\n+                }\n+                let last_range = match self.bump() {\n+                    None => return,\n+                    Some(it) => it.1,\n+                };\n+                self.id_alloc.close_delim(id, last_range);\n+                subtree.into()\n+            } else {\n+                let spacing = match self.peek() {\n+                    Some(next)\n+                        if next.kind.is_trivia()\n+                            || next.kind == T!['[']\n+                            || next.kind == T!['{']\n+                            || next.kind == T!['('] =>\n+                    {\n+                        tt::Spacing::Alone\n+                    }\n+                    Some(next) if next.kind.is_punct() => tt::Spacing::Joint,\n+                    _ => tt::Spacing::Alone,\n+                };\n+                let char =\n+                    self.text[range].chars().next().expect(\"Token from lexer must be single char\");\n+\n+                tt::Leaf::from(tt::Punct { char, spacing, id: self.id_alloc.alloc(range) }).into()\n+            }\n+        } else {\n+            macro_rules! make_leaf {\n+                ($i:ident) => {\n+                    tt::$i { id: self.id_alloc.alloc(range), text: self.text[range].into() }.into()\n+                };\n+            }\n+            let leaf: tt::Leaf = match k {\n+                T![true] | T![false] => make_leaf!(Literal),\n+                IDENT | LIFETIME => make_leaf!(Ident),\n+                k if k.is_keyword() => make_leaf!(Ident),\n+                k if k.is_literal() => make_leaf!(Literal),\n+                _ => return,\n+            };\n+\n+            leaf.into()\n+        });\n+    }\n+}\n+\n impl RawConvertor<'_> {\n     fn go(&mut self) -> Option<tt::Subtree> {\n         let mut subtree = tt::Subtree::default();\n@@ -295,6 +397,7 @@ impl RawConvertor<'_> {\n     fn peek(&self) -> Option<Token> {\n         self.inner.as_slice().get(0).cloned()\n     }\n+    \n \n     fn collect_leaf(&mut self, result: &mut Vec<tt::TokenTree>) {\n         let (token, range) = match self.bump() {"}, {"sha": "966af1d1250387573eb7bf6d7473f0e7880b6065", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/27c516970bea6bee9d6bca52ac9ad619412809ef/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c516970bea6bee9d6bca52ac9ad619412809ef/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=27c516970bea6bee9d6bca52ac9ad619412809ef", "patch": "@@ -427,22 +427,28 @@ MACRO_ITEMS@[0; 40)\n     );\n }\n \n-#[test]\n-fn test_expand_literals_to_token_tree() {\n-    fn to_subtree(tt: &tt::TokenTree) -> &tt::Subtree {\n-        if let tt::TokenTree::Subtree(subtree) = tt {\n-            return &subtree;\n-        }\n-        unreachable!(\"It is not a subtree\");\n+fn to_subtree(tt: &tt::TokenTree) -> &tt::Subtree {\n+    if let tt::TokenTree::Subtree(subtree) = tt {\n+        return &subtree;\n     }\n+    unreachable!(\"It is not a subtree\");\n+}\n+fn to_literal(tt: &tt::TokenTree) -> &tt::Literal {\n+    if let tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) = tt {\n+        return lit;\n+    }\n+    unreachable!(\"It is not a literal\");\n+}\n \n-    fn to_literal(tt: &tt::TokenTree) -> &tt::Literal {\n-        if let tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) = tt {\n-            return lit;\n-        }\n-        unreachable!(\"It is not a literal\");\n+fn to_punct(tt: &tt::TokenTree) -> &tt::Punct {\n+    if let tt::TokenTree::Leaf(tt::Leaf::Punct(lit)) = tt {\n+        return lit;\n     }\n+    unreachable!(\"It is not a Punct\");\n+}\n \n+#[test]\n+fn test_expand_literals_to_token_tree() {\n     let expansion = parse_macro(\n         r#\"\n             macro_rules! literals {\n@@ -470,6 +476,22 @@ fn test_expand_literals_to_token_tree() {\n     assert_eq!(to_literal(&stm_tokens[15 + 3]).text, \"\\\"rust1\\\"\");\n }\n \n+#[test]\n+fn test_attr_to_token_tree() {\n+    let expansion = parse_to_token_tree_by_syntax(\n+        r#\"\n+            #[derive(Copy)]\n+            struct Foo;\n+            \"#,\n+    );\n+\n+    assert_eq!(to_punct(&expansion.token_trees[0]).char, '#');\n+    assert_eq!(\n+        to_subtree(&expansion.token_trees[1]).delimiter_kind(),\n+        Some(tt::DelimiterKind::Bracket)\n+    );\n+}\n+\n #[test]\n fn test_two_idents() {\n     parse_macro(\n@@ -1517,6 +1539,16 @@ pub(crate) fn parse_macro(ra_fixture: &str) -> MacroFixture {\n     MacroFixture { rules }\n }\n \n+pub(crate) fn parse_to_token_tree_by_syntax(ra_fixture: &str) -> tt::Subtree {\n+    let source_file = ast::SourceFile::parse(ra_fixture).ok().unwrap();\n+    let tt = syntax_node_to_token_tree(source_file.syntax()).unwrap().0;\n+\n+    let parsed = parse_to_token_tree(ra_fixture).unwrap().0;\n+    assert_eq!(tt, parsed);\n+\n+    parsed\n+}\n+\n fn debug_dump_ignore_spaces(node: &ra_syntax::SyntaxNode) -> String {\n     let mut level = 0;\n     let mut buf = String::new();"}]}