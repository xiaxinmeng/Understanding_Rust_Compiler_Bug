{"sha": "e224f063e8b7ea16302d0b048b9272dfe8465734", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMjRmMDYzZThiN2VhMTYzMDJkMGIwNDhiOTI3MmRmZTg0NjU3MzQ=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-06T20:52:15Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Prefixed type methods & removed trait impl for write::CodegenContext", "tree": {"sha": "0b52a6127d62aea4cf8ab5545aab28b8db210e72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b52a6127d62aea4cf8ab5545aab28b8db210e72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e224f063e8b7ea16302d0b048b9272dfe8465734", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e224f063e8b7ea16302d0b048b9272dfe8465734", "html_url": "https://github.com/rust-lang/rust/commit/e224f063e8b7ea16302d0b048b9272dfe8465734", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e224f063e8b7ea16302d0b048b9272dfe8465734/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d42574b7a22831de97a6ca458f22d011561be56", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d42574b7a22831de97a6ca458f22d011561be56", "html_url": "https://github.com/rust-lang/rust/commit/6d42574b7a22831de97a6ca458f22d011561be56"}], "stats": {"total": 537, "additions": 265, "deletions": 272}, "files": [{"sha": "0d570bc8adabaf78af900b39ad48476bfbdf440b", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -111,16 +111,16 @@ pub trait LlvmType {\n impl LlvmType for Reg {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, '_>) -> &'ll Type {\n         match self.kind {\n-            RegKind::Integer => cx.ix(self.size.bits()),\n+            RegKind::Integer => cx.type_ix(self.size.bits()),\n             RegKind::Float => {\n                 match self.size.bits() {\n-                    32 => cx.f32(),\n-                    64 => cx.f64(),\n+                    32 => cx.type_f32(),\n+                    64 => cx.type_f64(),\n                     _ => bug!(\"unsupported float: {:?}\", self)\n                 }\n             }\n             RegKind::Vector => {\n-                cx.vector(cx.i8(), self.size.bytes())\n+                cx.type_vector(cx.type_i8(), self.size.bytes())\n             }\n         }\n     }\n@@ -144,7 +144,7 @@ impl LlvmType for CastTarget {\n \n             // Simplify to array when all chunks are the same size and type\n             if rem_bytes == 0 {\n-                return cx.array(rest_ll_unit, rest_count);\n+                return cx.type_array(rest_ll_unit, rest_count);\n             }\n         }\n \n@@ -159,10 +159,10 @@ impl LlvmType for CastTarget {\n         if rem_bytes != 0 {\n             // Only integers can be really split further.\n             assert_eq!(self.rest.unit.kind, RegKind::Integer);\n-            args.push(cx.ix(rem_bytes * 8));\n+            args.push(cx.type_ix(rem_bytes * 8));\n         }\n \n-        cx.struct_(&args, false)\n+        cx.type_struct(&args, false)\n     }\n }\n \n@@ -212,7 +212,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n-                let cast_dst = bx.pointercast(dst.llval, cx.ptr_to(cast.llvm_type(cx)));\n+                let cast_dst = bx.pointercast(dst.llval, cx.type_ptr_to(cast.llvm_type(cx)));\n                 bx.store(val, cast_dst, self.layout.align);\n             } else {\n                 // The actual return type is a struct, but the ABI\n@@ -240,9 +240,9 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n \n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bx,\n-                                  bx.pointercast(dst.llval, cx.i8p()),\n+                                  bx.pointercast(dst.llval, cx.type_i8p()),\n                                   self.layout.align,\n-                                  bx.pointercast(llscratch, cx.i8p()),\n+                                  bx.pointercast(llscratch, cx.type_i8p()),\n                                   scratch_align,\n                                   cx.const_usize(self.layout.size.bytes()),\n                                   MemFlags::empty());\n@@ -635,14 +635,14 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         );\n \n         let llreturn_ty = match self.ret.mode {\n-            PassMode::Ignore => cx.void(),\n+            PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 self.ret.layout.immediate_llvm_type(cx)\n             }\n             PassMode::Cast(cast) => cast.llvm_type(cx),\n             PassMode::Indirect(..) => {\n-                llargument_tys.push(cx.ptr_to(self.ret.memory_ty(cx)));\n-                cx.void()\n+                llargument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n+                cx.type_void()\n             }\n         };\n \n@@ -668,15 +668,15 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     continue;\n                 }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),\n-                PassMode::Indirect(_, None) => cx.ptr_to(arg.memory_ty(cx)),\n+                PassMode::Indirect(_, None) => cx.type_ptr_to(arg.memory_ty(cx)),\n             };\n             llargument_tys.push(llarg_ty);\n         }\n \n         if self.variadic {\n-            cx.variadic_func(&llargument_tys, llreturn_ty)\n+            cx.type_variadic_func(&llargument_tys, llreturn_ty)\n         } else {\n-            cx.func(&llargument_tys, llreturn_ty)\n+            cx.type_func(&llargument_tys, llreturn_ty)\n         }\n     }\n "}, {"sha": "0a1cc1e36717217c848dd8c70e50f59c22468756", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -75,9 +75,9 @@ pub fn codegen_inline_asm(\n     // Depending on how many outputs we have, the return type is different\n     let num_outputs = output_types.len();\n     let output_type = match num_outputs {\n-        0 => bx.cx().void(),\n+        0 => bx.cx().type_void(),\n         1 => output_types[0],\n-        _ => bx.cx().struct_(&output_types, false)\n+        _ => bx.cx().type_struct(&output_types, false)\n     };\n \n     let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();"}, {"sha": "6977b1285099281b7e28b3a905ef474cfcebe8ff", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -24,7 +24,7 @@ use rustc::session::config::{self, OutputFilenames, OutputType, Passes, Sanitize\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use time_graph::{self, TimeGraph, Timeline};\n-use llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic, BasicBlock};\n+use llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n use llvm_util;\n use {CodegenResults, ModuleCodegen, CompiledModule, ModuleKind, // ModuleLlvm,\n      CachedModuleCodegen};\n@@ -46,7 +46,6 @@ use syntax_pos::MultiSpan;\n use syntax_pos::symbol::Symbol;\n use type_::Type;\n use context::{is_pie_binary, get_reloc_model};\n-use interfaces::{Backend, CommonWriteMethods};\n use common;\n use jobserver::{Client, Acquired};\n use rustc_demangle;\n@@ -429,15 +428,8 @@ impl CodegenContext<'ll> {\n     }\n }\n \n-impl<'ll> Backend for CodegenContext<'ll> {\n-    type Value = &'ll Value;\n-    type BasicBlock = &'ll BasicBlock;\n-    type Type = &'ll Type;\n-    type Context = &'ll llvm::Context;\n-    type TypeKind = llvm::TypeKind;\n-}\n \n-impl CommonWriteMethods for CodegenContext<'ll> {\n+impl CodegenContext<'ll> {\n     fn val_ty(&self, v: &'ll Value) -> &'ll Type {\n         common::val_ty(v)\n     }\n@@ -446,18 +438,7 @@ impl CommonWriteMethods for CodegenContext<'ll> {\n         common::const_bytes_in_context(llcx, bytes)\n     }\n \n-    fn const_struct_in_context(\n-        &self,\n-        llcx: &'a llvm::Context,\n-        elts: &[&'a Value],\n-        packed: bool,\n-    ) -> &'a Value {\n-        common::const_struct_in_context(llcx, elts, packed)\n-    }\n-}\n-\n-impl CodegenContext<'ll> {\n-    pub fn ptr_to(&self, ty: &'ll Type) -> &'ll Type {\n+    pub fn type_ptr_to(&self, ty: &'ll Type) -> &'ll Type {\n         unsafe {\n             llvm::LLVMPointerType(ty, 0)\n         }"}, {"sha": "0fab55972bf609be86659b568250eb719bfed863", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -234,13 +234,13 @@ pub fn unsize_thin_ptr(\n         (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n          &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().ptr_to(bx.cx().layout_of(b).llvm_type(bx.cx()));\n+            let ptr_ty = bx.cx().type_ptr_to(bx.cx().layout_of(b).llvm_type(bx.cx()));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n             let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n             assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().ptr_to(bx.cx().layout_of(b).llvm_type(bx.cx()));\n+            let ptr_ty = bx.cx().type_ptr_to(bx.cx().layout_of(b).llvm_type(bx.cx()));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n@@ -353,10 +353,10 @@ fn cast_shift_rhs<'ll, F, G>(bx: &Builder<'_, 'll, '_>,\n     if op.is_shift() {\n         let mut rhs_llty = bx.cx().val_ty(rhs);\n         let mut lhs_llty = bx.cx().val_ty(lhs);\n-        if bx.cx().kind(rhs_llty) == TypeKind::Vector {\n+        if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n             rhs_llty = bx.cx().element_type(rhs_llty)\n         }\n-        if bx.cx().kind(lhs_llty) == TypeKind::Vector {\n+        if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n             lhs_llty = bx.cx().element_type(lhs_llty)\n         }\n         let rhs_sz = bx.cx().int_width(rhs_llty);\n@@ -393,8 +393,8 @@ pub fn from_immediate<'a, 'll: 'a, 'tcx: 'll>(\n     bx: &Builder<'_ ,'ll, '_, &'ll Value>,\n     val: &'ll Value\n ) -> &'ll Value {\n-    if bx.cx().val_ty(val) == bx.cx().i1() {\n-        bx.zext(val, bx.cx().i8())\n+    if bx.cx().val_ty(val) == bx.cx().type_i1() {\n+        bx.zext(val, bx.cx().type_i8())\n     } else {\n         val\n     }\n@@ -417,7 +417,7 @@ pub fn to_immediate_scalar(\n     scalar: &layout::Scalar,\n ) -> &'ll Value {\n     if scalar.is_bool() {\n-        return bx.trunc(val, bx.cx().i1());\n+        return bx.trunc(val, bx.cx().type_i1());\n     }\n     val\n }\n@@ -434,13 +434,13 @@ pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll>(\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n         let val = bx.load(src, src_align);\n-        let ptr = bx.pointercast(dst, bx.cx().ptr_to(bx.cx().val_ty(val)));\n+        let ptr = bx.pointercast(dst, bx.cx().type_ptr_to(bx.cx().val_ty(val)));\n         bx.store_with_flags(val, ptr, dst_align, flags);\n         return;\n     }\n     let cx = bx.cx();\n-    let src_ptr = bx.pointercast(src, cx.i8p());\n-    let dst_ptr = bx.pointercast(dst, cx.i8p());\n+    let src_ptr = bx.pointercast(src, cx.type_i8p());\n+    let dst_ptr = bx.pointercast(dst, cx.type_i8p());\n     let size = bx.intcast(n_bytes, cx.isize_ty, false);\n     let volatile = flags.contains(MemFlags::VOLATILE);\n     bx.memcpy(dst_ptr, dst_align.abi(), src_ptr, src_align.abi(), size, volatile);\n@@ -551,7 +551,7 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n         use_start_lang_item: bool,\n     ) {\n         let llfty =\n-            cx.func(&[cx.t_int(), cx.ptr_to(cx.i8p())], cx.t_int());\n+            cx.type_func(&[cx.type_int(), cx.type_ptr_to(cx.type_i8p())], cx.type_int());\n \n         let main_ret_ty = cx.tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -594,15 +594,15 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n                 start_def_id,\n                 cx.tcx.intern_substs(&[main_ret_ty.into()]),\n             );\n-            (start_fn, vec![bx.pointercast(rust_main, cx.ptr_to(cx.i8p())),\n+            (start_fn, vec![bx.pointercast(rust_main, cx.type_ptr_to(cx.type_i8p())),\n                             arg_argc, arg_argv])\n         } else {\n             debug!(\"using user-defined start fn\");\n             (rust_main, vec![arg_argc, arg_argv])\n         };\n \n         let result = bx.call(start_fn, &args, None);\n-        bx.ret(bx.intcast(result, cx.t_int(), true));\n+        bx.ret(bx.intcast(result, cx.type_int(), true));\n     }\n }\n \n@@ -1151,7 +1151,10 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if !cx.used_statics.borrow().is_empty() {\n                 let name = const_cstr!(\"llvm.used\");\n                 let section = const_cstr!(\"llvm.metadata\");\n-                let array = cx.const_array(&cx.ptr_to(cx.i8()), &*cx.used_statics.borrow());\n+                let array = cx.const_array(\n+                    &cx.type_ptr_to(cx.type_i8()),\n+                    &*cx.used_statics.borrow()\n+                );\n \n                 unsafe {\n                     let g = llvm::LLVMAddGlobal(cx.llmod,"}, {"sha": "e55c942f606a25b31b5777e94747a8a4cbcc5f9c", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -765,7 +765,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = &self.cx().func(&argtys[..], output);\n+        let fty = &self.cx().type_func(&argtys[..], output);\n         unsafe {\n             // Ask LLVM to verify that the constraints are well-formed.\n             let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons);\n@@ -861,9 +861,9 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = self.cx.val_ty(elt);\n-            let undef = llvm::LLVMGetUndef(&self.cx().vector(elt_ty, num_elts as u64));\n+            let undef = llvm::LLVMGetUndef(&self.cx().type_vector(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, self.cx.const_i32(0));\n-            let vec_i32_ty = &self.cx().vector(&self.cx().i32(), num_elts as u64);\n+            let vec_i32_ty = &self.cx().type_vector(&self.cx().type_i32(), num_elts as u64);\n             self.shuffle_vector(vec, undef, self.cx().const_null(vec_i32_ty))\n         }\n     }\n@@ -1142,9 +1142,9 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n                        ptr: &'ll Value) -> &'ll Value {\n         let dest_ptr_ty = self.cx.val_ty(ptr);\n         let stored_ty = self.cx.val_ty(val);\n-        let stored_ptr_ty = self.cx.ptr_to(stored_ty);\n+        let stored_ptr_ty = self.cx.type_ptr_to(stored_ty);\n \n-        assert_eq!(self.cx.kind(dest_ptr_ty), llvm::TypeKind::Pointer);\n+        assert_eq!(self.cx.type_kind(dest_ptr_ty), llvm::TypeKind::Pointer);\n \n         if dest_ptr_ty == stored_ptr_ty {\n             ptr\n@@ -1163,14 +1163,14 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n                       args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n         let mut fn_ty = self.cx.val_ty(llfn);\n         // Strip off pointers\n-        while self.cx.kind(fn_ty) == llvm::TypeKind::Pointer {\n+        while self.cx.type_kind(fn_ty) == llvm::TypeKind::Pointer {\n             fn_ty = self.cx.element_type(fn_ty);\n         }\n \n-        assert!(self.cx.kind(fn_ty) == llvm::TypeKind::Function,\n+        assert!(self.cx.type_kind(fn_ty) == llvm::TypeKind::Function,\n                 \"builder::{} not passed a function, but {:?}\", typ, fn_ty);\n \n-        let param_tys = self.cx.func_params(fn_ty);\n+        let param_tys = self.cx.func_params_types(fn_ty);\n \n         let all_args_match = param_tys.iter()\n             .zip(args.iter().map(|&v| self.cx().val_ty(v)))\n@@ -1227,7 +1227,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n         let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n \n-        let ptr = self.pointercast(ptr, self.cx.i8p());\n+        let ptr = self.pointercast(ptr, self.cx.type_i8p());\n         self.call(lifetime_intrinsic, &[self.cx.const_u64(size), ptr], None);\n     }\n "}, {"sha": "fb049b0c9a8bf8bc97759d6a8d4489e7370d4d07", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -236,19 +236,19 @@ impl<'ll, 'tcx: 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn const_bool(&self, val: bool) -> &'ll Value {\n-        &self.const_uint(&self.i1(), val as u64)\n+        &self.const_uint(&self.type_i1(), val as u64)\n     }\n \n     fn const_i32(&self, i: i32) -> &'ll Value {\n-        &self.const_int(&self.i32(), i as i64)\n+        &self.const_int(&self.type_i32(), i as i64)\n     }\n \n     fn const_u32(&self, i: u32) -> &'ll Value {\n-        &self.const_uint(&self.i32(), i as u64)\n+        &self.const_uint(&self.type_i32(), i as u64)\n     }\n \n     fn const_u64(&self, i: u64) -> &'ll Value {\n-        &self.const_uint(&self.i64(), i)\n+        &self.const_uint(&self.type_i64(), i)\n     }\n \n     fn const_usize(&self, i: u64) -> &'ll Value {\n@@ -262,7 +262,7 @@ impl<'ll, 'tcx: 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn const_u8(&self, i: u8) -> &'ll Value {\n-        &self.const_uint(&self.i8(), i as u64)\n+        &self.const_uint(&self.type_i8(), i as u64)\n     }\n \n \n@@ -300,7 +300,7 @@ impl<'ll, 'tcx: 'll> CommonMethods for CodegenCx<'ll, 'tcx> {\n     fn const_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n         let len = s.len();\n         let cs = consts::ptrcast(&self.const_cstr(s, false),\n-            &self.ptr_to(&self.layout_of(&self.tcx.mk_str()).llvm_type(&self)));\n+            &self.type_ptr_to(&self.layout_of(&self.tcx.mk_str()).llvm_type(&self)));\n         &self.const_fat_ptr(cs, &self.const_usize(len as u64))\n     }\n \n@@ -505,7 +505,7 @@ pub fn shift_mask_val(\n     mask_llty: &'ll Type,\n     invert: bool\n ) -> &'ll Value {\n-    let kind = bx.cx().kind(llty);\n+    let kind = bx.cx().type_kind(llty);\n     match kind {\n         TypeKind::Integer => {\n             // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc."}, {"sha": "2bc9ab084352c0feb61704618eae1bf758e5c04f", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -313,8 +313,8 @@ pub fn codegen_static<'a, 'tcx>(\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let mut val_llty = cx.val_ty(v);\n-        let v = if val_llty == cx.i1() {\n-            val_llty = cx.i8();\n+        let v = if val_llty == cx.type_i1() {\n+            val_llty = cx.type_i8();\n             llvm::LLVMConstZExt(v, val_llty)\n         } else {\n             v\n@@ -432,7 +432,7 @@ pub fn codegen_static<'a, 'tcx>(\n \n         if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n             // This static will be stored in the llvm.used variable which is an array of i8*\n-            let cast = llvm::LLVMConstPointerCast(g, cx.i8p());\n+            let cast = llvm::LLVMConstPointerCast(g, cx.type_i8p());\n             cx.used_statics.borrow_mut().push(cast);\n         }\n     }"}, {"sha": "1c25cec35ccece177d72bbba6fee4dbcd7c9426e", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -380,7 +380,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n                 } else {\n                     \"rust_eh_personality\"\n                 };\n-                let fty = &self.variadic_func(&[], &self.i32());\n+                let fty = &self.type_variadic_func(&[], &self.type_i32());\n                 declare::declare_cfn(self, name, fty)\n             }\n         };\n@@ -488,52 +488,52 @@ fn declare_intrinsic(\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, cx.func(&[], $ret));\n+                let f = declare::declare_cfn(cx, $name, cx.type_func(&[], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn(...) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, cx.variadic_func(&[], $ret));\n+                let f = declare::declare_cfn(cx, $name, cx.type_variadic_func(&[], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if key == $name {\n-                let f = declare::declare_cfn(cx, $name, cx.func(&[$($arg),*], $ret));\n+                let f = declare::declare_cfn(cx, $name, cx.type_func(&[$($arg),*], $ret));\n                 llvm::SetUnnamedAddr(f, false);\n                 cx.intrinsics.borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n     }\n     macro_rules! mk_struct {\n-        ($($field_ty:expr),*) => (cx.struct_( &[$($field_ty),*], false))\n+        ($($field_ty:expr),*) => (cx.type_struct( &[$($field_ty),*], false))\n     }\n \n-    let i8p = cx.i8p();\n-    let void = cx.void();\n-    let i1 = cx.i1();\n-    let t_i8 = cx.i8();\n-    let t_i16 = cx.i16();\n-    let t_i32 = cx.i32();\n-    let t_i64 = cx.i64();\n-    let t_i128 = cx.i128();\n-    let t_f32 = cx.f32();\n-    let t_f64 = cx.f64();\n-\n-    let t_v2f32 = cx.vector(t_f32, 2);\n-    let t_v4f32 = cx.vector(t_f32, 4);\n-    let t_v8f32 = cx.vector(t_f32, 8);\n-    let t_v16f32 = cx.vector(t_f32, 16);\n-\n-    let t_v2f64 = cx.vector(t_f64, 2);\n-    let t_v4f64 = cx.vector(t_f64, 4);\n-    let t_v8f64 = cx.vector(t_f64, 8);\n+    let i8p = cx.type_i8p();\n+    let void = cx.type_void();\n+    let i1 = cx.type_i1();\n+    let t_i8 = cx.type_i8();\n+    let t_i16 = cx.type_i16();\n+    let t_i32 = cx.type_i32();\n+    let t_i64 = cx.type_i64();\n+    let t_i128 = cx.type_i128();\n+    let t_f32 = cx.type_f32();\n+    let t_f64 = cx.type_f64();\n+\n+    let t_v2f32 = cx.type_vector(t_f32, 2);\n+    let t_v4f32 = cx.type_vector(t_f32, 4);\n+    let t_v8f32 = cx.type_vector(t_f32, 8);\n+    let t_v16f32 = cx.type_vector(t_f32, 16);\n+\n+    let t_v2f64 = cx.type_vector(t_f64, 2);\n+    let t_v4f64 = cx.type_vector(t_f64, 4);\n+    let t_v8f64 = cx.type_vector(t_f64, 8);\n \n     ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n@@ -786,8 +786,8 @@ fn declare_intrinsic(\n     ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n \n     if cx.sess().opts.debuginfo != DebugInfo::None {\n-        ifn!(\"llvm.dbg.declare\", fn(cx.metadata(), cx.metadata()) -> void);\n-        ifn!(\"llvm.dbg.value\", fn(cx.metadata(), t_i64, cx.metadata()) -> void);\n+        ifn!(\"llvm.dbg.declare\", fn(cx.type_metadata(), cx.type_metadata()) -> void);\n+        ifn!(\"llvm.dbg.value\", fn(cx.type_metadata(), t_i64, cx.type_metadata()) -> void);\n     }\n \n     None"}, {"sha": "a2df65b73b1cf965f11681975e7f4a6fe705a0b6", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -55,7 +55,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n         let section_contents = b\"\\x01gdb_load_rust_pretty_printers.py\\0\";\n \n         unsafe {\n-            let llvm_type = cx.array(cx.i8(),\n+            let llvm_type = cx.type_array(cx.type_i8(),\n                                         section_contents.len() as u64);\n \n             let section_var = declare::define_global(cx, section_var_name,"}, {"sha": "31022140519b72bf6b2365cbb216ae6abcb3486c", "filename": "src/librustc_codegen_llvm/interfaces/type_.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Ftype_.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -11,31 +11,31 @@\n use super::backend::Backend;\n \n pub trait TypeMethods : Backend {\n-    fn void(&self) -> Self::Type;\n-    fn metadata(&self) -> Self::Type;\n-    fn i1(&self) -> Self::Type;\n-    fn i8(&self) -> Self::Type;\n-    fn i16(&self) -> Self::Type;\n-    fn i32(&self) -> Self::Type;\n-    fn i64(&self) -> Self::Type;\n-    fn i128(&self) -> Self::Type;\n-    fn ix(&self, num_bites: u64) -> Self::Type;\n-    fn f32(&self) -> Self::Type;\n-    fn f64(&self) -> Self::Type;\n-    fn x86_mmx(&self) -> Self::Type;\n+    fn type_void(&self) -> Self::Type;\n+    fn type_metadata(&self) -> Self::Type;\n+    fn type_i1(&self) -> Self::Type;\n+    fn type_i8(&self) -> Self::Type;\n+    fn type_i16(&self) -> Self::Type;\n+    fn type_i32(&self) -> Self::Type;\n+    fn type_i64(&self) -> Self::Type;\n+    fn type_i128(&self) -> Self::Type;\n+    fn type_ix(&self, num_bites: u64) -> Self::Type;\n+    fn type_f32(&self) -> Self::Type;\n+    fn type_f64(&self) -> Self::Type;\n+    fn type_x86_mmx(&self) -> Self::Type;\n \n-    fn func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n-    fn variadic_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n-    fn struct_(&self, els: &[Self::Type], packed: bool) -> Self::Type;\n-    fn named_struct(&self, name: &str) -> Self::Type;\n-    fn array(&self, ty: Self::Type, len: u64) -> Self::Type;\n-    fn vector(&self, ty: Self::Type, len: u64) -> Self::Type;\n-    fn kind(&self, ty: Self::Type) -> Self::TypeKind;\n+    fn type_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n+    fn type_variadic_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n+    fn type_struct(&self, els: &[Self::Type], packed: bool) -> Self::Type;\n+    fn type_named_struct(&self, name: &str) -> Self::Type;\n+    fn type_array(&self, ty: Self::Type, len: u64) -> Self::Type;\n+    fn type_vector(&self, ty: Self::Type, len: u64) -> Self::Type;\n+    fn type_kind(&self, ty: Self::Type) -> Self::TypeKind;\n     fn set_struct_body(&self, ty: Self::Type, els: &[Self::Type], packed: bool);\n-    fn ptr_to(&self, ty: Self::Type) -> Self::Type;\n+    fn type_ptr_to(&self, ty: Self::Type) -> Self::Type;\n     fn element_type(&self, ty: Self::Type) -> Self::Type;\n     fn vector_length(&self, ty: Self::Type) -> usize;\n-    fn func_params(&self, ty: Self::Type) -> Vec<Self::Type>;\n+    fn func_params_types(&self, ty: Self::Type) -> Vec<Self::Type>;\n     fn float_width(&self, ty: Self::Type) -> usize;\n     fn int_width(&self, ty: Self::Type) -> u64;\n }"}, {"sha": "0af014ac681daac823d9219f9b1d91ac277f5953", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -252,7 +252,7 @@ pub fn codegen_intrinsic_call(\n             let tp_ty = substs.type_at(0);\n             let mut ptr = args[0].immediate();\n             if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-                ptr = bx.pointercast(ptr, bx.cx().ptr_to(ty.llvm_type(cx)));\n+                ptr = bx.pointercast(ptr, bx.cx().type_ptr_to(ty.llvm_type(cx)));\n             }\n             let load = bx.volatile_load(ptr);\n             let align = if name == \"unaligned_volatile_load\" {\n@@ -338,7 +338,7 @@ pub fn codegen_intrinsic_call(\n                                 args[1].immediate()\n                             ], None);\n                             let val = bx.extract_value(pair, 0);\n-                            let overflow = bx.zext(bx.extract_value(pair, 1), cx.bool());\n+                            let overflow = bx.zext(bx.extract_value(pair, 1), cx.type_bool());\n \n                             let dest = result.project_field(bx, 0);\n                             bx.store(val, dest.llval, dest.align);\n@@ -388,7 +388,7 @@ pub fn codegen_intrinsic_call(\n                             } else {\n                                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n-                                let width = cx.const_uint(cx.ix(width), width);\n+                                let width = cx.const_uint(cx.type_ix(width), width);\n                                 let shift = bx.urem(raw_shift, width);\n                                 let inv_shift = bx.urem(bx.sub(width, raw_shift), width);\n                                 let shift1 = bx.shl(val, if is_left { shift } else { inv_shift });\n@@ -495,7 +495,7 @@ pub fn codegen_intrinsic_call(\n                             failorder,\n                             weak);\n                         let val = bx.extract_value(pair, 0);\n-                        let success = bx.zext(bx.extract_value(pair, 1), bx.cx().bool());\n+                        let success = bx.zext(bx.extract_value(pair, 1), bx.cx().type_bool());\n \n                         let dest = result.project_field(bx, 0);\n                         bx.store(val, dest.llval, dest.align);\n@@ -582,32 +582,32 @@ pub fn codegen_intrinsic_call(\n             fn ty_to_type(cx: &CodegenCx<'ll, '_>, t: &intrinsics::Type) -> Vec<&'ll Type> {\n                 use intrinsics::Type::*;\n                 match *t {\n-                    Void => vec![cx.void()],\n+                    Void => vec![cx.type_void()],\n                     Integer(_signed, _width, llvm_width) => {\n-                        vec![cx.ix( llvm_width as u64)]\n+                        vec![cx.type_ix( llvm_width as u64)]\n                     }\n                     Float(x) => {\n                         match x {\n-                            32 => vec![cx.f32()],\n-                            64 => vec![cx.f64()],\n+                            32 => vec![cx.type_f32()],\n+                            64 => vec![cx.type_f64()],\n                             _ => bug!()\n                         }\n                     }\n                     Pointer(ref t, ref llvm_elem, _const) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n                         let elem = one(ty_to_type(cx, t));\n-                        vec![cx.ptr_to(elem)]\n+                        vec![cx.type_ptr_to(elem)]\n                     }\n                     Vector(ref t, ref llvm_elem, length) => {\n                         let t = llvm_elem.as_ref().unwrap_or(t);\n                         let elem = one(ty_to_type(cx, t));\n-                        vec![cx.vector(elem, length as u64)]\n+                        vec![cx.type_vector(elem, length as u64)]\n                     }\n                     Aggregate(false, ref contents) => {\n                         let elems = contents.iter()\n                                             .map(|t| one(ty_to_type(cx, t)))\n                                             .collect::<Vec<_>>();\n-                        vec![cx.struct_( &elems, false)]\n+                        vec![cx.type_struct( &elems, false)]\n                     }\n                     Aggregate(true, ref contents) => {\n                         contents.iter()\n@@ -646,20 +646,20 @@ pub fn codegen_intrinsic_call(\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n                         let llvm_elem = one(ty_to_type(bx.cx(), llvm_elem));\n-                        vec![bx.pointercast(arg.immediate(), bx.cx().ptr_to(llvm_elem))]\n+                        vec![bx.pointercast(arg.immediate(), bx.cx().type_ptr_to(llvm_elem))]\n                     }\n                     intrinsics::Type::Vector(_, Some(ref llvm_elem), length) => {\n                         let llvm_elem = one(ty_to_type(bx.cx(), llvm_elem));\n                         vec![\n                             bx.bitcast(arg.immediate(),\n-                            bx.cx().vector(llvm_elem, length as u64))\n+                            bx.cx().type_vector(llvm_elem, length as u64))\n                         ]\n                     }\n                     intrinsics::Type::Integer(_, width, llvm_width) if width != llvm_width => {\n                         // the LLVM intrinsic uses a smaller integer\n                         // size than the C intrinsic's signature, so\n                         // we have to trim it down here.\n-                        vec![bx.trunc(arg.immediate(), bx.cx().ix(llvm_width as u64))]\n+                        vec![bx.trunc(arg.immediate(), bx.cx().type_ix(llvm_width as u64))]\n                     }\n                     _ => vec![arg.immediate()],\n                 }\n@@ -681,7 +681,7 @@ pub fn codegen_intrinsic_call(\n                 intrinsics::IntrinsicDef::Named(name) => {\n                     let f = declare::declare_cfn(cx,\n                                                  name,\n-                                                 cx.func(&inputs, outputs));\n+                                                 cx.type_func(&inputs, outputs));\n                     bx.call(f, &llargs, None)\n                 }\n             };\n@@ -705,7 +705,7 @@ pub fn codegen_intrinsic_call(\n \n     if !fn_ty.ret.is_ignore() {\n         if let PassMode::Cast(ty) = fn_ty.ret.mode {\n-            let ptr = bx.pointercast(result.llval, cx.ptr_to(ty.llvm_type(cx)));\n+            let ptr = bx.pointercast(result.llval, cx.type_ptr_to(ty.llvm_type(cx)));\n             bx.store(llval, ptr, result.align);\n         } else {\n             OperandRef::from_immediate_or_packed_pair(bx, llval, result.layout)\n@@ -727,8 +727,8 @@ fn copy_intrinsic(\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = cx.const_usize(size.bytes());\n     let align = align.abi();\n-    let dst_ptr = bx.pointercast(dst, cx.i8p());\n-    let src_ptr = bx.pointercast(src, cx.i8p());\n+    let dst_ptr = bx.pointercast(dst, cx.type_i8p());\n+    let src_ptr = bx.pointercast(src, cx.type_i8p());\n     if allow_overlap {\n         bx.memmove(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n     } else {\n@@ -748,7 +748,7 @@ fn memset_intrinsic(\n     let (size, align) = cx.size_and_align_of(ty);\n     let size = cx.const_usize(size.bytes());\n     let align = cx.const_i32(align.abi() as i32);\n-    let dst = bx.pointercast(dst, cx.i8p());\n+    let dst = bx.pointercast(dst, cx.type_i8p());\n     call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n }\n \n@@ -763,7 +763,7 @@ fn try_intrinsic(\n     if bx.sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        bx.store(cx.const_null(cx.i8p()), dest, ptr_align);\n+        bx.store(cx.const_null(cx.type_i8p()), dest, ptr_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, cx, func, data, local_ptr, dest);\n     } else {\n@@ -839,7 +839,7 @@ fn codegen_msvc_try(\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let i64p = cx.ptr_to(cx.i64());\n+        let i64p = cx.type_ptr_to(cx.type_i64());\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let slot = bx.alloca(i64p, \"slot\", ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n@@ -930,12 +930,12 @@ fn codegen_gnu_try(\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n-        let lpad_ty = cx.struct_(&[cx.i8p(), cx.i32()], false);\n+        let lpad_ty = cx.type_struct(&[cx.type_i8p(), cx.type_i32()], false);\n         let vals = catch.landing_pad(lpad_ty, bx.cx().eh_personality(), 1);\n-        catch.add_clause(vals, bx.cx().const_null(cx.i8p()));\n+        catch.add_clause(vals, bx.cx().const_null(cx.type_i8p()));\n         let ptr = catch.extract_value(vals, 0);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        catch.store(ptr, catch.bitcast(local_ptr, cx.ptr_to(cx.i8p())), ptr_align);\n+        catch.store(ptr, catch.bitcast(local_ptr, cx.type_ptr_to(cx.type_i8p())), ptr_align);\n         catch.ret(cx.const_i32(1));\n     });\n \n@@ -1078,7 +1078,7 @@ fn generic_simd_intrinsic(\n                   found `{}` with length {}\",\n                  in_len, in_ty,\n                  ret_ty, out_len);\n-        require!(bx.cx().kind(bx.cx().element_type(llret_ty)) == TypeKind::Integer,\n+        require!(bx.cx().type_kind(bx.cx().element_type(llret_ty)) == TypeKind::Integer,\n                  \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n                  ret_ty,\n                  ret_ty.simd_type(tcx));\n@@ -1167,8 +1167,8 @@ fn generic_simd_intrinsic(\n             _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty)\n         }\n         // truncate the mask to a vector of i1s\n-        let i1 = bx.cx().i1();\n-        let i1xn = bx.cx().vector(i1, m_len as u64);\n+        let i1 = bx.cx().type_i1();\n+        let i1xn = bx.cx().type_vector(i1, m_len as u64);\n         let m_i1s = bx.trunc(args[0].immediate(), i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n@@ -1300,16 +1300,16 @@ fn generic_simd_intrinsic(\n                       mut no_pointers: usize) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n         let mut elem_ty = match elem_ty.sty {\n-            ty::Int(v) => cx.int_from_ty( v),\n-            ty::Uint(v) => cx.uint_from_ty( v),\n-            ty::Float(v) => cx.float_from_ty( v),\n+            ty::Int(v) => cx.type_int_from_ty( v),\n+            ty::Uint(v) => cx.type_uint_from_ty( v),\n+            ty::Float(v) => cx.type_float_from_ty( v),\n             _ => unreachable!(),\n         };\n         while no_pointers > 0 {\n-            elem_ty = cx.ptr_to(elem_ty);\n+            elem_ty = cx.type_ptr_to(elem_ty);\n             no_pointers -= 1;\n         }\n-        cx.vector(elem_ty, vec_len as u64)\n+        cx.type_vector(elem_ty, vec_len as u64)\n     }\n \n \n@@ -1386,13 +1386,13 @@ fn generic_simd_intrinsic(\n         }\n \n         // Alignment of T, must be a constant integer value:\n-        let alignment_ty = bx.cx().i32();\n+        let alignment_ty = bx.cx().type_i32();\n         let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n-            let i1 = bx.cx().i1();\n-            let i1xn = bx.cx().vector(i1, in_len as u64);\n+            let i1 = bx.cx().type_i1();\n+            let i1xn = bx.cx().type_vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n@@ -1407,7 +1407,7 @@ fn generic_simd_intrinsic(\n         let llvm_intrinsic = format!(\"llvm.masked.gather.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx(), &llvm_intrinsic,\n-                                     bx.cx().func(&[\n+                                     bx.cx().type_func(&[\n                                          llvm_pointer_vec_ty,\n                                          alignment_ty,\n                                          mask_ty,\n@@ -1486,17 +1486,17 @@ fn generic_simd_intrinsic(\n         }\n \n         // Alignment of T, must be a constant integer value:\n-        let alignment_ty = bx.cx().i32();\n+        let alignment_ty = bx.cx().type_i32();\n         let alignment = bx.cx().const_i32(bx.cx().align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n-            let i1 = bx.cx().i1();\n-            let i1xn = bx.cx().vector(i1, in_len as u64);\n+            let i1 = bx.cx().type_i1();\n+            let i1xn = bx.cx().type_vector(i1, in_len as u64);\n             (bx.trunc(args[2].immediate(), i1xn), i1xn)\n         };\n \n-        let ret_t = bx.cx().void();\n+        let ret_t = bx.cx().type_void();\n \n         // Type of the vector of pointers:\n         let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx(), underlying_ty, in_len, pointer_count);\n@@ -1509,7 +1509,7 @@ fn generic_simd_intrinsic(\n         let llvm_intrinsic = format!(\"llvm.masked.scatter.{}.{}\",\n                                      llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = declare::declare_cfn(bx.cx(), &llvm_intrinsic,\n-                                     bx.cx().func(&[llvm_elem_vec_ty,\n+                                     bx.cx().type_func(&[llvm_elem_vec_ty,\n                                                   llvm_pointer_vec_ty,\n                                                   alignment_ty,\n                                                   mask_ty], ret_t));\n@@ -1565,8 +1565,8 @@ fn generic_simd_intrinsic(\n                         } else {\n                             // unordered arithmetic reductions do not:\n                             match f.bit_width() {\n-                                32 => bx.cx().const_undef(bx.cx().f32()),\n-                                64 => bx.cx().const_undef(bx.cx().f64()),\n+                                32 => bx.cx().const_undef(bx.cx().type_f32()),\n+                                64 => bx.cx().const_undef(bx.cx().type_f64()),\n                                 v => {\n                                     return_error!(r#\"\n unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n@@ -1643,8 +1643,8 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n-                    let i1 = bx.cx().i1();\n-                    let i1xn = bx.cx().vector(i1, in_len as u64);\n+                    let i1 = bx.cx().type_i1();\n+                    let i1xn = bx.cx().type_vector(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n                 return match in_elem.sty {\n@@ -1654,7 +1654,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                             if !$boolean {\n                                 r\n                             } else {\n-                                bx.zext(r, bx.cx().bool())\n+                                bx.zext(r, bx.cx().type_bool())\n                             }\n                         )\n                     },"}, {"sha": "73c220dbfda271960bffe3b4f67731e4d8b27ca2", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> VirtualIndex {\n \n         let llvtable = bx.pointercast(\n             llvtable,\n-            bx.cx().ptr_to(fn_ty.ptr_to_llvm_type(bx.cx()))\n+            bx.cx().type_ptr_to(fn_ty.ptr_to_llvm_type(bx.cx()))\n         );\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> VirtualIndex {\n         // Load the data pointer from the object.\n         debug!(\"get_int({:?}, {:?})\", llvtable, self);\n \n-        let llvtable = bx.pointercast(llvtable, bx.cx().ptr_to(bx.cx().isize()));\n+        let llvtable = bx.pointercast(llvtable, bx.cx().type_ptr_to(bx.cx().type_isize()));\n         let usize_align = bx.tcx().data_layout.pointer_align;\n         let ptr = bx.load(\n             bx.inbounds_gep(llvtable, &[bx.cx().const_usize(self.0)]),\n@@ -98,7 +98,7 @@ pub fn get_vtable(\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = cx.const_null(cx.i8p());\n+    let nullptr = cx.const_null(cx.type_i8p());\n \n     let methods = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n     let methods = methods.iter().cloned().map(|opt_mth| {"}, {"sha": "781271ffaa705a106c25948d969b8f6bcfd7514b", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -268,7 +268,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                             }\n                         };\n                         bx.load(\n-                            bx.pointercast(llslot, bx.cx().ptr_to(cast_ty.llvm_type(bx.cx()))),\n+                            bx.pointercast(llslot, bx.cx().type_ptr_to(cast_ty.llvm_type(bx.cx()))),\n                             self.fn_ty.ret.layout.align)\n                     }\n                 };\n@@ -560,7 +560,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            bx.cx().const_undef(bx.cx().ptr_to(fn_ty.ret.memory_ty(bx.cx())))\n+                            bx.cx().const_undef(bx.cx().type_ptr_to(fn_ty.ret.memory_ty(bx.cx())))\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -801,7 +801,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if let PassMode::Cast(ty) = arg.mode {\n-                llval = bx.load(bx.pointercast(llval, bx.cx().ptr_to(ty.llvm_type(bx.cx()))),\n+                llval = bx.load(bx.pointercast(llval, bx.cx().type_ptr_to(ty.llvm_type(bx.cx()))),\n                                 align.min(arg.layout.align));\n             } else {\n                 // We can't use `PlaceRef::load` here because the argument\n@@ -902,7 +902,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n     fn landing_pad_type(&self) -> &'ll Type {\n         let cx = self.cx;\n-        cx.struct_( &[cx.i8p(), cx.i32()], false)\n+        cx.type_struct( &[cx.type_i8p(), cx.type_i32()], false)\n     }\n \n     fn unreachable_block(&mut self) -> &'ll BasicBlock {\n@@ -1014,7 +1014,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                               dst: PlaceRef<'tcx, &'ll Value>) {\n         let src = self.codegen_operand(bx, src);\n         let llty = src.layout.llvm_type(bx.cx());\n-        let cast_ptr = bx.pointercast(dst.llval, bx.cx().ptr_to(llty));\n+        let cast_ptr = bx.pointercast(dst.llval, bx.cx().type_ptr_to(llty));\n         let align = src.layout.align.min(dst.layout.align);\n         src.val.store(bx, PlaceRef::new_sized(cast_ptr, src.layout, align));\n     }"}, {"sha": "0731f27732cf9bd556f6041c3848d6ed0e6f45b2", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -40,11 +40,11 @@ pub fn scalar_to_llvm(\n     match cv {\n         Scalar::Bits { size: 0, .. } => {\n             assert_eq!(0, layout.value.size(cx).bytes());\n-            cx.const_undef(cx.ix(0))\n+            cx.const_undef(cx.type_ix(0))\n         },\n         Scalar::Bits { bits, size } => {\n             assert_eq!(size as u64, layout.value.size(cx).bytes());\n-            let llval = cx.const_uint_big(cx.ix(bitsize), bits);\n+            let llval = cx.const_uint_big(cx.type_ix(bitsize), bits);\n             if layout.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n             } else {\n@@ -72,7 +72,7 @@ pub fn scalar_to_llvm(\n                 None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n             };\n             let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-                consts::bitcast(base_addr, cx.i8p()),\n+                consts::bitcast(base_addr, cx.type_i8p()),\n                 &cx.const_usize(ptr.offset.bytes()),\n                 1,\n             ) };\n@@ -109,7 +109,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n                 value: layout::Primitive::Pointer,\n                 valid_range: 0..=!0\n             },\n-            cx.i8p()\n+            cx.type_i8p()\n         ));\n         next_offset = offset + pointer_size;\n     }"}, {"sha": "4a31b4d3a4ba8dc9bac113ed0edb40855a2717e4", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -419,7 +419,7 @@ fn create_funclets(\n                 // C++ personality function, but `catch (...)` has no type so\n                 // it's null. The 64 here is actually a bitfield which\n                 // represents that this is a catch-all block.\n-                let null = bx.cx().const_null(bx.cx().i8p());\n+                let null = bx.cx().const_null(bx.cx().type_i8p());\n                 let sixty_four = bx.cx().const_i32(64);\n                 cleanup = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n                 cp_bx.br(llbb);"}, {"sha": "be9107160dad2b24a70f536771fb34cc3eb63e08", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -348,7 +348,7 @@ impl OperandValue<&'ll Value> {\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(bx.cx().i8(), llsize, \"unsized_tmp\", max_align);\n+        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, \"unsized_tmp\", max_align);\n         base::call_memcpy(bx, lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place.\n@@ -462,7 +462,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // We've errored, so we don't have to produce working code.\n                         let layout = bx.cx().layout_of(ty);\n                         PlaceRef::new_sized(\n-                            bx.cx().const_undef(bx.cx().ptr_to(layout.llvm_type(bx.cx()))),\n+                            bx.cx().const_undef(bx.cx().type_ptr_to(layout.llvm_type(bx.cx()))),\n                             layout,\n                             layout.align,\n                         ).load(bx)"}, {"sha": "2570be8154e558233caef9b876422758b9d0fb9f", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -67,11 +67,11 @@ impl PlaceRef<'tcx, &'ll Value> {\n         let base_addr = consts::addr_of(bx.cx(), init, layout.align, None);\n \n         let llval = unsafe { LLVMConstInBoundsGEP(\n-            consts::bitcast(base_addr, bx.cx().i8p()),\n+            consts::bitcast(base_addr, bx.cx().type_i8p()),\n             &bx.cx().const_usize(offset.bytes()),\n             1,\n         )};\n-        let llval = consts::bitcast(llval, bx.cx().ptr_to(layout.llvm_type(bx.cx())));\n+        let llval = consts::bitcast(llval, bx.cx().type_ptr_to(layout.llvm_type(bx.cx())));\n         PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n \n@@ -159,7 +159,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 let load = bx.load(llptr, self.align);\n                 scalar_load_metadata(load, scalar);\n                 if scalar.is_bool() {\n-                    bx.trunc(load, bx.cx().i1())\n+                    bx.trunc(load, bx.cx().type_i1())\n                 } else {\n                     load\n                 }\n@@ -196,7 +196,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n             };\n             PlaceRef {\n                 // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                llval: bx.pointercast(llval, cx.ptr_to(field.llvm_type(cx))),\n+                llval: bx.pointercast(llval, cx.type_ptr_to(field.llvm_type(cx))),\n                 llextra: if cx.type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n@@ -265,15 +265,15 @@ impl PlaceRef<'tcx, &'ll Value> {\n         debug!(\"struct_field_ptr: DST field offset: {:?}\", offset);\n \n         // Cast and adjust pointer\n-        let byte_ptr = bx.pointercast(self.llval, cx.i8p());\n+        let byte_ptr = bx.pointercast(self.llval, cx.type_i8p());\n         let byte_ptr = bx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n         let ll_fty = field.llvm_type(cx);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n \n         PlaceRef {\n-            llval: bx.pointercast(byte_ptr, bx.cx().ptr_to(ll_fty)),\n+            llval: bx.pointercast(byte_ptr, bx.cx().type_ptr_to(ll_fty)),\n             llextra: self.llextra,\n             layout: field,\n             align: effective_field_align,\n@@ -379,7 +379,10 @@ impl PlaceRef<'tcx, &'ll Value> {\n                        bx.sess().target.target.arch == \"aarch64\" {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n-                        let llptr = bx.pointercast(self.llval, bx.cx().ptr_to(bx.cx().i8()));\n+                        let llptr = bx.pointercast(\n+                            self.llval,\n+                            bx.cx().type_ptr_to(bx.cx().type_i8())\n+                        );\n                         let fill_byte = bx.cx().const_u8(0);\n                         let (size, align) = self.layout.size_and_align();\n                         let size = bx.cx().const_usize(size.bytes());\n@@ -422,7 +425,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n \n         // Cast to the appropriate variant struct type.\n         let variant_ty = downcast.layout.llvm_type(bx.cx());\n-        downcast.llval = bx.pointercast(downcast.llval, bx.cx().ptr_to(variant_ty));\n+        downcast.llval = bx.pointercast(downcast.llval, bx.cx().type_ptr_to(variant_ty));\n \n         downcast\n     }\n@@ -483,7 +486,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // so we generate an abort\n                         let fnname = bx.cx().get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n-                        let llval = bx.cx().const_undef(bx.cx().ptr_to(layout.llvm_type(bx.cx())));\n+                        let llval = bx.cx().const_undef(\n+                            bx.cx().type_ptr_to(layout.llvm_type(bx.cx()))\n+                        );\n                         PlaceRef::new_sized(llval, layout, layout.align)\n                     }\n                 }\n@@ -543,7 +548,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // Cast the place pointer type to the new\n                         // array or slice type (*[%_; new_len]).\n                         subslice.llval = bx.pointercast(subslice.llval,\n-                            bx.cx().ptr_to(subslice.layout.llvm_type(bx.cx())));\n+                            bx.cx().type_ptr_to(subslice.layout.llvm_type(bx.cx())));\n \n                         subslice\n                     }"}, {"sha": "199bb474dd12bee0e5e7d6a30c5489f1baa3b5e3", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -117,7 +117,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     let v = base::from_immediate(&bx, v);\n-                    if bx.cx().val_ty(v) == bx.cx().i8() {\n+                    if bx.cx().val_ty(v) == bx.cx().type_i8() {\n                         base::call_memset(&bx, start, v, size, align, false);\n                         return bx;\n                     }"}, {"sha": "1ef1417ab4ebfc93f9cabd0b28451552a29c7487", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -43,82 +43,82 @@ impl fmt::Debug for Type {\n \n impl TypeMethods for CodegenCx<'ll, 'tcx> {\n \n-    fn void(&self) -> &'ll Type {\n+    fn type_void(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMVoidTypeInContext(self.llcx)\n         }\n     }\n \n-    fn metadata(&self) -> &'ll Type {\n+    fn type_metadata(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMRustMetadataTypeInContext(self.llcx)\n         }\n     }\n \n-    fn i1(&self) -> &'ll Type {\n+    fn type_i1(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt1TypeInContext(self.llcx)\n         }\n     }\n \n-    fn i8(&self) -> &'ll Type {\n+    fn type_i8(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt8TypeInContext(self.llcx)\n         }\n     }\n \n \n-    fn i16(&self) -> &'ll Type {\n+    fn type_i16(&self) -> &'ll Type {\n         unsafe {\n \n             llvm::LLVMInt16TypeInContext(self.llcx)\n         }\n     }\n \n-    fn i32(&self) -> &'ll Type {\n+    fn type_i32(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt32TypeInContext(self.llcx)\n         }\n     }\n \n-    fn i64(&self) -> &'ll Type {\n+    fn type_i64(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMInt64TypeInContext(self.llcx)\n         }\n     }\n \n-    fn i128(&self) -> &'ll Type {\n+    fn type_i128(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMIntTypeInContext(self.llcx, 128)\n         }\n     }\n \n     // Creates an integer type with the given number of bits, e.g. i24\n-    fn ix(&self, num_bits: u64) -> &'ll Type {\n+    fn type_ix(&self, num_bits: u64) -> &'ll Type {\n         unsafe {\n             llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint)\n         }\n     }\n \n-    fn f32(&self) -> &'ll Type {\n+    fn type_f32(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMFloatTypeInContext(self.llcx)\n         }\n     }\n \n-    fn f64(&self) -> &'ll Type {\n+    fn type_f64(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMDoubleTypeInContext(self.llcx)\n         }\n     }\n \n-    fn x86_mmx(&self) -> &'ll Type {\n+    fn type_x86_mmx(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMX86MMXTypeInContext(self.llcx)\n         }\n     }\n \n-    fn func(\n+    fn type_func(\n         &self,\n         args: &[&'ll Type],\n         ret: &'ll Type\n@@ -129,7 +129,7 @@ impl TypeMethods for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn variadic_func(\n+    fn type_variadic_func(\n         &self,\n         args: &[&'ll Type],\n         ret: &'ll Type\n@@ -140,7 +140,7 @@ impl TypeMethods for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn struct_(\n+    fn type_struct(\n         &self,\n         els: &[&'ll Type],\n         packed: bool\n@@ -152,27 +152,27 @@ impl TypeMethods for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn named_struct(&self, name: &str) -> &'ll Type {\n+    fn type_named_struct(&self, name: &str) -> &'ll Type {\n         let name = SmallCStr::new(name);\n         unsafe {\n             llvm::LLVMStructCreateNamed(self.llcx, name.as_ptr())\n         }\n     }\n \n \n-    fn array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+    fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe {\n             llvm::LLVMRustArrayType(ty, len)\n         }\n     }\n \n-    fn vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+    fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe {\n             llvm::LLVMVectorType(ty, len as c_uint)\n         }\n     }\n \n-    fn kind(&self, ty: &'ll Type) -> TypeKind {\n+    fn type_kind(&self, ty: &'ll Type) -> TypeKind {\n         unsafe {\n             llvm::LLVMRustGetTypeKind(ty)\n         }\n@@ -185,8 +185,8 @@ impl TypeMethods for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn ptr_to(&self, ty: &'ll Type) -> &'ll Type {\n-        assert_ne!(self.kind(ty), TypeKind::Function,\n+    fn type_ptr_to(&self, ty: &'ll Type) -> &'ll Type {\n+        assert_ne!(self.type_kind(ty), TypeKind::Function,\n                    \"don't call ptr_to on function types, use ptr_to_llvm_type on FnType instead\");\n         unsafe {\n             llvm::LLVMPointerType(ty, 0)\n@@ -206,7 +206,7 @@ impl TypeMethods for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn func_params(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n+    fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(ty) as usize;\n             let mut args = Vec::with_capacity(n_args);\n@@ -217,7 +217,7 @@ impl TypeMethods for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn float_width(&self, ty : &'ll Type) -> usize {\n-        match self.kind(ty) {\n+        match self.type_kind(ty) {\n             TypeKind::Float => 32,\n             TypeKind::Double => 64,\n             TypeKind::X86_FP80 => 80,\n@@ -252,96 +252,100 @@ impl Type {\n     }\n \n     pub fn i8p_llcx(cx : &write::CodegenContext<'ll>, llcx: &'ll llvm::Context) -> &'ll Type {\n-        cx.ptr_to(Type::i8_llcx(llcx))\n+        cx.type_ptr_to(Type::i8_llcx(llcx))\n     }\n }\n \n impl CodegenCx<'ll, 'tcx> {\n-    pub fn bool(&self) -> &'ll Type {\n-        self.i8()\n+    pub fn type_bool(&self) -> &'ll Type {\n+        self.type_i8()\n     }\n \n-    pub fn i8p(&self) -> &'ll Type {\n-        self.ptr_to(self.i8())\n+    pub fn type_i8p(&self) -> &'ll Type {\n+        self.type_ptr_to(self.type_i8())\n     }\n \n-    pub fn isize(&self) -> &'ll Type {\n+    pub fn type_isize(&self) -> &'ll Type {\n         self.isize_ty\n     }\n \n-    pub fn t_int(&self) -> &'ll Type {\n+    pub fn type_int(&self) -> &'ll Type {\n         match &self.sess().target.target.target_c_int_width[..] {\n-            \"16\" => self.i16(),\n-            \"32\" => self.i32(),\n-            \"64\" => self.i64(),\n+            \"16\" => self.type_i16(),\n+            \"32\" => self.type_i32(),\n+            \"64\" => self.type_i64(),\n             width => bug!(\"Unsupported target_c_int_width: {}\", width),\n         }\n     }\n \n-    pub fn int_from_ty(\n+    pub fn type_int_from_ty(\n         &self,\n         t: ast::IntTy\n     ) -> &'ll Type {\n         match t {\n             ast::IntTy::Isize => self.isize_ty,\n-            ast::IntTy::I8 => self.i8(),\n-            ast::IntTy::I16 => self.i16(),\n-            ast::IntTy::I32 => self.i32(),\n-            ast::IntTy::I64 => self.i64(),\n-            ast::IntTy::I128 => self.i128(),\n+            ast::IntTy::I8 => self.type_i8(),\n+            ast::IntTy::I16 => self.type_i16(),\n+            ast::IntTy::I32 => self.type_i32(),\n+            ast::IntTy::I64 => self.type_i64(),\n+            ast::IntTy::I128 => self.type_i128(),\n         }\n     }\n \n-    pub fn uint_from_ty(\n+    pub fn type_uint_from_ty(\n         &self,\n         t: ast::UintTy\n     ) -> &'ll Type {\n         match t {\n             ast::UintTy::Usize => self.isize_ty,\n-            ast::UintTy::U8 => self.i8(),\n-            ast::UintTy::U16 => self.i16(),\n-            ast::UintTy::U32 => self.i32(),\n-            ast::UintTy::U64 => self.i64(),\n-            ast::UintTy::U128 => self.i128(),\n+            ast::UintTy::U8 => self.type_i8(),\n+            ast::UintTy::U16 => self.type_i16(),\n+            ast::UintTy::U32 => self.type_i32(),\n+            ast::UintTy::U64 => self.type_i64(),\n+            ast::UintTy::U128 => self.type_i128(),\n         }\n     }\n \n-    pub fn float_from_ty(\n+    pub fn type_float_from_ty(\n         &self,\n         t: ast::FloatTy\n     ) -> &'ll Type {\n         match t {\n-            ast::FloatTy::F32 => self.f32(),\n-            ast::FloatTy::F64 => self.f64(),\n+            ast::FloatTy::F32 => self.type_f32(),\n+            ast::FloatTy::F64 => self.type_f64(),\n         }\n     }\n \n-    pub fn from_integer(&self, i: layout::Integer) -> &'ll Type {\n+    pub fn type_from_integer(&self, i: layout::Integer) -> &'ll Type {\n         use rustc::ty::layout::Integer::*;\n         match i {\n-            I8 => self.i8(),\n-            I16 => self.i16(),\n-            I32 => self.i32(),\n-            I64 => self.i64(),\n-            I128 => self.i128(),\n+            I8 => self.type_i8(),\n+            I16 => self.type_i16(),\n+            I32 => self.type_i32(),\n+            I64 => self.type_i64(),\n+            I128 => self.type_i128(),\n         }\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// as a conservative approximation for unknown pointee types.\n-    pub fn pointee_for_abi_align(&self, align: Align) -> &'ll Type {\n+    pub fn type_pointee_for_abi_align(&self, align: Align) -> &'ll Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n         let ity = layout::Integer::approximate_abi_align(self, align);\n-        self.from_integer(ity)\n+        self.type_from_integer(ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    pub fn padding_filler(&self, size: Size, align: Align) -> &'ll Type {\n+    pub fn type_padding_filler(\n+        &self,\n+        size: Size,\n+        align: Align\n+    ) -> &'ll Type {\n         let unit = layout::Integer::approximate_abi_align(self, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n-        self.array(self.from_integer(unit), size / unit_size)\n+        self.type_array(self.type_from_integer(unit), size / unit_size)\n     }\n }"}, {"sha": "5f961cf125f3af091abb4eb533417677c3e85611", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e224f063e8b7ea16302d0b048b9272dfe8465734/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=e224f063e8b7ea16302d0b048b9272dfe8465734", "patch": "@@ -38,14 +38,14 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                 (cx.sess().target.target.arch == \"x86\" ||\n                  cx.sess().target.target.arch == \"x86_64\");\n             if use_x86_mmx {\n-                return cx.x86_mmx()\n+                return cx.type_x86_mmx()\n             } else {\n                 let element = layout.scalar_llvm_type_at(cx, element, Size::ZERO);\n-                return cx.vector(element, count);\n+                return cx.type_vector(element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n-            return cx.struct_( &[\n+            return cx.type_struct( &[\n                 layout.scalar_pair_element_llvm_type(cx, 0, false),\n                 layout.scalar_pair_element_llvm_type(cx, 1, false),\n             ], false);\n@@ -80,30 +80,30 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let fill = cx.padding_filler( layout.size, layout.align);\n+            let fill = cx.type_padding_filler( layout.size, layout.align);\n             let packed = false;\n             match name {\n                 None => {\n-                    cx.struct_( &[fill], packed)\n+                    cx.type_struct( &[fill], packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = cx.named_struct( name);\n+                    let llty = cx.type_named_struct( name);\n                     cx.set_struct_body(llty, &[fill], packed);\n                     llty\n                 }\n             }\n         }\n         layout::FieldPlacement::Array { count, .. } => {\n-            cx.array(layout.field(cx, 0).llvm_type(cx), count)\n+            cx.type_array(layout.field(cx, 0).llvm_type(cx), count)\n         }\n         layout::FieldPlacement::Arbitrary { .. } => {\n             match name {\n                 None => {\n                     let (llfields, packed) = struct_llfields(cx, layout);\n-                    cx.struct_( &llfields, packed)\n+                    cx.type_struct( &llfields, packed)\n                 }\n                 Some(ref name) => {\n-                    let llty = cx.named_struct( name);\n+                    let llty = cx.type_named_struct( name);\n                     *defer = Some((llty, layout));\n                     llty\n                 }\n@@ -137,7 +137,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         let padding = target_offset - offset;\n         let padding_align = prev_effective_align.min(effective_field_align);\n         assert_eq!(offset.abi_align(padding_align) + padding, target_offset);\n-        result.push(cx.padding_filler( padding, padding_align));\n+        result.push(cx.type_padding_filler( padding, padding_align));\n         debug!(\"    padding before: {:?}\", padding);\n \n         result.push(field.llvm_type(cx));\n@@ -154,7 +154,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         assert_eq!(offset.abi_align(padding_align) + padding, layout.size);\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, layout.size);\n-        result.push(cx.padding_filler(padding, padding_align));\n+        result.push(cx.type_padding_filler(padding, padding_align));\n         assert_eq!(result.len(), 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n@@ -256,10 +256,10 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             let llty = match self.ty.sty {\n                 ty::Ref(_, ty, _) |\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    cx.ptr_to(cx.layout_of(ty).llvm_type(cx))\n+                    cx.type_ptr_to(cx.layout_of(ty).llvm_type(cx))\n                 }\n                 ty::Adt(def, _) if def.is_box() => {\n-                    cx.ptr_to(cx.layout_of(self.ty.boxed_ty()).llvm_type(cx))\n+                    cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).llvm_type(cx))\n                 }\n                 ty::FnPtr(sig) => {\n                     let sig = cx.tcx.normalize_erasing_late_bound_regions(\n@@ -317,7 +317,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn immediate_llvm_type<'a>(&self, cx: &CodegenCx<'a, 'tcx>) -> &'a Type {\n         if let layout::Abi::Scalar(ref scalar) = self.abi {\n             if scalar.is_bool() {\n-                return cx.i1();\n+                return cx.type_i1();\n             }\n         }\n         self.llvm_type(cx)\n@@ -326,17 +326,17 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n     fn scalar_llvm_type_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>,\n                                scalar: &layout::Scalar, offset: Size) -> &'a Type {\n         match scalar.value {\n-            layout::Int(i, _) => cx.from_integer( i),\n-            layout::Float(FloatTy::F32) => cx.f32(),\n-            layout::Float(FloatTy::F64) => cx.f64(),\n+            layout::Int(i, _) => cx.type_from_integer( i),\n+            layout::Float(FloatTy::F32) => cx.type_f32(),\n+            layout::Float(FloatTy::F64) => cx.type_f64(),\n             layout::Pointer => {\n                 // If we know the alignment, pick something better than i8.\n                 let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n-                    cx.pointee_for_abi_align( pointee.align)\n+                    cx.type_pointee_for_abi_align( pointee.align)\n                 } else {\n-                    cx.i8()\n+                    cx.type_i8()\n                 };\n-                cx.ptr_to(pointee)\n+                cx.type_ptr_to(pointee)\n             }\n         }\n     }\n@@ -370,7 +370,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         // when immediate.  We need to load/store `bool` as `i8` to avoid\n         // crippling LLVM optimizations or triggering other LLVM bugs with `i1`.\n         if immediate && scalar.is_bool() {\n-            return cx.i1();\n+            return cx.type_i1();\n         }\n \n         let offset = if index == 0 {"}]}