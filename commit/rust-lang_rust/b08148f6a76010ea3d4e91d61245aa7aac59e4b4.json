{"sha": "b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "node_id": "C_kwDOAAsO6NoAKGIwODE0OGY2YTc2MDEwZWEzZDRlOTFkNjEyNDVhYTdhYWM1OWU0YjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-23T12:47:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-23T12:47:51Z"}, "message": "Auto merge of #111869 - Dylan-DPC:rollup-9pydw08, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #111461 (Fix symbol conflict diagnostic mistakenly being shown instead of missing crate diagnostic)\n - #111579 (Also assume wrap-around discriminants in `as` MIR building)\n - #111704 (Remove return type sized check hack from hir typeck)\n - #111853 (Check opaques for mismatch during writeback)\n - #111854 (rustdoc: clean up `settings.css`)\n - #111860 (Don't ICE if method receiver fails to unify with `arbitrary_self_types`)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "bb3f063f430b4843502fa17bd691aff6f4cbc056", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb3f063f430b4843502fa17bd691aff6f4cbc056"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "html_url": "https://github.com/rust-lang/rust/commit/b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3d597b31c0f101a02c230798afa31a36bdacbc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3d597b31c0f101a02c230798afa31a36bdacbc6", "html_url": "https://github.com/rust-lang/rust/commit/f3d597b31c0f101a02c230798afa31a36bdacbc6"}, {"sha": "c4f2a62182da7d2fce3a961fe12ffb7d72097ca2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2", "html_url": "https://github.com/rust-lang/rust/commit/c4f2a62182da7d2fce3a961fe12ffb7d72097ca2"}], "stats": {"total": 1182, "additions": 615, "deletions": 567}, "files": [{"sha": "e9b5c47ce23c4bef352425b63f5f8e2029362675", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -152,8 +152,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     let guar = ty.error_reported().err().unwrap_or_else(|| {\n                         prev.report_mismatch(\n                             &OpaqueHiddenType { ty, span: concrete_type.span },\n+                            opaque_type_key.def_id,\n                             infcx.tcx,\n                         )\n+                        .emit()\n                     });\n                     prev.ty = infcx.tcx.ty_error(guar);\n                 }"}, {"sha": "074fbb1322c9a2e80a928bdcdee844122ec9d976", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -478,6 +478,7 @@ pub enum StashKey {\n     MaybeFruTypo,\n     CallAssocMethod,\n     TraitMissingMethod,\n+    OpaqueHiddenTypeMismatch,\n }\n \n fn default_track_diagnostic(d: &mut Diagnostic, f: &mut dyn FnMut(&mut Diagnostic)) {"}, {"sha": "97c6cb491d1d6039fa70a09b57cf38acbae28fe0", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -584,7 +584,8 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n                 debug!(?concrete_type, \"found constraint\");\n                 if let Some(prev) = &mut self.found {\n                     if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n-                        let guar = prev.report_mismatch(&concrete_type, self.tcx);\n+                        let guar =\n+                            prev.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n                         prev.ty = self.tcx.ty_error(guar);\n                     }\n                 } else {\n@@ -678,10 +679,10 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n     // Only check against typeck if we didn't already error\n     if !hidden.ty.references_error() {\n         for concrete_type in locator.typeck_types {\n-            if tcx.erase_regions(concrete_type.ty) != tcx.erase_regions(hidden.ty)\n+            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n                 && !(concrete_type, hidden).references_error()\n             {\n-                hidden.report_mismatch(&concrete_type, tcx);\n+                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n             }\n         }\n     }\n@@ -722,7 +723,7 @@ fn find_opaque_ty_constraints_for_rpit(\n                 if concrete_type.ty != self.found.ty\n                     && !(concrete_type, self.found).references_error()\n                 {\n-                    self.found.report_mismatch(&concrete_type, self.tcx);\n+                    self.found.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n                 }\n             }\n         }"}, {"sha": "186ac536c6e5aa5bbb7c409f639af977741375d8", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -103,24 +103,8 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     fcx.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    if let ty::Dynamic(_, _, ty::Dyn) = declared_ret_ty.kind() {\n-        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n-        // been evaluated so that we have types available for all the nodes being returned, but that\n-        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n-        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n-        // while keeping the current ordering we will ignore the tail expression's type because we\n-        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n-        // because we will trigger \"unreachable expression\" lints unconditionally.\n-        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n-        // case that a newcomer might make, returning a bare trait, and in that case we populate\n-        // the tail expression's type so that the suggestion will be correct, but ignore all other\n-        // possible cases.\n-        fcx.check_expr(&body.value);\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    } else {\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-        fcx.check_return_expr(&body.value, false);\n-    }\n+    fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+    fcx.check_return_expr(&body.value, false);\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator."}, {"sha": "98529b66602faa30df3f4bd6a883ab179386a961", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -471,7 +471,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             self_ty, method_self_ty, self.span, pick\n         );\n         let cause = self.cause(\n-            self.span,\n+            self.self_expr.span,\n             ObligationCauseCode::UnifyReceiver(Box::new(UnifyReceiverContext {\n                 assoc_item: pick.item,\n                 param_env: self.param_env,\n@@ -482,13 +482,22 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }\n-            Err(_) => {\n-                span_bug!(\n-                    self.span,\n-                    \"{} was a subtype of {} but now is not?\",\n-                    self_ty,\n-                    method_self_ty\n-                );\n+            Err(terr) => {\n+                // FIXME(arbitrary_self_types): We probably should limit the\n+                // situations where this can occur by adding additional restrictions\n+                // to the feature, like the self type can't reference method substs.\n+                if self.tcx.features().arbitrary_self_types {\n+                    self.err_ctxt()\n+                        .report_mismatched_types(&cause, method_self_ty, self_ty, terr)\n+                        .emit();\n+                } else {\n+                    span_bug!(\n+                        self.span,\n+                        \"{} was a subtype of {} but now is not?\",\n+                        self_ty,\n+                        method_self_ty\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "0f21fc1e662380d506c248a8290fdc474c7f52a1", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -5,7 +5,7 @@\n use crate::FnCtxt;\n use hir::def_id::LocalDefId;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n@@ -82,10 +82,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.typeck_results.treat_byte_string_as_slice =\n             mem::take(&mut self.typeck_results.borrow_mut().treat_byte_string_as_slice);\n \n-        if let Some(e) = self.tainted_by_errors() {\n-            wbcx.typeck_results.tainted_by_errors = Some(e);\n-        }\n-\n         debug!(\"writeback: typeck results for {:?} are {:#?}\", item_def_id, wbcx.typeck_results);\n \n         self.tcx.arena.alloc(wbcx.typeck_results)\n@@ -118,12 +114,21 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     ) -> WritebackCx<'cx, 'tcx> {\n         let owner = body.id().hir_id.owner;\n \n-        WritebackCx {\n+        let mut wbcx = WritebackCx {\n             fcx,\n             typeck_results: ty::TypeckResults::new(owner),\n             body,\n             rustc_dump_user_substs,\n+        };\n+\n+        // HACK: We specifically don't want the (opaque) error from tainting our\n+        // inference context. That'll prevent us from doing opaque type inference\n+        // later on in borrowck, which affects diagnostic spans pretty negatively.\n+        if let Some(e) = fcx.tainted_by_errors() {\n+            wbcx.typeck_results.tainted_by_errors = Some(e);\n         }\n+\n+        wbcx\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -578,13 +583,26 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 continue;\n             }\n \n-            let hidden_type = hidden_type.remap_generic_params_to_declaration_params(\n-                opaque_type_key,\n-                self.fcx.infcx.tcx,\n-                true,\n-            );\n-\n-            self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id, hidden_type);\n+            let hidden_type =\n+                self.tcx().erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n+                    opaque_type_key,\n+                    self.tcx(),\n+                    true,\n+                ));\n+\n+            if let Some(last_opaque_ty) = self\n+                .typeck_results\n+                .concrete_opaque_types\n+                .insert(opaque_type_key.def_id, hidden_type)\n+                && last_opaque_ty.ty != hidden_type.ty\n+            {\n+                hidden_type\n+                    .report_mismatch(&last_opaque_ty, opaque_type_key.def_id, self.tcx())\n+                    .stash(\n+                        self.tcx().def_span(opaque_type_key.def_id),\n+                        StashKey::OpaqueHiddenTypeMismatch,\n+                    );\n+            }\n         }\n     }\n "}, {"sha": "209bf3956243879a1ee409c1efb3cc48f06c20b2", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -148,11 +148,15 @@ impl CStore {\n         assert_eq!(self.metas.len(), self.stable_crate_ids.len());\n         let num = CrateNum::new(self.stable_crate_ids.len());\n         if let Some(&existing) = self.stable_crate_ids.get(&root.stable_crate_id()) {\n-            let crate_name0 = root.name();\n-            if let Some(crate_name1) = self.metas[existing].as_ref().map(|data| data.name()) {\n+            // Check for (potential) conflicts with the local crate\n+            if existing == LOCAL_CRATE {\n+                Err(CrateError::SymbolConflictsCurrent(root.name()))\n+            } else if let Some(crate_name1) = self.metas[existing].as_ref().map(|data| data.name())\n+            {\n+                let crate_name0 = root.name();\n                 Err(CrateError::StableCrateIdCollision(crate_name0, crate_name1))\n             } else {\n-                Err(CrateError::SymbolConflictsCurrent(crate_name0))\n+                Err(CrateError::NotFound(root.name()))\n             }\n         } else {\n             self.metas.push(None);"}, {"sha": "1aab4adf0b3ed7d6e180e8b8e98f192eba9728fc", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -961,6 +961,7 @@ pub(crate) enum CrateError {\n     DlSym(String),\n     LocatorCombined(Box<CombinedLocatorError>),\n     NonDylibPlugin(Symbol),\n+    NotFound(Symbol),\n }\n \n enum MetadataError<'a> {\n@@ -1131,6 +1132,18 @@ impl CrateError {\n             CrateError::NonDylibPlugin(crate_name) => {\n                 sess.emit_err(errors::NoDylibPlugin { span, crate_name });\n             }\n+            CrateError::NotFound(crate_name) => {\n+                sess.emit_err(errors::CannotFindCrate {\n+                    span,\n+                    crate_name,\n+                    add_info: String::new(),\n+                    missing_core,\n+                    current_crate: sess.opts.crate_name.clone().unwrap_or(\"<unknown>\".to_string()),\n+                    is_nightly_build: sess.is_nightly_build(),\n+                    profiler_runtime: Symbol::intern(&sess.opts.unstable_opts.profiler_runtime),\n+                    locator_triple: sess.opts.target_triple.clone(),\n+                });\n+            }\n         }\n     }\n }"}, {"sha": "c9cd644fab0e6b5d94115c6efe3f5bcb8a9f82a4", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -37,7 +37,7 @@ use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, DocLinkResMap, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LocalDefIdMap};\n@@ -1439,14 +1439,26 @@ pub struct OpaqueHiddenType<'tcx> {\n }\n \n impl<'tcx> OpaqueHiddenType<'tcx> {\n-    pub fn report_mismatch(&self, other: &Self, tcx: TyCtxt<'tcx>) -> ErrorGuaranteed {\n+    pub fn report_mismatch(\n+        &self,\n+        other: &Self,\n+        opaque_def_id: LocalDefId,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        if let Some(diag) = tcx\n+            .sess\n+            .diagnostic()\n+            .steal_diagnostic(tcx.def_span(opaque_def_id), StashKey::OpaqueHiddenTypeMismatch)\n+        {\n+            diag.cancel();\n+        }\n         // Found different concrete types for the opaque type.\n         let sub_diag = if self.span == other.span {\n             TypeMismatchReason::ConflictType { span: self.span }\n         } else {\n             TypeMismatchReason::PreviousUse { span: self.span }\n         };\n-        tcx.sess.emit_err(OpaqueHiddenTypeMismatch {\n+        tcx.sess.create_err(OpaqueHiddenTypeMismatch {\n             self_ty: self.ty,\n             other_ty: other.ty,\n             other_span: other.span,"}, {"sha": "e04dbbff9a777b452c85195d369e0744caf72229", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -151,10 +151,14 @@ pub struct TypeckResults<'tcx> {\n     /// this field will be set to `Some(ErrorGuaranteed)`.\n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n \n-    /// All the opaque types that have hidden types set\n-    /// by this function. We also store the\n-    /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n-    /// even if they are only set in dead code (which doesn't show up in MIR).\n+    /// All the opaque types that have hidden types set by this function.\n+    /// We also store the type here, so that the compiler can use it as a hint\n+    /// for figuring out hidden types, even if they are only set in dead code\n+    /// (which doesn't show up in MIR).\n+    ///\n+    /// These types are mapped back to the opaque's identity substitutions\n+    /// (with erased regions), which is why we don't associated substs with any\n+    /// of these usages.\n     pub concrete_opaque_types: FxIndexMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;"}, {"sha": "bcab4c0d24b5fae0502df9e6f88a3f64462878b3", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::mir::Place;\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::cast::{mir_cast_kind, CastTy};\n+use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Ty, UpvarSubsts};\n use rustc_span::Span;\n \n@@ -225,49 +226,63 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n                     let (op,ty) = (Operand::Move(discr), discr_ty);\n \n-                    if let Abi::Scalar(scalar) = layout.unwrap().abi{\n-                        if let Primitive::Int(_, signed) = scalar.primitive() {\n-                            let range = scalar.valid_range(&this.tcx);\n-                            // FIXME: Handle wraparound cases too.\n-                            if range.end >= range.start {\n-                                let mut assumer = |range: u128, bin_op: BinOp| {\n-                                    // We will be overwriting this val if our scalar is signed value\n-                                    // because sign extension on unsigned types might cause unintended things\n-                                    let mut range_val =\n-                                        ConstantKind::from_bits(this.tcx, range, ty::ParamEnv::empty().and(discr_ty));\n-                                    let bool_ty = this.tcx.types.bool;\n-                                    if signed {\n-                                        let scalar_size_extend = scalar.size(&this.tcx).sign_extend(range);\n-                                        let discr_layout = this.tcx.layout_of(this.param_env.and(discr_ty));\n-                                        let truncated_val = discr_layout.unwrap().size.truncate(scalar_size_extend);\n-                                        range_val = ConstantKind::from_bits(\n-                                            this.tcx,\n-                                            truncated_val,\n-                                            ty::ParamEnv::empty().and(discr_ty),\n-                                        );\n-                                    }\n-                                    let lit_op = this.literal_operand(expr.span, range_val);\n-                                    let is_bin_op = this.temp(bool_ty, expr_span);\n-                                    this.cfg.push_assign(\n-                                        block,\n-                                        source_info,\n-                                        is_bin_op,\n-                                        Rvalue::BinaryOp(bin_op, Box::new(((lit_op), (Operand::Copy(discr))))),\n-                                    );\n-                                    this.cfg.push(\n-                                        block,\n-                                        Statement {\n-                                            source_info,\n-                                            kind: StatementKind::Intrinsic(Box::new(NonDivergingIntrinsic::Assume(\n-                                                Operand::Copy(is_bin_op),\n-                                            ))),\n-                                        },\n-                                    )\n-                                };\n-                                assumer(range.end, BinOp::Ge);\n-                                assumer(range.start, BinOp::Le);\n-                            }\n-                        }\n+                    if let Abi::Scalar(scalar) = layout.unwrap().abi\n+                        && !scalar.is_always_valid(&this.tcx)\n+                        && let Primitive::Int(int_width, _signed) = scalar.primitive()\n+                    {\n+                        let unsigned_ty = int_width.to_ty(this.tcx, false);\n+                        let unsigned_place = this.temp(unsigned_ty, expr_span);\n+                        this.cfg.push_assign(\n+                            block,\n+                            source_info,\n+                            unsigned_place,\n+                            Rvalue::Cast(CastKind::IntToInt, Operand::Copy(discr), unsigned_ty));\n+\n+                        let bool_ty = this.tcx.types.bool;\n+                        let range = scalar.valid_range(&this.tcx);\n+                        let merge_op =\n+                            if range.start <= range.end {\n+                                BinOp::BitAnd\n+                            } else {\n+                                BinOp::BitOr\n+                            };\n+\n+                        let mut comparer = |range: u128, bin_op: BinOp| -> Place<'tcx> {\n+                            let range_val =\n+                                ConstantKind::from_bits(this.tcx, range, ty::ParamEnv::empty().and(unsigned_ty));\n+                            let lit_op = this.literal_operand(expr.span, range_val);\n+                            let is_bin_op = this.temp(bool_ty, expr_span);\n+                            this.cfg.push_assign(\n+                                block,\n+                                source_info,\n+                                is_bin_op,\n+                                Rvalue::BinaryOp(bin_op, Box::new((Operand::Copy(unsigned_place), lit_op))),\n+                            );\n+                            is_bin_op\n+                        };\n+                        let assert_place = if range.start == 0 {\n+                            comparer(range.end, BinOp::Le)\n+                        } else {\n+                            let start_place = comparer(range.start, BinOp::Ge);\n+                            let end_place = comparer(range.end, BinOp::Le);\n+                            let merge_place = this.temp(bool_ty, expr_span);\n+                            this.cfg.push_assign(\n+                                block,\n+                                source_info,\n+                                merge_place,\n+                                Rvalue::BinaryOp(merge_op, Box::new((Operand::Move(start_place), Operand::Move(end_place)))),\n+                            );\n+                            merge_place\n+                        };\n+                        this.cfg.push(\n+                            block,\n+                            Statement {\n+                                source_info,\n+                                kind: StatementKind::Intrinsic(Box::new(NonDivergingIntrinsic::Assume(\n+                                    Operand::Move(assert_place),\n+                                ))),\n+                            },\n+                        );\n                     }\n \n                     (op,ty)"}, {"sha": "dc43a3d154ab3e9d270b28aa93c681f4b08bf368", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -885,7 +885,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             return;\n                         }\n \n-                        if self.suggest_impl_trait(&mut err, span, &obligation, trait_predicate) {\n+                        if self.suggest_impl_trait(&mut err, &obligation, trait_predicate) {\n                             err.emit();\n                             return;\n                         }"}, {"sha": "83511e898f70c8e3999b307a1b447d5972cdaaa0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 48, "deletions": 229, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -30,9 +30,9 @@ use rustc_middle::hir::map;\n use rustc_middle::ty::error::TypeError::{self, Sorts};\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind,\n-    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, InternalSubsts,\n-    IsSuggestable, ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder,\n-    TypeSuperFoldable, TypeVisitableExt, TypeckResults,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, InferTy, InternalSubsts, IsSuggestable,\n+    ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitableExt, TypeckResults,\n };\n use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -261,7 +261,6 @@ pub trait TypeErrCtxtExt<'tcx> {\n     fn suggest_impl_trait(\n         &self,\n         err: &mut Diagnostic,\n-        span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n@@ -1792,215 +1791,66 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn suggest_impl_trait(\n         &self,\n         err: &mut Diagnostic,\n-        span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n-        match obligation.cause.code().peel_derives() {\n-            // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n-            ObligationCauseCode::SizedReturnType => {}\n-            _ => return false,\n-        }\n-\n-        let hir = self.tcx.hir();\n-        let fn_hir_id = hir.local_def_id_to_hir_id(obligation.cause.body_id);\n-        let node = hir.find_by_def_id(obligation.cause.body_id);\n-        let Some(hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(sig, _, body_id),\n-            ..\n-        })) = node\n-        else {\n+        let ObligationCauseCode::SizedReturnType = obligation.cause.code() else {\n             return false;\n         };\n-        let body = hir.body(*body_id);\n-        let trait_pred = self.resolve_vars_if_possible(trait_pred);\n-        let ty = trait_pred.skip_binder().self_ty();\n-        let is_object_safe = match ty.kind() {\n-            ty::Dynamic(predicates, _, ty::Dyn) => {\n-                // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n-                predicates\n-                    .principal_def_id()\n-                    .map_or(true, |def_id| self.tcx.check_is_object_safe(def_id))\n-            }\n-            // We only want to suggest `impl Trait` to `dyn Trait`s.\n-            // For example, `fn foo() -> str` needs to be filtered out.\n-            _ => return false,\n-        };\n-\n-        let hir::FnRetTy::Return(ret_ty) = sig.decl.output else {\n+        let ty::Dynamic(_, _, ty::Dyn) = trait_pred.self_ty().skip_binder().kind() else {\n             return false;\n         };\n \n-        // Use `TypeVisitor` instead of the output type directly to find the span of `ty` for\n-        // cases like `fn foo() -> (dyn Trait, i32) {}`.\n-        // Recursively look for `TraitObject` types and if there's only one, use that span to\n-        // suggest `impl Trait`.\n-\n-        // Visit to make sure there's a single `return` type to suggest `impl Trait`,\n-        // otherwise suggest using `Box<dyn Trait>` or an enum.\n-        let mut visitor = ReturnsVisitor::default();\n-        visitor.visit_body(&body);\n-\n-        let typeck_results = self.typeck_results.as_ref().unwrap();\n-        let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id).copied() else { return false; };\n-\n-        let ret_types = visitor\n-            .returns\n-            .iter()\n-            .filter_map(|expr| Some((expr.span, typeck_results.node_type_opt(expr.hir_id)?)))\n-            .map(|(expr_span, ty)| (expr_span, self.resolve_vars_if_possible(ty)));\n-        let (last_ty, all_returns_have_same_type, only_never_return) = ret_types.clone().fold(\n-            (None, true, true),\n-            |(last_ty, mut same, only_never_return): (std::option::Option<Ty<'_>>, bool, bool),\n-             (_, ty)| {\n-                let ty = self.resolve_vars_if_possible(ty);\n-                same &=\n-                    !matches!(ty.kind(), ty::Error(_))\n-                        && last_ty.map_or(true, |last_ty| {\n-                            // FIXME: ideally we would use `can_coerce` here instead, but `typeck` comes\n-                            // *after* in the dependency graph.\n-                            match (ty.kind(), last_ty.kind()) {\n-                                (Infer(InferTy::IntVar(_)), Infer(InferTy::IntVar(_)))\n-                                | (Infer(InferTy::FloatVar(_)), Infer(InferTy::FloatVar(_)))\n-                                | (Infer(InferTy::FreshIntTy(_)), Infer(InferTy::FreshIntTy(_)))\n-                                | (\n-                                    Infer(InferTy::FreshFloatTy(_)),\n-                                    Infer(InferTy::FreshFloatTy(_)),\n-                                ) => true,\n-                                _ => ty == last_ty,\n-                            }\n-                        });\n-                (Some(ty), same, only_never_return && matches!(ty.kind(), ty::Never))\n-            },\n-        );\n-        let mut spans_and_needs_box = vec![];\n-\n-        match liberated_sig.output().kind() {\n-            ty::Dynamic(predicates, _, ty::Dyn) => {\n-                let cause = ObligationCause::misc(ret_ty.span, obligation.cause.body_id);\n-                let param_env = ty::ParamEnv::empty();\n-\n-                if !only_never_return {\n-                    for (expr_span, return_ty) in ret_types {\n-                        let self_ty_satisfies_dyn_predicates = |self_ty| {\n-                            predicates.iter().all(|predicate| {\n-                                let pred = predicate.with_self_ty(self.tcx, self_ty);\n-                                let obl = Obligation::new(self.tcx, cause.clone(), param_env, pred);\n-                                self.predicate_may_hold(&obl)\n-                            })\n-                        };\n-\n-                        if let ty::Adt(def, substs) = return_ty.kind()\n-                            && def.is_box()\n-                            && self_ty_satisfies_dyn_predicates(substs.type_at(0))\n-                        {\n-                            spans_and_needs_box.push((expr_span, false));\n-                        } else if self_ty_satisfies_dyn_predicates(return_ty) {\n-                            spans_and_needs_box.push((expr_span, true));\n-                        } else {\n-                            return false;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => return false,\n-        };\n-\n-        let sm = self.tcx.sess.source_map();\n-        if !ret_ty.span.overlaps(span) {\n-            return false;\n-        }\n-        let snippet = if let hir::TyKind::TraitObject(..) = ret_ty.kind {\n-            if let Ok(snippet) = sm.span_to_snippet(ret_ty.span) {\n-                snippet\n-            } else {\n-                return false;\n-            }\n-        } else {\n-            // Substitute the type, so we can print a fixup given `type Alias = dyn Trait`\n-            let name = liberated_sig.output().to_string();\n-            let name =\n-                name.strip_prefix('(').and_then(|name| name.strip_suffix(')')).unwrap_or(&name);\n-            if !name.starts_with(\"dyn \") {\n-                return false;\n-            }\n-            name.to_owned()\n-        };\n-\n         err.code(error_code!(E0746));\n         err.set_primary_message(\"return type cannot have an unboxed trait object\");\n         err.children.clear();\n-        let impl_trait_msg = \"for information on `impl Trait`, see \\\n-            <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-            #returning-types-that-implement-traits>\";\n-        let trait_obj_msg = \"for information on trait objects, see \\\n-            <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n-            #using-trait-objects-that-allow-for-values-of-different-types>\";\n-\n-        let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n-        let trait_obj = if has_dyn { &snippet[4..] } else { &snippet };\n-        if only_never_return {\n-            // No return paths, probably using `panic!()` or similar.\n-            // Suggest `-> impl Trait`, and if `Trait` is object safe, `-> Box<dyn Trait>`.\n-            suggest_trait_object_return_type_alternatives(\n-                err,\n-                ret_ty.span,\n-                trait_obj,\n-                is_object_safe,\n-            );\n-        } else if let (Some(last_ty), true) = (last_ty, all_returns_have_same_type) {\n-            // Suggest `-> impl Trait`.\n+\n+        let span = obligation.cause.span;\n+        if let Ok(snip) = self.tcx.sess.source_map().span_to_snippet(span)\n+            && snip.starts_with(\"dyn \")\n+        {\n             err.span_suggestion(\n-                ret_ty.span,\n-                format!(\n-                    \"use `impl {1}` as the return type, as all return paths are of type `{}`, \\\n-                     which implements `{1}`\",\n-                    last_ty, trait_obj,\n-                ),\n-                format!(\"impl {}\", trait_obj),\n-                Applicability::MachineApplicable,\n+                span.with_hi(span.lo() + BytePos(4)),\n+                \"return an `impl Trait` instead of a `dyn Trait`, \\\n+                if all returned values are the same type\",\n+                \"impl \",\n+                Applicability::MaybeIncorrect,\n             );\n-            err.note(impl_trait_msg);\n-        } else {\n-            if is_object_safe {\n-                // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n-                err.multipart_suggestion(\n-                    \"return a boxed trait object instead\",\n-                    vec![\n-                        (ret_ty.span.shrink_to_lo(), \"Box<\".to_string()),\n-                        (span.shrink_to_hi(), \">\".to_string()),\n-                    ],\n-                    Applicability::MaybeIncorrect,\n-                );\n-                for (span, needs_box) in spans_and_needs_box {\n-                    if needs_box {\n-                        err.multipart_suggestion(\n-                            \"... and box this value\",\n-                            vec![\n-                                (span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n+        }\n+\n+        let body = self.tcx.hir().body(self.tcx.hir().body_owned_by(obligation.cause.body_id));\n+\n+        let mut visitor = ReturnsVisitor::default();\n+        visitor.visit_body(&body);\n+\n+        let mut sugg =\n+            vec![(span.shrink_to_lo(), \"Box<\".to_string()), (span.shrink_to_hi(), \">\".to_string())];\n+        sugg.extend(visitor.returns.into_iter().flat_map(|expr| {\n+            let span = expr.span.find_ancestor_in_same_ctxt(obligation.cause.span).unwrap_or(expr.span);\n+            if !span.can_be_used_for_suggestions() {\n+                vec![]\n+            } else if let hir::ExprKind::Call(path, ..) = expr.kind\n+                && let hir::ExprKind::Path(hir::QPath::TypeRelative(ty, method)) = path.kind\n+                && method.ident.name == sym::new\n+                && let hir::TyKind::Path(hir::QPath::Resolved(.., box_path)) = ty.kind\n+                && box_path.res.opt_def_id().is_some_and(|def_id| Some(def_id) == self.tcx.lang_items().owned_box())\n+            {\n+                // Don't box `Box::new`\n+                vec![]\n             } else {\n-                // This is currently not possible to trigger because E0038 takes precedence, but\n-                // leave it in for completeness in case anything changes in an earlier stage.\n-                err.note(format!(\n-                    \"if trait `{}` were object-safe, you could return a trait object\",\n-                    trait_obj,\n-                ));\n+                vec![\n+                    (span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                    (span.shrink_to_hi(), \")\".to_string()),\n+                ]\n             }\n-            err.note(trait_obj_msg);\n-            err.note(format!(\n-                \"if all the returned values were of the same type you could use `impl {}` as the \\\n-                 return type\",\n-                trait_obj,\n-            ));\n-            err.note(impl_trait_msg);\n-            err.note(\"you can create a new `enum` with a variant for each returned type\");\n-        }\n+        }));\n+\n+        err.multipart_suggestion(\n+            \"box the return type, and wrap all of the returned values in `Box::new`\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+\n         true\n     }\n \n@@ -4139,37 +3989,6 @@ impl NextTypeParamName for &[hir::GenericParam<'_>] {\n     }\n }\n \n-fn suggest_trait_object_return_type_alternatives(\n-    err: &mut Diagnostic,\n-    ret_ty: Span,\n-    trait_obj: &str,\n-    is_object_safe: bool,\n-) {\n-    err.span_suggestion(\n-        ret_ty,\n-        format!(\n-            \"use `impl {}` as the return type if all return paths have the same type but you \\\n-                want to expose only the trait in the signature\",\n-            trait_obj,\n-        ),\n-        format!(\"impl {}\", trait_obj),\n-        Applicability::MaybeIncorrect,\n-    );\n-    if is_object_safe {\n-        err.multipart_suggestion(\n-            format!(\n-                \"use a boxed trait object if all return paths implement trait `{}`\",\n-                trait_obj,\n-            ),\n-            vec![\n-                (ret_ty.shrink_to_lo(), \"Box<\".to_string()),\n-                (ret_ty.shrink_to_hi(), \">\".to_string()),\n-            ],\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-}\n-\n /// Collect the spans that we see the generic param `param_did`\n struct ReplaceImplTraitVisitor<'a> {\n     ty_spans: &'a mut Vec<Span>,"}, {"sha": "c1324c0760e63a662e27e0531d9daf5b9201ad67", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -1,6 +1,5 @@\n .setting-line {\n \tmargin: 1.2em 0.6em;\n-\tposition: relative;\n }\n \n .setting-radio input, .setting-check input {\n@@ -15,11 +14,6 @@\n .setting-radio input {\n \tborder-radius: 50%;\n }\n-.setting-check input:checked {\n-\tcontent: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 40 40\">\\\n-\t\t<path d=\"M7,25L17,32L33,12\" fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>\\\n-\t\t<path d=\"M7,23L17,30L33,10\" fill=\"none\" stroke=\"white\" stroke-width=\"5\"/></svg>');\n-}\n \n .setting-radio span, .setting-check span {\n \tpadding-bottom: 1px;\n@@ -52,6 +46,9 @@\n .setting-check input:checked {\n \tbackground-color: var(--settings-input-color);\n \tborder-width: 1px;\n+\tcontent: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 40 40\">\\\n+\t\t<path d=\"M7,25L17,32L33,12\" fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>\\\n+\t\t<path d=\"M7,23L17,30L33,10\" fill=\"none\" stroke=\"white\" stroke-width=\"5\"/></svg>');\n }\n .setting-radio input:focus, .setting-check input:focus {\n \tbox-shadow: 0 0 1px 1px var(--settings-input-color);"}, {"sha": "f5d88de76ddf5f76197ec20666d7facb5b5c4095", "filename": "tests/assembly/option-nonzero-eq.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fassembly%2Foption-nonzero-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fassembly%2Foption-nonzero-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Foption-nonzero-eq.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,28 @@\n+// revisions: WIN LIN\n+// [WIN] only-windows\n+// [LIN] only-linux\n+// assembly-output: emit-asm\n+// compile-flags: --crate-type=lib -O -C llvm-args=-x86-asm-syntax=intel\n+// only-x86_64\n+// ignore-sgx\n+// ignore-debug\n+\n+use std::cmp::Ordering;\n+\n+// CHECK-lABEL: ordering_eq:\n+#[no_mangle]\n+pub fn ordering_eq(l: Option<Ordering>, r: Option<Ordering>) -> bool {\n+    // Linux (System V): first two arguments are rdi then rsi\n+    // Windows: first two arguments are rcx then rdx\n+    // Both use rax for the return value.\n+\n+    // CHECK-NOT: mov\n+    // CHECK-NOT: test\n+    // CHECK-NOT: cmp\n+\n+    // LIN: cmp dil, sil\n+    // WIN: cmp cl, dl\n+    // CHECK-NEXT: sete al\n+    // CHECK-NEXT: ret\n+    l == r\n+}"}, {"sha": "a394695f3bd65c3e521fdec05785b3e9c02ccd58", "filename": "tests/codegen/option-nonzero-eq.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fcodegen%2Foption-nonzero-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fcodegen%2Foption-nonzero-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Foption-nonzero-eq.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -7,6 +7,9 @@ use core::cmp::Ordering;\n use core::num::{NonZeroU32, NonZeroI64};\n use core::ptr::NonNull;\n \n+// See also tests/assembly/option-nonzero-eq.rs, for cases with `assume`s in the\n+// LLVM and thus don't optimize down clearly here, but do in assembly.\n+\n // CHECK-lABEL: @non_zero_eq\n #[no_mangle]\n pub fn non_zero_eq(l: Option<NonZeroU32>, r: Option<NonZeroU32>) -> bool {\n@@ -33,12 +36,3 @@ pub fn non_null_eq(l: Option<NonNull<u8>>, r: Option<NonNull<u8>>) -> bool {\n     // CHECK-NEXT: ret i1\n     l == r\n }\n-\n-// CHECK-lABEL: @ordering_eq\n-#[no_mangle]\n-pub fn ordering_eq(l: Option<Ordering>, r: Option<Ordering>) -> bool {\n-    // CHECK: start:\n-    // CHECK-NEXT: icmp eq i8\n-    // CHECK-NEXT: ret i1\n-    l == r\n-}"}, {"sha": "9f14c02846547503ad764a3883b84b5fb321ab7f", "filename": "tests/mir-opt/building/enum_cast.bar.built.after.mir", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.bar.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.bar.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.bar.built.after.mir?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -5,17 +5,16 @@ fn bar(_1: Bar) -> usize {\n     let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:+0:21: +0:26\n     let _2: Bar;                         // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n     let mut _3: isize;                   // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n-    let mut _4: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+    let mut _4: u8;                      // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n     let mut _5: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n \n     bb0: {\n         StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n         _2 = move _1;                    // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n         _3 = discriminant(_2);           // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n-        _4 = Ge(const 1_isize, _3);      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n-        assume(_4);                      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n-        _5 = Le(const 0_isize, _3);      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n-        assume(_5);                      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _4 = _3 as u8 (IntToInt);        // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _5 = Le(_4, const 1_u8);         // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        assume(move _5);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n         _0 = move _3 as usize (IntToInt); // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n         StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:16: +1:17\n         return;                          // scope 0 at $DIR/enum_cast.rs:+2:2: +2:2"}, {"sha": "715dedcf24deb999ee5d82a2e17c662f41097645", "filename": "tests/mir-opt/building/enum_cast.boo.built.after.mir", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.boo.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.boo.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.boo.built.after.mir?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -5,17 +5,16 @@ fn boo(_1: Boo) -> usize {\n     let mut _0: usize;                   // return place in scope 0 at $DIR/enum_cast.rs:+0:21: +0:26\n     let _2: Boo;                         // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n     let mut _3: u8;                      // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n-    let mut _4: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+    let mut _4: u8;                      // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n     let mut _5: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n \n     bb0: {\n         StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n         _2 = move _1;                    // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n         _3 = discriminant(_2);           // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n-        _4 = Ge(const 1_u8, _3);         // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n-        assume(_4);                      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n-        _5 = Le(const 0_u8, _3);         // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n-        assume(_5);                      // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _4 = _3 as u8 (IntToInt);        // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _5 = Le(_4, const 1_u8);         // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        assume(move _5);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n         _0 = move _3 as usize (IntToInt); // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n         StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:16: +1:17\n         return;                          // scope 0 at $DIR/enum_cast.rs:+2:2: +2:2"}, {"sha": "6c177c61ecad8042be71107f39a3f7ecd6cbc593", "filename": "tests/mir-opt/building/enum_cast.droppy.built.after.mir", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.droppy.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.droppy.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.droppy.built.after.mir?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -6,7 +6,7 @@ fn droppy() -> () {\n     let _2: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:+2:13: +2:14\n     let _4: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:+5:17: +5:18\n     let mut _5: isize;                   // in scope 0 at $DIR/enum_cast.rs:+5:17: +5:18\n-    let mut _6: bool;                    // in scope 0 at $DIR/enum_cast.rs:+5:17: +5:27\n+    let mut _6: u8;                      // in scope 0 at $DIR/enum_cast.rs:+5:17: +5:27\n     let mut _7: bool;                    // in scope 0 at $DIR/enum_cast.rs:+5:17: +5:27\n     let _8: Droppy;                      // in scope 0 at $DIR/enum_cast.rs:+7:9: +7:10\n     scope 1 {\n@@ -31,10 +31,9 @@ fn droppy() -> () {\n         StorageLive(_4);                 // scope 3 at $DIR/enum_cast.rs:+5:17: +5:18\n         _4 = move _2;                    // scope 3 at $DIR/enum_cast.rs:+5:17: +5:18\n         _5 = discriminant(_4);           // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n-        _6 = Ge(const 2_isize, _5);      // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n-        assume(_6);                      // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n-        _7 = Le(const 0_isize, _5);      // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n-        assume(_7);                      // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n+        _6 = _5 as u8 (IntToInt);        // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n+        _7 = Le(_6, const 2_u8);         // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n+        assume(move _7);                 // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n         _3 = move _5 as usize (IntToInt); // scope 3 at $DIR/enum_cast.rs:+5:17: +5:27\n         drop(_4) -> [return: bb1, unwind: bb4]; // scope 3 at $DIR/enum_cast.rs:+5:26: +5:27\n     }"}, {"sha": "ab8129ca01cfca925f0d1b9f2abe38ab645ff49b", "filename": "tests/mir-opt/building/enum_cast.far.built.after.mir", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.far.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.far.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.far.built.after.mir?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,22 @@\n+// MIR for `far` after built\n+\n+fn far(_1: Far) -> isize {\n+    debug far => _1;                     // in scope 0 at $DIR/enum_cast.rs:+0:8: +0:11\n+    let mut _0: isize;                   // return place in scope 0 at $DIR/enum_cast.rs:+0:21: +0:26\n+    let _2: Far;                         // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n+    let mut _3: i16;                     // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n+    let mut _4: u16;                     // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+    let mut _5: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n+        _2 = move _1;                    // scope 0 at $DIR/enum_cast.rs:+1:5: +1:8\n+        _3 = discriminant(_2);           // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _4 = _3 as u16 (IntToInt);       // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _5 = Le(_4, const 1_u16);        // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        assume(move _5);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        _0 = move _3 as isize (IntToInt); // scope 0 at $DIR/enum_cast.rs:+1:5: +1:17\n+        StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:16: +1:17\n+        return;                          // scope 0 at $DIR/enum_cast.rs:+2:2: +2:2\n+    }\n+}"}, {"sha": "7b2b583f20fb9cd669b84c4f2fc29b71199f4ead", "filename": "tests/mir-opt/building/enum_cast.offsetty.built.after.mir", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.offsetty.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.offsetty.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.offsetty.built.after.mir?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,26 @@\n+// MIR for `offsetty` after built\n+\n+fn offsetty(_1: NotStartingAtZero) -> u32 {\n+    debug x => _1;                       // in scope 0 at $DIR/enum_cast.rs:+0:13: +0:14\n+    let mut _0: u32;                     // return place in scope 0 at $DIR/enum_cast.rs:+0:38: +0:41\n+    let _2: NotStartingAtZero;           // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:6\n+    let mut _3: isize;                   // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:6\n+    let mut _4: u8;                      // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+    let mut _5: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+    let mut _6: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+    let mut _7: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:6\n+        _2 = move _1;                    // scope 0 at $DIR/enum_cast.rs:+1:5: +1:6\n+        _3 = discriminant(_2);           // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _4 = _3 as u8 (IntToInt);        // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _5 = Ge(_4, const 4_u8);         // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _6 = Le(_4, const 8_u8);         // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _7 = BitAnd(move _5, move _6);   // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        assume(move _7);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _0 = move _3 as u32 (IntToInt);  // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:12: +1:13\n+        return;                          // scope 0 at $DIR/enum_cast.rs:+2:2: +2:2\n+    }\n+}"}, {"sha": "431b5c708b929bfdc832839798209c4d989b7511", "filename": "tests/mir-opt/building/enum_cast.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -1,6 +1,7 @@\n // EMIT_MIR enum_cast.foo.built.after.mir\n // EMIT_MIR enum_cast.bar.built.after.mir\n // EMIT_MIR enum_cast.boo.built.after.mir\n+// EMIT_MIR enum_cast.far.built.after.mir\n \n enum Foo {\n     A\n@@ -15,6 +16,11 @@ enum Boo {\n     A, B\n }\n \n+#[repr(i16)]\n+enum Far {\n+    A, B\n+}\n+\n fn foo(foo: Foo) -> usize {\n     foo as usize\n }\n@@ -27,6 +33,10 @@ fn boo(boo: Boo) -> usize {\n     boo as usize\n }\n \n+fn far(far: Far) -> isize {\n+    far as isize\n+}\n+\n // EMIT_MIR enum_cast.droppy.built.after.mir\n enum Droppy {\n     A, B, C\n@@ -46,5 +56,37 @@ fn droppy() {\n     let z = Droppy::B;\n }\n \n+#[repr(i16)]\n+enum SignedAroundZero {\n+    A = -2,\n+    B = 0,\n+    C = 2,\n+}\n+\n+#[repr(u16)]\n+enum UnsignedAroundZero {\n+    A = 65535,\n+    B = 0,\n+    C = 1,\n+}\n+\n+// EMIT_MIR enum_cast.signy.built.after.mir\n+fn signy(x: SignedAroundZero) -> i16 {\n+    x as i16\n+}\n+\n+// EMIT_MIR enum_cast.unsigny.built.after.mir\n+fn unsigny(x: UnsignedAroundZero) -> u16 {\n+    // FIXME: This doesn't get an around-the-end range today, sadly.\n+    x as u16\n+}\n+\n+enum NotStartingAtZero { A = 4, B = 6, C = 8 }\n+\n+// EMIT_MIR enum_cast.offsetty.built.after.mir\n+fn offsetty(x: NotStartingAtZero) -> u32 {\n+    x as u32\n+}\n+\n fn main() {\n }"}, {"sha": "ef4fea604ec1a826e9708d142469c73633cff129", "filename": "tests/mir-opt/building/enum_cast.signy.built.after.mir", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.signy.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.signy.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.signy.built.after.mir?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,26 @@\n+// MIR for `signy` after built\n+\n+fn signy(_1: SignedAroundZero) -> i16 {\n+    debug x => _1;                       // in scope 0 at $DIR/enum_cast.rs:+0:10: +0:11\n+    let mut _0: i16;                     // return place in scope 0 at $DIR/enum_cast.rs:+0:34: +0:37\n+    let _2: SignedAroundZero;            // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:6\n+    let mut _3: i16;                     // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:6\n+    let mut _4: u16;                     // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+    let mut _5: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+    let mut _6: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+    let mut _7: bool;                    // in scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:6\n+        _2 = move _1;                    // scope 0 at $DIR/enum_cast.rs:+1:5: +1:6\n+        _3 = discriminant(_2);           // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _4 = _3 as u16 (IntToInt);       // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _5 = Ge(_4, const 65534_u16);    // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _6 = Le(_4, const 2_u16);        // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _7 = BitOr(move _5, move _6);    // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        assume(move _7);                 // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        _0 = move _3 as i16 (IntToInt);  // scope 0 at $DIR/enum_cast.rs:+1:5: +1:13\n+        StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:+1:12: +1:13\n+        return;                          // scope 0 at $DIR/enum_cast.rs:+2:2: +2:2\n+    }\n+}"}, {"sha": "7ca147b1596ffad218319dbef2961c007cf6b1ae", "filename": "tests/mir-opt/building/enum_cast.unsigny.built.after.mir", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.unsigny.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.unsigny.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fenum_cast.unsigny.built.after.mir?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,17 @@\n+// MIR for `unsigny` after built\n+\n+fn unsigny(_1: UnsignedAroundZero) -> u16 {\n+    debug x => _1;                       // in scope 0 at $DIR/enum_cast.rs:+0:12: +0:13\n+    let mut _0: u16;                     // return place in scope 0 at $DIR/enum_cast.rs:+0:38: +0:41\n+    let _2: UnsignedAroundZero;          // in scope 0 at $DIR/enum_cast.rs:+2:5: +2:6\n+    let mut _3: u16;                     // in scope 0 at $DIR/enum_cast.rs:+2:5: +2:6\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/enum_cast.rs:+2:5: +2:6\n+        _2 = move _1;                    // scope 0 at $DIR/enum_cast.rs:+2:5: +2:6\n+        _3 = discriminant(_2);           // scope 0 at $DIR/enum_cast.rs:+2:5: +2:13\n+        _0 = move _3 as u16 (IntToInt);  // scope 0 at $DIR/enum_cast.rs:+2:5: +2:13\n+        StorageDead(_2);                 // scope 0 at $DIR/enum_cast.rs:+2:12: +2:13\n+        return;                          // scope 0 at $DIR/enum_cast.rs:+3:2: +3:2\n+    }\n+}"}, {"sha": "b76e184b610c53da5fd4ddf25ae164614b73e067", "filename": "tests/run-make/issue-83045/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Frun-make%2Fissue-83045%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Frun-make%2Fissue-83045%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-83045%2FMakefile?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -29,5 +29,5 @@ all:\n \t\t\t\t  --crate-type=rlib \\\n \t\t\t\t  --edition=2018 \\\n \t\t\t\t  c.rs 2>&1 | tee $(TMPDIR)/output.txt || exit 0\n-\t$(CGREP) E0519 < $(TMPDIR)/output.txt\n+\t$(CGREP) E0463 < $(TMPDIR)/output.txt\n \t$(CGREP) -v \"internal compiler error\" < $(TMPDIR)/output.txt"}, {"sha": "c37d969324ceea9778b15e6ab28bb8b9b11b0e0e", "filename": "tests/rustdoc-gui/settings.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Frustdoc-gui%2Fsettings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Frustdoc-gui%2Fsettings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsettings.goml?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -301,7 +301,7 @@ wait-for-css: (\"#help-button .popover\", {\"display\": \"block\"})\n // Now we go to the settings page to check that the CSS is loaded as expected.\n go-to: \"file://\" + |DOC_PATH| + \"/settings.html\"\n wait-for: \"#settings\"\n-assert-css: (\".setting-line\", {\"position\": \"relative\"})\n+assert-css: (\".setting-radio\", {\"cursor\": \"pointer\"})\n \n assert-attribute-false: (\"#settings\", {\"class\": \"popover\"}, CONTAINS)\n compare-elements-position: (\".sub form\", \"#settings\", (\"x\"))\n@@ -322,4 +322,4 @@ reload:\n set-window-size: (300, 1000)\n click: \"#settings-menu\"\n wait-for: \"#settings\"\n-assert-css: (\".setting-line\", {\"position\": \"relative\"})\n+assert-css: (\".setting-radio\", {\"cursor\": \"pointer\"})"}, {"sha": "ca8319aa020dceea3f35a462540de4f30b896ec1", "filename": "tests/ui/error-codes/E0746.fixed", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f3d597b31c0f101a02c230798afa31a36bdacbc6/tests%2Fui%2Ferror-codes%2FE0746.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f3d597b31c0f101a02c230798afa31a36bdacbc6/tests%2Fui%2Ferror-codes%2FE0746.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0746.fixed?ref=f3d597b31c0f101a02c230798afa31a36bdacbc6", "patch": "@@ -1,18 +0,0 @@\n-// run-rustfix\n-#![allow(dead_code)]\n-struct Struct;\n-trait Trait {}\n-impl Trait for Struct {}\n-impl Trait for u32 {}\n-\n-fn foo() -> impl Trait { Struct }\n-//~^ ERROR E0746\n-\n-fn bar() -> impl Trait { //~ ERROR E0746\n-    if true {\n-        return 0;\n-    }\n-    42\n-}\n-\n-fn main() {}"}, {"sha": "86b5b7444d18ef5bb448a4f20193832d983c1d13", "filename": "tests/ui/error-codes/E0746.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ferror-codes%2FE0746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ferror-codes%2FE0746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0746.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -1,5 +1,5 @@\n-// run-rustfix\n #![allow(dead_code)]\n+\n struct Struct;\n trait Trait {}\n impl Trait for Struct {}"}, {"sha": "9fe90ab7bec7fcb41f779bee3e785c84d22077ab", "filename": "tests/ui/error-codes/E0746.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ferror-codes%2FE0746.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ferror-codes%2FE0746.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0746.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -4,23 +4,33 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn foo() -> dyn Trait { Struct }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `Struct`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn foo() -> impl Trait { Struct }\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL | fn foo() -> Box<dyn Trait> { Box::new(Struct) }\n+   |             ++++         +   +++++++++      +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/E0746.rs:11:13\n    |\n LL | fn bar() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `{integer}`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn bar() -> impl Trait {\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL ~ fn bar() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         return Box::new(0);\n+LL |     }\n+LL ~     Box::new(42)\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "af368203de021bc075245e2f4bfa253f68dfb666", "filename": "tests/ui/impl-trait/dyn-trait-return-should-be-impl-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -26,7 +26,7 @@ fn bax() -> dyn Trait { //~ ERROR E0746\n     if true {\n         Struct\n     } else {\n-        42 //~ ERROR `if` and `else` have incompatible types\n+        42\n     }\n }\n fn bam() -> Box<dyn Trait> {"}, {"sha": "ed9261d0de578f4d71f6ee603d78a2798e056e68", "filename": "tests/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "modified", "additions": 53, "deletions": 57, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -46,96 +46,78 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn bap() -> Trait { Struct }\n    |             ^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `Struct`, which implements `Trait`\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | fn bap() -> impl Trait { Struct }\n-   |             ~~~~~~~~~~\n+LL | fn bap() -> Box<Trait> { Box::new(Struct) }\n+   |             ++++     +   +++++++++      +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:15:13\n    |\n LL | fn ban() -> dyn Trait { Struct }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `Struct`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn ban() -> impl Trait { Struct }\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL | fn ban() -> Box<dyn Trait> { Box::new(Struct) }\n+   |             ++++         +   +++++++++      +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:17:13\n    |\n LL | fn bak() -> dyn Trait { unimplemented!() }\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-help: use `impl Trait` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn bak() -> impl Trait { unimplemented!() }\n-   |             ~~~~~~~~~~\n-help: use a boxed trait object if all return paths implement trait `Trait`\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | fn bak() -> Box<dyn Trait> { unimplemented!() }\n-   |             ++++         +\n+LL | fn bak() -> Box<dyn Trait> { Box::new(unimplemented!()) }\n+   |             ++++         +   +++++++++                +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:19:13\n    |\n LL | fn bal() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl Trait` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL | fn bal() -> Box<dyn Trait> {\n-   |             ++++         +\n-help: ... and box this value\n+LL | fn bal() -> impl Trait {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL |         return Box::new(Struct);\n-   |                +++++++++      +\n-help: ... and box this value\n+LL ~ fn bal() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         return Box::new(Struct);\n+LL |     }\n+LL ~     Box::new(42)\n    |\n-LL |     Box::new(42)\n-   |     +++++++++  +\n-\n-error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:29:9\n-   |\n-LL | /     if true {\n-LL | |         Struct\n-   | |         ------ expected because of this\n-LL | |     } else {\n-LL | |         42\n-   | |         ^^ expected `Struct`, found integer\n-LL | |     }\n-   | |_____- `if` and `else` have incompatible types\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:25:13\n    |\n LL | fn bax() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl Trait` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL | fn bax() -> Box<dyn Trait> {\n-   |             ++++         +\n-help: ... and box this value\n+LL | fn bax() -> impl Trait {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL |         Box::new(Struct)\n-   |         +++++++++      +\n-help: ... and box this value\n+LL ~ fn bax() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         Box::new(Struct)\n+LL |     } else {\n+LL ~         Box::new(42)\n    |\n-LL |         Box::new(42)\n-   |         +++++++++  +\n \n error[E0308]: mismatched types\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:34:16\n@@ -279,25 +261,39 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn bat() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `{integer}`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn bat() -> impl Trait {\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL ~ fn bat() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         return Box::new(0);\n+LL |     }\n+LL ~     Box::new(42)\n+   |\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:66:13\n    |\n LL | fn bay() -> dyn Trait {\n    |             ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Trait` as the return type, as all return paths are of type `{integer}`, which implements `Trait`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn bay() -> impl Trait {\n-   |             ~~~~~~~~~~\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL ~ fn bay() -> Box<dyn Trait> {\n+LL |     if true {\n+LL ~         Box::new(0)\n+LL |     } else {\n+LL ~         Box::new(42)\n+   |\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 19 previous errors\n \n Some errors have detailed explanations: E0277, E0308, E0746.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "a8a6288eb56fb3a349d0a6964923aed195a41071", "filename": "tests/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -77,7 +77,7 @@ fn hat() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed\n fn pug() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed trait object\n     match 13 {\n         0 => 0i32,\n-        1 => 1u32, //~ ERROR `match` arms have incompatible types\n+        1 => 1u32,\n         _ => 2u32,\n     }\n }\n@@ -86,7 +86,7 @@ fn man() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed\n     if false {\n         0i32\n     } else {\n-        1u32 //~ ERROR `if` and `else` have incompatible types\n+        1u32\n     }\n }\n "}, {"sha": "9205d74504f6f2d6c43e77213cc7338d66909709", "filename": "tests/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 30, "deletions": 78, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -171,108 +171,60 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn hat() -> dyn std::fmt::Display {\n    |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n-   |\n-LL | fn hat() -> Box<dyn std::fmt::Display> {\n-   |             ++++                     +\n-help: ... and box this value\n-   |\n-LL |             return Box::new(0i32);\n-   |                    +++++++++    +\n-help: ... and box this value\n-   |\n-LL |             Box::new(1u32)\n-   |             +++++++++    +\n-\n-error[E0308]: `match` arms have incompatible types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:80:14\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL | /     match 13 {\n-LL | |         0 => 0i32,\n-   | |              ---- this is found to be of type `i32`\n-LL | |         1 => 1u32,\n-   | |              ^^^^ expected `i32`, found `u32`\n-LL | |         _ => 2u32,\n-LL | |     }\n-   | |_____- `match` arms have incompatible types\n+LL | fn hat() -> impl std::fmt::Display {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-help: change the type of the numeric literal from `u32` to `i32`\n+LL ~ fn hat() -> Box<dyn std::fmt::Display> {\n+LL |     match 13 {\n+LL |         0 => {\n+LL ~             return Box::new(0i32);\n+LL |         }\n+LL |         _ => {\n+LL ~             Box::new(1u32)\n    |\n-LL |         1 => 1i32,\n-   |               ~~~\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:77:13\n    |\n LL | fn pug() -> dyn std::fmt::Display {\n    |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n-   |\n-LL | fn pug() -> Box<dyn std::fmt::Display> {\n-   |             ++++                     +\n-help: ... and box this value\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL |         0 => Box::new(0i32),\n-   |              +++++++++    +\n-help: ... and box this value\n-   |\n-LL |         1 => Box::new(1u32),\n-   |              +++++++++    +\n-help: ... and box this value\n-   |\n-LL |         _ => Box::new(2u32),\n-   |              +++++++++    +\n-\n-error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:89:9\n+LL | fn pug() -> impl std::fmt::Display {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | /     if false {\n-LL | |         0i32\n-   | |         ---- expected because of this\n-LL | |     } else {\n-LL | |         1u32\n-   | |         ^^^^ expected `i32`, found `u32`\n-LL | |     }\n-   | |_____- `if` and `else` have incompatible types\n-   |\n-help: change the type of the numeric literal from `u32` to `i32`\n+LL ~ fn pug() -> Box<dyn std::fmt::Display> {\n+LL |     match 13 {\n+LL ~         0 => Box::new(0i32),\n+LL ~         1 => Box::new(1u32),\n+LL ~         _ => Box::new(2u32),\n    |\n-LL |         1i32\n-   |          ~~~\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:85:13\n    |\n LL | fn man() -> dyn std::fmt::Display {\n    |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n-LL | fn man() -> Box<dyn std::fmt::Display> {\n-   |             ++++                     +\n-help: ... and box this value\n+LL | fn man() -> impl std::fmt::Display {\n+   |             ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL |         Box::new(0i32)\n-   |         +++++++++    +\n-help: ... and box this value\n+LL ~ fn man() -> Box<dyn std::fmt::Display> {\n+LL |     if false {\n+LL ~         Box::new(0i32)\n+LL |     } else {\n+LL ~         Box::new(1u32)\n    |\n-LL |         Box::new(1u32)\n-   |         +++++++++    +\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 12 previous errors\n \n Some errors have detailed explanations: E0308, E0746.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "cf4e06316a71004ab67f44de63bbb74e57cf4000", "filename": "tests/ui/issues/issue-18107.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fissues%2Fissue-18107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fissues%2Fissue-18107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-18107.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -4,14 +4,18 @@ error[E0746]: return type cannot have an unboxed trait object\n LL |     dyn AbstractRenderer\n    |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-help: use `impl AbstractRenderer` as the return type if all return paths have the same type but you want to expose only the trait in the signature\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL |     impl AbstractRenderer\n+   |     ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-help: use a boxed trait object if all return paths implement trait `AbstractRenderer`\n+LL ~     Box<dyn AbstractRenderer>\n+LL |\n+LL | {\n+LL |     match 0 {\n+LL ~         _ => Box::new(unimplemented!())\n    |\n-LL |     Box<dyn AbstractRenderer>\n-   |     ++++                    +\n \n error: aborting due to previous error\n "}, {"sha": "0f911a20842bc4e0fe5650dc119c156cc6dea9d5", "filename": "tests/ui/self/arbitrary-self-from-method-substs.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,16 @@\n+#![feature(arbitrary_self_types)]\n+\n+use std::ops::Deref;\n+\n+struct Foo(u32);\n+impl Foo {\n+    fn get<R: Deref<Target=Self>>(self: R) -> u32 {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo(1);\n+    foo.get::<&Foo>();\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "6c252fadf46573e81167b32d91bf28591a34121a", "filename": "tests/ui/self/arbitrary-self-from-method-substs.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fself%2Farbitrary-self-from-method-substs.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/arbitrary-self-from-method-substs.rs:14:5\n+   |\n+LL |     foo.get::<&Foo>();\n+   |     ^^^ expected `&Foo`, found `Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e5bfbfdae91fd79a57091c9cde62d419ccc12cc4", "filename": "tests/ui/type-alias-impl-trait/different_defining_uses_never_type-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-2.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,15 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Tait<'a> = impl Sized + 'a;\n+\n+fn foo<'a, 'b>() {\n+    if false {\n+        if { return } {\n+            let y: Tait<'b> = 1i32;\n+            //~^ ERROR concrete type differs from previous defining opaque type use\n+        }\n+    }\n+    let x: Tait<'a> = ();\n+}\n+\n+fn main() {}"}, {"sha": "f2eb7bc4dc79b5034e94783f4824531f2c64337c", "filename": "tests/ui/type-alias-impl-trait/different_defining_uses_never_type-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-2.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,14 @@\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/different_defining_uses_never_type-2.rs:8:31\n+   |\n+LL |             let y: Tait<'b> = 1i32;\n+   |                               ^^^^ expected `()`, got `i32`\n+   |\n+note: previous use here\n+  --> $DIR/different_defining_uses_never_type-2.rs:12:23\n+   |\n+LL |     let x: Tait<'a> = ();\n+   |                       ^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2b30a9cd57cf687fb06761dc137bd0a1c77ffcdf", "filename": "tests/ui/type-alias-impl-trait/different_defining_uses_never_type-3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-3.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,15 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Tait<T> = impl Sized;\n+\n+fn foo<T, U>() {\n+    if false {\n+        if { return } {\n+            let y: Tait<U> = 1i32;\n+            //~^ ERROR concrete type differs from previous defining opaque type use\n+        }\n+    }\n+    let x: Tait<T> = ();\n+}\n+\n+fn main() {}"}, {"sha": "8fc2e22848c70748a91d83d4debc0c6c7e2f4b18", "filename": "tests/ui/type-alias-impl-trait/different_defining_uses_never_type-3.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fdifferent_defining_uses_never_type-3.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -0,0 +1,14 @@\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/different_defining_uses_never_type-3.rs:8:30\n+   |\n+LL |             let y: Tait<U> = 1i32;\n+   |                              ^^^^ expected `()`, got `i32`\n+   |\n+note: previous use here\n+  --> $DIR/different_defining_uses_never_type-3.rs:12:22\n+   |\n+LL |     let x: Tait<T> = ();\n+   |                      ^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9ae2c34b935f2d433c19619d2305b8c6e095b0f3", "filename": "tests/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -8,6 +8,7 @@ type X<A, B> = impl Into<&'static A>;\n \n fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n     //~^ ERROR the trait bound `&'static B: From<&A>` is not satisfied\n+    //~| ERROR concrete type differs from previous defining opaque type use\n     (a, a)\n }\n "}, {"sha": "0d24d42ba62e8b71c876b41f5043254393a3a0cd", "filename": "tests/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -10,6 +10,15 @@ help: consider introducing a `where` clause, but there might be an alternative b\n LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) where &'static B: From<&A> {\n    |                                                                ++++++++++++++++++++++++++\n \n-error: aborting due to previous error\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/multiple-def-uses-in-one-fn.rs:9:45\n+   |\n+LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+   |                                             |\n+   |                                             expected `&B`, got `&A`\n+   |                                             this expression supplies two conflicting concrete types for the same opaque type\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "321c2ebf5a12244eb23e27231f7670743e054788", "filename": "tests/ui/unsized/box-instead-of-dyn-fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -8,7 +8,6 @@ fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> dyn Fn() + 'a {\n         move || println!(\"{a}\")\n     } else {\n         Box::new(move || println!(\"{}\", b))\n-        //~^ ERROR `if` and `else` have incompatible types\n     }\n }\n "}, {"sha": "6087f5c5465266f570d9f647c5837c9897367ee7", "filename": "tests/ui/unsized/box-instead-of-dyn-fn.stderr", "status": "modified", "additions": 11, "deletions": 32, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -1,42 +1,21 @@\n-error[E0308]: `if` and `else` have incompatible types\n-  --> $DIR/box-instead-of-dyn-fn.rs:10:9\n-   |\n-LL | /     if a % 2 == 0 {\n-LL | |         move || println!(\"{a}\")\n-   | |         -----------------------\n-   | |         |\n-   | |         the expected closure\n-   | |         expected because of this\n-LL | |     } else {\n-LL | |         Box::new(move || println!(\"{}\", b))\n-   | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found `Box<[closure@box-instead-of-dyn-fn.rs:10:18]>`\n-LL | |\n-LL | |     }\n-   | |_____- `if` and `else` have incompatible types\n-   |\n-   = note: expected closure `[closure@$DIR/box-instead-of-dyn-fn.rs:8:9: 8:16]`\n-               found struct `Box<[closure@$DIR/box-instead-of-dyn-fn.rs:10:18: 10:25]>`\n-\n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/box-instead-of-dyn-fn.rs:5:56\n    |\n LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> dyn Fn() + 'a {\n    |                                                        ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n-   = note: if all the returned values were of the same type you could use `impl Fn() + 'a` as the return type\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-   = note: you can create a new `enum` with a variant for each returned type\n-help: return a boxed trait object instead\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n+   |\n+LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> impl Fn() + 'a {\n+   |                                                        ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> Box<dyn Fn() + 'a> {\n-   |                                                        ++++             +\n-help: ... and box this value\n+LL ~ fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> Box<dyn Fn() + 'a> {\n+LL |\n+LL |     if a % 2 == 0 {\n+LL ~         Box::new(move || println!(\"{a}\"))\n    |\n-LL |         Box::new(move || println!(\"{a}\"))\n-   |         +++++++++                       +\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0746.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0746`."}, {"sha": "da5c4322403486d6557c1b40a851e8caebca21a4", "filename": "tests/ui/unsized/issue-91801.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Funsized%2Fissue-91801.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Funsized%2Fissue-91801.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Fissue-91801.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -4,11 +4,10 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> Validator<'a> {\n    |                                                                             ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a` as the return type, as all return paths are of type `Box<[closure@$DIR/issue-91801.rs:10:21: 10:70]>`, which implements `Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a`\n+help: box the return type, and wrap all of the returned values in `Box::new`\n    |\n-LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> impl Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a {\n-   |                                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> Box<Validator<'a>> {\n+   |                                                                             ++++             +\n \n error: aborting due to previous error\n "}, {"sha": "a43b8d0741f2c6bbf4b2b3ee7f063a84da53f115", "filename": "tests/ui/unsized/issue-91803.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Funsized%2Fissue-91803.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b08148f6a76010ea3d4e91d61245aa7aac59e4b4/tests%2Fui%2Funsized%2Fissue-91803.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsized%2Fissue-91803.stderr?ref=b08148f6a76010ea3d4e91d61245aa7aac59e4b4", "patch": "@@ -4,11 +4,14 @@ error[E0746]: return type cannot have an unboxed trait object\n LL | fn or<'a>(first: &'static dyn Foo<'a>) -> dyn Foo<'a> {\n    |                                           ^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n-   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n-help: use `impl Foo<'a>` as the return type, as all return paths are of type `Box<_>`, which implements `Foo<'a>`\n+help: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\n    |\n LL | fn or<'a>(first: &'static dyn Foo<'a>) -> impl Foo<'a> {\n-   |                                           ~~~~~~~~~~~~\n+   |                                           ~~~~\n+help: box the return type, and wrap all of the returned values in `Box::new`\n+   |\n+LL | fn or<'a>(first: &'static dyn Foo<'a>) -> Box<dyn Foo<'a>> {\n+   |                                           ++++           +\n \n error: aborting due to previous error\n "}]}