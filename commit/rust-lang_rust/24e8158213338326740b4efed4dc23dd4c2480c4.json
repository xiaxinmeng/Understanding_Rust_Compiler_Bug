{"sha": "24e8158213338326740b4efed4dc23dd4c2480c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZTgxNTgyMTMzMzgzMjY3NDBiNGVmZWQ0ZGMyM2RkNGMyNDgwYzQ=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-18T03:21:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-18T03:21:18Z"}, "message": "Rollup merge of #41310 - eddyb:demand-const-eval, r=nikomatsakis\n\n[on-demand] Turn monomorphic_const_eval into a proper query, not just a cache.\n\nThe error definitions and reporting logic, alongside with `eval_length` were moved to `librustc`.\nBoth local and cross-crate constant evaluation is on-demand now, but the latter is only used for `enum` discriminants, to replace the manual insertion into the cache which was done when decoding variants.\n\nr? @nikomatsakis", "tree": {"sha": "72cbfdc6cbcd28acead54b688a8ff3c796cb32a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72cbfdc6cbcd28acead54b688a8ff3c796cb32a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24e8158213338326740b4efed4dc23dd4c2480c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24e8158213338326740b4efed4dc23dd4c2480c4", "html_url": "https://github.com/rust-lang/rust/commit/24e8158213338326740b4efed4dc23dd4c2480c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24e8158213338326740b4efed4dc23dd4c2480c4/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8c446eab808a16ea6e878171762d5a1a58ac927", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c446eab808a16ea6e878171762d5a1a58ac927", "html_url": "https://github.com/rust-lang/rust/commit/b8c446eab808a16ea6e878171762d5a1a58ac927"}, {"sha": "6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d", "html_url": "https://github.com/rust-lang/rust/commit/6dc21b71cfd8e5246e7953cf64ea5ee6a19ceb3d"}], "stats": {"total": 879, "additions": 431, "deletions": 448}, "files": [{"sha": "62b853480394fd5c54568bb78fd3b7e7642bd006", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -503,7 +503,6 @@ name = \"rustc_const_eval\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n- \"graphviz 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -731,7 +730,6 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n- \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -762,7 +760,6 @@ dependencies = [\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n- \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n@@ -783,7 +780,6 @@ dependencies = [\n  \"pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n- \"rustc_const_eval 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_driver 0.0.0\",\n  \"rustc_errors 0.0.0\","}, {"sha": "8a391f9cde3a3a37b9dc74dddd09106617a86292", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -327,6 +327,25 @@ struct ListNode {\n This works because `Box` is a pointer, so its size is well-known.\n \"##,\n \n+E0080: r##\"\n+This error indicates that the compiler was unable to sensibly evaluate an\n+constant expression that had to be evaluated. Attempting to divide by 0\n+or causing integer overflow are two ways to induce this error. For example:\n+\n+```compile_fail,E0080\n+enum Enum {\n+    X = (1 << 500),\n+    Y = (1 / 0)\n+}\n+```\n+\n+Ensure that the expressions given can be evaluated as the desired integer type.\n+See the FFI section of the Reference for more information about using a custom\n+integer type:\n+\n+https://doc.rust-lang.org/reference.html#ffi-attributes\n+\"##,\n+\n E0106: r##\"\n This error indicates that a lifetime is missing from a type. If it is an error\n inside a function signature, the problem may be with failing to adhere to the"}, {"sha": "b4c5af9401944102f6b9b613b05e01b0259fb0c9", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 194, "deletions": 5, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -8,17 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::symbol::InternedString;\n-use syntax::ast;\n-use std::rc::Rc;\n+use self::ConstVal::*;\n+pub use rustc_const_math::ConstInt;\n+\n+use hir;\n+use hir::def::Def;\n use hir::def_id::DefId;\n+use ty::{self, TyCtxt};\n use ty::subst::Substs;\n+use util::common::ErrorReported;\n use rustc_const_math::*;\n \n-use self::ConstVal::*;\n-pub use rustc_const_math::ConstInt;\n+use graphviz::IntoCow;\n+use errors::DiagnosticBuilder;\n+use syntax::symbol::InternedString;\n+use syntax::ast;\n+use syntax_pos::Span;\n \n+use std::borrow::Cow;\n use std::collections::BTreeMap;\n+use std::rc::Rc;\n+\n+pub type EvalResult<'tcx> = Result<ConstVal<'tcx>, ConstEvalErr<'tcx>>;\n \n #[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal<'tcx> {\n@@ -61,3 +72,181 @@ impl<'tcx> ConstVal<'tcx> {\n         }\n     }\n }\n+\n+#[derive(Clone, Debug)]\n+pub struct ConstEvalErr<'tcx> {\n+    pub span: Span,\n+    pub kind: ErrKind<'tcx>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum ErrKind<'tcx> {\n+    CannotCast,\n+    MissingStructField,\n+    NegateOn(ConstVal<'tcx>),\n+    NotOn(ConstVal<'tcx>),\n+    CallOn(ConstVal<'tcx>),\n+\n+    NonConstPath,\n+    UnimplementedConstVal(&'static str),\n+    ExpectedConstTuple,\n+    ExpectedConstStruct,\n+    IndexedNonVec,\n+    IndexNotUsize,\n+    IndexOutOfBounds { len: u64, index: u64 },\n+\n+    MiscBinaryOp,\n+    MiscCatchAll,\n+\n+    IndexOpFeatureGated,\n+    Math(ConstMathErr),\n+\n+    ErroneousReferencedConstant(Box<ConstEvalErr<'tcx>>),\n+\n+    TypeckError\n+}\n+\n+impl<'tcx> From<ConstMathErr> for ErrKind<'tcx> {\n+    fn from(err: ConstMathErr) -> ErrKind<'tcx> {\n+        match err {\n+            ConstMathErr::UnsignedNegation => ErrKind::TypeckError,\n+            _ => ErrKind::Math(err)\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum ConstEvalErrDescription<'a> {\n+    Simple(Cow<'a, str>),\n+}\n+\n+impl<'a> ConstEvalErrDescription<'a> {\n+    /// Return a one-line description of the error, for lints and such\n+    pub fn into_oneline(self) -> Cow<'a, str> {\n+        match self {\n+            ConstEvalErrDescription::Simple(simple) => simple,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n+    pub fn description(&self) -> ConstEvalErrDescription {\n+        use self::ErrKind::*;\n+        use self::ConstEvalErrDescription::*;\n+\n+        macro_rules! simple {\n+            ($msg:expr) => ({ Simple($msg.into_cow()) });\n+            ($fmt:expr, $($arg:tt)+) => ({\n+                Simple(format!($fmt, $($arg)+).into_cow())\n+            })\n+        }\n+\n+        match self.kind {\n+            CannotCast => simple!(\"can't cast this type\"),\n+            NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n+            NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n+            CallOn(ref const_val) => simple!(\"call on {}\", const_val.description()),\n+\n+            MissingStructField  => simple!(\"nonexistent struct field\"),\n+            NonConstPath        => simple!(\"non-constant path in constant expression\"),\n+            UnimplementedConstVal(what) =>\n+                simple!(\"unimplemented constant expression: {}\", what),\n+            ExpectedConstTuple => simple!(\"expected constant tuple\"),\n+            ExpectedConstStruct => simple!(\"expected constant struct\"),\n+            IndexedNonVec => simple!(\"indexing is only supported for arrays\"),\n+            IndexNotUsize => simple!(\"indices must be of type `usize`\"),\n+            IndexOutOfBounds { len, index } => {\n+                simple!(\"index out of bounds: the len is {} but the index is {}\",\n+                        len, index)\n+            }\n+\n+            MiscBinaryOp => simple!(\"bad operands for binary\"),\n+            MiscCatchAll => simple!(\"unsupported constant expr\"),\n+            IndexOpFeatureGated => simple!(\"the index operation on const values is unstable\"),\n+            Math(ref err) => Simple(err.description().into_cow()),\n+\n+            ErroneousReferencedConstant(_) => simple!(\"could not evaluate referenced constant\"),\n+\n+            TypeckError => simple!(\"type-checking failed\"),\n+        }\n+    }\n+\n+    pub fn struct_error(&self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        primary_span: Span,\n+        primary_kind: &str)\n+        -> DiagnosticBuilder<'gcx>\n+    {\n+        let mut err = self;\n+        while let &ConstEvalErr {\n+            kind: ErrKind::ErroneousReferencedConstant(box ref i_err), ..\n+        } = err {\n+            err = i_err;\n+        }\n+\n+        let mut diag = struct_span_err!(tcx.sess, err.span, E0080, \"constant evaluation error\");\n+        err.note(tcx, primary_span, primary_kind, &mut diag);\n+        diag\n+    }\n+\n+    pub fn note(&self,\n+        _tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        primary_span: Span,\n+        primary_kind: &str,\n+        diag: &mut DiagnosticBuilder)\n+    {\n+        match self.description() {\n+            ConstEvalErrDescription::Simple(message) => {\n+                diag.span_label(self.span, &message);\n+            }\n+        }\n+\n+        if !primary_span.contains(self.span) {\n+            diag.span_note(primary_span,\n+                        &format!(\"for {} here\", primary_kind));\n+        }\n+    }\n+\n+    pub fn report(&self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        primary_span: Span,\n+        primary_kind: &str)\n+    {\n+        if let ErrKind::TypeckError = self.kind {\n+            return;\n+        }\n+        self.struct_error(tcx, primary_span, primary_kind).emit();\n+    }\n+}\n+\n+/// Returns the value of the length-valued expression\n+pub fn eval_length(tcx: TyCtxt,\n+                   count: hir::BodyId,\n+                   reason: &str)\n+                   -> Result<usize, ErrorReported>\n+{\n+    let count_expr = &tcx.hir.body(count).value;\n+    let count_def_id = tcx.hir.body_owner_def_id(count);\n+    match ty::queries::monomorphic_const_eval::get(tcx, count_expr.span, count_def_id) {\n+        Ok(Integral(Usize(count))) => {\n+            let val = count.as_u64(tcx.sess.target.uint_type);\n+            assert_eq!(val as usize as u64, val);\n+            Ok(val as usize)\n+        },\n+        Ok(_) |\n+        Err(ConstEvalErr { kind: ErrKind::TypeckError, .. }) => Err(ErrorReported),\n+        Err(err) => {\n+            let mut diag = err.struct_error(tcx, count_expr.span, reason);\n+\n+            if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n+                if let Def::Local(..) = path.def {\n+                    diag.note(&format!(\"`{}` is a variable\",\n+                                       tcx.hir.node_to_pretty_string(count_expr.id)));\n+                }\n+            }\n+\n+            diag.emit();\n+            Err(ErrorReported)\n+        }\n+    }\n+}"}, {"sha": "e9eb5e97582bf136975d6332cb6e1925a17ebd62", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -10,7 +10,7 @@\n \n use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use middle::const_val::ConstVal;\n+use middle::const_val;\n use middle::privacy::AccessLevels;\n use mir;\n use session::CompileResult;\n@@ -443,7 +443,7 @@ define_maps! { <'tcx>\n \n     /// Results of evaluating monomorphic constants embedded in\n     /// other items, such as enum variant explicit discriminants.\n-    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal<'tcx>, ()>,\n+    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> const_val::EvalResult<'tcx>,\n \n     /// Performs the privacy check and computes \"access levels\".\n     pub privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,"}, {"sha": "79d369595a52533e02d1354261b9a3301220a61b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -1690,7 +1690,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.variants.iter().map(move |v| {\n             let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n-                match tcx.maps.monomorphic_const_eval.borrow()[&expr_did] {\n+                match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n                     Ok(ConstVal::Integral(v)) => {\n                         discr = v;\n                     }\n@@ -1703,6 +1703,51 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         })\n     }\n \n+    /// Compute the discriminant value used by a specific variant.\n+    /// Unlike `discriminants`, this is (amortized) constant-time,\n+    /// only doing at most one query for evaluating an explicit\n+    /// discriminant (the last one before the requested variant),\n+    /// assuming there are no constant-evaluation errors there.\n+    pub fn discriminant_for_variant(&self,\n+                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                    variant_index: usize)\n+                                    -> ConstInt {\n+        let repr_type = self.repr.discr_type();\n+        let mut explicit_value = repr_type.initial_discriminant(tcx.global_tcx());\n+        let mut explicit_index = variant_index;\n+        loop {\n+            match self.variants[explicit_index].discr {\n+                ty::VariantDiscr::Relative(0) => break,\n+                ty::VariantDiscr::Relative(distance) => {\n+                    explicit_index -= distance;\n+                }\n+                ty::VariantDiscr::Explicit(expr_did) => {\n+                    match queries::monomorphic_const_eval::get(tcx, DUMMY_SP, expr_did) {\n+                        Ok(ConstVal::Integral(v)) => {\n+                            explicit_value = v;\n+                            break;\n+                        }\n+                        _ => {\n+                            explicit_index -= 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        let discr = explicit_value.to_u128_unchecked()\n+            .wrapping_add((variant_index - explicit_index) as u128);\n+        match repr_type {\n+            attr::UnsignedInt(ty) => {\n+                ConstInt::new_unsigned_truncating(discr, ty,\n+                                                  tcx.sess.target.uint_type)\n+            }\n+            attr::SignedInt(ty) => {\n+                ConstInt::new_signed_truncating(discr as i128, ty,\n+                                                tcx.sess.target.int_type)\n+            }\n+        }\n+    }\n+\n     pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {\n         queries::adt_destructor::get(tcx, DUMMY_SP, self.did)\n     }"}, {"sha": "bbc6148082494f905194f9be7aa9b200b075686f", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -17,5 +17,4 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n-graphviz = { path = \"../libgraphviz\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "f1ab6a00aa2effb1e3528546dc825b9aec8b0319", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -14,8 +14,6 @@ use _match::WitnessPreference::*;\n \n use pattern::{Pattern, PatternContext, PatternError, PatternKind};\n \n-use eval::report_const_eval_err;\n-\n use rustc::dep_graph::DepNode;\n \n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n@@ -108,27 +106,29 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n-    fn check_patterns(&self, has_guard: bool, pats: &[P<Pat>]) {\n-        check_legality_of_move_bindings(self, has_guard, pats);\n-        for pat in pats {\n-            check_legality_of_bindings_in_at_patterns(self, pat);\n-        }\n-    }\n-\n-    fn report_inlining_errors(&self, patcx: PatternContext, pat_span: Span) {\n-        for error in patcx.errors {\n-            match error {\n+impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n+    fn report_inlining_errors(&self, pat_span: Span) {\n+        for error in &self.errors {\n+            match *error {\n                 PatternError::StaticInPattern(span) => {\n                     span_err!(self.tcx.sess, span, E0158,\n                               \"statics cannot be referenced in patterns\");\n                 }\n-                PatternError::ConstEval(err) => {\n-                    report_const_eval_err(self.tcx, &err, pat_span, \"pattern\");\n+                PatternError::ConstEval(ref err) => {\n+                    err.report(self.tcx, pat_span, \"pattern\");\n                 }\n             }\n         }\n     }\n+}\n+\n+impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n+    fn check_patterns(&self, has_guard: bool, pats: &[P<Pat>]) {\n+        check_legality_of_move_bindings(self, has_guard, pats);\n+        for pat in pats {\n+            check_legality_of_bindings_in_at_patterns(self, pat);\n+        }\n+    }\n \n     fn check_match(\n         &self,\n@@ -161,7 +161,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                     let mut patcx = PatternContext::new(self.tcx, self.tables);\n                     let pattern = expand_pattern(cx, patcx.lower_pattern(&pat));\n                     if !patcx.errors.is_empty() {\n-                        self.report_inlining_errors(patcx, pat.span);\n+                        patcx.report_inlining_errors(pat.span);\n                         have_errors = true;\n                     }\n                     (pattern, &**pat)"}, {"sha": "04fc3e68c8ccd9033f3fd0226cfc10e6fe4967b0", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -557,25 +557,6 @@ The `op_string_ref` binding has type `&Option<&String>` in both cases.\n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n \n-E0080: r##\"\n-This error indicates that the compiler was unable to sensibly evaluate an\n-constant expression that had to be evaluated. Attempting to divide by 0\n-or causing integer overflow are two ways to induce this error. For example:\n-\n-```compile_fail,E0080\n-enum Enum {\n-    X = (1 << 500),\n-    Y = (1 / 0)\n-}\n-```\n-\n-Ensure that the expressions given can be evaluated as the desired integer type.\n-See the FFI section of the Reference for more information about using a custom\n-integer type:\n-\n-https://doc.rust-lang.org/reference.html#ffi-attributes\n-\"##,\n-\n }\n \n "}, {"sha": "9c5a669bef0d92623aeb12488802a49f321c6cfe", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 23, "deletions": 203, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -9,31 +9,29 @@\n // except according to those terms.\n \n use rustc::middle::const_val::ConstVal::*;\n-use rustc::middle::const_val::ConstVal;\n-use self::ErrKind::*;\n+use rustc::middle::const_val::ErrKind::*;\n+use rustc::middle::const_val::{ConstVal, ConstEvalErr, EvalResult, ErrKind};\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::traits;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::{Substs, Subst};\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::DefIdMap;\n \n-use graphviz::IntoCow;\n use syntax::ast;\n use rustc::hir::{self, Expr};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::borrow::Cow;\n use std::cmp::Ordering;\n \n use rustc_const_math::*;\n-use rustc_errors::DiagnosticBuilder;\n \n macro_rules! signal {\n     ($e:expr, $exn:expr) => {\n@@ -158,66 +156,6 @@ fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     }\n }\n \n-fn build_const_eval_err<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    err: &ConstEvalErr,\n-    primary_span: Span,\n-    primary_kind: &str)\n-    -> DiagnosticBuilder<'tcx>\n-{\n-    let mut err = err;\n-    while let &ConstEvalErr { kind: ErroneousReferencedConstant(box ref i_err), .. } = err {\n-        err = i_err;\n-    }\n-\n-    let mut diag = struct_span_err!(tcx.sess, err.span, E0080, \"constant evaluation error\");\n-    note_const_eval_err(tcx, err, primary_span, primary_kind, &mut diag);\n-    diag\n-}\n-\n-pub fn report_const_eval_err<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    err: &ConstEvalErr,\n-    primary_span: Span,\n-    primary_kind: &str)\n-{\n-    if let TypeckError = err.kind {\n-        return;\n-    }\n-    build_const_eval_err(tcx, err, primary_span, primary_kind).emit();\n-}\n-\n-pub fn fatal_const_eval_err<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    err: &ConstEvalErr,\n-    primary_span: Span,\n-    primary_kind: &str)\n-    -> !\n-{\n-    report_const_eval_err(tcx, err, primary_span, primary_kind);\n-    tcx.sess.abort_if_errors();\n-    unreachable!()\n-}\n-\n-pub fn note_const_eval_err<'a, 'tcx>(\n-    _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    err: &ConstEvalErr,\n-    primary_span: Span,\n-    primary_kind: &str,\n-    diag: &mut DiagnosticBuilder)\n-{\n-    match err.description() {\n-        ConstEvalErrDescription::Simple(message) => {\n-            diag.span_label(err.span, &message);\n-        }\n-    }\n-\n-    if !primary_span.contains(err.span) {\n-        diag.span_note(primary_span,\n-                       &format!(\"for {} here\", primary_kind));\n-    }\n-}\n-\n pub struct ConstContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -226,12 +164,6 @@ pub struct ConstContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: hir::BodyId) -> Self {\n-        let def_id = tcx.hir.body_owner_def_id(body);\n-        ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n-        ConstContext::with_tables(tcx, tcx.item_tables(def_id))\n-    }\n-\n     pub fn with_tables(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &'a ty::TypeckTables<'tcx>) -> Self {\n         ConstContext {\n             tcx: tcx,\n@@ -251,107 +183,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct ConstEvalErr<'tcx> {\n-    pub span: Span,\n-    pub kind: ErrKind<'tcx>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum ErrKind<'tcx> {\n-    CannotCast,\n-    MissingStructField,\n-    NegateOn(ConstVal<'tcx>),\n-    NotOn(ConstVal<'tcx>),\n-    CallOn(ConstVal<'tcx>),\n-\n-    NonConstPath,\n-    UnimplementedConstVal(&'static str),\n-    ExpectedConstTuple,\n-    ExpectedConstStruct,\n-    IndexedNonVec,\n-    IndexNotUsize,\n-    IndexOutOfBounds { len: u64, index: u64 },\n-\n-    MiscBinaryOp,\n-    MiscCatchAll,\n-\n-    IndexOpFeatureGated,\n-    Math(ConstMathErr),\n-\n-    ErroneousReferencedConstant(Box<ConstEvalErr<'tcx>>),\n-\n-    TypeckError\n-}\n-\n-impl<'tcx> From<ConstMathErr> for ErrKind<'tcx> {\n-    fn from(err: ConstMathErr) -> ErrKind<'tcx> {\n-        match err {\n-            ConstMathErr::UnsignedNegation => TypeckError,\n-            _ => Math(err)\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum ConstEvalErrDescription<'a> {\n-    Simple(Cow<'a, str>),\n-}\n-\n-impl<'a> ConstEvalErrDescription<'a> {\n-    /// Return a one-line description of the error, for lints and such\n-    pub fn into_oneline(self) -> Cow<'a, str> {\n-        match self {\n-            ConstEvalErrDescription::Simple(simple) => simple,\n-        }\n-    }\n-}\n-\n-impl<'tcx> ConstEvalErr<'tcx> {\n-    pub fn description(&self) -> ConstEvalErrDescription {\n-        use self::ErrKind::*;\n-        use self::ConstEvalErrDescription::*;\n-\n-        macro_rules! simple {\n-            ($msg:expr) => ({ Simple($msg.into_cow()) });\n-            ($fmt:expr, $($arg:tt)+) => ({\n-                Simple(format!($fmt, $($arg)+).into_cow())\n-            })\n-        }\n-\n-        match self.kind {\n-            CannotCast => simple!(\"can't cast this type\"),\n-            NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n-            NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n-            CallOn(ref const_val) => simple!(\"call on {}\", const_val.description()),\n-\n-            MissingStructField  => simple!(\"nonexistent struct field\"),\n-            NonConstPath        => simple!(\"non-constant path in constant expression\"),\n-            UnimplementedConstVal(what) =>\n-                simple!(\"unimplemented constant expression: {}\", what),\n-            ExpectedConstTuple => simple!(\"expected constant tuple\"),\n-            ExpectedConstStruct => simple!(\"expected constant struct\"),\n-            IndexedNonVec => simple!(\"indexing is only supported for arrays\"),\n-            IndexNotUsize => simple!(\"indices must be of type `usize`\"),\n-            IndexOutOfBounds { len, index } => {\n-                simple!(\"index out of bounds: the len is {} but the index is {}\",\n-                        len, index)\n-            }\n-\n-            MiscBinaryOp => simple!(\"bad operands for binary\"),\n-            MiscCatchAll => simple!(\"unsupported constant expr\"),\n-            IndexOpFeatureGated => simple!(\"the index operation on const values is unstable\"),\n-            Math(ref err) => Simple(err.description().into_cow()),\n-\n-            ErroneousReferencedConstant(_) => simple!(\"could not evaluate referenced constant\"),\n-\n-            TypeckError => simple!(\"type-checking failed\"),\n-        }\n-    }\n-}\n-\n-pub type EvalResult<'tcx> = Result<ConstVal<'tcx>, ConstEvalErr<'tcx>>;\n-pub type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n+type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n \n fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                                      e: &Expr) -> EvalResult<'tcx> {\n@@ -947,50 +779,38 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n         let a = match self.eval(a) {\n             Ok(a) => a,\n             Err(e) => {\n-                report_const_eval_err(tcx, &e, a.span, \"expression\");\n+                e.report(tcx, a.span, \"expression\");\n                 return Err(ErrorReported);\n             }\n         };\n         let b = match self.eval(b) {\n             Ok(b) => b,\n             Err(e) => {\n-                report_const_eval_err(tcx, &e, b.span, \"expression\");\n+                e.report(tcx, b.span, \"expression\");\n                 return Err(ErrorReported);\n             }\n         };\n         compare_const_vals(tcx, span, &a, &b)\n     }\n }\n \n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        monomorphic_const_eval,\n+        ..*providers\n+    };\n+}\n \n-/// Returns the value of the length-valued expression\n-pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             count: hir::BodyId,\n-                             reason: &str)\n-                             -> Result<usize, ErrorReported>\n-{\n-    let count_expr = &tcx.hir.body(count).value;\n-    match ConstContext::new(tcx, count).eval(count_expr) {\n-        Ok(Integral(Usize(count))) => {\n-            let val = count.as_u64(tcx.sess.target.uint_type);\n-            assert_eq!(val as usize as u64, val);\n-            Ok(val as usize)\n-        },\n-        Ok(_) |\n-        Err(ConstEvalErr { kind: TypeckError, .. }) => Err(ErrorReported),\n-        Err(err) => {\n-            let mut diag = build_const_eval_err(\n-                tcx, &err, count_expr.span, reason);\n-\n-            if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n-                if let Def::Local(..) = path.def {\n-                    diag.note(&format!(\"`{}` is a variable\",\n-                                       tcx.hir.node_to_pretty_string(count_expr.id)));\n-                }\n-            }\n+fn monomorphic_const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    def_id: DefId)\n+                                    -> EvalResult<'tcx> {\n+    let cx = ConstContext::with_tables(tcx, tcx.item_tables(def_id));\n \n-            diag.emit();\n-            Err(ErrorReported)\n-        }\n-    }\n+    let body = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n+        ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id);\n+        tcx.hir.body(tcx.hir.body_owned_by(id))\n+    } else {\n+        tcx.sess.cstore.maybe_get_item_body(tcx, def_id).unwrap()\n+    };\n+    cx.eval(&body.value)\n }"}, {"sha": "fa3161a860498c17dd866295a008c25e86e66e63", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -40,7 +40,6 @@ extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n-extern crate graphviz;\n extern crate syntax_pos;\n \n // NB: This module needs to be declared first so diagnostics are"}, {"sha": "f20fa27dc225124eca4bd6cd00fa90128e7ffd5a", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -11,7 +11,7 @@\n use eval;\n \n use rustc::lint;\n-use rustc::middle::const_val::ConstVal;\n+use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, TypeVariants, Region};\n use rustc::ty::subst::{Substs, Kind};\n@@ -29,7 +29,7 @@ use syntax_pos::Span;\n #[derive(Clone, Debug)]\n pub enum PatternError<'tcx> {\n     StaticInPattern(Span),\n-    ConstEval(eval::ConstEvalErr<'tcx>),\n+    ConstEval(ConstEvalErr<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "7632b40ab4f9ead935148a64514c5ec9147268a7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -37,7 +37,7 @@ use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc_passes::{ast_validation, no_asm, loops, consts,\n                    static_recursion, hir_stats, mir_stats};\n-use rustc_const_eval::check_match;\n+use rustc_const_eval::{self, check_match};\n use super::Compilation;\n \n use serialize::json;\n@@ -895,10 +895,13 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n+    rustc_const_eval::provide(&mut local_providers);\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n+    // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n+    rustc_const_eval::provide(&mut extern_providers);\n \n     TyCtxt::create_and_enter(sess,\n                              local_providers,"}, {"sha": "b73b3e161f9b547fcfb0ef6f0b26090ad794d31d", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -266,6 +266,17 @@ impl<'a, 'tcx, 'm> intravisit::Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, '\n         intravisit::walk_item(self, item);\n     }\n \n+    fn visit_variant(&mut self,\n+                     variant: &'tcx hir::Variant,\n+                     generics: &'tcx hir::Generics,\n+                     parent_id: ast::NodeId) {\n+        if let Some(e) = variant.node.disr_expr {\n+            self.check_item(e.node_id, variant.span);\n+        }\n+\n+        intravisit::walk_variant(self, variant, generics, parent_id);\n+    }\n+\n     fn visit_variant_data(&mut self,\n                           variant_data: &'tcx hir::VariantData,\n                           _: ast::Name,"}, {"sha": "fac6079529e30187af8c4830be5d44876fbaffab", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -511,24 +511,15 @@ impl<'a, 'tcx> CrateMetadata {\n         def\n     }\n \n-    fn get_variant(&self,\n-                   item: &Entry<'tcx>,\n-                   index: DefIndex,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                   -> (ty::VariantDef, Option<DefIndex>) {\n+    fn get_variant(&self, item: &Entry, index: DefIndex) -> ty::VariantDef {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        if let ty::VariantDiscr::Explicit(def_id) = data.discr {\n-            let result = data.evaluated_discr.map_or(Err(()), Ok);\n-            tcx.maps.monomorphic_const_eval.borrow_mut().insert(def_id, result);\n-        }\n-\n-        (ty::VariantDef {\n+        ty::VariantDef {\n             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n             name: self.item_name(index),\n             fields: item.children.decode(self).map(|index| {\n@@ -541,7 +532,7 @@ impl<'a, 'tcx> CrateMetadata {\n             }).collect(),\n             discr: data.discr,\n             ctor_kind: data.ctor_kind,\n-        }, data.struct_ctor)\n+        }\n     }\n \n     pub fn get_adt_def(&self,\n@@ -560,15 +551,11 @@ impl<'a, 'tcx> CrateMetadata {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n-                    let (variant, struct_ctor) =\n-                        self.get_variant(&self.entry(index), index, tcx);\n-                    assert_eq!(struct_ctor, None);\n-                    variant\n+                    self.get_variant(&self.entry(index), index)\n                 })\n                 .collect()\n         } else {\n-            let (variant, _struct_ctor) = self.get_variant(&item, item_id, tcx);\n-            vec![variant]\n+            vec![self.get_variant(&item, item_id)]\n         };\n         let (kind, repr) = match item.kind {\n             EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),"}, {"sha": "ce9f0a73fe2b85cf47f3cd7a7936a79fc5f54be2", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -269,12 +269,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            evaluated_discr: match variant.discr {\n-                ty::VariantDiscr::Explicit(def_id) => {\n-                    ty::queries::monomorphic_const_eval::get(tcx, DUMMY_SP, def_id).ok()\n-                }\n-                ty::VariantDiscr::Relative(_) => None\n-            },\n             struct_ctor: None,\n         };\n \n@@ -408,7 +402,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            evaluated_discr: None,\n             struct_ctor: Some(def_id.index),\n         };\n \n@@ -697,7 +690,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    evaluated_discr: None,\n                     struct_ctor: struct_ctor,\n                 }), repr_options)\n             }\n@@ -708,7 +700,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n-                    evaluated_discr: None,\n                     struct_ctor: None,\n                 }), repr_options)\n             }\n@@ -1037,6 +1028,17 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n                           EntryBuilder::encode_info_for_foreign_item,\n                           (def_id, ni));\n     }\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     id: ast::NodeId) {\n+        intravisit::walk_variant(self, v, g, id);\n+\n+        if let Some(discr) = v.node.disr_expr {\n+            let def_id = self.index.tcx.hir.body_owner_def_id(discr);\n+            self.index.record(def_id, EntryBuilder::encode_info_for_embedded_const, def_id);\n+        }\n+    }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         intravisit::walk_generics(self, generics);\n         self.index.encode_info_for_generics(generics);\n@@ -1160,6 +1162,32 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         }\n     }\n \n+    fn encode_info_for_embedded_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        debug!(\"EntryBuilder::encode_info_for_embedded_const({:?})\", def_id);\n+        let tcx = self.tcx;\n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let body = tcx.hir.body_owned_by(id);\n+\n+        Entry {\n+            kind: EntryKind::Const(ty::queries::mir_const_qualif::get(tcx, DUMMY_SP, def_id)),\n+            visibility: self.lazy(&ty::Visibility::Public),\n+            span: self.lazy(&tcx.def_span(def_id)),\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n+\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n+\n+            ast: Some(self.encode_body(body)),\n+            mir: self.encode_mir(def_id),\n+        }\n+    }\n+\n     fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n         // NOTE: This must use lazy_seq_from_slice(), not lazy_seq() because\n         //       we really on the HashStable specialization for [Attribute]"}, {"sha": "2f2e0e125aea5673959122f19bd3c89d55b360b0", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -15,7 +15,6 @@ use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n use rustc::ich::StableHashingContext;\n-use rustc::middle::const_val::ConstVal;\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -271,9 +270,9 @@ pub enum EntryKind<'tcx> {\n     Type,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy<VariantData<'tcx>>),\n-    Struct(Lazy<VariantData<'tcx>>, ReprOptions),\n-    Union(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Variant(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>, ReprOptions),\n+    Union(Lazy<VariantData>, ReprOptions),\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n@@ -374,20 +373,18 @@ pub struct FnData {\n impl_stable_hash_for!(struct FnData { constness, arg_names });\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData<'tcx> {\n+pub struct VariantData {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n-    pub evaluated_discr: Option<ConstVal<'tcx>>,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item.\n     pub struct_ctor: Option<DefIndex>,\n }\n \n-impl_stable_hash_for!(struct VariantData<'tcx> {\n+impl_stable_hash_for!(struct VariantData {\n     ctor_kind,\n     discr,\n-    evaluated_discr,\n     struct_ctor\n });\n "}, {"sha": "b7de50efe34424bb14e621b60a6d1609825638b1", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -17,7 +17,6 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::map;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::{ConstContext, fatal_const_eval_err};\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n@@ -592,12 +591,12 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         // Now comes the rote stuff:\n         hir::ExprRepeat(ref v, count) => {\n-            let tcx = cx.tcx.global_tcx();\n             let c = &cx.tcx.hir.body(count).value;\n-            let count = match ConstContext::new(tcx, count).eval(c) {\n+            let def_id = cx.tcx.hir.body_owner_def_id(count);\n+            let count = match ty::queries::monomorphic_const_eval::get(cx.tcx, c.span, def_id) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n-                Err(s) => fatal_const_eval_err(tcx, &s, c.span, \"expression\")\n+                Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")\n             };\n \n             ExprKind::Repeat {"}, {"sha": "5f9fb8e1b120f040c57486f2cf285e0ed1b512e7", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -17,8 +17,8 @@\n use hair::*;\n use rustc::mir::transform::MirSource;\n \n-use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::{ConstContext, fatal_const_eval_err};\n+use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n+use rustc_const_eval::ConstContext;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -115,10 +115,21 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx.global_tcx();\n         match ConstContext::with_tables(tcx, self.tables()).eval(e) {\n             Ok(value) => Literal::Value { value: value },\n-            Err(s) => fatal_const_eval_err(tcx, &s, e.span, \"expression\")\n+            Err(s) => self.fatal_const_eval_err(&s, e.span, \"expression\")\n         }\n     }\n \n+    pub fn fatal_const_eval_err(&self,\n+        err: &ConstEvalErr<'tcx>,\n+        primary_span: Span,\n+        primary_kind: &str)\n+        -> !\n+    {\n+        err.report(self.tcx, primary_span, primary_kind);\n+        self.tcx.sess.abort_if_errors();\n+        unreachable!()\n+    }\n+\n     pub fn trait_method(&mut self,\n                         trait_def_id: DefId,\n                         method_name: &str,"}, {"sha": "44d3026d80c3e9d20238310d91b7bb65a6804550", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -26,10 +26,11 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::ty::cast::CastKind;\n-use rustc_const_eval::{ConstEvalErr, ConstContext};\n-use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n-use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n-use rustc_const_eval::ErrKind::{TypeckError};\n+use rustc_const_eval::ConstContext;\n+use rustc::middle::const_val::ConstEvalErr;\n+use rustc::middle::const_val::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll};\n+use rustc::middle::const_val::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n+use rustc::middle::const_val::ErrKind::{TypeckError, Math};\n use rustc_const_math::{ConstMathErr, Op};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;"}, {"sha": "af477f5a15217bf7ca4c132a5dba9f77a9cb17d1", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -15,7 +15,6 @@ log = \"0.3\"\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "87ca410dece0dcee116b43653044c586653712f5", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -41,8 +41,6 @@\n //!   used unboxed and any field can have pointers (including mutable)\n //!   taken to it, implementing them for Rust seems difficult.\n \n-use super::Disr;\n-\n use std;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n@@ -347,31 +345,31 @@ fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n \n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n-pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr) {\n+pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: u64) {\n     let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n-            assert_discr_in_range(Disr(min), Disr(max), to);\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n+            assert_discr_in_range(min, max, to);\n+            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n                   val, None);\n         }\n         layout::General{ discr, .. } => {\n-            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n+            bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to, true),\n                   bcx.struct_gep(val, 0), None);\n         }\n         layout::Univariant { .. }\n         | layout::UntaggedUnion { .. }\n         | layout::Vector { .. } => {\n-            assert_eq!(to, Disr(0));\n+            assert_eq!(to, 0);\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            if to.0 != nndiscr {\n+            if to != nndiscr {\n                 let llptrty = val_ty(val).element_type();\n                 bcx.store(C_null(llptrty), val, None);\n             }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n-            if to.0 != nndiscr {\n+            if to != nndiscr {\n                 if target_sets_discr_via_memset(bcx) {\n                     // Issue #34427: As workaround for LLVM bug on\n                     // ARM, use memset of 0 on whole struct rather\n@@ -397,7 +395,7 @@ fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n     bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n }\n \n-pub fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n+pub fn assert_discr_in_range<D: PartialOrd>(min: D, max: D, discr: D) {\n     if min <= max {\n         assert!(min <= discr && discr <= max)\n     } else {\n@@ -415,7 +413,7 @@ fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n /// (Not to be confused with `common::const_get_elt`, which operates on\n /// raw LLVM-level structs and arrays.)\n pub fn const_get_field<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                       val: ValueRef, _discr: Disr,\n+                       val: ValueRef,\n                        ix: usize) -> ValueRef {\n     let l = ccx.layout_of(t);\n     match *l {"}, {"sha": "7a53a03344fcba2046f7a20e15f5679ffe72e4fa", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -13,9 +13,9 @@ use back::symbol_names;\n use llvm;\n use llvm::{SetUnnamedAddr};\n use llvm::{ValueRef, True};\n-use rustc_const_eval::ConstEvalErr;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n+use rustc::middle::const_val::ConstEvalErr;\n use {debuginfo, machine};\n use base;\n use trans_item::TransItem;"}, {"sha": "a940faac8387735a7288f915564ea3b1dc0f88a0", "filename": "src/librustc_trans/disr.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b8c446eab808a16ea6e878171762d5a1a58ac927/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c446eab808a16ea6e878171762d5a1a58ac927/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=b8c446eab808a16ea6e878171762d5a1a58ac927", "patch": "@@ -1,82 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::middle::const_val::ConstVal;\n-use rustc::ty::{self, TyCtxt};\n-use rustc_const_math::ConstInt;\n-\n-#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n-pub struct Disr(pub u64);\n-\n-impl Disr {\n-    pub fn for_variant(tcx: TyCtxt,\n-                       def: &ty::AdtDef,\n-                       variant_index: usize) -> Self {\n-        let mut explicit_index = variant_index;\n-        let mut explicit_value = Disr(0);\n-        loop {\n-            match def.variants[explicit_index].discr {\n-                ty::VariantDiscr::Relative(0) => break,\n-                ty::VariantDiscr::Relative(distance) => {\n-                    explicit_index -= distance;\n-                }\n-                ty::VariantDiscr::Explicit(expr_did) => {\n-                    match tcx.maps.monomorphic_const_eval.borrow()[&expr_did] {\n-                        Ok(ConstVal::Integral(v)) => {\n-                            explicit_value = Disr::from(v);\n-                            break;\n-                        }\n-                        _ => {\n-                            explicit_index -= 1;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        let distance = variant_index - explicit_index;\n-        explicit_value.wrapping_add(Disr::from(distance))\n-    }\n-\n-    pub fn wrapping_add(self, other: Self) -> Self {\n-        Disr(self.0.wrapping_add(other.0))\n-    }\n-}\n-\n-impl ::std::ops::BitAnd for Disr {\n-    type Output = Disr;\n-    fn bitand(self, other: Self) -> Self {\n-        Disr(self.0 & other.0)\n-    }\n-}\n-\n-impl From<ConstInt> for Disr {\n-    fn from(i: ConstInt) -> Disr {\n-        // FIXME: what if discr has 128 bit discr?\n-        Disr(i.to_u128_unchecked() as u64)\n-    }\n-}\n-\n-impl From<usize> for Disr {\n-    fn from(i: usize) -> Disr {\n-        Disr(i as u64)\n-    }\n-}\n-\n-impl PartialOrd for Disr {\n-    fn partial_cmp(&self, other: &Disr) -> Option<::std::cmp::Ordering> {\n-        self.0.partial_cmp(&other.0)\n-    }\n-}\n-\n-impl Ord for Disr {\n-    fn cmp(&self, other: &Disr) -> ::std::cmp::Ordering {\n-        self.0.cmp(&other.0)\n-    }\n-}"}, {"sha": "be214a0f6143cdb5b751fdddd9fbc3e851d6c127", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -51,7 +51,6 @@ extern crate rustc_incremental;\n pub extern crate rustc_llvm as llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_const_math;\n-extern crate rustc_const_eval;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;\n@@ -68,7 +67,6 @@ pub use rustc::lint;\n pub use rustc::util;\n \n pub use base::trans_crate;\n-pub use disr::Disr;\n \n pub mod back {\n     pub use rustc::hir::svh;\n@@ -119,7 +117,6 @@ mod consts;\n mod context;\n mod debuginfo;\n mod declare;\n-mod disr;\n mod glue;\n mod intrinsic;\n mod machine;"}, {"sha": "0976859e27f44b7ed8a018922bad67fd9c55bc11", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef, BasicBlockRef};\n-use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n-use rustc::middle::const_val::ConstInt;\n+use rustc::middle::const_val::{ConstEvalErr, ConstInt, ErrKind};\n use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir;\n@@ -363,7 +362,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let err = ConstEvalErr{ span: span, kind: err };\n                         let mut diag = bcx.tcx().sess.struct_span_warn(\n                             span, \"this expression will panic at run-time\");\n-                        note_const_eval_err(bcx.tcx(), &err, span, \"expression\", &mut diag);\n+                        err.note(bcx.tcx(), span, \"expression\", &mut diag);\n                         diag.emit();\n                     }\n                 }"}, {"sha": "8bce0cf85c08bf57184704e1ea55a88fc69c489a", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n-use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::{ErrKind, ConstEvalErr, report_const_eval_err};\n+use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n use rustc_const_math::ConstInt::*;\n use rustc_const_math::ConstFloat::*;\n use rustc_const_math::{ConstInt, ConstMathErr};\n@@ -23,7 +22,7 @@ use rustc::ty::layout::{self, LayoutTyper};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use {abi, adt, base, Disr, machine};\n+use {abi, adt, base, machine};\n use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n@@ -327,8 +326,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             }\n                         };\n \n-                        let err = ConstEvalErr{ span: span, kind: err };\n-                        report_const_eval_err(tcx, &err, span, \"expression\");\n+                        let err = ConstEvalErr { span: span, kind: err };\n+                        err.report(tcx, span, \"expression\");\n                         failure = Err(err);\n                     }\n                     target\n@@ -429,7 +428,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         let llprojected = adt::const_get_field(self.ccx, tr_base.ty, base.llval,\n-                                                               Disr(0), field.index());\n+                                                               field.index());\n                         let llextra = if is_sized {\n                             ptr::null_mut()\n                         } else {\n@@ -988,13 +987,14 @@ fn trans_const<'a, 'tcx>(\n         layout::CEnum { discr: d, min, max, .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n-                    Disr::for_variant(ccx.tcx(), adt_def, variant_index)\n+                    adt_def.discriminant_for_variant(ccx.tcx(), variant_index)\n+                           .to_u128_unchecked() as u64\n                 },\n-                _ => Disr(0),\n+                _ => 0,\n             };\n             assert_eq!(vals.len(), 0);\n-            adt::assert_discr_in_range(Disr(min), Disr(max), discr);\n-            C_integral(Type::from_integer(ccx, d), discr.0, true)\n+            adt::assert_discr_in_range(min, max, discr);\n+            C_integral(Type::from_integer(ccx, d), discr, true)\n         }\n         layout::General { discr: d, ref variants, .. } => {\n             let variant = &variants[variant_index];"}, {"sha": "98e9008f829f683fbbcea1e6b9f63e9ad8a6dd41", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -28,7 +28,6 @@ use type_::Type;\n use type_of;\n use tvec;\n use value::Value;\n-use Disr;\n \n use super::MirContext;\n use super::constant::const_scalar_checked_binop;\n@@ -107,9 +106,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n-                        let disr = Disr::for_variant(bcx.tcx(), adt_def, variant_index);\n+                        let discr = adt_def.discriminant_for_variant(bcx.tcx(), variant_index)\n+                           .to_u128_unchecked() as u64;\n                         let dest_ty = dest.ty.to_ty(bcx.tcx());\n-                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, disr);\n+                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, discr);\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields."}, {"sha": "52c2afca4748bda2566c91a0370737eab75e9663", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -18,7 +18,6 @@ use builder::Builder;\n use super::MirContext;\n use super::LocalRef;\n use super::super::adt;\n-use super::super::disr::Disr;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n@@ -65,7 +64,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 adt::trans_set_discr(&bcx,\n                     ty,\n                     lvalue_transed.llval,\n-                    Disr::from(variant_index));\n+                    variant_index as u64);\n                 bcx\n             }\n             mir::StatementKind::StorageLive(ref lvalue) => {"}, {"sha": "4d908f3c94fa58c7e2bda52885741b14ff6dc437", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -28,7 +28,6 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n-use rustc_const_eval::fatal_const_eval_err;\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n use type_of;\n@@ -82,9 +81,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                     match consts::trans_static(&ccx, m, item.id, &item.attrs) {\n                         Ok(_) => { /* Cool, everything's alright. */ },\n                         Err(err) => {\n-                            // FIXME: shouldn't this be a `span_err`?\n-                            fatal_const_eval_err(\n-                                ccx.tcx(), &err, item.span, \"static\");\n+                            err.report(ccx.tcx(), item.span, \"static\");\n                         }\n                     };\n                 } else {"}, {"sha": "194d37dcb81c22c40d096612aebb489c641332d4", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -16,7 +16,6 @@ arena = { path = \"../libarena\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }"}, {"sha": "9426d601dfcce3cc6b704d9e2ee5d0c85dcc408c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -12,7 +12,7 @@\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n //! is parameterized by an instance of `AstConv`.\n \n-use rustc_const_eval::eval_length;\n+use rustc::middle::const_val::eval_length;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use hir;\n use hir::def::Def;\n@@ -1208,7 +1208,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n             }\n             hir::TyArray(ref ty, length) => {\n-                if let Ok(length) = eval_length(tcx.global_tcx(), length, \"array length\") {\n+                if let Ok(length) = eval_length(tcx, length, \"array length\") {\n                     tcx.mk_array(self.ast_ty_to_ty(&ty), length)\n                 } else {\n                     self.tcx().types.err"}, {"sha": "f894c0d32e0447fe7d236e98cbcc8db9bc5449ad", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -126,7 +126,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, PatKind};\n use rustc::middle::lang_items;\n use rustc_back::slice;\n-use rustc_const_eval::eval_length;\n+use rustc::middle::const_val::eval_length;\n use rustc_const_math::ConstInt;\n \n mod assoc;\n@@ -3634,7 +3634,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               tcx.mk_array(element_ty, args.len())\n           }\n           hir::ExprRepeat(ref element, count) => {\n-            let count = eval_length(self.tcx.global_tcx(), count, \"repeat count\")\n+            let count = eval_length(self.tcx, count, \"repeat count\")\n                   .unwrap_or(0);\n \n             let uty = match expected {"}, {"sha": "73e3de0cc76ddc4293f48a2196adda06b92a1aec", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -59,14 +59,12 @@ use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use middle::resolve_lifetime as rl;\n-use rustc_const_eval::{ConstContext, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n use rustc::dep_graph::DepNode;\n-use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, FxHashMap};\n \n use rustc_const_math::ConstInt;\n@@ -587,17 +585,6 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.item_predicates(def_id);\n }\n \n-fn evaluate_disr_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                body: hir::BodyId)\n-                                -> Result<ConstVal<'tcx>, ()> {\n-    let e = &tcx.hir.body(body).value;\n-    ConstContext::new(tcx, body).eval(e).map_err(|err| {\n-        // enum variant evaluation happens before the global constant check\n-        // so we need to report the real error\n-        report_const_eval_err(tcx, &err, e.span, \"enum discriminant\");\n-    })\n-}\n-\n fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n                                         variants: &[hir::Variant]) {\n@@ -611,9 +598,13 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n             let expr_did = tcx.hir.local_def_id(e.node_id);\n-            let result = tcx.maps.monomorphic_const_eval.memoize(expr_did, || {\n-                evaluate_disr_expr(tcx, e)\n-            });\n+            let result = ty::queries::monomorphic_const_eval::get(tcx, variant.span, expr_did);\n+\n+            // enum variant evaluation happens before the global constant check\n+            // so we need to report the real error\n+            if let Err(ref err) = result {\n+                err.report(tcx, variant.span, \"enum discriminant\");\n+            }\n \n             match result {\n                 Ok(ConstVal::Integral(x)) => Some(x),"}, {"sha": "e9d52c5eb98d94630d8e669f701e5a1ab8370dbb", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -94,7 +94,6 @@ extern crate fmt_macros;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_back;\n extern crate rustc_const_math;\n-extern crate rustc_const_eval;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n "}, {"sha": "7caae51e88913676b767b13b508192f5434b18c2", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -15,7 +15,6 @@ env_logger = { version = \"0.4\", default-features = false }\n log = \"0.3\"\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_driver = { path = \"../librustc_driver\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "cf872db682379fb815351275674a96bae74bf659", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -1718,7 +1718,7 @@ impl Clean<Type> for hir::Ty {\n             }\n             TySlice(ref ty) => Vector(box ty.clean(cx)),\n             TyArray(ref ty, length) => {\n-                use rustc_const_eval::eval_length;\n+                use rustc::middle::const_val::eval_length;\n                 let n = eval_length(cx.tcx, length, \"array length\").unwrap();\n                 FixedVector(box ty.clean(cx), n.to_string())\n             },"}, {"sha": "d5b997001bb9deed6297102df90d603fb2737c53", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -33,7 +33,6 @@ extern crate getopts;\n extern crate env_logger;\n extern crate libc;\n extern crate rustc;\n-extern crate rustc_const_eval;\n extern crate rustc_data_structures;\n extern crate rustc_trans;\n extern crate rustc_driver;"}, {"sha": "0f734683b60e58490286f961a7c1b711545f8227", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24e8158213338326740b4efed4dc23dd4c2480c4/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=24e8158213338326740b4efed4dc23dd4c2480c4", "patch": "@@ -27,6 +27,7 @@\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n+#![feature(stmt_expr_attributes)]\n #![crate_type=\"rlib\"]\n \n \n@@ -125,9 +126,12 @@ enum EnumChangeValueCStyleVariant0 {\n enum EnumChangeValueCStyleVariant0 {\n     Variant1,\n \n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n-    Variant2 = 22,\n+    Variant2 =\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        22,\n }\n \n #[cfg(cfail1)]"}]}