{"sha": "34bc80650b93bf422039af31844898f427cc375c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YmM4MDY1MGI5M2JmNDIyMDM5YWYzMTg0NDg5OGY0MjdjYzM3NWM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-11T17:46:56Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:52:37Z"}, "message": "Hook up query, add impls, lower moar", "tree": {"sha": "da7a75bc2147c16c17f1fcf94f16940e21e12b09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da7a75bc2147c16c17f1fcf94f16940e21e12b09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34bc80650b93bf422039af31844898f427cc375c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34bc80650b93bf422039af31844898f427cc375c", "html_url": "https://github.com/rust-lang/rust/commit/34bc80650b93bf422039af31844898f427cc375c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34bc80650b93bf422039af31844898f427cc375c/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d75d11d6cbd8a2d4605fd185237ec2747b0687f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d75d11d6cbd8a2d4605fd185237ec2747b0687f", "html_url": "https://github.com/rust-lang/rust/commit/1d75d11d6cbd8a2d4605fd185237ec2747b0687f"}], "stats": {"total": 169, "additions": 128, "deletions": 41}, "files": [{"sha": "f159f80af05c71caf2d9c3a1fd81b8454c795986", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34bc80650b93bf422039af31844898f427cc375c/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bc80650b93bf422039af31844898f427cc375c/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=34bc80650b93bf422039af31844898f427cc375c", "patch": "@@ -3,7 +3,6 @@\n \n use either::Either;\n use hir_expand::{\n-    db::AstDatabase,\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n     HirFileId, MacroDefId, MacroDefKind,\n@@ -42,8 +41,8 @@ pub(crate) struct LowerCtx {\n }\n \n impl LowerCtx {\n-    pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Self {\n-        LowerCtx { hygiene: Hygiene::new(db, file_id) }\n+    pub fn new(db: &dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx { hygiene: Hygiene::new(db.upcast(), file_id) }\n     }\n     pub fn with_hygiene(hygiene: &Hygiene) -> Self {\n         LowerCtx { hygiene: hygiene.clone() }\n@@ -120,7 +119,7 @@ impl ExprCollector<'_> {\n     }\n \n     fn ctx(&self) -> LowerCtx {\n-        LowerCtx::new(self.db.upcast(), self.expander.current_file_id)\n+        LowerCtx::new(self.db, self.expander.current_file_id)\n     }\n \n     fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {"}, {"sha": "c4c9e10a3d8b598cccdb194e3cb48bed962dc963", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34bc80650b93bf422039af31844898f427cc375c/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bc80650b93bf422039af31844898f427cc375c/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=34bc80650b93bf422039af31844898f427cc375c", "patch": "@@ -14,6 +14,7 @@ use crate::{\n     docs::Documentation,\n     generics::GenericParams,\n     import_map::ImportMap,\n+    item_tree::ItemTree,\n     lang_item::{LangItemTarget, LangItems},\n     nameres::{raw::RawItems, CrateDefMap},\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n@@ -48,6 +49,9 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(RawItems::raw_items_query)]\n     fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n \n+    #[salsa::invoke(ItemTree::item_tree_query)]\n+    fn item_tree(&self, file_id: HirFileId) -> Arc<ItemTree>;\n+\n     #[salsa::invoke(crate_def_map_wait)]\n     #[salsa::transparent]\n     fn crate_def_map(&self, krate: CrateId) -> Arc<CrateDefMap>;"}, {"sha": "7e81bc178d1491e0f34d62c12fb9bcc6d3dbf07b", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 121, "deletions": 37, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/34bc80650b93bf422039af31844898f427cc375c/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bc80650b93bf422039af31844898f427cc375c/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=34bc80650b93bf422039af31844898f427cc375c", "patch": "@@ -4,25 +4,28 @@ use hir_expand::{\n     ast_id_map::{AstIdMap, FileAstId},\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n+    HirFileId,\n };\n use ra_arena::{Arena, Idx, RawId};\n-use ra_syntax::ast;\n+use ra_syntax::{ast, match_ast};\n \n use crate::{\n     attr::Attrs,\n+    db::DefDatabase,\n     generics::GenericParams,\n     path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path},\n     type_ref::{Mutability, TypeBound, TypeRef},\n     visibility::RawVisibility,\n };\n-use ast::{NameOwner, StructKind, TypeAscriptionOwner};\n+use ast::{AstNode, ModuleItemOwner, NameOwner, StructKind, TypeAscriptionOwner};\n use std::{\n     ops::{Index, Range},\n     sync::Arc,\n };\n \n-#[derive(Default)]\n+#[derive(Debug, Default, Eq, PartialEq)]\n pub struct ItemTree {\n+    top_level: Vec<ModItem>,\n     imports: Arena<Import>,\n     functions: Arena<Function>,\n     structs: Arena<Struct>,\n@@ -41,8 +44,42 @@ pub struct ItemTree {\n }\n \n impl ItemTree {\n-    pub fn query(syntax: &ast::SourceFile) -> ItemTree {\n-        todo!()\n+    pub fn item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {\n+        let syntax = if let Some(node) = db.parse_or_expand(file_id) {\n+            node\n+        } else {\n+            return Default::default();\n+        };\n+\n+        let (macro_storage, file_storage);\n+        let item_owner = match_ast! {\n+            match syntax {\n+                ast::MacroItems(items) => {\n+                    macro_storage = items;\n+                    &macro_storage as &dyn ModuleItemOwner\n+                },\n+                ast::SourceFile(file) => {\n+                    file_storage = file;\n+                    &file_storage\n+                },\n+                _ => return Default::default(),\n+            }\n+        };\n+\n+        let map = db.ast_id_map(file_id);\n+        let ctx = Ctx {\n+            tree: ItemTree::default(),\n+            hygiene: Hygiene::new(db.upcast(), file_id),\n+            source_ast_id_map: map,\n+            body_ctx: crate::body::LowerCtx::new(db, file_id),\n+        };\n+        Arc::new(ctx.lower(item_owner))\n+    }\n+\n+    /// Returns an iterator over all items located at the top level of the `HirFileId` this\n+    /// `ItemTree` was created from.\n+    pub fn top_level_items(&self) -> impl Iterator<Item = ModItem> + '_ {\n+        self.top_level.iter().copied()\n     }\n }\n \n@@ -78,6 +115,7 @@ impl_index!(\n     exprs: Expr,\n );\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Import {\n     pub path: ModPath,\n     pub alias: Option<ImportAlias>,\n@@ -88,6 +126,7 @@ pub struct Import {\n     pub is_macro_use: bool,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Function {\n     pub name: Name,\n     pub attrs: Attrs,\n@@ -99,6 +138,7 @@ pub struct Function {\n     pub ast: FileAstId<ast::FnDef>,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Struct {\n     pub name: Name,\n     pub attrs: Attrs,\n@@ -108,6 +148,7 @@ pub struct Struct {\n     pub ast: FileAstId<ast::StructDef>,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Union {\n     pub name: Name,\n     pub attrs: Attrs,\n@@ -116,6 +157,7 @@ pub struct Union {\n     pub fields: Fields,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Enum {\n     pub name: Name,\n     pub attrs: Attrs,\n@@ -124,19 +166,22 @@ pub struct Enum {\n     pub variants: Range<Idx<Variant>>,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Const {\n     /// const _: () = ();\n     pub name: Option<Name>,\n     pub visibility: RawVisibility,\n     pub type_ref: TypeRef,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Static {\n     pub name: Name,\n     pub visibility: RawVisibility,\n     pub type_ref: TypeRef,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Trait {\n     pub name: Name,\n     pub visibility: RawVisibility,\n@@ -145,6 +190,7 @@ pub struct Trait {\n     pub items: Vec<AssocItem>,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Impl {\n     pub generic_params: GenericParams,\n     pub target_trait: Option<TypeRef>,\n@@ -161,12 +207,14 @@ pub struct TypeAlias {\n     pub type_ref: Option<TypeRef>,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct Mod {\n     pub name: Name,\n     pub visibility: RawVisibility,\n     pub items: Vec<ModItem>,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n pub struct MacroCall {\n     pub name: Option<Name>,\n     pub path: ModPath,\n@@ -177,8 +225,22 @@ pub struct MacroCall {\n \n // NB: There's no `FileAstId` for `Expr`. The only case where this would be useful is for array\n // lengths, but we don't do much with them yet.\n+#[derive(Debug, Eq, PartialEq)]\n pub struct Expr;\n \n+macro_rules! impl_froms {\n+    ($e:ident { $($v:ident ($t:ty)),* $(,)? }) => {\n+        $(\n+            impl From<$t> for $e {\n+                fn from(it: $t) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n pub enum ModItem {\n     Import(Idx<Import>),\n     Function(Idx<Function>),\n@@ -194,13 +256,37 @@ pub enum ModItem {\n     MacroCall(Idx<MacroCall>),\n }\n \n+impl_froms!(ModItem {\n+    Import(Idx<Import>),\n+    Function(Idx<Function>),\n+    Struct(Idx<Struct>),\n+    Union(Idx<Union>),\n+    Enum(Idx<Enum>),\n+    Const(Idx<Const>),\n+    Static(Idx<Static>),\n+    Trait(Idx<Trait>),\n+    Impl(Idx<Impl>),\n+    TypeAlias(Idx<TypeAlias>),\n+    Mod(Idx<Mod>),\n+    MacroCall(Idx<MacroCall>),\n+});\n+\n+#[derive(Debug, Eq, PartialEq)]\n pub enum AssocItem {\n     Function(Idx<Function>),\n     TypeAlias(Idx<TypeAlias>),\n     Const(Idx<Const>),\n     MacroCall(Idx<MacroCall>),\n }\n \n+impl_froms!(AssocItem {\n+    Function(Idx<Function>),\n+    TypeAlias(Idx<TypeAlias>),\n+    Const(Idx<Const>),\n+    MacroCall(Idx<MacroCall>),\n+});\n+\n+#[derive(Debug, Eq, PartialEq)]\n pub struct Variant {\n     pub name: Name,\n     pub fields: Fields,\n@@ -229,55 +315,44 @@ struct Ctx {\n }\n \n impl Ctx {\n-    fn lower(&mut self, item_owner: &dyn ast::ModuleItemOwner) {\n-        for item in item_owner.items() {\n-            self.lower_item(&item)\n-        }\n+    fn lower(mut self, item_owner: &dyn ModuleItemOwner) -> ItemTree {\n+        self.tree.top_level = item_owner.items().flat_map(|item| self.lower_item(&item)).collect();\n+        self.tree\n     }\n \n-    fn lower_item(&mut self, item: &ast::ModuleItem) {\n+    fn lower_item(&mut self, item: &ast::ModuleItem) -> Option<ModItem> {\n         match item {\n             ast::ModuleItem::StructDef(ast) => {\n-                if let Some(data) = self.lower_struct(ast) {\n-                    let idx = self.tree.structs.alloc(data);\n-                }\n+                self.lower_struct(ast).map(|data| self.tree.structs.alloc(data).into())\n             }\n             ast::ModuleItem::UnionDef(ast) => {\n-                if let Some(data) = self.lower_union(ast) {\n-                    let idx = self.tree.unions.alloc(data);\n-                }\n+                self.lower_union(ast).map(|data| self.tree.unions.alloc(data).into())\n             }\n             ast::ModuleItem::EnumDef(ast) => {\n-                if let Some(data) = self.lower_enum(ast) {\n-                    let idx = self.tree.enums.alloc(data);\n-                }\n+                self.lower_enum(ast).map(|data| self.tree.enums.alloc(data).into())\n             }\n             ast::ModuleItem::FnDef(ast) => {\n-                if let Some(data) = self.lower_function(ast) {\n-                    let idx = self.tree.functions.alloc(data);\n-                }\n+                self.lower_function(ast).map(|data| self.tree.functions.alloc(data).into())\n             }\n             ast::ModuleItem::TypeAliasDef(ast) => {\n-                if let Some(data) = self.lower_type_alias(ast) {\n-                    let idx = self.tree.type_aliases.alloc(data);\n-                }\n+                self.lower_type_alias(ast).map(|data| self.tree.type_aliases.alloc(data).into())\n             }\n             ast::ModuleItem::StaticDef(ast) => {\n-                if let Some(data) = self.lower_static(ast) {\n-                    let idx = self.tree.statics.alloc(data);\n-                }\n+                self.lower_static(ast).map(|data| self.tree.statics.alloc(data).into())\n             }\n             ast::ModuleItem::ConstDef(ast) => {\n                 let data = self.lower_const(ast);\n-                let idx = self.tree.consts.alloc(data);\n+                Some(self.tree.consts.alloc(data).into())\n+            }\n+            ast::ModuleItem::Module(ast) => {\n+                self.lower_module(ast).map(|data| self.tree.mods.alloc(data).into())\n             }\n-            ast::ModuleItem::Module(_) => {}\n-            ast::ModuleItem::TraitDef(_) => {}\n-            ast::ModuleItem::ImplDef(_) => {}\n-            ast::ModuleItem::UseItem(_) => {}\n-            ast::ModuleItem::ExternCrateItem(_) => {}\n-            ast::ModuleItem::MacroCall(_) => {}\n-            ast::ModuleItem::ExternBlock(_) => {}\n+            ast::ModuleItem::TraitDef(_) => todo!(),\n+            ast::ModuleItem::ImplDef(_) => todo!(),\n+            ast::ModuleItem::UseItem(_) => todo!(),\n+            ast::ModuleItem::ExternCrateItem(_) => todo!(),\n+            ast::ModuleItem::MacroCall(_) => todo!(),\n+            ast::ModuleItem::ExternBlock(_) => todo!(),\n         }\n     }\n \n@@ -473,7 +548,16 @@ impl Ctx {\n         Const { name, visibility, type_ref }\n     }\n \n-    fn lower_generic_params(&mut self, item: &impl ast::TypeParamsOwner) -> GenericParams {\n+    fn lower_module(&mut self, module: &ast::Module) -> Option<Mod> {\n+        let name = module.name()?.as_name();\n+        let visibility = self.lower_visibility(module);\n+        let items = module\n+            .item_list()\n+            .map(move |list| list.items().flat_map(move |item| self.lower_item(&item)).collect());\n+        Some(Mod { name, visibility, items: items.unwrap_or_default() })\n+    }\n+\n+    fn lower_generic_params(&mut self, _item: &impl ast::TypeParamsOwner) -> GenericParams {\n         None.unwrap()\n     }\n "}]}