{"sha": "387e0991e3be528ab85fce8f57c489949a7a41a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4N2UwOTkxZTNiZTUyOGFiODVmY2U4ZjU3YzQ4OTk0OWE3YTQxYTU=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-14T19:58:32Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-14T19:58:32Z"}, "message": "Handle more iterator adapter cases in for loops", "tree": {"sha": "48a6bda42eb8e59534a2d551155965e3f922cf1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48a6bda42eb8e59534a2d551155965e3f922cf1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/387e0991e3be528ab85fce8f57c489949a7a41a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/387e0991e3be528ab85fce8f57c489949a7a41a5", "html_url": "https://github.com/rust-lang/rust/commit/387e0991e3be528ab85fce8f57c489949a7a41a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/387e0991e3be528ab85fce8f57c489949a7a41a5/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f8723c78cffe7cebec5b3792fcff0c81586ab8", "html_url": "https://github.com/rust-lang/rust/commit/f6f8723c78cffe7cebec5b3792fcff0c81586ab8"}], "stats": {"total": 163, "additions": 117, "deletions": 46}, "files": [{"sha": "614b561749f761f15c8f58eeb3fb1951bbfaa456", "filename": "src/loops.rs", "status": "modified", "additions": 95, "deletions": 43, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/387e0991e3be528ab85fce8f57c489949a7a41a5/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/387e0991e3be528ab85fce8f57c489949a7a41a5/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=387e0991e3be528ab85fce8f57c489949a7a41a5", "patch": "@@ -8,7 +8,6 @@ use consts::{constant_simple, Constant};\n use rustc::front::map::Node::NodeBlock;\n use std::borrow::Cow;\n use std::collections::{HashSet, HashMap};\n-use syntax::ast::Lit_::*;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro, expr_block,\n             span_help_and_lint, is_integer_literal, get_enclosing_block};\n@@ -247,54 +246,102 @@ impl LateLintPass for LoopsPass {\n }\n \n fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n-    // check for looping over a range and then indexing a sequence with it\n-    // -> the iteratee must be a range literal\n-    if let ExprRange(Some(ref l), _) = arg.node {\n-        // Range should start with `0`\n-        if let ExprLit(ref lit) = l.node {\n-            if let LitInt(0, _) = lit.node {\n-\n-                // the var must be a single name\n-                if let PatIdent(_, ref ident, _) = pat.node {\n-                    let mut visitor = VarVisitor {\n-                        cx: cx,\n-                        var: ident.node.name,\n-                        indexed: HashSet::new(),\n-                        nonindex: false,\n-                    };\n-                    walk_expr(&mut visitor, body);\n-                    // linting condition: we only indexed one variable\n-                    if visitor.indexed.len() == 1 {\n-                        let indexed = visitor.indexed\n-                                             .into_iter()\n-                                             .next()\n-                                             .expect(\"Len was nonzero, but no contents found\");\n-                        if visitor.nonindex {\n-                            span_lint(cx,\n-                                      NEEDLESS_RANGE_LOOP,\n-                                      expr.span,\n-                                      &format!(\"the loop variable `{}` is used to index `{}`. Consider using `for \\\n-                                                ({}, item) in {}.iter().enumerate()` or similar iterators\",\n-                                               ident.node.name,\n-                                               indexed,\n-                                               ident.node.name,\n-                                               indexed));\n-                        } else {\n-                            span_lint(cx,\n-                                      NEEDLESS_RANGE_LOOP,\n-                                      expr.span,\n-                                      &format!(\"the loop variable `{}` is only used to index `{}`. Consider using \\\n-                                                `for item in &{}` or similar iterators\",\n-                                               ident.node.name,\n-                                               indexed,\n-                                               indexed));\n-                        }\n+    check_for_loop_range(cx, pat, arg, body, expr);\n+    check_for_loop_reverse_range(cx, arg, expr);\n+    check_for_loop_explicit_iter(cx, arg, expr);\n+    check_for_loop_explicit_counter(cx, arg, body, expr);\n+}\n+\n+/// Check for looping over a range and then indexing a sequence with it.\n+/// The iteratee must be a range literal.\n+fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+    if let ExprRange(Some(ref l), ref r) = arg.node {\n+        // the var must be a single name\n+        if let PatIdent(_, ref ident, _) = pat.node {\n+            let mut visitor = VarVisitor {\n+                cx: cx,\n+                var: ident.node.name,\n+                indexed: HashSet::new(),\n+                nonindex: false,\n+            };\n+            walk_expr(&mut visitor, body);\n+            // linting condition: we only indexed one variable\n+            if visitor.indexed.len() == 1 {\n+                let indexed = visitor.indexed\n+                                     .into_iter()\n+                                     .next()\n+                                     .expect(\"Len was nonzero, but no contents found\");\n+\n+                let starts_at_zero = is_integer_literal(l, 0);\n+\n+                let skip: Cow<_> = if starts_at_zero {\n+                    \"\".into()\n+                }\n+                else {\n+                    format!(\".skip({})\", snippet(cx, l.span, \"..\")).into()\n+                };\n+\n+                let take: Cow<_> = if let Some(ref r) = *r {\n+                    if !is_len_call(&r, &indexed) {\n+                        format!(\".take({})\", snippet(cx, r.span, \"..\")).into()\n+                    }\n+                    else {\n+                        \"\".into()\n+                    }\n+                } else {\n+                    \"\".into()\n+                };\n+\n+                if visitor.nonindex {\n+                    span_lint(cx,\n+                              NEEDLESS_RANGE_LOOP,\n+                              expr.span,\n+                              &format!(\"the loop variable `{}` is used to index `{}`. \\\n+                                        Consider using `for ({}, item) in {}.iter().enumerate(){}{}` or similar iterators\",\n+                                        ident.node.name,\n+                                        indexed,\n+                                        ident.node.name,\n+                                        indexed,\n+                                        take,\n+                                        skip));\n+                } else {\n+                    let repl = if starts_at_zero && take.is_empty() {\n+                        format!(\"&{}\", indexed)\n                     }\n+                    else {\n+                        format!(\"{}.iter(){}{}\", indexed, take, skip)\n+                    };\n+\n+                    span_lint(cx,\n+                              NEEDLESS_RANGE_LOOP,\n+                              expr.span,\n+                              &format!(\"the loop variable `{}` is only used to index `{}`. \\\n+                                        Consider using `for item in {}` or similar iterators\",\n+                                        ident.node.name,\n+                                        indexed,\n+                                        repl));\n                 }\n             }\n         }\n     }\n+}\n+\n+fn is_len_call(expr: &Expr, var: &Name) -> bool {\n+    if_let_chain! {[\n+        let ExprMethodCall(method, _, ref len_args) = expr.node,\n+        len_args.len() == 1,\n+        method.node.as_str() == \"len\",\n+        let ExprPath(_, ref path) = len_args[0].node,\n+        path.segments.len() == 1,\n+        &path.segments[0].identifier.name == var\n+    ], {\n+        return true;\n+    }}\n+\n+    false\n+}\n \n+fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n     if let ExprRange(Some(ref start_expr), Some(ref stop_expr)) = arg.node {\n         // ...and both sides are compile-time constant integers...\n@@ -324,7 +371,9 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n             }\n         }\n     }\n+}\n \n+fn check_for_loop_explicit_iter(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     if let ExprMethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n@@ -356,6 +405,9 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n         }\n     }\n \n+}\n+\n+fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, expr: &Expr) {\n     // Look for variables that are incremented once per loop iteration.\n     let mut visitor = IncrementVisitor {\n         cx: cx,"}, {"sha": "312cf77d068ce2ca85d9ac1de0c5a6b2330096aa", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/387e0991e3be528ab85fce8f57c489949a7a41a5/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/387e0991e3be528ab85fce8f57c489949a7a41a5/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=387e0991e3be528ab85fce8f57c489949a7a41a5", "patch": "@@ -445,6 +445,7 @@ pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n     inner(ty, 0)\n }\n \n+/// Check whether the given expression is a constant literal of the given value.\n pub fn is_integer_literal(expr: &Expr, value: u64) -> bool {\n     // FIXME: use constant folding\n     if let ExprLit(ref spanned) = expr.node {"}, {"sha": "6791d71ca361836f1e0eac0280fbb80262251418", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/387e0991e3be528ab85fce8f57c489949a7a41a5/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/387e0991e3be528ab85fce8f57c489949a7a41a5/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=387e0991e3be528ab85fce8f57c489949a7a41a5", "patch": "@@ -20,20 +20,38 @@ impl Unrelated {\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];\n     let vec2 = vec![1, 2, 3, 4];\n-    for i in 0..vec.len() {      //~ERROR the loop variable `i` is only used to index `vec`.\n+    for i in 0..vec.len() {\n+        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in &vec`\n         println!(\"{}\", vec[i]);\n     }\n-    for i in 0..vec.len() {      //~ERROR the loop variable `i` is used to index `vec`.\n+    for i in 0..vec.len() {\n+        //~^ ERROR `i` is used to index `vec`. Consider using `for (i, item) in vec.iter().enumerate()`\n         println!(\"{} {}\", vec[i], i);\n     }\n     for i in 0..vec.len() {      // not an error, indexing more than one variable\n         println!(\"{} {}\", vec[i], vec2[i]);\n     }\n \n-    for i in 5..vec.len() {      // not an error, not starting with 0\n+    for i in 5..vec.len() {\n+        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().skip(5)`\n         println!(\"{}\", vec[i]);\n     }\n \n+    for i in 5..10 {\n+        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(10).skip(5)`\n+        println!(\"{}\", vec[i]);\n+    }\n+\n+    for i in 5..vec.len() {\n+        //~^ ERROR `i` is used to index `vec`. Consider using `for (i, item) in vec.iter().enumerate().skip(5)`\n+        println!(\"{} {}\", vec[i], i);\n+    }\n+\n+    for i in 5..10 {\n+        //~^ ERROR `i` is used to index `vec`. Consider using `for (i, item) in vec.iter().enumerate().take(10).skip(5)`\n+        println!(\"{} {}\", vec[i], i);\n+    }\n+\n     for i in 10..0 { //~ERROR this range is empty so this for loop will never run\n         println!(\"{}\", i);\n     }"}]}