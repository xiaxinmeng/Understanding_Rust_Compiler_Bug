{"sha": "11cc8024a1897a0c844a1f7aca4b20ee34b95b50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExY2M4MDI0YTE4OTdhMGM4NDRhMWY3YWNhNGIyMGVlMzRiOTViNTA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-03T17:54:54Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-03T17:54:54Z"}, "message": "Merge #1229\n\n1229: Mark unused mbe variable as `Binding::Empty` r=matklad a=edwin0cheng\n\nThis PR fixes a regression bug in In #1228, which incorrect expand an empty binding :\r\n\r\n* Introduce a new Binding type `Binding::Empty`.\r\n* Mark all unused binding variables are empty and error out in expansion instead of just by passing.\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "4e5c79b8302e416d02d95a11f71e13656a26b4fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e5c79b8302e416d02d95a11f71e13656a26b4fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11cc8024a1897a0c844a1f7aca4b20ee34b95b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11cc8024a1897a0c844a1f7aca4b20ee34b95b50", "html_url": "https://github.com/rust-lang/rust/commit/11cc8024a1897a0c844a1f7aca4b20ee34b95b50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11cc8024a1897a0c844a1f7aca4b20ee34b95b50/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "26b499811489f72ad5176d68d40c9a0748620417", "url": "https://api.github.com/repos/rust-lang/rust/commits/26b499811489f72ad5176d68d40c9a0748620417", "html_url": "https://github.com/rust-lang/rust/commit/26b499811489f72ad5176d68d40c9a0748620417"}, {"sha": "4ba4747578ba22033f6dc8ac9f429b678e37e578", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ba4747578ba22033f6dc8ac9f429b678e37e578", "html_url": "https://github.com/rust-lang/rust/commit/4ba4747578ba22033f6dc8ac9f429b678e37e578"}], "stats": {"total": 74, "additions": 61, "deletions": 13}, "files": [{"sha": "4b007647cf2c78d166393e335875b4edf7fa2408", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/11cc8024a1897a0c844a1f7aca4b20ee34b95b50/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11cc8024a1897a0c844a1f7aca4b20ee34b95b50/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=11cc8024a1897a0c844a1f7aca4b20ee34b95b50", "patch": "@@ -81,9 +81,25 @@ struct Bindings {\n enum Binding {\n     Simple(tt::TokenTree),\n     Nested(Vec<Binding>),\n+    Empty,\n }\n \n impl Bindings {\n+    fn push_optional(&mut self, name: &SmolStr) {\n+        // FIXME: Do we have a better way to represent an empty token ?\n+        // Insert an empty subtree for empty token\n+        self.inner.insert(\n+            name.clone(),\n+            Binding::Simple(\n+                tt::Subtree { delimiter: tt::Delimiter::None, token_trees: vec![] }.into(),\n+            ),\n+        );\n+    }\n+\n+    fn push_empty(&mut self, name: &SmolStr) {\n+        self.inner.insert(name.clone(), Binding::Empty);\n+    }\n+\n     fn contains(&self, name: &SmolStr) -> bool {\n         self.inner.contains_key(name)\n     }\n@@ -100,6 +116,12 @@ impl Bindings {\n                     \"could not find nested binding `{}`\",\n                     name\n                 )))?,\n+                Binding::Empty => {\n+                    return Err(ExpandError::BindingError(format!(\n+                        \"could not find empty binding `{}`\",\n+                        name\n+                    )))\n+                }\n             };\n         }\n         match b {\n@@ -108,6 +130,10 @@ impl Bindings {\n                 \"expected simple binding, found nested binding `{}`\",\n                 name\n             ))),\n+            Binding::Empty => Err(ExpandError::BindingError(format!(\n+                \"expected simple binding, found empty binding `{}`\",\n+                name\n+            ))),\n         }\n     }\n \n@@ -140,6 +166,24 @@ impl Bindings {\n     }\n }\n \n+fn collect_vars(subtree: &crate::Subtree) -> Vec<SmolStr> {\n+    let mut res = vec![];\n+\n+    for tkn in subtree.token_trees.iter() {\n+        match tkn {\n+            crate::TokenTree::Leaf(crate::Leaf::Var(crate::Var { text, .. })) => {\n+                res.push(text.clone());\n+            }\n+            crate::TokenTree::Subtree(subtree) => {\n+                res.extend(collect_vars(subtree));\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    res\n+}\n+\n fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings, ExpandError> {\n     let mut res = Bindings::default();\n     for pat in pattern.token_trees.iter() {\n@@ -217,18 +261,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                                 let vis = vis.clone();\n                                 res.inner.insert(text.clone(), Binding::Simple(vis.into()));\n                             } else {\n-                                // FIXME: Do we have a better way to represent an empty token ?\n-                                // Insert an empty subtree for empty token\n-                                res.inner.insert(\n-                                    text.clone(),\n-                                    Binding::Simple(\n-                                        tt::Subtree {\n-                                            delimiter: tt::Delimiter::None,\n-                                            token_trees: vec![],\n-                                        }\n-                                        .into(),\n-                                    ),\n-                                );\n+                                res.push_optional(&text);\n                             }\n                         }\n \n@@ -295,6 +328,10 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                     crate::RepeatKind::OneOrMore if counter == 0 => {\n                         return Err(ExpandError::UnexpectedToken);\n                     }\n+                    _ if counter == 0 => {\n+                        // Collect all empty variables in subtrees\n+                        collect_vars(subtree).iter().for_each(|s| res.push_empty(s));\n+                    }\n                     _ => {}\n                 }\n             }"}, {"sha": "bd5a44240b0688cba08a1669ba97d48c7bf926bd", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/11cc8024a1897a0c844a1f7aca4b20ee34b95b50/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11cc8024a1897a0c844a1f7aca4b20ee34b95b50/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=11cc8024a1897a0c844a1f7aca4b20ee34b95b50", "patch": "@@ -1244,7 +1244,12 @@ fn test_cfg_if_main() {\n                     $( ( ($($meta),*) ($($it)*) ), )*\n                     ( () ($($it2)*) ),\n                 }\n-            }\n+            };\n+\n+            // Internal macro to Apply a cfg attribute to a list of items\n+            (@__apply $m:meta, $($it:item)*) => {\n+                $(#[$m] $it)*\n+            };\n         }\n \"#,\n     );\n@@ -1262,6 +1267,12 @@ cfg_if !   {\n  }        \n \"#,         \n         \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\");\n+\n+    assert_expansion(MacroKind::Items, &rules, r#\"\n+cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" , target_os = \"illumos\" ) ) ) ) ) ) , }    \n+\"#,\n+        \"\"    \n+    );\n }\n \n #[test]"}]}