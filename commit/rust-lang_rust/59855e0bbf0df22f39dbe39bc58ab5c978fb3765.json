{"sha": "59855e0bbf0df22f39dbe39bc58ab5c978fb3765", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ODU1ZTBiYmYwZGYyMmYzOWRiZTM5YmM1OGFiNWM5NzhmYjM3NjU=", "commit": {"author": {"name": "Arlie Davis", "email": "ardavis@microsoft.com", "date": "2021-01-21T20:13:35Z"}, "committer": {"name": "Arlie Davis", "email": "ardavis@microsoft.com", "date": "2021-01-22T10:02:39Z"}, "message": "Remove delay-binding for Win XP and Vista\n\nThe minimum supported Windows version is now Windows 7. Windows XP\nand Windows Vista are no longer supported; both are already broken, and\nrequire extra steps to use.\n\nThis commit removes the delayed-binding support for Windows API\nfunctions that are present on all supported Windows targets. This has\nseveral benefits: Removes needless complexity. Removes a load and\ndynamic call on hot paths in mutex acquire / release. This may have\nperformance benefits.\n\n* \"Drop official support for Windows XP\"\n  https://github.com/rust-lang/compiler-team/issues/378\n\n* \"Firefox has ended support for Windows XP and Vista\"\n  https://support.mozilla.org/en-US/kb/end-support-windows-xp-and-vista", "tree": {"sha": "acc412100caaff41e2adcaadb379ee2a492159a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acc412100caaff41e2adcaadb379ee2a492159a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59855e0bbf0df22f39dbe39bc58ab5c978fb3765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59855e0bbf0df22f39dbe39bc58ab5c978fb3765", "html_url": "https://github.com/rust-lang/rust/commit/59855e0bbf0df22f39dbe39bc58ab5c978fb3765", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59855e0bbf0df22f39dbe39bc58ab5c978fb3765/comments", "author": null, "committer": null, "parents": [{"sha": "25f39fe80293f77bd86f64a1261a3e2c0ca23847", "url": "https://api.github.com/repos/rust-lang/rust/commits/25f39fe80293f77bd86f64a1261a3e2c0ca23847", "html_url": "https://github.com/rust-lang/rust/commit/25f39fe80293f77bd86f64a1261a3e2c0ca23847"}], "stats": {"total": 226, "additions": 81, "deletions": 145}, "files": [{"sha": "f43a19d91b657f4899ba0445c2d375d5495a006e", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 63, "deletions": 53, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/59855e0bbf0df22f39dbe39bc58ab5c978fb3765/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59855e0bbf0df22f39dbe39bc58ab5c978fb3765/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=59855e0bbf0df22f39dbe39bc58ab5c978fb3765", "patch": "@@ -1020,77 +1020,87 @@ extern \"system\" {\n     pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n     pub fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n     pub fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n+\n+    // >= Vista / Server 2008\n+    // https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinka\n+    pub fn CreateSymbolicLinkW(\n+        lpSymlinkFileName: LPCWSTR,\n+        lpTargetFileName: LPCWSTR,\n+        dwFlags: DWORD,\n+    ) -> BOOLEAN;\n+\n+    // >= Vista / Server 2008\n+    // https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfinalpathnamebyhandlew\n+    pub fn GetFinalPathNameByHandleW(\n+        hFile: HANDLE,\n+        lpszFilePath: LPCWSTR,\n+        cchFilePath: DWORD,\n+        dwFlags: DWORD,\n+    ) -> DWORD;\n+\n+    // >= Vista / Server 2003\n+    // https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadstackguarantee\n+    #[cfg(not(target_vendor = \"uwp\"))]\n+    pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;\n+\n+    // >= Vista / Server 2008\n+    // https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfileinformationbyhandle\n+    pub fn SetFileInformationByHandle(\n+        hFile: HANDLE,\n+        FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n+        lpFileInformation: LPVOID,\n+        dwBufferSize: DWORD,\n+    ) -> BOOL;\n+\n+    // >= Vista / Server 2008\n+    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepconditionvariablesrw\n+    pub fn SleepConditionVariableSRW(\n+        ConditionVariable: PCONDITION_VARIABLE,\n+        SRWLock: PSRWLOCK,\n+        dwMilliseconds: DWORD,\n+        Flags: ULONG,\n+    ) -> BOOL;\n+\n+    // >= Vista / Server 2008\n+    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-wakeconditionvariable\n+    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n+    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n+\n+    // >= Vista / Server 2008\n+    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-acquiresrwlockexclusive\n+    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);\n+    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);\n+    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);\n+    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);\n+    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;\n+    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n }\n \n // Functions that aren't available on every version of Windows that we support,\n // but we still use them and just provide some form of a fallback implementation.\n compat_fn! {\n     \"kernel32\":\n \n-    pub fn CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n-                               _lpTargetFileName: LPCWSTR,\n-                               _dwFlags: DWORD) -> BOOLEAN {\n-        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-    }\n-    pub fn GetFinalPathNameByHandleW(_hFile: HANDLE,\n-                                     _lpszFilePath: LPCWSTR,\n-                                     _cchFilePath: DWORD,\n-                                     _dwFlags: DWORD) -> DWORD {\n-        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-    }\n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL {\n-        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-    }\n+    // >= Win10 1607\n+    // https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreaddescription\n     pub fn SetThreadDescription(hThread: HANDLE,\n                                 lpThreadDescription: LPCWSTR) -> HRESULT {\n         SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); E_NOTIMPL\n     }\n-    pub fn SetFileInformationByHandle(_hFile: HANDLE,\n-                    _FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n-                    _lpFileInformation: LPVOID,\n-                    _dwBufferSize: DWORD) -> BOOL {\n-        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-    }\n+\n+    // >= Win8 / Server 2012\n+    // https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsystemtimepreciseasfiletime\n     pub fn GetSystemTimePreciseAsFileTime(lpSystemTimeAsFileTime: LPFILETIME)\n                                           -> () {\n         GetSystemTimeAsFileTime(lpSystemTimeAsFileTime)\n     }\n-    pub fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE,\n-                                     SRWLock: PSRWLOCK,\n-                                     dwMilliseconds: DWORD,\n-                                     Flags: ULONG) -> BOOL {\n-        panic!(\"condition variables not available\")\n-    }\n-    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE)\n-                                 -> () {\n-        panic!(\"condition variables not available\")\n-    }\n-    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE)\n-                                    -> () {\n-        panic!(\"condition variables not available\")\n-    }\n-    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> () {\n-        panic!(\"rwlocks not available\")\n-    }\n-    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK) -> () {\n-        panic!(\"rwlocks not available\")\n-    }\n-    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK) -> () {\n-        panic!(\"rwlocks not available\")\n-    }\n-    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK) -> () {\n-        panic!(\"rwlocks not available\")\n-    }\n-    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN {\n-        panic!(\"rwlocks not available\")\n-    }\n-    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN {\n-        panic!(\"rwlocks not available\")\n-    }\n }\n+\n compat_fn! {\n     \"api-ms-win-core-synch-l1-2-0\":\n+\n+    // >= Windows 8 / Server 2012\n+    // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress\n     pub fn WaitOnAddress(\n         Address: LPVOID,\n         CompareAddress: LPVOID,"}, {"sha": "72a0993d94ddf12960648e149e92a33dc0fcde3b", "filename": "library/std/src/sys/windows/mutex.rs", "status": "modified", "additions": 18, "deletions": 92, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/59855e0bbf0df22f39dbe39bc58ab5c978fb3765/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59855e0bbf0df22f39dbe39bc58ab5c978fb3765/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs?ref=59855e0bbf0df22f39dbe39bc58ab5c978fb3765", "patch": "@@ -13,20 +13,13 @@\n //!\n //! 3. While CriticalSection is fair and SRWLock is not, the current Rust policy\n //!    is that there are no guarantees of fairness.\n-//!\n-//! The downside of this approach, however, is that SRWLock is not available on\n-//! Windows XP, so we continue to have a fallback implementation where\n-//! CriticalSection is used and we keep track of who's holding the mutex to\n-//! detect recursive locks.\n-\n-use crate::cell::{Cell, UnsafeCell};\n-use crate::mem::{self, MaybeUninit};\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n+\n+use crate::cell::UnsafeCell;\n+use crate::mem::MaybeUninit;\n use crate::sys::c;\n \n pub struct Mutex {\n-    // This is either directly an SRWLOCK (if supported), or a Box<Inner> otherwise.\n-    lock: AtomicUsize,\n+    srwlock: UnsafeCell<c::SRWLOCK>,\n }\n \n // Windows SRW Locks are movable (while not borrowed).\n@@ -37,106 +30,39 @@ pub type MovableMutex = Mutex;\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n-struct Inner {\n-    remutex: ReentrantMutex,\n-    held: Cell<bool>,\n-}\n-\n-#[derive(Clone, Copy)]\n-enum Kind {\n-    SRWLock,\n-    CriticalSection,\n-}\n-\n #[inline]\n pub unsafe fn raw(m: &Mutex) -> c::PSRWLOCK {\n-    debug_assert!(mem::size_of::<c::SRWLOCK>() <= mem::size_of_val(&m.lock));\n-    &m.lock as *const _ as *mut _\n+    m.srwlock.get()\n }\n \n impl Mutex {\n     pub const fn new() -> Mutex {\n-        Mutex {\n-            // This works because SRWLOCK_INIT is 0 (wrapped in a struct), so we are also properly\n-            // initializing an SRWLOCK here.\n-            lock: AtomicUsize::new(0),\n-        }\n+        Mutex { srwlock: UnsafeCell::new(c::SRWLOCK_INIT) }\n     }\n     #[inline]\n     pub unsafe fn init(&mut self) {}\n+\n+    #[inline]\n     pub unsafe fn lock(&self) {\n-        match kind() {\n-            Kind::SRWLock => c::AcquireSRWLockExclusive(raw(self)),\n-            Kind::CriticalSection => {\n-                let inner = &*self.inner();\n-                inner.remutex.lock();\n-                if inner.held.replace(true) {\n-                    // It was already locked, so we got a recursive lock which we do not want.\n-                    inner.remutex.unlock();\n-                    panic!(\"cannot recursively lock a mutex\");\n-                }\n-            }\n-        }\n+        c::AcquireSRWLockExclusive(raw(self));\n     }\n+\n+    #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        match kind() {\n-            Kind::SRWLock => c::TryAcquireSRWLockExclusive(raw(self)) != 0,\n-            Kind::CriticalSection => {\n-                let inner = &*self.inner();\n-                if !inner.remutex.try_lock() {\n-                    false\n-                } else if inner.held.replace(true) {\n-                    // It was already locked, so we got a recursive lock which we do not want.\n-                    inner.remutex.unlock();\n-                    false\n-                } else {\n-                    true\n-                }\n-            }\n-        }\n+        c::TryAcquireSRWLockExclusive(raw(self)) != 0\n     }\n+\n+    #[inline]\n     pub unsafe fn unlock(&self) {\n-        match kind() {\n-            Kind::SRWLock => c::ReleaseSRWLockExclusive(raw(self)),\n-            Kind::CriticalSection => {\n-                let inner = &*(self.lock.load(Ordering::SeqCst) as *const Inner);\n-                inner.held.set(false);\n-                inner.remutex.unlock();\n-            }\n-        }\n-    }\n-    pub unsafe fn destroy(&self) {\n-        match kind() {\n-            Kind::SRWLock => {}\n-            Kind::CriticalSection => match self.lock.load(Ordering::SeqCst) {\n-                0 => {}\n-                n => Box::from_raw(n as *mut Inner).remutex.destroy(),\n-            },\n-        }\n+        c::ReleaseSRWLockExclusive(raw(self));\n     }\n \n-    unsafe fn inner(&self) -> *const Inner {\n-        match self.lock.load(Ordering::SeqCst) {\n-            0 => {}\n-            n => return n as *const _,\n-        }\n-        let inner = box Inner { remutex: ReentrantMutex::uninitialized(), held: Cell::new(false) };\n-        inner.remutex.init();\n-        let inner = Box::into_raw(inner);\n-        match self.lock.compare_exchange(0, inner as usize, Ordering::SeqCst, Ordering::SeqCst) {\n-            Ok(_) => inner,\n-            Err(n) => {\n-                Box::from_raw(inner).remutex.destroy();\n-                n as *const _\n-            }\n-        }\n+    #[inline]\n+    pub unsafe fn destroy(&self) {\n+        // SRWLock does not need to be destroyed.\n     }\n }\n \n-fn kind() -> Kind {\n-    if c::AcquireSRWLockExclusive::is_available() { Kind::SRWLock } else { Kind::CriticalSection }\n-}\n-\n pub struct ReentrantMutex {\n     inner: MaybeUninit<UnsafeCell<c::CRITICAL_SECTION>>,\n }"}]}