{"sha": "e8bb6c05ab455999ccfe10e178bc2ada9d450187", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YmI2YzA1YWI0NTU5OTljY2ZlMTBlMTc4YmMyYWRhOWQ0NTAxODc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-07T07:15:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-07T07:15:19Z"}, "message": "Rollup merge of #67741 - estebank:point-at-pat-def, r=Centril\n\nWhen encountering an Item in a pat context, point at the item def\n\n```\nerror[E0308]: mismatched types\n  --> $DIR/const-in-struct-pat.rs:8:17\n   |\nLL | struct foo;\n   | ----------- `foo` defined here\n...\nLL |     let Thing { foo } = t;\n   |                 ^^^ expected struct `std::string::String`, found struct `foo`\n   |\n   = note: `foo` is interpreted as a unit struct, not a new binding\nhelp: you can bind the struct field to a different name\n   |\nLL |     let Thing { foo: other_foo } = t;\n   |                 ^^^^^^^^^^^^^^\n```\n```\nerror[E0308]: mismatched types\n  --> $DIR/const.rs:14:9\n   |\nLL | const FOO: Foo = Foo{bar: 5};\n   | ----------------------------- constant defined here\n...\nLL |         FOO => {},\n   |         ^^^\n   |         |\n   |         expected `&Foo`, found struct `Foo`\n   |         `FOO` is interpreted as a constant, not a new binding\n   |         help: use different name to introduce a new binding: `other_foo`\n```\n\nFix #55631, fix #48062, cc #42876.", "tree": {"sha": "3ab5e5734a1bb4a0794de59141b975ea13120b3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ab5e5734a1bb4a0794de59141b975ea13120b3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8bb6c05ab455999ccfe10e178bc2ada9d450187", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeY0oHCRBK7hj4Ov3rIwAAdHIIADDIHrFq8EuExAboLnUUImcC\nCF3/MJlc1nwLl9v5mTjlNk4oDtaBXLeKDtkciCQH42y0Et6QqMJlyKJI5OiS4/dZ\n3ndySsYe32ObkE07A8WXWnjovRsgg/gERNXrZkWdAz4rDnHqc3OaOfOQbOxTFYLO\n88V9skzdkl15NfWrKWob+RGD+h2kaUO/zdXVfDXNG+fgAU/D5FxlmwepcgpweAAH\nRq5cF8yu8n7gTDjuCxBvgGufanrBGEumzFIDEsQeZEFc8IND3uxprsPWwEkdC04U\nxUMQVNqBIN+qj3MYgbe4Q96qx6K6h8GoUatgu3PkM8iIn1FY10bXWvTCAF1+DgE=\n=utm9\n-----END PGP SIGNATURE-----\n", "payload": "tree 3ab5e5734a1bb4a0794de59141b975ea13120b3d\nparent 2890b37b861247de3b8c6ba2ecbcd00048c728a1\nparent 125159f30a7a97b0b4d4bc36b11846a3f6dd4a7b\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1583565319 +0100\ncommitter GitHub <noreply@github.com> 1583565319 +0100\n\nRollup merge of #67741 - estebank:point-at-pat-def, r=Centril\n\nWhen encountering an Item in a pat context, point at the item def\n\n```\nerror[E0308]: mismatched types\n  --> $DIR/const-in-struct-pat.rs:8:17\n   |\nLL | struct foo;\n   | ----------- `foo` defined here\n...\nLL |     let Thing { foo } = t;\n   |                 ^^^ expected struct `std::string::String`, found struct `foo`\n   |\n   = note: `foo` is interpreted as a unit struct, not a new binding\nhelp: you can bind the struct field to a different name\n   |\nLL |     let Thing { foo: other_foo } = t;\n   |                 ^^^^^^^^^^^^^^\n```\n```\nerror[E0308]: mismatched types\n  --> $DIR/const.rs:14:9\n   |\nLL | const FOO: Foo = Foo{bar: 5};\n   | ----------------------------- constant defined here\n...\nLL |         FOO => {},\n   |         ^^^\n   |         |\n   |         expected `&Foo`, found struct `Foo`\n   |         `FOO` is interpreted as a constant, not a new binding\n   |         help: use different name to introduce a new binding: `other_foo`\n```\n\nFix #55631, fix #48062, cc #42876.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8bb6c05ab455999ccfe10e178bc2ada9d450187", "html_url": "https://github.com/rust-lang/rust/commit/e8bb6c05ab455999ccfe10e178bc2ada9d450187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8bb6c05ab455999ccfe10e178bc2ada9d450187/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2890b37b861247de3b8c6ba2ecbcd00048c728a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2890b37b861247de3b8c6ba2ecbcd00048c728a1", "html_url": "https://github.com/rust-lang/rust/commit/2890b37b861247de3b8c6ba2ecbcd00048c728a1"}, {"sha": "125159f30a7a97b0b4d4bc36b11846a3f6dd4a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/125159f30a7a97b0b4d4bc36b11846a3f6dd4a7b", "html_url": "https://github.com/rust-lang/rust/commit/125159f30a7a97b0b4d4bc36b11846a3f6dd4a7b"}], "stats": {"total": 175, "additions": 147, "deletions": 28}, "files": [{"sha": "dd4b407ac52cbb22f18de775e20168261e0f395d", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 79, "deletions": 24, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -63,6 +63,22 @@ struct TopInfo<'tcx> {\n     ///              found type `std::result::Result<_, _>`\n     /// ```\n     span: Option<Span>,\n+    /// This refers to the parent pattern. Used to provide extra diagnostic information on errors.\n+    /// ```text\n+    /// error[E0308]: mismatched types\n+    ///   --> $DIR/const-in-struct-pat.rs:8:17\n+    ///   |\n+    /// L | struct f;\n+    ///   | --------- unit struct defined here\n+    /// ...\n+    /// L |     let Thing { f } = t;\n+    ///   |                 ^\n+    ///   |                 |\n+    ///   |                 expected struct `std::string::String`, found struct `f`\n+    ///   |                 `f` is interpreted as a unit struct, not a new binding\n+    ///   |                 help: bind the struct field to a different name instead: `f: other_f`\n+    /// ```\n+    parent_pat: Option<&'tcx Pat<'tcx>>,\n }\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n@@ -120,7 +136,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Option<Span>,\n         origin_expr: bool,\n     ) {\n-        self.check_pat(pat, expected, INITIAL_BM, TopInfo { expected, origin_expr, span });\n+        let info = TopInfo { expected, origin_expr, span, parent_pat: None };\n+        self.check_pat(pat, expected, INITIAL_BM, info);\n     }\n \n     /// Type check the given `pat` against the `expected` type\n@@ -161,8 +178,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n             }\n             PatKind::Or(pats) => {\n+                let parent_pat = Some(pat);\n                 for pat in pats {\n-                    self.check_pat(pat, expected, def_bm, ti);\n+                    self.check_pat(pat, expected, def_bm, TopInfo { parent_pat, ..ti });\n                 }\n                 expected\n             }\n@@ -501,7 +519,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ident(\n         &self,\n-        pat: &Pat<'_>,\n+        pat: &'tcx Pat<'tcx>,\n         ba: hir::BindingAnnotation,\n         var_id: HirId,\n         sub: Option<&'tcx Pat<'tcx>>,\n@@ -546,7 +564,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(p) = sub {\n-            self.check_pat(&p, expected, def_bm, ti);\n+            self.check_pat(&p, expected, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n         }\n \n         local_ty\n@@ -647,6 +665,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             variant_ty\n         } else {\n             for field in fields {\n+                let ti = TopInfo { parent_pat: Some(&pat), ..ti };\n                 self.check_pat(&field.pat, self.tcx.types.err, def_bm, ti);\n             }\n             return self.tcx.types.err;\n@@ -656,9 +675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.demand_eqtype_pat(pat.span, expected, pat_ty, ti);\n \n         // Type-check subpatterns.\n-        if self\n-            .check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm, ti)\n-        {\n+        if self.check_struct_pat_fields(pat_ty, &pat, variant, fields, etc, def_bm, ti) {\n             pat_ty\n         } else {\n             self.tcx.types.err\n@@ -696,18 +713,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // Type-check the path.\n-        let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n-        if let Some(mut err) =\n+        let (pat_ty, pat_res) =\n+            self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id);\n+        if let Some(err) =\n             self.demand_suptype_with_origin(&self.pattern_cause(ti, pat.span), expected, pat_ty)\n         {\n-            err.emit();\n+            self.emit_bad_pat_path(err, pat.span, res, pat_res, segments, ti.parent_pat);\n         }\n         pat_ty\n     }\n \n+    fn emit_bad_pat_path(\n+        &self,\n+        mut e: DiagnosticBuilder<'_>,\n+        pat_span: Span,\n+        res: Res,\n+        pat_res: Res,\n+        segments: &'b [hir::PathSegment<'b>],\n+        parent_pat: Option<&Pat<'_>>,\n+    ) {\n+        if let Some(span) = self.tcx.hir().res_span(pat_res) {\n+            e.span_label(span, &format!(\"{} defined here\", res.descr()));\n+            if let [hir::PathSegment { ident, .. }] = &*segments {\n+                e.span_label(\n+                    pat_span,\n+                    &format!(\n+                        \"`{}` is interpreted as {} {}, not a new binding\",\n+                        ident,\n+                        res.article(),\n+                        res.descr(),\n+                    ),\n+                );\n+                let (msg, sugg) = match parent_pat {\n+                    Some(Pat { kind: hir::PatKind::Struct(..), .. }) => (\n+                        \"bind the struct field to a different name instead\",\n+                        format!(\"{}: other_{}\", ident, ident.as_str().to_lowercase()),\n+                    ),\n+                    _ => (\n+                        \"introduce a new binding instead\",\n+                        format!(\"other_{}\", ident.as_str().to_lowercase()),\n+                    ),\n+                };\n+                e.span_suggestion(ident.span, msg, sugg, Applicability::HasPlaceholders);\n+            }\n+        }\n+        e.emit();\n+    }\n+\n     fn check_pat_tuple_struct(\n         &self,\n-        pat: &Pat<'_>,\n+        pat: &'tcx Pat<'tcx>,\n         qpath: &hir::QPath<'_>,\n         subpats: &'tcx [&'tcx Pat<'tcx>],\n         ddpos: Option<usize>,\n@@ -717,8 +772,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let on_error = || {\n+            let parent_pat = Some(pat);\n             for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err, def_bm, ti);\n+                self.check_pat(&pat, tcx.types.err, def_bm, TopInfo { parent_pat, ..ti });\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -793,7 +849,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat(&subpat, field_ty, def_bm, ti);\n+                self.check_pat(&subpat, field_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n \n                 self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n             }\n@@ -938,8 +994,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_struct_pat_fields(\n         &self,\n         adt_ty: Ty<'tcx>,\n-        pat_id: HirId,\n-        span: Span,\n+        pat: &'tcx Pat<'tcx>,\n         variant: &'tcx ty::VariantDef,\n         fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n@@ -950,7 +1005,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (substs, adt) = match adt_ty.kind {\n             ty::Adt(adt, substs) => (substs, adt),\n-            _ => span_bug!(span, \"struct pattern is not an ADT\"),\n+            _ => span_bug!(pat.span, \"struct pattern is not an ADT\"),\n         };\n         let kind_name = adt.variant_descr();\n \n@@ -983,7 +1038,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .get(&ident)\n                         .map(|(i, f)| {\n                             self.write_field_index(field.hir_id, *i);\n-                            self.tcx.check_stability(f.did, Some(pat_id), span);\n+                            self.tcx.check_stability(f.did, Some(pat.hir_id), span);\n                             self.field_ty(span, f, substs)\n                         })\n                         .unwrap_or_else(|| {\n@@ -994,7 +1049,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.check_pat(&field.pat, field_ty, def_bm, ti);\n+            self.check_pat(&field.pat, field_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n         }\n \n         let mut unmentioned_fields = variant\n@@ -1017,7 +1072,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n             struct_span_err!(\n                 tcx.sess,\n-                span,\n+                pat.span,\n                 E0638,\n                 \"`..` required with {} marked as non-exhaustive\",\n                 kind_name\n@@ -1029,14 +1084,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if kind_name == \"union\" {\n             if fields.len() != 1 {\n                 tcx.sess\n-                    .struct_span_err(span, \"union patterns should have exactly one field\")\n+                    .struct_span_err(pat.span, \"union patterns should have exactly one field\")\n                     .emit();\n             }\n             if etc {\n-                tcx.sess.struct_span_err(span, \"`..` cannot be used in union patterns\").emit();\n+                tcx.sess.struct_span_err(pat.span, \"`..` cannot be used in union patterns\").emit();\n             }\n         } else if !etc && !unmentioned_fields.is_empty() {\n-            self.error_unmentioned_fields(span, &unmentioned_fields, variant);\n+            self.error_unmentioned_fields(pat.span, &unmentioned_fields, variant);\n         }\n         no_field_errors\n     }\n@@ -1196,7 +1251,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_pat_ref(\n         &self,\n-        pat: &Pat<'_>,\n+        pat: &'tcx Pat<'tcx>,\n         inner: &'tcx Pat<'tcx>,\n         mutbl: hir::Mutability,\n         expected: Ty<'tcx>,\n@@ -1236,7 +1291,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             (tcx.types.err, tcx.types.err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, ti);\n+        self.check_pat(&inner, inner_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n         rptr_ty\n     }\n "}, {"sha": "d8d15615d7c338ac8f99466d51ce11460dc26d30", "filename": "src/test/ui/blind/blind-item-block-middle.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fblind%2Fblind-item-block-middle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fblind%2Fblind-item-block-middle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblind%2Fblind-item-block-middle.stderr?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -1,8 +1,15 @@\n error[E0308]: mismatched types\n   --> $DIR/blind-item-block-middle.rs:6:9\n    |\n+LL | mod foo { pub struct bar; }\n+   |           --------------- unit struct defined here\n+...\n LL |     let bar = 5;\n-   |         ^^^ expected integer, found struct `foo::bar`\n+   |         ^^^\n+   |         |\n+   |         expected integer, found struct `foo::bar`\n+   |         `bar` is interpreted as a unit struct, not a new binding\n+   |         help: introduce a new binding instead: `other_bar`\n \n error: aborting due to previous error\n "}, {"sha": "1e61178f42edbca6727c7e20d382f088a3c806d8", "filename": "src/test/ui/issues/issue-33504.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fissues%2Fissue-33504.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fissues%2Fissue-33504.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33504.stderr?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -1,8 +1,15 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-33504.rs:7:13\n    |\n+LL | struct Test;\n+   | ------------ unit struct defined here\n+...\n LL |         let Test = 1;\n-   |             ^^^^ expected integer, found struct `Test`\n+   |             ^^^^\n+   |             |\n+   |             expected integer, found struct `Test`\n+   |             `Test` is interpreted as a unit struct, not a new binding\n+   |             help: introduce a new binding instead: `other_test`\n \n error: aborting due to previous error\n "}, {"sha": "5451cf423559ed14d681785ac1f503ac07b81a4d", "filename": "src/test/ui/issues/issue-4968.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fissues%2Fissue-4968.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fissues%2Fissue-4968.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4968.stderr?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -1,8 +1,15 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-4968.rs:5:16\n    |\n+LL | const A: (isize,isize) = (4,2);\n+   | ------------------------------- constant defined here\n+LL | fn main() {\n LL |     match 42 { A => () }\n-   |                ^ expected integer, found tuple\n+   |                ^\n+   |                |\n+   |                expected integer, found tuple\n+   |                `A` is interpreted as a constant, not a new binding\n+   |                help: introduce a new binding instead: `other_a`\n    |\n    = note: expected type `{integer}`\n              found tuple `(isize, isize)`"}, {"sha": "a89980964ca0ab56afe3cbbd9fb77b1d82b811e8", "filename": "src/test/ui/issues/issue-5100.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:8:9\n    |\n+LL | enum A { B, C }\n+   |          - unit variant defined here\n+...\n LL |     match (true, false) {\n    |           ------------- this expression has type `(bool, bool)`\n LL |         A::B => (),"}, {"sha": "0d3121d60455d95c6df8c9602f338e26aca8701b", "filename": "src/test/ui/issues/issue-7867.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7867.stderr?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-7867.rs:7:9\n    |\n+LL | enum A { B, C }\n+   |          - unit variant defined here\n+...\n LL |     match (true, false) {\n    |           ------------- this expression has type `(bool, bool)`\n LL |         A::B => (),"}, {"sha": "723c7fa92b10d00e68495694d61285687e70f944", "filename": "src/test/ui/match/match-tag-nullary.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-nullary.stderr?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/match-tag-nullary.rs:4:40\n    |\n+LL | enum B { B }\n+   |          - unit variant defined here\n+LL | \n LL | fn main() { let x: A = A::A; match x { B::B => { } } }\n    |                                    -   ^^^^ expected enum `A`, found enum `B`\n    |                                    |"}, {"sha": "10d30ec1a1b189941d8143a2b559d264b3718895", "filename": "src/test/ui/rfc-2005-default-binding-mode/const.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fconst.stderr?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -1,10 +1,17 @@\n error[E0308]: mismatched types\n   --> $DIR/const.rs:14:9\n    |\n+LL | const FOO: Foo = Foo{bar: 5};\n+   | ----------------------------- constant defined here\n+...\n LL |     match &f {\n    |           -- this expression has type `&Foo`\n LL |         FOO => {},\n-   |         ^^^ expected `&Foo`, found struct `Foo`\n+   |         ^^^\n+   |         |\n+   |         expected `&Foo`, found struct `Foo`\n+   |         `FOO` is interpreted as a constant, not a new binding\n+   |         help: introduce a new binding instead: `other_foo`\n \n error: aborting due to previous error\n "}, {"sha": "1cbba935402a90a398c23516952e496a392a0c15", "filename": "src/test/ui/suggestions/const-in-struct-pat.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.rs?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -0,0 +1,11 @@\n+#[allow(non_camel_case_types)]\n+struct foo;\n+struct Thing {\n+    foo: String,\n+}\n+\n+fn example(t: Thing) {\n+    let Thing { foo } = t; //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "0a010dcab4c26ba5f193adbe7d495f5a827fa6fc", "filename": "src/test/ui/suggestions/const-in-struct-pat.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8bb6c05ab455999ccfe10e178bc2ada9d450187/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-in-struct-pat.stderr?ref=e8bb6c05ab455999ccfe10e178bc2ada9d450187", "patch": "@@ -0,0 +1,16 @@\n+error[E0308]: mismatched types\n+  --> $DIR/const-in-struct-pat.rs:8:17\n+   |\n+LL | struct foo;\n+   | ----------- unit struct defined here\n+...\n+LL |     let Thing { foo } = t;\n+   |                 ^^^     - this expression has type `Thing`\n+   |                 |\n+   |                 expected struct `std::string::String`, found struct `foo`\n+   |                 `foo` is interpreted as a unit struct, not a new binding\n+   |                 help: bind the struct field to a different name instead: `foo: other_foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}