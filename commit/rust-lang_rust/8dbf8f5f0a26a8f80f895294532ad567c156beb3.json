{"sha": "8dbf8f5f0a26a8f80f895294532ad567c156beb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYmY4ZjVmMGEyNmE4ZjgwZjg5NTI5NDUzMmFkNTY3YzE1NmJlYjM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-04-16T01:10:59Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-04-24T17:59:44Z"}, "message": "syntax: Don't rely on token::IdentStyle in the parser", "tree": {"sha": "5b0fcc8d207f3a59dbdca97c5d71f2fd2db511e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b0fcc8d207f3a59dbdca97c5d71f2fd2db511e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dbf8f5f0a26a8f80f895294532ad567c156beb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dbf8f5f0a26a8f80f895294532ad567c156beb3", "html_url": "https://github.com/rust-lang/rust/commit/8dbf8f5f0a26a8f80f895294532ad567c156beb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dbf8f5f0a26a8f80f895294532ad567c156beb3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d0dd7876e733555b0284e9b6cbf0f33ed792b67", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0dd7876e733555b0284e9b6cbf0f33ed792b67", "html_url": "https://github.com/rust-lang/rust/commit/8d0dd7876e733555b0284e9b6cbf0f33ed792b67"}], "stats": {"total": 190, "additions": 55, "deletions": 135}, "files": [{"sha": "b81ee67c2141c5a0965eaf74fbe25c33ac07bf5c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 69, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8dbf8f5f0a26a8f80f895294532ad567c156beb3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbf8f5f0a26a8f80f895294532ad567c156beb3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8dbf8f5f0a26a8f80f895294532ad567c156beb3", "patch": "@@ -297,8 +297,8 @@ impl TokenType {\n     }\n }\n \n-fn is_plain_ident_or_underscore(t: &token::Token) -> bool {\n-    t.is_plain_ident() || *t == token::Underscore\n+fn is_ident_or_underscore(t: &token::Token) -> bool {\n+    t.is_ident() || *t == token::Underscore\n }\n \n /// Information about the path to a module.\n@@ -585,14 +585,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_ident_or_self_type(&mut self) -> PResult<'a, ast::Ident> {\n-        if self.is_self_type_ident() {\n-            self.expect_self_type_ident()\n-        } else {\n-            self.parse_ident()\n-        }\n-    }\n-\n     /// Check if the next token is `tok`, and return `true` if so.\n     ///\n     /// This method will automatically add `tok` to `expected_tokens` if `tok` is not\n@@ -1476,9 +1468,7 @@ impl<'a> Parser<'a> {\n                  self.parse_qualified_path(NoTypesAllowed)?;\n \n             TyKind::Path(Some(qself), path)\n-        } else if self.check(&token::ModSep) ||\n-                  self.token.is_ident() ||\n-                  self.token.is_path() {\n+        } else if self.is_path_start() {\n             let path = self.parse_path(LifetimeAndTypesWithoutColons)?;\n             if self.check(&token::Not) {\n                 // MACRO INVOCATION\n@@ -1541,10 +1531,10 @@ impl<'a> Parser<'a> {\n         debug!(\"parser is_named_argument offset:{}\", offset);\n \n         if offset == 0 {\n-            is_plain_ident_or_underscore(&self.token)\n+            is_ident_or_underscore(&self.token)\n                 && self.look_ahead(1, |t| *t == token::Colon)\n         } else {\n-            self.look_ahead(offset, |t| is_plain_ident_or_underscore(t))\n+            self.look_ahead(offset, |t| is_ident_or_underscore(t))\n                 && self.look_ahead(offset + 1, |t| *t == token::Colon)\n         }\n     }\n@@ -1707,6 +1697,16 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> {\n+        match self.token {\n+            token::Ident(sid, _) if self.token.is_path_segment_keyword() => {\n+                self.bump();\n+                Ok(sid)\n+            }\n+            _ => self.parse_ident(),\n+         }\n+     }\n+\n     /// Parses qualified path.\n     ///\n     /// Assumes that the leading `<` has been parsed already.\n@@ -1813,7 +1813,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n-            let identifier = self.parse_ident_or_self_type()?;\n+            let identifier = self.parse_path_segment_ident()?;\n \n             // Parse types, optionally.\n             let parameters = if self.eat_lt() {\n@@ -1866,7 +1866,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n-            let identifier = self.parse_ident_or_self_type()?;\n+            let identifier = self.parse_path_segment_ident()?;\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n@@ -1913,7 +1913,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n-            let identifier = self.parse_ident_or_self_type()?;\n+            let identifier = self.parse_path_segment_ident()?;\n \n             // Assemble and push the result.\n             segments.push(ast::PathSegment {\n@@ -2212,15 +2212,6 @@ impl<'a> Parser<'a> {\n                 let lo = self.span.lo;\n                 return self.parse_lambda_expr(lo, CaptureBy::Ref, attrs);\n             },\n-            token::Ident(id @ ast::Ident {\n-                            name: token::SELF_KEYWORD_NAME,\n-                            ctxt: _\n-                         }, token::Plain) => {\n-                self.bump();\n-                let path = ast::Path::from_ident(mk_sp(lo, hi), id);\n-                ex = ExprKind::Path(None, path);\n-                hi = self.last_span.hi;\n-            }\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n \n@@ -2350,12 +2341,8 @@ impl<'a> Parser<'a> {\n                     let mut db = self.fatal(\"expected expression, found statement (`let`)\");\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n-                } else if self.check(&token::ModSep) ||\n-                        self.token.is_ident() &&\n-                        !self.check_keyword(keywords::True) &&\n-                        !self.check_keyword(keywords::False) {\n-                    let pth =\n-                        self.parse_path(LifetimeAndTypesWithColons)?;\n+                } else if self.is_path_start() {\n+                    let pth = self.parse_path(LifetimeAndTypesWithColons)?;\n \n                     // `!`, as an operator, is prefix, so we know this isn't that\n                     if self.check(&token::Not) {\n@@ -2694,7 +2681,7 @@ impl<'a> Parser<'a> {\n                                           op: repeat,\n                                           num_captures: name_num\n                                       })));\n-                } else if self.token.is_keyword_allow_following_colon(keywords::Crate) {\n+                } else if self.token.is_keyword(keywords::Crate) {\n                     self.bump();\n                     return Ok(TokenTree::Token(sp, SpecialVarNt(SpecialMacroVar::CrateMacroVar)));\n                 } else {\n@@ -3663,10 +3650,9 @@ impl<'a> Parser<'a> {\n                 pat = PatKind::Box(subpat);\n             } else if self.is_path_start() {\n                 // Parse pattern starting with a path\n-                if self.token.is_plain_ident() && self.look_ahead(1, |t| *t != token::DotDotDot &&\n+                if self.token.is_ident() && self.look_ahead(1, |t| *t != token::DotDotDot &&\n                         *t != token::OpenDelim(token::Brace) &&\n                         *t != token::OpenDelim(token::Paren) &&\n-                        // Contrary to its definition, a plain ident can be followed by :: in macros\n                         *t != token::ModSep) {\n                     // Plain idents have some extra abilities here compared to general paths\n                     if self.look_ahead(1, |t| *t == token::Not) {\n@@ -4626,16 +4612,9 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn is_self_ident(&mut self) -> bool {\n-        match self.token {\n-          token::Ident(id, token::Plain) => id.name == special_idents::self_.name,\n-          _ => false\n-        }\n-    }\n-\n     fn expect_self_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token {\n-            token::Ident(id, token::Plain) if id.name == special_idents::self_.name => {\n+            token::Ident(id, _) if id.name == special_idents::self_.name => {\n                 self.bump();\n                 Ok(id)\n             },\n@@ -4647,27 +4626,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn is_self_type_ident(&mut self) -> bool {\n-        match self.token {\n-          token::Ident(id, token::Plain) => id.name == special_idents::type_self.name,\n-          _ => false\n-        }\n-    }\n-\n-    fn expect_self_type_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.token {\n-            token::Ident(id, token::Plain) if id.name == special_idents::type_self.name => {\n-                self.bump();\n-                Ok(id)\n-            },\n-            _ => {\n-                let token_str = self.this_token_to_string();\n-                Err(self.fatal(&format!(\"expected `Self`, found `{}`\",\n-                                   token_str)))\n-            }\n-        }\n-    }\n-\n     /// Parse the argument list and result type of a function\n     /// that may have a self type.\n     fn parse_fn_decl_with_self<F>(&mut self,\n@@ -4736,7 +4694,7 @@ impl<'a> Parser<'a> {\n                 } else {\n                     Mutability::Immutable\n                 };\n-                if self.is_self_ident() {\n+                if self.token.is_keyword(keywords::SelfValue) {\n                     let span = self.span;\n                     self.span_err(span, \"cannot pass self by raw pointer\");\n                     self.bump();\n@@ -4745,7 +4703,7 @@ impl<'a> Parser<'a> {\n                 SelfKind::Value(special_idents::self_)\n             }\n             token::Ident(..) => {\n-                if self.is_self_ident() {\n+                if self.token.is_keyword(keywords::SelfValue) {\n                     let self_ident = self.expect_self_ident()?;\n \n                     // Determine whether this is the fully explicit form, `self:\n@@ -6044,7 +6002,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, Option<P<Item>>> {\n         if macros_allowed && !self.token.is_any_keyword()\n                 && self.look_ahead(1, |t| *t == token::Not)\n-                && (self.look_ahead(2, |t| t.is_plain_ident())\n+                && (self.look_ahead(2, |t| t.is_ident())\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n             // MACRO INVOCATION ITEM\n@@ -6061,7 +6019,7 @@ impl<'a> Parser<'a> {\n             // a 'special' identifier (like what `macro_rules!` uses)\n             // is optional. We should eventually unify invoc syntax\n             // and remove this.\n-            let id = if self.token.is_plain_ident() {\n+            let id = if self.token.is_ident() {\n                 self.parse_ident()?\n             } else {\n                 token::special_idents::invalid // no special identifier"}, {"sha": "46cf79ba336ef2739885963dece0196f94985368", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 26, "deletions": 62, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8dbf8f5f0a26a8f80f895294532ad567c156beb3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbf8f5f0a26a8f80f895294532ad567c156beb3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=8dbf8f5f0a26a8f80f895294532ad567c156beb3", "patch": "@@ -26,7 +26,6 @@ use std::fmt;\n use std::ops::Deref;\n use std::rc::Rc;\n \n-#[allow(non_camel_case_types)]\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum BinOpToken {\n     Plus,\n@@ -99,7 +98,6 @@ impl Lit {\n     }\n }\n \n-#[allow(non_camel_case_types)]\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug)]\n pub enum Token {\n     /* Expression-operator symbols. */\n@@ -185,7 +183,7 @@ impl Token {\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n             OpenDelim(_)                => true,\n-            Ident(_, _)                 => true,\n+            Ident(..)                   => true,\n             Underscore                  => true,\n             Tilde                       => true,\n             Literal(_, _)               => true,\n@@ -218,7 +216,7 @@ impl Token {\n     /// Returns `true` if the token is an identifier.\n     pub fn is_ident(&self) -> bool {\n         match *self {\n-            Ident(_, _) => true,\n+            Ident(..)   => true,\n             _           => false,\n         }\n     }\n@@ -239,16 +237,6 @@ impl Token {\n         }\n     }\n \n-    /// Returns `true` if the token is a path that is not followed by a `::`\n-    /// token.\n-    #[allow(non_upper_case_globals)]\n-    pub fn is_plain_ident(&self) -> bool {\n-        match *self {\n-            Ident(_, Plain) => true,\n-            _               => false,\n-        }\n-    }\n-\n     /// Returns `true` if the token is a lifetime.\n     pub fn is_lifetime(&self) -> bool {\n         match *self {\n@@ -289,77 +277,53 @@ impl Token {\n     }\n \n     /// Returns `true` if the token is a given keyword, `kw`.\n-    #[allow(non_upper_case_globals)]\n     pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n         match *self {\n-            Ident(sid, Plain) => kw.to_name() == sid.name,\n-            _                      => false,\n+            Ident(id, _) => id.name == kw.to_name(),\n+            _ => false,\n         }\n     }\n \n-    pub fn is_keyword_allow_following_colon(&self, kw: keywords::Keyword) -> bool {\n+    pub fn is_path_segment_keyword(&self) -> bool {\n         match *self {\n-            Ident(sid, _) => { kw.to_name() == sid.name }\n-            _ => { false }\n+            Ident(id, _) => id.name == SUPER_KEYWORD_NAME ||\n+                            id.name == SELF_KEYWORD_NAME ||\n+                            id.name == SELF_TYPE_KEYWORD_NAME,\n+            _ => false,\n         }\n     }\n \n-    /// Returns `true` if the token is either a special identifier, or a strict\n-    /// or reserved keyword.\n-    #[allow(non_upper_case_globals)]\n+    /// Returns `true` if the token is either a strict or reserved keyword.\n     pub fn is_any_keyword(&self) -> bool {\n         match *self {\n-            Ident(sid, Plain) => {\n-                let n = sid.name;\n-\n-                   n == SELF_KEYWORD_NAME\n-                || n == STATIC_KEYWORD_NAME\n-                || n == SUPER_KEYWORD_NAME\n-                || n == SELF_TYPE_KEYWORD_NAME\n-                || STRICT_KEYWORD_START <= n\n-                && n <= RESERVED_KEYWORD_FINAL\n-            },\n+            Ident(id, _) => id.name == SELF_KEYWORD_NAME ||\n+                            id.name == STATIC_KEYWORD_NAME ||\n+                            id.name == SUPER_KEYWORD_NAME ||\n+                            id.name == SELF_TYPE_KEYWORD_NAME ||\n+                            id.name >= STRICT_KEYWORD_START &&\n+                            id.name <= RESERVED_KEYWORD_FINAL,\n             _ => false\n         }\n     }\n \n-    /// Returns `true` if the token may not appear as an identifier.\n-    #[allow(non_upper_case_globals)]\n+    /// Returns `true` if the token is either a strict keyword.\n     pub fn is_strict_keyword(&self) -> bool {\n         match *self {\n-            Ident(sid, Plain) => {\n-                let n = sid.name;\n-\n-                   n == SELF_KEYWORD_NAME\n-                || n == STATIC_KEYWORD_NAME\n-                || n == SUPER_KEYWORD_NAME\n-                || n == SELF_TYPE_KEYWORD_NAME\n-                || STRICT_KEYWORD_START <= n\n-                && n <= STRICT_KEYWORD_FINAL\n-            },\n-            Ident(sid, ModName) => {\n-                let n = sid.name;\n-\n-                   n != SELF_KEYWORD_NAME\n-                && n != SUPER_KEYWORD_NAME\n-                && STRICT_KEYWORD_START <= n\n-                && n <= STRICT_KEYWORD_FINAL\n-            }\n+            Ident(id, _) => id.name == SELF_KEYWORD_NAME ||\n+                            id.name == STATIC_KEYWORD_NAME ||\n+                            id.name == SUPER_KEYWORD_NAME ||\n+                            id.name == SELF_TYPE_KEYWORD_NAME ||\n+                            id.name >= STRICT_KEYWORD_START &&\n+                            id.name <= STRICT_KEYWORD_FINAL,\n             _ => false,\n         }\n     }\n \n-    /// Returns `true` if the token is a keyword that has been reserved for\n-    /// possible future use.\n-    #[allow(non_upper_case_globals)]\n+    /// Returns `true` if the token is either a keyword reserved for possible future use.\n     pub fn is_reserved_keyword(&self) -> bool {\n         match *self {\n-            Ident(sid, Plain) => {\n-                let n = sid.name;\n-\n-                   RESERVED_KEYWORD_START <= n\n-                && n <= RESERVED_KEYWORD_FINAL\n-            },\n+            Ident(id, _) => id.name >= RESERVED_KEYWORD_START &&\n+                            id.name <= RESERVED_KEYWORD_FINAL,\n             _ => false,\n         }\n     }"}, {"sha": "146d37f41d638fef9c291710587e3e84b08f7b09", "filename": "src/test/compile-fail/use-mod-4.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8dbf8f5f0a26a8f80f895294532ad567c156beb3/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dbf8f5f0a26a8f80f895294532ad567c156beb3/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-mod-4.rs?ref=8dbf8f5f0a26a8f80f895294532ad567c156beb3", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n-use foo::self;\n-//~^ ERROR expected identifier, found keyword `self`\n+use foo::self; //~ ERROR unresolved import `foo::self`\n+//~^ ERROR `self` imports are only allowed within a { } list\n \n fn main() {}", "previous_filename": "src/test/parse-fail/use-mod-4.rs"}]}