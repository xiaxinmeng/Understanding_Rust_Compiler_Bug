{"sha": "cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNTVlZjZlMTJmNzJmODhlYTlmMDVjODRjMjkwZGZhOTU4NDlmMDM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-31T23:10:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-31T23:24:08Z"}, "message": "Convert benchmarks to istrs. Issue #855", "tree": {"sha": "80a652022409238c5c352c19ab4f06f1fafd257c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80a652022409238c5c352c19ab4f06f1fafd257c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "html_url": "https://github.com/rust-lang/rust/commit/cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04700066f38409df2ca05de98d6998c41cbd7ba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/04700066f38409df2ca05de98d6998c41cbd7ba0", "html_url": "https://github.com/rust-lang/rust/commit/04700066f38409df2ca05de98d6998c41cbd7ba0"}], "stats": {"total": 200, "additions": 97, "deletions": 103}, "files": [{"sha": "3268d21078f3127b512dda48aa6ff5f7078a23f0", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -6,34 +6,33 @@\n  */\n use std;\n import std::int;\n-import std::str;\n import std::istr;\n \n-fn b1() -> str { ret \"# of beer on the wall, # of beer.\"; }\n+fn b1() -> istr { ret ~\"# of beer on the wall, # of beer.\"; }\n \n-fn b2() -> str {\n-    ret \"Take one down and pass it around, # of beer on the wall.\";\n+fn b2() -> istr {\n+    ret ~\"Take one down and pass it around, # of beer on the wall.\";\n }\n \n-fn b7() -> str {\n-    ret \"No more bottles of beer on the wall, no more bottles of beer.\";\n+fn b7() -> istr {\n+    ret ~\"No more bottles of beer on the wall, no more bottles of beer.\";\n }\n \n-fn b8() -> str {\n-    ret \"Go to the store and buy some more, # of beer on the wall.\";\n+fn b8() -> istr {\n+    ret ~\"Go to the store and buy some more, # of beer on the wall.\";\n }\n \n-fn sub(t: str, n: int) -> str {\n-    let b: str = \"\";\n+fn sub(t: &istr, n: int) -> istr {\n+    let b: istr = ~\"\";\n     let i: uint = 0u;\n-    let ns: str;\n+    let ns: istr;\n     alt n {\n-      0 { ns = \"no more bottles\"; }\n-      1 { ns = \"1 bottle\"; }\n-      _ { ns = istr::to_estr(int::to_str(n, 10u) + ~\" bottles\"); }\n+      0 { ns = ~\"no more bottles\"; }\n+      1 { ns = ~\"1 bottle\"; }\n+      _ { ns = int::to_str(n, 10u) + ~\" bottles\"; }\n     }\n-    while i < str::byte_len(t) {\n-        if t[i] == '#' as u8 { b += ns; } else { str::push_byte(b, t[i]); }\n+    while i < istr::byte_len(t) {\n+        if t[i] == '#' as u8 { b += ns; } else { istr::push_byte(b, t[i]); }\n         i += 1u;\n     }\n     ret b;"}, {"sha": "3b3b1e8278c8ab9f3b9e1768a43ac04270d7f900", "filename": "src/test/bench/99bob-simple.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -6,34 +6,33 @@\n  */\n use std;\n import std::int;\n-import std::str;\n import std::istr;\n \n-fn b1() -> str { ret \"# of beer on the wall, # of beer.\"; }\n+fn b1() -> istr { ret ~\"# of beer on the wall, # of beer.\"; }\n \n-fn b2() -> str {\n-    ret \"Take one down and pass it around, # of beer on the wall.\";\n+fn b2() -> istr {\n+    ret ~\"Take one down and pass it around, # of beer on the wall.\";\n }\n \n-fn b7() -> str {\n-    ret \"No more bottles of beer on the wall, no more bottles of beer.\";\n+fn b7() -> istr {\n+    ret ~\"No more bottles of beer on the wall, no more bottles of beer.\";\n }\n \n-fn b8() -> str {\n-    ret \"Go to the store and buy some more, # of beer on the wall.\";\n+fn b8() -> istr {\n+    ret ~\"Go to the store and buy some more, # of beer on the wall.\";\n }\n \n-fn sub(t: str, n: int) -> str {\n-    let b: str = \"\";\n+fn sub(t: &istr, n: int) -> istr {\n+    let b: istr = ~\"\";\n     let i: uint = 0u;\n-    let ns: str;\n+    let ns: istr;\n     alt n {\n-      0 { ns = \"no more bottles\"; }\n-      1 { ns = \"1 bottle\"; }\n-      _ { ns = istr::to_estr(int::to_str(n, 10u) + ~\" bottles\"); }\n+      0 { ns = ~\"no more bottles\"; }\n+      1 { ns = ~\"1 bottle\"; }\n+      _ { ns = int::to_str(n, 10u) + ~\" bottles\"; }\n     }\n-    while i < str::byte_len(t) {\n-        if t[i] == '#' as u8 { b += ns; } else { str::push_byte(b, t[i]); }\n+    while i < istr::byte_len(t) {\n+        if t[i] == '#' as u8 { b += ns; } else { istr::push_byte(b, t[i]); }\n         i += 1u;\n     }\n     ret b;"}, {"sha": "2c9447c1fe1d1dfe8a8fbe3572dfe22e8899c9c1", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -7,9 +7,9 @@\n  */\n use std;\n import std::vec;\n-import std::str;\n import std::uint;\n import std::int;\n+import std::istr;\n \n fn LINE_LENGTH() -> uint { ret 60u; }\n \n@@ -43,26 +43,27 @@ fn select_random(r: u32, genelist: &[aminoacids]) -> char {\n     ret bisect(genelist, 0u, vec::len::<aminoacids>(genelist) - 1u, r);\n }\n \n-fn make_random_fasta(id: str, desc: str, genelist: &[aminoacids], n: int) {\n-    log \">\" + id + \" \" + desc;\n+fn make_random_fasta(id: &istr, desc: &istr,\n+                     genelist: &[aminoacids], n: int) {\n+    log ~\">\" + id + ~\" \" + desc;\n     let rng = myrandom(std::rand::mk_rng().next());\n-    let op: str = \"\";\n+    let op: istr = ~\"\";\n     for each i: uint in uint::range(0u, n as uint) {\n-        str::push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n-        if str::byte_len(op) >= LINE_LENGTH() { log op; op = \"\"; }\n+        istr::push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n+        if istr::byte_len(op) >= LINE_LENGTH() { log op; op = ~\"\"; }\n     }\n-    if str::byte_len(op) > 0u { log op; }\n+    if istr::byte_len(op) > 0u { log op; }\n }\n \n-fn make_repeat_fasta(id: str, desc: str, s: str, n: int) {\n-    log \">\" + id + \" \" + desc;\n-    let op: str = \"\";\n-    let sl: uint = str::byte_len(s);\n+fn make_repeat_fasta(id: &istr, desc: &istr, s: &istr, n: int) {\n+    log ~\">\" + id + ~\" \" + desc;\n+    let op: istr = ~\"\";\n+    let sl: uint = istr::byte_len(s);\n     for each i: uint in uint::range(0u, n as uint) {\n-        str::push_byte(op, s[i % sl]);\n-        if str::byte_len(op) >= LINE_LENGTH() { log op; op = \"\"; }\n+        istr::push_byte(op, s[i % sl]);\n+        if istr::byte_len(op) >= LINE_LENGTH() { log op; op = ~\"\"; }\n     }\n-    if str::byte_len(op) > 0u { log op; }\n+    if istr::byte_len(op) > 0u { log op; }\n }\n \n fn acid(ch: char, prob: u32) -> aminoacids { ret {ch: ch, prob: prob}; }\n@@ -77,16 +78,17 @@ fn main(args: [str]) {\n     let homosapiens: [aminoacids] =\n         make_cumulative([acid('a', 30u32), acid('c', 20u32), acid('g', 20u32),\n                          acid('t', 30u32)]);\n-    let alu: str =\n-        \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\" +\n-            \"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\" +\n-            \"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\" +\n-            \"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\" +\n-            \"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\" +\n-            \"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\" +\n-            \"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n+    let alu: istr =\n+        ~\"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\" +\n+            ~\"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\" +\n+            ~\"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\" +\n+            ~\"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\" +\n+            ~\"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\" +\n+            ~\"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\" +\n+            ~\"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n     let n: int = 512;\n-    make_repeat_fasta(\"ONE\", \"Homo sapiens alu\", alu, n * 2);\n-    make_random_fasta(\"TWO\", \"IUB ambiguity codes\", iub, n * 3);\n-    make_random_fasta(\"THREE\", \"Homo sapiens frequency\", homosapiens, n * 5);\n+    make_repeat_fasta(~\"ONE\", ~\"Homo sapiens alu\", alu, n * 2);\n+    make_random_fasta(~\"TWO\", ~\"IUB ambiguity codes\", iub, n * 3);\n+    make_random_fasta(~\"THREE\", ~\"Homo sapiens frequency\",\n+                      homosapiens, n * 5);\n }"}, {"sha": "fd9210169e35c7c49102d3a4cbc2e323b977326f", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -14,7 +14,6 @@ use std;\n import std::vec;\n import std::uint;\n import std::time;\n-import std::str;\n import std::istr;\n import std::int::range;\n import std::io;\n@@ -50,8 +49,7 @@ fn fib(n: int) -> int {\n \n type config = {stress: bool};\n \n-fn parse_opts(argv: [str]) -> config {\n-    let argv = istr::from_estrs(argv);\n+fn parse_opts(argv: &[istr]) -> config {\n     let opts = [getopts::optflag(~\"stress\")];\n \n     let opt_args = vec::slice(argv, 1u, vec::len(argv));\n@@ -82,6 +80,7 @@ fn stress(num_tasks: int) {\n }\n \n fn main(argv: [str]) {\n+    let argv = istr::from_estrs(argv);\n     if vec::len(argv) == 1u {\n         assert (fib(8) == 21);\n         log fib(8);\n@@ -93,7 +92,7 @@ fn main(argv: [str]) {\n         if opts.stress {\n             stress(2);\n         } else {\n-            let max = uint::parse_buf(str::bytes(argv[1]), 10u) as int;\n+            let max = uint::parse_buf(istr::bytes(argv[1]), 10u) as int;\n \n             let num_trials = 10;\n "}, {"sha": "dc186811153bb2269654fc6c27d2fb3c08aa5711", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -2,7 +2,7 @@ use std;\n import std::vec;\n import std::task;\n import std::uint;\n-import std::str;\n+import std::istr;\n \n fn f(n: uint) {\n     let i = 0u;\n@@ -13,12 +13,11 @@ fn f(n: uint) {\n \n fn g() { }\n \n-fn main(args: [str]) {\n-\n+fn main(args: [istr]) {\n     let n =\n         if vec::len(args) < 2u {\n             10u\n-        } else { uint::parse_buf(str::bytes(args[1]), 10u) };\n+        } else { uint::parse_buf(istr::bytes(args[1]), 10u) };\n     let i = 0u;\n     while i < n { task::spawn(bind f(n)); i += 1u; }\n }"}, {"sha": "6374cf8ab9852f97f9e0e43cf0a0bd117c04d499", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -13,7 +13,6 @@ use std;\n import option = std::option::t;\n import std::option::some;\n import std::option::none;\n-import std::str;\n import std::istr;\n import std::treemap;\n import std::vec;\n@@ -35,7 +34,7 @@ fn map(filename: &[u8], emit: &map_reduce::putter<[u8], int>) {\n \n     while true {\n         alt read_word(f) {\n-          some(w) { emit(str::bytes(w), 1); }\n+          some(w) { emit(istr::bytes(w), 1); }\n           none. { break; }\n         }\n     }\n@@ -198,12 +197,12 @@ mod map_reduce {\n     }\n }\n \n-fn main(argv: [str]) {\n+fn main(argv: [istr]) {\n     if vec::len(argv) < 2u {\n         let out = io::stdout();\n \n         out.write_line(\n-            #ifmt[\"Usage: %s <filename> ...\", istr::from_estr(argv[0])]);\n+            #ifmt[\"Usage: %s <filename> ...\", argv[0]]);\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program.\n@@ -213,7 +212,7 @@ fn main(argv: [str]) {\n \n     let iargs = [];\n     for a in vec::slice(argv, 1u, vec::len(argv)) {\n-        iargs += [str::bytes(a)];\n+        iargs += [istr::bytes(a)];\n     }\n \n     // We can get by with 8k stacks, and we'll probably exhaust our\n@@ -228,20 +227,20 @@ fn main(argv: [str]) {\n     let elapsed = stop - start;\n     elapsed /= 1000000u64;\n \n-    log_err \"MapReduce completed in \" +\n-        istr::to_estr(u64::str(elapsed)) + \"ms\";\n+    log_err ~\"MapReduce completed in \" +\n+        u64::str(elapsed) + ~\"ms\";\n }\n \n-fn read_word(r: io::reader) -> option<str> {\n-    let w = \"\";\n+fn read_word(r: io::reader) -> option<istr> {\n+    let w = ~\"\";\n \n     while !r.eof() {\n         let c = r.read_char();\n \n \n         if is_word_char(c) {\n-            w += str::from_char(c);\n-        } else { if w != \"\" { ret some(w); } }\n+            w += istr::from_char(c);\n+        } else { if w != ~\"\" { ret some(w); } }\n     }\n     ret none;\n }"}, {"sha": "726a5f22fdd64804ead0ebe9a2cd25e734ea6ce7", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb55ef6e12f72f88ea9f05c84c290dfa95849f03/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=cb55ef6e12f72f88ea9f05c84c290dfa95849f03", "patch": "@@ -13,7 +13,6 @@ use std;\n import option = std::option::t;\n import std::option::some;\n import std::option::none;\n-import std::str;\n import std::istr;\n import std::map;\n import std::vec;\n@@ -30,16 +29,16 @@ import std::comm::port;\n import std::comm::recv;\n import std::comm::send;\n \n-fn map(filename: str, emit: map_reduce::putter) {\n-    let f = io::file_reader(istr::from_estr(filename));\n+fn map(filename: &istr, emit: map_reduce::putter) {\n+    let f = io::file_reader(filename);\n \n \n     while true {\n         alt read_word(f) { some(w) { emit(w, 1); } none. { break; } }\n     }\n }\n \n-fn reduce(word: str, get: map_reduce::getter) {\n+fn reduce(word: &istr, get: map_reduce::getter) {\n     let count = 0;\n \n \n@@ -53,48 +52,47 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter = fn(str, int);\n+    type putter = fn(&istr, int);\n \n-    type mapper = fn(str, putter);\n+    type mapper = fn(&istr, putter);\n \n     type getter = fn() -> option<int>;\n \n-    type reducer = fn(str, getter);\n+    type reducer = fn(&istr, getter);\n \n     tag ctrl_proto {\n-        find_reducer([u8], chan<chan<reduce_proto>>);\n+        find_reducer(istr, chan<chan<reduce_proto>>);\n         mapper_done;\n     }\n \n     tag reduce_proto { emit_val(int); done; ref; release; }\n \n-    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[str])\n+    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[istr])\n         -> [joinable_task] {\n         let tasks = [];\n-        for i: str in inputs {\n+        for i: istr in inputs {\n             tasks += [task::spawn_joinable(bind map_task(ctrl, i))];\n         }\n         ret tasks;\n     }\n \n-    fn map_task(ctrl: chan<ctrl_proto>, input: str) {\n+    fn map_task(ctrl: chan<ctrl_proto>, input: &istr) {\n         // log_err \"map_task \" + input;\n         let intermediates = map::new_str_hash();\n \n         fn emit(im: &map::hashmap<istr, chan<reduce_proto>>,\n-                ctrl: chan<ctrl_proto>, key: str, val: int) {\n+                ctrl: chan<ctrl_proto>, key: &istr, val: int) {\n             let c;\n-            alt im.find(istr::from_estr(key)) {\n+            alt im.find(key) {\n               some(_c) {\n \n                 c = _c\n               }\n               none. {\n                 let p = port();\n-                let keyi = str::bytes(key);\n-                send(ctrl, find_reducer(keyi, chan(p)));\n+                send(ctrl, find_reducer(key, chan(p)));\n                 c = recv(p);\n-                im.insert(istr::from_estr(key), c);\n+                im.insert(key, c);\n                 send(c, ref);\n               }\n             }\n@@ -111,7 +109,7 @@ mod map_reduce {\n         send(ctrl, mapper_done);\n     }\n \n-    fn reduce_task(key: str, out: chan<chan<reduce_proto>>) {\n+    fn reduce_task(key: &istr, out: chan<chan<reduce_proto>>) {\n         let p = port();\n \n         send(out, chan(p));\n@@ -141,7 +139,7 @@ mod map_reduce {\n         reduce(key, bind get(p, ref_count, is_done));\n     }\n \n-    fn map_reduce(inputs: &[str]) {\n+    fn map_reduce(inputs: &[istr]) {\n         let ctrl = port::<ctrl_proto>();\n \n         // This task becomes the master control task. It task::_spawns\n@@ -161,9 +159,8 @@ mod map_reduce {\n                 // log_err \"received mapper terminated.\";\n                 num_mappers -= 1;\n               }\n-              find_reducer(ki, cc) {\n+              find_reducer(k, cc) {\n                 let c;\n-                let k = istr::unsafe_from_bytes(ki);\n                 // log_err \"finding reducer for \" + k;\n                 alt reducers.find(k) {\n                   some(_c) {\n@@ -175,7 +172,7 @@ mod map_reduce {\n                     let p = port();\n                     tasks +=\n                         [task::spawn_joinable(\n-                            bind reduce_task(istr::to_estr(k), chan(p)))];\n+                            bind reduce_task(k, chan(p)))];\n                     c = recv(p);\n                     reducers.insert(k, c);\n                   }\n@@ -194,12 +191,12 @@ mod map_reduce {\n     }\n }\n \n-fn main(argv: [str]) {\n+fn main(argv: [istr]) {\n     if vec::len(argv) < 2u {\n         let out = io::stdout();\n \n         out.write_line(\n-            #ifmt[\"Usage: %s <filename> ...\", istr::from_estr(argv[0])]);\n+            #ifmt[\"Usage: %s <filename> ...\", argv[0]]);\n \n         // TODO: run something just to make sure the code hasn't\n         // broken yet. This is the unit test mode of this program.\n@@ -222,16 +219,16 @@ fn main(argv: [str]) {\n     log_err ~\"MapReduce completed in \" + u64::str(elapsed) + ~\"ms\";\n }\n \n-fn read_word(r: io::reader) -> option<str> {\n-    let w = \"\";\n+fn read_word(r: io::reader) -> option<istr> {\n+    let w = ~\"\";\n \n     while !r.eof() {\n         let c = r.read_char();\n \n \n         if is_word_char(c) {\n-            w += str::from_char(c);\n-        } else { if w != \"\" { ret some(w); } }\n+            w += istr::from_char(c);\n+        } else { if w != ~\"\" { ret some(w); } }\n     }\n     ret none;\n }"}]}