{"sha": "d87164500fa2535dbd10eb9c250be59c714ffe1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NzE2NDUwMGZhMjUzNWRiZDEwZWI5YzI1MGJlNTljNzE0ZmZlMWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-30T20:43:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-30T20:43:39Z"}, "message": "Rollup merge of #63129 - Centril:subslice-pat-statdyn, r=oli-obk\n\nSubslice patterns: Test passing static & dynamic semantics.\n\nWorking towards testing coverage for https://github.com/rust-lang/rust/issues/62254.\nSee https://github.com/rust-lang/rfcs/blob/master/text/2359-subslice-pattern-syntax.md for the RFC.\n\nr? @oli-obk cc @petrochenkov", "tree": {"sha": "4ec3d2d559d8efb2ede25239df854e2f307b41f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ec3d2d559d8efb2ede25239df854e2f307b41f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d87164500fa2535dbd10eb9c250be59c714ffe1d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdQKv7CRBK7hj4Ov3rIwAAdHIIAB/k2/b02/+Y0dwfpnlSNxn5\n5lRIoigb4wlDEylQzCOymoBTEX45JV4Ty/lfV2ameRfW3SZk95CMASyRMbeGMjoT\n1shUWMocIYJLUxQ3EIXpp/tciiNqUdag6BciD/l857DR92uPPdjqKyDgrDGjVT3N\nP50gjUpdS6g2CL6SVJ2e6pGGKibnQ7aUcfSImO1QudZ8PAqCjpOsX/oXsRPhfdOw\nKXIXRkAUsNeux4tPGC5QE6Fh55P8KCcba68y1xZ61TYLq+IkLoO56qvR2EffHEjn\nFxjR0U+No7ZE28pRDMRNSMOAcrc1ICxIFYjIi1htKoffpaccufIoftqiHfprIgw=\n=PSYK\n-----END PGP SIGNATURE-----\n", "payload": "tree 4ec3d2d559d8efb2ede25239df854e2f307b41f6\nparent c088890b6e9f813b47bbe41e4eae9cd3545cb1d2\nparent 969a3743e6363ce526f5ec8577b7de95dfc1e984\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564519419 +0200\ncommitter GitHub <noreply@github.com> 1564519419 +0200\n\nRollup merge of #63129 - Centril:subslice-pat-statdyn, r=oli-obk\n\nSubslice patterns: Test passing static & dynamic semantics.\n\nWorking towards testing coverage for https://github.com/rust-lang/rust/issues/62254.\nSee https://github.com/rust-lang/rfcs/blob/master/text/2359-subslice-pattern-syntax.md for the RFC.\n\nr? @oli-obk cc @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d87164500fa2535dbd10eb9c250be59c714ffe1d", "html_url": "https://github.com/rust-lang/rust/commit/d87164500fa2535dbd10eb9c250be59c714ffe1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d87164500fa2535dbd10eb9c250be59c714ffe1d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c088890b6e9f813b47bbe41e4eae9cd3545cb1d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c088890b6e9f813b47bbe41e4eae9cd3545cb1d2", "html_url": "https://github.com/rust-lang/rust/commit/c088890b6e9f813b47bbe41e4eae9cd3545cb1d2"}, {"sha": "969a3743e6363ce526f5ec8577b7de95dfc1e984", "url": "https://api.github.com/repos/rust-lang/rust/commits/969a3743e6363ce526f5ec8577b7de95dfc1e984", "html_url": "https://github.com/rust-lang/rust/commit/969a3743e6363ce526f5ec8577b7de95dfc1e984"}], "stats": {"total": 128, "additions": 128, "deletions": 0}, "files": [{"sha": "1ebf3def78876b5622c6713f2d4f00f660a7377c", "filename": "src/test/ui/array-slice-vec/subslice-patterns-pass.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d87164500fa2535dbd10eb9c250be59c714ffe1d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d87164500fa2535dbd10eb9c250be59c714ffe1d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs?ref=d87164500fa2535dbd10eb9c250be59c714ffe1d", "patch": "@@ -0,0 +1,128 @@\n+// This test comprehensively checks the passing static and dynamic semantics\n+// of subslice patterns `..`, `x @ ..`, `ref x @ ..`, and `ref mut @ ..`\n+// in slice patterns `[$($pat), $(,)?]` .\n+\n+// run-pass\n+\n+#![feature(slice_patterns)]\n+\n+#![allow(unreachable_patterns)]\n+\n+use std::convert::identity;\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+macro_rules! c {\n+    ($inp:expr, $typ:ty, $out:expr $(,)?) => {\n+        assert_eq!($out, identity::<$typ>($inp));\n+    }\n+}\n+\n+macro_rules! m {\n+    ($e:expr, $p:pat => $b:expr) => {\n+        match $e {\n+            $p => $b,\n+            _ => panic!(),\n+        }\n+    }\n+}\n+\n+fn main() {\n+    slices();\n+    arrays();\n+}\n+\n+fn slices() {\n+    // Matching slices using `ref` patterns:\n+    let mut v = vec![N(0), N(1), N(2), N(3), N(4)];\n+    let mut vc = (0..=4).collect::<Vec<u8>>();\n+\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(v[..], [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using `ref mut` patterns:\n+    let [..] = v[..]; // Always matches.\n+    m!(v[..], [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(v[..], [N(0), ref mut sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(v[..], [ref mut sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(v[..], [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(v[..], [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(vc[..], [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching slices using default binding modes (&):\n+    let [..] = &v[..]; // Always matches.\n+    m!(&v[..], [N(0), sub @ .., N(4)] => c!(sub, &[N], n![1, 2, 3]));\n+    m!(&v[..], [N(0), sub @ ..] => c!(sub, &[N], n![1, 2, 3, 4]));\n+    m!(&v[..], [sub @ .., N(4)] => c!(sub, &[N], n![0, 1, 2, 3]));\n+    m!(&v[..], [sub @ .., _, _, _, _, _] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &[N], &n![] as &[N]));\n+    m!(&vc[..], [x, .., y] => c!((x, y), (&u8, &u8), (&0, &4)));\n+\n+    // Matching slices using default binding modes (&mut):\n+    let [..] = &mut v[..]; // Always matches.\n+    m!(&mut v[..], [N(0), sub @ .., N(4)] => c!(sub, &mut [N], n![1, 2, 3]));\n+    m!(&mut v[..], [N(0), sub @ ..] => c!(sub, &mut [N], n![1, 2, 3, 4]));\n+    m!(&mut v[..], [sub @ .., N(4)] => c!(sub, &mut [N], n![0, 1, 2, 3]));\n+    m!(&mut v[..], [sub @ .., _, _, _, _, _] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut v[..], [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N], &mut n![] as &mut [N]));\n+    m!(&mut vc[..], [x, .., y] => c!((x, y), (&mut u8, &mut u8), (&mut 0, &mut 4)));\n+}\n+\n+fn arrays() {\n+    let mut v = n![0, 1, 2, 3, 4];\n+    let vc = [0, 1, 2, 3, 4];\n+\n+    // Matching arrays by value:\n+    m!(v.clone(), [N(0), sub @ .., N(4)] => c!(sub, [N; 3], n![1, 2, 3]));\n+    m!(v.clone(), [N(0), sub @ ..] => c!(sub, [N; 4], n![1, 2, 3, 4]));\n+    m!(v.clone(), [sub @ .., N(4)] => c!(sub, [N; 4], n![0, 1, 2, 3]));\n+    m!(v.clone(), [sub @ .., _, _, _, _, _] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [_, _, _, _, _, sub @ ..] => c!(sub, [N; 0], n![] as [N; 0]));\n+    m!(v.clone(), [x, .., y] => c!((x, y), (N, N), (N(0), N(4))));\n+    m!(v.clone(), [..] => ());\n+\n+    // Matching arrays by ref patterns:\n+    m!(v, [N(0), ref sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(v, [N(0), ref sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(v, [ref sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(v, [ref sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(v, [_, _, _, _, _, ref sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(vc, [x, .., y] => c!((x, y), (u8, u8), (0, 4)));\n+\n+    // Matching arrays by ref mut patterns:\n+    m!(v, [N(0), ref mut sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(v, [N(0), ref mut sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(v, [ref mut sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(v, [ref mut sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+    m!(v, [_, _, _, _, _, ref mut sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &mut [N; 0]));\n+\n+    // Matching arrays by default binding modes (&):\n+    m!(&v, [N(0), sub @ .., N(4)] => c!(sub, &[N; 3], &n![1, 2, 3]));\n+    m!(&v, [N(0), sub @ ..] => c!(sub, &[N; 4], &n![1, 2, 3, 4]));\n+    m!(&v, [sub @ .., N(4)] => c!(sub, &[N; 4], &n![0, 1, 2, 3]));\n+    m!(&v, [sub @ .., _, _, _, _, _] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [_, _, _, _, _, sub @ ..] => c!(sub, &[N; 0], &n![] as &[N; 0]));\n+    m!(&v, [..] => ());\n+    m!(&v, [x, .., y] => c!((x, y), (&N, &N), (&N(0), &N(4))));\n+\n+    // Matching arrays by default binding modes (&mut):\n+    m!(&mut v, [N(0), sub @ .., N(4)] => c!(sub, &mut [N; 3], &mut n![1, 2, 3]));\n+    m!(&mut v, [N(0), sub @ ..] => c!(sub, &mut [N; 4], &mut n![1, 2, 3, 4]));\n+    m!(&mut v, [sub @ .., N(4)] => c!(sub, &mut [N; 4], &mut n![0, 1, 2, 3]));\n+    m!(&mut v, [sub @ .., _, _, _, _, _] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [_, _, _, _, _, sub @ ..] => c!(sub, &mut [N; 0], &mut n![] as &[N; 0]));\n+    m!(&mut v, [..] => ());\n+    m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n+}"}]}