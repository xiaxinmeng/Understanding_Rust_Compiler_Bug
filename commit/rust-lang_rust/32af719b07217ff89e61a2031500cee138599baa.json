{"sha": "32af719b07217ff89e61a2031500cee138599baa", "node_id": "C_kwDOAAsO6NoAKDMyYWY3MTliMDcyMTdmZjg5ZTYxYTIwMzE1MDBjZWUxMzg1OTliYWE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-11T20:49:39Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-21T19:13:41Z"}, "message": "Always create parameters for functions-like types.", "tree": {"sha": "fef7781b316b4f2fd06655f2892f689032e7b297", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fef7781b316b4f2fd06655f2892f689032e7b297"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32af719b07217ff89e61a2031500cee138599baa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32af719b07217ff89e61a2031500cee138599baa", "html_url": "https://github.com/rust-lang/rust/commit/32af719b07217ff89e61a2031500cee138599baa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32af719b07217ff89e61a2031500cee138599baa/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b79b8bfa139ca5f991aa08b405003f748d3caf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b79b8bfa139ca5f991aa08b405003f748d3caf6", "html_url": "https://github.com/rust-lang/rust/commit/4b79b8bfa139ca5f991aa08b405003f748d3caf6"}], "stats": {"total": 480, "additions": 303, "deletions": 177}, "files": [{"sha": "e8b92eaad5c8dbfba258398f6f3fbcab75453d0f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -223,6 +223,12 @@ impl ResolverAstLoweringExt for ResolverAstLowering {\n     }\n \n     /// Obtain the list of lifetimes parameters to add to an item.\n+    ///\n+    /// Extra lifetime parameters should only be added in places that can appear\n+    /// as a `binder` in `LifetimeRes`.\n+    ///\n+    /// The extra lifetimes that appear from the parenthesized `Fn`-trait desugaring\n+    /// should appear at the enclosing `PolyTraitRef`.\n     fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)> {\n         self.extra_lifetime_params_map.remove(&id).unwrap_or_default()\n     }\n@@ -721,6 +727,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Converts a lifetime into a new generic parameter.\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn lifetime_res_to_generic_param(\n         &mut self,\n         ident: Ident,\n@@ -787,11 +794,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Register a binder to be ignored for lifetime capture.\n     #[tracing::instrument(level = \"debug\", skip(self, f))]\n     #[inline]\n-    fn with_lifetime_binder<T>(&mut self, binder: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n+    fn with_lifetime_binder<T>(\n+        &mut self,\n+        binder: NodeId,\n+        generic_params: &[GenericParam],\n+        f: impl FnOnce(&mut Self, &'hir [hir::GenericParam<'hir>]) -> T,\n+    ) -> T {\n+        let mut generic_params: Vec<_> = self.lower_generic_params_mut(generic_params).collect();\n+        let extra_lifetimes = self.resolver.take_extra_lifetime_params(binder);\n+        debug!(?extra_lifetimes);\n+        generic_params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n+            self.lifetime_res_to_generic_param(ident, node_id, res)\n+        }));\n+        let generic_params = self.arena.alloc_from_iter(generic_params);\n+        debug!(?generic_params);\n+\n         if let Some(ctxt) = &mut self.captured_lifetimes {\n             ctxt.binders_to_ignore.insert(binder);\n         }\n-        let ret = f(self);\n+        let ret = f(self, generic_params);\n         if let Some(ctxt) = &mut self.captured_lifetimes {\n             ctxt.binders_to_ignore.remove(&binder);\n         }\n@@ -1188,15 +1209,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let lifetime = self.lower_lifetime(&region);\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n-            TyKind::BareFn(ref f) => self.with_lifetime_binder(t.id, |this| {\n-                hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n-                    generic_params: this.lower_generic_params(&f.generic_params),\n-                    unsafety: this.lower_unsafety(f.unsafety),\n-                    abi: this.lower_extern(f.ext),\n-                    decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n-                    param_names: this.lower_fn_params_to_names(&f.decl),\n-                }))\n-            }),\n+            TyKind::BareFn(ref f) => {\n+                self.with_lifetime_binder(t.id, &f.generic_params, |this, generic_params| {\n+                    hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n+                        generic_params,\n+                        unsafety: this.lower_unsafety(f.unsafety),\n+                        abi: this.lower_extern(f.ext),\n+                        decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n+                        param_names: this.lower_fn_params_to_names(&f.decl),\n+                    }))\n+                })\n+            }\n             TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => hir::TyKind::Tup(\n                 self.arena.alloc_from_iter(tys.iter().map(|ty| self.lower_ty_direct(ty, itctx))),\n@@ -1963,13 +1986,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &PolyTraitRef,\n         itctx: ImplTraitContext,\n     ) -> hir::PolyTraitRef<'hir> {\n-        let bound_generic_params = self.lower_generic_params(&p.bound_generic_params);\n-\n-        let trait_ref = self.with_lifetime_binder(p.trait_ref.ref_id, |this| {\n-            this.lower_trait_ref(&p.trait_ref, itctx)\n-        });\n-\n-        hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }\n+        self.with_lifetime_binder(\n+            p.trait_ref.ref_id,\n+            &p.bound_generic_params,\n+            |this, bound_generic_params| {\n+                let trait_ref = this.lower_trait_ref(&p.trait_ref, itctx);\n+                hir::PolyTraitRef { bound_generic_params, trait_ref, span: this.lower_span(p.span) }\n+            },\n+        )\n     }\n \n     fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext) -> hir::MutTy<'hir> {"}, {"sha": "52ba5daf01410046555852aa3eb8ce2f5327c1d7", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -191,9 +191,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => {\n-                        self.lower_parenthesized_parameter_data(segment.id, data)\n-                    }\n+                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Err => {\n                         let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n                         err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n@@ -351,39 +349,34 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_parenthesized_parameter_data(\n         &mut self,\n-        id: NodeId,\n         data: &ParenthesizedArgs,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n         // a hidden lifetime parameter. This is needed for backwards\n         // compatibility, even in contexts like an impl header where\n         // we generally don't permit such things (see #51008).\n-        self.with_lifetime_binder(id, |this| {\n-            let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n-            let inputs = this.arena.alloc_from_iter(inputs.iter().map(|ty| {\n-                this.lower_ty_direct(\n-                    ty,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam),\n-                )\n-            }));\n-            let output_ty = match output {\n-                FnRetTy::Ty(ty) => this\n-                    .lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn)),\n-                FnRetTy::Default(_) => this.arena.alloc(this.ty_tup(*span, &[])),\n-            };\n-            let args = smallvec![GenericArg::Type(this.ty_tup(*inputs_span, inputs))];\n-            let binding = this.output_ty_binding(output_ty.span, output_ty);\n-            (\n-                GenericArgsCtor {\n-                    args,\n-                    bindings: arena_vec![this; binding],\n-                    parenthesized: true,\n-                    span: data.inputs_span,\n-                },\n-                false,\n-            )\n-        })\n+        let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n+        let inputs = self.arena.alloc_from_iter(inputs.iter().map(|ty| {\n+            self.lower_ty_direct(ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam))\n+        }));\n+        let output_ty = match output {\n+            FnRetTy::Ty(ty) => {\n+                self.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))\n+            }\n+            FnRetTy::Default(_) => self.arena.alloc(self.ty_tup(*span, &[])),\n+        };\n+        let args = smallvec![GenericArg::Type(self.ty_tup(*inputs_span, inputs))];\n+        let binding = self.output_ty_binding(output_ty.span, output_ty);\n+        (\n+            GenericArgsCtor {\n+                args,\n+                bindings: arena_vec![self; binding],\n+                parenthesized: true,\n+                span: data.inputs_span,\n+            },\n+            false,\n+        )\n     }\n \n     /// An associated type binding `Output = $ty`."}, {"sha": "d0893cd09d8db845df30bdfd3537dc3f84104e09", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -722,8 +722,7 @@ pub enum LifetimeRes {\n         /// Id of the introducing place. That can be:\n         /// - an item's id, for the item's generic parameters;\n         /// - a TraitRef's ref_id, identifying the `for<...>` binder;\n-        /// - a BareFn type's id;\n-        /// - a Path's id when this path has parenthesized generic args.\n+        /// - a BareFn type's id.\n         ///\n         /// This information is used for impl-trait lifetime captures, to know when to or not to\n         /// capture any given lifetime."}, {"sha": "08d6134237a4954c3ac78e1a6825dd507f704251", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 140, "deletions": 53, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -21,7 +21,6 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::{PrimTy, TraitCandidate};\n-use rustc_index::vec::Idx;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n@@ -240,9 +239,16 @@ enum LifetimeRibKind {\n     /// Create a new anonymous lifetime parameter and reference it.\n     ///\n     /// If `report_in_path`, report an error when encountering lifetime elision in a path:\n-    /// ```ignore\n-    /// struct Foo<'a> { .. }\n-    /// fn foo(x: Foo) {}\n+    /// ```compile_fail\n+    /// struct Foo<'a> { x: &'a () }\n+    /// async fn foo(x: Foo) {}\n+    /// ```\n+    ///\n+    /// Note: the error should not trigger when the elided lifetime is in a pattern or\n+    /// expression-position path:\n+    /// ```\n+    /// struct Foo<'a> { x: &'a () }\n+    /// async fn foo(Foo { x: _ }: Foo<'_>) {}\n     /// ```\n     AnonymousCreateParameter { binder: NodeId, report_in_path: bool },\n \n@@ -634,7 +640,10 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     |this| {\n                         this.visit_generic_params(&bare_fn.generic_params, false);\n                         this.with_lifetime_rib(\n-                            LifetimeRibKind::AnonymousPassThrough(ty.id, false),\n+                            LifetimeRibKind::AnonymousCreateParameter {\n+                                binder: ty.id,\n+                                report_in_path: false,\n+                            },\n                             |this| walk_list!(this, visit_param, &bare_fn.decl.inputs),\n                         );\n                         this.with_lifetime_rib(\n@@ -720,15 +729,13 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             // a body, or if there's no body for some other reason.\n             FnKind::Fn(FnCtxt::Foreign, _, sig, _, generics, _)\n             | FnKind::Fn(_, _, sig, _, generics, None) => {\n+                self.visit_fn_header(&sig.header);\n+                self.visit_generics(generics);\n                 // We don't need to deal with patterns in parameters, because\n                 // they are not possible for foreign or bodiless functions.\n                 self.with_lifetime_rib(\n                     LifetimeRibKind::AnonymousPassThrough(fn_id, false),\n-                    |this| {\n-                        this.visit_fn_header(&sig.header);\n-                        this.visit_generics(generics);\n-                        walk_list!(this, visit_param, &sig.decl.inputs);\n-                    },\n+                    |this| walk_list!(this, visit_param, &sig.decl.inputs),\n                 );\n                 self.with_lifetime_rib(\n                     LifetimeRibKind::AnonymousPassThrough(fn_id, true),\n@@ -761,15 +768,18 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         // generic parameters.  This is especially useful for `async fn`, where\n                         // these fresh generic parameters can be applied to the opaque `impl Trait`\n                         // return type.\n+                        let rib = if async_node_id.is_some() {\n+                            // Only emit a hard error for `async fn`, since this kind of\n+                            // elision has always been allowed in regular `fn`s.\n+                            LifetimeRibKind::AnonymousCreateParameter {\n+                                binder: fn_id,\n+                                report_in_path: true,\n+                            }\n+                        } else {\n+                            LifetimeRibKind::AnonymousPassThrough(fn_id, false)\n+                        };\n                         this.with_lifetime_rib(\n-                            if async_node_id.is_some() {\n-                                LifetimeRibKind::AnonymousCreateParameter {\n-                                    binder: fn_id,\n-                                    report_in_path: true,\n-                                }\n-                            } else {\n-                                LifetimeRibKind::AnonymousPassThrough(fn_id, false)\n-                            },\n+                            rib,\n                             // Add each argument to the rib.\n                             |this| this.resolve_params(&declaration.inputs),\n                         );\n@@ -937,19 +947,66 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.diagnostic_metadata.currently_processing_generics = prev;\n     }\n \n+    fn visit_assoc_constraint(&mut self, constraint: &'ast AssocConstraint) {\n+        self.visit_ident(constraint.ident);\n+        if let Some(ref gen_args) = constraint.gen_args {\n+            // Forbid anonymous lifetimes in GAT parameters until proper semantics are decided.\n+            self.with_lifetime_rib(LifetimeRibKind::AnonymousReportError, |this| {\n+                this.visit_generic_args(gen_args.span(), gen_args)\n+            });\n+        }\n+        match constraint.kind {\n+            AssocConstraintKind::Equality { ref term } => match term {\n+                Term::Ty(ty) => self.visit_ty(ty),\n+                Term::Const(c) => self.visit_anon_const(c),\n+            },\n+            AssocConstraintKind::Bound { ref bounds } => {\n+                walk_list!(self, visit_param_bound, bounds, BoundKind::Bound);\n+            }\n+        }\n+    }\n+\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n         if let Some(ref args) = path_segment.args {\n             match &**args {\n                 GenericArgs::AngleBracketed(..) => visit::walk_generic_args(self, path_span, args),\n-                GenericArgs::Parenthesized(ref data) => {\n-                    self.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(path_segment.id, false),\n-                        |this| walk_list!(this, visit_ty, &data.inputs),\n-                    );\n-                    self.with_lifetime_rib(\n-                        LifetimeRibKind::AnonymousPassThrough(path_segment.id, true),\n-                        |this| visit::walk_fn_ret_ty(this, &data.output),\n-                    )\n+                GenericArgs::Parenthesized(p_args) => {\n+                    // Probe the lifetime ribs to know how to behave.\n+                    for rib in self.lifetime_ribs.iter().rev() {\n+                        match rib.kind {\n+                            // We are inside a `PolyTraitRef`.  The lifetimes are\n+                            // to be intoduced in that (maybe implicit) `for<>` binder.\n+                            LifetimeRibKind::Generics {\n+                                binder,\n+                                kind: LifetimeBinderKind::PolyTrait,\n+                                ..\n+                            } => {\n+                                self.with_lifetime_rib(\n+                                    LifetimeRibKind::AnonymousCreateParameter {\n+                                        binder,\n+                                        report_in_path: false,\n+                                    },\n+                                    |this| walk_list!(this, visit_ty, &p_args.inputs),\n+                                );\n+                                self.with_lifetime_rib(\n+                                    LifetimeRibKind::AnonymousPassThrough(binder, true),\n+                                    |this| visit::walk_fn_ret_ty(this, &p_args.output),\n+                                );\n+                                break;\n+                            }\n+                            // We have nowhere to introduce generics.  Code is malformed,\n+                            // so use regular lifetime resolution to avoid spurious errors.\n+                            LifetimeRibKind::Item | LifetimeRibKind::Generics { .. } => {\n+                                visit::walk_generic_args(self, path_span, args);\n+                                break;\n+                            }\n+                            LifetimeRibKind::AnonymousPassThrough(..)\n+                            | LifetimeRibKind::AnonymousCreateParameter { .. }\n+                            | LifetimeRibKind::AnonymousReportError\n+                            | LifetimeRibKind::AnonConst\n+                            | LifetimeRibKind::ConstGeneric => {}\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -1474,7 +1531,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 continue;\n             }\n \n-            let mut should_lint = match source {\n+            let missing = match source {\n                 PathSource::Trait(..) | PathSource::TraitItem(..) | PathSource::Type => true,\n                 PathSource::Expr(..)\n                 | PathSource::Pat\n@@ -1499,6 +1556,39 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 LifetimeRes::ElidedAnchor { start: node_ids.start, end: node_ids.end },\n             );\n \n+            if !missing {\n+                // Do not create a parameter for patterns and expressions.\n+                for rib in self.lifetime_ribs.iter().rev() {\n+                    match rib.kind {\n+                        LifetimeRibKind::AnonymousPassThrough(binder, _) => {\n+                            let res = LifetimeRes::Anonymous { binder, elided: true };\n+                            for id in node_ids {\n+                                self.record_lifetime_res(id, res);\n+                            }\n+                            break;\n+                        }\n+                        // `LifetimeRes::Error`, which would usually be used in the case of\n+                        // `ReportError`, is unsuitable here, as we don't emit an error yet.  Instead,\n+                        // we simply resolve to an implicit lifetime, which will be checked later, at\n+                        // which point a suitable error will be emitted.\n+                        LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n+                            // FIXME(cjgillot) This resolution is wrong, but this does not matter\n+                            // since these cases are erroneous anyway.  Lifetime resolution should\n+                            // emit a \"missing lifetime specifier\" diagnostic.\n+                            let res =\n+                                LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n+                            for id in node_ids {\n+                                self.record_lifetime_res(id, res);\n+                            }\n+                            break;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                continue;\n+            }\n+\n+            let mut should_lint = true;\n             for rib in self.lifetime_ribs.iter().rev() {\n                 match rib.kind {\n                     // In create-parameter mode we error here because we don't want to support\n@@ -1526,44 +1616,38 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         err.note(\"assuming a `'static` lifetime...\");\n                         err.emit();\n                         should_lint = false;\n-                        for i in 0..expected_lifetimes {\n-                            let id = node_ids.start.plus(i);\n+\n+                        for id in node_ids {\n                             self.record_lifetime_res(id, LifetimeRes::Error);\n                         }\n                         break;\n                     }\n+                    // Do not create a parameter for patterns and expressions.\n                     LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n-                        let res = self.create_fresh_lifetime(node_ids.start, ident, binder);\n-                        self.record_lifetime_res(node_ids.start, res);\n-                        for i in 1..expected_lifetimes {\n-                            let id = node_ids.start.plus(i);\n+                        for id in node_ids {\n                             let res = self.create_fresh_lifetime(id, ident, binder);\n                             self.record_lifetime_res(id, res);\n                         }\n                         break;\n                     }\n                     // `PassThrough` is the normal case.\n-                    // `new_error_lifetime`, which would usually be used in the case of `ReportError`,\n-                    // is unsuitable here, as these can occur from missing lifetime parameters in a\n-                    // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n-                    // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n-                    // later, at which point a suitable error will be emitted.\n                     LifetimeRibKind::AnonymousPassThrough(binder, _) => {\n                         let res = LifetimeRes::Anonymous { binder, elided: true };\n-                        self.record_lifetime_res(node_ids.start, res);\n-                        for i in 1..expected_lifetimes {\n-                            let id = node_ids.start.plus(i);\n+                        for id in node_ids {\n                             self.record_lifetime_res(id, res);\n                         }\n                         break;\n                     }\n+                    // `LifetimeRes::Error`, which would usually be used in the case of\n+                    // `ReportError`, is unsuitable here, as we don't emit an error yet.  Instead,\n+                    // we simply resolve to an implicit lifetime, which will be checked later, at\n+                    // which point a suitable error will be emitted.\n                     LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n                         // FIXME(cjgillot) This resolution is wrong, but this does not matter\n                         // since these cases are erroneous anyway.  Lifetime resolution should\n                         // emit a \"missing lifetime specifier\" diagnostic.\n                         let res = LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided: true };\n-                        for i in 0..expected_lifetimes {\n-                            let id = node_ids.start.plus(i);\n+                        for id in node_ids {\n                             self.record_lifetime_res(id, res);\n                         }\n                         break;\n@@ -2235,7 +2319,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn resolve_impl_item(&mut self, item: &'ast AssocItem) {\n         use crate::ResolutionError::*;\n         match &item.kind {\n-            AssocItemKind::Const(_default, _ty, _expr) => {\n+            AssocItemKind::Const(_, ty, default) => {\n                 debug!(\"resolve_implementation AssocItemKind::Const\");\n                 // If this is a trait impl, ensure the const\n                 // exists in trait\n@@ -2248,14 +2332,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     |i, s, c| ConstNotMemberOfTrait(i, s, c),\n                 );\n \n-                // We allow arbitrary const expressions inside of associated consts,\n-                // even if they are potentially not const evaluatable.\n-                //\n-                // Type parameters can already be used and as associated consts are\n-                // not used as part of the type system, this is far less surprising.\n-                self.with_constant_rib(IsRepeatExpr::No, HasGenericParams::Yes, None, |this| {\n-                    visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n-                });\n+                self.visit_ty(ty);\n+                if let Some(expr) = default {\n+                    // We allow arbitrary const expressions inside of associated consts,\n+                    // even if they are potentially not const evaluatable.\n+                    //\n+                    // Type parameters can already be used and as associated consts are\n+                    // not used as part of the type system, this is far less surprising.\n+                    self.with_constant_rib(IsRepeatExpr::No, HasGenericParams::Yes, None, |this| {\n+                        this.visit_expr(expr)\n+                    });\n+                }\n             }\n             AssocItemKind::Fn(box Fn { generics, .. }) => {\n                 debug!(\"resolve_implementation AssocItemKind::Fn\");"}, {"sha": "15f862e21d751dad25b882bb749dff3331866db9", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -2223,9 +2223,18 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n             ]\n             .contains(&Some(did))\n             {\n-                let (span, span_type) = match &trait_ref.bound_generic_params {\n-                    [] => (trait_ref.span.shrink_to_lo(), ForLifetimeSpanType::BoundEmpty),\n-                    [.., bound] => (bound.span.shrink_to_hi(), ForLifetimeSpanType::BoundTail),\n+                let (span, span_type) = if let Some(bound) =\n+                    trait_ref.bound_generic_params.iter().rfind(|param| {\n+                        matches!(\n+                            param.kind,\n+                            hir::GenericParamKind::Lifetime {\n+                                kind: hir::LifetimeParamKind::Explicit\n+                            }\n+                        )\n+                    }) {\n+                    (bound.span.shrink_to_hi(), ForLifetimeSpanType::BoundTail)\n+                } else {\n+                    (trait_ref.span.shrink_to_lo(), ForLifetimeSpanType::BoundEmpty)\n                 };\n                 self.missing_named_lifetime_spots\n                     .push(MissingLifetimeSpot::HigherRanked { span, span_type });"}, {"sha": "53f6870bdf50a25bd3cedb074f2379d62a581808", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -755,7 +755,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let next_early_index = self.next_early_index();\n                 let lifetime_span: Option<Span> =\n                     c.generic_params.iter().rev().find_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(param.span),\n+                        GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit } => {\n+                            Some(param.span)\n+                        }\n                         _ => None,\n                     });\n                 let (span, span_type) = if let Some(span) = lifetime_span {"}, {"sha": "9db051dc0112b3cf076334ca495b74e7cb270249", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -2920,13 +2920,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) {\n         for br in referenced_regions.difference(&constrained_regions) {\n             let br_name = match *br {\n+                ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) | ty::BrEnv => {\n+                    \"an anonymous lifetime\".to_string()\n+                }\n                 ty::BrNamed(_, name) => format!(\"lifetime `{}`\", name),\n-                ty::BrAnon(_) | ty::BrEnv => \"an anonymous lifetime\".to_string(),\n             };\n \n             let mut err = generate_err(&br_name);\n \n-            if let ty::BrAnon(_) = *br {\n+            if let ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) = *br {\n                 // The only way for an anonymous lifetime to wind up\n                 // in the return type but **also** be unconstrained is\n                 // if it only appears in \"associated types\" in the"}, {"sha": "95c82a7d2c3d8e15a419b2cb1e4e6d491358cc17", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -628,24 +628,40 @@ fn compare_number_of_generics<'tcx>(\n     let mut err_occurred = None;\n     for (kind, trait_count, impl_count) in matchings {\n         if impl_count != trait_count {\n+            let arg_spans = |kind: ty::AssocKind, generics: &hir::Generics<'_>| {\n+                let mut spans = generics\n+                    .params\n+                    .iter()\n+                    .filter(|p| match p.kind {\n+                        hir::GenericParamKind::Lifetime {\n+                            kind: hir::LifetimeParamKind::Elided,\n+                        } => {\n+                            // A fn can have an arbitrary number of extra elided lifetimes for the\n+                            // same signature.\n+                            !matches!(kind, ty::AssocKind::Fn)\n+                        }\n+                        _ => true,\n+                    })\n+                    .map(|p| p.span)\n+                    .collect::<Vec<Span>>();\n+                if spans.is_empty() {\n+                    spans = vec![generics.span]\n+                }\n+                spans\n+            };\n             let (trait_spans, impl_trait_spans) = if let Some(def_id) = trait_.def_id.as_local() {\n                 let trait_item = tcx.hir().expect_trait_item(def_id);\n-                if trait_item.generics.params.is_empty() {\n-                    (Some(vec![trait_item.generics.span]), vec![])\n-                } else {\n-                    let arg_spans: Vec<Span> =\n-                        trait_item.generics.params.iter().map(|p| p.span).collect();\n-                    let impl_trait_spans: Vec<Span> = trait_item\n-                        .generics\n-                        .params\n-                        .iter()\n-                        .filter_map(|p| match p.kind {\n-                            GenericParamKind::Type { synthetic: true, .. } => Some(p.span),\n-                            _ => None,\n-                        })\n-                        .collect();\n-                    (Some(arg_spans), impl_trait_spans)\n-                }\n+                let arg_spans: Vec<Span> = arg_spans(trait_.kind, trait_item.generics);\n+                let impl_trait_spans: Vec<Span> = trait_item\n+                    .generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|p| match p.kind {\n+                        GenericParamKind::Type { synthetic: true, .. } => Some(p.span),\n+                        _ => None,\n+                    })\n+                    .collect();\n+                (Some(arg_spans), impl_trait_spans)\n             } else {\n                 (trait_span.map(|s| vec![s]), vec![])\n             };\n@@ -660,23 +676,7 @@ fn compare_number_of_generics<'tcx>(\n                     _ => None,\n                 })\n                 .collect();\n-            let spans = if impl_item.generics.params.is_empty() {\n-                vec![impl_item.generics.span]\n-            } else {\n-                impl_item\n-                    .generics\n-                    .params\n-                    .iter()\n-                    .filter(|p| {\n-                        matches!(\n-                            p.kind,\n-                            hir::GenericParamKind::Type { .. }\n-                                | hir::GenericParamKind::Const { .. }\n-                        )\n-                    })\n-                    .map(|p| p.span)\n-                    .collect::<Vec<Span>>()\n-            };\n+            let spans = arg_spans(impl_.kind, impl_item.generics);\n             let span = spans.first().copied();\n \n             let mut err = tcx.sess.struct_span_err_with_code("}, {"sha": "c9fd7248a80044038a2bb9694fde051d7ebb1982", "filename": "src/test/ui/generic-associated-types/issue-70304.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -45,7 +45,7 @@ where\n }\n \n fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'_>> {\n-    //~^ ERROR: missing lifetime specifier\n+    //~^ ERROR `'_` cannot be used here [E0637]\n     //~| ERROR: missing lifetime specifier\n     DocumentImpl {}\n }"}, {"sha": "b3881ccb099f07d6a2707b4bf1789e764bfedd03", "filename": "src/test/ui/generic-associated-types/issue-70304.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-70304.stderr?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -1,14 +1,8 @@\n-error[E0106]: missing lifetime specifier\n+error[E0637]: `'_` cannot be used here\n   --> $DIR/issue-70304.rs:47:41\n    |\n LL | fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'_>> {\n-   |                                         ^^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL | fn create_doc() -> impl Document<Cursor<'static> = DocCursorImpl<'_>> {\n-   |                                         ~~~~~~~\n+   |                                         ^^ `'_` is a reserved lifetime name\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-70304.rs:47:61\n@@ -24,4 +18,5 @@ LL | fn create_doc() -> impl Document<Cursor<'_> = DocCursorImpl<'static>> {\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0106, E0637.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "2365daada11479fc8ffadf3b6008dcfc66e8208b", "filename": "src/test/ui/generic-associated-types/issue-95305.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -9,7 +9,7 @@ trait Foo {\n }\n \n fn foo(x: &impl Foo<Item<'_> = u32>) { }\n-                       //~^ ERROR missing lifetime specifier\n+                       //~^ ERROR `'_` cannot be used here [E0637]\n \n fn bar(x: &impl for<'a> Foo<Item<'a> = &'_ u32>) { }\n                                       //~^ ERROR missing lifetime specifier"}, {"sha": "8624d880d4ee27e91009a446376bde35b68e5823", "filename": "src/test/ui/generic-associated-types/issue-95305.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-95305.stderr?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -1,13 +1,8 @@\n-error[E0106]: missing lifetime specifier\n+error[E0637]: `'_` cannot be used here\n   --> $DIR/issue-95305.rs:11:26\n    |\n LL | fn foo(x: &impl Foo<Item<'_> = u32>) { }\n-   |                          ^^ expected named lifetime parameter\n-   |\n-help: consider introducing a named lifetime parameter\n-   |\n-LL | fn foo<'a>(x: &impl Foo<Item<'a> = u32>) { }\n-   |       ++++                   ~~\n+   |                          ^^ `'_` is a reserved lifetime name\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-95305.rs:14:41\n@@ -22,4 +17,5 @@ LL | fn bar(x: &impl for<'a> Foo<Item<'a> = &'a u32>) { }\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+Some errors have detailed explanations: E0106, E0637.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "1458bf0c4a49341147eb47f4bf57c7601c8e5199", "filename": "src/test/ui/generic-associated-types/parameter_number_and_kind_impl.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -8,15 +8,17 @@ LL |     type A = u32;\n    |           ^ lifetimes do not match type in trait\n \n error[E0049]: type `B` has 1 type parameter but its trait declaration has 0 type parameters\n-  --> $DIR/parameter_number_and_kind_impl.rs:17:16\n+  --> $DIR/parameter_number_and_kind_impl.rs:17:12\n    |\n LL |     type B<'a, 'b>;\n    |            --  --\n    |            |\n    |            expected 0 type parameters\n ...\n LL |     type B<'a, T> = Vec<T>;\n-   |                ^ found 1 type parameter\n+   |            ^^  ^\n+   |            |\n+   |            found 1 type parameter\n \n error[E0195]: lifetime parameters or bounds on type `C` do not match the trait declaration\n   --> $DIR/parameter_number_and_kind_impl.rs:19:11"}, {"sha": "0bfa7b3cc7c45e8acc440c359b5e2e72f52e344b", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-71955.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-71955.stderr?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -23,7 +23,7 @@ error[E0308]: mismatched types\n LL |     foo(bar, \"string\", |s| s.len() == 5);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n    |\n-   = note: expected trait `FnOnce<(&&str,)>`\n+   = note: expected trait `for<'r, 's> FnOnce<(&'r &'s str,)>`\n               found trait `for<'r> FnOnce<(&'r &str,)>`\n note: this closure does not fulfill the lifetime requirements\n   --> $DIR/issue-71955.rs:45:24\n@@ -61,7 +61,7 @@ error[E0308]: mismatched types\n LL |     foo(baz, \"string\", |s| s.0.len() == 5);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n    |\n-   = note: expected trait `FnOnce<(&Wrapper<'_>,)>`\n+   = note: expected trait `for<'r, 's> FnOnce<(&'r Wrapper<'s>,)>`\n               found trait `for<'r> FnOnce<(&'r Wrapper<'_>,)>`\n note: this closure does not fulfill the lifetime requirements\n   --> $DIR/issue-71955.rs:48:24"}, {"sha": "172bf218c0d4cd7244dcdbbeb4a3cd3f0a62ccd2", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-85455.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -6,8 +6,8 @@ trait SomeTrait<'a> {\n \n fn give_me_ice<T>() {\n     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n-    //~^ ERROR the trait bound `T: SomeTrait<'_>` is not satisfied [E0277]\n-    //~| ERROR the trait bound `T: SomeTrait<'_>` is not satisfied [E0277]\n+    //~^ ERROR the trait bound `for<'r> T: SomeTrait<'r>` is not satisfied [E0277]\n+    //~| ERROR the trait bound `for<'r> T: SomeTrait<'r>` is not satisfied [E0277]\n }\n \n fn callee<T: Fn<(&'static (),)>>() {"}, {"sha": "ecca4b999e7e8c1c04bb230261d1c50a8646e545", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-85455.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-85455.stderr?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -1,24 +1,24 @@\n-error[E0277]: the trait bound `T: SomeTrait<'_>` is not satisfied\n+error[E0277]: the trait bound `for<'r> T: SomeTrait<'r>` is not satisfied\n   --> $DIR/issue-85455.rs:8:5\n    |\n LL |     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `SomeTrait<'_>` is not implemented for `T`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'r> SomeTrait<'r>` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |\n-LL | fn give_me_ice<T: SomeTrait<'_>>() {\n-   |                 +++++++++++++++\n+LL | fn give_me_ice<T: for<'r> SomeTrait<'r>>() {\n+   |                 +++++++++++++++++++++++\n \n-error[E0277]: the trait bound `T: SomeTrait<'_>` is not satisfied\n+error[E0277]: the trait bound `for<'r> T: SomeTrait<'r>` is not satisfied\n   --> $DIR/issue-85455.rs:8:14\n    |\n LL |     callee::<fn(&()) -> <T as SomeTrait<'_>>::Associated>();\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `SomeTrait<'_>` is not implemented for `T`\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'r> SomeTrait<'r>` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |\n-LL | fn give_me_ice<T: SomeTrait<'_>>() {\n-   |                 +++++++++++++++\n+LL | fn give_me_ice<T: for<'r> SomeTrait<'r>>() {\n+   |                 +++++++++++++++++++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "359c08c98d1ab8e0357326b1ec096083674c0a1a", "filename": "src/test/ui/impl-header-lifetime-elision/dyn-trait.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -13,6 +13,10 @@ impl StaticTrait for Box<dyn Debug> { }\n trait NotStaticTrait { }\n impl NotStaticTrait for Box<dyn Debug + '_> { }\n \n+// Check that we don't err when the trait has a lifetime parameter.\n+trait TraitWithLifetime<'a> { }\n+impl NotStaticTrait for &dyn TraitWithLifetime<'_> { }\n+\n fn static_val<T: StaticTrait>(_: T) {\n }\n "}, {"sha": "762698c4fc141b7753a41ff12635ba51b42b5409", "filename": "src/test/ui/impl-header-lifetime-elision/dyn-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -1,5 +1,5 @@\n error[E0521]: borrowed data escapes outside of function\n-  --> $DIR/dyn-trait.rs:20:5\n+  --> $DIR/dyn-trait.rs:24:5\n    |\n LL | fn with_dyn_debug_static<'a>(x: Box<dyn Debug + 'a>) {\n    |                          --  - `x` is a reference that is only valid in the function body"}, {"sha": "ff84d2511496005f6e8de48e16a37f10bba999da", "filename": "src/test/ui/lifetimes/elided-lifetime-in-path-in-pat.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Flifetimes%2Felided-lifetime-in-path-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Flifetimes%2Felided-lifetime-in-path-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Felided-lifetime-in-path-in-pat.rs?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+struct Foo<'a> {\n+    x: &'a (),\n+}\n+\n+// The lifetime in pattern-position `Foo` is elided.\n+// Verify that lowering does not create an independent lifetime parameter for it.\n+fn foo<'a>(Foo { x }: Foo<'a>) {\n+    *x\n+}\n+\n+fn main() {}"}, {"sha": "d85ea6529f628e08ea4272e961a378d99a8315bb", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-using-trait-objects.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/32af719b07217ff89e61a2031500cee138599baa/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.stderr?ref=32af719b07217ff89e61a2031500cee138599baa", "patch": "@@ -10,8 +10,8 @@ LL |   y.push(z);\n    |\n help: consider introducing a named lifetime parameter\n    |\n-LL | fn foo<'a>(x:Box<dyn Fn(&'a u8, &'a u8)> , y: Vec<&u8>, z: &u8) {\n-   |       ++++               ++      ++\n+LL | fn foo<'a>(x:Box<dyn Fn(&u8, &u8)> , y: Vec<&'a u8>, z: &'a u8) {\n+   |       ++++                                   ++          ++\n \n error[E0596]: cannot borrow `y` as mutable, as it is not declared as mutable\n   --> $DIR/ex3-both-anon-regions-using-trait-objects.rs:2:3"}]}