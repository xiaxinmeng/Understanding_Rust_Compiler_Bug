{"sha": "a1c170fc355947f54129a97aedcb8dea3d555f71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYzE3MGZjMzU1OTQ3ZjU0MTI5YTk3YWVkY2I4ZGVhM2Q1NTVmNzE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:41Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc: Split local type contexts interners from the global one.", "tree": {"sha": "c9a14d32948bcde76d6872b17c491cbbcebf2fd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9a14d32948bcde76d6872b17c491cbbcebf2fd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1c170fc355947f54129a97aedcb8dea3d555f71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c170fc355947f54129a97aedcb8dea3d555f71", "html_url": "https://github.com/rust-lang/rust/commit/a1c170fc355947f54129a97aedcb8dea3d555f71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1c170fc355947f54129a97aedcb8dea3d555f71/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31a07b0ce662e95119a76cce8dcfc29d2055f738", "url": "https://api.github.com/repos/rust-lang/rust/commits/31a07b0ce662e95119a76cce8dcfc29d2055f738", "html_url": "https://github.com/rust-lang/rust/commit/31a07b0ce662e95119a76cce8dcfc29d2055f738"}], "stats": {"total": 1842, "additions": 1142, "deletions": 700}, "files": [{"sha": "fe9e128d8a6caebda1fae87d67a157b7968bb403", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 190, "deletions": 57, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -24,6 +24,7 @@ use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::region::CodeExtent;\n+use mir::tcx::LvalueTy;\n use ty::subst;\n use ty::subst::Substs;\n use ty::subst::Subst;\n@@ -35,7 +36,7 @@ use ty::fold::TypeFoldable;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n@@ -72,10 +73,36 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n+/// A version of &ty::Tables which can be global or local.\n+/// Only the local version supports borrow_mut.\n+#[derive(Copy, Clone)]\n+pub enum InferTables<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    Global(&'a RefCell<ty::Tables<'gcx>>),\n+    Local(&'a RefCell<ty::Tables<'tcx>>)\n+}\n+\n+impl<'a, 'gcx, 'tcx> InferTables<'a, 'gcx, 'tcx> {\n+    pub fn borrow(self) -> Ref<'a, ty::Tables<'tcx>> {\n+        match self {\n+            InferTables::Global(tables) => tables.borrow(),\n+            InferTables::Local(tables) => tables.borrow()\n+        }\n+    }\n+\n+    pub fn borrow_mut(self) -> RefMut<'a, ty::Tables<'tcx>> {\n+        match self {\n+            InferTables::Global(_) => {\n+                bug!(\"InferTables: infcx.tables.borrow_mut() outside of type-checking\");\n+            }\n+            InferTables::Local(tables) => tables.borrow_mut()\n+        }\n+    }\n+}\n+\n pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n-    pub tables: &'a RefCell<ty::Tables<'tcx>>,\n+    pub tables: InferTables<'a, 'gcx, 'tcx>,\n \n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n@@ -390,48 +417,106 @@ impl fmt::Display for FixupError {\n     }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n-    pub fn enter<F, R>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       tables: Option<ty::Tables<'tcx>>,\n-                       param_env: Option<ty::ParameterEnvironment<'tcx>>,\n-                       projection_mode: ProjectionMode,\n-                       f: F) -> R\n-        where F: for<'b> FnOnce(InferCtxt<'b, 'tcx, 'tcx>) -> R\n+/// Helper type of a temporary returned by tcx.infer_ctxt(...).\n+/// Necessary because we can't write the following bound:\n+/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n+pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    arenas: ty::CtxtArenas<'tcx>,\n+    tables: Option<RefCell<ty::Tables<'tcx>>>,\n+    param_env: Option<ty::ParameterEnvironment<'gcx>>,\n+    projection_mode: ProjectionMode,\n+    normalize: bool\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n+    pub fn infer_ctxt(self,\n+                      tables: Option<ty::Tables<'tcx>>,\n+                      param_env: Option<ty::ParameterEnvironment<'gcx>>,\n+                      projection_mode: ProjectionMode)\n+                      -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+        InferCtxtBuilder {\n+            global_tcx: self,\n+            arenas: ty::CtxtArenas::new(),\n+            tables: tables.map(RefCell::new),\n+            param_env: param_env,\n+            projection_mode: projection_mode,\n+            normalize: false\n+        }\n+    }\n+\n+    pub fn normalizing_infer_ctxt(self, projection_mode: ProjectionMode)\n+                                  -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+        InferCtxtBuilder {\n+            global_tcx: self,\n+            arenas: ty::CtxtArenas::new(),\n+            tables: None,\n+            param_env: None,\n+            projection_mode: projection_mode,\n+            normalize: false\n+        }\n+    }\n+\n+    /// Fake InferCtxt with the global tcx. Used by pre-MIR borrowck\n+    /// for MemCategorizationContext/ExprUseVisitor.\n+    /// If any inference functionality is used, ICEs will occur.\n+    pub fn borrowck_fake_infer_ctxt(self, param_env: ty::ParameterEnvironment<'gcx>)\n+                                    -> InferCtxt<'a, 'gcx, 'gcx> {\n+        InferCtxt {\n+            tcx: self,\n+            tables: InferTables::Global(&self.tables),\n+            type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n+            int_unification_table: RefCell::new(UnificationTable::new()),\n+            float_unification_table: RefCell::new(UnificationTable::new()),\n+            region_vars: RegionVarBindings::new(self),\n+            parameter_environment: param_env,\n+            selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n+            reported_trait_errors: RefCell::new(FnvHashSet()),\n+            normalize: false,\n+            projection_mode: ProjectionMode::AnyFinal,\n+            tainted_by_errors_flag: Cell::new(false),\n+            err_count_on_creation: self.sess.err_count()\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+    pub fn enter<F, R>(&'tcx mut self, f: F) -> R\n+        where F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R\n     {\n-        let new_tables;\n-        let tables = if let Some(tables) = tables {\n-            new_tables = RefCell::new(tables);\n-            &new_tables\n+        let InferCtxtBuilder {\n+            global_tcx,\n+            ref arenas,\n+            ref tables,\n+            ref mut param_env,\n+            projection_mode,\n+            normalize\n+        } = *self;\n+        let tables = if let Some(ref tables) = *tables {\n+            InferTables::Local(tables)\n         } else {\n-            &tcx.tables\n+            InferTables::Global(&global_tcx.tables)\n         };\n-        f(InferCtxt {\n+        let param_env = param_env.take().unwrap_or_else(|| {\n+            global_tcx.empty_parameter_environment()\n+        });\n+        global_tcx.enter_local(arenas, |tcx| f(InferCtxt {\n             tcx: tcx,\n             tables: tables,\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(tcx),\n-            parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n+            parameter_environment: param_env,\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             reported_trait_errors: RefCell::new(FnvHashSet()),\n-            normalize: false,\n+            normalize: normalize,\n             projection_mode: projection_mode,\n-        tainted_by_errors_flag: Cell::new(false),\n+            tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count()\n-        })\n-    }\n-\n-    pub fn enter_normalizing<F, R>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   projection_mode: ProjectionMode,\n-                                   f: F) -> R\n-        where F: for<'b> FnOnce(InferCtxt<'b, 'tcx, 'tcx>) -> R\n-    {\n-        InferCtxt::enter(tcx, None, None, projection_mode, |mut infcx| {\n-            infcx.normalize = true;\n-            f(infcx)\n-        })\n+        }))\n     }\n }\n \n@@ -459,10 +544,54 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n+/// Helper trait for shortening the lifetimes inside a\n+/// value for post-type-checking normalization.\n+pub trait TransNormalize<'gcx>: TypeFoldable<'gcx> {\n+    fn trans_normalize<'a, 'tcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n+}\n+\n+macro_rules! items { ($($item:item)+) => ($($item)+) }\n+macro_rules! impl_trans_normalize {\n+    ($lt_gcx:tt, $($ty:ty),+) => {\n+        items!($(impl<$lt_gcx> TransNormalize<$lt_gcx> for $ty {\n+            fn trans_normalize<'a, 'tcx>(&self,\n+                                         infcx: &InferCtxt<'a, $lt_gcx, 'tcx>)\n+                                         -> Self {\n+                infcx.normalize_projections_in(self)\n+            }\n+        })+);\n+    }\n+}\n+\n+impl_trans_normalize!('gcx,\n+    Ty<'gcx>,\n+    &'gcx Substs<'gcx>,\n+    ty::FnSig<'gcx>,\n+    ty::FnOutput<'gcx>,\n+    &'gcx ty::BareFnTy<'gcx>,\n+    ty::ClosureSubsts<'gcx>,\n+    ty::PolyTraitRef<'gcx>\n+);\n+\n+impl<'gcx> TransNormalize<'gcx> for LvalueTy<'gcx> {\n+    fn trans_normalize<'a, 'tcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        match *self {\n+            LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.trans_normalize(infcx) },\n+            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n+                LvalueTy::Downcast {\n+                    adt_def: adt_def,\n+                    substs: substs.trans_normalize(infcx),\n+                    variant_index: variant_index\n+                }\n+            }\n+        }\n+    }\n+}\n+\n // NOTE: Callable from trans only!\n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn normalize_associated_type<T>(self, value: &T) -> T\n-        where T : TypeFoldable<'tcx>\n+        where T: TransNormalize<'tcx>\n     {\n         debug!(\"normalize_associated_type(t={:?})\", value);\n \n@@ -472,15 +601,15 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        InferCtxt::enter(self, None, None, ProjectionMode::Any, |infcx| {\n-            infcx.normalize_projections_in(&value)\n+        self.infer_ctxt(None, None, ProjectionMode::Any).enter(|infcx| {\n+            value.trans_normalize(&infcx)\n         })\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn normalize_projections_in<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx>\n+    fn normalize_projections_in<T>(&self, value: &T) -> T::Lifted\n+        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n     {\n         let mut selcx = traits::SelectionContext::new(self);\n         let cause = traits::ObligationCause::dummy();\n@@ -503,16 +632,21 @@ pub fn drain_fulfillment_cx_or_panic<T>(&self,\n                                         span: Span,\n                                         fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                         result: &T)\n-                                        -> T\n-    where T : TypeFoldable<'tcx>\n+                                        -> T::Lifted\n+    where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n {\n-    match self.drain_fulfillment_cx(fulfill_cx, result) {\n+    let when = \"resolving bounds after type-checking\";\n+    let v = match self.drain_fulfillment_cx(fulfill_cx, result) {\n         Ok(v) => v,\n         Err(errors) => {\n-            span_bug!(\n-                span,\n-                \"Encountered errors `{:?}` fulfilling during trans\",\n-                errors);\n+            span_bug!(span, \"Encountered errors `{:?}` {}\", errors, when);\n+        }\n+    };\n+\n+    match self.tcx.lift_to_global(&v) {\n+        Some(v) => v,\n+        None => {\n+            span_bug!(span, \"Uninferred types/regions in `{:?}` {}\", v, when);\n         }\n     }\n }\n@@ -1449,18 +1583,16 @@ pub fn drain_fulfillment_cx<T>(&self,\n         self.resolve_type_vars_or_error(&ty)\n     }\n \n-    pub fn tables_are_tcx_tables(&self) -> bool {\n-        let tables: &RefCell<ty::Tables> = &self.tables;\n-        let tcx_tables: &RefCell<ty::Tables> = &self.tcx.tables;\n-        tables as *const _ as usize == tcx_tables as *const _ as usize\n-    }\n-\n     pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n         if let Some(ty) = self.tcx.lift_to_global(&ty) {\n-            // HACK(eddyb) Temporarily handle infer type in the global tcx.\n-            if !ty.needs_infer() &&\n-               !(ty.has_closure_types() && !self.tables_are_tcx_tables()) {\n+            // Even if the type may have no inference variables, during\n+            // type-checking closure types are in local tables only.\n+            let local_closures = match self.tables {\n+                InferTables::Local(_) => ty.has_closure_types(),\n+                InferTables::Global(_) => false\n+            };\n+            if !local_closures {\n                 return ty.moves_by_default(self.tcx.global_tcx(), self.param_env(), span);\n             }\n         }\n@@ -1527,7 +1659,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n             // during trans, we see closure ids from other traits.\n             // That may require loading the closure data out of the\n             // cstore.\n-            Some(ty::Tables::closure_kind(&self.tables, self.tcx, def_id))\n+            Some(self.tcx.closure_kind(def_id))\n         }\n     }\n \n@@ -1536,12 +1668,13 @@ pub fn drain_fulfillment_cx<T>(&self,\n                         substs: ty::ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        let closure_ty =\n-            ty::Tables::closure_type(self.tables,\n-                                     self.tcx,\n-                                     def_id,\n-                                     substs);\n+        if let InferTables::Local(tables) = self.tables {\n+            if let Some(ty) = tables.borrow().closure_tys.get(&def_id) {\n+                return ty.subst(self.tcx, substs.func_substs);\n+            }\n+        }\n \n+        let closure_ty = self.tcx.closure_type(def_id, substs);\n         if self.normalize {\n             let closure_ty = self.tcx.erase_regions(&closure_ty);\n "}, {"sha": "07e69d85ff41bb811f451d7f96d69bbea1206767", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -36,7 +36,7 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n     fn visit_const(&mut self, item_id: ast::NodeId, expr: &hir::Expr) {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n-        InferCtxt::enter(self.tcx, None, Some(param_env), ProjectionMode::Any, |infcx| {\n+        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::Any).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n@@ -49,7 +49,7 @@ struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> ExprVisitor<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match self.infcx.tcx.lookup_item_type(def_id).ty.sty {\n             ty::TyFnDef(_, _, ref bfty) => bfty.abi == RustIntrinsic,\n@@ -58,7 +58,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx, 'tcx> {\n         intrinsic && self.infcx.tcx.item_name(def_id).as_str() == \"transmute\"\n     }\n \n-    fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {\n+    fn check_transmute(&self, span: Span, from: Ty<'gcx>, to: Ty<'gcx>, id: ast::NodeId) {\n         let sk_from = SizeSkeleton::compute(from, self.infcx);\n         let sk_to = SizeSkeleton::compute(to, self.infcx);\n \n@@ -84,7 +84,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx, 'tcx> {\n         }\n \n         // Try to display a sensible error with as much information as possible.\n-        let skeleton_string = |ty: Ty<'tcx>, sk| {\n+        let skeleton_string = |ty: Ty<'gcx>, sk| {\n             match sk {\n                 Ok(SizeSkeleton::Known(size)) => {\n                     format!(\"{} bits\", size.bits())\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     // const, static and N in [T; N].\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-        InferCtxt::enter(self.tcx, None, None, ProjectionMode::Any, |infcx| {\n+        self.tcx.infer_ctxt(None, None, ProjectionMode::Any).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n@@ -144,7 +144,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-        InferCtxt::enter(self.tcx, None, Some(param_env), ProjectionMode::Any, |infcx| {\n+        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::Any).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n@@ -153,7 +153,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprPath(..) = expr.node {\n             match self.infcx.tcx.resolve_expr(expr) {"}, {"sha": "473fd7d9be65473f7fdf02bd422ce99fedc847d0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -114,7 +114,6 @@ use hir::def::*;\n use hir::pat_util;\n use ty::{self, TyCtxt, ParameterEnvironment};\n use traits::{self, ProjectionMode};\n-use infer::InferCtxt;\n use ty::subst::Subst;\n use lint;\n use util::nodemap::NodeMap;\n@@ -1488,8 +1487,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n                 let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n                 let t_ret_subst = t_ret.subst(self.ir.tcx, &param_env.free_substs);\n-                let is_nil = InferCtxt::enter(self.ir.tcx, None, Some(param_env),\n-                                              ProjectionMode::Any, |infcx| {\n+                let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n+                                                    ProjectionMode::Any).enter(|infcx| {\n                     let cause = traits::ObligationCause::dummy();\n                     traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n                 });"}, {"sha": "a1c0d92f60cd63c874e5ea9fc528249ba13362eb", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -30,12 +30,12 @@ pub enum LvalueTy<'tcx> {\n                variant_index: usize },\n }\n \n-impl<'a, 'tcx> LvalueTy<'tcx> {\n+impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> LvalueTy<'tcx> {\n         LvalueTy::Ty { ty: ty }\n     }\n \n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             LvalueTy::Ty { ty } =>\n                 ty,\n@@ -44,7 +44,7 @@ impl<'a, 'tcx> LvalueTy<'tcx> {\n         }\n     }\n \n-    pub fn projection_ty(self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn projection_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          elem: &LvalueElem<'tcx>)\n                          -> LvalueTy<'tcx>\n     {\n@@ -99,8 +99,8 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Mir<'tcx> {\n-    pub fn operand_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n+    pub fn operand_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                       operand: &Operand<'tcx>)\n                       -> Ty<'tcx>\n     {\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn binop_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn binop_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     op: BinOp,\n                     lhs_ty: Ty<'tcx>,\n                     rhs_ty: Ty<'tcx>)\n@@ -134,7 +134,7 @@ impl<'a, 'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn lvalue_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn lvalue_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      lvalue: &Lvalue<'tcx>)\n                      -> LvalueTy<'tcx>\n     {\n@@ -154,7 +154,7 @@ impl<'a, 'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn rvalue_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub fn rvalue_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      rvalue: &Rvalue<'tcx>)\n                      -> Option<Ty<'tcx>>\n     {\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> Mir<'tcx> {\n                         ))\n                     }\n                     AggregateKind::Adt(def, _, substs) => {\n-                        Some(def.type_scheme(tcx).ty.subst(tcx, substs))\n+                        Some(tcx.lookup_item_type(def.did).ty.subst(tcx, substs))\n                     }\n                     AggregateKind::Closure(did, substs) => {\n                         Some(tcx.mk_closure_from_closure_substs(did, substs))"}, {"sha": "414b9fa70c3026381307da3aeeab2076d5be1065", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -24,10 +24,10 @@ struct InferIsLocal(bool);\n \n /// If there are types that satisfy both impls, returns a suitably-freshened\n /// `ImplHeader` with those types substituted\n-pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx, 'tcx>,\n-                                    impl1_def_id: DefId,\n-                                    impl2_def_id: DefId)\n-                                    -> Option<ty::ImplHeader<'tcx>>\n+pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+                                          impl1_def_id: DefId,\n+                                          impl2_def_id: DefId)\n+                                          -> Option<ty::ImplHeader<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -41,10 +41,10 @@ pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx, 'tcx>,\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n-fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx, 'tcx>,\n-                      a_def_id: DefId,\n-                      b_def_id: DefId)\n-                      -> Option<ty::ImplHeader<'tcx>>\n+fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+                            a_def_id: DefId,\n+                            b_def_id: DefId)\n+                            -> Option<ty::ImplHeader<'tcx>>\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n            a_def_id,"}, {"sha": "f606d73a5493f9f62469d40f5fdfd046795d1339", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -422,7 +422,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    InferCtxt::enter(tcx, None, Some(elaborated_env), ProjectionMode::AnyFinal, |infcx| {\n+    tcx.infer_ctxt(None, Some(elaborated_env), ProjectionMode::AnyFinal).enter(|infcx| {\n         let predicates = match fully_normalize(&infcx, cause,\n                                                &infcx.parameter_environment.caller_bounds) {\n             Ok(predicates) => predicates,\n@@ -454,17 +454,22 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n \n+        let predicates = match tcx.lift_to_global(&predicates) {\n+            Some(predicates) => predicates,\n+            None => return infcx.parameter_environment\n+        };\n+\n         debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n             predicates);\n \n         infcx.parameter_environment.with_caller_bounds(predicates)\n     })\n }\n \n-pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx, 'tcx>,\n-                                  cause: ObligationCause<'tcx>,\n-                                  value: &T)\n-                                  -> Result<T, Vec<FulfillmentError<'tcx>>>\n+pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                          cause: ObligationCause<'tcx>,\n+                                          value: &T)\n+                                          -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n {\n     debug!(\"fully_normalize(value={:?})\", value);"}, {"sha": "d43d2de1f1fbcdb6f73b6ea80c1e2da0a1864ce8", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -146,14 +146,21 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);\n \n-    InferCtxt::enter_normalizing(tcx, ProjectionMode::Topmost, |mut infcx| {\n+    tcx.normalizing_infer_ctxt(ProjectionMode::Topmost).enter(|mut infcx| {\n         // Normalize the trait reference, adding any obligations\n         // that arise into the impl1 assumptions.\n         let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n             let selcx = &mut SelectionContext::new(&infcx);\n             traits::normalize(selcx, ObligationCause::dummy(), &impl1_trait_ref)\n         };\n-        penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| o.predicate));\n+        penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| {\n+            match tcx.lift_to_global(&o.predicate) {\n+                Some(predicate) => predicate,\n+                None => {\n+                    bug!(\"specializes: obligation `{:?}` has inference types/regions\", o);\n+                }\n+            }\n+        }));\n \n         // Install the parameter environment, taking the predicates of impl1 as assumptions:\n         infcx.parameter_environment = penv;"}, {"sha": "ae7deb48f8677900ab93a6558bd20a0b29fa093a", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -14,7 +14,6 @@ use std::rc::Rc;\n use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n-use infer::InferCtxt;\n use traits::{self, ProjectionMode};\n use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n@@ -112,8 +111,8 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = InferCtxt::enter(tcx, None, None,\n-                                            ProjectionMode::Topmost, |infcx| {\n+            let (le, ge) = tcx.infer_ctxt(None, None,\n+                                          ProjectionMode::Topmost).enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "1495ae72ab34448d50d2754566c51d5c8480e50a", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -153,6 +153,58 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n     }\n }\n \n+// For trans only.\n+impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n+    type Lifted = traits::Vtable<'tcx, ()>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match self.clone() {\n+            traits::VtableImpl(traits::VtableImplData {\n+                impl_def_id,\n+                substs,\n+                nested\n+            }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableImpl(traits::VtableImplData {\n+                        impl_def_id: impl_def_id,\n+                        substs: substs,\n+                        nested: nested\n+                    })\n+                })\n+            }\n+            traits::VtableDefaultImpl(t) => Some(traits::VtableDefaultImpl(t)),\n+            traits::VtableClosure(traits::VtableClosureData {\n+                closure_def_id,\n+                substs,\n+                nested\n+            }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableClosure(traits::VtableClosureData {\n+                        closure_def_id: closure_def_id,\n+                        substs: substs,\n+                        nested: nested\n+                    })\n+                })\n+            }\n+            traits::VtableFnPointer(ty) => {\n+                tcx.lift(&ty).map(traits::VtableFnPointer)\n+            }\n+            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n+            traits::VtableBuiltin(d) => Some(traits::VtableBuiltin(d)),\n+            traits::VtableObject(traits::VtableObjectData {\n+                upcast_trait_ref,\n+                vtable_base\n+            }) => {\n+                tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n+                    traits::VtableObject(traits::VtableObjectData {\n+                        upcast_trait_ref: trait_ref,\n+                        vtable_base: vtable_base\n+                    })\n+                })\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n "}, {"sha": "39fe744c67d01528f865e96728918c589d6e2b45", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 236, "deletions": 169, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -22,7 +22,7 @@ use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n use middle::stability;\n-use ty::subst::{self, Subst, Substs};\n+use ty::subst::{self, Substs};\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants};\n@@ -41,6 +41,7 @@ use arena::TypedArena;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n+use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n use syntax::ast::{self, Name, NodeId};\n@@ -82,22 +83,22 @@ impl<'tcx> CtxtArenas<'tcx> {\n     }\n }\n \n-struct CtxtInterners<'tcx> {\n+pub struct CtxtInterners<'tcx> {\n     /// The arenas that types etc are allocated from.\n     arenas: &'tcx CtxtArenas<'tcx>,\n \n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n-    type_: RefCell<FnvHashSet<InternedTy<'tcx>>>,\n-    type_list: RefCell<FnvHashSet<InternedTyList<'tcx>>>,\n-    substs: RefCell<FnvHashSet<InternedSubsts<'tcx>>>,\n-    bare_fn: RefCell<FnvHashSet<&'tcx BareFnTy<'tcx>>>,\n-    region: RefCell<FnvHashSet<InternedRegion<'tcx>>>,\n+    type_: RefCell<FnvHashSet<Interned<'tcx, TyS<'tcx>>>>,\n+    type_list: RefCell<FnvHashSet<Interned<'tcx, [Ty<'tcx>]>>>,\n+    substs: RefCell<FnvHashSet<Interned<'tcx, Substs<'tcx>>>>,\n+    bare_fn: RefCell<FnvHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n+    region: RefCell<FnvHashSet<Interned<'tcx, Region>>>,\n     stability: RefCell<FnvHashSet<&'tcx attr::Stability>>,\n     layout: RefCell<FnvHashSet<&'tcx Layout>>,\n }\n \n-impl<'tcx> CtxtInterners<'tcx> {\n+impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n     fn new(arenas: &'tcx CtxtArenas<'tcx>) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arenas: arenas,\n@@ -111,24 +112,58 @@ impl<'tcx> CtxtInterners<'tcx> {\n         }\n     }\n \n-    fn intern_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n+    /// Intern a type. global_interners is Some only if this is\n+    /// a local interner and global_interners is its counterpart.\n+    fn intern_ty(&self, st: TypeVariants<'tcx>,\n+                 global_interners: Option<&CtxtInterners<'gcx>>)\n+                 -> Ty<'tcx> {\n         let ty = {\n             let mut interner = self.type_.borrow_mut();\n-            match interner.get(&st) {\n-                Some(&InternedTy { ty }) => return ty,\n-                None => ()\n+            let global_interner = global_interners.map(|interners| {\n+                interners.type_.borrow_mut()\n+            });\n+            if let Some(&Interned(ty)) = interner.get(&st) {\n+                return ty;\n+            }\n+            if let Some(ref interner) = global_interner {\n+                if let Some(&Interned(ty)) = interner.get(&st) {\n+                    return ty;\n+                }\n             }\n \n             let flags = super::flags::FlagComputation::for_sty(&st);\n-\n-            // Don't be &mut TyS.\n-            let ty: Ty = self.arenas.type_.alloc(TyS {\n+            let ty_struct = TyS {\n                 sty: st,\n                 flags: Cell::new(flags.flags),\n                 region_depth: flags.depth,\n-            });\n+            };\n+\n+            // HACK(eddyb) Depend on flags being accurate to\n+            // determine that all contents are in the global tcx.\n+            // See comments on Lift for why we can't use that.\n+            if !flags.flags.intersects(ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n+                if let Some(interner) = global_interners {\n+                    let ty_struct: TyS<'gcx> = unsafe {\n+                        mem::transmute(ty_struct)\n+                    };\n+                    let ty: Ty<'gcx> = interner.arenas.type_.alloc(ty_struct);\n+                    global_interner.unwrap().insert(Interned(ty));\n+                    return ty;\n+                }\n+            } else {\n+                // Make sure we don't end up with inference\n+                // types/regions in the global tcx.\n+                if global_interners.is_none() {\n+                    drop(interner);\n+                    bug!(\"Attempted to intern `{:?}` which contains \\\n+                          inference types/regions in the global type context\",\n+                         &ty_struct);\n+                }\n+            }\n \n-            interner.insert(InternedTy { ty: ty });\n+            // Don't be &mut TyS.\n+            let ty: Ty<'tcx> = self.arenas.type_.alloc(ty_struct);\n+            interner.insert(Interned(ty));\n             ty\n         };\n \n@@ -212,45 +247,11 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n             fru_field_types: NodeMap()\n         }\n     }\n-\n-    pub fn closure_kind(this: &RefCell<Self>,\n-                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                        def_id: DefId)\n-                        -> ty::ClosureKind {\n-        // If this is a local def-id, it should be inserted into the\n-        // tables by typeck; else, it will be retreived from\n-        // the external crate metadata.\n-        if let Some(&kind) = this.borrow().closure_kinds.get(&def_id) {\n-            return kind;\n-        }\n-\n-        let kind = tcx.sess.cstore.closure_kind(def_id);\n-        this.borrow_mut().closure_kinds.insert(def_id, kind);\n-        kind\n-    }\n-\n-    pub fn closure_type(this: &RefCell<Self>,\n-                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                        def_id: DefId,\n-                        substs: ClosureSubsts<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-    {\n-        // If this is a local def-id, it should be inserted into the\n-        // tables by typeck; else, it will be retreived from\n-        // the external crate metadata.\n-        if let Some(ty) = this.borrow().closure_tys.get(&def_id) {\n-            return ty.subst(tcx, substs.func_substs);\n-        }\n-\n-        let ty = tcx.sess.cstore.closure_ty(tcx.global_tcx(), def_id);\n-        this.borrow_mut().closure_tys.insert(def_id, ty.clone());\n-        ty.subst(tcx, substs.func_substs)\n-    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n-        let mk = |sty| interners.intern_ty(sty);\n+        let mk = |sty| interners.intern_ty(sty, None);\n         CommonTypes {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n@@ -558,27 +559,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n-    pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {\n-        if let Some(st) = self.interners.stability.borrow().get(&stab) {\n+    pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n+        if let Some(st) = self.global_interners.stability.borrow().get(&stab) {\n             return st;\n         }\n \n-        let interned = self.interners.arenas.stability.alloc(stab);\n-        if let Some(prev) = self.interners.stability\n+        let interned = self.global_interners.arenas.stability.alloc(stab);\n+        if let Some(prev) = self.global_interners.stability\n                                 .borrow_mut()\n                                 .replace(interned) {\n             bug!(\"Tried to overwrite interned Stability: {:?}\", prev)\n         }\n         interned\n     }\n \n-    pub fn intern_layout(self, layout: Layout) -> &'tcx Layout {\n-        if let Some(layout) = self.interners.layout.borrow().get(&layout) {\n+    pub fn intern_layout(self, layout: Layout) -> &'gcx Layout {\n+        if let Some(layout) = self.global_interners.layout.borrow().get(&layout) {\n             return layout;\n         }\n \n-        let interned = self.interners.arenas.layout.alloc(layout);\n-        if let Some(prev) = self.interners.layout\n+        let interned = self.global_interners.arenas.layout.alloc(layout);\n+        if let Some(prev) = self.global_interners.layout\n                                 .borrow_mut()\n                                 .replace(interned) {\n             bug!(\"Tried to overwrite interned Layout: {:?}\", prev)\n@@ -635,7 +636,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let common_types = CommonTypes::new(&interners);\n         let dep_graph = map.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n-        tls::enter(GlobalCtxt {\n+        tls::enter_global(GlobalCtxt {\n             global_interners: interners,\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n@@ -690,11 +691,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n+    /// Call the closure with a local `TyCtxt` using the given arenas.\n+    pub fn enter_local<F, R>(&self, arenas: &'tcx CtxtArenas<'tcx>, f: F) -> R\n+        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        let interners = CtxtInterners::new(arenas);\n+        tls::enter(self, &interners, f)\n+    }\n+}\n+\n /// A trait implemented for all X<'a> types which can be safely and\n /// efficiently converted to X<'tcx> as long as they are part of the\n /// provided TyCtxt<'tcx>.\n /// This can be done, for example, for Ty<'tcx> or &'tcx Substs<'tcx>\n /// by looking them up in their respective interners.\n+///\n+/// However, this is still not the best implementation as it does\n+/// need to compare the components, even for interned values.\n+/// It would be more efficient if TypedArena provided a way to\n+/// determine whether the address is in the allocated range.\n+///\n /// None is returned if the value or one of the components is not part\n /// of the provided context.\n /// For Ty, None can be returned if either the type interner doesn't\n@@ -709,7 +726,7 @@ pub trait Lift<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n-        if let Some(&InternedTy { ty }) = tcx.interners.type_.borrow().get(&self.sty) {\n+        if let Some(&Interned(ty)) = tcx.interners.type_.borrow().get(&self.sty) {\n             if *self as *const _ == ty as *const _ {\n                 return Some(ty);\n             }\n@@ -726,7 +743,7 @@ impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n-        if let Some(&InternedSubsts { substs }) = tcx.interners.substs.borrow().get(*self) {\n+        if let Some(&Interned(substs)) = tcx.interners.substs.borrow().get(*self) {\n             if *self as *const _ == substs as *const _ {\n                 return Some(substs);\n             }\n@@ -743,7 +760,7 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n     type Lifted = &'tcx Region;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Region> {\n-        if let Some(&InternedRegion { region }) = tcx.interners.region.borrow().get(*self) {\n+        if let Some(&Interned(region)) = tcx.interners.region.borrow().get(*self) {\n             if *self as *const _ == region as *const _ {\n                 return Some(region);\n             }\n@@ -760,7 +777,7 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n impl<'a, 'tcx> Lift<'tcx> for &'a [Ty<'a>] {\n     type Lifted = &'tcx [Ty<'tcx>];\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx [Ty<'tcx>]> {\n-        if let Some(&InternedTyList { list }) = tcx.interners.type_list.borrow().get(*self) {\n+        if let Some(&Interned(list)) = tcx.interners.type_list.borrow().get(*self) {\n             if *self as *const _ == list as *const _ {\n                 return Some(list);\n             }\n@@ -774,21 +791,41 @@ impl<'a, 'tcx> Lift<'tcx> for &'a [Ty<'a>] {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a BareFnTy<'a> {\n+    type Lifted = &'tcx BareFnTy<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<&'tcx BareFnTy<'tcx>> {\n+        if let Some(&Interned(fty)) = tcx.interners.bare_fn.borrow().get(*self) {\n+            if *self as *const _ == fty as *const _ {\n+                return Some(fty);\n+            }\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n \n pub mod tls {\n-    use super::{GlobalCtxt, TyCtxt};\n+    use super::{CtxtInterners, GlobalCtxt, TyCtxt};\n \n     use std::cell::Cell;\n     use std::fmt;\n     use syntax::codemap;\n \n-    /// Marker type used for the scoped TLS slot.\n+    /// Marker types used for the scoped TLS slot.\n     /// The type context cannot be used directly because the scoped TLS\n     /// in libstd doesn't allow types generic over lifetimes.\n     enum ThreadLocalGlobalCtxt {}\n+    enum ThreadLocalInterners {}\n \n     thread_local! {\n-        static TLS_TCX: Cell<Option<*const ThreadLocalGlobalCtxt>> = Cell::new(None)\n+        static TLS_TCX: Cell<Option<(*const ThreadLocalGlobalCtxt,\n+                                     *const ThreadLocalInterners)>> = Cell::new(None)\n     }\n \n     fn span_debug(span: codemap::Span, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -797,42 +834,55 @@ pub mod tls {\n         })\n     }\n \n-    pub fn enter<'tcx, F, R>(gcx: GlobalCtxt<'tcx>, f: F) -> R\n-        where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>) -> R\n+    pub fn enter_global<'gcx, F, R>(gcx: GlobalCtxt<'gcx>, f: F) -> R\n+        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n     {\n         codemap::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n             span_dbg.set(span_debug);\n-            let tls_ptr = &gcx as *const _ as *const ThreadLocalGlobalCtxt;\n-            let result = TLS_TCX.with(|tls| {\n-                let prev = tls.get();\n-                tls.set(Some(tls_ptr));\n-                let ret = f(gcx.global_tcx());\n-                tls.set(prev);\n-                ret\n-            });\n+            let result = enter(&gcx, &gcx.global_interners, f);\n             span_dbg.set(original_span_debug);\n             result\n         })\n     }\n \n+    pub fn enter<'a, 'gcx: 'tcx, 'tcx, F, R>(gcx: &'a GlobalCtxt<'gcx>,\n+                                             interners: &'a CtxtInterners<'tcx>,\n+                                             f: F) -> R\n+        where F: FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        let gcx_ptr = gcx as *const _ as *const ThreadLocalGlobalCtxt;\n+        let interners_ptr = interners as *const _ as *const ThreadLocalInterners;\n+        TLS_TCX.with(|tls| {\n+            let prev = tls.get();\n+            tls.set(Some((gcx_ptr, interners_ptr)));\n+            let ret = f(TyCtxt {\n+                gcx: gcx,\n+                interners: interners\n+            });\n+            tls.set(prev);\n+            ret\n+        })\n+    }\n+\n     pub fn with<F, R>(f: F) -> R\n-        where F: for<'a, 'tcx> FnOnce(TyCtxt<'a, 'tcx, 'tcx>) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n-        TLS_TCX.with(|gcx| {\n-            let gcx = gcx.get().unwrap();\n+        TLS_TCX.with(|tcx| {\n+            let (gcx, interners) = tcx.get().unwrap();\n             let gcx = unsafe { &*(gcx as *const GlobalCtxt) };\n+            let interners = unsafe { &*(interners as *const CtxtInterners) };\n             f(TyCtxt {\n                 gcx: gcx,\n-                interners: &gcx.global_interners\n+                interners: interners\n             })\n         })\n     }\n \n     pub fn with_opt<F, R>(f: F) -> R\n-        where F: for<'a, 'tcx> FnOnce(Option<TyCtxt<'a, 'tcx, 'tcx>>) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'a, 'gcx, 'tcx>>) -> R\n     {\n-        if TLS_TCX.with(|gcx| gcx.get().is_some()) {\n+        if TLS_TCX.with(|tcx| tcx.get().is_some()) {\n             with(|v| f(Some(v)))\n         } else {\n             f(None)\n@@ -847,7 +897,7 @@ macro_rules! sty_debug_print {\n         #[allow(non_snake_case)]\n         mod inner {\n             use ty::{self, TyCtxt};\n-            use ty::context::InternedTy;\n+            use ty::context::Interned;\n \n             #[derive(Copy, Clone)]\n             struct DebugStat {\n@@ -865,7 +915,7 @@ macro_rules! sty_debug_print {\n                 $(let mut $variant = total;)*\n \n \n-                for &InternedTy { ty: t } in tcx.interners.type_.borrow().iter() {\n+                for &Interned(t) in tcx.interners.type_.borrow().iter() {\n                     let variant = match t.sty {\n                         ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n                             ty::TyFloat(..) | ty::TyStr => continue,\n@@ -920,100 +970,134 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n }\n \n \n-/// An entry in the type interner.\n-struct InternedTy<'tcx> {\n-    ty: Ty<'tcx>\n-}\n+/// An entry in an interner.\n+struct Interned<'tcx, T: 'tcx+?Sized>(&'tcx T);\n \n-// NB: An InternedTy compares and hashes as a sty.\n-impl<'tcx> PartialEq for InternedTy<'tcx> {\n-    fn eq(&self, other: &InternedTy<'tcx>) -> bool {\n-        self.ty.sty == other.ty.sty\n+// NB: An Interned<Ty> compares and hashes as a sty.\n+impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n+    fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n+        self.0.sty == other.0.sty\n     }\n }\n \n-impl<'tcx> Eq for InternedTy<'tcx> {}\n+impl<'tcx> Eq for Interned<'tcx, TyS<'tcx>> {}\n \n-impl<'tcx> Hash for InternedTy<'tcx> {\n+impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.ty.sty.hash(s)\n+        self.0.sty.hash(s)\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<TypeVariants<'lcx>> for InternedTy<'tcx> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<TypeVariants<'lcx>> for Interned<'tcx, TyS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a TypeVariants<'lcx> {\n-        &self.ty.sty\n+        &self.0.sty\n     }\n }\n \n-/// An entry in the type list interner.\n-#[derive(PartialEq, Eq, Hash)]\n-struct InternedTyList<'tcx> {\n-    list: &'tcx [Ty<'tcx>]\n-}\n-\n-impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for InternedTyList<'tcx> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, [Ty<'tcx>]> {\n     fn borrow<'a>(&'a self) -> &'a [Ty<'lcx>] {\n-        self.list\n+        self.0\n     }\n }\n \n-/// An entry in the substs interner.\n-#[derive(PartialEq, Eq, Hash)]\n-struct InternedSubsts<'tcx> {\n-    substs: &'tcx Substs<'tcx>\n-}\n-\n-impl<'tcx: 'lcx, 'lcx> Borrow<Substs<'lcx>> for InternedSubsts<'tcx> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<Substs<'lcx>> for Interned<'tcx, Substs<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a Substs<'lcx> {\n-        self.substs\n+        self.0\n     }\n }\n \n-/// An entry in the region interner.\n-#[derive(PartialEq, Eq, Hash)]\n-struct InternedRegion<'tcx> {\n-    region: &'tcx Region\n+impl<'tcx: 'lcx, 'lcx> Borrow<BareFnTy<'lcx>> for Interned<'tcx, BareFnTy<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a BareFnTy<'lcx> {\n+        self.0\n+    }\n }\n \n-impl<'tcx> Borrow<Region> for InternedRegion<'tcx> {\n+impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n     fn borrow<'a>(&'a self) -> &'a Region {\n-        self.region\n+        self.0\n     }\n }\n \n-fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n-    bounds.is_empty() ||\n-        bounds[1..].iter().enumerate().all(\n-            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn mk_type_list(self, list: Vec<Ty<'tcx>>) -> &'tcx [Ty<'tcx>] {\n-        if let Some(interned) = self.interners.type_list.borrow().get(&list[..]) {\n-            return interned.list;\n+macro_rules! items { ($($item:item)+) => ($($item)+) }\n+macro_rules! impl_interners {\n+    ($lt_tcx:tt, $($name:ident: $method:ident($alloc:ty, $needs_infer:expr)-> $ty:ty),+) => {\n+        items!($(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n         }\n \n-        let list = self.interners.arenas.type_list.alloc(list);\n-        self.interners.type_list.borrow_mut().insert(InternedTyList {\n-            list: list\n-        });\n-        list\n-    }\n+        impl<$lt_tcx> Eq for Interned<$lt_tcx, $ty> {}\n \n-    // Type constructors\n-    pub fn mk_substs(self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n-        if let Some(interned) = self.interners.substs.borrow().get(&substs) {\n-            return interned.substs;\n+        impl<$lt_tcx> Hash for Interned<$lt_tcx, $ty> {\n+            fn hash<H: Hasher>(&self, s: &mut H) {\n+                self.0.hash(s)\n+            }\n         }\n \n-        let substs = self.interners.arenas.substs.alloc(substs);\n-        self.interners.substs.borrow_mut().insert(InternedSubsts {\n-            substs: substs\n-        });\n-        substs\n+        impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n+            pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n+                if let Some(i) = self.interners.$name.borrow().get::<$ty>(&v) {\n+                    return i.0;\n+                }\n+                if !self.is_global() {\n+                    if let Some(i) = self.global_interners.$name.borrow().get::<$ty>(&v) {\n+                        return i.0;\n+                    }\n+                }\n+\n+                // HACK(eddyb) Depend on flags being accurate to\n+                // determine that all contents are in the global tcx.\n+                // See comments on Lift for why we can't use that.\n+                if !($needs_infer)(&v) {\n+                    if !self.is_global() {\n+                        let v = unsafe {\n+                            mem::transmute(v)\n+                        };\n+                        let i = self.global_interners.arenas.$name.alloc(v);\n+                        self.global_interners.$name.borrow_mut().insert(Interned(i));\n+                        return i;\n+                    }\n+                } else {\n+                    // Make sure we don't end up with inference\n+                    // types/regions in the global tcx.\n+                    if self.is_global() {\n+                        bug!(\"Attempted to intern `{:?}` which contains \\\n+                              inference types/regions in the global type context\",\n+                             v);\n+                    }\n+                }\n+\n+                let i = self.interners.arenas.$name.alloc(v);\n+                self.interners.$name.borrow_mut().insert(Interned(i));\n+                i\n+            }\n+        })+);\n     }\n+}\n+\n+fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n+    x.has_type_flags(ty::TypeFlags::KEEP_IN_LOCAL_TCX)\n+}\n \n+impl_interners!('tcx,\n+    type_list: mk_type_list(Vec<Ty<'tcx>>, keep_local) -> [Ty<'tcx>],\n+    substs: mk_substs(Substs<'tcx>, |substs: &Substs| {\n+        keep_local(&substs.types) || keep_local(&substs.regions)\n+    }) -> Substs<'tcx>,\n+    bare_fn: mk_bare_fn(BareFnTy<'tcx>, |fty: &BareFnTy| {\n+        keep_local(&fty.sig)\n+    }) -> BareFnTy<'tcx>,\n+    region: mk_region(Region, keep_local) -> Region\n+);\n+\n+fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n+    bounds.is_empty() ||\n+        bounds[1..].iter().enumerate().all(\n+            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n         assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n@@ -1024,32 +1108,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }))\n     }\n \n-    pub fn mk_bare_fn(self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n-        if let Some(bare_fn) = self.interners.bare_fn.borrow().get(&bare_fn) {\n-            return *bare_fn;\n-        }\n-\n-        let bare_fn = self.interners.arenas.bare_fn.alloc(bare_fn);\n-        self.interners.bare_fn.borrow_mut().insert(bare_fn);\n-        bare_fn\n-    }\n-\n-    pub fn mk_region(self, region: Region) -> &'tcx Region {\n-        if let Some(interned) = self.interners.region.borrow().get(&region) {\n-            return interned.region;\n-        }\n-\n-        let region = self.interners.arenas.region.alloc(region);\n-        self.interners.region.borrow_mut().insert(InternedRegion {\n-            region: region\n-        });\n-        region\n-    }\n-\n     // Interns a type/name combination, stores the resulting box in cx.interners,\n     // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n     pub fn mk_ty(self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n-        self.interners.intern_ty(st)\n+        let global_interners = if !self.is_global() {\n+            Some(&self.global_interners)\n+        } else {\n+            None\n+        };\n+        self.interners.intern_ty(st, global_interners)\n     }\n \n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {"}, {"sha": "a1da3017fcd043f9eff961ab05be01da47777f51", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -90,9 +90,15 @@ impl FlagComputation {\n                 self.add_tys(&substs.upvar_tys);\n             }\n \n-            &ty::TyInfer(_) => {\n+            &ty::TyInfer(infer) => {\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES); // it might, right?\n-                self.add_flags(TypeFlags::HAS_TY_INFER)\n+                self.add_flags(TypeFlags::HAS_TY_INFER);\n+                match infer {\n+                    ty::FreshTy(_) |\n+                    ty::FreshIntTy(_) |\n+                    ty::FreshFloatTy(_) => {}\n+                    _ => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n+                }\n             }\n \n             &ty::TyEnum(_, substs) | &ty::TyStruct(_, substs) => {\n@@ -171,7 +177,10 @@ impl FlagComputation {\n     fn add_region(&mut self, r: ty::Region) {\n         match r {\n             ty::ReVar(..) |\n-            ty::ReSkolemized(..) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n+            ty::ReSkolemized(..) => {\n+                self.add_flags(TypeFlags::HAS_RE_INFER);\n+                self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX);\n+            }\n             ty::ReLateBound(debruijn, _) => { self.add_depth(debruijn.depth); }\n             ty::ReEarlyBound(..) => { self.add_flags(TypeFlags::HAS_RE_EARLY_BOUND); }\n             ty::ReStatic => {}"}, {"sha": "82a3b0b8db28467c7d32097ec3ca66da4e0d64a2", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -466,7 +466,7 @@ pub struct Struct {\n     pub offset_after_field: Vec<Size>\n }\n \n-impl<'a, 'tcx> Struct {\n+impl<'a, 'gcx, 'tcx> Struct {\n     pub fn new(dl: &TargetDataLayout, packed: bool) -> Struct {\n         Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n@@ -479,9 +479,9 @@ impl<'a, 'tcx> Struct {\n     /// Extend the Struct with more fields.\n     pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n                      fields: I,\n-                     scapegoat: Ty<'tcx>)\n-                     -> Result<(), LayoutError<'tcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n+                     scapegoat: Ty<'gcx>)\n+                     -> Result<(), LayoutError<'gcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n         self.offset_after_field.reserve(fields.size_hint().0);\n \n         for field in fields {\n@@ -528,8 +528,8 @@ impl<'a, 'tcx> Struct {\n \n     /// Determine whether a structure would be zero-sized, given its fields.\n     pub fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n-                                  -> Result<bool, LayoutError<'tcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n+                                  -> Result<bool, LayoutError<'gcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n         for field in fields {\n             let field = field?;\n             if field.is_unsized() || field.size(dl).bytes() > 0 {\n@@ -542,10 +542,10 @@ impl<'a, 'tcx> Struct {\n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given type and recursing through aggregates.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n-    pub fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                  ty: Ty<'tcx>)\n-                                  -> Result<Option<FieldPath>, LayoutError<'tcx>> {\n-        let tcx = infcx.tcx;\n+    pub fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                  ty: Ty<'gcx>)\n+                                  -> Result<Option<FieldPath>, LayoutError<'gcx>> {\n+        let tcx = infcx.tcx.global_tcx();\n         match (ty.layout(infcx)?, &ty.sty) {\n             (&Scalar { non_zero: true, .. }, _) => Ok(Some(vec![])),\n             (&FatPointer { non_zero: true, .. }, _) => {\n@@ -600,10 +600,10 @@ impl<'a, 'tcx> Struct {\n \n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given set of fields and recursing through aggregates.\n-    pub fn non_zero_field_path<I>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+    pub fn non_zero_field_path<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                   fields: I)\n-                                  -> Result<Option<FieldPath>, LayoutError<'tcx>>\n-    where I: Iterator<Item=Ty<'tcx>> {\n+                                  -> Result<Option<FieldPath>, LayoutError<'gcx>>\n+    where I: Iterator<Item=Ty<'gcx>> {\n         for (i, ty) in fields.enumerate() {\n             if let Some(mut path) = Struct::non_zero_field_in_type(infcx, ty)? {\n                 path.push(i as u32);\n@@ -736,9 +736,9 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n }\n \n /// Helper function for normalizing associated types in an inference context.\n-fn normalize_associated_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n-                                       ty: Ty<'tcx>)\n-                                       -> Ty<'tcx> {\n+fn normalize_associated_type<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             ty: Ty<'gcx>)\n+                                             -> Ty<'gcx> {\n     if !ty.has_projection_types() {\n         return ty;\n     }\n@@ -757,11 +757,11 @@ fn normalize_associated_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n     infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n }\n \n-impl<'a, 'tcx> Layout {\n-    pub fn compute_uncached(ty: Ty<'tcx>,\n-                            infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n-                            -> Result<Layout, LayoutError<'tcx>> {\n-        let tcx = infcx.tcx;\n+impl<'a, 'gcx, 'tcx> Layout {\n+    pub fn compute_uncached(ty: Ty<'gcx>,\n+                            infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                            -> Result<Layout, LayoutError<'gcx>> {\n+        let tcx = infcx.tcx.global_tcx();\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n \n@@ -1220,10 +1220,10 @@ pub enum SizeSkeleton<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SizeSkeleton<'tcx> {\n-    pub fn compute(ty: Ty<'tcx>, infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n-                   -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n-        let tcx = infcx.tcx;\n+impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n+    pub fn compute(ty: Ty<'gcx>, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                   -> Result<SizeSkeleton<'gcx>, LayoutError<'gcx>> {\n+        let tcx = infcx.tcx.global_tcx();\n         assert!(!ty.has_infer_types());\n \n         // First try computing a static layout."}, {"sha": "005d83da38dbf87dd13f2a443742733bc0a8dd3a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -165,8 +165,8 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-impl<'a, 'tcx> ImplHeader<'tcx> {\n-    pub fn with_fresh_ty_vars(selcx: &mut traits::SelectionContext<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n+    pub fn with_fresh_ty_vars(selcx: &mut traits::SelectionContext<'a, 'gcx, 'tcx>,\n                               impl_def_id: DefId)\n                               -> ImplHeader<'tcx>\n     {\n@@ -524,6 +524,10 @@ bitflags! {\n         // that are local to a particular fn\n         const HAS_LOCAL_NAMES   = 1 << 9,\n \n+        // Present if the type belongs in a local type context.\n+        // Only set for TyInfer other than Fresh.\n+        const KEEP_IN_LOCAL_TCX = 1 << 10,\n+\n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits,\n@@ -540,7 +544,8 @@ bitflags! {\n                                   TypeFlags::HAS_TY_ERR.bits |\n                                   TypeFlags::HAS_PROJECTION.bits |\n                                   TypeFlags::HAS_TY_CLOSURE.bits |\n-                                  TypeFlags::HAS_LOCAL_NAMES.bits,\n+                                  TypeFlags::HAS_LOCAL_NAMES.bits |\n+                                  TypeFlags::KEEP_IN_LOCAL_TCX.bits,\n \n         // Caches for type_is_sized, type_moves_by_default\n         const SIZEDNESS_CACHED  = 1 << 16,\n@@ -2715,15 +2720,33 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {\n-        Tables::closure_kind(&self.tables, self.global_tcx(), def_id)\n+        // If this is a local def-id, it should be inserted into the\n+        // tables by typeck; else, it will be retreived from\n+        // the external crate metadata.\n+        if let Some(&kind) = self.tables.borrow().closure_kinds.get(&def_id) {\n+            return kind;\n+        }\n+\n+        let kind = self.sess.cstore.closure_kind(def_id);\n+        self.tables.borrow_mut().closure_kinds.insert(def_id, kind);\n+        kind\n     }\n \n     pub fn closure_type(self,\n                         def_id: DefId,\n-                        substs: ClosureSubsts<'gcx>)\n-                        -> ty::ClosureTy<'gcx>\n+                        substs: ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n     {\n-        Tables::closure_type(&self.tables, self.global_tcx(), def_id, substs)\n+        // If this is a local def-id, it should be inserted into the\n+        // tables by typeck; else, it will be retreived from\n+        // the external crate metadata.\n+        if let Some(ty) = self.tables.borrow().closure_tys.get(&def_id) {\n+            return ty.subst(self, substs.func_substs);\n+        }\n+\n+        let ty = self.sess.cstore.closure_ty(self.global_tcx(), def_id);\n+        self.tables.borrow_mut().closure_tys.insert(def_id, ty.clone());\n+        ty.subst(self, substs.func_substs)\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements."}, {"sha": "77e980ff3196520c05600cf42bcf5245c56c7e6e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -131,6 +131,41 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n+    type Lifted = ty::Predicate<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::Predicate::Trait(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::Trait)\n+            }\n+            ty::Predicate::Equate(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::Equate)\n+            }\n+            ty::Predicate::RegionOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::RegionOutlives)\n+            }\n+            ty::Predicate::TypeOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::TypeOutlives)\n+            }\n+            ty::Predicate::Projection(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::Projection)\n+            }\n+            ty::Predicate::WellFormed(ty) => {\n+                tcx.lift(&ty).map(ty::Predicate::WellFormed)\n+            }\n+            ty::Predicate::Rfc1592(box ref a) => {\n+                tcx.lift(a).map(|a| ty::Predicate::Rfc1592(Box::new(a)))\n+            }\n+            ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                Some(ty::Predicate::ClosureKind(closure_def_id, kind))\n+            }\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                Some(ty::Predicate::ObjectSafe(trait_def_id))\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {"}, {"sha": "08909861d3f68adcbd0af8574c13207bfdd1d097", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -134,9 +134,9 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                        self_type: Ty<'tcx>, span: Span)\n                                        -> Result<(),CopyImplementationError> {\n         // FIXME: (@jroesch) float this code up\n-        let adt = InferCtxt::enter(tcx, None, Some(self.clone()),\n-                                   ProjectionMode::Topmost, |infcx| {\n-            match self_type.sty {\n+        tcx.infer_ctxt(None, Some(self.clone()),\n+                       ProjectionMode::Topmost).enter(|infcx| {\n+            let adt = match self_type.sty {\n                 ty::TyStruct(struct_def, substs) => {\n                     for field in struct_def.all_fields() {\n                         let field_ty = field.ty(tcx, substs);\n@@ -145,7 +145,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                 field.name))\n                         }\n                     }\n-                    Ok(struct_def)\n+                    struct_def\n                 }\n                 ty::TyEnum(enum_def, substs) => {\n                     for variant in &enum_def.variants {\n@@ -157,17 +157,17 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                             }\n                         }\n                     }\n-                    Ok(enum_def)\n+                    enum_def\n                 }\n-                _ => Err(CopyImplementationError::NotAnAdt)\n-            }\n-        })?;\n+                _ => return Err(CopyImplementationError::NotAnAdt)\n+            };\n \n-        if adt.has_dtor() {\n-            return Err(CopyImplementationError::HasDestructor)\n-        }\n+            if adt.has_dtor() {\n+                return Err(CopyImplementationError::HasDestructor);\n+            }\n \n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n@@ -513,7 +513,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                    param_env: &ParameterEnvironment<'tcx>,\n                    bound: ty::BuiltinBound, span: Span) -> bool\n     {\n-        InferCtxt::enter(tcx, None, Some(param_env.clone()), ProjectionMode::Topmost, |infcx| {\n+        tcx.infer_ctxt(None, Some(param_env.clone()), ProjectionMode::Topmost).enter(|infcx| {\n             traits::type_known_to_meet_builtin_bound(&infcx, self, bound, span)\n         })\n     }\n@@ -596,19 +596,20 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn layout(&'tcx self, infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n-                  -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+    pub fn layout<'lcx>(&'tcx self, infcx: &InferCtxt<'a, 'tcx, 'lcx>)\n+                        -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+        let tcx = infcx.tcx.global_tcx();\n         let can_cache = !self.has_param_types() && !self.has_self_ty();\n         if can_cache {\n-            if let Some(&cached) = infcx.tcx.layout_cache.borrow().get(&self) {\n+            if let Some(&cached) = tcx.layout_cache.borrow().get(&self) {\n                 return Ok(cached);\n             }\n         }\n \n         let layout = Layout::compute_uncached(self, infcx)?;\n-        let layout = infcx.tcx.intern_layout(layout);\n+        let layout = tcx.intern_layout(layout);\n         if can_cache {\n-            infcx.tcx.layout_cache.borrow_mut().insert(self, layout);\n+            tcx.layout_cache.borrow_mut().insert(self, layout);\n         }\n         Ok(layout)\n     }"}, {"sha": "1a802064b61270d253ae8c9a669e1ba856deb2cf", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -69,12 +69,12 @@ pub enum Ns {\n     Value\n }\n \n-fn number_of_supplied_defaults<'a, 'tcx, GG>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                             substs: &subst::Substs,\n-                                             space: subst::ParamSpace,\n-                                             get_generics: GG)\n-                                             -> usize\n-    where GG: FnOnce(TyCtxt<'a, 'tcx, 'tcx>) -> ty::Generics<'tcx>\n+fn number_of_supplied_defaults<'a, 'gcx, 'tcx, GG>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                   substs: &subst::Substs,\n+                                                   space: subst::ParamSpace,\n+                                                   get_generics: GG)\n+                                                   -> usize\n+    where GG: FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> ty::Generics<'tcx>\n {\n     let generics = get_generics(tcx);\n \n@@ -115,7 +115,7 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n                          projections: &[ty::ProjectionPredicate],\n                          get_generics: GG)\n                          -> fmt::Result\n-    where GG: for<'a, 'tcx> FnOnce(TyCtxt<'a, 'tcx, 'tcx>) -> ty::Generics<'tcx>\n+    where GG: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> ty::Generics<'tcx>\n {\n     if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n         write!(f, \"<{} as \", self_ty)?;\n@@ -231,10 +231,10 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     Ok(())\n }\n \n-fn in_binder<'a, 'tcx, T, U>(f: &mut fmt::Formatter,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             original: &ty::Binder<T>,\n-                             lifted: Option<ty::Binder<U>>) -> fmt::Result\n+fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n+                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                   original: &ty::Binder<T>,\n+                                   lifted: Option<ty::Binder<U>>) -> fmt::Result\n     where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>\n {\n     // Replace any anonymous late-bound regions with named"}, {"sha": "bf5bce8fc3ba3b16b7c7f500dd09372393aca263", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -22,12 +22,10 @@ use borrowck::*;\n use borrowck::InteriorKind::{InteriorElement, InteriorField};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n-use rustc::infer::InferCtxt;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n-use rustc::traits::ProjectionMode;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc::hir;\n@@ -203,17 +201,15 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    InferCtxt::enter(bccx.tcx, None, Some(param_env), ProjectionMode::AnyFinal, |infcx| {\n-        let mut clcx = CheckLoanCtxt {\n-            bccx: bccx,\n-            dfcx_loans: dfcx_loans,\n-            move_data: move_data,\n-            all_loans: all_loans,\n-            param_env: &infcx.parameter_environment\n-        };\n-        let mut euv = euv::ExprUseVisitor::new(&mut clcx, &infcx);\n-        euv.walk_fn(decl, body);\n-    });\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+    let mut clcx = CheckLoanCtxt {\n+        bccx: bccx,\n+        dfcx_loans: dfcx_loans,\n+        move_data: move_data,\n+        all_loans: all_loans,\n+        param_env: &infcx.parameter_environment\n+    };\n+    euv::ExprUseVisitor::new(&mut clcx, &infcx).walk_fn(decl, body);\n }\n \n #[derive(PartialEq)]"}, {"sha": "7d4f02bfe1109cdb9bd1a9dc4717d813b742bc57", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -19,12 +19,10 @@\n use borrowck::*;\n use borrowck::move_data::MoveData;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::infer::InferCtxt;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n-use rustc::traits::ProjectionMode;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -56,10 +54,8 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    InferCtxt::enter(bccx.tcx, None, Some(param_env), ProjectionMode::AnyFinal, |infcx| {\n-        let mut euv = euv::ExprUseVisitor::new(&mut glcx, &infcx);\n-        euv.walk_fn(decl, body);\n-    });\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+    euv::ExprUseVisitor::new(&mut glcx, &infcx).walk_fn(decl, body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n@@ -520,21 +516,22 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n /// sure the loans being taken are sound.\n struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    item_id: ast::NodeId\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let err = InferCtxt::enter(self.bccx.tcx, None, None,\n-                                       ProjectionMode::AnyFinal, |infcx| {\n-                let mc = mc::MemCategorizationContext::new(&infcx);\n-                let base_cmt = mc.cat_expr(&base).unwrap();\n-                let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n-                // Check that we don't allow borrows of unsafe static items.\n-                check_aliasability(self.bccx, ex.span,\n-                                   BorrowViolation(euv::AddrOf),\n-                                   base_cmt, borrow_kind).is_err()\n-            });\n+            let param_env = ty::ParameterEnvironment::for_item(self.bccx.tcx,\n+                                                               self.item_id);\n+            let infcx = self.bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+            let mc = mc::MemCategorizationContext::new(&infcx);\n+            let base_cmt = mc.cat_expr(&base).unwrap();\n+            let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n+            // Check that we don't allow borrows of unsafe static items.\n+            let err = check_aliasability(self.bccx, ex.span,\n+                                         BorrowViolation(euv::AddrOf),\n+                                         base_cmt, borrow_kind).is_err();\n             if err {\n                 return; // reported an error, no sense in reporting more.\n             }\n@@ -544,12 +541,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &hir::Expr) {\n+pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt,\n+                                          item_id: ast::NodeId,\n+                                          expr: &hir::Expr) {\n \n     debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n \n     let mut sicx = StaticInitializerCtxt {\n-        bccx: bccx\n+        bccx: bccx,\n+        item_id: item_id\n     };\n \n     sicx.visit_expr(expr);"}, {"sha": "f0ea69c8a6b3d32733f15015136ba9aeb8bf6bfe", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -87,14 +87,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n-            gather_loans::gather_loans_in_static_initializer(self, &expr);\n+            gather_loans::gather_loans_in_static_initializer(self, ti.id, &expr);\n         }\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n-            gather_loans::gather_loans_in_static_initializer(self, &expr);\n+            gather_loans::gather_loans_in_static_initializer(self, ii.id, &expr);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -142,7 +142,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &hir::Item) {\n     match item.node {\n         hir::ItemStatic(_, _, ref ex) |\n         hir::ItemConst(_, ref ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, &ex);\n+            gather_loans::gather_loans_in_static_initializer(this, item.id, &ex);\n         }\n         _ => { }\n     }"}, {"sha": "61d2408d5bfbb00eca6fc49200884535eed2b3ba", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -22,7 +22,6 @@ use rustc::hir::def_id::{DefId};\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::infer::InferCtxt;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::hir::pat_util::*;\n use rustc::traits::ProjectionMode;\n@@ -1123,8 +1122,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     PatKind::Ident(hir::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);\n                         //FIXME: (@jroesch) this code should be floated up as well\n-                        InferCtxt::enter(cx.tcx, None, Some(cx.param_env.clone()),\n-                                         ProjectionMode::AnyFinal, |infcx| {\n+                        cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n+                                          ProjectionMode::AnyFinal).enter(|infcx| {\n                             if infcx.type_moves_by_default(pat_ty, pat.span) {\n                                 check_move(p, sub.as_ref().map(|p| &**p));\n                             }\n@@ -1150,8 +1149,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n /// assign.\n fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n                                          guard: &hir::Expr) {\n-    InferCtxt::enter(cx.tcx, None, Some(cx.param_env.clone()),\n-                     ProjectionMode::AnyFinal, |infcx| {\n+    cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n+                      ProjectionMode::AnyFinal).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };\n@@ -1160,11 +1159,11 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n     });\n }\n \n-struct MutationChecker<'a, 'tcx: 'a> {\n-    cx: &'a MatchCheckCtxt<'a, 'tcx>,\n+struct MutationChecker<'a, 'gcx: 'a> {\n+    cx: &'a MatchCheckCtxt<'a, 'gcx>,\n }\n \n-impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n     fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}"}, {"sha": "9db24fa4770fe6f1a176c640fe2def881cf99b3e", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -19,7 +19,6 @@ use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::cstore::{self, InlinedItem};\n use rustc::traits;\n-use rustc::infer::InferCtxt;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n@@ -1014,7 +1013,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+    tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                                  trait_ref.to_poly_trait_predicate());"}, {"sha": "9bbf250b9714eda7d2c34b803a86598aa76e171f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -42,8 +42,8 @@ use syntax::feature_gate::UnstableFeatures;\n \n use rustc::hir;\n \n-struct Env<'a, 'tcx: 'a> {\n-    infcx: &'a infer::InferCtxt<'a, 'tcx, 'tcx>,\n+struct Env<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n struct RH<'a> {\n@@ -149,7 +149,7 @@ fn test_env<F>(source_string: &str,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n-        InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+        tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n \n             body(Env { infcx: &infcx });\n             let free_regions = FreeRegionMap::new();\n@@ -159,8 +159,8 @@ fn test_env<F>(source_string: &str,\n     });\n }\n \n-impl<'a, 'tcx> Env<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "d1eba5b3f4a4cd349b0ef61c2fa61fe19013d69a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -32,7 +32,6 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use middle::stability;\n use rustc::cfg;\n-use rustc::infer::InferCtxt;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment;\n@@ -866,7 +865,7 @@ impl LateLintPass for UnconditionalRecursion {\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n                     let param_env = Some(ty::ParameterEnvironment::for_item(tcx, node_id));\n-                    InferCtxt::enter(tcx, None, param_env, ProjectionMode::AnyFinal, |infcx| {\n+                    tcx.infer_ctxt(None, param_env, ProjectionMode::AnyFinal).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound."}, {"sha": "c1626b93f0c4181f1f9c18d4729fd04a2c9e01c6", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -13,7 +13,7 @@ use hair::*;\n use rustc::mir::repr::*;\n use rustc::hir;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n                      destination: &Lvalue<'tcx>,\n                      // FIXME(#32959): temporary measure for the issue"}, {"sha": "a08d14d9e20564b3f9bab9465afb022385d79a50", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -14,7 +14,7 @@ use build::Builder;\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n     pub fn as_constant<M>(&mut self, expr: M) -> Constant<'tcx>"}, {"sha": "15ea3f0e6e8675ce065c509277ce58cb01cdb398", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -15,7 +15,7 @@ use build::expr::category::Category;\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding an lvalue that we can move from etc.\n     pub fn as_lvalue<M>(&mut self,\n                         block: BasicBlock,"}, {"sha": "a059f2bdde9c733608dd56dd708feea84e8775fd", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -15,7 +15,7 @@ use build::expr::category::Category;\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr` into a value that can be used as an operand.\n     /// If `expr` is an lvalue like `x`, this will introduce a\n     /// temporary `tmp = x`, so that we capture the value of `x` at"}, {"sha": "2a73346240898fc89282223fb801d7edbb94c158", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -17,7 +17,7 @@ use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding an rvalue.\n     pub fn as_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>"}, {"sha": "38d32ec6777e08d62ede1e7b5d7133239441eae6", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -15,7 +15,7 @@ use build::expr::category::Category;\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n     pub fn as_temp<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Lvalue<'tcx>>"}, {"sha": "41610c90377b52af4119c22ffae705d7e4b3d164", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -16,7 +16,7 @@ use hair::*;\n use rustc::ty;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n     pub fn into_expr(&mut self,"}, {"sha": "9629396f48b50f1274b364e7021ade9a835d20af", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::region::CodeExtent;\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn stmt_expr(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<()> {\n         let this = self;"}, {"sha": "17ccb701c2b7a2acbdf392917d656cd08c9cad27", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -19,14 +19,14 @@ use hair::*;\n use rustc::mir::repr::*;\n \n pub trait EvalInto<'tcx> {\n-    fn eval_into<'a>(self,\n-                     builder: &mut Builder<'a, 'tcx>,\n-                     destination: &Lvalue<'tcx>,\n-                     block: BasicBlock)\n-                     -> BlockAnd<()>;\n+    fn eval_into<'a, 'gcx>(self,\n+                           builder: &mut Builder<'a, 'gcx, 'tcx>,\n+                           destination: &Lvalue<'tcx>,\n+                           block: BasicBlock)\n+                           -> BlockAnd<()>;\n }\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn into<E>(&mut self,\n                    destination: &Lvalue<'tcx>,\n                    block: BasicBlock,\n@@ -39,22 +39,22 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n }\n \n impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n-    fn eval_into<'a>(self,\n-                     builder: &mut Builder<'a, 'tcx>,\n-                     destination: &Lvalue<'tcx>,\n-                     block: BasicBlock)\n-                     -> BlockAnd<()> {\n+    fn eval_into<'a, 'gcx>(self,\n+                           builder: &mut Builder<'a, 'gcx, 'tcx>,\n+                           destination: &Lvalue<'tcx>,\n+                           block: BasicBlock)\n+                           -> BlockAnd<()> {\n         let expr = builder.hir.mirror(self);\n         builder.into_expr(destination, block, expr)\n     }\n }\n \n impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n-    fn eval_into<'a>(self,\n-                     builder: &mut Builder<'a, 'tcx>,\n-                     destination: &Lvalue<'tcx>,\n-                     block: BasicBlock)\n-                     -> BlockAnd<()> {\n+    fn eval_into<'a, 'gcx>(self,\n+                           builder: &mut Builder<'a, 'gcx, 'tcx>,\n+                           destination: &Lvalue<'tcx>,\n+                           block: BasicBlock)\n+                           -> BlockAnd<()> {\n         builder.into_expr(destination, block, self)\n     }\n }"}, {"sha": "c1a0e1f9a6900b622122e2b153cce60180a30eed", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -27,7 +27,7 @@ mod simplify;\n mod test;\n mod util;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn match_expr(&mut self,\n                       destination: &Lvalue<'tcx>,\n                       span: Span,\n@@ -304,7 +304,7 @@ pub struct Test<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Main matching algorithm\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// The main match algorithm. It begins with a set of candidates\n     /// `candidates` and has the job of generating code to determine\n     /// which of these candidates, if any, is the correct one. The"}, {"sha": "c707bb8a27b6f53983e7eececd0c78bfc93cbf0d", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -29,7 +29,7 @@ use rustc::mir::repr::*;\n \n use std::mem;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn simplify_candidate<'pat>(&mut self,\n                                     mut block: BasicBlock,\n                                     candidate: &mut Candidate<'pat, 'tcx>)"}, {"sha": "e53584a3f8b11ee42b733572caaa30f1b1da8631", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n     /// It is a bug to call this with a simplifyable pattern."}, {"sha": "5eb58f7612d744c5b9e38943bd5d1020190751a2", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -14,7 +14,7 @@ use hair::*;\n use rustc::mir::repr::*;\n use std::u32;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn field_match_pairs<'pat>(&mut self,\n                                    lvalue: Lvalue<'tcx>,\n                                    subpatterns: &'pat [FieldPattern<'tcx>])"}, {"sha": "7317c6f9b31336149a0a54acb83206a4a59653d1", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::repr::*;\n use std::u32;\n use syntax::codemap::Span;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Add a new temporary value of type `ty` storing the result of\n     /// evaluating `expr`.\n     ///"}, {"sha": "77499a0f96cde47efb3c87f3b047db16efea6b75", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -21,8 +21,8 @@ use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n \n-pub struct Builder<'a, 'tcx: 'a> {\n-    hir: Cx<'a, 'tcx, 'tcx>,\n+pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    hir: Cx<'a, 'gcx, 'tcx>,\n     cfg: CFG<'tcx>,\n \n     fn_span: Span,\n@@ -160,13 +160,13 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a, 'tcx, 'tcx>,\n-                                 fn_id: ast::NodeId,\n-                                 arguments: A,\n-                                 return_ty: ty::FnOutput<'tcx>,\n-                                 ast_block: &'tcx hir::Block)\n-                                 -> (Mir<'tcx>, ScopeAuxiliaryVec)\n-    where A: Iterator<Item=(Ty<'tcx>, Option<&'tcx hir::Pat>)>\n+pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n+                                       fn_id: ast::NodeId,\n+                                       arguments: A,\n+                                       return_ty: ty::FnOutput<'gcx>,\n+                                       ast_block: &'gcx hir::Block)\n+                                       -> (Mir<'tcx>, ScopeAuxiliaryVec)\n+    where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n     let tcx = hir.tcx();\n     let span = tcx.map.span(fn_id);\n@@ -232,10 +232,10 @@ pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a, 'tcx, 'tcx>,\n     builder.finish(upvar_decls, arg_decls, return_ty)\n }\n \n-pub fn construct_const<'a, 'tcx>(hir: Cx<'a, 'tcx, 'tcx>,\n-                                 item_id: ast::NodeId,\n-                                 ast_expr: &'tcx hir::Expr)\n-                                 -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n+                                       item_id: ast::NodeId,\n+                                       ast_expr: &'tcx hir::Expr)\n+                                       -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n     let tcx = hir.tcx();\n     let span = tcx.map.span(item_id);\n     let mut builder = Builder::new(hir, span);\n@@ -259,8 +259,8 @@ pub fn construct_const<'a, 'tcx>(hir: Cx<'a, 'tcx, 'tcx>,\n     builder.finish(vec![], vec![], ty::FnConverging(ty))\n }\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n-    fn new(hir: Cx<'a, 'tcx, 'tcx>, span: Span) -> Builder<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    fn new(hir: Cx<'a, 'gcx, 'tcx>, span: Span) -> Builder<'a, 'gcx, 'tcx> {\n         let mut builder = Builder {\n             hir: hir,\n             cfg: CFG { basic_blocks: vec![] },\n@@ -311,9 +311,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         return_ty: ty::FnOutput<'tcx>,\n                         arguments: A,\n                         argument_scope_id: ScopeId,\n-                        ast_block: &'tcx hir::Block)\n+                        ast_block: &'gcx hir::Block)\n                         -> BlockAnd<Vec<ArgDecl<'tcx>>>\n-        where A: Iterator<Item=(Ty<'tcx>, Option<&'tcx hir::Pat>)>\n+        where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n     {\n         // to start, translate the argument patterns and collect the argument types.\n         let arg_decls = arguments.enumerate().map(|(index, (ty, pattern))| {"}, {"sha": "071c8d618c845faaccd32bf643ab5da874ac3285", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -206,7 +206,7 @@ impl<'tcx> Scope<'tcx> {\n     }\n }\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Adding and removing scopes\n     // ==========================\n     /// Start a loop scope, which tracks where `continue` and `break`\n@@ -218,7 +218,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                break_block: BasicBlock,\n                                f: F)\n                                -> bool\n-        where F: FnOnce(&mut Builder<'a, 'tcx>)\n+        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>)\n     {\n         let extent = self.extent_of_innermost_scope();\n         let loop_scope = LoopScope {\n@@ -237,7 +237,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<'a, 'tcx>, ScopeId) -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>, ScopeId) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n         let id = self.push_scope(extent, block);\n@@ -662,12 +662,12 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n     block.unit()\n }\n \n-fn build_diverge_scope<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 cfg: &mut CFG<'tcx>,\n-                                 unit_temp: &Lvalue<'tcx>,\n-                                 scope: &mut Scope<'tcx>,\n-                                 mut target: BasicBlock)\n-                                 -> BasicBlock\n+fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       cfg: &mut CFG<'tcx>,\n+                                       unit_temp: &Lvalue<'tcx>,\n+                                       scope: &mut Scope<'tcx>,\n+                                       mut target: BasicBlock)\n+                                       -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n     // look like:\n@@ -721,11 +721,11 @@ fn build_diverge_scope<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     target\n }\n \n-fn build_free<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        unit_temp: &Lvalue<'tcx>,\n-                        data: &FreeData<'tcx>,\n-                        target: BasicBlock)\n-                        -> TerminatorKind<'tcx> {\n+fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                              unit_temp: &Lvalue<'tcx>,\n+                              data: &FreeData<'tcx>,\n+                              target: BasicBlock)\n+                              -> TerminatorKind<'tcx> {\n     let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n                        .unwrap_or_else(|e| tcx.sess.fatal(&e));\n     let substs = tcx.mk_substs(Substs::new("}, {"sha": "52d54f2cc85724db2203964e0dfa6800115c320f", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -18,7 +18,7 @@ use syntax::ast;\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx, 'tcx>) -> Block<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Block<'tcx> {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n@@ -31,10 +31,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     }\n }\n \n-fn mirror_stmts<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                          block_id: ast::NodeId,\n-                          stmts: &'tcx [hir::Stmt])\n-                          -> Vec<StmtRef<'tcx>>\n+fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                block_id: ast::NodeId,\n+                                stmts: &'tcx [hir::Stmt])\n+                                -> Vec<StmtRef<'tcx>>\n {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n@@ -74,9 +74,9 @@ fn mirror_stmts<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n     return result;\n }\n \n-pub fn to_expr_ref<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                             block: &'tcx hir::Block)\n-                             -> ExprRef<'tcx> {\n+pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                   block: &'tcx hir::Block)\n+                                   -> ExprRef<'tcx> {\n     let block_ty = cx.tcx.node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {"}, {"sha": "1e7164a62c070d8ea2020ea2b9a4fbd8b17947e5", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -29,7 +29,7 @@ use syntax::ptr::P;\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n         let temp_lifetime = cx.tcx.region_maps.temporary_scope(self.id);\n         let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n \n@@ -202,9 +202,9 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     }\n }\n \n-fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                                    expr: &'tcx hir::Expr)\n-                                    -> Expr<'tcx> {\n+fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                          expr: &'tcx hir::Expr)\n+                                          -> Expr<'tcx> {\n     let expr_ty = cx.tcx.expr_ty(expr);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n@@ -545,7 +545,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n             count: TypedConstVal {\n                 ty: cx.tcx.expr_ty(c),\n                 span: c.span,\n-                value: match const_eval::eval_const_expr(cx.tcx, c) {\n+                value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n                     ConstVal::Integral(ConstInt::Usize(u)) => u,\n                     other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 },\n@@ -622,10 +622,10 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn method_callee<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                           expr: &hir::Expr,\n-                           method_call: ty::MethodCall)\n-                           -> Expr<'tcx> {\n+fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                 expr: &hir::Expr,\n+                                 method_call: ty::MethodCall)\n+                                 -> Expr<'tcx> {\n     let tables = cx.tcx.tables.borrow();\n     let callee = &tables.method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n@@ -649,8 +649,8 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                         arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                               arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     let mut map;\n     let opt_map = if arm.pats.len() == 1 {\n         None\n@@ -669,9 +669,9 @@ fn convert_arm<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn convert_path_expr<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                               expr: &'tcx hir::Expr)\n-                               -> ExprKind<'tcx> {\n+fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                     expr: &'tcx hir::Expr)\n+                                     -> ExprKind<'tcx> {\n     let substs = cx.tcx.node_id_item_substs(expr.id).substs;\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n@@ -714,7 +714,8 @@ fn convert_path_expr<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => {\n             let substs = Some(cx.tcx.node_id_item_substs(expr.id).substs);\n-            if let Some((e, _)) = const_eval::lookup_const_by_id(cx.tcx, def_id, substs) {\n+            let tcx = cx.tcx.global_tcx();\n+            if let Some((e, _)) = const_eval::lookup_const_by_id(tcx, def_id, substs) {\n                 // FIXME ConstVal can't be yet used with adjustments, as they would be lost.\n                 if !cx.tcx.tables.borrow().adjustments.contains_key(&e.id) {\n                     if let Some(v) = cx.try_const_eval_literal(e) {\n@@ -743,10 +744,10 @@ fn convert_path_expr<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn convert_var<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                         expr: &'tcx hir::Expr,\n-                         def: Def)\n-                         -> ExprKind<'tcx> {\n+fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                               expr: &'tcx hir::Expr,\n+                               def: Def)\n+                               -> ExprKind<'tcx> {\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     match def {\n@@ -908,13 +909,13 @@ enum PassArgs {\n     ByRef,\n }\n \n-fn overloaded_operator<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                                 expr: &'tcx hir::Expr,\n-                                 method_call: ty::MethodCall,\n-                                 pass_args: PassArgs,\n-                                 receiver: ExprRef<'tcx>,\n-                                 args: Vec<&'tcx P<hir::Expr>>)\n-                                 -> ExprKind<'tcx> {\n+fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                       expr: &'tcx hir::Expr,\n+                                       method_call: ty::MethodCall,\n+                                       pass_args: PassArgs,\n+                                       receiver: ExprRef<'tcx>,\n+                                       args: Vec<&'tcx P<hir::Expr>>)\n+                                       -> ExprKind<'tcx> {\n     // the receiver has all the adjustments that are needed, so we can\n     // just push a reference to it\n     let mut argrefs = vec![receiver];\n@@ -959,13 +960,13 @@ fn overloaded_operator<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn overloaded_lvalue<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                               expr: &'tcx hir::Expr,\n-                               method_call: ty::MethodCall,\n-                               pass_args: PassArgs,\n-                               receiver: ExprRef<'tcx>,\n-                               args: Vec<&'tcx P<hir::Expr>>)\n-                               -> ExprKind<'tcx> {\n+fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                     expr: &'tcx hir::Expr,\n+                                     method_call: ty::MethodCall,\n+                                     pass_args: PassArgs,\n+                                     receiver: ExprRef<'tcx>,\n+                                     args: Vec<&'tcx P<hir::Expr>>)\n+                                     -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n@@ -994,11 +995,11 @@ fn overloaded_lvalue<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n     ExprKind::Deref { arg: ref_expr.to_ref() }\n }\n \n-fn capture_freevar<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                             closure_expr: &'tcx hir::Expr,\n-                             freevar: &hir::Freevar,\n-                             freevar_ty: Ty<'tcx>)\n-                             -> ExprRef<'tcx> {\n+fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                   closure_expr: &'tcx hir::Expr,\n+                                   freevar: &hir::Freevar,\n+                                   freevar_ty: Ty<'tcx>)\n+                                   -> ExprRef<'tcx> {\n     let id_var = freevar.def.var_id();\n     let upvar_id = ty::UpvarId {\n         var_id: id_var,\n@@ -1035,8 +1036,8 @@ fn capture_freevar<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn loop_label<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n-                        expr: &'tcx hir::Expr) -> CodeExtent {\n+fn loop_label<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                              expr: &'tcx hir::Expr) -> CodeExtent {\n     match cx.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n         Some(Def::Label(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n         d => {"}, {"sha": "fad6cfb7ae1aab784d84ebf4f603deddf5d674b2", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -35,10 +35,10 @@ pub struct Cx<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     constness: hir::Constness\n }\n \n-impl<'a, 'tcx> Cx<'a, 'tcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n+impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                constness: hir::Constness)\n-               -> Cx<'a, 'tcx, 'tcx> {\n+               -> Cx<'a, 'gcx, 'tcx> {\n         Cx {\n             tcx: infcx.tcx,\n             infcx: infcx,\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx: 'a> Cx<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     /// Normalizes `ast` into the appropriate `mirror` type.\n     pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n         ast.make_mirror(self)\n@@ -85,12 +85,15 @@ impl<'a, 'tcx: 'a> Cx<'a, 'tcx, 'tcx> {\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n-        Literal::Value { value: const_eval::eval_const_expr(self.tcx, e) }\n+        Literal::Value {\n+            value: const_eval::eval_const_expr(self.tcx.global_tcx(), e)\n+        }\n     }\n \n     pub fn try_const_eval_literal(&mut self, e: &hir::Expr) -> Option<Literal<'tcx>> {\n         let hint = const_eval::EvalHint::ExprTypeChecked;\n-        const_eval::eval_const_expr_partial(self.tcx, e, hint, None).ok().and_then(|v| {\n+        let tcx = self.tcx.global_tcx();\n+        const_eval::eval_const_expr_partial(tcx, e, hint, None).ok().and_then(|v| {\n             match v {\n                 // All of these contain local IDs, unsuitable for storing in MIR.\n                 ConstVal::Struct(_) | ConstVal::Tuple(_) |\n@@ -130,21 +133,25 @@ impl<'a, 'tcx: 'a> Cx<'a, 'tcx, 'tcx> {\n         bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n     }\n \n-    pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n+    pub fn num_variants(&mut self, adt_def: ty::AdtDef) -> usize {\n         adt_def.variants.len()\n     }\n \n-    pub fn all_fields(&mut self, adt_def: ty::AdtDef<'tcx>, variant_index: usize) -> Vec<Field> {\n+    pub fn all_fields(&mut self, adt_def: ty::AdtDef, variant_index: usize) -> Vec<Field> {\n         (0..adt_def.variants[variant_index].fields.len())\n             .map(Field::new)\n             .collect()\n     }\n \n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n+        let ty = self.tcx.lift_to_global(&ty).unwrap_or_else(|| {\n+            bug!(\"MIR: Cx::needs_drop({}) got \\\n+                  type with inference types/regions\", ty);\n+        });\n         self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n }"}, {"sha": "9e08e7b62d3bf9e6fe9baefea30aa2ef72375c5f", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -34,12 +34,12 @@ use syntax::ptr::P;\n ///    _ => { ... }\n /// }\n /// ```\n-struct PatCx<'patcx, 'cx: 'patcx, 'tcx: 'cx> {\n-    cx: &'patcx mut Cx<'cx, 'tcx, 'tcx>,\n+struct PatCx<'patcx, 'cx: 'patcx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+    cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n     binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>,\n }\n \n-impl<'cx, 'tcx> Cx<'cx, 'tcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> Cx<'cx, 'gcx, 'tcx> {\n     pub fn irrefutable_pat(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n         PatCx::new(self, None).to_pattern(pat)\n     }\n@@ -52,10 +52,10 @@ impl<'cx, 'tcx> Cx<'cx, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n-    fn new(cx: &'patcx mut Cx<'cx, 'tcx, 'tcx>,\n+impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n+    fn new(cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n                binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>)\n-               -> PatCx<'patcx, 'cx, 'tcx> {\n+               -> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n         PatCx {\n             cx: cx,\n             binding_map: binding_map,\n@@ -69,14 +69,14 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             PatKind::Wild => PatternKind::Wild,\n \n             PatKind::Lit(ref value) => {\n-                let value = const_eval::eval_const_expr(self.cx.tcx, value);\n+                let value = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), value);\n                 PatternKind::Constant { value: value }\n             }\n \n             PatKind::Range(ref lo, ref hi) => {\n-                let lo = const_eval::eval_const_expr(self.cx.tcx, lo);\n+                let lo = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), lo);\n                 let lo = Literal::Value { value: lo };\n-                let hi = const_eval::eval_const_expr(self.cx.tcx, hi);\n+                let hi = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), hi);\n                 let hi = Literal::Value { value: hi };\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n@@ -87,10 +87,11 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match def {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                        let tcx = self.cx.tcx.global_tcx();\n                         let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n-                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id, substs) {\n+                        match const_eval::lookup_const_by_id(tcx, def_id, substs) {\n                             Some((const_expr, _const_ty)) => {\n-                                match const_eval::const_expr_to_pat(self.cx.tcx,\n+                                match const_eval::const_expr_to_pat(tcx,\n                                                                     const_expr,\n                                                                     pat.id,\n                                                                     pat.span) {"}, {"sha": "020fbb6fcd19c66bb0aae0105a90fbfddb7c12fe", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -358,21 +358,21 @@ pub struct FieldPattern<'tcx> {\n pub trait Mirror<'tcx> {\n     type Output;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx, 'tcx>) -> Self::Output;\n+    fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Self::Output;\n }\n \n impl<'tcx> Mirror<'tcx> for Expr<'tcx> {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, _: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n         self\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, hir: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n         match self {\n             ExprRef::Hair(h) => h.make_mirror(hir),\n             ExprRef::Mirror(m) => *m,\n@@ -383,15 +383,15 @@ impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n impl<'tcx> Mirror<'tcx> for Stmt<'tcx> {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx, 'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, _: &mut Cx<'a, 'gcx, 'tcx>) -> Stmt<'tcx> {\n         self\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx, 'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, _: &mut Cx<'a, 'gcx, 'tcx>) -> Stmt<'tcx> {\n         match self {\n             StmtRef::Mirror(m) => *m,\n         }\n@@ -401,7 +401,7 @@ impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n impl<'tcx> Mirror<'tcx> for Block<'tcx> {\n     type Output = Block<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx, 'tcx>) -> Block<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, _: &mut Cx<'a, 'gcx, 'tcx>) -> Block<'tcx> {\n         self\n     }\n }"}, {"sha": "73cfdeda74a885ab14e4f9a89af6789acc50d350", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 96, "deletions": 29, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -20,20 +20,24 @@ use build;\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n use rustc::mir::transform::MirSource;\n+use rustc::mir::visit::MutVisitor;\n use pretty;\n use hair::cx::Cx;\n \n use rustc::mir::mir_map::MirMap;\n-use rustc::infer::InferCtxt;\n+use rustc::infer::InferCtxtBuilder;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n use rustc::hir::map::blocks::FnLikeNode;\n use syntax::ast;\n use syntax::codemap::Span;\n \n+use std::mem;\n+\n pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MirMap<'tcx> {\n     let mut map = MirMap {\n         map: NodeMap(),\n@@ -48,6 +52,36 @@ pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MirMap<'tcx\n     map\n }\n \n+/// A pass to lift all the types and substitutions in a Mir\n+/// to the global tcx. Sadly, we don't have a \"folder\" that\n+/// can change 'tcx so we have to transmute afterwards.\n+struct GlobalizeMir<'a, 'gcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    span: Span\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(ty) {\n+            *ty = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found type `{:?}` with inference types/regions in MIR\",\n+                      ty);\n+        }\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(substs) {\n+            *substs = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found substs `{:?}` with inference types/regions in MIR\",\n+                      substs);\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n@@ -56,44 +90,77 @@ struct BuildMir<'a, 'tcx: 'a> {\n     map: &'a mut MirMap<'tcx>,\n }\n \n-impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n-    fn build<F>(&mut self, src: MirSource, f: F)\n-        where F: for<'b> FnOnce(Cx<'b, 'tcx, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n+/// Helper type of a temporary returned by BuildMir::cx(...).\n+/// Necessary because we can't write the following bound:\n+/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Cx<'b, 'gcx, 'tcx>).\n+struct CxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    src: MirSource,\n+    infcx: InferCtxtBuilder<'a, 'gcx, 'tcx>,\n+    map: &'a mut MirMap<'gcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n+    fn cx<'b>(&'b mut self, src: MirSource) -> CxBuilder<'b, 'gcx, 'tcx> {\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n+        CxBuilder {\n+            src: src,\n+            infcx: self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal),\n+            map: self.map\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n+    fn build<F>(&'tcx mut self, f: F)\n+        where F: for<'b> FnOnce(Cx<'b, 'gcx, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n     {\n-        let constness = match src {\n-            MirSource::Const(_) |\n-            MirSource::Static(..) => hir::Constness::Const,\n-            MirSource::Fn(id) => {\n-                let fn_like = FnLikeNode::from_node(self.tcx.map.get(id));\n-                match fn_like.map(|f| f.kind()) {\n-                    Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => c,\n-                    Some(FnKind::Method(_, m, _, _)) => m.constness,\n-                    _ => hir::Constness::NotConst\n+        let src = self.src;\n+        let mir = self.infcx.enter(|infcx| {\n+            let constness = match src {\n+                MirSource::Const(_) |\n+                MirSource::Static(..) => hir::Constness::Const,\n+                MirSource::Fn(id) => {\n+                    let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n+                    match fn_like.map(|f| f.kind()) {\n+                        Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => c,\n+                        Some(FnKind::Method(_, m, _, _)) => m.constness,\n+                        _ => hir::Constness::NotConst\n+                    }\n                 }\n-            }\n-            MirSource::Promoted(..) => bug!()\n-        };\n+                MirSource::Promoted(..) => bug!()\n+            };\n+            let (mut mir, scope_auxiliary) = f(Cx::new(&infcx, constness));\n+\n+            // Convert the Mir to global types.\n+            let mut globalizer = GlobalizeMir {\n+                tcx: infcx.tcx.global_tcx(),\n+                span: mir.span\n+            };\n+            globalizer.visit_mir(&mut mir);\n+            let mir = unsafe {\n+                mem::transmute::<Mir, Mir<'gcx>>(mir)\n+            };\n+\n+            pretty::dump_mir(infcx.tcx.global_tcx(), \"mir_map\", &0,\n+                             src, &mir, Some(&scope_auxiliary));\n \n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n-        let mir = InferCtxt::enter(self.tcx, None, Some(param_env),\n-                                   ProjectionMode::AnyFinal, |infcx| {\n-            let (mir, scope_auxiliary) = f(Cx::new(&infcx, constness));\n-            pretty::dump_mir(self.tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n             mir\n         });\n \n         assert!(self.map.map.insert(src.item_id(), mir).is_none())\n     }\n+}\n \n-    fn build_const_integer(&mut self, expr: &'tcx hir::Expr) {\n+impl<'a, 'gcx> BuildMir<'a, 'gcx> {\n+    fn build_const_integer(&mut self, expr: &'gcx hir::Expr) {\n         // FIXME(eddyb) Closures should have separate\n         // function definition IDs and expression IDs.\n         // Type-checking should not let closures get\n         // this far in an integer constant position.\n         if let hir::ExprClosure(..) = expr.node {\n             return;\n         }\n-        self.build(MirSource::Const(expr.id), |cx| {\n+        self.cx(MirSource::Const(expr.id)).build(|cx| {\n             build::construct_const(cx, expr.id, expr)\n         });\n     }\n@@ -104,12 +171,12 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemConst(_, ref expr) => {\n-                self.build(MirSource::Const(item.id), |cx| {\n+                self.cx(MirSource::Const(item.id)).build(|cx| {\n                     build::construct_const(cx, item.id, expr)\n                 });\n             }\n             hir::ItemStatic(_, m, ref expr) => {\n-                self.build(MirSource::Static(item.id, m), |cx| {\n+                self.cx(MirSource::Static(item.id, m)).build(|cx| {\n                     build::construct_const(cx, item.id, expr)\n                 });\n             }\n@@ -121,7 +188,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Trait associated const defaults.\n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n-            self.build(MirSource::Const(item.id), |cx| {\n+            self.cx(MirSource::Const(item.id)).build(|cx| {\n                 build::construct_const(cx, item.id, expr)\n             });\n         }\n@@ -131,7 +198,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Impl associated const.\n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n-            self.build(MirSource::Const(item.id), |cx| {\n+            self.cx(MirSource::Const(item.id)).build(|cx| {\n                 build::construct_const(cx, item.id, expr)\n             });\n         }\n@@ -192,8 +259,8 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n                     (fn_sig.inputs[index], Some(&*arg.pat))\n                 });\n \n-        self.build(MirSource::Fn(id), |cx| {\n-            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+        let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+        self.cx(MirSource::Fn(id)).build(|cx| {\n             build::construct_fn(cx, id, arguments, fn_sig.output, body)\n         });\n "}, {"sha": "54ac04bea9c4cf8e98a2ba6015b4971b11db0d02", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -19,7 +19,6 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::infer::InferCtxt;\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::cast::CastTy;\n@@ -1019,7 +1018,7 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n             // Statics must be Sync.\n             if mode == Mode::Static {\n                 let ty = mir.return_ty.unwrap();\n-                InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+                tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n                     let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                     let mut fulfillment_cx = traits::FulfillmentContext::new();\n                     fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);"}, {"sha": "40157aa934c6571999263021aaa3fcfe4974f084", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -61,7 +61,7 @@ struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n     errors_reported: bool\n }\n \n-impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx, 'tcx> {\n+impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn visit_span(&mut self, span: &Span) {\n         if *span != DUMMY_SP {\n             self.last_span = *span;\n@@ -104,8 +104,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx, 'tcx> {\n-    fn new(cx: &'a mut TypeChecker<'b, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n+    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n         TypeVerifier {\n             cx: cx,\n             mir: mir,\n@@ -114,11 +114,11 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.cx.infcx.tcx\n     }\n \n-    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n         self.cx.infcx\n     }\n \n@@ -324,8 +324,8 @@ pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     last_span: Span\n }\n \n-impl<'a, 'tcx> TypeChecker<'a, 'tcx, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> Self {\n+impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         TypeChecker {\n             infcx: infcx,\n             fulfillment_cx: traits::FulfillmentContext::new(),\n@@ -349,7 +349,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx, 'tcx> {\n             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -584,7 +584,7 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n             return;\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n-        InferCtxt::enter(tcx, None, Some(param_env), ProjectionMode::AnyFinal, |infcx| {\n+        tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal).enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx);\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "b1bb48aacee9ff2892071e9a0c9333d8edef3ed0", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -36,7 +36,6 @@ use rustc_const_math::{ConstMathErr, Op};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::infer::InferCtxt;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -74,9 +73,9 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     rvalue_borrows: NodeMap<hir::Mutability>\n }\n \n-impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n+impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R where\n-        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>) -> R,\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'gcx>) -> R,\n     {\n         let (old_mode, old_qualif) = (self.mode, self.qualif);\n         self.mode = mode;\n@@ -88,14 +87,14 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn with_euv<F, R>(&mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n-        F: for<'b> FnOnce(&mut euv::ExprUseVisitor<'b, 'tcx, 'tcx>) -> R,\n+        F: for<'b, 'tcx> FnOnce(&mut euv::ExprUseVisitor<'b, 'gcx, 'tcx>) -> R,\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n             None => self.tcx.empty_parameter_environment()\n         };\n \n-        InferCtxt::enter(self.tcx, None, Some(param_env), ProjectionMode::AnyFinal, |infcx| {\n+        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal).enter(|infcx| {\n             f(&mut euv::ExprUseVisitor::new(self, &infcx))\n         })\n     }\n@@ -178,7 +177,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn handle_const_fn_call(&mut self,\n                             _expr: &hir::Expr,\n                             def_id: DefId,\n-                            ret_ty: Ty<'tcx>)\n+                            ret_ty: Ty<'gcx>)\n                             -> bool {\n         if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n             let qualif = self.fn_like(fn_like.kind(),\n@@ -672,7 +671,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.sess.abort_if_errors();\n }\n \n-impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,"}, {"sha": "137a50642fcf4be2f8ff781355e5cad43add1738", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -13,7 +13,6 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::infer::InferCtxt;\n use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::traits::ProjectionMode;\n@@ -41,10 +40,10 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n                 fn_id: ast::NodeId) {\n         // FIXME (@jroesch) change this to be an inference context\n         let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n-        InferCtxt::enter(self.tcx, None, Some(param_env.clone()),\n-                         ProjectionMode::AnyFinal, |infcx| {\n+        self.tcx.infer_ctxt(None, Some(param_env.clone()),\n+                            ProjectionMode::AnyFinal).enter(|infcx| {\n             let mut delegate = RvalueContextDelegate {\n-                tcx: self.tcx,\n+                tcx: infcx.tcx,\n                 param_env: &param_env\n             };\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n@@ -54,22 +53,23 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n     }\n }\n \n-struct RvalueContextDelegate<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+struct RvalueContextDelegate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'gcx>,\n }\n \n-impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'gcx, 'tcx> {\n     fn consume(&mut self,\n                _: ast::NodeId,\n                span: Span,\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {:?}; type: {:?}\", *cmt, cmt.ty);\n-        if !cmt.ty.is_sized(self.tcx, self.param_env, span) {\n+        let ty = self.tcx.lift_to_global(&cmt.ty).unwrap();\n+        if !ty.is_sized(self.tcx.global_tcx(), self.param_env, span) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n-                cmt.ty);\n+                ty);\n         }\n     }\n "}, {"sha": "6df308d5e624a6d13c3ffc54559980caf539a7b7", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -194,7 +194,6 @@ use rustc_const_eval::{compare_lit_exprs, eval_const_expr};\n use rustc::hir::def::{Def, DefMap};\n use rustc::hir::def_id::DefId;\n use middle::expr_use_visitor as euv;\n-use rustc::infer::InferCtxt;\n use middle::lang_items::StrEqFnLangItem;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n@@ -1466,7 +1465,7 @@ fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool\n         field: field,\n         reassigned: false\n     };\n-    InferCtxt::enter_normalizing(bcx.tcx(), ProjectionMode::Any, |infcx| {\n+    bcx.tcx().normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n         let mut visitor = euv::ExprUseVisitor::new(&mut rc, &infcx);\n         visitor.walk_expr(body);\n     });"}, {"sha": "1c393f8091eee996eb58e3f5151097b5b5682c6f", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -153,7 +153,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let symbol = symbol_names::exported_name(ccx, &instance);\n \n     // Compute the rust-call form of the closure call method.\n-    let sig = &ty::Tables::closure_type(&tcx.tables, tcx, closure_id, substs).sig;\n+    let sig = &tcx.closure_type(closure_id, substs).sig;\n     let sig = tcx.erase_late_bound_regions(sig);\n     let sig = tcx.normalize_associated_type(&sig);\n     let closure_type = tcx.mk_closure_from_closure_substs(closure_id, substs);\n@@ -217,9 +217,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n \n-    let sig = &ty::Tables::closure_type(&tcx.tables, tcx,\n-                                        closure_def_id,\n-                                        closure_substs).sig;\n+    let sig = &tcx.closure_type(closure_def_id, closure_substs).sig;\n     let sig = tcx.erase_late_bound_regions(sig);\n     let sig = tcx.normalize_associated_type(&sig);\n \n@@ -349,7 +347,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Make a version with the type of by-ref closure.\n     let ty::ClosureTy { unsafety, abi, mut sig } =\n-        ty::Tables::closure_type(&tcx.tables, tcx, closure_def_id, substs);\n+        tcx.closure_type(closure_def_id, substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n     let llref_fn_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n         unsafety: unsafety,"}, {"sha": "dfab2bdbf644ec505a89086ddb29efb06ccf2ce1", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -530,7 +530,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 let exchange_malloc_fn_trans_item =\n                     create_fn_trans_item(self.scx.tcx(),\n                                          exchange_malloc_fn_def_id,\n-                                         self.ccx.tcx().mk_substs(Substs::empty()),\n+                                         self.scx.tcx().mk_substs(Substs::empty()),\n                                          self.param_substs);\n \n                 self.output.push(exchange_malloc_fn_trans_item);\n@@ -670,8 +670,8 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         let exchange_free_fn_trans_item =\n             create_fn_trans_item(scx.tcx(),\n                                  exchange_free_fn_def_id,\n-                                 ccx.tcx().mk_substs(Substs::empty()),\n-                                 ccx.tcx().mk_substs(Substs::empty()));\n+                                 scx.tcx().mk_substs(Substs::empty()),\n+                                 scx.tcx().mk_substs(Substs::empty()));\n \n         output.push(exchange_free_fn_trans_item);\n     }\n@@ -709,7 +709,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             let trans_item = create_fn_trans_item(scx.tcx(),\n                                                   destructor_did,\n                                                   substs,\n-                                                  ccx.tcx().mk_substs(Substs::empty()));\n+                                                  scx.tcx().mk_substs(Substs::empty()));\n             output.push(trans_item);\n         }\n \n@@ -1014,7 +1014,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                                 Some(create_fn_trans_item(scx.tcx(),\n                                     impl_method.method.def_id,\n                                     impl_method.substs,\n-                                    ccx.tcx().mk_substs(Substs::empty())))\n+                                    scx.tcx().mk_substs(Substs::empty())))\n                             } else {\n                                 None\n                             }"}, {"sha": "c1685e6a749046b8c8f7ee42ee737b4b648cbdf9", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -19,7 +19,7 @@ use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::cfg;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n+use rustc::infer::TransNormalize;\n use rustc::util::common::MemoizationMap;\n use middle::lang_items::LangItem;\n use rustc::ty::subst::Substs;\n@@ -428,7 +428,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx>\n+        where T: TransNormalize<'tcx>\n     {\n         monomorphize::apply_param_substs(self.ccx.tcx(),\n                                          self.param_substs,\n@@ -603,7 +603,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx>\n+        where T: TransNormalize<'tcx>\n     {\n         monomorphize::apply_param_substs(self.tcx(),\n                                          self.fcx.param_substs,\n@@ -710,7 +710,7 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n     }\n \n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx>\n+        where T: TransNormalize<'tcx>\n     {\n         self.bcx.monomorphize(value)\n     }\n@@ -1066,7 +1066,7 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n         // Do the initial selection for the obligation. This yields the\n         // shallow result we are looking for -- that is, what specific impl.\n-        let vtable = InferCtxt::enter_normalizing(tcx, ProjectionMode::Any, |infcx| {\n+        tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n             let mut selcx = SelectionContext::new(&infcx);\n \n             let obligation_cause = traits::ObligationCause::misc(span,\n@@ -1108,7 +1108,7 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n             vtable\n         })\n-    });\n+    })\n }\n \n /// Normalizes the predicates and checks whether they hold.  If this\n@@ -1122,7 +1122,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    InferCtxt::enter_normalizing(tcx, ProjectionMode::Any, |infcx| {\n+    tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n         let cause = traits::ObligationCause::dummy();"}, {"sha": "a29ff95851d7600ec31a633fed41cc37125e7de6", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -18,7 +18,6 @@ use back::symbol_names;\n use llvm;\n use llvm::{ValueRef, get_param};\n use middle::lang_items::ExchangeFreeFnLangItem;\n-use rustc::infer::InferCtxt;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -117,16 +116,15 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match t.sty {\n         ty::TyBox(typ) if !type_needs_drop(tcx, typ)\n                          && type_is_sized(tcx, typ) => {\n-            let infcx = InferCtxt::normalizing(tcx,\n-                                               &tcx.tables,\n-                                               traits::ProjectionMode::Any);\n-            let layout = t.layout(&infcx).unwrap();\n-            if layout.size(&tcx.data_layout).bytes() == 0 {\n-                // `Box<ZeroSizeType>` does not allocate.\n-                tcx.types.i8\n-            } else {\n-                tcx.erase_regions(&t)\n-            }\n+            tcx.normalizing_infer_ctxt(traits::ProjectionMode::Any).enter(|infcx| {\n+                let layout = t.layout(&infcx).unwrap();\n+                if layout.size(&tcx.data_layout).bytes() == 0 {\n+                    // `Box<ZeroSizeType>` does not allocate.\n+                    tcx.types.i8\n+                } else {\n+                    tcx.erase_regions(&t)\n+                }\n+            })\n         }\n         _ => tcx.erase_regions(&t)\n     }"}, {"sha": "9b279a397f8649d6164252cd1170a4127b8a999e", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -14,7 +14,6 @@ use arena::TypedArena;\n use back::symbol_names;\n use llvm::{ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n use rustc::ty::subst::{FnSpace, Subst, Substs};\n use rustc::ty::subst;\n use rustc::traits::{self, ProjectionMode};\n@@ -317,8 +316,14 @@ pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {\n-            let substs = InferCtxt::enter_normalizing(tcx, ProjectionMode::Any, |infcx| {\n-                traits::translate_substs(&infcx, impl_def_id, substs, node_item.node)\n+            let substs = tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+                let substs = traits::translate_substs(&infcx, impl_def_id,\n+                                                      substs, node_item.node);\n+                tcx.lift(&substs).unwrap_or_else(|| {\n+                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n+                          returned {:?} which contains inference types/regions\",\n+                         substs);\n+                })\n             });\n             ImplMethod {\n                 method: node_item.item,"}, {"sha": "039304ece60b0da01e4b100bbc3d32885049d315", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -13,6 +13,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::ErrKind;\n use rustc_const_math::ConstInt::*;\n use rustc::hir::def_id::DefId;\n+use rustc::infer::TransNormalize;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc::traits;\n@@ -252,7 +253,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn monomorphize<T>(&self, value: &T) -> T\n-        where T : TypeFoldable<'tcx>\n+        where T: TransNormalize<'tcx>\n     {\n         monomorphize::apply_param_substs(self.ccx.tcx(),\n                                          self.substs,"}, {"sha": "8b1809e40233a92edcb04236bcd7636a2b1ca948", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -12,6 +12,7 @@ use back::symbol_names;\n use llvm::ValueRef;\n use llvm;\n use rustc::hir::def_id::DefId;\n+use rustc::infer::TransNormalize;\n use rustc::ty::subst;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n@@ -193,7 +194,7 @@ pub fn apply_param_substs<'a, 'tcx, T>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        param_substs: &Substs<'tcx>,\n                                        value: &T)\n                                        -> T\n-    where T : TypeFoldable<'tcx>\n+    where T: TransNormalize<'tcx>\n {\n     let substituted = value.subst(tcx, param_substs);\n     tcx.normalize_associated_type(&substituted)"}, {"sha": "98ec87ebbcf6ff81864235cb1a4b5929448454b4", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -11,7 +11,6 @@\n #![allow(non_camel_case_types)]\n \n use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n use rustc::ty::subst;\n use abi::FnType;\n use adt;\n@@ -124,7 +123,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n \n     // FIXME(eddyb) Temporary sanity check for ty::layout.\n-    let layout = InferCtxt::enter_normalizing(cx.tcx(), ProjectionMode::Any, |infcx| {\n+    let layout = cx.tcx().normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n         t.layout(&infcx)\n     });\n     match layout {"}, {"sha": "a1a6a83d34ff2c8ebf46d6cf3d7e9f533ff02bde", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::free_region::FreeRegionMap;\n-use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin};\n+use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty;\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n@@ -196,27 +196,22 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return;\n     }\n \n-    // Create obligations for each predicate declared by the impl\n-    // definition in the context of the trait's parameter\n-    // environment. We can't just use `impl_env.caller_bounds`,\n-    // however, because we want to replace all late-bound regions with\n-    // region variables.\n-    let impl_bounds =\n-        impl_m.predicates.instantiate(tcx, impl_to_skol_substs);\n-\n-    InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |mut infcx| {\n+    tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|mut infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n-        let (impl_bounds, _) =\n-            infcx.replace_late_bound_regions_with_fresh_var(\n-                impl_m_span,\n-                infer::HigherRankedType,\n-                &ty::Binder(impl_bounds));\n-        debug!(\"compare_impl_method: impl_bounds={:?}\",\n-               impl_bounds);\n \n         // Normalize the associated types in the trait_bounds.\n         let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n \n+        // Create obligations for each predicate declared by the impl\n+        // definition in the context of the trait's parameter\n+        // environment. We can't just use `impl_env.caller_bounds`,\n+        // however, because we want to replace all late-bound regions with\n+        // region variables.\n+        let impl_bounds =\n+            impl_m.predicates.instantiate(tcx, impl_to_skol_substs);\n+\n+        debug!(\"compare_impl_method: impl_bounds={:?}\", impl_bounds);\n+\n         // Obtain the predicate split predicate sets for each.\n         let trait_pred = trait_bounds.predicates.split();\n         let impl_pred = impl_bounds.predicates.split();\n@@ -250,7 +245,12 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        for predicate in impl_pred.fns {\n+        let (impl_pred_fns, _) =\n+            infcx.replace_late_bound_regions_with_fresh_var(\n+                impl_m_span,\n+                infer::HigherRankedType,\n+                &ty::Binder(impl_pred.fns));\n+        for predicate in impl_pred_fns {\n             let traits::Normalized { value: predicate, .. } =\n                 traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n \n@@ -285,6 +285,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n         let err = infcx.commit_if_ok(|snapshot| {\n+            let tcx = infcx.tcx;\n             let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n             let (impl_sig, _) =\n@@ -421,7 +422,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n            impl_trait_ref);\n \n     let tcx = ccx.tcx;\n-    InferCtxt::enter(tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+    tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         // The below is for the most part highly similar to the procedure"}, {"sha": "ae614d7b02157ec7ae5252aeb53ab18fd3902222", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -13,7 +13,7 @@ use check::regionck::RegionCtxt;\n \n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer;\n use middle::region;\n use rustc::ty::subst::{self, Subst};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -84,7 +84,8 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    InferCtxt::enter(tcx, None, Some(impl_param_env), ProjectionMode::AnyFinal, |infcx| {\n+    tcx.infer_ctxt(None, Some(impl_param_env), ProjectionMode::AnyFinal).enter(|infcx| {\n+        let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         let named_type = tcx.lookup_item_type(self_type_did).ty;"}, {"sha": "ad0ccdcf3890d02252024a6cfe22818443cb82d8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -372,17 +372,32 @@ impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    fn enter<F, R>(ccx: &'a CrateCtxt<'a, 'tcx>,\n-                   param_env: ty::ParameterEnvironment<'tcx>,\n-                   f: F) -> R\n-        where F: for<'b> FnOnce(Inherited<'b, 'tcx, 'tcx>) -> R\n+/// Helper type of a temporary returned by ccx.inherited(...).\n+/// Necessary because we can't write the following bound:\n+/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Inherited<'b, 'gcx, 'tcx>).\n+pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    ccx: &'a CrateCtxt<'a, 'gcx>,\n+    infcx: infer::InferCtxtBuilder<'a, 'gcx, 'tcx>\n+}\n+\n+impl<'a, 'gcx, 'tcx> CrateCtxt<'a, 'gcx> {\n+    pub fn inherited(&'a self, param_env: Option<ty::ParameterEnvironment<'gcx>>)\n+                     -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+        InheritedBuilder {\n+            ccx: self,\n+            infcx: self.tcx.infer_ctxt(Some(ty::Tables::empty()),\n+                                       param_env,\n+                                       ProjectionMode::AnyFinal)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n+    fn enter<F, R>(&'tcx mut self, f: F) -> R\n+        where F: for<'b> FnOnce(Inherited<'b, 'gcx, 'tcx>) -> R\n     {\n-        InferCtxt::enter(ccx.tcx,\n-                         Some(ty::Tables::empty()),\n-                         Some(param_env),\n-                         ProjectionMode::AnyFinal,\n-                         |infcx| {\n+        let ccx = self.ccx;\n+        self.infcx.enter(|infcx| {\n             f(Inherited {\n                 ccx: ccx,\n                 infcx: infcx,\n@@ -393,7 +408,9 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             })\n         })\n     }\n+}\n \n+impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     fn normalize_associated_types_in<T>(&self,\n                                         span: Span,\n                                         body_id: ast::NodeId,\n@@ -491,7 +508,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n     };\n \n-    Inherited::enter(ccx, param_env, |inh| {\n+    ccx.inherited(Some(param_env)).enter(|inh| {\n         // Compute the fty from point of view of inside fn.\n         let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body.id);\n         let fn_sig =\n@@ -1124,7 +1141,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n                                 expr: &'tcx hir::Expr,\n                                 expected_type: Ty<'tcx>) {\n-    Inherited::enter(ccx, ccx.tcx.empty_parameter_environment(), |inh| {\n+    ccx.inherited(None).enter(|inh| {\n         let fcx = FnCtxt::new(&inh, ty::FnConverging(expected_type), expr.id);\n         fcx.check_const_with_ty(expr.span, expr, expected_type);\n     });\n@@ -1134,7 +1151,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         sp: Span,\n                         e: &'tcx hir::Expr,\n                         id: ast::NodeId) {\n-    Inherited::enter(ccx, ccx.tcx.empty_parameter_environment(), |inh| {\n+    ccx.inherited(None).enter(|inh| {\n         let rty = ccx.tcx.node_id_to_type(id);\n         let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), e.id);\n         let declty = fcx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n@@ -1208,7 +1225,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             \"unsupported representation for zero-variant enum\");\n     }\n \n-    Inherited::enter(ccx, ccx.tcx.empty_parameter_environment(), |inh| {\n+    ccx.inherited(None).enter(|inh| {\n         let rty = ccx.tcx.node_id_to_type(id);\n         let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), id);\n "}, {"sha": "bb63cf11d9ad65b9196dc528909f4c9abff32eea", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 73, "deletions": 47, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use check::{FnCtxt, Inherited};\n+use check::FnCtxt;\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use hir::def_id::DefId;\n@@ -30,16 +30,46 @@ pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n     code: traits::ObligationCauseCode<'tcx>,\n }\n \n-impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n-    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'tcx>)\n-               -> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+/// Helper type of a temporary returned by .for_item(...).\n+/// Necessary because we can't write the following bound:\n+/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>).\n+struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n+    code: traits::ObligationCauseCode<'gcx>,\n+    id: ast::NodeId,\n+    span: Span\n+}\n+\n+impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+    fn with_fcx<F>(&'tcx mut self, f: F) where\n+        F: for<'b> FnOnce(&FnCtxt<'b, 'gcx, 'tcx>,\n+                          &mut CheckTypeWellFormedVisitor<'b, 'gcx>) -> Vec<Ty<'tcx>>\n+    {\n+        let code = self.code.clone();\n+        let id = self.id;\n+        let span = self.span;\n+        self.inherited.enter(|inh| {\n+            let fcx = FnCtxt::new(&inh, ty::FnDiverging, id);\n+            let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n+                ccx: fcx.ccx,\n+                code: code\n+            });\n+            fcx.select_all_obligations_or_error();\n+            fcx.regionck_item(id, span, &wf_tys);\n+        });\n+    }\n+}\n+\n+impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n+    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'gcx>)\n+               -> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         CheckTypeWellFormedVisitor {\n             ccx: ccx,\n             code: traits::ObligationCauseCode::MiscObligation\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'ccx, 'tcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'ccx, 'gcx, 'gcx> {\n         self.ccx.tcx\n     }\n \n@@ -128,7 +158,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn check_trait_or_impl_item(&mut self, item_id: ast::NodeId, span: Span) {\n         let code = self.code.clone();\n-        self.with_fcx(item_id, span, |fcx, this| {\n+        self.for_id(item_id, span).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let free_id_outlive = fcx.parameter_environment.free_id_outlive;\n \n@@ -166,32 +196,28 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         })\n     }\n \n-    fn with_item_fcx<F>(&mut self, item: &hir::Item, f: F) where\n-        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx, 'tcx>,\n-                           &mut CheckTypeWellFormedVisitor<'ccx,'tcx>) -> Vec<Ty<'tcx>>,\n-    {\n-        self.with_fcx(item.id, item.span, f)\n+    fn for_item<'tcx>(&self, item: &hir::Item)\n+                      -> CheckWfFcxBuilder<'ccx, 'gcx, 'tcx> {\n+        self.for_id(item.id, item.span)\n     }\n \n-    fn with_fcx<F>(&mut self, id: ast::NodeId, span: Span, mut f: F) where\n-        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx, 'tcx>,\n-                           &mut CheckTypeWellFormedVisitor<'ccx,'tcx>) -> Vec<Ty<'tcx>>,\n-    {\n-        let ccx = self.ccx;\n-        let param_env = ty::ParameterEnvironment::for_item(ccx.tcx, id);\n-        Inherited::enter(ccx, param_env, |inh| {\n-            let fcx = FnCtxt::new(&inh, ty::FnDiverging, id);\n-            let wf_tys = f(&fcx, self);\n-            fcx.select_all_obligations_or_error();\n-            fcx.regionck_item(id, span, &wf_tys);\n-        });\n+    fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n+                    -> CheckWfFcxBuilder<'ccx, 'gcx, 'tcx> {\n+        let param_env = ty::ParameterEnvironment::for_item(self.ccx.tcx, id);\n+        CheckWfFcxBuilder {\n+            inherited: self.ccx.inherited(Some(param_env)),\n+            code: self.code.clone(),\n+            id: id,\n+            span: span\n+        }\n     }\n \n     /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n     fn check_type_defn<F>(&mut self, item: &hir::Item, mut lookup_fields: F) where\n-        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n+        F: for<'fcx, 'tcx> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx>)\n+                                 -> Vec<AdtVariant<'tcx>>\n     {\n-        self.with_item_fcx(item, |fcx, this| {\n+        self.for_item(item).with_fcx(|fcx, this| {\n             let variants = lookup_fields(fcx);\n \n             for variant in &variants {\n@@ -234,7 +260,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n         }\n \n-        self.with_item_fcx(item, |fcx, this| {\n+        self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let predicates = fcx.tcx.lookup_predicates(trait_def_id);\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n@@ -247,7 +273,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                      item: &hir::Item,\n                      body: &hir::Block)\n     {\n-        self.with_item_fcx(item, |fcx, this| {\n+        self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let type_scheme = fcx.tcx.lookup_item_type(fcx.tcx.map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n@@ -274,7 +300,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         debug!(\"check_item_type: {:?}\", item);\n \n-        self.with_item_fcx(item, |fcx, this| {\n+        self.for_item(item).with_fcx(|fcx, this| {\n             let type_scheme = fcx.tcx.lookup_item_type(fcx.tcx.map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n                                                       &fcx.parameter_environment\n@@ -294,7 +320,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         debug!(\"check_impl: {:?}\", item);\n \n-        self.with_item_fcx(item, |fcx, this| {\n+        self.for_item(item).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n             let item_def_id = fcx.tcx.map.local_def_id(item.id);\n \n@@ -328,10 +354,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         });\n     }\n \n-    fn check_where_clauses<'fcx>(&mut self,\n-                                 fcx: &FnCtxt<'fcx,'tcx, 'tcx>,\n-                                 span: Span,\n-                                 predicates: &ty::InstantiatedPredicates<'tcx>)\n+    fn check_where_clauses<'fcx, 'tcx>(&mut self,\n+                                       fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                       span: Span,\n+                                       predicates: &ty::InstantiatedPredicates<'tcx>)\n     {\n         let obligations =\n             predicates.predicates\n@@ -346,13 +372,13 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         }\n     }\n \n-    fn check_fn_or_method<'fcx>(&mut self,\n-                                fcx: &FnCtxt<'fcx,'tcx, 'tcx>,\n-                                span: Span,\n-                                fty: &'tcx ty::BareFnTy<'tcx>,\n-                                predicates: &ty::InstantiatedPredicates<'tcx>,\n-                                free_id_outlive: CodeExtent,\n-                                implied_bounds: &mut Vec<Ty<'tcx>>)\n+    fn check_fn_or_method<'fcx, 'tcx>(&mut self,\n+                                      fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                      span: Span,\n+                                      fty: &'tcx ty::BareFnTy<'tcx>,\n+                                      predicates: &ty::InstantiatedPredicates<'tcx>,\n+                                      free_id_outlive: CodeExtent,\n+                                      implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n         let free_substs = &fcx.parameter_environment.free_substs;\n         let fty = fcx.instantiate_type_scheme(span, free_substs, &fty);\n@@ -376,12 +402,12 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         self.check_where_clauses(fcx, span, predicates);\n     }\n \n-    fn check_method_receiver<'fcx>(&mut self,\n-                                   fcx: &FnCtxt<'fcx,'tcx, 'tcx>,\n-                                   span: Span,\n-                                   method: &ty::Method<'tcx>,\n-                                   free_id_outlive: CodeExtent,\n-                                   self_ty: ty::Ty<'tcx>)\n+    fn check_method_receiver<'fcx, 'tcx>(&mut self,\n+                                         fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                         span: Span,\n+                                         method: &ty::Method<'tcx>,\n+                                         free_id_outlive: CodeExtent,\n+                                         self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the\n         // method's first parameter.\n@@ -549,7 +575,7 @@ struct AdtField<'tcx> {\n     span: Span,\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n fn struct_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n     let fields =\n         struct_def.fields().iter()"}, {"sha": "33238f6cda772b3f155292a548c32b9e65685229", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -56,15 +56,15 @@ struct CoherenceCheckVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n             self.cc.check_implementation(item)\n         }\n     }\n }\n \n-impl<'a, 'tcx> CoherenceChecker<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n // Returns the def ID of the base type, if there is one.\n fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n@@ -187,7 +187,7 @@ fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n             Rc::new(RefCell::new(vec!(impl_def_id))));\n     }\n \n-    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n+    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'gcx>, impl_def_id: DefId) {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n                impl_trait_ref, impl_def_id);\n         let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n@@ -376,10 +376,10 @@ fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            InferCtxt::enter(tcx, None, Some(param_env), ProjectionMode::Topmost, |infcx| {\n+            tcx.infer_ctxt(None, Some(param_env), ProjectionMode::Topmost).enter(|infcx| {\n                 let origin = TypeOrigin::Misc(span);\n-                let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>, mt_b: ty::TypeAndMut<'tcx>,\n-                                   mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+                let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>, mt_b: ty::TypeAndMut<'gcx>,\n+                                   mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n                     if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n                         infcx.report_mismatched_types(origin, mk_ptr(mt_b.ty),\n                                                       target, ty::error::TypeError::Mutability);\n@@ -513,7 +513,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    InferCtxt::enter(ccx.tcx, None, None, ProjectionMode::Topmost, |infcx| {\n+    ccx.tcx.infer_ctxt(None, None, ProjectionMode::Topmost).enter(|infcx| {\n         CoherenceChecker {\n             crate_context: ccx,\n             inference_context: infcx,"}, {"sha": "dcaa5cfb20a46ff73a8c8f3509ec0bce51be717d", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -14,7 +14,6 @@\n \n use hir::def_id::DefId;\n use rustc::traits::{self, ProjectionMode};\n-use rustc::infer::InferCtxt;\n use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n use rustc::dep_graph::DepNode;\n@@ -85,7 +84,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i+1)..] {\n-                InferCtxt::enter(self.tcx, None, None, ProjectionMode::Topmost, |infcx| {\n+                self.tcx.infer_ctxt(None, None, ProjectionMode::Topmost).enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                     }"}, {"sha": "b88b3c9802d30bbd3bff3273aa824ae3ba3b1f58", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c170fc355947f54129a97aedcb8dea3d555f71/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=a1c170fc355947f54129a97aedcb8dea3d555f71", "patch": "@@ -104,7 +104,7 @@ pub use rustc::util;\n use dep_graph::DepNode;\n use hir::map as hir_map;\n use hir::def::Def;\n-use rustc::infer::{InferCtxt, TypeOrigin};\n+use rustc::infer::TypeOrigin;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::traits::ProjectionMode;\n@@ -211,7 +211,7 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 t2: Ty<'tcx>,\n                                 msg: &str)\n                                 -> bool {\n-    InferCtxt::enter(ccx.tcx, None, None, ProjectionMode::AnyFinal, |infcx| {\n+    ccx.tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n         if let Err(err) = infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2) {\n             emit_type_err(infcx.tcx, span, t1, t2, &err, msg);\n             false"}]}