{"sha": "fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMGMxMTllN2RhMmU5YjA2OGRkNTRiYjg4ZThhY2IyM2QzMWJmYTQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-03-08T10:39:31Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-15T13:20:19Z"}, "message": "Consolidate ty::Generics", "tree": {"sha": "462658be1ad5ebd454c533e4638a148c8636636f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/462658be1ad5ebd454c533e4638a148c8636636f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "html_url": "https://github.com/rust-lang/rust/commit/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eca0da59850d4a9eef17c0e6c3795397102d88a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/eca0da59850d4a9eef17c0e6c3795397102d88a3", "html_url": "https://github.com/rust-lang/rust/commit/eca0da59850d4a9eef17c0e6c3795397102d88a3"}], "stats": {"total": 312, "additions": 186, "deletions": 126}, "files": [{"sha": "e05c686f39fcc53ee7df44d5bc2bc9be6f067fa3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -1461,7 +1461,7 @@ impl<'a> LoweringContext<'a> {\n                         assert!(!def_id.is_local());\n                         let n = self.cstore\n                             .item_generics_cloned_untracked(def_id, self.sess)\n-                            .regions\n+                            .lifetimes()\n                             .len();\n                         self.type_def_lifetime_params.insert(def_id, n);\n                         n"}, {"sha": "c7f0979766cf635256b1515b13bdd07d5d736dac", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -735,10 +735,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::Generics {\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n-            parent_regions,\n-            parent_types,\n-            ref regions,\n-            ref types,\n+            ref parent_parameters,\n+            ref parameters,\n \n             // Reverse map to each `TypeParameterDef`'s `index` field, from\n             // `def_id.index` (`def_id.krate` is the same as the item's).\n@@ -748,15 +746,18 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::Generics {\n         } = *self;\n \n         parent.hash_stable(hcx, hasher);\n-        parent_regions.hash_stable(hcx, hasher);\n-        parent_types.hash_stable(hcx, hasher);\n-        regions.hash_stable(hcx, hasher);\n-        types.hash_stable(hcx, hasher);\n+        parent_parameters.hash_stable(hcx, hasher);\n+        parameters.hash_stable(hcx, hasher);\n         has_self.hash_stable(hcx, hasher);\n         has_late_bound_regions.hash_stable(hcx, hasher);\n     }\n }\n \n+impl_stable_hash_for!(enum ty::GenericParameterDef {\n+    Lifetime(lt),\n+    Type(ty)\n+});\n+\n impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionParameterDef {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "9cf55e85693a4c18e84a5f1193a4af8f0a0f43bb", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -313,7 +313,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // `['a]` for the first impl trait and `'b` for the\n         // second.\n         let mut least_region = None;\n-        for region_def in &abstract_type_generics.regions {\n+        for region_def in abstract_type_generics.lifetimes() {\n             // Find the index of this region in the list of substitutions.\n             let index = region_def.index as usize;\n "}, {"sha": "8f44507035af3fd4ca4183aa61e7cc2bd8243aac", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -1659,7 +1659,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .entry(def_id)\n                     .or_insert_with(|| {\n                         tcx.generics_of(def_id)\n-                            .types\n+                            .types()\n                             .iter()\n                             .map(|def| def.object_lifetime_default)\n                             .collect()"}, {"sha": "dfe0cd6900e7a3bd2439410c41bd4d00e74ff838", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             flags.push((\"_Self\".to_string(), Some(self.tcx.type_of(def.did).to_string())));\n         }\n \n-        for param in generics.types.iter() {\n+        for param in generics.types().iter() {\n             let name = param.name.to_string();\n             let ty = trait_ref.substs.type_for_def(param);\n             let ty_str = ty.to_string();"}, {"sha": "10228c5783c56cf890eeb49a11588808b7c99250", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // We can't monomorphize things like `fn foo<A>(...)`.\n-        if !self.generics_of(method.def_id).types.is_empty() {\n+        if !self.generics_of(method.def_id).types().is_empty() {\n             return Some(MethodViolationCode::Generic);\n         }\n "}, {"sha": "b2fc2c171063fb47d8d8da0edad6cd57cb5b8419", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -243,7 +243,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n         let parser = Parser::new(&self.0);\n-        let types = &generics.types;\n+        let types = generics.types();\n         let mut result = Ok(());\n         for token in parser {\n             match token {\n@@ -288,7 +288,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let name = tcx.item_name(trait_ref.def_id);\n         let trait_str = tcx.item_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);\n-        let generic_map = generics.types.iter().map(|param| {\n+        let generic_map = generics.types().iter().map(|param| {\n             (param.name.to_string(),\n              trait_ref.substs.type_for_def(param).to_string())\n         }).collect::<FxHashMap<String, String>>();"}, {"sha": "f32316ac54723877120f4901c2903aea6755818e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -757,6 +757,21 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum GenericParameterDef {\n+    Lifetime(RegionParameterDef),\n+    Type(TypeParameterDef),\n+}\n+\n+impl GenericParameterDef {\n+    pub fn index(&self) -> u32 {\n+        match self {\n+            GenericParameterDef::Lifetime(lt) => lt.index,\n+            GenericParameterDef::Type(ty)     => ty.index,\n+        }\n+    }\n+}\n+\n /// Information about the formal type/lifetime parameters associated\n /// with an item or method. Analogous to hir::Generics.\n ///\n@@ -769,10 +784,8 @@ impl ty::EarlyBoundRegion {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Generics {\n     pub parent: Option<DefId>,\n-    pub parent_regions: u32,\n-    pub parent_types: u32,\n-    pub regions: Vec<RegionParameterDef>,\n-    pub types: Vec<TypeParameterDef>,\n+    pub parent_parameters: Vec<u32>,\n+    pub parameters: Vec<GenericParameterDef>,\n \n     /// Reverse map to each `TypeParameterDef`'s `index` field\n     pub type_param_to_index: FxHashMap<DefId, u32>,\n@@ -783,24 +796,56 @@ pub struct Generics {\n \n impl<'a, 'gcx, 'tcx> Generics {\n     pub fn parent_count(&self) -> usize {\n-        self.parent_regions as usize + self.parent_types as usize\n+        self.parent_parameters.iter().map(|&x| x as usize).sum()\n     }\n \n     pub fn own_count(&self) -> usize {\n-        self.regions.len() + self.types.len()\n+        self.parameters.len()\n     }\n \n     pub fn count(&self) -> usize {\n         self.parent_count() + self.own_count()\n     }\n \n+    pub fn lifetimes(&self) -> Vec<&RegionParameterDef> {\n+        self.parameters.iter().filter_map(|p| {\n+            if let GenericParameterDef::Lifetime(lt) = p {\n+                Some(lt)\n+            } else {\n+                None\n+            }\n+        }).collect()\n+    }\n+\n+    pub fn types(&self) -> Vec<&TypeParameterDef> {\n+        self.parameters.iter().filter_map(|p| {\n+            if let GenericParameterDef::Type(ty) = p {\n+                Some(ty)\n+            } else {\n+                None\n+            }\n+        }).collect()\n+    }\n+\n+    pub fn parent_lifetimes(&self) -> u32 {\n+        self.parent_parameters[0]\n+    }\n+\n+    pub fn parent_types(&self) -> u32 {\n+        self.parent_parameters[1]\n+    }\n+\n     pub fn region_param(&'tcx self,\n                         param: &EarlyBoundRegion,\n                         tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                         -> &'tcx RegionParameterDef\n     {\n         if let Some(index) = param.index.checked_sub(self.parent_count() as u32) {\n-            &self.regions[index as usize - self.has_self as usize]\n+            // We're currently assuming that lifetimes precede other generic parameters.\n+            match self.parameters[index as usize - self.has_self as usize] {\n+                ty::GenericParameterDef::Lifetime(ref lt) => lt,\n+                _ => bug!(\"expected region parameter, but found another generic parameter\")\n+            }\n         } else {\n             tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n                 .region_param(param, tcx)\n@@ -840,17 +885,23 @@ impl<'a, 'gcx, 'tcx> Generics {\n             // And it can be seen that in both cases, to move from a substs\n             // offset to a generics offset you just have to offset by the\n             // number of regions.\n-            let type_param_offset = self.regions.len();\n+            let type_param_offset = self.lifetimes().len();\n \n             let has_self = self.has_self && self.parent.is_none();\n             let is_separated_self = type_param_offset != 0 && idx == 0 && has_self;\n \n-            if let Some(idx) = (idx as usize).checked_sub(type_param_offset) {\n+            if let Some(_) = (idx as usize).checked_sub(type_param_offset) {\n                 assert!(!is_separated_self, \"found a Self after type_param_offset\");\n-                &self.types[idx]\n+                match self.parameters[idx as usize] {\n+                    ty::GenericParameterDef::Type(ref ty) => ty,\n+                    _ => bug!(\"expected type parameter, but found another generic parameter\")\n+                }\n             } else {\n                 assert!(is_separated_self, \"non-Self param before type_param_offset\");\n-                &self.types[0]\n+                match self.parameters[type_param_offset] {\n+                    ty::GenericParameterDef::Type(ref ty) => ty,\n+                    _ => bug!(\"expected type parameter, but found another generic parameter\")\n+                }\n             }\n         } else {\n             tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))"}, {"sha": "fa2aa9720064a33ee42afaa6d4c876684cfe036c", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -242,24 +242,31 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> ty::Region<'tcx>,\n           FT: FnMut(&ty::TypeParameterDef, &[Kind<'tcx>]) -> Ty<'tcx> {\n         // Handle Self first, before all regions.\n-        let mut types = defs.types.iter();\n-        if defs.parent.is_none() && defs.has_self {\n+        let types = defs.types();\n+        let mut types = types.iter();\n+        let mut skip_self = defs.parent.is_none() && defs.has_self;\n+        if skip_self {\n             let def = types.next().unwrap();\n             let ty = mk_type(def, substs);\n             assert_eq!(def.index as usize, substs.len());\n             substs.push(ty.into());\n         }\n \n-        for def in &defs.regions {\n-            let region = mk_region(def, substs);\n-            assert_eq!(def.index as usize, substs.len());\n-            substs.push(Kind::from(region));\n-        }\n-\n-        for def in types {\n-            let ty = mk_type(def, substs);\n-            assert_eq!(def.index as usize, substs.len());\n-            substs.push(Kind::from(ty));\n+        for def in &defs.parameters {\n+            let param = match def {\n+                ty::GenericParameterDef::Lifetime(ref lt) => {\n+                    UnpackedKind::Lifetime(mk_region(lt, substs))\n+                }\n+                ty::GenericParameterDef::Type(ref ty) => {\n+                    if skip_self {\n+                        skip_self = false;\n+                        continue\n+                    }\n+                    UnpackedKind::Type(mk_type(ty, substs))\n+                }\n+            };\n+            assert_eq!(def.index() as usize, substs.len());\n+            substs.push(param.pack());\n         }\n     }\n "}, {"sha": "5b287e416297bcd56bb9cbd3098422cc69bcc0ff", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -310,10 +310,10 @@ impl PrintContext {\n             if let Some(def_id) = generics.parent {\n                 // Methods.\n                 assert!(is_value_path);\n-                child_types = generics.types.len();\n+                child_types = generics.types().len();\n                 generics = tcx.generics_of(def_id);\n-                num_regions = generics.regions.len();\n-                num_types = generics.types.len();\n+                num_regions = generics.lifetimes().len();\n+                num_types = generics.types().len();\n \n                 if has_self {\n                     print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n@@ -328,16 +328,16 @@ impl PrintContext {\n                     assert_eq!(has_self, false);\n                 } else {\n                     // Types and traits.\n-                    num_regions = generics.regions.len();\n-                    num_types = generics.types.len();\n+                    num_regions = generics.lifetimes().len();\n+                    num_types = generics.types().len();\n                 }\n             }\n \n             if !verbose {\n-                if generics.types.last().map_or(false, |def| def.has_default) {\n+                if generics.types().last().map_or(false, |def| def.has_default) {\n                     if let Some(substs) = tcx.lift(&substs) {\n                         let tps = substs.types().rev().skip(child_types);\n-                        for (def, actual) in generics.types.iter().rev().zip(tps) {\n+                        for (def, actual) in generics.types().iter().rev().zip(tps) {\n                             if !def.has_default {\n                                 break;\n                             }"}, {"sha": "7e580e9333ff0d65b5487a4a75dc717f17d927eb", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -929,7 +929,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ImplItemKind::Const(..) => true,\n                 hir::ImplItemKind::Method(ref sig, _) => {\n                     let generics = self.tcx.generics_of(def_id);\n-                    let types = generics.parent_types as usize + generics.types.len();\n+                    let types = generics.parent_types() as usize + generics.types().len();\n                     let needs_inline =\n                         (types > 0 || tcx.trans_fn_attrs(def_id).requests_inline())\n                             && !self.metadata_output_only();"}, {"sha": "bfdf81588afdc927155d0f879658ae9a2f959f2b", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -1076,7 +1076,7 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n \n fn item_has_type_parameters<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     let generics = tcx.generics_of(def_id);\n-    generics.parent_types as usize + generics.types.len() > 0\n+    generics.parent_types() as usize + generics.types().len() > 0\n }\n \n fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1108,7 +1108,7 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         continue;\n                     }\n \n-                    if !tcx.generics_of(method.def_id).types.is_empty() {\n+                    if !tcx.generics_of(method.def_id).types().is_empty() {\n                         continue;\n                     }\n "}, {"sha": "1e8707157f75adfc2fbf3186c44fe32d93dee420", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -357,7 +357,7 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n \n     // FIXME: when we make this a hard error, this should have its\n     // own error code.\n-    let message = if !tcx.generics_of(def_id).types.is_empty() {\n+    let message = if !tcx.generics_of(def_id).types().is_empty() {\n         format!(\"#[derive] can't be used on a #[repr(packed)] struct with \\\n                  type parameters (error E0133)\")\n     } else {"}, {"sha": "445717ac60081887160fd938516da802efb5f9f6", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n-        for def in &self.ev.tcx.generics_of(self.item_def_id).types {\n+        for def in &self.ev.tcx.generics_of(self.item_def_id).types() {\n             if def.has_default {\n                 self.ev.tcx.type_of(def.def_id).visit_with(self);\n             }\n@@ -1335,7 +1335,7 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n-        for def in &self.tcx.generics_of(self.item_def_id).types {\n+        for def in &self.tcx.generics_of(self.item_def_id).types() {\n             if def.has_default {\n                 self.tcx.type_of(def.def_id).visit_with(self);\n             }"}, {"sha": "be9aa49c100a81ccd6083062678d5d4457252a48", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -417,7 +417,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n             get_type_parameter_names(cx, cx.tcx.generics_of(def_id))\n         });\n-        names.extend(generics.types.iter().map(|param| param.name));\n+        names.extend(generics.types().iter().map(|param| param.name));\n         names\n     }\n "}, {"sha": "4286946599a7cce241fbaa79d006d0b2a3ee3117", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -209,7 +209,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // whatever & would get replaced with).\n         let decl_generics = tcx.generics_of(def_id);\n         let num_types_provided = parameters.types.len();\n-        let expected_num_region_params = decl_generics.regions.len();\n+        let expected_num_region_params = decl_generics.lifetimes().len();\n         let supplied_num_region_params = parameters.lifetimes.len();\n         if expected_num_region_params != supplied_num_region_params {\n             report_lifetime_number_error(tcx, span,\n@@ -221,7 +221,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         assert_eq!(decl_generics.has_self, self_ty.is_some());\n \n         // Check the number of type parameters supplied by the user.\n-        let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n+        let ty_param_defs = &decl_generics.types()[self_ty.is_some() as usize..];\n         if !infer_types || num_types_provided > ty_param_defs.len() {\n             check_type_argument_count(tcx, span, num_types_provided, ty_param_defs);\n         }\n@@ -254,7 +254,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 return ty;\n             }\n \n-            let i = i - self_ty.is_some() as usize - decl_generics.regions.len();\n+            let i = i - self_ty.is_some() as usize - decl_generics.lifetimes().len();\n             if i < num_types_provided {\n                 // A provided type parameter.\n                 self.ast_ty_to_ty(&parameters.types[i])\n@@ -1300,7 +1300,7 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n }\n \n fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n-                             ty_param_defs: &[ty::TypeParameterDef]) {\n+                             ty_param_defs: &[&ty::TypeParameterDef]) {\n     let accepted = ty_param_defs.len();\n     let required = ty_param_defs.iter().take_while(|x| !x.has_default).count();\n     if supplied < required {"}, {"sha": "1dce514023a593f40b9e559318b8cdc510e3fb18", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -357,8 +357,8 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 trait_to_skol_substs: &Substs<'tcx>)\n                                                 -> Result<(), ErrorReported> {\n     let span = tcx.sess.codemap().def_span(span);\n-    let trait_params = &trait_generics.regions[..];\n-    let impl_params = &impl_generics.regions[..];\n+    let trait_params = trait_generics.lifetimes();\n+    let impl_params = impl_generics.lifetimes();\n \n     debug!(\"check_region_bounds_on_impl_method: \\\n             trait_generics={:?} \\\n@@ -574,8 +574,8 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         -> Result<(), ErrorReported> {\n     let impl_m_generics = tcx.generics_of(impl_m.def_id);\n     let trait_m_generics = tcx.generics_of(trait_m.def_id);\n-    let num_impl_m_type_params = impl_m_generics.types.len();\n-    let num_trait_m_type_params = trait_m_generics.types.len();\n+    let num_impl_m_type_params = impl_m_generics.types().len();\n+    let num_trait_m_type_params = trait_m_generics.types().len();\n     if num_impl_m_type_params != num_trait_m_type_params {\n         let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n         let impl_m_item = tcx.hir.expect_impl_item(impl_m_node_id);\n@@ -728,7 +728,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut error_found = false;\n     let impl_m_generics = tcx.generics_of(impl_m.def_id);\n     let trait_m_generics = tcx.generics_of(trait_m.def_id);\n-    for (impl_ty, trait_ty) in impl_m_generics.types.iter().zip(trait_m_generics.types.iter()) {\n+    for (impl_ty, trait_ty) in impl_m_generics.types().iter().zip(trait_m_generics.types().iter()) {\n         if impl_ty.synthetic != trait_ty.synthetic {\n             let impl_node_id = tcx.hir.as_local_node_id(impl_ty.def_id).unwrap();\n             let impl_span = tcx.hir.span(impl_node_id);"}, {"sha": "50a3cab6d2bb0b10692f93e0fbf55a621d9e0745", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -45,7 +45,7 @@ fn equate_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let i_n_tps = tcx.generics_of(def_id).types.len();\n+    let i_n_tps = tcx.generics_of(def_id).types().len();\n     if i_n_tps != n_tps {\n         let span = match it.node {\n             hir::ForeignItemFn(_, _, ref generics) => generics.span,\n@@ -346,7 +346,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let def_id = tcx.hir.local_def_id(it.id);\n-    let i_n_tps = tcx.generics_of(def_id).types.len();\n+    let i_n_tps = tcx.generics_of(def_id).types().len();\n     let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {"}, {"sha": "3accb51f3087e72314b3af2b19d917ca63b0fd72", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 parent_substs.type_at(i)\n             } else if let Some(ast_ty)\n                 = provided.as_ref().and_then(|p| {\n-                    p.types.get(i - parent_substs.len() - method_generics.regions.len())\n+                    p.types.get(i - parent_substs.len() - method_generics.lifetimes().len())\n                 })\n             {\n                 self.to_ty(ast_ty)"}, {"sha": "8d7d8cb0f5f667ec5f451fc698ce7f74ff8d3ca7", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -288,8 +288,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let method_item = self.associated_item(trait_def_id, m_name, Namespace::Value).unwrap();\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);\n-        assert_eq!(generics.types.len(), 0);\n-        assert_eq!(generics.regions.len(), 0);\n+        assert_eq!(generics.parameters.len(), 0);\n \n         debug!(\"lookup_in_trait_adjusted: method_item={:?}\", method_item);\n         let mut obligations = vec![];"}, {"sha": "d3335fdd9807ef52818750ca972cdff0dacdddd9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -1378,14 +1378,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         // method yet. So create fresh variables here for those too,\n         // if there are any.\n         let generics = self.tcx.generics_of(method);\n-        assert_eq!(substs.types().count(), generics.parent_types as usize);\n-        assert_eq!(substs.regions().count(), generics.parent_regions as usize);\n+        assert_eq!(substs.regions().count(), generics.parent_lifetimes() as usize);\n+        assert_eq!(substs.types().count(), generics.parent_types() as usize);\n \n         // Erase any late-bound regions from the method and substitute\n         // in the values from the substitution.\n         let xform_fn_sig = self.erase_late_bound_regions(&fn_sig);\n \n-        if generics.types.is_empty() && generics.regions.is_empty() {\n+        if generics.parameters.is_empty() {\n             xform_fn_sig.subst(self.tcx, substs)\n         } else {\n             let substs = Substs::for_item(self.tcx, method, |def, _| {"}, {"sha": "1faf1f7e8828613ed519e3339e9d9a956c677de9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -1239,7 +1239,7 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n         } else {\n             for item in &m.items {\n                 let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n-                if !generics.types.is_empty() {\n+                if !generics.types().is_empty() {\n                     let mut err = struct_span_err!(tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n                     err.span_label(item.span, \"can't have type parameters\");\n@@ -4799,7 +4799,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Skip over the lifetimes in the same segment.\n             if let Some((_, generics)) = segment {\n-                i -= generics.regions.len();\n+                i -= generics.lifetimes().len();\n             }\n \n             if let Some(ast_ty) = types.get(i) {\n@@ -4918,11 +4918,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Check provided type parameters.\n-        let type_defs = segment.map_or(&[][..], |(_, generics)| {\n+        let type_defs = segment.map_or(vec![], |(_, generics)| {\n             if generics.parent.is_none() {\n-                &generics.types[generics.has_self as usize..]\n+                generics.types()[generics.has_self as usize..].to_vec()\n             } else {\n-                &generics.types\n+                generics.types()\n             }\n         });\n         let required_len = type_defs.iter().take_while(|d| !d.has_default).count();\n@@ -4957,7 +4957,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // Check provided lifetime parameters.\n-        let lifetime_defs = segment.map_or(&[][..], |(_, generics)| &generics.regions);\n+        let lifetime_defs = segment.map_or(vec![], |(_, generics)| generics.lifetimes());\n         let required_len = lifetime_defs.len();\n \n         // Prohibit explicit lifetime arguments if late bound lifetime parameters are present.\n@@ -5014,13 +5014,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let segment = segment.map(|(path_segment, generics)| {\n             let explicit = !path_segment.infer_types;\n-            let impl_trait = generics.types.iter()\n-                                           .any(|ty_param| {\n-                                               match ty_param.synthetic {\n-                                                   Some(ImplTrait) => true,\n-                                                   _ => false,\n-                                               }\n-                                           });\n+            let impl_trait = generics.types().iter()\n+                                             .any(|ty_param| {\n+                                                 match ty_param.synthetic {\n+                                                     Some(ImplTrait) => true,\n+                                                     _ => false,\n+                                                 }\n+                                             });\n \n             if explicit && impl_trait {\n                 let mut err = struct_span_err! {"}, {"sha": "ec1f654d44b1ea8c1bb014a03c2cf8b6cd1298b6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -641,12 +641,12 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n     let generics = tcx.generics_of(def_id);\n     let parent = tcx.generics_of(generics.parent.unwrap());\n-    let impl_params: FxHashMap<_, _> = parent.types\n-                                       .iter()\n-                                       .map(|tp| (tp.name, tp.def_id))\n-                                       .collect();\n+    let impl_params: FxHashMap<_, _> = parent.types()\n+                                             .iter()\n+                                             .map(|tp| (tp.name, tp.def_id))\n+                                             .collect();\n \n-    for method_param in &generics.types {\n+    for method_param in generics.types() {\n         if impl_params.contains_key(&method_param.name) {\n             // Tighten up the span to focus on only the shadowing type\n             let type_span = tcx.def_span(method_param.def_id);"}, {"sha": "bb308668869178716d505c2a551be22b60018c29", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -881,8 +881,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         assert_eq!(has_self, false);\n         parent_has_self = generics.has_self;\n         own_start = generics.count() as u32;\n-        (generics.parent_regions + generics.regions.len() as u32,\n-            generics.parent_types + generics.types.len() as u32)\n+        (generics.parent_lifetimes() + generics.lifetimes().len() as u32,\n+            generics.parent_types() + generics.types().len() as u32)\n     });\n \n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n@@ -971,12 +971,17 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    .map(|param| (param.def_id, param.index))\n                                    .collect();\n \n+    let parent_parameters = vec![parent_regions, parent_types];\n+    let lifetimes: Vec<ty::GenericParameterDef> =\n+        regions.into_iter().map(|lt| ty::GenericParameterDef::Lifetime(lt)).collect();\n+    let types: Vec<ty::GenericParameterDef> =\n+        types.into_iter().map(|ty| ty::GenericParameterDef::Type(ty)).collect();\n+    let parameters = lifetimes.into_iter().chain(types.into_iter()).collect();\n+\n     tcx.alloc_generics(ty::Generics {\n         parent: parent_def_id,\n-        parent_regions,\n-        parent_types,\n-        regions,\n-        types,\n+        parent_parameters,\n+        parameters,\n         type_param_to_index,\n         has_self: has_self || parent_has_self,\n         has_late_bound_regions: has_late_bound_regions(tcx, node),"}, {"sha": "fe51e182044c89976f0d61ef01a27468821d8fff", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -105,7 +105,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx, &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n \n     // Disallow ANY unconstrained type parameters.\n-    for (ty_param, param) in impl_generics.types.iter().zip(impl_hir_generics.ty_params()) {\n+    for (ty_param, param) in impl_generics.types().iter().zip(impl_hir_generics.ty_params()) {\n         let param_ty = ty::ParamTy::for_def(ty_param);\n         if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n             report_unused_parameter(tcx, param.span, \"type\", &param_ty.to_string());\n@@ -122,7 +122,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         .flat_map(|def_id| {\n             ctp::parameters_for(&tcx.type_of(def_id), true)\n         }).collect();\n-    for (ty_lifetime, lifetime) in impl_generics.regions.iter()\n+    for (ty_lifetime, lifetime) in impl_generics.lifetimes().iter()\n         .zip(impl_hir_generics.lifetimes())\n     {\n         let param = ctp::Parameter::from(ty_lifetime.to_early_bound_region_data());"}, {"sha": "7601bac67b066e81bdeac6d613f5f3ceccb0a0bb", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -225,30 +225,28 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n     fn generics_to_path_params(&self, generics: ty::Generics) -> hir::PathParameters {\n         let lifetimes = HirVec::from_vec(\n-            generics\n-                .regions\n-                .iter()\n-                .map(|p| {\n-                    let name = if p.name == \"\" {\n-                        hir::LifetimeName::Static\n-                    } else {\n-                        hir::LifetimeName::Name(p.name.as_symbol())\n-                    };\n+            generics.lifetimes()\n+                    .iter()\n+                    .map(|p| {\n+                        let name = if p.name == \"\" {\n+                            hir::LifetimeName::Static\n+                        } else {\n+                            hir::LifetimeName::Name(p.name.as_symbol())\n+                        };\n \n-                    hir::Lifetime {\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: DUMMY_SP,\n-                        name,\n-                    }\n-                })\n-                .collect(),\n+                        hir::Lifetime {\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: DUMMY_SP,\n+                            name,\n+                        }\n+                    })\n+                    .collect(),\n         );\n         let types = HirVec::from_vec(\n-            generics\n-                .types\n-                .iter()\n-                .map(|p| P(self.ty_param_to_ty(p.clone())))\n-                .collect(),\n+            generics.types()\n+                    .into_iter()\n+                    .map(|p| P(self.ty_param_to_ty(p.clone())))\n+                    .collect(),\n         );\n \n         hir::PathParameters {"}, {"sha": "eec92184ac49dec4c95366330a800aa590279e46", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fe0c119e7da2e9b068dd54bb88e8acb23d31bfa4", "patch": "@@ -1800,7 +1800,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens.types.iter().filter_map(|tp| {\n+        let stripped_typarams = gens.types().iter().filter_map(|tp| {\n             if tp.name == keywords::SelfType.name().as_str() {\n                 assert_eq!(tp.index, 0);\n                 None\n@@ -1849,16 +1849,15 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         // and instead see `where T: Foo + Bar + Sized + 'a`\n \n         Generics {\n-            params: gens.regions\n-                .clean(cx)\n-                .into_iter()\n-                .map(|lp| GenericParam::Lifetime(lp))\n-                .chain(\n-                    simplify::ty_params(stripped_typarams)\n+            params: gens.lifetimes()\n                         .into_iter()\n-                        .map(|tp| GenericParam::Type(tp))\n-                )\n-                .collect(),\n+                        .map(|lp| GenericParam::Lifetime(lp.clean(cx)))\n+                        .chain(\n+                            simplify::ty_params(stripped_typarams)\n+                                .into_iter()\n+                                .map(|tp| GenericParam::Type(tp))\n+                        )\n+                        .collect(),\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n         }\n     }"}]}