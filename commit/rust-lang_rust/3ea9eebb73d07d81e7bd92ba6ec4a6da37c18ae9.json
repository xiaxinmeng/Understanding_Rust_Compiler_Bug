{"sha": "3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "node_id": "C_kwDOAAsO6NoAKDNlYTllZWJiNzNkMDdkODFlN2JkOTJiYTZlYzRhNmRhMzdjMThhZTk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-02T03:30:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-02T03:30:12Z"}, "message": "Rollup merge of #94503 - joshtriplett:core-ffi-c, r=Amanieu\n\nProvide C FFI types via core::ffi, not just in std\n\nTracking issue: https://github.com/rust-lang/rust/issues/94501\n\nThe ability to interoperate with C code via FFI is not limited to crates\nusing std; this allows using these types without std.\n\nThe existing types in `std::os::raw` become type aliases for the ones in\n`core::ffi`. This uses type aliases rather than re-exports, to allow the\nstd types to remain stable while the core types are unstable.\n\nThis also moves the currently unstable `NonZero_` variants and\n`c_size_t`/`c_ssize_t`/`c_ptrdiff_t` types to `core::ffi`, while leaving\nthem unstable.\n\nHistorically, we didn't do this because these types are target-dependent.\nHowever, `core` itself is also target-dependent. `core` should not call\nany OS services, but it knows the target and the target's ABI.", "tree": {"sha": "9d25d306754e0262bf37f18e5f054ac733e9842a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d25d306754e0262bf37f18e5f054ac733e9842a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiHuTFCRBK7hj4Ov3rIwAAu9UIAH4nyH78MX12mtPySllGUcbU\nmVR4F32yGMZe0f3sXP+DMc6zejvsOoyC6QC6ee9rHsn7/qS1q2nsbY5vzxI5NWjp\notC2p+XYWQO/94kn3nPS0HXpuFakEPdVO8IPZHE6Ob8WAklqtEcQH1PfVS+O7eQz\nTr4AHXWIq6e+RwTE5JHsdtYWfZgxbci+AChxfRU+9t5afv0qnF5BhPg2bMLQsUf/\nnTYLVklYpcGk+4YLb7T4m22aS/4hD4tznPro8MSGdXFYTRjAprYonentkPHlYqgt\ndKsBYI/cBX1bq8t2ICf/f4Rp02p9XMCHxjcMdDmN1nqkMQxqu+PWi0gpCitk868=\n=n/5I\n-----END PGP SIGNATURE-----\n", "payload": "tree 9d25d306754e0262bf37f18e5f054ac733e9842a\nparent 1ff654af3922096737fa8642c238338305585639\nparent 75c3e9c23f07b275548998555883e34e39896587\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1646191812 +0100\ncommitter GitHub <noreply@github.com> 1646191812 +0100\n\nRollup merge of #94503 - joshtriplett:core-ffi-c, r=Amanieu\n\nProvide C FFI types via core::ffi, not just in std\n\nTracking issue: https://github.com/rust-lang/rust/issues/94501\n\nThe ability to interoperate with C code via FFI is not limited to crates\nusing std; this allows using these types without std.\n\nThe existing types in `std::os::raw` become type aliases for the ones in\n`core::ffi`. This uses type aliases rather than re-exports, to allow the\nstd types to remain stable while the core types are unstable.\n\nThis also moves the currently unstable `NonZero_` variants and\n`c_size_t`/`c_ssize_t`/`c_ptrdiff_t` types to `core::ffi`, while leaving\nthem unstable.\n\nHistorically, we didn't do this because these types are target-dependent.\nHowever, `core` itself is also target-dependent. `core` should not call\nany OS services, but it knows the target and the target's ABI.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "html_url": "https://github.com/rust-lang/rust/commit/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff654af3922096737fa8642c238338305585639", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff654af3922096737fa8642c238338305585639", "html_url": "https://github.com/rust-lang/rust/commit/1ff654af3922096737fa8642c238338305585639"}, {"sha": "75c3e9c23f07b275548998555883e34e39896587", "url": "https://api.github.com/repos/rust-lang/rust/commits/75c3e9c23f07b275548998555883e34e39896587", "html_url": "https://github.com/rust-lang/rust/commit/75c3e9c23f07b275548998555883e34e39896587"}], "stats": {"total": 451, "additions": 283, "deletions": 168}, "files": [{"sha": "b262a3663b3c146d37066c51eda7d8cf6ac22584", "filename": "library/core/src/ffi/c_char.md", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_char.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_char.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_char.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -2,8 +2,7 @@ Equivalent to C's `char` type.\n \n [C's `char` type] is completely unlike [Rust's `char` type]; while Rust's type represents a unicode scalar value, C's `char` type is just an ordinary integer. On modern architectures this type will always be either [`i8`] or [`u8`], as they use byte-addresses memory with 8-bit bytes.\n \n-C chars are most commonly used to make C strings. Unlike Rust, where the length of a string is included alongside the string, C strings mark the end of a string with the character `'\\0'`. See [`CStr`] for more information.\n+C chars are most commonly used to make C strings. Unlike Rust, where the length of a string is included alongside the string, C strings mark the end of a string with the character `'\\0'`. See `CStr` for more information.\n \n [C's `char` type]: https://en.wikipedia.org/wiki/C_data_types#Basic_types\n [Rust's `char` type]: char\n-[`CStr`]: crate::ffi::CStr", "previous_filename": "library/std/src/os/raw/char.md"}, {"sha": "57f4534829ec834a1b69ae377b393adc3dfd0519", "filename": "library/core/src/ffi/c_double.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_double.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/double.md"}, {"sha": "61e2abc05189df2e12d7fa1b77894868f3e2d269", "filename": "library/core/src/ffi/c_float.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_float.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/float.md"}, {"sha": "8062ff2307a9537ccf9007c982aa5e0eda09135e", "filename": "library/core/src/ffi/c_int.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_int.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_int.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_int.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/int.md"}, {"sha": "cc160783f78b7d5b429f92ac9e8750531ce64063", "filename": "library/core/src/ffi/c_long.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_long.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_long.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_long.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/long.md"}, {"sha": "49c61bd61f4ad71c2c569289b978b182f125c85c", "filename": "library/core/src/ffi/c_longlong.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_longlong.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_longlong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_longlong.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/longlong.md"}, {"sha": "69879c9f17f4d80af70250424ed18558942cdc5c", "filename": "library/core/src/ffi/c_schar.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_schar.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_schar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_schar.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/schar.md"}, {"sha": "3d1e53d1325f31a12fee0825a30a8e89a2c0c857", "filename": "library/core/src/ffi/c_short.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_short.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_short.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_short.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/short.md"}, {"sha": "b633bb7f8dacf5bf2ca300d0ab0a793acbbc3a49", "filename": "library/core/src/ffi/c_uchar.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_uchar.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_uchar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_uchar.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/uchar.md"}, {"sha": "f3abea35937abd712a916313955b86932570fb00", "filename": "library/core/src/ffi/c_uint.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_uint.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_uint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_uint.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/uint.md"}, {"sha": "4ab304e65777326eeef30e4e950e0296bb38881b", "filename": "library/core/src/ffi/c_ulong.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_ulong.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_ulong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_ulong.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/ulong.md"}, {"sha": "a27d70e17537d440fcddae685df71b4e1d6a9fd8", "filename": "library/core/src/ffi/c_ulonglong.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_ulonglong.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_ulonglong.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_ulonglong.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/ulonglong.md"}, {"sha": "6928e51b352c82d2a5aa413f20c402f4ff28dca4", "filename": "library/core/src/ffi/c_ushort.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_ushort.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_ushort.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_ushort.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "previous_filename": "library/std/src/os/raw/ushort.md"}, {"sha": "ee7403aa04099ecbfbaca2881efbe9e6dda76499", "filename": "library/core/src/ffi/c_void.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_void.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fc_void.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_void.md?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -0,0 +1,16 @@\n+Equivalent to C's `void` type when used as a [pointer].\n+\n+In essence, `*const c_void` is equivalent to C's `const void*`\n+and `*mut c_void` is equivalent to C's `void*`. That said, this is\n+*not* the same as C's `void` return type, which is Rust's `()` type.\n+\n+To model pointers to opaque types in FFI, until `extern type` is\n+stabilized, it is recommended to use a newtype wrapper around an empty\n+byte array. See the [Nomicon] for details.\n+\n+One could use `std::os::raw::c_void` if they want to support old Rust\n+compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by\n+this definition. For more information, please read [RFC 2521].\n+\n+[Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs\n+[RFC 2521]: https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md"}, {"sha": "e5255686ff984432a003a619221b323ab06502f8", "filename": "library/core/src/ffi/mod.rs", "status": "renamed", "additions": 145, "deletions": 15, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -1,28 +1,157 @@\n+//! Platform-specific types, as defined by C.\n+//!\n+//! Code that interacts via FFI will almost certainly be using the\n+//! base types provided by C, which aren't nearly as nicely defined\n+//! as Rust's primitive types. This module provides types which will\n+//! match those defined by C, so that code that interacts with C will\n+//! refer to the correct types.\n+\n #![stable(feature = \"\", since = \"1.30.0\")]\n #![allow(non_camel_case_types)]\n \n-//! Utilities related to foreign function interface (FFI) bindings.\n-\n use crate::fmt;\n use crate::marker::PhantomData;\n+use crate::num::*;\n use crate::ops::{Deref, DerefMut};\n \n-/// Equivalent to C's `void` type when used as a [pointer].\n-///\n-/// In essence, `*const c_void` is equivalent to C's `const void*`\n-/// and `*mut c_void` is equivalent to C's `void*`. That said, this is\n-/// *not* the same as C's `void` return type, which is Rust's `()` type.\n+macro_rules! type_alias_no_nz {\n+    {\n+      $Docfile:tt, $Alias:ident = $Real:ty;\n+      $( $Cfg:tt )*\n+    } => {\n+        #[doc = include_str!($Docfile)]\n+        $( $Cfg )*\n+        #[unstable(feature = \"core_ffi_c\", issue = \"94501\")]\n+        pub type $Alias = $Real;\n+    }\n+}\n+\n+// To verify that the NonZero types in this file's macro invocations correspond\n+//\n+//  perl -n < library/std/src/os/raw/mod.rs -e 'next unless m/type_alias\\!/; die \"$_ ?\" unless m/, (c_\\w+) = (\\w+), NonZero_(\\w+) = NonZero(\\w+)/; die \"$_ ?\" unless $3 eq $1 and $4 eq ucfirst $2'\n+//\n+// NB this does not check that the main c_* types are right.\n+\n+macro_rules! type_alias {\n+    {\n+      $Docfile:tt, $Alias:ident = $Real:ty, $NZAlias:ident = $NZReal:ty;\n+      $( $Cfg:tt )*\n+    } => {\n+        type_alias_no_nz! { $Docfile, $Alias = $Real; $( $Cfg )* }\n+\n+        #[doc = concat!(\"Type alias for `NonZero` version of [`\", stringify!($Alias), \"`]\")]\n+        #[unstable(feature = \"raw_os_nonzero\", issue = \"82363\")]\n+        $( $Cfg )*\n+        pub type $NZAlias = $NZReal;\n+    }\n+}\n+\n+type_alias! { \"c_char.md\", c_char = c_char_definition::c_char, NonZero_c_char = c_char_definition::NonZero_c_char;\n+// Make this type alias appear cfg-dependent so that Clippy does not suggest\n+// replacing `0 as c_char` with `0_i8`/`0_u8`. This #[cfg(all())] can be removed\n+// after the false positive in https://github.com/rust-lang/rust-clippy/issues/8093\n+// is fixed.\n+#[cfg(all())]\n+#[doc(cfg(all()))] }\n+type_alias! { \"c_schar.md\", c_schar = i8, NonZero_c_schar = NonZeroI8; }\n+type_alias! { \"c_uchar.md\", c_uchar = u8, NonZero_c_uchar = NonZeroU8; }\n+type_alias! { \"c_short.md\", c_short = i16, NonZero_c_short = NonZeroI16; }\n+type_alias! { \"c_ushort.md\", c_ushort = u16, NonZero_c_ushort = NonZeroU16; }\n+type_alias! { \"c_int.md\", c_int = i32, NonZero_c_int = NonZeroI32; }\n+type_alias! { \"c_uint.md\", c_uint = u32, NonZero_c_uint = NonZeroU32; }\n+type_alias! { \"c_long.md\", c_long = i32, NonZero_c_long = NonZeroI32;\n+#[doc(cfg(all()))]\n+#[cfg(any(target_pointer_width = \"32\", windows))] }\n+type_alias! { \"c_ulong.md\", c_ulong = u32, NonZero_c_ulong = NonZeroU32;\n+#[doc(cfg(all()))]\n+#[cfg(any(target_pointer_width = \"32\", windows))] }\n+type_alias! { \"c_long.md\", c_long = i64, NonZero_c_long = NonZeroI64;\n+#[doc(cfg(all()))]\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n+type_alias! { \"c_ulong.md\", c_ulong = u64, NonZero_c_ulong = NonZeroU64;\n+#[doc(cfg(all()))]\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n+type_alias! { \"c_longlong.md\", c_longlong = i64, NonZero_c_longlong = NonZeroI64; }\n+type_alias! { \"c_ulonglong.md\", c_ulonglong = u64, NonZero_c_ulonglong = NonZeroU64; }\n+type_alias_no_nz! { \"c_float.md\", c_float = f32; }\n+type_alias_no_nz! { \"c_double.md\", c_double = f64; }\n+\n+/// Equivalent to C's `size_t` type, from `stddef.h` (or `cstddef` for C++).\n ///\n-/// To model pointers to opaque types in FFI, until `extern type` is\n-/// stabilized, it is recommended to use a newtype wrapper around an empty\n-/// byte array. See the [Nomicon] for details.\n+/// This type is currently always [`usize`], however in the future there may be\n+/// platforms where this is not the case.\n+#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n+pub type c_size_t = usize;\n+\n+/// Equivalent to C's `ptrdiff_t` type, from `stddef.h` (or `cstddef` for C++).\n ///\n-/// One could use `std::os::raw::c_void` if they want to support old Rust\n-/// compiler down to 1.1.0. After Rust 1.30.0, it was re-exported by\n-/// this definition. For more information, please read [RFC 2521].\n+/// This type is currently always [`isize`], however in the future there may be\n+/// platforms where this is not the case.\n+#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n+pub type c_ptrdiff_t = isize;\n+\n+/// Equivalent to C's `ssize_t` (on POSIX) or `SSIZE_T` (on Windows) type.\n ///\n-/// [Nomicon]: https://doc.rust-lang.org/nomicon/ffi.html#representing-opaque-structs\n-/// [RFC 2521]: https://github.com/rust-lang/rfcs/blob/master/text/2521-c_void-reunification.md\n+/// This type is currently always [`isize`], however in the future there may be\n+/// platforms where this is not the case.\n+#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n+pub type c_ssize_t = isize;\n+\n+mod c_char_definition {\n+    cfg_if! {\n+        // These are the targets on which c_char is unsigned.\n+        if #[cfg(any(\n+            all(\n+                target_os = \"linux\",\n+                any(\n+                    target_arch = \"aarch64\",\n+                    target_arch = \"arm\",\n+                    target_arch = \"hexagon\",\n+                    target_arch = \"powerpc\",\n+                    target_arch = \"powerpc64\",\n+                    target_arch = \"s390x\",\n+                    target_arch = \"riscv64\",\n+                    target_arch = \"riscv32\"\n+                )\n+            ),\n+            all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n+            all(target_os = \"l4re\", target_arch = \"x86_64\"),\n+            all(\n+                target_os = \"freebsd\",\n+                any(\n+                    target_arch = \"aarch64\",\n+                    target_arch = \"arm\",\n+                    target_arch = \"powerpc\",\n+                    target_arch = \"powerpc64\",\n+                    target_arch = \"riscv64\"\n+                )\n+            ),\n+            all(\n+                target_os = \"netbsd\",\n+                any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n+            ),\n+            all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n+            all(\n+                target_os = \"vxworks\",\n+                any(\n+                    target_arch = \"aarch64\",\n+                    target_arch = \"arm\",\n+                    target_arch = \"powerpc64\",\n+                    target_arch = \"powerpc\"\n+                )\n+            ),\n+            all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n+        ))] {\n+            pub type c_char = u8;\n+            pub type NonZero_c_char = crate::num::NonZeroU8;\n+        } else {\n+            // On every other target, c_char is signed.\n+            pub type c_char = i8;\n+            pub type NonZero_c_char = crate::num::NonZeroI8;\n+        }\n+    }\n+}\n+\n // N.B., for LLVM to recognize the void pointer type and by extension\n //     functions like malloc(), we need to have it represented as i8* in\n //     LLVM bitcode. The enum used here ensures this and prevents misuse\n@@ -31,6 +160,7 @@ use crate::ops::{Deref, DerefMut};\n //     otherwise and we need at least one variant as otherwise the enum\n //     would be uninhabited and at least dereferencing such pointers would\n //     be UB.\n+#[doc = include_str!(\"c_void.md\")]\n #[repr(u8)]\n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub enum c_void {", "previous_filename": "library/core/src/ffi.rs"}, {"sha": "417ed51c6b6a23063b3a84355397aea07d1cca20", "filename": "library/core/src/internal_macros.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fcore%2Fsrc%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Finternal_macros.rs?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -187,3 +187,96 @@ macro_rules! impl_fn_for_zst {\n         )+\n     }\n }\n+\n+/// A macro for defining `#[cfg]` if-else statements.\n+///\n+/// `cfg_if` is similar to the `if/elif` C preprocessor macro by allowing definition of a cascade\n+/// of `#[cfg]` cases, emitting the implementation which matches first.\n+///\n+/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code without having to\n+/// rewrite each clause multiple times.\n+///\n+/// # Example\n+///\n+/// ```\n+/// cfg_if! {\n+///     if #[cfg(unix)] {\n+///         fn foo() { /* unix specific functionality */ }\n+///     } else if #[cfg(target_pointer_width = \"32\")] {\n+///         fn foo() { /* non-unix, 32-bit functionality */ }\n+///     } else {\n+///         fn foo() { /* fallback implementation */ }\n+///     }\n+/// }\n+///\n+/// # fn main() {}\n+/// ```\n+// This is a copy of `cfg_if!` from the `cfg_if` crate.\n+// The recursive invocations should use $crate if this is ever exported.\n+macro_rules! cfg_if {\n+    // match if/else chains with a final `else`\n+    (\n+        $(\n+            if #[cfg( $i_meta:meta )] { $( $i_tokens:tt )* }\n+        ) else+\n+        else { $( $e_tokens:tt )* }\n+    ) => {\n+        cfg_if! {\n+            @__items () ;\n+            $(\n+                (( $i_meta ) ( $( $i_tokens )* )) ,\n+            )+\n+            (() ( $( $e_tokens )* )) ,\n+        }\n+    };\n+\n+    // match if/else chains lacking a final `else`\n+    (\n+        if #[cfg( $i_meta:meta )] { $( $i_tokens:tt )* }\n+        $(\n+            else if #[cfg( $e_meta:meta )] { $( $e_tokens:tt )* }\n+        )*\n+    ) => {\n+        cfg_if! {\n+            @__items () ;\n+            (( $i_meta ) ( $( $i_tokens )* )) ,\n+            $(\n+                (( $e_meta ) ( $( $e_tokens )* )) ,\n+            )*\n+        }\n+    };\n+\n+    // Internal and recursive macro to emit all the items\n+    //\n+    // Collects all the previous cfgs in a list at the beginning, so they can be\n+    // negated. After the semicolon is all the remaining items.\n+    (@__items ( $( $_:meta , )* ) ; ) => {};\n+    (\n+        @__items ( $( $no:meta , )* ) ;\n+        (( $( $yes:meta )? ) ( $( $tokens:tt )* )) ,\n+        $( $rest:tt , )*\n+    ) => {\n+        // Emit all items within one block, applying an appropriate #[cfg]. The\n+        // #[cfg] will require all `$yes` matchers specified and must also negate\n+        // all previous matchers.\n+        #[cfg(all(\n+            $( $yes , )?\n+            not(any( $( $no ),* ))\n+        ))]\n+        cfg_if! { @__identity $( $tokens )* }\n+\n+        // Recurse to emit all other items in `$rest`, and when we do so add all\n+        // our `$yes` matchers to the list of `$no` matchers as future emissions\n+        // will have to negate everything we just matched as well.\n+        cfg_if! {\n+            @__items ( $( $no , )* $( $yes , )? ) ;\n+            $( $rest , )*\n+        }\n+    };\n+\n+    // Internal macro to make __apply work out right for different match types,\n+    // because of how macros match/expand stuff.\n+    (@__identity $( $tokens:tt )* ) => {\n+        $( $tokens )*\n+    };\n+}"}, {"sha": "4603b5aae20b05902c1efb4942b37c16ce216e19", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -261,6 +261,7 @@\n #![feature(const_socketaddr)]\n #![feature(const_trait_impl)]\n #![feature(container_error_extra)]\n+#![feature(core_ffi_c)]\n #![feature(core_intrinsics)]\n #![feature(core_panic)]\n #![feature(custom_test_frameworks)]\n@@ -315,6 +316,7 @@\n #![feature(prelude_import)]\n #![feature(ptr_as_uninit)]\n #![feature(ptr_internals)]\n+#![feature(raw_os_nonzero)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]\n #![feature(saturating_int_impl)]"}, {"sha": "19d0ffb2e39cbac533ee4016faf2ca6612a5a053", "filename": "library/std/src/os/raw/mod.rs", "status": "modified", "additions": 21, "deletions": 146, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -1,156 +1,31 @@\n-//! Platform-specific types, as defined by C.\n-//!\n-//! Code that interacts via FFI will almost certainly be using the\n-//! base types provided by C, which aren't nearly as nicely defined\n-//! as Rust's primitive types. This module provides types which will\n-//! match those defined by C, so that code that interacts with C will\n-//! refer to the correct types.\n+//! Compatibility module for C platform-specific types. Use [`core::ffi`] instead.\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n #[cfg(test)]\n mod tests;\n \n-use core::num::*;\n-\n-macro_rules! type_alias_no_nz {\n-    {\n-      $Docfile:tt, $Alias:ident = $Real:ty;\n-      $( $Cfg:tt )*\n-    } => {\n-        #[doc = include_str!($Docfile)]\n-        $( $Cfg )*\n+macro_rules! alias_core_ffi {\n+    ($($t:ident)*) => {$(\n         #[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-        pub type $Alias = $Real;\n-    }\n-}\n-\n-// To verify that the NonZero types in this file's macro invocations correspond\n-//\n-//  perl -n < library/std/src/os/raw/mod.rs -e 'next unless m/type_alias\\!/; die \"$_ ?\" unless m/, (c_\\w+) = (\\w+), NonZero_(\\w+) = NonZero(\\w+)/; die \"$_ ?\" unless $3 eq $1 and $4 eq ucfirst $2'\n-//\n-// NB this does not check that the main c_* types are right.\n-\n-macro_rules! type_alias {\n-    {\n-      $Docfile:tt, $Alias:ident = $Real:ty, $NZAlias:ident = $NZReal:ty;\n-      $( $Cfg:tt )*\n-    } => {\n-        type_alias_no_nz! { $Docfile, $Alias = $Real; $( $Cfg )* }\n-\n-        #[doc = concat!(\"Type alias for `NonZero` version of [`\", stringify!($Alias), \"`]\")]\n-        #[unstable(feature = \"raw_os_nonzero\", issue = \"82363\")]\n-        $( $Cfg )*\n-        pub type $NZAlias = $NZReal;\n-    }\n+        #[doc = include_str!(concat!(\"../../../../core/src/ffi/\", stringify!($t), \".md\"))]\n+        // Make this type alias appear cfg-dependent so that Clippy does not suggest\n+        // replacing expressions like `0 as c_char` with `0_i8`/`0_u8`. This #[cfg(all())] can be\n+        // removed after the false positive in https://github.com/rust-lang/rust-clippy/issues/8093\n+        // is fixed.\n+        #[cfg(all())]\n+        #[doc(cfg(all()))]\n+        pub type $t = core::ffi::$t;\n+    )*}\n }\n \n-type_alias! { \"char.md\", c_char = c_char_definition::c_char, NonZero_c_char = c_char_definition::NonZero_c_char;\n-// Make this type alias appear cfg-dependent so that Clippy does not suggest\n-// replacing `0 as c_char` with `0_i8`/`0_u8`. This #[cfg(all())] can be removed\n-// after the false positive in https://github.com/rust-lang/rust-clippy/issues/8093\n-// is fixed.\n-#[cfg(all())]\n-#[doc(cfg(all()))] }\n-type_alias! { \"schar.md\", c_schar = i8, NonZero_c_schar = NonZeroI8; }\n-type_alias! { \"uchar.md\", c_uchar = u8, NonZero_c_uchar = NonZeroU8; }\n-type_alias! { \"short.md\", c_short = i16, NonZero_c_short = NonZeroI16; }\n-type_alias! { \"ushort.md\", c_ushort = u16, NonZero_c_ushort = NonZeroU16; }\n-type_alias! { \"int.md\", c_int = i32, NonZero_c_int = NonZeroI32; }\n-type_alias! { \"uint.md\", c_uint = u32, NonZero_c_uint = NonZeroU32; }\n-type_alias! { \"long.md\", c_long = i32, NonZero_c_long = NonZeroI32;\n-#[doc(cfg(all()))]\n-#[cfg(any(target_pointer_width = \"32\", windows))] }\n-type_alias! { \"ulong.md\", c_ulong = u32, NonZero_c_ulong = NonZeroU32;\n-#[doc(cfg(all()))]\n-#[cfg(any(target_pointer_width = \"32\", windows))] }\n-type_alias! { \"long.md\", c_long = i64, NonZero_c_long = NonZeroI64;\n-#[doc(cfg(all()))]\n-#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n-type_alias! { \"ulong.md\", c_ulong = u64, NonZero_c_ulong = NonZeroU64;\n-#[doc(cfg(all()))]\n-#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n-type_alias! { \"longlong.md\", c_longlong = i64, NonZero_c_longlong = NonZeroI64; }\n-type_alias! { \"ulonglong.md\", c_ulonglong = u64, NonZero_c_ulonglong = NonZeroU64; }\n-type_alias_no_nz! { \"float.md\", c_float = f32; }\n-type_alias_no_nz! { \"double.md\", c_double = f64; }\n-\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-#[doc(no_inline)]\n-pub use core::ffi::c_void;\n-\n-/// Equivalent to C's `size_t` type, from `stddef.h` (or `cstddef` for C++).\n-///\n-/// This type is currently always [`usize`], however in the future there may be\n-/// platforms where this is not the case.\n-#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n-pub type c_size_t = usize;\n-\n-/// Equivalent to C's `ptrdiff_t` type, from `stddef.h` (or `cstddef` for C++).\n-///\n-/// This type is currently always [`isize`], however in the future there may be\n-/// platforms where this is not the case.\n-#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n-pub type c_ptrdiff_t = isize;\n-\n-/// Equivalent to C's `ssize_t` (on POSIX) or `SSIZE_T` (on Windows) type.\n-///\n-/// This type is currently always [`isize`], however in the future there may be\n-/// platforms where this is not the case.\n-#[unstable(feature = \"c_size_t\", issue = \"88345\")]\n-pub type c_ssize_t = isize;\n-\n-mod c_char_definition {\n-    cfg_if::cfg_if! {\n-        // These are the targets on which c_char is unsigned.\n-        if #[cfg(any(\n-            all(\n-                target_os = \"linux\",\n-                any(\n-                    target_arch = \"aarch64\",\n-                    target_arch = \"arm\",\n-                    target_arch = \"hexagon\",\n-                    target_arch = \"powerpc\",\n-                    target_arch = \"powerpc64\",\n-                    target_arch = \"s390x\",\n-                    target_arch = \"riscv64\",\n-                    target_arch = \"riscv32\"\n-                )\n-            ),\n-            all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n-            all(target_os = \"l4re\", target_arch = \"x86_64\"),\n-            all(\n-                target_os = \"freebsd\",\n-                any(\n-                    target_arch = \"aarch64\",\n-                    target_arch = \"arm\",\n-                    target_arch = \"powerpc\",\n-                    target_arch = \"powerpc64\",\n-                    target_arch = \"riscv64\"\n-                )\n-            ),\n-            all(\n-                target_os = \"netbsd\",\n-                any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n-            ),\n-            all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n-            all(\n-                target_os = \"vxworks\",\n-                any(\n-                    target_arch = \"aarch64\",\n-                    target_arch = \"arm\",\n-                    target_arch = \"powerpc64\",\n-                    target_arch = \"powerpc\"\n-                )\n-            ),\n-            all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n-        ))] {\n-            pub type c_char = u8;\n-            pub type NonZero_c_char = core::num::NonZeroU8;\n-        } else {\n-            // On every other target, c_char is signed.\n-            pub type c_char = i8;\n-            pub type NonZero_c_char = core::num::NonZeroI8;\n-        }\n-    }\n+alias_core_ffi! {\n+    c_char c_schar c_uchar\n+    c_short c_ushort\n+    c_int c_uint\n+    c_long c_ulong\n+    c_longlong c_ulonglong\n+    c_float\n+    c_double\n+    c_void\n }"}, {"sha": "07a0339c066bc9b23207be9d50e9bc4a73ba9dd2", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -3,11 +3,11 @@ use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n use crate::num::NonZeroI32;\n-use crate::os::raw::NonZero_c_int;\n use crate::ptr;\n use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n+use core::ffi::NonZero_c_int;\n \n #[cfg(target_os = \"linux\")]\n use crate::os::linux::process::PidFd;"}, {"sha": "bbabdf787d994dce53d3d4f6731508d47f54466d", "filename": "library/std/src/sys/unix/process/process_unsupported.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -3,12 +3,12 @@ use crate::fmt;\n use crate::io;\n use crate::io::ErrorKind;\n use crate::num::NonZeroI32;\n-use crate::os::raw::NonZero_c_int;\n use crate::sys;\n use crate::sys::cvt;\n use crate::sys::pipe::AnonPipe;\n use crate::sys::process::process_common::*;\n use crate::sys::unix::unsupported::*;\n+use core::ffi::NonZero_c_int;\n \n use libc::{c_int, pid_t};\n "}, {"sha": "56ed6cfeb6a6b891101b10cdf3677ded11257b64", "filename": "library/std/src/sys/unix/process/process_vxworks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -2,11 +2,11 @@ use crate::convert::{TryFrom, TryInto};\n use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::num::NonZeroI32;\n-use crate::os::raw::NonZero_c_int;\n use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n use crate::sys_common::thread;\n+use core::ffi::NonZero_c_int;\n use libc::RTP_ID;\n use libc::{self, c_char, c_int};\n "}, {"sha": "2affd7e75b03082b3f49d2a2f2e4dcb1c9007932", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -5,9 +5,9 @@\n #![unstable(issue = \"none\", feature = \"windows_c\")]\n \n use crate::mem;\n-use crate::os::raw::NonZero_c_ulong;\n use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n use crate::ptr;\n+use core::ffi::NonZero_c_ulong;\n \n use libc::{c_void, size_t, wchar_t};\n "}, {"sha": "f5ff3860afe344ee7f4491771bb71394fb60d886", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=3ea9eebb73d07d81e7bd92ba6ec4a6da37c18ae9", "patch": "@@ -46,7 +46,7 @@ const EXCEPTION_PATHS: &[&str] = &[\n     // pointer regardless of the target architecture. As a result,\n     // we must use `#[cfg(windows)]` to conditionally compile the\n     // correct `VaList` structure for windows.\n-    \"library/core/src/ffi.rs\",\n+    \"library/core/src/ffi/mod.rs\",\n     \"library/std/src/sys/\", // Platform-specific code for std lives here.\n     \"library/std/src/os\",   // Platform-specific public interfaces\n     // Temporary `std` exceptions"}]}