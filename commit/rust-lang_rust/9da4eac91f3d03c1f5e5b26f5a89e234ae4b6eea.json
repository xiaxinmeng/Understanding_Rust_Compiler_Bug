{"sha": "9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYTRlYWM5MWYzZDAzYzFmNWU1YjI2ZjVhODllMjM0YWU0YjZlZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-08T08:56:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-08T08:56:35Z"}, "message": "auto merge of #11391 : alexcrichton/rust/rustdoc-inline, r=brson\n\nIf a reexport comes from a non-public module, then the documentation for the\r\nreexport will be inlined into the module that exports it, but if the reexport is\r\ntargeted at a public type (like the prelude), then it is not inlined but rather\r\nhyperlinked.", "tree": {"sha": "6265cce84a9bf7f151dde172e71802652328596c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6265cce84a9bf7f151dde172e71802652328596c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "html_url": "https://github.com/rust-lang/rust/commit/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a121f7bab3fe21f03cef6e214d5771bfe669e48c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a121f7bab3fe21f03cef6e214d5771bfe669e48c", "html_url": "https://github.com/rust-lang/rust/commit/a121f7bab3fe21f03cef6e214d5771bfe669e48c"}, {"sha": "3425901d934f9e897b76f42309670285293df902", "url": "https://api.github.com/repos/rust-lang/rust/commits/3425901d934f9e897b76f42309670285293df902", "html_url": "https://github.com/rust-lang/rust/commit/3425901d934f9e897b76f42309670285293df902"}], "stats": {"total": 438, "additions": 289, "deletions": 149}, "files": [{"sha": "46bdbab2257fdc57b3c91b20d71a001e5651966c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "patch": "@@ -209,6 +209,7 @@ pub fn phase_2_configure_and_expand(sess: Session,\n pub struct CrateAnalysis {\n     exp_map2: middle::resolve::ExportMap2,\n     exported_items: middle::privacy::ExportedItems,\n+    public_items: middle::privacy::PublicItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n     reachable: @RefCell<HashSet<ast::NodeId>>\n@@ -268,9 +269,10 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                                           method_map, ty_cx));\n \n     let maps = (external_exports, last_private_map);\n-    let exported_items = time(time_passes, \"privacy checking\", maps, |(a, b)|\n-             middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n-                                          a, b, crate));\n+    let (exported_items, public_items) =\n+            time(time_passes, \"privacy checking\", maps, |(a, b)|\n+                 middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n+                                              a, b, crate));\n \n     time(time_passes, \"effect checking\", (), |_|\n          middle::effect::check_crate(ty_cx, method_map, crate));\n@@ -322,6 +324,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         exp_map2: exp_map2,\n         ty_cx: ty_cx,\n         exported_items: exported_items,\n+        public_items: public_items,\n         maps: astencode::Maps {\n             root_map: root_map,\n             method_map: method_map,"}, {"sha": "9b297aa8792da40e800c022e17d6faf7631745fe", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "patch": "@@ -35,6 +35,11 @@ type Context<'a> = (&'a method_map, &'a resolve::ExportMap2);\n /// A set of AST nodes exported by the crate.\n pub type ExportedItems = HashSet<ast::NodeId>;\n \n+/// A set of AST nodes that are fully public in the crate. This map is used for\n+/// documentation purposes (reexporting a private struct inlines the doc,\n+/// reexporting a public struct doesn't inline the doc).\n+pub type PublicItems = HashSet<ast::NodeId>;\n+\n ////////////////////////////////////////////////////////////////////////////////\n /// The parent visitor, used to determine what's the parent of what (node-wise)\n ////////////////////////////////////////////////////////////////////////////////\n@@ -165,6 +170,12 @@ struct EmbargoVisitor<'a> {\n     // means that the destination of the reexport is exported, and hence the\n     // destination must also be exported.\n     reexports: HashSet<ast::NodeId>,\n+\n+    // These two fields are closely related to one another in that they are only\n+    // used for generation of the 'PublicItems' set, not for privacy checking at\n+    // all\n+    public_items: PublicItems,\n+    prev_public: bool,\n }\n \n impl<'a> EmbargoVisitor<'a> {\n@@ -186,7 +197,13 @@ impl<'a> EmbargoVisitor<'a> {\n \n impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::item, _: ()) {\n-        let orig_all_pub = self.prev_exported;\n+        let orig_all_pub = self.prev_public;\n+        self.prev_public = orig_all_pub && item.vis == ast::public;\n+        if self.prev_public {\n+            self.public_items.insert(item.id);\n+        }\n+\n+        let orig_all_exported = self.prev_exported;\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n             // cannot have visibility qualifiers on them anyway\n@@ -202,7 +219,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n             // `pub` is explicitly listed.\n             _ => {\n                 self.prev_exported =\n-                    (orig_all_pub && item.vis == ast::public) ||\n+                    (orig_all_exported && item.vis == ast::public) ||\n                      self.reexports.contains(&item.id);\n             }\n         }\n@@ -304,7 +321,8 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n \n         visit::walk_item(self, item, ());\n \n-        self.prev_exported = orig_all_pub;\n+        self.prev_exported = orig_all_exported;\n+        self.prev_public = orig_all_pub;\n     }\n \n     fn visit_foreign_item(&mut self, a: &ast::foreign_item, _: ()) {\n@@ -1002,7 +1020,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                    exp_map2: &resolve::ExportMap2,\n                    external_exports: resolve::ExternalExports,\n                    last_private_map: resolve::LastPrivateMap,\n-                   crate: &ast::Crate) -> ExportedItems {\n+                   crate: &ast::Crate) -> (ExportedItems, PublicItems) {\n     // Figure out who everyone's parent is\n     let mut visitor = ParentVisitor {\n         parents: HashMap::new(),\n@@ -1038,9 +1056,11 @@ pub fn check_crate(tcx: ty::ctxt,\n     let mut visitor = EmbargoVisitor {\n         tcx: tcx,\n         exported_items: HashSet::new(),\n+        public_items: HashSet::new(),\n         reexports: HashSet::new(),\n         exp_map2: exp_map2,\n         prev_exported: true,\n+        prev_public: true,\n     };\n     loop {\n         let before = visitor.exported_items.len();\n@@ -1050,5 +1070,6 @@ pub fn check_crate(tcx: ty::ctxt,\n         }\n     }\n \n-    return visitor.exported_items;\n+    let EmbargoVisitor { exported_items, public_items, .. } = visitor;\n+    return (exported_items, public_items);\n }"}, {"sha": "8e63dca57b0e8a4ad8796c19da7d01a38e47aaed", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "patch": "@@ -72,7 +72,7 @@ pub struct Crate {\n     externs: HashMap<ast::CrateNum, ExternalCrate>,\n }\n \n-impl Clean<Crate> for visit_ast::RustdocVisitor {\n+impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n     fn clean(&self) -> Crate {\n         use syntax::attr::find_crateid;\n         let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());"}, {"sha": "947038bc8d85fc1d7d816a2362514441c29fc0d9", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "patch": "@@ -34,6 +34,7 @@ pub struct DocContext {\n \n pub struct CrateAnalysis {\n     exported_items: privacy::ExportedItems,\n+    public_items: privacy::PublicItems,\n }\n \n /// Parses, resolves, and typechecks the given crate\n@@ -75,21 +76,27 @@ fn get_ast_and_resolve(cpath: &Path,\n     let crate = phase_1_parse_input(sess, cfg.clone(), &input);\n     let (crate, ast_map) = phase_2_configure_and_expand(sess, cfg, crate);\n     let driver::driver::CrateAnalysis {\n-        exported_items, ty_cx, ..\n+        exported_items, public_items, ty_cx, ..\n     } = phase_3_run_analysis_passes(sess, &crate, ast_map);\n \n     debug!(\"crate: {:?}\", crate);\n     return (DocContext { crate: crate, tycx: Some(ty_cx), sess: sess },\n-            CrateAnalysis { exported_items: exported_items });\n+            CrateAnalysis {\n+                exported_items: exported_items,\n+                public_items: public_items,\n+            });\n }\n \n pub fn run_core (libs: HashSet<Path>, cfgs: ~[~str], path: &Path) -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n     let ctxt = @ctxt;\n     local_data::set(super::ctxtkey, ctxt);\n \n-    let mut v = RustdocVisitor::new();\n-    v.visit(&ctxt.crate);\n+    let crate = {\n+        let mut v = RustdocVisitor::new(ctxt, Some(&analysis));\n+        v.visit(&ctxt.crate);\n+        v.clean()\n+    };\n \n-    (v.clean(), analysis)\n+    (crate, analysis)\n }"}, {"sha": "31a500718eed9662a55af42d6878b77bfce1c606", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "patch": "@@ -67,7 +67,7 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     };\n     local_data::set(super::ctxtkey, ctx);\n \n-    let mut v = RustdocVisitor::new();\n+    let mut v = RustdocVisitor::new(ctx, None);\n     v.visit(&ctx.crate);\n     let crate = v.clean();\n     let (crate, _) = passes::unindent_comments(crate);"}, {"sha": "60df2402e9ea9cb5e37c6bc0677e0f2d66cbbbe8", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 243, "deletions": 134, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9da4eac91f3d03c1f5e5b26f5a89e234ae4b6eea", "patch": "@@ -13,169 +13,278 @@\n \n use syntax::abi::AbiSet;\n use syntax::ast;\n+use syntax::ast_util;\n+use syntax::ast_map;\n use syntax::codemap::Span;\n \n+use core;\n use doctree::*;\n \n-pub struct RustdocVisitor {\n+pub struct RustdocVisitor<'a> {\n     module: Module,\n     attrs: ~[ast::Attribute],\n+    cx: &'a core::DocContext,\n+    analysis: Option<&'a core::CrateAnalysis>,\n }\n \n-impl RustdocVisitor {\n-    pub fn new() -> RustdocVisitor {\n+impl<'a> RustdocVisitor<'a> {\n+    pub fn new<'b>(cx: &'b core::DocContext,\n+                   analysis: Option<&'b core::CrateAnalysis>) -> RustdocVisitor<'b> {\n         RustdocVisitor {\n             module: Module::new(None),\n             attrs: ~[],\n+            cx: cx,\n+            analysis: analysis,\n         }\n     }\n-}\n \n-impl RustdocVisitor {\n     pub fn visit(&mut self, crate: &ast::Crate) {\n         self.attrs = crate.attrs.clone();\n-        fn visit_struct_def(item: &ast::item, sd: @ast::struct_def, generics:\n-                            &ast::Generics) -> Struct {\n-            debug!(\"Visiting struct\");\n-            let struct_type = struct_type_from_def(sd);\n-            Struct {\n-                id: item.id,\n-                struct_type: struct_type,\n-                name: item.ident,\n-                vis: item.vis,\n-                attrs: item.attrs.clone(),\n-                generics: generics.clone(),\n-                fields: sd.fields.clone(),\n-                where: item.span\n-            }\n+\n+        self.module = self.visit_mod_contents(crate.span, crate.attrs.clone(),\n+                                              ast::public, ast::CRATE_NODE_ID,\n+                                              &crate.module, None);\n+    }\n+\n+    pub fn visit_struct_def(&mut self, item: &ast::item, sd: @ast::struct_def,\n+\n+                        generics: &ast::Generics) -> Struct {\n+        debug!(\"Visiting struct\");\n+        let struct_type = struct_type_from_def(sd);\n+        Struct {\n+            id: item.id,\n+            struct_type: struct_type,\n+            name: item.ident,\n+            vis: item.vis,\n+            attrs: item.attrs.clone(),\n+            generics: generics.clone(),\n+            fields: sd.fields.clone(),\n+            where: item.span\n         }\n+    }\n \n-        fn visit_enum_def(it: &ast::item, def: &ast::enum_def, params: &ast::Generics) -> Enum {\n-            debug!(\"Visiting enum\");\n-            let mut vars: ~[Variant] = ~[];\n-            for x in def.variants.iter() {\n-                vars.push(Variant {\n-                    name: x.node.name,\n-                    attrs: x.node.attrs.clone(),\n-                    vis: x.node.vis,\n-                    id: x.node.id,\n-                    kind: x.node.kind.clone(),\n-                    where: x.span,\n-                });\n-            }\n-            Enum {\n-                name: it.ident,\n-                variants: vars,\n-                vis: it.vis,\n-                generics: params.clone(),\n-                attrs: it.attrs.clone(),\n-                id: it.id,\n-                where: it.span,\n-            }\n+    pub fn visit_enum_def(&mut self, it: &ast::item, def: &ast::enum_def,\n+                      params: &ast::Generics) -> Enum {\n+        debug!(\"Visiting enum\");\n+        let mut vars: ~[Variant] = ~[];\n+        for x in def.variants.iter() {\n+            vars.push(Variant {\n+                name: x.node.name,\n+                attrs: x.node.attrs.clone(),\n+                vis: x.node.vis,\n+                id: x.node.id,\n+                kind: x.node.kind.clone(),\n+                where: x.span,\n+            });\n+        }\n+        Enum {\n+            name: it.ident,\n+            variants: vars,\n+            vis: it.vis,\n+            generics: params.clone(),\n+            attrs: it.attrs.clone(),\n+            id: it.id,\n+            where: it.span,\n         }\n+    }\n \n-        fn visit_fn(item: &ast::item, fd: &ast::fn_decl, purity: &ast::purity,\n-                     _abi: &AbiSet, gen: &ast::Generics) -> Function {\n-            debug!(\"Visiting fn\");\n-            Function {\n-                id: item.id,\n-                vis: item.vis,\n-                attrs: item.attrs.clone(),\n-                decl: fd.clone(),\n-                name: item.ident,\n-                where: item.span,\n-                generics: gen.clone(),\n-                purity: *purity,\n-            }\n+    pub fn visit_fn(&mut self, item: &ast::item, fd: &ast::fn_decl,\n+                    purity: &ast::purity, _abi: &AbiSet,\n+                    gen: &ast::Generics) -> Function {\n+        debug!(\"Visiting fn\");\n+        Function {\n+            id: item.id,\n+            vis: item.vis,\n+            attrs: item.attrs.clone(),\n+            decl: fd.clone(),\n+            name: item.ident,\n+            where: item.span,\n+            generics: gen.clone(),\n+            purity: *purity,\n         }\n+    }\n \n-        fn visit_mod_contents(span: Span, attrs: ~[ast::Attribute], vis:\n-                              ast::visibility, id: ast::NodeId, m: &ast::_mod,\n+    pub fn visit_mod_contents(&mut self, span: Span, attrs: ~[ast::Attribute],\n+                              vis: ast::visibility, id: ast::NodeId,\n+                              m: &ast::_mod,\n                               name: Option<ast::Ident>) -> Module {\n-            let mut om = Module::new(name);\n-            om.view_items = m.view_items.clone();\n-            om.where = span;\n-            om.attrs = attrs;\n-            om.vis = vis;\n-            om.id = id;\n-            for i in m.items.iter() {\n-                visit_item(*i, &mut om);\n+        let mut om = Module::new(name);\n+        for item in m.view_items.iter() {\n+            self.visit_view_item(item, &mut om);\n+        }\n+        om.where = span;\n+        om.attrs = attrs;\n+        om.vis = vis;\n+        om.id = id;\n+        for i in m.items.iter() {\n+            self.visit_item(*i, &mut om);\n+        }\n+        om\n+    }\n+\n+    pub fn visit_view_item(&mut self, item: &ast::view_item, om: &mut Module) {\n+        if item.vis != ast::public {\n+            return om.view_items.push(item.clone());\n+        }\n+        let item = match item.node {\n+            ast::view_item_use(ref paths) => {\n+                // rustc no longer supports \"use foo, bar;\"\n+                assert_eq!(paths.len(), 1);\n+                match self.visit_view_path(paths[0], om) {\n+                    None => return,\n+                    Some(path) => {\n+                        ast::view_item {\n+                            node: ast::view_item_use(~[path]),\n+                            .. item.clone()\n+                        }\n+                    }\n+                }\n+            }\n+            ast::view_item_extern_mod(..) => item.clone()\n+        };\n+        om.view_items.push(item);\n+    }\n+\n+    fn visit_view_path(&mut self, path: @ast::view_path,\n+                       om: &mut Module) -> Option<@ast::view_path> {\n+        match path.node {\n+            ast::view_path_simple(_, _, id) => {\n+                if self.resolve_id(id, false, om) { return None }\n+            }\n+            ast::view_path_list(ref p, ref paths, ref b) => {\n+                let mut mine = ~[];\n+                for path in paths.iter() {\n+                    if !self.resolve_id(path.node.id, false, om) {\n+                        mine.push(path.clone());\n+                    }\n+                }\n+\n+                if mine.len() == 0 { return None }\n+                return Some(@::syntax::codemap::Spanned {\n+                    node: ast::view_path_list(p.clone(), mine, b.clone()),\n+                    span: path.span,\n+                })\n+            }\n+\n+            // these are feature gated anyway\n+            ast::view_path_glob(_, id) => {\n+                if self.resolve_id(id, true, om) { return None }\n             }\n-            om\n         }\n+        return Some(path);\n+    }\n \n-        fn visit_item(item: &ast::item, om: &mut Module) {\n-            debug!(\"Visiting item {:?}\", item);\n-            match item.node {\n-                ast::item_mod(ref m) => {\n-                    om.mods.push(visit_mod_contents(item.span, item.attrs.clone(),\n-                                                    item.vis, item.id, m,\n-                                                    Some(item.ident)));\n-                },\n-                ast::item_enum(ref ed, ref gen) => om.enums.push(visit_enum_def(item, ed, gen)),\n-                ast::item_struct(sd, ref gen) => om.structs.push(visit_struct_def(item, sd, gen)),\n-                ast::item_fn(fd, ref pur, ref abi, ref gen, _) =>\n-                    om.fns.push(visit_fn(item, fd, pur, abi, gen)),\n-                ast::item_ty(ty, ref gen) => {\n-                    let t = Typedef {\n-                        ty: ty,\n-                        gen: gen.clone(),\n-                        name: item.ident,\n-                        id: item.id,\n-                        attrs: item.attrs.clone(),\n-                        where: item.span,\n-                        vis: item.vis,\n-                    };\n-                    om.typedefs.push(t);\n-                },\n-                ast::item_static(ty, ref mut_, ref exp) => {\n-                    let s = Static {\n-                        type_: ty,\n-                        mutability: mut_.clone(),\n-                        expr: exp.clone(),\n-                        id: item.id,\n-                        name: item.ident,\n-                        attrs: item.attrs.clone(),\n-                        where: item.span,\n-                        vis: item.vis,\n-                    };\n-                    om.statics.push(s);\n-                },\n-                ast::item_trait(ref gen, ref tr, ref met) => {\n-                    let t = Trait {\n-                        name: item.ident,\n-                        methods: met.clone(),\n-                        generics: gen.clone(),\n-                        parents: tr.clone(),\n-                        id: item.id,\n-                        attrs: item.attrs.clone(),\n-                        where: item.span,\n-                        vis: item.vis,\n-                    };\n-                    om.traits.push(t);\n-                },\n-                ast::item_impl(ref gen, ref tr, ty, ref meths) => {\n-                    let i = Impl {\n-                        generics: gen.clone(),\n-                        trait_: tr.clone(),\n-                        for_: ty,\n-                        methods: meths.clone(),\n-                        attrs: item.attrs.clone(),\n-                        id: item.id,\n-                        where: item.span,\n-                        vis: item.vis,\n-                    };\n-                    om.impls.push(i);\n-                },\n-                ast::item_foreign_mod(ref fm) => {\n-                    om.foreigns.push(fm.clone());\n+    fn resolve_id(&mut self, id: ast::NodeId, glob: bool,\n+                  om: &mut Module) -> bool {\n+        let def = {\n+            let dm = match self.cx.tycx {\n+                Some(tcx) => tcx.def_map.borrow(),\n+                None => return false,\n+            };\n+            ast_util::def_id_of_def(*dm.get().get(&id))\n+        };\n+        if !ast_util::is_local(def) { return false }\n+        let analysis = match self.analysis {\n+            Some(analysis) => analysis, None => return false\n+        };\n+        if analysis.public_items.contains(&def.node) { return false }\n+\n+        let item = {\n+            let items = self.cx.tycx.unwrap().items.borrow();\n+            *items.get().get(&def.node)\n+        };\n+        match item {\n+            ast_map::node_item(it, _) => {\n+                if glob {\n+                    match it.node {\n+                        ast::item_mod(ref m) => {\n+                            for vi in m.view_items.iter() {\n+                                self.visit_view_item(vi, om);\n+                            }\n+                            for i in m.items.iter() {\n+                                self.visit_item(*i, om);\n+                            }\n+                        }\n+                        _ => { fail!(\"glob not mapped to a module\"); }\n+                    }\n+                } else {\n+                    self.visit_item(it, om);\n                 }\n-                _ => (),\n+                true\n             }\n+            _ => false,\n         }\n+    }\n \n-        self.module = visit_mod_contents(crate.span, crate.attrs.clone(),\n-                                         ast::public, ast::CRATE_NODE_ID,\n-                                         &crate.module, None);\n+    pub fn visit_item(&mut self, item: &ast::item, om: &mut Module) {\n+        debug!(\"Visiting item {:?}\", item);\n+        match item.node {\n+            ast::item_mod(ref m) => {\n+                om.mods.push(self.visit_mod_contents(item.span, item.attrs.clone(),\n+                                                item.vis, item.id, m,\n+                                                Some(item.ident)));\n+            },\n+            ast::item_enum(ref ed, ref gen) =>\n+                om.enums.push(self.visit_enum_def(item, ed, gen)),\n+            ast::item_struct(sd, ref gen) =>\n+                om.structs.push(self.visit_struct_def(item, sd, gen)),\n+            ast::item_fn(fd, ref pur, ref abi, ref gen, _) =>\n+                om.fns.push(self.visit_fn(item, fd, pur, abi, gen)),\n+            ast::item_ty(ty, ref gen) => {\n+                let t = Typedef {\n+                    ty: ty,\n+                    gen: gen.clone(),\n+                    name: item.ident,\n+                    id: item.id,\n+                    attrs: item.attrs.clone(),\n+                    where: item.span,\n+                    vis: item.vis,\n+                };\n+                om.typedefs.push(t);\n+            },\n+            ast::item_static(ty, ref mut_, ref exp) => {\n+                let s = Static {\n+                    type_: ty,\n+                    mutability: mut_.clone(),\n+                    expr: exp.clone(),\n+                    id: item.id,\n+                    name: item.ident,\n+                    attrs: item.attrs.clone(),\n+                    where: item.span,\n+                    vis: item.vis,\n+                };\n+                om.statics.push(s);\n+            },\n+            ast::item_trait(ref gen, ref tr, ref met) => {\n+                let t = Trait {\n+                    name: item.ident,\n+                    methods: met.clone(),\n+                    generics: gen.clone(),\n+                    parents: tr.clone(),\n+                    id: item.id,\n+                    attrs: item.attrs.clone(),\n+                    where: item.span,\n+                    vis: item.vis,\n+                };\n+                om.traits.push(t);\n+            },\n+            ast::item_impl(ref gen, ref tr, ty, ref meths) => {\n+                let i = Impl {\n+                    generics: gen.clone(),\n+                    trait_: tr.clone(),\n+                    for_: ty,\n+                    methods: meths.clone(),\n+                    attrs: item.attrs.clone(),\n+                    id: item.id,\n+                    where: item.span,\n+                    vis: item.vis,\n+                };\n+                om.impls.push(i);\n+            },\n+            ast::item_foreign_mod(ref fm) => {\n+                om.foreigns.push(fm.clone());\n+            }\n+            _ => (),\n+        }\n     }\n }"}]}