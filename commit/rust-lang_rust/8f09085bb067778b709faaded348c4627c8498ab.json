{"sha": "8f09085bb067778b709faaded348c4627c8498ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMDkwODViYjA2Nzc3OGI3MDlmYWFkZWQzNDhjNDYyN2M4NDk4YWI=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-10-15T23:07:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-15T23:07:46Z"}, "message": "Rollup merge of #65265 - GuillaumeGomez:cleanup-librustc_mir-err-codes, r=Mark-Simulacrum\n\nCleanup librustc mir err codes\n\nThree things are done in this PR:\n\n * Sort error codes\n * Uncomment an error code long error explanation (they should **never** be commented)\n * Unify explanations", "tree": {"sha": "a4c3c1a04412e5a6060eed0493ea6d8f4f8e39ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4c3c1a04412e5a6060eed0493ea6d8f4f8e39ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f09085bb067778b709faaded348c4627c8498ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdplFCCRBK7hj4Ov3rIwAAdHIIADagcELpmOC5PAnQVgwTE75L\n/0m7ibuMQ+16Q+Of1LJH5amzMS3zxUjS4AAyUzf/ChSPJCizWPEQI2o66glbcxsu\n9OD3NeDtugd+Oyt/zPLShpMvnrxozplEwcDiw4taH/MUPGFfN1Mh62Rydq/jon4B\niBcQ/ERqfYIZPCwNIOKQeehd7U11wGwC2G0nDFpCEFJfvn7ApAjYR572ds148n/b\n/Zn9PrXhKDi+gJyeRt6ZemlUCU6kQfHGCWcaIePexR3HY9o9URVB1zW6+WR2k5wt\nPDDHtuh8GaBGtHU5r8IfIdAG+R7n7/lVpm9ePmDOqiqj77QAlyZ6hrPCvbIUvGg=\n=FT2G\n-----END PGP SIGNATURE-----\n", "payload": "tree a4c3c1a04412e5a6060eed0493ea6d8f4f8e39ba\nparent ef9d6ee8adc3130ff222d037f29518bd4a61089b\nparent d4e3e6bc15ece1c017ec7bd1fd892c6a981b2020\nauthor Tyler Mandry <tmandry@gmail.com> 1571180866 -0700\ncommitter GitHub <noreply@github.com> 1571180866 -0700\n\nRollup merge of #65265 - GuillaumeGomez:cleanup-librustc_mir-err-codes, r=Mark-Simulacrum\n\nCleanup librustc mir err codes\n\nThree things are done in this PR:\n\n * Sort error codes\n * Uncomment an error code long error explanation (they should **never** be commented)\n * Unify explanations\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f09085bb067778b709faaded348c4627c8498ab", "html_url": "https://github.com/rust-lang/rust/commit/8f09085bb067778b709faaded348c4627c8498ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f09085bb067778b709faaded348c4627c8498ab/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef9d6ee8adc3130ff222d037f29518bd4a61089b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9d6ee8adc3130ff222d037f29518bd4a61089b", "html_url": "https://github.com/rust-lang/rust/commit/ef9d6ee8adc3130ff222d037f29518bd4a61089b"}, {"sha": "d4e3e6bc15ece1c017ec7bd1fd892c6a981b2020", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4e3e6bc15ece1c017ec7bd1fd892c6a981b2020", "html_url": "https://github.com/rust-lang/rust/commit/d4e3e6bc15ece1c017ec7bd1fd892c6a981b2020"}], "stats": {"total": 505, "additions": 275, "deletions": 230}, "files": [{"sha": "419c905cb5127a070530064f1b056b4630f7cb21", "filename": "src/librustc_mir/error_codes.rs", "status": "modified", "additions": 275, "deletions": 230, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/8f09085bb067778b709faaded348c4627c8498ab/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f09085bb067778b709faaded348c4627c8498ab/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=8f09085bb067778b709faaded348c4627c8498ab", "patch": "@@ -64,7 +64,9 @@ E0004: r##\"\n This error indicates that the compiler cannot guarantee a matching pattern for\n one or more possible inputs to a match expression. Guaranteed matches are\n required in order to assign values to match expressions, or alternatively,\n-determine the flow of execution. Erroneous code example:\n+determine the flow of execution.\n+\n+Erroneous code example:\n \n ```compile_fail,E0004\n enum Terminator {\n@@ -109,7 +111,9 @@ match x {\n \n E0005: r##\"\n Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases. Erroneous code example:\n+that a name will be extracted in all cases.\n+\n+Erroneous code example:\n \n ```compile_fail,E0005\n let x = Some(1);\n@@ -145,6 +149,8 @@ like the following is invalid as it requires the entire `Option<String>` to be\n moved into a variable called `op_string` while simultaneously requiring the\n inner `String` to be moved into a variable called `s`.\n \n+Erroneous code example:\n+\n ```compile_fail,E0007\n let x = Some(\"s\".to_string());\n \n@@ -208,15 +214,130 @@ match x {\n ```\n \"##,\n \n+E0010: r##\"\n+The value of statics and constants must be known at compile time, and they live\n+for the entire lifetime of a program. Creating a boxed value allocates memory on\n+the heap at runtime, and therefore cannot be done at compile time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0010\n+#![feature(box_syntax)]\n+\n+const CON : Box<i32> = box 0;\n+```\n+\"##,\n+\n+E0013: r##\"\n+Static and const variables can refer to other const variables. But a const\n+variable cannot refer to a static variable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0013\n+static X: i32 = 42;\n+const Y: i32 = X;\n+```\n+\n+In this example, `Y` cannot refer to `X` here. To fix this, the value can be\n+extracted as a const and then used:\n+\n+```\n+const A: i32 = 42;\n+static X: i32 = A;\n+const Y: i32 = A;\n+```\n+\"##,\n+\n+// FIXME(#57563) Change the language here when const fn stabilizes\n+E0015: r##\"\n+The only functions that can be called in static or constant expressions are\n+`const` functions, and struct/enum constructors. `const` functions are only\n+available on a nightly compiler. Rust currently does not support more general\n+compile-time function execution.\n+\n+```\n+const FOO: Option<u8> = Some(1); // enum constructor\n+struct Bar {x: u8}\n+const BAR: Bar = Bar {x: 1}; // struct constructor\n+```\n+\n+See [RFC 911] for more details on the design of `const fn`s.\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n+\"##,\n+\n+E0017: r##\"\n+References in statics and constants may only refer to immutable values.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0017\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`.\n+\"##,\n+\n+E0019: r##\"\n+A function call isn't allowed in the const's initialization expression\n+because the expression's value must be known at compile-time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0019\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    struct MyOwned;\n+\n+    static STATIC11: Box<MyOwned> = box MyOwned; // error!\n+}\n+```\n+\n+Remember: you can't use a function call inside a const's initialization\n+expression! However, you can totally use it anywhere else:\n+\n+```\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn func(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    FOO.func(); // here is good\n+    let x = FOO.func(); // or even here!\n+}\n+```\n+\"##,\n+\n E0030: r##\"\n When matching against a range, the compiler verifies that the range is\n-non-empty.  Range patterns include both end-points, so this is equivalent to\n+non-empty. Range patterns include both end-points, so this is equivalent to\n requiring the start of the range to be less than or equal to the end of the\n range.\n \n-For example:\n+Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0030\n match 5u32 {\n     // This range is ok, albeit pointless.\n     1 ..= 1 => {}\n@@ -226,7 +347,61 @@ match 5u32 {\n ```\n \"##,\n \n+E0133: r##\"\n+Unsafe code was used outside of an unsafe function or block.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0133\n+unsafe fn f() { return; } // This is the unsafe code\n+\n+fn main() {\n+    f(); // error: call to unsafe function requires unsafe function or block\n+}\n+```\n+\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n+\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n+\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n+\n+```\n+unsafe fn f() { return; }\n+\n+fn main() {\n+    unsafe { f(); } // ok!\n+}\n+```\n+\n+See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n+\"##,\n+\n E0158: r##\"\n+An associated const has been referenced in a pattern.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0158\n+enum EFoo { A, B, C, D }\n+\n+trait Foo {\n+    const X: EFoo;\n+}\n+\n+fn test<A: Foo>(arg: EFoo) {\n+    match arg {\n+        A::X => { // error!\n+            println!(\"A::X\");\n+        }\n+    }\n+}\n+```\n+\n `const` and `static` mean different things. A `const` is a compile-time\n constant, an alias for a literal value. This property means you can match it\n directly within a pattern.\n@@ -247,6 +422,39 @@ match Some(42) {\n ```\n \"##,\n \n+E0161: r##\"\n+A value was moved. However, its size was not known at compile time, and only\n+values of a known size can be moved.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0161\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<[isize]> = box *array;\n+    // error: cannot move a value of type [isize]: the size of [isize] cannot\n+    //        be statically determined\n+}\n+```\n+\n+In Rust, you can only move a value when its size is known at compile time.\n+\n+To work around this restriction, consider \"hiding\" the value behind a reference:\n+either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n+it around as usual. Example:\n+\n+```\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<&[isize]> = box array; // ok!\n+}\n+```\n+\"##,\n+\n E0162: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -468,158 +676,6 @@ The `op_string_ref` binding has type `&Option<&String>` in both cases.\n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n \n-E0010: r##\"\n-The value of statics and constants must be known at compile time, and they live\n-for the entire lifetime of a program. Creating a boxed value allocates memory on\n-the heap at runtime, and therefore cannot be done at compile time. Erroneous\n-code example:\n-\n-```compile_fail,E0010\n-#![feature(box_syntax)]\n-\n-const CON : Box<i32> = box 0;\n-```\n-\"##,\n-\n-E0013: r##\"\n-Static and const variables can refer to other const variables. But a const\n-variable cannot refer to a static variable. For example, `Y` cannot refer to\n-`X` here:\n-\n-```compile_fail,E0013\n-static X: i32 = 42;\n-const Y: i32 = X;\n-```\n-\n-To fix this, the value can be extracted as a const and then used:\n-\n-```\n-const A: i32 = 42;\n-static X: i32 = A;\n-const Y: i32 = A;\n-```\n-\"##,\n-\n-// FIXME(#57563) Change the language here when const fn stabilizes\n-E0015: r##\"\n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors. `const` functions are only\n-available on a nightly compiler. Rust currently does not support more general\n-compile-time function execution.\n-\n-```\n-const FOO: Option<u8> = Some(1); // enum constructor\n-struct Bar {x: u8}\n-const BAR: Bar = Bar {x: 1}; // struct constructor\n-```\n-\n-See [RFC 911] for more details on the design of `const fn`s.\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0017: r##\"\n-References in statics and constants may only refer to immutable values.\n-Erroneous code example:\n-\n-```compile_fail,E0017\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-// these three are not allowed:\n-const CR: &mut i32 = &mut C;\n-static STATIC_REF: &'static mut i32 = &mut X;\n-static CONST_REF: &'static mut i32 = &mut C;\n-```\n-\n-Statics are shared everywhere, and if they refer to mutable data one might\n-violate memory safety since holding multiple mutable references to shared data\n-is not allowed.\n-\n-If you really want global mutable state, try using `static mut` or a global\n-`UnsafeCell`.\n-\"##,\n-\n-E0019: r##\"\n-A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time. Erroneous code\n-example:\n-\n-```compile_fail\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn test(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    const A: i32 = FOO.test(); // You can't call Test::func() here!\n-}\n-```\n-\n-Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it anywhere else:\n-\n-```\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn func(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    FOO.func(); // here is good\n-    let x = FOO.func(); // or even here!\n-}\n-```\n-\"##,\n-\n-E0133: r##\"\n-Unsafe code was used outside of an unsafe function or block.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0133\n-unsafe fn f() { return; } // This is the unsafe code\n-\n-fn main() {\n-    f(); // error: call to unsafe function requires unsafe function or block\n-}\n-```\n-\n-Using unsafe functionality is potentially dangerous and disallowed by safety\n-checks. Examples:\n-\n-* Dereferencing raw pointers\n-* Calling functions via FFI\n-* Calling functions marked unsafe\n-\n-These safety checks can be relaxed for a section of the code by wrapping the\n-unsafe instructions with an `unsafe` block. For instance:\n-\n-```\n-unsafe fn f() { return; }\n-\n-fn main() {\n-    unsafe { f(); } // ok!\n-}\n-```\n-\n-See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n-\"##,\n-\n E0373: r##\"\n This error occurs when an attempt is made to use data captured by a closure,\n when that data may no longer exist. It's most commonly seen when attempting to\n@@ -672,7 +728,9 @@ about safety.\n \"##,\n \n E0381: r##\"\n-It is not allowed to use or capture an uninitialized variable. For example:\n+It is not allowed to use or capture an uninitialized variable.\n+\n+Erroneous code example:\n \n ```compile_fail,E0381\n fn main() {\n@@ -694,7 +752,9 @@ fn main() {\n \n E0382: r##\"\n This error occurs when an attempt is made to use a variable after its contents\n-have been moved elsewhere. For example:\n+have been moved elsewhere.\n+\n+Erroneous code example:\n \n ```compile_fail,E0382\n struct MyStruct { s: u32 }\n@@ -842,7 +902,8 @@ x = Foo { a: 2 };\n \n E0384: r##\"\n This error occurs when an attempt is made to reassign an immutable variable.\n-For example:\n+\n+Erroneous code example:\n \n ```compile_fail,E0384\n fn main() {\n@@ -862,13 +923,15 @@ fn main() {\n ```\n \"##,\n \n-/*E0386: r##\"\n+E0386: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n This error occurs when an attempt is made to mutate the target of a mutable\n reference stored inside an immutable container.\n \n For example, this can happen when storing a `&mut` inside an immutable `Box`:\n \n-```compile_fail,E0386\n+```\n let mut x: i64 = 1;\n let y: Box<_> = Box::new(&mut x);\n **y = 2; // error, cannot assign to data in an immutable container\n@@ -892,13 +955,15 @@ let x: i64 = 1;\n let y: Box<Cell<_>> = Box::new(Cell::new(x));\n y.set(2);\n ```\n-\"##,*/\n+\"##,\n \n E0387: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n This error occurs when an attempt is made to mutate or mutably reference data\n-that a closure has captured immutably. Examples of this error are shown below:\n+that a closure has captured immutably.\n+\n+Erroneous code example:\n \n ```compile_fail\n // Accepts a function or a closure that captures its environment immutably.\n@@ -963,7 +1028,7 @@ An attempt was made to mutate data using a non-mutable reference. This\n commonly occurs when attempting to assign to a non-mutable reference of a\n mutable reference (`&(&mut T)`).\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail\n struct FancyNum {\n@@ -1022,43 +1087,11 @@ fn main() {\n ```\n \"##,\n \n-E0161: r##\"\n-A value was moved. However, its size was not known at compile time, and only\n-values of a known size can be moved.\n+E0492: r##\"\n+A borrow of a constant containing interior mutability was attempted.\n \n Erroneous code example:\n \n-```compile_fail\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<[isize]> = box *array;\n-    // error: cannot move a value of type [isize]: the size of [isize] cannot\n-    //        be statically determined\n-}\n-```\n-\n-In Rust, you can only move a value when its size is known at compile time.\n-\n-To work around this restriction, consider \"hiding\" the value behind a reference:\n-either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n-it around as usual. Example:\n-\n-```\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<&[isize]> = box array; // ok!\n-}\n-```\n-\"##,\n-\n-E0492: r##\"\n-A borrow of a constant containing interior mutability was attempted. Erroneous\n-code example:\n-\n ```compile_fail,E0492\n use std::sync::atomic::AtomicUsize;\n \n@@ -1174,7 +1207,9 @@ static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields\n \"##,\n \n E0499: r##\"\n-A variable was borrowed as mutable more than once. Erroneous code example:\n+A variable was borrowed as mutable more than once.\n+\n+Erroneous code example:\n \n ```compile_fail,E0499\n let mut i = 0;\n@@ -1205,7 +1240,9 @@ a;\n \"##,\n \n E0500: r##\"\n-A borrowed variable was used by a closure. Example of erroneous code:\n+A borrowed variable was used by a closure.\n+\n+Erroneous code example:\n \n ```compile_fail,E0500\n fn you_know_nothing(jon_snow: &mut i32) {\n@@ -1256,7 +1293,7 @@ situation, the closure is borrowing the variable. Take a look at\n http://rustbyexample.com/fn/closures/capture.html for more information about\n capturing.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0501\n fn inside_closure(x: &mut i32) {\n@@ -1329,7 +1366,7 @@ E0502: r##\"\n This error indicates that you are trying to borrow a variable as mutable when it\n has already been borrowed as immutable.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0502\n fn bar(x: &mut i32) {}\n@@ -1360,7 +1397,7 @@ https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.\n E0503: r##\"\n A value was used after it was mutably borrowed.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0503\n fn main() {\n@@ -1418,7 +1455,7 @@ E0504: r##\"\n This error occurs when an attempt is made to move a borrowed variable into a\n closure.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail\n struct FancyNum {\n@@ -1609,7 +1646,7 @@ http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n E0506: r##\"\n This error occurs when an attempt is made to assign to a borrowed value.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0506\n struct FancyNum {\n@@ -1827,7 +1864,7 @@ http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n E0508: r##\"\n A value was moved out of a non-copy fixed-size array.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0508\n struct NonCopy;\n@@ -1872,7 +1909,7 @@ E0509: r##\"\n This error occurs when an attempt is made to move out of a value whose type\n implements the `Drop` trait.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0509\n struct FancyNum {\n@@ -1982,30 +2019,14 @@ Here executing `x = None` would modify the value being matched and require us\n to go \"back in time\" to the `None` arm.\n \"##,\n \n-E0579: r##\"\n-When matching against an exclusive range, the compiler verifies that the range\n-is non-empty. Exclusive range patterns include the start point but not the end\n-point, so this is equivalent to requiring the start of the range to be less\n-than the end of the range.\n-\n-For example:\n-\n-```compile_fail\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 .. 2 => {}\n-    // This range is empty, and the compiler can tell.\n-    5 .. 5 => {}\n-}\n-```\n-\"##,\n-\n E0515: r##\"\n Cannot return value that references local variable\n \n Local variables, function parameters and temporaries are all dropped before the\n end of the function body. So a reference to them cannot be returned.\n \n+Erroneous code example:\n+\n ```compile_fail,E0515\n fn get_dangling_reference() -> &'static i32 {\n     let x = 0;\n@@ -2101,6 +2122,28 @@ fn dragoooon(x: &mut isize) {\n ```\n \"##,\n \n+E0579: r##\"\n+When matching against an exclusive range, the compiler verifies that the range\n+is non-empty. Exclusive range patterns include the start point but not the end\n+point, so this is equivalent to requiring the start of the range to be less\n+than the end of the range.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0579\n+#![feature(exclusive_range_pattern)]\n+\n+fn main() {\n+    match 5u32 {\n+        // This range is ok, albeit pointless.\n+        1 .. 2 => {}\n+        // This range is empty, and the compiler can tell.\n+        5 .. 5 => {} // error!\n+    }\n+}\n+```\n+\"##,\n+\n E0595: r##\"\n #### Note: this error code is no longer emitted by the compiler.\n \n@@ -2124,7 +2167,7 @@ let mut c = || { x += 1 };\n E0596: r##\"\n This error occurs because you tried to mutably borrow a non-mutable variable.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0596\n let x = 1;\n@@ -2143,7 +2186,7 @@ let y = &mut x; // ok!\n E0597: r##\"\n This error occurs because a value was dropped while it was still borrowed\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0597\n struct Foo<'a> {\n@@ -2180,6 +2223,8 @@ E0626: r##\"\n This error occurs because a borrow in a generator persists across a\n yield point.\n \n+Erroneous code example:\n+\n ```compile_fail,E0626\n # #![feature(generators, generator_trait, pin)]\n # use std::ops::Generator;\n@@ -2271,7 +2316,7 @@ E0712: r##\"\n This error occurs because a borrow of a thread-local variable was made inside a\n function which outlived the lifetime of the function.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0712\n #![feature(thread_local)]\n@@ -2293,7 +2338,7 @@ E0713: r##\"\n This error occurs when an attempt is made to borrow state past the end of the\n lifetime of a type that implements the `Drop` trait.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0713\n #![feature(nll)]"}]}