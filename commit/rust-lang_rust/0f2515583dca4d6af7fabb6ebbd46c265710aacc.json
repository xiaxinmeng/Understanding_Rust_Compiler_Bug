{"sha": "0f2515583dca4d6af7fabb6ebbd46c265710aacc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMjUxNTU4M2RjYTRkNmFmN2ZhYmI2ZWJiZDQ2YzI2NTcxMGFhY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-07T12:22:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-07T12:22:56Z"}, "message": "auto merge of #7615 : Aatch/rust/syntax-deshare, r=graydon\n\nIn an ideal world, the AST would be completely sendable, this gets us a step closer.\r\n\r\nIt removes the local heap allocations for `view_item`, `Path`, `Lifetime` `trait_ref` `OptVec<TyParamBounds>` and `Ty`. There are also a few other smaller changes I made as things went along.", "tree": {"sha": "beff1824554421ded82c48b6f0f6f03d18c4f662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beff1824554421ded82c48b6f0f6f03d18c4f662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f2515583dca4d6af7fabb6ebbd46c265710aacc", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f2515583dca4d6af7fabb6ebbd46c265710aacc", "html_url": "https://github.com/rust-lang/rust/commit/0f2515583dca4d6af7fabb6ebbd46c265710aacc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f2515583dca4d6af7fabb6ebbd46c265710aacc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d91ac39cd522dd40b80372baeb693680c1d15927", "url": "https://api.github.com/repos/rust-lang/rust/commits/d91ac39cd522dd40b80372baeb693680c1d15927", "html_url": "https://github.com/rust-lang/rust/commit/d91ac39cd522dd40b80372baeb693680c1d15927"}, {"sha": "280e4245c065da9c22b09c1d18c0629af1709eb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/280e4245c065da9c22b09c1d18c0629af1709eb3", "html_url": "https://github.com/rust-lang/rust/commit/280e4245c065da9c22b09c1d18c0629af1709eb3"}], "stats": {"total": 1523, "additions": 753, "deletions": 770}, "files": [{"sha": "df829d5e2096132416b390d52f19201fa4a2da4f", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -12,7 +12,7 @@\n use std::option;\n use syntax::{ast, fold, attr};\n \n-type in_cfg_pred = @fn(attrs: ~[ast::attribute]) -> bool;\n+type in_cfg_pred = @fn(attrs: &[ast::attribute]) -> bool;\n \n struct Context {\n     in_cfg: in_cfg_pred\n@@ -50,8 +50,7 @@ fn filter_item(cx: @Context, item: @ast::item) ->\n     if item_in_cfg(cx, item) { option::Some(item) } else { option::None }\n }\n \n-fn filter_view_item(cx: @Context, view_item: @ast::view_item\n-                   )-> Option<@ast::view_item> {\n+fn filter_view_item<'r>(cx: @Context, view_item: &'r ast::view_item)-> Option<&'r ast::view_item> {\n     if view_item_in_cfg(cx, view_item) {\n         option::Some(view_item)\n     } else {\n@@ -64,7 +63,7 @@ fn fold_mod(cx: @Context, m: &ast::_mod, fld: @fold::ast_fold) -> ast::_mod {\n         filter_item(cx, *a).chain(|x| fld.fold_item(x))\n     }.collect();\n     let filtered_view_items = do m.view_items.iter().filter_map |a| {\n-        filter_view_item(cx, *a).map(|x| fld.fold_view_item(*x))\n+        filter_view_item(cx, a).map(|&x| fld.fold_view_item(x))\n     }.collect();\n     ast::_mod {\n         view_items: filtered_view_items,\n@@ -86,7 +85,7 @@ fn fold_foreign_mod(\n ) -> ast::foreign_mod {\n     let filtered_items = nm.items.iter().filter_map(|a| filter_foreign_item(cx, *a)).collect();\n     let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n-        filter_view_item(cx, *a).map(|x| fld.fold_view_item(*x))\n+        filter_view_item(cx, a).map(|&x| fld.fold_view_item(x))\n     }.collect();\n     ast::foreign_mod {\n         sort: nm.sort,\n@@ -99,10 +98,10 @@ fn fold_foreign_mod(\n fn fold_item_underscore(cx: @Context, item: &ast::item_,\n                         fld: @fold::ast_fold) -> ast::item_ {\n     let item = match *item {\n-        ast::item_impl(ref a, b, c, ref methods) => {\n+        ast::item_impl(ref a, ref b, ref c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n                 .transform(|x| *x).collect();\n-            ast::item_impl(/*bad*/ copy *a, b, c, methods)\n+            ast::item_impl(/*bad*/ copy *a, /*bad*/ copy *b, /*bad*/ copy *c, methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n             let methods = methods.iter().filter(|m| trait_method_in_cfg(cx, *m) )\n@@ -141,7 +140,7 @@ fn fold_block(\n         filter_stmt(cx, *a).chain(|stmt| fld.fold_stmt(stmt))\n     }.collect();\n     let filtered_view_items = do b.view_items.iter().filter_map |a| {\n-        filter_view_item(cx, *a).map(|x| fld.fold_view_item(*x))\n+        filter_view_item(cx, a).map(|&x| fld.fold_view_item(x))\n     }.collect();\n     ast::blk_ {\n         view_items: filtered_view_items,\n@@ -160,8 +159,8 @@ fn foreign_item_in_cfg(cx: @Context, item: @ast::foreign_item) -> bool {\n     return (cx.in_cfg)(/*bad*/copy item.attrs);\n }\n \n-fn view_item_in_cfg(cx: @Context, item: @ast::view_item) -> bool {\n-    return (cx.in_cfg)(/*bad*/copy item.attrs);\n+fn view_item_in_cfg(cx: @Context, item: &ast::view_item) -> bool {\n+    return (cx.in_cfg)(item.attrs);\n }\n \n fn method_in_cfg(cx: @Context, meth: @ast::method) -> bool {"}, {"sha": "699799929ba00ad3a0efba28b30f0e6506e401b8", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -41,7 +41,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n     let precursor = @fold::AstFoldFns {\n         fold_crate: |crate, span, fld| {\n             let n1 = sess.next_node_id();\n-            let vi1 = @ast::view_item {\n+            let vi1 = ast::view_item {\n                 node: ast::view_item_extern_mod(\n                         sess.ident_of(\"std\"), ~[], n1),\n                 attrs: ~[\n@@ -75,7 +75,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n         fold_mod: |module, fld| {\n             let n2 = sess.next_node_id();\n \n-            let prelude_path = @ast::Path {\n+            let prelude_path = ast::Path {\n                 span: dummy_sp(),\n                 global: false,\n                 idents: ~[\n@@ -87,7 +87,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::crate) -> @ast::crate {\n             };\n \n             let vp = @spanned(ast::view_path_glob(prelude_path, n2));\n-            let vi2 = @ast::view_item { node: ast::view_item_use(~[vp]),\n+            let vi2 = ast::view_item { node: ast::view_item_use(~[vp]),\n                                         attrs: ~[],\n                                         vis: ast::private,\n                                         span: dummy_sp() };"}, {"sha": "f2670a663ea0c4ce14d5ee0dac007da1ea930c5a", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -272,7 +272,7 @@ mod __test {\n \n */\n \n-fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n+fn mk_std(cx: &TestCtxt) -> ast::view_item {\n     let vers = ast::lit_str(@\"0.7\");\n     let vers = nospan(vers);\n     let mi = ast::meta_name_value(@\"vers\", vers);\n@@ -287,13 +287,12 @@ fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n         ast::view_item_extern_mod(id_std, ~[@mi],\n                            cx.sess.next_node_id())\n     };\n-    let vi = ast::view_item {\n+    ast::view_item {\n         node: vi,\n         attrs: ~[],\n         vis: ast::public,\n         span: dummy_sp()\n-    };\n-    return @vi;\n+    }\n }\n \n fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n@@ -343,16 +342,16 @@ fn nospan<T:Copy>(t: T) -> codemap::spanned<T> {\n     codemap::spanned { node: t, span: dummy_sp() }\n }\n \n-fn path_node(ids: ~[ast::ident]) -> @ast::Path {\n-    @ast::Path { span: dummy_sp(),\n+fn path_node(ids: ~[ast::ident]) -> ast::Path {\n+    ast::Path { span: dummy_sp(),\n                 global: false,\n                 idents: ids,\n                 rp: None,\n                 types: ~[] }\n }\n \n-fn path_node_global(ids: ~[ast::ident]) -> @ast::Path {\n-    @ast::Path { span: dummy_sp(),\n+fn path_node_global(ids: ~[ast::ident]) -> ast::Path {\n+    ast::Path { span: dummy_sp(),\n                  global: true,\n                  idents: ids,\n                  rp: None,"}, {"sha": "8c62f4dbbe357eb2851d6e43a94735fdeff9f465", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -136,7 +136,7 @@ fn visit_crate(e: &Env, c: &ast::crate) {\n     }\n }\n \n-fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n+fn visit_view_item(e: @mut Env, i: &ast::view_item) {\n     match i.node {\n       ast::view_item_extern_mod(ident, ref meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\","}, {"sha": "1e508d0813184559f93a99f343ae493495e0be7d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -1141,7 +1141,7 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n \n     let r = get_attributes(md);\n     for r.iter().advance |attr| {\n-        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(*attr, intr)));\n+        out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(attr, intr)));\n     }\n \n     out.write_str(\"\\n\\n\");"}, {"sha": "a9f3200af1284882f15075416ad13637e849937d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -1003,7 +1003,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                         index);\n         }\n       }\n-      item_impl(ref generics, opt_trait, ty, ref methods) => {\n+      item_impl(ref generics, ref opt_trait, ref ty, ref methods) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -1014,7 +1014,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n-            ast::ty_path(path, bounds, _) if path.idents.len() == 1 => {\n+            ast::ty_path(ref path, ref bounds, _) if path.idents.len() == 1 => {\n                 assert!(bounds.is_none());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));"}, {"sha": "7113244c7f6cf3e589b907928d2fee528143fdaa", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -112,7 +112,7 @@ pub fn check_expr(sess: Session,\n                               \"` in a constant expression\");\n             }\n           }\n-          expr_path(pth) => {\n+          expr_path(ref pth) => {\n             // NB: In the future you might wish to relax this slightly\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on"}, {"sha": "335a54a97535370deb9b5a1c9be7e979914b0123", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -117,15 +117,15 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // If this is a destructor, check kinds.\n     if !attrs_contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n-            item_impl(_, Some(trait_ref), self_type, _) => {\n+            item_impl(_, Some(ref trait_ref), ref self_type, _) => {\n                 match cx.tcx.def_map.find(&trait_ref.ref_id) {\n                     None => cx.tcx.sess.bug(\"trait ref not in def map!\"),\n                     Some(&trait_def) => {\n                         let trait_def_id = ast_util::def_id_of_def(trait_def);\n                         if cx.tcx.lang_items.drop_trait() == trait_def_id {\n                             // Yes, it's a destructor.\n                             match self_type.node {\n-                                ty_path(_, bounds, path_node_id) => {\n+                                ty_path(_, ref bounds, path_node_id) => {\n                                     assert!(bounds.is_none());\n                                     let struct_def = cx.tcx.def_map.get_copy(\n                                         &path_node_id);\n@@ -321,7 +321,7 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n     visit::visit_expr(e, (cx, v));\n }\n \n-fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n+fn check_ty(aty: &Ty, (cx, v): (Context, visit::vt<Context>)) {\n     match aty.node {\n       ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);"}, {"sha": "0dce9c69bfdbe2fe5a515c09190a558fcbc3af92", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -747,9 +747,9 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n         for decl.inputs.iter().advance |in| {\n-            check_ty(cx, in.ty);\n+            check_ty(cx, &in.ty);\n         }\n-        check_ty(cx, decl.output)\n+        check_ty(cx, &decl.output)\n     }\n \n     match it.node {\n@@ -759,7 +759,7 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n                 ast::foreign_item_fn(ref decl, _, _) => {\n                     check_foreign_fn(cx, decl);\n                 }\n-                ast::foreign_item_static(t, _) => { check_ty(cx, t); }\n+                ast::foreign_item_static(ref t, _) => { check_ty(cx, t); }\n             }\n         }\n       }"}, {"sha": "7dd7ae6ec9ae0a71f86513d37a35a936f282a059", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -71,10 +71,10 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                    it: &fn(binding_mode, node_id, span, @Path)) {\n+                    it: &fn(binding_mode, node_id, span, &Path)) {\n     for walk_pat(pat) |p| {\n         match p.node {\n-          pat_ident(binding_mode, pth, _) if pat_is_binding(dm, p) => {\n+          pat_ident(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}"}, {"sha": "dd6b5615c3f3fe460849ea9866536fd107b6cf67", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -276,7 +276,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n     };\n \n     // Checks that a private path is in scope.\n-    let check_path: @fn(span: span, def: def, path: @Path) =\n+    let check_path: @fn(span: span, def: def, path: &Path) =\n             |span, def, path| {\n         debug!(\"checking path\");\n         match def {\n@@ -449,7 +449,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         _ => {}\n                     }\n                 }\n-                expr_path(path) => {\n+                expr_path(ref path) => {\n                     check_path(expr.span, tcx.def_map.get_copy(&expr.id), path);\n                 }\n                 expr_struct(_, ref fields, _) => {"}, {"sha": "70833813cc0877f7cef8669dcf1367b1cc50759a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -141,7 +141,7 @@ impl ReachableContext {\n                             }\n                         }\n                     }\n-                    item_impl(ref generics, trait_ref, _, ref methods) => {\n+                    item_impl(ref generics, ref trait_ref, _, ref methods) => {\n                         // XXX(pcwalton): We conservatively assume any methods\n                         // on a trait implementation are reachable, when this\n                         // is not the case. We could be more precise by only"}, {"sha": "b1b2a0083acc364e5550dd0e99a3c3c3d56f8eb5", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -651,18 +651,18 @@ impl DetermineRpCtxt {\n     // with &self type, &self is also bound.  We detect those last two\n     // cases via flags (anon_implies_rp and self_implies_rp) that are\n     // true when the anon or self region implies RP.\n-    pub fn region_is_relevant(&self, r: Option<@ast::Lifetime>) -> bool {\n+    pub fn region_is_relevant(&self, r: &Option<ast::Lifetime>) -> bool {\n         match r {\n-            None => {\n+            &None => {\n                 self.anon_implies_rp\n             }\n-            Some(ref l) if l.ident == special_idents::statik => {\n+            &Some(ref l) if l.ident == special_idents::statik => {\n                 false\n             }\n-            Some(ref l) if l.ident == special_idents::self_ => {\n+            &Some(ref l) if l.ident == special_idents::self_ => {\n                 true\n             }\n-            Some(_) => {\n+            &Some(_) => {\n                 false\n             }\n         }\n@@ -713,10 +713,10 @@ fn determine_rp_in_fn(fk: &visit::fn_kind,\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.iter().advance |a| {\n-                (visitor.visit_ty)(a.ty, (cx, visitor));\n+                (visitor.visit_ty)(&a.ty, (cx, visitor));\n             }\n         }\n-        (visitor.visit_ty)(decl.output, (cx, visitor));\n+        (visitor.visit_ty)(&decl.output, (cx, visitor));\n         let generics = visit::generics_of_fn(fk);\n         (visitor.visit_generics)(&generics, (cx, visitor));\n         (visitor.visit_block)(body, (cx, visitor));\n@@ -731,7 +731,7 @@ fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n     }\n }\n \n-fn determine_rp_in_ty(ty: @ast::Ty,\n+fn determine_rp_in_ty(ty: &ast::Ty,\n                       (cx, visitor): (@mut DetermineRpCtxt,\n                                       visit::vt<@mut DetermineRpCtxt>)) {\n     // we are only interested in types that will require an item to\n@@ -747,7 +747,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     // locations)\n     let sess = cx.sess;\n     match ty.node {\n-        ast::ty_rptr(r, _) => {\n+        ast::ty_rptr(ref r, _) => {\n             debug!(\"referenced rptr type %s\",\n                    pprust::ty_to_str(ty, sess.intr()));\n \n@@ -762,7 +762,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n                    pprust::ty_to_str(ty, sess.intr()));\n             match f.region {\n                 Some(_) => {\n-                    if cx.region_is_relevant(f.region) {\n+                    if cx.region_is_relevant(&f.region) {\n                         let rv = cx.add_variance(rv_contravariant);\n                         cx.add_rp(cx.item_id, rv)\n                     }\n@@ -784,13 +784,13 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     // then check whether it is region-parameterized and consider\n     // that as a direct dependency.\n     match ty.node {\n-      ast::ty_path(path, _bounds, id) => {\n+      ast::ty_path(ref path, _, id) => {\n         match cx.def_map.find(&id) {\n           Some(&ast::def_ty(did)) |\n           Some(&ast::def_trait(did)) |\n           Some(&ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n-                if cx.region_is_relevant(path.rp) {\n+                if cx.region_is_relevant(&path.rp) {\n                     cx.add_dep(did.node);\n                 }\n             } else {\n@@ -800,7 +800,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n                   Some(variance) => {\n                     debug!(\"reference to external, rp'd type %s\",\n                            pprust::ty_to_str(ty, sess.intr()));\n-                    if cx.region_is_relevant(path.rp) {\n+                    if cx.region_is_relevant(&path.rp) {\n                         let rv = cx.add_variance(variance);\n                         cx.add_rp(cx.item_id, rv)\n                     }\n@@ -815,16 +815,16 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     }\n \n     match ty.node {\n-      ast::ty_box(mt) | ast::ty_uniq(mt) | ast::ty_vec(mt) |\n-      ast::ty_rptr(_, mt) | ast::ty_ptr(mt) => {\n+      ast::ty_box(ref mt) | ast::ty_uniq(ref mt) | ast::ty_vec(ref mt) |\n+      ast::ty_rptr(_, ref mt) | ast::ty_ptr(ref mt) => {\n         visit_mt(mt, (cx, visitor));\n       }\n \n-      ast::ty_path(path, _bounds, _) => {\n+      ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for path.types.iter().advance |tp| {\n-                (visitor.visit_ty)(*tp, (cx, visitor));\n+                (visitor.visit_ty)(tp, (cx, visitor));\n             }\n         }\n       }\n@@ -837,10 +837,10 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for decl.inputs.iter().advance |a| {\n-                    (visitor.visit_ty)(a.ty, (cx, visitor));\n+                    (visitor.visit_ty)(&a.ty, (cx, visitor));\n                 }\n             }\n-            (visitor.visit_ty)(decl.output, (cx, visitor));\n+            (visitor.visit_ty)(&decl.output, (cx, visitor));\n         }\n       }\n \n@@ -849,7 +849,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n       }\n     }\n \n-    fn visit_mt(mt: ast::mt,\n+    fn visit_mt(mt: &ast::mt,\n                 (cx, visitor): (@mut DetermineRpCtxt,\n                                 visit::vt<@mut DetermineRpCtxt>)) {\n         // mutability is invariant"}, {"sha": "041d52a690425925d2230ab376a13e76c3f30e79", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -1233,7 +1233,7 @@ impl Resolver {\n                 visit_item(item, (new_parent, visitor));\n             }\n \n-            item_impl(_, None, ty, ref methods) => {\n+            item_impl(_, None, ref ty, ref methods) => {\n                 // If this implements an anonymous trait, then add all the\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n@@ -1243,9 +1243,9 @@ impl Resolver {\n                 // the same module that declared the type.\n \n                 // Create the module and add all methods.\n-                match *ty {\n-                    Ty {\n-                        node: ty_path(path, _, _),\n+                match ty {\n+                    &Ty {\n+                        node: ty_path(ref path, _, _),\n                         _\n                     } if path.idents.len() == 1 => {\n                         let name = path_to_ident(path);\n@@ -1313,7 +1313,7 @@ impl Resolver {\n                 visit_item(item, (parent, visitor));\n             }\n \n-            item_impl(_, Some(_), _ty, ref _methods) => {\n+            item_impl(_, Some(_), _, _) => {\n                 visit_item(item, (parent, visitor));\n             }\n \n@@ -1432,7 +1432,7 @@ impl Resolver {\n     /// Constructs the reduced graph for one 'view item'. View items consist\n     /// of imports and use directives.\n     pub fn build_reduced_graph_for_view_item(@mut self,\n-                                             view_item: @view_item,\n+                                             view_item: &view_item,\n                                              (parent, _):\n                                              (ReducedGraphParent,\n                                               vt<ReducedGraphParent>)) {\n@@ -1446,7 +1446,7 @@ impl Resolver {\n \n                     let mut module_path = ~[];\n                     match view_path.node {\n-                        view_path_simple(_, full_path, _) => {\n+                        view_path_simple(_, ref full_path, _) => {\n                             let path_len = full_path.idents.len();\n                             assert!(path_len != 0);\n \n@@ -1457,8 +1457,8 @@ impl Resolver {\n                             }\n                         }\n \n-                        view_path_glob(module_ident_path, _) |\n-                        view_path_list(module_ident_path, _, _) => {\n+                        view_path_glob(ref module_ident_path, _) |\n+                        view_path_list(ref module_ident_path, _, _) => {\n                             for module_ident_path.idents.iter().advance |ident| {\n                                 module_path.push(*ident);\n                             }\n@@ -1468,7 +1468,7 @@ impl Resolver {\n                     // Build up the import directives.\n                     let module_ = self.get_module_from_parent(parent);\n                     match view_path.node {\n-                        view_path_simple(binding, full_path, id) => {\n+                        view_path_simple(binding, ref full_path, id) => {\n                             let source_ident = *full_path.idents.last();\n                             let subclass = @SingleImport(binding,\n                                                          source_ident);\n@@ -3533,8 +3533,8 @@ impl Resolver {\n             }\n \n             item_impl(ref generics,\n-                      implemented_traits,\n-                      self_type,\n+                      ref implemented_traits,\n+                      ref self_type,\n                       ref methods) => {\n                 self.resolve_implementation(item.id,\n                                             generics,\n@@ -3561,7 +3561,7 @@ impl Resolver {\n \n                     // Resolve derived traits.\n                     for traits.iter().advance |trt| {\n-                        self.resolve_trait_reference(*trt, visitor, TraitDerivation);\n+                        self.resolve_trait_reference(trt, visitor, TraitDerivation);\n                     }\n \n                     for (*methods).iter().advance |method| {\n@@ -3585,10 +3585,10 @@ impl Resolver {\n                                     visitor);\n \n                                 for ty_m.decl.inputs.iter().advance |argument| {\n-                                    self.resolve_type(argument.ty, visitor);\n+                                    self.resolve_type(&argument.ty, visitor);\n                                 }\n \n-                                self.resolve_type(ty_m.decl.output, visitor);\n+                                self.resolve_type(&ty_m.decl.output, visitor);\n                             }\n                           }\n                           provided(m) => {\n@@ -3778,12 +3778,12 @@ impl Resolver {\n                                              None,\n                                              visitor);\n \n-                        self.resolve_type(argument.ty, visitor);\n+                        self.resolve_type(&argument.ty, visitor);\n \n                         debug!(\"(resolving function) recorded argument\");\n                     }\n \n-                    self.resolve_type(declaration.output, visitor);\n+                    self.resolve_type(&declaration.output, visitor);\n                 }\n             }\n \n@@ -3811,7 +3811,7 @@ impl Resolver {\n                                         type_parameter_bound: &TyParamBound,\n                                         visitor: ResolveVisitor) {\n         match *type_parameter_bound {\n-            TraitTyParamBound(tref) => {\n+            TraitTyParamBound(ref tref) => {\n                 self.resolve_trait_reference(tref, visitor, TraitBoundingTypeParameter)\n             }\n             RegionTyParamBound => {}\n@@ -3822,7 +3822,7 @@ impl Resolver {\n                                    trait_reference: &trait_ref,\n                                    visitor: ResolveVisitor,\n                                    reference_type: TraitReferenceType) {\n-        match self.resolve_path(trait_reference.path, TypeNS, true, visitor) {\n+        match self.resolve_path(&trait_reference.path, TypeNS, true, visitor) {\n             None => {\n                 let path_str = self.idents_to_str(trait_reference.path.idents);\n \n@@ -3878,7 +3878,7 @@ impl Resolver {\n \n             // Resolve fields.\n             for fields.iter().advance |field| {\n-                self.resolve_type(field.node.ty, visitor);\n+                self.resolve_type(&field.node.ty, visitor);\n             }\n         }\n     }\n@@ -3913,8 +3913,8 @@ impl Resolver {\n     pub fn resolve_implementation(@mut self,\n                                   id: node_id,\n                                   generics: &Generics,\n-                                  opt_trait_reference: Option<@trait_ref>,\n-                                  self_type: @Ty,\n+                                  opt_trait_reference: &Option<trait_ref>,\n+                                  self_type: &Ty,\n                                   methods: &[@method],\n                                   visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n@@ -3929,7 +3929,7 @@ impl Resolver {\n             // Resolve the trait reference, if necessary.\n             let original_trait_refs;\n             match opt_trait_reference {\n-                Some(trait_reference) => {\n+                &Some(ref trait_reference) => {\n                     self.resolve_trait_reference(trait_reference, visitor, TraitImplementation);\n \n                     // Record the current set of trait references.\n@@ -3944,7 +3944,7 @@ impl Resolver {\n                         &mut self.current_trait_refs,\n                         Some(new_trait_refs)));\n                 }\n-                None => {\n+                &None => {\n                     original_trait_refs = None;\n                 }\n             }\n@@ -4001,7 +4001,7 @@ impl Resolver {\n         let mutability = if local.node.is_mutbl {Mutable} else {Immutable};\n \n         // Resolve the type.\n-        self.resolve_type(local.node.ty, visitor);\n+        self.resolve_type(&local.node.ty, visitor);\n \n         // Resolve the initializer, if necessary.\n         match local.node.init {\n@@ -4112,12 +4112,12 @@ impl Resolver {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    pub fn resolve_type(@mut self, ty: @Ty, visitor: ResolveVisitor) {\n+    pub fn resolve_type(@mut self, ty: &Ty, visitor: ResolveVisitor) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n \n-            ty_path(path, bounds, path_id) => {\n+            ty_path(ref path, ref bounds, path_id) => {\n                 // This is a path in the type namespace. Walk through scopes\n                 // scopes looking for it.\n                 let mut result_def = None;\n@@ -4211,7 +4211,7 @@ impl Resolver {\n         let pat_id = pattern.id;\n         for walk_pat(pattern) |pattern| {\n             match pattern.node {\n-                pat_ident(binding_mode, path, _)\n+                pat_ident(binding_mode, ref path, _)\n                         if !path.global && path.idents.len() == 1 => {\n \n                     // The meaning of pat_ident with no type parameters\n@@ -4334,11 +4334,11 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.iter().advance |ty| {\n-                        self.resolve_type(*ty, visitor);\n+                        self.resolve_type(ty, visitor);\n                     }\n                 }\n \n-                pat_ident(binding_mode, path, _) => {\n+                pat_ident(binding_mode, ref path, _) => {\n                     // This must be an enum variant, struct, or constant.\n                     match self.resolve_path(path, ValueNS, false, visitor) {\n                         Some(def @ def_variant(*)) |\n@@ -4367,11 +4367,11 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.iter().advance |ty| {\n-                        self.resolve_type(*ty, visitor);\n+                        self.resolve_type(ty, visitor);\n                     }\n                 }\n \n-                pat_enum(path, _) => {\n+                pat_enum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n                     match self.resolve_path(path, ValueNS, false, visitor) {\n                         Some(def @ def_fn(*))      |\n@@ -4396,7 +4396,7 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.iter().advance |ty| {\n-                        self.resolve_type(*ty, visitor);\n+                        self.resolve_type(ty, visitor);\n                     }\n                 }\n \n@@ -4409,7 +4409,7 @@ impl Resolver {\n                     self.resolve_expr(last_expr, visitor);\n                 }\n \n-                pat_struct(path, _, _) => {\n+                pat_struct(ref path, _, _) => {\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n                                 if self.structs.contains(&class_id) => {\n@@ -4484,14 +4484,14 @@ impl Resolver {\n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n     pub fn resolve_path(@mut self,\n-                        path: @Path,\n+                        path: &Path,\n                         namespace: Namespace,\n                         check_ribs: bool,\n                         visitor: ResolveVisitor)\n                         -> Option<def> {\n         // First, resolve the types.\n         for path.types.iter().advance |ty| {\n-            self.resolve_type(*ty, visitor);\n+            self.resolve_type(ty, visitor);\n         }\n \n         if path.global {\n@@ -4610,7 +4610,7 @@ impl Resolver {\n         return NoNameDefinition;\n     }\n \n-    pub fn intern_module_part_of_path(@mut self, path: @Path) -> ~[ident] {\n+    pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n         for path.idents.iter().enumerate().advance |(index, ident)| {\n             if index == path.idents.len() - 1 {\n@@ -4624,7 +4624,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_module_relative_path(@mut self,\n-                                        path: @Path,\n+                                        path: &Path,\n                                         xray: XrayFlag,\n                                         namespace: Namespace)\n                                         -> Option<def> {\n@@ -4690,7 +4690,7 @@ impl Resolver {\n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n     pub fn resolve_crate_relative_path(@mut self,\n-                                       path: @Path,\n+                                       path: &Path,\n                                        xray: XrayFlag,\n                                        namespace: Namespace)\n                                        -> Option<def> {\n@@ -4916,7 +4916,7 @@ impl Resolver {\n             // The interpretation of paths depends on whether the path has\n             // multiple elements in it or not.\n \n-            expr_path(path) => {\n+            expr_path(ref path) => {\n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n \n@@ -4985,7 +4985,7 @@ impl Resolver {\n                                       visitor);\n             }\n \n-            expr_struct(path, _, _) => {\n+            expr_struct(ref path, _, _) => {\n                 // Resolve the path to the structure it goes to.\n                 match self.resolve_path(path, TypeNS, false, visitor) {\n                     Some(def_ty(class_id)) | Some(def_struct(class_id))\n@@ -5295,7 +5295,7 @@ impl Resolver {\n         visit_crate(self.crate, ((), vt));\n     }\n \n-    pub fn check_for_item_unused_imports(&mut self, vi: @view_item) {\n+    pub fn check_for_item_unused_imports(&mut self, vi: &view_item) {\n         // Ignore public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the"}, {"sha": "3e828a891d49eac71b946147857e75a617919e35", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -385,7 +385,7 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n \n     do m.map |br| {\n         match br.pats[col].node {\n-            ast::pat_ident(_, path, Some(inner)) => {\n+            ast::pat_ident(_, ref path, Some(inner)) => {\n                 let pats = vec::append(\n                     br.pats.slice(0u, col).to_owned(),\n                     vec::append(~[inner],\n@@ -441,7 +441,7 @@ pub fn enter_match<'r>(bcx: block,\n \n                 let this = br.pats[col];\n                 match this.node {\n-                    ast::pat_ident(_, path, None) => {\n+                    ast::pat_ident(_, ref path, None) => {\n                         if pat_is_binding(dm, this) {\n                             let binding_info =\n                                 br.data.bindings_map.get("}, {"sha": "e6384ae4d0d3428aad15c2bcb19c8b9b4418bbec", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -1399,7 +1399,7 @@ pub fn alloc_local(cx: block, local: &ast::local) -> block {\n     let _icx = push_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n-      ast::pat_ident(_, pth, None) => Some(path_to_ident(pth)),\n+      ast::pat_ident(_, ref pth, None) => Some(path_to_ident(pth)),\n       _ => None\n     };\n     let val = alloc_ty(cx, t);\n@@ -1737,7 +1737,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         fcx.llargs.insert(arg_id, llarg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n-            debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n+            debuginfo::create_arg(bcx, &args[arg_n], args[arg_n].ty.span);\n         }\n     }\n \n@@ -1911,7 +1911,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n     let fn_args = do args.map |varg| {\n         ast::arg {\n             is_mutbl: false,\n-            ty: varg.ty,\n+            ty: copy varg.ty,\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),\n                 codemap::dummy_sp(),\n@@ -1985,7 +1985,7 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n     let fn_args = do fields.map |field| {\n         ast::arg {\n             is_mutbl: false,\n-            ty: field.node.ty,\n+            ty: copy field.node.ty,\n             pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n                                         codemap::dummy_sp(),\n                                         special_idents::arg),"}, {"sha": "1030af9787868e7504bcda9447c82c88ec9a85ab", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -34,9 +34,6 @@ use std::cast::transmute;\n use std::cast;\n use std::hashmap::{HashMap};\n use std::libc::{c_uint, c_longlong, c_ulonglong};\n-use std::to_bytes;\n-use std::str;\n-use std::vec::raw::to_ptr;\n use std::vec;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};"}, {"sha": "bbec78880fe23b323d2e67b2bc0811a6ad66fd57", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -525,7 +525,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n-          ast::expr_path(pth) => {\n+          ast::expr_path(ref pth) => {\n             assert_eq!(pth.types.len(), 0);\n             let tcx = cx.tcx;\n             match tcx.def_map.find(&e.id) {"}, {"sha": "fc73d80537987ef04d154edb7f1f07a976f9e5d7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -133,7 +133,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n     let cx = bcx.ccx();\n \n     let ident = match local.node.pat.node {\n-      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n+      ast::pat_ident(_, ref pth, _) => ast_util::path_to_ident(pth),\n       // FIXME this should be handled (#2533)\n       _ => {\n         bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n@@ -182,7 +182,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n+pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n     debug!(\"create_arg\");\n     if true {\n         // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n@@ -204,7 +204,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n     let context = create_function(fcx);\n \n     match arg.pat.node {\n-        ast::pat_ident(_, path, _) => {\n+        ast::pat_ident(_, ref path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n             let ident = path.idents.last();\n             let name: &str = cx.sess.str_of(*ident);\n@@ -259,23 +259,25 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let fcx = &mut *fcx;\n     let span = fcx.span.get();\n \n-    let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n-      ast_map::node_item(item, _) => {\n+    let fnitem = cx.tcx.items.get_copy(&fcx.id);\n+    let (ident, ret_ty, id) = match fnitem {\n+      ast_map::node_item(ref item, _) => {\n         match item.node {\n-          ast::item_fn(ref decl, _, _, _, _) => {\n-            (item.ident, decl.output, item.id)\n+          ast::item_fn(ast::fn_decl { output: ref ty, _}, _, _, _, _) => {\n+            (item.ident, ty, item.id)\n           }\n           _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n         }\n       }\n-      ast_map::node_method(method, _, _) => {\n-          (method.ident, method.decl.output, method.id)\n+      ast_map::node_method(@ast::method { decl: ast::fn_decl { output: ref ty, _ },\n+                           id: id, ident: ident, _}, _, _) => {\n+          (ident, ty, id)\n       }\n-      ast_map::node_expr(expr) => {\n+      ast_map::node_expr(ref expr) => {\n         match expr.node {\n           ast::expr_fn_block(ref decl, _) => {\n             let name = gensym_name(\"fn\");\n-            (name, decl.output, expr.id)\n+            (name, &decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n                   \"create_function: expected an expr_fn_block here\")"}, {"sha": "ca469a42103a2a7d27fe75ccbdff7f7773d90cdf", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -548,7 +548,6 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n \n     let _icx = push_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n-    let mut bcx = bcx;\n \n     // Load the vtable from the @Trait pair\n     debug!(\"(translating trait callee) loading vtable from pair %s\","}, {"sha": "adecd61bc4f4cd4690d642c2a4fdea2de118e410", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n \n-use back;\n use lib::llvm::ValueRef;\n use middle::trans::base::*;\n use middle::trans::build::*;"}, {"sha": "129208a9aa37eabc1210674ab5aa33959a377e4b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -3624,12 +3624,12 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n             debug!(\"(impl_trait_ref) searching for trait impl %?\", id);\n             match cx.items.find(&id.node) {\n                 Some(&ast_map::node_item(@ast::item {\n-                                         node: ast::item_impl(_, opt_trait, _, _),\n+                                         node: ast::item_impl(_, ref opt_trait, _, _),\n                                          _},\n                                          _)) => {\n                     match opt_trait {\n-                        Some(t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n-                        None => None\n+                        &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n+                        &None => None\n                     }\n                 }\n                 _ => None"}, {"sha": "9442eb0b83869b427be2a8b17b322629d9d8c40f", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -85,15 +85,15 @@ pub trait AstConv {\n pub fn get_region_reporting_err(\n     tcx: ty::ctxt,\n     span: span,\n-    a_r: Option<@ast::Lifetime>,\n+    a_r: &Option<ast::Lifetime>,\n     res: Result<ty::Region, RegionError>) -> ty::Region\n {\n     match res {\n         result::Ok(r) => r,\n         result::Err(ref e) => {\n             let descr = match a_r {\n-                None => ~\"anonymous lifetime\",\n-                Some(a) => fmt!(\"lifetime %s\",\n+                &None => ~\"anonymous lifetime\",\n+                &Some(ref a) => fmt!(\"lifetime %s\",\n                                 lifetime_to_str(a, tcx.sess.intr()))\n             };\n             tcx.sess.span_err(\n@@ -109,19 +109,19 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + 'static>(\n     this: &AC,\n     rscope: &RS,\n     default_span: span,\n-    opt_lifetime: Option<@ast::Lifetime>) -> ty::Region\n+    opt_lifetime: &Option<ast::Lifetime>) -> ty::Region\n {\n     let (span, res) = match opt_lifetime {\n-        None => {\n+        &None => {\n             (default_span, rscope.anon_region(default_span))\n         }\n-        Some(ref lifetime) if lifetime.ident == special_idents::statik => {\n+        &Some(ref lifetime) if lifetime.ident == special_idents::statik => {\n             (lifetime.span, Ok(ty::re_static))\n         }\n-        Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n+        &Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n             (lifetime.span, rscope.self_region(lifetime.span))\n         }\n-        Some(ref lifetime) => {\n+        &Some(ref lifetime) => {\n             (lifetime.span, rscope.named_region(lifetime.span,\n                                                 lifetime.ident))\n         }\n@@ -136,7 +136,7 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n     def_id: ast::def_id,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n-    path: @ast::Path) -> ty::substs\n+    path: &ast::Path) -> ty::substs\n {\n     /*!\n      *\n@@ -164,11 +164,11 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n       }\n       (&Some(_), &None) => {\n         let res = rscope.anon_region(path.span);\n-        let r = get_region_reporting_err(this.tcx(), path.span, None, res);\n+        let r = get_region_reporting_err(this.tcx(), path.span, &None, res);\n         Some(r)\n       }\n       (&Some(_), &Some(_)) => {\n-        Some(ast_region_to_region(this, rscope, path.span, path.rp))\n+        Some(ast_region_to_region(this, rscope, path.span, &path.rp))\n       }\n     };\n \n@@ -179,7 +179,7 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n                  decl_generics.type_param_defs.len(), path.types.len()));\n     }\n-    let tps = path.types.map(|a_t| ast_ty_to_ty(this, rscope, *a_t));\n+    let tps = path.types.map(|a_t| ast_ty_to_ty(this, rscope, a_t));\n \n     substs {self_r:self_r, self_ty:self_ty, tps:tps}\n }\n@@ -188,7 +188,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::def_id,\n-    path: @ast::Path) -> ty_param_substs_and_ty\n+    path: &ast::Path) -> ty_param_substs_and_ty\n {\n     let tcx = this.tcx();\n     let ty::ty_param_bounds_and_ty {\n@@ -206,7 +206,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + 'static>(\n     rscope: &RS,\n     trait_def_id: ast::def_id,\n     self_ty: Option<ty::t>,\n-    path: @ast::Path) -> @ty::TraitRef\n+    path: &ast::Path) -> @ty::TraitRef\n {\n     let trait_def =\n         this.get_trait_def(trait_def_id);\n@@ -228,7 +228,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + 'static>(\n         this: &AC,\n         rscope: &RS,\n         did: ast::def_id,\n-        path: @ast::Path)\n+        path: &ast::Path)\n      -> ty_param_substs_and_ty\n {\n     // Look up the polytype of the item and then substitute the provided types\n@@ -276,7 +276,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                 }\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n-            ast::ty_path(path, bounds, id) => {\n+            ast::ty_path(ref path, ref bounds, id) => {\n                 // Note that the \"bounds must be empty if path is not a trait\"\n                 // restriction is enforced in the below case for ty_path, which\n                 // will run after this as long as the path isn't a trait.\n@@ -321,7 +321,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n     }\n \n     fn check_path_args(tcx: ty::ctxt,\n-                       path: @ast::Path,\n+                       path: &ast::Path,\n                        flags: uint) {\n         if (flags & NO_TPS) != 0u {\n             if path.types.len() > 0u {\n@@ -371,13 +371,13 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n       ast::ty_ptr(ref mt) => {\n         ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n       }\n-      ast::ty_rptr(region, ref mt) => {\n+      ast::ty_rptr(ref region, ref mt) => {\n         let r = ast_region_to_region(this, rscope, ast_ty.span, region);\n         mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(ref fields) => {\n-        let flds = fields.map(|t| ast_ty_to_ty(this, rscope, *t));\n+        let flds = fields.map(|t| ast_ty_to_ty(this, rscope, t));\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_bare_fn(ref bf) => {\n@@ -398,14 +398,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                       f.purity,\n                                       f.onceness,\n                                       bounds,\n-                                      f.region,\n+                                      &f.region,\n                                       &f.decl,\n                                       None,\n                                       &f.lifetimes,\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n-      ast::ty_path(path, bounds, id) => {\n+      ast::ty_path(ref path, ref bounds, id) => {\n         let a_def = match tcx.def_map.find(&id) {\n           None => tcx.sess.span_fatal(\n               ast_ty.span, fmt!(\"unbound path %s\",\n@@ -525,13 +525,13 @@ pub fn ty_of_arg<AC:AstConv,\n                  RS:region_scope + Copy + 'static>(\n                  this: &AC,\n                  rscope: &RS,\n-                 a: ast::arg,\n+                 a: &ast::arg,\n                  expected_ty: Option<ty::t>)\n                  -> ty::t {\n     match a.ty.node {\n         ast::ty_infer if expected_ty.is_some() => expected_ty.get(),\n         ast::ty_infer => this.ty_infer(a.ty.span),\n-        _ => ast_ty_to_ty(this, rscope, a.ty),\n+        _ => ast_ty_to_ty(this, rscope, &a.ty),\n     }\n }\n \n@@ -621,11 +621,11 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n         transform_self_ty(this, &rb, self_info)\n     });\n \n-    let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, *a, None));\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, a, None));\n \n     let output_ty = match decl.output.node {\n         ast::ty_infer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &decl.output)\n     };\n \n     return (opt_transformed_self_ty,\n@@ -647,7 +647,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n             ast::sty_value => {\n                 Some(self_info.untransformed_self_ty)\n             }\n-            ast::sty_region(lifetime, mutability) => {\n+            ast::sty_region(ref lifetime, mutability) => {\n                 let region =\n                     ast_region_to_region(this, rscope,\n                                          self_info.explicit_self.span,\n@@ -677,7 +677,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     purity: ast::purity,\n     onceness: ast::Onceness,\n     bounds: ty::BuiltinBounds,\n-    opt_lifetime: Option<@ast::Lifetime>,\n+    opt_lifetime: &Option<ast::Lifetime>,\n     decl: &ast::fn_decl,\n     expected_sig: Option<ty::FnSig>,\n     lifetimes: &OptVec<ast::Lifetime>,\n@@ -695,10 +695,10 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     // resolve the function bound region in the original region\n     // scope `rscope`, not the scope of the function parameters\n     let bound_region = match opt_lifetime {\n-        Some(_) => {\n+        &Some(_) => {\n             ast_region_to_region(this, rscope, span, opt_lifetime)\n         }\n-        None => {\n+        &None => {\n             match sigil {\n                 ast::OwnedSigil | ast::ManagedSigil => {\n                     // @fn(), ~fn() default to static as the bound\n@@ -724,14 +724,14 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n         };\n-        ty_of_arg(this, &rb, *a, expected_arg_ty)\n+        ty_of_arg(this, &rb, a, expected_arg_ty)\n     }.collect();\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {\n         ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n         ast::ty_infer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &decl.output)\n     };\n \n     ty::ClosureTy {\n@@ -764,7 +764,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n             let mut builtin_bounds = ty::EmptyBuiltinBounds();\n             for bound_vec.iter().advance |ast_bound| {\n                 match *ast_bound {\n-                    ast::TraitTyParamBound(b) => {\n+                    ast::TraitTyParamBound(ref b) => {\n                         match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n                             ast::def_trait(trait_did) => {\n                                 if try_add_builtin_trait(tcx,"}, {"sha": "1f7946576db5c6cd95c010b952403a000e27a5bf", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -105,7 +105,7 @@ pub struct pat_ctxt {\n     map: PatIdMap,\n }\n \n-pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n+pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                          subpats: &Option<~[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n@@ -271,7 +271,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                                span: span,\n-                               path: @ast::Path,\n+                               path: &ast::Path,\n                                fields: &[ast::field_pat],\n                                class_fields: ~[ty::field_ty],\n                                class_id: ast::def_id,\n@@ -322,7 +322,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n }\n \n pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::node_id, span: span,\n-                        expected: ty::t, path: @ast::Path,\n+                        expected: ty::t, path: &ast::Path,\n                         fields: &[ast::field_pat], etc: bool,\n                         class_id: ast::def_id, substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n@@ -356,7 +356,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n                                           pat_id: ast::node_id,\n                                           span: span,\n                                           expected: ty::t,\n-                                          path: @ast::Path,\n+                                          path: &ast::Path,\n                                           fields: &[ast::field_pat],\n                                           etc: bool,\n                                           enum_id: ast::def_id,\n@@ -440,7 +440,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);\n       }\n-      ast::pat_ident(bm, name, sub) if pat_is_binding(tcx.def_map, pat) => {\n+      ast::pat_ident(bm, ref name, sub) if pat_is_binding(tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {\n@@ -476,13 +476,13 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ => ()\n         }\n       }\n-      ast::pat_ident(_, path, _) => {\n+      ast::pat_ident(_, ref path, _) => {\n         check_pat_variant(pcx, pat, path, &Some(~[]), expected);\n       }\n-      ast::pat_enum(path, ref subpats) => {\n+      ast::pat_enum(ref path, ref subpats) => {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n-      ast::pat_struct(path, ref fields, etc) => {\n+      ast::pat_struct(ref path, ref fields, etc) => {\n         // Grab the class data that we care about.\n         let structure = structure_of(fcx, pat.span, expected);\n         let mut error_happened = false;"}, {"sha": "5c8ce6b2d8bb03f51ac897fe81190696c1171b18", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -463,7 +463,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             }\n \n             // Check the pattern.\n-            let region = fcx.block_region();\n             let pcx = pat_ctxt {\n                 fcx: fcx,\n                 map: pat_id_map(tcx.def_map, input.pat),\n@@ -476,7 +475,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 |local, (e, v)| {\n             let o_ty = match local.node.ty.node {\n               ast::ty_infer => None,\n-              _ => Some(fcx.to_ty(local.node.ty))\n+              _ => Some(fcx.to_ty(&local.node.ty))\n             };\n             assign(local.node.id, o_ty);\n             debug!(\"Local variable %s is assigned type %s\",\n@@ -489,7 +488,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Add pattern bindings.\n         let visit_pat: @fn(@ast::pat, ((), visit::vt<()>)) = |p, (e, v)| {\n             match p.node {\n-              ast::pat_ident(_, path, _)\n+              ast::pat_ident(_, ref path, _)\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n@@ -624,7 +623,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_struct(*) => {\n         check_struct(ccx, it.id, it.span);\n       }\n-      ast::item_ty(t, ref generics) => {\n+      ast::item_ty(ref t, ref generics) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n       }\n@@ -790,7 +789,7 @@ impl FnCtxt {\n         self.write_ty(node_id, ty::mk_err());\n     }\n \n-    pub fn to_ty(&self, ast_t: @ast::Ty) -> ty::t {\n+    pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n@@ -1381,7 +1380,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n                          args: &[@ast::expr],\n-                         tps: &[@ast::Ty],\n+                         tps: &[ast::Ty],\n                          sugar: ast::CallSugar) {\n         check_expr(fcx, rcvr);\n \n@@ -1390,7 +1389,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                 expr.span,\n                                                 fcx.expr_ty(rcvr));\n \n-        let tps = tps.map(|ast_ty| fcx.to_ty(*ast_ty));\n+        let tps = tps.map(|ast_ty| fcx.to_ty(ast_ty));\n         match method::lookup(fcx,\n                              expr,\n                              rcvr,\n@@ -1738,7 +1737,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            purity,\n                                            expected_onceness,\n                                            expected_bounds,\n-                                           None,\n+                                           &None,\n                                            decl,\n                                            expected_sig,\n                                            &opt_vec::Empty,\n@@ -1779,7 +1778,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n                    base: @ast::expr,\n                    field: ast::ident,\n-                   tys: &[@ast::Ty]) {\n+                   tys: &[ast::Ty]) {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -1809,7 +1808,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => ()\n         }\n \n-        let tps = tys.iter().transform(|ty| fcx.to_ty(*ty)).collect::<~[ty::t]>();\n+        let tps : ~[ty::t] = tys.iter().transform(|ty| fcx.to_ty(ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2437,7 +2436,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n         fcx.write_ty(id, oprnd_t);\n       }\n-      ast::expr_path(pth) => {\n+      ast::expr_path(ref pth) => {\n         let defn = lookup_def(fcx, pth.span, id);\n \n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n@@ -2622,7 +2621,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::expr_cast(e, t) => {\n+      ast::expr_cast(e, ref t) => {\n         check_expr(fcx, e);\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n@@ -2775,7 +2774,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_ty(id, typ);\n         }\n       }\n-      ast::expr_struct(path, ref fields, base_expr) => {\n+      ast::expr_struct(ref path, ref fields, base_expr) => {\n         // Resolve the path.\n         match tcx.def_map.find(&id) {\n             Some(&ast::def_struct(type_def_id)) => {\n@@ -2892,7 +2891,6 @@ pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local)  {\n         _ => {}\n     }\n \n-    let region = tcx.region_maps.encl_region(local.node.id);\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),\n@@ -3286,7 +3284,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n pub fn instantiate_path(fcx: @mut FnCtxt,\n-                        pth: @ast::Path,\n+                        pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         span: span,\n                         node_id: ast::node_id) {\n@@ -3310,7 +3308,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n             None\n           }\n           Some(_) => { // ...and the type is lifetime parameterized, ok.\n-            Some(ast_region_to_region(fcx, fcx, span, pth.rp))\n+            Some(ast_region_to_region(fcx, fcx, span, &pth.rp))\n           }\n         }\n       }\n@@ -3336,7 +3334,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n             (span, \"not enough type parameters provided for this item\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n-        pth.types.map(|aty| fcx.to_ty(*aty))\n+        pth.types.map(|aty| fcx.to_ty(aty))\n     };\n \n     let substs = substs { self_r: self_r, self_ty: None, tps: tps };"}, {"sha": "65b40fbd48c5d3a3491c8809bf65cd050d3769af", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -36,11 +36,9 @@ use middle::typeck::check::regionmanip::relate_nested_regions;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n-use util::ppaux::{note_and_explain_region, ty_to_str,\n-                  region_to_str};\n+use util::ppaux::{ty_to_str, region_to_str};\n use middle::pat_util;\n \n-use std::result;\n use std::uint;\n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n@@ -419,8 +417,6 @@ fn constrain_callee(rcx: @mut Rcx,\n                     call_expr: @ast::expr,\n                     callee_expr: @ast::expr)\n {\n-    let tcx = rcx.fcx.tcx();\n-\n     let call_region = ty::re_scope(call_expr.id);\n \n     let callee_ty = rcx.resolve_node_type(callee_id);\n@@ -559,8 +555,6 @@ fn constrain_index(rcx: @mut Rcx,\n      * includes the deref expr.\n      */\n \n-    let tcx = rcx.fcx.tcx();\n-\n     debug!(\"constrain_index(index_expr=?, indexed_ty=%s\",\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n "}, {"sha": "473d5b8e6e8804e3375f12d862635dc143a96006", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -207,9 +207,11 @@ impl CoherenceChecker {\n //                       self.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n-                    item_impl(_, opt_trait, _, _) => {\n-                        self.check_implementation(item,\n-                                                  opt_trait.iter().transform(|&x| x).collect());\n+                    item_impl(_, ref opt_trait, _, _) => {\n+                        let opt_trait : ~[trait_ref] = opt_trait.iter()\n+                                                                .transform(|&x| x)\n+                                                                .collect();\n+                        self.check_implementation(item, opt_trait);\n                     }\n                     _ => {\n                         // Nothing to do.\n@@ -238,7 +240,7 @@ impl CoherenceChecker {\n \n     pub fn check_implementation(&self,\n                                 item: @item,\n-                                associated_traits: ~[@trait_ref]) {\n+                                associated_traits: &[trait_ref]) {\n         let tcx = self.crate_context.tcx;\n         let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n \n@@ -636,7 +638,7 @@ impl CoherenceChecker {\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, ((), visitor));\n                     }\n-                    item_impl(_, None, ast_ty, _) => {\n+                    item_impl(_, None, ref ast_ty, _) => {\n                         if !self.ast_type_is_defined_in_local_crate(ast_ty) {\n                             // This is an error.\n                             let session = self.crate_context.tcx.sess;\n@@ -646,7 +648,7 @@ impl CoherenceChecker {\n                                               a trait or new type instead\");\n                         }\n                     }\n-                    item_impl(_, Some(trait_ref), _, _) => {\n+                    item_impl(_, Some(ref trait_ref), _, _) => {\n                         // `for_ty` is `Type` in `impl Trait for Type`\n                         let for_ty =\n                             ty::node_id_to_type(self.crate_context.tcx,\n@@ -678,7 +680,7 @@ impl CoherenceChecker {\n         })));\n     }\n \n-    pub fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {\n+    pub fn trait_ref_to_trait_def_id(&self, trait_ref: &trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n         let trait_def = def_map.get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n@@ -723,7 +725,7 @@ impl CoherenceChecker {\n     /// For coherence, when we have `impl Type`, we need to guarantee that\n     /// `Type` is \"local\" to the crate. For our purposes, this means that it\n     /// must precisely name some nominal type defined in this crate.\n-    pub fn ast_type_is_defined_in_local_crate(&self, original_type: @ast::Ty)\n+    pub fn ast_type_is_defined_in_local_crate(&self, original_type: &ast::Ty)\n                                               -> bool {\n         match original_type.node {\n             ty_path(_, _, path_id) => {\n@@ -805,7 +807,7 @@ impl CoherenceChecker {\n                 // Check that we have implementations of every trait method\n                 for trait_refs.iter().advance |trait_ref| {\n                     let trait_did =\n-                        self.trait_ref_to_trait_def_id(*trait_ref);\n+                        self.trait_ref_to_trait_def_id(trait_ref);\n                     self.please_check_that_trait_methods_are_implemented(\n                         &mut methods,\n                         trait_did,\n@@ -817,7 +819,7 @@ impl CoherenceChecker {\n                 // if a method of that name is not inherent to the\n                 // impl, use the provided definition in the trait.\n                 for trait_refs.iter().advance |trait_ref| {\n-                    let trait_did = self.trait_ref_to_trait_def_id(*trait_ref);\n+                    let trait_did = self.trait_ref_to_trait_def_id(trait_ref);\n                     self.add_provided_methods_to_impl(\n                         &mut methods,\n                         &trait_did,"}, {"sha": "fb88f198231f807203e3c50be8ba832a8cc605b5", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -148,7 +148,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let rs = type_rscope(region_parameterization);\n-                let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n+                let input_tys = args.map(|va| ccx.to_ty(&rs, &va.ty));\n                 result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n             }\n \n@@ -378,15 +378,15 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::node_id,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n-                          ast_trait_refs: &[@ast::trait_ref],\n+                          ast_trait_refs: &[ast::trait_ref],\n                           generics: &ast::Generics)\n {\n     let tcx = ccx.tcx;\n     if tcx.supertraits.contains_key(&local_def(id)) { return; }\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n     let mut ty_trait_refs: ~[@ty::TraitRef] = ~[];\n-    for ast_trait_refs.iter().advance |&ast_trait_ref| {\n+    for ast_trait_refs.iter().advance |ast_trait_ref| {\n         let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n                                               generics, self_ty);\n \n@@ -441,7 +441,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n                       but not in the trait\",\n                      tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(impl_m.explicit_self, tcx.sess.intr())));\n+                     explicit_self_to_str(&impl_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         (_, &ast::sty_static) => {\n@@ -450,7 +450,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n                       but not in the impl\",\n                      tcx.sess.str_of(trait_m.ident),\n-                     explicit_self_to_str(trait_m.explicit_self, tcx.sess.intr())));\n+                     explicit_self_to_str(&trait_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n         _ => {\n@@ -671,7 +671,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                     impl_m.span,\n                     fmt!(\"method `%s` is not a member of trait `%s`\",\n                          tcx.sess.str_of(impl_m.mty.ident),\n-                         path_to_str(a_trait_ty.path, tcx.sess.intr())));\n+                         path_to_str(&a_trait_ty.path, tcx.sess.intr())));\n             }\n         }\n     }\n@@ -684,7 +684,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n                      generics: &ast::Generics) {\n     let region_parameterization =\n         RegionParameterization::from_variance_and_generics(rp, generics);\n-    let tt = ccx.to_ty(&type_rscope(region_parameterization), v.node.ty);\n+    let tt = ccx.to_ty(&type_rscope(region_parameterization), &v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n@@ -813,7 +813,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                generics,\n                                rp);\n       }\n-      ast::item_impl(ref generics, opt_trait_ref, selfty, ref ms) => {\n+      ast::item_impl(ref generics, ref opt_trait_ref, ref selfty, ref ms) => {\n         let i_ty_generics = ty_generics(ccx, rp, generics, 0);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n@@ -839,7 +839,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                   &i_ty_generics, generics,\n                                   parent_visibility);\n         for opt_trait_ref.iter().advance |t| {\n-            check_methods_against_trait(ccx, generics, rp, selfty, *t, cms);\n+            check_methods_against_trait(ccx, generics, rp, selfty, t, cms);\n         }\n       }\n       ast::item_trait(ref generics, ref supertraits, ref trait_methods) => {\n@@ -966,7 +966,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n         ast::def_trait(trait_did) => {\n             let trait_ref =\n                 astconv::ast_path_to_trait_ref(\n-                    ccx, &rscope, trait_did, Some(self_ty), ast_trait_ref.path);\n+                    ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n             ccx.tcx.trait_refs.insert(\n                 ast_trait_ref.ref_id, trait_ref);\n             return trait_ref;\n@@ -975,7 +975,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n             ccx.tcx.sess.span_fatal(\n                 ast_trait_ref.path.span,\n                 fmt!(\"%s is not a trait\",\n-                    path_to_str(ast_trait_ref.path,\n+                    path_to_str(&ast_trait_ref.path,\n                                 ccx.tcx.sess.intr())));\n         }\n     }\n@@ -1031,7 +1031,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n     }\n     let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n     match it.node {\n-      ast::item_static(t, _, _) => {\n+      ast::item_static(ref t, _, _) => {\n         let typ = ccx.to_ty(&empty_rscope, t);\n         let tpt = no_params(typ);\n         tcx.tcache.insert(local_def(it.id), tpt);\n@@ -1060,7 +1060,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_ty(t, ref generics) => {\n+      ast::item_ty(ref t, ref generics) => {\n         match tcx.tcache.find(&local_def(it.id)) {\n           Some(&tpt) => return tpt,\n           None => { }\n@@ -1124,7 +1124,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                                   generics,\n                                   abis)\n         }\n-        ast::foreign_item_static(t, _) => {\n+        ast::foreign_item_static(ref t, _) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @~[],\n@@ -1149,7 +1149,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n                     let param_ty = ty::param_ty {idx: base_index + offset,\n                                                  def_id: local_def(param.id)};\n                     let bounds = @compute_bounds(ccx, rp, generics,\n-                                                 param_ty, param.bounds);\n+                                                 param_ty, &param.bounds);\n                     let def = ty::TypeParameterDef {\n                         def_id: local_def(param.id),\n                         bounds: bounds\n@@ -1167,7 +1167,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n         rp: Option<ty::region_variance>,\n         generics: &ast::Generics,\n         param_ty: ty::param_ty,\n-        ast_bounds: @OptVec<ast::TyParamBound>) -> ty::ParamBounds\n+        ast_bounds: &OptVec<ast::TyParamBound>) -> ty::ParamBounds\n     {\n         /*!\n          *\n@@ -1184,7 +1184,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n         };\n         for ast_bounds.iter().advance |ast_bound| {\n             match *ast_bound {\n-                TraitTyParamBound(b) => {\n+                TraitTyParamBound(ref b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n                     let trait_ref = instantiate_trait_ref(ccx, b, rp, generics, ty);\n                     if !astconv::try_add_builtin_trait(\n@@ -1215,8 +1215,8 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     let ty_generics = ty_generics(ccx, None, ast_generics, 0);\n     let region_param_names = RegionParamNames::from_generics(ast_generics);\n     let rb = in_binding_rscope(&empty_rscope, region_param_names);\n-    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, *a, None) );\n-    let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, a, None) );\n+    let output_ty = ast_ty_to_ty(ccx, &rb, &decl.output);\n \n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,"}, {"sha": "ee90d9661c37f90ef1f9112b279c984bf93eb31e", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -65,15 +65,14 @@ use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{InferCtxtMethods};\n use middle::typeck::infer::{InferCtxt, cres, ures};\n-use middle::typeck::infer::{TypeOrigin, TypeTrace};\n+use middle::typeck::infer::{TypeTrace};\n use util::common::indent;\n \n use std::result::{iter_vec2, map_vec2};\n use std::vec;\n use syntax::ast::{Onceness, purity};\n use syntax::ast;\n use syntax::opt_vec;\n-use syntax::codemap::span;\n use syntax::abi::AbiSet;\n \n pub trait Combine {"}, {"sha": "928f33803dd8c556408e1686fdb04f2f50d42f96", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -59,23 +59,18 @@ time of error detection.\n \n */\n \n-use std::prelude::*;\n use middle::ty;\n use middle::ty::Region;\n use middle::typeck::infer;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::TypeTrace;\n-use middle::typeck::infer::TypeOrigin;\n use middle::typeck::infer::SubregionOrigin;\n use middle::typeck::infer::RegionVariableOrigin;\n-use middle::typeck::infer::Types;\n-use middle::typeck::infer::TraitRefs;\n use middle::typeck::infer::ValuePairs;\n use middle::typeck::infer::region_inference::RegionResolutionError;\n use middle::typeck::infer::region_inference::ConcreteFailure;\n use middle::typeck::infer::region_inference::SubSupConflict;\n use middle::typeck::infer::region_inference::SupSupConflict;\n-use syntax::opt_vec;\n use syntax::opt_vec::OptVec;\n use util::ppaux::UserString;\n use util::ppaux::note_and_explain_region;\n@@ -362,7 +357,7 @@ impl ErrorReporting for InferCtxt {\n                     sup,\n                     \"\");\n             }\n-            infer::ReferenceOutlivesReferent(ty, span) => {\n+            infer::ReferenceOutlivesReferent(ty, _) => {\n                 self.tcx.sess.span_err(\n                     origin.span(),\n                     fmt!(\"in type `%s`, pointer has a longer lifetime than \\"}, {"sha": "32f3e8fea3a86407f95831cef5e9b4aa66fb334a", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -26,8 +26,7 @@ use syntax::ast::{Many, Once, extern_fn, impure_fn, m_const, m_imm, m_mutbl};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n use syntax::abi::AbiSet;\n-use syntax::codemap::span;\n-use util::common::{indent, indenter};\n+use util::common::{indenter};\n use util::ppaux::mt_to_str;\n \n use extra::list;"}, {"sha": "3f23fd6e7096f6588b881da7981194ff313d560d", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -21,7 +21,6 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::isr_alist;\n-use util::common::indent;\n use util::ppaux::mt_to_str;\n \n use extra::list;\n@@ -30,7 +29,6 @@ use syntax::ast;\n use syntax::ast::{Many, Once, extern_fn, m_const, impure_fn};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n-use syntax::codemap::span;\n \n pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n "}, {"sha": "d0a778139dbd2b81d6a48d7f797954af8e89c0b7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -328,7 +328,7 @@ pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n }\n \n pub fn mk_subr(cx: @mut InferCtxt,\n-               a_is_expected: bool,\n+               _a_is_expected: bool,\n                origin: SubregionOrigin,\n                a: ty::Region,\n                b: ty::Region) {"}, {"sha": "7bf4d07b72306247d199b09ac2b3f5d7ee19c661", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -19,13 +19,12 @@ use middle::typeck::infer::cres;\n use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n use middle::typeck::infer;\n use util::common::indenter;\n-use util::ppaux::{note_and_explain_region, Repr, UserString};\n+use util::ppaux::{Repr};\n \n use std::cell::Cell;\n use std::hashmap::{HashMap, HashSet};\n use std::uint;\n use std::vec;\n-use syntax::codemap::span;\n use syntax::ast;\n use syntax::opt_vec;\n use syntax::opt_vec::OptVec;"}, {"sha": "cfb33732459ff271f8e6c308415f63514b4b290b", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -21,15 +21,14 @@ use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{TypeTrace, Subtype};\n-use util::common::{indent, indenter};\n+use util::common::{indenter};\n use util::ppaux::bound_region_to_str;\n \n use extra::list::Nil;\n use extra::list;\n use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::{Onceness, m_const, purity};\n-use syntax::codemap::span;\n \n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n "}, {"sha": "40c662e3a09e530a4cf727d0a7864e80e06ea830", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -94,7 +94,7 @@ fn fold_const(\n             do astsrv::exec(srv) |ctxt| {\n                 match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n-                        node: ast::item_static(ty, _, _), _\n+                        node: ast::item_static(ref ty, _, _), _\n                     }, _) => {\n                         pprust::ty_to_str(ty, extract::interner())\n                     }\n@@ -245,12 +245,12 @@ fn fold_impl(\n         do astsrv::exec(srv) |ctxt| {\n             match ctxt.ast_map.get_copy(&doc.id()) {\n                 ast_map::node_item(@ast::item {\n-                    node: ast::item_impl(ref generics, opt_trait_type, self_ty, _), _\n+                    node: ast::item_impl(ref generics, ref opt_trait_type, ref self_ty, _), _\n                 }, _) => {\n                     let bounds = pprust::generics_to_str(generics, extract::interner());\n                     let bounds = if bounds.is_empty() { None } else { Some(bounds) };\n                     let trait_types = opt_trait_type.map_default(~[], |p| {\n-                        ~[pprust::path_to_str(p.path, extract::interner())]\n+                        ~[pprust::path_to_str(&p.path, extract::interner())]\n                     });\n                     (bounds,\n                      trait_types,\n@@ -285,15 +285,14 @@ fn fold_type(\n                 match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n                         ident: ident,\n-                        node: ast::item_ty(ty, ref params), _\n+                        node: ast::item_ty(ref ty, ref params), _\n                     }, _) => {\n                         Some(fmt!(\n                             \"type %s%s = %s\",\n                             to_str(ident),\n                             pprust::generics_to_str(params,\n                                                     extract::interner()),\n-                            pprust::ty_to_str(ty,\n-                                              extract::interner())\n+                            pprust::ty_to_str(ty, extract::interner())\n                         ))\n                     }\n                     _ => fail!(\"expected type\")"}, {"sha": "d9cd52201c0c504af2a7fb64c63c1ae45806d5f7", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -132,7 +132,7 @@ fn run(mut repl: Repl, input: ~str) -> Repl {\n         // differently beause they must appear before all 'use' statements\n         for blk.node.view_items.iter().advance |vi| {\n             let s = do with_pp(intr) |pp, _| {\n-                pprust::print_view_item(pp, *vi);\n+                pprust::print_view_item(pp, vi);\n             };\n             match vi.node {\n                 ast::view_item_extern_mod(*) => {"}, {"sha": "3932df1db847abfd4ed9e647ea1462adae41f2e2", "filename": "src/librusti/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -14,14 +14,14 @@ use syntax::print::pp;\n use syntax::print::pprust;\n use syntax::parse::token;\n \n-pub fn each_binding(l: @ast::local, f: @fn(@ast::Path, ast::node_id)) {\n+pub fn each_binding(l: @ast::local, f: @fn(&ast::Path, ast::node_id)) {\n     use syntax::visit;\n \n     let vt = visit::mk_simple_visitor(\n         @visit::SimpleVisitor {\n             visit_pat: |pat| {\n                 match pat.node {\n-                    ast::pat_ident(_, path, _) => {\n+                    ast::pat_ident(_, ref path, _) => {\n                         f(path, pat.id);\n                     }\n                     _ => {}"}, {"sha": "8c37c1510cf20974d6543ce87a9335c961ca4c3d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -109,8 +109,8 @@ pub struct Path {\n     span: span,\n     global: bool,\n     idents: ~[ident],\n-    rp: Option<@Lifetime>,\n-    types: ~[@Ty],\n+    rp: Option<Lifetime>,\n+    types: ~[Ty],\n }\n \n pub type crate_num = int;\n@@ -132,15 +132,15 @@ pub static crate_node_id: node_id = 0;\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Send, and Freeze.\n pub enum TyParamBound {\n-    TraitTyParamBound(@trait_ref),\n+    TraitTyParamBound(trait_ref),\n     RegionTyParamBound\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyParam {\n     ident: ident,\n     id: node_id,\n-    bounds: @OptVec<TyParamBound>\n+    bounds: OptVec<TyParamBound>\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n@@ -219,7 +219,7 @@ pub type blk = spanned<blk_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct blk_ {\n-    view_items: ~[@view_item],\n+    view_items: ~[view_item],\n     stmts: ~[@stmt],\n     expr: Option<@expr>,\n     id: node_id,\n@@ -255,10 +255,10 @@ pub enum pat_ {\n     // which it is. The resolver determines this, and\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    pat_ident(binding_mode, @Path, Option<@pat>),\n-    pat_enum(@Path, Option<~[@pat]>), /* \"none\" means a * pattern where\n+    pat_ident(binding_mode, Path, Option<@pat>),\n+    pat_enum(Path, Option<~[@pat]>), /* \"none\" means a * pattern where\n                                        * we don't bind the fields to names */\n-    pat_struct(@Path, ~[field_pat], bool),\n+    pat_struct(Path, ~[field_pat], bool),\n     pat_tup(~[@pat]),\n     pat_box(@pat),\n     pat_uniq(@pat),\n@@ -296,7 +296,7 @@ pub enum vstore {\n     vstore_fixed(Option<uint>),     // [1,2,3,4]\n     vstore_uniq,                    // ~[1,2,3,4]\n     vstore_box,                     // @[1,2,3,4]\n-    vstore_slice(Option<@Lifetime>) // &'foo? [1,2,3,4]\n+    vstore_slice(Option<Lifetime>) // &'foo? [1,2,3,4]\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n@@ -361,7 +361,7 @@ pub enum stmt_ {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct local_ {\n     is_mutbl: bool,\n-    ty: @Ty,\n+    ty: Ty,\n     pat: @pat,\n     init: Option<@expr>,\n     id: node_id,\n@@ -429,12 +429,12 @@ pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_call(@expr, ~[@expr], CallSugar),\n-    expr_method_call(node_id, @expr, ident, ~[@Ty], ~[@expr], CallSugar),\n+    expr_method_call(node_id, @expr, ident, ~[Ty], ~[@expr], CallSugar),\n     expr_tup(~[@expr]),\n     expr_binary(node_id, binop, @expr, @expr),\n     expr_unary(node_id, unop, @expr),\n     expr_lit(@lit),\n-    expr_cast(@expr, @Ty),\n+    expr_cast(@expr, Ty),\n     expr_if(@expr, blk, Option<@expr>),\n     expr_while(@expr, blk),\n     /* Conditionless loop (can be exited with break, cont, or ret)\n@@ -454,9 +454,9 @@ pub enum expr_ {\n     expr_copy(@expr),\n     expr_assign(@expr, @expr),\n     expr_assign_op(node_id, binop, @expr, @expr),\n-    expr_field(@expr, ident, ~[@Ty]),\n+    expr_field(@expr, ident, ~[Ty]),\n     expr_index(node_id, @expr, @expr),\n-    expr_path(@Path),\n+    expr_path(Path),\n \n     /// The special identifier `self`.\n     expr_self,\n@@ -471,7 +471,7 @@ pub enum expr_ {\n     expr_mac(mac),\n \n     // A struct literal expression.\n-    expr_struct(@Path, ~[field], Option<@expr>),\n+    expr_struct(Path, ~[field], Option<@expr>),\n \n     // A vector literal constructed from one repeated element.\n     expr_repeat(@expr /* element */, @expr /* count */, mutability),\n@@ -583,7 +583,7 @@ pub type mac = spanned<mac_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum mac_ {\n-    mac_invoc_tt(@Path,~[token_tree]),   // new macro-invocation\n+    mac_invoc_tt(Path,~[token_tree]),   // new macro-invocation\n }\n \n pub type lit = spanned<lit_>;\n@@ -604,7 +604,7 @@ pub enum lit_ {\n // type structure in middle/ty.rs as well.\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct mt {\n-    ty: @Ty,\n+    ty: ~Ty,\n     mutbl: mutability,\n }\n \n@@ -701,7 +701,7 @@ impl ToStr for Onceness {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyClosure {\n     sigil: Sigil,\n-    region: Option<@Lifetime>,\n+    region: Option<Lifetime>,\n     lifetimes: OptVec<Lifetime>,\n     purity: purity,\n     onceness: Onceness,\n@@ -730,11 +730,11 @@ pub enum ty_ {\n     ty_vec(mt),\n     ty_fixed_length_vec(mt, @expr),\n     ty_ptr(mt),\n-    ty_rptr(Option<@Lifetime>, mt),\n+    ty_rptr(Option<Lifetime>, mt),\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n-    ty_tup(~[@Ty]),\n-    ty_path(@Path, @Option<OptVec<TyParamBound>>, node_id), // for #7264; see above\n+    ty_tup(~[Ty]),\n+    ty_path(Path, Option<OptVec<TyParamBound>>, node_id), // for #7264; see above\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n@@ -762,15 +762,15 @@ pub struct inline_asm {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct arg {\n     is_mutbl: bool,\n-    ty: @Ty,\n+    ty: Ty,\n     pat: @pat,\n     id: node_id,\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct fn_decl {\n     inputs: ~[arg],\n-    output: @Ty,\n+    output: Ty,\n     cf: ret_style,\n }\n \n@@ -803,7 +803,7 @@ pub enum ret_style {\n pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n-    sty_region(Option<@Lifetime>, mutability), // `&'lt self`\n+    sty_region(Option<Lifetime>, mutability), // `&'lt self`\n     sty_box(mutability),                       // `@self`\n     sty_uniq                                   // `~self`\n }\n@@ -827,7 +827,7 @@ pub struct method {\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct _mod {\n-    view_items: ~[@view_item],\n+    view_items: ~[view_item],\n     items: ~[@item],\n }\n \n@@ -839,13 +839,13 @@ pub enum foreign_mod_sort { named, anonymous }\n pub struct foreign_mod {\n     sort: foreign_mod_sort,\n     abis: AbiSet,\n-    view_items: ~[@view_item],\n+    view_items: ~[view_item],\n     items: ~[@foreign_item],\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct variant_arg {\n-    ty: @Ty,\n+    ty: Ty,\n     id: node_id,\n }\n \n@@ -890,13 +890,13 @@ pub enum view_path_ {\n     // or just\n     //\n     // foo::bar::baz  (with 'baz =' implicitly on the left)\n-    view_path_simple(ident, @Path, node_id),\n+    view_path_simple(ident, Path, node_id),\n \n     // foo::bar::*\n-    view_path_glob(@Path, node_id),\n+    view_path_glob(Path, node_id),\n \n     // foo::bar::{a,b,c}\n-    view_path_list(@Path, ~[path_list_ident], node_id)\n+    view_path_list(Path, ~[path_list_ident], node_id)\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n@@ -939,7 +939,7 @@ pub struct attribute_ {\n  */\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct trait_ref {\n-    path: @Path,\n+    path: Path,\n     ref_id: node_id,\n }\n \n@@ -959,7 +959,7 @@ impl visibility {\n pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n-    ty: @Ty,\n+    ty: Ty,\n     attrs: ~[attribute],\n }\n \n@@ -995,17 +995,17 @@ pub struct item {\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum item_ {\n-    item_static(@Ty, mutability, @expr),\n+    item_static(Ty, mutability, @expr),\n     item_fn(fn_decl, purity, AbiSet, Generics, blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n-    item_ty(@Ty, Generics),\n+    item_ty(Ty, Generics),\n     item_enum(enum_def, Generics),\n     item_struct(@struct_def, Generics),\n-    item_trait(Generics, ~[@trait_ref], ~[trait_method]),\n+    item_trait(Generics, ~[trait_ref], ~[trait_method]),\n     item_impl(Generics,\n-              Option<@trait_ref>, // (optional) trait this impl implements\n-              @Ty, // self\n+              Option<trait_ref>, // (optional) trait this impl implements\n+              Ty, // self\n               ~[@method]),\n     // a macro invocation (which includes macro definition)\n     item_mac(mac),\n@@ -1024,7 +1024,7 @@ pub struct foreign_item {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, Generics),\n-    foreign_item_static(@Ty, /* is_mutbl */ bool),\n+    foreign_item_static(Ty, /* is_mutbl */ bool),\n }\n \n // The data we save and restore about an inlined item or method.  This is not"}, {"sha": "59020e9d18377a463b69eb97ac30f650f6cdbc8e", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -196,7 +196,7 @@ pub fn map_block(b: &blk, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n \n pub fn map_pat(pat: @pat, (cx,v): (@mut Ctx, visit::vt<@mut Ctx>)) {\n     match pat.node {\n-        pat_ident(_, path, _) => {\n+        pat_ident(_, ref path, _) => {\n             // Note: this is at least *potentially* a pattern...\n             cx.map.insert(pat.id, node_local(ast_util::path_to_ident(path)));\n         }"}, {"sha": "565f181ab8598431549f5b66b704ebc9cb050c62", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -27,7 +27,7 @@ pub fn path_name_i(idents: &[ident]) -> ~str {\n     idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n }\n \n-pub fn path_to_ident(p: @Path) -> ident { copy *p.idents.last() }\n+pub fn path_to_ident(p: &Path) -> ident { copy *p.idents.last() }\n \n pub fn local_def(id: node_id) -> def_id {\n     ast::def_id { crate: local_crate, node: id }\n@@ -212,8 +212,8 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: span, i: ident) -> @Path {\n-    @ast::Path { span: s,\n+pub fn ident_to_path(s: span, i: ident) -> Path {\n+    ast::Path { span: s,\n                  global: false,\n                  idents: ~[i],\n                  rp: None,\n@@ -580,7 +580,7 @@ pub fn view_path_id(p: &view_path) -> node_id {\n \n /// Returns true if the given struct def is tuple-like; i.e. that its fields\n /// are unnamed.\n-pub fn struct_def_is_tuple_like(struct_def: @ast::struct_def) -> bool {\n+pub fn struct_def_is_tuple_like(struct_def: &ast::struct_def) -> bool {\n     struct_def.ctor_id.is_some()\n }\n "}, {"sha": "5686887491615feb1ec1c2c263a3ad110d3d8dc8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -326,7 +326,7 @@ pub fn expr_to_ident(cx: @ExtCtxt,\n                      expr: @ast::expr,\n                      err_msg: &str) -> ast::ident {\n     match expr.node {\n-      ast::expr_path(p) => {\n+      ast::expr_path(ref p) => {\n         if p.types.len() > 0u || p.idents.len() != 1u {\n             cx.span_fatal(expr.span, err_msg);\n         }"}, {"sha": "73220ec28817030f71afc81e00e857ffce2ca78e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 97, "deletions": 100, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -32,44 +32,43 @@ mod syntax {\n \n pub trait AstBuilder {\n     // paths\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n-    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path;\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path;\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> ast::Path;\n+    fn path_ident(&self, span: span, id: ast::ident) -> ast::Path;\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path;\n     fn path_all(&self, sp: span,\n                 global: bool,\n                 idents: ~[ast::ident],\n-                rp: Option<@ast::Lifetime>,\n-                types: ~[@ast::Ty])\n-        -> @ast::Path;\n+                rp: Option<ast::Lifetime>,\n+                types: ~[ast::Ty])\n+        -> ast::Path;\n \n     // types\n-    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n+    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::mutability) -> ast::mt;\n \n-    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty;\n-    fn ty_path(&self, @ast::Path, @Option<OptVec<ast::TyParamBound>>) -> @ast::Ty;\n-    fn ty_ident(&self, span: span, idents: ast::ident) -> @ast::Ty;\n+    fn ty(&self, span: span, ty: ast::ty_) -> ast::Ty;\n+    fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> ast::Ty;\n+    fn ty_ident(&self, span: span, idents: ast::ident) -> ast::Ty;\n \n     fn ty_rptr(&self, span: span,\n-               ty: @ast::Ty,\n-               lifetime: Option<@ast::Lifetime>,\n-               mutbl: ast::mutability)\n-        -> @ast::Ty;\n-    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_box(&self, span: span, ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty;\n-\n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_infer(&self, sp: span) -> @ast::Ty;\n-    fn ty_nil(&self) -> @ast::Ty;\n-\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field;\n+               ty: ast::Ty,\n+               lifetime: Option<ast::Lifetime>,\n+               mutbl: ast::mutability) -> ast::Ty;\n+    fn ty_uniq(&self, span: span, ty: ast::Ty) -> ast::Ty;\n+    fn ty_box(&self, span: span, ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty;\n+\n+    fn ty_option(&self, ty: ast::Ty) -> ast::Ty;\n+    fn ty_infer(&self, sp: span) -> ast::Ty;\n+    fn ty_nil(&self) -> ast::Ty;\n+\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n+    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::ty_field;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n-    fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam;\n+    fn typaram(&self, id: ast::ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam;\n \n-    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref;\n-    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound;\n+    fn trait_ref(&self, path: ast::Path) -> ast::trait_ref;\n+    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n     fn lifetime(&self, span: span, ident: ast::ident) -> ast::Lifetime;\n \n     // statements\n@@ -80,13 +79,13 @@ pub trait AstBuilder {\n     fn blk(&self, span: span, stmts: ~[@ast::stmt], expr: Option<@ast::expr>) -> ast::blk;\n     fn blk_expr(&self, expr: @ast::expr) -> ast::blk;\n     fn blk_all(&self, span: span,\n-               view_items: ~[@ast::view_item],\n+               view_items: ~[ast::view_item],\n                stmts: ~[@ast::stmt],\n                expr: Option<@ast::expr>) -> ast::blk;\n \n     // expressions\n     fn expr(&self, span: span, node: ast::expr_) -> @ast::expr;\n-    fn expr_path(&self, path: @ast::Path) -> @ast::expr;\n+    fn expr_path(&self, path: ast::Path) -> @ast::expr;\n     fn expr_ident(&self, span: span, id: ast::ident) -> @ast::expr;\n \n     fn expr_self(&self, span: span) -> @ast::expr;\n@@ -110,7 +109,7 @@ pub trait AstBuilder {\n     fn expr_blk(&self, b: ast::blk) -> @ast::expr;\n \n     fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field;\n-    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr;\n+    fn expr_struct(&self, span: span, path: ast::Path, fields: ~[ast::field]) -> @ast::expr;\n     fn expr_struct_ident(&self, span: span, id: ast::ident, fields: ~[ast::field]) -> @ast::expr;\n \n     fn expr_lit(&self, sp: span, lit: ast::lit_) -> @ast::expr;\n@@ -138,9 +137,9 @@ pub trait AstBuilder {\n                               span: span,\n                               ident: ast::ident,\n                               bm: ast::binding_mode) -> @ast::pat;\n-    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n+    fn pat_enum(&self, span: span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n     fn pat_struct(&self, span: span,\n-                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n+                  path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat;\n \n     fn arm(&self, span: span, pats: ~[@ast::pat], expr: @ast::expr) -> ast::arm;\n     fn arm_unreachable(&self, span: span) -> ast::arm;\n@@ -167,25 +166,25 @@ pub trait AstBuilder {\n     fn item(&self, span: span,\n             name: ident, attrs: ~[ast::attribute], node: ast::item_) -> @ast::item;\n \n-    fn arg(&self, span: span, name: ident, ty: @ast::Ty) -> ast::arg;\n+    fn arg(&self, span: span, name: ident, ty: ast::Ty) -> ast::arg;\n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl;\n \n     fn item_fn_poly(&self,\n                     span: span,\n                     name: ident,\n                     inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n+                    output: ast::Ty,\n                     generics: Generics,\n                     body: ast::blk) -> @ast::item;\n     fn item_fn(&self,\n                span: span,\n                name: ident,\n                inputs: ~[ast::arg],\n-               output: @ast::Ty,\n+               output: ast::Ty,\n                body: ast::blk) -> @ast::item;\n \n-    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant;\n+    fn variant(&self, span: span, name: ident, tys: ~[ast::Ty]) -> ast::variant;\n     fn item_enum_poly(&self,\n                       span: span,\n                       name: ident,\n@@ -202,14 +201,14 @@ pub trait AstBuilder {\n \n     fn item_mod(&self, span: span,\n                 name: ident, attrs: ~[ast::attribute],\n-                vi: ~[@ast::view_item], items: ~[@ast::item]) -> @ast::item;\n+                vi: ~[ast::view_item], items: ~[@ast::item]) -> @ast::item;\n \n     fn item_ty_poly(&self,\n                     span: span,\n                     name: ident,\n-                    ty: @ast::Ty,\n+                    ty: ast::Ty,\n                     generics: Generics) -> @ast::item;\n-    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item;\n+    fn item_ty(&self, span: span, name: ident, ty: ast::Ty) -> @ast::item;\n \n     fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute;\n \n@@ -218,30 +217,30 @@ pub trait AstBuilder {\n     fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::meta_item;\n \n     fn view_use(&self, sp: span,\n-                vis: ast::visibility, vp: ~[@ast::view_path]) -> @ast::view_item;\n+                vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item;\n     fn view_use_list(&self, sp: span, vis: ast::visibility,\n-                     path: ~[ast::ident], imports: &[ast::ident]) -> @ast::view_item;\n+                     path: ~[ast::ident], imports: &[ast::ident]) -> ast::view_item;\n     fn view_use_glob(&self, sp: span,\n-                     vis: ast::visibility, path: ~[ast::ident]) -> @ast::view_item;\n+                     vis: ast::visibility, path: ~[ast::ident]) -> ast::view_item;\n }\n \n impl AstBuilder for @ExtCtxt {\n-    fn path(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+    fn path(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, false, strs, None, ~[])\n     }\n-    fn path_ident(&self, span: span, id: ast::ident) -> @ast::Path {\n+    fn path_ident(&self, span: span, id: ast::ident) -> ast::Path {\n         self.path(span, ~[id])\n     }\n-    fn path_global(&self, span: span, strs: ~[ast::ident]) -> @ast::Path {\n+    fn path_global(&self, span: span, strs: ~[ast::ident]) -> ast::Path {\n         self.path_all(span, true, strs, None, ~[])\n     }\n     fn path_all(&self, sp: span,\n                 global: bool,\n                 idents: ~[ast::ident],\n-                rp: Option<@ast::Lifetime>,\n-                types: ~[@ast::Ty])\n-        -> @ast::Path {\n-        @ast::Path {\n+                rp: Option<ast::Lifetime>,\n+                types: ~[ast::Ty])\n+        -> ast::Path {\n+        ast::Path {\n             span: sp,\n             global: global,\n             idents: idents,\n@@ -250,52 +249,52 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n+    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::mutability) -> ast::mt {\n         ast::mt {\n-            ty: ty,\n+            ty: ~ty,\n             mutbl: mutbl\n         }\n     }\n \n-    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty {\n-        @ast::Ty {\n+    fn ty(&self, span: span, ty: ast::ty_) -> ast::Ty {\n+        ast::Ty {\n             id: self.next_id(),\n             span: span,\n             node: ty\n         }\n     }\n \n-    fn ty_path(&self, path: @ast::Path, bounds: @Option<OptVec<ast::TyParamBound>>)\n-              -> @ast::Ty {\n+    fn ty_path(&self, path: ast::Path, bounds: Option<OptVec<ast::TyParamBound>>)\n+              -> ast::Ty {\n         self.ty(path.span,\n                 ast::ty_path(path, bounds, self.next_id()))\n     }\n \n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n     fn ty_ident(&self, span: span, ident: ast::ident)\n-        -> @ast::Ty {\n-        self.ty_path(self.path_ident(span, ident), @None)\n+        -> ast::Ty {\n+        self.ty_path(self.path_ident(span, ident), None)\n     }\n \n     fn ty_rptr(&self,\n                span: span,\n-               ty: @ast::Ty,\n-               lifetime: Option<@ast::Lifetime>,\n+               ty: ast::Ty,\n+               lifetime: Option<ast::Lifetime>,\n                mutbl: ast::mutability)\n-        -> @ast::Ty {\n+        -> ast::Ty {\n         self.ty(span,\n                 ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n-    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty {\n+    fn ty_uniq(&self, span: span, ty: ast::Ty) -> ast::Ty {\n         self.ty(span, ast::ty_uniq(self.ty_mt(ty, ast::m_imm)))\n     }\n     fn ty_box(&self, span: span,\n-                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n+                 ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty {\n         self.ty(span, ast::ty_box(self.ty_mt(ty, mutbl)))\n     }\n \n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n+    fn ty_option(&self, ty: ast::Ty) -> ast::Ty {\n         self.ty_path(\n             self.path_all(dummy_sp(),\n                           true,\n@@ -305,67 +304,65 @@ impl AstBuilder for @ExtCtxt {\n                               self.ident_of(\"Option\")\n                           ],\n                           None,\n-                          ~[ ty ]),\n-            @None)\n+                          ~[ ty ]), None)\n     }\n \n-    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field {\n+    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::ty_field {\n         respan(span,\n                ast::ty_field_ {\n                    ident: name,\n-                   mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n+                   mt: ast::mt { ty: ~ty, mutbl: ast::m_imm },\n                })\n     }\n \n-    fn ty_infer(&self, span: span) -> @ast::Ty {\n+    fn ty_infer(&self, span: span) -> ast::Ty {\n         self.ty(span, ast::ty_infer)\n     }\n \n-    fn ty_nil(&self) -> @ast::Ty {\n-        @ast::Ty {\n+    fn ty_nil(&self) -> ast::Ty {\n+        ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_nil,\n             span: dummy_sp(),\n         }\n     }\n \n-    fn typaram(&self, id: ast::ident, bounds: @OptVec<ast::TyParamBound>) -> ast::TyParam {\n+    fn typaram(&self, id: ast::ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam {\n         ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n     }\n \n     // these are strange, and probably shouldn't be used outside of\n     // pipes. Specifically, the global version possible generates\n     // incorrect code.\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_ident(dummy_sp(), p.ident)))\n     }\n \n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                self.path_global(dummy_sp(), ~[p.ident]), @None)))\n+                self.path_global(dummy_sp(), ~[p.ident]), None)))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {\n-        let no_bounds = @opt_vec::Empty;\n         let new_params = do generics.ty_params.map |ty_param| {\n-            ast::TyParam { bounds: no_bounds, ..copy *ty_param }\n+            ast::TyParam { bounds: opt_vec::Empty, ..copy *ty_param }\n         };\n         Generics {\n             ty_params: new_params,\n             .. copy *generics\n         }\n     }\n \n-    fn trait_ref(&self, path: @ast::Path) -> @ast::trait_ref {\n-        @ast::trait_ref {\n+    fn trait_ref(&self, path: ast::Path) -> ast::trait_ref {\n+        ast::trait_ref {\n             path: path,\n             ref_id: self.next_id()\n         }\n     }\n \n-    fn typarambound(&self, path: @ast::Path) -> ast::TyParamBound {\n+    fn typarambound(&self, path: ast::Path) -> ast::TyParamBound {\n         ast::TraitTyParamBound(self.trait_ref(path))\n     }\n \n@@ -400,7 +397,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n     fn blk_all(&self,\n                span: span,\n-               view_items: ~[@ast::view_item],\n+               view_items: ~[ast::view_item],\n                stmts: ~[@ast::stmt],\n                expr: Option<@ast::expr>) -> ast::blk {\n         respan(span,\n@@ -421,7 +418,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn expr_path(&self, path: @ast::Path) -> @ast::expr {\n+    fn expr_path(&self, path: ast::Path) -> @ast::expr {\n         self.expr(path.span, ast::expr_path(path))\n     }\n \n@@ -487,7 +484,7 @@ impl AstBuilder for @ExtCtxt {\n     fn field_imm(&self, span: span, name: ident, e: @ast::expr) -> ast::field {\n         respan(span, ast::field_ { ident: name, expr: e })\n     }\n-    fn expr_struct(&self, span: span, path: @ast::Path, fields: ~[ast::field]) -> @ast::expr {\n+    fn expr_struct(&self, span: span, path: ast::Path, fields: ~[ast::field]) -> @ast::expr {\n         self.expr(span, ast::expr_struct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: span,\n@@ -570,12 +567,12 @@ impl AstBuilder for @ExtCtxt {\n         let pat = ast::pat_ident(bm, path, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: span, path: @ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n+    fn pat_enum(&self, span: span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat {\n         let pat = ast::pat_enum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: span,\n-                  path: @ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n+                  path: ast::Path, field_pats: ~[ast::field_pat]) -> @ast::pat {\n         let pat = ast::pat_struct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n@@ -644,7 +641,7 @@ impl AstBuilder for @ExtCtxt {\n         self.lambda1(span, self.blk(span, stmts, None), ident)\n     }\n \n-    fn arg(&self, span: span, ident: ast::ident, ty: @ast::Ty) -> ast::arg {\n+    fn arg(&self, span: span, ident: ast::ident, ty: ast::Ty) -> ast::arg {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::arg {\n             is_mutbl: false,\n@@ -655,7 +652,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl {\n         ast::fn_decl {\n             inputs: inputs,\n             output: output,\n@@ -679,7 +676,7 @@ impl AstBuilder for @ExtCtxt {\n                     span: span,\n                     name: ident,\n                     inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n+                    output: ast::Ty,\n                     generics: Generics,\n                     body: ast::blk) -> @ast::item {\n         self.item(span,\n@@ -696,7 +693,7 @@ impl AstBuilder for @ExtCtxt {\n                span: span,\n                name: ident,\n                inputs: ~[ast::arg],\n-               output: @ast::Ty,\n+               output: ast::Ty,\n                body: ast::blk\n               ) -> @ast::item {\n         self.item_fn_poly(\n@@ -708,10 +705,10 @@ impl AstBuilder for @ExtCtxt {\n             body)\n     }\n \n-    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant {\n-        let args = do tys.map |ty| {\n-            ast::variant_arg { ty: *ty, id: self.next_id() }\n-        };\n+    fn variant(&self, span: span, name: ident, tys: ~[ast::Ty]) -> ast::variant {\n+        let args = tys.consume_iter().transform(|ty| {\n+            ast::variant_arg { ty: ty, id: self.next_id() }\n+        }).collect();\n \n         respan(span,\n                ast::variant_ {\n@@ -762,7 +759,7 @@ impl AstBuilder for @ExtCtxt {\n \n     fn item_mod(&self, span: span, name: ident,\n                 attrs: ~[ast::attribute],\n-                vi: ~[@ast::view_item],\n+                vi: ~[ast::view_item],\n                 items: ~[@ast::item]) -> @ast::item {\n         self.item(\n             span,\n@@ -775,12 +772,12 @@ impl AstBuilder for @ExtCtxt {\n         )\n     }\n \n-    fn item_ty_poly(&self, span: span, name: ident, ty: @ast::Ty,\n+    fn item_ty_poly(&self, span: span, name: ident, ty: ast::Ty,\n                     generics: Generics) -> @ast::item {\n         self.item(span, name, ~[], ast::item_ty(ty, generics))\n     }\n \n-    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item {\n+    fn item_ty(&self, span: span, name: ident, ty: ast::Ty) -> @ast::item {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n@@ -804,8 +801,8 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn view_use(&self, sp: span,\n-                vis: ast::visibility, vp: ~[@ast::view_path]) -> @ast::view_item {\n-        @ast::view_item {\n+                vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item {\n+        ast::view_item {\n             node: ast::view_item_use(vp),\n             attrs: ~[],\n             vis: vis,\n@@ -814,7 +811,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn view_use_list(&self, sp: span, vis: ast::visibility,\n-                     path: ~[ast::ident], imports: &[ast::ident]) -> @ast::view_item {\n+                     path: ~[ast::ident], imports: &[ast::ident]) -> ast::view_item {\n         let imports = do imports.map |id| {\n             respan(sp, ast::path_list_ident_ { name: *id, id: self.next_id() })\n         };\n@@ -827,7 +824,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn view_use_glob(&self, sp: span,\n-                     vis: ast::visibility, path: ~[ast::ident]) -> @ast::view_item {\n+                     vis: ast::visibility, path: ~[ast::ident]) -> ast::view_item {\n         self.view_use(sp, vis,\n                       ~[@respan(sp,\n                                 ast::view_path_glob(self.path(sp, path), self.next_id()))])"}, {"sha": "900668df117e3cb3ab963dac4817bb843574a61d", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -36,7 +36,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let e = @ast::expr {\n         id: cx.next_id(),\n         node: ast::expr_path(\n-            @ast::Path {\n+            ast::Path {\n                  span: sp,\n                  global: false,\n                  idents: ~[res],"}, {"sha": "01769482d08297eb211d460ca62887e56d043d24", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -335,9 +335,9 @@ impl<'self> TraitDef<'self> {\n                     cx.typarambound(p.to_path(cx, span, type_ident, generics))\n                 });\n             // require the current trait\n-            bounds.push(cx.typarambound(trait_path));\n+            bounds.push(cx.typarambound(copy trait_path));\n \n-            trait_generics.ty_params.push(cx.typaram(ty_param.ident, @bounds));\n+            trait_generics.ty_params.push(cx.typaram(ty_param.ident, bounds));\n         }\n \n         // Create the reference to the trait.\n@@ -351,13 +351,12 @@ impl<'self> TraitDef<'self> {\n         let self_lifetime = if generics.lifetimes.is_empty() {\n             None\n         } else {\n-            Some(@*generics.lifetimes.get(0))\n+            Some(*generics.lifetimes.get(0))\n         };\n \n         // Create the type of `self`.\n         let self_type = cx.ty_path(cx.path_all(span, false, ~[ type_ident ], self_lifetime,\n-                                               opt_vec::take_vec(self_ty_params)),\n-                                   @None);\n+                                               opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute(\n             span,\n@@ -457,7 +456,7 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn get_ret_ty(&self, cx: @ExtCtxt, span: span,\n-                     generics: &Generics, type_ident: ident) -> @ast::Ty {\n+                     generics: &Generics, type_ident: ident) -> ast::Ty {\n         self.ret_ty.to_ty(cx, span, type_ident, generics)\n     }\n \n@@ -467,7 +466,7 @@ impl<'self> MethodDef<'self> {\n \n     fn split_self_nonself_args(&self, cx: @ExtCtxt, span: span,\n                              type_ident: ident, generics: &Generics)\n-        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n+        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, ast::Ty)]) {\n \n         let mut self_args = ~[];\n         let mut nonself_args = ~[];\n@@ -515,7 +514,7 @@ impl<'self> MethodDef<'self> {\n                      type_ident: ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n-                     arg_types: ~[(ident, @ast::Ty)],\n+                     arg_types: ~[(ident, ast::Ty)],\n                      body: @expr) -> @ast::method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n@@ -890,7 +889,7 @@ fn summarise_struct(cx: @ExtCtxt, span: span,\n \n pub fn create_subpatterns(cx: @ExtCtxt,\n                           span: span,\n-                          field_paths: ~[@ast::Path],\n+                          field_paths: ~[ast::Path],\n                           mutbl: ast::mutability)\n                    -> ~[@ast::pat] {\n     do field_paths.map |&path| {\n@@ -941,7 +940,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n         };\n         let path = cx.path_ident(span,\n                                  cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n-        paths.push(path);\n+        paths.push(copy path);\n         ident_expr.push((opt_id, cx.expr_path(path)));\n     }\n \n@@ -987,7 +986,7 @@ fn create_enum_variant_pattern(cx: @ExtCtxt,\n                 let path = cx.path_ident(span,\n                                          cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n \n-                paths.push(path);\n+                paths.push(copy path);\n                 ident_expr.push((None, cx.expr_path(path)));\n             }\n "}, {"sha": "255bc6c98775be9679da3c9a6444cedaad9894d4", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -61,16 +61,15 @@ impl<'self> Path<'self> {\n                  span: span,\n                  self_ty: ident,\n                  self_generics: &Generics)\n-                 -> @ast::Ty {\n-        cx.ty_path(self.to_path(cx, span,\n-                                self_ty, self_generics), @None)\n+                 -> ast::Ty {\n+        cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n     }\n     pub fn to_path(&self,\n                    cx: @ExtCtxt,\n                    span: span,\n                    self_ty: ident,\n                    self_generics: &Generics)\n-                   -> @ast::Path {\n+                   -> ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n         let lt = mk_lifetime(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n@@ -110,9 +109,9 @@ pub fn nil_ty() -> Ty<'static> {\n     Tuple(~[])\n }\n \n-fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<@ast::Lifetime> {\n+fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => Some(@cx.lifetime(span, cx.ident_of(*s))),\n+        Some(ref s) => Some(cx.lifetime(span, cx.ident_of(*s))),\n         None => None\n     }\n }\n@@ -123,7 +122,7 @@ impl<'self> Ty<'self> {\n                  span: span,\n                  self_ty: ident,\n                  self_generics: &Generics)\n-                 -> @ast::Ty {\n+                 -> ast::Ty {\n         match *self {\n             Ptr(ref ty, ref ptr) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n@@ -142,8 +141,7 @@ impl<'self> Ty<'self> {\n             }\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n             Self  => {\n-                cx.ty_path(self.to_path(cx, span, self_ty, self_generics),\n-                           @None)\n+                cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n             }\n             Tuple(ref fields) => {\n                 let ty = if fields.is_empty() {\n@@ -162,7 +160,7 @@ impl<'self> Ty<'self> {\n                    span: span,\n                    self_ty: ident,\n                    self_generics: &Generics)\n-                   -> @ast::Path {\n+                   -> ast::Path {\n         match *self {\n             Self => {\n                 let self_params = do self_generics.ty_params.map |ty_param| {\n@@ -171,7 +169,7 @@ impl<'self> Ty<'self> {\n                 let lifetime = if self_generics.lifetimes.is_empty() {\n                     None\n                 } else {\n-                    Some(@*self_generics.lifetimes.get(0))\n+                    Some(*self_generics.lifetimes.get(0))\n                 };\n \n                 cx.path_all(span, false, ~[self_ty], lifetime,\n@@ -194,7 +192,7 @@ fn mk_ty_param(cx: @ExtCtxt, span: span, name: &str, bounds: &[Path],\n             let path = b.to_path(cx, span, self_ident, self_generics);\n             cx.typarambound(path)\n         });\n-    cx.typaram(cx.ident_of(name), @bounds)\n+    cx.typaram(cx.ident_of(name), bounds)\n }\n \n fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Generics {\n@@ -251,8 +249,7 @@ pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n                     Send => ast::sty_uniq,\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| @cx.lifetime(span,\n-                                                         cx.ident_of(*s)));\n+                        let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(*s)));\n                         ast::sty_region(lt, mutbl)\n                     }\n                 });"}, {"sha": "940bd5ef61c11bed2d5aa393eff19ef42246c3fb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -40,7 +40,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         expr_mac(ref mac) => {\n             match (*mac).node {\n                 // Token-tree macros:\n-                mac_invoc_tt(pth, ref tts) => {\n+                mac_invoc_tt(ref pth, ref tts) => {\n                     if (pth.idents.len() > 1u) {\n                         cx.span_fatal(\n                             pth.span,\n@@ -208,7 +208,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n     let (pth, tts) = match it.node {\n-        item_mac(codemap::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n+        item_mac(codemap::spanned { node: mac_invoc_tt(ref pth, ref tts), _}) => {\n             (pth, copy *tts)\n         }\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n@@ -298,7 +298,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n     let (mac, pth, tts, semi) = match *s {\n         stmt_mac(ref mac, semi) => {\n             match mac.node {\n-                mac_invoc_tt(pth, ref tts) => {\n+                mac_invoc_tt(ref pth, ref tts) => {\n                     (copy *mac, pth, copy *tts, semi)\n                 }\n             }\n@@ -372,10 +372,10 @@ pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n                      (ident_accum, v): (@mut ~[ast::ident], visit::vt<@mut ~[ast::ident]>)| {\n             match *p {\n                 // we found a pat_ident!\n-                ast::pat{id:_, node: ast::pat_ident(_,path,ref inner), span:_} => {\n+                ast::pat{id:_, node: ast::pat_ident(_,ref path,ref inner), span:_} => {\n                     match path {\n                         // a path of length one:\n-                        @ast::Path{global: false,idents: [id], span:_,rp:_,types:_} =>\n+                        &ast::Path{global: false,idents: [id], span:_,rp:_,types:_} =>\n                         ident_accum.push(id),\n                         // I believe these must be enums...\n                         _ => ()"}, {"sha": "9e6776363a82db7e1a91bebfc82d6c445eec3689", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -26,7 +26,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n     cx.print_backtrace();\n     io::stdout().write_line(\n         print::pprust::tt_to_str(\n-            ast::tt_delim(vec::to_owned(tt)),\n+            &ast::tt_delim(vec::to_owned(tt)),\n             get_ident_interner()));\n \n     //trivial expression"}, {"sha": "a4873e6e34b45feb0e86f5f98b5658150459e388", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -25,39 +25,39 @@ mod syntax {\n     pub use parse;\n }\n \n-pub fn path(ids: ~[ident], span: span) -> @ast::Path {\n-    @ast::Path { span: span,\n+pub fn path(ids: ~[ident], span: span) -> ast::Path {\n+    ast::Path { span: span,\n                  global: false,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n-pub fn path_global(ids: ~[ident], span: span) -> @ast::Path {\n-    @ast::Path { span: span,\n+pub fn path_global(ids: ~[ident], span: span) -> ast::Path {\n+    ast::Path { span: span,\n                  global: true,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n pub trait append_types {\n-    fn add_ty(&self, ty: @ast::Ty) -> @ast::Path;\n-    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path;\n+    fn add_ty(&self, ty: ast::Ty) -> ast::Path;\n+    fn add_tys(&self, tys: ~[ast::Ty]) -> ast::Path;\n }\n \n-impl append_types for @ast::Path {\n-    fn add_ty(&self, ty: @ast::Ty) -> @ast::Path {\n-        @ast::Path {\n+impl append_types for ast::Path {\n+    fn add_ty(&self, ty: ast::Ty) -> ast::Path {\n+        ast::Path {\n             types: vec::append_one(copy self.types, ty),\n-            .. copy **self\n+            .. copy *self\n         }\n     }\n \n-    fn add_tys(&self, tys: ~[@ast::Ty]) -> @ast::Path {\n-        @ast::Path {\n+    fn add_tys(&self, tys: ~[ast::Ty]) -> ast::Path {\n+        ast::Path {\n             types: vec::append(copy self.types, tys),\n-            .. copy **self\n+            .. copy *self\n         }\n     }\n }"}, {"sha": "adf10215cb56636ef995845e1e8bc70fdcb5ace8", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -49,7 +49,7 @@ impl proto::visitor<(), (), ()> for @ExtCtxt {\n         }\n     }\n \n-    fn visit_message(&self, name: @str, _span: span, _tys: &[@ast::Ty],\n+    fn visit_message(&self, name: @str, _span: span, _tys: &[ast::Ty],\n                      this: state, next: Option<next_state>) {\n         match next {\n           Some(ref next_state) => {"}, {"sha": "98fc9aa61784d05b3d634ce01d8b23e1b03e06ef", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -25,7 +25,7 @@ use std::vec;\n \n pub trait gen_send {\n     fn gen_send(&mut self, cx: @ExtCtxt, try: bool) -> @ast::item;\n-    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty;\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> ast::Ty;\n }\n \n pub trait to_type_decls {\n@@ -37,7 +37,7 @@ pub trait to_type_decls {\n pub trait gen_init {\n     fn gen_init(&self, cx: @ExtCtxt) -> @ast::item;\n     fn compile(&self, cx: @ExtCtxt) -> @ast::item;\n-    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty;\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> ast::Ty;\n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item;\n     fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n     fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n@@ -56,11 +56,11 @@ impl gen_send for message {\n                 next.generics.ty_params.len());\n             let arg_names = vec::from_fn(tys.len(), |i| cx.ident_of(\"x_\"+i.to_str()));\n             let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                .transform(|(n, t)| cx.arg(span, *n, *t)).collect();\n+                .transform(|(n, t)| cx.arg(span, copy *n, copy *t)).collect();\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars(&this.generics.ty_params)), @None);\n+                .add_tys(cx.ty_vars(&this.generics.ty_params)), None);\n             let args_ast = vec::append(\n                 ~[cx.arg(span, cx.ident_of(\"pipe\"), pipe_ty)],\n                 args_ast);\n@@ -117,7 +117,7 @@ impl gen_send for message {\n \n             let mut rty = cx.ty_path(path(~[next.data_name()],\n                                           span)\n-                                     .add_tys(copy next_state.tys), @None);\n+                                     .add_tys(copy next_state.tys), None);\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -137,15 +137,15 @@ impl gen_send for message {\n                 let arg_names = vec::from_fn(tys.len(), |i| \"x_\" + i.to_str());\n \n                 let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                    .transform(|(n, t)| cx.arg(span, cx.ident_of(*n), *t)).collect();\n+                    .transform(|(&n, t)| cx.arg(span, cx.ident_of(n), copy *t)).collect();\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(span,\n                              cx.ident_of(\"pipe\"),\n                              cx.ty_path(\n                                  path(~[this.data_name()], span)\n                                  .add_tys(cx.ty_vars(\n-                                     &this.generics.ty_params)), @None))],\n+                                     &this.generics.ty_params)), None))],\n                     args_ast);\n \n                 let message_args = if arg_names.len() == 0 {\n@@ -189,9 +189,9 @@ impl gen_send for message {\n           }\n         }\n \n-    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> ast::Ty {\n         cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars(&self.get_generics().ty_params)), @None)\n+          .add_tys(cx.ty_vars(&self.get_generics().ty_params)), None)\n     }\n }\n \n@@ -225,7 +225,7 @@ impl to_type_decls for state {\n                                 cx.ty_path(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(copy next_state.tys), @None))\n+                                    .add_tys(copy next_state.tys), None))\n               }\n               None => tys\n             };\n@@ -278,8 +278,7 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                  dummy_sp())\n                             .add_tys(cx.ty_vars(\n-                                &self.generics.ty_params)), @None)),\n-                        @None),\n+                                &self.generics.ty_params)), None)), None),\n                     cx.strip_bounds(&self.generics)));\n         }\n         else {\n@@ -298,8 +297,8 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                         dummy_sp())\n                             .add_tys(cx.ty_vars_global(\n-                                &self.generics.ty_params)), @None),\n-                                   self.proto.buffer_ty_path(cx)]), @None),\n+                                &self.generics.ty_params)), None),\n+                                   self.proto.buffer_ty_path(cx)]), None),\n                     cx.strip_bounds(&self.generics)));\n         };\n         items\n@@ -370,12 +369,12 @@ impl gen_init for protocol {\n         })\n     }\n \n-    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty {\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> ast::Ty {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n-        for (copy self.states).iter().advance |s| {\n+        for self.states.iter().advance |s| {\n             for s.generics.ty_params.iter().advance |tp| {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n-                  None => params.push(*tp),\n+                  None => params.push(copy *tp),\n                   _ => ()\n                 }\n             }\n@@ -384,16 +383,16 @@ impl gen_init for protocol {\n         cx.ty_path(path(~[cx.ident_of(\"super\"),\n                           cx.ident_of(\"__Buffer\")],\n                         copy self.span)\n-                   .add_tys(cx.ty_vars_global(&params)), @None)\n+                   .add_tys(cx.ty_vars_global(&params)), None)\n     }\n \n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {\n         let ext_cx = cx;\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n-        let fields = do (copy self.states).iter().transform |s| {\n+        let fields = do self.states.iter().transform |s| {\n             for s.generics.ty_params.iter().advance |tp| {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n-                  None => params.push(*tp),\n+                  None => params.push(copy *tp),\n                   _ => ()\n                 }\n             }"}, {"sha": "2fe8456c2749c7becbce1a5a79ebb3995b8b5630", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -37,11 +37,11 @@ impl direction {\n \n pub struct next_state {\n     state: @str,\n-    tys: ~[@ast::Ty],\n+    tys: ~[ast::Ty],\n }\n \n // name, span, data, current state, next state\n-pub struct message(@str, span, ~[@ast::Ty], state, Option<next_state>);\n+pub struct message(@str, span, ~[ast::Ty], state, Option<next_state>);\n \n impl message {\n     pub fn name(&mut self) -> @str {\n@@ -81,7 +81,7 @@ impl state_ {\n     pub fn add_message(@self,\n                        name: @str,\n                        span: span,\n-                       data: ~[@ast::Ty],\n+                       data: ~[ast::Ty],\n                        next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n@@ -96,10 +96,10 @@ impl state_ {\n     }\n \n     /// Returns the type that is used for the messages.\n-    pub fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n+    pub fn to_ty(&self, cx: @ExtCtxt) -> ast::Ty {\n         cx.ty_path\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n-                cx.ty_vars(&self.generics.ty_params)), @None)\n+                cx.ty_vars(&self.generics.ty_params)), None)\n     }\n \n     /// Iterate over the states that can be reached in one message\n@@ -206,7 +206,7 @@ impl protocol_ {\n pub trait visitor<Tproto, Tstate, Tmessage> {\n     fn visit_proto(&self, proto: protocol, st: &[Tstate]) -> Tproto;\n     fn visit_state(&self, state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(&self, name: @str, spane: span, tys: &[@ast::Ty],\n+    fn visit_message(&self, name: @str, spane: span, tys: &[ast::Ty],\n                      this: state, next: Option<next_state>) -> Tmessage;\n }\n "}, {"sha": "c550e3382a233ca272d068b2286008e7eda95f53", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -88,13 +88,13 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for @ast::Ty {\n+    impl ToSource for ast::Ty {\n         fn to_source(&self) -> @str {\n-            pprust::ty_to_str(*self, get_ident_interner()).to_managed()\n+            pprust::ty_to_str(self, get_ident_interner()).to_managed()\n         }\n     }\n \n-    impl<'self> ToSource for &'self [@ast::Ty] {\n+    impl<'self> ToSource for &'self [ast::Ty] {\n         fn to_source(&self) -> @str {\n             self.map(|i| i.to_source()).connect(\", \").to_managed()\n         }\n@@ -216,13 +216,13 @@ pub mod rt {\n         }\n     }\n \n-    impl ToTokens for @ast::Ty {\n+    impl ToTokens for ast::Ty {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source())\n         }\n     }\n \n-    impl<'self> ToTokens for &'self [@ast::Ty] {\n+    impl<'self> ToTokens for &'self [ast::Ty] {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source())\n         }"}, {"sha": "6de504c66fd88937313b3a364f3dd2bf164a6a85", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -82,7 +82,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n             io::println(fmt!(\"%s! { %s }\",\n                              cx.str_of(name),\n                              print::pprust::tt_to_str(\n-                                 ast::tt_delim(vec::to_owned(arg)),\n+                                 &ast::tt_delim(vec::to_owned(arg)),\n                                  get_ident_interner())));\n         }\n "}, {"sha": "c36b717ea0055f58f181bd60f8ad3792e4ecd61b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -16,7 +16,7 @@ use opt_vec::OptVec;\n \n pub trait ast_fold {\n     fn fold_crate(@self, &crate) -> crate;\n-    fn fold_view_item(@self, @view_item) -> @view_item;\n+    fn fold_view_item(@self, &view_item) -> view_item;\n     fn fold_foreign_item(@self, @foreign_item) -> @foreign_item;\n     fn fold_item(@self, @item) -> Option<@item>;\n     fn fold_struct_field(@self, @struct_field) -> @struct_field;\n@@ -28,12 +28,12 @@ pub trait ast_fold {\n     fn fold_pat(@self, @pat) -> @pat;\n     fn fold_decl(@self, @decl) -> Option<@decl>;\n     fn fold_expr(@self, @expr) -> @expr;\n-    fn fold_ty(@self, @Ty) -> @Ty;\n+    fn fold_ty(@self, &Ty) -> Ty;\n     fn fold_mod(@self, &_mod) -> _mod;\n     fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n     fn fold_variant(@self, &variant) -> variant;\n     fn fold_ident(@self, ident) -> ident;\n-    fn fold_path(@self, @Path) -> @Path;\n+    fn fold_path(@self, &Path) -> Path;\n     fn fold_local(@self, @local) -> @local;\n     fn map_exprs(@self, @fn(@expr) -> @expr, &[@expr]) -> ~[@expr];\n     fn new_id(@self, node_id) -> node_id;\n@@ -62,7 +62,7 @@ pub struct AstFoldFns {\n     fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n     fold_variant: @fn(&variant_, span, @ast_fold) -> (variant_, span),\n     fold_ident: @fn(ident, @ast_fold) -> ident,\n-    fold_path: @fn(@Path, @ast_fold) -> Path,\n+    fold_path: @fn(&Path, @ast_fold) -> Path,\n     fold_local: @fn(&local_, span, @ast_fold) -> (local_, span),\n     map_exprs: @fn(@fn(@expr) -> @expr, &[@expr]) -> ~[@expr],\n     new_id: @fn(node_id) -> node_id,\n@@ -107,7 +107,7 @@ fn fold_attribute_(at: attribute, fld: @ast_fold) -> attribute {\n fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     ast::arg {\n         is_mutbl: a.is_mutbl,\n-        ty: fld.fold_ty(a.ty),\n+        ty: fld.fold_ty(&a.ty),\n         pat: fld.fold_pat(a.pat),\n         id: fld.new_id(a.id),\n     }\n@@ -117,7 +117,7 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n     spanned {\n         node: match m.node {\n-            mac_invoc_tt(p,ref tts) =>\n+            mac_invoc_tt(ref p,ref tts) =>\n             mac_invoc_tt(fld.fold_path(p),\n                          fold_tts(*tts,fld))\n         },\n@@ -154,15 +154,15 @@ fn maybe_fold_ident(t : &token::Token, fld: @ast_fold) -> token::Token {\n \n pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n     ast::fn_decl {\n-        inputs: decl.inputs.map(|x| fold_arg_(*x, fld)),\n-        output: fld.fold_ty(decl.output),\n+        inputs: decl.inputs.map(|x| fold_arg_(/*bad*/ copy *x, fld)),\n+        output: fld.fold_ty(&decl.output),\n         cf: decl.cf,\n     }\n }\n \n fn fold_ty_param_bound(tpb: &TyParamBound, fld: @ast_fold) -> TyParamBound {\n     match *tpb {\n-        TraitTyParamBound(ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n+        TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n@@ -171,12 +171,13 @@ pub fn fold_ty_param(tp: TyParam,\n                      fld: @ast_fold) -> TyParam {\n     TyParam {ident: tp.ident,\n              id: fld.new_id(tp.id),\n-             bounds: @tp.bounds.map(|x| fold_ty_param_bound(x, fld))}\n+             bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld))}\n }\n \n pub fn fold_ty_params(tps: &OptVec<TyParam>,\n                       fld: @ast_fold) -> OptVec<TyParam> {\n-    tps.map(|tp| fold_ty_param(*tp, fld))\n+    let tps = /*bad*/ copy *tps;\n+    tps.map_consume(|tp| fold_ty_param(tp, fld))\n }\n \n pub fn fold_lifetime(l: &Lifetime,\n@@ -225,14 +226,14 @@ fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n                 foreign_item_fn(ref fdec, purity, ref generics) => {\n                     foreign_item_fn(\n                         ast::fn_decl {\n-                            inputs: fdec.inputs.map(|a| fold_arg(*a)),\n-                            output: fld.fold_ty(fdec.output),\n+                            inputs: fdec.inputs.map(|a| fold_arg(/*bad*/copy *a)),\n+                            output: fld.fold_ty(&fdec.output),\n                             cf: fdec.cf,\n                         },\n                         purity,\n                         fold_generics(generics, fld))\n                 }\n-                foreign_item_static(t, m) => {\n+                foreign_item_static(ref t, m) => {\n                     foreign_item_static(fld.fold_ty(t), m)\n                 }\n             },\n@@ -259,14 +260,14 @@ fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n \n     @spanned { node: ast::struct_field_ { kind: copy sf.node.kind,\n                                           id: sf.node.id,\n-                                          ty: fld.fold_ty(sf.node.ty),\n+                                          ty: fld.fold_ty(&sf.node.ty),\n                                           attrs: sf.node.attrs.map(|e| fold_attribute(*e)) },\n                span: sf.span }\n }\n \n pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n     match *i {\n-        item_static(t, m, e) => item_static(fld.fold_ty(t), m, fld.fold_expr(e)),\n+        item_static(ref t, m, e) => item_static(fld.fold_ty(t), m, fld.fold_expr(e)),\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             item_fn(\n                 fold_fn_decl(decl, fld),\n@@ -280,7 +281,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n         item_foreign_mod(ref nm) => {\n             item_foreign_mod(fld.fold_foreign_mod(nm))\n         }\n-        item_ty(t, ref generics) => {\n+        item_ty(ref t, ref generics) => {\n             item_ty(fld.fold_ty(t), fold_generics(generics, fld))\n         }\n         item_enum(ref enum_definition, ref generics) => {\n@@ -296,10 +297,10 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n             let struct_def = fold_struct_def(*struct_def, fld);\n             item_struct(struct_def, /* FIXME (#2543) */ copy *generics)\n         }\n-        item_impl(ref generics, ifce, ty, ref methods) => {\n+        item_impl(ref generics, ref ifce, ref ty, ref methods) => {\n             item_impl(\n                 fold_generics(generics, fld),\n-                ifce.map(|p| fold_trait_ref(*p, fld)),\n+                ifce.map(|p| fold_trait_ref(p, fld)),\n                 fld.fold_ty(ty),\n                 methods.map(|x| fld.fold_method(*x))\n             )\n@@ -313,7 +314,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n             };\n             item_trait(\n                 fold_generics(generics, fld),\n-                traits.map(|p| fold_trait_ref(*p, fld)),\n+                traits.map(|p| fold_trait_ref(p, fld)),\n                 methods\n             )\n         }\n@@ -335,9 +336,9 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n     }\n }\n \n-fn fold_trait_ref(p: @trait_ref, fld: @ast_fold) -> @trait_ref {\n-    @ast::trait_ref {\n-        path: fld.fold_path(p.path),\n+fn fold_trait_ref(p: &trait_ref, fld: @ast_fold) -> trait_ref {\n+    ast::trait_ref {\n+        path: fld.fold_path(&p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n@@ -347,7 +348,7 @@ fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n         node: ast::struct_field_ {\n             kind: copy f.node.kind,\n             id: fld.new_id(f.node.id),\n-            ty: fld.fold_ty(f.node.ty),\n+            ty: fld.fold_ty(&f.node.ty),\n             attrs: /* FIXME (#2543) */ copy f.node.attrs,\n         },\n         span: fld.new_span(f.span),\n@@ -372,7 +373,7 @@ fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n \n \n pub fn noop_fold_block(b: &blk_, fld: @ast_fold) -> blk_ {\n-    let view_items = b.view_items.map(|x| fld.fold_view_item(*x));\n+    let view_items = b.view_items.map(|x| fld.fold_view_item(x));\n     let mut stmts = ~[];\n     for b.stmts.iter().advance |stmt| {\n         match fld.fold_stmt(*stmt) {\n@@ -419,21 +420,21 @@ fn noop_fold_arm(a: &arm, fld: @ast_fold) -> arm {\n pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n     match *p {\n         pat_wild => pat_wild,\n-        pat_ident(binding_mode, pth, ref sub) => {\n+        pat_ident(binding_mode, ref pth, ref sub) => {\n             pat_ident(\n                 binding_mode,\n                 fld.fold_path(pth),\n                 sub.map(|x| fld.fold_pat(*x))\n             )\n         }\n         pat_lit(e) => pat_lit(fld.fold_expr(e)),\n-        pat_enum(pth, ref pats) => {\n+        pat_enum(ref pth, ref pats) => {\n             pat_enum(\n                 fld.fold_path(pth),\n                 pats.map(|pats| pats.map(|x| fld.fold_pat(*x)))\n             )\n         }\n-        pat_struct(pth, ref fields, etc) => {\n+        pat_struct(ref pth, ref fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n             let fs = do fields.map |f| {\n                 ast::field_pat {\n@@ -517,7 +518,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 fld.new_id(callee_id),\n                 fld.fold_expr(f),\n                 fld.fold_ident(i),\n-                tps.map(|x| fld.fold_ty(*x)),\n+                tps.map(|x| fld.fold_ty(x)),\n                 fld.map_exprs(|x| fld.fold_expr(x), *args),\n                 blk\n             )\n@@ -540,7 +541,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n         expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n         expr_lit(_) => copy *e,\n-        expr_cast(expr, ty) => expr_cast(fld.fold_expr(expr), ty),\n+        expr_cast(expr, ref ty) => expr_cast(fld.fold_expr(expr), copy *ty),\n         expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n         expr_if(cond, ref tr, fl) => {\n             expr_if(\n@@ -586,7 +587,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_field(el, id, ref tys) => {\n             expr_field(\n                 fld.fold_expr(el), fld.fold_ident(id),\n-                tys.map(|x| fld.fold_ty(*x))\n+                tys.map(|x| fld.fold_ty(x))\n             )\n         }\n         expr_index(callee_id, el, er) => {\n@@ -596,7 +597,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 fld.fold_expr(er)\n             )\n         }\n-        expr_path(pth) => expr_path(fld.fold_path(pth)),\n+        expr_path(ref pth) => expr_path(fld.fold_path(pth)),\n         expr_self => expr_self,\n         expr_break(ref opt_ident) => {\n             expr_break(opt_ident.map(|x| fld.fold_ident(*x)))\n@@ -621,7 +622,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n             })\n         }\n         expr_mac(ref mac) => expr_mac(fold_mac(mac)),\n-        expr_struct(path, ref fields, maybe_expr) => {\n+        expr_struct(ref path, ref fields, maybe_expr) => {\n             expr_struct(\n                 fld.fold_path(path),\n                 fields.map(|x| fold_field(*x)),\n@@ -636,7 +637,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n     fn fold_mt(mt: &mt, fld: @ast_fold) -> mt {\n         mt {\n-            ty: fld.fold_ty(mt.ty),\n+            ty: ~fld.fold_ty(mt.ty),\n             mutbl: mt.mutbl,\n         }\n     }\n@@ -681,9 +682,9 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 decl: fold_fn_decl(&f.decl, fld)\n             })\n         }\n-        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(*ty))),\n-        ty_path(path, bounds, id) =>\n-            ty_path(fld.fold_path(path), @fold_opt_bounds(bounds, fld), fld.new_id(id)),\n+        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(ty))),\n+        ty_path(ref path, ref bounds, id) =>\n+            ty_path(fld.fold_path(path), fold_opt_bounds(bounds, fld), fld.new_id(id)),\n         ty_fixed_length_vec(ref mt, e) => {\n             ty_fixed_length_vec(\n                 fold_mt(mt, fld),\n@@ -697,7 +698,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n // ...nor do modules\n pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n     ast::_mod {\n-        view_items: m.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n+        view_items: m.view_items.iter().transform(|x| fld.fold_view_item(x)).collect(),\n         items: m.items.iter().filter_map(|x| fld.fold_item(*x)).collect(),\n     }\n }\n@@ -706,22 +707,22 @@ fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: nm.view_items.iter().transform(|x| fld.fold_view_item(*x)).collect(),\n+        view_items: nm.view_items.iter().transform(|x| fld.fold_view_item(x)).collect(),\n         items: nm.items.iter().transform(|x| fld.fold_foreign_item(*x)).collect(),\n     }\n }\n \n fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: @ast_fold) -> variant_arg {\n-        ast::variant_arg { ty: fld.fold_ty(va.ty), id: fld.new_id(va.id) }\n+        ast::variant_arg { ty: fld.fold_ty(&va.ty), id: fld.new_id(va.id) }\n     }\n     let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n \n     let kind;\n     match v.kind {\n         tuple_variant_kind(ref variant_args) => {\n             kind = tuple_variant_kind(do variant_args.map |x| {\n-                fold_variant_arg(*x)\n+                fold_variant_arg(/*bad*/ copy *x)\n             })\n         }\n         struct_variant_kind(struct_def) => {\n@@ -754,20 +755,20 @@ fn noop_fold_ident(i: ident, _fld: @ast_fold) -> ident {\n     /* FIXME (#2543) */ copy i\n }\n \n-fn noop_fold_path(p: @Path, fld: @ast_fold) -> Path {\n+fn noop_fold_path(p: &Path, fld: @ast_fold) -> Path {\n     ast::Path {\n         span: fld.new_span(p.span),\n         global: p.global,\n         idents: p.idents.map(|x| fld.fold_ident(*x)),\n         rp: p.rp,\n-        types: p.types.map(|x| fld.fold_ty(*x)),\n+        types: p.types.map(|x| fld.fold_ty(x)),\n     }\n }\n \n fn noop_fold_local(l: &local_, fld: @ast_fold) -> local_ {\n     local_ {\n         is_mutbl: l.is_mutbl,\n-        ty: fld.fold_ty(l.ty),\n+        ty: fld.fold_ty(&l.ty),\n         pat: fld.fold_pat(l.pat),\n         init: l.init.map(|e| fld.fold_expr(*e)),\n         id: fld.new_id(l.id),\n@@ -818,9 +819,8 @@ impl ast_fold for AstFoldFns {\n         let (n, s) = (self.fold_crate)(&c.node, c.span, self as @ast_fold);\n         spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_view_item(@self, x: @view_item) ->\n-       @view_item {\n-        @ast::view_item {\n+    fn fold_view_item(@self, x: &view_item) -> view_item {\n+        ast::view_item {\n             node: (self.fold_view_item)(&x.node, self as @ast_fold),\n             attrs: x.attrs.iter().transform(|a| fold_attribute_(*a, self as @ast_fold)).collect(),\n             vis: x.vis,\n@@ -838,7 +838,7 @@ impl ast_fold for AstFoldFns {\n             node: ast::struct_field_ {\n                 kind: copy sf.node.kind,\n                 id: sf.node.id,\n-                ty: (self as @ast_fold).fold_ty(sf.node.ty),\n+                ty: self.fold_ty(&sf.node.ty),\n                 attrs: copy sf.node.attrs,\n             },\n             span: (self.new_span)(sf.span),\n@@ -887,9 +887,9 @@ impl ast_fold for AstFoldFns {\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_ty(@self, x: @Ty) -> @Ty {\n+    fn fold_ty(@self, x: &Ty) -> Ty {\n         let (n, s) = (self.fold_ty)(&x.node, x.span, self as @ast_fold);\n-        @Ty {\n+        Ty {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),\n@@ -908,8 +908,8 @@ impl ast_fold for AstFoldFns {\n     fn fold_ident(@self, x: ident) -> ident {\n         (self.fold_ident)(x, self as @ast_fold)\n     }\n-    fn fold_path(@self, x: @Path) -> @Path {\n-        @(self.fold_path)(x, self as @ast_fold)\n+    fn fold_path(@self, x: &Path) -> Path {\n+        (self.fold_path)(x, self as @ast_fold)\n     }\n     fn fold_local(@self, x: @local) -> @local {\n         let (n, s) = (self.fold_local)(&x.node, x.span, self as @ast_fold);\n@@ -964,7 +964,7 @@ mod test {\n     }\n \n     // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate(s: @pprust::ps, crate: ast::crate) {\n+    fn fake_print_crate(s: @pprust::ps, crate: &ast::crate) {\n         pprust::print_mod(s, &crate.node.module, crate.node.attrs);\n     }\n \n@@ -995,7 +995,7 @@ mod test {\n         let ast = string_to_crate(@\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(zz_fold.fold_crate(ast),fake_print_crate,\n+                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n                                     token::get_ident_interner()),\n                      ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n     }\n@@ -1007,7 +1007,7 @@ mod test {\n => (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(zz_fold.fold_crate(ast),fake_print_crate,\n+                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n                                     token::get_ident_interner()),\n                      ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n     }"}, {"sha": "ba3b72ec19443fe3f4d1b9e7ce324ba2bb5af7d4", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -16,7 +16,7 @@\n  * other useful things like `push()` and `len()`.\n  */\n \n-use std::vec::VecIterator;\n+use std::vec::{VecIterator};\n \n #[deriving(Encodable, Decodable,IterBytes)]\n pub enum OptVec<T> {\n@@ -58,6 +58,13 @@ impl<T> OptVec<T> {\n         }\n     }\n \n+    fn map_consume<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n+        match self {\n+            Empty => Empty,\n+            Vec(v) => Vec(v.consume_iter().transform(op).collect())\n+        }\n+    }\n+\n     fn get<'a>(&'a self, i: uint) -> &'a T {\n         match *self {\n             Empty => fail!(\"Invalid index %u\", i),"}, {"sha": "75d1f35bf38a5f1701b80556722b0f86505fe0ed", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -370,7 +370,7 @@ mod test {\n     #[test] fn path_exprs_1 () {\n         assert_eq!(string_to_expr(@\"a\"),\n                    @ast::expr{id:1,\n-                              node:ast::expr_path(@ast::Path {span:sp(0,1),\n+                              node:ast::expr_path(ast::Path {span:sp(0,1),\n                                                               global:false,\n                                                               idents:~[str_to_ident(\"a\")],\n                                                               rp:None,\n@@ -382,7 +382,7 @@ mod test {\n         assert_eq!(string_to_expr(@\"::a::b\"),\n                    @ast::expr{id:1,\n                                node:ast::expr_path(\n-                                   @ast::Path {span:sp(0,6),\n+                                    ast::Path {span:sp(0,6),\n                                                global:true,\n                                                idents:strs_to_idents(~[\"a\",\"b\"]),\n                                                rp:None,\n@@ -432,7 +432,7 @@ mod test {\n                               node:ast::expr_ret(\n                                   Some(@ast::expr{id:1,\n                                                   node:ast::expr_path(\n-                                                      @ast::Path{span:sp(7,8),\n+                                                       ast::Path{span:sp(7,8),\n                                                                  global:false,\n                                                                  idents:~[str_to_ident(\"d\")],\n                                                                  rp:None,\n@@ -448,7 +448,7 @@ mod test {\n                        node: ast::stmt_expr(@ast::expr{\n                            id: 1,\n                            node: ast::expr_path(\n-                               @ast::Path{\n+                                ast::Path{\n                                    span:sp(0,1),\n                                    global:false,\n                                    idents:~[str_to_ident(\"b\")],\n@@ -469,7 +469,7 @@ mod test {\n         assert_eq!(parser.parse_pat(),\n                    @ast::pat{id:1, // fixme\n                              node: ast::pat_ident(ast::bind_infer,\n-                                                  @ast::Path{\n+                                                   ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n                                                       idents:~[str_to_ident(\"b\")],\n@@ -486,19 +486,19 @@ mod test {\n         assert_eq!(parser.parse_arg_general(true),\n                    ast::arg{\n                        is_mutbl: false,\n-                       ty: @ast::Ty{id:3, // fixme\n-                                    node: ast::ty_path(@ast::Path{\n+                       ty: ast::Ty{id:3, // fixme\n+                                    node: ast::ty_path(ast::Path{\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       @None, 2),\n+                                                       None, 2),\n                                     span:sp(4,7)},\n                        pat: @ast::pat{id:1,\n                                       node: ast::pat_ident(ast::bind_infer,\n-                                                           @ast::Path{\n+                                                            ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n                                                                idents:~[str_to_ident(\"b\")],\n@@ -523,19 +523,19 @@ mod test {\n                             node: ast::item_fn(ast::fn_decl{\n                                 inputs: ~[ast::arg{\n                                     is_mutbl: false,\n-                                    ty: @ast::Ty{id:3, // fixme\n-                                                node: ast::ty_path(@ast::Path{\n+                                    ty: ast::Ty{id:3, // fixme\n+                                                node: ast::ty_path(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       @None, 2),\n+                                                       None, 2),\n                                                 span:sp(10,13)},\n                                     pat: @ast::pat{id:1, // fixme\n                                                    node: ast::pat_ident(\n                                                        ast::bind_infer,\n-                                                       @ast::Path{\n+                                                       ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,\n                                                            idents:~[str_to_ident(\"b\")],\n@@ -546,7 +546,7 @@ mod test {\n                                                   span: sp(6,7)},\n                                     id: 4 // fixme\n                                 }],\n-                                output: @ast::Ty{id:5, // fixme\n+                                output: ast::Ty{id:5, // fixme\n                                                  node: ast::ty_nil,\n                                                  span:sp(15,15)}, // not sure\n                                 cf: ast::return_val\n@@ -565,7 +565,7 @@ mod test {\n                                                 node: ast::stmt_semi(@ast::expr{\n                                                     id: 6,\n                                                     node: ast::expr_path(\n-                                                        @ast::Path{\n+                                                          ast::Path{\n                                                             span:sp(17,18),\n                                                             global:false,\n                                                             idents:~[str_to_ident(\"b\")],"}, {"sha": "2f79f60fb608b97384a699c26f5652b42d3f16e6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 74, "deletions": 66, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -115,7 +115,7 @@ pub enum item_or_view_item {\n     iovi_none,\n     iovi_item(@item),\n     iovi_foreign_item(@foreign_item),\n-    iovi_view_item(@view_item)\n+    iovi_view_item(view_item)\n }\n \n #[deriving(Eq)]\n@@ -130,20 +130,28 @@ The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n macro_rules! maybe_whole_expr (\n     ($p:expr) => (\n-        match *($p).token {\n-            INTERPOLATED(token::nt_expr(e)) => {\n-                $p.bump();\n-                return e;\n-            }\n-            INTERPOLATED(token::nt_path(pt)) => {\n-                $p.bump();\n-                return $p.mk_expr(\n-                    ($p).span.lo,\n-                    ($p).span.hi,\n-                    expr_path(pt)\n-                );\n+        {\n+            // This horrible convolution is brought to you by\n+            // @mut, have a terrible day\n+            let ret = match *($p).token {\n+                INTERPOLATED(token::nt_expr(e)) => {\n+                    Some(e)\n+                }\n+                INTERPOLATED(token::nt_path(ref pt)) => {\n+                    Some($p.mk_expr(\n+                        ($p).span.lo,\n+                        ($p).span.hi,\n+                        expr_path(/* bad */ copy *pt)))\n+                }\n+                _ => None\n+            };\n+            match ret {\n+                Some(e) => {\n+                    $p.bump();\n+                    return e;\n+                }\n+                None => ()\n             }\n-            _ => ()\n         }\n     )\n )\n@@ -208,7 +216,7 @@ fn maybe_append(lhs: ~[attribute], rhs: Option<~[attribute]>)\n \n struct ParsedItemsAndViewItems {\n     attrs_remaining: ~[attribute],\n-    view_items: ~[@view_item],\n+    view_items: ~[view_item],\n     items: ~[@item],\n     foreign_items: ~[@foreign_item]\n }\n@@ -637,7 +645,7 @@ impl Parser {\n     // parse a ty_closure type\n     pub fn parse_ty_closure(&self,\n                             sigil: ast::Sigil,\n-                            region: Option<@ast::Lifetime>)\n+                            region: Option<ast::Lifetime>)\n                             -> ty_ {\n         /*\n \n@@ -815,7 +823,7 @@ impl Parser {\n     // parse a possibly mutable type\n     pub fn parse_mt(&self) -> mt {\n         let mutbl = self.parse_mutability();\n-        let t = self.parse_ty(false);\n+        let t = ~self.parse_ty(false);\n         mt { ty: t, mutbl: mutbl }\n     }\n \n@@ -826,7 +834,7 @@ impl Parser {\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = ~self.parse_ty(false);\n         spanned(\n             lo,\n             ty.span.hi,\n@@ -838,13 +846,13 @@ impl Parser {\n     }\n \n     // parse optional return type [ -> TY ] in function decl\n-    pub fn parse_ret_ty(&self) -> (ret_style, @Ty) {\n+    pub fn parse_ret_ty(&self) -> (ret_style, Ty) {\n         return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(&token::NOT) {\n                 (\n                     noreturn,\n-                    @Ty {\n+                    Ty {\n                         id: self.get_id(),\n                         node: ty_bot,\n                         span: mk_sp(lo, self.last_span.hi)\n@@ -857,7 +865,7 @@ impl Parser {\n             let pos = self.span.lo;\n             (\n                 return_val,\n-                @Ty {\n+                Ty {\n                     id: self.get_id(),\n                     node: ty_nil,\n                     span: mk_sp(pos, pos),\n@@ -869,7 +877,7 @@ impl Parser {\n     // parse a type.\n     // Useless second parameter for compatibility with quasiquote macros.\n     // Bleh!\n-    pub fn parse_ty(&self, _: bool) -> @Ty {\n+    pub fn parse_ty(&self, _: bool) -> Ty {\n         maybe_whole!(self, nt_ty);\n \n         let lo = self.span.lo;\n@@ -959,14 +967,14 @@ impl Parser {\n             || is_ident_or_path(self.token) {\n             // NAMED TYPE\n             let (path, bounds) = self.parse_type_path();\n-            ty_path(path, @bounds, self.get_id())\n+            ty_path(path, bounds, self.get_id())\n         } else {\n             self.fatal(fmt!(\"expected type, found token %?\",\n                             *self.token));\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n-        @Ty {id: self.get_id(), node: t, span: sp}\n+        Ty {id: self.get_id(), node: t, span: sp}\n     }\n \n     // parse the type following a @ or a ~\n@@ -976,7 +984,7 @@ impl Parser {\n         // @'foo fn() or @foo/fn() or @fn() are parsed directly as fn types:\n         match *self.token {\n             token::LIFETIME(*) => {\n-                let lifetime = @self.parse_lifetime();\n+                let lifetime = self.parse_lifetime();\n                 self.bump();\n                 return self.parse_ty_closure(sigil, Some(lifetime));\n             }\n@@ -985,7 +993,7 @@ impl Parser {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n                     self.token_is_closure_keyword(&self.look_ahead(2u))\n                 {\n-                    let lifetime = @self.parse_lifetime();\n+                    let lifetime = self.parse_lifetime();\n                     self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n                     return self.parse_ty_closure(sigil, Some(lifetime));\n                 } else if self.token_is_closure_keyword(&copy *self.token) {\n@@ -1107,7 +1115,7 @@ impl Parser {\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n         } else {\n-            @Ty {\n+            Ty {\n                 id: self.get_id(),\n                 node: ty_infer,\n                 span: mk_sp(self.span.lo, self.span.hi),\n@@ -1217,18 +1225,18 @@ impl Parser {\n     }\n \n     // parse a path that doesn't have type parameters attached\n-    pub fn parse_path_without_tps(&self) -> @ast::Path {\n+    pub fn parse_path_without_tps(&self) -> ast::Path {\n         maybe_whole!(self, nt_path);\n         let (ids,is_global,sp) = self.parse_path();\n-        @ast::Path { span: sp,\n+        ast::Path { span: sp,\n                      global: is_global,\n                      idents: ids,\n                      rp: None,\n                      types: ~[] }\n     }\n \n     pub fn parse_bounded_path_with_tps(&self, colons: bool,\n-                                        before_tps: Option<&fn()>) -> @ast::Path {\n+                                        before_tps: Option<&fn()>) -> ast::Path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n         maybe_whole!(self, nt_path);\n@@ -1254,7 +1262,7 @@ impl Parser {\n                     token::IDENT(sid, _) => {\n                         let span = copy self.span;\n                         self.bump();\n-                        Some(@ast::Lifetime {\n+                        Some(ast::Lifetime {\n                             id: self.get_id(),\n                             span: *span,\n                             ident: sid\n@@ -1279,30 +1287,30 @@ impl Parser {\n                 if v.len() == 0 {\n                     None\n                 } else if v.len() == 1 {\n-                    Some(@*v.get(0))\n+                    Some(*v.get(0))\n                 } else {\n                     self.fatal(fmt!(\"Expected at most one \\\n                                      lifetime name (for now)\"));\n                 }\n             }\n         };\n \n-        @ast::Path { span: mk_sp(lo, hi),\n+        ast::Path { span: mk_sp(lo, hi),\n                      rp: rp,\n                      types: tps,\n-                     .. copy *path }\n+                     .. path }\n     }\n \n     // parse a path optionally with type parameters. If 'colons'\n     // is true, then type parameters must be preceded by colons,\n     // as in a::t::<t1,t2>\n-    pub fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n+    pub fn parse_path_with_tps(&self, colons: bool) -> ast::Path {\n         self.parse_bounded_path_with_tps(colons, None)\n     }\n \n     // Like the above, but can also parse kind bounds in the case of a\n     // path to be used as a type that might be a trait.\n-    pub fn parse_type_path(&self) -> (@ast::Path, Option<OptVec<TyParamBound>>) {\n+    pub fn parse_type_path(&self) -> (ast::Path, Option<OptVec<TyParamBound>>) {\n         let mut bounds = None;\n         let path = self.parse_bounded_path_with_tps(false, Some(|| {\n             // Note: this closure might not even get called in the case of a\n@@ -1313,17 +1321,17 @@ impl Parser {\n     }\n \n     /// parses 0 or 1 lifetime\n-    pub fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n+    pub fn parse_opt_lifetime(&self) -> Option<ast::Lifetime> {\n         match *self.token {\n             token::LIFETIME(*) => {\n-                Some(@self.parse_lifetime())\n+                Some(self.parse_lifetime())\n             }\n \n             // Also accept the (obsolete) syntax `foo/`\n             token::IDENT(*) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n                     self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n-                    Some(@self.parse_lifetime())\n+                    Some(self.parse_lifetime())\n                 } else {\n                     None\n                 }\n@@ -1454,7 +1462,7 @@ impl Parser {\n     pub fn mk_method_call(&self,\n                       rcvr: @expr,\n                       ident: ident,\n-                      tps: ~[@Ty],\n+                      tps: ~[Ty],\n                       args: ~[@expr],\n                       sugar: CallSugar) -> ast::expr_ {\n         expr_method_call(self.get_id(), rcvr, ident, tps, args, sugar)\n@@ -1464,7 +1472,7 @@ impl Parser {\n         expr_index(self.get_id(), expr, idx)\n     }\n \n-    pub fn mk_field(&self, expr: @expr, ident: ident, tys: ~[@Ty]) -> ast::expr_ {\n+    pub fn mk_field(&self, expr: @expr, ident: ident, tys: ~[Ty]) -> ast::expr_ {\n         expr_field(expr, ident, tys)\n     }\n \n@@ -2206,7 +2214,7 @@ impl Parser {\n                     // No argument list - `do foo {`\n                       ast::fn_decl {\n                           inputs: ~[],\n-                          output: @Ty {\n+                          output: Ty {\n                               id: self.get_id(),\n                               node: ty_infer,\n                               span: *self.span\n@@ -2817,7 +2825,7 @@ impl Parser {\n             self.obsolete(*self.span, ObsoleteMutWithMultipleBindings)\n         }\n \n-        let mut ty = @Ty {\n+        let mut ty = Ty {\n             id: self.get_id(),\n             node: ty_infer,\n             span: mk_sp(lo, lo),\n@@ -3204,7 +3212,7 @@ impl Parser {\n         let ident = self.parse_ident();\n         let opt_bounds = self.parse_optional_ty_param_bounds();\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n-        let bounds = @opt_bounds.get_or_default(opt_vec::Empty);\n+        let bounds = opt_bounds.get_or_default(opt_vec::Empty);\n         ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n@@ -3226,7 +3234,7 @@ impl Parser {\n \n     // parse a generic use site\n     fn parse_generic_values(\n-        &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n+        &self) -> (OptVec<ast::Lifetime>, ~[Ty])\n     {\n         if !self.eat(&token::LT) {\n             (opt_vec::Empty, ~[])\n@@ -3236,7 +3244,7 @@ impl Parser {\n     }\n \n     fn parse_generic_values_after_lt(\n-        &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n+        &self) -> (OptVec<ast::Lifetime>, ~[Ty])\n     {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n@@ -3334,14 +3342,14 @@ impl Parser {\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n                        token::is_keyword(keywords::Self, &this.look_ahead(2))) {\n                 this.bump();\n-                let lifetime = @this.parse_lifetime();\n+                let lifetime = this.parse_lifetime();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), m_imm)\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n                        this.token_is_mutability(&this.look_ahead(2)) &&\n                        token::is_keyword(keywords::Self, &this.look_ahead(3))) {\n                 this.bump();\n-                let lifetime = @this.parse_lifetime();\n+                let lifetime = this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), mutability)\n@@ -3446,7 +3454,7 @@ impl Parser {\n         let output = if self.eat(&token::RARROW) {\n             self.parse_ty(false)\n         } else {\n-            @Ty { id: self.get_id(), node: ty_infer, span: *self.span }\n+            Ty { id: self.get_id(), node: ty_infer, span: *self.span }\n         };\n \n         ast::fn_decl {\n@@ -3556,9 +3564,9 @@ impl Parser {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n-                ty_path(path, @None, node_id) => {\n-                    Some(@trait_ref {\n-                        path: path,\n+                ty_path(ref path, None, node_id) => {\n+                    Some(trait_ref {\n+                        path: /* bad */ copy *path,\n                         ref_id: node_id\n                     })\n                 }\n@@ -3599,15 +3607,15 @@ impl Parser {\n     }\n \n     // parse a::B<~str,int>\n-    fn parse_trait_ref(&self) -> @trait_ref {\n-        @ast::trait_ref {\n+    fn parse_trait_ref(&self) -> trait_ref {\n+        ast::trait_ref {\n             path: self.parse_path_with_tps(false),\n             ref_id: self.get_id(),\n         }\n     }\n \n     // parse B + C<~str,int> + D\n-    fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[@trait_ref] {\n+    fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[trait_ref] {\n         self.parse_seq_to_before_end(\n             ket,\n             seq_sep_trailing_disallowed(token::BINOP(token::PLUS)),\n@@ -4091,7 +4099,7 @@ impl Parser {\n         // extern mod foo;\n         let metadata = self.parse_optional_meta();\n         self.expect(&token::SEMI);\n-        iovi_view_item(@ast::view_item {\n+        iovi_view_item(ast::view_item {\n             node: view_item_extern_mod(ident, metadata, self.get_id()),\n             attrs: copy attrs,\n             vis: visibility,\n@@ -4164,9 +4172,9 @@ impl Parser {\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_ty(false)\n                 );\n-                for arg_tys.iter().advance |ty| {\n+                for arg_tys.consume_iter().advance |ty| {\n                     args.push(ast::variant_arg {\n-                        ty: *ty,\n+                        ty: ty,\n                         id: self.get_id(),\n                     });\n                 }\n@@ -4325,7 +4333,7 @@ impl Parser {\n             // USE ITEM (iovi_view_item)\n             let view_item = self.parse_use();\n             self.expect(&token::SEMI);\n-            return iovi_view_item(@ast::view_item {\n+            return iovi_view_item(ast::view_item {\n                 node: view_item,\n                 attrs: attrs,\n                 vis: visibility,\n@@ -4575,7 +4583,7 @@ impl Parser {\n                 let id = self.parse_ident();\n                 path.push(id);\n             }\n-            let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+            let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                     global: false,\n                                     idents: path,\n                                     rp: None,\n@@ -4605,7 +4613,7 @@ impl Parser {\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_path_list_ident()\n                     );\n-                    let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                             global: false,\n                                             idents: path,\n                                             rp: None,\n@@ -4617,7 +4625,7 @@ impl Parser {\n                   // foo::bar::*\n                   token::BINOP(token::STAR) => {\n                     self.bump();\n-                    let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+                    let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                             global: false,\n                                             idents: path,\n                                             rp: None,\n@@ -4633,7 +4641,7 @@ impl Parser {\n           _ => ()\n         }\n         let last = path[path.len() - 1u];\n-        let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n+        let path = ast::Path { span: mk_sp(lo, self.span.hi),\n                                 global: false,\n                                 idents: path,\n                                 rp: None,\n@@ -4673,7 +4681,7 @@ impl Parser {\n         &self,\n         attrs: ~[attribute],\n         vis: visibility\n-    ) -> @view_item {\n+    ) -> view_item {\n         let lo = self.span.lo;\n         let node = if self.eat_keyword(keywords::Use) {\n             self.parse_use()\n@@ -4686,7 +4694,7 @@ impl Parser {\n             self.bug(\"expected view item\");\n         };\n         self.expect(&token::SEMI);\n-        @ast::view_item { node: node,\n+        ast::view_item { node: node,\n                           attrs: attrs,\n                           vis: vis,\n                           span: mk_sp(lo, self.last_span.hi) }\n@@ -4704,7 +4712,7 @@ impl Parser {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n         // First, parse view items.\n-        let mut view_items = ~[];\n+        let mut view_items : ~[ast::view_item] = ~[];\n         let mut items = ~[];\n         let mut done = false;\n         // I think this code would probably read better as a single"}, {"sha": "09d6ecb40fc0b86048fb54a8d3d9926812b93df2", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -104,9 +104,9 @@ pub enum nonterminal {\n     nt_stmt(@ast::stmt),\n     nt_pat( @ast::pat),\n     nt_expr(@ast::expr),\n-    nt_ty(  @ast::Ty),\n+    nt_ty(   ast::Ty),\n     nt_ident(ast::ident, bool),\n-    nt_path(@ast::Path),\n+    nt_path( ast::Path),\n     nt_tt(  @ast::token_tree), //needs @ed to break a circularity\n     nt_matchers(~[ast::matcher])\n }"}, {"sha": "b545c56778e90d7be141cef85f0affd2fb82b581", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 120, "deletions": 121, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -34,9 +34,9 @@ use std::uint;\n // The @ps is stored here to prevent recursive type.\n pub enum ann_node<'self> {\n     node_block(@ps, &'self ast::blk),\n-    node_item(@ps, @ast::item),\n-    node_expr(@ps, @ast::expr),\n-    node_pat(@ps, @ast::pat),\n+    node_item(@ps, &'self ast::item),\n+    node_expr(@ps, &'self ast::expr),\n+    node_pat(@ps, &'self ast::pat),\n }\n pub struct pp_ann {\n     pre: @fn(ann_node),\n@@ -106,7 +106,7 @@ pub static default_columns: uint = 78u;\n pub fn print_crate(cm: @CodeMap,\n                    intr: @ident_interner,\n                    span_diagnostic: @diagnostic::span_handler,\n-                   crate: @ast::crate,\n+                   crate: &ast::crate,\n                    filename: @str,\n                    in: @io::Reader,\n                    out: @io::Writer,\n@@ -136,41 +136,41 @@ pub fn print_crate(cm: @CodeMap,\n     print_crate_(s, crate);\n }\n \n-pub fn print_crate_(s: @ps, crate: @ast::crate) {\n+pub fn print_crate_(s: @ps, crate: &ast::crate) {\n     print_mod(s, &crate.node.module, crate.node.attrs);\n     print_remaining_comments(s);\n     eof(s.s);\n }\n \n-pub fn ty_to_str(ty: @ast::Ty, intr: @ident_interner) -> ~str {\n+pub fn ty_to_str(ty: &ast::Ty, intr: @ident_interner) -> ~str {\n     to_str(ty, print_type, intr)\n }\n \n-pub fn pat_to_str(pat: @ast::pat, intr: @ident_interner) -> ~str {\n+pub fn pat_to_str(pat: &ast::pat, intr: @ident_interner) -> ~str {\n     to_str(pat, print_irrefutable_pat, intr)\n }\n \n-pub fn expr_to_str(e: @ast::expr, intr: @ident_interner) -> ~str {\n+pub fn expr_to_str(e: &ast::expr, intr: @ident_interner) -> ~str {\n     to_str(e, print_expr, intr)\n }\n \n pub fn lifetime_to_str(e: &ast::Lifetime, intr: @ident_interner) -> ~str {\n     to_str(e, print_lifetime, intr)\n }\n \n-pub fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n-    to_str(&tt, print_tt, intr)\n+pub fn tt_to_str(tt: &ast::token_tree, intr: @ident_interner) -> ~str {\n+    to_str(tt, print_tt, intr)\n }\n \n pub fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n-    to_str(tts, print_tts, intr)\n+    to_str(&tts, print_tts, intr)\n }\n \n pub fn stmt_to_str(s: &ast::stmt, intr: @ident_interner) -> ~str {\n     to_str(s, print_stmt, intr)\n }\n \n-pub fn item_to_str(i: @ast::item, intr: @ident_interner) -> ~str {\n+pub fn item_to_str(i: &ast::item, intr: @ident_interner) -> ~str {\n     to_str(i, print_item, intr)\n }\n \n@@ -179,7 +179,7 @@ pub fn generics_to_str(generics: &ast::Generics,\n     to_str(generics, print_generics, intr)\n }\n \n-pub fn path_to_str(p: @ast::Path, intr: @ident_interner) -> ~str {\n+pub fn path_to_str(p: &ast::Path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n@@ -208,11 +208,11 @@ pub fn block_to_str(blk: &ast::blk, intr: @ident_interner) -> ~str {\n     }\n }\n \n-pub fn meta_item_to_str(mi: @ast::meta_item, intr: @ident_interner) -> ~str {\n+pub fn meta_item_to_str(mi: &ast::meta_item, intr: @ident_interner) -> ~str {\n     to_str(mi, print_meta_item, intr)\n }\n \n-pub fn attribute_to_str(attr: ast::attribute, intr: @ident_interner) -> ~str {\n+pub fn attribute_to_str(attr: &ast::attribute, intr: @ident_interner) -> ~str {\n     to_str(attr, print_attribute, intr)\n }\n \n@@ -314,45 +314,44 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, \"*/\");\n }\n \n-pub fn commasep<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n+pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.iter().advance |elt| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        op(s, copy *elt);\n+        op(s, elt);\n     }\n     end(s);\n }\n \n \n-pub fn commasep_cmnt<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n-                               get_span: &fn(IN) -> codemap::span) {\n+pub fn commasep_cmnt<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T),\n+                               get_span: &fn(&T) -> codemap::span) {\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n     for elts.iter().advance |elt| {\n-        maybe_print_comment(s, get_span(copy *elt).hi);\n-        op(s, copy *elt);\n+        maybe_print_comment(s, get_span(elt).hi);\n+        op(s, elt);\n         i += 1u;\n         if i < len {\n             word(s.s, \",\");\n-            maybe_print_trailing_comment(s, get_span(copy *elt),\n-                                         Some(get_span(copy elts[i]).hi));\n+            maybe_print_trailing_comment(s, get_span(elt),\n+                                         Some(get_span(&elts[i]).hi));\n             space_if_not_bol(s);\n         }\n     }\n     end(s);\n }\n \n pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n-    fn expr_span(expr: @ast::expr) -> codemap::span { return expr.span; }\n-    commasep_cmnt(s, b, exprs, print_expr, expr_span);\n+    commasep_cmnt(s, b, exprs, |p, &e| print_expr(p, e), |e| e.span);\n }\n \n pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.iter().advance |vitem| {\n-        print_view_item(s, *vitem);\n+        print_view_item(s, vitem);\n     }\n     for _mod.items.iter().advance |item| { print_item(s, *item); }\n }\n@@ -361,19 +360,19 @@ pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n                          attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.iter().advance |vitem| {\n-        print_view_item(s, *vitem);\n+        print_view_item(s, vitem);\n     }\n     for nmod.items.iter().advance |item| { print_foreign_item(s, *item); }\n }\n \n-pub fn print_opt_lifetime(s: @ps, lifetime: Option<@ast::Lifetime>) {\n+pub fn print_opt_lifetime(s: @ps, lifetime: &Option<ast::Lifetime>) {\n     for lifetime.iter().advance |l| {\n-        print_lifetime(s, *l);\n+        print_lifetime(s, l);\n         nbsp(s);\n     }\n }\n \n-pub fn print_type(s: @ps, ty: @ast::Ty) {\n+pub fn print_type(s: @ps, ty: &ast::Ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n@@ -392,7 +391,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n         word(s.s, \"]\");\n       }\n       ast::ty_ptr(ref mt) => { word(s.s, \"*\"); print_mt(s, mt); }\n-      ast::ty_rptr(lifetime, ref mt) => {\n+      ast::ty_rptr(ref lifetime, ref mt) => {\n           word(s.s, \"&\");\n           print_opt_lifetime(s, lifetime);\n           print_mt(s, mt);\n@@ -408,18 +407,18 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n       ast::ty_bare_fn(f) => {\n           let generics = ast::Generics {lifetimes: copy f.lifetimes,\n                                         ty_params: opt_vec::Empty};\n-          print_ty_fn(s, Some(f.abis), None, None,\n+          print_ty_fn(s, Some(f.abis), None, &None,\n                       f.purity, ast::Many, &f.decl, None, &None,\n                       Some(&generics), None);\n       }\n       ast::ty_closure(f) => {\n           let generics = ast::Generics {lifetimes: copy f.lifetimes,\n                                         ty_params: opt_vec::Empty};\n-          print_ty_fn(s, None, Some(f.sigil), f.region,\n+          print_ty_fn(s, None, Some(f.sigil), &f.region,\n                       f.purity, f.onceness, &f.decl, None, &f.bounds,\n                       Some(&generics), None);\n       }\n-      ast::ty_path(path, bounds, _) => print_bounded_path(s, path, bounds),\n+      ast::ty_path(ref path, ref bounds, _) => print_bounded_path(s, path, bounds),\n       ast::ty_fixed_length_vec(ref mt, v) => {\n         word(s.s, \"[\");\n         match mt.mutbl {\n@@ -443,7 +442,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n     end(s);\n }\n \n-pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n+pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -455,7 +454,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n         word(s.s, \";\");\n         end(s); // end the outer fn box\n       }\n-      ast::foreign_item_static(t, m) => {\n+      ast::foreign_item_static(ref t, m) => {\n         head(s, \"static\");\n         if m {\n             word_space(s, \"mut\");\n@@ -470,14 +469,14 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     }\n }\n \n-pub fn print_item(s: @ps, item: @ast::item) {\n+pub fn print_item(s: @ps, item: &ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n     (s.ann.pre)(ann_node);\n     match item.node {\n-      ast::item_static(ty, m, expr) => {\n+      ast::item_static(ref ty, m, expr) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n         if m == ast::m_mutbl {\n             word_space(s, \"mut\");\n@@ -531,7 +530,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         print_foreign_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_ty(ty, ref params) => {\n+      ast::item_ty(ref ty, ref params) => {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, visibility_qualified(item.vis, \"type\"));\n@@ -560,20 +559,20 @@ pub fn print_item(s: @ps, item: @ast::item) {\n           print_struct(s, struct_def, generics, item.ident, item.span);\n       }\n \n-      ast::item_impl(ref generics, opt_trait, ty, ref methods) => {\n+      ast::item_impl(ref generics, ref opt_trait, ref ty, ref methods) => {\n         head(s, visibility_qualified(item.vis, \"impl\"));\n         if generics.is_parameterized() {\n             print_generics(s, generics);\n             space(s.s);\n         }\n \n         match opt_trait {\n-            Some(t) => {\n+            &Some(ref t) => {\n                 print_trait_ref(s, t);\n                 space(s.s);\n                 word_space(s, \"for\");\n             }\n-            None => ()\n+            &None => ()\n         };\n \n         print_type(s, ty);\n@@ -600,7 +599,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n                 if i != 0 {\n                     word_space(s, \"+\");\n                 }\n-                print_path(s, trait_.path, false);\n+                print_path(s, &trait_.path, false);\n             }\n         }\n         word(s.s, \" \");\n@@ -610,15 +609,15 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_mac(codemap::spanned { node: ast::mac_invoc_tt(pth, ref tts),\n+      ast::item_mac(codemap::spanned { node: ast::mac_invoc_tt(ref pth, ref tts),\n                                    _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n         word(s.s, \"! \");\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n-        print_tts(s, *tts);\n+        print_tts(s, &(tts.as_slice()));\n         pclose(s);\n         end(s);\n       }\n@@ -627,7 +626,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n }\n \n fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n-    print_path(s, t.path, false);\n+    print_path(s, &t.path, false);\n }\n \n pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n@@ -681,7 +680,7 @@ pub fn print_visibility(s: @ps, vis: ast::visibility) {\n }\n \n pub fn print_struct(s: @ps,\n-                    struct_def: @ast::struct_def,\n+                    struct_def: &ast::struct_def,\n                     generics: &ast::Generics,\n                     ident: ast::ident,\n                     span: codemap::span) {\n@@ -695,7 +694,7 @@ pub fn print_struct(s: @ps,\n                     ast::named_field(*) => fail!(\"unexpected named field\"),\n                     ast::unnamed_field => {\n                         maybe_print_comment(s, field.span.lo);\n-                        print_type(s, field.node.ty);\n+                        print_type(s, &field.node.ty);\n                     }\n                 }\n             }\n@@ -719,7 +718,7 @@ pub fn print_struct(s: @ps,\n                     print_visibility(s, visibility);\n                     print_ident(s, ident);\n                     word_nbsp(s, \":\");\n-                    print_type(s, field.node.ty);\n+                    print_type(s, &field.node.ty);\n                     word(s.s, \",\");\n                 }\n             }\n@@ -738,7 +737,7 @@ pub fn print_struct(s: @ps,\n /// expression arguments as expressions). It can be done! I think.\n pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n     match *tt {\n-      ast::tt_delim(ref tts) => print_tts(s, *tts),\n+      ast::tt_delim(ref tts) => print_tts(s, &(tts.as_slice())),\n       ast::tt_tok(_, ref tk) => {\n           word(s.s, parse::token::to_str(s.intr, tk));\n       }\n@@ -759,7 +758,7 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n     }\n }\n \n-pub fn print_tts(s: @ps, tts: &[ast::token_tree]) {\n+pub fn print_tts(s: @ps, tts: & &[ast::token_tree]) {\n     ibox(s, 0);\n     for tts.iter().enumerate().advance |(i, tt)| {\n         if i != 0 {\n@@ -777,8 +776,8 @@ pub fn print_variant(s: @ps, v: &ast::variant) {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n                 popen(s);\n-                fn print_variant_arg(s: @ps, arg: ast::variant_arg) {\n-                    print_type(s, arg.ty);\n+                fn print_variant_arg(s: @ps, arg: &ast::variant_arg) {\n+                    print_type(s, &arg.ty);\n                 }\n                 commasep(s, consistent, *args, print_variant_arg);\n                 pclose(s);\n@@ -804,7 +803,7 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, None, None, None, m.purity, ast::Many,\n+    print_ty_fn(s, None, None, &None, m.purity, ast::Many,\n                 &m.decl, Some(m.ident), &None, Some(&m.generics),\n                 Some(/*bad*/ copy m.explicit_self.node));\n     word(s.s, \";\");\n@@ -817,7 +816,7 @@ pub fn print_trait_method(s: @ps, m: &ast::trait_method) {\n     }\n }\n \n-pub fn print_method(s: @ps, meth: @ast::method) {\n+pub fn print_method(s: @ps, meth: &ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n@@ -832,7 +831,7 @@ pub fn print_outer_attributes(s: @ps, attrs: &[ast::attribute]) {\n     let mut count = 0;\n     for attrs.iter().advance |attr| {\n         match attr.node.style {\n-          ast::attr_outer => { print_attribute(s, *attr); count += 1; }\n+          ast::attr_outer => { print_attribute(s, attr); count += 1; }\n           _ => {/* fallthrough */ }\n         }\n     }\n@@ -844,7 +843,7 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     for attrs.iter().advance |attr| {\n         match attr.node.style {\n           ast::attr_inner => {\n-            print_attribute(s, *attr);\n+            print_attribute(s, attr);\n             if !attr.node.is_sugared_doc {\n                 word(s.s, \";\");\n             }\n@@ -856,11 +855,11 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_attribute(s: @ps, attr: ast::attribute) {\n+pub fn print_attribute(s: @ps, attr: &ast::attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n-        let meta = attr::attr_meta(attr);\n+        let meta = attr::attr_meta(*attr);\n         let comment = attr::get_meta_item_value_str(meta).get();\n         word(s.s, comment);\n     } else {\n@@ -947,7 +946,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n \n     print_inner_attributes(s, attrs);\n \n-    for blk.node.view_items.iter().advance |vi| { print_view_item(s, *vi); }\n+    for blk.node.view_items.iter().advance |vi| { print_view_item(s, vi); }\n     for blk.node.stmts.iter().advance |st| {\n         print_stmt(s, *st);\n     }\n@@ -963,7 +962,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n     (s.ann.post)(ann_node);\n }\n \n-pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n+pub fn print_if(s: @ps, test: &ast::expr, blk: &ast::blk,\n                 elseopt: Option<@ast::expr>, chk: bool) {\n     head(s, \"if\");\n     if chk { word_nbsp(s, \"check\"); }\n@@ -1005,11 +1004,11 @@ pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n \n pub fn print_mac(s: @ps, m: &ast::mac) {\n     match m.node {\n-      ast::mac_invoc_tt(pth, ref tts) => {\n+      ast::mac_invoc_tt(ref pth, ref tts) => {\n         print_path(s, pth, false);\n         word(s.s, \"!\");\n         popen(s);\n-        print_tts(s, *tts);\n+        print_tts(s, &tts.as_slice());\n         pclose(s);\n       }\n     }\n@@ -1021,7 +1020,7 @@ pub fn print_vstore(s: @ps, t: ast::vstore) {\n         ast::vstore_fixed(None) => word(s.s, \"_\"),\n         ast::vstore_uniq => word(s.s, \"~\"),\n         ast::vstore_box => word(s.s, \"@\"),\n-        ast::vstore_slice(r) => {\n+        ast::vstore_slice(ref r) => {\n             word(s.s, \"&\");\n             print_opt_lifetime(s, r);\n         }\n@@ -1088,15 +1087,15 @@ pub fn print_call_post(s: @ps,\n     }\n }\n \n-pub fn print_expr(s: @ps, expr: @ast::expr) {\n-    fn print_field(s: @ps, field: ast::field) {\n+pub fn print_expr(s: @ps, expr: &ast::expr) {\n+    fn print_field(s: @ps, field: &ast::field) {\n         ibox(s, indent_unit);\n         print_ident(s, field.node.ident);\n         word_space(s, \":\");\n         print_expr(s, field.node.expr);\n         end(s);\n     }\n-    fn get_span(field: ast::field) -> codemap::span { return field.span; }\n+    fn get_span(field: &ast::field) -> codemap::span { return field.span; }\n \n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n@@ -1134,7 +1133,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         end(s);\n       }\n \n-      ast::expr_struct(path, ref fields, wth) => {\n+      ast::expr_struct(ref path, ref fields, wth) => {\n         print_path(s, path, true);\n         word(s.s, \"{\");\n         commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n@@ -1199,7 +1198,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_expr(s, expr);\n       }\n       ast::expr_lit(lit) => print_literal(s, lit),\n-      ast::expr_cast(expr, ty) => {\n+      ast::expr_cast(expr, ref ty) => {\n         print_expr(s, expr);\n         space(s.s);\n         word_space(s, \"as\");\n@@ -1359,7 +1358,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_expr(s, index);\n         word(s.s, \"]\");\n       }\n-      ast::expr_path(path) => print_path(s, path, true),\n+      ast::expr_path(ref path) => print_path(s, path, true),\n       ast::expr_self => word(s.s, \"self\"),\n       ast::expr_break(opt_ident) => {\n         word(s.s, \"break\");\n@@ -1434,15 +1433,15 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n     end(s);\n }\n \n-pub fn print_local_decl(s: @ps, loc: @ast::local) {\n+pub fn print_local_decl(s: @ps, loc: &ast::local) {\n     print_irrefutable_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n       ast::ty_infer => (),\n-      _ => { word_space(s, \":\"); print_type(s, loc.node.ty); }\n+      _ => { word_space(s, \":\"); print_type(s, &loc.node.ty); }\n     }\n }\n \n-pub fn print_decl(s: @ps, decl: @ast::decl) {\n+pub fn print_decl(s: @ps, decl: &ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n     match decl.node {\n       ast::decl_local(ref loc) => {\n@@ -1454,7 +1453,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n             word_nbsp(s, \"mut\");\n         }\n \n-        fn print_local(s: @ps, loc: @ast::local) {\n+        fn print_local(s: @ps, loc: &ast::local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n@@ -1479,14 +1478,14 @@ pub fn print_ident(s: @ps, ident: ast::ident) {\n     word(s.s, ident_to_str(&ident));\n }\n \n-pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n+pub fn print_for_decl(s: @ps, loc: &ast::local, coll: &ast::expr) {\n     print_local_decl(s, loc);\n     space(s.s);\n     word_space(s, \"in\");\n     print_expr(s, coll);\n }\n \n-fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n+fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n                opt_bounds: &Option<OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n@@ -1505,7 +1504,7 @@ fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n             word(s.s, \"<\");\n \n             for path.rp.iter().advance |r| {\n-                print_lifetime(s, *r);\n+                print_lifetime(s, r);\n                 if !path.types.is_empty() {\n                     word_space(s, \",\");\n                 }\n@@ -1518,32 +1517,32 @@ fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n     }\n }\n \n-pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n+pub fn print_path(s: @ps, path: &ast::Path, colons_before_params: bool) {\n     print_path_(s, path, colons_before_params, &None)\n }\n \n-pub fn print_bounded_path(s: @ps, path: @ast::Path,\n+pub fn print_bounded_path(s: @ps, path: &ast::Path,\n                           bounds: &Option<OptVec<ast::TyParamBound>>) {\n     print_path_(s, path, false, bounds)\n }\n \n-pub fn print_irrefutable_pat(s: @ps, pat: @ast::pat) {\n+pub fn print_irrefutable_pat(s: @ps, pat: &ast::pat) {\n     print_pat(s, pat, false)\n }\n \n-pub fn print_refutable_pat(s: @ps, pat: @ast::pat) {\n+pub fn print_refutable_pat(s: @ps, pat: &ast::pat) {\n     print_pat(s, pat, true)\n }\n \n-pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n+pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     (s.ann.pre)(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     match pat.node {\n       ast::pat_wild => word(s.s, \"_\"),\n-      ast::pat_ident(binding_mode, path, sub) => {\n+      ast::pat_ident(binding_mode, ref path, sub) => {\n           if refutable {\n               match binding_mode {\n                   ast::bind_by_ref(mutbl) => {\n@@ -1562,31 +1561,31 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n               None => ()\n           }\n       }\n-      ast::pat_enum(path, ref args_) => {\n+      ast::pat_enum(ref path, ref args_) => {\n         print_path(s, path, true);\n         match *args_ {\n           None => word(s.s, \"(*)\"),\n           Some(ref args) => {\n             if !args.is_empty() {\n               popen(s);\n               commasep(s, inconsistent, *args,\n-                       |s, p| print_pat(s, p, refutable));\n+                       |s, &p| print_pat(s, p, refutable));\n               pclose(s);\n             } else { }\n           }\n         }\n       }\n-      ast::pat_struct(path, ref fields, etc) => {\n+      ast::pat_struct(ref path, ref fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, \"{\");\n-        fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n+        fn print_field(s: @ps, f: &ast::field_pat, refutable: bool) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n             word_space(s, \":\");\n             print_pat(s, f.pat, refutable);\n             end(s);\n         }\n-        fn get_span(f: ast::field_pat) -> codemap::span { return f.pat.span; }\n+        fn get_span(f: &ast::field_pat) -> codemap::span { return f.pat.span; }\n         commasep_cmnt(s, consistent, *fields,\n                       |s, f| print_field(s,f,refutable),\n                       get_span);\n@@ -1598,7 +1597,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n       }\n       ast::pat_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, *elts, |s, p| print_pat(s, p, refutable));\n+        commasep(s, inconsistent, *elts, |s, &p| print_pat(s, p, refutable));\n         if elts.len() == 1 {\n             word(s.s, \",\");\n         }\n@@ -1625,7 +1624,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n       }\n       ast::pat_vec(ref before, slice, ref after) => {\n         word(s.s, \"[\");\n-        do commasep(s, inconsistent, *before) |s, p| {\n+        do commasep(s, inconsistent, *before) |s, &p| {\n             print_pat(s, p, refutable);\n         }\n         for slice.iter().advance |&p| {\n@@ -1634,7 +1633,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n             print_pat(s, p, refutable);\n             if !after.is_empty() { word_space(s, \",\"); }\n         }\n-        do commasep(s, inconsistent, *after) |s, p| {\n+        do commasep(s, inconsistent, *after) |s, &p| {\n             print_pat(s, p, refutable);\n         }\n         word(s.s, \"]\");\n@@ -1643,8 +1642,8 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n     (s.ann.post)(ann_node);\n }\n \n-pub fn explicit_self_to_str(explicit_self: ast::explicit_self_, intr: @ident_interner) -> ~str {\n-    to_str(explicit_self, |a, b| { print_explicit_self(a, b); () }, intr)\n+pub fn explicit_self_to_str(explicit_self: &ast::explicit_self_, intr: @ident_interner) -> ~str {\n+    to_str(explicit_self, |a, &b| { print_explicit_self(a, b); () }, intr)\n }\n \n // Returns whether it printed anything\n@@ -1653,7 +1652,7 @@ pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n         ast::sty_static => { return false; }\n         ast::sty_value => { word(s.s, \"self\"); }\n         ast::sty_uniq => { word(s.s, \"~self\"); }\n-        ast::sty_region(lt, m) => {\n+        ast::sty_region(ref lt, m) => {\n             word(s.s, \"&\");\n             print_opt_lifetime(s, lt);\n             print_mutability(s, m);\n@@ -1694,7 +1693,7 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n \n     for decl.inputs.iter().advance |arg| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        print_arg(s, *arg);\n+        print_arg(s, arg);\n     }\n \n     end(s);\n@@ -1712,7 +1711,7 @@ pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n         _ => {\n             space_if_not_bol(s);\n             word_space(s, \"->\");\n-            print_type(s, decl.output);\n+            print_type(s, &decl.output);\n         }\n     }\n }\n@@ -1727,7 +1726,7 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n         _ => {\n             space_if_not_bol(s);\n             word_space(s, \"->\");\n-            print_type(s, decl.output);\n+            print_type(s, &decl.output);\n         }\n     }\n \n@@ -1748,7 +1747,7 @@ pub fn print_bounds(s: @ps, bounds: &OptVec<ast::TyParamBound>,\n             }\n \n             match *bound {\n-                TraitTyParamBound(tref) => print_trait_ref(s, tref),\n+                TraitTyParamBound(ref tref) => print_trait_ref(s, tref),\n                 RegionTyParamBound => word(s.s, \"'static\"),\n             }\n         }\n@@ -1774,7 +1773,7 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n                 let idx = idx - generics.lifetimes.len();\n                 let param = generics.ty_params.get(idx);\n                 print_ident(s, param.ident);\n-                print_bounds(s, param.bounds, false);\n+                print_bounds(s, &param.bounds, false);\n             }\n         }\n \n@@ -1784,12 +1783,12 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n         }\n \n         commasep(s, inconsistent, ints,\n-                 |s, i| print_item(s, generics, i));\n+                 |s, &i| print_item(s, generics, i));\n         word(s.s, \">\");\n     }\n }\n \n-pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n+pub fn print_meta_item(s: @ps, item: &ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n       ast::meta_word(name) => word(s.s, name),\n@@ -1804,18 +1803,18 @@ pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n         commasep(\n             s,\n             consistent,\n-            /* FIXME (#2543) */ copy *items,\n-            print_meta_item\n+            items.as_slice(),\n+            |p, &i| print_meta_item(p, i)\n         );\n         pclose(s);\n       }\n     }\n     end(s);\n }\n \n-pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n+pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n     match vp.node {\n-      ast::view_path_simple(ident, path, _) => {\n+      ast::view_path_simple(ident, ref path, _) => {\n         if path.idents[path.idents.len()-1u] != ident {\n             print_ident(s, ident);\n             space(s.s);\n@@ -1824,12 +1823,12 @@ pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n         print_path(s, path, false);\n       }\n \n-      ast::view_path_glob(path, _) => {\n+      ast::view_path_glob(ref path, _) => {\n         print_path(s, path, false);\n         word(s.s, \"::*\");\n       }\n \n-      ast::view_path_list(path, ref idents, _) => {\n+      ast::view_path_list(ref path, ref idents, _) => {\n         print_path(s, path, false);\n         word(s.s, \"::{\");\n         do commasep(s, inconsistent, (*idents)) |s, w| {\n@@ -1841,10 +1840,10 @@ pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n }\n \n pub fn print_view_paths(s: @ps, vps: &[@ast::view_path]) {\n-    commasep(s, inconsistent, vps, print_view_path);\n+    commasep(s, inconsistent, vps, |p, &vp| print_view_path(p, vp));\n }\n \n-pub fn print_view_item(s: @ps, item: @ast::view_item) {\n+pub fn print_view_item(s: @ps, item: &ast::view_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -1855,7 +1854,7 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n             print_ident(s, id);\n             if !mta.is_empty() {\n                 popen(s);\n-                commasep(s, consistent, *mta, print_meta_item);\n+                commasep(s, consistent, *mta, |p, &i| print_meta_item(p, i));\n                 pclose(s);\n             }\n         }\n@@ -1883,7 +1882,7 @@ pub fn print_mt(s: @ps, mt: &ast::mt) {\n     print_type(s, mt.ty);\n }\n \n-pub fn print_arg(s: @ps, input: ast::arg) {\n+pub fn print_arg(s: @ps, input: &ast::arg) {\n     ibox(s, indent_unit);\n     if input.is_mutbl {\n         word_space(s, \"mut\");\n@@ -1892,7 +1891,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n       ast::ty_infer => print_irrefutable_pat(s, input.pat),\n       _ => {\n         match input.pat.node {\n-            ast::pat_ident(_, path, _) if\n+            ast::pat_ident(_, ref path, _) if\n                 path.idents.len() == 1 &&\n                 path.idents[0] == parse::token::special_idents::invalid => {\n                 // Do nothing.\n@@ -1903,7 +1902,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n                 space(s.s);\n             }\n         }\n-        print_type(s, input.ty);\n+        print_type(s, &input.ty);\n       }\n     }\n     end(s);\n@@ -1912,7 +1911,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n pub fn print_ty_fn(s: @ps,\n                    opt_abis: Option<AbiSet>,\n                    opt_sigil: Option<ast::Sigil>,\n-                   opt_region: Option<@ast::Lifetime>,\n+                   opt_region: &Option<ast::Lifetime>,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n                    decl: &ast::fn_decl,\n@@ -1945,7 +1944,7 @@ pub fn print_ty_fn(s: @ps,\n     }\n     for decl.inputs.iter().advance |arg| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        print_arg(s, *arg);\n+        print_arg(s, arg);\n     }\n     end(s);\n     pclose(s);\n@@ -1959,7 +1958,7 @@ pub fn print_ty_fn(s: @ps,\n             ibox(s, indent_unit);\n             word_space(s, \"->\");\n             if decl.cf == ast::noreturn { word_nbsp(s, \"!\"); }\n-            else { print_type(s, decl.output); }\n+            else { print_type(s, &decl.output); }\n             end(s);\n         }\n     }\n@@ -2003,7 +2002,7 @@ pub fn print_remaining_comments(s: @ps) {\n     }\n }\n \n-pub fn print_literal(s: @ps, lit: @ast::lit) {\n+pub fn print_literal(s: @ps, lit: &ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n@@ -2056,7 +2055,7 @@ pub fn print_literal(s: @ps, lit: @ast::lit) {\n     }\n }\n \n-pub fn lit_to_str(l: @ast::lit) -> ~str {\n+pub fn lit_to_str(l: &ast::lit) -> ~str {\n     return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n }\n \n@@ -2139,10 +2138,10 @@ pub fn print_string(s: @ps, st: &str) {\n     word(s.s, \"\\\"\");\n }\n \n-pub fn to_str<T: Copy>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n+pub fn to_str<T>(t: &T, f: &fn(@ps, &T), intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n-        f(s, copy t);\n+        f(s, t);\n         eof(s.s);\n     }\n }\n@@ -2273,7 +2272,7 @@ mod test {\n \n         let decl = ast::fn_decl {\n             inputs: ~[],\n-            output: @ast::Ty {id: 0,\n+            output: ast::Ty {id: 0,\n                               node: ast::ty_nil,\n                               span: codemap::dummy_sp()},\n             cf: ast::return_val"}, {"sha": "b2d9d49f0ee77eed8610ac37a28c494b9ca35f04", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f2515583dca4d6af7fabb6ebbd46c265710aacc/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0f2515583dca4d6af7fabb6ebbd46c265710aacc", "patch": "@@ -72,7 +72,7 @@ pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n \n pub struct Visitor<E> {\n     visit_mod: @fn(&_mod, span, node_id, (E, vt<E>)),\n-    visit_view_item: @fn(@view_item, (E, vt<E>)),\n+    visit_view_item: @fn(&view_item, (E, vt<E>)),\n     visit_foreign_item: @fn(@foreign_item, (E, vt<E>)),\n     visit_item: @fn(@item, (E, vt<E>)),\n     visit_local: @fn(@local, (E, vt<E>)),\n@@ -83,7 +83,7 @@ pub struct Visitor<E> {\n     visit_decl: @fn(@decl, (E, vt<E>)),\n     visit_expr: @fn(@expr, (E, vt<E>)),\n     visit_expr_post: @fn(@expr, (E, vt<E>)),\n-    visit_ty: @fn(@Ty, (E, vt<E>)),\n+    visit_ty: @fn(&Ty, (E, vt<E>)),\n     visit_generics: @fn(&Generics, (E, vt<E>)),\n     visit_fn: @fn(&fn_kind, &fn_decl, &blk, span, node_id, (E, vt<E>)),\n     visit_ty_method: @fn(&ty_method, (E, vt<E>)),\n@@ -123,28 +123,28 @@ pub fn visit_crate<E: Copy>(c: &crate, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_mod<E: Copy>(m: &_mod, _sp: span, _id: node_id, (e, v): (E, vt<E>)) {\n-    for m.view_items.iter().advance |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+    for m.view_items.iter().advance |vi| { (v.visit_view_item)(vi, (copy e, v)); }\n     for m.items.iter().advance |i| { (v.visit_item)(*i, (copy e, v)); }\n }\n \n pub fn visit_view_item<E>(_vi: &view_item, (_e, _v): (E, vt<E>)) { }\n \n pub fn visit_local<E: Copy>(loc: &local, (e, v): (E, vt<E>)) {\n     (v.visit_pat)(loc.node.pat, (copy e, v));\n-    (v.visit_ty)(loc.node.ty, (copy e, v));\n+    (v.visit_ty)(&loc.node.ty, (copy e, v));\n     match loc.node.init {\n       None => (),\n       Some(ex) => (v.visit_expr)(ex, (e, v))\n     }\n }\n \n fn visit_trait_ref<E: Copy>(tref: &ast::trait_ref, (e, v): (E, vt<E>)) {\n-    visit_path(tref.path, (e, v));\n+    visit_path(&tref.path, (e, v));\n }\n \n pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n     match i.node {\n-        item_static(t, _, ex) => {\n+        item_static(ref t, _, ex) => {\n             (v.visit_ty)(t, (copy e, v));\n             (v.visit_expr)(ex, (copy e, v));\n         }\n@@ -166,10 +166,10 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_mod(ref m) => (v.visit_mod)(m, i.span, i.id, (e, v)),\n         item_foreign_mod(ref nm) => {\n-            for nm.view_items.iter().advance |vi| { (v.visit_view_item)(*vi, (copy e, v)); }\n+            for nm.view_items.iter().advance |vi| { (v.visit_view_item)(vi, (copy e, v)); }\n             for nm.items.iter().advance |ni| { (v.visit_foreign_item)(*ni, (copy e, v)); }\n         }\n-        item_ty(t, ref tps) => {\n+        item_ty(ref t, ref tps) => {\n             (v.visit_ty)(t, (copy e, v));\n             (v.visit_generics)(tps, (e, v));\n         }\n@@ -181,9 +181,9 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n                 (e, v)\n             );\n         }\n-        item_impl(ref tps, ref traits, ty, ref methods) => {\n+        item_impl(ref tps, ref traits, ref ty, ref methods) => {\n             (v.visit_generics)(tps, (copy e, v));\n-            for traits.iter().advance |&p| {\n+            for traits.iter().advance |p| {\n                 visit_trait_ref(p, (copy e, v));\n             }\n             (v.visit_ty)(ty, (copy e, v));\n@@ -197,7 +197,7 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             (v.visit_generics)(generics, (copy e, v));\n-            for traits.iter().advance |p| { visit_path(p.path, (copy e, v)); }\n+            for traits.iter().advance |p| { visit_path(&p.path, (copy e, v)); }\n             for methods.iter().advance |m| {\n                 (v.visit_trait_method)(m, (copy e, v));\n             }\n@@ -213,7 +213,7 @@ pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n                 for variant_args.iter().advance |va| {\n-                    (v.visit_ty)(va.ty, (copy e, v));\n+                    (v.visit_ty)(&va.ty, (copy e, v));\n                 }\n             }\n             struct_variant_kind(struct_def) => {\n@@ -232,27 +232,27 @@ pub fn skip_ty<E>(_t: &Ty, (_e,_v): (E, vt<E>)) {}\n \n pub fn visit_ty<E: Copy>(t: &Ty, (e, v): (E, vt<E>)) {\n     match t.node {\n-        ty_box(mt) | ty_uniq(mt) |\n-        ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n+        ty_box(ref mt) | ty_uniq(ref mt) |\n+        ty_vec(ref mt) | ty_ptr(ref mt) | ty_rptr(_, ref mt) => {\n             (v.visit_ty)(mt.ty, (e, v));\n         },\n         ty_tup(ref ts) => {\n             for ts.iter().advance |tt| {\n-                (v.visit_ty)(*tt, (copy e, v));\n+                (v.visit_ty)(tt, (copy e, v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n-            (v.visit_ty)(f.decl.output, (copy e, v));\n+            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n+            (v.visit_ty)(&f.decl.output, (copy e, v));\n             do f.bounds.map |bounds| {\n                 visit_ty_param_bounds(bounds, (copy e, v));\n             };\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n-            (v.visit_ty)(f.decl.output, (e, v));\n+            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n+            (v.visit_ty)(&f.decl.output, (e, v));\n         },\n-        ty_path(p, bounds, _) => {\n+        ty_path(ref p, ref bounds, _) => {\n             visit_path(p, (copy e, v));\n             do bounds.map |bounds| {\n                 visit_ty_param_bounds(bounds, (copy e, v));\n@@ -267,20 +267,20 @@ pub fn visit_ty<E: Copy>(t: &Ty, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_path<E: Copy>(p: &Path, (e, v): (E, vt<E>)) {\n-    for p.types.iter().advance |tp| { (v.visit_ty)(*tp, (copy e, v)); }\n+    for p.types.iter().advance |tp| { (v.visit_ty)(tp, (copy e, v)); }\n }\n \n pub fn visit_pat<E: Copy>(p: &pat, (e, v): (E, vt<E>)) {\n     match p.node {\n-        pat_enum(path, ref children) => {\n+        pat_enum(ref path, ref children) => {\n             visit_path(path, (copy e, v));\n             for children.iter().advance |children| {\n                 for children.iter().advance |child| {\n                     (v.visit_pat)(*child, (copy e, v));\n                 }\n             }\n         }\n-        pat_struct(path, ref fields, _) => {\n+        pat_struct(ref path, ref fields, _) => {\n             visit_path(path, (copy e, v));\n             for fields.iter().advance |f| {\n                 (v.visit_pat)(f.pat, (copy e, v));\n@@ -294,7 +294,7 @@ pub fn visit_pat<E: Copy>(p: &pat, (e, v): (E, vt<E>)) {\n         pat_box(inner) | pat_uniq(inner) | pat_region(inner) => {\n             (v.visit_pat)(inner, (e, v))\n         },\n-        pat_ident(_, path, ref inner) => {\n+        pat_ident(_, ref path, ref inner) => {\n             visit_path(path, (copy e, v));\n             for inner.iter().advance |subpat| {\n                 (v.visit_pat)(*subpat, (copy e, v))\n@@ -326,7 +326,7 @@ pub fn visit_foreign_item<E: Copy>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n             visit_fn_decl(fd, (copy e, v));\n             (v.visit_generics)(generics, (e, v));\n         }\n-        foreign_item_static(t, _) => {\n+        foreign_item_static(ref t, _) => {\n             (v.visit_ty)(t, (e, v));\n         }\n     }\n@@ -336,24 +336,24 @@ pub fn visit_ty_param_bounds<E: Copy>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n     for bounds.iter().advance |bound| {\n         match *bound {\n-            TraitTyParamBound(ty) => visit_trait_ref(ty, (copy e, v)),\n+            TraitTyParamBound(ref ty) => visit_trait_ref(ty, (copy e, v)),\n             RegionTyParamBound => {}\n         }\n     }\n }\n \n pub fn visit_generics<E: Copy>(generics: &Generics, (e, v): (E, vt<E>)) {\n     for generics.ty_params.iter().advance |tp| {\n-        visit_ty_param_bounds(tp.bounds, (copy e, v));\n+        visit_ty_param_bounds(&tp.bounds, (copy e, v));\n     }\n }\n \n pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n     for fd.inputs.iter().advance |a| {\n         (v.visit_pat)(a.pat, (copy e, v));\n-        (v.visit_ty)(a.ty, (copy e, v));\n+        (v.visit_ty)(&a.ty, (copy e, v));\n     }\n-    (v.visit_ty)(fd.output, (e, v));\n+    (v.visit_ty)(&fd.output, (e, v));\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n@@ -384,9 +384,9 @@ pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n }\n \n pub fn visit_ty_method<E: Copy>(m: &ty_method, (e, v): (E, vt<E>)) {\n-    for m.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n+    for m.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n     (v.visit_generics)(&m.generics, (copy e, v));\n-    (v.visit_ty)(m.decl.output, (e, v));\n+    (v.visit_ty)(&m.decl.output, (e, v));\n }\n \n pub fn visit_trait_method<E: Copy>(m: &trait_method, (e, v): (E, vt<E>)) {\n@@ -409,12 +409,12 @@ pub fn visit_struct_def<E: Copy>(\n }\n \n pub fn visit_struct_field<E: Copy>(sf: &struct_field, (e, v): (E, vt<E>)) {\n-    (v.visit_ty)(sf.node.ty, (e, v));\n+    (v.visit_ty)(&sf.node.ty, (e, v));\n }\n \n pub fn visit_block<E: Copy>(b: &blk, (e, v): (E, vt<E>)) {\n     for b.node.view_items.iter().advance |vi| {\n-        (v.visit_view_item)(*vi, (copy e, v));\n+        (v.visit_view_item)(vi, (copy e, v));\n     }\n     for b.node.stmts.iter().advance |s| {\n         (v.visit_stmt)(*s, (copy e, v));\n@@ -458,7 +458,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n             (v.visit_expr)(element, (copy e, v));\n             (v.visit_expr)(count, (copy e, v));\n         }\n-        expr_struct(p, ref flds, base) => {\n+        expr_struct(ref p, ref flds, base) => {\n             visit_path(p, (copy e, v));\n             for flds.iter().advance |f| {\n                 (v.visit_expr)(f.node.expr, (copy e, v));\n@@ -475,7 +475,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n             visit_exprs(*args, (copy e, v));\n             for tys.iter().advance |tp| {\n-                (v.visit_ty)(*tp, (copy e, v));\n+                (v.visit_ty)(tp, (copy e, v));\n             }\n             (v.visit_expr)(callee, (copy e, v));\n         }\n@@ -486,7 +486,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_addr_of(_, x) | expr_unary(_, _, x) |\n         expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (copy e, v)),\n         expr_lit(_) => (),\n-        expr_cast(x, t) => {\n+        expr_cast(x, ref t) => {\n             (v.visit_expr)(x, (copy e, v));\n             (v.visit_ty)(t, (copy e, v));\n         }\n@@ -527,14 +527,14 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_field(x, _, ref tys) => {\n             (v.visit_expr)(x, (copy e, v));\n             for tys.iter().advance |tp| {\n-                (v.visit_ty)(*tp, (copy e, v));\n+                (v.visit_ty)(tp, (copy e, v));\n             }\n         }\n         expr_index(_, a, b) => {\n             (v.visit_expr)(a, (copy e, v));\n             (v.visit_expr)(b, (copy e, v));\n         }\n-        expr_path(p) => visit_path(p, (copy e, v)),\n+        expr_path(ref p) => visit_path(p, (copy e, v)),\n         expr_self => (),\n         expr_break(_) => (),\n         expr_again(_) => (),\n@@ -568,7 +568,7 @@ pub fn visit_arm<E: Copy>(a: &arm, (e, v): (E, vt<E>)) {\n \n pub struct SimpleVisitor {\n     visit_mod: @fn(&_mod, span, node_id),\n-    visit_view_item: @fn(@view_item),\n+    visit_view_item: @fn(&view_item),\n     visit_foreign_item: @fn(@foreign_item),\n     visit_item: @fn(@item),\n     visit_local: @fn(@local),\n@@ -579,7 +579,7 @@ pub struct SimpleVisitor {\n     visit_decl: @fn(@decl),\n     visit_expr: @fn(@expr),\n     visit_expr_post: @fn(@expr),\n-    visit_ty: @fn(@Ty),\n+    visit_ty: @fn(&Ty),\n     visit_generics: @fn(&Generics),\n     visit_fn: @fn(&fn_kind, &fn_decl, &blk, span, node_id),\n     visit_ty_method: @fn(&ty_method),\n@@ -591,7 +591,7 @@ pub struct SimpleVisitor {\n \n pub type simple_visitor = @SimpleVisitor;\n \n-pub fn simple_ignore_ty(_t: @Ty) {}\n+pub fn simple_ignore_ty(_t: &Ty) {}\n \n pub fn default_simple_visitor() -> @SimpleVisitor {\n     @SimpleVisitor {\n@@ -629,7 +629,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(m, sp, id);\n         visit_mod(m, sp, id, (e, v));\n     }\n-    fn v_view_item(f: @fn(@view_item), vi: @view_item, (e, v): ((), vt<()>)) {\n+    fn v_view_item(f: @fn(&view_item), vi: &view_item, (e, v): ((), vt<()>)) {\n         f(vi);\n         visit_view_item(vi, (e, v));\n     }\n@@ -672,7 +672,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     fn v_expr_post(f: @fn(@expr), ex: @expr, (_e, _v): ((), vt<()>)) {\n         f(ex);\n     }\n-    fn v_ty(f: @fn(@Ty), ty: @Ty, (e, v): ((), vt<()>)) {\n+    fn v_ty(f: @fn(&Ty), ty: &Ty, (e, v): ((), vt<()>)) {\n         f(ty);\n         visit_ty(ty, (e, v));\n     }\n@@ -717,7 +717,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(fk, decl, body, sp, id);\n         visit_fn(fk, decl, body, sp, id, (e, v));\n     }\n-    let visit_ty: @fn(@Ty, ((), vt<()>)) =\n+    let visit_ty: @fn(&Ty, ((), vt<()>)) =\n         |a,b| v_ty(v.visit_ty, a, b);\n     fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, (e, v): ((), vt<()>)) {\n         f(sf);"}]}