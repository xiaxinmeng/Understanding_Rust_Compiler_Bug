{"sha": "d54bd9f29af67748b7ddf80a5cf285145949ddc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NGJkOWYyOWFmNjc3NDhiN2RkZjgwYTVjZjI4NTE0NTk0OWRkYzI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-11T21:16:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-13T03:39:03Z"}, "message": "std: Stabilize the `io` module\n\nThe new `std::io` module has had some time to bake now, and this commit\nstabilizes its functionality. There are still portions of the module which\nremain unstable, and below contains a summart of the actions taken.\n\nThis commit also deprecates the entire contents of the `old_io` module in a\nblanket fashion. All APIs should now have a reasonable replacement in the\nnew I/O modules.\n\nStable APIs:\n\n* `std::io` (the name)\n* `std::io::prelude` (the name)\n* `Read`\n* `Read::read`\n* `Read::{read_to_end, read_to_string}` after being modified to return a `usize`\n  for the number of bytes read.\n* `Write`\n* `Write::write`\n* `Write::{write_all, write_fmt}`\n* `BufRead`\n* `BufRead::{fill_buf, consume}`\n* `BufRead::{read_line, read_until}` after being modified to return a `usize`\n  for the number of bytes read.\n* `BufReader`\n* `BufReader::{new, with_capacity}`\n* `BufReader::{get_ref, get_mut, into_inner}`\n* `{Read,BufRead} for BufReader`\n* `BufWriter`\n* `BufWriter::{new, with_capacity}`\n* `BufWriter::{get_ref, get_mut, into_inner}`\n* `Write for BufWriter`\n* `IntoInnerError`\n* `IntoInnerError::{error, into_inner}`\n* `{Error,Display} for IntoInnerError`\n* `LineWriter`\n* `LineWriter::{new, with_capacity}` - `with_capacity` was added\n* `LineWriter::{get_ref, get_mut, into_inner}` - `get_mut` was added)\n* `Write for LineWriter`\n* `BufStream`\n* `BufStream::{new, with_capacities}`\n* `BufStream::{get_ref, get_mut, into_inner}`\n* `{BufRead,Read,Write} for BufStream`\n* `stdin`\n* `Stdin`\n* `Stdin::lock`\n* `Stdin::read_line` - added method\n* `StdinLock`\n* `Read for Stdin`\n* `{Read,BufRead} for StdinLock`\n* `stdout`\n* `Stdout`\n* `Stdout::lock`\n* `StdoutLock`\n* `Write for Stdout`\n* `Write for StdoutLock`\n* `stderr`\n* `Stderr`\n* `Stderr::lock`\n* `StderrLock`\n* `Write for Stderr`\n* `Write for StderrLock`\n* `io::Result`\n* `io::Error`\n* `io::Error::last_os_error`\n* `{Display, Error} for Error`\n\nUnstable APIs:\n\n(reasons can be found in the commit itself)\n\n* `Write::flush`\n* `Seek`\n* `ErrorKind`\n* `Error::new`\n* `Error::from_os_error`\n* `Error::kind`\n\nDeprecated APIs\n\n* `Error::description` - available via the `Error` trait\n* `Error::detail` - available via the `Display` implementation\n* `thread::Builder::{stdout, stderr}`\n\nChanges in functionality:\n\n* `old_io::stdio::set_stderr` is now a noop as the infrastructure for printing\n  backtraces has migrated to `std::io`.\n* The `ReadExt`, `WriteExt`, and `BufReadExt` extension traits were all removed\n  by folding functionality into the corresponding trait.\n\n[breaking-change]", "tree": {"sha": "a42b5b92bcc03e847bd6ff112154680884cf524c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a42b5b92bcc03e847bd6ff112154680884cf524c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d54bd9f29af67748b7ddf80a5cf285145949ddc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d54bd9f29af67748b7ddf80a5cf285145949ddc2", "html_url": "https://github.com/rust-lang/rust/commit/d54bd9f29af67748b7ddf80a5cf285145949ddc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d54bd9f29af67748b7ddf80a5cf285145949ddc2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79dd393a4f144fa5e6f81c720c782de3175810d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/79dd393a4f144fa5e6f81c720c782de3175810d7", "html_url": "https://github.com/rust-lang/rust/commit/79dd393a4f144fa5e6f81c720c782de3175810d7"}], "stats": {"total": 317, "additions": 212, "deletions": 105}, "files": [{"sha": "fb7af1d821d2d0944f02c775d3b50a65280000f1", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 57, "deletions": 10, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=d54bd9f29af67748b7ddf80a5cf285145949ddc2", "patch": "@@ -16,8 +16,7 @@ use prelude::v1::*;\n use io::prelude::*;\n \n use cmp;\n-use error::Error as StdError;\n-use error::FromError;\n+use error::{self, FromError};\n use fmt;\n use io::{self, Cursor, DEFAULT_BUF_SIZE, Error, ErrorKind};\n use ptr;\n@@ -28,18 +27,21 @@ use ptr;\n /// For example, every call to `read` on `TcpStream` results in a system call.\n /// A `BufReader` performs large, infrequent reads on the underlying `Read`\n /// and maintains an in-memory buffer of the results.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufReader<R> {\n     inner: R,\n     buf: Cursor<Vec<u8>>,\n }\n \n impl<R: Read> BufReader<R> {\n     /// Creates a new `BufReader` with a default buffer capacity\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: R) -> BufReader<R> {\n         BufReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n     /// Creates a new `BufReader` with the specified buffer capacity\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> {\n         BufReader {\n             inner: inner,\n@@ -48,21 +50,25 @@ impl<R: Read> BufReader<R> {\n     }\n \n     /// Gets a reference to the underlying reader.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &R { &self.inner }\n \n     /// Gets a mutable reference to the underlying reader.\n     ///\n     /// # Warning\n     ///\n     /// It is inadvisable to directly read from the underlying reader.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n \n     /// Unwraps this `BufReader`, returning the underlying reader.\n     ///\n     /// Note that any leftover data in the internal buffer is lost.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> R { self.inner }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R: Read> Read for BufReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         // If we don't have any buffered data and we're doing a massive read\n@@ -77,6 +83,7 @@ impl<R: Read> Read for BufReader<R> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R: Read> BufRead for BufReader<R> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> {\n         // If we've reached the end of our internal buffer then we need to fetch\n@@ -112,6 +119,7 @@ impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n /// underlying `Write` in large, infrequent batches.\n ///\n /// This writer will be flushed when it is dropped.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W> {\n     inner: Option<W>,\n     buf: Vec<u8>,\n@@ -120,15 +128,18 @@ pub struct BufWriter<W> {\n /// An error returned by `into_inner` which indicates whether a flush error\n /// happened or not.\n #[derive(Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoInnerError<W>(W, Error);\n \n impl<W: Write> BufWriter<W> {\n     /// Creates a new `BufWriter` with a default buffer capacity\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: W) -> BufWriter<W> {\n         BufWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n     }\n \n     /// Creates a new `BufWriter` with the specified buffer capacity\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: W) -> BufWriter<W> {\n         BufWriter {\n             inner: Some(inner),\n@@ -165,18 +176,21 @@ impl<W: Write> BufWriter<W> {\n     }\n \n     /// Gets a reference to the underlying writer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n \n     /// Gets a mutable reference to the underlying write.\n     ///\n     /// # Warning\n     ///\n     /// It is inadvisable to directly read from the underlying writer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n \n     /// Unwraps this `BufWriter`, returning the underlying writer.\n     ///\n     /// The buffer is flushed before returning the writer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n         match self.flush_buf() {\n             Err(e) => Err(IntoInnerError(self, e)),\n@@ -185,6 +199,7 @@ impl<W: Write> BufWriter<W> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> Write for BufWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         if self.buf.len() + buf.len() > self.buf.capacity() {\n@@ -224,23 +239,30 @@ impl<W> IntoInnerError<W> {\n     /// Returns the error which caused the call to `into_inner` to fail.\n     ///\n     /// This error was returned when attempting to flush the internal buffer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn error(&self) -> &Error { &self.1 }\n \n     /// Returns the underlying `BufWriter` instance which generated the error.\n     ///\n     /// The returned object can be used to retry a flush or re-inspect the\n     /// buffer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> W { self.0 }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W> FromError<IntoInnerError<W>> for Error {\n     fn from_error(iie: IntoInnerError<W>) -> Error { iie.1 }\n }\n \n-impl<W> StdError for IntoInnerError<W> {\n-    fn description(&self) -> &str { self.error().description() }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W> error::Error for IntoInnerError<W> {\n+    fn description(&self) -> &str {\n+        error::Error::description(self.error())\n+    }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W> fmt::Display for IntoInnerError<W> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.error().fmt(f)\n@@ -251,33 +273,49 @@ impl<W> fmt::Display for IntoInnerError<W> {\n /// (`0x0a`, `'\\n'`) is detected.\n ///\n /// This writer will be flushed when it is dropped.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LineWriter<W> {\n     inner: BufWriter<W>,\n }\n \n impl<W: Write> LineWriter<W> {\n     /// Creates a new `LineWriter`\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: W) -> LineWriter<W> {\n         // Lines typically aren't that long, don't use a giant buffer\n-        LineWriter { inner: BufWriter::with_capacity(1024, inner) }\n+        LineWriter::with_capacity(1024, inner)\n+    }\n+\n+    /// Creates a new `LineWriter` with a specified capacity for the internal\n+    /// buffer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity(cap: usize, inner: W) -> LineWriter<W> {\n+        LineWriter { inner: BufWriter::with_capacity(cap, inner) }\n     }\n \n     /// Gets a reference to the underlying writer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_ref(&self) -> &W { self.inner.get_ref() }\n+\n+    /// Gets a mutable reference to the underlying writer.\n     ///\n-    /// This type does not expose the ability to get a mutable reference to the\n-    /// underlying reader because that could possibly corrupt the buffer.\n-    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n+    /// Caution must be taken when calling methods on the mutable reference\n+    /// returned as extra writes could corrupt the output stream.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut W { self.inner.get_mut() }\n \n     /// Unwraps this `LineWriter`, returning the underlying writer.\n     ///\n     /// The internal buffer is flushed before returning the writer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<W, IntoInnerError<LineWriter<W>>> {\n         self.inner.into_inner().map_err(|IntoInnerError(buf, e)| {\n             IntoInnerError(LineWriter { inner: buf }, e)\n         })\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> Write for LineWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         match buf.rposition_elem(&b'\\n') {\n@@ -320,19 +358,21 @@ impl<W: Read> Read for InternalBufWriter<W> {\n \n /// Wraps a Stream and buffers input and output to and from it.\n ///\n-/// It can be excessively inefficient to work directly with a `Stream`. For\n+/// It can be excessively inefficient to work directly with a `Read+Write`. For\n /// example, every call to `read` or `write` on `TcpStream` results in a system\n /// call. A `BufStream` keeps in memory buffers of data, making large,\n-/// infrequent calls to `read` and `write` on the underlying `Stream`.\n+/// infrequent calls to `read` and `write` on the underlying `Read+Write`.\n ///\n /// The output half will be flushed when this stream is dropped.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufStream<S> {\n     inner: BufReader<InternalBufWriter<S>>\n }\n \n impl<S: Read + Write> BufStream<S> {\n     /// Creates a new buffered stream with explicitly listed capacities for the\n     /// reader/writer buffer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)\n                            -> BufStream<S> {\n         let writer = BufWriter::with_capacity(writer_cap, inner);\n@@ -343,11 +383,13 @@ impl<S: Read + Write> BufStream<S> {\n \n     /// Creates a new buffered stream with the default reader/writer buffer\n     /// capacities.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: S) -> BufStream<S> {\n         BufStream::with_capacities(DEFAULT_BUF_SIZE, DEFAULT_BUF_SIZE, inner)\n     }\n \n     /// Gets a reference to the underlying stream.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &S {\n         let InternalBufWriter(ref w) = self.inner.inner;\n         w.get_ref()\n@@ -359,6 +401,7 @@ impl<S: Read + Write> BufStream<S> {\n     ///\n     /// It is inadvisable to read directly from or write directly to the\n     /// underlying stream.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut S {\n         let InternalBufWriter(ref mut w) = self.inner.inner;\n         w.get_mut()\n@@ -368,6 +411,7 @@ impl<S: Read + Write> BufStream<S> {\n     ///\n     /// The internal buffer is flushed before returning the stream. Any leftover\n     /// data in the read buffer is lost.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<S, IntoInnerError<BufStream<S>>> {\n         let BufReader { inner: InternalBufWriter(w), buf } = self.inner;\n         w.into_inner().map_err(|IntoInnerError(w, e)| {\n@@ -378,17 +422,20 @@ impl<S: Read + Write> BufStream<S> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Read + Write> BufRead for BufStream<S> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n     fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Read + Write> Read for BufStream<S> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Read + Write> Write for BufStream<S> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.inner.get_mut().write(buf)"}, {"sha": "530c672810723a26ae7c59cfd1c6535a3e6a9105", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=d54bd9f29af67748b7ddf80a5cf285145949ddc2", "patch": "@@ -10,7 +10,7 @@\n \n use boxed::Box;\n use clone::Clone;\n-use error::Error as StdError;\n+use error;\n use fmt;\n use option::Option::{self, Some, None};\n use result;\n@@ -22,6 +22,7 @@ use sys;\n ///\n /// This typedef is generally used to avoid writing out `io::Error` directly and\n /// is otherwise a direct mapping to `std::result::Result`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type Result<T> = result::Result<T, Error>;\n \n /// The error type for I/O operations of the `Read`, `Write`, `Seek`, and\n@@ -31,6 +32,7 @@ pub type Result<T> = result::Result<T, Error>;\n /// `Error` can be created with crafted error messages and a particular value of\n /// `ErrorKind`.\n #[derive(PartialEq, Eq, Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Error {\n     repr: Repr,\n }\n@@ -50,6 +52,10 @@ struct Custom {\n \n /// A list specifying general categories of I/O error.\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n+#[unstable(feature = \"io\",\n+           reason = \"the interaction between OS error codes and how they map to \\\n+                     these names (as well as the names themselves) has not \\\n+                     been thoroughly thought out\")]\n pub enum ErrorKind {\n     /// The file was not found.\n     FileNotFound,\n@@ -96,6 +102,9 @@ pub enum ErrorKind {\n \n impl Error {\n     /// Creates a new custom error from a specified kind/description/detail.\n+    #[unstable(feature = \"io\", reason = \"the exact makeup of an Error may\n+                                         change to include `Box<Error>` for \\\n+                                         example\")]\n     pub fn new(kind: ErrorKind,\n                description: &'static str,\n                detail: Option<String>) -> Error {\n@@ -113,16 +122,20 @@ impl Error {\n     /// This function reads the value of `errno` for the target platform (e.g.\n     /// `GetLastError` on Windows) and will return a corresponding instance of\n     /// `Error` for the error code.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn last_os_error() -> Error {\n         Error::from_os_error(sys::os::errno() as i32)\n     }\n \n     /// Creates a new instance of an `Error` from a particular OS error code.\n+    #[unstable(feature = \"io\",\n+               reason = \"unclear whether this function is necessary\")]\n     pub fn from_os_error(code: i32) -> Error {\n         Error { repr: Repr::Os(code) }\n     }\n \n     /// Return the corresponding `ErrorKind` for this error.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn kind(&self) -> ErrorKind {\n         match self.repr {\n             Repr::Os(code) => sys::decode_error_kind(code),\n@@ -131,6 +144,9 @@ impl Error {\n     }\n \n     /// Returns a short description for this error message\n+    #[unstable(feature = \"io\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use the Error trait's description \\\n+                                            method instead\")]\n     pub fn description(&self) -> &str {\n         match self.repr {\n             Repr::Os(..) => \"os error\",\n@@ -139,6 +155,8 @@ impl Error {\n     }\n \n     /// Returns a detailed error message for this error (if one is available)\n+    #[unstable(feature = \"io\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use the to_string() method instead\")]\n     pub fn detail(&self) -> Option<String> {\n         match self.repr {\n             Repr::Os(code) => Some(sys::os::error_string(code)),\n@@ -147,6 +165,7 @@ impl Error {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Error {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match self.repr {\n@@ -173,7 +192,8 @@ impl fmt::Display for Error {\n     }\n }\n \n-impl StdError for Error {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl error::Error for Error {\n     fn description(&self) -> &str {\n         match self.repr {\n             Repr::Os(..) => \"os error\","}, {"sha": "16298240acfbed7e9968ade38f5f875c7f70e9a2", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=d54bd9f29af67748b7ddf80a5cf285145949ddc2", "patch": "@@ -27,10 +27,10 @@ impl<'a, R: Read + ?Sized> Read for &'a mut R {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         (**self).read(buf)\n     }\n-    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<()> {\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         (**self).read_to_end(buf)\n     }\n-    fn read_to_string(&mut self, buf: &mut String) -> io::Result<()> {\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n         (**self).read_to_string(buf)\n     }\n }\n@@ -53,10 +53,10 @@ impl<'a, S: Seek + ?Sized> Seek for &'a mut S {\n impl<'a, B: BufRead + ?Sized> BufRead for &'a mut B {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n     fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n-    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<()> {\n+    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n         (**self).read_until(byte, buf)\n     }\n-    fn read_line(&mut self, buf: &mut String) -> io::Result<()> {\n+    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n         (**self).read_line(buf)\n     }\n }\n@@ -66,10 +66,10 @@ impl<R: Read + ?Sized> Read for Box<R> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         (**self).read(buf)\n     }\n-    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<()> {\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         (**self).read_to_end(buf)\n     }\n-    fn read_to_string(&mut self, buf: &mut String) -> io::Result<()> {\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n         (**self).read_to_string(buf)\n     }\n }\n@@ -92,10 +92,10 @@ impl<S: Seek + ?Sized> Seek for Box<S> {\n impl<B: BufRead + ?Sized> BufRead for Box<B> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { (**self).fill_buf() }\n     fn consume(&mut self, amt: usize) { (**self).consume(amt) }\n-    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<()> {\n+    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> io::Result<usize> {\n         (**self).read_until(byte, buf)\n     }\n-    fn read_line(&mut self, buf: &mut String) -> io::Result<()> {\n+    fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n         (**self).read_line(buf)\n     }\n }"}, {"sha": "5500f8d6c75e6c7837cf132ddb8cd38ea0e0180e", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 78, "deletions": 58, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d54bd9f29af67748b7ddf80a5cf285145949ddc2", "patch": "@@ -14,13 +14,11 @@\n //! > development. At this time it is still recommended to use the `old_io`\n //! > module while the details of this module shake out.\n \n-#![unstable(feature = \"io\",\n-            reason = \"this new I/O module is still under active development and \\\n-                      APIs are subject to tweaks fairly regularly\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use cmp;\n use unicode::str as core_str;\n-use error::Error as StdError;\n+use error as std_error;\n use fmt;\n use iter::Iterator;\n use marker::Sized;\n@@ -111,8 +109,8 @@ fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>\n // 2. We're passing a raw buffer to the function `f`, and it is expected that\n //    the function only *appends* bytes to the buffer. We'll get undefined\n //    behavior if existing bytes are overwritten to have non-UTF-8 data.\n-fn append_to_string<F>(buf: &mut String, f: F) -> Result<()>\n-    where F: FnOnce(&mut Vec<u8>) -> Result<()>\n+fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n+    where F: FnOnce(&mut Vec<u8>) -> Result<usize>\n {\n     struct Guard<'a> { s: &'a mut Vec<u8>, len: usize }\n     #[unsafe_destructor]\n@@ -126,7 +124,7 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<()>\n         let mut g = Guard { len: buf.len(), s: buf.as_mut_vec() };\n         let ret = f(g.s);\n         if str::from_utf8(&g.s[g.len..]).is_err() {\n-            ret.and_then(|()| {\n+            ret.and_then(|_| {\n                 Err(Error::new(ErrorKind::InvalidInput,\n                                \"stream did not contain valid UTF-8\", None))\n             })\n@@ -137,14 +135,15 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<()>\n     }\n }\n \n-fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<()> {\n+fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n+    let mut read = 0;\n     loop {\n         if buf.capacity() == buf.len() {\n             buf.reserve(DEFAULT_BUF_SIZE);\n         }\n         match with_end_to_cap(buf, |b| r.read(b)) {\n-            Ok(0) => return Ok(()),\n-            Ok(_) => {}\n+            Ok(0) => return Ok(read),\n+            Ok(n) => read += n,\n             Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n             Err(e) => return Err(e),\n         }\n@@ -159,6 +158,7 @@ fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<()> {\n /// Readers are intended to be composable with one another. Many objects\n /// throughout the I/O and related libraries take and provide types which\n /// implement the `Read` trait.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Read {\n     /// Pull some bytes from this source into the specified buffer, returning\n     /// how many bytes were read.\n@@ -187,6 +187,7 @@ pub trait Read {\n     /// If this function encounters any form of I/O or other error, an error\n     /// variant will be returned. If an error is returned then it must be\n     /// guaranteed that no bytes were read.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n \n     /// Read all bytes until EOF in this source, placing them into `buf`.\n@@ -198,7 +199,8 @@ pub trait Read {\n     /// 2. Returns an error which is not of the kind `ErrorKind::Interrupted`.\n     ///\n     /// Until one of these conditions is met the function will continuously\n-    /// invoke `read` to append more data to `buf`.\n+    /// invoke `read` to append more data to `buf`. If successful, this function\n+    /// will return the total number of bytes read.\n     ///\n     /// # Errors\n     ///\n@@ -209,19 +211,24 @@ pub trait Read {\n     /// If any other read error is encountered then this function immediately\n     /// returns. Any bytes which have already been read will be appended to\n     /// `buf`.\n-    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<()> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n         read_to_end(self, buf)\n     }\n \n     /// Read all bytes until EOF in this source, placing them into `buf`.\n     ///\n+    /// If successful, this function returns the number of bytes which were read\n+    /// and appended to `buf`.\n+    ///\n     /// # Errors\n     ///\n     /// If the data in this stream is *not* valid UTF-8 then an error is\n     /// returned and `buf` is unchanged.\n     ///\n     /// See `read_to_end` for other error semantics.\n-    fn read_to_string(&mut self, buf: &mut String) -> Result<()> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we do *not* call `.read_to_end()` here. We are passing\n         // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n         // method to fill it up. An arbitrary implementation could overwrite the\n@@ -233,18 +240,13 @@ pub trait Read {\n         // know is guaranteed to only read data into the end of the buffer.\n         append_to_string(buf, |b| read_to_end(self, b))\n     }\n-}\n \n-/// Extension methods for all instances of `Read`, typically imported through\n-/// `std::io::prelude::*`.\n-#[unstable(feature = \"io\", reason = \"may merge into the Read trait\")]\n-pub trait ReadExt: Read + Sized {\n     /// Create a \"by reference\" adaptor for this instance of `Read`.\n     ///\n     /// The returned adaptor also implements `Read` and will simply borrow this\n     /// current reader.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn by_ref(&mut self) -> &mut Self { self }\n+    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n     /// Transform this `Read` instance to an `Iterator` over its bytes.\n     ///\n@@ -253,7 +255,7 @@ pub trait ReadExt: Read + Sized {\n     /// `Err` otherwise for I/O errors. EOF is mapped to returning `None` from\n     /// this iterator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn bytes(self) -> Bytes<Self> {\n+    fn bytes(self) -> Bytes<Self> where Self: Sized {\n         Bytes { inner: self }\n     }\n \n@@ -270,7 +272,7 @@ pub trait ReadExt: Read + Sized {\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n-    fn chars(self) -> Chars<Self> {\n+    fn chars(self) -> Chars<Self> where Self: Sized {\n         Chars { inner: self }\n     }\n \n@@ -280,7 +282,7 @@ pub trait ReadExt: Read + Sized {\n     /// until EOF is encountered. Afterwards the output is equivalent to the\n     /// output of `next`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn chain<R: Read>(self, next: R) -> Chain<Self, R> {\n+    fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized {\n         Chain { first: self, second: next, done_first: false }\n     }\n \n@@ -291,7 +293,7 @@ pub trait ReadExt: Read + Sized {\n     /// read errors will not count towards the number of bytes read and future\n     /// calls to `read` may succeed.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn take(self, limit: u64) -> Take<Self> {\n+    fn take(self, limit: u64) -> Take<Self> where Self: Sized {\n         Take { inner: self, limit: limit }\n     }\n \n@@ -304,13 +306,11 @@ pub trait ReadExt: Read + Sized {\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n-    fn tee<W: Write>(self, out: W) -> Tee<Self, W> {\n+    fn tee<W: Write>(self, out: W) -> Tee<Self, W> where Self: Sized {\n         Tee { reader: self, writer: out }\n     }\n }\n \n-impl<T: Read> ReadExt for T {}\n-\n /// A trait for objects which are byte-oriented sinks.\n ///\n /// The `write` method will attempt to write some data into the object,\n@@ -322,6 +322,7 @@ impl<T: Read> ReadExt for T {}\n /// Writers are intended to be composable with one another. Many objects\n /// throughout the I/O and related libraries take and provide types which\n /// implement the `Write` trait.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Write {\n     /// Write a buffer into this object, returning how many bytes were written.\n     ///\n@@ -347,6 +348,7 @@ pub trait Write {\n     ///\n     /// It is **not** considered an error if the entire buffer could not be\n     /// written to this writer.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, buf: &[u8]) -> Result<usize>;\n \n     /// Flush this output stream, ensuring that all intermediately buffered\n@@ -356,6 +358,7 @@ pub trait Write {\n     ///\n     /// It is considered an error if not all bytes could be written due to\n     /// I/O errors or EOF being reached.\n+    #[unstable(feature = \"io\", reason = \"waiting for RFC 950\")]\n     fn flush(&mut self) -> Result<()>;\n \n     /// Attempts to write an entire buffer into this write.\n@@ -368,6 +371,7 @@ pub trait Write {\n     /// # Errors\n     ///\n     /// This function will return the first error that `write` returns.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n         while buf.len() > 0 {\n             match self.write(buf) {\n@@ -396,6 +400,7 @@ pub trait Write {\n     /// # Errors\n     ///\n     /// This function will return any I/O error reported while formatting.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> {\n         // Create a shim which translates a Write to a fmt::Write and saves\n         // off I/O errors. instead of discarding them\n@@ -422,18 +427,13 @@ pub trait Write {\n             Err(..) => output.error\n         }\n     }\n-}\n \n-/// Extension methods for all instances of `Write`, typically imported through\n-/// `std::io::prelude::*`.\n-#[unstable(feature = \"io\", reason = \"may merge into the Read trait\")]\n-pub trait WriteExt: Write + Sized {\n     /// Create a \"by reference\" adaptor for this instance of `Write`.\n     ///\n     /// The returned adaptor also implements `Write` and will simply borrow this\n     /// current writer.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn by_ref(&mut self) -> &mut Self { self }\n+    fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n     /// Creates a new writer which will write all data to both this writer and\n     /// another writer.\n@@ -446,19 +446,21 @@ pub trait WriteExt: Write + Sized {\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n-    fn broadcast<W: Write>(self, other: W) -> Broadcast<Self, W> {\n+    fn broadcast<W: Write>(self, other: W) -> Broadcast<Self, W>\n+        where Self: Sized\n+    {\n         Broadcast { first: self, second: other }\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Write> WriteExt for T {}\n-\n /// An object implementing `Seek` internally has some form of cursor which can\n /// be moved within a stream of bytes.\n ///\n /// The stream typically has a fixed size, allowing seeking relative to either\n /// end or the current offset.\n+#[unstable(feature = \"io\", reason = \"the central `seek` method may be split \\\n+                                     into multiple methods instead of taking \\\n+                                     an enum as an argument\")]\n pub trait Seek {\n     /// Seek to an offset, in bytes, in a stream\n     ///\n@@ -479,6 +481,7 @@ pub trait Seek {\n \n /// Enumeration of possible methods to seek within an I/O object.\n #[derive(Copy, PartialEq, Eq, Clone, Debug)]\n+#[unstable(feature = \"io\", reason = \"awaiting the stability of Seek\")]\n pub enum SeekFrom {\n     /// Set the offset to the provided number of bytes.\n     Start(u64),\n@@ -499,7 +502,8 @@ pub enum SeekFrom {\n }\n \n fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n-                                   -> Result<()> {\n+                                   -> Result<usize> {\n+    let mut read = 0;\n     loop {\n         let (done, used) = {\n             let available = match r.fill_buf() {\n@@ -519,8 +523,9 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n             }\n         };\n         r.consume(used);\n+        read += used;\n         if done || used == 0 {\n-            return Ok(());\n+            return Ok(read);\n         }\n     }\n }\n@@ -530,6 +535,7 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n ///\n /// This type extends the `Read` trait with a few methods that are not\n /// possible to reasonably implement with purely a read interface.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BufRead: Read {\n     /// Fills the internal buffer of this object, returning the buffer contents.\n     ///\n@@ -546,10 +552,16 @@ pub trait BufRead: Read {\n     ///\n     /// This function will return an I/O error if the underlying reader was\n     /// read, but returned an error.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fill_buf(&mut self) -> Result<&[u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `read`.\n+    ///\n+    /// This function does not perform any I/O, it simply informs this object\n+    /// that some amount of its buffer, returned from `fill_buf`, has been\n+    /// consumed and should no longer be returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n \n     /// Read all bytes until the delimiter `byte` is reached.\n@@ -560,7 +572,8 @@ pub trait BufRead: Read {\n     /// `buf`.\n     ///\n     /// If this buffered reader is currently at EOF, then this function will not\n-    /// place any more bytes into `buf` and will return `Ok(())`.\n+    /// place any more bytes into `buf` and will return `Ok(n)` where `n` is the\n+    /// number of bytes which were read.\n     ///\n     /// # Errors\n     ///\n@@ -569,7 +582,8 @@ pub trait BufRead: Read {\n     ///\n     /// If an I/O error is encountered then all bytes read so far will be\n     /// present in `buf` and its length will have been adjusted appropriately.\n-    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<()> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n         read_until(self, byte, buf)\n     }\n \n@@ -581,25 +595,23 @@ pub trait BufRead: Read {\n     /// found) will be appended to `buf`.\n     ///\n     /// If this reader is currently at EOF then this function will not modify\n-    /// `buf` and will return `Ok(())`.\n+    /// `buf` and will return `Ok(n)` where `n` is the number of bytes which\n+    /// were read.\n     ///\n     /// # Errors\n     ///\n     /// This function has the same error semantics as `read_until` and will also\n     /// return an error if the read bytes are not valid UTF-8. If an I/O error\n     /// is encountered then `buf` may contain some bytes already read in the\n     /// event that all data read so far was valid UTF-8.\n-    fn read_line(&mut self, buf: &mut String) -> Result<()> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we are not calling the `.read_until` method here, but\n         // rather our hardcoded implementation. For more details as to why, see\n         // the comments in `read_to_end`.\n         append_to_string(buf, |b| read_until(self, b'\\n', b))\n     }\n-}\n \n-/// Extension methods for all instances of `BufRead`, typically imported through\n-/// `std::io::prelude::*`.\n-pub trait BufReadExt: BufRead + Sized {\n     /// Returns an iterator over the contents of this reader split on the byte\n     /// `byte`.\n     ///\n@@ -611,7 +623,7 @@ pub trait BufReadExt: BufRead + Sized {\n     /// yielded an error.\n     #[unstable(feature = \"io\", reason = \"may be renamed to not conflict with \\\n                                          SliceExt::split\")]\n-    fn split(self, byte: u8) -> Split<Self> {\n+    fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n         Split { buf: self, delim: byte }\n     }\n \n@@ -624,22 +636,21 @@ pub trait BufReadExt: BufRead + Sized {\n     /// This function will yield errors whenever `read_string` would have also\n     /// yielded an error.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn lines(self) -> Lines<Self> {\n+    fn lines(self) -> Lines<Self> where Self: Sized {\n         Lines { buf: self }\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: BufRead> BufReadExt for T {}\n-\n /// A `Write` adaptor which will write data to multiple locations.\n ///\n /// For more information, see `WriteExt::broadcast`.\n+#[unstable(feature = \"io\", reason = \"awaiting stability of WriteExt::broadcast\")]\n pub struct Broadcast<T, U> {\n     first: T,\n     second: U,\n }\n \n+#[unstable(feature = \"io\", reason = \"awaiting stability of WriteExt::broadcast\")]\n impl<T: Write, U: Write> Write for Broadcast<T, U> {\n     fn write(&mut self, data: &[u8]) -> Result<usize> {\n         let n = try!(self.first.write(data));\n@@ -732,11 +743,13 @@ impl<T: BufRead> BufRead for Take<T> {\n /// An adaptor which will emit all read data to a specified writer as well.\n ///\n /// For more information see `ReadExt::tee`\n+#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::tee\")]\n pub struct Tee<R, W> {\n     reader: R,\n     writer: W,\n }\n \n+#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::tee\")]\n impl<R: Read, W: Write> Read for Tee<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n         let n = try!(self.reader.read(buf));\n@@ -771,13 +784,15 @@ impl<R: Read> Iterator for Bytes<R> {\n /// A bridge from implementations of `Read` to an `Iterator` of `char`.\n ///\n /// See `ReadExt::chars` for more information.\n+#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n pub struct Chars<R> {\n     inner: R,\n }\n \n /// An enumeration of possible errors that can be generated from the `Chars`\n /// adapter.\n #[derive(PartialEq, Clone, Debug)]\n+#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n pub enum CharsError {\n     /// Variant representing that the underlying stream was read successfully\n     /// but it did not contain valid utf8 data.\n@@ -787,6 +802,7 @@ pub enum CharsError {\n     Other(Error),\n }\n \n+#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n impl<R: Read> Iterator for Chars<R> {\n     type Item = result::Result<char, CharsError>;\n \n@@ -818,21 +834,23 @@ impl<R: Read> Iterator for Chars<R> {\n     }\n }\n \n-impl StdError for CharsError {\n+#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n+impl std_error::Error for CharsError {\n     fn description(&self) -> &str {\n         match *self {\n             CharsError::NotUtf8 => \"invalid utf8 encoding\",\n-            CharsError::Other(ref e) => e.description(),\n+            CharsError::Other(ref e) => std_error::Error::description(e),\n         }\n     }\n-    fn cause(&self) -> Option<&StdError> {\n+    fn cause(&self) -> Option<&std_error::Error> {\n         match *self {\n             CharsError::NotUtf8 => None,\n             CharsError::Other(ref e) => e.cause(),\n         }\n     }\n }\n \n+#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n impl fmt::Display for CharsError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -848,19 +866,21 @@ impl fmt::Display for CharsError {\n /// particular byte.\n ///\n /// See `BufReadExt::split` for more information.\n+#[unstable(feature = \"io\", reason = \"awaiting stability of BufReadExt::split\")]\n pub struct Split<B> {\n     buf: B,\n     delim: u8,\n }\n \n+#[unstable(feature = \"io\", reason = \"awaiting stability of BufReadExt::split\")]\n impl<B: BufRead> Iterator for Split<B> {\n     type Item = Result<Vec<u8>>;\n \n     fn next(&mut self) -> Option<Result<Vec<u8>>> {\n         let mut buf = Vec::new();\n         match self.buf.read_until(self.delim, &mut buf) {\n-            Ok(()) if buf.len() == 0 => None,\n-            Ok(()) => {\n+            Ok(0) => None,\n+            Ok(_n) => {\n                 if buf[buf.len() - 1] == self.delim {\n                     buf.pop();\n                 }\n@@ -887,8 +907,8 @@ impl<B: BufRead> Iterator for Lines<B> {\n     fn next(&mut self) -> Option<Result<String>> {\n         let mut buf = String::new();\n         match self.buf.read_line(&mut buf) {\n-            Ok(()) if buf.len() == 0 => None,\n-            Ok(()) => {\n+            Ok(0) => None,\n+            Ok(_n) => {\n                 if buf.ends_with(\"\\n\") {\n                     buf.pop();\n                 }"}, {"sha": "6bf0ebd1a59e9c8b0a744e7be449f6f83c2d18ef", "filename": "src/libstd/io/prelude.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprelude.rs?ref=d54bd9f29af67748b7ddf80a5cf285145949ddc2", "patch": "@@ -21,7 +21,9 @@\n //! `Write`, `ReadExt`, and `WriteExt`. Structures and functions are not\n //! contained in this module.\n \n-pub use super::{Read, ReadExt, Write, WriteExt, BufRead, BufReadExt};\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub use super::{Read, Write, BufRead};\n pub use fs::PathExt;\n \n // FIXME: pub use as `Seek` when the name isn't in the actual prelude any more"}, {"sha": "c8625a2765d1ace9ebfbc4190de4e8843704b8e5", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=d54bd9f29af67748b7ddf80a5cf285145949ddc2", "patch": "@@ -86,6 +86,7 @@ impl Write for StderrRaw {\n ///\n /// This handle implements the `Read` trait, but beware that concurrent reads\n /// of `Stdin` must be executed with care.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdin {\n     inner: Arc<Mutex<BufReader<StdinRaw>>>,\n }\n@@ -94,6 +95,7 @@ pub struct Stdin {\n ///\n /// This handle implements both the `Read` and `BufRead` traits and is\n /// constructed via the `lock` method on `Stdin`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdinLock<'a> {\n     inner: MutexGuard<'a, BufReader<StdinRaw>>,\n }\n@@ -110,6 +112,7 @@ pub struct StdinLock<'a> {\n ///\n /// To avoid locking and buffering altogether, it is recommended to use the\n /// `stdin_raw` constructor.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n     static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = lazy_init!(stdin_init);\n     return Stdin {\n@@ -136,30 +139,41 @@ impl Stdin {\n     /// The lock is released when the returned lock goes out of scope. The\n     /// returned guard also implements the `Read` and `BufRead` traits for\n     /// accessing the underlying data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdinLock {\n         StdinLock { inner: self.inner.lock().unwrap() }\n     }\n+\n+    /// Locks this handle and reads a line of input into the specified buffer.\n+    ///\n+    /// For detailed semantics of this method, see the documentation on\n+    /// `BufRead::read_line`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn read_line(&mut self, buf: &mut String) -> io::Result<usize> {\n+        self.lock().read_line(buf)\n+    }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for Stdin {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.lock().read(buf)\n     }\n-\n-    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<()> {\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         self.lock().read_to_end(buf)\n     }\n-\n-    fn read_to_string(&mut self, buf: &mut String) -> io::Result<()> {\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n         self.lock().read_to_string(buf)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for StdinLock<'a> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> BufRead for StdinLock<'a> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n     fn consume(&mut self, n: usize) { self.inner.consume(n) }\n@@ -186,6 +200,7 @@ const OUT_MAX: usize = ::usize::MAX;\n /// Each handle shares a global buffer of data to be written to the standard\n /// output stream. Access is also synchronized via a lock and explicit control\n /// over locking is available via the `lock` method.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n     //        stdout (tty or not). Note that if this is not line buffered it\n@@ -197,6 +212,7 @@ pub struct Stdout {\n ///\n /// This handle implements the `Write` trait and is constructed via the `lock`\n /// method on `Stdout`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdoutLock<'a> {\n     inner: MutexGuard<'a, LineWriter<StdoutRaw>>,\n }\n@@ -211,6 +227,7 @@ pub struct StdoutLock<'a> {\n ///\n /// To avoid locking and buffering altogether, it is recommended to use the\n /// `stdout_raw` constructor.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n     static INSTANCE: Lazy<Mutex<LineWriter<StdoutRaw>>> = lazy_init!(stdout_init);\n     return Stdout {\n@@ -228,11 +245,13 @@ impl Stdout {\n     ///\n     /// The lock is released when the returned lock goes out of scope. The\n     /// returned guard also implements the `Write` trait for writing data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdoutLock {\n         StdoutLock { inner: self.inner.lock().unwrap() }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Stdout {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.lock().write(buf)\n@@ -247,6 +266,7 @@ impl Write for Stdout {\n         self.lock().write_fmt(fmt)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for StdoutLock<'a> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.write(&buf[..cmp::min(buf.len(), OUT_MAX)])\n@@ -257,6 +277,7 @@ impl<'a> Write for StdoutLock<'a> {\n /// A handle to the standard error stream of a process.\n ///\n /// For more information, see `stderr`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n     inner: Arc<Mutex<StderrRaw>>,\n }\n@@ -265,6 +286,7 @@ pub struct Stderr {\n ///\n /// This handle implements the `Write` trait and is constructed via the `lock`\n /// method on `Stderr`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StderrLock<'a> {\n     inner: MutexGuard<'a, StderrRaw>,\n }\n@@ -278,6 +300,7 @@ pub struct StderrLock<'a> {\n ///\n /// To avoid locking altogether, it is recommended to use the `stderr_raw`\n /// constructor.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stderr() -> Stderr {\n     static INSTANCE: Lazy<Mutex<StderrRaw>> = lazy_init!(stderr_init);\n     return Stderr {\n@@ -295,11 +318,13 @@ impl Stderr {\n     ///\n     /// The lock is released when the returned lock goes out of scope. The\n     /// returned guard also implements the `Write` trait for writing data.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StderrLock {\n         StderrLock { inner: self.inner.lock().unwrap() }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Stderr {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.lock().write(buf)\n@@ -314,6 +339,7 @@ impl Write for Stderr {\n         self.lock().write_fmt(fmt)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for StderrLock<'a> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.write(&buf[..cmp::min(buf.len(), OUT_MAX)])"}, {"sha": "9d438978f4211e67f5dd787689220f9e7ffea5d4", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=d54bd9f29af67748b7ddf80a5cf285145949ddc2", "patch": "@@ -242,6 +242,9 @@\n #![deny(unused_must_use)]\n #![allow(deprecated)] // seriously this is all deprecated\n #![allow(unused_imports)]\n+#![deprecated(since = \"1.0.0\",\n+              reasons = \"APIs have been replaced with new I/O modules such as \\\n+                         std::{io, fs, net, process}\")]\n \n pub use self::SeekStyle::*;\n pub use self::FileMode::*;"}, {"sha": "dcf7a37b7a650701c50c8e296630992f11260731", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=d54bd9f29af67748b7ddf80a5cf285145949ddc2", "patch": "@@ -148,7 +148,6 @@ use cell::UnsafeCell;\n use fmt;\n use io;\n use marker::PhantomData;\n-use old_io::stdio;\n use rt::{self, unwind};\n use sync::{Mutex, Condvar, Arc};\n use thunk::Thunk;\n@@ -165,10 +164,6 @@ pub struct Builder {\n     name: Option<String>,\n     // The size of the stack for the spawned thread\n     stack_size: Option<usize>,\n-    // Thread-local stdout\n-    stdout: Option<Box<Writer + Send + 'static>>,\n-    // Thread-local stderr\n-    stderr: Option<Box<Writer + Send + 'static>>,\n }\n \n impl Builder {\n@@ -179,8 +174,6 @@ impl Builder {\n         Builder {\n             name: None,\n             stack_size: None,\n-            stdout: None,\n-            stderr: None,\n         }\n     }\n \n@@ -202,16 +195,22 @@ impl Builder {\n     /// Redirect thread-local stdout.\n     #[unstable(feature = \"std_misc\",\n                reason = \"Will likely go away after proc removal\")]\n-    pub fn stdout(mut self, stdout: Box<Writer + Send + 'static>) -> Builder {\n-        self.stdout = Some(stdout);\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"the old I/O module is deprecated and this function \\\n+                           will be removed with no replacement\")]\n+    #[allow(deprecated)]\n+    pub fn stdout(self, _stdout: Box<Writer + Send + 'static>) -> Builder {\n         self\n     }\n \n     /// Redirect thread-local stderr.\n     #[unstable(feature = \"std_misc\",\n                reason = \"Will likely go away after proc removal\")]\n-    pub fn stderr(mut self, stderr: Box<Writer + Send + 'static>) -> Builder {\n-        self.stderr = Some(stderr);\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"the old I/O module is deprecated and this function \\\n+                           will be removed with no replacement\")]\n+    #[allow(deprecated)]\n+    pub fn stderr(self, _stderr: Box<Writer + Send + 'static>) -> Builder {\n         self\n     }\n \n@@ -259,7 +258,7 @@ impl Builder {\n     }\n \n     fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> io::Result<JoinInner<T>> {\n-        let Builder { name, stack_size, stdout, stderr } = self;\n+        let Builder { name, stack_size } = self;\n \n         let stack_size = stack_size.unwrap_or(rt::min_stack());\n \n@@ -290,16 +289,6 @@ impl Builder {\n             }\n \n             let mut output = None;\n-            let f: Thunk<(), T> = if stdout.is_some() || stderr.is_some() {\n-                Thunk::new(move || {\n-                    let _ = stdout.map(stdio::set_stdout);\n-                    let _ = stderr.map(stdio::set_stderr);\n-                    f.invoke(())\n-                })\n-            } else {\n-                f\n-            };\n-\n             let try_result = {\n                 let ptr = &mut output;\n "}]}