{"sha": "0e6747fb2538d394ede02210fff4e77afb5aec2e", "node_id": "C_kwDOAAsO6NoAKDBlNjc0N2ZiMjUzOGQzOTRlZGUwMjIxMGZmZjRlNzdhZmI1YWVjMmU", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-09-05T23:36:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-05T23:36:03Z"}, "message": "Rollup merge of #99291 - est31:let_else_tests, r=joshtriplett\n\nAdd let else drop order tests\n\nAdd a systematic matrix based test that checks temporary drop order in various settings, `let-else-drop-order.rs`, as requested [here](https://github.com/rust-lang/rust/pull/93628#issuecomment-1055738523).\n\nThe drop order of let and let else is supposed to be the and in order to ensure this, the test checks that this holds for a number of cases.\n\nThe test also ensures that we drop the temporaries of the condition before executing the else block.\n\ncc #87335 tracking issue for `let else`", "tree": {"sha": "6017fe22d2a5b9c8a594c3c65717da2b71bd9425", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6017fe22d2a5b9c8a594c3c65717da2b71bd9425"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e6747fb2538d394ede02210fff4e77afb5aec2e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjFofjCRBK7hj4Ov3rIwAAGxgIADEV60kHeSdEiOyzy5s3QLX6\nMdXump6ixHsK04bh8B6Wko9UbMB0gfNGJJu/pcIA0B6wtr8IWOvnkU6qy2mda9RL\nGdjRkqGLNvk8mP3wUUmqxyeG6oTlkGm9QZ9T24xokx7YzdGfBiH5u9vRM23JYhT1\nehvKmVmPnZoamWnNCxBJB/AHGfdpVSVLacQEF+6zOfNWw/ah3/rrajomPPlL6Jhx\nhVqEQa3AWFtKVlu6/Q1xWVlWIbfzF365ErNaqnKuTwsCWYEnk04Tf44wlGrnZOiB\nKM+nYOkD6dEfXoYuBVJBlTKWcLd2UJFV/YZxbbfN8jxzrQf+8mnrKnpEEVEKmNE=\n=GDH7\n-----END PGP SIGNATURE-----\n", "payload": "tree 6017fe22d2a5b9c8a594c3c65717da2b71bd9425\nparent b44197abb0b3ffe4908892e1e08ab1cd721ff3b9\nparent 2d8460ef43d902f34ba2133fe38f66ee8d2fdafc\nauthor Yuki Okushi <jtitor@2k36.org> 1662420963 +0900\ncommitter GitHub <noreply@github.com> 1662420963 +0900\n\nRollup merge of #99291 - est31:let_else_tests, r=joshtriplett\n\nAdd let else drop order tests\n\nAdd a systematic matrix based test that checks temporary drop order in various settings, `let-else-drop-order.rs`, as requested [here](https://github.com/rust-lang/rust/pull/93628#issuecomment-1055738523).\n\nThe drop order of let and let else is supposed to be the and in order to ensure this, the test checks that this holds for a number of cases.\n\nThe test also ensures that we drop the temporaries of the condition before executing the else block.\n\ncc #87335 tracking issue for `let else`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e6747fb2538d394ede02210fff4e77afb5aec2e", "html_url": "https://github.com/rust-lang/rust/commit/0e6747fb2538d394ede02210fff4e77afb5aec2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e6747fb2538d394ede02210fff4e77afb5aec2e/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9", "html_url": "https://github.com/rust-lang/rust/commit/b44197abb0b3ffe4908892e1e08ab1cd721ff3b9"}, {"sha": "2d8460ef43d902f34ba2133fe38f66ee8d2fdafc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc", "html_url": "https://github.com/rust-lang/rust/commit/2d8460ef43d902f34ba2133fe38f66ee8d2fdafc"}], "stats": {"total": 321, "additions": 321, "deletions": 0}, "files": [{"sha": "0054f3d4182ec12a32ebf6d19f0ea43ea454754f", "filename": "src/test/ui/let-else/let-else-drop-order.rs", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/0e6747fb2538d394ede02210fff4e77afb5aec2e/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e6747fb2538d394ede02210fff4e77afb5aec2e/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.rs?ref=0e6747fb2538d394ede02210fff4e77afb5aec2e", "patch": "@@ -0,0 +1,270 @@\n+// run-pass\n+// edition:2021\n+// check-run-results\n+//\n+// Drop order tests for let else\n+//\n+// Mostly this ensures two things:\n+// 1. That let and let else temporary drop order is the same.\n+//    This is a specific design request: https://github.com/rust-lang/rust/pull/93628#issuecomment-1047140316\n+// 2. That the else block truly only runs after the\n+//    temporaries have dropped.\n+//\n+// We also print some nice tables for an overview by humans.\n+// Changes in those tables are considered breakages, but the\n+// important properties 1 and 2 are also enforced by the code.\n+// This is important as it's easy to update the stdout file\n+// with a --bless and miss the impact of that change.\n+\n+#![feature(let_else)]\n+#![allow(irrefutable_let_patterns)]\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+#[derive(Clone)]\n+struct DropAccountant(Rc<RefCell<Vec<Vec<String>>>>);\n+\n+impl DropAccountant {\n+    fn new() -> Self {\n+        Self(Default::default())\n+    }\n+    fn build_droppy(&self, v: u32) -> Droppy<u32> {\n+        Droppy(self.clone(), v)\n+    }\n+    fn build_droppy_enum_none(&self, _v: u32) -> ((), DroppyEnum<u32>) {\n+        ((), DroppyEnum::None(self.clone()))\n+    }\n+    fn new_list(&self, s: impl ToString) {\n+        self.0.borrow_mut().push(vec![s.to_string()]);\n+    }\n+    fn push(&self, s: impl ToString) {\n+        let s = s.to_string();\n+        let mut accounts = self.0.borrow_mut();\n+        accounts.last_mut().unwrap().push(s);\n+    }\n+    fn print_table(&self) {\n+        println!();\n+\n+        let accounts = self.0.borrow();\n+        let before_last = &accounts[accounts.len() - 2];\n+        let last = &accounts[accounts.len() - 1];\n+        let before_last = get_comma_list(before_last);\n+        let last = get_comma_list(last);\n+        const LINES: &[&str] = &[\n+            \"vanilla\",\n+            \"&\",\n+            \"&mut\",\n+            \"move\",\n+            \"fn(this)\",\n+            \"tuple\",\n+            \"array\",\n+            \"ref &\",\n+            \"ref mut &mut\",\n+        ];\n+        let max_len = LINES.iter().map(|v| v.len()).max().unwrap();\n+        let max_len_before = before_last.iter().map(|v| v.len()).max().unwrap();\n+        let max_len_last = last.iter().map(|v| v.len()).max().unwrap();\n+\n+        println!(\n+            \"| {: <max_len$} | {: <max_len_before$} | {: <max_len_last$} |\",\n+            \"construct\", before_last[0], last[0]\n+        );\n+        println!(\"| {:-<max_len$} | {:-<max_len_before$} | {:-<max_len_last$} |\", \"\", \"\", \"\");\n+\n+        for ((l, l_before), l_last) in\n+            LINES.iter().zip(before_last[1..].iter()).zip(last[1..].iter())\n+        {\n+            println!(\n+                \"| {: <max_len$} | {: <max_len_before$} | {: <max_len_last$} |\",\n+                l, l_before, l_last,\n+            );\n+        }\n+    }\n+    #[track_caller]\n+    fn assert_all_equal_to(&self, st: &str) {\n+        let accounts = self.0.borrow();\n+        let last = &accounts[accounts.len() - 1];\n+        let last = get_comma_list(last);\n+        for line in last[1..].iter() {\n+            assert_eq!(line.trim(), st.trim());\n+        }\n+    }\n+    #[track_caller]\n+    fn assert_equality_last_two_lists(&self) {\n+        let accounts = self.0.borrow();\n+        let last = &accounts[accounts.len() - 1];\n+        let before_last = &accounts[accounts.len() - 2];\n+        for (l, b) in last[1..].iter().zip(before_last[1..].iter()) {\n+            if !(l == b || l == \"n/a\" || b == \"n/a\") {\n+                panic!(\"not equal: '{last:?}' != '{before_last:?}'\");\n+            }\n+        }\n+    }\n+}\n+\n+fn get_comma_list(sl: &[String]) -> Vec<String> {\n+    std::iter::once(sl[0].clone())\n+        .chain(sl[1..].chunks(2).map(|c| c.join(\",\")))\n+        .collect::<Vec<String>>()\n+}\n+\n+struct Droppy<T>(DropAccountant, T);\n+\n+impl<T> Drop for Droppy<T> {\n+    fn drop(&mut self) {\n+        self.0.push(\"drop\");\n+    }\n+}\n+\n+#[allow(dead_code)]\n+enum DroppyEnum<T> {\n+    Some(DropAccountant, T),\n+    None(DropAccountant),\n+}\n+\n+impl<T> Drop for DroppyEnum<T> {\n+    fn drop(&mut self) {\n+        match self {\n+            DroppyEnum::Some(acc, _inner) => acc,\n+            DroppyEnum::None(acc) => acc,\n+        }\n+        .push(\"drop\");\n+    }\n+}\n+\n+macro_rules! nestings_with {\n+    ($construct:ident, $binding:pat, $exp:expr) => {\n+        // vanilla:\n+        $construct!($binding, $exp.1);\n+\n+        // &:\n+        $construct!(&$binding, &$exp.1);\n+\n+        // &mut:\n+        $construct!(&mut $binding, &mut ($exp.1));\n+\n+        {\n+            // move:\n+            let w = $exp;\n+            $construct!(\n+                $binding,\n+                {\n+                    let w = w;\n+                    w\n+                }\n+                .1\n+            );\n+        }\n+\n+        // fn(this):\n+        $construct!($binding, std::convert::identity($exp).1);\n+    };\n+}\n+\n+macro_rules! nestings {\n+    ($construct:ident, $binding:pat, $exp:expr) => {\n+        nestings_with!($construct, $binding, $exp);\n+\n+        // tuple:\n+        $construct!(($binding, 77), ($exp.1, 77));\n+\n+        // array:\n+        $construct!([$binding], [$exp.1]);\n+    };\n+}\n+\n+macro_rules! let_else {\n+    ($acc:expr, $v:expr, $binding:pat, $build:ident) => {\n+        let acc = $acc;\n+        let v = $v;\n+\n+        macro_rules! let_else_construct {\n+            ($arg:pat, $exp:expr) => {\n+                loop {\n+                    let $arg = $exp else {\n+                        acc.push(\"else\");\n+                        break;\n+                    };\n+                    acc.push(\"body\");\n+                    break;\n+                }\n+            };\n+        }\n+        nestings!(let_else_construct, $binding, acc.$build(v));\n+        // ref &:\n+        let_else_construct!($binding, &acc.$build(v).1);\n+\n+        // ref mut &mut:\n+        let_else_construct!($binding, &mut acc.$build(v).1);\n+    };\n+}\n+\n+macro_rules! let_ {\n+    ($acc:expr, $binding:tt) => {\n+        let acc = $acc;\n+\n+        macro_rules! let_construct {\n+            ($arg:pat, $exp:expr) => {{\n+                let $arg = $exp;\n+                acc.push(\"body\");\n+            }};\n+        }\n+        let v = 0;\n+        {\n+            nestings_with!(let_construct, $binding, acc.build_droppy(v));\n+        }\n+        acc.push(\"n/a\");\n+        acc.push(\"n/a\");\n+        acc.push(\"n/a\");\n+        acc.push(\"n/a\");\n+\n+        // ref &:\n+        let_construct!($binding, &acc.build_droppy(v).1);\n+\n+        // ref mut &mut:\n+        let_construct!($binding, &mut acc.build_droppy(v).1);\n+    };\n+}\n+\n+fn main() {\n+    let acc = DropAccountant::new();\n+\n+    println!(\" --- matching cases ---\");\n+\n+    // Ensure that let and let else have the same behaviour\n+    acc.new_list(\"let _\");\n+    let_!(&acc, _);\n+    acc.new_list(\"let else _\");\n+    let_else!(&acc, 0, _, build_droppy);\n+    acc.assert_equality_last_two_lists();\n+    acc.print_table();\n+\n+    // Ensure that let and let else have the same behaviour\n+    acc.new_list(\"let _v\");\n+    let_!(&acc, _v);\n+    acc.new_list(\"let else _v\");\n+    let_else!(&acc, 0, _v, build_droppy);\n+    acc.assert_equality_last_two_lists();\n+    acc.print_table();\n+\n+    println!();\n+\n+    println!(\" --- mismatching cases ---\");\n+\n+    acc.new_list(\"let else _ mismatch\");\n+    let_else!(&acc, 1, DroppyEnum::Some(_, _), build_droppy_enum_none);\n+    acc.new_list(\"let else _v mismatch\");\n+    let_else!(&acc, 1, DroppyEnum::Some(_, _v), build_droppy_enum_none);\n+    acc.print_table();\n+    // This ensures that we always drop before visiting the else case\n+    acc.assert_all_equal_to(\"drop,else\");\n+\n+    acc.new_list(\"let else 0 mismatch\");\n+    let_else!(&acc, 1, 0, build_droppy);\n+    acc.new_list(\"let else 0 mismatch\");\n+    let_else!(&acc, 1, 0, build_droppy);\n+    acc.print_table();\n+    // This ensures that we always drop before visiting the else case\n+    acc.assert_all_equal_to(\"drop,else\");\n+}"}, {"sha": "01cf2f73e17c9e466508fa538169d64c510dd6c5", "filename": "src/test/ui/let-else/let-else-drop-order.run.stdout", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0e6747fb2538d394ede02210fff4e77afb5aec2e/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0e6747fb2538d394ede02210fff4e77afb5aec2e/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-drop-order.run.stdout?ref=0e6747fb2538d394ede02210fff4e77afb5aec2e", "patch": "@@ -0,0 +1,51 @@\n+ --- matching cases ---\n+\n+| construct    | let _     | let else _ |\n+| ------------ | --------- | ---------- |\n+| vanilla      | drop,body | drop,body  |\n+| &            | body,drop | body,drop  |\n+| &mut         | body,drop | body,drop  |\n+| move         | drop,body | drop,body  |\n+| fn(this)     | drop,body | drop,body  |\n+| tuple        | n/a,n/a   | drop,body  |\n+| array        | n/a,n/a   | drop,body  |\n+| ref &        | body,drop | body,drop  |\n+| ref mut &mut | body,drop | body,drop  |\n+\n+| construct    | let _v    | let else _v |\n+| ------------ | --------- | ----------- |\n+| vanilla      | drop,body | drop,body   |\n+| &            | body,drop | body,drop   |\n+| &mut         | body,drop | body,drop   |\n+| move         | drop,body | drop,body   |\n+| fn(this)     | drop,body | drop,body   |\n+| tuple        | n/a,n/a   | drop,body   |\n+| array        | n/a,n/a   | drop,body   |\n+| ref &        | body,drop | body,drop   |\n+| ref mut &mut | body,drop | body,drop   |\n+\n+ --- mismatching cases ---\n+\n+| construct    | let else _ mismatch | let else _v mismatch |\n+| ------------ | ------------------- | -------------------- |\n+| vanilla      | drop,else           | drop,else            |\n+| &            | drop,else           | drop,else            |\n+| &mut         | drop,else           | drop,else            |\n+| move         | drop,else           | drop,else            |\n+| fn(this)     | drop,else           | drop,else            |\n+| tuple        | drop,else           | drop,else            |\n+| array        | drop,else           | drop,else            |\n+| ref &        | drop,else           | drop,else            |\n+| ref mut &mut | drop,else           | drop,else            |\n+\n+| construct    | let else 0 mismatch | let else 0 mismatch |\n+| ------------ | ------------------- | ------------------- |\n+| vanilla      | drop,else           | drop,else           |\n+| &            | drop,else           | drop,else           |\n+| &mut         | drop,else           | drop,else           |\n+| move         | drop,else           | drop,else           |\n+| fn(this)     | drop,else           | drop,else           |\n+| tuple        | drop,else           | drop,else           |\n+| array        | drop,else           | drop,else           |\n+| ref &        | drop,else           | drop,else           |\n+| ref mut &mut | drop,else           | drop,else           |"}]}