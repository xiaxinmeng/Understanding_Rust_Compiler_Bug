{"sha": "f590a44ce61888c78b9044817d8b798db5cd2ffd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1OTBhNDRjZTYxODg4Yzc4YjkwNDQ4MTdkOGI3OThkYjVjZDJmZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-27T05:12:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-27T05:12:07Z"}, "message": "Auto merge of #42922 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 5 pull requests\n\n- Successful merges: #42519, #42871, #42874, #42905, #42917\n- Failed merges:", "tree": {"sha": "d1841cfd3dffb71e2c9de0469a4575d4e3ab6834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1841cfd3dffb71e2c9de0469a4575d4e3ab6834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f590a44ce61888c78b9044817d8b798db5cd2ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f590a44ce61888c78b9044817d8b798db5cd2ffd", "html_url": "https://github.com/rust-lang/rust/commit/f590a44ce61888c78b9044817d8b798db5cd2ffd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f590a44ce61888c78b9044817d8b798db5cd2ffd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77931c2a04fbb41f3cd92435aa5294222bb5db7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/77931c2a04fbb41f3cd92435aa5294222bb5db7f", "html_url": "https://github.com/rust-lang/rust/commit/77931c2a04fbb41f3cd92435aa5294222bb5db7f"}, {"sha": "d7a5508069000403e303977a474f5bc775b7fc98", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a5508069000403e303977a474f5bc775b7fc98", "html_url": "https://github.com/rust-lang/rust/commit/d7a5508069000403e303977a474f5bc775b7fc98"}], "stats": {"total": 472, "additions": 336, "deletions": 136}, "files": [{"sha": "873d39ec9e9fb0fb6cd7d16a198d27390b146958", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -2170,12 +2170,12 @@ impl<'a> LoweringContext<'a> {\n                 //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n                 //       mut iter => {\n                 //         [opt_ident]: loop {\n-                //           let mut _next;\n+                //           let mut __next;\n                 //           match ::std::iter::Iterator::next(&mut iter) {\n-                //             ::std::option::Option::Some(val) => _next = val,\n+                //             ::std::option::Option::Some(val) => __next = val,\n                 //             ::std::option::Option::None => break\n                 //           };\n-                //           let <pat> = _next;\n+                //           let <pat> = __next;\n                 //           StmtExpr(<body>);\n                 //         }\n                 //       }\n@@ -2188,7 +2188,7 @@ impl<'a> LoweringContext<'a> {\n \n                 let iter = self.str_to_ident(\"iter\");\n \n-                let next_ident = self.str_to_ident(\"_next\");\n+                let next_ident = self.str_to_ident(\"__next\");\n                 let next_pat = self.pat_ident_binding_mode(e.span,\n                                                            next_ident,\n                                                            hir::BindByValue(hir::MutMutable));\n@@ -2237,13 +2237,13 @@ impl<'a> LoweringContext<'a> {\n \n                 let next_expr = P(self.expr_ident(e.span, next_ident, next_pat.id));\n \n-                // `let mut _next`\n+                // `let mut __next`\n                 let next_let = self.stmt_let_pat(e.span,\n                     None,\n                     next_pat,\n                     hir::LocalSource::ForLoopDesugar);\n \n-                // `let <pat> = _next`\n+                // `let <pat> = __next`\n                 let pat = self.lower_pat(pat);\n                 let pat_let = self.stmt_let_pat(e.span,\n                     Some(next_expr),"}, {"sha": "466d163854f1d81bd0a7d4fcb17199fbf979871a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -291,16 +291,13 @@ impl LintStore {\n         self.by_name.insert(name.into(), Removed(reason.into()));\n     }\n \n-    #[allow(unused_variables)]\n-    fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n-                 -> Result<LintId, FindLintError>\n-    {\n+    fn find_lint(&self, lint_name: &str) -> Result<LintId, FindLintError> {\n         match self.by_name.get(lint_name) {\n             Some(&Id(lint_id)) => Ok(lint_id),\n             Some(&Renamed(_, lint_id)) => {\n                 Ok(lint_id)\n             },\n-            Some(&Removed(ref reason)) => {\n+            Some(&Removed(_)) => {\n                 Err(FindLintError::Removed)\n             },\n             None => Err(FindLintError::NotFound)\n@@ -313,7 +310,7 @@ impl LintStore {\n                                     &lint_name[..], level);\n \n             let lint_flag_val = Symbol::intern(&lint_name);\n-            match self.find_lint(&lint_name[..], sess, None) {\n+            match self.find_lint(&lint_name[..]) {\n                 Ok(lint_id) => self.levels.set(lint_id, (level, CommandLine(lint_flag_val))),\n                 Err(FindLintError::Removed) => { }\n                 Err(_) => {\n@@ -724,21 +721,22 @@ pub trait LintContext<'tcx>: Sized {\n         let mut pushed = 0;\n \n         for result in gather_attrs(attrs) {\n-            let v = match result {\n+            let (is_group, lint_level_spans) = match result {\n                 Err(span) => {\n                     span_err!(self.sess(), span, E0452,\n                               \"malformed lint attribute\");\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints().find_lint(&lint_name.as_str(), &self.sess(), Some(span)) {\n-                        Ok(lint_id) => vec![(lint_id, level, span)],\n+                    match self.lints().find_lint(&lint_name.as_str()) {\n+                        Ok(lint_id) => (false, vec![(lint_id, level, span)]),\n                         Err(FindLintError::NotFound) => {\n                             match self.lints().lint_groups.get(&*lint_name.as_str()) {\n-                                Some(&(ref v, _)) => v.iter()\n+                                Some(&(ref v, _)) => (true,\n+                                                      v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n-                                                      .collect(),\n+                                                      .collect()),\n                                 None => {\n                                     // The lint or lint group doesn't exist.\n                                     // This is an error, but it was handled\n@@ -754,14 +752,18 @@ pub trait LintContext<'tcx>: Sized {\n \n             let lint_attr_name = result.expect(\"lint attribute should be well-formed\").0;\n \n-            for (lint_id, level, span) in v {\n+            for (lint_id, level, span) in lint_level_spans {\n                 let (now, now_source) = self.lint_sess().get_source(lint_id);\n                 if now == Forbid && level != Forbid {\n-                    let lint_name = lint_id.to_string();\n+                    let forbidden_lint_name = match now_source {\n+                        LintSource::Default => lint_id.to_string(),\n+                        LintSource::Node(name, _) => name.to_string(),\n+                        LintSource::CommandLine(name) => name.to_string(),\n+                    };\n                     let mut diag_builder = struct_span_err!(self.sess(), span, E0453,\n                                                             \"{}({}) overruled by outer forbid({})\",\n-                                                            level.as_str(), lint_name,\n-                                                            lint_name);\n+                                                            level.as_str(), lint_attr_name,\n+                                                            forbidden_lint_name);\n                     diag_builder.span_label(span, \"overruled by previous forbid\");\n                     match now_source {\n                         LintSource::Default => &mut diag_builder,\n@@ -772,7 +774,10 @@ pub trait LintContext<'tcx>: Sized {\n                         LintSource::CommandLine(_) => {\n                             diag_builder.note(\"`forbid` lint level was set on command line\")\n                         }\n-                    }.emit()\n+                    }.emit();\n+                    if is_group { // don't set a separate error for every lint in the group\n+                        break;\n+                    }\n                 } else if now != level {\n                     let cx = self.lint_sess_mut();\n                     cx.stack.push((lint_id, (now, now_source)));\n@@ -1420,7 +1425,7 @@ impl Decodable for LintId {\n     fn decode<D: Decoder>(d: &mut D) -> Result<LintId, D::Error> {\n         let s = d.read_str()?;\n         ty::tls::with(|tcx| {\n-            match tcx.sess.lint_store.borrow().find_lint(&s, tcx.sess, None) {\n+            match tcx.sess.lint_store.borrow().find_lint(&s) {\n                 Ok(id) => Ok(id),\n                 Err(_) => panic!(\"invalid lint-id `{}`\", s),\n             }"}, {"sha": "ea08f1f624e679ca0bfdd6adc84a4e95e3a2d29f", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 42, "deletions": 63, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -40,9 +40,11 @@\n \n use super::{Diverges, FnCtxt};\n \n-use lint;\n+use errors::DiagnosticBuilder;\n use hir::def_id::DefId;\n+use lint;\n use rustc::hir;\n+use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::cast::{CastKind, CastTy};\n@@ -112,6 +114,18 @@ enum CastError {\n     NonScalar,\n }\n \n+fn make_invalid_casting_error<'a, 'gcx, 'tcx>(sess: &'a Session,\n+                                              span: Span,\n+                                              expr_ty: Ty<'tcx>,\n+                                              cast_ty: Ty<'tcx>,\n+                                              fcx: &FnCtxt<'a, 'gcx, 'tcx>)\n+                                              -> DiagnosticBuilder<'a> {\n+    type_error_struct!(sess, span, expr_ty, E0606,\n+                       \"casting `{}` as `{}` is invalid\",\n+                       fcx.ty_to_string(expr_ty),\n+                       fcx.ty_to_string(cast_ty))\n+}\n+\n impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     pub fn new(fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                expr: &'tcx hir::Expr,\n@@ -146,14 +160,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         match e {\n             CastError::NeedDeref => {\n                 let error_span = self.span;\n+                let mut err = make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty,\n+                                                         self.cast_ty, fcx);\n                 let cast_ty = fcx.ty_to_string(self.cast_ty);\n-                let mut err = fcx.type_error_struct(error_span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   cast_ty)\n-                                       },\n-                                       self.expr_ty);\n                 err.span_label(error_span,\n                                format!(\"cannot cast `{}` as `{}`\",\n                                         fcx.ty_to_string(self.expr_ty),\n@@ -166,13 +175,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             }\n             CastError::NeedViaThinPtr |\n             CastError::NeedViaPtr => {\n-                let mut err = fcx.type_error_struct(self.span,\n-                                                    |actual| {\n-                                                        format!(\"casting `{}` as `{}` is invalid\",\n-                                                                actual,\n-                                                                fcx.ty_to_string(self.cast_ty))\n-                                                    },\n-                                                    self.expr_ty);\n+                let mut err = make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty,\n+                                                         self.cast_ty, fcx);\n                 if self.cast_ty.is_uint() {\n                     err.help(&format!(\"cast through {} first\",\n                                       match e {\n@@ -184,72 +188,47 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 err.emit();\n             }\n             CastError::NeedViaInt => {\n-                fcx.type_error_struct(self.span,\n-                                      |actual| {\n-                                          format!(\"casting `{}` as `{}` is invalid\",\n-                                                  actual,\n-                                                  fcx.ty_to_string(self.cast_ty))\n-                                      },\n-                                      self.expr_ty)\n+                make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty, self.cast_ty, fcx)\n                    .help(&format!(\"cast through {} first\",\n                                   match e {\n                                       CastError::NeedViaInt => \"an integer\",\n                                       _ => bug!(),\n                                   }))\n                    .emit();\n             }\n+            CastError::IllegalCast => {\n+                make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty, self.cast_ty, fcx)\n+                    .emit();\n+            }\n+            CastError::DifferingKinds => {\n+                make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty, self.cast_ty, fcx)\n+                    .note(\"vtable kinds may not match\")\n+                    .emit();\n+            }\n             CastError::CastToBool => {\n                 struct_span_err!(fcx.tcx.sess, self.span, E0054, \"cannot cast as `bool`\")\n                     .span_label(self.span, \"unsupported cast\")\n                     .help(\"compare with zero instead\")\n                     .emit();\n             }\n             CastError::CastToChar => {\n-                fcx.type_error_message(self.span,\n-                                       |actual| {\n-                                           format!(\"only `u8` can be cast as `char`, not `{}`\",\n-                                                   actual)\n-                                       },\n-                                       self.expr_ty);\n+                type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0604,\n+                                 \"only `u8` can be cast as `char`, not `{}`\", self.expr_ty).emit();\n             }\n             CastError::NonScalar => {\n-                fcx.type_error_message(self.span,\n-                                       |actual| {\n-                                           format!(\"non-scalar cast: `{}` as `{}`\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty);\n-            }\n-            CastError::IllegalCast => {\n-                fcx.type_error_message(self.span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty);\n+                type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0605,\n+                                 \"non-primitive cast: `{}` as `{}`\",\n+                                 self.expr_ty,\n+                                 fcx.ty_to_string(self.cast_ty))\n+                                .note(\"an `as` expression can only be used to convert between \\\n+                                       primitive types. Consider using the `From` trait\")\n+                                .emit();\n             }\n             CastError::SizedUnsizedCast => {\n-                fcx.type_error_message(self.span,\n-                                       |actual| {\n-                                           format!(\"cannot cast thin pointer `{}` to fat pointer \\\n-                                                    `{}`\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty)\n-            }\n-            CastError::DifferingKinds => {\n-                fcx.type_error_struct(self.span,\n-                                       |actual| {\n-                                           format!(\"casting `{}` as `{}` is invalid\",\n-                                                   actual,\n-                                                   fcx.ty_to_string(self.cast_ty))\n-                                       },\n-                                       self.expr_ty)\n-                    .note(\"vtable kinds may not match\")\n-                    .emit();\n+                type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0607,\n+                                 \"cannot cast thin pointer `{}` to fat pointer `{}`\",\n+                                 self.expr_ty,\n+                                 fcx.ty_to_string(self.cast_ty)).emit();\n             }\n         }\n     }"}, {"sha": "b2fa2cc7c61d2524f98696fa025c412d174091df", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -4208,6 +4208,104 @@ println!(\"{}\", v[2]);\n ```\n \"##,\n \n+E0604: r##\"\n+A cast to `char` was attempted on a type other than `u8`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0604\n+0u32 as char; // error: only `u8` can be cast as `char`, not `u32`\n+```\n+\n+As the error message indicates, only `u8` can be cast into `char`. Example:\n+\n+```\n+let c = 86u8 as char; // ok!\n+assert_eq!(c, 'V');\n+```\n+\n+For more information about casts, take a look at The Book:\n+https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+\"##,\n+\n+E0605: r##\"\n+An invalid cast was attempted.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0605\n+let x = 0u8;\n+x as Vec<u8>; // error: non-primitive cast: `u8` as `std::vec::Vec<u8>`\n+\n+// Another example\n+\n+let v = 0 as *const u8; // So here, `v` is a `*const u8`.\n+v as &u8; // error: non-primitive cast: `*const u8` as `&u8`\n+```\n+\n+Only primitive types can be cast into each other. Examples:\n+\n+```\n+let x = 0u8;\n+x as u32; // ok!\n+\n+let v = 0 as *const u8;\n+v as *const i8; // ok!\n+```\n+\n+For more information about casts, take a look at The Book:\n+https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+\"##,\n+\n+E0606: r##\"\n+An incompatible cast was attempted.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0606\n+let x = &0u8; // Here, `x` is a `&u8`.\n+let y: u32 = x as u32; // error: casting `&u8` as `u32` is invalid\n+```\n+\n+When casting, keep in mind that only primitive types can be cast into each\n+other. Example:\n+\n+```\n+let x = &0u8;\n+let y: u32 = *x as u32; // We dereference it first and then cast it.\n+```\n+\n+For more information about casts, take a look at The Book:\n+https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+\"##,\n+\n+E0607: r##\"\n+A cast between a thin and a fat pointer was attempted.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0607\n+let v = 0 as *const u8;\n+v as *const [u8];\n+```\n+\n+First: what are thin and fat pointers?\n+\n+Thin pointers are \"simple\" pointers: they are purely a reference to a memory\n+address.\n+\n+Fat pointers are pointers referencing Dynamically Sized Types (also called DST).\n+DST don't have a statically known size, therefore they can only exist behind\n+some kind of pointers that contain additional information. Slices and trait\n+objects are DSTs. In the case of slices, the additional information the fat\n+pointer holds is their size.\n+\n+To fix this error, don't try to cast directly between thin and fat pointers.\n+\n+For more information about casts, take a look at The Book:\n+https://doc.rust-lang.org/book/first-edition/casting-between-types.html\n+\"##,\n+\n E0609: r##\"\n Attempted to access a non-existent field in a struct.\n "}, {"sha": "e9296f33b9e0fbd0d621a7bfec22efe1e941ea34", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -29,7 +29,7 @@ use sys_common::{AsInner, IntoInner, FromInner};\n /// * On Windows, strings are often arbitrary sequences of non-zero 16-bit\n ///   values, interpreted as UTF-16 when it is valid to do so.\n ///\n-/// * In Rust, strings are always valid UTF-8, but may contain zeros.\n+/// * In Rust, strings are always valid UTF-8, which may contain zeros.\n ///\n /// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust\n /// and platform-native string values, and in particular allowing a Rust string"}, {"sha": "c5bf3a77b6c8f4ba27003646e6d176a3bab35c55", "filename": "src/test/compile-fail/E0604.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2FE0604.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2FE0604.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0604.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    1u32 as char; //~ ERROR E0604\n+}"}, {"sha": "add3fd8fd8ac28c1b81735672fa0b629a9a663bf", "filename": "src/test/compile-fail/E0605.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2FE0605.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2FE0605.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0605.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = 0u8;\n+    x as Vec<u8>; //~ ERROR E0605\n+                  //~| NOTE an `as` expression can only be used to convert between primitive types\n+\n+    let v = 0 as *const u8;\n+    v as &u8; //~ ERROR E0605\n+              //~| NOTE an `as` expression can only be used to convert between primitive types\n+}"}, {"sha": "55071736bfe51918241beb893a90e3193794e000", "filename": "src/test/compile-fail/E0606.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2FE0606.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2FE0606.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0606.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    &0u8 as u8; //~ ERROR E0606\n+}"}, {"sha": "fa761f2c17896149398c421df6984145b72df3b3", "filename": "src/test/compile-fail/E0607.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2FE0607.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2FE0607.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0607.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = 0 as *const u8;\n+    v as *const [u8]; //~ ERROR E0607\n+}"}, {"sha": "ab22d352480739d3fe27520993523b4df654acf5", "filename": "src/test/compile-fail/cast-from-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: non-scalar cast: `()` as `u32`\n+// error-pattern: non-primitive cast: `()` as `u32`\n fn main() { let u = (assert!(true) as u32); }"}, {"sha": "d5a998c6e4b6b944884c6135beac62f29cf74742", "filename": "src/test/compile-fail/cast-to-bare-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -13,8 +13,8 @@ fn foo(_x: isize) { }\n fn main() {\n     let v: u64 = 5;\n     let x = foo as extern \"C\" fn() -> isize;\n-    //~^ ERROR non-scalar cast\n+    //~^ ERROR non-primitive cast\n     let y = v as extern \"Rust\" fn(isize) -> (isize, isize);\n-    //~^ ERROR non-scalar cast\n+    //~^ ERROR non-primitive cast\n     y(x());\n }"}, {"sha": "27d9e8a42b188c58759ff50ac7410f893d33cf65", "filename": "src/test/compile-fail/cast-to-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: non-scalar cast: `u32` as `()`\n+// error-pattern: non-primitive cast: `u32` as `()`\n fn main() { let u = 0u32 as (); }"}, {"sha": "6584c16c9dec67cfdbb3d6966dcb56d6ada51b10", "filename": "src/test/compile-fail/closure-no-fn-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-no-fn-3.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -14,5 +14,5 @@\n fn main() {\n     let b = 0u8;\n     let baz: fn() -> u8 = (|| { b }) as fn() -> u8;\n-    //~^ ERROR non-scalar cast\n+    //~^ ERROR non-primitive cast\n }"}, {"sha": "0479f5cce65379ed73bd43b46f1356bde316f564", "filename": "src/test/compile-fail/coerce-to-bang-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang-cast.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -17,7 +17,7 @@ fn cast_a() {\n }\n \n fn cast_b() {\n-    let y = 22 as !; //~ ERROR non-scalar cast\n+    let y = 22 as !; //~ ERROR non-primitive cast\n }\n \n fn main() { }"}, {"sha": "bc2dc1cc5d4c83923f349f8062462af9bc79f020", "filename": "src/test/compile-fail/fat-ptr-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -22,7 +22,7 @@ fn main() {\n     a as isize; //~ ERROR casting\n     a as i16; //~ ERROR casting `&[i32]` as `i16` is invalid\n     a as u32; //~ ERROR casting `&[i32]` as `u32` is invalid\n-    b as usize; //~ ERROR non-scalar cast\n+    b as usize; //~ ERROR non-primitive cast\n     p as usize;\n     //~^ ERROR casting\n     //~^^ HELP cast through a thin pointer"}, {"sha": "2d00f339f33a066607fbf6eee018501ce5557422", "filename": "src/test/compile-fail/issue-10991.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let nil = ();\n-    let _t = nil as usize; //~ ERROR: non-scalar cast: `()` as `usize`\n+    let _t = nil as usize; //~ ERROR: non-primitive cast: `()` as `usize`\n }"}, {"sha": "c23fc4f334472bee36f321981f2e44078bc71d83", "filename": "src/test/compile-fail/issue-22289.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    0 as &std::any::Any; //~ ERROR non-scalar cast\n+    0 as &std::any::Any; //~ ERROR non-primitive cast\n }"}, {"sha": "2128c4206301b3848968c48eb9db804b5a75a17e", "filename": "src/test/compile-fail/issue-22312.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fissue-22312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fissue-22312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22312.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -19,7 +19,7 @@ pub trait Array2D: Index<usize> {\n         }\n         let i = y * self.columns() + x;\n         let indexer = &(*self as &Index<usize, Output = <Self as Index<usize>>::Output>);\n-        //~^ERROR non-scalar cast\n+        //~^ERROR non-primitive cast\n         Some(indexer.index(i))\n     }\n }"}, {"sha": "d735e184d5cd568f3c0461d11e9bebb8e9b483b4", "filename": "src/test/compile-fail/issue-2995.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn bad (p: *const isize) {\n-    let _q: &isize = p as &isize; //~ ERROR non-scalar cast\n+    let _q: &isize = p as &isize; //~ ERROR non-primitive cast\n }\n \n fn main() { }"}, {"sha": "0abbc05eef05dd7b84bcd578b3ef6413001c2ed1", "filename": "src/test/compile-fail/nonscalar-cast.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:non-scalar cast\n-\n #[derive(Debug)]\n struct foo {\n     x: isize\n }\n \n fn main() {\n-    println!(\"{}\", foo{ x: 1 } as isize);\n+    println!(\"{}\", foo{ x: 1 } as isize); //~ non-primitive cast: `foo` as `isize` [E0605]\n }"}, {"sha": "220537633eaf12291d6f99b18df7af814b5e90b3", "filename": "src/test/compile-fail/tag-variant-cast-non-nullary.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Ftag-variant-cast-non-nullary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Ftag-variant-cast-non-nullary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-variant-cast-non-nullary.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//error-pattern: non-scalar cast\n-\n enum non_nullary {\n     nullary,\n     other(isize),\n }\n \n fn main() {\n     let v = non_nullary::nullary;\n-    let val = v as isize;\n+    let val = v as isize; //~ ERROR non-primitive cast: `non_nullary` as `isize` [E0605]\n }"}, {"sha": "2a5d25e6b98dd0497286a83883c518c64a5ceef0", "filename": "src/test/compile-fail/uninhabited-enum-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Funinhabited-enum-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fcompile-fail%2Funinhabited-enum-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funinhabited-enum-cast.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -11,7 +11,7 @@\n enum E {}\n \n fn f(e: E) {\n-    println!(\"{}\", (e as isize).to_string());   //~ ERROR non-scalar cast\n+    println!(\"{}\", (e as isize).to_string());   //~ ERROR non-primitive cast\n }\n \n fn main() {}"}, {"sha": "d71da58829a72772ca51a61d1e91ffe1f648c65c", "filename": "src/test/ui/lint/outer-forbid.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fui%2Flint%2Fouter-forbid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fui%2Flint%2Fouter-forbid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fouter-forbid.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Forbidding a group (here, `unused`) overrules subsequent allowance of both\n+// the group, and an individual lint in the group (here, `unused_variables`);\n+// and, forbidding an individual lint (here, `non_snake_case`) overrules\n+// subsequent allowance of a lint group containing it (here, `bad_style`). See\n+// Issue #42873.\n+\n+#![forbid(unused, non_snake_case)]\n+\n+#[allow(unused, unused_variables, bad_style)]\n+fn main() {\n+    println!(\"hello forbidden world\")\n+}"}, {"sha": "831b3f65634b2b805485b8dfbe8dd3dfe1899c43", "filename": "src/test/ui/lint/outer-forbid.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fui%2Flint%2Fouter-forbid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fui%2Flint%2Fouter-forbid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fouter-forbid.stderr?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -0,0 +1,29 @@\n+error[E0453]: allow(unused) overruled by outer forbid(unused)\n+  --> $DIR/outer-forbid.rs:19:9\n+   |\n+17 | #![forbid(unused, non_snake_case)]\n+   |           ------ `forbid` level set here\n+18 | \n+19 | #[allow(unused, unused_variables, bad_style)]\n+   |         ^^^^^^ overruled by previous forbid\n+\n+error[E0453]: allow(unused_variables) overruled by outer forbid(unused)\n+  --> $DIR/outer-forbid.rs:19:17\n+   |\n+17 | #![forbid(unused, non_snake_case)]\n+   |           ------ `forbid` level set here\n+18 | \n+19 | #[allow(unused, unused_variables, bad_style)]\n+   |                 ^^^^^^^^^^^^^^^^ overruled by previous forbid\n+\n+error[E0453]: allow(bad_style) overruled by outer forbid(non_snake_case)\n+  --> $DIR/outer-forbid.rs:19:35\n+   |\n+17 | #![forbid(unused, non_snake_case)]\n+   |                   -------------- `forbid` level set here\n+18 | \n+19 | #[allow(unused, unused_variables, bad_style)]\n+   |                                   ^^^^^^^^^ overruled by previous forbid\n+\n+error: aborting due to previous error(s)\n+"}, {"sha": "879acbcf9d9d1cd198a603df218e067a894c0dab", "filename": "src/test/ui/mismatched_types/cast-rfc0401.stderr", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fcast-rfc0401.stderr?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -1,12 +1,12 @@\n-error: casting `*const U` as `*const V` is invalid\n+error[E0606]: casting `*const U` as `*const V` is invalid\n   --> $DIR/cast-rfc0401.rs:13:5\n    |\n 13 |     u as *const V\n    |     ^^^^^^^^^^^^^\n    |\n    = note: vtable kinds may not match\n \n-error: casting `*const U` as `*const str` is invalid\n+error[E0606]: casting `*const U` as `*const str` is invalid\n   --> $DIR/cast-rfc0401.rs:18:5\n    |\n 18 |     u as *const str\n@@ -20,57 +20,67 @@ error[E0609]: no field `f` on type `fn() {main}`\n 75 |     let _ = main.f as *const u32;\n    |                  ^\n \n-error: non-scalar cast: `*const u8` as `&u8`\n+error[E0605]: non-primitive cast: `*const u8` as `&u8`\n   --> $DIR/cast-rfc0401.rs:39:13\n    |\n 39 |     let _ = v as &u8;\n    |             ^^^^^^^^\n+   |\n+   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n \n-error: non-scalar cast: `*const u8` as `E`\n+error[E0605]: non-primitive cast: `*const u8` as `E`\n   --> $DIR/cast-rfc0401.rs:40:13\n    |\n 40 |     let _ = v as E;\n    |             ^^^^^^\n+   |\n+   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n \n-error: non-scalar cast: `*const u8` as `fn()`\n+error[E0605]: non-primitive cast: `*const u8` as `fn()`\n   --> $DIR/cast-rfc0401.rs:41:13\n    |\n 41 |     let _ = v as fn();\n    |             ^^^^^^^^^\n+   |\n+   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n \n-error: non-scalar cast: `*const u8` as `(u32,)`\n+error[E0605]: non-primitive cast: `*const u8` as `(u32,)`\n   --> $DIR/cast-rfc0401.rs:42:13\n    |\n 42 |     let _ = v as (u32,);\n    |             ^^^^^^^^^^^\n+   |\n+   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n \n-error: non-scalar cast: `std::option::Option<&*const u8>` as `*const u8`\n+error[E0605]: non-primitive cast: `std::option::Option<&*const u8>` as `*const u8`\n   --> $DIR/cast-rfc0401.rs:43:13\n    |\n 43 |     let _ = Some(&v) as *const u8;\n    |             ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n \n-error: casting `*const u8` as `f32` is invalid\n+error[E0606]: casting `*const u8` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:45:13\n    |\n 45 |     let _ = v as f32;\n    |             ^^^^^^^^\n \n-error: casting `fn() {main}` as `f64` is invalid\n+error[E0606]: casting `fn() {main}` as `f64` is invalid\n   --> $DIR/cast-rfc0401.rs:46:13\n    |\n 46 |     let _ = main as f64;\n    |             ^^^^^^^^^^^\n \n-error: casting `&*const u8` as `usize` is invalid\n+error[E0606]: casting `&*const u8` as `usize` is invalid\n   --> $DIR/cast-rfc0401.rs:47:13\n    |\n 47 |     let _ = &v as usize;\n    |             ^^^^^^^^^^^\n    |\n    = help: cast through a raw pointer first\n \n-error: casting `f32` as `*const u8` is invalid\n+error[E0606]: casting `f32` as `*const u8` is invalid\n   --> $DIR/cast-rfc0401.rs:48:13\n    |\n 48 |     let _ = f as *const u8;\n@@ -92,113 +102,113 @@ error[E0054]: cannot cast as `bool`\n    |\n    = help: compare with zero instead\n \n-error: only `u8` can be cast as `char`, not `u32`\n+error[E0604]: only `u8` can be cast as `char`, not `u32`\n   --> $DIR/cast-rfc0401.rs:51:13\n    |\n 51 |     let _ = 0x61u32 as char;\n    |             ^^^^^^^^^^^^^^^\n \n-error: casting `bool` as `f32` is invalid\n+error[E0606]: casting `bool` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:53:13\n    |\n 53 |     let _ = false as f32;\n    |             ^^^^^^^^^^^^\n    |\n    = help: cast through an integer first\n \n-error: casting `E` as `f32` is invalid\n+error[E0606]: casting `E` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:54:13\n    |\n 54 |     let _ = E::A as f32;\n    |             ^^^^^^^^^^^\n    |\n    = help: cast through an integer first\n \n-error: casting `char` as `f32` is invalid\n+error[E0606]: casting `char` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:55:13\n    |\n 55 |     let _ = 'a' as f32;\n    |             ^^^^^^^^^^\n    |\n    = help: cast through an integer first\n \n-error: casting `bool` as `*const u8` is invalid\n+error[E0606]: casting `bool` as `*const u8` is invalid\n   --> $DIR/cast-rfc0401.rs:57:13\n    |\n 57 |     let _ = false as *const u8;\n    |             ^^^^^^^^^^^^^^^^^^\n \n-error: casting `E` as `*const u8` is invalid\n+error[E0606]: casting `E` as `*const u8` is invalid\n   --> $DIR/cast-rfc0401.rs:58:13\n    |\n 58 |     let _ = E::A as *const u8;\n    |             ^^^^^^^^^^^^^^^^^\n \n-error: casting `char` as `*const u8` is invalid\n+error[E0606]: casting `char` as `*const u8` is invalid\n   --> $DIR/cast-rfc0401.rs:59:13\n    |\n 59 |     let _ = 'a' as *const u8;\n    |             ^^^^^^^^^^^^^^^^\n \n-error: casting `usize` as `*const [u8]` is invalid\n+error[E0606]: casting `usize` as `*const [u8]` is invalid\n   --> $DIR/cast-rfc0401.rs:61:13\n    |\n 61 |     let _ = 42usize as *const [u8];\n    |             ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: cannot cast thin pointer `*const u8` to fat pointer `*const [u8]`\n+error[E0607]: cannot cast thin pointer `*const u8` to fat pointer `*const [u8]`\n   --> $DIR/cast-rfc0401.rs:62:13\n    |\n 62 |     let _ = v as *const [u8];\n    |             ^^^^^^^^^^^^^^^^\n \n-error: casting `&Foo` as `*const str` is invalid\n+error[E0606]: casting `&Foo` as `*const str` is invalid\n   --> $DIR/cast-rfc0401.rs:64:13\n    |\n 64 |     let _ = foo as *const str;\n    |             ^^^^^^^^^^^^^^^^^\n \n-error: casting `&Foo` as `*mut str` is invalid\n+error[E0606]: casting `&Foo` as `*mut str` is invalid\n   --> $DIR/cast-rfc0401.rs:65:13\n    |\n 65 |     let _ = foo as *mut str;\n    |             ^^^^^^^^^^^^^^^\n \n-error: casting `fn() {main}` as `*mut str` is invalid\n+error[E0606]: casting `fn() {main}` as `*mut str` is invalid\n   --> $DIR/cast-rfc0401.rs:66:13\n    |\n 66 |     let _ = main as *mut str;\n    |             ^^^^^^^^^^^^^^^^\n \n-error: casting `&f32` as `*mut f32` is invalid\n+error[E0606]: casting `&f32` as `*mut f32` is invalid\n   --> $DIR/cast-rfc0401.rs:67:13\n    |\n 67 |     let _ = &f as *mut f32;\n    |             ^^^^^^^^^^^^^^\n \n-error: casting `&f32` as `*const f64` is invalid\n+error[E0606]: casting `&f32` as `*const f64` is invalid\n   --> $DIR/cast-rfc0401.rs:68:13\n    |\n 68 |     let _ = &f as *const f64;\n    |             ^^^^^^^^^^^^^^^^\n \n-error: casting `*const [i8]` as `usize` is invalid\n+error[E0606]: casting `*const [i8]` as `usize` is invalid\n   --> $DIR/cast-rfc0401.rs:69:13\n    |\n 69 |     let _ = fat_sv as usize;\n    |             ^^^^^^^^^^^^^^^\n    |\n    = help: cast through a thin pointer first\n \n-error: casting `*const Foo` as `*const [u16]` is invalid\n+error[E0606]: casting `*const Foo` as `*const [u16]` is invalid\n   --> $DIR/cast-rfc0401.rs:78:13\n    |\n 78 |     let _ = cf as *const [u16];\n    |             ^^^^^^^^^^^^^^^^^^\n    |\n    = note: vtable kinds may not match\n \n-error: casting `*const Foo` as `*const Bar` is invalid\n+error[E0606]: casting `*const Foo` as `*const Bar` is invalid\n   --> $DIR/cast-rfc0401.rs:79:13\n    |\n 79 |     let _ = cf as *const Bar;\n@@ -224,7 +234,7 @@ error[E0277]: the trait bound `str: std::marker::Sized` is not satisfied\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n    = note: required for the cast to the object type `Foo`\n \n-error: casting `&{float}` as `f32` is invalid\n+error[E0606]: casting `&{float}` as `f32` is invalid\n   --> $DIR/cast-rfc0401.rs:81:30\n    |\n 81 |     vec![0.0].iter().map(|s| s as f32).collect::<Vec<f32>>();"}, {"sha": "9da9042e78ed13b891e2899e6e9bccd36b368a0f", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -7,14 +7,16 @@ error[E0308]: mismatched types\n 37 |     write!(hello);\n    |     -------------- in this macro invocation\n \n-error: non-scalar cast: `{integer}` as `()`\n+error[E0605]: non-primitive cast: `{integer}` as `()`\n   --> $DIR/issue-26480.rs:32:19\n    |\n 32 |     ($x:expr) => ($x as ())\n    |                   ^^^^^^^^\n ...\n 38 |     cast!(2);\n    |     --------- in this macro invocation\n+   |\n+   = note: an `as` expression can only be used to convert between primitive types. Consider using the `From` trait\n \n error: aborting due to previous error(s)\n "}, {"sha": "4961609c77fbd99e055eed2d16ad21b0c6219fe9", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f590a44ce61888c78b9044817d8b798db5cd2ffd/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=f590a44ce61888c78b9044817d8b798db5cd2ffd", "patch": "@@ -692,7 +692,7 @@ actual:\\n\\\n         }\n \n         if !debugger_run_result.status.success() {\n-            self.fatal(\"gdb failed to execute\");\n+            self.fatal_proc_rec(\"gdb failed to execute\", &debugger_run_result);\n         }\n \n         self.check_debugger_output(&debugger_run_result, &check_lines);"}]}