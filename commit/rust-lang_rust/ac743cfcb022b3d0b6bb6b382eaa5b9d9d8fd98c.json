{"sha": "ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNzQzY2ZjYjAyMmIzZDBiNmJiNmIzODJlYWE1YjlkOWQ4ZmQ5OGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-15T01:32:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-15T01:32:04Z"}, "message": "Merge pull request #490 from msullivan/fix_vec_append\n\nMove the implementation of vec_append from llvm assembly to a regular upcall", "tree": {"sha": "97f4ae26db7fa584bb7fdcaefe779101e2d0fc9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97f4ae26db7fa584bb7fdcaefe779101e2d0fc9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "html_url": "https://github.com/rust-lang/rust/commit/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6be352f73927ddf44357aaf87b161b5805263c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6be352f73927ddf44357aaf87b161b5805263c0", "html_url": "https://github.com/rust-lang/rust/commit/c6be352f73927ddf44357aaf87b161b5805263c0"}, {"sha": "ccd1bcf7a754a5437cd108bb6bb8a32848334fe6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccd1bcf7a754a5437cd108bb6bb8a32848334fe6", "html_url": "https://github.com/rust-lang/rust/commit/ccd1bcf7a754a5437cd108bb6bb8a32848334fe6"}], "stats": {"total": 134, "additions": 80, "deletions": 54}, "files": [{"sha": "107905f50851e3ddc711fdac472ea442979eb148", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "patch": "@@ -88,8 +88,8 @@ fn bzero_glue_name() -> str {\n     ret \"rust_bzero_glue\";\n }\n \n-fn vec_append_glue_name() -> str {\n-    ret \"rust_vec_append_glue\";\n+fn yield_glue_name() -> str {\n+    ret \"rust_yield_glue\";\n }\n \n fn no_op_type_glue_name() -> str {"}, {"sha": "c2c90f641f10cd42872a7740c18f5fea5197857b", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "patch": "@@ -5,6 +5,7 @@ import trans::decl_cdecl_fn;\n import trans::T_f32;\n import trans::T_f64;\n import trans::T_fn;\n+import trans::T_bool;\n import trans::T_i8;\n import trans::T_i32;\n import trans::T_int;\n@@ -53,6 +54,7 @@ type upcalls = rec(\n     ValueRef new_str,\n     ValueRef new_vec,\n     ValueRef vec_grow,\n+    ValueRef vec_append,\n     ValueRef get_type_desc,\n     ValueRef new_task,\n     ValueRef start_task,\n@@ -111,6 +113,9 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n         vec_grow=d(\"vec_grow\", [T_opaque_vec_ptr(), T_size_t(),\n                                    T_ptr(T_int()), T_ptr(T_tydesc(tn))],\n                    T_opaque_vec_ptr()),\n+        vec_append=d(\"vec_append\", [T_ptr(T_tydesc(tn)), T_ptr(T_tydesc(tn)),\n+                                    T_ptr(T_opaque_vec_ptr()),\n+                                    T_opaque_vec_ptr(), T_bool()], T_void()),\n         get_type_desc=d(\"get_type_desc\",\n                         [T_ptr(T_nil()), T_size_t(), T_size_t(),\n                          T_size_t(), T_ptr(T_ptr(T_tydesc(tn)))],"}, {"sha": "ab2bf5a46bdcd9066412bcef40ddc9ddd8e4b08c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 10, "deletions": 45, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "patch": "@@ -85,8 +85,7 @@ state obj namegen(mutable int i) {\n \n type derived_tydesc_info = rec(ValueRef lltydesc, bool escapes);\n \n-type glue_fns = rec(ValueRef no_op_type_glue,\n-                    ValueRef vec_append_glue);\n+type glue_fns = rec(ValueRef no_op_type_glue);\n \n type tydesc_info = rec(ty::t ty,\n                        ValueRef tydesc,\n@@ -1972,7 +1971,7 @@ fn declare_generic_glue(&@local_ctxt cx,\n         fn_nm = mangle_internal_name_by_seq(cx.ccx,\n                                             \"glue_\" + name);\n     }\n-    auto llfn = decl_fastcall_fn(cx.ccx.llmod, fn_nm, llfnty);\n+    auto llfn = decl_cdecl_fn(cx.ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(cx, llfn, t);\n     ret llfn;\n }\n@@ -3263,11 +3262,11 @@ fn call_tydesc_glue_full(&@block_ctxt cx, ValueRef v,\n     auto llfnptr = cx.build.GEP(tydesc, [C_int(0), C_int(field)]);\n     auto llfn = cx.build.Load(llfnptr);\n \n-    cx.build.FastCall(llfn, [C_null(T_ptr(T_nil())),\n-                                cx.fcx.lltaskptr,\n-                                C_null(T_ptr(T_nil())),\n-                                lltydescs,\n-                                llrawptr]);\n+    cx.build.Call(llfn, [C_null(T_ptr(T_nil())),\n+                         cx.fcx.lltaskptr,\n+                         C_null(T_ptr(T_nil())),\n+                         lltydescs,\n+                         llrawptr]);\n }\n \n fn call_tydesc_glue(&@block_ctxt cx, ValueRef v,\n@@ -3342,7 +3341,7 @@ fn call_cmp_glue(&@block_ctxt cx,\n                                    llrawrhsptr,\n                                    llop];\n \n-    r.bcx.build.FastCall(llfn, llargs);\n+    r.bcx.build.Call(llfn, llargs);\n \n     ret res(r.bcx, r.bcx.build.Load(llcmpresultptr));\n }\n@@ -3711,7 +3710,7 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t,\n     auto dst = bcx.build.PointerCast(lhs, T_ptr(T_opaque_vec_ptr()));\n     auto src = bcx.build.PointerCast(rhs, T_opaque_vec_ptr());\n \n-    ret res(bcx, bcx.build.FastCall(cx.fcx.lcx.ccx.glues.vec_append_glue,\n+    ret res(bcx, bcx.build.Call(cx.fcx.lcx.ccx.upcalls.vec_append,\n                                     [cx.fcx.lltaskptr,\n                                         llvec_tydesc.val,\n                                         llelt_tydesc.val,\n@@ -8742,39 +8741,6 @@ fn make_no_op_type_glue(ValueRef fun) {\n     new_builder(llbb).RetVoid();\n }\n \n-fn make_vec_append_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n-    /*\n-     * Args to vec_append_glue:\n-     *\n-     *   0. (Implicit) task ptr\n-     *\n-     *   1. Pointer to the tydesc of the vec, so that we can tell if it's gc\n-     *      mem, and have a tydesc to pass to malloc if we're allocating anew.\n-     *\n-     *   2. Pointer to the tydesc of the vec's stored element type, so that\n-     *      elements can be copied to a newly alloc'ed vec if one must be\n-     *      created.\n-     *\n-     *   3. Dst vec ptr (i.e. ptr to ptr to rust_vec).\n-     *\n-     *   4. Src vec (i.e. ptr to rust_vec).\n-     *\n-     *   5. Flag indicating whether to skip trailing null on dst.\n-     *\n-     */\n-\n-    auto ty = T_fn([T_taskptr(tn),\n-                       T_ptr(T_tydesc(tn)),\n-                       T_ptr(T_tydesc(tn)),\n-                       T_ptr(T_opaque_vec_ptr()),\n-                       T_opaque_vec_ptr(), T_bool()],\n-                   T_void());\n-\n-    auto llfn = decl_fastcall_fn(llmod, abi::vec_append_glue_name(), ty);\n-    ret llfn;\n-}\n-\n-\n fn vec_fill(&@block_ctxt bcx, ValueRef v) -> ValueRef {\n     ret bcx.build.Load(bcx.build.GEP(v, [C_int(0),\n                                             C_int(abi::vec_elt_fill)]));\n@@ -8787,8 +8753,7 @@ fn vec_p0(&@block_ctxt bcx, ValueRef v) -> ValueRef {\n }\n \n fn make_glues(ModuleRef llmod, &type_names tn) -> @glue_fns {\n-    ret @rec(no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n-             vec_append_glue = make_vec_append_glue(llmod, tn));\n+    ret @rec(no_op_type_glue = decl_no_op_type_glue(llmod, tn));\n }\n \n fn make_common_glue(&session::session sess, &str output) {"}, {"sha": "5db1216c1021e499440674dc37b700152bda93b0", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "patch": "@@ -206,19 +206,27 @@ struct rust_timer {\n \n #include \"rust_util.h\"\n \n+typedef void CDECL (glue_fn)(void *, rust_task *, void *,\n+                             const type_desc **, void *);\n+typedef void CDECL (cmp_glue_fn)(void *, rust_task *, void *,\n+                                 const type_desc **,\n+                                 void *, void *, int8_t);\n+\n+\n struct type_desc {\n     // First part of type_desc is known to compiler.\n     // first_param = &descs[1] if dynamic, null if static.\n     const type_desc **first_param;\n     size_t size;\n     size_t align;\n-    uintptr_t copy_glue_off;\n-    uintptr_t drop_glue_off;\n-    uintptr_t free_glue_off;\n-    uintptr_t sever_glue_off;    // For GC.\n-    uintptr_t mark_glue_off;     // For GC.\n-    uintptr_t obj_drop_glue_off; // For custom destructors.\n+    glue_fn *take_glue;\n+    glue_fn *drop_glue;\n+    glue_fn *free_glue;\n+    glue_fn *sever_glue;    // For GC.\n+    glue_fn *mark_glue;     // For GC.\n+    glue_fn *obj_drop_glue; // For custom destructors.\n     uintptr_t is_stateful;\n+    cmp_glue_fn *cmp_glue;\n \n     // Residual fields past here are known only to runtime.\n     UT_hash_handle hh;"}, {"sha": "c3945bdd0c81697b0bc08a7524aa5f3f4fdda31b", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "patch": "@@ -415,7 +415,7 @@ upcall_vec_grow(rust_task *task,\n          *\n          * Step 3 is a bit tricky.  We don't know how to properly copy the\n          * elements in the runtime (all we have are bits in a buffer; no\n-         * type infromation and no copy glue).  What we do instead is set the\n+         * type information and no copy glue).  What we do instead is set the\n          * need_copy outparam flag to indicate to our caller (vec-copy glue)\n          * that we need the copies performed for us.\n          */\n@@ -436,6 +436,53 @@ upcall_vec_grow(rust_task *task,\n     return v;\n }\n \n+// Copy elements from one vector to another,\n+// dealing with reference counts\n+static inline void\n+copy_elements(rust_task *task, type_desc *elem_t,\n+              void *pdst, void *psrc, size_t n)\n+{\n+    char *dst = (char *)pdst, *src = (char *)psrc;\n+\n+    // increment the refcount of each element of the vector\n+    if (elem_t->take_glue) {\n+        glue_fn *take_glue = elem_t->take_glue;\n+        size_t elem_size = elem_t->size;\n+        const type_desc **tydescs = elem_t->first_param;\n+        for (char *p = src; p < src+n; p += elem_size) {\n+            take_glue(NULL, task, NULL, tydescs, p);\n+        }\n+    }\n+    memmove(dst, src, n);\n+}\n+\n+extern \"C\" CDECL void\n+upcall_vec_append(rust_task *task, type_desc *t, type_desc *elem_t,\n+                  rust_vec **dst_ptr, rust_vec *src, bool skip_null)\n+{\n+    LOG_UPCALL_ENTRY(task);\n+    rust_vec *dst = *dst_ptr;\n+    uintptr_t need_copy;\n+    size_t n_src_bytes = skip_null ? src->fill - 1 : src->fill;\n+    size_t n_dst_bytes = skip_null ? dst->fill - 1 : dst->fill;\n+    rust_vec *new_vec = upcall_vec_grow(task, dst, n_src_bytes,\n+                                        &need_copy, t);\n+\n+    if (need_copy) {\n+        // Copy any dst elements in, omitting null if doing str.\n+        copy_elements(task, elem_t, &new_vec->data, &dst->data, n_dst_bytes);\n+    }\n+\n+    // Copy any src elements in, carrying along null if doing str.\n+    void *new_end = (void *)((char *)new_vec->data + n_dst_bytes);\n+    copy_elements(task, elem_t, new_end, &src->data, src->fill);\n+    new_vec->fill = n_dst_bytes + src->fill;\n+\n+    // Write new_vec back through the alias we were given.\n+    *dst_ptr = new_vec;\n+}\n+\n+\n extern \"C\" CDECL type_desc *\n upcall_get_type_desc(rust_task *task,\n                      void *curr_crate, // ignored, legacy compat."}, {"sha": "9be5141f04d2cad250341d112298633fecea296e", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=ac743cfcb022b3d0b6bb6b382eaa5b9d9d8fd98c", "patch": "@@ -73,6 +73,7 @@ upcall_start_thread\n upcall_trace_str\n upcall_trace_word\n upcall_vec_grow\n+upcall_vec_append\n upcall_yield\n vec_alloc\n vec_alloc_mut"}]}