{"sha": "b90d7d4c817743234f33695837b2e0aa7bf01d3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MGQ3ZDRjODE3NzQzMjM0ZjMzNjk1ODM3YjJlMGFhN2JmMDFkM2E=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-03T00:57:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-03T00:59:15Z"}, "message": "rustc: Refactor vtable lookup to use a vtable context, so that it can be called outside a function. rs=refactor", "tree": {"sha": "9effdcc139269af265c0d60e22da73cd079121d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9effdcc139269af265c0d60e22da73cd079121d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b90d7d4c817743234f33695837b2e0aa7bf01d3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b90d7d4c817743234f33695837b2e0aa7bf01d3a", "html_url": "https://github.com/rust-lang/rust/commit/b90d7d4c817743234f33695837b2e0aa7bf01d3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b90d7d4c817743234f33695837b2e0aa7bf01d3a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e0c59614143abae80b155ca835758e27f286d14", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e0c59614143abae80b155ca835758e27f286d14", "html_url": "https://github.com/rust-lang/rust/commit/9e0c59614143abae80b155ca835758e27f286d14"}], "stats": {"total": 163, "additions": 101, "deletions": 62}, "files": [{"sha": "ae123f8dc5a0c941fe886e2e4b31d9b83e927ec3", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b90d7d4c817743234f33695837b2e0aa7bf01d3a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b90d7d4c817743234f33695837b2e0aa7bf01d3a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=b90d7d4c817743234f33695837b2e0aa7bf01d3a", "patch": "@@ -78,7 +78,7 @@ use typeck::infer::{resolve_type, force_tvar};\n use result::{Result, Ok, Err};\n use syntax::print::pprust;\n use syntax::parse::token::special_idents;\n-use vtable::LocationInfo;\n+use vtable::{LocationInfo, VtableContext};\n \n use std::map::HashMap;\n \n@@ -865,20 +865,20 @@ fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-fn impl_self_ty(fcx: @fn_ctxt,\n+fn impl_self_ty(vcx: &VtableContext,\n                 location_info: &LocationInfo, // (potential) receiver for\n                                               // this impl\n                 did: ast::def_id) -> ty_param_substs_and_ty {\n-    let tcx = fcx.ccx.tcx;\n+    let tcx = vcx.tcx();\n \n     let {n_tps, region_param, raw_ty} = if did.crate == ast::local_crate {\n-        let region_param = fcx.tcx().region_paramd_items.find(did.node);\n+        let region_param = tcx.region_paramd_items.find(did.node);\n         match tcx.items.find(did.node) {\n           Some(ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n                                   _}, _)) => {\n             {n_tps: ts.len(),\n              region_param: region_param,\n-             raw_ty: fcx.ccx.to_ty(rscope::type_rscope(region_param), st)}\n+             raw_ty: vcx.ccx.to_ty(rscope::type_rscope(region_param), st)}\n           }\n           Some(ast_map::node_item(@{node: ast::item_class(_, ts),\n                                     id: class_id, _},_)) => {\n@@ -904,12 +904,12 @@ fn impl_self_ty(fcx: @fn_ctxt,\n     };\n \n     let self_r = if region_param.is_some() {\n-        Some(fcx.infcx().next_region_var(location_info.span,\n+        Some(vcx.infcx.next_region_var(location_info.span,\n                                          location_info.id))\n     } else {\n         None\n     };\n-    let tps = fcx.infcx().next_ty_vars(n_tps);\n+    let tps = vcx.infcx.next_ty_vars(n_tps);\n \n     let substs = {self_r: self_r, self_ty: None, tps: tps};\n     let substd_ty = ty::subst(tcx, &substs, raw_ty);"}, {"sha": "f1185181f554addee9c705b48ca173c6baf74a6e", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b90d7d4c817743234f33695837b2e0aa7bf01d3a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b90d7d4c817743234f33695837b2e0aa7bf01d3a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=b90d7d4c817743234f33695837b2e0aa7bf01d3a", "patch": "@@ -492,8 +492,12 @@ impl LookupContext {\n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n         let location_info = &vtable::location_info_for_expr(self.self_expr);\n+        let vcx = VtableContext {\n+            ccx: self.fcx.ccx,\n+            infcx: self.fcx.infcx()\n+        };\n         let {substs: impl_substs, ty: impl_ty} =\n-            impl_self_ty(self.fcx, location_info, impl_info.did);\n+            impl_self_ty(&vcx, location_info, impl_info.did);\n \n         let (impl_ty, impl_substs) =\n             self.create_rcvr_ty_and_substs_for_method("}, {"sha": "2c3666419b214811f0356a8d710f9aed7aa4d415", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 89, "deletions": 54, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b90d7d4c817743234f33695837b2e0aa7bf01d3a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b90d7d4c817743234f33695837b2e0aa7bf01d3a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=b90d7d4c817743234f33695837b2e0aa7bf01d3a", "patch": "@@ -1,5 +1,5 @@\n use check::{fn_ctxt, impl_self_ty};\n-use infer::{resolve_type, resolve_and_force_all_but_regions,\n+use infer::{infer_ctxt, resolve_type, resolve_and_force_all_but_regions,\n                fixup_err_to_str};\n use syntax::codemap::span;\n use syntax::print::pprust;\n@@ -30,6 +30,17 @@ struct LocationInfo {\n     id: ast::node_id\n }\n \n+/// A vtable context includes an inference context, a crate context, and a\n+/// callback function to call in case of type error.\n+struct VtableContext {\n+    ccx: @crate_ctxt,\n+    infcx: infer::infer_ctxt\n+}\n+\n+impl VtableContext {\n+    fn tcx(&const self) -> ty::ctxt { self.ccx.tcx }\n+}\n+\n fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n         bs.any(|b| {\n@@ -38,7 +49,7 @@ fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     })\n }\n \n-fn lookup_vtables(fcx: @fn_ctxt,\n+fn lookup_vtables(vcx: &VtableContext,\n                   location_info: &LocationInfo,\n                   bounds: @~[ty::param_bounds],\n                   substs: &ty::substs,\n@@ -50,26 +61,26 @@ fn lookup_vtables(fcx: @fn_ctxt,\n             substs=%s\",\n            location_info,\n            bounds.len(),\n-           ty::substs_to_str(fcx.tcx(), substs));\n+           ty::substs_to_str(vcx.tcx(), substs));\n     let _i = indenter();\n \n-    let tcx = fcx.ccx.tcx;\n+    let tcx = vcx.tcx();\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n         for vec::each(*bounds[i]) |bound| {\n             match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                match lookup_vtable_covariant(fcx, location_info, *ty, i_ty,\n+                match lookup_vtable_covariant(vcx, location_info, *ty, i_ty,\n                                               allow_unsafe, is_early) {\n                     Some(vtable) => result.push(vtable),\n                     None => {\n-                        fcx.tcx().sess.span_fatal(\n+                        vcx.tcx().sess.span_fatal(\n                             location_info.span,\n                             fmt!(\"failed to find an implementation of trait \\\n                                   %s for %s\",\n-                                 ty_to_str(fcx.tcx(), i_ty),\n-                                 ty_to_str(fcx.tcx(), *ty)));\n+                                 ty_to_str(vcx.tcx(), i_ty),\n+                                 ty_to_str(vcx.tcx(), *ty)));\n                     }\n                 }\n               }\n@@ -81,43 +92,43 @@ fn lookup_vtables(fcx: @fn_ctxt,\n     @result\n }\n \n-fn fixup_substs(fcx: @fn_ctxt, location_info: &LocationInfo,\n+fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n                 id: ast::def_id, substs: ty::substs,\n                 is_early: bool) -> Option<ty::substs> {\n-    let tcx = fcx.ccx.tcx;\n+    let tcx = vcx.tcx();\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx, id, substs, ty::vstore_slice(ty::re_static));\n-    do fixup_ty(fcx, location_info, t, is_early).map |t_f| {\n+    do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n           ty::ty_trait(_, substs_f, _) => substs_f,\n           _ => fail ~\"t_f should be a trait\"\n         }\n     }\n }\n \n-fn relate_trait_tys(fcx: @fn_ctxt, location_info: &LocationInfo,\n+fn relate_trait_tys(vcx: &VtableContext, location_info: &LocationInfo,\n                     exp_trait_ty: ty::t, act_trait_ty: ty::t) {\n-    demand::suptype(fcx, location_info.span, exp_trait_ty, act_trait_ty)\n+    demand_suptype(vcx, location_info.span, exp_trait_ty, act_trait_ty)\n }\n \n // Look up the vtable to use when treating an item of type `t` as if it has\n // type `trait_ty`. This does allow subtraits.\n-fn lookup_vtable_covariant(fcx: @fn_ctxt,\n+fn lookup_vtable_covariant(vcx: &VtableContext,\n                            location_info: &LocationInfo,\n                            ty: ty::t,\n                            trait_ty: ty::t,\n                            allow_unsafe: bool,\n                            is_early: bool)\n                         -> Option<vtable_origin> {\n     debug!(\"lookup_vtable_covariant(ty: %s, trait_ty=%s)\",\n-           fcx.infcx().ty_to_str(ty),\n-           fcx.infcx().ty_to_str(trait_ty));\n+           vcx.infcx.ty_to_str(ty),\n+           vcx.infcx.ty_to_str(trait_ty));\n \n     let worklist = dvec::DVec();\n     worklist.push(trait_ty);\n     while worklist.len() > 0 {\n         let trait_ty = worklist.pop();\n-        let result = lookup_vtable_invariant(fcx, location_info, ty, trait_ty,\n+        let result = lookup_vtable_invariant(vcx, location_info, ty, trait_ty,\n                                              allow_unsafe, is_early);\n         if result.is_some() {\n             return result;\n@@ -126,7 +137,7 @@ fn lookup_vtable_covariant(fcx: @fn_ctxt,\n         // Add subtraits to the worklist, if applicable.\n         match ty::get(trait_ty).sty {\n             ty::ty_trait(trait_id, _, _) => {\n-                let table = fcx.ccx.coherence_info.supertrait_to_subtraits;\n+                let table = vcx.ccx.coherence_info.supertrait_to_subtraits;\n                 match table.find(trait_id) {\n                     None => {}\n                     Some(subtraits) => {\n@@ -135,7 +146,7 @@ fn lookup_vtable_covariant(fcx: @fn_ctxt,\n                             // have substs.\n                             let substs =\n                                 { self_r: None, self_ty: None, tps: ~[] };\n-                            let trait_ty = ty::mk_trait(fcx.ccx.tcx,\n+                            let trait_ty = ty::mk_trait(vcx.tcx(),\n                                                         *subtrait_id,\n                                                         substs,\n                                                         ty::vstore_box);\n@@ -145,9 +156,9 @@ fn lookup_vtable_covariant(fcx: @fn_ctxt,\n                 }\n             }\n             _ => {\n-                fcx.ccx.tcx.sess.impossible_case(location_info.span,\n-                                                 \"lookup_vtable_covariant: \\\n-                                                  non-trait in worklist\");\n+                vcx.tcx().sess.impossible_case(location_info.span,\n+                                               \"lookup_vtable_covariant: \\\n+                                                non-trait in worklist\");\n             }\n         }\n     }\n@@ -157,25 +168,25 @@ fn lookup_vtable_covariant(fcx: @fn_ctxt,\n \n // Look up the vtable to use when treating an item of type `t` as if it has\n // type `trait_ty`. This does not allow subtraits.\n-fn lookup_vtable_invariant(fcx: @fn_ctxt,\n+fn lookup_vtable_invariant(vcx: &VtableContext,\n                            location_info: &LocationInfo,\n                            ty: ty::t,\n                            trait_ty: ty::t,\n                            allow_unsafe: bool,\n                            is_early: bool)\n                         -> Option<vtable_origin> {\n     debug!(\"lookup_vtable_invariant(ty=%s, trait_ty=%s)\",\n-           fcx.infcx().ty_to_str(ty), fcx.inh.infcx.ty_to_str(trait_ty));\n+           vcx.infcx.ty_to_str(ty), vcx.infcx.ty_to_str(trait_ty));\n     let _i = indenter();\n \n-    let tcx = fcx.ccx.tcx;\n+    let tcx = vcx.tcx();\n     let (trait_id, trait_substs, trait_vstore) = match ty::get(trait_ty).sty {\n         ty::ty_trait(did, substs, vstore) => (did, substs, vstore),\n         _ => tcx.sess.impossible_case(location_info.span,\n                                       \"lookup_vtable_invariant: \\\n                                        don't know how to handle a non-trait\")\n     };\n-    let ty = match fixup_ty(fcx, location_info, ty, is_early) {\n+    let ty = match fixup_ty(vcx, location_info, ty, is_early) {\n         Some(ty) => ty,\n         None => {\n             // fixup_ty can only fail if this is early resolution\n@@ -203,7 +214,7 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                                     debug!(\"(checking vtable) @0 relating \\\n                                             ty to trait ty with did %?\",\n                                            idid);\n-                                    relate_trait_tys(fcx, location_info,\n+                                    relate_trait_tys(vcx, location_info,\n                                                      trait_ty, ity);\n                                     return Some(vtable_param(n, n_bound));\n                                 }\n@@ -223,7 +234,7 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n             debug!(\"(checking vtable) @1 relating ty to trait ty with did %?\",\n                    did);\n \n-            relate_trait_tys(fcx, location_info, trait_ty, ty);\n+            relate_trait_tys(vcx, location_info, trait_ty, ty);\n             if !allow_unsafe && !is_early {\n                 for vec::each(*ty::trait_methods(tcx, did)) |m| {\n                     if ty::type_has_self(ty::mk_fn(tcx, m.fty)) {\n@@ -248,7 +259,7 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n \n             let mut impls_seen = HashMap();\n \n-            match fcx.ccx.coherence_info.extension_methods.find(trait_id) {\n+            match vcx.ccx.coherence_info.extension_methods.find(trait_id) {\n                 None => {\n                     // Nothing found. Continue.\n                 }\n@@ -309,11 +320,14 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                             // to some_trait.  If not, then we try the next\n                             // impl.\n                             let {substs: substs, ty: for_ty} =\n-                                impl_self_ty(fcx, location_info, im.did);\n+                                impl_self_ty(vcx, location_info, im.did);\n                             let im_bs = ty::lookup_item_type(tcx,\n                                                              im.did).bounds;\n-                            match fcx.mk_subty(false, location_info.span, ty,\n-                                               for_ty) {\n+                            match infer::mk_subty(vcx.infcx,\n+                                                  false,\n+                                                  location_info.span,\n+                                                  ty,\n+                                                  for_ty) {\n                                 result::Err(_) => loop,\n                                 result::Ok(()) => ()\n                             }\n@@ -322,8 +336,8 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                             // bound to the type self_ty, and substs\n                             // is bound to [T].\n                             debug!(\"The self ty is %s and its substs are %s\",\n-                                   fcx.infcx().ty_to_str(for_ty),\n-                                   tys_to_str(fcx.ccx.tcx, substs.tps));\n+                                   vcx.infcx.ty_to_str(for_ty),\n+                                   tys_to_str(vcx.tcx(), substs.tps));\n \n                             // Next, we unify trait_ty -- the type\n                             // that we want to cast to -- with of_ty\n@@ -341,10 +355,10 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n \n                             debug!(\"(checking vtable) @2 relating trait \\\n                                     ty %s to of_ty %s\",\n-                                   fcx.infcx().ty_to_str(trait_ty),\n-                                   fcx.infcx().ty_to_str(*of_ty));\n+                                   vcx.infcx.ty_to_str(trait_ty),\n+                                   vcx.infcx.ty_to_str(*of_ty));\n                             let of_ty = ty::subst(tcx, &substs, *of_ty);\n-                            relate_trait_tys(fcx, location_info, trait_ty,\n+                            relate_trait_tys(vcx, location_info, trait_ty,\n                                              of_ty);\n \n                             // Recall that trait_ty -- the trait type\n@@ -357,7 +371,7 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n \n                             debug!(\"Casting to a trait ty whose substs \\\n                                     (trait_tps) are %s\",\n-                                   tys_to_str(fcx.ccx.tcx, trait_tps));\n+                                   tys_to_str(vcx.tcx(), trait_tps));\n \n                             // Recall that substs is the impl self\n                             // type's list of substitutions. That is,\n@@ -367,7 +381,7 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                             // variables, so we call fixup_substs to\n                             // resolve them.\n \n-                            let substs_f = match fixup_substs(fcx,\n+                            let substs_f = match fixup_substs(vcx,\n                                                               location_info,\n                                                               trait_id,\n                                                               substs,\n@@ -383,8 +397,8 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                             debug!(\"The fixed-up substs are %s - \\\n                                     they will be unified with the bounds for \\\n                                     the target ty, %s\",\n-                                   tys_to_str(fcx.ccx.tcx, substs_f.tps),\n-                                   tys_to_str(fcx.ccx.tcx, trait_tps));\n+                                   tys_to_str(vcx.tcx(), substs_f.tps),\n+                                   tys_to_str(vcx.tcx(), trait_tps));\n \n                             // Next, we unify the fixed-up\n                             // substitutions for the impl self ty with\n@@ -393,14 +407,14 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                             // to. connect_trait_tps requires these\n                             // lists of types to unify pairwise.\n \n-                            connect_trait_tps(fcx,\n+                            connect_trait_tps(vcx,\n                                               location_info,\n                                               substs_f.tps,\n                                               trait_tps,\n                                               im.did,\n                                               trait_vstore);\n                             let subres = lookup_vtables(\n-                                fcx, location_info, im_bs, &substs_f,\n+                                vcx, location_info, im_bs, &substs_f,\n                                 false, is_early);\n \n                             // Finally, we register that we found a\n@@ -421,7 +435,7 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n                 1 => { return Some(found[0]); }\n                 _ => {\n                     if !is_early {\n-                        fcx.ccx.tcx.sess.span_err(\n+                        vcx.tcx().sess.span_err(\n                             location_info.span,\n                             ~\"multiple applicable methods in scope\");\n                     }\n@@ -434,13 +448,13 @@ fn lookup_vtable_invariant(fcx: @fn_ctxt,\n     return None;\n }\n \n-fn fixup_ty(fcx: @fn_ctxt,\n+fn fixup_ty(vcx: &VtableContext,\n             location_info: &LocationInfo,\n             ty: ty::t,\n             is_early: bool) -> Option<ty::t>\n {\n-    let tcx = fcx.ccx.tcx;\n-    match resolve_type(fcx.infcx(), ty, resolve_and_force_all_but_regions) {\n+    let tcx = vcx.tcx();\n+    match resolve_type(vcx.infcx, ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n         Err(e) if !is_early => {\n             tcx.sess.span_fatal(\n@@ -455,13 +469,31 @@ fn fixup_ty(fcx: @fn_ctxt,\n     }\n }\n \n-fn connect_trait_tps(fcx: @fn_ctxt,\n+// Version of demand::suptype() that takes a vtable context instead of a\n+// function context.\n+fn demand_suptype(vcx: &VtableContext, sp: span, e: ty::t, a: ty::t) {\n+    // NB: Order of actual, expected is reversed.\n+    match infer::mk_subty(vcx.infcx, false, sp, a, e) {\n+        result::Ok(()) => {} // Ok.\n+        result::Err(ref err) => {\n+            vcx.tcx().sess.span_err(\n+                sp,\n+                fmt!(\"mismatched types: expected `%s` but found `%s` (%s)\",\n+                     vcx.infcx.ty_to_str(e),\n+                     vcx.infcx.ty_to_str(a),\n+                     ty::type_err_to_str(vcx.tcx(), err)));\n+            ty::note_and_explain_type_err(vcx.tcx(), err);\n+        }\n+    }\n+}\n+\n+fn connect_trait_tps(vcx: &VtableContext,\n                      location_info: &LocationInfo,\n                      impl_tys: ~[ty::t],\n                      trait_tys: ~[ty::t],\n                      impl_did: ast::def_id,\n                      vstore: ty::vstore) {\n-    let tcx = fcx.ccx.tcx;\n+    let tcx = vcx.tcx();\n \n     // XXX: This should work for multiple traits.\n     let ity = ty::impl_traits(tcx, impl_did, vstore)[0];\n@@ -471,7 +503,7 @@ fn connect_trait_tps(fcx: @fn_ctxt,\n     match ty::get(trait_ty).sty {\n      ty::ty_trait(_, substs, _) => {\n          for vec::each2(substs.tps, trait_tys) |a, b| {\n-             demand::suptype(fcx, location_info.span, *a, *b)\n+            demand_suptype(vcx, location_info.span, *a, *b);\n          }\n       }\n      _ => tcx.sess.impossible_case(location_info.span, \"connect_trait_tps: \\\n@@ -513,7 +545,8 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                             %s\",\n                            ty::param_bounds_to_str(fcx.tcx(), *bounds));\n                 }\n-                let vtbls = lookup_vtables(fcx, &location_info_for_expr(ex),\n+                let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n+                let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            item_ty.bounds, substs, false,\n                                            is_early);\n                 if !is_early { cx.vtable_map.insert(ex.id, vtbls); }\n@@ -539,7 +572,8 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                   _ => ex.callee_id\n                 };\n                 let substs = fcx.node_ty_substs(callee_id);\n-                let vtbls = lookup_vtables(fcx, &location_info_for_expr(ex),\n+                let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n+                let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            bounds, &substs, false, is_early);\n                 if !is_early {\n                     insert_vtables(cx, callee_id, vtbls);\n@@ -559,8 +593,9 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n             // XXX: This is invariant and shouldn't be. --pcw\n \n             let ty = fcx.expr_ty(src);\n+            let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n             let vtable_opt =\n-                lookup_vtable_invariant(fcx,\n+                lookup_vtable_invariant(&vcx,\n                                         &location_info_for_expr(ex),\n                                         ty,\n                                         target_ty,\n@@ -586,7 +621,7 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                                     let location_info =\n                                         &location_info_for_expr(ex);\n                                     let vtable_opt =\n-                                        lookup_vtable_invariant(fcx,\n+                                        lookup_vtable_invariant(&vcx,\n                                                                 location_info,\n                                                                 mt.ty,\n                                                                 target_ty,"}]}