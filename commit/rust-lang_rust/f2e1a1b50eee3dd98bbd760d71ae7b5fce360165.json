{"sha": "f2e1a1b50eee3dd98bbd760d71ae7b5fce360165", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZTFhMWI1MGVlZTNkZDk4YmJkNzYwZDcxYWU3YjVmY2UzNjAxNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T07:02:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T07:02:40Z"}, "message": "Auto merge of #23424 - arielb1:ambiguous-project, r=nikomatsakis\n\nr? @nikomatsakis", "tree": {"sha": "a2b6c1b3ee6bf24b51f44ee64d6b13518c5df4a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2b6c1b3ee6bf24b51f44ee64d6b13518c5df4a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165", "html_url": "https://github.com/rust-lang/rust/commit/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a90453a178069b890aa3877009fa99968dc85c09", "url": "https://api.github.com/repos/rust-lang/rust/commits/a90453a178069b890aa3877009fa99968dc85c09", "html_url": "https://github.com/rust-lang/rust/commit/a90453a178069b890aa3877009fa99968dc85c09"}, {"sha": "2a12e51dbd6949ae17925af9f3c4cc7402aa1b9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a12e51dbd6949ae17925af9f3c4cc7402aa1b9b", "html_url": "https://github.com/rust-lang/rust/commit/2a12e51dbd6949ae17925af9f3c4cc7402aa1b9b"}], "stats": {"total": 190, "additions": 123, "deletions": 67}, "files": [{"sha": "e199bb17bf94c00333021568f34c43ad65807423", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 103, "deletions": 67, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f2e1a1b50eee3dd98bbd760d71ae7b5fce360165", "patch": "@@ -117,23 +117,71 @@ pub enum MethodMatchedData {\n /// obligation is for `int`. In that case, we drop the impl out of the\n /// list.  But the other cases are considered *candidates*.\n ///\n-/// Candidates can either be definitive or ambiguous. An ambiguous\n-/// candidate is one that might match or might not, depending on how\n-/// type variables wind up being resolved. This only occurs during inference.\n+/// For selection to succeed, there must be exactly one matching\n+/// candidate. If the obligation is fully known, this is guaranteed\n+/// by coherence. However, if the obligation contains type parameters\n+/// or variables, there may be multiple such impls.\n ///\n-/// For selection to succeed, there must be exactly one non-ambiguous\n-/// candidate.  Usually, it is not possible to have more than one\n-/// definitive candidate, due to the coherence rules. However, there is\n-/// one case where it could occur: if there is a blanket impl for a\n-/// trait (that is, an impl applied to all T), and a type parameter\n-/// with a where clause. In that case, we can have a candidate from the\n-/// where clause and a second candidate from the impl. This is not a\n-/// problem because coherence guarantees us that the impl which would\n-/// be used to satisfy the where clause is the same one that we see\n-/// now. To resolve this issue, therefore, we ignore impls if we find a\n-/// matching where clause. Part of the reason for this is that where\n-/// clauses can give additional information (like, the types of output\n-/// parameters) that would have to be inferred from the impl.\n+/// It is not a real problem if multiple matching impls exist because\n+/// of type variables - it just means the obligation isn't sufficiently\n+/// elaborated. In that case we report an ambiguity, and the caller can\n+/// try again after more type information has been gathered or report a\n+/// \"type annotations required\" error.\n+///\n+/// However, with type parameters, this can be a real problem - type\n+/// parameters don't unify with regular types, but they *can* unify\n+/// with variables from blanket impls, and (unless we know its bounds\n+/// will always be satisfied) picking the blanket impl will be wrong\n+/// for at least *some* substitutions. To make this concrete, if we have\n+///\n+///    trait AsDebug { type Out : fmt::Debug; fn debug(self) -> Self::Out; }\n+///    impl<T: fmt::Debug> AsDebug for T {\n+///        type Out = T;\n+///        fn debug(self) -> fmt::Debug { self }\n+///    }\n+///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n+///\n+/// we can't just use the impl to resolve the <T as AsDebug> obligation\n+/// - a type from another crate (that doesn't implement fmt::Debug) could\n+/// implement AsDebug.\n+///\n+/// Because where-clauses match the type exactly, multiple clauses can\n+/// only match if there are unresolved variables, and we can mostly just\n+/// report this ambiguity in that case. This is still a problem - we can't\n+/// *do anything* with ambiguities that involve only regions. This is issue\n+/// #21974.\n+///\n+/// If a single where-clause matches and there are no inference\n+/// variables left, then it definitely matches and we can just select\n+/// it.\n+///\n+/// In fact, we even select the where-clause when the obligation contains\n+/// inference variables. The can lead to inference making \"leaps of logic\",\n+/// for example in this situation:\n+///\n+///    pub trait Foo<T> { fn foo(&self) -> T; }\n+///    impl<T> Foo<()> for T { fn foo(&self) { } }\n+///    impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n+///\n+///    pub fn foo<T>(t: T) where T: Foo<bool> {\n+///       println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n+///    }\n+///    fn main() { foo(false); }\n+///\n+/// Here the obligation <T as Foo<$0>> can be matched by both the blanket\n+/// impl and the where-clause. We select the where-clause and unify $0=bool,\n+/// so the program prints \"false\". However, if the where-clause is omitted,\n+/// the blanket impl is selected, we unify $0=(), and the program prints\n+/// \"()\".\n+///\n+/// Exactly the same issues apply to projection and object candidates, except\n+/// that we can have both a projection candidate and a where-clause candidate\n+/// for the same obligation. In that case either would do (except that\n+/// different \"leaps of logic\" would occur if inference variables are\n+/// present), and we just pick the projection. This is, for example,\n+/// required for associated types to work in default impls, as the bounds\n+/// are visible both as projection bounds and as where-clauses from the\n+/// parameter environment.\n #[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n     PhantomFnCandidate,\n@@ -1350,63 +1398,51 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Returns true if `candidate_i` should be dropped in favor of\n     /// `candidate_j`.  Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n+    /// Returns true if `victim` should be dropped in favor of\n+    /// `other`.  Generally speaking we will drop duplicate\n+    /// candidates and prefer where-clause candidates.\n+    ///\n+    /// See the comment for \"SelectionCandidate\" for more details.\n     fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n-                                                   candidate_i: &SelectionCandidate<'tcx>,\n-                                                   candidate_j: &SelectionCandidate<'tcx>)\n+                                                   victim: &SelectionCandidate<'tcx>,\n+                                                   other: &SelectionCandidate<'tcx>)\n                                                    -> bool\n     {\n-        if candidate_i == candidate_j {\n+        if victim == other {\n             return true;\n         }\n \n-        match (candidate_i, candidate_j) {\n-            (&ImplCandidate(..), &ParamCandidate(..)) |\n-            (&ClosureCandidate(..), &ParamCandidate(..)) |\n-            (&FnPointerCandidate(..), &ParamCandidate(..)) |\n-            (&BuiltinObjectCandidate(..), &ParamCandidate(_)) |\n-            (&BuiltinCandidate(..), &ParamCandidate(..)) => {\n-                // We basically prefer always prefer to use a\n-                // where-clause over another option. Where clauses\n-                // impose the burden of finding the exact match onto\n-                // the caller. Using an impl in preference of a where\n-                // clause can also lead us to \"overspecialize\", as in\n-                // #18453.\n-                true\n-            }\n-            (&ImplCandidate(..), &ObjectCandidate(..)) => {\n-                // This means that we are matching an object of type\n-                // `Trait` against the trait `Trait`. In that case, we\n-                // always prefer to use the object vtable over the\n-                // impl. Like a where clause, the impl may or may not\n-                // be the one that is used by the object (because the\n-                // impl may have additional where-clauses that the\n-                // object's source might not meet) -- if it is, using\n-                // the vtable is fine. If it is not, using the vtable\n-                // is good. A win win!\n-                true\n-            }\n-            (&DefaultImplCandidate(_), _) => {\n-                // Prefer other candidates over default implementations.\n-                self.tcx().sess.bug(\n-                    \"default implementations shouldn't be recorded \\\n-                     when there are other valid candidates\");\n-            }\n-            (&ProjectionCandidate, &ParamCandidate(_)) => {\n-                // FIXME(#20297) -- this gives where clauses precedent\n-                // over projections. Really these are just two means\n-                // of deducing information (one based on the where\n-                // clauses on the trait definition; one based on those\n-                // on the enclosing scope), and it'd be better to\n-                // integrate them more intelligently. But for now this\n-                // seems ok. If we DON'T give where clauses\n-                // precedence, we run into trouble in default methods,\n-                // where both the projection bounds for `Self::A` and\n-                // the where clauses are in scope.\n-                true\n-            }\n-            _ => {\n-                false\n-            }\n+        match other {\n+            &ObjectCandidate(..) |\n+            &ParamCandidate(_) | &ProjectionCandidate => match victim {\n+                &DefaultImplCandidate(..) => {\n+                    self.tcx().sess.bug(\n+                        \"default implementations shouldn't be recorded \\\n+                         when there are other valid candidates\");\n+                }\n+                &PhantomFnCandidate => {\n+                    self.tcx().sess.bug(\"PhantomFn didn't short-circuit selection\");\n+                }\n+                &ImplCandidate(..) |\n+                &ClosureCandidate(..) |\n+                &FnPointerCandidate(..) |\n+                &BuiltinObjectCandidate(..) |\n+                &DefaultImplObjectCandidate(..) |\n+                &BuiltinCandidate(..) => {\n+                    // We have a where-clause so don't go around looking\n+                    // for impls.\n+                    true\n+                }\n+                &ObjectCandidate(..) |\n+                &ProjectionCandidate => {\n+                    // Arbitrarily give param candidates priority\n+                    // over projection and object candidates.\n+                    true\n+                },\n+                &ParamCandidate(..) => false,\n+                &ErrorCandidate => false // propagate errors\n+            },\n+            _ => false\n         }\n     }\n "}, {"sha": "21e5129844498412759ad5ac2f20454a07a98cea", "filename": "src/test/run-pass/issue-23336.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165/src%2Ftest%2Frun-pass%2Fissue-23336.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165/src%2Ftest%2Frun-pass%2Fissue-23336.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23336.rs?ref=f2e1a1b50eee3dd98bbd760d71ae7b5fce360165", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Data { fn doit(&self) {} }\n+impl<T> Data for T {}\n+pub trait UnaryLogic { type D: Data; }\n+impl UnaryLogic for () { type D = i32; }\n+\n+pub fn crashes<T: UnaryLogic>(t: T::D) {\n+    t.doit();\n+}\n+\n+fn main() { crashes::<()>(0); }"}]}