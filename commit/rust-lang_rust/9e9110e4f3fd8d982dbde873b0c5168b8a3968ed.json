{"sha": "9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "node_id": "C_kwDOAAsO6NoAKDllOTExMGU0ZjNmZDhkOTgyZGJkZTg3M2IwYzUxNjhiOGEzOTY4ZWQ", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-11T19:31:35Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-23T01:35:32Z"}, "message": "Remove final reference on fields and method calls in `needless_borrow`", "tree": {"sha": "060de539571b72d5b8cd8e415b5b2387d2826176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/060de539571b72d5b8cd8e415b5b2387d2826176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "html_url": "https://github.com/rust-lang/rust/commit/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15c068ed0f4d231beabb22975cbca7fd33996ce5", "url": "https://api.github.com/repos/rust-lang/rust/commits/15c068ed0f4d231beabb22975cbca7fd33996ce5", "html_url": "https://github.com/rust-lang/rust/commit/15c068ed0f4d231beabb22975cbca7fd33996ce5"}], "stats": {"total": 848, "additions": 485, "deletions": 363}, "files": [{"sha": "8e65a799eaddd56990f9533eed222c130b79307f", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -981,7 +981,7 @@ Released 2021-03-25\n   [#6532](https://github.com/rust-lang/rust-clippy/pull/6532)\n * [`single_match`] Suggest `if` over `if let` when possible\n   [#6574](https://github.com/rust-lang/rust-clippy/pull/6574)\n-* [`ref_in_deref`] Use parentheses correctly in suggestion\n+* `ref_in_deref` Use parentheses correctly in suggestion\n   [#6609](https://github.com/rust-lang/rust-clippy/pull/6609)\n * [`stable_sort_primitive`] Clarify error message\n   [#6611](https://github.com/rust-lang/rust-clippy/pull/6611)"}, {"sha": "70f456465963c8eb1255d592be0e1789cb628e52", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 135, "deletions": 77, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::sugg::has_enclosing_paren;\n use clippy_utils::ty::peel_mid_ty_refs;\n use clippy_utils::{get_parent_expr, get_parent_node, is_lint_allowed, path_to_local};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n@@ -130,8 +131,6 @@ pub struct Dereferencing {\n struct StateData {\n     /// Span of the top level expression\n     span: Span,\n-    /// The required mutability\n-    target_mut: Mutability,\n }\n \n enum State {\n@@ -140,9 +139,13 @@ enum State {\n         // The number of calls in a sequence which changed the referenced type\n         ty_changed_count: usize,\n         is_final_ufcs: bool,\n+        /// The required mutability\n+        target_mut: Mutability,\n     },\n     DerefedBorrow {\n-        count: u32,\n+        count: usize,\n+        required_precedence: i8,\n+        msg: &'static str,\n     },\n }\n \n@@ -213,77 +216,98 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     1\n                                 },\n                                 is_final_ufcs: matches!(expr.kind, ExprKind::Call(..)),\n-                            },\n-                            StateData {\n-                                span: expr.span,\n                                 target_mut,\n                             },\n+                            StateData { span: expr.span },\n                         ));\n                     },\n                     RefOp::AddrOf => {\n                         // Find the number of times the borrow is auto-derefed.\n                         let mut iter = find_adjustments(cx.tcx, typeck, expr).iter();\n-                        if let Some((i, adjust)) = iter.by_ref().enumerate().find_map(|(i, adjust)| {\n-                            if !matches!(adjust.kind, Adjust::Deref(_)) {\n-                                Some((i, Some(adjust)))\n-                            } else if !adjust.target.is_ref() {\n-                                // Include the current deref.\n-                                Some((i + 1, None))\n-                            } else {\n-                                None\n-                            }\n-                        }) {\n-                            if i > 1 {\n-                                // If the next adjustment is a mutable borrow, then check to see if the compiler will\n-                                // insert a re-borrow here. If not, leave an extra borrow here to avoid attempting to\n-                                // move the a mutable reference.\n-                                let (i, target_mut) = if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n-                                    adjust.or_else(|| iter.next()).map(|a| &a.kind)\n-                                {\n-                                    if matches!(mutability, AutoBorrowMutability::Mut { .. })\n-                                        && !is_auto_reborrow_position(parent, expr.hir_id)\n-                                    {\n-                                        (i - 1, Mutability::Mut)\n-                                    } else {\n-                                        (i, mutability.into())\n+                        let mut deref_count = 0usize;\n+                        let next_adjust = loop {\n+                            match iter.next() {\n+                                Some(adjust) => {\n+                                    if !matches!(adjust.kind, Adjust::Deref(_)) {\n+                                        break Some(adjust);\n+                                    } else if !adjust.target.is_ref() {\n+                                        deref_count += 1;\n+                                        break iter.next();\n                                     }\n-                                } else {\n-                                    (\n-                                        i,\n-                                        iter.find_map(|adjust| match adjust.kind {\n-                                            Adjust::Borrow(AutoBorrow::Ref(_, m)) => Some(m.into()),\n-                                            _ => None,\n-                                        })\n-                                        // This default should never happen. Auto-deref always reborrows.\n-                                        .unwrap_or(Mutability::Not),\n-                                    )\n-                                };\n-\n-                                if i > 1 {\n-                                    self.state = Some((\n-                                        // Subtract one for the current borrow expression, and one to cover the last\n-                                        // reference which can't be removed (it's either reborrowed, or needed for\n-                                        // auto-deref to happen).\n-                                        State::DerefedBorrow {\n-                                        count:\n-                                            // Truncation here would require more than a `u32::MAX` level reference. The compiler\n-                                            // does not support this.\n-                                            #[allow(clippy::cast_possible_truncation)]\n-                                            { i as u32 - 2 }\n-                                    },\n-                                        StateData {\n-                                            span: expr.span,\n-                                            target_mut,\n-                                        },\n-                                    ));\n-                                }\n+                                    deref_count += 1;\n+                                },\n+                                None => break None,\n+                            };\n+                        };\n+\n+                        // Determine the required number of references before any can be removed. In all cases the\n+                        // reference made by the current expression will be removed. After that there are four cases to\n+                        // handle.\n+                        //\n+                        // 1. Auto-borrow will trigger in the current position, so no further references are required.\n+                        // 2. Auto-deref ends at a reference, or the underlying type, so one extra needs to be left to\n+                        //    handle the automatically inserted re-borrow.\n+                        // 3. Auto-deref hits a user-defined `Deref` impl, so at least one reference needs to exist to\n+                        //    start auto-deref.\n+                        // 4. If the chain of non-user-defined derefs ends with a mutable re-borrow, and re-borrow\n+                        //    adjustments will not be inserted automatically, then leave one further reference to avoid\n+                        //    moving a mutable borrow.\n+                        //    e.g.\n+                        //        fn foo<T>(x: &mut Option<&mut T>, y: &mut T) {\n+                        //            let x = match x {\n+                        //                // Removing the borrow will cause `x` to be moved\n+                        //                Some(x) => &mut *x,\n+                        //                None => y\n+                        //            };\n+                        //        }\n+                        let deref_msg =\n+                            \"this expression creates a reference which is immediately dereferenced by the compiler\";\n+                        let borrow_msg = \"this expression borrows a value the compiler would automatically borrow\";\n+\n+                        let (required_refs, required_precedence, msg) = if is_auto_borrow_position(parent, expr.hir_id)\n+                        {\n+                            (1, PREC_POSTFIX, if deref_count == 1 { borrow_msg } else { deref_msg })\n+                        } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n+                            next_adjust.map(|a| &a.kind)\n+                        {\n+                            if matches!(mutability, AutoBorrowMutability::Mut { .. })\n+                                && !is_auto_reborrow_position(parent)\n+                            {\n+                                (3, 0, deref_msg)\n+                            } else {\n+                                (2, 0, deref_msg)\n                             }\n+                        } else {\n+                            (2, 0, deref_msg)\n+                        };\n+\n+                        if deref_count >= required_refs {\n+                            self.state = Some((\n+                                State::DerefedBorrow {\n+                                    // One of the required refs is for the current borrow expression, the remaining ones\n+                                    // can't be removed without breaking the code. See earlier comment.\n+                                    count: deref_count - required_refs,\n+                                    required_precedence,\n+                                    msg,\n+                                },\n+                                StateData { span: expr.span },\n+                            ));\n                         }\n                     },\n                     _ => (),\n                 }\n             },\n-            (Some((State::DerefMethod { ty_changed_count, .. }, data)), RefOp::Method(_)) => {\n+            (\n+                Some((\n+                    State::DerefMethod {\n+                        target_mut,\n+                        ty_changed_count,\n+                        ..\n+                    },\n+                    data,\n+                )),\n+                RefOp::Method(_),\n+            ) => {\n                 self.state = Some((\n                     State::DerefMethod {\n                         ty_changed_count: if deref_method_same_type(typeck.expr_ty(expr), typeck.expr_ty(sub_expr)) {\n@@ -292,12 +316,30 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             ty_changed_count + 1\n                         },\n                         is_final_ufcs: matches!(expr.kind, ExprKind::Call(..)),\n+                        target_mut,\n                     },\n                     data,\n                 ));\n             },\n-            (Some((State::DerefedBorrow { count }, data)), RefOp::AddrOf) if count != 0 => {\n-                self.state = Some((State::DerefedBorrow { count: count - 1 }, data));\n+            (\n+                Some((\n+                    State::DerefedBorrow {\n+                        count,\n+                        required_precedence,\n+                        msg,\n+                    },\n+                    data,\n+                )),\n+                RefOp::AddrOf,\n+            ) if count != 0 => {\n+                self.state = Some((\n+                    State::DerefedBorrow {\n+                        count: count - 1,\n+                        required_precedence,\n+                        msg,\n+                    },\n+                    data,\n+                ));\n             },\n \n             (Some((state, data)), _) => report(cx, expr, state, data),\n@@ -475,18 +517,28 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n \n /// Checks if the given expression is in a position which can be auto-reborrowed.\n /// Note: This is only correct assuming auto-deref is already occurring.\n-fn is_auto_reborrow_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n+fn is_auto_reborrow_position(parent: Option<Node<'_>>) -> bool {\n     match parent {\n-        Some(Node::Expr(parent)) => match parent.kind {\n-            ExprKind::MethodCall(..) => true,\n-            ExprKind::Call(callee, _) => callee.hir_id != child_id,\n-            _ => false,\n-        },\n+        Some(Node::Expr(parent)) => matches!(parent.kind, ExprKind::MethodCall(..) | ExprKind::Call(..)),\n         Some(Node::Local(_)) => true,\n         _ => false,\n     }\n }\n \n+/// Checks if the given expression is a position which can auto-borrow.\n+fn is_auto_borrow_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n+    if let Some(Node::Expr(parent)) = parent {\n+        match parent.kind {\n+            ExprKind::MethodCall(_, _, [self_arg, ..], _) => self_arg.hir_id == child_id,\n+            ExprKind::Field(..) => true,\n+            ExprKind::Call(f, _) => f.hir_id == child_id,\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n /// Adjustments are sometimes made in the parent block rather than the expression itself.\n fn find_adjustments<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -535,6 +587,7 @@ fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData)\n         State::DerefMethod {\n             ty_changed_count,\n             is_final_ufcs,\n+            target_mut,\n         } => {\n             let mut app = Applicability::MachineApplicable;\n             let (expr_str, expr_is_macro_call) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n@@ -549,12 +602,12 @@ fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData)\n             };\n             let addr_of_str = if ty_changed_count < ref_count {\n                 // Check if a reborrow from &mut T -> &T is required.\n-                if data.target_mut == Mutability::Not && matches!(ty.kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                if target_mut == Mutability::Not && matches!(ty.kind(), ty::Ref(_, _, Mutability::Mut)) {\n                     \"&*\"\n                 } else {\n                     \"\"\n                 }\n-            } else if data.target_mut == Mutability::Mut {\n+            } else if target_mut == Mutability::Mut {\n                 \"&mut \"\n             } else {\n                 \"&\"\n@@ -570,7 +623,7 @@ fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData)\n                 cx,\n                 EXPLICIT_DEREF_METHODS,\n                 data.span,\n-                match data.target_mut {\n+                match target_mut {\n                     Mutability::Not => \"explicit `deref` method call\",\n                     Mutability::Mut => \"explicit `deref_mut` method call\",\n                 },\n@@ -579,19 +632,24 @@ fn report(cx: &LateContext<'_>, expr: &Expr<'_>, state: State, data: StateData)\n                 app,\n             );\n         },\n-        State::DerefedBorrow { .. } => {\n+        State::DerefedBorrow {\n+            required_precedence,\n+            msg,\n+            ..\n+        } => {\n             let mut app = Applicability::MachineApplicable;\n             let snip = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app).0;\n             span_lint_and_sugg(\n                 cx,\n                 NEEDLESS_BORROW,\n                 data.span,\n-                &format!(\n-                    \"this expression borrows a reference (`{}`) that is immediately dereferenced by the compiler\",\n-                    cx.typeck_results().expr_ty(expr),\n-                ),\n+                msg,\n                 \"change this to\",\n-                snip.into(),\n+                if required_precedence > expr.precedence().order() && !has_enclosing_paren(&snip) {\n+                    format!(\"({})\", snip)\n+                } else {\n+                    snip.into()\n+                },\n                 app,\n             );\n         },"}, {"sha": "2818b3e006a5bd4c83110aaa3e494d9c509ccf23", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -179,7 +179,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                             )\n                             .and_then(|snip| {\n                                 let i = snip.find(\"fn\")?;\n-                                Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n+                                Some(item.span.lo() + BytePos((i + snip[i..].find('(')?) as u32))\n                             })\n                             .expect(\"failed to create span for type parameters\");\n                             Span::new(pos, pos, item.span.ctxt(), item.span.parent())"}, {"sha": "b446cf9b6c29d3a4e17ea42cdeb648d2d12d7c7a", "filename": "clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/clippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/clippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foctal_escapes.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -101,7 +101,7 @@ fn check_lit(cx: &EarlyContext<'_>, lit: &Lit, span: Span, is_string: bool) {\n         // construct a replacement escape\n         // the maximum value is \\077, or \\x3f, so u8 is sufficient here\n         if let Ok(n) = u8::from_str_radix(&contents[from + 1..to], 8) {\n-            write!(&mut suggest_1, \"\\\\x{:02x}\", n).unwrap();\n+            write!(suggest_1, \"\\\\x{:02x}\", n).unwrap();\n         }\n \n         // append the null byte as \\x00 and the following digits literally"}, {"sha": "be1928045b8f8b50a95ed18a7d496efe7cb2ea92", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -388,7 +388,7 @@ fn binop_to_string(op: AssocOp, lhs: &str, rhs: &str) -> String {\n }\n \n /// Return `true` if `sugg` is enclosed in parenthesis.\n-fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n+pub fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n     let mut chars = sugg.as_ref().chars();\n     if chars.next() == Some('(') {\n         let mut depth = 1;"}, {"sha": "d3ad26921bffa8d4d15db41f488b73d30f8681d7", "filename": "tests/ui/bytecount.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytecount.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,3 +1,5 @@\n+#![allow(clippy::needless_borrow)]\n+\n #[deny(clippy::naive_bytecount)]\n fn main() {\n     let x = vec![0_u8; 16];"}, {"sha": "68d838c1f828aa550a01573b87a0dc75d76425cc", "filename": "tests/ui/bytecount.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fbytecount.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fbytecount.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytecount.stderr?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,23 +1,23 @@\n error: you appear to be counting bytes the naive way\n-  --> $DIR/bytecount.rs:5:13\n+  --> $DIR/bytecount.rs:7:13\n    |\n LL |     let _ = x.iter().filter(|&&a| a == 0).count(); // naive byte count\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the bytecount crate: `bytecount::count(x, 0)`\n    |\n note: the lint level is defined here\n-  --> $DIR/bytecount.rs:1:8\n+  --> $DIR/bytecount.rs:3:8\n    |\n LL | #[deny(clippy::naive_bytecount)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: you appear to be counting bytes the naive way\n-  --> $DIR/bytecount.rs:7:13\n+  --> $DIR/bytecount.rs:9:13\n    |\n LL |     let _ = (&x[..]).iter().filter(|&a| *a == 0).count(); // naive byte count\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the bytecount crate: `bytecount::count((&x[..]), 0)`\n \n error: you appear to be counting bytes the naive way\n-  --> $DIR/bytecount.rs:19:13\n+  --> $DIR/bytecount.rs:21:13\n    |\n LL |     let _ = x.iter().filter(|a| b + 1 == **a).count(); // naive byte count\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the bytecount crate: `bytecount::count(x, b + 1)`"}, {"sha": "dc062762604e063a4d1dac5f9554a7276898e65e", "filename": "tests/ui/clone_on_copy.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fclone_on_copy.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fclone_on_copy.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.fixed?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -7,7 +7,8 @@\n     clippy::no_effect,\n     clippy::unnecessary_operation,\n     clippy::vec_init_then_push,\n-    clippy::toplevel_ref_arg\n+    clippy::toplevel_ref_arg,\n+    clippy::needless_borrow\n )]\n \n use std::cell::RefCell;"}, {"sha": "8c39d0d55dd8bdbf23e48a37bdd194bbd930cc6b", "filename": "tests/ui/clone_on_copy.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -7,7 +7,8 @@\n     clippy::no_effect,\n     clippy::unnecessary_operation,\n     clippy::vec_init_then_push,\n-    clippy::toplevel_ref_arg\n+    clippy::toplevel_ref_arg,\n+    clippy::needless_borrow\n )]\n \n use std::cell::RefCell;"}, {"sha": "861543d0aa904566aac464ca4071ddd23aee4153", "filename": "tests/ui/clone_on_copy.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fclone_on_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fclone_on_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.stderr?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,49 +1,49 @@\n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:24:5\n+  --> $DIR/clone_on_copy.rs:25:5\n    |\n LL |     42.clone();\n    |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n    |\n    = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:28:5\n+  --> $DIR/clone_on_copy.rs:29:5\n    |\n LL |     (&42).clone();\n    |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:31:5\n+  --> $DIR/clone_on_copy.rs:32:5\n    |\n LL |     rc.borrow().clone();\n    |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n \n error: using `clone` on type `u32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:34:5\n+  --> $DIR/clone_on_copy.rs:35:5\n    |\n LL |     x.clone().rotate_left(1);\n    |     ^^^^^^^^^ help: try removing the `clone` call: `x`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:48:5\n+  --> $DIR/clone_on_copy.rs:49:5\n    |\n LL |     m!(42).clone();\n    |     ^^^^^^^^^^^^^^ help: try removing the `clone` call: `m!(42)`\n \n error: using `clone` on type `[u32; 2]` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:58:5\n+  --> $DIR/clone_on_copy.rs:59:5\n    |\n LL |     x.clone()[0];\n    |     ^^^^^^^^^ help: try dereferencing it: `(*x)`\n \n error: using `clone` on type `char` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:68:14\n+  --> $DIR/clone_on_copy.rs:69:14\n    |\n LL |     is_ascii('z'.clone());\n    |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:72:14\n+  --> $DIR/clone_on_copy.rs:73:14\n    |\n LL |     vec.push(42.clone());\n    |              ^^^^^^^^^^ help: try removing the `clone` call: `42`"}, {"sha": "d92b8998e8805c2b0da6e1648ede17b1c0e71578", "filename": "tests/ui/duration_subsec.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fduration_subsec.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fduration_subsec.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fduration_subsec.fixed?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::needless_borrow)]\n #![warn(clippy::duration_subsec)]\n \n use std::time::Duration;"}, {"sha": "08da804996d1b5660db6a9bb91c6e6a4141c6b72", "filename": "tests/ui/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fduration_subsec.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::needless_borrow)]\n #![warn(clippy::duration_subsec)]\n \n use std::time::Duration;"}, {"sha": "618f80cdcf84923d9ca035b35e177c9cc22079e4", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -5,13 +5,10 @@\n     clippy::no_effect,\n     clippy::redundant_closure_call,\n     clippy::needless_pass_by_value,\n-    clippy::option_map_unit_fn\n-)]\n-#![warn(\n-    clippy::redundant_closure,\n-    clippy::redundant_closure_for_method_calls,\n+    clippy::option_map_unit_fn,\n     clippy::needless_borrow\n )]\n+#![warn(clippy::redundant_closure, clippy::redundant_closure_for_method_calls)]\n \n use std::path::{Path, PathBuf};\n \n@@ -34,7 +31,7 @@ fn main() {\n     Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n     let _: Option<Vec<u8>> = true.then(std::vec::Vec::new); // special case vec!\n     let d = Some(1u8).map(|a| foo(foo2(a))); //is adjusted?\n-    all(&[1, 2, 3], &2, below); //is adjusted\n+    all(&[1, 2, 3], &&2, below); //is adjusted\n     unsafe {\n         Some(1u8).map(|a| unsafe_fn(a)); // unsafe fn\n     }"}, {"sha": "a759e6eb514b42bacb0254c704fe251902711890", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -5,13 +5,10 @@\n     clippy::no_effect,\n     clippy::redundant_closure_call,\n     clippy::needless_pass_by_value,\n-    clippy::option_map_unit_fn\n-)]\n-#![warn(\n-    clippy::redundant_closure,\n-    clippy::redundant_closure_for_method_calls,\n+    clippy::option_map_unit_fn,\n     clippy::needless_borrow\n )]\n+#![warn(clippy::redundant_closure, clippy::redundant_closure_for_method_calls)]\n \n use std::path::{Path, PathBuf};\n "}, {"sha": "cda84982c9b7508020113a57acf2474077147971", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,134 +1,126 @@\n error: redundant closure\n-  --> $DIR/eta.rs:31:27\n+  --> $DIR/eta.rs:28:27\n    |\n LL |     let a = Some(1u8).map(|a| foo(a));\n    |                           ^^^^^^^^^^ help: replace the closure with the function itself: `foo`\n    |\n    = note: `-D clippy::redundant-closure` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:35:40\n+  --> $DIR/eta.rs:32:40\n    |\n LL |     let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n    |                                        ^^^^^^^^^ help: replace the closure with `Vec::new`: `std::vec::Vec::new`\n \n error: redundant closure\n-  --> $DIR/eta.rs:36:35\n+  --> $DIR/eta.rs:33:35\n    |\n LL |     let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n    |                                   ^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo2`\n \n-error: this expression borrows a reference (`&u8`) that is immediately dereferenced by the compiler\n-  --> $DIR/eta.rs:37:21\n-   |\n-LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n-   |                     ^^^ help: change this to: `&2`\n-   |\n-   = note: `-D clippy::needless-borrow` implied by `-D warnings`\n-\n error: redundant closure\n-  --> $DIR/eta.rs:37:26\n+  --> $DIR/eta.rs:34:26\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n    |                          ^^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `below`\n \n error: redundant closure\n-  --> $DIR/eta.rs:43:27\n+  --> $DIR/eta.rs:40:27\n    |\n LL |     let e = Some(1u8).map(|a| divergent(a));\n    |                           ^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `divergent`\n \n error: redundant closure\n-  --> $DIR/eta.rs:44:27\n+  --> $DIR/eta.rs:41:27\n    |\n LL |     let e = Some(1u8).map(|a| generic(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `generic`\n \n error: redundant closure\n-  --> $DIR/eta.rs:90:51\n+  --> $DIR/eta.rs:87:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n    |                                                   ^^^^^^^^^^^ help: replace the closure with the method itself: `TestStruct::foo`\n    |\n    = note: `-D clippy::redundant-closure-for-method-calls` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:91:51\n+  --> $DIR/eta.rs:88:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n    |                                                   ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `TestTrait::trait_foo`\n \n error: redundant closure\n-  --> $DIR/eta.rs:93:42\n+  --> $DIR/eta.rs:90:42\n    |\n LL |     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n    |                                          ^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::vec::Vec::clear`\n \n error: redundant closure\n-  --> $DIR/eta.rs:97:29\n+  --> $DIR/eta.rs:94:29\n    |\n LL |     let e = Some(\"str\").map(|s| s.to_string());\n    |                             ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::string::ToString::to_string`\n \n error: redundant closure\n-  --> $DIR/eta.rs:98:27\n+  --> $DIR/eta.rs:95:27\n    |\n LL |     let e = Some('a').map(|s| s.to_uppercase());\n    |                           ^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:100:65\n+  --> $DIR/eta.rs:97:65\n    |\n LL |     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n    |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_ascii_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:163:22\n+  --> $DIR/eta.rs:160:22\n    |\n LL |     requires_fn_once(|| x());\n    |                      ^^^^^^ help: replace the closure with the function itself: `x`\n \n error: redundant closure\n-  --> $DIR/eta.rs:170:27\n+  --> $DIR/eta.rs:167:27\n    |\n LL |     let a = Some(1u8).map(|a| foo_ptr(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo_ptr`\n \n error: redundant closure\n-  --> $DIR/eta.rs:175:27\n+  --> $DIR/eta.rs:172:27\n    |\n LL |     let a = Some(1u8).map(|a| closure(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `closure`\n \n error: redundant closure\n-  --> $DIR/eta.rs:207:28\n+  --> $DIR/eta.rs:204:28\n    |\n LL |     x.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:208:28\n+  --> $DIR/eta.rs:205:28\n    |\n LL |     y.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:209:28\n+  --> $DIR/eta.rs:206:28\n    |\n LL |     z.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:216:21\n+  --> $DIR/eta.rs:213:21\n    |\n LL |         Some(1).map(|n| closure(n));\n    |                     ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut closure`\n \n error: redundant closure\n-  --> $DIR/eta.rs:235:21\n+  --> $DIR/eta.rs:232:21\n    |\n LL |     map_str_to_path(|s| s.as_ref());\n    |                     ^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::convert::AsRef::as_ref`\n \n-error: aborting due to 21 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "aa69781d15a6bc40f6222382fb0fe4d85c1a8b1f", "filename": "tests/ui/for_loop_fixable.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Ffor_loop_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Ffor_loop_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.fixed?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -23,7 +23,12 @@ impl Unrelated {\n     clippy::iter_next_loop,\n     clippy::for_kv_map\n )]\n-#[allow(clippy::linkedlist, clippy::unnecessary_mut_passed, clippy::similar_names)]\n+#[allow(\n+    clippy::linkedlist,\n+    clippy::unnecessary_mut_passed,\n+    clippy::similar_names,\n+    clippy::needless_borrow\n+)]\n #[allow(unused_variables)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];"}, {"sha": "7c063d99511d81950720ef67753c78f0cba81318", "filename": "tests/ui/for_loop_fixable.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Ffor_loop_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Ffor_loop_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -23,7 +23,12 @@ impl Unrelated {\n     clippy::iter_next_loop,\n     clippy::for_kv_map\n )]\n-#[allow(clippy::linkedlist, clippy::unnecessary_mut_passed, clippy::similar_names)]\n+#[allow(\n+    clippy::linkedlist,\n+    clippy::unnecessary_mut_passed,\n+    clippy::similar_names,\n+    clippy::needless_borrow\n+)]\n #[allow(unused_variables)]\n fn main() {\n     let mut vec = vec![1, 2, 3, 4];"}, {"sha": "ddfe66d675f91efbc8f070116c570ef9eda5a496", "filename": "tests/ui/for_loop_fixable.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Ffor_loop_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Ffor_loop_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loop_fixable.stderr?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,93 +1,93 @@\n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:38:15\n+  --> $DIR/for_loop_fixable.rs:43:15\n    |\n LL |     for _v in vec.iter() {}\n    |               ^^^^^^^^^^ help: to write this more concisely, try: `&vec`\n    |\n    = note: `-D clippy::explicit-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:40:15\n+  --> $DIR/for_loop_fixable.rs:45:15\n    |\n LL |     for _v in vec.iter_mut() {}\n    |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&mut vec`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:43:15\n+  --> $DIR/for_loop_fixable.rs:48:15\n    |\n LL |     for _v in out_vec.into_iter() {}\n    |               ^^^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `out_vec`\n    |\n    = note: `-D clippy::explicit-into-iter-loop` implied by `-D warnings`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:48:15\n+  --> $DIR/for_loop_fixable.rs:53:15\n    |\n LL |     for _v in [1, 2, 3].iter() {}\n    |               ^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[1, 2, 3]`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:52:15\n+  --> $DIR/for_loop_fixable.rs:57:15\n    |\n LL |     for _v in [0; 32].iter() {}\n    |               ^^^^^^^^^^^^^^ help: to write this more concisely, try: `&[0; 32]`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:57:15\n+  --> $DIR/for_loop_fixable.rs:62:15\n    |\n LL |     for _v in ll.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&ll`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:60:15\n+  --> $DIR/for_loop_fixable.rs:65:15\n    |\n LL |     for _v in vd.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&vd`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:63:15\n+  --> $DIR/for_loop_fixable.rs:68:15\n    |\n LL |     for _v in bh.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bh`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:66:15\n+  --> $DIR/for_loop_fixable.rs:71:15\n    |\n LL |     for _v in hm.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&hm`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:69:15\n+  --> $DIR/for_loop_fixable.rs:74:15\n    |\n LL |     for _v in bt.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bt`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:72:15\n+  --> $DIR/for_loop_fixable.rs:77:15\n    |\n LL |     for _v in hs.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&hs`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:75:15\n+  --> $DIR/for_loop_fixable.rs:80:15\n    |\n LL |     for _v in bs.iter() {}\n    |               ^^^^^^^^^ help: to write this more concisely, try: `&bs`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:250:18\n+  --> $DIR/for_loop_fixable.rs:255:18\n    |\n LL |         for i in iterator.into_iter() {\n    |                  ^^^^^^^^^^^^^^^^^^^^ help: to write this more concisely, try: `iterator`\n \n error: it is more concise to loop over references to containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:270:18\n+  --> $DIR/for_loop_fixable.rs:275:18\n    |\n LL |         for _ in t.into_iter() {}\n    |                  ^^^^^^^^^^^^^ help: to write this more concisely, try: `&t`\n \n error: it is more concise to loop over containers instead of using explicit iteration methods\n-  --> $DIR/for_loop_fixable.rs:272:18\n+  --> $DIR/for_loop_fixable.rs:277:18\n    |\n LL |         for _ in r.into_iter() {}\n    |                  ^^^^^^^^^^^^^ help: to write this more concisely, try: `r`"}, {"sha": "b856f1375d303ad11520922ae7a78fc9e359c0be", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -62,6 +62,16 @@ fn main() {\n     };\n \n     *x = 5;\n+\n+    let s = String::new();\n+    let _ = s.len();\n+    let _ = s.capacity();\n+    let _ = s.capacity();\n+\n+    let x = (1, 2);\n+    let _ = x.0;\n+    let x = &x as *const (i32, i32);\n+    let _ = unsafe { (*x).0 };\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "0bfe222a3dc170ee85bf20f1e2fadb2766891560", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -62,6 +62,16 @@ fn main() {\n     };\n \n     *x = 5;\n+\n+    let s = String::new();\n+    let _ = (&s).len();\n+    let _ = (&s).capacity();\n+    let _ = (&&s).capacity();\n+\n+    let x = (1, 2);\n+    let _ = (&x).0;\n+    let x = &x as *const (i32, i32);\n+    let _ = unsafe { (&*x).0 };\n }\n \n #[allow(clippy::needless_borrowed_reference)]"}, {"sha": "e67718879ecb253dfd22cbad4252cb1e81fd1007", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 59, "deletions": 15, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,88 +1,132 @@\n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: creating a reference that is immediately dereferenced\n+  --> $DIR/needless_borrow.rs:72:13\n+   |\n+LL |     let _ = (&x).0;\n+   |             ^^^^ help: try this: `x`\n+   |\n+   = note: `-D clippy::ref-in-deref` implied by `-D warnings`\n+\n+error: creating a reference that is immediately dereferenced\n+  --> $DIR/needless_borrow.rs:74:22\n+   |\n+LL |     let _ = unsafe { (&*x).0 };\n+   |                      ^^^^^ help: try this: `(*x)`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:9:15\n    |\n LL |     let _ = x(&&a); // warn\n    |               ^^^ help: change this to: `&a`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:13:13\n    |\n LL |     mut_ref(&mut &mut b); // warn\n    |             ^^^^^^^^^^^ help: change this to: `&mut b`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:25:13\n    |\n LL |             &&a\n    |             ^^^ help: change this to: `&a`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:27:15\n    |\n LL |         46 => &&a,\n    |               ^^^ help: change this to: `&a`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:33:27\n    |\n LL |                     break &ref_a;\n    |                           ^^^^^^ help: change this to: `ref_a`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:40:15\n    |\n LL |     let _ = x(&&&a);\n    |               ^^^^ help: change this to: `&a`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:41:15\n    |\n LL |     let _ = x(&mut &&a);\n    |               ^^^^^^^^ help: change this to: `&a`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:42:15\n    |\n LL |     let _ = x(&&&mut b);\n    |               ^^^^^^^^ help: change this to: `&mut b`\n \n-error: this expression borrows a reference (`&i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:43:15\n    |\n LL |     let _ = x(&&ref_a);\n    |               ^^^^^^^ help: change this to: `ref_a`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:46:11\n    |\n LL |         x(&b);\n    |           ^^ help: change this to: `b`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:53:13\n    |\n LL |     mut_ref(&mut x);\n    |             ^^^^^^ help: change this to: `x`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:54:13\n    |\n LL |     mut_ref(&mut &mut x);\n    |             ^^^^^^^^^^^ help: change this to: `x`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:55:23\n    |\n LL |     let y: &mut i32 = &mut x;\n    |                       ^^^^^^ help: change this to: `x`\n \n-error: this expression borrows a reference (`&mut i32`) that is immediately dereferenced by the compiler\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n   --> $DIR/needless_borrow.rs:56:23\n    |\n LL |     let y: &mut i32 = &mut &mut x;\n    |                       ^^^^^^^^^^^ help: change this to: `x`\n \n-error: aborting due to 14 previous errors\n+error: this expression borrows a value the compiler would automatically borrow\n+  --> $DIR/needless_borrow.rs:67:13\n+   |\n+LL |     let _ = (&s).len();\n+   |             ^^^^ help: change this to: `s`\n+\n+error: this expression borrows a value the compiler would automatically borrow\n+  --> $DIR/needless_borrow.rs:68:13\n+   |\n+LL |     let _ = (&s).capacity();\n+   |             ^^^^ help: change this to: `s`\n+\n+error: this expression creates a reference which is immediately dereferenced by the compiler\n+  --> $DIR/needless_borrow.rs:69:13\n+   |\n+LL |     let _ = (&&s).capacity();\n+   |             ^^^^^ help: change this to: `s`\n+\n+error: this expression borrows a value the compiler would automatically borrow\n+  --> $DIR/needless_borrow.rs:72:13\n+   |\n+LL |     let _ = (&x).0;\n+   |             ^^^^ help: change this to: `x`\n+\n+error: this expression borrows a value the compiler would automatically borrow\n+  --> $DIR/needless_borrow.rs:74:22\n+   |\n+LL |     let _ = unsafe { (&*x).0 };\n+   |                      ^^^^^ help: change this to: `(*x)`\n+\n+error: aborting due to 21 previous errors\n "}, {"sha": "e431661d180deb443298780b3445becb2bd1fd2e", "filename": "tests/ui/useless_asref.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fuseless_asref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fuseless_asref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.fixed?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -67,7 +67,7 @@ fn not_ok() {\n         foo_rslice(mrrrrrslice);\n         foo_rslice(mrrrrrslice);\n     }\n-    #[allow(unused_parens, clippy::double_parens)]\n+    #[allow(unused_parens, clippy::double_parens, clippy::needless_borrow)]\n     foo_rrrrmr((&&&&MoreRef));\n \n     generic_not_ok(mrslice);"}, {"sha": "6ae931d7aa4812097f77622589501baaaf846b92", "filename": "tests/ui/useless_asref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -67,7 +67,7 @@ fn not_ok() {\n         foo_rslice(mrrrrrslice.as_ref());\n         foo_rslice(mrrrrrslice);\n     }\n-    #[allow(unused_parens, clippy::double_parens)]\n+    #[allow(unused_parens, clippy::double_parens, clippy::needless_borrow)]\n     foo_rrrrmr((&&&&MoreRef).as_ref());\n \n     generic_not_ok(mrslice);"}, {"sha": "4466917441162f49b14ae65722cac9f1a7ae6378", "filename": "tests/ui/write_literal.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -7,37 +7,37 @@ fn main() {\n     let mut v = Vec::new();\n \n     // these should be fine\n-    write!(&mut v, \"Hello\");\n-    writeln!(&mut v, \"Hello\");\n+    write!(v, \"Hello\");\n+    writeln!(v, \"Hello\");\n     let world = \"world\";\n-    writeln!(&mut v, \"Hello {}\", world);\n-    writeln!(&mut v, \"Hello {world}\", world = world);\n-    writeln!(&mut v, \"3 in hex is {:X}\", 3);\n-    writeln!(&mut v, \"2 + 1 = {:.4}\", 3);\n-    writeln!(&mut v, \"2 + 1 = {:5.4}\", 3);\n-    writeln!(&mut v, \"Debug test {:?}\", \"hello, world\");\n-    writeln!(&mut v, \"{0:8} {1:>8}\", \"hello\", \"world\");\n-    writeln!(&mut v, \"{1:8} {0:>8}\", \"hello\", \"world\");\n-    writeln!(&mut v, \"{foo:8} {bar:>8}\", foo = \"hello\", bar = \"world\");\n-    writeln!(&mut v, \"{bar:8} {foo:>8}\", foo = \"hello\", bar = \"world\");\n-    writeln!(&mut v, \"{number:>width$}\", number = 1, width = 6);\n-    writeln!(&mut v, \"{number:>0width$}\", number = 1, width = 6);\n-    writeln!(&mut v, \"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n-    writeln!(&mut v, \"10 / 4 is {}\", 2.5);\n-    writeln!(&mut v, \"2 + 1 = {}\", 3);\n+    writeln!(v, \"Hello {}\", world);\n+    writeln!(v, \"Hello {world}\", world = world);\n+    writeln!(v, \"3 in hex is {:X}\", 3);\n+    writeln!(v, \"2 + 1 = {:.4}\", 3);\n+    writeln!(v, \"2 + 1 = {:5.4}\", 3);\n+    writeln!(v, \"Debug test {:?}\", \"hello, world\");\n+    writeln!(v, \"{0:8} {1:>8}\", \"hello\", \"world\");\n+    writeln!(v, \"{1:8} {0:>8}\", \"hello\", \"world\");\n+    writeln!(v, \"{foo:8} {bar:>8}\", foo = \"hello\", bar = \"world\");\n+    writeln!(v, \"{bar:8} {foo:>8}\", foo = \"hello\", bar = \"world\");\n+    writeln!(v, \"{number:>width$}\", number = 1, width = 6);\n+    writeln!(v, \"{number:>0width$}\", number = 1, width = 6);\n+    writeln!(v, \"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n+    writeln!(v, \"10 / 4 is {}\", 2.5);\n+    writeln!(v, \"2 + 1 = {}\", 3);\n \n     // these should throw warnings\n-    write!(&mut v, \"Hello {}\", \"world\");\n-    writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n-    writeln!(&mut v, \"Hello {}\", \"world\");\n+    write!(v, \"Hello {}\", \"world\");\n+    writeln!(v, \"Hello {} {}\", world, \"world\");\n+    writeln!(v, \"Hello {}\", \"world\");\n \n     // positional args don't change the fact\n     // that we're using a literal -- this should\n     // throw a warning\n-    writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-    writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n+    writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+    writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n \n     // named args shouldn't change anything either\n-    writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-    writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+    writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+    writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n }"}, {"sha": "593e9493ec5904edacfc7eafd6277121141ac6a8", "filename": "tests/ui/write_literal.stderr", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.stderr?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,134 +1,134 @@\n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:30:32\n+  --> $DIR/write_literal.rs:30:27\n    |\n-LL |     write!(&mut v, \"Hello {}\", \"world\");\n-   |                                ^^^^^^^\n+LL |     write!(v, \"Hello {}\", \"world\");\n+   |                           ^^^^^^^\n    |\n    = note: `-D clippy::write-literal` implied by `-D warnings`\n help: try this\n    |\n-LL -     write!(&mut v, \"Hello {}\", \"world\");\n-LL +     write!(&mut v, \"Hello world\");\n+LL -     write!(v, \"Hello {}\", \"world\");\n+LL +     write!(v, \"Hello world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:31:44\n+  --> $DIR/write_literal.rs:31:39\n    |\n-LL |     writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n-   |                                            ^^^^^^^\n+LL |     writeln!(v, \"Hello {} {}\", world, \"world\");\n+   |                                       ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n-LL +     writeln!(&mut v, \"Hello {} world\", world);\n+LL -     writeln!(v, \"Hello {} {}\", world, \"world\");\n+LL +     writeln!(v, \"Hello {} world\", world);\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:32:34\n+  --> $DIR/write_literal.rs:32:29\n    |\n-LL |     writeln!(&mut v, \"Hello {}\", \"world\");\n-   |                                  ^^^^^^^\n+LL |     writeln!(v, \"Hello {}\", \"world\");\n+   |                             ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"Hello {}\", \"world\");\n-LL +     writeln!(&mut v, \"Hello world\");\n+LL -     writeln!(v, \"Hello {}\", \"world\");\n+LL +     writeln!(v, \"Hello world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:37:33\n+  --> $DIR/write_literal.rs:37:28\n    |\n-LL |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-   |                                 ^^^^^^^\n+LL |     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+   |                            ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-LL +     writeln!(&mut v, \"hello {1}\", \"world\");\n+LL -     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+LL +     writeln!(v, \"hello {1}\", \"world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:37:42\n+  --> $DIR/write_literal.rs:37:37\n    |\n-LL |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-   |                                          ^^^^^^^\n+LL |     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+   |                                     ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n-LL +     writeln!(&mut v, \"{0} world\", \"hello\");\n+LL -     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n+LL +     writeln!(v, \"{0} world\", \"hello\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:38:33\n+  --> $DIR/write_literal.rs:38:28\n    |\n-LL |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n-   |                                 ^^^^^^^\n+LL |     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n+   |                            ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n-LL +     writeln!(&mut v, \"{1} hello\", \"world\");\n+LL -     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n+LL +     writeln!(v, \"{1} hello\", \"world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:38:42\n+  --> $DIR/write_literal.rs:38:37\n    |\n-LL |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n-   |                                          ^^^^^^^\n+LL |     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n+   |                                     ^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n-LL +     writeln!(&mut v, \"world {0}\", \"hello\");\n+LL -     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n+LL +     writeln!(v, \"world {0}\", \"hello\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:41:37\n+  --> $DIR/write_literal.rs:41:32\n    |\n-LL |     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                     ^^^^^^^^^^^^^\n+LL |     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+   |                                ^^^^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(&mut v, \"hello {bar}\", bar = \"world\");\n+LL -     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+LL +     writeln!(v, \"hello {bar}\", bar = \"world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:41:52\n+  --> $DIR/write_literal.rs:41:47\n    |\n-LL |     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                                    ^^^^^^^^^^^^^\n+LL |     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+   |                                               ^^^^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(&mut v, \"{foo} world\", foo = \"hello\");\n+LL -     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n+LL +     writeln!(v, \"{foo} world\", foo = \"hello\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:42:37\n+  --> $DIR/write_literal.rs:42:32\n    |\n-LL |     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                     ^^^^^^^^^^^^^\n+LL |     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+   |                                ^^^^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(&mut v, \"{bar} hello\", bar = \"world\");\n+LL -     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+LL +     writeln!(v, \"{bar} hello\", bar = \"world\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:42:52\n+  --> $DIR/write_literal.rs:42:47\n    |\n-LL |     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                                    ^^^^^^^^^^^^^\n+LL |     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+   |                                               ^^^^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(&mut v, \"world {foo}\", foo = \"hello\");\n+LL -     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n+LL +     writeln!(v, \"world {foo}\", foo = \"hello\");\n    | \n \n error: aborting due to 11 previous errors"}, {"sha": "ba0d7be5eaa68dfe5234f0499db72cc8d759af99", "filename": "tests/ui/write_literal_2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_literal_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_literal_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal_2.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -6,20 +6,20 @@ use std::io::Write;\n fn main() {\n     let mut v = Vec::new();\n \n-    writeln!(&mut v, \"{}\", \"{hello}\");\n-    writeln!(&mut v, r\"{}\", r\"{hello}\");\n-    writeln!(&mut v, \"{}\", '\\'');\n-    writeln!(&mut v, \"{}\", '\"');\n-    writeln!(&mut v, r\"{}\", '\"'); // don't lint\n-    writeln!(&mut v, r\"{}\", '\\'');\n+    writeln!(v, \"{}\", \"{hello}\");\n+    writeln!(v, r\"{}\", r\"{hello}\");\n+    writeln!(v, \"{}\", '\\'');\n+    writeln!(v, \"{}\", '\"');\n+    writeln!(v, r\"{}\", '\"'); // don't lint\n+    writeln!(v, r\"{}\", '\\'');\n     writeln!(\n-        &mut v,\n+        v,\n         \"some {}\",\n         \"hello \\\n         world!\"\n     );\n     writeln!(\n-        &mut v,\n+        v,\n         \"some {}\\\n         {} \\\\ {}\",\n         \"1\", \"2\", \"3\","}, {"sha": "fc40fbfa9e239b7ab02eed9b3d372484647a67cb", "filename": "tests/ui/write_literal_2.stderr", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_literal_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_literal_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal_2.stderr?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,62 +1,62 @@\n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:9:28\n+  --> $DIR/write_literal_2.rs:9:23\n    |\n-LL |     writeln!(&mut v, \"{}\", \"{hello}\");\n-   |                            ^^^^^^^^^\n+LL |     writeln!(v, \"{}\", \"{hello}\");\n+   |                       ^^^^^^^^^\n    |\n    = note: `-D clippy::write-literal` implied by `-D warnings`\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{}\", \"{hello}\");\n-LL +     writeln!(&mut v, \"{{hello}}\");\n+LL -     writeln!(v, \"{}\", \"{hello}\");\n+LL +     writeln!(v, \"{{hello}}\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:10:29\n+  --> $DIR/write_literal_2.rs:10:24\n    |\n-LL |     writeln!(&mut v, r\"{}\", r\"{hello}\");\n-   |                             ^^^^^^^^^^\n+LL |     writeln!(v, r\"{}\", r\"{hello}\");\n+   |                        ^^^^^^^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, r\"{}\", r\"{hello}\");\n-LL +     writeln!(&mut v, r\"{{hello}}\");\n+LL -     writeln!(v, r\"{}\", r\"{hello}\");\n+LL +     writeln!(v, r\"{{hello}}\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:11:28\n+  --> $DIR/write_literal_2.rs:11:23\n    |\n-LL |     writeln!(&mut v, \"{}\", '/'');\n-   |                            ^^^^\n+LL |     writeln!(v, \"{}\", '/'');\n+   |                       ^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{}\", '/'');\n-LL +     writeln!(&mut v, \"'\");\n+LL -     writeln!(v, \"{}\", '/'');\n+LL +     writeln!(v, \"'\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:12:28\n+  --> $DIR/write_literal_2.rs:12:23\n    |\n-LL |     writeln!(&mut v, \"{}\", '\"');\n-   |                            ^^^\n+LL |     writeln!(v, \"{}\", '\"');\n+   |                       ^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, \"{}\", '\"');\n-LL +     writeln!(&mut v, \"/\"\");\n+LL -     writeln!(v, \"{}\", '\"');\n+LL +     writeln!(v, \"/\"\");\n    | \n \n error: literal with an empty format string\n-  --> $DIR/write_literal_2.rs:14:29\n+  --> $DIR/write_literal_2.rs:14:24\n    |\n-LL |     writeln!(&mut v, r\"{}\", '/'');\n-   |                             ^^^^\n+LL |     writeln!(v, r\"{}\", '/'');\n+   |                        ^^^^\n    |\n help: try this\n    |\n-LL -     writeln!(&mut v, r\"{}\", '/'');\n-LL +     writeln!(&mut v, r\"'\");\n+LL -     writeln!(v, r\"{}\", '/'');\n+LL +     writeln!(v, r\"'\");\n    | \n \n error: literal with an empty format string"}, {"sha": "446d6914d3461205a185daf7f71f6fabf399e3c7", "filename": "tests/ui/write_with_newline.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -10,50 +10,50 @@ fn main() {\n     let mut v = Vec::new();\n \n     // These should fail\n-    write!(&mut v, \"Hello\\n\");\n-    write!(&mut v, \"Hello {}\\n\", \"world\");\n-    write!(&mut v, \"Hello {} {}\\n\", \"world\", \"#2\");\n-    write!(&mut v, \"{}\\n\", 1265);\n-    write!(&mut v, \"\\n\");\n+    write!(v, \"Hello\\n\");\n+    write!(v, \"Hello {}\\n\", \"world\");\n+    write!(v, \"Hello {} {}\\n\", \"world\", \"#2\");\n+    write!(v, \"{}\\n\", 1265);\n+    write!(v, \"\\n\");\n \n     // These should be fine\n-    write!(&mut v, \"\");\n-    write!(&mut v, \"Hello\");\n-    writeln!(&mut v, \"Hello\");\n-    writeln!(&mut v, \"Hello\\n\");\n-    writeln!(&mut v, \"Hello {}\\n\", \"world\");\n-    write!(&mut v, \"Issue\\n{}\", 1265);\n-    write!(&mut v, \"{}\", 1265);\n-    write!(&mut v, \"\\n{}\", 1275);\n-    write!(&mut v, \"\\n\\n\");\n-    write!(&mut v, \"like eof\\n\\n\");\n-    write!(&mut v, \"Hello {} {}\\n\\n\", \"world\", \"#2\");\n-    writeln!(&mut v, \"\\ndon't\\nwarn\\nfor\\nmultiple\\nnewlines\\n\"); // #3126\n-    writeln!(&mut v, \"\\nbla\\n\\n\"); // #3126\n+    write!(v, \"\");\n+    write!(v, \"Hello\");\n+    writeln!(v, \"Hello\");\n+    writeln!(v, \"Hello\\n\");\n+    writeln!(v, \"Hello {}\\n\", \"world\");\n+    write!(v, \"Issue\\n{}\", 1265);\n+    write!(v, \"{}\", 1265);\n+    write!(v, \"\\n{}\", 1275);\n+    write!(v, \"\\n\\n\");\n+    write!(v, \"like eof\\n\\n\");\n+    write!(v, \"Hello {} {}\\n\\n\", \"world\", \"#2\");\n+    writeln!(v, \"\\ndon't\\nwarn\\nfor\\nmultiple\\nnewlines\\n\"); // #3126\n+    writeln!(v, \"\\nbla\\n\\n\"); // #3126\n \n     // Escaping\n-    write!(&mut v, \"\\\\n\"); // #3514\n-    write!(&mut v, \"\\\\\\n\"); // should fail\n-    write!(&mut v, \"\\\\\\\\n\");\n+    write!(v, \"\\\\n\"); // #3514\n+    write!(v, \"\\\\\\n\"); // should fail\n+    write!(v, \"\\\\\\\\n\");\n \n     // Raw strings\n-    write!(&mut v, r\"\\n\"); // #3778\n+    write!(v, r\"\\n\"); // #3778\n \n     // Literal newlines should also fail\n     write!(\n-        &mut v,\n+        v,\n         \"\n \"\n     );\n     write!(\n-        &mut v,\n+        v,\n         r\"\n \"\n     );\n \n     // Don't warn on CRLF (#4208)\n-    write!(&mut v, \"\\r\\n\");\n-    write!(&mut v, \"foo\\r\\n\");\n-    write!(&mut v, \"\\\\r\\n\"); //~ ERROR\n-    write!(&mut v, \"foo\\rbar\\n\");\n+    write!(v, \"\\r\\n\");\n+    write!(v, \"foo\\r\\n\");\n+    write!(v, \"\\\\r\\n\"); //~ ERROR\n+    write!(v, \"foo\\rbar\\n\");\n }"}, {"sha": "3314a2a6e242089ff826a4d412cff4185f0e2311", "filename": "tests/ui/write_with_newline.stderr", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,81 +1,81 @@\n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:13:5\n    |\n-LL |     write!(&mut v, \"Hello/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"Hello/n\");\n+   |     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::write-with-newline` implied by `-D warnings`\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"Hello/n\");\n-LL +     writeln!(&mut v, \"Hello\");\n+LL -     write!(v, \"Hello/n\");\n+LL +     writeln!(v, \"Hello\");\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:14:5\n    |\n-LL |     write!(&mut v, \"Hello {}/n\", \"world\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"Hello {}/n\", \"world\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"Hello {}/n\", \"world\");\n-LL +     writeln!(&mut v, \"Hello {}\", \"world\");\n+LL -     write!(v, \"Hello {}/n\", \"world\");\n+LL +     writeln!(v, \"Hello {}\", \"world\");\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:15:5\n    |\n-LL |     write!(&mut v, \"Hello {} {}/n\", \"world\", \"#2\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"Hello {} {}/n\", \"world\", \"#2\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"Hello {} {}/n\", \"world\", \"#2\");\n-LL +     writeln!(&mut v, \"Hello {} {}\", \"world\", \"#2\");\n+LL -     write!(v, \"Hello {} {}/n\", \"world\", \"#2\");\n+LL +     writeln!(v, \"Hello {} {}\", \"world\", \"#2\");\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:16:5\n    |\n-LL |     write!(&mut v, \"{}/n\", 1265);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"{}/n\", 1265);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"{}/n\", 1265);\n-LL +     writeln!(&mut v, \"{}\", 1265);\n+LL -     write!(v, \"{}/n\", 1265);\n+LL +     writeln!(v, \"{}\", 1265);\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:17:5\n    |\n-LL |     write!(&mut v, \"/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"/n\");\n+   |     ^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"/n\");\n-LL +     writeln!(&mut v);\n+LL -     write!(v, \"/n\");\n+LL +     writeln!(v);\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:36:5\n    |\n-LL |     write!(&mut v, \"//n\"); // should fail\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"//n\"); // should fail\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"//n\"); // should fail\n-LL +     writeln!(&mut v, \"/\"); // should fail\n+LL -     write!(v, \"//n\"); // should fail\n+LL +     writeln!(v, \"/\"); // should fail\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:43:5\n    |\n LL | /     write!(\n-LL | |         &mut v,\n+LL | |         v,\n LL | |         \"\n LL | | \"\n LL | |     );\n@@ -84,15 +84,15 @@ LL | |     );\n help: use `writeln!()` instead\n    |\n LL ~     writeln!(\n-LL |         &mut v,\n+LL |         v,\n LL ~         \"\"\n    |\n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:48:5\n    |\n LL | /     write!(\n-LL | |         &mut v,\n+LL | |         v,\n LL | |         r\"\n LL | | \"\n LL | |     );\n@@ -101,32 +101,32 @@ LL | |     );\n help: use `writeln!()` instead\n    |\n LL ~     writeln!(\n-LL |         &mut v,\n+LL |         v,\n LL ~         r\"\"\n    |\n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:57:5\n    |\n-LL |     write!(&mut v, \"/r/n\"); //~ ERROR\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"/r/n\"); //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"/r/n\"); //~ ERROR\n-LL +     writeln!(&mut v, \"/r\"); //~ ERROR\n+LL -     write!(v, \"/r/n\"); //~ ERROR\n+LL +     writeln!(v, \"/r\"); //~ ERROR\n    | \n \n error: using `write!()` with a format string that ends in a single newline\n   --> $DIR/write_with_newline.rs:58:5\n    |\n-LL |     write!(&mut v, \"foo/rbar/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     write!(v, \"foo/rbar/n\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: use `writeln!()` instead\n    |\n-LL -     write!(&mut v, \"foo/rbar/n\");\n-LL +     writeln!(&mut v, \"foo/rbar\");\n+LL -     write!(v, \"foo/rbar/n\");\n+LL +     writeln!(v, \"foo/rbar\");\n    | \n \n error: aborting due to 10 previous errors"}, {"sha": "e7d94acd130d67b2877a6bf45c4a9b2351785bbf", "filename": "tests/ui/writeln_empty_string.fixed", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwriteln_empty_string.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwriteln_empty_string.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.fixed?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -8,13 +8,13 @@ fn main() {\n     let mut v = Vec::new();\n \n     // These should fail\n-    writeln!(&mut v);\n+    writeln!(v);\n \n     let mut suggestion = Vec::new();\n-    writeln!(&mut suggestion);\n+    writeln!(suggestion);\n \n     // These should be fine\n-    writeln!(&mut v);\n-    writeln!(&mut v, \" \");\n-    write!(&mut v, \"\");\n+    writeln!(v);\n+    writeln!(v, \" \");\n+    write!(v, \"\");\n }"}, {"sha": "662c62f02116e64d4a21213bface9d73b8bb11d4", "filename": "tests/ui/writeln_empty_string.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwriteln_empty_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwriteln_empty_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.rs?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -8,13 +8,13 @@ fn main() {\n     let mut v = Vec::new();\n \n     // These should fail\n-    writeln!(&mut v, \"\");\n+    writeln!(v, \"\");\n \n     let mut suggestion = Vec::new();\n-    writeln!(&mut suggestion, \"\");\n+    writeln!(suggestion, \"\");\n \n     // These should be fine\n-    writeln!(&mut v);\n-    writeln!(&mut v, \" \");\n-    write!(&mut v, \"\");\n+    writeln!(v);\n+    writeln!(v, \" \");\n+    write!(v, \"\");\n }"}, {"sha": "ac65aadfc0e8926f4cf5d04dcde1f0906d5672e9", "filename": "tests/ui/writeln_empty_string.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwriteln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9110e4f3fd8d982dbde873b0c5168b8a3968ed/tests%2Fui%2Fwriteln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.stderr?ref=9e9110e4f3fd8d982dbde873b0c5168b8a3968ed", "patch": "@@ -1,16 +1,16 @@\n-error: using `writeln!(&mut v, \"\")`\n+error: using `writeln!(v, \"\")`\n   --> $DIR/writeln_empty_string.rs:11:5\n    |\n-LL |     writeln!(&mut v, \"\");\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(&mut v)`\n+LL |     writeln!(v, \"\");\n+   |     ^^^^^^^^^^^^^^^ help: replace it with: `writeln!(v)`\n    |\n    = note: `-D clippy::writeln-empty-string` implied by `-D warnings`\n \n-error: using `writeln!(&mut suggestion, \"\")`\n+error: using `writeln!(suggestion, \"\")`\n   --> $DIR/writeln_empty_string.rs:14:5\n    |\n-LL |     writeln!(&mut suggestion, \"\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(&mut suggestion)`\n+LL |     writeln!(suggestion, \"\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(suggestion)`\n \n error: aborting due to 2 previous errors\n "}]}