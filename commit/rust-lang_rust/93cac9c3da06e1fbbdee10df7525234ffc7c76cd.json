{"sha": "93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzY2FjOWMzZGEwNmUxZmJiZGVlMTBkZjc1MjUyMzRmZmM3Yzc2Y2Q=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-18T01:24:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-24T17:06:37Z"}, "message": "rustc: add `Span`s to `inferred_outlives_of` predicates.", "tree": {"sha": "8c4d3d33ea26b7cb62c2ae9ed8243f76e537e0d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c4d3d33ea26b7cb62c2ae9ed8243f76e537e0d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "html_url": "https://github.com/rust-lang/rust/commit/93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e0007f829661e57d008d2e908c95f6e84b04b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e0007f829661e57d008d2e908c95f6e84b04b25", "html_url": "https://github.com/rust-lang/rust/commit/8e0007f829661e57d008d2e908c95f6e84b04b25"}], "stats": {"total": 62, "additions": 39, "deletions": 23}, "files": [{"sha": "7cae74b59c7f9a91d2beb9bff709386e68053d39", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "patch": "@@ -191,7 +191,7 @@ rustc_queries! {\n \n         /// Returns the inferred outlives predicates (e.g., for `struct\n         /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n-        query inferred_outlives_of(_: DefId) -> &'tcx [ty::Predicate<'tcx>] {}\n+        query inferred_outlives_of(_: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {}\n \n         /// Maps from the `DefId` of a trait to the list of\n         /// super-predicates. This is a subset of the full list of"}, {"sha": "e58ba9d6a2b3a3382ae2807a768d2111648a190f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "patch": "@@ -1136,7 +1136,7 @@ pub struct CratePredicatesMap<'tcx> {\n     /// For each struct with outlive bounds, maps to a vector of the\n     /// predicate of its outlive bounds. If an item has no outlives\n     /// bounds, it will have no entry.\n-    pub predicates: FxHashMap<DefId, &'tcx [ty::Predicate<'tcx>]>,\n+    pub predicates: FxHashMap<DefId, &'tcx [(ty::Predicate<'tcx>, Span)]>,\n }\n \n impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {"}, {"sha": "7c19449f96b86f674bcb627584c02603d1910435", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "patch": "@@ -1497,10 +1497,10 @@ declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMEN\n \n impl ExplicitOutlivesRequirements {\n     fn lifetimes_outliving_lifetime<'tcx>(\n-        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n-        inferred_outlives.iter().filter_map(|pred| {\n+        inferred_outlives.iter().filter_map(|(pred, _)| {\n             match pred {\n                 ty::Predicate::RegionOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n@@ -1517,10 +1517,10 @@ impl ExplicitOutlivesRequirements {\n     }\n \n     fn lifetimes_outliving_type<'tcx>(\n-        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         index: u32,\n     ) -> Vec<ty::Region<'tcx>> {\n-        inferred_outlives.iter().filter_map(|pred| {\n+        inferred_outlives.iter().filter_map(|(pred, _)| {\n             match pred {\n                 ty::Predicate::TypeOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n@@ -1539,7 +1539,7 @@ impl ExplicitOutlivesRequirements {\n         &self,\n         param: &'tcx hir::GenericParam,\n         tcx: TyCtxt<'tcx>,\n-        inferred_outlives: &'tcx [ty::Predicate<'tcx>],\n+        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n         ty_generics: &'tcx ty::Generics,\n     ) -> Vec<ty::Region<'tcx>> {\n         let index = ty_generics.param_def_id_to_index["}, {"sha": "78347ded726356d78b12e86bf24f50b958207c28", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "patch": "@@ -1970,19 +1970,18 @@ fn predicates_defined_on(\n     );\n     let inferred_outlives = tcx.inferred_outlives_of(def_id);\n     if !inferred_outlives.is_empty() {\n-        let span = tcx.def_span(def_id);\n         debug!(\n             \"predicates_defined_on: inferred_outlives_of({:?}) = {:?}\",\n             def_id,\n             inferred_outlives,\n         );\n-        result.predicates = tcx.arena.alloc_from_iter(\n-            result.predicates.iter().copied().chain(\n-                // FIXME(eddyb) use better spans - maybe add `Span`s\n-                // to `inferred_outlives_of` predicates as well?\n-                inferred_outlives.iter().map(|&p| (p, span)),\n-            ),\n-        );\n+        if result.predicates.is_empty() {\n+            result.predicates = inferred_outlives;\n+        } else {\n+            result.predicates = tcx.arena.alloc_from_iter(\n+                result.predicates.iter().chain(inferred_outlives).copied(),\n+            );\n+        }\n     }\n     debug!(\"predicates_defined_on({:?}) = {:?}\", def_id, result);\n     result"}, {"sha": "b2699fffc2c17d57622093ff9e6c54f87492a171", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93cac9c3da06e1fbbdee10df7525234ffc7c76cd/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=93cac9c3da06e1fbbdee10df7525234ffc7c76cd", "patch": "@@ -5,6 +5,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::GenericArgKind;\n use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n use syntax::symbol::sym;\n+use syntax_pos::Span;\n \n mod explicit;\n mod implicit_infer;\n@@ -23,7 +24,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n fn inferred_outlives_of(\n     tcx: TyCtxt<'_>,\n     item_def_id: DefId,\n-) -> &[ty::Predicate<'_>] {\n+) -> &[(ty::Predicate<'_>, Span)] {\n     let id = tcx\n         .hir()\n         .as_local_hir_id(item_def_id)\n@@ -43,7 +44,7 @@ fn inferred_outlives_of(\n                 if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n-                        .map(|out_pred| match out_pred {\n+                        .map(|(out_pred, _)| match out_pred {\n                             ty::Predicate::RegionOutlives(p) => p.to_string(),\n                             ty::Predicate::TypeOutlives(p) => p.to_string(),\n                             err => bug!(\"unexpected predicate {:?}\", err),\n@@ -96,27 +97,43 @@ fn inferred_outlives_crate(\n     let predicates = global_inferred_outlives\n         .iter()\n         .map(|(&def_id, set)| {\n-            let predicates = tcx.arena.alloc_from_iter(set\n+            let def_span = tcx.def_span(def_id);\n+            let generics = tcx.generics_of(def_id);\n+            let predicates = &*tcx.arena.alloc_from_iter(set\n                 .iter()\n                 .filter_map(\n                     |ty::OutlivesPredicate(kind1, region2)| match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => {\n-                            Some(ty::Predicate::TypeOutlives(ty::Binder::bind(\n+                            // FIXME(eddyb) compute `Span`s in `implicit_infer`.\n+                            let span = match &ty1.kind {\n+                                ty::Param(p) => {\n+                                    tcx.def_span(generics.type_param(p, tcx).def_id)\n+                                }\n+                                _ => def_span,\n+                            };\n+                            Some((ty::Predicate::TypeOutlives(ty::Binder::bind(\n                                 ty::OutlivesPredicate(ty1, region2)\n-                            )))\n+                            )), span))\n                         }\n                         GenericArgKind::Lifetime(region1) => {\n-                            Some(ty::Predicate::RegionOutlives(\n+                            // FIXME(eddyb) compute `Span`s in `implicit_infer`.\n+                            let span = match region1 {\n+                                ty::RegionKind::ReEarlyBound(p) => {\n+                                    tcx.def_span(generics.region_param(p, tcx).def_id)\n+                                }\n+                                _ => def_span,\n+                            };\n+                            Some((ty::Predicate::RegionOutlives(\n                                 ty::Binder::bind(ty::OutlivesPredicate(region1, region2))\n-                            ))\n+                            ), span))\n                         }\n                         GenericArgKind::Const(_) => {\n                             // Generic consts don't impose any constraints.\n                             None\n                         }\n                     },\n                 ));\n-            (def_id, &*predicates)\n+            (def_id, predicates)\n         }).collect();\n \n     tcx.arena.alloc(ty::CratePredicatesMap {"}]}