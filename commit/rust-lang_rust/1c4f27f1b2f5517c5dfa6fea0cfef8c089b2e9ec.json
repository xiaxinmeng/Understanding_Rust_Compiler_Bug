{"sha": "1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNGYyN2YxYjJmNTUxN2M1ZGZhNmZlYTBjZmVmOGMwODliMmU5ZWM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-14T10:53:09Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-03-15T09:59:07Z"}, "message": "adjust Miri to needs of changed unwinding strategy", "tree": {"sha": "c55d18ac9ff4486c2056ebe602dfc70e0abe9571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c55d18ac9ff4486c2056ebe602dfc70e0abe9571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec", "html_url": "https://github.com/rust-lang/rust/commit/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7580f795c04c7d0a036b4b27da375a0ac87eb36", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7580f795c04c7d0a036b4b27da375a0ac87eb36", "html_url": "https://github.com/rust-lang/rust/commit/a7580f795c04c7d0a036b4b27da375a0ac87eb36"}], "stats": {"total": 157, "additions": 77, "deletions": 80}, "files": [{"sha": "d94c6928cfe0422c7eae395f5d84114916457536", "filename": "src/machine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec", "patch": "@@ -32,11 +32,10 @@ pub struct FrameData<'tcx> {\n     /// Extra data for Stacked Borrows.\n     pub call_id: stacked_borrows::CallId,\n \n-    /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of the closure\n-    /// called by `__rustc_maybe_catch_panic`). When this frame is popped during unwinding a panic,\n-    /// we stop unwinding, use the `CatchUnwindData` to\n-    /// store the panic payload, and continue execution in the parent frame.\n-    pub catch_panic: Option<CatchUnwindData<'tcx>>,\n+    /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of `try_fn`\n+    /// called by `try`). When this frame is popped during unwinding a panic,\n+    /// we stop unwinding, use the `CatchUnwindData` to handle catching.\n+    pub catch_unwind: Option<CatchUnwindData<'tcx>>,\n }\n \n /// Extra memory kinds\n@@ -163,7 +162,8 @@ pub struct Evaluator<'tcx> {\n \n     /// The temporary used for storing the argument of\n     /// the call to `miri_start_panic` (the panic payload) when unwinding.\n-    pub(crate) panic_payload: Option<ImmTy<'tcx, Tag>>,\n+    /// This is pointer-sized, and matches the `Payload` type in `src/libpanic_unwind/miri.rs`.\n+    pub(crate) panic_payload: Option<Scalar<Tag>>,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n@@ -405,15 +405,15 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         let call_id = stacked_borrows.map_or(NonZeroU64::new(1).unwrap(), |stacked_borrows| {\n             stacked_borrows.borrow_mut().new_call()\n         });\n-        Ok(FrameData { call_id, catch_panic: None })\n+        Ok(FrameData { call_id, catch_unwind: None })\n     }\n \n     #[inline(always)]\n     fn stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         extra: FrameData<'tcx>,\n         unwinding: bool,\n-    ) -> InterpResult<'tcx, StackPopInfo> {\n+    ) -> InterpResult<'tcx, StackPopJump> {\n         ecx.handle_stack_pop(extra, unwinding)\n     }\n "}, {"sha": "0183757cff0ae269e002c8c200bb36c751d54f98", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec", "patch": "@@ -150,12 +150,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Second: some functions that we forward to MIR implementations.\n         match link_name {\n-            // This matches calls to the *foreign* item `__rust_start_panic*, that is,\n-            // calls to `extern \"Rust\" { fn __rust_start_panic(...) }`.\n+            // This matches calls to the foreign item `__rust_start_panic`, that is,\n+            // calls to `extern \"Rust\" { fn __rust_start_panic(...) }`\n+            // (and `__rust_panic_cleanup`, respectively).\n             // We forward this to the underlying *implementation* in the panic runtime crate.\n             // Normally, this will be either `libpanic_unwind` or `libpanic_abort`, but it could\n             // also be a custom user-provided implementation via `#![feature(panic_runtime)]`\n-            \"__rust_start_panic\" => {\n+            \"__rust_start_panic\" | \"__rust_panic_cleanup\"=> {\n                 // FIXME we might want to cache this... but it's not really performance-critical.\n                 let panic_runtime = tcx\n                     .crates()\n@@ -164,7 +165,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .expect(\"No panic runtime found!\");\n                 let panic_runtime = tcx.crate_name(*panic_runtime);\n                 let start_panic_instance =\n-                    this.resolve_path(&[&*panic_runtime.as_str(), \"__rust_start_panic\"])?;\n+                    this.resolve_path(&[&*panic_runtime.as_str(), link_name])?;\n                 return Ok(Some(&*this.load_mir(start_panic_instance.def, None)?));\n             }\n             _ => {}\n@@ -291,11 +292,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(new_ptr, dest)?;\n             }\n \n-            \"__rust_maybe_catch_panic\" => {\n-                this.handle_catch_panic(args, dest, ret)?;\n-                return Ok(false);\n-            }\n-\n             \"memcmp\" => {\n                 let left = this.read_scalar(args[0])?.not_undef()?;\n                 let right = this.read_scalar(args[1])?.not_undef()?;"}, {"sha": "8d7645c81fe4fc75b24c5ae09652a432722ba3b8", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec", "patch": "@@ -34,6 +34,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // First handle intrinsics without return place.\n         let (dest, ret) = match ret {\n             None => match intrinsic_name {\n+                \"miri_start_panic\" => return this.handle_miri_start_panic(args, unwind),\n                 \"abort\" => {\n                     // FIXME: remove, once the intrinsic on the rustc side is fixed.\n                     throw_machine_stop!(TerminationInfo::Abort);\n@@ -44,7 +45,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         match intrinsic_name {\n-            \"miri_start_panic\" => return this.handle_miri_start_panic(args, unwind),\n+            \"try\" => return this.handle_try(args, dest, ret),\n \n             \"arith_offset\" => {\n                 let offset = this.read_scalar(args[1])?.to_machine_isize(this)?;"}, {"sha": "2f61ab6c39583aea101089d58fd3867c0cb822e1", "filename": "src/shims/panic.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=1c4f27f1b2f5517c5dfa6fea0cfef8c089b2e9ec", "patch": "@@ -17,24 +17,22 @@ use rustc_target::spec::PanicStrategy;\n \n use crate::*;\n \n-/// Holds all of the relevant data for a call to\n-/// `__rust_maybe_catch_panic`.\n-///\n-/// If a panic occurs, we update this data with\n-/// the information from the panic site.\n+/// Holds all of the relevant data for when unwinding hits a `try` frame.\n #[derive(Debug)]\n pub struct CatchUnwindData<'tcx> {\n-    /// The dereferenced `data_ptr` argument passed to `__rust_maybe_catch_panic`.\n-    pub data_place: MPlaceTy<'tcx, Tag>,\n-    /// The dereferenced `vtable_ptr` argument passed to `__rust_maybe_catch_panic`.\n-    pub vtable_place: MPlaceTy<'tcx, Tag>,\n-    /// The `dest` from the original call to `__rust_maybe_catch_panic`.\n-    pub dest: PlaceTy<'tcx, Tag>,\n+    /// The `catch_fn` callback to call in case of a panic.\n+    catch_fn: Scalar<Tag>,\n+    /// The `data` argument for that callback.\n+    data: Scalar<Tag>,\n+    /// The return place from the original call to `try`.\n+    dest: PlaceTy<'tcx, Tag>,\n+    /// The return block from the original call to `try`.\n+    ret: mir::BasicBlock,\n }\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// Handles the special \"miri_start_panic\" intrinsic, which is called\n+    /// Handles the special `miri_start_panic` intrinsic, which is called\n     /// by libpanic_unwind to delegate the actual unwinding process to Miri.\n     fn handle_miri_start_panic(\n         &mut self,\n@@ -46,47 +44,50 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         trace!(\"miri_start_panic: {:?}\", this.frame().span);\n \n         // Get the raw pointer stored in arg[0] (the panic payload).\n-        let scalar = this.read_immediate(args[0])?;\n+        let payload = this.read_scalar(args[0])?.not_undef()?;\n         assert!(\n             this.machine.panic_payload.is_none(),\n             \"the panic runtime should avoid double-panics\"\n         );\n-        this.machine.panic_payload = Some(scalar);\n+        this.machine.panic_payload = Some(payload);\n \n         // Jump to the unwind block to begin unwinding.\n         this.unwind_to_block(unwind);\n         return Ok(());\n     }\n \n-    fn handle_catch_panic(\n+    /// Handles the `try` intrinsic, the underlying implementation of `std::panicking::try`.\n+    fn handle_try(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n         dest: PlaceTy<'tcx, Tag>,\n         ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let tcx = &{ this.tcx.tcx };\n \n-        // fn __rust_maybe_catch_panic(\n-        //     f: fn(*mut u8),\n-        //     data: *mut u8,\n-        //     data_ptr: *mut usize,\n-        //     vtable_ptr: *mut usize,\n-        // ) -> u32\n+        // Signature:\n+        //   fn r#try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32\n+        // Calls `try_fn` with `data` as argument. If that executes normally, returns 0.\n+        // If that unwinds, calls `catch_fn` with the first argument being `data` and\n+        // then second argument being a target-dependent `payload` (i.e. it is up to us to define\n+        // what that is), and returns 1.\n+        // The `payload` is passed (by libstd) to `__rust_panic_cleanup`, which is then expected to\n+        // return a `Box<dyn Any + Send + 'static>`.\n+        // In Miri, `miri_start_panic` is passed exactly that type, so we make the `payload` simply\n+        // a pointer to `Box<dyn Any + Send + 'static>`.\n \n         // Get all the arguments.\n-        let f = this.read_scalar(args[0])?.not_undef()?;\n-        let f_arg = this.read_scalar(args[1])?.not_undef()?;\n-        let data_place = this.deref_operand(args[2])?;\n-        let vtable_place = this.deref_operand(args[3])?;\n-\n-        // Now we make a function call, and pass `f_arg` as first and only argument.\n-        let f_instance = this.memory.get_fn(f)?.as_instance()?;\n-        trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n-        let ret_place = MPlaceTy::dangling(this.layout_of(tcx.mk_unit())?, this).into();\n+        let try_fn = this.read_scalar(args[0])?.not_undef()?;\n+        let data = this.read_scalar(args[1])?.not_undef()?;\n+        let catch_fn = this.read_scalar(args[2])?.not_undef()?;\n+\n+        // Now we make a function call, and pass `data` as first and only argument.\n+        let f_instance = this.memory.get_fn(try_fn)?.as_instance()?;\n+        trace!(\"try_fn: {:?}\", f_instance);\n+        let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n         this.call_function(\n             f_instance,\n-            &[f_arg.into()],\n+            &[data.into()],\n             Some(ret_place),\n             // Directly return to caller.\n             StackPopCleanup::Goto { ret: Some(ret), unwind: None },\n@@ -95,12 +96,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // We ourselves will return `0`, eventually (will be overwritten if we catch a panic).\n         this.write_null(dest)?;\n \n-        // In unwind mode, we tag this frame with some extra data.\n+        // In unwind mode, we tag this frame with the extra data needed to catch unwinding.\n         // This lets `handle_stack_pop` (below) know that we should stop unwinding\n         // when we pop this frame.\n-        if this.tcx.tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n-            this.frame_mut().extra.catch_panic =\n-                Some(CatchUnwindData { data_place, vtable_place, dest })\n+        if this.tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n+            this.frame_mut().extra.catch_unwind = Some(CatchUnwindData { catch_fn, data, dest, ret });\n         }\n \n         return Ok(());\n@@ -110,45 +110,45 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         mut extra: FrameData<'tcx>,\n         unwinding: bool,\n-    ) -> InterpResult<'tcx, StackPopInfo> {\n+    ) -> InterpResult<'tcx, StackPopJump> {\n         let this = self.eval_context_mut();\n \n         trace!(\"handle_stack_pop(extra = {:?}, unwinding = {})\", extra, unwinding);\n+        if let Some(stacked_borrows) = this.memory.extra.stacked_borrows.as_ref() {\n+            stacked_borrows.borrow_mut().end_call(extra.call_id);\n+        }\n \n         // We only care about `catch_panic` if we're unwinding - if we're doing a normal\n         // return, then we don't need to do anything special.\n-        let res = if let (true, Some(unwind_data)) = (unwinding, extra.catch_panic.take()) {\n-            // We've just popped a frame that was pushed by `__rust_maybe_catch_panic`,\n+        if let (true, Some(catch_unwind)) = (unwinding, extra.catch_unwind.take()) {\n+            // We've just popped a frame that was pushed by `try`,\n             // and we are unwinding, so we should catch that.\n             trace!(\"unwinding: found catch_panic frame during unwinding: {:?}\", this.frame().span);\n \n-            // `panic_payload` now holds a `*mut (dyn Any + Send)`,\n-            // provided by the `miri_start_panic` intrinsic.\n-            // We want to split this into its consituient parts -\n-            // the data and vtable pointers - and store them according to\n-            // `unwind_data`, i.e., we store them where `__rust_maybe_catch_panic`\n-            // was told to put them.\n-            let payload = this.machine.panic_payload.take().unwrap();\n-            let payload = this.ref_to_mplace(payload)?;\n-            let payload_data_place = payload.ptr;\n-            let payload_vtable_place = payload.meta.unwrap_meta();\n-\n-            this.write_scalar(payload_data_place, unwind_data.data_place.into())?;\n-            this.write_scalar(payload_vtable_place, unwind_data.vtable_place.into())?;\n+            // We set the return value of `try` to 1, since there was a panic.\n+            this.write_scalar(Scalar::from_i32(1), catch_unwind.dest)?;\n \n-            // We set the return value of `__rust_maybe_catch_panic` to 1,\n-            // since there was a panic.\n-            let dest = unwind_data.dest;\n-            this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n+            // `panic_payload` holds what was passed to `miri_start_panic`.\n+            // This is exactly the second argument we need to pass to `catch_fn`.\n+            let payload = this.machine.panic_payload.take().unwrap();\n \n-            StackPopInfo::StopUnwinding\n+            // Push the `catch_fn` stackframe.\n+            let f_instance = this.memory.get_fn(catch_unwind.catch_fn)?.as_instance()?;\n+            trace!(\"catch_fn: {:?}\", f_instance);\n+            let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n+            this.call_function(\n+                f_instance,\n+                &[catch_unwind.data.into(), payload.into()],\n+                Some(ret_place),\n+                // Directly return to caller of `try`.\n+                StackPopCleanup::Goto { ret: Some(catch_unwind.ret), unwind: None },\n+            )?;\n+\n+            // We pushed a new stack frame, the engine should not do any jumping now!\n+            Ok(StackPopJump::NoJump)\n         } else {\n-            StackPopInfo::Normal\n-        };\n-        if let Some(stacked_borrows) = this.memory.extra.stacked_borrows.as_ref() {\n-            stacked_borrows.borrow_mut().end_call(extra.call_id);\n+            Ok(StackPopJump::Normal)\n         }\n-        Ok(res)\n     }\n \n     /// Starta a panic in the interpreter with the given message as payload."}]}