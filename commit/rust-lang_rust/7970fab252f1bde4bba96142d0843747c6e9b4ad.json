{"sha": "7970fab252f1bde4bba96142d0843747c6e9b4ad", "node_id": "C_kwDOAAsO6NoAKDc5NzBmYWIyNTJmMWJkZTRiYmE5NjE0MmQwODQzNzQ3YzZlOWI0YWQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-08T15:08:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-08T15:08:06Z"}, "message": "Rollup merge of #90709 - estebank:erase-known-type-params, r=nagisa\n\nOnly shown relevant type params in E0283 label\n\nWhen we point at a binding to suggest giving it a type, erase all the\ntype for ADTs that have been resolved, leaving only the ones that could\nnot be inferred. For small shallow types this is not a problem, but for\nbig nested types with lots of params, this can otherwise cause a lot of\nunnecessary visual output.", "tree": {"sha": "fca38778b5422dc93c273b2a7309d28dac6a50ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fca38778b5422dc93c273b2a7309d28dac6a50ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7970fab252f1bde4bba96142d0843747c6e9b4ad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhsMpXCRBK7hj4Ov3rIwAAY/8IAChhDI0Ue+ypUXVDOVdgw7lA\nMShTkXG/8bSuT9W2sAevvR5jyA/Cf7A7XbqMrQ1UYa38pN+UsWD3teHMOk2Tbhfa\nf1aloyu96zR9FuJk143qmi7KwUUYWCqXVBCHvw0PCv71Hqma7xu/bRIGVVk6Qv34\nzJvKsJg20jIMpVAINRPwhpg2FM5UJMIojyEoImZ5VjGMUAyKUPe020oEFdg5Bq2X\n2QEOaXJsW6K7GVmjIVQEb0If3YJb82nRqGmsygPF5wSiiYd0wo5qVx9beZsQbmJ6\nxOGZWwuQXKejj26wt3+J59+AVxyWIyvY65bmUkoOmgHdCuI3d4/mjmNn6mJZXE8=\n=SQdS\n-----END PGP SIGNATURE-----\n", "payload": "tree fca38778b5422dc93c273b2a7309d28dac6a50ea\nparent 4459e720bee5a741b962cfcd6f0593b32dc19009\nparent 7271d1f803ba4a2f850d19c570d04993b61881a9\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1638976086 +0100\ncommitter GitHub <noreply@github.com> 1638976086 +0100\n\nRollup merge of #90709 - estebank:erase-known-type-params, r=nagisa\n\nOnly shown relevant type params in E0283 label\n\nWhen we point at a binding to suggest giving it a type, erase all the\ntype for ADTs that have been resolved, leaving only the ones that could\nnot be inferred. For small shallow types this is not a problem, but for\nbig nested types with lots of params, this can otherwise cause a lot of\nunnecessary visual output.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7970fab252f1bde4bba96142d0843747c6e9b4ad", "html_url": "https://github.com/rust-lang/rust/commit/7970fab252f1bde4bba96142d0843747c6e9b4ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7970fab252f1bde4bba96142d0843747c6e9b4ad/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4459e720bee5a741b962cfcd6f0593b32dc19009", "url": "https://api.github.com/repos/rust-lang/rust/commits/4459e720bee5a741b962cfcd6f0593b32dc19009", "html_url": "https://github.com/rust-lang/rust/commit/4459e720bee5a741b962cfcd6f0593b32dc19009"}, {"sha": "7271d1f803ba4a2f850d19c570d04993b61881a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7271d1f803ba4a2f850d19c570d04993b61881a9", "html_url": "https://github.com/rust-lang/rust/commit/7271d1f803ba4a2f850d19c570d04993b61881a9"}], "stats": {"total": 209, "additions": 201, "deletions": 8}, "files": [{"sha": "9cf6cde259150a433041cbdb7631d194f04d736a", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 131, "deletions": 6, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/7970fab252f1bde4bba96142d0843747c6e9b4ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7970fab252f1bde4bba96142d0843747c6e9b4ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=7970fab252f1bde4bba96142d0843747c6e9b4ad", "patch": "@@ -1,6 +1,5 @@\n use crate::infer::type_variable::TypeVariableOriginKind;\n-use crate::infer::InferCtxt;\n-use crate::rustc_middle::ty::TypeFoldable;\n+use crate::infer::{InferCtxt, Symbol};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};\n@@ -11,7 +10,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::infer::unify_key::ConstVariableOriginKind;\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, DefIdTree, InferConst, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Const, DefIdTree, InferConst, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -306,6 +305,15 @@ pub enum UnderspecifiedArgKind {\n     Const { is_parameter: bool },\n }\n \n+impl UnderspecifiedArgKind {\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            Self::Type { .. } => \"type\",\n+            Self::Const { .. } => \"const\",\n+        }\n+    }\n+}\n+\n impl InferenceDiagnosticsData {\n     /// Generate a label for a generic argument which can't be inferred. When not\n     /// much is known about the argument, `use_diag` may be used to describe the\n@@ -588,6 +596,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        let param_type = arg_data.kind.descr();\n         let suffix = match local_visitor.found_node_ty {\n             Some(ty) if ty.is_closure() => {\n                 let substs =\n@@ -626,13 +635,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             Some(ty) if is_named_and_not_impl_trait(ty) && arg_data.name == \"_\" => {\n                 let ty = ty_to_string(ty);\n-                format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n+                format!(\"the explicit type `{}`, with the {} parameters specified\", ty, param_type)\n             }\n             Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != arg_data.name => {\n+                let ty = ResolvedTypeParamEraser::new(self.tcx).fold_ty(ty);\n+                let ty = ErrTypeParamEraser(self.tcx).fold_ty(ty);\n                 let ty = ty_to_string(ty);\n                 format!(\n-                    \"the explicit type `{}`, where the type parameter `{}` is specified\",\n-                    ty, arg_data.name,\n+                    \"the explicit type `{}`, where the {} parameter `{}` is specified\",\n+                    ty, param_type, arg_data.name,\n                 )\n             }\n             _ => \"a type\".to_string(),\n@@ -908,3 +919,117 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err\n     }\n }\n+\n+/// Turn *resolved* type params into `[type error]` to signal we don't want to display them. After\n+/// performing that replacement, we'll turn all remaining infer type params to use their name from\n+/// their definition, and replace all the `[type error]`s back to being infer so they display in\n+/// the output as `_`. If we didn't go through `[type error]`, we would either show all type params\n+/// by their name *or* `_`, neither of which is desireable: we want to show all types that we could\n+/// infer as `_` to reduce verbosity and avoid telling the user about unnecessary type annotations.\n+struct ResolvedTypeParamEraser<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    level: usize,\n+}\n+\n+impl<'tcx> ResolvedTypeParamEraser<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        ResolvedTypeParamEraser { tcx, level: 0 }\n+    }\n+\n+    /// Replace not yet inferred const params with their def name.\n+    fn replace_infers(&self, c: &'tcx Const<'tcx>, index: u32, name: Symbol) -> &'tcx Const<'tcx> {\n+        match c.val {\n+            ty::ConstKind::Infer(..) => self.tcx().mk_const_param(index, name, c.ty),\n+            _ => c,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        self.level += 1;\n+        let t = match t.kind() {\n+            // We'll hide this type only if all its type params are hidden as well.\n+            ty::Adt(def, substs) => {\n+                let generics = self.tcx().generics_of(def.did);\n+                // Account for params with default values, like `Vec`, where we\n+                // want to show `Vec<T>`, not `Vec<T, _>`. If we replaced that\n+                // subst, then we'd get the incorrect output, so we passthrough.\n+                let substs: Vec<_> = substs\n+                    .iter()\n+                    .zip(generics.params.iter())\n+                    .map(|(subst, param)| match &(subst.unpack(), &param.kind) {\n+                        (_, ty::GenericParamDefKind::Type { has_default: true, .. }) => subst,\n+                        (crate::infer::GenericArgKind::Const(c), _) => {\n+                            self.replace_infers(c, param.index, param.name).into()\n+                        }\n+                        _ => subst.super_fold_with(self),\n+                    })\n+                    .collect();\n+                let should_keep = |subst: &GenericArg<'_>| match subst.unpack() {\n+                    ty::subst::GenericArgKind::Type(t) => match t.kind() {\n+                        ty::Error(_) => false,\n+                        _ => true,\n+                    },\n+                    // Account for `const` params here, otherwise `doesnt_infer.rs`\n+                    // shows `_` instead of `Foo<{ _: u32 }>`\n+                    ty::subst::GenericArgKind::Const(_) => true,\n+                    _ => false,\n+                };\n+                if self.level == 1 || substs.iter().any(should_keep) {\n+                    let substs = self.tcx().intern_substs(&substs[..]);\n+                    self.tcx().mk_ty(ty::Adt(def, substs))\n+                } else {\n+                    self.tcx().ty_error()\n+                }\n+            }\n+            ty::Ref(_, ty, _) => {\n+                let ty = self.fold_ty(ty);\n+                match ty.kind() {\n+                    // Avoid `&_`, these can be safely presented as `_`.\n+                    ty::Error(_) => self.tcx().ty_error(),\n+                    _ => t.super_fold_with(self),\n+                }\n+            }\n+            // We could account for `()` if we wanted to replace it, but it's assured to be short.\n+            ty::Tuple(_)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Opaque(..)\n+            | ty::Projection(_)\n+            | ty::Never => t.super_fold_with(self),\n+            ty::Array(ty, c) => self\n+                .tcx()\n+                .mk_ty(ty::Array(self.fold_ty(ty), self.replace_infers(c, 0, Symbol::intern(\"N\")))),\n+            // We don't want to hide type params that haven't been resolved yet.\n+            // This would be the type that will be written out with the type param\n+            // name in the output.\n+            ty::Infer(_) => t,\n+            // We don't want to hide the outermost type, only its type params.\n+            _ if self.level == 1 => t.super_fold_with(self),\n+            // Hide this type\n+            _ => self.tcx().ty_error(),\n+        };\n+        self.level -= 1;\n+        t\n+    }\n+}\n+\n+/// Replace `[type error]` with `ty::Infer(ty::Var)` to display `_`.\n+struct ErrTypeParamEraser<'tcx>(TyCtxt<'tcx>);\n+impl<'tcx> TypeFolder<'tcx> for ErrTypeParamEraser<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.0\n+    }\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.kind() {\n+            ty::Error(_) => self.tcx().mk_ty_var(ty::TyVid::from_u32(0)),\n+            _ => t.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "d6c64d58be5f39c9975650203301179d702f500f", "filename": "src/test/ui/const-generics/defaults/doesnt_infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7970fab252f1bde4bba96142d0843747c6e9b4ad/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7970fab252f1bde4bba96142d0843747c6e9b4ad/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr?ref=7970fab252f1bde4bba96142d0843747c6e9b4ad", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed for `Foo<{_: u32}>`\n LL |     let foo = Foo::foo();\n    |         ---   ^^^^^^^^ cannot infer the value of const parameter `N`\n    |         |\n-   |         consider giving `foo` the explicit type `Foo<{_: u32}>`, where the type parameter `N` is specified\n+   |         consider giving `foo` the explicit type `Foo<N>`, where the const parameter `N` is specified\n \n error: aborting due to previous error\n "}, {"sha": "1fea2da92da94367ec01ededabbbd74b014bde3f", "filename": "src/test/ui/inference/erase-type-params-in-label.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7970fab252f1bde4bba96142d0843747c6e9b4ad/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7970fab252f1bde4bba96142d0843747c6e9b4ad/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.rs?ref=7970fab252f1bde4bba96142d0843747c6e9b4ad", "patch": "@@ -0,0 +1,27 @@\n+fn main() {\n+    let foo = foo(1, \"\"); //~ ERROR E0283\n+}\n+fn baz() {\n+    let bar = bar(1, \"\"); //~ ERROR E0283\n+}\n+\n+struct Bar<T, K, N: Default> {\n+    t: T,\n+    k: K,\n+    n: N,\n+}\n+\n+fn bar<T, K, Z: Default>(t: T, k: K) -> Bar<T, K, Z> {\n+    Bar { t, k, n: Default::default() }\n+}\n+\n+struct Foo<T, K, N: Default, M: Default> {\n+    t: T,\n+    k: K,\n+    n: N,\n+    m: M,\n+}\n+\n+fn foo<T, K, W: Default, Z: Default>(t: T, k: K) -> Foo<T, K, W, Z> {\n+    Foo { t, k, n: Default::default(), m: Default::default() }\n+}"}, {"sha": "d0b06cde9d63a58bef0164f77026ed17b1212c99", "filename": "src/test/ui/inference/erase-type-params-in-label.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7970fab252f1bde4bba96142d0843747c6e9b4ad/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7970fab252f1bde4bba96142d0843747c6e9b4ad/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr?ref=7970fab252f1bde4bba96142d0843747c6e9b4ad", "patch": "@@ -0,0 +1,41 @@\n+error[E0283]: type annotations needed for `Foo<i32, &str, W, Z>`\n+  --> $DIR/erase-type-params-in-label.rs:2:15\n+   |\n+LL |     let foo = foo(1, \"\");\n+   |         ---   ^^^ cannot infer type for type parameter `W` declared on the function `foo`\n+   |         |\n+   |         consider giving `foo` the explicit type `Foo<_, _, W, Z>`, where the type parameter `W` is specified\n+   |\n+   = note: cannot satisfy `_: Default`\n+note: required by a bound in `foo`\n+  --> $DIR/erase-type-params-in-label.rs:25:17\n+   |\n+LL | fn foo<T, K, W: Default, Z: Default>(t: T, k: K) -> Foo<T, K, W, Z> {\n+   |                 ^^^^^^^ required by this bound in `foo`\n+help: consider specifying the type arguments in the function call\n+   |\n+LL |     let foo = foo::<T, K, W, Z>(1, \"\");\n+   |                  ++++++++++++++\n+\n+error[E0283]: type annotations needed for `Bar<i32, &str, Z>`\n+  --> $DIR/erase-type-params-in-label.rs:5:15\n+   |\n+LL |     let bar = bar(1, \"\");\n+   |         ---   ^^^ cannot infer type for type parameter `Z` declared on the function `bar`\n+   |         |\n+   |         consider giving `bar` the explicit type `Bar<_, _, Z>`, where the type parameter `Z` is specified\n+   |\n+   = note: cannot satisfy `_: Default`\n+note: required by a bound in `bar`\n+  --> $DIR/erase-type-params-in-label.rs:14:17\n+   |\n+LL | fn bar<T, K, Z: Default>(t: T, k: K) -> Bar<T, K, Z> {\n+   |                 ^^^^^^^ required by this bound in `bar`\n+help: consider specifying the type arguments in the function call\n+   |\n+LL |     let bar = bar::<T, K, Z>(1, \"\");\n+   |                  +++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "9ca8f35fd545a4abb34cbae54e3ee8b9a8765443", "filename": "src/test/ui/inference/issue-83606.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7970fab252f1bde4bba96142d0843747c6e9b4ad/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7970fab252f1bde4bba96142d0843747c6e9b4ad/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr?ref=7970fab252f1bde4bba96142d0843747c6e9b4ad", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed for `[usize; _]`\n LL |     let _ = foo(\"foo\"); //<- Do not suggest `foo::<N>(\"foo\");`!\n    |         -   ^^^ cannot infer the value of const parameter `N` declared on the function `foo`\n    |         |\n-   |         consider giving this pattern the explicit type `[usize; _]`, where the type parameter `N` is specified\n+   |         consider giving this pattern the explicit type `[_; N]`, where the const parameter `N` is specified\n \n error: aborting due to previous error\n "}]}