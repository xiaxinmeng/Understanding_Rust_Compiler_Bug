{"sha": "63217e08cc041d0c4ce6df4e981899bfbc557de5", "node_id": "C_kwDOAAsO6NoAKDYzMjE3ZTA4Y2MwNDFkMGM0Y2U2ZGY0ZTk4MTg5OWJmYmM1NTdkZTU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-09T18:46:57Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-09T22:58:39Z"}, "message": "make dropck_outlives into a proper canonicalized type query", "tree": {"sha": "5291629f1ff61279d0c42b2bf207c90be0a5b16c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5291629f1ff61279d0c42b2bf207c90be0a5b16c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63217e08cc041d0c4ce6df4e981899bfbc557de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63217e08cc041d0c4ce6df4e981899bfbc557de5", "html_url": "https://github.com/rust-lang/rust/commit/63217e08cc041d0c4ce6df4e981899bfbc557de5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63217e08cc041d0c4ce6df4e981899bfbc557de5/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed6a7cc22815e45cd0418b0b2b28b22238d9e81e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed6a7cc22815e45cd0418b0b2b28b22238d9e81e", "html_url": "https://github.com/rust-lang/rust/commit/ed6a7cc22815e45cd0418b0b2b28b22238d9e81e"}], "stats": {"total": 207, "additions": 97, "deletions": 110}, "files": [{"sha": "7b4ad9fea137a7bd30bf835c5a86f528b058f764", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 97, "deletions": 110, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/63217e08cc041d0c4ce6df4e981899bfbc557de5/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63217e08cc041d0c4ce6df4e981899bfbc557de5/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=63217e08cc041d0c4ce6df4e981899bfbc557de5", "patch": "@@ -2,20 +2,18 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc_trait_selection::traits::query::dropck_outlives::{\n     DropckConstraint, DropckOutlivesResult,\n };\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::{\n-    Normalized, ObligationCause, TraitEngine, TraitEngineExt as _,\n-};\n+use rustc_trait_selection::traits::{Normalized, ObligationCause};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };\n@@ -27,120 +25,109 @@ fn dropck_outlives<'tcx>(\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>, NoSolution> {\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n \n-    let (ref infcx, goal, canonical_inference_vars) =\n-        tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-    let tcx = infcx.tcx;\n-    let ParamEnvAnd { param_env, value: for_ty } = goal;\n-\n-    let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n-\n-    // A stack of types left to process. Each round, we pop\n-    // something from the stack and invoke\n-    // `dtorck_constraint_for_ty`. This may produce new types that\n-    // have to be pushed on the stack. This continues until we have explored\n-    // all the reachable types from the type `for_ty`.\n-    //\n-    // Example: Imagine that we have the following code:\n-    //\n-    // ```rust\n-    // struct A {\n-    //     value: B,\n-    //     children: Vec<A>,\n-    // }\n-    //\n-    // struct B {\n-    //     value: u32\n-    // }\n-    //\n-    // fn f() {\n-    //   let a: A = ...;\n-    //   ..\n-    // } // here, `a` is dropped\n-    // ```\n-    //\n-    // at the point where `a` is dropped, we need to figure out\n-    // which types inside of `a` contain region data that may be\n-    // accessed by any destructors in `a`. We begin by pushing `A`\n-    // onto the stack, as that is the type of `a`. We will then\n-    // invoke `dtorck_constraint_for_ty` which will expand `A`\n-    // into the types of its fields `(B, Vec<A>)`. These will get\n-    // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-    // lead to us trying to push `A` a second time -- to prevent\n-    // infinite recursion, we notice that `A` was already pushed\n-    // once and stop.\n-    let mut ty_stack = vec![(for_ty, 0)];\n-\n-    // Set used to detect infinite recursion.\n-    let mut ty_set = FxHashSet::default();\n-\n-    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-    let cause = ObligationCause::dummy();\n-    let mut constraints = DropckConstraint::empty();\n-    while let Some((ty, depth)) = ty_stack.pop() {\n-        debug!(\n-            \"{} kinds, {} overflows, {} ty_stack\",\n-            result.kinds.len(),\n-            result.overflows.len(),\n-            ty_stack.len()\n-        );\n-        dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n-\n-        // \"outlives\" represent types/regions that may be touched\n-        // by a destructor.\n-        result.kinds.append(&mut constraints.outlives);\n-        result.overflows.append(&mut constraints.overflows);\n-\n-        // If we have even one overflow, we should stop trying to evaluate further --\n-        // chances are, the subsequent overflows for this evaluation won't provide useful\n-        // information and will just decrease the speed at which we can emit these errors\n-        // (since we'll be printing for just that much longer for the often enormous types\n-        // that result here).\n-        if !result.overflows.is_empty() {\n-            break;\n-        }\n+    tcx.infer_ctxt().enter_canonical_trait_query(&canonical_goal, |ocx, goal| {\n+        let tcx = ocx.infcx.tcx;\n+        let ParamEnvAnd { param_env, value: for_ty } = goal;\n+\n+        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+        // A stack of types left to process. Each round, we pop\n+        // something from the stack and invoke\n+        // `dtorck_constraint_for_ty`. This may produce new types that\n+        // have to be pushed on the stack. This continues until we have explored\n+        // all the reachable types from the type `for_ty`.\n+        //\n+        // Example: Imagine that we have the following code:\n+        //\n+        // ```rust\n+        // struct A {\n+        //     value: B,\n+        //     children: Vec<A>,\n+        // }\n+        //\n+        // struct B {\n+        //     value: u32\n+        // }\n+        //\n+        // fn f() {\n+        //   let a: A = ...;\n+        //   ..\n+        // } // here, `a` is dropped\n+        // ```\n+        //\n+        // at the point where `a` is dropped, we need to figure out\n+        // which types inside of `a` contain region data that may be\n+        // accessed by any destructors in `a`. We begin by pushing `A`\n+        // onto the stack, as that is the type of `a`. We will then\n+        // invoke `dtorck_constraint_for_ty` which will expand `A`\n+        // into the types of its fields `(B, Vec<A>)`. These will get\n+        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+        // lead to us trying to push `A` a second time -- to prevent\n+        // infinite recursion, we notice that `A` was already pushed\n+        // once and stop.\n+        let mut ty_stack = vec![(for_ty, 0)];\n+\n+        // Set used to detect infinite recursion.\n+        let mut ty_set = FxHashSet::default();\n+\n+        let cause = ObligationCause::dummy();\n+        let mut constraints = DropckConstraint::empty();\n+        while let Some((ty, depth)) = ty_stack.pop() {\n+            debug!(\n+                \"{} kinds, {} overflows, {} ty_stack\",\n+                result.kinds.len(),\n+                result.overflows.len(),\n+                ty_stack.len()\n+            );\n+            dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n+\n+            // \"outlives\" represent types/regions that may be touched\n+            // by a destructor.\n+            result.kinds.append(&mut constraints.outlives);\n+            result.overflows.append(&mut constraints.overflows);\n+\n+            // If we have even one overflow, we should stop trying to evaluate further --\n+            // chances are, the subsequent overflows for this evaluation won't provide useful\n+            // information and will just decrease the speed at which we can emit these errors\n+            // (since we'll be printing for just that much longer for the often enormous types\n+            // that result here).\n+            if !result.overflows.is_empty() {\n+                break;\n+            }\n \n-        // dtorck types are \"types that will get dropped but which\n-        // do not themselves define a destructor\", more or less. We have\n-        // to push them onto the stack to be expanded.\n-        for ty in constraints.dtorck_types.drain(..) {\n-            match infcx.at(&cause, param_env).normalize(ty) {\n-                Ok(Normalized { value: ty, obligations }) => {\n-                    fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                    debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                    match ty.kind() {\n-                        // All parameters live for the duration of the\n-                        // function.\n-                        ty::Param(..) => {}\n-\n-                        // A projection that we couldn't resolve - it\n-                        // might have a destructor.\n-                        ty::Projection(..) | ty::Opaque(..) => {\n-                            result.kinds.push(ty.into());\n-                        }\n+            // dtorck types are \"types that will get dropped but which\n+            // do not themselves define a destructor\", more or less. We have\n+            // to push them onto the stack to be expanded.\n+            for ty in constraints.dtorck_types.drain(..) {\n+                let Normalized { value: ty, obligations } =\n+                    ocx.infcx.at(&cause, param_env).normalize(ty)?;\n+                ocx.register_obligations(obligations);\n+\n+                debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+                match ty.kind() {\n+                    // All parameters live for the duration of the\n+                    // function.\n+                    ty::Param(..) => {}\n+\n+                    // A projection that we couldn't resolve - it\n+                    // might have a destructor.\n+                    ty::Projection(..) | ty::Opaque(..) => {\n+                        result.kinds.push(ty.into());\n+                    }\n \n-                        _ => {\n-                            if ty_set.insert(ty) {\n-                                ty_stack.push((ty, depth + 1));\n-                            }\n+                    _ => {\n+                        if ty_set.insert(ty) {\n+                            ty_stack.push((ty, depth + 1));\n                         }\n                     }\n                 }\n-\n-                // We don't actually expect to fail to normalize.\n-                // That implies a WF error somewhere else.\n-                Err(NoSolution) => {\n-                    return Err(NoSolution);\n-                }\n             }\n         }\n-    }\n-\n-    debug!(\"dropck_outlives: result = {:#?}\", result);\n \n-    infcx.make_canonicalized_query_response(canonical_inference_vars, result, &mut *fulfill_cx)\n+        debug!(\"dropck_outlives: result = {:#?}\", result);\n+        Ok(result)\n+    })\n }\n \n /// Returns a set of constraints that needs to be satisfied in"}]}