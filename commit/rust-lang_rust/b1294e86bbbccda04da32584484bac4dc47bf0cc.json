{"sha": "b1294e86bbbccda04da32584484bac4dc47bf0cc", "node_id": "C_kwDOAAsO6NoAKGIxMjk0ZTg2YmJiY2NkYTA0ZGEzMjU4NDQ4NGJhYzRkYzQ3YmYwY2M", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-27T20:15:58Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-03T10:03:20Z"}, "message": "Manipulate lifetimes by LocalDefId for region resolution.", "tree": {"sha": "9ffda939269ecad790f9ac98092bdfcc1e89c0ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ffda939269ecad790f9ac98092bdfcc1e89c0ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1294e86bbbccda04da32584484bac4dc47bf0cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1294e86bbbccda04da32584484bac4dc47bf0cc", "html_url": "https://github.com/rust-lang/rust/commit/b1294e86bbbccda04da32584484bac4dc47bf0cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1294e86bbbccda04da32584484bac4dc47bf0cc/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a90bedb332d7d7eabfc1e98a1e3d96898579e1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a90bedb332d7d7eabfc1e98a1e3d96898579e1d", "html_url": "https://github.com/rust-lang/rust/commit/3a90bedb332d7d7eabfc1e98a1e3d96898579e1d"}], "stats": {"total": 331, "additions": 161, "deletions": 170}, "files": [{"sha": "d1ea76b392223c9b76bf53c918b9c261e11d602d", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -672,9 +672,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Param { .. } => {\n                 (hir::ParamName::Plain(ident), hir::LifetimeParamKind::Explicit)\n             }\n-            LifetimeRes::Fresh { param, .. } => {\n-                (hir::ParamName::Fresh(param), hir::LifetimeParamKind::Elided)\n-            }\n+            LifetimeRes::Fresh { .. } => (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided),\n             LifetimeRes::Static | LifetimeRes::Error => return None,\n             res => panic!(\n                 \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n@@ -1576,10 +1574,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     (hir::ParamName::Plain(ident), LifetimeRes::Param { param, binder: fn_node_id })\n                 }\n                 // Input lifetime like `'1`:\n-                LifetimeRes::Fresh { param, .. } => (\n-                    hir::ParamName::Fresh(outer_def_id),\n-                    LifetimeRes::Fresh { param, binder: fn_node_id },\n-                ),\n+                LifetimeRes::Fresh { param, .. } => {\n+                    (hir::ParamName::Fresh, LifetimeRes::Fresh { param, binder: fn_node_id })\n+                }\n                 LifetimeRes::Static | LifetimeRes::Error => continue,\n                 res => {\n                     panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span)\n@@ -1749,18 +1746,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::Lifetime {\n         debug!(?self.captured_lifetimes);\n         let name = match res {\n-            LifetimeRes::Param { param, binder } => {\n+            LifetimeRes::Param { mut param, binder } => {\n                 debug_assert_ne!(ident.name, kw::UnderscoreLifetime);\n                 let p_name = ParamName::Plain(ident);\n                 if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n                     &mut self.captured_lifetimes\n                     && !binders_to_ignore.contains(&binder)\n                 {\n                     match captures.entry(param) {\n-                        Entry::Occupied(_) => {}\n+                        Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n                         Entry::Vacant(v) => {\n                             let p_id = self.resolver.next_node_id();\n-                            self.resolver.create_def(\n+                            let p_def_id = self.resolver.create_def(\n                                 *parent_def_id,\n                                 p_id,\n                                 DefPathData::LifetimeNs(p_name.ident().name),\n@@ -1769,10 +1766,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             );\n \n                             v.insert((span, p_id, p_name, res));\n+                            param = p_def_id;\n                         }\n                     }\n                 }\n-                hir::LifetimeName::Param(p_name)\n+                hir::LifetimeName::Param(param, p_name)\n             }\n             LifetimeRes::Fresh { mut param, binder } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n@@ -1792,21 +1790,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 span.with_parent(None),\n                             );\n \n-                            let p_name = ParamName::Fresh(param);\n-                            v.insert((span, p_id, p_name, res));\n+                            v.insert((span, p_id, ParamName::Fresh, res));\n                             param = p_def_id;\n                         }\n                     }\n                 }\n-                let p_name = ParamName::Fresh(param);\n-                hir::LifetimeName::Param(p_name)\n+                hir::LifetimeName::Param(param, ParamName::Fresh)\n             }\n             LifetimeRes::Anonymous { binder, elided } => {\n-                let l_name = if elided {\n-                    hir::LifetimeName::Implicit\n-                } else {\n-                    hir::LifetimeName::Underscore\n-                };\n                 if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n                     &mut self.captured_lifetimes\n                     && !binders_to_ignore.contains(&binder)\n@@ -1819,18 +1810,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         ExpnId::root(),\n                         span.with_parent(None),\n                     );\n-                    let p_name = ParamName::Fresh(p_def_id);\n-                    captures.insert(p_def_id, (span, p_id, p_name, res));\n-                    hir::LifetimeName::Param(p_name)\n+                    captures.insert(p_def_id, (span, p_id, ParamName::Fresh, res));\n+                    hir::LifetimeName::Param(p_def_id, ParamName::Fresh)\n+                } else if elided {\n+                    hir::LifetimeName::Implicit\n                 } else {\n-                    l_name\n+                    hir::LifetimeName::Underscore\n                 }\n             }\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,\n             res => panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span),\n         };\n         debug!(?self.captured_lifetimes);\n+        debug!(?name);\n         hir::Lifetime { hir_id: self.lower_node_id(id), span: self.lower_span(span), name }\n     }\n "}, {"sha": "fcb6ae438fed9768726737a68858817e8593d9de", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -567,14 +567,14 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let lifetime =\n             self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n         match lifetime.name {\n-            hir::LifetimeName::Param(hir::ParamName::Plain(_) | hir::ParamName::Error)\n+            hir::LifetimeName::Param(_, hir::ParamName::Plain(_) | hir::ParamName::Error)\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static => {\n                 let lifetime_span = lifetime.span;\n                 Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n             }\n \n-            hir::LifetimeName::Param(hir::ParamName::Fresh(_))\n+            hir::LifetimeName::Param(_, hir::ParamName::Fresh)\n             | hir::LifetimeName::ImplicitObjectLifetimeDefault\n             | hir::LifetimeName::Implicit\n             | hir::LifetimeName::Underscore => {"}, {"sha": "b98d4341118628544ae65a239477dba0fa74f66a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -26,7 +26,7 @@ use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n use std::fmt;\n \n-#[derive(Copy, Clone, Encodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -60,7 +60,7 @@ pub enum ParamName {\n     /// ```\n     /// where `'f` is something like `Fresh(0)`. The indices are\n     /// unique per impl, but not necessarily continuous.\n-    Fresh(LocalDefId),\n+    Fresh,\n \n     /// Indicates an illegal name was given and an error has been\n     /// reported (so we should squelch other derived errors). Occurs\n@@ -72,9 +72,7 @@ impl ParamName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             ParamName::Plain(ident) => ident,\n-            ParamName::Fresh(_) | ParamName::Error => {\n-                Ident::with_dummy_span(kw::UnderscoreLifetime)\n-            }\n+            ParamName::Fresh | ParamName::Error => Ident::with_dummy_span(kw::UnderscoreLifetime),\n         }\n     }\n \n@@ -90,7 +88,7 @@ impl ParamName {\n #[derive(HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n-    Param(ParamName),\n+    Param(LocalDefId, ParamName),\n \n     /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n@@ -127,7 +125,7 @@ impl LifetimeName {\n             | LifetimeName::Error => Ident::empty(),\n             LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n-            LifetimeName::Param(param_name) => param_name.ident(),\n+            LifetimeName::Param(_, param_name) => param_name.ident(),\n         }\n     }\n \n@@ -136,9 +134,9 @@ impl LifetimeName {\n             LifetimeName::ImplicitObjectLifetimeDefault\n             | LifetimeName::Implicit\n             | LifetimeName::Underscore\n-            | LifetimeName::Param(ParamName::Fresh(_))\n+            | LifetimeName::Param(_, ParamName::Fresh)\n             | LifetimeName::Error => true,\n-            LifetimeName::Static | LifetimeName::Param(_) => false,\n+            LifetimeName::Static | LifetimeName::Param(..) => false,\n         }\n     }\n \n@@ -148,12 +146,12 @@ impl LifetimeName {\n             | LifetimeName::Implicit\n             | LifetimeName::Underscore => true,\n \n-            // It might seem surprising that `Fresh(_)` counts as\n+            // It might seem surprising that `Fresh` counts as\n             // *not* elided -- but this is because, as far as the code\n-            // in the compiler is concerned -- `Fresh(_)` variants act\n+            // in the compiler is concerned -- `Fresh` variants act\n             // equivalently to \"some fresh name\". They correspond to\n             // early-bound regions on an impl, in other words.\n-            LifetimeName::Error | LifetimeName::Param(_) | LifetimeName::Static => false,\n+            LifetimeName::Error | LifetimeName::Param(..) | LifetimeName::Static => false,\n         }\n     }\n \n@@ -163,8 +161,8 @@ impl LifetimeName {\n \n     pub fn normalize_to_macros_2_0(&self) -> LifetimeName {\n         match *self {\n-            LifetimeName::Param(param_name) => {\n-                LifetimeName::Param(param_name.normalize_to_macros_2_0())\n+            LifetimeName::Param(def_id, param_name) => {\n+                LifetimeName::Param(def_id, param_name.normalize_to_macros_2_0())\n             }\n             lifetime_name => lifetime_name,\n         }\n@@ -177,12 +175,6 @@ impl fmt::Display for Lifetime {\n     }\n }\n \n-impl fmt::Debug for Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"lifetime({}: {})\", self.hir_id, self.name.ident())\n-    }\n-}\n-\n impl Lifetime {\n     pub fn is_elided(&self) -> bool {\n         self.name.is_elided()\n@@ -628,6 +620,16 @@ impl<'hir> Generics<'hir> {\n         })\n     }\n \n+    pub fn outlives_for_param(\n+        &self,\n+        param_def_id: LocalDefId,\n+    ) -> impl Iterator<Item = &WhereRegionPredicate<'_>> {\n+        self.predicates.iter().filter_map(move |pred| match pred {\n+            WherePredicate::RegionPredicate(rp) if rp.is_param_bound(param_def_id) => Some(rp),\n+            _ => None,\n+        })\n+    }\n+\n     pub fn bounds_span_for_suggestions(&self, param_def_id: LocalDefId) -> Option<Span> {\n         self.bounds_for_param(param_def_id).flat_map(|bp| bp.bounds.iter().rev()).find_map(\n             |bound| {\n@@ -769,6 +771,16 @@ pub struct WhereRegionPredicate<'hir> {\n     pub bounds: GenericBounds<'hir>,\n }\n \n+impl<'hir> WhereRegionPredicate<'hir> {\n+    /// Returns `true` if `param_def_id` matches the `lifetime` of this predicate.\n+    pub fn is_param_bound(&self, param_def_id: LocalDefId) -> bool {\n+        match self.lifetime.name {\n+            LifetimeName::Param(id, _) => id == param_def_id,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// An equality predicate (e.g., `T = int`); currently unsupported.\n #[derive(Debug, HashStable_Generic)]\n pub struct WhereEqPredicate<'hir> {"}, {"sha": "bd8587f1106e9ad708fbf007bbbec54e73d64e1c", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -510,11 +510,11 @@ pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.hir_id);\n     match lifetime.name {\n-        LifetimeName::Param(ParamName::Plain(ident)) => {\n+        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n             visitor.visit_ident(ident);\n         }\n-        LifetimeName::Param(ParamName::Fresh(_))\n-        | LifetimeName::Param(ParamName::Error)\n+        LifetimeName::Param(_, ParamName::Fresh)\n+        | LifetimeName::Param(_, ParamName::Error)\n         | LifetimeName::Static\n         | LifetimeName::Error\n         | LifetimeName::Implicit\n@@ -879,7 +879,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n     visitor.visit_id(param.hir_id);\n     match param.name {\n         ParamName::Plain(ident) => visitor.visit_ident(ident),\n-        ParamName::Error | ParamName::Fresh(_) => {}\n+        ParamName::Error | ParamName::Fresh => {}\n     }\n     match param.kind {\n         GenericParamKind::Lifetime { .. } => {}"}, {"sha": "cdc0d07680193ef54818efa149a235e4d4b8b0db", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -6,7 +6,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::ItemLocalId;\n use rustc_macros::HashStable;\n-use rustc_span::symbol::Symbol;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Region {\n@@ -22,12 +21,12 @@ pub enum Region {\n /// so that we can e.g. suggest elided-lifetimes-in-paths of the form <'_, '_> e.g.\n #[derive(Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum LifetimeScopeForPath {\n-    // Contains all lifetime names that are in scope and could possibly be used in generics\n-    // arguments of path.\n-    NonElided(Vec<Symbol>),\n+    /// Contains all lifetime names that are in scope and could possibly be used in generics\n+    /// arguments of path.\n+    NonElided(Vec<LocalDefId>),\n \n-    // Information that allows us to suggest args of the form `<'_>` in case\n-    // no generic arguments were provided for a path.\n+    /// Information that allows us to suggest args of the form `<'_>` in case\n+    /// no generic arguments were provided for a path.\n     Elided,\n }\n "}, {"sha": "cb39eb5416ba27dbc2822d8529ffb2d32ef6b870", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -13,15 +13,15 @@ use rustc_ast::{\n };\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust::path_segment_to_string;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n     MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -2082,7 +2082,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n \n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n     pub(crate) fn report_elision_failure(\n-        &mut self,\n+        &self,\n         diag: &mut Diagnostic,\n         params: &[ElisionFailureInfo],\n     ) -> bool {\n@@ -2187,10 +2187,27 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         mut spans_with_counts: Vec<(Span, usize)>,\n-        lifetime_names: &FxHashSet<Symbol>,\n-        lifetime_spans: Vec<Span>,\n-        params: &[ElisionFailureInfo],\n+        in_scope_lifetimes: FxIndexSet<LocalDefId>,\n+        params: Option<&[ElisionFailureInfo]>,\n     ) {\n+        let (mut lifetime_names, lifetime_spans): (FxHashSet<_>, Vec<_>) = in_scope_lifetimes\n+            .iter()\n+            .filter_map(|def_id| {\n+                let name = self.tcx.item_name(def_id.to_def_id());\n+                let span = self.tcx.def_ident_span(def_id.to_def_id())?;\n+                Some((name, span))\n+            })\n+            .filter(|&(n, _)| n != kw::UnderscoreLifetime)\n+            .unzip();\n+\n+        if let Some(params) = params {\n+            // If there's no lifetime available, suggest `'static`.\n+            if self.report_elision_failure(err, params) && lifetime_names.is_empty() {\n+                lifetime_names.insert(kw::StaticLifetime);\n+            }\n+        }\n+        let params = params.unwrap_or(&[]);\n+\n         let snippets: Vec<Option<String>> = spans_with_counts\n             .iter()\n             .map(|(span, _)| self.tcx.sess.source_map().span_to_snippet(*span).ok())"}, {"sha": "6cd81aa7dac13581508aea6f0b9162ebbf46f98c", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 64, "deletions": 83, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -8,14 +8,14 @@\n \n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc_ast::walk_list;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::hir_id::ItemLocalId;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node, ParamName};\n+use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node};\n use rustc_hir::{GenericParamKind, HirIdMap, HirIdSet};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n@@ -33,9 +33,9 @@ use std::mem::take;\n use tracing::{debug, span, Level};\n \n trait RegionExt {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n-    fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n     fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region;\n \n@@ -51,22 +51,22 @@ trait RegionExt {\n }\n \n impl RegionExt for Region {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id.to_def_id()))\n+        (def_id, Region::EarlyBound(i, def_id.to_def_id()))\n     }\n \n-    fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n         let depth = ty::INNERMOST;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         debug!(\n             \"Region::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n             idx, param, depth, def_id,\n         );\n-        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, idx, def_id.to_def_id()))\n+        (def_id, Region::LateBound(depth, idx, def_id.to_def_id()))\n     }\n \n     fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region {\n@@ -178,7 +178,7 @@ enum Scope<'a> {\n     Binder {\n         /// We use an IndexMap here because we want these lifetimes in order\n         /// for diagnostics.\n-        lifetimes: FxIndexMap<hir::ParamName, Region>,\n+        lifetimes: FxIndexMap<LocalDefId, Region>,\n \n         /// if we extend this scope with another scope, what is the next index\n         /// we should use for an early-bound region?\n@@ -554,10 +554,7 @@ fn get_lifetime_scopes_for_path(mut scope: &Scope<'_>) -> LifetimeScopeForPath {\n     loop {\n         match scope {\n             Scope::Binder { lifetimes, s, .. } => {\n-                available_lifetimes.extend(lifetimes.keys().filter_map(|p| match p {\n-                    hir::ParamName::Plain(ident) => Some(ident.name),\n-                    _ => None,\n-                }));\n+                available_lifetimes.extend(lifetimes.keys());\n                 scope = s;\n             }\n             Scope::Body { s, .. } => {\n@@ -841,7 +838,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.missing_named_lifetime_spots\n                     .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n-                let (lifetimes, binders): (FxIndexMap<hir::ParamName, Region>, Vec<_>) = c\n+                let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n                     .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n@@ -898,7 +895,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // cc #48468\n                         self.resolve_elided_lifetimes(&[lifetime])\n                     }\n-                    LifetimeName::Param(_) | LifetimeName::Static => {\n+                    LifetimeName::Param(..) | LifetimeName::Static => {\n                         // If the user wrote an explicit name, use that.\n                         self.visit_lifetime(lifetime);\n                     }\n@@ -1016,17 +1013,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (name, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n+                            let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n                             if let hir::ParamName::Plain(Ident {\n                                 name: kw::UnderscoreLifetime,\n                                 ..\n-                            }) = name\n+                            }) = param.name\n                             {\n                                 // Pick the elided lifetime \"definition\" if one exists\n                                 // and use it to make an elision scope.\n                                 elision = Some(reg);\n                             } else {\n-                                lifetimes.insert(name, reg);\n+                                lifetimes.insert(def_id, reg);\n                             }\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n@@ -1174,7 +1171,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes: FxIndexMap<hir::ParamName, Region> = generics\n+                let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n@@ -1218,15 +1215,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n-        if lifetime_ref.is_elided() {\n-            self.resolve_elided_lifetimes(&[lifetime_ref]);\n-            return;\n-        }\n-        if lifetime_ref.is_static() {\n-            self.insert_lifetime(lifetime_ref, Region::Static);\n-            return;\n+        match lifetime_ref.name {\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault\n+            | hir::LifetimeName::Implicit\n+            | hir::LifetimeName::Underscore => self.resolve_elided_lifetimes(&[lifetime_ref]),\n+            hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n+            hir::LifetimeName::Param(param_def_id, _) => {\n+                self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n+            }\n+            // If we've already reported an error, just ignore `lifetime_ref`.\n+            hir::LifetimeName::Error => {}\n         }\n-        self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n     fn visit_assoc_type_binding(&mut self, type_binding: &'tcx hir::TypeBinding<'_>) {\n@@ -1311,7 +1310,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         ref bound_generic_params,\n                         ..\n                     }) => {\n-                        let (lifetimes, binders): (FxIndexMap<hir::ParamName, Region>, Vec<_>) =\n+                        let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n                             bound_generic_params\n                                 .iter()\n                                 .filter(|param| {\n@@ -1433,7 +1432,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n-        let mut lifetimes: FxIndexMap<hir::ParamName, Region> = FxIndexMap::default();\n+        let mut lifetimes: FxIndexMap<LocalDefId, Region> = FxIndexMap::default();\n         let binders_iter = trait_ref\n             .bound_generic_params\n             .iter()\n@@ -1580,14 +1579,17 @@ fn object_lifetime_defaults_for_item<'tcx>(\n                             .iter()\n                             .filter_map(|param| match param.kind {\n                                 GenericParamKind::Lifetime { .. } => {\n-                                    Some((param.hir_id, hir::LifetimeName::Param(param.name)))\n+                                    let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+                                    Some((\n+                                        param_def_id,\n+                                        hir::LifetimeName::Param(param_def_id, param.name),\n+                                    ))\n                                 }\n                                 _ => None,\n                             })\n                             .enumerate()\n                             .find(|&(_, (_, lt_name))| lt_name == name)\n-                            .map_or(Set1::Many, |(i, (id, _))| {\n-                                let def_id = tcx.hir().local_def_id(id);\n+                            .map_or(Set1::Many, |(i, (def_id, _))| {\n                                 Set1::One(Region::EarlyBound(i as u32, def_id.to_def_id()))\n                             })\n                     }\n@@ -1660,7 +1662,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n-        insert_late_bound_lifetimes(self.map, decl, generics);\n+        insert_late_bound_lifetimes(self.tcx, self.map, decl, generics);\n \n         // Find the start of nested early scopes, e.g., in methods.\n         let mut next_early_index = 0;\n@@ -1680,7 +1682,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut non_lifetime_count = 0;\n         let mut named_late_bound_vars = 0;\n-        let lifetimes: FxIndexMap<hir::ParamName, Region> = generics\n+        let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n             .params\n             .iter()\n             .filter_map(|param| match param.kind {\n@@ -1763,14 +1765,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.next_early_index_helper(false)\n     }\n \n-    fn resolve_lifetime_ref(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n-        debug!(\"resolve_lifetime_ref(lifetime_ref={:?})\", lifetime_ref);\n-\n-        // If we've already reported an error, just ignore `lifetime_ref`.\n-        if let LifetimeName::Error = lifetime_ref.name {\n-            return;\n-        }\n-\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_lifetime_ref(\n+        &mut self,\n+        region_def_id: LocalDefId,\n+        lifetime_ref: &'tcx hir::Lifetime,\n+    ) {\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n         // given name or we run out of scopes.\n@@ -1790,14 +1790,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::Binder { ref lifetimes, scope_type, s, .. } => {\n-                    match lifetime_ref.name {\n-                        LifetimeName::Param(param_name) => {\n-                            if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n-                            {\n-                                break Some(def.shifted(late_depth));\n-                            }\n-                        }\n-                        _ => bug!(\"expected LifetimeName::Param\"),\n+                    if let Some(&def) = lifetimes.get(&region_def_id) {\n+                        break Some(def.shifted(late_depth));\n                     }\n                     match scope_type {\n                         BinderScopeType::Normal => late_depth += 1,\n@@ -2473,8 +2467,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut late_depth = 0;\n         let mut scope = self.scope;\n-        let mut lifetime_names = FxHashSet::default();\n-        let mut lifetime_spans = vec![];\n+        let mut in_scope_lifetimes = FxIndexSet::default();\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n@@ -2484,12 +2477,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Binder { s, ref lifetimes, scope_type, .. } => {\n                     // collect named lifetimes for suggestions\n-                    for name in lifetimes.keys() {\n-                        if let hir::ParamName::Plain(name) = name {\n-                            lifetime_names.insert(name.name);\n-                            lifetime_spans.push(name.span);\n-                        }\n-                    }\n+                    in_scope_lifetimes.extend(lifetimes.keys().copied());\n                     match scope_type {\n                         BinderScopeType::Normal => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n@@ -2524,12 +2512,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         match scope {\n                             Scope::Binder { ref lifetimes, s, .. } => {\n                                 // Collect named lifetimes for suggestions.\n-                                for name in lifetimes.keys() {\n-                                    if let hir::ParamName::Plain(name) = name {\n-                                        lifetime_names.insert(name.name);\n-                                        lifetime_spans.push(name.span);\n-                                    }\n-                                }\n+                                in_scope_lifetimes.extend(lifetimes.keys().copied());\n                                 scope = s;\n                             }\n                             Scope::ObjectLifetimeDefault { ref s, .. }\n@@ -2574,19 +2557,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut err = self.report_missing_lifetime_specifiers(spans.clone(), lifetime_refs.len());\n \n-        if let Some(params) = error {\n-            // If there's no lifetime available, suggest `'static`.\n-            if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(kw::StaticLifetime);\n-            }\n-        }\n-\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n             spans_with_counts,\n-            &lifetime_names,\n-            lifetime_spans,\n-            error.unwrap_or(&[]),\n+            in_scope_lifetimes,\n+            error,\n         );\n         err.emit();\n     }\n@@ -2647,8 +2622,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// \"Constrained\" basically means that it appears in any type but\n /// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n-#[tracing::instrument(level = \"debug\", skip(map))]\n+#[tracing::instrument(level = \"debug\", skip(tcx, map))]\n fn insert_late_bound_lifetimes(\n+    tcx: TyCtxt<'_>,\n     map: &mut NamedRegionMap,\n     decl: &hir::FnDecl<'_>,\n     generics: &hir::Generics<'_>,\n@@ -2683,15 +2659,16 @@ fn insert_late_bound_lifetimes(\n             hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => continue,\n         }\n \n-        let lt_name = hir::LifetimeName::Param(param.name.normalize_to_macros_2_0());\n+        let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+\n         // appears in the where clauses? early-bound.\n-        if appears_in_where_clause.regions.contains(&lt_name) {\n+        if appears_in_where_clause.regions.contains(&param_def_id) {\n             continue;\n         }\n \n         // does not appear in the inputs, but appears in the return type? early-bound.\n-        if !constrained_by_input.regions.contains(&lt_name)\n-            && appears_in_output.regions.contains(&lt_name)\n+        if !constrained_by_input.regions.contains(&param_def_id)\n+            && appears_in_output.regions.contains(&param_def_id)\n         {\n             continue;\n         }\n@@ -2706,7 +2683,7 @@ fn insert_late_bound_lifetimes(\n \n     #[derive(Default)]\n     struct ConstrainedCollector {\n-        regions: FxHashSet<hir::LifetimeName>,\n+        regions: FxHashSet<LocalDefId>,\n     }\n \n     impl<'v> Visitor<'v> for ConstrainedCollector {\n@@ -2738,18 +2715,22 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n+            if let hir::LifetimeName::Param(def_id, _) = lifetime_ref.name {\n+                self.regions.insert(def_id);\n+            }\n         }\n     }\n \n     #[derive(Default)]\n     struct AllCollector {\n-        regions: FxHashSet<hir::LifetimeName>,\n+        regions: FxHashSet<LocalDefId>,\n     }\n \n     impl<'v> Visitor<'v> for AllCollector {\n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n+            if let hir::LifetimeName::Param(def_id, _) = lifetime_ref.name {\n+                self.regions.insert(def_id);\n+            }\n         }\n     }\n }"}, {"sha": "bc3a3db9fdadb3e7ce35a12f4d6c71f7fd39f738", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -514,7 +514,9 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n                             param_names\n                                 .iter()\n                                 .take(num_params_to_take)\n-                                .map(|p| p.as_str())\n+                                .map(|def_id| {\n+                                    self.tcx.item_name(def_id.to_def_id()).to_ident_string()\n+                                })\n                                 .collect::<Vec<_>>()\n                                 .join(\", \")\n                         } else {"}, {"sha": "f3070fb35f1d09bf2354a034809c77990b2b267e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -475,24 +475,14 @@ fn clean_generic_param<'tcx>(\n     generics: Option<&hir::Generics<'tcx>>,\n     param: &hir::GenericParam<'tcx>,\n ) -> GenericParamDef {\n+    let did = cx.tcx.hir().local_def_id(param.hir_id);\n     let (name, kind) = match param.kind {\n         hir::GenericParamKind::Lifetime { .. } => {\n             let outlives = if let Some(generics) = generics {\n                 generics\n-                    .predicates\n-                    .iter()\n-                    .flat_map(|pred| {\n-                        match pred {\n-                            hir::WherePredicate::RegionPredicate(rp)\n-                                if rp.lifetime.name == hir::LifetimeName::Param(param.name)\n-                                    && !rp.in_where_clause =>\n-                            {\n-                                rp.bounds\n-                            }\n-                            _ => &[],\n-                        }\n-                        .iter()\n-                    })\n+                    .outlives_for_param(did)\n+                    .filter(|bp| !bp.in_where_clause)\n+                    .flat_map(|bp| bp.bounds)\n                     .map(|bound| match bound {\n                         hir::GenericBound::Outlives(lt) => lt.clean(cx),\n                         _ => panic!(),\n@@ -504,7 +494,6 @@ fn clean_generic_param<'tcx>(\n             (param.name.ident().name, GenericParamDefKind::Lifetime { outlives })\n         }\n         hir::GenericParamKind::Type { ref default, synthetic } => {\n-            let did = cx.tcx.hir().local_def_id(param.hir_id);\n             let bounds = if let Some(generics) = generics {\n                 generics\n                     .bounds_for_param(did)\n@@ -528,7 +517,7 @@ fn clean_generic_param<'tcx>(\n         hir::GenericParamKind::Const { ty, default } => (\n             param.name.ident().name,\n             GenericParamDefKind::Const {\n-                did: cx.tcx.hir().local_def_id(param.hir_id).to_def_id(),\n+                did: did.to_def_id(),\n                 ty: Box::new(ty.clean(cx)),\n                 default: default.map(|ct| {\n                     let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n@@ -1459,7 +1448,7 @@ impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n                 // Turning `fn f(&'_ self)` into `fn f(&self)` isn't the worst thing in the world, though;\n                 // there's no case where it could cause the function to fail to compile.\n                 let elided =\n-                    l.is_elided() || matches!(l.name, LifetimeName::Param(ParamName::Fresh(_)));\n+                    l.is_elided() || matches!(l.name, LifetimeName::Param(_, ParamName::Fresh));\n                 let lifetime = if elided { None } else { Some(l.clean(cx)) };\n                 BorrowedRef { lifetime, mutability: m.mutbl, type_: box m.ty.clean(cx) }\n             }"}, {"sha": "070c7e591420d49128fea3160076391425d2c615", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -371,7 +371,7 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n         if let Some(ref lt) = *lifetime {\n             if lt.name == LifetimeName::Static {\n                 self.lts.push(RefLt::Static);\n-            } else if let LifetimeName::Param(ParamName::Fresh(_)) = lt.name {\n+            } else if let LifetimeName::Param(_, ParamName::Fresh) = lt.name {\n                 // Fresh lifetimes generated should be ignored.\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);"}, {"sha": "0b96f6ff6835800aec2f42ec9614c88319c8425a", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -343,7 +343,7 @@ impl fmt::Display for RefPrefix {\n         use fmt::Write;\n         f.write_char('&')?;\n         match self.lt {\n-            LifetimeName::Param(ParamName::Plain(name)) => {\n+            LifetimeName::Param(_, ParamName::Plain(name)) => {\n                 name.fmt(f)?;\n                 f.write_char(' ')?;\n             },"}, {"sha": "fc1a4e1f6025555bb7c472d6c4c0968676bf3a9b", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1294e86bbbccda04da32584484bac4dc47bf0cc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1294e86bbbccda04da32584484bac4dc47bf0cc/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=b1294e86bbbccda04da32584484bac4dc47bf0cc", "patch": "@@ -902,16 +902,14 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_lifetime(&mut self, lifetime: Lifetime) {\n         std::mem::discriminant(&lifetime.name).hash(&mut self.s);\n-        if let LifetimeName::Param(ref name) = lifetime.name {\n+        if let LifetimeName::Param(param_id, ref name) = lifetime.name {\n             std::mem::discriminant(name).hash(&mut self.s);\n+            param_id.hash(&mut self.s);\n             match name {\n                 ParamName::Plain(ref ident) => {\n                     ident.name.hash(&mut self.s);\n                 },\n-                ParamName::Fresh(ref size) => {\n-                    size.hash(&mut self.s);\n-                },\n-                ParamName::Error => {},\n+                ParamName::Fresh | ParamName::Error => {},\n             }\n         }\n     }"}]}