{"sha": "b9178dc47c939c2a61ff6c872a1ff486df674d84", "node_id": "C_kwDOAAsO6NoAKGI5MTc4ZGM0N2M5MzljMmE2MWZmNmM4NzJhMWZmNDg2ZGY2NzRkODQ", "commit": {"author": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2021-10-20T04:38:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-20T04:38:47Z"}, "message": "Merge pull request #5036 from calebcartwright/1.4.38-subtree\n\nsync subtree", "tree": {"sha": "8711fc1fcfa4f8ba85586327ff56a38247b6ed26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8711fc1fcfa4f8ba85586327ff56a38247b6ed26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9178dc47c939c2a61ff6c872a1ff486df674d84", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhb51XCRBK7hj4Ov3rIwAAsz8IAIQPLlpIHKThorm3/zhPimCn\n3bqEtZup1mMx6jEUiEU3DrzMX8j8IGu1gbgEwX6viVGfZOw8PvB1gE/96JTUKugG\npdaqSn0ArlaJ3J8iP/URF2JHRGxaPPBEO5UzHolJ3LFSOU8m2j4912IFpX53do+h\n58kTrE3+oqo4esFF5iMG7pHJ3o7QRq4tIeuREQHLlf5aGu9brq0ZBZBP7Ih8fh1c\nSWZvTLpIYZ1tJGBEUL3DBk+nxGDbd0apm0XY3x70/nliuRaedeoDNKWYDqceRLQp\nFDuQy0z3neW8/5iPxyjIoKJgpp7UVmY5DghHLKwhrocBuAGGlWeUrd1ILYjSR2s=\n=yLWM\n-----END PGP SIGNATURE-----\n", "payload": "tree 8711fc1fcfa4f8ba85586327ff56a38247b6ed26\nparent 1ae5c35f8d2a0d2ce5d914a479839dc0f3eb70f9\nparent 5f79583c3c83aa3b8a832e4effacb9141de4c2aa\nauthor Caleb Cartwright <calebcartwright@users.noreply.github.com> 1634704727 -0500\ncommitter GitHub <noreply@github.com> 1634704727 -0500\n\nMerge pull request #5036 from calebcartwright/1.4.38-subtree\n\nsync subtree"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9178dc47c939c2a61ff6c872a1ff486df674d84", "html_url": "https://github.com/rust-lang/rust/commit/b9178dc47c939c2a61ff6c872a1ff486df674d84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9178dc47c939c2a61ff6c872a1ff486df674d84/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ae5c35f8d2a0d2ce5d914a479839dc0f3eb70f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae5c35f8d2a0d2ce5d914a479839dc0f3eb70f9", "html_url": "https://github.com/rust-lang/rust/commit/1ae5c35f8d2a0d2ce5d914a479839dc0f3eb70f9"}, {"sha": "5f79583c3c83aa3b8a832e4effacb9141de4c2aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f79583c3c83aa3b8a832e4effacb9141de4c2aa", "html_url": "https://github.com/rust-lang/rust/commit/5f79583c3c83aa3b8a832e4effacb9141de4c2aa"}], "stats": {"total": 218, "additions": 69, "deletions": 149}, "files": [{"sha": "d282766e00b4f638ec1d3eb442ac4492d0099cdf", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -2,14 +2,13 @@\n \n name = \"rustfmt-nightly\"\n version = \"1.4.37\"\n-authors = [\"Nicholas Cameron <ncameron@mozilla.com>\", \"The Rustfmt developers\"]\n description = \"Tool to find and fix Rust formatting issues\"\n repository = \"https://github.com/rust-lang/rustfmt\"\n readme = \"README.md\"\n license = \"Apache-2.0/MIT\"\n build = \"build.rs\"\n categories = [\"development-tools\"]\n-edition = \"2018\"\n+edition = \"2021\"\n \n [[bin]]\n name = \"rustfmt\""}, {"sha": "a41b3a5e6bf8846a0dcdc9b89f4d3b5313095904", "filename": "config_proc_macro/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/config_proc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/config_proc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2FCargo.toml?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -1,7 +1,6 @@\n [package]\n name = \"rustfmt-config_proc_macro\"\n version = \"0.2.0\"\n-authors = [\"topecongiro <seuchida@gmail.com>\"]\n edition = \"2018\"\n description = \"A collection of procedural macros for rustfmt\"\n license = \"Apache-2.0/MIT\""}, {"sha": "b19ecbdb07c4f425540264a618144618e7acbcab", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-07-23\"\n+channel = \"nightly-2021-10-20\"\n components = [\"rustc-dev\"]"}, {"sha": "34d73a77fd3d4fa6b41c5a7737b316865febcb13", "filename": "src/closures.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -160,6 +160,7 @@ fn rewrite_closure_with_block(\n             .first()\n             .map(|attr| attr.span.to(body.span))\n             .unwrap_or(body.span),\n+        could_be_bare_literal: false,\n     };\n     let block = crate::expr::rewrite_block_with_visitor(\n         context,"}, {"sha": "7f1dd363f9379a3bd971dbf87c93e4a0955a0cab", "filename": "src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -616,7 +616,7 @@ struct ControlFlow<'a> {\n \n fn extract_pats_and_cond(expr: &ast::Expr) -> (Option<&ast::Pat>, &ast::Expr) {\n     match expr.kind {\n-        ast::ExprKind::Let(ref pat, ref cond) => (Some(pat), cond),\n+        ast::ExprKind::Let(ref pat, ref cond, _) => (Some(pat), cond),\n         _ => (None, expr),\n     }\n }"}, {"sha": "1cb1a2701c36bf24f78109c56c45d320c4da2806", "filename": "src/items.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -6,7 +6,7 @@ use std::cmp::{max, min, Ordering};\n use regex::Regex;\n use rustc_ast::visit;\n use rustc_ast::{ast, ptr};\n-use rustc_span::{symbol, BytePos, Span};\n+use rustc_span::{symbol, BytePos, Span, DUMMY_SP};\n \n use crate::attr::filter_inline_attrs;\n use crate::comment::{\n@@ -31,7 +31,12 @@ use crate::stmt::Stmt;\n use crate::utils::*;\n use crate::vertical::rewrite_with_alignment;\n use crate::visitor::FmtVisitor;\n-use crate::DEFAULT_VISIBILITY;\n+\n+const DEFAULT_VISIBILITY: ast::Visibility = ast::Visibility {\n+    kind: ast::VisibilityKind::Inherited,\n+    span: DUMMY_SP,\n+    tokens: None,\n+};\n \n fn type_annotation_separator(config: &Config) -> &str {\n     colon_spaces(config)\n@@ -48,7 +53,7 @@ impl Rewrite for ast::Local {\n \n         skip_out_of_file_lines_range!(context, self.span);\n \n-        if contains_skip(&self.attrs) {\n+        if contains_skip(&self.attrs) || matches!(self.kind, ast::LocalKind::InitElse(..)) {\n             return None;\n         }\n \n@@ -97,7 +102,7 @@ impl Rewrite for ast::Local {\n                 infix.push_str(&rewrite);\n             }\n \n-            if self.init.is_some() {\n+            if self.kind.init().is_some() {\n                 infix.push_str(\" =\");\n             }\n \n@@ -106,11 +111,12 @@ impl Rewrite for ast::Local {\n \n         result.push_str(&infix);\n \n-        if let Some(ref ex) = self.init {\n+        if let Some((init, _els)) = self.kind.init_else_opt() {\n             // 1 = trailing semicolon;\n             let nested_shape = shape.sub_width(1)?;\n \n-            result = rewrite_assign_rhs(context, result, &**ex, nested_shape)?;\n+            result = rewrite_assign_rhs(context, result, init, nested_shape)?;\n+            // todo else\n         }\n \n         result.push(';');\n@@ -972,7 +978,7 @@ impl<'a> StructParts<'a> {\n         format_header(context, self.prefix, self.ident, self.vis, offset)\n     }\n \n-    pub(crate) fn from_variant(variant: &'a ast::Variant) -> Self {\n+    fn from_variant(variant: &'a ast::Variant) -> Self {\n         StructParts {\n             prefix: \"\",\n             ident: variant.ident,"}, {"sha": "47a7b9d4dbe3cb80baa2d08d979e9e94e2b56241", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -32,7 +32,7 @@ use std::path::PathBuf;\n use std::rc::Rc;\n \n use rustc_ast::ast;\n-use rustc_span::{symbol, DUMMY_SP};\n+use rustc_span::symbol;\n use thiserror::Error;\n \n use crate::comment::LineClasses;\n@@ -96,11 +96,6 @@ mod types;\n mod vertical;\n pub(crate) mod visitor;\n \n-const DEFAULT_VISIBILITY: ast::Visibility = ast::Visibility {\n-    kind: ast::VisibilityKind::Inherited,\n-    span: DUMMY_SP,\n-    tokens: None,\n-};\n /// The various errors that can occur during formatting. Note that not all of\n /// these can currently be propagated to clients.\n #[derive(Error, Debug)]"}, {"sha": "927187dfd8a2336b20220dd9e794bc04171f0eff", "filename": "src/macros.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -401,7 +401,7 @@ fn rewrite_macro_inner(\n                 handle_vec_semi(context, shape, arg_vec, macro_name, style)\n             } else {\n                 // If we are rewriting `vec!` macro or other special macros,\n-                // then we can rewrite this as an usual array literal.\n+                // then we can rewrite this as a usual array literal.\n                 // Otherwise, we must preserve the original existence of trailing comma.\n                 let macro_name = &macro_name.as_str();\n                 let mut force_trailing_comma = if trailing_comma {\n@@ -762,7 +762,6 @@ impl MacroArgKind {\n #[derive(Debug, Clone)]\n struct ParsedMacroArg {\n     kind: MacroArgKind,\n-    span: Span,\n }\n \n impl ParsedMacroArg {\n@@ -780,14 +779,10 @@ impl ParsedMacroArg {\n struct MacroArgParser {\n     /// Either a name of the next metavariable, a separator, or junk.\n     buf: String,\n-    /// The start position on the current buffer.\n-    lo: BytePos,\n     /// The first token of the current buffer.\n     start_tok: Token,\n     /// `true` if we are parsing a metavariable or a repeat.\n     is_meta_var: bool,\n-    /// The position of the last token.\n-    hi: BytePos,\n     /// The last token parsed.\n     last_tok: Token,\n     /// Holds the parsed arguments.\n@@ -807,8 +802,6 @@ fn last_tok(tt: &TokenTree) -> Token {\n impl MacroArgParser {\n     fn new() -> MacroArgParser {\n         MacroArgParser {\n-            lo: BytePos(0),\n-            hi: BytePos(0),\n             buf: String::new(),\n             is_meta_var: false,\n             last_tok: Token {\n@@ -824,7 +817,6 @@ impl MacroArgParser {\n     }\n \n     fn set_last_tok(&mut self, tok: &TokenTree) {\n-        self.hi = tok.span().hi();\n         self.last_tok = last_tok(tok);\n     }\n \n@@ -836,7 +828,6 @@ impl MacroArgParser {\n         };\n         self.result.push(ParsedMacroArg {\n             kind: MacroArgKind::Separator(self.buf.clone(), prefix),\n-            span: mk_sp(self.lo, self.hi),\n         });\n         self.buf.clear();\n     }\n@@ -849,7 +840,6 @@ impl MacroArgParser {\n         };\n         self.result.push(ParsedMacroArg {\n             kind: MacroArgKind::Other(self.buf.clone(), prefix),\n-            span: mk_sp(self.lo, self.hi),\n         });\n         self.buf.clear();\n     }\n@@ -858,11 +848,10 @@ impl MacroArgParser {\n         match iter.next() {\n             Some(TokenTree::Token(Token {\n                 kind: TokenKind::Ident(name, _),\n-                span,\n+                ..\n             })) => {\n                 self.result.push(ParsedMacroArg {\n                     kind: MacroArgKind::MetaVariable(name, self.buf.clone()),\n-                    span: mk_sp(self.lo, span.hi()),\n                 });\n \n                 self.buf.clear();\n@@ -873,10 +862,9 @@ impl MacroArgParser {\n         }\n     }\n \n-    fn add_delimited(&mut self, inner: Vec<ParsedMacroArg>, delim: DelimToken, span: Span) {\n+    fn add_delimited(&mut self, inner: Vec<ParsedMacroArg>, delim: DelimToken) {\n         self.result.push(ParsedMacroArg {\n             kind: MacroArgKind::Delimited(delim, inner),\n-            span,\n         });\n     }\n \n@@ -886,19 +874,15 @@ impl MacroArgParser {\n         inner: Vec<ParsedMacroArg>,\n         delim: DelimToken,\n         iter: &mut Cursor,\n-        span: Span,\n     ) -> Option<()> {\n         let mut buffer = String::new();\n         let mut first = true;\n-        let mut lo = span.lo();\n-        let mut hi = span.hi();\n \n         // Parse '*', '+' or '?.\n         for tok in iter {\n             self.set_last_tok(&tok);\n             if first {\n                 first = false;\n-                lo = tok.span().lo();\n             }\n \n             match tok {\n@@ -918,7 +902,6 @@ impl MacroArgParser {\n                 }\n                 TokenTree::Token(ref t) => {\n                     buffer.push_str(&pprust::token_to_string(&t));\n-                    hi = t.span.hi();\n                 }\n                 _ => return None,\n             }\n@@ -930,20 +913,17 @@ impl MacroArgParser {\n         } else {\n             Some(Box::new(ParsedMacroArg {\n                 kind: MacroArgKind::Other(buffer, \"\".to_owned()),\n-                span: mk_sp(lo, hi),\n             }))\n         };\n \n         self.result.push(ParsedMacroArg {\n             kind: MacroArgKind::Repeat(delim, inner, another, self.last_tok.clone()),\n-            span: mk_sp(self.lo, self.hi),\n         });\n         Some(())\n     }\n \n     fn update_buffer(&mut self, t: &Token) {\n         if self.buf.is_empty() {\n-            self.lo = t.span.lo();\n             self.start_tok = t.clone();\n         } else {\n             let needs_space = match next_space(&self.last_tok.kind) {\n@@ -999,7 +979,6 @@ impl MacroArgParser {\n \n                     // Start keeping the name of this metavariable in the buffer.\n                     self.is_meta_var = true;\n-                    self.lo = span.lo();\n                     self.start_tok = Token {\n                         kind: TokenKind::Dollar,\n                         span,\n@@ -1012,7 +991,7 @@ impl MacroArgParser {\n                     self.add_meta_variable(&mut iter)?;\n                 }\n                 TokenTree::Token(ref t) => self.update_buffer(t),\n-                TokenTree::Delimited(delimited_span, delimited, ref tts) => {\n+                TokenTree::Delimited(_delimited_span, delimited, ref tts) => {\n                     if !self.buf.is_empty() {\n                         if next_space(&self.last_tok.kind) == SpaceState::Always {\n                             self.add_separator();\n@@ -1022,16 +1001,14 @@ impl MacroArgParser {\n                     }\n \n                     // Parse the stuff inside delimiters.\n-                    let mut parser = MacroArgParser::new();\n-                    parser.lo = delimited_span.open.lo();\n+                    let parser = MacroArgParser::new();\n                     let delimited_arg = parser.parse(tts.clone())?;\n \n-                    let span = delimited_span.entire();\n                     if self.is_meta_var {\n-                        self.add_repeat(delimited_arg, delimited, &mut iter, span)?;\n+                        self.add_repeat(delimited_arg, delimited, &mut iter)?;\n                         self.is_meta_var = false;\n                     } else {\n-                        self.add_delimited(delimited_arg, delimited, span);\n+                        self.add_delimited(delimited_arg, delimited);\n                     }\n                 }\n             }\n@@ -1270,7 +1247,12 @@ impl MacroParser {\n                 let data = delimited_span.entire().data();\n                 (\n                     data.hi,\n-                    Span::new(data.lo + BytePos(1), data.hi - BytePos(1), data.ctxt),\n+                    Span::new(\n+                        data.lo + BytePos(1),\n+                        data.hi - BytePos(1),\n+                        data.ctxt,\n+                        data.parent,\n+                    ),\n                     delimited_span.entire(),\n                 )\n             }\n@@ -1417,7 +1399,7 @@ impl MacroBranch {\n     }\n }\n \n-/// Format `lazy_static!` from https://crates.io/crates/lazy_static.\n+/// Format `lazy_static!` from <https://crates.io/crates/lazy_static>.\n ///\n /// # Expected syntax\n ///"}, {"sha": "ded34d9032f91f188c11c9437b41691cdcce75b5", "filename": "src/modules.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -27,7 +27,6 @@ type FileModMap<'ast> = BTreeMap<FileName, Module<'ast>>;\n pub(crate) struct Module<'a> {\n     ast_mod_kind: Option<Cow<'a, ast::ModKind>>,\n     pub(crate) items: Cow<'a, Vec<rustc_ast::ptr::P<ast::Item>>>,\n-    attrs: Cow<'a, Vec<ast::Attribute>>,\n     inner_attr: Vec<ast::Attribute>,\n     pub(crate) span: Span,\n }\n@@ -46,7 +45,6 @@ impl<'a> Module<'a> {\n             .collect();\n         Module {\n             items: mod_items,\n-            attrs: mod_attrs,\n             inner_attr,\n             span: mod_span,\n             ast_mod_kind,"}, {"sha": "ba8d8024a9707c34ef31c4eae24665eb99f5f39d", "filename": "src/patterns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -23,11 +23,11 @@ use crate::utils::{format_mutability, mk_sp, mk_sp_lo_plus_one, rewrite_ident};\n /// Returns `true` if the given pattern is \"short\".\n /// A short pattern is defined by the following grammar:\n ///\n-/// [small, ntp]:\n+/// `[small, ntp]`:\n ///     - single token\n ///     - `&[single-line, ntp]`\n ///\n-/// [small]:\n+/// `[small]`:\n ///     - `[small, ntp]`\n ///     - unary tuple constructor `([small, ntp])`\n ///     - `&[small]`"}, {"sha": "64ae15672df8ff1c88f3d749d6d2de14bff2f9c3", "filename": "src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -153,7 +153,7 @@ pub(crate) fn rewrite_string<'a>(\n     wrap_str(result, fmt.config.max_width(), fmt.shape)\n }\n \n-/// Returns the index to the end of the URL if the split at index of the given string includes an\n+/// Returns the index to the end of the URL if the split at index of the given string includes a\n /// URL or alike. Otherwise, returns `None`.\n fn detect_url(s: &[&str], index: usize) -> Option<usize> {\n     let start = match s[..=index].iter().rposition(|g| is_whitespace(g)) {"}, {"sha": "946c076d9f2d1fdf388b19156c5c2a7b5ca254e0", "filename": "src/syntux/session.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fsyntux%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fsyntux%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fsession.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -317,6 +317,7 @@ mod tests {\n                 suggestions: vec![],\n                 span: span.unwrap_or_else(MultiSpan::new),\n                 sort_span: DUMMY_SP,\n+                is_lint: false,\n             }\n         }\n "}, {"sha": "62c05ba078c56facce55f848d2b4cee53e0a1c78", "filename": "src/types.rs", "status": "modified", "additions": 5, "deletions": 58, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -1,15 +1,15 @@\n use std::iter::ExactSizeIterator;\n use std::ops::Deref;\n \n-use rustc_ast::ast::{self, AttrVec, FnRetTy, Mutability};\n-use rustc_span::{symbol::kw, symbol::Ident, BytePos, Pos, Span};\n+use rustc_ast::ast::{self, FnRetTy, Mutability};\n+use rustc_span::{symbol::kw, BytePos, Pos, Span};\n \n+use crate::comment::{combine_strs_with_missing_comments, contains_comment};\n use crate::config::lists::*;\n use crate::config::{IndentStyle, TypeDensity, Version};\n use crate::expr::{\n     format_expr, rewrite_assign_rhs, rewrite_call, rewrite_tuple, rewrite_unary_prefix, ExprType,\n };\n-use crate::items::StructParts;\n use crate::lists::{\n     definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator,\n };\n@@ -24,11 +24,6 @@ use crate::utils::{\n     colon_spaces, extra_offset, first_line_width, format_extern, format_mutability,\n     last_line_extendable, last_line_width, mk_sp, rewrite_ident,\n };\n-use crate::DEFAULT_VISIBILITY;\n-use crate::{\n-    comment::{combine_strs_with_missing_comments, contains_comment},\n-    items::format_struct_struct,\n-};\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub(crate) enum PathContext {\n@@ -548,10 +543,10 @@ impl Rewrite for ast::GenericBound {\n                         .map(|s| format!(\"?{}\", s)),\n                     ast::TraitBoundModifier::MaybeConst => poly_trait_ref\n                         .rewrite(context, shape.offset_left(7)?)\n-                        .map(|s| format!(\"?const {}\", s)),\n+                        .map(|s| format!(\"~const {}\", s)),\n                     ast::TraitBoundModifier::MaybeConstMaybe => poly_trait_ref\n                         .rewrite(context, shape.offset_left(8)?)\n-                        .map(|s| format!(\"?const ?{}\", s)),\n+                        .map(|s| format!(\"~const ?{}\", s)),\n                 };\n                 rewrite.map(|s| if has_paren { format!(\"({})\", s) } else { s })\n             }\n@@ -790,54 +785,6 @@ impl Rewrite for ast::Ty {\n             ast::TyKind::Tup(ref items) => {\n                 rewrite_tuple(context, items.iter(), self.span, shape, items.len() == 1)\n             }\n-            ast::TyKind::AnonymousStruct(ref fields, recovered) => {\n-                let ident = Ident::new(\n-                    kw::Struct,\n-                    mk_sp(self.span.lo(), self.span.lo() + BytePos(6)),\n-                );\n-                let data = ast::VariantData::Struct(fields.clone(), recovered);\n-                let variant = ast::Variant {\n-                    attrs: AttrVec::new(),\n-                    id: self.id,\n-                    span: self.span,\n-                    vis: DEFAULT_VISIBILITY,\n-                    ident,\n-                    data,\n-                    disr_expr: None,\n-                    is_placeholder: false,\n-                };\n-                format_struct_struct(\n-                    &context,\n-                    &StructParts::from_variant(&variant),\n-                    fields,\n-                    shape.indent,\n-                    None,\n-                )\n-            }\n-            ast::TyKind::AnonymousUnion(ref fields, recovered) => {\n-                let ident = Ident::new(\n-                    kw::Union,\n-                    mk_sp(self.span.lo(), self.span.lo() + BytePos(5)),\n-                );\n-                let data = ast::VariantData::Struct(fields.clone(), recovered);\n-                let variant = ast::Variant {\n-                    attrs: AttrVec::new(),\n-                    id: self.id,\n-                    span: self.span,\n-                    vis: DEFAULT_VISIBILITY,\n-                    ident,\n-                    data,\n-                    disr_expr: None,\n-                    is_placeholder: false,\n-                };\n-                format_struct_struct(\n-                    &context,\n-                    &StructParts::from_variant(&variant),\n-                    fields,\n-                    shape.indent,\n-                    None,\n-                )\n-            }\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }"}, {"sha": "29e1e070d41114079921683fea87f7cd62ec941f", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -356,11 +356,11 @@ macro_rules! source {\n }\n \n pub(crate) fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n-    Span::new(lo, hi, SyntaxContext::root())\n+    Span::new(lo, hi, SyntaxContext::root(), None)\n }\n \n pub(crate) fn mk_sp_lo_plus_one(lo: BytePos) -> Span {\n-    Span::new(lo, lo + BytePos(1), SyntaxContext::root())\n+    Span::new(lo, lo + BytePos(1), SyntaxContext::root(), None)\n }\n \n // Returns `true` if the given span does not intersect with file lines."}, {"sha": "d854d90b40b6d9d33e7f7ff4917d8c872c97f6a5", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -36,7 +36,7 @@ pub(crate) struct SnippetProvider {\n     big_snippet: Lrc<String>,\n     /// A position of the start of `big_snippet`, used as an offset.\n     start_pos: usize,\n-    /// A end position of the file that this snippet lives.\n+    /// An end position of the file that this snippet lives.\n     end_pos: usize,\n }\n "}, {"sha": "4c71a2c6ab90b655bf18504e81899faf21db815d", "filename": "tests/source/cfg_if/detect/arch/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The features are detected using the `detect_features` function below.\n //! This function uses the CPUID instruction to read the feature flags from the\n-//! CPU and encodes them in an `usize` where each bit position represents\n+//! CPU and encodes them in a `usize` where each bit position represents\n //! whether a feature is available (bit is set) or unavaiable (bit is cleared).\n //!\n //! The enum `Feature` is used to map bit positions to feature names, and the"}, {"sha": "a6e816fb524b70ca01c72c4a66c41fe2b8fccc93", "filename": "tests/source/let_else.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Fsource%2Flet_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Fsource%2Flet_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Flet_else.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let Some(1) = Some(1) else { return };\n+}"}, {"sha": "61ef73a3cab1c6dbe80399e0f4fc5c0f77ae6685", "filename": "tests/source/type.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Fsource%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Fsource%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ftype.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -140,29 +140,23 @@ fn foo(a: SomeLongComplexType, b: SomeOtherLongComplexType) -> Box<Future<Item =\n \n type MyFn = fn(a: SomeLongComplexType, b: SomeOtherLongComplexType,) -> Box<Future<Item = AnotherLongType, Error = ALongErrorType>>;\n \n-// Const opt-out\n+// Const bound\n \n-trait T: ?   const  Super {}\n+trait T: ~   const  Super {}\n \n-const fn maybe_const<S: ?   const    T>() -> i32 { <S as T>::CONST }\n+const fn not_quite_const<S: ~  const    T>() -> i32 { <S as T>::CONST }\n \n-struct S<T:?  const   ?  Sized>(std::marker::PhantomData<T>);\n+struct S<T:~  const   ?  Sized>(std::marker::PhantomData<T>);\n \n-impl ?    const T {}\n+impl ~    const T {}\n \n-fn trait_object() -> &'static dyn ?  const T { &S }\n+fn apit(_: impl ~   const T) {}\n \n-fn i(_: impl IntoIterator<Item = Box<dyn ?    const    T>>) {}\n-\n-fn apit(_: impl ?const T) {}\n-\n-fn rpit() -> impl ?  const T { S }\n+fn rpit() -> impl ~  const T { S }\n \n pub struct Foo<T: Trait>(T);\n-impl<T:   ?  const Trait> Foo<T> {\n+impl<T:   ~  const Trait> Foo<T> {\n     fn new(t: T) -> Self {\n-        // not calling methods on `t`, so we opt out of requiring\n-        // `<T as Trait>` to have const methods via `?const`\n         Self(t)\n     }\n }\n@@ -171,4 +165,4 @@ impl<T:   ?  const Trait> Foo<T> {\n type T = typeof(\n 1);\n impl T for  .. {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "b985dd8caa1ffa0ecbdd9fc5e2945424567d0025", "filename": "tests/target/cfg_if/detect/arch/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The features are detected using the `detect_features` function below.\n //! This function uses the CPUID instruction to read the feature flags from the\n-//! CPU and encodes them in an `usize` where each bit position represents\n+//! CPU and encodes them in a `usize` where each bit position represents\n //! whether a feature is available (bit is set) or unavaiable (bit is cleared).\n //!\n //! The enum `Feature` is used to map bit positions to feature names, and the"}, {"sha": "a6e816fb524b70ca01c72c4a66c41fe2b8fccc93", "filename": "tests/target/let_else.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Ftarget%2Flet_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Ftarget%2Flet_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Flet_else.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let Some(1) = Some(1) else { return };\n+}"}, {"sha": "38cf909c2587a52c0b4b452df0cf6a79400d8270", "filename": "tests/target/type.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Ftarget%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9178dc47c939c2a61ff6c872a1ff486df674d84/tests%2Ftarget%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftype.rs?ref=b9178dc47c939c2a61ff6c872a1ff486df674d84", "patch": "@@ -145,35 +145,27 @@ type MyFn = fn(\n     b: SomeOtherLongComplexType,\n ) -> Box<Future<Item = AnotherLongType, Error = ALongErrorType>>;\n \n-// Const opt-out\n+// Const bound\n \n-trait T: ?const Super {}\n+trait T: ~const Super {}\n \n-const fn maybe_const<S: ?const T>() -> i32 {\n+const fn not_quite_const<S: ~const T>() -> i32 {\n     <S as T>::CONST\n }\n \n-struct S<T: ?const ?Sized>(std::marker::PhantomData<T>);\n+struct S<T: ~const ?Sized>(std::marker::PhantomData<T>);\n \n-impl ?const T {}\n+impl ~const T {}\n \n-fn trait_object() -> &'static dyn ?const T {\n-    &S\n-}\n-\n-fn i(_: impl IntoIterator<Item = Box<dyn ?const T>>) {}\n-\n-fn apit(_: impl ?const T) {}\n+fn apit(_: impl ~const T) {}\n \n-fn rpit() -> impl ?const T {\n+fn rpit() -> impl ~const T {\n     S\n }\n \n pub struct Foo<T: Trait>(T);\n-impl<T: ?const Trait> Foo<T> {\n+impl<T: ~const Trait> Foo<T> {\n     fn new(t: T) -> Self {\n-        // not calling methods on `t`, so we opt out of requiring\n-        // `<T as Trait>` to have const methods via `?const`\n         Self(t)\n     }\n }"}]}