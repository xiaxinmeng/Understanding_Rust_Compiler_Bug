{"sha": "093926e841df9a715f35d194846ad24134bafd2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MzkyNmU4NDFkZjlhNzE1ZjM1ZDE5NDg0NmFkMjQxMzRiYWZkMmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-27T19:52:54Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-27T20:39:58Z"}, "message": "Check and extract bindings from trait definitions.\n\nFixes #21636.", "tree": {"sha": "15e1bf945ff2739b69003d72ff471457d47c137d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15e1bf945ff2739b69003d72ff471457d47c137d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/093926e841df9a715f35d194846ad24134bafd2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/093926e841df9a715f35d194846ad24134bafd2c", "html_url": "https://github.com/rust-lang/rust/commit/093926e841df9a715f35d194846ad24134bafd2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/093926e841df9a715f35d194846ad24134bafd2c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "777435990e0e91df6b72ce80c9b6fa485eeb5daa", "url": "https://api.github.com/repos/rust-lang/rust/commits/777435990e0e91df6b72ce80c9b6fa485eeb5daa", "html_url": "https://github.com/rust-lang/rust/commit/777435990e0e91df6b72ce80c9b6fa485eeb5daa"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "f15132937263d51399ca49c8ad7a67251e91a220", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/093926e841df9a715f35d194846ad24134bafd2c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093926e841df9a715f35d194846ad24134bafd2c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=093926e841df9a715f35d194846ad24134bafd2c", "patch": "@@ -401,6 +401,11 @@ fn project_type<'cx,'tcx>(\n                                        &obligation_trait_ref,\n                                        &mut candidates);\n \n+    assemble_candidates_from_trait_def(selcx,\n+                                       obligation,\n+                                       &obligation_trait_ref,\n+                                       &mut candidates);\n+\n     if let Err(e) = assemble_candidates_from_impls(selcx,\n                                                    obligation,\n                                                    &obligation_trait_ref,\n@@ -446,6 +451,41 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n                                         candidate_set, env_predicates);\n }\n \n+/// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n+/// that the definition of `Foo` has some clues:\n+///\n+/// ```rust\n+/// trait Foo {\n+///     type FooT : Bar<BarT=i32>\n+/// }\n+/// ```\n+///\n+/// Here, for example, we could conclude that the result is `i32`.\n+fn assemble_candidates_from_trait_def<'cx,'tcx>(\n+    selcx: &mut SelectionContext<'cx,'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n+{\n+    // Check whether the self-type is itself a projection.\n+    let trait_ref = match obligation_trait_ref.self_ty().sty {\n+        ty::ty_projection(ref data) => data.trait_ref.clone(),\n+        ty::ty_infer(ty::TyVar(_)) => {\n+            // If the self-type is an inference variable, then it MAY wind up\n+            // being a projected type, so induce an ambiguity.\n+            candidate_set.ambiguous = true;\n+            return;\n+        }\n+        _ => { return; }\n+    };\n+\n+    // If so, extract what we know from the trait and try to come up with a good answer.\n+    let trait_def = ty::lookup_trait_def(selcx.tcx(), trait_ref.def_id);\n+    let bounds = trait_def.generics.to_bounds(selcx.tcx(), trait_ref.substs);\n+    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n+                                        candidate_set, bounds.predicates.into_vec());\n+}\n+\n fn assemble_candidates_from_predicates<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "b47b0109bdf39220700753aed82820fb24a025e0", "filename": "src/test/run-pass/associated-types-binding-in-trait.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/093926e841df9a715f35d194846ad24134bafd2c/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093926e841df9a715f35d194846ad24134bafd2c/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-binding-in-trait.rs?ref=093926e841df9a715f35d194846ad24134bafd2c", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where the associated type binding (to `bool`, in this\n+// case) is derived from the trait definition. Issue #21636.\n+\n+use std::vec;\n+\n+pub trait BitIter {\n+    type Iter: Iterator<Item=bool>;\n+    fn bit_iter(self) -> <Self as BitIter>::Iter;\n+}\n+\n+impl BitIter for Vec<bool> {\n+    type Iter = vec::IntoIter<bool>;\n+    fn bit_iter(self) -> <Self as BitIter>::Iter {\n+        self.into_iter()\n+    }\n+}\n+\n+fn count<T>(arg: T) -> usize\n+    where T: BitIter\n+{\n+    let mut sum = 0;\n+    for i in arg.bit_iter() {\n+        if i {\n+            sum += 1;\n+        }\n+    }\n+    sum\n+}\n+\n+fn main() {\n+    let v = vec![true, false, true];\n+    let c = count(v);\n+    assert_eq!(c, 2);\n+}"}]}