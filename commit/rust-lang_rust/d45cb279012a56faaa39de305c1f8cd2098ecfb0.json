{"sha": "d45cb279012a56faaa39de305c1f8cd2098ecfb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NWNiMjc5MDEyYTU2ZmFhYTM5ZGUzMDVjMWY4Y2QyMDk4ZWNmYjA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-06T19:01:58Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-07T19:21:14Z"}, "message": "syntax: point quote tokens at the site of quote-using-extension invocation.", "tree": {"sha": "cb7303d2b29a63a48685c736e3f2ba60a66f65af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb7303d2b29a63a48685c736e3f2ba60a66f65af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d45cb279012a56faaa39de305c1f8cd2098ecfb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d45cb279012a56faaa39de305c1f8cd2098ecfb0", "html_url": "https://github.com/rust-lang/rust/commit/d45cb279012a56faaa39de305c1f8cd2098ecfb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d45cb279012a56faaa39de305c1f8cd2098ecfb0/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f27bf7debcaa208f87ad045638070a4e2b226d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f27bf7debcaa208f87ad045638070a4e2b226d9", "html_url": "https://github.com/rust-lang/rust/commit/9f27bf7debcaa208f87ad045638070a4e2b226d9"}], "stats": {"total": 209, "additions": 120, "deletions": 89}, "files": [{"sha": "1f5b2b92f97ecce4c4a90649ba1b6ff78074c6d3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d45cb279012a56faaa39de305c1f8cd2098ecfb0/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45cb279012a56faaa39de305c1f8cd2098ecfb0/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d45cb279012a56faaa39de305c1f8cd2098ecfb0", "patch": "@@ -163,6 +163,7 @@ trait ext_ctxt {\n     fn codemap() -> @CodeMap;\n     fn parse_sess() -> parse::parse_sess;\n     fn cfg() -> ast::crate_cfg;\n+    fn call_site() -> span;\n     fn print_backtrace();\n     fn backtrace() -> Option<@ExpnInfo>;\n     fn mod_push(mod_name: ast::ident);\n@@ -195,6 +196,12 @@ fn mk_ctxt(parse_sess: parse::parse_sess,\n         fn codemap() -> @CodeMap { self.parse_sess.cm }\n         fn parse_sess() -> parse::parse_sess { self.parse_sess }\n         fn cfg() -> ast::crate_cfg { self.cfg }\n+        fn call_site() -> span {\n+            match self.backtrace {\n+                Some(@ExpandedFrom({call_site: cs, _})) => cs,\n+                None => self.bug(~\"missing top span\")\n+            }\n+        }\n         fn print_backtrace() { }\n         fn backtrace() -> Option<@ExpnInfo> { self.backtrace }\n         fn mod_push(i: ast::ident) { self.mod_path.push(i); }"}, {"sha": "04a59d1fe4162d835ee38d731e186bfc78c6b587", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d45cb279012a56faaa39de305c1f8cd2098ecfb0/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45cb279012a56faaa39de305c1f8cd2098ecfb0/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d45cb279012a56faaa39de305c1f8cd2098ecfb0", "patch": "@@ -145,6 +145,24 @@ fn mk_glob_use(cx: ext_ctxt, sp: span,\n       vis: ast::private,\n       span: sp}\n }\n+fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n+            ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n+\n+    let pat : @ast::pat = @{id: cx.next_id(),\n+                            node: ast::pat_ident(ast::bind_by_value,\n+                                                 mk_raw_path(sp, ~[ident]),\n+                                                 None),\n+                           span: sp};\n+    let ty : @ast::Ty = @{ id: cx.next_id(), node: ast::ty_infer, span: sp };\n+    let local : @ast::local = @{node: {is_mutbl: mutbl,\n+                                       ty: ty,\n+                                       pat: pat,\n+                                       init: Some(ex),\n+                                       id: cx.next_id()},\n+                                span: sp};\n+    let decl = {node: ast::decl_local(~[local]), span: sp};\n+    @{ node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n+}\n fn mk_block(cx: ext_ctxt, sp: span,\n             view_items: ~[@ast::view_item],\n             stmts: ~[@ast::stmt],"}, {"sha": "022f843a0ec960c1d1cf92226686d52027eb43be", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d45cb279012a56faaa39de305c1f8cd2098ecfb0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45cb279012a56faaa39de305c1f8cd2098ecfb0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d45cb279012a56faaa39de305c1f8cd2098ecfb0", "patch": "@@ -50,10 +50,11 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                         fmt!(\"%s can only be used as a decorator\", *extname));\n                   }\n                   Some(normal({expander: exp, span: exp_sp})) => {\n-                    let expanded = exp(cx, (*mac).span, args, body);\n \n                     cx.bt_push(ExpandedFrom({call_site: s,\n                                 callie: {name: *extname, span: exp_sp}}));\n+                    let expanded = exp(cx, (*mac).span, args, body);\n+\n                     //keep going, outside-in\n                     let fully_expanded = fld.fold_expr(expanded).node;\n                     cx.bt_pop();\n@@ -90,6 +91,9 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                                   fmt!(\"macro undefined: '%s'\", *extname))\n                   }\n                   Some(normal_tt({expander: exp, span: exp_sp})) => {\n+                    cx.bt_push(ExpandedFrom({call_site: s,\n+                                callie: {name: *extname, span: exp_sp}}));\n+\n                     let expanded = match exp(cx, (*mac).span, (*tts)) {\n                       mr_expr(e) => e,\n                       mr_any(expr_maker,_,_) => expr_maker(),\n@@ -98,22 +102,21 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                                          *extname))\n                     };\n \n-                    cx.bt_push(ExpandedFrom({call_site: s,\n-                                callie: {name: *extname, span: exp_sp}}));\n                     //keep going, outside-in\n                     let fully_expanded = fld.fold_expr(expanded).node;\n                     cx.bt_pop();\n \n                     (fully_expanded, s)\n                   }\n                   Some(normal({expander: exp, span: exp_sp})) => {\n+                    cx.bt_push(ExpandedFrom({call_site: s,\n+                                callie: {name: *extname, span: exp_sp}}));\n+\n                     //convert the new-style invoc for the old-style macro\n                     let arg = base::tt_args_to_original_flavor(cx, pth.span,\n                                                                (*tts));\n                     let expanded = exp(cx, (*mac).span, arg, None);\n \n-                    cx.bt_push(ExpandedFrom({call_site: s,\n-                                callie: {name: *extname, span: exp_sp}}));\n                     //keep going, outside-in\n                     let fully_expanded = fld.fold_expr(expanded).node;\n                     cx.bt_pop();\n@@ -296,6 +299,8 @@ fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n             cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extname)),\n \n         Some(normal_tt({expander: exp, span: exp_sp})) => {\n+            cx.bt_push(ExpandedFrom(\n+                {call_site: sp, callie: {name: *extname, span: exp_sp}}));\n             let expanded = match exp(cx, mac.span, tts) {\n                 mr_expr(e) =>\n                     @{node: stmt_expr(e, cx.next_id()), span: e.span},\n@@ -305,8 +310,6 @@ fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n                     fmt!(\"non-stmt macro in stmt pos: %s\", *extname))\n             };\n \n-            cx.bt_push(ExpandedFrom(\n-                {call_site: sp, callie: {name: *extname, span: exp_sp}}));\n             //keep going, outside-in\n             let fully_expanded = fld.fold_stmt(expanded).node;\n             cx.bt_pop();\n@@ -315,15 +318,15 @@ fn expand_stmt(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n         }\n \n         Some(normal({expander: exp, span: exp_sp})) => {\n+            cx.bt_push(ExpandedFrom({call_site: sp,\n+                                      callie: {name: *extname,\n+                                               span: exp_sp}}));\n             //convert the new-style invoc for the old-style macro\n             let arg = base::tt_args_to_original_flavor(cx, pth.span, tts);\n             let exp_expr = exp(cx, mac.span, arg, None);\n             let expanded = @{node: stmt_expr(exp_expr, cx.next_id()),\n                              span: exp_expr.span};\n \n-            cx.bt_push(ExpandedFrom({call_site: sp,\n-                                      callie: {name: *extname,\n-                                               span: exp_sp}}));\n             //keep going, outside-in\n             let fully_expanded = fld.fold_stmt(expanded).node;\n             cx.bt_pop();"}, {"sha": "d1761ea51103de56900b966a3af38d040d038f62", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 82, "deletions": 79, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/d45cb279012a56faaa39de305c1f8cd2098ecfb0/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45cb279012a56faaa39de305c1f8cd2098ecfb0/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=d45cb279012a56faaa39de305c1f8cd2098ecfb0", "patch": "@@ -86,65 +86,6 @@ fn id_ext(cx: ext_ctxt, str: ~str) -> ast::ident {\n     cx.parse_sess().interner.intern(@str)\n }\n \n-fn mk_option_span(cx: ext_ctxt,\n-                  qsp: span,\n-                  sp: Option<span>) -> @ast::expr {\n-    match sp {\n-        None => build::mk_path(cx, qsp, ids_ext(cx, ~[~\"None\"])),\n-        Some(sp) => {\n-            build::mk_call(cx, qsp,\n-                           ids_ext(cx, ~[~\"Some\"]),\n-                           ~[build::mk_managed(cx, qsp,\n-                                               mk_span(cx, qsp, sp))])\n-        }\n-    }\n-}\n-\n-fn mk_span(cx: ext_ctxt, qsp: span, sp: span) -> @ast::expr {\n-\n-    let e_expn_info = match sp.expn_info {\n-        None => build::mk_path(cx, qsp, ids_ext(cx, ~[~\"None\"])),\n-        Some(@codemap::ExpandedFrom(ref cr)) => {\n-            let e_callee =\n-                build::mk_rec_e(\n-                    cx, qsp,\n-                    ~[{ident: id_ext(cx, ~\"name\"),\n-                       ex: build::mk_uniq_str(cx, qsp,\n-                                              (*cr).callie.name)},\n-                      {ident: id_ext(cx, ~\"span\"),\n-                       ex: mk_option_span(cx, qsp, (*cr).callie.span)}]);\n-\n-            let e_expn_info_ =\n-                build::mk_call(\n-                    cx, qsp,\n-                    ids_ext(cx, ~[~\"expanded_from\"]),\n-                    ~[build::mk_rec_e(\n-                        cx, qsp,\n-                        ~[{ident: id_ext(cx, ~\"call_site\"),\n-                           ex: mk_span(cx, qsp, (*cr).call_site)},\n-                          {ident: id_ext(cx, ~\"callie\"),\n-                           ex: e_callee}])]);\n-\n-            build::mk_call(cx, qsp,\n-                           ids_ext(cx, ~[~\"Some\"]),\n-                           ~[build::mk_managed(cx, qsp, e_expn_info_)])\n-        }\n-    };\n-\n-    let span_path = ids_ext(cx, ~[~\"span\"]);\n-\n-    build::mk_struct_e(cx, qsp,\n-                       span_path,\n-                    ~[{ident: id_ext(cx, ~\"lo\"),\n-                       ex: mk_bytepos(cx, qsp, sp.lo) },\n-\n-                      {ident: id_ext(cx, ~\"hi\"),\n-                       ex: mk_bytepos(cx, qsp, sp.hi) },\n-\n-                      {ident: id_ext(cx, ~\"expn_info\"),\n-                       ex: e_expn_info}])\n-}\n-\n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n     let e_meth = build::mk_access(cx, sp,\n@@ -321,59 +262,121 @@ fn mk_token(cx: ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n }\n \n \n-fn mk_tt(cx: ext_ctxt, sp: span, tt: &ast::token_tree) -> @ast::expr {\n+fn mk_tt(cx: ext_ctxt, sp: span, tt: &ast::token_tree)\n+    -> ~[@ast::stmt] {\n+\n     match *tt {\n+\n         ast::tt_tok(sp, ref tok) => {\n+            let e_sp = build::mk_path(cx, sp,\n+                                      ids_ext(cx, ~[~\"sp\"]));\n             let e_tok =\n                 build::mk_call(cx, sp,\n                                ids_ext(cx, ~[~\"tt_tok\"]),\n-                               ~[mk_span(cx, sp, sp),\n-                                 mk_token(cx, sp, (*tok))]);\n-            build::mk_uniq_vec_e(cx, sp, ~[e_tok])\n-        }\n+                               ~[e_sp, mk_token(cx, sp, *tok)]);\n+            let e_push =\n+                build::mk_call_(cx, sp,\n+                                build::mk_access(cx, sp,\n+                                                 ids_ext(cx, ~[~\"tt\"]),\n+                                                 id_ext(cx, ~\"push\")),\n+                                ~[e_tok]);\n+            ~[build::mk_stmt(cx, sp, e_push)]\n \n-        ast::tt_delim(ref tts) => {\n-            let e_delim =\n-                build::mk_call(cx, sp,\n-                               ids_ext(cx, ~[~\"tt_delim\"]),\n-                               ~[mk_tts(cx, sp, (*tts))]);\n-            build::mk_uniq_vec_e(cx, sp, ~[e_delim])\n         }\n \n+        ast::tt_delim(ref tts) => mk_tts(cx, sp, *tts),\n         ast::tt_seq(*) => fail ~\"tt_seq in quote!\",\n \n-        ast::tt_nonterminal(sp, ident) =>\n-        build::mk_copy(cx, sp, build::mk_path(cx, sp, ~[ident]))\n+        ast::tt_nonterminal(sp, ident) => {\n+            let e_push =\n+                build::mk_call_(cx, sp,\n+                                build::mk_access\n+                                (cx, sp,\n+                                 ids_ext(cx, ~[~\"tt\"]),\n+                                 id_ext(cx, ~\"push_all_move\")),\n+                                ~[build::mk_path(cx, sp, ~[ident])]);\n+            ~[build::mk_stmt(cx, sp, e_push)]            \n+        }\n     }\n }\n \n-fn mk_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree]) -> @ast::expr {\n-    let e_tts = tts.map(|tt| mk_tt(cx, sp, tt));\n-    build::mk_call(cx, sp,\n-                   ids_ext(cx, ~[~\"vec\", ~\"concat\"]),\n-                   ~[build::mk_slice_vec_e(cx, sp, e_tts)])\n+fn mk_tts(cx: ext_ctxt, sp: span, tts: &[ast::token_tree])\n+    -> ~[@ast::stmt] {\n+    let mut ss = ~[];\n+    for tts.each |tt| {\n+        ss.push_all_move(mk_tt(cx, sp, tt));\n+    }\n+    ss\n }\n \n fn expand_tts(cx: ext_ctxt,\n               sp: span,\n               tts: ~[ast::token_tree]) -> @ast::expr {\n+\n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n     // it has to do with transition away from supporting old-style macros, so\n     // try removing it when enough of them are gone.\n+\n     let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts);\n     p.quote_depth += 1u;\n     let tts = p.parse_all_token_trees();\n     p.abort_if_errors();\n \n     // We want to emit a block expression that does a sequence of 'use's to\n-    // import the runtime module, followed by a tt expression.\n+    // import the runtime module, followed by a tt-building expression.\n+\n     let uses = ~[ build::mk_glob_use(cx, sp, ids_ext(cx, ~[~\"syntax\",\n                                                            ~\"ext\",\n                                                            ~\"quote\",\n                                                            ~\"rt\"])) ];\n-    build::mk_block(cx, sp, uses, ~[], Some(mk_tts(cx, sp, tts)))\n+\n+    // We also bind a single value, sp, to ext_cx.call_site()\n+    //\n+    // This causes every span in a token-tree quote to be attributed to the\n+    // call site of the extension using the quote. We can't really do much\n+    // better since the source of the quote may well be in a library that\n+    // was not even parsed by this compilation run, that the user has no\n+    // source code for (eg. in libsyntax, which they're just _using_).\n+    //\n+    // The old quasiquoter had an elaborate mechanism for denoting input\n+    // file locations from which quotes originated; unfortunately this\n+    // relied on feeding the source string of the quote back into the\n+    // compiler (which we don't really want to do) and, in any case, only\n+    // pushed the problem a very small step further back: an error\n+    // resulting from a parse of the resulting quote is still attributed to\n+    // the site the string literal occured, which was in a source file\n+    // _other_ than the one the user has control over. For example, an\n+    // error in a quote from the protocol compiler, invoked in user code\n+    // using proto! for example, will be attributed to the pipec.rs file in\n+    // libsyntax, which the user might not even have source to (unless they\n+    // happen to have a compiler on hand). Over all, the phase distinction\n+    // just makes quotes \"hard to attribute\". Possibly this could be fixed\n+    // by recreating some of the original qq machinery in the tt regime\n+    // (pushing fake FileMaps onto the parser to account for original sites\n+    // of quotes, for example) but at this point it seems not likely to be\n+    // worth the hassle.\n+\n+    let e_sp = build::mk_call_(cx, sp,\n+                               build::mk_access(cx, sp,\n+                                                ids_ext(cx, ~[~\"ext_cx\"]),\n+                                                id_ext(cx, ~\"call_site\")),\n+                               ~[]);\n+\n+    let stmt_let_sp = build::mk_local(cx, sp, false,\n+                                      id_ext(cx, ~\"sp\"),\n+                                      e_sp);\n+    \n+    let stmt_let_tt = build::mk_local(cx, sp, true,\n+                                      id_ext(cx, ~\"tt\"),\n+                                      build::mk_uniq_vec_e(cx, sp, ~[]));\n+\n+    build::mk_block(cx, sp, uses,\n+                    ~[stmt_let_sp,\n+                      stmt_let_tt] + mk_tts(cx, sp, tts),\n+                    Some(build::mk_path(cx, sp,\n+                                        ids_ext(cx, ~[~\"tt\"]))))\n }\n \n fn expand_parse_call(cx: ext_ctxt,"}]}