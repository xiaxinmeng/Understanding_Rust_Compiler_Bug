{"sha": "9faf7962cb73e543575c5646c8f010cbd9953e54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYWY3OTYyY2I3M2U1NDM1NzVjNTY0NmM4ZjAxMGNiZDk5NTNlNTQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-23T05:40:55Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-25T01:18:14Z"}, "message": "parse `pub(restricted)` visibilities for struct fields", "tree": {"sha": "2d98b03fbca919e8f736b7a7bfc39b8815d7b44c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d98b03fbca919e8f736b7a7bfc39b8815d7b44c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9faf7962cb73e543575c5646c8f010cbd9953e54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9faf7962cb73e543575c5646c8f010cbd9953e54", "html_url": "https://github.com/rust-lang/rust/commit/9faf7962cb73e543575c5646c8f010cbd9953e54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9faf7962cb73e543575c5646c8f010cbd9953e54/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19304837c86cc406ee042c99e12fa34debae4e8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/19304837c86cc406ee042c99e12fa34debae4e8a", "html_url": "https://github.com/rust-lang/rust/commit/19304837c86cc406ee042c99e12fa34debae4e8a"}], "stats": {"total": 45, "additions": 38, "deletions": 7}, "files": [{"sha": "671a11b57dec1db4e9b35867cbfa3a2c22a625fe", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9faf7962cb73e543575c5646c8f010cbd9953e54/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faf7962cb73e543575c5646c8f010cbd9953e54/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9faf7962cb73e543575c5646c8f010cbd9953e54", "patch": "@@ -5218,8 +5218,25 @@ impl<'a> Parser<'a> {\n             |p| {\n                 let attrs = p.parse_outer_attributes()?;\n                 let lo = p.span.lo;\n-                let vis = p.parse_visibility(false)?;\n-                let ty = p.parse_ty_sum()?;\n+                let mut vis = p.parse_visibility(false)?;\n+                let ty_is_interpolated =\n+                    p.token.is_interpolated() || p.look_ahead(1, |t| t.is_interpolated());\n+                let mut ty = p.parse_ty_sum()?;\n+\n+                // Handle `pub(path) type`, in which `vis` will be `pub` and `ty` will be `(path)`.\n+                if vis == Visibility::Public && !ty_is_interpolated &&\n+                   p.token != token::Comma && p.token != token::CloseDelim(token::Paren) {\n+                    ty = if let TyKind::Paren(ref path_ty) = ty.node {\n+                        if let TyKind::Path(None, ref path) = path_ty.node {\n+                            vis = Visibility::Restricted { path: P(path.clone()), id: path_ty.id };\n+                            Some(p.parse_ty_sum()?)\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    }.unwrap_or(ty);\n+                }\n                 Ok(StructField {\n                     span: mk_sp(lo, p.span.hi),\n                     vis: vis,\n@@ -5263,15 +5280,29 @@ impl<'a> Parser<'a> {\n         self.parse_single_struct_field(vis, attrs)\n     }\n \n-    fn parse_visibility(&mut self, allow_restricted: bool) -> PResult<'a, Visibility> {\n+    // If `allow_path` is false, just parse the `pub` in `pub(path)` (but still parse `pub(crate)`)\n+    fn parse_visibility(&mut self, allow_path: bool) -> PResult<'a, Visibility> {\n+        let pub_crate = |this: &mut Self| {\n+            let span = this.last_span;\n+            this.expect(&token::CloseDelim(token::Paren))?;\n+            Ok(Visibility::Crate(span))\n+        };\n+\n         if !self.eat_keyword(keywords::Pub) {\n             Ok(Visibility::Inherited)\n-        } else if !allow_restricted || !self.eat(&token::OpenDelim(token::Paren)) {\n+        } else if !allow_path {\n+            // Look ahead to avoid eating the `(` in `pub(path)` while still parsing `pub(crate)`\n+            if self.token == token::OpenDelim(token::Paren) &&\n+               self.look_ahead(1, |t| t.is_keyword(keywords::Crate)) {\n+                self.bump(); self.bump();\n+                pub_crate(self)\n+            } else {\n+                Ok(Visibility::Public)\n+            }\n+        } else if !self.eat(&token::OpenDelim(token::Paren)) {\n             Ok(Visibility::Public)\n         } else if self.eat_keyword(keywords::Crate) {\n-            let span = self.last_span;\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-            Ok(Visibility::Crate(span))\n+            pub_crate(self)\n         } else {\n             let path = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::CloseDelim(token::Paren))?;"}]}