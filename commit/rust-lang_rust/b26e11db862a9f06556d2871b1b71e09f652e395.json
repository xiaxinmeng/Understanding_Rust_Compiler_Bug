{"sha": "b26e11db862a9f06556d2871b1b71e09f652e395", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNmUxMWRiODYyYTlmMDY1NTZkMjg3MWIxYjcxZTA5ZjY1MmUzOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-18T22:02:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-18T22:02:04Z"}, "message": "auto merge of #8560 : kballard/rust/reserve-yield, r=pcwalton\n\nRename task::yield() to task::deschedule().\r\n\r\nFixes #8494.", "tree": {"sha": "f2515c8e289133c917b0dfd1d0d2f5e4ba7e3281", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2515c8e289133c917b0dfd1d0d2f5e4ba7e3281"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b26e11db862a9f06556d2871b1b71e09f652e395", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b26e11db862a9f06556d2871b1b71e09f652e395", "html_url": "https://github.com/rust-lang/rust/commit/b26e11db862a9f06556d2871b1b71e09f652e395", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b26e11db862a9f06556d2871b1b71e09f652e395/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e185b049af214cc7900beaae557a12863f4b3ce3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e185b049af214cc7900beaae557a12863f4b3ce3", "html_url": "https://github.com/rust-lang/rust/commit/e185b049af214cc7900beaae557a12863f4b3ce3"}, {"sha": "418e1ebae6ed543b1a78c3e987d42bf0bf25f310", "url": "https://api.github.com/repos/rust-lang/rust/commits/418e1ebae6ed543b1a78c3e987d42bf0bf25f310", "html_url": "https://github.com/rust-lang/rust/commit/418e1ebae6ed543b1a78c3e987d42bf0bf25f310"}], "stats": {"total": 147, "additions": 75, "deletions": 72}, "files": [{"sha": "1704e9a48d6c591b5377daef26e29421f7a12fc0", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -762,7 +762,7 @@ mod tests {\n                 do 10.times {\n                     let tmp = *num;\n                     *num = -1;\n-                    task::yield();\n+                    task::deschedule();\n                     *num = tmp + 1;\n                 }\n                 c.send(());\n@@ -913,17 +913,17 @@ mod tests {\n             do read_mode.read |state| {\n                 // if writer mistakenly got in, make sure it mutates state\n                 // before we assert on it\n-                do 5.times { task::yield(); }\n+                do 5.times { task::deschedule(); }\n                 // make sure writer didn't get in.\n                 assert!(*state);\n             }\n         }\n     }\n     #[test]\n     fn test_rw_write_cond_downgrade_read_race() {\n-        // Ideally the above test case would have yield statements in it that\n+        // Ideally the above test case would have deschedule statements in it that\n         // helped to expose the race nearly 100% of the time... but adding\n-        // yields in the intuitively-right locations made it even less likely,\n+        // deschedules in the intuitively-right locations made it even less likely,\n         // and I wasn't sure why :( . This is a mediocre \"next best\" option.\n         do 8.times { test_rw_write_cond_downgrade_read_race_helper() }\n     }"}, {"sha": "d32b7d6af03cd57ec45af451cb4e0a04030d2608", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -112,7 +112,7 @@ impl<Q:Send> Sem<Q> {\n                 }\n             }\n             // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n-            /* do 1000.times { task::yield(); } */\n+            /* do 1000.times { task::deschedule(); } */\n             // Need to wait outside the exclusive.\n             if waiter_nobe.is_some() {\n                 let _ = waiter_nobe.unwrap().recv();\n@@ -225,7 +225,7 @@ impl<'self> Condvar<'self> {\n                 }\n             }\n \n-            // If yield checks start getting inserted anywhere, we can be\n+            // If deschedule checks start getting inserted anywhere, we can be\n             // killed before or after enqueueing. Deciding whether to\n             // unkillably reacquire the lock needs to happen atomically\n             // wrt enqueuing.\n@@ -731,11 +731,11 @@ mod tests {\n         let s2 = ~s.clone();\n         do task::spawn || {\n             do s2.access {\n-                do 5.times { task::yield(); }\n+                do 5.times { task::deschedule(); }\n             }\n         }\n         do s.access {\n-            do 5.times { task::yield(); }\n+            do 5.times { task::deschedule(); }\n         }\n     }\n     #[test]\n@@ -748,7 +748,7 @@ mod tests {\n             s2.acquire();\n             c.send(());\n         }\n-        do 5.times { task::yield(); }\n+        do 5.times { task::deschedule(); }\n         s.release();\n         let _ = p.recv();\n \n@@ -757,7 +757,7 @@ mod tests {\n         let s = ~Semaphore::new(0);\n         let s2 = ~s.clone();\n         do task::spawn || {\n-            do 5.times { task::yield(); }\n+            do 5.times { task::deschedule(); }\n             s2.release();\n             let _ = p.recv();\n         }\n@@ -800,7 +800,7 @@ mod tests {\n                     c.send(());\n                 }\n                 let _ = p.recv(); // wait for child to come alive\n-                do 5.times { task::yield(); } // let the child contend\n+                do 5.times { task::deschedule(); } // let the child contend\n             }\n             let _ = p.recv(); // wait for child to be done\n         }\n@@ -837,7 +837,7 @@ mod tests {\n             do n.times {\n                 do m.lock {\n                     let oldval = *sharedstate;\n-                    task::yield();\n+                    task::deschedule();\n                     *sharedstate = oldval + 1;\n                 }\n             }\n@@ -948,7 +948,7 @@ mod tests {\n             let (p,c) = comm::stream();\n             do task::spawn || { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n-                task::yield();\n+                task::deschedule();\n                 fail!();\n             }\n             do m2.lock_cond |cond| {\n@@ -1114,7 +1114,7 @@ mod tests {\n             do n.times {\n                 do lock_rwlock_in_mode(x, mode) {\n                     let oldval = *sharedstate;\n-                    task::yield();\n+                    task::deschedule();\n                     *sharedstate = oldval + 1;\n                 }\n             }"}, {"sha": "1608d8cbc2c31fe81c28fbe71e6b4535ec26b4c6", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -141,7 +141,7 @@ pub struct Death {\n     on_exit:         Option<~fn(bool)>,\n     // nesting level counter for task::unkillable calls (0 == killable).\n     unkillable:      int,\n-    // nesting level counter for unstable::atomically calls (0 == can yield).\n+    // nesting level counter for unstable::atomically calls (0 == can deschedule).\n     wont_sleep:      int,\n     // A \"spare\" handle to the kill flag inside the kill handle. Used during\n     // blocking/waking as an optimization to avoid two xadds on the refcount.\n@@ -572,16 +572,16 @@ impl Death {\n     }\n \n     /// Enter a possibly-nested \"atomic\" section of code. Just for assertions.\n-    /// All calls must be paired with a subsequent call to allow_yield.\n+    /// All calls must be paired with a subsequent call to allow_deschedule.\n     #[inline]\n-    pub fn inhibit_yield(&mut self) {\n+    pub fn inhibit_deschedule(&mut self) {\n         self.wont_sleep += 1;\n     }\n \n     /// Exit a possibly-nested \"atomic\" section of code. Just for assertions.\n-    /// All calls must be paired with a preceding call to inhibit_yield.\n+    /// All calls must be paired with a preceding call to inhibit_deschedule.\n     #[inline]\n-    pub fn allow_yield(&mut self) {\n+    pub fn allow_deschedule(&mut self) {\n         rtassert!(self.wont_sleep != 0);\n         self.wont_sleep -= 1;\n     }"}, {"sha": "6a81be3dc8ffe9d565cda68f3a976d890d6be95b", "filename": "src/libstd/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -250,7 +250,7 @@ mod test {\n                     let (c2, p3, c4) = x.take();\n                     p3.recv();   // handshake parent\n                     c4.send(()); // normal receive\n-                    task::yield();\n+                    task::deschedule();\n                     c2.send(()); // select receive\n                 }\n \n@@ -294,7 +294,7 @@ mod test {\n                             if send_on_chans.contains(&i) {\n                                 let c = Cell::new(c);\n                                 do spawntask_random {\n-                                    task::yield();\n+                                    task::deschedule();\n                                     c.take().send(());\n                                 }\n                             }"}, {"sha": "2c79f1c4ded985d71a6d5537117e4b5e21b0f9ae", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -537,7 +537,7 @@ pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n     }\n }\n \n-pub fn yield() {\n+pub fn deschedule() {\n     //! Yield control to the task scheduler\n \n     use rt::local::Local;\n@@ -568,10 +568,10 @@ pub fn failing() -> bool {\n  *\n  * ~~~\n  * do task::unkillable {\n- *     // detach / yield / destroy must all be called together\n+ *     // detach / deschedule / destroy must all be called together\n  *     rustrt::rust_port_detach(po);\n  *     // This must not result in the current task being killed\n- *     task::yield();\n+ *     task::deschedule();\n  *     rustrt::rust_port_destroy(po);\n  * }\n  * ~~~\n@@ -689,7 +689,7 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n             let ch = ch.clone();\n             do spawn_unlinked {\n                 // Give middle task a chance to fail-but-not-kill-us.\n-                do 16.times { task::yield(); }\n+                do 16.times { task::deschedule(); }\n                 ch.send(()); // If killed first, grandparent hangs.\n             }\n             fail!(); // Shouldn't kill either (grand)parent or (grand)child.\n@@ -712,7 +712,7 @@ fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n     do run_in_newsched_task {\n         do spawn_supervised { fail!(); }\n         // Give child a chance to fail-but-not-kill-us.\n-        do 16.times { task::yield(); }\n+        do 16.times { task::deschedule(); }\n     }\n }\n #[ignore(reason = \"linked failure\")]\n@@ -821,7 +821,7 @@ fn test_spawn_failure_propagate_grandchild() {\n             do spawn_supervised {\n                 do spawn_supervised { block_forever(); }\n             }\n-            do 16.times { task::yield(); }\n+            do 16.times { task::deschedule(); }\n             fail!();\n         };\n         assert!(result.is_err());\n@@ -838,7 +838,7 @@ fn test_spawn_failure_propagate_secondborn() {\n             do spawn_supervised {\n                 do spawn { block_forever(); } // linked\n             }\n-            do 16.times { task::yield(); }\n+            do 16.times { task::deschedule(); }\n             fail!();\n         };\n         assert!(result.is_err());\n@@ -855,7 +855,7 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n             do spawn { // linked\n                 do spawn_supervised { block_forever(); }\n             }\n-            do 16.times { task::yield(); }\n+            do 16.times { task::deschedule(); }\n             fail!();\n         };\n         assert!(result.is_err());\n@@ -872,7 +872,7 @@ fn test_spawn_linked_sup_propagate_sibling() {\n             do spawn { // linked\n                 do spawn { block_forever(); } // linked\n             }\n-            do 16.times { task::yield(); }\n+            do 16.times { task::deschedule(); }\n             fail!();\n         };\n         assert!(result.is_err());\n@@ -1169,12 +1169,12 @@ fn test_unkillable() {\n \n     // We want to do this after failing\n     do spawn_unlinked {\n-        do 10.times { yield() }\n+        do 10.times { deschedule() }\n         ch.send(());\n     }\n \n     do spawn {\n-        yield();\n+        deschedule();\n         // We want to fail after the unkillable task\n         // blocks on recv\n         fail!();\n@@ -1205,12 +1205,12 @@ fn test_unkillable_nested() {\n \n     // We want to do this after failing\n     do spawn_unlinked || {\n-        do 10.times { yield() }\n+        do 10.times { deschedule() }\n         ch.send(());\n     }\n \n     do spawn {\n-        yield();\n+        deschedule();\n         // We want to fail after the unkillable task\n         // blocks on recv\n         fail!();\n@@ -1277,7 +1277,7 @@ fn test_spawn_watched() {\n                 t.unlinked();\n                 t.watched();\n                 do t.spawn {\n-                    task::yield();\n+                    task::deschedule();\n                     fail!();\n                 }\n             }\n@@ -1313,7 +1313,7 @@ fn test_indestructible() {\n                 t.unwatched();\n                 do t.spawn {\n                     p3.recv();\n-                    task::yield();\n+                    task::deschedule();\n                     fail!();\n                 }\n                 c3.send(());"}, {"sha": "c6b860eb1396654cd528a6892c06bbe96ced428b", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -272,9 +272,9 @@ impl<T> Drop for UnsafeAtomicRcBox<T>{\n \n /**\n  * Enables a runtime assertion that no operation in the argument closure shall\n- * use scheduler operations (yield, recv, spawn, etc). This is for use with\n+ * use scheduler operations (deschedule, recv, spawn, etc). This is for use with\n  * pthread mutexes, which may block the entire scheduler thread, rather than\n- * just one task, and is hence prone to deadlocks if mixed with yielding.\n+ * just one task, and is hence prone to deadlocks if mixed with descheduling.\n  *\n  * NOTE: THIS DOES NOT PROVIDE LOCKING, or any sort of critical-section\n  * synchronization whatsoever. It only makes sense to use for CPU-local issues.\n@@ -288,10 +288,10 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     if in_green_task_context() {\n         let t = Local::unsafe_borrow::<Task>();\n         do (|| {\n-            (*t).death.inhibit_yield();\n+            (*t).death.inhibit_deschedule();\n             f()\n         }).finally {\n-            (*t).death.allow_yield();\n+            (*t).death.allow_deschedule();\n         }\n     } else {\n         f()\n@@ -349,7 +349,7 @@ struct ExData<T> {\n  * This uses a pthread mutex, not one that's aware of the userspace scheduler.\n  * The user of an Exclusive must be careful not to invoke any functions that may\n  * reschedule the task while holding the lock, or deadlock may result. If you\n- * need to block or yield while accessing shared state, use extra::sync::RWArc.\n+ * need to block or deschedule while accessing shared state, use extra::sync::RWArc.\n  */\n pub struct Exclusive<T> {\n     x: UnsafeAtomicRcBox<ExData<T>>\n@@ -377,7 +377,7 @@ impl<T:Send> Exclusive<T> {\n     // Exactly like std::arc::MutexArc,access(), but with the LittleLock\n     // instead of a proper mutex. Same reason for being unsafe.\n     //\n-    // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n+    // Currently, scheduling operations (i.e., descheduling, receiving on a pipe,\n     // accessing the provided condition variable) are prohibited while inside\n     // the Exclusive. Supporting that is a work in progress.\n     #[inline]\n@@ -431,7 +431,7 @@ mod tests {\n     fn test_atomically() {\n         // NB. The whole runtime will abort on an 'atomic-sleep' violation,\n         // so we can't really test for the converse behaviour.\n-        unsafe { do atomically { } } task::yield(); // oughtn't fail\n+        unsafe { do atomically { } } task::deschedule(); // oughtn't fail\n     }\n \n     #[test]\n@@ -545,7 +545,7 @@ mod tests {\n             c.send(());\n         }\n         p.recv();\n-        task::yield(); // Try to make the unwrapper get blocked first.\n+        task::deschedule(); // Try to make the unwrapper get blocked first.\n         let left_x = x.try_unwrap();\n         assert!(left_x.is_left());\n         util::ignore(left_x);\n@@ -566,7 +566,7 @@ mod tests {\n         do task::spawn {\n             let x2 = x2.take();\n             unsafe { do x2.with |_hello| { } }\n-            task::yield();\n+            task::deschedule();\n         }\n         assert!(x.unwrap() == ~~\"hello\");\n \n@@ -612,7 +612,7 @@ mod tests {\n             let x = Exclusive::new(~~\"hello\");\n             let x2 = x.clone();\n             do task::spawn {\n-                do 10.times { task::yield(); } // try to let the unwrapper go\n+                do 10.times { task::deschedule(); } // try to let the unwrapper go\n                 fail!(); // punt it awake from its deadlock\n             }\n             let _z = x.unwrap();"}, {"sha": "0d7def84003e4d27ee13962544995c5f47ebb139", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -477,6 +477,7 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n \n         \"be\",                 // 64\n         \"pure\",               // 65\n+        \"yield\",              // 66\n     ];\n \n     @ident_interner {\n@@ -585,7 +586,6 @@ pub mod keywords {\n         Once,\n         Priv,\n         Pub,\n-        Pure,\n         Ref,\n         Return,\n         Static,\n@@ -601,6 +601,8 @@ pub mod keywords {\n \n         // Reserved keywords\n         Be,\n+        Pure,\n+        Yield,\n     }\n \n     impl Keyword {\n@@ -628,7 +630,6 @@ pub mod keywords {\n                 Once => ident { name: 50, ctxt: 0 },\n                 Priv => ident { name: 51, ctxt: 0 },\n                 Pub => ident { name: 52, ctxt: 0 },\n-                Pure => ident { name: 65, ctxt: 0 },\n                 Ref => ident { name: 53, ctxt: 0 },\n                 Return => ident { name: 54, ctxt: 0 },\n                 Static => ident { name: 27, ctxt: 0 },\n@@ -642,6 +643,8 @@ pub mod keywords {\n                 Use => ident { name: 61, ctxt: 0 },\n                 While => ident { name: 62, ctxt: 0 },\n                 Be => ident { name: 64, ctxt: 0 },\n+                Pure => ident { name: 65, ctxt: 0 },\n+                Yield => ident { name: 66, ctxt: 0 },\n             }\n         }\n     }\n@@ -657,7 +660,7 @@ pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n pub fn is_any_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            8 | 27 | 32 .. 65 => true,\n+            8 | 27 | 32 .. 66 => true,\n             _ => false,\n         },\n         _ => false\n@@ -677,7 +680,7 @@ pub fn is_strict_keyword(tok: &Token) -> bool {\n pub fn is_reserved_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            64 .. 65 => true,\n+            64 .. 66 => true,\n             _ => false,\n         },\n         _ => false,"}, {"sha": "0020a006e68d854a431f3a7767e2e8b6ba0a50d3", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -31,7 +31,7 @@ fn child_generation(gens_left: uint, c: comm::Chan<()>) {\n     do task::spawn_supervised {\n         let c = c.take();\n         if gens_left & 1 == 1 {\n-            task::yield(); // shake things up a bit\n+            task::deschedule(); // shake things up a bit\n         }\n         if gens_left > 0 {\n             child_generation(gens_left - 1, c); // recurse"}, {"sha": "ce5ea56502cc7bb1bdefe63bfb41958110e3001b", "filename": "src/test/run-fail/extern-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-fail.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -35,7 +35,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n \n fn count(n: uint) -> uint {\n     unsafe {\n-        task::yield();\n+        task::deschedule();\n         rustrt::rust_dbg_call(cb, n)\n     }\n }"}, {"sha": "52a67872d4cffba35f640d1f5f7670ddd1fff922", "filename": "src/test/run-fail/linked-failure2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure2.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -21,5 +21,5 @@ fn child() { fail!(); }\n fn main() {\n     let (p, _c) = comm::stream::<()>();\n     task::spawn(|| child() );\n-    task::yield();\n+    task::deschedule();\n }"}, {"sha": "fb2d90e99cf194d0411e2e8c6b6425ba9fe573b3", "filename": "src/test/run-fail/task-comm-recv-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -15,7 +15,7 @@ use std::comm;\n use std::task;\n \n fn goodfail() {\n-    task::yield();\n+    task::deschedule();\n     fail!(\"goodfail\");\n }\n "}, {"sha": "7719a25985082d5d7e78932ae33194087cb994ef", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This creates a bunch of yielding tasks that run concurrently\n+// This creates a bunch of descheduling tasks that run concurrently\n // while holding onto C stacks\n \n use std::libc;\n@@ -27,7 +27,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n     if data == 1u {\n         data\n     } else {\n-        task::yield();\n+        task::deschedule();\n         count(data - 1u) + count(data - 1u)\n     }\n }"}, {"sha": "2972b8559bbc1e62686f5d02fa1f773a1fc59d8b", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -30,7 +30,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n \n fn count(n: uint) -> uint {\n     unsafe {\n-        task::yield();\n+        task::deschedule();\n         rustrt::rust_dbg_call(cb, n)\n     }\n }"}, {"sha": "edfae096407b6f77d7e1da4bc5ccdd13feb515f9", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -108,7 +108,7 @@ pub mod pipes {\n             let old_state = swap_state_acq(&mut (*p).state,\n                                            blocked);\n             match old_state {\n-              empty | blocked => { task::yield(); }\n+              empty | blocked => { task::deschedule(); }\n               full => {\n                 let payload = util::replace(&mut p.payload, None);\n                 return Some(payload.unwrap())"}, {"sha": "4e4d3436fb0fd3b57faa0b96cc065cb4d638d30b", "filename": "src/test/run-pass/send-iloop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-iloop.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -23,13 +23,13 @@ fn iloop() {\n     task::spawn(|| die() );\n     let (p, c) = comm::stream::<()>();\n     loop {\n-        // Sending and receiving here because these actions yield,\n+        // Sending and receiving here because these actions deschedule,\n         // at which point our child can kill us.\n         c.send(());\n         p.recv();\n         // The above comment no longer makes sense but I'm\n         // reluctant to remove a linked failure test case.\n-        task::yield();\n+        task::deschedule();\n     }\n }\n "}, {"sha": "1825f1bcca339ed229e541c4749319f455180283", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -21,5 +21,5 @@ pub fn main() {\n     task::spawn(|| x(~\"hello from second spawned fn\", 66) );\n     task::spawn(|| x(~\"hello from third spawned fn\", 67) );\n     let mut i: int = 30;\n-    while i > 0 { i = i - 1; info!(\"parent sleeping\"); task::yield(); }\n+    while i > 0 { i = i - 1; info!(\"parent sleeping\"); task::deschedule(); }\n }"}, {"sha": "fd0d9568845c147903baa1761f965f88aab1100d", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -36,5 +36,5 @@ pub fn main() {\n     let c = p.recv();\n     c.send(~\"A\");\n     c.send(~\"B\");\n-    task::yield();\n+    task::deschedule();\n }"}, {"sha": "7e741959a9c4fef35f05568a47a1d81203df71dd", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -28,7 +28,7 @@ fn test00() {\n     // Sleep long enough for the task to finish.\n     let mut i = 0;\n     while i < 10000 {\n-        task::yield();\n+        task::deschedule();\n         i += 1;\n     }\n "}, {"sha": "ac9b7a315f809055bdf26103985793ac8ce2453d", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -69,11 +69,11 @@ fn join(port: Port<bool>) -> bool {\n }\n \n fn supervised() {\n-    // Yield to make sure the supervisor joins before we\n+    // Deschedule to make sure the supervisor joins before we\n     // fail. This is currently not needed because the supervisor\n     // runs first, but I can imagine that changing.\n     error!(\"supervised task=%?\", 0);\n-    task::yield();\n+    task::deschedule();\n     fail!();\n }\n "}, {"sha": "d995bd7e3a34ebc3afd82d496da3c5459d2ade24", "filename": "src/test/run-pass/task-killjoin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -19,10 +19,10 @@\n use std::task;\n \n fn supervised() {\n-    // Yield to make sure the supervisor joins before we fail. This is\n+    // Deschedule to make sure the supervisor joins before we fail. This is\n     // currently not needed because the supervisor runs first, but I can\n     // imagine that changing.\n-    task::yield();\n+    task::deschedule();\n     fail!();\n }\n "}, {"sha": "040084df911c794434824f6f49a97618f6c3192f", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -17,13 +17,13 @@ pub fn main() {\n     builder.future_result(|r| { result = Some(r); });\n     builder.spawn(child);\n     error!(\"1\");\n-    task::yield();\n+    task::deschedule();\n     error!(\"2\");\n-    task::yield();\n+    task::deschedule();\n     error!(\"3\");\n     result.unwrap().recv();\n }\n \n fn child() {\n-    error!(\"4\"); task::yield(); error!(\"5\"); task::yield(); error!(\"6\");\n+    error!(\"4\"); task::deschedule(); error!(\"5\"); task::deschedule(); error!(\"6\");\n }"}, {"sha": "cee7f5f4ef098ef3dd32ae56b845557264432c8a", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -17,7 +17,7 @@ pub fn main() {\n     builder.future_result(|r| { result = Some(r); });\n     builder.spawn(child);\n     error!(\"1\");\n-    task::yield();\n+    task::deschedule();\n     result.unwrap().recv();\n }\n "}, {"sha": "5e3dde0257266293e973c2cdb5d244e2ba82a002", "filename": "src/test/run-pass/yield2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fyield2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b26e11db862a9f06556d2871b1b71e09f652e395/src%2Ftest%2Frun-pass%2Fyield2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield2.rs?ref=b26e11db862a9f06556d2871b1b71e09f652e395", "patch": "@@ -13,5 +13,5 @@ use std::task;\n \n pub fn main() {\n     let mut i: int = 0;\n-    while i < 100 { i = i + 1; error!(i); task::yield(); }\n+    while i < 100 { i = i + 1; error!(i); task::deschedule(); }\n }"}]}