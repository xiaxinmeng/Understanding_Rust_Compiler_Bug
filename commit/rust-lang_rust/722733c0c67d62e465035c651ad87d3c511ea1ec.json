{"sha": "722733c0c67d62e465035c651ad87d3c511ea1ec", "node_id": "C_kwDOAAsO6NoAKDcyMjczM2MwYzY3ZDYyZTQ2NTAzNWM2NTFhZDg3ZDNjNTExZWExZWM", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-07-25T13:46:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-25T13:46:04Z"}, "message": "Merge pull request #1247 from bjorn3/melt_some_ice\n\nMelt some ICE", "tree": {"sha": "1cdd98003f065243a5ade19c6359aa30f7c52488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cdd98003f065243a5ade19c6359aa30f7c52488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/722733c0c67d62e465035c651ad87d3c511ea1ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi3p6cCRBK7hj4Ov3rIwAAJrkIAIGhuxVEJLFaNzF0Bo9QcxVa\nDls5HFEEhyMVBwipc2Pe6aN6zFdcvLV/KpyHz1kTYQdThCUoglyvB+JVimLv9elh\n3w9frapEul6Qtfj+LWax7bQ33RfKNnSIWklo7qeBEj4RS66XpG83ZawKNSByk271\n479rca2Rgu0V2JSMwp9Mk2h/f6j2YC5ld9Xtoldn3bUP6KyvN5s3cGRqmqF9NDrt\nXFBGzoKUq+sViTh7hC6lsSsBEOP329WIucPnPDFEa2QD7jro81mdZpGGcOBg6Aec\n/YcwvmbO2zEwOXcjQ+lX0gZ4nmqaeADbD7+UG48h+49foxkreEp+AFp+put9wTs=\n=ddI2\n-----END PGP SIGNATURE-----\n", "payload": "tree 1cdd98003f065243a5ade19c6359aa30f7c52488\nparent 5fcedf62df66c9b197d5a1d2bc8694e35cef1772\nparent fd2669d1e91027c4ce31f9a3690ce6dab7d8619a\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1658756764 +0200\ncommitter GitHub <noreply@github.com> 1658756764 +0200\n\nMerge pull request #1247 from bjorn3/melt_some_ice\n\nMelt some ICE"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/722733c0c67d62e465035c651ad87d3c511ea1ec", "html_url": "https://github.com/rust-lang/rust/commit/722733c0c67d62e465035c651ad87d3c511ea1ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/722733c0c67d62e465035c651ad87d3c511ea1ec/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fcedf62df66c9b197d5a1d2bc8694e35cef1772", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fcedf62df66c9b197d5a1d2bc8694e35cef1772", "html_url": "https://github.com/rust-lang/rust/commit/5fcedf62df66c9b197d5a1d2bc8694e35cef1772"}, {"sha": "fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a", "html_url": "https://github.com/rust-lang/rust/commit/fd2669d1e91027c4ce31f9a3690ce6dab7d8619a"}], "stats": {"total": 338, "additions": 229, "deletions": 109}, "files": [{"sha": "aa1f239bae23ec55bce6c5872f7eac3d37ae8355", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -330,6 +330,17 @@ fn main() {\n     static REF1: &u8 = &42;\n     static REF2: &u8 = REF1;\n     assert_eq!(*REF1, *REF2);\n+\n+    extern \"C\" {\n+        type A;\n+    }\n+\n+    fn main() {\n+        let x: &A = unsafe { &*(1usize as *const A) };\n+\n+        assert_eq!(unsafe { intrinsics::size_of_val(x) }, 0);\n+        assert_eq!(unsafe { intrinsics::min_align_of_val(x) }, 1);\n+}\n }\n \n #[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]"}, {"sha": "0b5b6cd55d720d4750060ecb81f75b83f76f4cf6", "filename": "example/std_example.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -128,6 +128,25 @@ fn main() {\n         0 => loop {},\n         v => panic(v),\n     };\n+\n+    if black_box(false) {\n+        // Based on https://github.com/rust-lang/rust/blob/2f320a224e827b400be25966755a621779f797cc/src/test/ui/debuginfo/debuginfo_with_uninhabitable_field_and_unsized.rs\n+        let _ = Foo::<dyn Send>::new();\n+\n+        #[allow(dead_code)]\n+        struct Foo<T: ?Sized> {\n+            base: Never,\n+            value: T,\n+        }\n+\n+        impl<T: ?Sized> Foo<T> {\n+            pub fn new() -> Box<Foo<T>> {\n+                todo!()\n+            }\n+        }\n+\n+        enum Never {}\n+    }\n }\n \n fn panic(_: u128) {"}, {"sha": "944787612d8bc206e1a29a7ab130518696ecc410", "filename": "scripts/test_rustc_tests.sh", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/scripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/scripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftest_rustc_tests.sh?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -99,9 +99,6 @@ rm -r src/test/run-make/remap-path-prefix-dwarf # requires llvm-dwarfdump\n # ============\n rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n \n-rm -r src/test/ui/polymorphization/ # polymorphization not yet supported\n-rm src/test/codegen-units/polymorphization/unused_type_parameters.rs # same\n-\n rm src/test/incremental/spike-neg1.rs # errors out for some reason\n rm src/test/incremental/spike-neg2.rs # same\n rm src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs"}, {"sha": "815450f689e4ab50c4957a35d5ee90faf22ca7e9", "filename": "src/abi/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -4,6 +4,7 @@ mod comments;\n mod pass_mode;\n mod returning;\n \n+use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_target::abi::call::{Conv, FnAbi};\n@@ -69,7 +70,17 @@ pub(crate) fn import_function<'tcx>(\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name;\n     let sig = get_function_sig(tcx, module.isa().triple(), inst);\n-    module.declare_function(name, Linkage::Import, &sig).unwrap()\n+    match module.declare_function(name, Linkage::Import, &sig) {\n+        Ok(func_id) => func_id,\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{name}` as function, but it was already declared as static\"\n+        )),\n+        Err(ModuleError::IncompatibleSignature(_, prev_sig, new_sig)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{name}` with signature {new_sig:?}, \\\n+             but it was already declared with signature {prev_sig:?}\"\n+        )),\n+        Err(err) => Err::<_, _>(err).unwrap(),\n+    }\n }\n \n impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n@@ -182,6 +193,15 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     }\n \n     let fn_abi = fx.fn_abi.take().unwrap();\n+\n+    // FIXME implement variadics in cranelift\n+    if fn_abi.c_variadic {\n+        fx.tcx.sess.span_fatal(\n+            fx.mir.span,\n+            \"Defining variadic functions is not yet supported by Cranelift\",\n+        );\n+    }\n+\n     let mut arg_abis_iter = fn_abi.args.iter();\n \n     let func_params = fx"}, {"sha": "6c10baa53d415da6e32e64adebecab4d57a059d4", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -216,7 +216,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     is_owned: bool,\n ) -> SmallVec<[Value; 2]> {\n-    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n+    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty, 16);\n     match arg_abi.mode {\n         PassMode::Ignore => smallvec![],\n         PassMode::Direct(_) => smallvec![arg.load_scalar(fx)],"}, {"sha": "c83dab951bc471e8c7260da119b4a95f5fdffd9d", "filename": "src/constant.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -316,14 +316,18 @@ fn data_id_for_static(\n \n     let attrs = tcx.codegen_fn_attrs(def_id);\n \n-    let data_id = module\n-        .declare_data(\n-            &*symbol_name,\n-            linkage,\n-            is_mutable,\n-            attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n-        )\n-        .unwrap();\n+    let data_id = match module.declare_data(\n+        &*symbol_name,\n+        linkage,\n+        is_mutable,\n+        attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n+    ) {\n+        Ok(data_id) => data_id,\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n+        )),\n+        Err(err) => Err::<_, _>(err).unwrap(),\n+    };\n \n     if rlinkage.is_some() {\n         // Comment copied from https://github.com/rust-lang/rust/blob/45060c2a66dfd667f88bd8b94261b28a58d85bd5/src/librustc_codegen_llvm/consts.rs#L141\n@@ -428,7 +432,8 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             let data_id = match reloc_target_alloc {\n                 GlobalAlloc::Function(instance) => {\n                     assert_eq!(addend, 0);\n-                    let func_id = crate::abi::import_function(tcx, module, instance);\n+                    let func_id =\n+                        crate::abi::import_function(tcx, module, instance.polymorphize(tcx));\n                     let local_func_id = module.declare_func_in_data(func_id, &mut data_ctx);\n                     data_ctx.write_function_addr(offset.bytes() as u32, local_func_id);\n                     continue;"}, {"sha": "241de5e36530c8bbddb1bce99b2f4f2fe39fa23b", "filename": "src/inline_asm.rs", "status": "modified", "additions": 90, "deletions": 80, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -18,86 +18,96 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n ) {\n     // FIXME add .eh_frame unwind info directives\n \n-    if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n-        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-        fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n-        return;\n-    } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n-        && matches!(\n-            template[1],\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n-        )\n-        && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n-        && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n-        && matches!(\n-            template[6],\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n-        )\n-    {\n-        assert_eq!(operands.len(), 4);\n-        let (leaf, eax_place) = match operands[1] {\n-            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n-                );\n-                (\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                    crate::base::codegen_place(fx, out_place.unwrap()),\n-                )\n-            }\n-            _ => unreachable!(),\n-        };\n-        let ebx_place = match operands[0] {\n-            InlineAsmOperand::Out { reg, late: true, place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n-                        X86InlineAsmRegClass::reg\n-                    ))\n-                );\n-                crate::base::codegen_place(fx, place.unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n-        let (sub_leaf, ecx_place) = match operands[2] {\n-            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n-                );\n-                (\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                    crate::base::codegen_place(fx, out_place.unwrap()),\n-                )\n-            }\n-            _ => unreachable!(),\n-        };\n-        let edx_place = match operands[3] {\n-            InlineAsmOperand::Out { reg, late: true, place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n-                );\n-                crate::base::codegen_place(fx, place.unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n-\n-        let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n-\n-        eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n-        ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n-        ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n-        edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n-        return;\n-    } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n-        // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-        crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n-    } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n-        crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+    if !template.is_empty() {\n+        if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n+            let true_ = fx.bcx.ins().iconst(types::I32, 1);\n+            fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+            && matches!(\n+                template[1],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n+            && matches!(\n+                template[6],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+        {\n+            assert_eq!(operands.len(), 4);\n+            let (leaf, eax_place) = match operands[1] {\n+                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n+                    );\n+                    (\n+                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                        crate::base::codegen_place(fx, out_place.unwrap()),\n+                    )\n+                }\n+                _ => unreachable!(),\n+            };\n+            let ebx_place = match operands[0] {\n+                InlineAsmOperand::Out { reg, late: true, place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n+                            X86InlineAsmRegClass::reg\n+                        ))\n+                    );\n+                    crate::base::codegen_place(fx, place.unwrap())\n+                }\n+                _ => unreachable!(),\n+            };\n+            let (sub_leaf, ecx_place) = match operands[2] {\n+                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n+                    );\n+                    (\n+                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                        crate::base::codegen_place(fx, out_place.unwrap()),\n+                    )\n+                }\n+                _ => unreachable!(),\n+            };\n+            let edx_place = match operands[3] {\n+                InlineAsmOperand::Out { reg, late: true, place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n+                    );\n+                    crate::base::codegen_place(fx, place.unwrap())\n+                }\n+                _ => unreachable!(),\n+            };\n+\n+            let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n+\n+            eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+            ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+            ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+            edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+            return;\n+        } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+            // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n+            crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+        } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n+            crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+        }\n     }\n \n     let mut inputs = Vec::new();"}, {"sha": "537aade8b86a489a98ebce09c7ddee6ca26a7d78", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -404,7 +404,9 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n         size_of_val, (c ptr) {\n             let layout = fx.layout_of(substs.type_at(0));\n-            let size = if layout.is_unsized() {\n+            // Note: Can't use is_unsized here as truly unsized types need to take the fixed size\n+            // branch\n+            let size = if let Abi::ScalarPair(_, _) = ptr.layout().abi {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (size, _align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n                 size\n@@ -418,7 +420,9 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n         min_align_of_val, (c ptr) {\n             let layout = fx.layout_of(substs.type_at(0));\n-            let align = if layout.is_unsized() {\n+            // Note: Can't use is_unsized here as truly unsized types need to take the fixed size\n+            // branch\n+            let align = if let Abi::ScalarPair(_, _) = ptr.layout().abi {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (_size, align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n                 align\n@@ -1135,6 +1139,20 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             // FIXME implement black_box semantics\n             ret.write_cvalue(fx, a);\n         };\n+\n+        // FIXME implement variadics in cranelift\n+        va_copy, (o _dest, o _src) {\n+            fx.tcx.sess.span_fatal(\n+                source_info.span,\n+                \"Defining variadic functions is not yet supported by Cranelift\",\n+            );\n+        };\n+        va_arg | va_end, (o _valist) {\n+            fx.tcx.sess.span_fatal(\n+                source_info.span,\n+                \"Defining variadic functions is not yet supported by Cranelift\",\n+            );\n+        };\n     }\n \n     let ret_block = fx.get_block(destination.unwrap());"}, {"sha": "c67b6e98b32c7daeeca8558ed2882f082cd0b103", "filename": "src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -109,7 +109,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n                     tcx.mk_substs([GenericArg::from(main_ret_ty)].iter()),\n                 )\n                 .unwrap()\n-                .unwrap();\n+                .unwrap()\n+                .polymorphize(tcx);\n \n                 let report_name = tcx.symbol_name(report).name;\n                 let report_sig = get_function_sig(tcx, m.isa().triple(), report);"}, {"sha": "052ca0a082b3c62261bea1e2d36a3a93936d84a4", "filename": "src/unsize.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -153,11 +153,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     info: Value,\n ) -> (Value, Value) {\n-    if !layout.is_unsized() {\n-        let size = fx.bcx.ins().iconst(fx.pointer_type, layout.size.bytes() as i64);\n-        let align = fx.bcx.ins().iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n-        return (size, align);\n-    }\n+    assert!(layout.is_unsized() || layout.abi == Abi::Uninhabited);\n     match layout.ty.kind() {\n         ty::Dynamic(..) => {\n             // load size/align from vtable"}, {"sha": "6674099e9a23b8263d84e70e2cf22bf8637d2840", "filename": "src/value_and_place.rs", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/722733c0c67d62e465035c651ad87d3c511ea1ec/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=722733c0c67d62e465035c651ad87d3c511ea1ec", "patch": "@@ -324,6 +324,12 @@ impl<'tcx> CPlace<'tcx> {\n             };\n         }\n \n+        if layout.size.bytes() >= u64::from(u32::MAX - 16) {\n+            fx.tcx\n+                .sess\n+                .fatal(&format!(\"values of type {} are too big to store on the stack\", layout.ty));\n+        }\n+\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n@@ -420,7 +426,7 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn write_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>, from: CValue<'tcx>) {\n-        assert_assignable(fx, from.layout().ty, self.layout().ty);\n+        assert_assignable(fx, from.layout().ty, self.layout().ty, 16);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n     }\n@@ -782,18 +788,25 @@ pub(crate) fn assert_assignable<'tcx>(\n     fx: &FunctionCx<'_, '_, 'tcx>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n+    limit: usize,\n ) {\n+    if limit == 0 {\n+        // assert_assignable exists solely to catch bugs in cg_clif. it isn't necessary for\n+        // soundness. don't attempt to check deep types to avoid exponential behavior in certain\n+        // cases.\n+        return;\n+    }\n     match (from_ty.kind(), to_ty.kind()) {\n         (ty::Ref(_, a, _), ty::Ref(_, b, _))\n         | (\n             ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n             ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n         ) => {\n-            assert_assignable(fx, *a, *b);\n+            assert_assignable(fx, *a, *b, limit - 1);\n         }\n         (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n         | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n-            assert_assignable(fx, *a, *b);\n+            assert_assignable(fx, *a, *b, limit - 1);\n         }\n         (ty::FnPtr(_), ty::FnPtr(_)) => {\n             let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n@@ -823,25 +836,55 @@ pub(crate) fn assert_assignable<'tcx>(\n             }\n             // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n         }\n+        (&ty::Tuple(types_a), &ty::Tuple(types_b)) => {\n+            let mut types_a = types_a.iter();\n+            let mut types_b = types_b.iter();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n         (&ty::Adt(adt_def_a, substs_a), &ty::Adt(adt_def_b, substs_b))\n             if adt_def_a.did() == adt_def_b.did() =>\n         {\n             let mut types_a = substs_a.types();\n             let mut types_b = substs_b.types();\n             loop {\n                 match (types_a.next(), types_b.next()) {\n-                    (Some(a), Some(b)) => assert_assignable(fx, a, b),\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n                     (None, None) => return,\n                     (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n                 }\n             }\n         }\n-        (ty::Array(a, _), ty::Array(b, _)) => assert_assignable(fx, *a, *b),\n+        (ty::Array(a, _), ty::Array(b, _)) => assert_assignable(fx, *a, *b, limit - 1),\n+        (&ty::Closure(def_id_a, substs_a), &ty::Closure(def_id_b, substs_b))\n+            if def_id_a == def_id_b =>\n+        {\n+            let mut types_a = substs_a.types();\n+            let mut types_b = substs_b.types();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n+        (ty::Param(_), _) | (_, ty::Param(_)) if fx.tcx.sess.opts.unstable_opts.polymorphize => {\n+            // No way to check if it is correct or not with polymorphization enabled\n+        }\n         _ => {\n             assert_eq!(\n-                from_ty, to_ty,\n+                from_ty,\n+                to_ty,\n                 \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                from_ty, to_ty, fx,\n+                from_ty.kind(),\n+                to_ty.kind(),\n+                fx,\n             );\n         }\n     }"}]}