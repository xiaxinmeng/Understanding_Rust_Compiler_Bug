{"sha": "b2d9b6323e3573839760ea3dc83a2c1658a01cf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZDliNjMyM2UzNTczODM5NzYwZWEzZGM4M2EyYzE2NThhMDFjZjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-08T22:37:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-08T22:37:35Z"}, "message": "Auto merge of #41092 - jonhoo:std-fence-intrinsics, r=alexcrichton\n\nAdd safe wrapper for atomic_compilerfence intrinsics\n\nThis PR adds a proposed safe wrapper for the `atomic_singlethreadfence_*` intrinsics introduced by [RFC #888](https://github.com/rust-lang/rfcs/pull/888). See #41091 for further discussion.", "tree": {"sha": "3a74650bca3c60638f33c9b64a665b829f1a7de0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a74650bca3c60638f33c9b64a665b829f1a7de0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2d9b6323e3573839760ea3dc83a2c1658a01cf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d9b6323e3573839760ea3dc83a2c1658a01cf2", "html_url": "https://github.com/rust-lang/rust/commit/b2d9b6323e3573839760ea3dc83a2c1658a01cf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2d9b6323e3573839760ea3dc83a2c1658a01cf2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "666e7148d167de551a7c3692caf9966f49773f4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/666e7148d167de551a7c3692caf9966f49773f4c", "html_url": "https://github.com/rust-lang/rust/commit/666e7148d167de551a7c3692caf9966f49773f4c"}, {"sha": "f093d59c31bd2064328e24d0ec76e0d105fc32fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f093d59c31bd2064328e24d0ec76e0d105fc32fc", "html_url": "https://github.com/rust-lang/rust/commit/f093d59c31bd2064328e24d0ec76e0d105fc32fc"}], "stats": {"total": 148, "additions": 148, "deletions": 0}, "files": [{"sha": "93ce911ac6cc72169cb25bb45163beda497fde2b", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d9b6323e3573839760ea3dc83a2c1658a01cf2/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d9b6323e3573839760ea3dc83a2c1658a01cf2/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=b2d9b6323e3573839760ea3dc83a2c1658a01cf2", "patch": "@@ -37,6 +37,7 @@\n - [collections](collections.md)\n - [collections_range](collections-range.md)\n - [command_envs](command-envs.md)\n+- [compiler_barriers](compiler-barriers.md)\n - [compiler_builtins](compiler-builtins.md)\n - [compiler_builtins_lib](compiler-builtins-lib.md)\n - [concat_idents](concat-idents.md)"}, {"sha": "827447f0bd5107a02a1cf240b0c4f6d403d381d3", "filename": "src/doc/unstable-book/src/compiler-barriers.md", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b2d9b6323e3573839760ea3dc83a2c1658a01cf2/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-barriers.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d9b6323e3573839760ea3dc83a2c1658a01cf2/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-barriers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-barriers.md?ref=b2d9b6323e3573839760ea3dc83a2c1658a01cf2", "patch": "@@ -0,0 +1,106 @@\n+# `compiler_barriers`\n+\n+The tracking issue for this feature is: [#41091]\n+\n+[#41091]: https://github.com/rust-lang/rust/issues/41091\n+\n+------------------------\n+\n+The `compiler_barriers` feature exposes the `compiler_barrier` function\n+in `std::sync::atomic`. This function is conceptually similar to C++'s\n+`atomic_signal_fence`, which can currently only be accessed in nightly\n+Rust using the `atomic_singlethreadfence_*` instrinsic functions in\n+`core`, or through the mostly equivalent literal assembly:\n+\n+```rust\n+#![feature(asm)]\n+unsafe { asm!(\"\" ::: \"memory\" : \"volatile\") };\n+```\n+\n+A `compiler_barrier` restricts the kinds of memory re-ordering the\n+compiler is allowed to do. Specifically, depending on the given ordering\n+semantics, the compiler may be disallowed from moving reads or writes\n+from before or after the call to the other side of the call to\n+`compiler_barrier`. Note that it does **not** prevent the *hardware*\n+from doing such re-ordering. This is not a problem in a single-threaded,\n+execution context, but when other threads may modify memory at the same\n+time, stronger synchronization primitives are required.\n+\n+## Examples\n+\n+`compiler_barrier` is generally only useful for preventing a thread from\n+racing *with itself*. That is, if a given thread is executing one piece\n+of code, and is then interrupted, and starts executing code elsewhere\n+(while still in the same thread, and conceptually still on the same\n+core). In traditional programs, this can only occur when a signal\n+handler is registered. In more low-level code, such situations can also\n+arise when handling interrupts, when implementing green threads with\n+pre-emption, etc.\n+\n+To give a straightforward example of when a `compiler_barrier` is\n+necessary, consider the following example:\n+\n+```rust\n+# use std::sync::atomic::{AtomicBool, AtomicUsize};\n+# use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n+# use std::sync::atomic::Ordering;\n+static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n+static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n+\n+fn main() {\n+    IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n+    IS_READY.store(true, Ordering::Relaxed);\n+}\n+\n+fn signal_handler() {\n+    if IS_READY.load(Ordering::Relaxed) {\n+        assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n+    }\n+}\n+```\n+\n+The way it is currently written, the `assert_eq!` is *not* guaranteed to\n+succeed, despite everything happening in a single thread. To see why,\n+remember that the compiler is free to swap the stores to\n+`IMPORTANT_VARIABLE` and `IS_READ` since they are both\n+`Ordering::Relaxed`. If it does, and the signal handler is invoked right\n+after `IS_READY` is updated, then the signal handler will see\n+`IS_READY=1`, but `IMPORTANT_VARIABLE=0`.\n+\n+Using a `compiler_barrier`, we can remedy this situation:\n+\n+```rust\n+#![feature(compiler_barriers)]\n+# use std::sync::atomic::{AtomicBool, AtomicUsize};\n+# use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n+# use std::sync::atomic::Ordering;\n+use std::sync::atomic::compiler_barrier;\n+\n+static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n+static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n+\n+fn main() {\n+    IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n+    // prevent earlier writes from being moved beyond this point\n+    compiler_barrier(Ordering::Release);\n+    IS_READY.store(true, Ordering::Relaxed);\n+}\n+\n+fn signal_handler() {\n+    if IS_READY.load(Ordering::Relaxed) {\n+        assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n+    }\n+}\n+```\n+\n+A deeper discussion of compiler barriers with various re-ordering\n+semantics (such as `Ordering::SeqCst`) is beyond the scope of this text.\n+Curious readers are encouraged to read the Linux kernel's discussion of\n+[memory barriers][1], the C++ references on [`std::memory_order`][2] and\n+[`atomic_signal_fence`][3], and [this StackOverflow answer][4] for\n+further details.\n+\n+[1]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n+[2]: http://en.cppreference.com/w/cpp/atomic/memory_order\n+[3]: http://www.cplusplus.com/reference/atomic/atomic_signal_fence/\n+[4]: http://stackoverflow.com/a/18454971/472927"}, {"sha": "0c70524ead246beee3a85bbe16754f9612f34329", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b2d9b6323e3573839760ea3dc83a2c1658a01cf2/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d9b6323e3573839760ea3dc83a2c1658a01cf2/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=b2d9b6323e3573839760ea3dc83a2c1658a01cf2", "patch": "@@ -1591,6 +1591,47 @@ pub fn fence(order: Ordering) {\n }\n \n \n+/// A compiler memory barrier.\n+///\n+/// `compiler_barrier` does not emit any machine code, but prevents the compiler from re-ordering\n+/// memory operations across this point. Which reorderings are disallowed is dictated by the given\n+/// [`Ordering`]. Note that `compiler_barrier` does *not* introduce inter-thread memory\n+/// synchronization; for that, a [`fence`] is needed.\n+///\n+/// The re-ordering prevented by the different ordering semantics are:\n+///\n+///  - with [`SeqCst`], no re-ordering of reads and writes across this point is allowed.\n+///  - with [`Release`], preceding reads and writes cannot be moved past subsequent writes.\n+///  - with [`Acquire`], subsequent reads and writes cannot be moved ahead of preceding reads.\n+///  - with [`AcqRel`], both of the above rules are enforced.\n+///\n+/// # Panics\n+///\n+/// Panics if `order` is [`Relaxed`].\n+///\n+/// [`fence`]: fn.fence.html\n+/// [`Ordering`]: enum.Ordering.html\n+/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n+/// [`Release`]: enum.Ordering.html#variant.Release\n+/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+#[inline]\n+#[unstable(feature = \"compiler_barriers\", issue = \"41091\")]\n+pub fn compiler_barrier(order: Ordering) {\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_singlethreadfence_acq(),\n+            Release => intrinsics::atomic_singlethreadfence_rel(),\n+            AcqRel => intrinsics::atomic_singlethreadfence_acqrel(),\n+            SeqCst => intrinsics::atomic_singlethreadfence(),\n+            Relaxed => panic!(\"there is no such thing as a relaxed barrier\"),\n+            __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+        }\n+    }\n+}\n+\n+\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl fmt::Debug for AtomicBool {"}]}