{"sha": "3ebc12d25f146291e0e5c0630eea6098f417420d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYmMxMmQyNWYxNDYyOTFlMGU1YzA2MzBlZWE2MDk4ZjQxNzQyMGQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-03-02T11:26:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-02T11:26:22Z"}, "message": "Merge pull request #1584 from ensch/master\n\nFix for rustc 1.17.0-nightly (be760566c 2017-02-28)", "tree": {"sha": "9973633c997bfbdd622bba84edeb4181b7635539", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9973633c997bfbdd622bba84edeb4181b7635539"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ebc12d25f146291e0e5c0630eea6098f417420d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ebc12d25f146291e0e5c0630eea6098f417420d", "html_url": "https://github.com/rust-lang/rust/commit/3ebc12d25f146291e0e5c0630eea6098f417420d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ebc12d25f146291e0e5c0630eea6098f417420d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a39b5f95b83efdb8202956b0f4514b6459046be5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a39b5f95b83efdb8202956b0f4514b6459046be5", "html_url": "https://github.com/rust-lang/rust/commit/a39b5f95b83efdb8202956b0f4514b6459046be5"}, {"sha": "51295960bf499368e48e9da2eafcdc9dbb7e2918", "url": "https://api.github.com/repos/rust-lang/rust/commits/51295960bf499368e48e9da2eafcdc9dbb7e2918", "html_url": "https://github.com/rust-lang/rust/commit/51295960bf499368e48e9da2eafcdc9dbb7e2918"}], "stats": {"total": 697, "additions": 390, "deletions": 307}, "files": [{"sha": "1cd57e632ca71d2487b23a68b40882b8f8b195ac", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -1,9 +1,8 @@\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n-use rustc_const_math::ConstInt;\n+use rustc_const_math::{ConstUsize,ConstIsize,ConstInt};\n use rustc::hir;\n use syntax::ast::RangeLimits;\n use utils::{self, higher};\n@@ -61,11 +60,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n             // Array with known size can be checked statically\n             let ty = cx.tables.expr_ty(array);\n             if let ty::TyArray(_, size) = ty.sty {\n-                let size = ConstInt::Infer(size as u128);\n+                let size = ConstInt::Usize(ConstUsize::new(size as u64, cx.sess().target.uint_type).expect(\"array size is invalid\"));\n                 let constcx = ConstContext::with_tables(cx.tcx, cx.tables);\n \n                 // Index is a constant uint\n-                let const_index = constcx.eval(index, ExprTypeChecked);\n+                let const_index = constcx.eval(index);\n                 if let Ok(ConstVal::Integral(const_index)) = const_index {\n                     if size <= const_index {\n                         utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n@@ -77,10 +76,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n                 // Index is a constant range\n                 if let Some(range) = higher::range(index) {\n                     let start = range.start\n-                        .map(|start| constcx.eval(start, ExprTypeChecked))\n+                        .map(|start| constcx.eval(start))\n                         .map(|v| v.ok());\n                     let end = range.end\n-                        .map(|end| constcx.eval(end, ExprTypeChecked))\n+                        .map(|end| constcx.eval(end))\n                         .map(|v| v.ok());\n \n                     if let Some((start, end)) = to_const_range(&start, &end, range.limits, size) {\n@@ -117,13 +116,30 @@ fn to_const_range(\n     let start = match *start {\n         Some(Some(ConstVal::Integral(x))) => x,\n         Some(_) => return None,\n-        None => ConstInt::Infer(0),\n+        None => ConstInt::U8(0),\n     };\n \n     let end = match *end {\n         Some(Some(ConstVal::Integral(x))) => {\n             if limits == RangeLimits::Closed {\n-                (x + ConstInt::Infer(1)).expect(\"such a big array is not realistic\")\n+                match x {\n+                    ConstInt::U8(_) => (x + ConstInt::U8(1)),\n+                    ConstInt::U16(_) => (x + ConstInt::U16(1)),\n+                    ConstInt::U32(_) => (x + ConstInt::U32(1)),\n+                    ConstInt::U64(_) => (x + ConstInt::U64(1)),\n+                    ConstInt::U128(_) => (x + ConstInt::U128(1)),\n+                    ConstInt::Usize(ConstUsize::Us16(_)) => (x + ConstInt::Usize(ConstUsize::Us16(1))),\n+                    ConstInt::Usize(ConstUsize::Us32(_)) => (x + ConstInt::Usize(ConstUsize::Us32(1))),\n+                    ConstInt::Usize(ConstUsize::Us64(_)) => (x + ConstInt::Usize(ConstUsize::Us64(1))),\n+                    ConstInt::I8(_) => (x + ConstInt::I8(1)),\n+                    ConstInt::I16(_) => (x + ConstInt::I16(1)),\n+                    ConstInt::I32(_) => (x + ConstInt::I32(1)),\n+                    ConstInt::I64(_) => (x + ConstInt::I64(1)),\n+                    ConstInt::I128(_) => (x + ConstInt::I128(1)),\n+                    ConstInt::Isize(ConstIsize::Is16(_)) => (x + ConstInt::Isize(ConstIsize::Is16(1))),\n+                    ConstInt::Isize(ConstIsize::Is32(_)) => (x + ConstInt::Isize(ConstIsize::Is32(1))),\n+                    ConstInt::Isize(ConstIsize::Is64(_)) => (x + ConstInt::Isize(ConstIsize::Is64(1))),\n+                }.expect(\"such a big array is not realistic\")\n             } else {\n                 x\n             }"}, {"sha": "789de240d732943b168a5dfab6b9013b22078d23", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -237,6 +237,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n }\n \n fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n+    use rustc::ty::subst::Substs;\n     match lit.node {\n         ExprLit(ref lit_ptr) => {\n             if let LitKind::Int(value, _) = lit_ptr.node {\n@@ -248,7 +249,7 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n         ExprPath(ref qpath) => {\n             let def = cx.tables.qpath_def(qpath, lit.id);\n             if let Def::Const(def_id) = def {\n-                lookup_const_by_id(cx.tcx, def_id, None).and_then(|(l, _tab, _ty)| fetch_int_literal(cx, l))\n+                lookup_const_by_id(cx.tcx, def_id, Substs::empty()).and_then(|(l, _ty)| fetch_int_literal(cx, l))\n             } else {\n                 None\n             }"}, {"sha": "b38b906b4a65659befc57f17196cdf433cb29490", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -3,14 +3,15 @@\n use rustc::lint::LateContext;\n use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n-use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n+use rustc_const_math::ConstInt;\n use rustc::hir::*;\n+use rustc::ty::{TyCtxt, self};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::rc::Rc;\n-use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy, NodeId};\n+use syntax::ast::{FloatTy, LitKind, StrStyle, NodeId};\n use syntax::ptr::P;\n \n #[derive(Debug, Copy, Clone)]\n@@ -174,29 +175,36 @@ impl PartialOrd for Constant {\n \n /// parse a `LitKind` to a `Constant`\n #[allow(cast_possible_wrap)]\n-pub fn lit_to_constant(lit: &LitKind) -> Constant {\n+pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: ty::Ty<'tcx>) -> Constant {\n+    use syntax::ast::*;\n+    use syntax::ast::LitIntType::*;\n+    use rustc::ty::util::IntTypeExt;\n+\n+    if let ty::TyAdt(adt, _) = ty.sty {\n+        if adt.is_enum() {\n+            ty = adt.repr.discr_type().to_ty(tcx)\n+        }\n+    }\n     match *lit {\n         LitKind::Str(ref is, style) => Constant::Str(is.to_string(), style),\n         LitKind::Byte(b) => Constant::Int(ConstInt::U8(b)),\n         LitKind::ByteStr(ref s) => Constant::Binary(s.clone()),\n         LitKind::Char(c) => Constant::Char(c),\n-        LitKind::Int(value, LitIntType::Unsuffixed) => Constant::Int(ConstInt::Infer(value)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U8)) => Constant::Int(ConstInt::U8(value as u8)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U16)) => Constant::Int(ConstInt::U16(value as u16)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U32)) => Constant::Int(ConstInt::U32(value as u32)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U64)) => Constant::Int(ConstInt::U64(value as u64)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U128)) => Constant::Int(ConstInt::U128(value as u128)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => {\n-            Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32)))\n-        },\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I8)) => Constant::Int(ConstInt::I8(value as i8)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I16)) => Constant::Int(ConstInt::I16(value as i16)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I32)) => Constant::Int(ConstInt::I32(value as i32)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I64)) => Constant::Int(ConstInt::I64(value as i64)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I128)) => Constant::Int(ConstInt::I128(value as i128)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => {\n-            Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32)))\n-        },\n+        LitKind::Int(n, hint) => {\n+            match (&ty.sty, hint) {\n+                (&ty::TyInt(ity), _) |\n+                (_, Signed(ity)) => {\n+                    Constant::Int(ConstInt::new_signed_truncating(n as i128,\n+                        ity, tcx.sess.target.int_type))\n+                }\n+                (&ty::TyUint(uty), _) |\n+                (_, Unsigned(uty)) => {\n+                    Constant::Int(ConstInt::new_unsigned_truncating(n as u128,\n+                        uty, tcx.sess.target.uint_type))\n+                }\n+                _ => bug!()\n+            }\n+        }\n         LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n         LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n         LitKind::Bool(b) => Constant::Bool(b),\n@@ -231,22 +239,20 @@ fn neg_float_str(s: &str) -> String {\n \n pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n-        lcx: Some(lcx),\n+        tcx: lcx.tcx,\n+        tables: lcx.tables,\n         needed_resolution: false,\n     };\n     cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n \n-pub fn constant_simple(e: &Expr) -> Option<Constant> {\n-    let mut cx = ConstEvalLateContext {\n-        lcx: None,\n-        needed_resolution: false,\n-    };\n-    cx.expr(e)\n+pub fn constant_simple(lcx: &LateContext, e: &Expr) -> Option<Constant> {\n+    constant(lcx, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n-struct ConstEvalLateContext<'c, 'cc: 'c> {\n-    lcx: Option<&'c LateContext<'c, 'cc>>,\n+struct ConstEvalLateContext<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::TypeckTables<'tcx>,\n     needed_resolution: bool,\n }\n \n@@ -257,17 +263,14 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprPath(ref qpath) => self.fetch_path(qpath, e.id),\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n-            ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n+            ExprLit(ref lit) => Some(lit_to_constant(&lit.node, self.tcx, self.tables.expr_ty(e))),\n             ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprRepeat(ref value, number_id) => {\n-                if let Some(lcx) = self.lcx {\n-                    self.binop_apply(value,\n-                                     &lcx.tcx.hir.body(number_id).value,\n-                                     |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n-                } else {\n-                    None\n-                }\n+                let val = &self.tcx.hir.body(number_id).value;\n+                self.binop_apply(value,\n+                                 val,\n+                                 |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n             },\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| match op {\n@@ -292,24 +295,27 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n \n     /// lookup a possibly constant expression from a ExprPath\n     fn fetch_path(&mut self, qpath: &QPath, id: NodeId) -> Option<Constant> {\n-        if let Some(lcx) = self.lcx {\n-            let def = lcx.tables.qpath_def(qpath, id);\n-            match def {\n-                Def::Const(def_id) |\n-                Def::AssociatedConst(def_id) => {\n-                    let substs = Some(lcx.tables\n-                        .node_id_item_substs(id)\n-                        .unwrap_or_else(|| lcx.tcx.intern_substs(&[])));\n-                    if let Some((const_expr, _tab, _ty)) = lookup_const_by_id(lcx.tcx, def_id, substs) {\n-                        let ret = self.expr(const_expr);\n-                        if ret.is_some() {\n-                            self.needed_resolution = true;\n-                        }\n-                        return ret;\n+        let def = self.tables.qpath_def(qpath, id);\n+        match def {\n+            Def::Const(def_id) |\n+            Def::AssociatedConst(def_id) => {\n+                let substs = self.tables\n+                    .node_id_item_substs(id)\n+                    .unwrap_or_else(|| self.tcx.intern_substs(&[]));\n+                if let Some((const_expr, tables)) = lookup_const_by_id(self.tcx, def_id, substs) {\n+                    let mut cx = ConstEvalLateContext {\n+                        tcx: self.tcx,\n+                        tables,\n+                        needed_resolution: false,\n+                    };\n+                    let ret = cx.expr(const_expr);\n+                    if ret.is_some() {\n+                        self.needed_resolution = true;\n                     }\n-                },\n-                _ => {},\n-            }\n+                    return ret;\n+                }\n+            },\n+            _ => {},\n         }\n         None\n     }"}, {"sha": "33c27b53b835e8a905a6afa88875343a152891ea", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n                 let ty = self.cx.tables.node_id_to_type(callee.id);\n                 match ty.sty {\n                     ty::TyFnDef(_, _, ty) |\n-                    ty::TyFnPtr(ty) if ty.sig.skip_binder().output().sty == ty::TyNever => {\n+                    ty::TyFnPtr(ty) if ty.skip_binder().output().sty == ty::TyNever => {\n                         self.divergence += 1;\n                     },\n                     _ => (),"}, {"sha": "4032234ac5cb71607b5b273fed73eb66ccb7ab26", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                 if let Some(body_id) = variant.disr_expr {\n                     use rustc_const_eval::*;\n                     let constcx = ConstContext::new(cx.tcx, body_id);\n-                    let bad = match constcx.eval(&cx.tcx.hir.body(body_id).value, EvalHint::ExprTypeChecked) {\n+                    let bad = match constcx.eval(&cx.tcx.hir.body(body_id).value) {\n                         Ok(ConstVal::Integral(Usize(Us64(i)))) => i as u32 as u64 != i,\n                         Ok(ConstVal::Integral(Isize(Is64(i)))) => i as i32 as i64 != i,\n                         _ => false,"}, {"sha": "8230fe7313033bb839e05eed1229b1743d5bb184", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -66,7 +66,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 // Is it an unsafe function? They don't implement the closure traits\n                 ty::TyFnDef(_, _, fn_ty) |\n                 ty::TyFnPtr(fn_ty) => {\n-                    if fn_ty.unsafety == Unsafety::Unsafe || fn_ty.sig.skip_binder().output().sty == ty::TyNever {\n+                    if fn_ty.skip_binder().unsafety == Unsafety::Unsafe || fn_ty.skip_binder().output().sty == ty::TyNever {\n                         return;\n                     }\n                 },"}, {"sha": "f07ec7de52b2b7fff971813dc0ace5c1799bdfdf", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                 match self.cx.tables.expr_ty(func).sty {\n                     ty::TyFnDef(_, _, fn_ty) |\n                     ty::TyFnPtr(fn_ty) => {\n-                        if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty.sig).output().sty {\n+                        if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty).output().sty {\n                             self.report_diverging_sub_expr(e);\n                         }\n                     },"}, {"sha": "82db13b1025bbfe858fe648d9d52fc51bccbdec1", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::{span_lint, snippet, in_macro};\n-use rustc_const_math::ConstInt;\n+use syntax::attr::IntType::{SignedInt, UnsignedInt};\n \n /// **What it does:** Checks for identity operations, e.g. `x + 0`.\n ///\n@@ -60,11 +60,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n \n \n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if let Some(v @ Constant::Int(_)) = constant_simple(e) {\n+    if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n         if match m {\n-            0 => v == Constant::Int(ConstInt::Infer(0)),\n-            -1 => v == Constant::Int(ConstInt::InferSigned(-1)),\n-            1 => v == Constant::Int(ConstInt::Infer(1)),\n+            0 => v.to_u128_unchecked() == 0,\n+            -1 => match v.int_type() {\n+                SignedInt(_) => #[allow(cast_possible_wrap)] (v.to_u128_unchecked() as i128  == -1),\n+                UnsignedInt(_) =>  false\n+            },\n+            1 => v.to_u128_unchecked() == 1,\n             _ => unreachable!(),\n         } {\n             span_lint(cx,"}, {"sha": "bfd17d995c8dd8f2080b1531194da68e137b413b", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -2,10 +2,8 @@\n \n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{span_lint_and_then, snippet_opt};\n-use rustc::ty::layout::TargetDataLayout;\n+use utils::{span_lint_and_then, snippet_opt, type_size};\n use rustc::ty::TypeFoldable;\n-use rustc::traits::Reveal;\n \n /// **What it does:** Checks for large size differences between variants on `enum`s.\n ///\n@@ -55,28 +53,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n             let mut largest_variant: Option<(_, _)> = None;\n \n             for (i, variant) in adt.variants.iter().enumerate() {\n-                let data_layout = TargetDataLayout::parse(cx.sess());\n-                cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-                    let size: u64 = variant.fields\n-                        .iter()\n-                        .map(|f| {\n-                            let ty = cx.tcx.item_type(f.did);\n-                            if ty.needs_subst() {\n-                                0 // we can't reason about generics, so we treat them as zero sized\n-                            } else {\n-                                ty.layout(&infcx)\n-                                    .expect(\"layout should be computable for concrete type\")\n-                                    .size(&data_layout)\n-                                    .bytes()\n-                            }\n-                        })\n-                        .sum();\n+                let size: u64 = variant.fields\n+                    .iter()\n+                    .map(|f| {\n+                        let ty = cx.tcx.item_type(f.did);\n+                        if ty.needs_subst() {\n+                            0 // we can't reason about generics, so we treat them as zero sized\n+                        } else {\n+                            type_size(cx, ty).expect(\"size should be computable for concrete type\")\n+                        }\n+                    })\n+                    .sum();\n \n-                    let grouped = (size, (i, variant));\n+                let grouped = (size, (i, variant));\n \n-                    update_if(&mut smallest_variant, grouped, |a, b| b.0 <= a.0);\n-                    update_if(&mut largest_variant, grouped, |a, b| b.0 >= a.0);\n-                });\n+                update_if(&mut smallest_variant, grouped, |a, b| b.0 <= a.0);\n+                update_if(&mut largest_variant, grouped, |a, b| b.0 >= a.0);\n             }\n \n             if let (Some(smallest), Some(largest)) = (smallest_variant, largest_variant) {"}, {"sha": "03522cc02cd53b12260324e31b77df520291c181", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -186,7 +186,8 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n             if &*item.name.as_str() == \"is_empty\" {\n-                let ty = cx.tcx.item_type(item.def_id).fn_sig().skip_binder();\n+                let sig = cx.tcx.item_type(item.def_id).fn_sig();\n+                let ty = sig.skip_binder();\n                 ty.inputs().len() == 1\n             } else {\n                 false\n@@ -198,7 +199,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n-        cx.tcx.inherent_impls.borrow().get(&id).map_or(false, |impls| {\n+        cx.tcx.maps.inherent_impls.borrow().get(&id).map_or(false, |impls| {\n             impls.iter().any(|imp| cx.tcx.associated_items(*imp).any(|item| is_is_empty(cx, &item)))\n         })\n     }"}, {"sha": "1571372cefbd9dccd076cdebb936f21c7ac08e4a", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -257,7 +257,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                         }\n                     },\n                     Def::Trait(def_id) => {\n-                        let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n+                        let trait_def = self.cx.tcx.maps.trait_def.borrow()[&def_id];\n                         for _ in &self.cx.tcx.item_generics(trait_def.def_id).regions {\n                             self.record(&None);\n                         }"}, {"sha": "8c1f47a2187d4accfe2246a478ba9441216abefd", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -8,7 +8,6 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use std::collections::HashMap;\n use syntax::ast;\n@@ -596,8 +595,8 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(arg) {\n         // ...and both sides are compile-time constant integers...\n         let constcx = ConstContext::with_tables(cx.tcx, cx.tables);\n-        if let Ok(start_idx) = constcx.eval(start, ExprTypeChecked) {\n-            if let Ok(end_idx) = constcx.eval(end, ExprTypeChecked) {\n+        if let Ok(start_idx) = constcx.eval(start) {\n+            if let Ok(end_idx) = constcx.eval(end) {\n                 // ...and the start index is greater than the end index,\n                 // this loop will never run. This is often confusing for developers\n                 // who think that this will iterate from the larger value to the"}, {"sha": "4df2052cdced60846b1bb52020a7469805391868", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -2,7 +2,6 @@ use rustc::hir::*;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstInt;\n use std::cmp::Ordering;\n@@ -415,7 +414,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n }\n \n /// Get all arms that are unbounded `PatRange`s.\n-fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n+fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &[Arm]) -> Vec<SpannedRange<ConstVal<'tcx>>> {\n     let constcx = ConstContext::with_tables(cx.tcx, cx.tables);\n     arms.iter()\n         .flat_map(|arm| {\n@@ -427,8 +426,8 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n                 .filter_map(|pat| {\n                     if_let_chain! {[\n                     let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node,\n-                    let Ok(lhs) = constcx.eval(lhs, ExprTypeChecked),\n-                    let Ok(rhs) = constcx.eval(rhs, ExprTypeChecked)\n+                    let Ok(lhs) = constcx.eval(lhs),\n+                    let Ok(rhs) = constcx.eval(rhs)\n                 ], {\n                     let rhs = match *range_end {\n                         RangeEnd::Included => Bound::Included(rhs),\n@@ -439,7 +438,7 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n \n                     if_let_chain! {[\n                     let PatKind::Lit(ref value) = pat.node,\n-                    let Ok(value) = constcx.eval(value, ExprTypeChecked)\n+                    let Ok(value) = constcx.eval(value)\n                 ], {\n                     return Some(SpannedRange { span: pat.span, node: (value.clone(), Bound::Included(value)) });\n                 }}"}, {"sha": "b43a2473f0df6dfbf18c68344cce5d8dda04337f", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n                     let forgot_ty = cx.tables.expr_ty(&args[0]);\n \n                     if match forgot_ty.ty_adt_def() {\n-                        Some(def) => def.has_dtor(),\n+                        Some(def) => def.has_dtor(cx.tcx),\n                         _ => false,\n                     } {\n                         span_lint(cx, MEM_FORGET, e.span, \"usage of mem::forget on Drop type\");"}, {"sha": "b7416630963bd74ff0cb0f9cf5c4f3b21b4d2e06", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -3,7 +3,6 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n use rustc::hir::def::Def;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n use std::fmt;\n@@ -1240,7 +1239,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n-    if let Ok(ConstVal::Str(r)) = ConstContext::with_tables(cx.tcx, cx.tables).eval(arg, ExprTypeChecked) {\n+    if let Ok(ConstVal::Str(r)) = ConstContext::with_tables(cx.tcx, cx.tables).eval(arg) {\n         if r.len() == 1 {\n             let hint = snippet(cx, expr.span, \"..\").replace(&format!(\"\\\"{}\\\"\", r), &format!(\"'{}'\", r));\n             span_lint_and_then(cx,"}, {"sha": "2c6553e90c93de2ad8b73bef87a1366e4debc425", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -65,9 +65,9 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n             let def_id = cx.tables.qpath_def(qpath, path.id).def_id();\n \n             if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n-                fetch_const(args, MinMax::Min)\n+                fetch_const(cx, args, MinMax::Min)\n             } else if match_def_path(cx.tcx, def_id, &paths::CMP_MAX) {\n-                fetch_const(args, MinMax::Max)\n+                fetch_const(cx, args, MinMax::Max)\n             } else {\n                 None\n             }\n@@ -79,18 +79,18 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n     }\n }\n \n-fn fetch_const(args: &[Expr], m: MinMax) -> Option<(MinMax, Constant, &Expr)> {\n+fn fetch_const<'a>(cx: &LateContext, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n     if args.len() != 2 {\n         return None;\n     }\n-    if let Some(c) = constant_simple(&args[0]) {\n-        if constant_simple(&args[1]).is_none() {\n+    if let Some(c) = constant_simple(cx, &args[0]) {\n+        if constant_simple(cx, &args[1]).is_none() {\n             // otherwise ignore\n             Some((m, c, &args[1]))\n         } else {\n             None\n         }\n-    } else if let Some(c) = constant_simple(&args[1]) {\n+    } else if let Some(c) = constant_simple(cx, &args[1]) {\n         Some((m, c, &args[0]))\n     } else {\n         None"}, {"sha": "3fb9101076dac9ad1fd29550639261db9f5501fd", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -4,7 +4,6 @@ use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n@@ -360,27 +359,31 @@ fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n }\n \n fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n-    let res = ConstContext::with_tables(cx.tcx, cx.tables).eval(expr, ExprTypeChecked);\n+    let res = ConstContext::with_tables(cx.tcx, cx.tables).eval(expr);\n     if let Ok(ConstVal::Float(val)) = res {\n         use std::cmp::Ordering;\n+        match val {\n+            val @ ConstFloat::F32(_) => {\n+                let zero = ConstFloat::F32(0.0);\n \n-        let zero = ConstFloat::FInfer {\n-            f32: 0.0,\n-            f64: 0.0,\n-        };\n+                let infinity = ConstFloat::F32(::std::f32::INFINITY);\n \n-        let infinity = ConstFloat::FInfer {\n-            f32: ::std::f32::INFINITY,\n-            f64: ::std::f64::INFINITY,\n-        };\n+                let neg_infinity = ConstFloat::F32(::std::f32::NEG_INFINITY);\n \n-        let neg_infinity = ConstFloat::FInfer {\n-            f32: ::std::f32::NEG_INFINITY,\n-            f64: ::std::f64::NEG_INFINITY,\n-        };\n+                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n+                val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+            },\n+            val @ ConstFloat::F64(_) => {\n+                let zero = ConstFloat::F64(0.0);\n \n-        val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n-        val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+                let infinity = ConstFloat::F64(::std::f64::INFINITY);\n+\n+                let neg_infinity = ConstFloat::F64(::std::f64::NEG_INFINITY);\n+\n+                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n+                val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+            }\n+        }\n     } else {\n         false\n     }"}, {"sha": "07c941ecee6b1270d427e7a0635e0c05ed5cc7f1", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -62,7 +62,7 @@ fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS,\n     match type_definition.sty {\n         TypeVariants::TyFnDef(_, _, fn_type) |\n         TypeVariants::TyFnPtr(fn_type) => {\n-            let parameters = fn_type.sig.skip_binder().inputs();\n+            let parameters = fn_type.skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n                     TypeVariants::TyRef(_, TypeAndMut { mutbl: MutImmutable, .. }) |"}, {"sha": "d7e7a0bdb476fe72616904b8f69e8f246e547166", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -85,7 +85,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, node_id);\n         let fn_sig = cx.tcx.item_type(fn_def_id).fn_sig();\n-        let fn_sig = cx.tcx.liberate_late_bound_regions(param_env.free_id_outlive, fn_sig);\n+        let fn_sig = cx.tcx.liberate_late_bound_regions(param_env.free_id_outlive, &fn_sig);\n \n         for ((input, ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n "}, {"sha": "d7437f34cff393bfbb48285032273ee9590ab498", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n     if_let_chain!([\n         let ExprLit(ref l) = lit.node,\n-        let Constant::Int(ref ci) = consts::lit_to_constant(&l.node),\n+        let Constant::Int(ref ci) = consts::lit_to_constant(&l.node, cx.tcx, cx.tables.expr_ty(lit)),\n         let Some(val) = ci.to_u64(),\n         val == 1,\n         cx.tables.expr_ty(exp).is_integral()"}, {"sha": "279996bfabe77240c8816217097e1f6a07229f1c", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -113,7 +113,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n \n fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_id);\n-    let fn_ty = cx.tcx.item_type(fn_def_id).fn_sig().skip_binder();\n+    let sig = cx.tcx.item_type(fn_def_id).fn_sig();\n+    let fn_ty = sig.skip_binder();\n \n     for (arg, ty) in decl.inputs.iter().zip(fn_ty.inputs()) {\n         if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {"}, {"sha": "6f22c3cfc7f65adc99b54904b1000c90c712f730", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -2,7 +2,6 @@ use regex_syntax;\n use rustc::hir::*;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use std::collections::HashSet;\n use std::error::Error;\n@@ -151,7 +150,7 @@ fn str_span(base: Span, s: &str, c: usize) -> Span {\n }\n \n fn const_str(cx: &LateContext, e: &Expr) -> Option<InternedString> {\n-    match ConstContext::with_tables(cx.tcx, cx.tables).eval(e, ExprTypeChecked) {\n+    match ConstContext::with_tables(cx.tcx, cx.tables).eval(e) {\n         Ok(ConstVal::Str(r)) => Some(r),\n         _ => None,\n     }"}, {"sha": "c93ba00218ab6669d3ece540c9759315e93056e0", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -5,9 +5,10 @@ use rustc::lint::*;\n use rustc::ty;\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n+use syntax::attr::IntType;\n use syntax::codemap::Span;\n use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint,\n-            opt_def_id, last_path_segment};\n+            opt_def_id, last_path_segment, type_size};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -907,7 +908,6 @@ fn detect_absurd_comparison<'a>(\n fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeExpr<'a>> {\n     use rustc::middle::const_val::ConstVal::*;\n     use rustc_const_math::*;\n-    use rustc_const_eval::EvalHint::ExprTypeChecked;\n     use rustc_const_eval::*;\n     use types::ExtremeType::*;\n \n@@ -918,7 +918,7 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n         _ => return None,\n     };\n \n-    let cv = match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr, ExprTypeChecked) {\n+    let cv = match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr) {\n         Ok(val) => val,\n         Err(_) => return None,\n     };\n@@ -1077,7 +1077,13 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     use std::*;\n \n     if let ExprCast(ref cast_exp, _) = expr.node {\n-        match cx.tables.expr_ty(cast_exp).sty {\n+        let pre_cast_ty = cx.tables.expr_ty(cast_exp);\n+        let cast_ty = cx.tables.expr_ty(expr);\n+        // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n+        if type_size(cx, pre_cast_ty) == type_size(cx, cast_ty) {\n+            return None;\n+        }\n+        match pre_cast_ty.sty {\n             TyInt(int_ty) => {\n                 Some(match int_ty {\n                     IntTy::I8 => (FullInt::S(i8::min_value() as i128), FullInt::S(i8::max_value() as i128)),\n@@ -1107,18 +1113,15 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n \n fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n     use rustc::middle::const_val::ConstVal::*;\n-    use rustc_const_eval::EvalHint::ExprTypeChecked;\n     use rustc_const_eval::ConstContext;\n-    use rustc_const_math::ConstInt;\n \n-    match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr, ExprTypeChecked) {\n+    match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr) {\n         Ok(val) => {\n             if let Integral(const_int) = val {\n-                Some(match const_int.erase_type() {\n-                    ConstInt::InferSigned(x) => FullInt::S(x as i128),\n-                    ConstInt::Infer(x) => FullInt::U(x as u128),\n-                    _ => unreachable!(),\n-                })\n+                match const_int.int_type() {\n+                    IntType::SignedInt(_) => #[allow(cast_possible_wrap)] Some(FullInt::S(const_int.to_u128_unchecked() as i128)),\n+                    IntType::UnsignedInt(_) => Some(FullInt::U(const_int.to_u128_unchecked())),\n+                }\n             } else {\n                 None\n             }"}, {"sha": "18864d42df2abc301bbe216fd9e151cc7b0ca3cb", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -9,6 +9,7 @@ use rustc::traits::Reveal;\n use rustc::traits;\n use rustc::ty::subst::Subst;\n use rustc::ty;\n+use rustc::ty::layout::TargetDataLayout;\n use rustc_errors;\n use std::borrow::Cow;\n use std::env;\n@@ -781,7 +782,7 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::T\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_item);\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_item);\n     let fn_sig = cx.tcx.item_type(fn_def_id).fn_sig();\n-    let fn_sig = cx.tcx.liberate_late_bound_regions(parameter_env.free_id_outlive, fn_sig);\n+    let fn_sig = cx.tcx.liberate_late_bound_regions(parameter_env.free_id_outlive, &fn_sig);\n     fn_sig.output()\n }\n \n@@ -806,7 +807,7 @@ pub fn same_tys<'a, 'tcx>(\n pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n     match ty.sty {\n         ty::TyFnDef(_, _, f) |\n-        ty::TyFnPtr(f) => f.unsafety == Unsafety::Unsafe,\n+        ty::TyFnPtr(f) => f.unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n }\n@@ -972,3 +973,9 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n \n     None\n }\n+\n+pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Option<u64> {\n+    cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx|\n+        ty.layout(&infcx).ok().map(|lay| lay.size(&TargetDataLayout::parse(cx.sess())).bytes())\n+    )\n+}"}, {"sha": "3b9e38cb66bf113e139ff55d6a9f496e85eda12f", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -1,7 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use syntax::codemap::Span;\n use utils::{higher, is_copy, snippet, span_lint_and_then};\n@@ -60,7 +59,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n-            if ConstContext::with_tables(cx.tcx, cx.tables).eval(len, ExprTypeChecked).is_ok() {\n+            if ConstContext::with_tables(cx.tcx, cx.tables).eval(len).is_ok() {\n                 format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n             } else {\n                 return;"}, {"sha": "eb298f9bc7b3211d221b72420ec4c2a258ffa97d", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -36,8 +36,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-            let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(left),\n-            let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(right),\n+            let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(cx, left),\n+            let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(cx, right),\n             let Ok(0.0) = lhs_value.parse(),\n             let Ok(0.0) = rhs_value.parse()\n         ], {"}, {"sha": "d4a4ef8a3a81255cc239ef72a30e6dc266089d50", "filename": "tests/consts.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a39b5f95b83efdb8202956b0f4514b6459046be5/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a39b5f95b83efdb8202956b0f4514b6459046be5/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=a39b5f95b83efdb8202956b0f4514b6459046be5", "patch": "@@ -1,99 +0,0 @@\n-#![feature(rustc_private)]\n-\n-extern crate clippy_lints;\n-extern crate rustc;\n-extern crate rustc_const_eval;\n-extern crate rustc_const_math;\n-extern crate syntax;\n-\n-use clippy_lints::consts::{constant_simple, Constant, FloatWidth};\n-use rustc_const_math::ConstInt;\n-use rustc::hir::*;\n-use syntax::ast::{LitIntType, LitKind, NodeId, StrStyle};\n-use syntax::codemap::{Spanned, COMMAND_LINE_SP};\n-use syntax::symbol::Symbol;\n-use syntax::ptr::P;\n-use syntax::util::ThinVec;\n-\n-fn spanned<T>(t: T) -> Spanned<T> {\n-    Spanned {\n-        node: t,\n-        span: COMMAND_LINE_SP,\n-    }\n-}\n-\n-fn expr(n: Expr_) -> Expr {\n-    Expr {\n-        id: NodeId::new(1),\n-        node: n,\n-        span: COMMAND_LINE_SP,\n-        attrs: ThinVec::new(),\n-    }\n-}\n-\n-fn lit(l: LitKind) -> Expr {\n-    expr(ExprLit(P(spanned(l))))\n-}\n-\n-fn binop(op: BinOp_, l: Expr, r: Expr) -> Expr {\n-    expr(ExprBinary(spanned(op), P(l), P(r)))\n-}\n-\n-fn check(expect: Constant, expr: &Expr) {\n-    assert_eq!(Some(expect), constant_simple(expr))\n-}\n-\n-const TRUE: Constant = Constant::Bool(true);\n-const FALSE: Constant = Constant::Bool(false);\n-const ZERO: Constant = Constant::Int(ConstInt::Infer(0));\n-const ONE: Constant = Constant::Int(ConstInt::Infer(1));\n-const TWO: Constant = Constant::Int(ConstInt::Infer(2));\n-\n-#[test]\n-fn test_lit() {\n-    check(TRUE, &lit(LitKind::Bool(true)));\n-    check(FALSE, &lit(LitKind::Bool(false)));\n-    check(ZERO, &lit(LitKind::Int(0, LitIntType::Unsuffixed)));\n-    check(Constant::Str(\"cool!\".into(), StrStyle::Cooked),\n-          &lit(LitKind::Str(Symbol::intern(\"cool!\"), StrStyle::Cooked)));\n-}\n-\n-#[test]\n-fn test_ops() {\n-    check(TRUE, &binop(BiOr, lit(LitKind::Bool(false)), lit(LitKind::Bool(true))));\n-    check(FALSE, &binop(BiAnd, lit(LitKind::Bool(false)), lit(LitKind::Bool(true))));\n-\n-    let litzero = lit(LitKind::Int(0, LitIntType::Unsuffixed));\n-    let litone = lit(LitKind::Int(1, LitIntType::Unsuffixed));\n-    check(TRUE, &binop(BiEq, litzero.clone(), litzero.clone()));\n-    check(TRUE, &binop(BiGe, litzero.clone(), litzero.clone()));\n-    check(TRUE, &binop(BiLe, litzero.clone(), litzero.clone()));\n-    check(FALSE, &binop(BiNe, litzero.clone(), litzero.clone()));\n-    check(FALSE, &binop(BiGt, litzero.clone(), litzero.clone()));\n-    check(FALSE, &binop(BiLt, litzero.clone(), litzero.clone()));\n-\n-    check(ZERO, &binop(BiAdd, litzero.clone(), litzero.clone()));\n-    check(TWO, &binop(BiAdd, litone.clone(), litone.clone()));\n-    check(ONE, &binop(BiSub, litone.clone(), litzero.clone()));\n-    check(ONE, &binop(BiMul, litone.clone(), litone.clone()));\n-    check(ONE, &binop(BiDiv, litone.clone(), litone.clone()));\n-\n-    let half_any = Constant::Float(\"0.5\".into(), FloatWidth::Any);\n-    let half32 = Constant::Float(\"0.5\".into(), FloatWidth::F32);\n-    let half64 = Constant::Float(\"0.5\".into(), FloatWidth::F64);\n-    let pos_zero = Constant::Float(\"0.0\".into(), FloatWidth::F64);\n-    let neg_zero = Constant::Float(\"-0.0\".into(), FloatWidth::F64);\n-\n-    assert_eq!(pos_zero, pos_zero);\n-    assert_eq!(neg_zero, neg_zero);\n-    assert_eq!(None, pos_zero.partial_cmp(&neg_zero));\n-\n-    assert_eq!(half_any, half32);\n-    assert_eq!(half_any, half64);\n-    // for transitivity\n-    assert_eq!(half32, half64);\n-\n-    assert_eq!(Constant::Int(ConstInt::Infer(0)), Constant::Int(ConstInt::U8(0)));\n-    assert_eq!(Constant::Int(ConstInt::Infer(0)), Constant::Int(ConstInt::I8(0)));\n-    assert_eq!(Constant::Int(ConstInt::InferSigned(-1)), Constant::Int(ConstInt::I8(-1)));\n-}"}, {"sha": "c59f04d4f381ca9ef4efcddd855db67ea747de0f", "filename": "tests/ui/invalid_upcast_comparisons.rs", "status": "modified", "additions": 68, "deletions": 22, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/tests%2Fui%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/tests%2Fui%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finvalid_upcast_comparisons.rs?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -3,33 +3,79 @@\n \n #![deny(invalid_upcast_comparisons)]\n #![allow(unused, eq_op, no_effect, unnecessary_operation)]\n-fn main() {\n-    let zero: u32 = 0;\n-    let u8_max: u8 = 255;\n \n-    (u8_max as u32) > 300;\n-    (u8_max as u32) > 20;\n+fn mk_value<T>() -> T { unimplemented!() }\n+\n+fn main() {\n+    let u32: u32 = mk_value();\n+    let u8: u8 = mk_value();\n+    let i32: i32 = mk_value();\n+    let i8: i8 = mk_value();\n \n-    (zero as i32) < -5;\n-    (zero as i32) < 10;\n+    // always false, since no u8 can be > 300\n+    (u8 as u32) > 300;\n+    (u8 as i32) > 300;\n+    (u8 as u32) == 300;\n+    (u8 as i32) == 300;\n+    300 < (u8 as u32);\n+    300 < (u8 as i32);\n+    300 == (u8 as u32);\n+    300 == (u8 as i32);\n+    // inverted of the above\n+    (u8 as u32) <= 300;\n+    (u8 as i32) <= 300;\n+    (u8 as u32) != 300;\n+    (u8 as i32) != 300;\n+    300 >= (u8 as u32);\n+    300 >= (u8 as i32);\n+    300 != (u8 as u32);\n+    300 != (u8 as i32);\n \n-    -5 < (zero as i32);\n-    0 <= (zero as i32);\n-    0 < (zero as i32);\n+    // always false, since u8 -> i32 doesn't wrap\n+    (u8 as i32) < 0;\n+    -5 != (u8 as i32);\n+    // inverted of the above\n+    (u8 as i32) >= 0;\n+    -5 == (u8 as i32);\n \n-    -5 > (zero as i32);\n-    -5 >= (u8_max as i32);\n-    1337 == (u8_max as i32);\n+    // always false, since no u8 can be 1337\n+    1337 == (u8 as i32);\n+    1337 == (u8 as u32);\n+    // inverted of the above\n+    1337 != (u8 as i32);\n+    1337 != (u8 as u32);\n \n-    -5 == (zero as i32);\n-    -5 != (u8_max as i32);\n \n     // Those are Ok:\n-    42 == (u8_max as i32);\n-    42 != (u8_max as i32);\n-    42 > (u8_max as i32);\n-    (u8_max as i32) == 42;\n-    (u8_max as i32) != 42;\n-    (u8_max as i32) > 42;\n-    (u8_max as i32) < 42;\n+    (u8 as u32) > 20;\n+    42 == (u8 as i32);\n+    42 != (u8 as i32);\n+    42 > (u8 as i32);\n+    (u8 as i32) == 42;\n+    (u8 as i32) != 42;\n+    (u8 as i32) > 42;\n+    (u8 as i32) < 42;\n+\n+    (u8 as i8) == -1;\n+    (u8 as i8) != -1;\n+    (u8 as i32) > -1;\n+    (u8 as i32) < -1;\n+    (u32 as i32) < -5;\n+    (u32 as i32) < 10;\n+\n+    (i8 as u8) == 1;\n+    (i8 as u8) != 1;\n+    (i8 as u8) < 1;\n+    (i8 as u8) > 1;\n+    (i32 as u32) < 5;\n+    (i32 as u32) < 10;\n+\n+    -5 < (u32 as i32);\n+    0 <= (u32 as i32);\n+    0 < (u32 as i32);\n+\n+    -5 > (u32 as i32);\n+    -5 >= (u8 as i32);\n+\n+    -5 == (u32 as i32);\n }"}, {"sha": "874081c22abea2cebe2b72e7073f7e576755ddf4", "filename": "tests/ui/invalid_upcast_comparisons.stderr", "status": "modified", "additions": 139, "deletions": 31, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/3ebc12d25f146291e0e5c0630eea6098f417420d/tests%2Fui%2Finvalid_upcast_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ebc12d25f146291e0e5c0630eea6098f417420d/tests%2Fui%2Finvalid_upcast_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finvalid_upcast_comparisons.stderr?ref=3ebc12d25f146291e0e5c0630eea6098f417420d", "patch": "@@ -1,62 +1,170 @@\n-error: because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n-  --> $DIR/invalid_upcast_comparisons.rs:10:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:16:5\n    |\n-10 |     (u8_max as u32) > 300;\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+16 |     (u8 as u32) > 300;\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/invalid_upcast_comparisons.rs:4:9\n    |\n 4  | #![deny(invalid_upcast_comparisons)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always false\n-  --> $DIR/invalid_upcast_comparisons.rs:13:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:17:5\n    |\n-13 |     (zero as i32) < -5;\n-   |     ^^^^^^^^^^^^^^^^^^\n+17 |     (u8 as i32) > 300;\n+   |     ^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always true\n-  --> $DIR/invalid_upcast_comparisons.rs:16:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:18:5\n    |\n-16 |     -5 < (zero as i32);\n+18 |     (u8 as u32) == 300;\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always true\n-  --> $DIR/invalid_upcast_comparisons.rs:17:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:19:5\n    |\n-17 |     0 <= (zero as i32);\n+19 |     (u8 as i32) == 300;\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always false\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n   --> $DIR/invalid_upcast_comparisons.rs:20:5\n    |\n-20 |     -5 > (zero as i32);\n-   |     ^^^^^^^^^^^^^^^^^^\n+20 |     300 < (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n   --> $DIR/invalid_upcast_comparisons.rs:21:5\n    |\n-21 |     -5 >= (u8_max as i32);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+21 |     300 < (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n   --> $DIR/invalid_upcast_comparisons.rs:22:5\n    |\n-22 |     1337 == (u8_max as i32);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+22 |     300 == (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always false\n-  --> $DIR/invalid_upcast_comparisons.rs:24:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:23:5\n    |\n-24 |     -5 == (zero as i32);\n-   |     ^^^^^^^^^^^^^^^^^^^\n+23 |     300 == (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `u8_max` prior to casting, this expression is always true\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n   --> $DIR/invalid_upcast_comparisons.rs:25:5\n    |\n-25 |     -5 != (u8_max as i32);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+25 |     (u8 as u32) <= 300;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:26:5\n+   |\n+26 |     (u8 as i32) <= 300;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:27:5\n+   |\n+27 |     (u8 as u32) != 300;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:28:5\n+   |\n+28 |     (u8 as i32) != 300;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:29:5\n+   |\n+29 |     300 >= (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:30:5\n+   |\n+30 |     300 >= (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:31:5\n+   |\n+31 |     300 != (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:32:5\n+   |\n+32 |     300 != (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:35:5\n+   |\n+35 |     (u8 as i32) < 0;\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:36:5\n+   |\n+36 |     -5 != (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:38:5\n+   |\n+38 |     (u8 as i32) >= 0;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:39:5\n+   |\n+39 |     -5 == (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:42:5\n+   |\n+42 |     1337 == (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:43:5\n+   |\n+43 |     1337 == (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:45:5\n+   |\n+45 |     1337 != (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:46:5\n+   |\n+46 |     1337 != (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:61:5\n+   |\n+61 |     (u8 as i32) > -1;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:62:5\n+   |\n+62 |     (u8 as i32) < -1;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:78:5\n+   |\n+78 |     -5 >= (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 27 previous errors\n "}]}