{"sha": "77beffc889effe6f77248568a684d8b942610c85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3YmVmZmM4ODllZmZlNmY3NzI0ODU2OGE2ODRkOGI5NDI2MTBjODU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-15T19:29:45Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-15T19:29:45Z"}, "message": "Add some form-judgements on plvals and pexps.", "tree": {"sha": "602f5cb8d782d1e4939ec04cfb01c3b56d74f648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/602f5cb8d782d1e4939ec04cfb01c3b56d74f648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77beffc889effe6f77248568a684d8b942610c85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77beffc889effe6f77248568a684d8b942610c85", "html_url": "https://github.com/rust-lang/rust/commit/77beffc889effe6f77248568a684d8b942610c85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77beffc889effe6f77248568a684d8b942610c85/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c61d021f6d97c101ff9d201e5bf8e78eda8c8a1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c61d021f6d97c101ff9d201e5bf8e78eda8c8a1b", "html_url": "https://github.com/rust-lang/rust/commit/c61d021f6d97c101ff9d201e5bf8e78eda8c8a1b"}], "stats": {"total": 179, "additions": 169, "deletions": 10}, "files": [{"sha": "c0d983574027cd0b7de8655069dc9cbb391c2777", "filename": "src/boot/fe/ast.ml", "status": "modified", "additions": 86, "deletions": 10, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/77beffc889effe6f77248568a684d8b942610c85/src%2Fboot%2Ffe%2Fast.ml", "raw_url": "https://github.com/rust-lang/rust/raw/77beffc889effe6f77248568a684d8b942610c85/src%2Fboot%2Ffe%2Fast.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fast.ml?ref=77beffc889effe6f77248568a684d8b942610c85", "patch": "@@ -114,22 +114,22 @@ and ty_tag = { tag_id: opaque_id;\n (* In closed type terms a constraint may refer to components of the term by\n  * anchoring off the \"formal symbol\" '*', which represents \"the term this\n  * constraint is attached to\".\n- * \n- * \n+ *\n+ *\n  * For example, if I have a tuple type tup(int,int), I may wish to enforce the\n  * lt predicate on it; I can write this as a constrained type term like:\n- * \n+ *\n  * tup(int,int) : lt( *._0, *._1 )\n- * \n+ *\n  * In fact all tuple types are converted to this form for purpose of\n  * type-compatibility testing; the argument tuple in a function\n- * \n+ *\n  * fn (int x, int y) : lt(x, y) -> int\n- * \n+ *\n  * desugars to\n- * \n+ *\n  * fn (tup(int, int) : lt( *._1, *._2 )) -> int\n- * \n+ *\n  *)\n \n and carg_base =\n@@ -353,7 +353,7 @@ and plval =\n   | PLVAL_ext_pexp of (pexp * pexp)\n   | PLVAL_ext_deref of pexp\n \n-and pexp = pexp' Common.identified\n+and pexp = pexp' identified\n \n and lit =\n   | LIT_nil\n@@ -481,6 +481,9 @@ and crate' =\n and crate = crate' identified\n ;;\n \n+\n+(* Utility values and functions. *)\n+\n let empty_crate' =\n   { crate_items = ({ view_imports = Hashtbl.create 0;\n                      view_exports = Hashtbl.create 0 },\n@@ -511,9 +514,82 @@ let sane_name (n:name) : bool =\n       | NAME_ext (prefix, _) -> sane_prefix prefix\n ;;\n \n+(*\n+ * We have multiple subset-categories of expression:\n+ *\n+ *   - Atomic expressions are just atomic-lvals and literals.\n+ *\n+ *   - Primitive expressions are 1-level, machine-level operations on atomic\n+ *     expressions (so: 1-level binops and unops on atomics)\n+ *   - Constant expressions are those that can be evaluated at compile time,\n+ *     without calling user code or accessing the communication subsystem. So\n+ *     all expressions aside from call, port, chan or spawn, applied to all\n+ *     lvals that are themselves constant.\n+\n+ *\n+ * We similarly have multiple subset-categories of lval:\n+ *\n+ *   - Name lvals are those that contain no dynamic indices.\n+ *\n+ *   - Atomic lvals are those indexed by atomic expressions.\n+ *\n+ *   - Constant lvals are those that are only indexed by constant expressions.\n+ *\n+ * Rationales:\n+ *\n+ *   - The primitives are those that can be evaluated without adjusting\n+ *     reference counts or otherwise perturbing the lifecycle of anything\n+ *     dynamically allocated.\n+ *\n+ *   - The atomics exist to define the sub-structure of the primitives.\n+ *\n+ *   - The constants are those we'll compile to read-only memory, either\n+ *     immediates in the code-stream or frags in the .rodata section.\n+ *\n+ * Note:\n+ *\n+ *   - Constant-expression-ness is defined in semant, and can only be judged\n+ *     after resolve has run and connected idents with bindings.\n+ *)\n+\n+let rec plval_is_atomic (plval:plval) : bool =\n+  match plval with\n+      PLVAL_ident _\n+    | PLVAL_app _ -> true\n+\n+    | PLVAL_ext_name (p, _) ->\n+        pexp_is_atomic p\n+\n+    | PLVAL_ext_pexp (a, b) ->\n+        (pexp_is_atomic a) &&\n+          (pexp_is_atomic b)\n+\n+    | PLVAL_ext_deref p ->\n+        pexp_is_atomic p\n+\n+and pexp_is_atomic (pexp:pexp) : bool =\n+  match pexp.node with\n+      PEXP_lval pl -> plval_is_atomic pl\n+    | PEXP_lit _ -> true\n+    | _ -> false\n+;;\n+\n+\n+let pexp_is_primitive (pexp:pexp) : bool =\n+  match pexp.node with\n+      PEXP_binop (_, a, b) ->\n+        (pexp_is_atomic a) &&\n+          (pexp_is_atomic b)\n+    | PEXP_unop (_, p) ->\n+        pexp_is_atomic p\n+    | PEXP_lval pl ->\n+        plval_is_atomic pl\n+    | PEXP_lit _ -> true\n+    | _ -> false\n+;;\n \n-(***********************************************************************)\n \n+(* Pretty-printing. *)\n \n let fmt_ident (ff:Format.formatter) (i:ident) : unit =\n   fmt ff  \"%s\" i"}, {"sha": "0957621950f0bddc0bcb3a48e85704112d766994", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/77beffc889effe6f77248568a684d8b942610c85/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/77beffc889effe6f77248568a684d8b942610c85/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=77beffc889effe6f77248568a684d8b942610c85", "patch": "@@ -98,6 +98,7 @@ type ctxt =\n       ctxt_slot_keys: (node_id,Ast.slot_key) Hashtbl.t;\n       ctxt_node_referenced: (node_id, unit) Hashtbl.t;\n       ctxt_auto_deref_lval: (node_id, bool) Hashtbl.t;\n+      ctxt_plval_const: (node_id,bool) Hashtbl.t;\n       ctxt_all_item_names: (node_id,Ast.name) Hashtbl.t;\n       ctxt_all_item_types: (node_id,Ast.ty) Hashtbl.t;\n       ctxt_all_lval_types: (node_id,Ast.ty) Hashtbl.t;\n@@ -185,6 +186,7 @@ let new_ctxt sess abi crate =\n     ctxt_slot_keys = Hashtbl.create 0;\n     ctxt_node_referenced = Hashtbl.create 0;\n     ctxt_auto_deref_lval = Hashtbl.create 0;\n+    ctxt_plval_const = Hashtbl.create 0;\n     ctxt_all_item_names = Hashtbl.create 0;\n     ctxt_all_item_types = Hashtbl.create 0;\n     ctxt_all_lval_types = Hashtbl.create 0;\n@@ -1340,6 +1342,87 @@ let expr_type (cx:ctxt) (e:Ast.expr) : Ast.ty =\n     | Ast.EXPR_atom a -> atom_type cx a\n ;;\n \n+\n+let rec pexp_is_const (cx:ctxt) (pexp:Ast.pexp) : bool =\n+  let check_opt po =\n+    match po with\n+        None -> true\n+      | Some x -> pexp_is_const cx x\n+  in\n+\n+  let check_mut_pexp mut p =\n+    mut = Ast.MUT_immutable && pexp_is_const cx p\n+  in\n+\n+    match pexp.node with\n+        Ast.PEXP_call _\n+      | Ast.PEXP_spawn _\n+      | Ast.PEXP_port\n+      | Ast.PEXP_chan _\n+      | Ast.PEXP_custom _ -> false\n+\n+      | Ast.PEXP_bind (fn, args) ->\n+          (pexp_is_const cx fn) &&\n+            (arr_for_all\n+               (fun _ a -> check_opt a)\n+               args)\n+\n+      | Ast.PEXP_rec (elts, base) ->\n+          (check_opt base) &&\n+            (arr_for_all\n+               (fun _ (_, mut, p) ->\n+                  check_mut_pexp mut p)\n+               elts)\n+\n+      | Ast.PEXP_tup elts ->\n+          arr_for_all\n+            (fun _ (mut, p) ->\n+               check_mut_pexp mut p)\n+            elts\n+\n+      | Ast.PEXP_vec (mut, elts) ->\n+          (arr_for_all\n+             (fun _ p ->\n+                check_mut_pexp mut p)\n+             elts)\n+\n+      | Ast.PEXP_binop (_, a, b)\n+      | Ast.PEXP_lazy_and (a, b)\n+      | Ast.PEXP_lazy_or (a, b) ->\n+          (pexp_is_const cx a) &&\n+            (pexp_is_const cx b)\n+\n+      | Ast.PEXP_unop (_, p) -> pexp_is_const cx p\n+      | Ast.PEXP_lval p ->\n+          begin\n+            match htab_search cx.ctxt_plval_const pexp.id with\n+                None -> plval_is_const cx p\n+              | Some b -> b\n+          end\n+\n+      | Ast.PEXP_lit _\n+      | Ast.PEXP_str _ -> true\n+\n+      | Ast.PEXP_box (mut, p) ->\n+          check_mut_pexp mut p\n+\n+and plval_is_const (cx:ctxt) (plval:Ast.plval) : bool =\n+  match plval with\n+    Ast.PLVAL_ident _\n+  | Ast.PLVAL_app _ ->\n+      bug () \"Semant.plval_is_const on plval base\"\n+\n+  | Ast.PLVAL_ext_name (pexp, _) ->\n+      pexp_is_const cx pexp\n+\n+  | Ast.PLVAL_ext_pexp (a, b) ->\n+      (pexp_is_const cx a) &&\n+        (pexp_is_const cx b)\n+\n+  | Ast.PLVAL_ext_deref p ->\n+      pexp_is_const cx p\n+;;\n+\n (* Mappings between mod items and their respective types. *)\n \n let arg_slots (slots:Ast.header_slots) : Ast.slot array ="}]}