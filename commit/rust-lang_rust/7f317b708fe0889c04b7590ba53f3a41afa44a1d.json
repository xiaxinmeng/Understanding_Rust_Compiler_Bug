{"sha": "7f317b708fe0889c04b7590ba53f3a41afa44a1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMzE3YjcwOGZlMDg4OWMwNGI3NTkwYmE1M2YzYTQxYWZhNDRhMWQ=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-05-16T23:18:43Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-05-16T23:18:43Z"}, "message": "Run fmt", "tree": {"sha": "3d14f3ce930f0cf0a39a7c959adef476b93c9a08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d14f3ce930f0cf0a39a7c959adef476b93c9a08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f317b708fe0889c04b7590ba53f3a41afa44a1d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEqv54U47RUUXZfOLnLO/Nsn7QvnkFAl7AdNMACgkQLO/Nsn7Q\nvnlt/Q//e7QW3iL1tQzb5xh6PntMBpAC+OzkW96KU01r6SU8u9MNje/TBRUNclAS\nOEmWCd0G7PPbM9VFzlL2DYC0/P7ju830hfLqFrpjuZtHakVKNVVOKZG5FrTwi4Tv\nENnNhhju8vYfZxauV3ahT0B/K+HZVvkbFMZjKZBe6+VakusC/2gDqIpVzfh/PZ8d\npdECxMF0CsJFOcOMYOqU9ZqDyNFgZjTOyRj26v2daQA6CQV7mUVc+pREb4Wpt9sy\ntu/epCnZbO5KDsgjdhDi0rkW1i5C+GT3jNq6uNeCi0yVwPUVJwDHjmCWKnBcnkJb\n2updkKXSmYI7ObX9nU64JQRE5LMVDrP3msbyc3+sXIouQSpjRI/wh0MEXyWkLuUr\n/Gd2lRUHhwc1xGPKfNxPaTvshfi8LO1rUbl8J1Lr7Fc9MgiNtilfMWBhsZ+cusVM\neCwcIWZZ2v8CdEDl4J4xbDyOB5D7oVMNlLRcenDtMRKo8EW4M8SvdBwo9EdfiZUR\nX6mDPTOlkbR904jPHRGj+ozr7Rdfwditw6bNhWkqis1/8kgcqrjEPTCBqw5qS39V\nIf7EHrSREFHwIAgkopHqvZq5X/rClO2aK4uTjxV9J/9CH/eZHiU3yZaX4gcg4q7B\nXGtqM3TM6qNneEGdUqy2vNvkbQApUDEoSjECuMCv3s31ErNpFF0=\n=Aq99\n-----END PGP SIGNATURE-----", "payload": "tree 3d14f3ce930f0cf0a39a7c959adef476b93c9a08\nparent 404ae5b211c9fb3960b64ecbf91d903d484b0c20\nauthor flip1995 <hello@philkrones.com> 1589671123 +0200\ncommitter flip1995 <hello@philkrones.com> 1589671123 +0200\n\nRun fmt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f317b708fe0889c04b7590ba53f3a41afa44a1d", "html_url": "https://github.com/rust-lang/rust/commit/7f317b708fe0889c04b7590ba53f3a41afa44a1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f317b708fe0889c04b7590ba53f3a41afa44a1d/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "404ae5b211c9fb3960b64ecbf91d903d484b0c20", "url": "https://api.github.com/repos/rust-lang/rust/commits/404ae5b211c9fb3960b64ecbf91d903d484b0c20", "html_url": "https://github.com/rust-lang/rust/commit/404ae5b211c9fb3960b64ecbf91d903d484b0c20"}], "stats": {"total": 222, "additions": 110, "deletions": 112}, "files": [{"sha": "d3a7e24937f95e865ff81cd7ae31ec6d994a8026", "filename": "src/driver.rs", "status": "modified", "additions": 110, "deletions": 112, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/7f317b708fe0889c04b7590ba53f3a41afa44a1d/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f317b708fe0889c04b7590ba53f3a41afa44a1d/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=7f317b708fe0889c04b7590ba53f3a41afa44a1d", "patch": "@@ -295,121 +295,119 @@ fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<Pat\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n     lazy_static::initialize(&ICE_HOOK);\n-    exit(\n-        rustc_driver::catch_with_exit_code(move || {\n-            let mut orig_args: Vec<String> = env::args().collect();\n-\n-            if orig_args.iter().any(|a| a == \"--version\" || a == \"-V\") {\n-                let version_info = rustc_tools_util::get_version_info!();\n-                println!(\"{}\", version_info);\n-                exit(0);\n-            }\n+    exit(rustc_driver::catch_with_exit_code(move || {\n+        let mut orig_args: Vec<String> = env::args().collect();\n \n-            // Get the sysroot, looking from most specific to this invocation to the least:\n-            // - command line\n-            // - runtime environment\n-            //    - SYSROOT\n-            //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n-            // - sysroot from rustc in the path\n-            // - compile-time environment\n-            //    - SYSROOT\n-            //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n-            let sys_root_arg = arg_value(&orig_args, \"--sysroot\", |_| true);\n-            let have_sys_root_arg = sys_root_arg.is_some();\n-            let sys_root = sys_root_arg\n-                .map(PathBuf::from)\n-                .or_else(|| std::env::var(\"SYSROOT\").ok().map(PathBuf::from))\n-                .or_else(|| {\n-                    let home = std::env::var(\"RUSTUP_HOME\")\n-                        .or_else(|_| std::env::var(\"MULTIRUST_HOME\"))\n-                        .ok();\n-                    let toolchain = std::env::var(\"RUSTUP_TOOLCHAIN\")\n-                        .or_else(|_| std::env::var(\"MULTIRUST_TOOLCHAIN\"))\n-                        .ok();\n-                    toolchain_path(home, toolchain)\n-                })\n-                .or_else(|| {\n-                    Command::new(\"rustc\")\n-                        .arg(\"--print\")\n-                        .arg(\"sysroot\")\n-                        .output()\n-                        .ok()\n-                        .and_then(|out| String::from_utf8(out.stdout).ok())\n-                        .map(|s| PathBuf::from(s.trim()))\n-                })\n-                .or_else(|| option_env!(\"SYSROOT\").map(PathBuf::from))\n-                .or_else(|| {\n-                    let home = option_env!(\"RUSTUP_HOME\")\n-                        .or(option_env!(\"MULTIRUST_HOME\"))\n-                        .map(ToString::to_string);\n-                    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\")\n-                        .or(option_env!(\"MULTIRUST_TOOLCHAIN\"))\n-                        .map(ToString::to_string);\n-                    toolchain_path(home, toolchain)\n-                })\n-                .map(|pb| pb.to_string_lossy().to_string())\n-                .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\");\n-\n-            // Setting RUSTC_WRAPPER causes Cargo to pass 'rustc' as the first argument.\n-            // We're invoking the compiler programmatically, so we ignore this/\n-            let wrapper_mode = orig_args.get(1).map(Path::new).and_then(Path::file_stem) == Some(\"rustc\".as_ref());\n-\n-            if wrapper_mode {\n-                // we still want to be able to invoke it normally though\n-                orig_args.remove(1);\n-            }\n+        if orig_args.iter().any(|a| a == \"--version\" || a == \"-V\") {\n+            let version_info = rustc_tools_util::get_version_info!();\n+            println!(\"{}\", version_info);\n+            exit(0);\n+        }\n \n-            if !wrapper_mode && (orig_args.iter().any(|a| a == \"--help\" || a == \"-h\") || orig_args.len() == 1) {\n-                display_help();\n-                exit(0);\n-            }\n+        // Get the sysroot, looking from most specific to this invocation to the least:\n+        // - command line\n+        // - runtime environment\n+        //    - SYSROOT\n+        //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n+        // - sysroot from rustc in the path\n+        // - compile-time environment\n+        //    - SYSROOT\n+        //    - RUSTUP_HOME, MULTIRUST_HOME, RUSTUP_TOOLCHAIN, MULTIRUST_TOOLCHAIN\n+        let sys_root_arg = arg_value(&orig_args, \"--sysroot\", |_| true);\n+        let have_sys_root_arg = sys_root_arg.is_some();\n+        let sys_root = sys_root_arg\n+            .map(PathBuf::from)\n+            .or_else(|| std::env::var(\"SYSROOT\").ok().map(PathBuf::from))\n+            .or_else(|| {\n+                let home = std::env::var(\"RUSTUP_HOME\")\n+                    .or_else(|_| std::env::var(\"MULTIRUST_HOME\"))\n+                    .ok();\n+                let toolchain = std::env::var(\"RUSTUP_TOOLCHAIN\")\n+                    .or_else(|_| std::env::var(\"MULTIRUST_TOOLCHAIN\"))\n+                    .ok();\n+                toolchain_path(home, toolchain)\n+            })\n+            .or_else(|| {\n+                Command::new(\"rustc\")\n+                    .arg(\"--print\")\n+                    .arg(\"sysroot\")\n+                    .output()\n+                    .ok()\n+                    .and_then(|out| String::from_utf8(out.stdout).ok())\n+                    .map(|s| PathBuf::from(s.trim()))\n+            })\n+            .or_else(|| option_env!(\"SYSROOT\").map(PathBuf::from))\n+            .or_else(|| {\n+                let home = option_env!(\"RUSTUP_HOME\")\n+                    .or(option_env!(\"MULTIRUST_HOME\"))\n+                    .map(ToString::to_string);\n+                let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\")\n+                    .or(option_env!(\"MULTIRUST_TOOLCHAIN\"))\n+                    .map(ToString::to_string);\n+                toolchain_path(home, toolchain)\n+            })\n+            .map(|pb| pb.to_string_lossy().to_string())\n+            .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\");\n \n-            let should_describe_lints = || {\n-                let args: Vec<_> = env::args().collect();\n-                args.windows(2).any(|args| {\n-                    args[1] == \"help\"\n-                        && match args[0].as_str() {\n-                            \"-W\" | \"-A\" | \"-D\" | \"-F\" => true,\n-                            _ => false,\n-                        }\n-                })\n-            };\n-\n-            if !wrapper_mode && should_describe_lints() {\n-                describe_lints();\n-                exit(0);\n-            }\n+        // Setting RUSTC_WRAPPER causes Cargo to pass 'rustc' as the first argument.\n+        // We're invoking the compiler programmatically, so we ignore this/\n+        let wrapper_mode = orig_args.get(1).map(Path::new).and_then(Path::file_stem) == Some(\"rustc\".as_ref());\n+\n+        if wrapper_mode {\n+            // we still want to be able to invoke it normally though\n+            orig_args.remove(1);\n+        }\n+\n+        if !wrapper_mode && (orig_args.iter().any(|a| a == \"--help\" || a == \"-h\") || orig_args.len() == 1) {\n+            display_help();\n+            exit(0);\n+        }\n+\n+        let should_describe_lints = || {\n+            let args: Vec<_> = env::args().collect();\n+            args.windows(2).any(|args| {\n+                args[1] == \"help\"\n+                    && match args[0].as_str() {\n+                        \"-W\" | \"-A\" | \"-D\" | \"-F\" => true,\n+                        _ => false,\n+                    }\n+            })\n+        };\n \n-            // this conditional check for the --sysroot flag is there so users can call\n-            // `clippy_driver` directly\n-            // without having to pass --sysroot or anything\n-            let mut args: Vec<String> = orig_args.clone();\n-            if !have_sys_root_arg {\n-                args.extend(vec![\"--sysroot\".into(), sys_root]);\n-            };\n-\n-            // this check ensures that dependencies are built but not linted and the final\n-            // crate is linted but not built\n-            let clippy_enabled = env::var(\"CLIPPY_TESTS\").map_or(false, |val| val == \"true\")\n-                || arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_none();\n-\n-            if clippy_enabled {\n-                args.extend(vec![\"--cfg\".into(), r#\"feature=\"cargo-clippy\"\"#.into()]);\n-                if let Ok(extra_args) = env::var(\"CLIPPY_ARGS\") {\n-                    args.extend(extra_args.split(\"__CLIPPY_HACKERY__\").filter_map(|s| {\n-                        if s.is_empty() {\n-                            None\n-                        } else {\n-                            Some(s.to_string())\n-                        }\n-                    }));\n-                }\n+        if !wrapper_mode && should_describe_lints() {\n+            describe_lints();\n+            exit(0);\n+        }\n+\n+        // this conditional check for the --sysroot flag is there so users can call\n+        // `clippy_driver` directly\n+        // without having to pass --sysroot or anything\n+        let mut args: Vec<String> = orig_args.clone();\n+        if !have_sys_root_arg {\n+            args.extend(vec![\"--sysroot\".into(), sys_root]);\n+        };\n+\n+        // this check ensures that dependencies are built but not linted and the final\n+        // crate is linted but not built\n+        let clippy_enabled = env::var(\"CLIPPY_TESTS\").map_or(false, |val| val == \"true\")\n+            || arg_value(&orig_args, \"--cap-lints\", |val| val == \"allow\").is_none();\n+\n+        if clippy_enabled {\n+            args.extend(vec![\"--cfg\".into(), r#\"feature=\"cargo-clippy\"\"#.into()]);\n+            if let Ok(extra_args) = env::var(\"CLIPPY_ARGS\") {\n+                args.extend(extra_args.split(\"__CLIPPY_HACKERY__\").filter_map(|s| {\n+                    if s.is_empty() {\n+                        None\n+                    } else {\n+                        Some(s.to_string())\n+                    }\n+                }));\n             }\n-            let mut clippy = ClippyCallbacks;\n-            let mut default = DefaultCallbacks;\n-            let callbacks: &mut (dyn rustc_driver::Callbacks + Send) =\n-                if clippy_enabled { &mut clippy } else { &mut default };\n-            rustc_driver::run_compiler(&args, callbacks, None, None)\n-        })\n-    )\n+        }\n+        let mut clippy = ClippyCallbacks;\n+        let mut default = DefaultCallbacks;\n+        let callbacks: &mut (dyn rustc_driver::Callbacks + Send) =\n+            if clippy_enabled { &mut clippy } else { &mut default };\n+        rustc_driver::run_compiler(&args, callbacks, None, None)\n+    }))\n }"}]}