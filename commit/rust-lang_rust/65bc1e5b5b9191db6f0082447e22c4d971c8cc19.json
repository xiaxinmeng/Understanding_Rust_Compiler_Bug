{"sha": "65bc1e5b5b9191db6f0082447e22c4d971c8cc19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YmMxZTViNWI5MTkxZGI2ZjAwODI0NDdlMjJjNGQ5NzFjOGNjMTk=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-06-16T10:51:16Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-06-16T10:51:16Z"}, "message": "Fix `write_cvalue` for `ByValPair` when the cvalue is not trivially a pair\n\n`write_cvalue` didn't work for `Box<[u8]>`, because the inner fat ptr\nwas wrapped inside a newtype, which meant `Box<[u8]>` itself only had\none field.\n\nThis also simplifies `CValue::force_stack` by reusing `write_cvalue`\nwhen it is not already on the stack.", "tree": {"sha": "3096543c74816b862e900b6bfca0185d22c45f50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3096543c74816b862e900b6bfca0185d22c45f50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65bc1e5b5b9191db6f0082447e22c4d971c8cc19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65bc1e5b5b9191db6f0082447e22c4d971c8cc19", "html_url": "https://github.com/rust-lang/rust/commit/65bc1e5b5b9191db6f0082447e22c4d971c8cc19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65bc1e5b5b9191db6f0082447e22c4d971c8cc19/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d406cdcad83c992416ad213c077e3203d75cce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d406cdcad83c992416ad213c077e3203d75cce1", "html_url": "https://github.com/rust-lang/rust/commit/4d406cdcad83c992416ad213c077e3203d75cce1"}], "stats": {"total": 47, "additions": 20, "deletions": 27}, "files": [{"sha": "51af4650942db5e9e98753e7423821e1937a849d", "filename": "src/value_and_place.rs", "status": "modified", "additions": 20, "deletions": 27, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/65bc1e5b5b9191db6f0082447e22c4d971c8cc19/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65bc1e5b5b9191db6f0082447e22c4d971c8cc19/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=65bc1e5b5b9191db6f0082447e22c4d971c8cc19", "patch": "@@ -53,28 +53,10 @@ impl<'tcx> CValue<'tcx> {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(value) => value,\n-            CValueInner::ByVal(value) => {\n-                let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n-                    kind: StackSlotKind::ExplicitSlot,\n-                    size: layout.size.bytes() as u32,\n-                    offset: None,\n-                });\n-                let addr = fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0);\n-                fx.bcx.ins().store(MemFlags::new(), value, addr, 0);\n-                addr\n-            }\n-            CValueInner::ByValPair(value, extra) => {\n-                let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n-                    kind: StackSlotKind::ExplicitSlot,\n-                    size: layout.size.bytes() as u32,\n-                    offset: None,\n-                });\n-                let base = fx.bcx.ins().stack_addr(types::I64, stack_slot, 0);\n-                let a_addr = codegen_field(fx, base, layout, mir::Field::new(0)).0;\n-                let b_addr = codegen_field(fx, base, layout, mir::Field::new(1)).0;\n-                fx.bcx.ins().store(MemFlags::new(), value, a_addr, 0);\n-                fx.bcx.ins().store(MemFlags::new(), extra, b_addr, 0);\n-                base\n+            CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => {\n+                let cplace = CPlace::new_stack_slot(fx, layout.ty);\n+                cplace.write_cvalue(fx, self);\n+                cplace.to_addr(fx)\n             }\n         }\n     }\n@@ -356,11 +338,22 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             CValueInner::ByVal(val) => {\n                 fx.bcx.ins().store(MemFlags::new(), val, addr, 0);\n             }\n-            CValueInner::ByValPair(val1, val2) => {\n-                let val1_offset = dst_layout.fields.offset(0).bytes() as i32;\n-                let val2_offset = dst_layout.fields.offset(1).bytes() as i32;\n-                fx.bcx.ins().store(MemFlags::new(), val1, addr, val1_offset);\n-                fx.bcx.ins().store(MemFlags::new(), val2, addr, val2_offset);\n+            CValueInner::ByValPair(value, extra) => {\n+                match dst_layout.abi {\n+                    Abi::ScalarPair(ref a, _) => {\n+                        fx.bcx.ins().store(MemFlags::new(), value, addr, 0);\n+                        fx.bcx.ins().store(\n+                            MemFlags::new(),\n+                            extra,\n+                            addr,\n+                            a.value.size(&fx.tcx).bytes() as u32 as i32,\n+                        );\n+                    }\n+                    _ => bug!(\n+                        \"Non ScalarPair abi {:?} for ByValPair CValue\",\n+                        dst_layout.abi\n+                    ),\n+                }\n             }\n             CValueInner::ByRef(from_addr) => {\n                 let src_layout = from.1;"}]}