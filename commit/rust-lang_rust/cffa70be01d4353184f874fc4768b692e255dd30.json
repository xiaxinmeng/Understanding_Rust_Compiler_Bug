{"sha": "cffa70be01d4353184f874fc4768b692e255dd30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZmE3MGJlMDFkNDM1MzE4NGY4NzRmYzQ3NjhiNjkyZTI1NWRkMzA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-15T20:25:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-15T20:25:42Z"}, "message": "Merge #4470\n\n4470: Handle `Self` in values and patterns r=matklad a=flodiebold\n\nI.e.\r\n - `Self(x)` or `Self` in tuple/unit struct impls\r\n - `Self::Variant(x)` or `Self::Variant` in enum impls\r\n - the same in patterns\r\n\r\nFixes #4454.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "481c93f91eec65f98a82fa28a123140d5a227eea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/481c93f91eec65f98a82fa28a123140d5a227eea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cffa70be01d4353184f874fc4768b692e255dd30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cffa70be01d4353184f874fc4768b692e255dd30", "html_url": "https://github.com/rust-lang/rust/commit/cffa70be01d4353184f874fc4768b692e255dd30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cffa70be01d4353184f874fc4768b692e255dd30/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d51c1f62178c383363a2d95e865131d9a7b969d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d51c1f62178c383363a2d95e865131d9a7b969d0", "html_url": "https://github.com/rust-lang/rust/commit/d51c1f62178c383363a2d95e865131d9a7b969d0"}, {"sha": "3f42b2e837c4672a0fbe953e14ae2fd3fe6fc3b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f42b2e837c4672a0fbe953e14ae2fd3fe6fc3b6", "html_url": "https://github.com/rust-lang/rust/commit/3f42b2e837c4672a0fbe953e14ae2fd3fe6fc3b6"}], "stats": {"total": 216, "additions": 197, "deletions": 19}, "files": [{"sha": "c862a4f483fd3f67d24da5eb04dee702228babb2", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=cffa70be01d4353184f874fc4768b692e255dd30", "patch": "@@ -417,6 +417,7 @@ pub(crate) fn resolve_hir_path(\n                 ValueNs::StaticId(it) => PathResolution::Def(Static::from(it).into()),\n                 ValueNs::StructId(it) => PathResolution::Def(Struct::from(it).into()),\n                 ValueNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+                ValueNs::ImplSelf(impl_id) => PathResolution::SelfType(impl_id.into()),\n             };\n             Some(res)\n         });"}, {"sha": "15fdd9019b73aba62cdd4b5b9ef11f9e95ecca26", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=cffa70be01d4353184f874fc4768b692e255dd30", "patch": "@@ -86,6 +86,7 @@ pub enum ResolveValueResult {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum ValueNs {\n+    ImplSelf(ImplId),\n     LocalBinding(PatId),\n     FunctionId(FunctionId),\n     ConstId(ConstId),\n@@ -291,19 +292,26 @@ impl Resolver {\n                 }\n                 Scope::GenericParams { .. } => continue,\n \n-                Scope::ImplDefScope(impl_) if n_segments > 1 => {\n+                Scope::ImplDefScope(impl_) => {\n                     if first_name == &name![Self] {\n-                        let ty = TypeNs::SelfType(*impl_);\n-                        return Some(ResolveValueResult::Partial(ty, 1));\n+                        if n_segments > 1 {\n+                            let ty = TypeNs::SelfType(*impl_);\n+                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        } else {\n+                            return Some(ResolveValueResult::ValueNs(ValueNs::ImplSelf(*impl_)));\n+                        }\n                     }\n                 }\n-                Scope::AdtScope(adt) if n_segments > 1 => {\n+                Scope::AdtScope(adt) => {\n+                    if n_segments == 1 {\n+                        // bare `Self` doesn't work in the value namespace in a struct/enum definition\n+                        continue;\n+                    }\n                     if first_name == &name![Self] {\n                         let ty = TypeNs::AdtSelfType(*adt);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n-                Scope::ImplDefScope(_) | Scope::AdtScope(_) => continue,\n \n                 Scope::ModuleScope(m) => {\n                     let (module_def, idx) = m.crate_def_map.resolve_path("}, {"sha": "2876cb141aa22120d6c36889b9c319fed50e5dd7", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 66, "deletions": 13, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=cffa70be01d4353184f874fc4768b692e255dd30", "patch": "@@ -28,7 +28,8 @@ use hir_def::{\n     path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{Mutability, TypeRef},\n-    AdtId, AssocItemId, DefWithBodyId, FieldId, FunctionId, TraitId, TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, TraitId, TypeAliasId,\n+    VariantId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use ra_arena::map::ArenaMap;\n@@ -438,43 +439,95 @@ impl<'a> InferenceContext<'a> {\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n-        return match resolver.resolve_path_in_type_ns_fully(self.db.upcast(), path.mod_path()) {\n-            Some(TypeNs::AdtId(AdtId::StructId(strukt))) => {\n+        let (resolution, unresolved) =\n+            match resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n+                Some(it) => it,\n+                None => return (Ty::Unknown, None),\n+            };\n+        return match resolution {\n+            TypeNs::AdtId(AdtId::StructId(strukt)) => {\n                 let substs = Ty::substs_from_path(&ctx, path, strukt.into());\n                 let ty = self.db.ty(strukt.into());\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n-                (ty, Some(strukt.into()))\n+                forbid_unresolved_segments((ty, Some(strukt.into())), unresolved)\n             }\n-            Some(TypeNs::EnumVariantId(var)) => {\n+            TypeNs::EnumVariantId(var) => {\n                 let substs = Ty::substs_from_path(&ctx, path, var.into());\n                 let ty = self.db.ty(var.parent.into());\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n-                (ty, Some(var.into()))\n+                forbid_unresolved_segments((ty, Some(var.into())), unresolved)\n             }\n-            Some(TypeNs::SelfType(impl_id)) => {\n+            TypeNs::SelfType(impl_id) => {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = Substs::type_params_for_generics(&generics);\n                 let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n-                let variant = ty_variant(&ty);\n-                (ty, variant)\n+                match unresolved {\n+                    None => {\n+                        let variant = ty_variant(&ty);\n+                        (ty, variant)\n+                    }\n+                    Some(1) => {\n+                        let segment = path.mod_path().segments.last().unwrap();\n+                        // this could be an enum variant or associated type\n+                        if let Some((AdtId::EnumId(enum_id), _)) = ty.as_adt() {\n+                            let enum_data = self.db.enum_data(enum_id);\n+                            if let Some(local_id) = enum_data.variant(segment) {\n+                                let variant = EnumVariantId { parent: enum_id, local_id };\n+                                return (ty, Some(variant.into()));\n+                            }\n+                        }\n+                        // FIXME potentially resolve assoc type\n+                        (Ty::Unknown, None)\n+                    }\n+                    Some(_) => {\n+                        // FIXME diagnostic\n+                        (Ty::Unknown, None)\n+                    }\n+                }\n             }\n-            Some(TypeNs::TypeAliasId(it)) => {\n+            TypeNs::TypeAliasId(it) => {\n                 let substs = Substs::build_for_def(self.db, it)\n                     .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                     .build();\n                 let ty = self.db.ty(it.into()).subst(&substs);\n                 let variant = ty_variant(&ty);\n-                (ty, variant)\n+                forbid_unresolved_segments((ty, variant), unresolved)\n+            }\n+            TypeNs::AdtSelfType(_) => {\n+                // FIXME this could happen in array size expressions, once we're checking them\n+                (Ty::Unknown, None)\n+            }\n+            TypeNs::GenericParam(_) => {\n+                // FIXME potentially resolve assoc type\n+                (Ty::Unknown, None)\n+            }\n+            TypeNs::AdtId(AdtId::EnumId(_))\n+            | TypeNs::AdtId(AdtId::UnionId(_))\n+            | TypeNs::BuiltinType(_)\n+            | TypeNs::TraitId(_) => {\n+                // FIXME diagnostic\n+                (Ty::Unknown, None)\n             }\n-            Some(_) | None => (Ty::Unknown, None),\n         };\n \n+        fn forbid_unresolved_segments(\n+            result: (Ty, Option<VariantId>),\n+            unresolved: Option<usize>,\n+        ) -> (Ty, Option<VariantId>) {\n+            if unresolved.is_none() {\n+                result\n+            } else {\n+                // FIXME diagnostic\n+                (Ty::Unknown, None)\n+            }\n+        }\n+\n         fn ty_variant(ty: &Ty) -> Option<VariantId> {\n             ty.as_adt().and_then(|(adt_id, _)| match adt_id {\n                 AdtId::StructId(s) => Some(VariantId::StructId(s)),\n                 AdtId::UnionId(u) => Some(VariantId::UnionId(u)),\n                 AdtId::EnumId(_) => {\n-                    // Error E0071, expected struct, variant or union type, found enum `Foo`\n+                    // FIXME Error E0071, expected struct, variant or union type, found enum `Foo`\n                     None\n                 }\n             })"}, {"sha": "1c2e56fb0d822b55c7565dcd14bc56a78c8a287a", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=cffa70be01d4353184f874fc4768b692e255dd30", "patch": "@@ -5,7 +5,7 @@ use std::iter;\n use hir_def::{\n     path::{Path, PathSegment},\n     resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n-    AssocContainerId, AssocItemId, Lookup,\n+    AdtId, AssocContainerId, AssocItemId, EnumVariantId, Lookup,\n };\n use hir_expand::name::Name;\n \n@@ -77,6 +77,18 @@ impl<'a> InferenceContext<'a> {\n \n                 it.into()\n             }\n+            ValueNs::ImplSelf(impl_id) => {\n+                let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n+                let substs = Substs::type_params_for_generics(&generics);\n+                let ty = self.db.impl_self_ty(impl_id).subst(&substs);\n+                if let Some((AdtId::StructId(struct_id), _)) = ty.as_adt() {\n+                    let ty = self.db.value_ty(struct_id.into()).subst(&substs);\n+                    return Some(ty);\n+                } else {\n+                    // FIXME: diagnostic, invalid Self reference\n+                    return None;\n+                }\n+            }\n         };\n \n         let ty = self.db.value_ty(typable);\n@@ -199,6 +211,10 @@ impl<'a> InferenceContext<'a> {\n             return None;\n         }\n \n+        if let Some(result) = self.resolve_enum_variant_on_ty(&ty, name, id) {\n+            return Some(result);\n+        }\n+\n         let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n         let krate = self.resolver.krate()?;\n         let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n@@ -250,4 +266,21 @@ impl<'a> InferenceContext<'a> {\n             },\n         )\n     }\n+\n+    fn resolve_enum_variant_on_ty(\n+        &mut self,\n+        ty: &Ty,\n+        name: &Name,\n+        id: ExprOrPatId,\n+    ) -> Option<(ValueNs, Option<Substs>)> {\n+        let (enum_id, subst) = match ty.as_adt() {\n+            Some((AdtId::EnumId(e), subst)) => (e, subst),\n+            _ => return None,\n+        };\n+        let enum_data = self.db.enum_data(enum_id);\n+        let local_id = enum_data.variant(name)?;\n+        let variant = EnumVariantId { parent: enum_id, local_id };\n+        self.write_variant_resolution(id, variant.into());\n+        Some((ValueNs::EnumVariantId(variant), Some(subst.clone())))\n+    }\n }"}, {"sha": "d83ff5e0ea7082b044a97177a54613f10f95a348", "filename": "crates/ra_hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=cffa70be01d4353184f874fc4768b692e255dd30", "patch": "@@ -368,6 +368,45 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn enum_variant_through_self_in_pattern() {\n+    assert_snapshot!(\n+        infer(r#\"\n+enum E {\n+    A { x: usize },\n+    B(usize),\n+    C\n+}\n+\n+impl E {\n+    fn test() {\n+        match (loop {}) {\n+            Self::A { x } => { x; },\n+            Self::B(x) => { x; },\n+            Self::C => {},\n+        };\n+    }\n+}\n+\"#),\n+        @r###\"\n+    76..218 '{     ...     }': ()\n+    86..211 'match ...     }': ()\n+    93..100 'loop {}': !\n+    98..100 '{}': ()\n+    116..129 'Self::A { x }': E\n+    126..127 'x': usize\n+    133..139 '{ x; }': ()\n+    135..136 'x': usize\n+    153..163 'Self::B(x)': E\n+    161..162 'x': usize\n+    167..173 '{ x; }': ()\n+    169..170 'x': usize\n+    187..194 'Self::C': E\n+    198..200 '{}': ()\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_generics_in_patterns() {\n     assert_snapshot!("}, {"sha": "72122c070ad8940091006e0028201a475c0fb986", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffa70be01d4353184f874fc4768b692e255dd30/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=cffa70be01d4353184f874fc4768b692e255dd30", "patch": "@@ -575,6 +575,50 @@ impl S {\n     );\n }\n \n+#[test]\n+fn infer_self_as_path() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct S1;\n+struct S2(isize);\n+enum E {\n+    V1,\n+    V2(u32),\n+}\n+\n+impl S1 {\n+    fn test() {\n+        Self;\n+    }\n+}\n+impl S2 {\n+    fn test() {\n+        Self(1);\n+    }\n+}\n+impl E {\n+    fn test() {\n+        Self::V1;\n+        Self::V2(1);\n+    }\n+}\n+\"#),\n+        @r###\"\n+    87..108 '{     ...     }': ()\n+    97..101 'Self': S1\n+    135..159 '{     ...     }': ()\n+    145..149 'Self': S2(isize) -> S2\n+    145..152 'Self(1)': S2\n+    150..151 '1': isize\n+    185..231 '{     ...     }': ()\n+    195..203 'Self::V1': E\n+    213..221 'Self::V2': V2(u32) -> E\n+    213..224 'Self::V2(1)': E\n+    222..223 '1': u32\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_binary_op() {\n     assert_snapshot!("}]}