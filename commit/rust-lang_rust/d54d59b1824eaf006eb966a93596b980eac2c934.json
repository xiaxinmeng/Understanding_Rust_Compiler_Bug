{"sha": "d54d59b1824eaf006eb966a93596b980eac2c934", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NGQ1OWIxODI0ZWFmMDA2ZWI5NjZhOTM1OTZiOTgwZWFjMmM5MzQ=", "commit": {"author": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-11T03:17:03Z"}, "committer": {"name": "Taylor Yu", "email": "tlyu@mit.edu", "date": "2021-06-11T03:30:00Z"}, "message": "method overviews for option and result", "tree": {"sha": "ad6a74fc74a63f338bd885e30a4da3f5b615e21d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad6a74fc74a63f338bd885e30a4da3f5b615e21d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d54d59b1824eaf006eb966a93596b980eac2c934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d54d59b1824eaf006eb966a93596b980eac2c934", "html_url": "https://github.com/rust-lang/rust/commit/d54d59b1824eaf006eb966a93596b980eac2c934", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d54d59b1824eaf006eb966a93596b980eac2c934/comments", "author": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tlyu", "id": 431873, "node_id": "MDQ6VXNlcjQzMTg3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/431873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlyu", "html_url": "https://github.com/tlyu", "followers_url": "https://api.github.com/users/tlyu/followers", "following_url": "https://api.github.com/users/tlyu/following{/other_user}", "gists_url": "https://api.github.com/users/tlyu/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlyu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlyu/subscriptions", "organizations_url": "https://api.github.com/users/tlyu/orgs", "repos_url": "https://api.github.com/users/tlyu/repos", "events_url": "https://api.github.com/users/tlyu/events{/privacy}", "received_events_url": "https://api.github.com/users/tlyu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4763377a96691997e03e27f7b292e7dcd5e7a53d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4763377a96691997e03e27f7b292e7dcd5e7a53d", "html_url": "https://github.com/rust-lang/rust/commit/4763377a96691997e03e27f7b292e7dcd5e7a53d"}], "stats": {"total": 240, "additions": 240, "deletions": 0}, "files": [{"sha": "5f3529caa9ae553229d4a6aacf447eace47b46b5", "filename": "library/core/src/option.rs", "status": "modified", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/d54d59b1824eaf006eb966a93596b980eac2c934/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54d59b1824eaf006eb966a93596b980eac2c934/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=d54d59b1824eaf006eb966a93596b980eac2c934", "patch": "@@ -90,6 +90,205 @@\n //! from `Some::<T>(_)` to `T` (but transmuting `None::<T>` to `T`\n //! is undefined behaviour).\n //!\n+//! # Method overview\n+//!\n+//! In addition to working with pattern matching, [`Option`] provides a wide\n+//! variety of different methods.\n+//!\n+//! ## Querying the variant\n+//!\n+//! The [`is_some`] and [`is_none`] methods return [`true`] if the [`Option`]\n+//! is [`Some`] or [`None`], respectively.\n+//!\n+//! [`is_some`]: Option::is_some\n+//! [`is_none`]: Option::is_none\n+//!\n+//! ## Adapters for working with references\n+//!\n+//! * [`as_ref`] converts from `&Option<T>` to `Option<&T>`\n+//! * [`as_mut`] converts from `&mut Option<T>` to `Option<&mut T>`\n+//! * [`as_deref`] converts from `&Option<T>` to `Option<&T::Target>`\n+//! * [`as_deref_mut`] converts from `&mut Option<T>` to `Option<&mut T::Target>`\n+//! * [`as_pin_ref`] converts from [`&Pin`]`<Option<T>>` to `Option<`[`Pin`]`<&T>>`\n+//! * [`as_pin_mut`] converts from [`&mut Pin`]`<Option<T>>` to `Option<`[`Pin`]`<&mut T>>`\n+//!\n+//! [`&mut Pin`]: crate::pin::Pin\n+//! [`&Pin`]: crate::pin::Pin\n+//! [`as_deref`]: Option::as_deref\n+//! [`as_deref_mut`]: Option::as_deref_mut\n+//! [`as_mut`]: Option::as_mut\n+//! [`as_pin_ref`]: Option::as_pin_ref\n+//! [`as_pin_mut`]: Option::as_pin_mut\n+//! [`as_ref`]: Option::as_ref\n+//! [`Pin`]: crate::pin::Pin\n+//!\n+//! ## Extracting the contained value\n+//!\n+//! These methods extract the contained value in an [`Option`] when it is\n+//! the [`Some`] variant. If the [`Option`] is [`None`]:\n+//!\n+//! * [`expect`] panics with a provided custom message\n+//! * [`unwrap`] panics with a generic message\n+//! * [`unwrap_or`] returns the provided default value\n+//! * [`unwrap_or_default`] returns the default value of the type `T`\n+//!   (which must implement the [`Default`] trait)\n+//! * [`unwrap_or_else`] evaluates a provided function\n+//!\n+//! [`Default`]: crate::default::Default\n+//! [`expect`]: Option::expect\n+//! [`unwrap`]: Option::unwrap\n+//! [`unwrap_or`]: Option::unwrap_or\n+//! [`unwrap_or_default`]: Option::unwrap_or_default\n+//! [`unwrap_or_else`]: Option::unwrap_or_else\n+//!\n+//! ## Transforming contained values\n+//!\n+//! * [`map`] transforms [`Some<T>`] to [`Some<U>`] using the provided\n+//!   function\n+//! * [`map_or`] transforms [`Some<T>`] to a value of `U` using the\n+//!   provided function, or transforms [`None`] to a provided default value\n+//!   of `U`\n+//! * [`map_or_else`] transforms [`Some<T>`] to [`Some<U>`] using the\n+//!   provided function, or transforms [`None`] to a value of `U` using\n+//!   another provided function\n+//! * [`ok_or`] transforms [`Some(v)`] to [`Ok(v)`], and [`None`] to\n+//!   [`Err(err)`] using the provided default `err` value\n+//! * [`ok_or_else`] transforms [`Some(v)`] to [`Ok(v)`], and [`None`] to\n+//!   a value of [`Err<E>`] using the provided function\n+//!\n+//! [`Err(err)`]: Err\n+//! [`map`]: Option::map\n+//! [`map_or`]: Option::map_or\n+//! [`map_or_else`]: Option::map_or_else\n+//! [`Ok(v)`]: Ok\n+//! [`ok_or`]: Option::ok_or\n+//! [`ok_or_else`]: Option::ok_or_else\n+//! [`Some(v)`]: Some\n+//!\n+//! ## Boolean operators\n+//!\n+//! These methods treat the [`Option`] as a boolean value, where [`Some`]\n+//! acts like [`true`] and [`None`] acts like [`false`]. There are two\n+//! categories of these methods: ones that take an [`Option`] as input, and\n+//! ones that take a function as input (to be lazily evaluated).\n+//!\n+//! The [`and`], [`or`], and [`xor`] methods take another [`Option`] as\n+//! input, and produce an [`Option`] as output. Only the [`and`] method can\n+//! produce an [`Option<U>`] value having a different inner type `U` than\n+//! [`Option<T>`].\n+//!\n+//! | method  | self      | input     | output    |\n+//! |---------|-----------|-----------|-----------|\n+//! | [`and`] | N/A       | `None`    | `None`    |\n+//! | [`and`] | `Some(x)` | `Some(y)` | `Some(y)` |\n+//! | [`or`]  | `None`    | `None`    | `None`    |\n+//! | [`or`]  | `None`    | `Some(y)` | `Some(y)` |\n+//! | [`or`]  | `Some(x)` | N/A       | `Some(x)` |\n+//! | [`xor`] | `None`    | `None`    | `None`    |\n+//! | [`xor`] | `None`    | `Some(y)` | `Some(y)` |\n+//! | [`xor`] | `Some(x)` | `None`    | `Some(x)` |\n+//! | [`xor`] | `Some(x)` | `Some(y)` | `None`    |\n+//!\n+//! The [`and_then`], [`filter`], and [`or_else`] methods take a function\n+//! as input, and only evaluate the function when they need to produce a\n+//! new value. [`and_then`] and [`or_else`] take a function that produces\n+//! another [`Option`] value, while [`filter`] takes a predicate that is\n+//! used to decide whether to pass the [`Some`] value through. Only the\n+//! [`and_then`] method can produce an [`Option<U>`] value having a\n+//! different inner type `U` than [`Option<T>`].\n+//!\n+//! | method       | self      | function input | function result | output    |\n+//! |--------------|-----------|----------------|-----------------|-----------|\n+//! | [`and_then`] | `None`    | N/A            | (not evaluated) | `None`    |\n+//! | [`and_then`] | `Some(x)` | `x`            | `None`          | `None`    |\n+//! | [`and_then`] | `Some(x)` | `x`            | `Some(y)`       | `Some(y)` |\n+//! | [`filter`]   | `None`    | N/A            | (not evaluated) | `None`    |\n+//! | [`filter`]   | `Some(x)` | `x`            | `false`         | `None`    |\n+//! | [`filter`]   | `Some(x)` | `x`            | `true`          | `Some(x)` |\n+//! | [`or_else`]  | `None`    | N/A            | `None`          | `None`    |\n+//! | [`or_else`]  | `None`    | N/A            | `Some(y)`       | `Some(y)` |\n+//! | [`or_else`]  | `Some(x)` | N/A            | (not evaluated) | `Some(x)` |\n+//!\n+//! [`and`]: Option::and\n+//! [`and_then`]: Option::and_then\n+//! [`filter`]: Option::filter\n+//! [`or`]: Option::or\n+//! [`or_else`]: Option::or_else\n+//! [`xor`]: Option::xor\n+//!\n+//! ## Iterators\n+//!\n+//! An [`Option`] can be iterated over. This can be helpful if you need an\n+//! iterator that is conditionally empty. The iterator will either produce\n+//! a single value (when the [`Option`] is [`Some`]), or produce no values\n+//! (when the [`Option`] is [`None`]). For example, [`into_iter`] acts like\n+//! [`once(v)`] if the [`Option`] is [`Some(v)`], and like [`empty()`] if\n+//! the [`Option`] is [`None`].\n+//!\n+//! Iterators over [`Option`] come in three types:\n+//!\n+//! * [`into_iter`] consumes the [`Option`] and produces the contained\n+//!   value\n+//! * [`iter`] produces an immutable reference of type `&T` to the\n+//!   contained value\n+//! * [`iter_mut`] produces a mutable reference of type `&mut T` to the\n+//!   contained value\n+//!\n+//! [`Option`] implements the [`FromIterator`] trait, which allows an\n+//! iterator over [`Option`] values to be collected into an [`Option`] of a\n+//! collection of each contained value of the original [`Option`] values,\n+//! or [`None`] if any of the elements was [`None`].\n+//!\n+//! [`empty()`]: crate::iter::empty\n+//! [`FromIterator`]: Option#impl-FromIterator%3COption%3CA%3E%3E\n+//! [`into_iter`]: Option::into_iter\n+//! [`iter`]: Option::iter\n+//! [`iter_mut`]: Option::iter_mut\n+//! [`once(v)`]: crate::iter::once\n+//! [`Some(v)`]: Some\n+//!\n+//! An iterator over [`Option`] can be useful when chaining iterators:\n+//!\n+//! ```\n+//! let yep = Some(42);\n+//! let nope = None;\n+//! let nums: Vec<i32> = (0..4).chain(yep.into_iter()).chain(4..8).collect();\n+//! assert_eq!(nums, [0, 1, 2, 3, 42, 4, 5, 6, 7]);\n+//! let nums: Vec<i32> = (0..4).chain(nope.into_iter()).chain(4..8).collect();\n+//! assert_eq!(nums, [0, 1, 2, 3, 4, 5, 6, 7]);\n+//! ```\n+//!\n+//! One reason to chain iterators in this way is that a function returning\n+//! `impl Iterator` must have all possible return values be of the same\n+//! concrete type. Chaining an iterated [`Option`] can help with that.\n+//!\n+//! ```\n+//! let yep = Some(42);\n+//! let nope = None;\n+//!\n+//! fn makeiter(opt: Option<i32>) -> impl Iterator<Item = i32> {\n+//!     (0..4).chain(opt.into_iter()).chain(4..8)\n+//! }\n+//! println!(\"{:?}\", makeiter(yep).collect::<Vec<_>>());\n+//! println!(\"{:?}\", makeiter(nope).collect::<Vec<_>>());\n+//! ```\n+//!\n+//! If we try to do the same thing, but using pattern matching, we can't\n+//! return `impl Iterator` anymore because the concrete types of the return\n+//! values differ.\n+//!\n+//! ```compile_fail,E0308\n+//! # use std::iter::{empty, once};\n+//! // This won't compile because all possible returns from the function\n+//! // must have the same concrete type.\n+//! fn makeiter(opt: Option<i32>) -> impl Iterator<Item = i32> {\n+//!     match opt {\n+//!         Some(x) => return (0..4).chain(once(x)).chain(4..8),\n+//!         None => return (0..4).chain(empty()).chain(4..8)\n+//!     }\n+//! }\n+//! ```\n+//!\n //! # Examples\n //!\n //! Basic pattern matching on [`Option`]:"}, {"sha": "449a5b489c708278b40a3436317bb56a9e245c7e", "filename": "library/core/src/result.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d54d59b1824eaf006eb966a93596b980eac2c934/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54d59b1824eaf006eb966a93596b980eac2c934/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=d54d59b1824eaf006eb966a93596b980eac2c934", "patch": "@@ -224,6 +224,47 @@\n //! [`Ok(T)`]: Ok\n //! [`Err(E)`]: Err\n //! [`io::Error`]: ../../std/io/struct.Error.html\n+//!\n+//! # Method overview\n+//!\n+//! ## Boolean operators\n+//!\n+//! These methods treat the [`Result`] as a boolean value, where [`Ok`]\n+//! acts like [`true`] and [`Err`] acts like [`false`]. There are two\n+//! categories of these methods: ones that take a [`Result`] as input, and\n+//! ones that take a function as input (to be lazily evaluated).\n+//!\n+//! The [`and`] and [`or`] methods take another [`Result`] as input, and\n+//! produce an [`Result`] as output. Only the [`and`] method can produce a\n+//! [`Result<U, E>`] value having a different inner type `U` than\n+//! [`Result<T, E>`].\n+//!\n+//! | method  | self     | input    | output   |\n+//! |---------|----------|----------|----------|\n+//! | [`and`] | N/A      | `Err(e)` | `Err(e)` |\n+//! | [`and`] | `Ok(x)`  | `Ok(y)`  | `Ok(y)`  |\n+//! | [`or`]  | `Err(e)` | `Err(d)` | `Err(d)` |\n+//! | [`or`]  | `Err(e)` | `Ok(y)`  | `Ok(y)`  |\n+//! | [`or`]  | `Ok(x)`  | N/A      | `Ok(x)`  |\n+//!\n+//! The [`and_then`] and [`or_else`] methods take a function as input, and\n+//! only evaluate the function when they need to produce a new value. Only\n+//! the [`and_then`] method can produce an [`Result<U, E>`] value having a\n+//! different inner type `U` than [`Result<T, E>`].\n+//!\n+//! | method       | self     | function input | function result | output   |\n+//! |--------------|----------|----------------|-----------------|----------|\n+//! | [`and_then`] | `Err(e)` | N/A            | (not evaluated) | `Err(e)` |\n+//! | [`and_then`] | `Ok(x)`  | `x`            | `Err(d)`        | `Err(d)` |\n+//! | [`and_then`] | `Ok(x)`  | `x`            | `Ok(y)`         | `Ok(y)`  |\n+//! | [`or_else`]  | `Err(e)` | `e`            | `Err(d)`        | `Err(d)` |\n+//! | [`or_else`]  | `Err(e)` | `e`            | `Ok(y)`         | `Ok(y)`  |\n+//! | [`or_else`]  | `Ok(x)`  | N/A            | (not evaluated) | `Ok(x)`  |\n+//!\n+//! [`and`]: Result::and\n+//! [`and_then`]: Result::and_then\n+//! [`or`]: Result::or\n+//! [`or_else`]: Result::or_else\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}