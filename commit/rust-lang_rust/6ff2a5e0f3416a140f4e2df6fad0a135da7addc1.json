{"sha": "6ff2a5e0f3416a140f4e2df6fad0a135da7addc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZjJhNWUwZjM0MTZhMTQwZjRlMmRmNmZhZDBhMTM1ZGE3YWRkYzE=", "commit": {"author": {"name": "Aaron Loucks", "email": "aloucks@cofront.net", "date": "2018-07-28T20:18:58Z"}, "committer": {"name": "Aaron Loucks", "email": "aloucks@cofront.net", "date": "2018-07-29T14:12:31Z"}, "message": "Auto-detect newline style by default", "tree": {"sha": "9d0954bbd3028e15640727232e3ba940d97f034f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d0954bbd3028e15640727232e3ba940d97f034f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1", "html_url": "https://github.com/rust-lang/rust/commit/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1/comments", "author": {"login": "aloucks", "id": 221559, "node_id": "MDQ6VXNlcjIyMTU1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/221559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aloucks", "html_url": "https://github.com/aloucks", "followers_url": "https://api.github.com/users/aloucks/followers", "following_url": "https://api.github.com/users/aloucks/following{/other_user}", "gists_url": "https://api.github.com/users/aloucks/gists{/gist_id}", "starred_url": "https://api.github.com/users/aloucks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aloucks/subscriptions", "organizations_url": "https://api.github.com/users/aloucks/orgs", "repos_url": "https://api.github.com/users/aloucks/repos", "events_url": "https://api.github.com/users/aloucks/events{/privacy}", "received_events_url": "https://api.github.com/users/aloucks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aloucks", "id": 221559, "node_id": "MDQ6VXNlcjIyMTU1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/221559?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aloucks", "html_url": "https://github.com/aloucks", "followers_url": "https://api.github.com/users/aloucks/followers", "following_url": "https://api.github.com/users/aloucks/following{/other_user}", "gists_url": "https://api.github.com/users/aloucks/gists{/gist_id}", "starred_url": "https://api.github.com/users/aloucks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aloucks/subscriptions", "organizations_url": "https://api.github.com/users/aloucks/orgs", "repos_url": "https://api.github.com/users/aloucks/repos", "events_url": "https://api.github.com/users/aloucks/events{/privacy}", "received_events_url": "https://api.github.com/users/aloucks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69ad879d52606ac03440744efa5b4d8ca8cc7566", "url": "https://api.github.com/repos/rust-lang/rust/commits/69ad879d52606ac03440744efa5b4d8ca8cc7566", "html_url": "https://github.com/rust-lang/rust/commit/69ad879d52606ac03440744efa5b4d8ca8cc7566"}], "stats": {"total": 153, "additions": 120, "deletions": 33}, "files": [{"sha": "4c621e7b5d20ac64ebe9a9e6baf43a6e013e6cb1", "filename": "Configurations.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=6ff2a5e0f3416a140f4e2df6fad0a135da7addc1", "patch": "@@ -1338,8 +1338,8 @@ fn main() {\n \n Unix or Windows line endings\n \n-- **Default value**: `\"Native\"`\n-- **Possible values**: `\"Native\"`, `\"Unix\"`, `\"Windows\"`\n+- **Default value**: `\"Auto\"`\n+- **Possible values**: `\"Auto\"`, `\"Native\"`, `\"Unix\"`, `\"Windows\"`\n - **Stable**: Yes\n \n ## `normalize_comments`"}, {"sha": "f240c7b13c68b1ffcf0df9f86a7ba3e0b0b3b085", "filename": "src/config/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=6ff2a5e0f3416a140f4e2df6fad0a135da7addc1", "patch": "@@ -39,7 +39,7 @@ create_config! {\n     max_width: usize, 100, true, \"Maximum width of each line\";\n     hard_tabs: bool, false, true, \"Use tab characters for indentation, spaces for alignment\";\n     tab_spaces: usize, 4, true, \"Number of spaces per tab\";\n-    newline_style: NewlineStyle, NewlineStyle::Native, true, \"Unix or Windows line endings\";\n+    newline_style: NewlineStyle, NewlineStyle::Auto, true, \"Unix or Windows line endings\";\n     use_small_heuristics: Heuristics, Heuristics::Default, true, \"Whether to use different \\\n         formatting for items and expressions if they satisfy a heuristic notion of 'small'\";\n     indent_style: IndentStyle, IndentStyle::Block, false, \"How do we indent expressions or items\";"}, {"sha": "f17e95e57e6f2862eadc9d673c9a26e5fdfaf4e1", "filename": "src/config/options.rs", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=6ff2a5e0f3416a140f4e2df6fad0a135da7addc1", "patch": "@@ -105,11 +105,68 @@ macro_rules! configuration_option_enum{\n }\n \n configuration_option_enum! { NewlineStyle:\n+    Auto, // Auto-detect based on the raw source input\n     Windows, // \\r\\n\n     Unix, // \\n\n     Native, // \\r\\n in Windows, \\n on other platforms\n }\n \n+impl NewlineStyle {\n+    fn auto_detect(raw_input_text: &str) -> NewlineStyle {\n+        if let Some(pos) = raw_input_text.find('\\n') {\n+            let pos = pos.saturating_sub(1);\n+            if let Some('\\r') = raw_input_text.chars().nth(pos) {\n+                NewlineStyle::Windows\n+            } else {\n+                NewlineStyle::Unix\n+            }\n+        } else {\n+            NewlineStyle::Native\n+        }\n+    }\n+\n+    fn native() -> NewlineStyle {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n+        } else {\n+            NewlineStyle::Unix\n+        }\n+    }\n+\n+    /// Apply this newline style to the formatted text. When the style is set\n+    /// to `Auto`, the `raw_input_text` is used to detect the existing line\n+    /// endings.\n+    ///\n+    /// If the style is set to `Auto` and `raw_input_text` contains no\n+    /// newlines, the `Native` style will be used.\n+    pub(crate) fn apply(self, formatted_text: &mut String, raw_input_text: &str) {\n+        use NewlineStyle::*;\n+        let mut style = self;\n+        if style == Auto {\n+            style = Self::auto_detect(raw_input_text);\n+        }\n+        if style == Native {\n+            style = Self::native();\n+        }\n+        match style {\n+            Windows => {\n+                let mut transformed = String::with_capacity(formatted_text.capacity());\n+                for c in formatted_text.chars() {\n+                    match c {\n+                        '\\n' => transformed.push_str(\"\\r\\n\"),\n+                        '\\r' => continue,\n+                        c => transformed.push(c),\n+                    }\n+                }\n+                *formatted_text = transformed;\n+            }\n+            Unix => return,\n+            Native => unreachable!(\"NewlineStyle::Native\"),\n+            Auto => unreachable!(\"NewlineStyle::Auto\"),\n+        }\n+    }\n+}\n+\n configuration_option_enum! { BraceStyle:\n     AlwaysNextLine,\n     PreferSameLine,\n@@ -367,3 +424,59 @@ impl Edition {\n         }\n     }\n }\n+\n+#[test]\n+fn test_newline_style_auto_detect() {\n+    let lf = \"One\\nTwo\\nThree\";\n+    let crlf = \"One\\r\\nTwo\\r\\nThree\";\n+    let none = \"One Two Three\";\n+\n+    assert_eq!(NewlineStyle::Unix, NewlineStyle::auto_detect(lf));\n+    assert_eq!(NewlineStyle::Windows, NewlineStyle::auto_detect(crlf));\n+    assert_eq!(NewlineStyle::Native, NewlineStyle::auto_detect(none));\n+}\n+\n+#[test]\n+fn test_newline_style_auto_apply() {\n+    let auto = NewlineStyle::Auto;\n+\n+    let formatted_text = \"One\\nTwo\\nThree\";\n+    let raw_input_text = \"One\\nTwo\\nThree\";\n+\n+    let mut out = String::from(formatted_text);\n+    auto.apply(&mut out, raw_input_text);\n+    assert_eq!(\"One\\nTwo\\nThree\", &out, \"auto should detect 'lf'\");\n+\n+    let formatted_text = \"One\\nTwo\\nThree\";\n+    let raw_input_text = \"One\\r\\nTwo\\r\\nThree\";\n+\n+    let mut out = String::from(formatted_text);\n+    auto.apply(&mut out, raw_input_text);\n+    assert_eq!(\"One\\r\\nTwo\\r\\nThree\", &out, \"auto should detect 'crlf'\");\n+\n+    #[cfg(not(windows))]\n+    {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One Two Three\";\n+\n+        let mut out = String::from(formatted_text);\n+        auto.apply(&mut out, raw_input_text);\n+        assert_eq!(\n+            \"One\\nTwo\\nThree\", &out,\n+            \"auto-native-unix should detect 'lf'\"\n+        );\n+    }\n+\n+    #[cfg(windows)]\n+    {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One Two Three\";\n+\n+        let mut out = String::from(formatted_text);\n+        auto.apply(&mut out, raw_input_text);\n+        assert_eq!(\n+            \"One\\r\\nTwo\\r\\nThree\", &out,\n+            \"auto-native-windows should detect 'crlf'\"\n+        );\n+    }\n+}"}, {"sha": "d29c93981745a06322fcf6e3c1bdb432d90d2f2c", "filename": "src/formatting.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ff2a5e0f3416a140f4e2df6fad0a135da7addc1/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=6ff2a5e0f3416a140f4e2df6fad0a135da7addc1", "patch": "@@ -13,7 +13,7 @@ use syntax::errors::Handler;\n use syntax::parse::{self, ParseSess};\n \n use comment::{CharClasses, FullCodeCharKind};\n-use config::{Config, FileName, NewlineStyle, Verbosity};\n+use config::{Config, FileName, Verbosity};\n use issues::BadIssueSeeker;\n use visitor::{FmtVisitor, SnippetProvider};\n use {filemap, modules, ErrorKind, FormatReport, Input, Session};\n@@ -166,7 +166,9 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             &self.config,\n             &self.report,\n         );\n-        replace_with_system_newlines(&mut visitor.buffer, &self.config);\n+        self.config\n+            .newline_style()\n+            .apply(&mut visitor.buffer, &big_snippet);\n \n         if visitor.macro_rewrite_failure {\n             self.report.add_macro_format_failure();\n@@ -645,34 +647,6 @@ fn make_parse_sess(codemap: Rc<CodeMap>, config: &Config) -> ParseSess {\n     ParseSess::with_span_handler(tty_handler, codemap)\n }\n \n-fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n-    let style = if config.newline_style() == NewlineStyle::Native {\n-        if cfg!(windows) {\n-            NewlineStyle::Windows\n-        } else {\n-            NewlineStyle::Unix\n-        }\n-    } else {\n-        config.newline_style()\n-    };\n-\n-    match style {\n-        NewlineStyle::Unix => return,\n-        NewlineStyle::Windows => {\n-            let mut transformed = String::with_capacity(text.capacity());\n-            for c in text.chars() {\n-                match c {\n-                    '\\n' => transformed.push_str(\"\\r\\n\"),\n-                    '\\r' => continue,\n-                    c => transformed.push(c),\n-                }\n-            }\n-            *text = transformed;\n-        }\n-        NewlineStyle::Native => unreachable!(),\n-    }\n-}\n-\n fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n where\n     F: Fn(),"}]}