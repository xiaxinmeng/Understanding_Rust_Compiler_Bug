{"sha": "2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "node_id": "C_kwDOAAsO6NoAKDJjNmU2NzEwNWU0OTY3ZjhiMzdlYmU5ZWQ5Mjg4MGM2NzczZWIyOWU", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-07-12T19:40:38Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-09-30T19:23:28Z"}, "message": "implement advance_(back_)_by on more iterators", "tree": {"sha": "0f88634848fe9037428999d266c14ec0ea0e61b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f88634848fe9037428999d266c14ec0ea0e61b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "html_url": "https://github.com/rust-lang/rust/commit/2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dc08b909b469d58dd8fa54c57ab193b8cf95257", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc08b909b469d58dd8fa54c57ab193b8cf95257", "html_url": "https://github.com/rust-lang/rust/commit/6dc08b909b469d58dd8fa54c57ab193b8cf95257"}], "stats": {"total": 379, "additions": 376, "deletions": 3}, "files": [{"sha": "ca41ce975e4fe421c042c039e2821039624617a1", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -111,6 +111,7 @@\n // that the feature-gate isn't enabled. Ideally, it wouldn't check for the feature gate for docs\n // from other crates, but since this can only appear for lang items, it doesn't seem worth fixing.\n #![feature(intra_doc_pointers)]\n+#![feature(iter_advance_by)]\n #![feature(iter_zip)]\n #![feature(lang_items)]\n #![feature(layout_for_ptr)]"}, {"sha": "eae9ad076dca06b80ee9f0ee1f17d80bb2b1b421", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -161,6 +161,28 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n         (exact, Some(exact))\n     }\n \n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let step_size = self.len().min(n);\n+        if mem::size_of::<T>() == 0 {\n+            // SAFETY: due to unchecked casts of unsigned amounts to signed offsets the wraparound\n+            // effectively results in unsigned pointers representing positions 0..usize::MAX,\n+            // which is valid for ZSTs.\n+            self.ptr = unsafe { arith_offset(self.ptr as *const i8, step_size as isize) as *mut T }\n+        } else {\n+            let to_drop = ptr::slice_from_raw_parts_mut(self.ptr as *mut T, step_size);\n+            // SAFETY: the min() above ensures that step_size is in bounds\n+            unsafe {\n+                self.ptr = self.ptr.add(step_size);\n+                ptr::drop_in_place(to_drop);\n+            }\n+        }\n+        if step_size < n {\n+            return Err(step_size);\n+        }\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn count(self) -> usize {\n         self.len()\n@@ -203,6 +225,29 @@ impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n             Some(unsafe { ptr::read(self.end) })\n         }\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let step_size = self.len().min(n);\n+        if mem::size_of::<T>() == 0 {\n+            // SAFETY: same as for advance_by()\n+            self.end = unsafe {\n+                arith_offset(self.end as *const i8, step_size.wrapping_neg() as isize) as *mut T\n+            }\n+        } else {\n+            // SAFETY: same as for advance_by()\n+            self.end = unsafe { self.end.offset(step_size.wrapping_neg() as isize) };\n+            let to_drop = ptr::slice_from_raw_parts_mut(self.end as *mut T, step_size);\n+            // SAFETY: same as for advance_by()\n+            unsafe {\n+                ptr::drop_in_place(to_drop);\n+            }\n+        }\n+        if step_size < n {\n+            return Err(step_size);\n+        }\n+        Ok(())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c6159539b48d0e2d51dae49869c521f413f70a92", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -18,6 +18,7 @@\n #![feature(binary_heap_retain)]\n #![feature(binary_heap_as_slice)]\n #![feature(inplace_iteration)]\n+#![feature(iter_advance_by)]\n #![feature(slice_group_by)]\n #![feature(slice_partition_dedup)]\n #![feature(vec_spare_capacity)]"}, {"sha": "00a878c079480b0e1a50f140d82b7ce9df157ec8", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -970,6 +970,24 @@ fn test_into_iter_leak() {\n     assert_eq!(unsafe { DROPS }, 3);\n }\n \n+#[test]\n+fn test_into_iter_advance_by() {\n+    let mut i = vec![1, 2, 3, 4, 5].into_iter();\n+    i.advance_by(0).unwrap();\n+    i.advance_back_by(0).unwrap();\n+    assert_eq!(i.as_slice(), [1, 2, 3, 4, 5]);\n+\n+    i.advance_by(1).unwrap();\n+    i.advance_back_by(1).unwrap();\n+    assert_eq!(i.as_slice(), [2, 3, 4]);\n+\n+    assert_eq!(i.advance_back_by(usize::MAX), Err(3));\n+\n+    assert_eq!(i.advance_by(usize::MAX), Err(0));\n+\n+    assert_eq!(i.len(), 0);\n+}\n+\n #[test]\n fn test_from_iter_specialization() {\n     let src: Vec<usize> = vec![0usize; 1];"}, {"sha": "e5f2886dcafadad5712125962ca5f9418fce1fa2", "filename": "library/core/src/iter/adapters/copied.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -76,6 +76,11 @@ where\n         self.it.count()\n     }\n \n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.it.advance_by(n)\n+    }\n+\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n     where\n@@ -112,6 +117,11 @@ where\n     {\n         self.it.rfold(init, copy_fold(f))\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.it.advance_back_by(n)\n+    }\n }\n \n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]"}, {"sha": "02b5939072ef07afe06bde0a614c171c70ec6d42", "filename": "library/core/src/iter/adapters/cycle.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -79,6 +79,27 @@ where\n         }\n     }\n \n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let mut rem = n;\n+        match self.iter.advance_by(rem) {\n+            ret @ Ok(_) => return ret,\n+            Err(advanced) => rem -= advanced,\n+        }\n+\n+        while rem > 0 {\n+            self.iter = self.orig.clone();\n+            match self.iter.advance_by(rem) {\n+                ret @ Ok(_) => return ret,\n+                Err(0) => return Err(n - rem),\n+                Err(advanced) => rem -= advanced,\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n     // and we can't do anything better than the default.\n }"}, {"sha": "c877b45095ace91f4a2ce8d507447f9ba000b55f", "filename": "library/core/src/iter/adapters/enumerate.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -112,6 +112,21 @@ where\n         self.iter.fold(init, enumerate(self.count, fold))\n     }\n \n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        match self.iter.advance_by(n) {\n+            ret @ Ok(_) => {\n+                self.count += n;\n+                ret\n+            }\n+            ret @ Err(advanced) => {\n+                self.count += advanced;\n+                ret\n+            }\n+        }\n+    }\n+\n     #[rustc_inherit_overflow_checks]\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n@@ -191,6 +206,13 @@ where\n         let count = self.count + self.iter.len();\n         self.iter.rfold(init, enumerate(count, fold))\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        // we do not need to update the count since that only tallies the number of items\n+        // consumed from the front. consuming items from the back can never reduce that.\n+        self.iter.advance_back_by(n)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e1d665bb2a177126886df01f0d951ce6b335102a", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -391,6 +391,40 @@ where\n \n         init\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let mut rem = n;\n+        loop {\n+            if let Some(ref mut front) = self.frontiter {\n+                match front.advance_by(rem) {\n+                    ret @ Ok(_) => return ret,\n+                    Err(advanced) => rem -= advanced,\n+                }\n+            }\n+            self.frontiter = match self.iter.next() {\n+                Some(iterable) => Some(iterable.into_iter()),\n+                _ => break,\n+            }\n+        }\n+\n+        self.frontiter = None;\n+\n+        if let Some(ref mut back) = self.backiter {\n+            if let Err(advanced) = back.advance_by(rem) {\n+                rem -= advanced\n+            }\n+        }\n+\n+        if rem > 0 {\n+            return Err(n - rem);\n+        }\n+\n+        self.backiter = None;\n+\n+        Ok(())\n+    }\n }\n \n impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n@@ -486,6 +520,41 @@ where\n \n         init\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let mut rem = n;\n+        loop {\n+            if let Some(ref mut back) = self.backiter {\n+                match back.advance_back_by(rem) {\n+                    ret @ Ok(_) => return ret,\n+                    Err(advanced) => rem -= advanced,\n+                }\n+            }\n+            match self.iter.next_back() {\n+                Some(iterable) => self.backiter = Some(iterable.into_iter()),\n+                _ => break,\n+            }\n+        }\n+\n+        self.backiter = None;\n+\n+        if let Some(ref mut front) = self.frontiter {\n+            match front.advance_back_by(rem) {\n+                ret @ Ok(_) => return ret,\n+                Err(advanced) => rem -= advanced,\n+            }\n+        }\n+\n+        if rem > 0 {\n+            return Err(n - rem);\n+        }\n+\n+        self.frontiter = None;\n+\n+        Ok(())\n+    }\n }\n \n trait ConstSizeIntoIterator: IntoIterator {"}, {"sha": "e29ff1291cf8d5fc3dbdf0c0caa9b563484db5de", "filename": "library/core/src/iter/adapters/skip.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -114,6 +114,17 @@ where\n         }\n         self.iter.fold(init, fold)\n     }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        if self.n >= n {\n+            self.n -= n;\n+            return Ok(());\n+        }\n+        let rem = n - self.n;\n+        self.n = 0;\n+        self.iter.advance_by(rem)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -174,6 +185,16 @@ where\n \n         self.try_rfold(init, ok(fold)).unwrap()\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let min = crate::cmp::min(self.len(), n);\n+        return match self.iter.advance_back_by(min) {\n+            ret @ Ok(_) if n <= min => ret,\n+            Ok(_) => Err(min),\n+            _ => panic!(\"ExactSizeIterator contract violation\"),\n+        };\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]"}, {"sha": "bff68339ddaf62d432b6fa124d622d56a2d04810", "filename": "library/core/src/iter/adapters/take.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -111,6 +111,22 @@ where\n \n         self.try_fold(init, ok(fold)).unwrap()\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let min = crate::cmp::min(self.n, n);\n+        return match self.iter.advance_by(min) {\n+            Ok(_) => {\n+                self.n -= min;\n+                if min < n { Err(min) } else { Ok(()) }\n+            }\n+            ret @ Err(advanced) => {\n+                self.n -= advanced;\n+                ret\n+            }\n+        };\n+    }\n }\n \n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n@@ -197,6 +213,24 @@ where\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let inner_len = self.iter.len();\n+        let len = self.n;\n+        let remainder = len.saturating_sub(n);\n+        let to_advance = inner_len - remainder;\n+        match self.iter.advance_back_by(to_advance) {\n+            Ok(_) => {\n+                self.n = remainder;\n+                if n > len {\n+                    return Err(len);\n+                }\n+                return Ok(());\n+            }\n+            _ => panic!(\"ExactSizeIterator contract violation\"),\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "06733a1b50b9198cf88c66ae0fb99e7848229523", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -521,10 +521,12 @@ trait RangeIteratorImpl {\n     // Iterator\n     fn spec_next(&mut self) -> Option<Self::Item>;\n     fn spec_nth(&mut self, n: usize) -> Option<Self::Item>;\n+    fn spec_advance_by(&mut self, n: usize) -> Result<(), usize>;\n \n     // DoubleEndedIterator\n     fn spec_next_back(&mut self) -> Option<Self::Item>;\n     fn spec_nth_back(&mut self, n: usize) -> Option<Self::Item>;\n+    fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize>;\n }\n \n impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n@@ -555,6 +557,22 @@ impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n         None\n     }\n \n+    #[inline]\n+    default fn spec_advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let available = if self.start <= self.end {\n+            Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n+        } else {\n+            0\n+        };\n+\n+        let taken = available.min(n);\n+\n+        self.start =\n+            Step::forward_checked(self.start.clone(), taken).expect(\"`Step` invariants not upheld\");\n+\n+        if taken < n { Err(taken) } else { Ok(()) }\n+    }\n+\n     #[inline]\n     default fn spec_next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n@@ -579,6 +597,22 @@ impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n         self.end = self.start.clone();\n         None\n     }\n+\n+    #[inline]\n+    default fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let available = if self.start <= self.end {\n+            Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n+        } else {\n+            0\n+        };\n+\n+        let taken = available.min(n);\n+\n+        self.end =\n+            Step::backward_checked(self.end.clone(), taken).expect(\"`Step` invariants not upheld\");\n+\n+        if taken < n { Err(taken) } else { Ok(()) }\n+    }\n }\n \n impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n@@ -607,6 +641,25 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n         None\n     }\n \n+    #[inline]\n+    fn spec_advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let available = if self.start <= self.end {\n+            Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n+        } else {\n+            0\n+        };\n+\n+        let taken = available.min(n);\n+\n+        // SAFETY: the conditions above ensure that the count is in bounds. If start <= end\n+        // then steps_between either returns a bound to which we clamp or returns None which\n+        // together with the initial inequality implies more than usize::MAX steps.\n+        // Otherwise 0 is returned which always safe to use.\n+        self.start = unsafe { Step::forward_unchecked(self.start.clone(), taken) };\n+\n+        if taken < n { Err(taken) } else { Ok(()) }\n+    }\n+\n     #[inline]\n     fn spec_next_back(&mut self) -> Option<T> {\n         if self.start < self.end {\n@@ -631,6 +684,22 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n         self.end = self.start.clone();\n         None\n     }\n+\n+    #[inline]\n+    fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let available = if self.start <= self.end {\n+            Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)\n+        } else {\n+            0\n+        };\n+\n+        let taken = available.min(n);\n+\n+        // SAFETY: same as the spec_advance_by() implementation\n+        self.end = unsafe { Step::backward_unchecked(self.end.clone(), taken) };\n+\n+        if taken < n { Err(taken) } else { Ok(()) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -677,6 +746,11 @@ impl<A: Step> Iterator for ops::Range<A> {\n         true\n     }\n \n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.spec_advance_by(n)\n+    }\n+\n     #[inline]\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n@@ -750,6 +824,11 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n         self.spec_nth_back(n)\n     }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.spec_advance_back_by(n)\n+    }\n }\n \n // Safety:"}, {"sha": "9a589c1f3b55c3fac8911291c5b8427a813b4fc1", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -103,9 +103,15 @@ pub trait DoubleEndedIterator: Iterator {\n     /// elements the iterator is advanced by before running out of elements (i.e. the length\n     /// of the iterator). Note that `k` is always less than `n`.\n     ///\n-    /// Calling `advance_back_by(0)` does not consume any elements and always returns [`Ok(())`].\n+    /// Calling `advance_back_by(0)` can do meaningful work, for example [`Flatten`] can advance its\n+    /// outer iterator until it finds an inner iterator that is not empty, which then often\n+    /// allows it to return a more accurate `size_hint()` than in its initial state.\n+    /// `advance_back_by(0)` may either return `Ok()` or `Err(0)`. The former conveys no information\n+    /// whether the iterator is or is not exhausted, the latter can be treated as if [`next_back`]\n+    /// had returned `None`. Replacing a `Err(0)` with `Ok` is only correct for `n = 0`.\n     ///\n     /// [`advance_by`]: Iterator::advance_by\n+    /// [`Flatten`]: crate::iter::Flatten\n     /// [`next_back`]: DoubleEndedIterator::next_back\n     ///\n     /// # Examples"}, {"sha": "e6b6aec7d943103353f03dd356911b5bda2d85bc", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -246,8 +246,14 @@ pub trait Iterator {\n     /// of elements the iterator is advanced by before running out of elements (i.e. the\n     /// length of the iterator). Note that `k` is always less than `n`.\n     ///\n-    /// Calling `advance_by(0)` does not consume any elements and always returns [`Ok(())`][Ok].\n-    ///\n+    /// Calling `advance_by(0)` can do meaningful work, for example [`Flatten`]\n+    /// can advance its outer iterator until it finds an inner iterator that is not empty, which\n+    /// then often allows it to return a more accurate `size_hint()` than in its initial state.\n+    /// `advance_by(0)` may either return `Ok()` or `Err(0)`. The former conveys no information\n+    /// whether the iterator is or is not exhausted, the latter can be treated as if [`next`]\n+    /// had returned `None`. Replacing a `Err(0)` with `Ok` is only correct for `n = 0`.\n+    ///\n+    /// [`Flatten`]: crate::iter::Flatten\n     /// [`next`]: Iterator::next\n     ///\n     /// # Examples"}, {"sha": "4ae50a2f06681582046d0add9cc74c250e9b6ec1", "filename": "library/core/tests/iter/adapters/flatten.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fflatten.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -58,6 +58,23 @@ fn test_flatten_try_folds() {\n     assert_eq!(iter.next_back(), Some(35));\n }\n \n+#[test]\n+fn test_flatten_advance_by() {\n+    let mut it = once(0..10).chain(once(10..30)).chain(once(30..40)).flatten();\n+    it.advance_by(5).unwrap();\n+    assert_eq!(it.next(), Some(5));\n+    it.advance_by(9).unwrap();\n+    assert_eq!(it.next(), Some(15));\n+    it.advance_back_by(4).unwrap();\n+    assert_eq!(it.next_back(), Some(35));\n+    it.advance_back_by(9).unwrap();\n+    assert_eq!(it.next_back(), Some(25));\n+\n+    assert_eq!(it.advance_by(usize::MAX), Err(9));\n+    assert_eq!(it.advance_back_by(usize::MAX), Err(0));\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+}\n+\n #[test]\n fn test_flatten_non_fused_outer() {\n     let mut iter = NonFused::new(once(0..2)).flatten();"}, {"sha": "6b4cf33efe1ff4574e6c9a3d376d3594da71caad", "filename": "library/core/tests/iter/range.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Ftests%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6e67105e4967f8b37ebe9ed92880c6773eb29e/library%2Fcore%2Ftests%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Frange.rs?ref=2c6e67105e4967f8b37ebe9ed92880c6773eb29e", "patch": "@@ -285,6 +285,29 @@ fn test_range_step() {\n     assert_eq!((isize::MIN..isize::MAX).step_by(1).size_hint(), (usize::MAX, Some(usize::MAX)));\n }\n \n+#[test]\n+fn test_range_advance_by() {\n+    let mut r = 0..usize::MAX;\n+    r.advance_by(0).unwrap();\n+    r.advance_back_by(0).unwrap();\n+\n+    assert_eq!(r.len(), usize::MAX);\n+\n+    r.advance_by(1).unwrap();\n+    r.advance_back_by(1).unwrap();\n+\n+    assert_eq!((r.start, r.end), (1, usize::MAX - 1));\n+\n+    assert_eq!(r.advance_by(usize::MAX), Err(usize::MAX - 2));\n+\n+    let mut r = 0u128..u128::MAX;\n+\n+    r.advance_by(usize::MAX).unwrap();\n+    r.advance_back_by(usize::MAX).unwrap();\n+\n+    assert_eq!((r.start, r.end), (0u128 + usize::MAX as u128, u128::MAX - usize::MAX as u128));\n+}\n+\n #[test]\n fn test_range_inclusive_step() {\n     assert_eq!((0..=50).step_by(10).collect::<Vec<_>>(), [0, 10, 20, 30, 40, 50]);"}]}