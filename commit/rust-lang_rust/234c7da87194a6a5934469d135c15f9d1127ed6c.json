{"sha": "234c7da87194a6a5934469d135c15f9d1127ed6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNGM3ZGE4NzE5NGE2YTU5MzQ0NjlkMTM1YzE1ZjlkMTEyN2VkNmM=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-09T07:43:22Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-09T07:45:25Z"}, "message": "Handle nested imports", "tree": {"sha": "94965a790027b8bcc74a0163dea3c3d361c8d24f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94965a790027b8bcc74a0163dea3c3d361c8d24f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/234c7da87194a6a5934469d135c15f9d1127ed6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/234c7da87194a6a5934469d135c15f9d1127ed6c", "html_url": "https://github.com/rust-lang/rust/commit/234c7da87194a6a5934469d135c15f9d1127ed6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/234c7da87194a6a5934469d135c15f9d1127ed6c/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4a569848e68ddcab4d2f59c1e052e7ac0e8e14c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a569848e68ddcab4d2f59c1e052e7ac0e8e14c", "html_url": "https://github.com/rust-lang/rust/commit/d4a569848e68ddcab4d2f59c1e052e7ac0e8e14c"}], "stats": {"total": 153, "additions": 87, "deletions": 66}, "files": [{"sha": "31021f3f0c99fd040d759c3c3864ac40ec77b939", "filename": "src/imports.rs", "status": "modified", "additions": 87, "deletions": 66, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/234c7da87194a6a5934469d135c15f9d1127ed6c/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/234c7da87194a6a5934469d135c15f9d1127ed6c/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=234c7da87194a6a5934469d135c15f9d1127ed6c", "patch": "@@ -53,8 +53,8 @@ fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree, nested: bool) -> Orderi\n \n     match (&a.kind, &b.kind) {\n         (&Simple(ident_a), &Simple(ident_b)) => {\n-            let name_a = &*a.prefix.segments.last().unwrap().identifier.name.as_str();\n-            let name_b = &*b.prefix.segments.last().unwrap().identifier.name.as_str();\n+            let name_a = &*path_to_imported_ident(&a.prefix).name.as_str();\n+            let name_b = &*path_to_imported_ident(&b.prefix).name.as_str();\n             let name_ordering = if name_a == \"self\" {\n                 if name_b == \"self\" {\n                     Ordering::Equal\n@@ -121,18 +121,15 @@ fn compare_use_items(context: &RewriteContext, a: &ast::Item, b: &ast::Item) ->\n // imports into a list import.\n \n fn rewrite_prefix(path: &ast::Path, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\"\n-        && path.segments.len() > 1\n-    {\n+    if path.segments.len() > 1 && path_to_imported_ident(path).to_string() == \"self\" {\n         let path = &ast::Path {\n             span: path.span,\n             segments: path.segments[..path.segments.len() - 1].to_owned(),\n         };\n-        rewrite_path(context, PathContext::Import, None, path, shape)?\n+        rewrite_path(context, PathContext::Import, None, path, shape)\n     } else {\n-        rewrite_path(context, PathContext::Import, None, path, shape)?\n-    };\n-    Some(path_str)\n+        rewrite_path(context, PathContext::Import, None, path, shape)\n+    }\n }\n \n impl Rewrite for ast::UseTree {\n@@ -155,10 +152,16 @@ impl Rewrite for ast::UseTree {\n                 let ident_str = ident.to_string();\n \n                 // 4 = \" as \".len()\n-                let prefix_shape = shape.sub_width(ident_str.len() + 4)?;\n-                let path_str = rewrite_prefix(&self.prefix, context, prefix_shape)?;\n+                let is_same_name_bind = path_to_imported_ident(&self.prefix) == ident;\n+                let prefix_shape = if is_same_name_bind {\n+                    shape\n+                } else {\n+                    shape.sub_width(ident_str.len() + 4)?\n+                };\n+                let path_str = rewrite_prefix(&self.prefix, context, prefix_shape)\n+                    .unwrap_or_else(|| context.snippet(self.prefix.span).to_owned());\n \n-                if self.prefix.segments.last().unwrap().identifier == ident {\n+                if is_same_name_bind {\n                     Some(path_str)\n                 } else {\n                     Some(format!(\"{} as {}\", path_str, ident_str))\n@@ -168,6 +171,21 @@ impl Rewrite for ast::UseTree {\n     }\n }\n \n+fn is_unused_import(tree: &ast::UseTree, attrs: &[ast::Attribute]) -> bool {\n+    attrs.is_empty() && is_unused_import_inner(tree)\n+}\n+\n+fn is_unused_import_inner(tree: &ast::UseTree) -> bool {\n+    match tree.kind {\n+        ast::UseTreeKind::Nested(ref items) => match items.len() {\n+            0 => true,\n+            1 => is_unused_import_inner(&items[0].0),\n+            _ => false,\n+        },\n+        _ => false,\n+    }\n+}\n+\n // Rewrite `use foo;` WITHOUT attributes.\n fn rewrite_import(\n     context: &RewriteContext,\n@@ -181,12 +199,13 @@ fn rewrite_import(\n     let rw = shape\n         .offset_left(vis.len() + 4)\n         .and_then(|shape| shape.sub_width(1))\n-        .and_then(|shape| match tree.kind {\n+        .and_then(|shape| {\n             // If we have an empty nested group with no attributes, we erase it\n-            ast::UseTreeKind::Nested(ref items) if items.is_empty() && attrs.is_empty() => {\n+            if is_unused_import(tree, attrs) {\n                 Some(\"\".to_owned())\n+            } else {\n+                tree.rewrite(context, shape)\n             }\n-            _ => tree.rewrite(context, shape),\n         });\n     match rw {\n         Some(ref s) if !s.is_empty() => Some(format!(\"{}use {};\", vis, s)),\n@@ -296,48 +315,45 @@ impl<'a> FmtVisitor<'a> {\n     }\n }\n \n-fn rewrite_nested_use_tree_single(path_str: String, tree: &ast::UseTree) -> String {\n-    if let ast::UseTreeKind::Simple(rename) = tree.kind {\n-        let ident = tree.prefix.segments.last().unwrap().identifier;\n-        let mut item_str = ident.name.to_string();\n-        if item_str == \"self\" {\n-            item_str = \"\".to_owned();\n-        }\n+fn rewrite_nested_use_tree_single(\n+    context: &RewriteContext,\n+    path_str: &str,\n+    tree: &ast::UseTree,\n+    shape: Shape,\n+) -> Option<String> {\n+    match tree.kind {\n+        ast::UseTreeKind::Simple(rename) => {\n+            let ident = path_to_imported_ident(&tree.prefix);\n+            let mut item_str = rewrite_prefix(&tree.prefix, context, shape)?;\n+            if item_str == \"self\" {\n+                item_str = \"\".to_owned();\n+            }\n \n-        let path_item_str = if path_str.is_empty() {\n-            if item_str.is_empty() {\n-                \"self\".to_owned()\n+            let path_item_str = if path_str.is_empty() {\n+                if item_str.is_empty() {\n+                    \"self\".to_owned()\n+                } else {\n+                    item_str\n+                }\n+            } else if item_str.is_empty() {\n+                path_str.to_owned()\n             } else {\n-                item_str\n-            }\n-        } else if item_str.is_empty() {\n-            path_str\n-        } else {\n-            format!(\"{}::{}\", path_str, item_str)\n-        };\n+                format!(\"{}::{}\", path_str, item_str)\n+            };\n \n-        if ident == rename {\n-            path_item_str\n-        } else {\n-            format!(\"{} as {}\", path_item_str, rename)\n+            Some(if ident == rename {\n+                path_item_str\n+            } else {\n+                format!(\"{} as {}\", path_item_str, rename)\n+            })\n         }\n-    } else {\n-        unimplemented!(\"`use_nested_groups` is not yet fully supported\");\n-    }\n-}\n-\n-fn rewrite_nested_use_tree_item(tree: &&ast::UseTree) -> Option<String> {\n-    Some(if let ast::UseTreeKind::Simple(rename) = tree.kind {\n-        let ident = tree.prefix.segments.last().unwrap().identifier;\n-\n-        if ident == rename {\n-            ident.name.to_string()\n-        } else {\n-            format!(\"{} as {}\", ident.name.to_string(), rename)\n+        ast::UseTreeKind::Glob | ast::UseTreeKind::Nested(..) => {\n+            // 2 = \"::\"\n+            let nested_shape = shape.offset_left(path_str.len() + 2)?;\n+            tree.rewrite(context, nested_shape)\n+                .map(|item| format!(\"{}::{}\", path_str, item))\n         }\n-    } else {\n-        unimplemented!(\"`use_nested_groups` is not yet fully supported\");\n-    })\n+    }\n }\n \n #[derive(Eq, PartialEq)]\n@@ -426,11 +442,13 @@ fn rewrite_nested_use_tree(\n \n     match trees.len() {\n         0 => {\n+            let shape = shape.offset_left(path_str.len() + 3)?;\n             return rewrite_path(context, PathContext::Import, None, path, shape)\n                 .map(|path_str| format!(\"{}::{{}}\", path_str));\n         }\n-        // TODO: fix this\n-        1 => return Some(rewrite_nested_use_tree_single(path_str, &trees[0].0)),\n+        1 => {\n+            return rewrite_nested_use_tree_single(context, &path_str, &trees[0].0, shape);\n+        }\n         _ => (),\n     }\n \n@@ -442,6 +460,16 @@ fn rewrite_nested_use_tree(\n \n     // 2 = \"{}\"\n     let remaining_width = shape.width.checked_sub(path_str.len() + 2).unwrap_or(0);\n+    let nested_indent = match context.config.imports_indent() {\n+        IndentStyle::Block => shape.indent.block_indent(context.config),\n+        // 1 = `{`\n+        IndentStyle::Visual => shape.visual_indent(path_str.len() + 1).indent,\n+    };\n+\n+    let nested_shape = match context.config.imports_indent() {\n+        IndentStyle::Block => Shape::indented(nested_indent, context.config).sub_width(1)?,\n+        IndentStyle::Visual => Shape::legacy(remaining_width, nested_indent),\n+    };\n \n     let mut items = {\n         // Dummy value, see explanation below.\n@@ -453,7 +481,7 @@ fn rewrite_nested_use_tree(\n             \",\",\n             |tree| tree.span.lo(),\n             |tree| tree.span.hi(),\n-            rewrite_nested_use_tree_item,\n+            |tree| tree.rewrite(context, nested_shape),\n             context.codemap.span_after(span, \"{\"),\n             span.hi(),\n             false,\n@@ -483,17 +511,6 @@ fn rewrite_nested_use_tree(\n         remaining_width,\n     );\n \n-    let nested_indent = match context.config.imports_indent() {\n-        IndentStyle::Block => shape.indent.block_indent(context.config),\n-        // 1 = `{`\n-        IndentStyle::Visual => shape.visual_indent(path_str.len() + 1).indent,\n-    };\n-\n-    let nested_shape = match context.config.imports_indent() {\n-        IndentStyle::Block => Shape::indented(nested_indent, context.config),\n-        IndentStyle::Visual => Shape::legacy(remaining_width, nested_indent),\n-    };\n-\n     let ends_with_newline = context.config.imports_indent() == IndentStyle::Block\n         && tactic != DefinitiveListTactic::Horizontal;\n \n@@ -541,3 +558,7 @@ fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n         None => false,\n     }\n }\n+\n+fn path_to_imported_ident(path: &ast::Path) -> ast::Ident {\n+    path.segments.last().unwrap().identifier\n+}"}]}