{"sha": "fbc6f2c70cf3d3cc3722cbd194e600d560d40758", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYzZmMmM3MGNmM2QzY2MzNzIyY2JkMTk0ZTYwMGQ1NjBkNDA3NTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-14T08:30:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-23T23:03:19Z"}, "message": "make some cast helpers infallible", "tree": {"sha": "2ecd469a3d3ef22b79c9f7f76369aae59dfd0ad6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ecd469a3d3ef22b79c9f7f76369aae59dfd0ad6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc6f2c70cf3d3cc3722cbd194e600d560d40758", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc6f2c70cf3d3cc3722cbd194e600d560d40758", "html_url": "https://github.com/rust-lang/rust/commit/fbc6f2c70cf3d3cc3722cbd194e600d560d40758", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc6f2c70cf3d3cc3722cbd194e600d560d40758/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75b0a68f35a06fc7aed8aa95831df8eace4afffb", "url": "https://api.github.com/repos/rust-lang/rust/commits/75b0a68f35a06fc7aed8aa95831df8eace4afffb", "html_url": "https://github.com/rust-lang/rust/commit/75b0a68f35a06fc7aed8aa95831df8eace4afffb"}], "stats": {"total": 46, "additions": 17, "deletions": 29}, "files": [{"sha": "c1ba9ae83dbba35fe32482225082029ec51e9352", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fbc6f2c70cf3d3cc3722cbd194e600d560d40758/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc6f2c70cf3d3cc3722cbd194e600d560d40758/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=fbc6f2c70cf3d3cc3722cbd194e600d560d40758", "patch": "@@ -106,14 +106,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match src.layout.ty.kind {\n             // Floating point\n             Float(FloatTy::F32) => {\n-                return Ok(self\n-                    .cast_from_float(src.to_scalar()?.to_f32()?, dest_layout.ty)?\n-                    .into());\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, dest_layout.ty).into());\n             }\n             Float(FloatTy::F64) => {\n-                return Ok(self\n-                    .cast_from_float(src.to_scalar()?.to_f64()?, dest_layout.ty)?\n-                    .into());\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, dest_layout.ty).into());\n             }\n             // The rest is integer/pointer-\"like\", including fn ptr casts and casts from enums that\n             // are represented as integers.\n@@ -135,7 +131,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     assert!(src.layout.is_zst());\n                     let discr_layout = self.layout_of(discr.ty)?;\n                     return Ok(self\n-                        .cast_from_int_like(discr.val, discr_layout, dest_layout)?\n+                        .cast_from_int_like(discr.val, discr_layout, dest_layout)\n                         .into());\n                 }\n             }\n@@ -173,15 +169,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // (b) cast from an integer-like (including bool, char, enums).\n         // In both cases we want the bits.\n         let bits = self.force_bits(src.to_scalar()?, src.layout.size)?;\n-        Ok(self.cast_from_int_like(bits, src.layout, dest_layout)?.into())\n+        Ok(self.cast_from_int_like(bits, src.layout, dest_layout).into())\n     }\n \n-    fn cast_from_int_like(\n+    pub(super) fn cast_from_int_like(\n         &self,\n         v: u128, // raw bits\n         src_layout: TyAndLayout<'tcx>,\n         dest_layout: TyAndLayout<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> Scalar<M::PointerTag> {\n         // Let's make sure v is sign-extended *if* it has a signed type.\n         let signed = src_layout.abi.is_signed();\n         let v = if signed { self.sign_extend(v, src_layout) } else { v };\n@@ -190,33 +186,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match dest_layout.ty.kind {\n             Int(_) | Uint(_) | RawPtr(_) => {\n                 let v = self.truncate(v, dest_layout);\n-                Ok(Scalar::from_uint(v, dest_layout.size))\n+                Scalar::from_uint(v, dest_layout.size)\n             }\n \n-            Float(FloatTy::F32) if signed => {\n-                Ok(Scalar::from_f32(Single::from_i128(v as i128).value))\n-            }\n-            Float(FloatTy::F64) if signed => {\n-                Ok(Scalar::from_f64(Double::from_i128(v as i128).value))\n-            }\n-            Float(FloatTy::F32) => Ok(Scalar::from_f32(Single::from_u128(v).value)),\n-            Float(FloatTy::F64) => Ok(Scalar::from_f64(Double::from_u128(v).value)),\n+            Float(FloatTy::F32) if signed => Scalar::from_f32(Single::from_i128(v as i128).value),\n+            Float(FloatTy::F64) if signed => Scalar::from_f64(Double::from_i128(v as i128).value),\n+            Float(FloatTy::F32) => Scalar::from_f32(Single::from_u128(v).value),\n+            Float(FloatTy::F64) => Scalar::from_f64(Double::from_u128(v).value),\n \n             Char => {\n                 // `u8` to `char` cast\n-                Ok(Scalar::from_u32(u8::try_from(v).unwrap().into()))\n+                Scalar::from_u32(u8::try_from(v).unwrap().into())\n             }\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n             _ => bug!(\"invalid int to {:?} cast\", dest_layout.ty),\n         }\n     }\n \n-    fn cast_from_float<F>(\n-        &self,\n-        f: F,\n-        dest_ty: Ty<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>>\n+    fn cast_from_float<F>(&self, f: F, dest_ty: Ty<'tcx>) -> Scalar<M::PointerTag>\n     where\n         F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>,\n     {\n@@ -229,20 +217,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n                 let v = f.to_u128(usize::try_from(width).unwrap()).value;\n                 // This should already fit the bit width\n-                Ok(Scalar::from_uint(v, Size::from_bits(width)))\n+                Scalar::from_uint(v, Size::from_bits(width))\n             }\n             // float -> int\n             Int(t) => {\n                 let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n                 // `to_i128` is a saturating cast, which is what we need\n                 // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n                 let v = f.to_i128(usize::try_from(width).unwrap()).value;\n-                Ok(Scalar::from_int(v, Size::from_bits(width)))\n+                Scalar::from_int(v, Size::from_bits(width))\n             }\n             // float -> f32\n-            Float(FloatTy::F32) => Ok(Scalar::from_f32(f.convert(&mut false).value)),\n+            Float(FloatTy::F32) => Scalar::from_f32(f.convert(&mut false).value),\n             // float -> f64\n-            Float(FloatTy::F64) => Ok(Scalar::from_f64(f.convert(&mut false).value)),\n+            Float(FloatTy::F64) => Scalar::from_f64(f.convert(&mut false).value),\n             // That's it.\n             _ => bug!(\"invalid float to {:?} cast\", dest_ty),\n         }"}]}