{"sha": "f37f9f6512cb6b295acb70938302704a80c29b2b", "node_id": "C_kwDOAAsO6NoAKGYzN2Y5ZjY1MTJjYjZiMjk1YWNiNzA5MzgzMDI3MDRhODBjMjliMmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-25T23:15:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-25T23:15:10Z"}, "message": "Auto merge of #108464 - compiler-errors:rollup-trl1g70, r=compiler-errors\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #105736 (Test that the compiler/library builds with validate-mir)\n - #107291 ([breaking change] Remove a rustdoc back compat warning)\n - #107675 (Implement -Zlink-directives=yes/no)\n - #107848 (Split `x setup` sub-actions to CLI arguments)\n - #107911 (Add check for invalid #[macro_export] arguments)\n - #108229 ([107049] Recognise top level keys in config.toml.example)\n - #108333 (Make object bound candidates sound in the new trait solver)\n\nFailed merges:\n\n - #108337 (hir-analysis: make a helpful note)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "95a91876287f79681be0f0bb7b6e563d4c95e331", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95a91876287f79681be0f0bb7b6e563d4c95e331"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f37f9f6512cb6b295acb70938302704a80c29b2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f37f9f6512cb6b295acb70938302704a80c29b2b", "html_url": "https://github.com/rust-lang/rust/commit/f37f9f6512cb6b295acb70938302704a80c29b2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f37f9f6512cb6b295acb70938302704a80c29b2b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34e6673a0473e90ef01a18eb575392c9e3859747", "url": "https://api.github.com/repos/rust-lang/rust/commits/34e6673a0473e90ef01a18eb575392c9e3859747", "html_url": "https://github.com/rust-lang/rust/commit/34e6673a0473e90ef01a18eb575392c9e3859747"}, {"sha": "4723a9ad14ae7d0948311a883da4ef72422a6481", "url": "https://api.github.com/repos/rust-lang/rust/commits/4723a9ad14ae7d0948311a883da4ef72422a6481", "html_url": "https://github.com/rust-lang/rust/commit/4723a9ad14ae7d0948311a883da4ef72422a6481"}], "stats": {"total": 692, "additions": 627, "deletions": 65}, "files": [{"sha": "da58492ccf27c6bbe76c4ff327fd2cfaaaa3e1bd", "filename": "compiler/rustc_interface/locales/en-US.ftl", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -11,10 +11,6 @@ interface_mixed_bin_crate =\n interface_mixed_proc_macro_crate =\n     cannot mix `proc-macro` crate type with others\n \n-interface_proc_macro_doc_without_arg =\n-    Trying to document proc macro crate without passing '--crate-type proc-macro to rustdoc\n-    .warn = The generated documentation may be incorrect\n-\n interface_error_writing_dependencies =\n     error writing dependencies to `{$path}`: {$error}\n "}, {"sha": "0eedee250269e4cfc0481b57996b558574142430", "filename": "compiler/rustc_interface/src/errors.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -31,10 +31,6 @@ pub struct MixedBinCrate;\n #[diag(interface_mixed_proc_macro_crate)]\n pub struct MixedProcMacroCrate;\n \n-#[derive(Diagnostic)]\n-#[diag(interface_proc_macro_doc_without_arg)]\n-pub struct ProcMacroDocWithoutArg;\n-\n #[derive(Diagnostic)]\n #[diag(interface_error_writing_dependencies)]\n pub struct ErrorWritingDependencies<'a> {"}, {"sha": "81c1d665ef0726a60e8061b64673444f2f134792", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -287,28 +287,18 @@ fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>)\n         sess.emit_warning(errors::ProcMacroCratePanicAbort);\n     }\n \n-    // For backwards compatibility, we don't try to run proc macro injection\n-    // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being\n-    // specified. This should only affect users who manually invoke 'rustdoc', as\n-    // 'cargo doc' will automatically pass the proper '--crate-type' flags.\n-    // However, we do emit a warning, to let such users know that they should\n-    // start passing '--crate-type proc-macro'\n-    if has_proc_macro_decls && sess.opts.actually_rustdoc && !is_proc_macro_crate {\n-        sess.emit_warning(errors::ProcMacroDocWithoutArg);\n-    } else {\n-        krate = sess.time(\"maybe_create_a_macro_crate\", || {\n-            let is_test_crate = sess.opts.test;\n-            rustc_builtin_macros::proc_macro_harness::inject(\n-                sess,\n-                resolver,\n-                krate,\n-                is_proc_macro_crate,\n-                has_proc_macro_decls,\n-                is_test_crate,\n-                sess.diagnostic(),\n-            )\n-        });\n-    }\n+    krate = sess.time(\"maybe_create_a_macro_crate\", || {\n+        let is_test_crate = sess.opts.test;\n+        rustc_builtin_macros::proc_macro_harness::inject(\n+            sess,\n+            resolver,\n+            krate,\n+            is_proc_macro_crate,\n+            has_proc_macro_decls,\n+            is_test_crate,\n+            sess.diagnostic(),\n+        )\n+    });\n \n     // Done with macro expansion!\n "}, {"sha": "18d84a7023aa14ef4ca7a0f00c320db9456264ba", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -756,6 +756,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(instrument_coverage, Some(InstrumentCoverage::All));\n     tracked!(instrument_mcount, true);\n     tracked!(instrument_xray, Some(InstrumentXRay::default()));\n+    tracked!(link_directives, false);\n     tracked!(link_only, true);\n     tracked!(llvm_plugins, vec![String::from(\"plugin_name\")]);\n     tracked!(location_detail, LocationDetail { file: true, line: false, column: false });"}, {"sha": "46ec1a2dca1f7e22437e8eac90a373229454f159", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -4103,3 +4103,33 @@ declare_lint! {\n     };\n     report_in_external_macro\n }\n+\n+declare_lint! {\n+    /// The `invalid_macro_export_arguments` lint detects cases where `#[macro_export]` is being used with invalid arguments.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(invalid_macro_export_arguments)]\n+    ///\n+    /// #[macro_export(invalid_parameter)]\n+    /// macro_rules! myMacro {\n+    ///    () => {\n+    ///         // [...]\n+    ///    }\n+    /// }\n+    ///\n+    /// #[macro_export(too, many, items)]\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The only valid argument is `#[macro_export(local_inner_macros)]` or no argument (`#[macro_export]`).\n+    /// You can't have multiple arguments in a `#[macro_export(..)]`, or mention arguments other than `local_inner_macros`.\n+    ///\n+    pub INVALID_MACRO_EXPORT_ARGUMENTS,\n+    Warn,\n+    \"\\\"invalid_parameter\\\" isn't a valid argument for `#[macro_export]`\",\n+}"}, {"sha": "d6f68b2e140553e79cafe1b16e2ca7911e97400b", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -103,8 +103,13 @@ impl<'tcx> Collector<'tcx> {\n         }\n \n         // Process all of the #[link(..)]-style arguments\n-        let sess = &self.tcx.sess;\n+        let sess = self.tcx.sess;\n         let features = self.tcx.features();\n+\n+        if !sess.opts.unstable_opts.link_directives {\n+            return;\n+        }\n+\n         for m in self.tcx.hir().attrs(it.hir_id()).iter().filter(|a| a.has_name(sym::link)) {\n             let Some(items) = m.meta_item_list() else {\n                 continue;"}, {"sha": "0ed29ce0d479578b3b51aea939e2d4e924607386", "filename": "compiler/rustc_passes/locales/en-US.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_passes%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_passes%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Flocales%2Fen-US.ftl?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -745,3 +745,7 @@ passes_proc_macro_invalid_abi = proc macro functions may not be `extern \"{$abi}\"\n passes_proc_macro_unsafe = proc macro functions may not be `unsafe`\n \n passes_skipping_const_checks = skipping const checks\n+\n+passes_invalid_macro_export_arguments = `{$name}` isn't a valid `#[macro_export]` argument\n+\n+passes_invalid_macro_export_arguments_too_many_items = `#[macro_export]` can only take 1 or 0 arguments"}, {"sha": "5ef3e13eff801ce37c30717788e4906e6e640656", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -23,7 +23,8 @@ use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_session::lint::builtin::{\n-    CONFLICTING_REPR_HINTS, INVALID_DOC_ATTRIBUTES, UNUSED_ATTRIBUTES,\n+    CONFLICTING_REPR_HINTS, INVALID_DOC_ATTRIBUTES, INVALID_MACRO_EXPORT_ARGUMENTS,\n+    UNUSED_ATTRIBUTES,\n };\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -2102,7 +2103,33 @@ impl CheckAttrVisitor<'_> {\n \n     fn check_macro_export(&self, hir_id: HirId, attr: &Attribute, target: Target) {\n         if target != Target::MacroDef {\n-            self.tcx.emit_spanned_lint(UNUSED_ATTRIBUTES, hir_id, attr.span, errors::MacroExport);\n+            self.tcx.emit_spanned_lint(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                attr.span,\n+                errors::MacroExport::Normal,\n+            );\n+        } else if let Some(meta_item_list) = attr.meta_item_list() &&\n+        !meta_item_list.is_empty() {\n+            if meta_item_list.len() > 1 {\n+                self.tcx.emit_spanned_lint(\n+                    INVALID_MACRO_EXPORT_ARGUMENTS,\n+                    hir_id,\n+                    attr.span,\n+                    errors::MacroExport::TooManyItems,\n+                );\n+            } else {\n+                if meta_item_list[0].name_or_empty() != sym::local_inner_macros {\n+                    self.tcx.emit_spanned_lint(\n+                        INVALID_MACRO_EXPORT_ARGUMENTS,\n+                        hir_id,\n+                        meta_item_list[0].span(),\n+                        errors::MacroExport::UnknownItem {\n+                            name: meta_item_list[0].name_or_empty(),\n+                        },\n+                    );\n+                }\n+            }\n         }\n     }\n "}, {"sha": "2c0d21b479848c75d7e5186a01afa3667ec33eb8", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -641,8 +641,16 @@ pub struct MacroUse {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes_macro_export)]\n-pub struct MacroExport;\n+pub enum MacroExport {\n+    #[diag(passes_macro_export)]\n+    Normal,\n+\n+    #[diag(passes_invalid_macro_export_arguments)]\n+    UnknownItem { name: Symbol },\n+\n+    #[diag(passes_invalid_macro_export_arguments_too_many_items)]\n+    TooManyItems,\n+}\n \n #[derive(LintDiagnostic)]\n #[diag(passes_plugin_registrar)]"}, {"sha": "4beac931632bec350d75f7de385904992f42dcc3", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -1489,6 +1489,8 @@ options! {\n         \"keep hygiene data after analysis (default: no)\"),\n     layout_seed: Option<u64> = (None, parse_opt_number, [TRACKED],\n         \"seed layout randomization\"),\n+    link_directives: bool = (true, parse_bool, [TRACKED],\n+        \"honor #[link] directives in the compiled crate (default: yes)\"),\n     link_native_libraries: bool = (true, parse_bool, [UNTRACKED],\n         \"link native libraries in the linker invocation (default: yes)\"),\n     link_only: bool = (false, parse_bool, [TRACKED],"}, {"sha": "dec9f8016b0c18845d2ae581c0eada8915de7e50", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -99,6 +99,15 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx>;\n \n+    // Consider a clause specifically for a `dyn Trait` self type. This requires\n+    // additionally checking all of the supertraits and object bounds to hold,\n+    // since they're not implied by the well-formedness of the object type.\n+    fn consider_object_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n@@ -455,7 +464,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         for assumption in\n             elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n         {\n-            match G::consider_implied_clause(self, goal, assumption.predicate, []) {\n+            match G::consider_object_bound_candidate(self, goal, assumption.predicate) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "88fd8bb8bd095ca111b723f20c25d2270a243371", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -128,6 +128,51 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_object_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n+            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        {\n+            ecx.probe(|ecx| {\n+                let assumption_projection_pred =\n+                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n+                let mut nested_goals = ecx.eq(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+\n+                let tcx = ecx.tcx();\n+                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+                nested_goals.extend(\n+                    structural_traits::predicates_for_object_candidate(\n+                        ecx,\n+                        goal.param_env,\n+                        goal.predicate.projection_ty.trait_ref(tcx),\n+                        bounds,\n+                    )\n+                    .into_iter()\n+                    .map(|pred| goal.with(tcx, pred)),\n+                );\n+\n+                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n+\n+                ecx.eq_term_and_make_canonical_response(\n+                    goal,\n+                    subst_certainty,\n+                    assumption_projection_pred.term,\n+                )\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,"}, {"sha": "5c499c36e9bf4686b239734410b73c21f2339fbc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -86,6 +86,46 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n     }\n \n+    fn consider_object_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n+            && poly_trait_pred.def_id() == goal.predicate.def_id()\n+        {\n+            // FIXME: Constness and polarity\n+            ecx.probe(|ecx| {\n+                let assumption_trait_pred =\n+                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n+                let mut nested_goals = ecx.eq(\n+                    goal.param_env,\n+                    goal.predicate.trait_ref,\n+                    assumption_trait_pred.trait_ref,\n+                )?;\n+\n+                let tcx = ecx.tcx();\n+                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+                nested_goals.extend(\n+                    structural_traits::predicates_for_object_candidate(\n+                        ecx,\n+                        goal.param_env,\n+                        goal.predicate.trait_ref,\n+                        bounds,\n+                    )\n+                    .into_iter()\n+                    .map(|pred| goal.with(tcx, pred)),\n+                );\n+\n+                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_auto_trait_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,"}, {"sha": "f7d1b4be74bf833ec7256705aba67e090b5a0396", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals/structural_traits.rs", "status": "modified", "additions": 112, "deletions": 2, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals%2Fstructural_traits.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -1,6 +1,7 @@\n-use rustc_hir::{Movability, Mutability};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{def_id::DefId, Movability, Mutability};\n use rustc_infer::traits::query::NoSolution;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable};\n \n use crate::solve::EvalCtxt;\n \n@@ -231,3 +232,112 @@ pub(crate) fn extract_tupled_inputs_and_output_from_callable<'tcx>(\n         }\n     }\n }\n+\n+/// Assemble a list of predicates that would be present on a theoretical\n+/// user impl for an object type. These predicates must be checked any time\n+/// we assemble a built-in object candidate for an object type, since they\n+/// are not implied by the well-formedness of the type.\n+///\n+/// For example, given the following traits:\n+///\n+/// ```rust,ignore (theoretical code)\n+/// trait Foo: Baz {\n+///     type Bar: Copy;\n+/// }\n+///\n+/// trait Baz {}\n+/// ```\n+///\n+/// For the dyn type `dyn Foo<Item = Ty>`, we can imagine there being a\n+/// pair of theoretical impls:\n+///\n+/// ```rust,ignore (theoretical code)\n+/// impl Foo for dyn Foo<Item = Ty>\n+/// where\n+///     Self: Baz,\n+///     <Self as Foo>::Bar: Copy,\n+/// {\n+///     type Bar = Ty;\n+/// }\n+///\n+/// impl Baz for dyn Foo<Item = Ty> {}\n+/// ```\n+///\n+/// However, in order to make such impls well-formed, we need to do an\n+/// additional step of eagerly folding the associated types in the where\n+/// clauses of the impl. In this example, that means replacing\n+/// `<Self as Foo>::Bar` with `Ty` in the first impl.\n+pub(crate) fn predicates_for_object_candidate<'tcx>(\n+    ecx: &EvalCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+    object_bound: &'tcx ty::List<ty::PolyExistentialPredicate<'tcx>>,\n+) -> Vec<ty::Predicate<'tcx>> {\n+    let tcx = ecx.tcx();\n+    let mut requirements = vec![];\n+    requirements.extend(\n+        tcx.super_predicates_of(trait_ref.def_id).instantiate(tcx, trait_ref.substs).predicates,\n+    );\n+    for item in tcx.associated_items(trait_ref.def_id).in_definition_order() {\n+        // FIXME(associated_const_equality): Also add associated consts to\n+        // the requirements here.\n+        if item.kind == ty::AssocKind::Type {\n+            requirements.extend(tcx.item_bounds(item.def_id).subst(tcx, trait_ref.substs));\n+        }\n+    }\n+\n+    let mut replace_projection_with = FxHashMap::default();\n+    for bound in object_bound {\n+        if let ty::ExistentialPredicate::Projection(proj) = bound.skip_binder() {\n+            let proj = proj.with_self_ty(tcx, trait_ref.self_ty());\n+            let old_ty = replace_projection_with.insert(proj.def_id(), bound.rebind(proj));\n+            assert_eq!(\n+                old_ty,\n+                None,\n+                \"{} has two substitutions: {} and {}\",\n+                proj.projection_ty,\n+                proj.term,\n+                old_ty.unwrap()\n+            );\n+        }\n+    }\n+\n+    requirements.fold_with(&mut ReplaceProjectionWith {\n+        ecx,\n+        param_env,\n+        mapping: replace_projection_with,\n+    })\n+}\n+\n+struct ReplaceProjectionWith<'a, 'tcx> {\n+    ecx: &'a EvalCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    mapping: FxHashMap<DefId, ty::PolyProjectionPredicate<'tcx>>,\n+}\n+\n+impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ReplaceProjectionWith<'_, 'tcx> {\n+    fn interner(&self) -> TyCtxt<'tcx> {\n+        self.ecx.tcx()\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if let ty::Alias(ty::Projection, alias_ty) = *ty.kind()\n+            && let Some(replacement) = self.mapping.get(&alias_ty.def_id)\n+        {\n+            // We may have a case where our object type's projection bound is higher-ranked,\n+            // but the where clauses we instantiated are not. We can solve this by instantiating\n+            // the binder at the usage site.\n+            let proj = self.ecx.instantiate_binder_with_infer(*replacement);\n+            // FIXME: Technically this folder could be fallible?\n+            let nested = self\n+                .ecx\n+                .eq(self.param_env, alias_ty, proj.projection_ty)\n+                .expect(\"expected to be able to unify goal projection with dyn's projection\");\n+            // FIXME: Technically we could register these too..\n+            assert!(nested.is_empty(), \"did not expect unification to have any nested goals\");\n+            proj.term.ty().unwrap()\n+        } else {\n+            ty.super_fold_with(self)\n+        }\n+    }\n+}"}, {"sha": "69eb228a2d5a0df361a32c06dcc55c1cf4fcc7c5", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -666,6 +666,9 @@ changelog-seen = 2\n # LTO entirely.\n #lto = \"thin-local\"\n \n+# Build compiler with the optimization enabled and -Zvalidate-mir, currently only for `std`\n+#validate-mir-opts = 3\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "b33fc02f49c247068b87f30ad95461e5661eacf9", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -792,7 +792,7 @@ impl<'a> Builder<'a> {\n                 run::CollectLicenseMetadata,\n                 run::GenerateCopyright,\n             ),\n-            Kind::Setup => describe!(setup::Profile),\n+            Kind::Setup => describe!(setup::Profile, setup::Hook, setup::Link, setup::Vscode),\n             Kind::Clean => describe!(clean::CleanAll, clean::Rustc, clean::Std),\n             // special-cased in Build::build()\n             Kind::Format => vec![],\n@@ -1915,6 +1915,13 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n+        if matches!(mode, Mode::Std) {\n+            if let Some(mir_opt_level) = self.config.rust_validate_mir_opts {\n+                rustflags.arg(\"-Zvalidate-mir\");\n+                rustflags.arg(&format!(\"-Zmir-opt-level={}\", mir_opt_level));\n+            }\n+        }\n+\n         Cargo { command: cargo, rustflags, rustdocflags, allow_features }\n     }\n "}, {"sha": "4a563bc396dc42713302593e0331feb380a0c709", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -173,6 +173,7 @@ pub struct Config {\n     pub rust_profile_use: Option<String>,\n     pub rust_profile_generate: Option<String>,\n     pub rust_lto: RustcLto,\n+    pub rust_validate_mir_opts: Option<u32>,\n     pub llvm_profile_use: Option<String>,\n     pub llvm_profile_generate: bool,\n     pub llvm_libunwind_default: Option<LlvmLibunwind>,\n@@ -770,6 +771,7 @@ define_config! {\n         // ignored; this is set from an env var set by bootstrap.py\n         download_rustc: Option<StringOrBool> = \"download-rustc\",\n         lto: Option<String> = \"lto\",\n+        validate_mir_opts: Option<u32> = \"validate-mir-opts\",\n     }\n }\n \n@@ -1149,6 +1151,7 @@ impl Config {\n                 .as_deref()\n                 .map(|value| RustcLto::from_str(value).unwrap())\n                 .unwrap_or_default();\n+            config.rust_validate_mir_opts = rust.validate_mir_opts;\n         } else {\n             config.rust_profile_use = flags.rust_profile_use;\n             config.rust_profile_generate = flags.rust_profile_generate;"}, {"sha": "04e798e3949d9a5a9316e0e55aa3bee743121e4c", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -379,8 +379,14 @@ def set(key, value):\n sections[None] = []\n section_order = [None]\n targets = {}\n+top_level_keys = []\n \n for line in open(rust_dir + '/config.toml.example').read().split(\"\\n\"):\n+    if cur_section == None:\n+        if line.count('=') == 1:\n+            top_level_key = line.split('=')[0]\n+            top_level_key = top_level_key.strip(' #')\n+            top_level_keys.append(top_level_key)\n     if line.startswith('['):\n         cur_section = line[1:-1]\n         if cur_section.startswith('target'):\n@@ -459,12 +465,22 @@ def configure_section(lines, config):\n                 raise RuntimeError(\"failed to find config line for {}\".format(key))\n \n \n-for section_key in config:\n-    section_config = config[section_key]\n-    if section_key not in sections:\n-        raise RuntimeError(\"config key {} not in sections\".format(section_key))\n+def configure_top_level_key(lines, top_level_key, value):\n+    for i, line in enumerate(lines):\n+        if line.startswith('#' + top_level_key + ' = ') or line.startswith(top_level_key + ' = '):\n+            lines[i] = \"{} = {}\".format(top_level_key, value)\n+            return\n \n-    if section_key == 'target':\n+    raise RuntimeError(\"failed to find config line for {}\".format(top_level_key))\n+\n+\n+for section_key, section_config in config.items():\n+    if section_key not in sections and section_key not in top_level_keys:\n+        raise RuntimeError(\"config key {} not in sections or top_level_keys\".format(section_key))\n+    if section_key in top_level_keys:\n+        configure_top_level_key(sections[None], section_key, section_config)\n+\n+    elif  section_key == 'target':\n         for target in section_config:\n             configure_section(targets[target], section_config[target])\n     else:"}, {"sha": "9d1504c34e81799a8aced1e1d8aaf89820eef906", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -554,7 +554,8 @@ Arguments:\n             Kind::Setup => {\n                 subcommand_help.push_str(&format!(\n                     \"\\n\n-x.py setup creates a `config.toml` which changes the defaults for x.py itself.\n+x.py setup creates a `config.toml` which changes the defaults for x.py itself,\n+as well as setting up a git pre-push hook, VS code config and toolchain link.\n \n Arguments:\n     This subcommand accepts a 'profile' to use for builds. For example:\n@@ -564,7 +565,13 @@ Arguments:\n     The profile is optional and you will be prompted interactively if it is not given.\n     The following profiles are available:\n \n-{}\",\n+{}\n+\n+    To only set up the git hook, VS code or toolchain link, you may use\n+        ./x.py setup hook\n+        ./x.py setup vscode\n+        ./x.py setup link\n+\",\n                     Profile::all_for_help(\"        \").trim_end()\n                 ));\n             }\n@@ -638,7 +645,7 @@ Arguments:\n             }\n             Kind::Setup => {\n                 let profile = if paths.len() > 1 {\n-                    eprintln!(\"\\nerror: At most one profile can be passed to setup\\n\");\n+                    eprintln!(\"\\nerror: At most one option can be passed to setup\\n\");\n                     usage(1, &opts, verbose, &subcommand_help)\n                 } else if let Some(path) = paths.pop() {\n                     let profile_string = t!(path.into_os_string().into_string().map_err("}, {"sha": "4480bce99d799075b3de7fd176fa0be1c282365e", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 103, "deletions": 17, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -21,6 +21,7 @@ pub enum Profile {\n     Library,\n     Tools,\n     User,\n+    None,\n }\n \n /// A list of historical hashes of `src/etc/vscode_settings.json`.\n@@ -41,7 +42,7 @@ impl Profile {\n     pub fn all() -> impl Iterator<Item = Self> {\n         use Profile::*;\n         // N.B. these are ordered by how they are displayed, not alphabetically\n-        [Library, Compiler, Codegen, Tools, User].iter().copied()\n+        [Library, Compiler, Codegen, Tools, User, None].iter().copied()\n     }\n \n     pub fn purpose(&self) -> String {\n@@ -52,6 +53,7 @@ impl Profile {\n             Codegen => \"Contribute to the compiler, and also modify LLVM or codegen\",\n             Tools => \"Contribute to tools which depend on the compiler, but do not modify it directly (e.g. rustdoc, clippy, miri)\",\n             User => \"Install Rust from source\",\n+            None => \"Do not modify `config.toml`\"\n         }\n         .to_string()\n     }\n@@ -71,6 +73,7 @@ impl Profile {\n             Profile::Library => \"library\",\n             Profile::Tools => \"tools\",\n             Profile::User => \"user\",\n+            Profile::None => \"none\",\n         }\n     }\n }\n@@ -87,6 +90,7 @@ impl FromStr for Profile {\n             \"tools\" | \"tool\" | \"rustdoc\" | \"clippy\" | \"miri\" | \"rustfmt\" | \"rls\" => {\n                 Ok(Profile::Tools)\n             }\n+            \"none\" => Ok(Profile::None),\n             _ => Err(format!(\"unknown profile: '{}'\", s)),\n         }\n     }\n@@ -144,17 +148,8 @@ impl Step for Profile {\n }\n \n pub fn setup(config: &Config, profile: Profile) {\n-    let stage_path =\n-        [\"build\", config.build.rustc_target_arg(), \"stage1\"].join(&MAIN_SEPARATOR.to_string());\n-\n-    if !rustup_installed() && profile != Profile::User {\n-        eprintln!(\"`rustup` is not installed; cannot link `stage1` toolchain\");\n-    } else if stage_dir_exists(&stage_path[..]) && !config.dry_run() {\n-        attempt_toolchain_link(&stage_path[..]);\n-    }\n-\n-    let suggestions = match profile {\n-        Profile::Codegen | Profile::Compiler => &[\"check\", \"build\", \"test\"][..],\n+    let suggestions: &[&str] = match profile {\n+        Profile::Codegen | Profile::Compiler | Profile::None => &[\"check\", \"build\", \"test\"],\n         Profile::Tools => &[\n             \"check\",\n             \"build\",\n@@ -167,11 +162,6 @@ pub fn setup(config: &Config, profile: Profile) {\n         Profile::User => &[\"dist\", \"build\"],\n     };\n \n-    if !config.dry_run() {\n-        t!(install_git_hook_maybe(&config));\n-        t!(create_vscode_settings_maybe(&config));\n-    }\n-\n     println!();\n \n     println!(\"To get started, try one of the following commands:\");\n@@ -190,6 +180,9 @@ pub fn setup(config: &Config, profile: Profile) {\n }\n \n fn setup_config_toml(path: &PathBuf, profile: Profile, config: &Config) {\n+    if profile == Profile::None {\n+        return;\n+    }\n     if path.exists() {\n         eprintln!();\n         eprintln!(\n@@ -217,6 +210,41 @@ fn setup_config_toml(path: &PathBuf, profile: Profile, config: &Config) {\n     println!(\"`x.py` will now use the configuration at {}\", include_path.display());\n }\n \n+/// Creates a toolchain link for stage1 using `rustup`\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\n+pub struct Link;\n+impl Step for Link {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.alias(\"link\")\n+    }\n+    fn make_run(run: RunConfig<'_>) {\n+        if run.builder.config.dry_run() {\n+            return;\n+        }\n+        if let [cmd] = &run.paths[..] {\n+            if cmd.assert_single_path().path.as_path().as_os_str() == \"link\" {\n+                run.builder.ensure(Link);\n+            }\n+        }\n+    }\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let config = &builder.config;\n+        if config.dry_run() {\n+            return;\n+        }\n+        let stage_path =\n+            [\"build\", config.build.rustc_target_arg(), \"stage1\"].join(&MAIN_SEPARATOR.to_string());\n+\n+        if !rustup_installed() {\n+            eprintln!(\"`rustup` is not installed; cannot link `stage1` toolchain\");\n+        } else if stage_dir_exists(&stage_path[..]) && !config.dry_run() {\n+            attempt_toolchain_link(&stage_path[..]);\n+        }\n+    }\n+}\n+\n fn rustup_installed() -> bool {\n     Command::new(\"rustup\")\n         .arg(\"--version\")\n@@ -394,6 +422,35 @@ fn prompt_user(prompt: &str) -> io::Result<Option<PromptResult>> {\n     }\n }\n \n+/// Installs `src/etc/pre-push.sh` as a Git hook\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\n+pub struct Hook;\n+\n+impl Step for Hook {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.alias(\"hook\")\n+    }\n+    fn make_run(run: RunConfig<'_>) {\n+        if run.builder.config.dry_run() {\n+            return;\n+        }\n+        if let [cmd] = &run.paths[..] {\n+            if cmd.assert_single_path().path.as_path().as_os_str() == \"hook\" {\n+                run.builder.ensure(Hook);\n+            }\n+        }\n+    }\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let config = &builder.config;\n+        if config.dry_run() {\n+            return;\n+        }\n+        t!(install_git_hook_maybe(&config));\n+    }\n+}\n+\n // install a git hook to automatically run tidy, if they want\n fn install_git_hook_maybe(config: &Config) -> io::Result<()> {\n     let git = t!(config.git().args(&[\"rev-parse\", \"--git-common-dir\"]).output().map(|output| {\n@@ -432,6 +489,35 @@ undesirable, simply delete the `pre-push` file from .git/hooks.\"\n     Ok(())\n }\n \n+/// Sets up or displays `src/etc/vscode_settings.json`\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\n+pub struct Vscode;\n+\n+impl Step for Vscode {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.alias(\"vscode\")\n+    }\n+    fn make_run(run: RunConfig<'_>) {\n+        if run.builder.config.dry_run() {\n+            return;\n+        }\n+        if let [cmd] = &run.paths[..] {\n+            if cmd.assert_single_path().path.as_path().as_os_str() == \"vscode\" {\n+                run.builder.ensure(Vscode);\n+            }\n+        }\n+    }\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let config = &builder.config;\n+        if config.dry_run() {\n+            return;\n+        }\n+        t!(create_vscode_settings_maybe(&config));\n+    }\n+}\n+\n /// Create a `.vscode/settings.json` file for rustc development, or just print it\n fn create_vscode_settings_maybe(config: &Config) -> io::Result<()> {\n     let (current_hash, historical_hashes) = SETTINGS_HASHES.split_last().unwrap();"}, {"sha": "98bd90210d615e40f48f6843f275f3e5db19cd15", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -23,6 +23,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n \n RUN curl -sL https://nodejs.org/dist/v16.9.0/node-v16.9.0-linux-x64.tar.xz | tar -xJ\n ENV PATH=\"/node-v16.9.0-linux-x64/bin:${PATH}\"\n+ENV RUST_CONFIGURE_ARGS=\"--set rust.validate-mir-opts=3\"\n+\n # Install es-check\n # Pin its version to prevent unrelated CI failures due to future es-check versions.\n RUN npm install es-check@6.1.1 eslint@8.6.0 -g\n@@ -38,7 +40,7 @@ COPY host-x86_64/mingw-check/validate-error-codes.sh /scripts/\n \n ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n ENV SCRIPT python3 ../x.py --stage 2 test src/tools/expand-yaml-anchors && \\\n-           python3 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu --all-targets && \\\n+           python3 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n            python3 ../x.py build --stage 0 src/tools/build-manifest && \\\n            python3 ../x.py test --stage 0 src/tools/compiletest && \\\n            python3 ../x.py test --stage 0 core alloc std test proc_macro && \\"}, {"sha": "e384e4863adb9e8f02b9a37e20bc518d1c6a0428", "filename": "tests/rustdoc-ui/proc_macro_bug.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Frustdoc-ui%2Fproc_macro_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Frustdoc-ui%2Fproc_macro_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fproc_macro_bug.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,12 @@\n+// regression test for failing to pass `--crate-type proc-macro` to rustdoc\n+// when documenting a proc macro crate https://github.com/rust-lang/rust/pull/107291\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(DeriveA)]\n+//~^ ERROR the `#[proc_macro_derive]` attribute is only usable with crates of the `proc-macro` crate type\n+pub fn a_derive(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "5b048097c496457409b4627050f48beb0fe32950", "filename": "tests/rustdoc-ui/proc_macro_bug.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Frustdoc-ui%2Fproc_macro_bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Frustdoc-ui%2Fproc_macro_bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fproc_macro_bug.stderr?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,8 @@\n+error: the `#[proc_macro_derive]` attribute is only usable with crates of the `proc-macro` crate type\n+  --> $DIR/proc_macro_bug.rs:8:1\n+   |\n+LL | #[proc_macro_derive(DeriveA)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "6aa9785f44e33d20747944ce9b32dd0f8f18648b", "filename": "tests/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fz-help.stdout?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -81,6 +81,7 @@\n          Multiple options can be combined with commas.\n     -Z                     keep-hygiene-data=val -- keep hygiene data after analysis (default: no)\n     -Z                           layout-seed=val -- seed layout randomization\n+    -Z                       link-directives=val -- honor #[link] directives in the compiled crate (default: yes)\n     -Z                 link-native-libraries=val -- link native libraries in the linker invocation (default: yes)\n     -Z                             link-only=val -- link the `.rlink` file generated by `-Z no-link` (default: no)\n     -Z                          llvm-plugins=val -- a list LLVM plugins to enable (space separated)"}, {"sha": "85d009f11a6f31ddab603b6ce150a5268274c799", "filename": "tests/ui/attributes/invalid_macro_export_argument.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+#[macro_export(hello, world)] //~ WARN `#[macro_export]` can only take 1 or 0 arguments\n+macro_rules! a {\n+    () => ()\n+}\n+\n+#[macro_export(not_local_inner_macros)] //~ WARN `not_local_inner_macros` isn't a valid `#[macro_export]` argument\n+macro_rules! b {\n+    () => ()\n+}\n+\n+#[macro_export]\n+macro_rules! c {\n+    () => ()\n+}\n+#[macro_export(local_inner_macros)]\n+macro_rules! d {\n+    () => ()\n+}\n+\n+#[macro_export()]\n+macro_rules! e {\n+    () => ()\n+}\n+\n+fn main() {}"}, {"sha": "a4e17642c2aac289523128602b3f209935585a81", "filename": "tests/ui/attributes/invalid_macro_export_argument.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid_macro_export_argument.stderr?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,16 @@\n+warning: `#[macro_export]` can only take 1 or 0 arguments\n+  --> $DIR/invalid_macro_export_argument.rs:2:1\n+   |\n+LL | #[macro_export(hello, world)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(invalid_macro_export_arguments)]` on by default\n+\n+warning: `not_local_inner_macros` isn't a valid `#[macro_export]` argument\n+  --> $DIR/invalid_macro_export_argument.rs:7:16\n+   |\n+LL | #[macro_export(not_local_inner_macros)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "83f9b16c4086ae1033a18af661e1b459134f6185", "filename": "tests/ui/issues/issue-70093/issue-70093-link-directives.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Fissues%2Fissue-70093%2Fissue-70093-link-directives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Fissues%2Fissue-70093%2Fissue-70093-link-directives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-70093%2Fissue-70093-link-directives.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,10 @@\n+// run-pass\n+// compile-flags: -Zlink-directives=no\n+// ignore-windows - this will probably only work on unixish systems\n+// ignore-fuchsia - missing __libc_start_main for some reason (#84733)\n+// ignore-cross-compile - default-linker-libraries=yes doesn't play well with cross compiling\n+\n+#[link(name = \"some-random-non-existent-library\", kind = \"static\")]\n+extern \"C\" {}\n+\n+fn main() {}"}, {"sha": "86459dc904a6eb0abc8ee4db79205e3a49a1025a", "filename": "tests/ui/issues/issue-70093/issue-70093.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Fissues%2Fissue-70093%2Fissue-70093.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Fissues%2Fissue-70093%2Fissue-70093.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-70093%2Fissue-70093.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "previous_filename": "tests/ui/issues/issue-70093.rs"}, {"sha": "c886aeeda3e4690e6f246c4698b41d46a3dd364c", "filename": "tests/ui/traits/new-solver/higher-ranked-dyn-bounds.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fhigher-ranked-dyn-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fhigher-ranked-dyn-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fhigher-ranked-dyn-bounds.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Trait<'a> {\n+    type Item: for<'b> Trait2<'b>;\n+}\n+\n+trait Trait2<'a> {}\n+impl Trait2<'_> for () {}\n+\n+fn needs_trait(_: Box<impl for<'a> Trait<'a> + ?Sized>) {}\n+\n+fn foo(x: Box<dyn for<'a> Trait<'a, Item = ()>>) {\n+    needs_trait(x);\n+}\n+\n+fn main() {}"}, {"sha": "712759ef0e612097d623ba6f0b6fbd79a3357495", "filename": "tests/ui/traits/new-solver/more-object-bound.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,27 @@\n+// compile-flags: -Ztrait-solver=next\n+// From #80800\n+\n+trait SuperTrait {\n+    type A;\n+    type B;\n+}\n+\n+trait Trait: SuperTrait<A = <Self as SuperTrait>::B> {}\n+\n+fn transmute<A, B>(x: A) -> B {\n+    foo::<A, B, dyn Trait<A = A, B = B>>(x)\n+    //~^ ERROR type annotations needed: cannot satisfy `dyn Trait<A = A, B = B>: Trait`\n+}\n+\n+fn foo<A, B, T: ?Sized>(x: T::A) -> B\n+where\n+    T: Trait<B = B>,\n+{\n+    x\n+}\n+\n+static X: u8 = 0;\n+fn main() {\n+    let x = transmute::<&u8, &[u8; 1_000_000]>(&X);\n+    println!(\"{:?}\", x[100_000]);\n+}"}, {"sha": "208fdecb08fc9f6856f075e615429466577c59ac", "filename": "tests/ui/traits/new-solver/more-object-bound.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fmore-object-bound.stderr?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,19 @@\n+error[E0283]: type annotations needed: cannot satisfy `dyn Trait<A = A, B = B>: Trait`\n+  --> $DIR/more-object-bound.rs:12:5\n+   |\n+LL |     foo::<A, B, dyn Trait<A = A, B = B>>(x)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: cannot satisfy `dyn Trait<A = A, B = B>: Trait`\n+note: required by a bound in `foo`\n+  --> $DIR/more-object-bound.rs:18:8\n+   |\n+LL | fn foo<A, B, T: ?Sized>(x: T::A) -> B\n+   |    --- required by a bound in this function\n+LL | where\n+LL |     T: Trait<B = B>,\n+   |        ^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "7bdd863a762c4069d3f1fdcb5a1e7f8c5c519981", "filename": "tests/ui/traits/new-solver/object-unsafety.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.rs?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Setup {\n+    type From: Copy;\n+}\n+\n+fn copy<U: Setup + ?Sized>(from: &U::From) -> U::From {\n+    *from\n+}\n+\n+pub fn copy_any<T>(t: &T) -> T {\n+    copy::<dyn Setup<From=T>>(t)\n+    //~^ ERROR the trait bound `dyn Setup<From = T>: Setup` is not satisfied\n+}\n+\n+fn main() {\n+    let x = String::from(\"Hello, world\");\n+    let y = copy_any(&x);\n+    println!(\"{y}\");\n+}"}, {"sha": "198ac623df8a6836339851d26131f2bc5b3cd380", "filename": "tests/ui/traits/new-solver/object-unsafety.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f37f9f6512cb6b295acb70938302704a80c29b2b/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fobject-unsafety.stderr?ref=f37f9f6512cb6b295acb70938302704a80c29b2b", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `dyn Setup<From = T>: Setup` is not satisfied\n+  --> $DIR/object-unsafety.rs:12:12\n+   |\n+LL |     copy::<dyn Setup<From=T>>(t)\n+   |            ^^^^^^^^^^^^^^^^^ the trait `Setup` is not implemented for `dyn Setup<From = T>`\n+   |\n+note: required by a bound in `copy`\n+  --> $DIR/object-unsafety.rs:7:12\n+   |\n+LL | fn copy<U: Setup + ?Sized>(from: &U::From) -> U::From {\n+   |            ^^^^^ required by this bound in `copy`\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | pub fn copy_any<T>(t: &T) -> T where dyn Setup<From = T>: Setup {\n+   |                                ++++++++++++++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}