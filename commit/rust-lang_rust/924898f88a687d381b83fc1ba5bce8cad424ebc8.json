{"sha": "924898f88a687d381b83fc1ba5bce8cad424ebc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNDg5OGY4OGE2ODdkMzgxYjgzZmMxYmE1YmNlOGNhZDQyNGViYzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-28T12:01:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-28T12:01:02Z"}, "message": "Auto merge of #41917 - arielb1:mir-array, r=nagisa\n\nTranslate array drop glue using MIR\n\nI was a bit lazy here and used a usize-based index instead of a pointer iteration. Do you think this is important @eddyb?\n\nr? @eddyb", "tree": {"sha": "acade8ee33a526fb96abad74bc3bff272f544b59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acade8ee33a526fb96abad74bc3bff272f544b59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/924898f88a687d381b83fc1ba5bce8cad424ebc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/924898f88a687d381b83fc1ba5bce8cad424ebc8", "html_url": "https://github.com/rust-lang/rust/commit/924898f88a687d381b83fc1ba5bce8cad424ebc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/924898f88a687d381b83fc1ba5bce8cad424ebc8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41e74a2282752499ebd9e2444f9b710d92fd0e64", "url": "https://api.github.com/repos/rust-lang/rust/commits/41e74a2282752499ebd9e2444f9b710d92fd0e64", "html_url": "https://github.com/rust-lang/rust/commit/41e74a2282752499ebd9e2444f9b710d92fd0e64"}, {"sha": "ee982d4355a10790993ab65f80730ba75395e140", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee982d4355a10790993ab65f80730ba75395e140", "html_url": "https://github.com/rust-lang/rust/commit/ee982d4355a10790993ab65f80730ba75395e140"}], "stats": {"total": 1453, "additions": 999, "deletions": 454}, "files": [{"sha": "3563dbe50966f0e0f9b2a3ed2a9a164305089fd1", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -315,7 +315,8 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Rvalue<'tcx>\n             mir::Rvalue::Discriminant(ref lvalue) => {\n                 lvalue.hash_stable(hcx, hasher);\n             }\n-            mir::Rvalue::Box(ty) => {\n+            mir::Rvalue::NullaryOp(op, ty) => {\n+                op.hash_stable(hcx, hasher);\n                 ty.hash_stable(hcx, hasher);\n             }\n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n@@ -374,14 +375,19 @@ impl_stable_hash_for!(enum mir::BinOp {\n     Le,\n     Ne,\n     Ge,\n-    Gt\n+    Gt,\n+    Offset\n });\n \n impl_stable_hash_for!(enum mir::UnOp {\n     Not,\n     Neg\n });\n \n+impl_stable_hash_for!(enum mir::NullOp {\n+    Box,\n+    SizeOf\n+});\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n "}, {"sha": "2a877aca53b7cb618d7b4bed10b97c50df360317", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -47,7 +47,7 @@\n #![cfg_attr(stage0, feature(staged_api))]\n #![cfg_attr(stage0, feature(loop_break_value))]\n \n-#![recursion_limit=\"128\"]\n+#![recursion_limit=\"192\"]\n \n extern crate arena;\n extern crate core;"}, {"sha": "6597db9e19bd9e2d49cf0b4c2d39bb1148f70145", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -245,7 +245,6 @@ pub trait CrateStore {\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n-    fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool;\n \n@@ -364,7 +363,6 @@ impl CrateStore for DummyCrateStore {\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n-    fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool { false }\n "}, {"sha": "80c42917196dba4ce5c151ea14e4a3a3e7024455", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -1046,6 +1046,7 @@ pub enum Rvalue<'tcx> {\n     BinaryOp(BinOp, Operand<'tcx>, Operand<'tcx>),\n     CheckedBinaryOp(BinOp, Operand<'tcx>, Operand<'tcx>),\n \n+    NullaryOp(NullOp, Ty<'tcx>),\n     UnaryOp(UnOp, Operand<'tcx>),\n \n     /// Read the discriminant of an ADT.\n@@ -1054,9 +1055,6 @@ pub enum Rvalue<'tcx> {\n     /// be defined to return, say, a 0) if ADT is not an enum.\n     Discriminant(Lvalue<'tcx>),\n \n-    /// Creates an *uninitialized* Box\n-    Box(Ty<'tcx>),\n-\n     /// Create an aggregate value, like a tuple or struct.  This is\n     /// only needed because we want to distinguish `dest = Foo { x:\n     /// ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n@@ -1132,6 +1130,8 @@ pub enum BinOp {\n     Ge,\n     /// The `>` operator (greater than)\n     Gt,\n+    /// The `ptr.offset` operator\n+    Offset,\n }\n \n impl BinOp {\n@@ -1144,6 +1144,14 @@ impl BinOp {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+pub enum NullOp {\n+    /// Return the size of a value of that type\n+    SizeOf,\n+    /// Create a new uninitialized box for a value of that type\n+    Box,\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n@@ -1167,7 +1175,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             }\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n             Discriminant(ref lval) => write!(fmt, \"discriminant({:?})\", lval),\n-            Box(ref t) => write!(fmt, \"Box({:?})\", t),\n+            NullaryOp(ref op, ref t) => write!(fmt, \"{:?}({:?})\", op, t),\n             Ref(_, borrow_kind, ref lv) => {\n                 let kind_str = match borrow_kind {\n                     BorrowKind::Shared => \"\",\n@@ -1601,7 +1609,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                 CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder)),\n             UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n             Discriminant(ref lval) => Discriminant(lval.fold_with(folder)),\n-            Box(ty) => Box(ty.fold_with(folder)),\n+            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n             Aggregate(ref kind, ref fields) => {\n                 let kind = box match **kind {\n                     AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n@@ -1629,7 +1637,7 @@ impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n                 rhs.visit_with(visitor) || lhs.visit_with(visitor),\n             UnaryOp(_, ref val) => val.visit_with(visitor),\n             Discriminant(ref lval) => lval.visit_with(visitor),\n-            Box(ty) => ty.visit_with(visitor),\n+            NullaryOp(_, ty) => ty.visit_with(visitor),\n             Aggregate(ref kind, ref fields) => {\n                 (match **kind {\n                     AggregateKind::Array(ty) => ty.visit_with(visitor),"}, {"sha": "6078778a61d502977940df21bf2c4d75e4752cac", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -166,7 +166,8 @@ impl<'tcx> Rvalue<'tcx> {\n                 let ty = op.ty(tcx, lhs_ty, rhs_ty);\n                 tcx.intern_tup(&[ty, tcx.types.bool], false)\n             }\n-            Rvalue::UnaryOp(_, ref operand) => {\n+            Rvalue::UnaryOp(UnOp::Not, ref operand) |\n+            Rvalue::UnaryOp(UnOp::Neg, ref operand) => {\n                 operand.ty(mir, tcx)\n             }\n             Rvalue::Discriminant(ref lval) => {\n@@ -179,9 +180,8 @@ impl<'tcx> Rvalue<'tcx> {\n                     bug!(\"Rvalue::Discriminant on Lvalue of type {:?}\", ty);\n                 }\n             }\n-            Rvalue::Box(t) => {\n-                tcx.mk_box(t)\n-            }\n+            Rvalue::NullaryOp(NullOp::Box, t) => tcx.mk_box(t),\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) => tcx.types.usize,\n             Rvalue::Aggregate(ref ak, ref ops) => {\n                 match **ak {\n                     AggregateKind::Array(ty) => {\n@@ -227,7 +227,7 @@ impl<'tcx> BinOp {\n                 assert_eq!(lhs_ty, rhs_ty);\n                 lhs_ty\n             }\n-            &BinOp::Shl | &BinOp::Shr => {\n+            &BinOp::Shl | &BinOp::Shr | &BinOp::Offset => {\n                 lhs_ty // lhs_ty can be != rhs_ty\n             }\n             &BinOp::Eq | &BinOp::Lt | &BinOp::Le |\n@@ -270,7 +270,8 @@ impl BinOp {\n             BinOp::Lt => hir::BinOp_::BiLt,\n             BinOp::Gt => hir::BinOp_::BiGt,\n             BinOp::Le => hir::BinOp_::BiLe,\n-            BinOp::Ge => hir::BinOp_::BiGe\n+            BinOp::Ge => hir::BinOp_::BiGe,\n+            BinOp::Offset => unreachable!()\n         }\n     }\n }"}, {"sha": "780ce736bfd3cd1b517b762cc34647db95b38161", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -509,7 +509,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_lvalue(lvalue, LvalueContext::Inspect, location);\n                     }\n \n-                    Rvalue::Box(ref $($mutability)* ty) => {\n+                    Rvalue::NullaryOp(_op, ref $($mutability)* ty) => {\n                         self.visit_ty(ty);\n                     }\n "}, {"sha": "78536b53ba8791092df5fe6020d6568101e406a2", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -218,15 +218,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         // Always use types for non-local impls, where types are always\n         // available, and filename/line-number is mostly uninteresting.\n-        let use_types = !impl_def_id.is_local() || {\n+        let use_types = !self.is_default_impl(impl_def_id) && (!impl_def_id.is_local() || {\n             // Otherwise, use filename/line-number if forced.\n             let force_no_types = FORCE_IMPL_FILENAME_LINE.with(|f| f.get());\n             !force_no_types && {\n                 // Otherwise, use types if we can query them without inducing a cycle.\n                 ty::queries::impl_trait_ref::try_get(self, DUMMY_SP, impl_def_id).is_ok() &&\n                     ty::queries::type_of::try_get(self, DUMMY_SP, impl_def_id).is_ok()\n             }\n-        };\n+        });\n \n         if !use_types {\n             return self.push_impl_path_fallback(buffer, impl_def_id);"}, {"sha": "757687f00a20cd69990318bcd88ab099ceedaa81", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -774,6 +774,9 @@ define_maps! { <'tcx>\n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n     [] is_foreign_item: IsForeignItem(DefId) -> bool,\n \n+    /// True if this is a default impl (aka impl Foo for ..)\n+    [] is_default_impl: ItemSignature(DefId) -> bool,\n+\n     /// Get a map with the variance of every item; use `item_variance`\n     /// instead.\n     [] crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,"}, {"sha": "8edae027dbfbc45b9cb78e960b9471db5787ba09", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -600,6 +600,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n         })\n     }\n+\n+    pub fn const_usize(&self, val: u16) -> ConstInt {\n+        match self.sess.target.uint_type {\n+            ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(val as u16)),\n+            ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(val as u32)),\n+            ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(val as u64)),\n+            _ => bug!(),\n+        }\n+    }\n }\n \n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, W> {"}, {"sha": "b03d34819f6374ce58985c1a50d9a22df141b6f7", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -22,7 +22,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_mir::util::patch::MirPatch;\n-use rustc_mir::util::elaborate_drops::{DropFlagState, elaborate_drop};\n+use rustc_mir::util::elaborate_drops::{DropFlagState, Unwind, elaborate_drop};\n use rustc_mir::util::elaborate_drops::{DropElaborator, DropStyle, DropFlagMode};\n use syntax::ast;\n use syntax_pos::Span;\n@@ -399,14 +399,13 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                                     ctxt: self\n                                 },\n                                 terminator.source_info,\n-                                data.is_cleanup,\n                                 location,\n                                 path,\n                                 target,\n                                 if data.is_cleanup {\n-                                    None\n+                                    Unwind::InCleanup\n                                 } else {\n-                                    Some(Option::unwrap_or(unwind, resume_block))\n+                                    Unwind::To(Option::unwrap_or(unwind, resume_block))\n                                 },\n                                 bb)\n                         }\n@@ -455,6 +454,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let bb = loc.block;\n         let data = &self.mir[bb];\n         let terminator = data.terminator();\n+        assert!(!data.is_cleanup, \"DropAndReplace in unwind path not supported\");\n \n         let assign = Statement {\n             kind: StatementKind::Assign(location.clone(), Rvalue::Use(value.clone())),\n@@ -477,7 +477,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 kind: TerminatorKind::Goto { target: target },\n                 ..*terminator\n             }),\n-            is_cleanup: data.is_cleanup,\n+            is_cleanup: false,\n         });\n \n         match self.move_data().rev_lookup.find(location) {\n@@ -491,11 +491,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                         ctxt: self\n                     },\n                     terminator.source_info,\n-                    data.is_cleanup,\n                     location,\n                     path,\n                     target,\n-                    Some(unwind),\n+                    Unwind::To(unwind),\n                     bb);\n                 on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n                     self.set_drop_flag(Location { block: target, statement_index: 0 },"}, {"sha": "b03d2a775df71de964255b3fadbe0226b189e620", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -438,7 +438,8 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             Rvalue::Ref(..) |\n             Rvalue::Discriminant(..) |\n             Rvalue::Len(..) |\n-            Rvalue::Box(..) => {\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n+            Rvalue::NullaryOp(NullOp::Box, _) => {\n                 // This returns an rvalue with uninitialized contents. We can't\n                 // move out of it here because it is an rvalue - assignments always\n                 // completely initialize their lvalue."}, {"sha": "2b39d2a256e1fa6cbd96fd611dd9c53bcbd9c1f7", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -59,7 +59,7 @@ pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n                     attributes: &[ast::Attribute]) {\n     let tcx = bcx.tcx;\n     let def_id = tcx.hir.local_def_id(id);\n-    debug!(\"borrowck_mir({}) UNIMPLEMENTED\", tcx.item_path_str(def_id));\n+    debug!(\"borrowck_mir({:?}) UNIMPLEMENTED\", def_id);\n \n     // It is safe for us to borrow `mir_validated()`: `optimized_mir`\n     // steals it, but it forces the `borrowck` query."}, {"sha": "29ac650aa7053110e374dfa6859919913b9cf067", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -212,6 +212,13 @@ impl<I: Idx, T> IndexMut<I> for IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T> Default for IndexVec<I, T> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n     #[inline]\n     fn extend<J: IntoIterator<Item = T>>(&mut self, iter: J) {"}, {"sha": "b3503713c904ea3acff385cb4337ac0aba044357", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -106,6 +106,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n     inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n+    is_default_impl => { cdata.is_default_impl(def_id.index) }\n     describe_def => { cdata.get_def(def_id.index) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n     stability => { cdata.get_stability(def_id.index) }\n@@ -176,11 +177,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(did.krate).is_const_fn(did.index)\n     }\n \n-    fn is_default_impl(&self, impl_did: DefId) -> bool {\n-        self.dep_graph.read(DepNode::MetaData(impl_did));\n-        self.get_crate_data(impl_did.krate).is_default_impl(impl_did.index)\n-    }\n-\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool\n     {\n         self.do_is_statically_included_foreign_item(def_id)\n@@ -403,7 +399,7 @@ impl CrateStore for cstore::CStore {\n         }\n \n         self.dep_graph.read(DepNode::MetaData(def_id));\n-        debug!(\"item_body({}): inlining item\", tcx.item_path_str(def_id));\n+        debug!(\"item_body({:?}): inlining item\", def_id);\n \n         self.get_crate_data(def_id.krate).item_body(tcx, def_id.index)\n     }\n@@ -515,4 +511,4 @@ impl CrateStore for cstore::CStore {\n         drop(visible_parent_map);\n         self.visible_parent_map.borrow()\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "2884b60fdd8a9ced6c6044e8af4e78a04afeb330", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -97,7 +97,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let value = this.hir.mirror(value);\n                 let result = this.temp(expr.ty, expr_span);\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n-                this.cfg.push_assign(block, source_info, &result, Rvalue::Box(value.ty));\n+                let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n+                this.cfg.push_assign(block, source_info, &result, box_);\n                 this.in_scope(value_extents, block, |this| {\n                     // schedule a shallow free of that memory, lest we unwind:\n                     this.schedule_box_free(expr_span, value_extents, &result, value.ty);"}, {"sha": "54779cbe30126c9484c1034c8f519691c66cf58d", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -198,11 +198,10 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             elaborate_drops::elaborate_drop(\n                 &mut elaborator,\n                 source_info,\n-                false,\n                 &dropee,\n                 (),\n                 return_block,\n-                Some(resume_block),\n+                elaborate_drops::Unwind::To(resume_block),\n                 START_BLOCK\n             );\n             elaborator.patch"}, {"sha": "fa88eca6ec3f09f2cd02f1428d5e418c24dcf302", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n             Rvalue::CheckedBinaryOp(..) |\n             Rvalue::UnaryOp(..) |\n             Rvalue::Discriminant(..) |\n-            Rvalue::Box(..) |\n+            Rvalue::NullaryOp(..) |\n             Rvalue::Aggregate(..) => {\n                 // These variants don't contain regions.\n             }"}, {"sha": "3b1c54f68e49b878889ba43261671bbb115d0641", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -361,7 +361,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n     /// Qualify a whole const, static initializer or const fn.\n     fn qualify_const(&mut self) -> Qualif {\n-        debug!(\"qualifying {} {}\", self.mode, self.tcx.item_path_str(self.def_id));\n+        debug!(\"qualifying {} {:?}\", self.mode, self.def_id);\n \n         let mir = self.mir;\n \n@@ -595,7 +595,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         match *rvalue {\n             Rvalue::Use(_) |\n             Rvalue::Repeat(..) |\n-            Rvalue::UnaryOp(..) |\n+            Rvalue::UnaryOp(UnOp::Neg, _) |\n+            Rvalue::UnaryOp(UnOp::Not, _) |\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n             Rvalue::CheckedBinaryOp(..) |\n             Rvalue::Cast(CastKind::ReifyFnPointer, ..) |\n             Rvalue::Cast(CastKind::UnsafeFnPointer, ..) |\n@@ -703,7 +705,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 if let ty::TyRawPtr(_) = lhs.ty(self.mir, self.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n-                            op == BinOp::Ge || op == BinOp::Gt);\n+                            op == BinOp::Ge || op == BinOp::Gt ||\n+                            op == BinOp::Offset);\n \n                     self.add(Qualif::NOT_CONST);\n                     if self.mode != Mode::Fn {\n@@ -719,7 +722,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n \n-            Rvalue::Box(_) => {\n+            Rvalue::NullaryOp(NullOp::Box, _) => {\n                 self.add(Qualif::NOT_CONST);\n                 if self.mode != Mode::Fn {\n                     struct_span_err!(self.tcx.sess, self.span, E0010,"}, {"sha": "8258627748f3008df8b7f567fce5345c6604a966", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -744,7 +744,7 @@ impl MirPass for TypeckMir {\n                           mir: &mut Mir<'tcx>) {\n         let item_id = src.item_id();\n         let def_id = tcx.hir.local_def_id(item_id);\n-        debug!(\"run_pass: {}\", tcx.item_path_str(def_id));\n+        debug!(\"run_pass: {:?}\", def_id);\n \n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a"}, {"sha": "50ebe366387330901ab6fc96db53c8f70fc58577", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 444, "deletions": 216, "changes": 660, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -11,7 +11,7 @@\n use std::fmt;\n use rustc::hir;\n use rustc::mir::*;\n-use rustc::middle::const_val::ConstInt;\n+use rustc::middle::const_val::{ConstInt, ConstVal};\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::{Kind, Substs};\n@@ -50,6 +50,35 @@ pub enum DropFlagMode {\n     Deep\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum Unwind {\n+    To(BasicBlock),\n+    InCleanup\n+}\n+\n+impl Unwind {\n+    fn is_cleanup(self) -> bool {\n+        match self {\n+            Unwind::To(..) => false,\n+            Unwind::InCleanup => true\n+        }\n+    }\n+\n+    fn into_option(self) -> Option<BasicBlock> {\n+        match self {\n+            Unwind::To(bb) => Some(bb),\n+            Unwind::InCleanup => None,\n+        }\n+    }\n+\n+    fn map<F>(self, f: F) -> Self where F: FnOnce(BasicBlock) -> BasicBlock {\n+        match self {\n+            Unwind::To(bb) => Unwind::To(f(bb)),\n+            Unwind::InCleanup => Unwind::InCleanup\n+        }\n+    }\n+}\n+\n pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n     type Path : Copy + fmt::Debug;\n \n@@ -75,28 +104,25 @@ struct DropCtxt<'l, 'b: 'l, 'tcx: 'b, D>\n     elaborator: &'l mut D,\n \n     source_info: SourceInfo,\n-    is_cleanup: bool,\n \n     lvalue: &'l Lvalue<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n-    unwind: Option<BasicBlock>,\n+    unwind: Unwind,\n }\n \n pub fn elaborate_drop<'b, 'tcx, D>(\n     elaborator: &mut D,\n     source_info: SourceInfo,\n-    is_cleanup: bool,\n     lvalue: &Lvalue<'tcx>,\n     path: D::Path,\n     succ: BasicBlock,\n-    unwind: Option<BasicBlock>,\n+    unwind: Unwind,\n     bb: BasicBlock)\n     where D: DropElaborator<'b, 'tcx>\n {\n-    assert_eq!(unwind.is_none(), is_cleanup);\n     DropCtxt {\n-        elaborator, source_info, is_cleanup, lvalue, path, succ, unwind\n+        elaborator, source_info, lvalue, path, succ, unwind\n     }.elaborate_drop(bb)\n }\n \n@@ -145,14 +171,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.elaborator.patch().patch_terminator(bb, TerminatorKind::Drop {\n                     location: self.lvalue.clone(),\n                     target: self.succ,\n-                    unwind: self.unwind\n+                    unwind: self.unwind.into_option(),\n                 });\n             }\n             DropStyle::Conditional => {\n-                let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+                let unwind = self.unwind; // FIXME(#6393)\n                 let succ = self.succ;\n-                let drop_bb = self.complete_drop(\n-                    is_cleanup, Some(DropFlagMode::Deep), succ);\n+                let drop_bb = self.complete_drop(Some(DropFlagMode::Deep), succ, unwind);\n                 self.elaborator.patch().patch_terminator(bb, TerminatorKind::Goto {\n                     target: drop_bb\n                 });\n@@ -189,11 +214,10 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     }\n \n     fn drop_subpath(&mut self,\n-                    is_cleanup: bool,\n                     lvalue: &Lvalue<'tcx>,\n                     path: Option<D::Path>,\n                     succ: BasicBlock,\n-                    unwind: Option<BasicBlock>)\n+                    unwind: Unwind)\n                     -> BasicBlock\n     {\n         if let Some(path) = path {\n@@ -202,57 +226,54 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             DropCtxt {\n                 elaborator: self.elaborator,\n                 source_info: self.source_info,\n-                path, lvalue, succ, unwind, is_cleanup\n+                path, lvalue, succ, unwind,\n             }.elaborated_drop_block()\n         } else {\n             debug!(\"drop_subpath: for rest field {:?}\", lvalue);\n \n             DropCtxt {\n                 elaborator: self.elaborator,\n                 source_info: self.source_info,\n-                lvalue, succ, unwind, is_cleanup,\n+                lvalue, succ, unwind,\n                 // Using `self.path` here to condition the drop on\n                 // our own drop flag.\n                 path: self.path\n-            }.complete_drop(is_cleanup, None, succ)\n+            }.complete_drop(None, succ, unwind)\n         }\n     }\n \n     /// Create one-half of the drop ladder for a list of fields, and return\n-    /// the list of steps in it in reverse order.\n+    /// the list of steps in it in reverse order, with the first step\n+    /// dropping 0 fields and so on.\n     ///\n     /// `unwind_ladder` is such a list of steps in reverse order,\n-    /// which is called instead of the next step if the drop unwinds\n-    /// (the first field is never reached). If it is `None`, all\n-    /// unwind targets are left blank.\n-    fn drop_halfladder<'a>(&mut self,\n-                           unwind_ladder: Option<&[BasicBlock]>,\n-                           succ: BasicBlock,\n-                           fields: &[(Lvalue<'tcx>, Option<D::Path>)],\n-                           is_cleanup: bool)\n-                           -> Vec<BasicBlock>\n+    /// which is called if the matching step of the drop glue panics.\n+    fn drop_halfladder(&mut self,\n+                       unwind_ladder: &[Unwind],\n+                       mut succ: BasicBlock,\n+                       fields: &[(Lvalue<'tcx>, Option<D::Path>)])\n+                       -> Vec<BasicBlock>\n     {\n-        let mut unwind_succ = if is_cleanup {\n-            None\n-        } else {\n-            self.unwind\n-        };\n-\n-        let goto = TerminatorKind::Goto { target: succ };\n-        let mut succ = self.new_block(is_cleanup, goto);\n-\n-        // Always clear the \"master\" drop flag at the bottom of the\n-        // ladder. This is needed because the \"master\" drop flag\n-        // protects the ADT's discriminant, which is invalidated\n-        // after the ADT is dropped.\n-        let succ_loc = Location { block: succ, statement_index: 0 };\n-        self.elaborator.clear_drop_flag(succ_loc, self.path, DropFlagMode::Shallow);\n+        Some(succ).into_iter().chain(\n+            fields.iter().rev().zip(unwind_ladder)\n+                .map(|(&(ref lv, path), &unwind_succ)| {\n+                    succ = self.drop_subpath(lv, path, succ, unwind_succ);\n+                    succ\n+                })\n+        ).collect()\n+    }\n \n-        fields.iter().rev().enumerate().map(|(i, &(ref lv, path))| {\n-            succ = self.drop_subpath(is_cleanup, lv, path, succ, unwind_succ);\n-            unwind_succ = unwind_ladder.as_ref().map(|p| p[i]);\n-            succ\n-        }).collect()\n+    fn drop_ladder_bottom(&mut self) -> (BasicBlock, Unwind) {\n+        // Clear the \"master\" drop flag at the end. This is needed\n+        // because the \"master\" drop protects the ADT's discriminant,\n+        // which is invalidated after the ADT is dropped.\n+        let (succ, unwind) = (self.succ, self.unwind); // FIXME(#6393)\n+        (\n+            self.drop_flag_reset_block(DropFlagMode::Shallow, succ, unwind),\n+            unwind.map(|unwind| {\n+                self.drop_flag_reset_block(DropFlagMode::Shallow, unwind, Unwind::InCleanup)\n+            })\n+        )\n     }\n \n     /// Create a full drop ladder, consisting of 2 connected half-drop-ladders\n@@ -269,9 +290,14 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///     ELAB(drop location.1 [target=.c2])\n     /// .c2:\n     ///     ELAB(drop location.2 [target=`self.unwind`])\n+    ///\n+    /// NOTE: this does not clear the master drop flag, so you need\n+    /// to point succ/unwind on a `drop_ladder_bottom`.\n     fn drop_ladder<'a>(&mut self,\n-                       fields: Vec<(Lvalue<'tcx>, Option<D::Path>)>)\n-                       -> (BasicBlock, Option<BasicBlock>)\n+                       fields: Vec<(Lvalue<'tcx>, Option<D::Path>)>,\n+                       succ: BasicBlock,\n+                       unwind: Unwind)\n+                       -> (BasicBlock, Unwind)\n     {\n         debug!(\"drop_ladder({:?}, {:?})\", self, fields);\n \n@@ -282,21 +308,18 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         debug!(\"drop_ladder - fields needing drop: {:?}\", fields);\n \n-        let unwind_ladder = if self.is_cleanup {\n-            None\n+        let unwind_ladder = vec![Unwind::InCleanup; fields.len() + 1];\n+        let unwind_ladder: Vec<_> = if let Unwind::To(target) = unwind {\n+            let halfladder = self.drop_halfladder(&unwind_ladder, target, &fields);\n+            halfladder.into_iter().map(Unwind::To).collect()\n         } else {\n-            let unwind = self.unwind.unwrap(); // FIXME(#6393)\n-            Some(self.drop_halfladder(None, unwind, &fields, true))\n+            unwind_ladder\n         };\n \n-        let succ = self.succ; // FIXME(#6393)\n-        let is_cleanup = self.is_cleanup;\n         let normal_ladder =\n-            self.drop_halfladder(unwind_ladder.as_ref().map(|x| &**x),\n-                                 succ, &fields, is_cleanup);\n+            self.drop_halfladder(&unwind_ladder, succ, &fields);\n \n-        (normal_ladder.last().cloned().unwrap_or(succ),\n-         unwind_ladder.and_then(|l| l.last().cloned()).or(self.unwind))\n+        (*normal_ladder.last().unwrap(), *unwind_ladder.last().unwrap())\n     }\n \n     fn open_drop_for_tuple<'a>(&mut self, tys: &[Ty<'tcx>])\n@@ -309,7 +332,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n              self.elaborator.field_subpath(self.path, Field::new(i)))\n         }).collect();\n \n-        self.drop_ladder(fields).0\n+        let (succ, unwind) = self.drop_ladder_bottom();\n+        self.drop_ladder(fields, succ, unwind).0\n     }\n \n     fn open_drop_for_box<'a>(&mut self, ty: Ty<'tcx>) -> BasicBlock\n@@ -320,13 +344,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.succ; // FIXME(#6393)\n-        let is_cleanup = self.is_cleanup;\n-        let succ = self.box_free_block(ty, succ, is_cleanup);\n-        let unwind_succ = self.unwind.map(|u| {\n-            self.box_free_block(ty, u, true)\n+        let unwind = self.unwind;\n+        let succ = self.box_free_block(ty, succ, unwind);\n+        let unwind_succ = self.unwind.map(|unwind| {\n+            self.box_free_block(ty, unwind, Unwind::InCleanup)\n         });\n \n-        self.drop_subpath(is_cleanup, &interior, interior_path, succ, unwind_succ)\n+        self.drop_subpath(&interior, interior_path, succ, unwind_succ)\n     }\n \n     fn open_drop_for_adt<'a>(&mut self, adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n@@ -339,7 +363,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     source_info: self.source_info,\n                     kind: TerminatorKind::Unreachable\n                 }),\n-                is_cleanup: self.is_cleanup\n+                is_cleanup: self.unwind.is_cleanup()\n             });\n         }\n \n@@ -356,114 +380,108 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         }\n     }\n \n-    fn open_drop_for_adt_contents<'a>(&mut self, adt: &'tcx ty::AdtDef,\n-                                      substs: &'tcx Substs<'tcx>)\n-                                      -> (BasicBlock, Option<BasicBlock>) {\n-        match adt.variants.len() {\n-            1 => {\n-                let fields = self.move_paths_for_fields(\n-                    self.lvalue,\n-                    self.path,\n-                    &adt.variants[0],\n-                    substs\n-                );\n-                self.drop_ladder(fields)\n-            }\n-            _ => {\n-                let is_cleanup = self.is_cleanup;\n-                let succ = self.succ;\n-                let unwind = self.unwind; // FIXME(#6393)\n+    fn open_drop_for_adt_contents(&mut self, adt: &'tcx ty::AdtDef,\n+                                  substs: &'tcx Substs<'tcx>)\n+                                  -> (BasicBlock, Unwind) {\n+        let (succ, unwind) = self.drop_ladder_bottom();\n+        if adt.variants.len() == 1 {\n+            let fields = self.move_paths_for_fields(\n+                self.lvalue,\n+                self.path,\n+                &adt.variants[0],\n+                substs\n+            );\n+            self.drop_ladder(fields, succ, unwind)\n+        } else {\n+            self.open_drop_for_multivariant(adt, substs, succ, unwind)\n+        }\n+    }\n+\n+    fn open_drop_for_multivariant(&mut self, adt: &'tcx ty::AdtDef,\n+                                  substs: &'tcx Substs<'tcx>,\n+                                  succ: BasicBlock,\n+                                  unwind: Unwind)\n+                                  -> (BasicBlock, Unwind) {\n+        let mut values = Vec::with_capacity(adt.variants.len());\n+        let mut normal_blocks = Vec::with_capacity(adt.variants.len());\n+        let mut unwind_blocks = if unwind.is_cleanup() {\n+            None\n+        } else {\n+            Some(Vec::with_capacity(adt.variants.len()))\n+        };\n \n-                let mut values = Vec::with_capacity(adt.variants.len());\n-                let mut normal_blocks = Vec::with_capacity(adt.variants.len());\n-                let mut unwind_blocks = if is_cleanup {\n-                    None\n-                } else {\n-                    Some(Vec::with_capacity(adt.variants.len()))\n-                };\n-                let mut otherwise = None;\n-                let mut unwind_otherwise = None;\n-                for (variant_index, discr) in adt.discriminants(self.tcx()).enumerate() {\n-                    let subpath = self.elaborator.downcast_subpath(\n-                        self.path, variant_index);\n-                    if let Some(variant_path) = subpath {\n-                        let base_lv = self.lvalue.clone().elem(\n-                            ProjectionElem::Downcast(adt, variant_index)\n+        let mut have_otherwise = false;\n+\n+        for (variant_index, discr) in adt.discriminants(self.tcx()).enumerate() {\n+            let subpath = self.elaborator.downcast_subpath(\n+                self.path, variant_index);\n+            if let Some(variant_path) = subpath {\n+                let base_lv = self.lvalue.clone().elem(\n+                    ProjectionElem::Downcast(adt, variant_index)\n                         );\n-                        let fields = self.move_paths_for_fields(\n-                            &base_lv,\n-                            variant_path,\n-                            &adt.variants[variant_index],\n-                            substs);\n-                        values.push(discr);\n-                        if let Some(ref mut unwind_blocks) = unwind_blocks {\n-                            // We can't use the half-ladder from the original\n-                            // drop ladder, because this breaks the\n-                            // \"funclet can't have 2 successor funclets\"\n-                            // requirement from MSVC:\n-                            //\n-                            //           switch       unwind-switch\n-                            //          /      \\         /        \\\n-                            //         v1.0    v2.0  v2.0-unwind  v1.0-unwind\n-                            //         |        |      /             |\n-                            //    v1.1-unwind  v2.1-unwind           |\n-                            //      ^                                |\n-                            //       \\-------------------------------/\n-                            //\n-                            // Create a duplicate half-ladder to avoid that. We\n-                            // could technically only do this on MSVC, but I\n-                            // I want to minimize the divergence between MSVC\n-                            // and non-MSVC.\n-\n-                            let unwind = unwind.unwrap();\n-                            let halfladder = self.drop_halfladder(\n-                                None, unwind, &fields, true);\n-                            unwind_blocks.push(\n-                                halfladder.last().cloned().unwrap_or(unwind)\n-                            );\n-                        }\n-                        let (normal, _) = self.drop_ladder(fields);\n-                        normal_blocks.push(normal);\n-                    } else {\n-                        // variant not found - drop the entire enum\n-                        if let None = otherwise {\n-                            otherwise = Some(self.complete_drop(\n-                                is_cleanup,\n-                                Some(DropFlagMode::Shallow),\n-                                succ));\n-                            unwind_otherwise = unwind.map(|unwind| self.complete_drop(\n-                                true,\n-                                Some(DropFlagMode::Shallow),\n-                                unwind\n-                            ));\n-                        }\n-                    }\n-                }\n-                if let Some(block) = otherwise {\n-                    normal_blocks.push(block);\n-                    if let Some(ref mut unwind_blocks) = unwind_blocks {\n-                        unwind_blocks.push(unwind_otherwise.unwrap());\n-                    }\n-                } else {\n-                    values.pop();\n+                let fields = self.move_paths_for_fields(\n+                    &base_lv,\n+                    variant_path,\n+                    &adt.variants[variant_index],\n+                    substs);\n+                values.push(discr);\n+                if let Unwind::To(unwind) = unwind {\n+                    // We can't use the half-ladder from the original\n+                    // drop ladder, because this breaks the\n+                    // \"funclet can't have 2 successor funclets\"\n+                    // requirement from MSVC:\n+                    //\n+                    //           switch       unwind-switch\n+                    //          /      \\         /        \\\n+                    //         v1.0    v2.0  v2.0-unwind  v1.0-unwind\n+                    //         |        |      /             |\n+                    //    v1.1-unwind  v2.1-unwind           |\n+                    //      ^                                |\n+                    //       \\-------------------------------/\n+                    //\n+                    // Create a duplicate half-ladder to avoid that. We\n+                    // could technically only do this on MSVC, but I\n+                    // I want to minimize the divergence between MSVC\n+                    // and non-MSVC.\n+\n+                    let unwind_blocks = unwind_blocks.as_mut().unwrap();\n+                    let unwind_ladder = vec![Unwind::InCleanup; fields.len() + 1];\n+                    let halfladder =\n+                        self.drop_halfladder(&unwind_ladder, unwind, &fields);\n+                    unwind_blocks.push(halfladder.last().cloned().unwrap());\n                 }\n+                let (normal, _) = self.drop_ladder(fields, succ, unwind);\n+                normal_blocks.push(normal);\n+            } else {\n+                have_otherwise = true;\n+            }\n+        }\n \n-                (self.adt_switch_block(is_cleanup, adt, normal_blocks, &values, succ),\n-                 unwind_blocks.map(|unwind_blocks| {\n-                     self.adt_switch_block(\n-                         is_cleanup, adt, unwind_blocks, &values, unwind.unwrap()\n-                     )\n-                 }))\n+        if have_otherwise {\n+            normal_blocks.push(self.drop_block(succ, unwind));\n+            if let Unwind::To(unwind) = unwind {\n+                unwind_blocks.as_mut().unwrap().push(\n+                    self.drop_block(unwind, Unwind::InCleanup)\n+                        );\n             }\n+        } else {\n+            values.pop();\n         }\n+\n+        (self.adt_switch_block(adt, normal_blocks, &values, succ, unwind),\n+         unwind.map(|unwind| {\n+             self.adt_switch_block(\n+                 adt, unwind_blocks.unwrap(), &values, unwind, Unwind::InCleanup\n+             )\n+         }))\n     }\n \n     fn adt_switch_block(&mut self,\n-                        is_cleanup: bool,\n                         adt: &'tcx ty::AdtDef,\n                         blocks: Vec<BasicBlock>,\n                         values: &[ConstInt],\n-                        succ: BasicBlock)\n+                        succ: BasicBlock,\n+                        unwind: Unwind)\n                         -> BasicBlock {\n         // If there are multiple variants, then if something\n         // is present within the enum the discriminant, tracked\n@@ -475,13 +493,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n         let discr = Lvalue::Local(self.new_temp(discr_ty));\n         let discr_rv = Rvalue::Discriminant(self.lvalue.clone());\n-        let switch_block = self.elaborator.patch().new_block(BasicBlockData {\n-            statements: vec![\n-                Statement {\n-                    source_info: self.source_info,\n-                    kind: StatementKind::Assign(discr.clone(), discr_rv),\n-                }\n-                ],\n+        let switch_block = BasicBlockData {\n+            statements: vec![self.assign(&discr, discr_rv)],\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::SwitchInt {\n@@ -491,12 +504,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     targets: blocks,\n                 }\n             }),\n-            is_cleanup: is_cleanup,\n-        });\n-        self.drop_flag_test_block(is_cleanup, switch_block, succ)\n+            is_cleanup: unwind.is_cleanup(),\n+        };\n+        let switch_block = self.elaborator.patch().new_block(switch_block);\n+        self.drop_flag_test_block(switch_block, succ, unwind)\n     }\n \n-    fn destructor_call_block<'a>(&mut self, (succ, unwind): (BasicBlock, Option<BasicBlock>))\n+    fn destructor_call_block<'a>(&mut self, (succ, unwind): (BasicBlock, Unwind))\n                                  -> BasicBlock\n     {\n         debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n@@ -513,26 +527,213 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let ref_lvalue = self.new_temp(ref_ty);\n         let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n \n-        self.elaborator.patch().new_block(BasicBlockData {\n-            statements: vec![Statement {\n-                source_info: self.source_info,\n-                kind: StatementKind::Assign(\n-                    Lvalue::Local(ref_lvalue),\n-                    Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone())\n-                )\n-            }],\n+        let result = BasicBlockData {\n+            statements: vec![self.assign(\n+                &Lvalue::Local(ref_lvalue),\n+                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone())\n+            )],\n             terminator: Some(Terminator {\n                 kind: TerminatorKind::Call {\n                     func: Operand::function_handle(tcx, drop_fn.def_id, substs,\n                                                    self.source_info.span),\n                     args: vec![Operand::Consume(Lvalue::Local(ref_lvalue))],\n                     destination: Some((unit_temp, succ)),\n-                    cleanup: unwind,\n+                    cleanup: unwind.into_option(),\n                 },\n                 source_info: self.source_info\n             }),\n-            is_cleanup: self.is_cleanup,\n-        })\n+            is_cleanup: unwind.is_cleanup(),\n+        };\n+        self.elaborator.patch().new_block(result)\n+    }\n+\n+    /// create a loop that drops an array:\n+    ///\n+\n+    ///\n+    /// loop-block:\n+    ///    can_go = cur == length_or_end\n+    ///    if can_go then succ else drop-block\n+    /// drop-block:\n+    ///    if ptr_based {\n+    ///        ptr = cur\n+    ///        cur = cur.offset(1)\n+    ///    } else {\n+    ///        ptr = &mut LV[cur]\n+    ///        cur = cur + 1\n+    ///    }\n+    ///    drop(ptr)\n+    fn drop_loop(&mut self,\n+                 succ: BasicBlock,\n+                 cur: &Lvalue<'tcx>,\n+                 length_or_end: &Lvalue<'tcx>,\n+                 ety: Ty<'tcx>,\n+                 unwind: Unwind,\n+                 ptr_based: bool)\n+                 -> BasicBlock\n+    {\n+        let use_ = |lv: &Lvalue<'tcx>| Operand::Consume(lv.clone());\n+        let tcx = self.tcx();\n+\n+        let ref_ty = tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n+            ty: ety,\n+            mutbl: hir::Mutability::MutMutable\n+        });\n+        let ptr = &Lvalue::Local(self.new_temp(ref_ty));\n+        let can_go = &Lvalue::Local(self.new_temp(tcx.types.bool));\n+\n+        let one = self.constant_usize(1);\n+        let (ptr_next, cur_next) = if ptr_based {\n+            (Rvalue::Use(use_(cur)),\n+             Rvalue::BinaryOp(BinOp::Offset, use_(cur), one))\n+        } else {\n+            (Rvalue::Ref(\n+                 tcx.types.re_erased,\n+                 BorrowKind::Mut,\n+                 self.lvalue.clone().index(use_(cur))),\n+             Rvalue::BinaryOp(BinOp::Add, use_(cur), one))\n+        };\n+\n+        let drop_block = BasicBlockData {\n+            statements: vec![\n+                self.assign(ptr, ptr_next),\n+                self.assign(cur, cur_next)\n+            ],\n+            is_cleanup: unwind.is_cleanup(),\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                // this gets overwritten by drop elaboration.\n+                kind: TerminatorKind::Unreachable,\n+            })\n+        };\n+        let drop_block = self.elaborator.patch().new_block(drop_block);\n+\n+        let loop_block = BasicBlockData {\n+            statements: vec![\n+                self.assign(can_go, Rvalue::BinaryOp(BinOp::Eq,\n+                                                     use_(cur),\n+                                                     use_(length_or_end)))\n+            ],\n+            is_cleanup: unwind.is_cleanup(),\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                kind: TerminatorKind::if_(tcx, use_(can_go), succ, drop_block)\n+            })\n+        };\n+        let loop_block = self.elaborator.patch().new_block(loop_block);\n+\n+        self.elaborator.patch().patch_terminator(drop_block, TerminatorKind::Drop {\n+            location: ptr.clone().deref(),\n+            target: loop_block,\n+            unwind: unwind.into_option()\n+        });\n+\n+        loop_block\n+    }\n+\n+    fn open_drop_for_array(&mut self, ety: Ty<'tcx>) -> BasicBlock {\n+        debug!(\"open_drop_for_array({:?})\", ety);\n+\n+        // if size_of::<ety>() == 0 {\n+        //     index_based_loop\n+        // } else {\n+        //     ptr_based_loop\n+        // }\n+\n+        let tcx = self.tcx();\n+\n+        let use_ = |lv: &Lvalue<'tcx>| Operand::Consume(lv.clone());\n+        let size = &Lvalue::Local(self.new_temp(tcx.types.usize));\n+        let size_is_zero = &Lvalue::Local(self.new_temp(tcx.types.bool));\n+        let base_block = BasicBlockData {\n+            statements: vec![\n+                self.assign(size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n+                self.assign(size_is_zero, Rvalue::BinaryOp(BinOp::Eq,\n+                                                           use_(size),\n+                                                           self.constant_usize(0)))\n+            ],\n+            is_cleanup: self.unwind.is_cleanup(),\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                kind: TerminatorKind::if_(\n+                    tcx,\n+                    use_(size_is_zero),\n+                    self.drop_loop_pair(ety, false),\n+                    self.drop_loop_pair(ety, true)\n+                )\n+            })\n+        };\n+        self.elaborator.patch().new_block(base_block)\n+    }\n+\n+    // create a pair of drop-loops of `lvalue`, which drops its contents\n+    // even in the case of 1 panic. If `ptr_based`, create a pointer loop,\n+    // otherwise create an index loop.\n+    fn drop_loop_pair(&mut self, ety: Ty<'tcx>, ptr_based: bool) -> BasicBlock {\n+        debug!(\"drop_loop_pair({:?}, {:?})\", ety, ptr_based);\n+        let tcx = self.tcx();\n+        let iter_ty = if ptr_based {\n+            tcx.mk_ptr(ty::TypeAndMut { ty: ety, mutbl: hir::Mutability::MutMutable })\n+        } else {\n+            tcx.types.usize\n+        };\n+\n+        let cur = Lvalue::Local(self.new_temp(iter_ty));\n+        let length = Lvalue::Local(self.new_temp(tcx.types.usize));\n+        let length_or_end = if ptr_based {\n+            Lvalue::Local(self.new_temp(iter_ty))\n+        } else {\n+            length.clone()\n+        };\n+\n+        let unwind = self.unwind.map(|unwind| {\n+            self.drop_loop(unwind,\n+                           &cur,\n+                           &length_or_end,\n+                           ety,\n+                           Unwind::InCleanup,\n+                           ptr_based)\n+        });\n+\n+        let succ = self.succ; // FIXME(#6393)\n+        let loop_block = self.drop_loop(\n+            succ,\n+            &cur,\n+            &length_or_end,\n+            ety,\n+            unwind,\n+            ptr_based);\n+\n+        let zero = self.constant_usize(0);\n+        let mut drop_block_stmts = vec![];\n+        drop_block_stmts.push(self.assign(&length, Rvalue::Len(self.lvalue.clone())));\n+        if ptr_based {\n+            // cur = &LV[0];\n+            // end = &LV[len];\n+            drop_block_stmts.push(self.assign(&cur, Rvalue::Ref(\n+                tcx.types.re_erased, BorrowKind::Mut,\n+                self.lvalue.clone().index(zero.clone())\n+            )));\n+            drop_block_stmts.push(self.assign(&length_or_end, Rvalue::Ref(\n+                tcx.types.re_erased, BorrowKind::Mut,\n+                self.lvalue.clone().index(Operand::Consume(length.clone()))\n+            )));\n+        } else {\n+            // index = 0 (length already pushed)\n+            drop_block_stmts.push(self.assign(&cur, Rvalue::Use(zero)));\n+        }\n+        let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n+            statements: drop_block_stmts,\n+            is_cleanup: unwind.is_cleanup(),\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                kind: TerminatorKind::Goto { target: loop_block }\n+            })\n+        });\n+\n+        // FIXME(#34708): handle partially-dropped array/slice elements.\n+        let reset_block = self.drop_flag_reset_block(DropFlagMode::Deep, drop_block, unwind);\n+        self.drop_flag_test_block(reset_block, succ, unwind)\n     }\n \n     /// The slow-path - create an \"open\", elaborated drop for a type\n@@ -545,8 +746,6 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// ADT, both in the success case or if one of the destructors fail.\n     fn open_drop<'a>(&mut self) -> BasicBlock {\n         let ty = self.lvalue_ty(self.lvalue);\n-        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n-        let succ = self.succ;\n         match ty.sty {\n             ty::TyClosure(def_id, substs) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n@@ -562,12 +761,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.open_drop_for_adt(def, substs)\n             }\n             ty::TyDynamic(..) => {\n-                self.complete_drop(is_cleanup, Some(DropFlagMode::Deep), succ)\n+                let unwind = self.unwind; // FIXME(#6393)\n+                let succ = self.succ;\n+                self.complete_drop(Some(DropFlagMode::Deep), succ, unwind)\n             }\n-            ty::TyArray(..) | ty::TySlice(..) => {\n-                // FIXME(#34708): handle partially-dropped\n-                // array/slice elements.\n-                self.complete_drop(is_cleanup, Some(DropFlagMode::Deep), succ)\n+            ty::TyArray(ety, _) | ty::TySlice(ety) => {\n+                self.open_drop_for_array(ety)\n             }\n             _ => bug!(\"open drop from non-ADT `{:?}`\", ty)\n         }\n@@ -581,26 +780,40 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///     if let Some(mode) = mode: FLAG(self.path)[mode] = false\n     ///     drop(self.lv)\n     fn complete_drop<'a>(&mut self,\n-                         is_cleanup: bool,\n                          drop_mode: Option<DropFlagMode>,\n-                         succ: BasicBlock) -> BasicBlock\n+                         succ: BasicBlock,\n+                         unwind: Unwind) -> BasicBlock\n     {\n         debug!(\"complete_drop({:?},{:?})\", self, drop_mode);\n \n-        let drop_block = self.drop_block(is_cleanup, succ);\n-        if let Some(mode) = drop_mode {\n-            let block_start = Location { block: drop_block, statement_index: 0 };\n-            self.elaborator.clear_drop_flag(block_start, self.path, mode);\n-        }\n+        let drop_block = self.drop_block(succ, unwind);\n+        let drop_block = if let Some(mode) = drop_mode {\n+            self.drop_flag_reset_block(mode, drop_block, unwind)\n+        } else {\n+            drop_block\n+        };\n+\n+        self.drop_flag_test_block(drop_block, succ, unwind)\n+    }\n \n-        self.drop_flag_test_block(is_cleanup, drop_block, succ)\n+    fn drop_flag_reset_block(&mut self,\n+                             mode: DropFlagMode,\n+                             succ: BasicBlock,\n+                             unwind: Unwind) -> BasicBlock\n+    {\n+        debug!(\"drop_flag_reset_block({:?},{:?})\", self, mode);\n+\n+        let block = self.new_block(unwind, TerminatorKind::Goto { target: succ });\n+        let block_start = Location { block: block, statement_index: 0 };\n+        self.elaborator.clear_drop_flag(block_start, self.path, mode);\n+        block\n     }\n \n     fn elaborated_drop_block<'a>(&mut self) -> BasicBlock {\n         debug!(\"elaborated_drop_block({:?})\", self);\n-        let is_cleanup = self.is_cleanup; // FIXME(#6393)\n+        let unwind = self.unwind; // FIXME(#6393)\n         let succ = self.succ;\n-        let blk = self.drop_block(is_cleanup, succ);\n+        let blk = self.drop_block(succ, unwind);\n         self.elaborate_drop(blk);\n         blk\n     }\n@@ -609,17 +822,17 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         &mut self,\n         ty: Ty<'tcx>,\n         target: BasicBlock,\n-        is_cleanup: bool\n+        unwind: Unwind,\n     ) -> BasicBlock {\n-        let block = self.unelaborated_free_block(ty, target, is_cleanup);\n-        self.drop_flag_test_block(is_cleanup, block, target)\n+        let block = self.unelaborated_free_block(ty, target, unwind);\n+        self.drop_flag_test_block(block, target, unwind)\n     }\n \n     fn unelaborated_free_block<'a>(\n         &mut self,\n         ty: Ty<'tcx>,\n         target: BasicBlock,\n-        is_cleanup: bool\n+        unwind: Unwind\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n         let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n@@ -632,45 +845,45 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             destination: Some((unit_temp, target)),\n             cleanup: None\n         }; // FIXME(#6393)\n-        let free_block = self.new_block(is_cleanup, call);\n+        let free_block = self.new_block(unwind, call);\n \n         let block_start = Location { block: free_block, statement_index: 0 };\n         self.elaborator.clear_drop_flag(block_start, self.path, DropFlagMode::Shallow);\n         free_block\n     }\n \n-    fn drop_block<'a>(&mut self, is_cleanup: bool, succ: BasicBlock) -> BasicBlock {\n+    fn drop_block<'a>(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n         let block = TerminatorKind::Drop {\n             location: self.lvalue.clone(),\n-            target: succ,\n-            unwind: if is_cleanup { None } else { self.unwind }\n+            target: target,\n+            unwind: unwind.into_option()\n         };\n-        self.new_block(is_cleanup, block)\n+        self.new_block(unwind, block)\n     }\n \n     fn drop_flag_test_block(&mut self,\n-                            is_cleanup: bool,\n                             on_set: BasicBlock,\n-                            on_unset: BasicBlock)\n+                            on_unset: BasicBlock,\n+                            unwind: Unwind)\n                             -> BasicBlock\n     {\n         let style = self.elaborator.drop_style(self.path, DropFlagMode::Shallow);\n-        debug!(\"drop_flag_test_block({:?},{:?},{:?}) - {:?}\",\n-               self, is_cleanup, on_set, style);\n+        debug!(\"drop_flag_test_block({:?},{:?},{:?},{:?}) - {:?}\",\n+               self, on_set, on_unset, unwind, style);\n \n         match style {\n             DropStyle::Dead => on_unset,\n             DropStyle::Static => on_set,\n             DropStyle::Conditional | DropStyle::Open => {\n                 let flag = self.elaborator.get_drop_flag(self.path).unwrap();\n                 let term = TerminatorKind::if_(self.tcx(), flag, on_set, on_unset);\n-                self.new_block(is_cleanup, term)\n+                self.new_block(unwind, term)\n             }\n         }\n     }\n \n     fn new_block<'a>(&mut self,\n-                     is_cleanup: bool,\n+                     unwind: Unwind,\n                      k: TerminatorKind<'tcx>)\n                      -> BasicBlock\n     {\n@@ -679,7 +892,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             terminator: Some(Terminator {\n                 source_info: self.source_info, kind: k\n             }),\n-            is_cleanup: is_cleanup\n+            is_cleanup: unwind.is_cleanup()\n         })\n     }\n \n@@ -691,4 +904,19 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let mir = self.elaborator.mir();\n         self.elaborator.patch().terminator_loc(mir, bb)\n     }\n+\n+    fn constant_usize(&self, val: u16) -> Operand<'tcx> {\n+        Operand::Constant(box Constant {\n+            span: self.source_info.span,\n+            ty: self.tcx().types.usize,\n+            literal: Literal::Value { value: ConstVal::Integral(self.tcx().const_usize(val)) }\n+        })\n+    }\n+\n+    fn assign(&self, lhs: &Lvalue<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n+        Statement {\n+            source_info: self.source_info,\n+            kind: StatementKind::Assign(lhs.clone(), rhs)\n+        }\n+    }\n }"}, {"sha": "e29da3a6496552cc9b43bef6b449649e2f4c7a17", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             Rvalue::CheckedBinaryOp(..) => \"Rvalue::CheckedBinaryOp\",\n             Rvalue::UnaryOp(..) => \"Rvalue::UnaryOp\",\n             Rvalue::Discriminant(..) => \"Rvalue::Discriminant\",\n-            Rvalue::Box(..) => \"Rvalue::Box\",\n+            Rvalue::NullaryOp(..) => \"Rvalue::NullaryOp\",\n             Rvalue::Aggregate(ref kind, ref _operands) => {\n                 // AggregateKind is not distinguished by visit API, so\n                 // record it. (`super_rvalue` handles `_operands`.)"}, {"sha": "120f201a9c8b73ef6bd4a93f079f96cc1cf5094a", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{type_is_fat_ptr, C_uint};\n+use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_uint};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -610,6 +610,14 @@ pub struct FnType<'tcx> {\n }\n \n impl<'a, 'tcx> FnType<'tcx> {\n+    pub fn of_instance(ccx: &CrateContext<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+                       -> Self {\n+        let fn_ty = instance_ty(ccx.shared(), &instance);\n+        let sig = ty_fn_sig(ccx, fn_ty);\n+        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+        Self::new(ccx, sig, &[])\n+    }\n+\n     pub fn new(ccx: &CrateContext<'a, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n@@ -631,6 +639,8 @@ impl<'a, 'tcx> FnType<'tcx> {\n     pub fn unadjusted(ccx: &CrateContext<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n+        debug!(\"FnType::unadjusted({:?}, {:?})\", sig, extra_args);\n+\n         use self::Abi::*;\n         let cconv = match ccx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |"}, {"sha": "da74ed88eaf857d87e3530ccdf65f5360244fab9", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -502,7 +502,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     _ => bug!(),\n                 }\n             }\n-            mir::Rvalue::Box(..) => {\n+            mir::Rvalue::NullaryOp(mir::NullOp::Box, _) => {\n                 let tcx = self.scx.tcx();\n                 let exchange_malloc_fn_def_id = tcx\n                     .lang_items\n@@ -612,17 +612,7 @@ fn visit_instance_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 output.push(create_fn_trans_item(instance));\n             }\n         }\n-        ty::InstanceDef::DropGlue(_, Some(ty)) => {\n-            match ty.sty {\n-                ty::TyArray(ety, _) |\n-                ty::TySlice(ety)\n-                    if is_direct_call =>\n-                {\n-                    // drop of arrays/slices is translated in-line.\n-                    visit_drop_use(scx, ety, false, output);\n-                }\n-                _ => {}\n-            };\n+        ty::InstanceDef::DropGlue(_, Some(_)) => {\n             output.push(create_fn_trans_item(instance));\n         }\n         ty::InstanceDef::ClosureOnceShim { .. } |"}, {"sha": "a6f3fb709a01b67f5cc4532f74e4d7809041c005", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -191,15 +191,6 @@ impl Funclet {\n     }\n }\n \n-impl Clone for Funclet {\n-    fn clone(&self) -> Funclet {\n-        Funclet {\n-            cleanuppad: self.cleanuppad,\n-            operand: OperandBundleDef::new(\"funclet\", &[self.cleanuppad]),\n-        }\n-    }\n-}\n-\n pub fn val_ty(v: ValueRef) -> Type {\n     unsafe {\n         Type::from_ref(llvm::LLVMTypeOf(v))"}, {"sha": "fa400b54d2708ed98b4d2e7f0d7df0bc54617ec9", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -76,6 +76,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n         let align = C_uint(bcx.ccx, align);\n         return (size, align);\n     }\n+    assert!(!info.is_null());\n     match t.sty {\n         ty::TyAdt(def, substs) => {\n             let ccx = bcx.ccx;"}, {"sha": "45afcf51b5203d18ae46287ad6484b2632771ce7", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -197,6 +197,16 @@ pub enum CleanupKind {\n     Internal { funclet: mir::BasicBlock }\n }\n \n+impl CleanupKind {\n+    pub fn funclet_bb(self, for_bb: mir::BasicBlock) -> Option<mir::BasicBlock> {\n+        match self {\n+            CleanupKind::NotCleanup => None,\n+            CleanupKind::Funclet => Some(for_bb),\n+            CleanupKind::Internal { funclet } => Some(funclet),\n+        }\n+    }\n+}\n+\n pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n     fn discover_masters<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n                               mir: &mir::Mir<'tcx>) {\n@@ -260,7 +270,9 @@ pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock\n                         result[succ] = CleanupKind::Internal { funclet: funclet };\n                     }\n                     CleanupKind::Funclet => {\n-                        set_successor(funclet, succ);\n+                        if funclet != succ {\n+                            set_successor(funclet, succ);\n+                        }\n                     }\n                     CleanupKind::Internal { funclet: succ_funclet } => {\n                         if funclet != succ_funclet {"}, {"sha": "4926485a121256e95afca19ce19a057100384434", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 111, "deletions": 142, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -19,100 +19,147 @@ use adt;\n use base::{self, Lifetime};\n use callee;\n use builder::Builder;\n-use common::{self, Funclet};\n-use common::{C_bool, C_str_slice, C_struct, C_u32, C_uint, C_undef};\n+use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use machine::llalign_of_min;\n use meth;\n use monomorphize;\n use type_of;\n-use tvec;\n use type_::Type;\n \n-use rustc_data_structures::indexed_vec::IndexVec;\n use syntax::symbol::Symbol;\n \n use std::cmp;\n \n use super::{MirContext, LocalRef};\n-use super::analyze::CleanupKind;\n use super::constant::Const;\n use super::lvalue::{Alignment, LvalueRef};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n-    pub fn trans_block(&mut self, bb: mir::BasicBlock,\n-        funclets: &IndexVec<mir::BasicBlock, Option<Funclet>>) {\n+    pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         let mut bcx = self.get_builder(bb);\n         let data = &self.mir[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n \n-        let funclet = match self.cleanup_kinds[bb] {\n-            CleanupKind::Internal { funclet } => funclets[funclet].as_ref(),\n-            _ => funclets[bb].as_ref(),\n-        };\n+        for statement in &data.statements {\n+            bcx = self.trans_statement(bcx, statement);\n+        }\n+\n+        self.trans_terminator(bcx, bb, data.terminator());\n+    }\n+\n+    fn trans_terminator(&mut self,\n+                        mut bcx: Builder<'a, 'tcx>,\n+                        bb: mir::BasicBlock,\n+                        terminator: &mir::Terminator<'tcx>)\n+    {\n+        debug!(\"trans_terminator: {:?}\", terminator);\n \n         // Create the cleanup bundle, if needed.\n+        let tcx = bcx.tcx();\n+        let span = terminator.source_info.span;\n+        let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n+        let funclet = funclet_bb.and_then(|funclet_bb| self.funclets[funclet_bb].as_ref());\n+\n         let cleanup_pad = funclet.map(|lp| lp.cleanuppad());\n         let cleanup_bundle = funclet.map(|l| l.bundle());\n \n-        let funclet_br = |this: &Self, bcx: Builder, bb: mir::BasicBlock| {\n-            let lltarget = this.blocks[bb];\n-            if let Some(cp) = cleanup_pad {\n-                match this.cleanup_kinds[bb] {\n-                    CleanupKind::Funclet => {\n-                        // micro-optimization: generate a `ret` rather than a jump\n-                        // to a return block\n-                        bcx.cleanup_ret(cp, Some(lltarget));\n-                    }\n-                    CleanupKind::Internal { .. } => bcx.br(lltarget),\n-                    CleanupKind::NotCleanup => bug!(\"jump from cleanup bb to bb {:?}\", bb)\n+        let lltarget = |this: &mut Self, target: mir::BasicBlock| {\n+            let lltarget = this.blocks[target];\n+            let target_funclet = this.cleanup_kinds[target].funclet_bb(target);\n+            match (funclet_bb, target_funclet) {\n+                (None, None) => (lltarget, false),\n+                (Some(f), Some(t_f))\n+                    if f == t_f || !base::wants_msvc_seh(tcx.sess)\n+                    => (lltarget, false),\n+                (None, Some(_)) => {\n+                    // jump *into* cleanup - need a landing pad if GNU\n+                    (this.landing_pad_to(target), false)\n+                }\n+                (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", terminator),\n+                (Some(_), Some(_)) => {\n+                    (this.landing_pad_to(target), true)\n                 }\n-            } else {\n-                bcx.br(lltarget);\n             }\n         };\n \n         let llblock = |this: &mut Self, target: mir::BasicBlock| {\n-            let lltarget = this.blocks[target];\n+            let (lltarget, is_cleanupret) = lltarget(this, target);\n+            if is_cleanupret {\n+                // MSVC cross-funclet jump - need a trampoline\n+\n+                debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n+                let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n+                let trampoline = this.new_block(name);\n+                trampoline.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n+                trampoline.llbb()\n+            } else {\n+                lltarget\n+            }\n+        };\n \n-            if let Some(cp) = cleanup_pad {\n-                match this.cleanup_kinds[target] {\n-                    CleanupKind::Funclet => {\n-                        // MSVC cross-funclet jump - need a trampoline\n+        let funclet_br = |this: &mut Self, bcx: Builder, target: mir::BasicBlock| {\n+            let (lltarget, is_cleanupret) = lltarget(this, target);\n+            if is_cleanupret {\n+                // micro-optimization: generate a `ret` rather than a jump\n+                // to a trampoline.\n+                bcx.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n+            } else {\n+                bcx.br(lltarget);\n+            }\n+        };\n \n-                        debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n-                        let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                        let trampoline = this.new_block(name);\n-                        trampoline.cleanup_ret(cp, Some(lltarget));\n-                        trampoline.llbb()\n-                    }\n-                    CleanupKind::Internal { .. } => lltarget,\n-                    CleanupKind::NotCleanup =>\n-                        bug!(\"jump from cleanup bb {:?} to bb {:?}\", bb, target)\n+        let do_call = |\n+            this: &mut Self,\n+            bcx: Builder<'a, 'tcx>,\n+            fn_ty: FnType<'tcx>,\n+            fn_ptr: ValueRef,\n+            llargs: &[ValueRef],\n+            destination: Option<(ReturnDest, ty::Ty<'tcx>, mir::BasicBlock)>,\n+            cleanup: Option<mir::BasicBlock>\n+        | {\n+            if let Some(cleanup) = cleanup {\n+                let ret_bcx = if let Some((_, _, target)) = destination {\n+                    this.blocks[target]\n+                } else {\n+                    this.unreachable_block()\n+                };\n+                let invokeret = bcx.invoke(fn_ptr,\n+                                           &llargs,\n+                                           ret_bcx,\n+                                           llblock(this, cleanup),\n+                                           cleanup_bundle);\n+                fn_ty.apply_attrs_callsite(invokeret);\n+\n+                if let Some((ret_dest, ret_ty, target)) = destination {\n+                    let ret_bcx = this.get_builder(target);\n+                    this.set_debug_loc(&ret_bcx, terminator.source_info);\n+                    let op = OperandRef {\n+                        val: Immediate(invokeret),\n+                        ty: ret_ty,\n+                    };\n+                    this.store_return(&ret_bcx, ret_dest, &fn_ty.ret, op);\n                 }\n             } else {\n-                if let (CleanupKind::NotCleanup, CleanupKind::Funclet) =\n-                    (this.cleanup_kinds[bb], this.cleanup_kinds[target])\n-                {\n-                    // jump *into* cleanup - need a landing pad if GNU\n-                    this.landing_pad_to(target)\n+                let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n+                fn_ty.apply_attrs_callsite(llret);\n+\n+                if let Some((ret_dest, ret_ty, target)) = destination {\n+                    let op = OperandRef {\n+                        val: Immediate(llret),\n+                        ty: ret_ty,\n+                    };\n+                    this.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n+                    funclet_br(this, bcx, target);\n                 } else {\n-                    lltarget\n+                    bcx.unreachable();\n                 }\n             }\n         };\n \n-        for statement in &data.statements {\n-            bcx = self.trans_statement(bcx, statement);\n-        }\n-\n-        let terminator = data.terminator();\n-        debug!(\"trans_block: terminator: {:?}\", terminator);\n-\n-        let span = terminator.source_info.span;\n         self.set_debug_loc(&bcx, terminator.source_info);\n         match terminator.kind {\n             mir::TerminatorKind::Resume => {\n@@ -219,52 +266,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let lvalue = self.trans_lvalue(&bcx, location);\n+                let fn_ty = FnType::of_instance(bcx.ccx, &drop_fn);\n                 let (drop_fn, need_extra) = match ty.sty {\n                     ty::TyDynamic(..) => (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra),\n                                           false),\n-                    ty::TyArray(ety, _) | ty::TySlice(ety) => {\n-                        // FIXME: handle panics\n-                        let drop_fn = monomorphize::resolve_drop_in_place(\n-                            bcx.ccx.shared(), ety);\n-                        let drop_fn = callee::get_fn(bcx.ccx, drop_fn);\n-                        let bcx = tvec::slice_for_each(\n-                            &bcx,\n-                            lvalue.project_index(&bcx, C_uint(bcx.ccx, 0u64)),\n-                            ety,\n-                            lvalue.len(bcx.ccx),\n-                            |bcx, llval, loop_bb| {\n-                                self.set_debug_loc(&bcx, terminator.source_info);\n-                                if let Some(unwind) = unwind {\n-                                    bcx.invoke(\n-                                        drop_fn,\n-                                        &[llval],\n-                                        loop_bb,\n-                                        llblock(self, unwind),\n-                                        cleanup_bundle\n-                                    );\n-                                } else {\n-                                    bcx.call(drop_fn, &[llval], cleanup_bundle);\n-                                    bcx.br(loop_bb);\n-                                }\n-                            });\n-                        funclet_br(self, bcx, target);\n-                        return\n-                    }\n                     _ => (callee::get_fn(bcx.ccx, drop_fn), lvalue.has_extra())\n                 };\n                 let args = &[lvalue.llval, lvalue.llextra][..1 + need_extra as usize];\n-                if let Some(unwind) = unwind {\n-                    bcx.invoke(\n-                        drop_fn,\n-                        args,\n-                        self.blocks[target],\n-                        llblock(self, unwind),\n-                        cleanup_bundle\n-                    );\n-                } else {\n-                    bcx.call(drop_fn, args, cleanup_bundle);\n-                    funclet_br(self, bcx, target);\n-                }\n+                do_call(self, bcx, fn_ty, drop_fn, args,\n+                        Some((ReturnDest::Nothing, tcx.mk_nil(), target)),\n+                        unwind);\n             }\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n@@ -371,26 +382,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n                 let instance = ty::Instance::mono(bcx.tcx(), def_id);\n+                let fn_ty = FnType::of_instance(bcx.ccx, &instance);\n                 let llfn = callee::get_fn(bcx.ccx, instance);\n \n                 // Translate the actual panic invoke/call.\n-                if let Some(unwind) = cleanup {\n-                    bcx.invoke(llfn,\n-                               &args,\n-                               self.unreachable_block(),\n-                               llblock(self, unwind),\n-                               cleanup_bundle);\n-                } else {\n-                    bcx.call(llfn, &args, cleanup_bundle);\n-                    bcx.unreachable();\n-                }\n+                do_call(self, bcx, fn_ty, llfn, &args, None, cleanup);\n             }\n \n             mir::TerminatorKind::DropAndReplace { .. } => {\n-                bug!(\"undesugared DropAndReplace in trans: {:?}\", data);\n+                bug!(\"undesugared DropAndReplace in trans: {:?}\", terminator);\n             }\n \n-            mir::TerminatorKind::Call { ref func, ref args, ref destination, ref cleanup } => {\n+            mir::TerminatorKind::Call { ref func, ref args, ref destination, cleanup } => {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n@@ -543,43 +546,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n-                // Many different ways to call a function handled here\n-                if let &Some(cleanup) = cleanup {\n-                    let ret_bcx = if let Some((_, target)) = *destination {\n-                        self.blocks[target]\n-                    } else {\n-                        self.unreachable_block()\n-                    };\n-                    let invokeret = bcx.invoke(fn_ptr,\n-                                               &llargs,\n-                                               ret_bcx,\n-                                               llblock(self, cleanup),\n-                                               cleanup_bundle);\n-                    fn_ty.apply_attrs_callsite(invokeret);\n-\n-                    if let Some((_, target)) = *destination {\n-                        let ret_bcx = self.get_builder(target);\n-                        self.set_debug_loc(&ret_bcx, terminator.source_info);\n-                        let op = OperandRef {\n-                            val: Immediate(invokeret),\n-                            ty: sig.output(),\n-                        };\n-                        self.store_return(&ret_bcx, ret_dest, &fn_ty.ret, op);\n-                    }\n-                } else {\n-                    let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n-                    fn_ty.apply_attrs_callsite(llret);\n-                    if let Some((_, target)) = *destination {\n-                        let op = OperandRef {\n-                            val: Immediate(llret),\n-                            ty: sig.output(),\n-                        };\n-                        self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n-                        funclet_br(self, bcx, target);\n-                    } else {\n-                        bcx.unreachable();\n-                    }\n-                }\n+                do_call(self, bcx, fn_ty, fn_ptr, &llargs,\n+                        destination.as_ref().map(|&(_, target)| (ret_dest, sig.output(), target)),\n+                        cleanup);\n             }\n         }\n     }\n@@ -774,7 +743,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn landing_pad_uncached(&mut self, target_bb: BasicBlockRef) -> BasicBlockRef {\n         if base::wants_msvc_seh(self.ccx.sess()) {\n-            return target_bb;\n+            span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n \n         let bcx = self.new_block(\"cleanup\");"}, {"sha": "4967ef2f7908b2236ff821e6efbab6363b0e3cfd", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -796,6 +796,12 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 Const::new(llval, operand.ty)\n             }\n \n+            mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n+                assert!(self.ccx.shared().type_is_sized(ty));\n+                let llval = C_uint(self.ccx, self.ccx.size_of(ty));\n+                Const::new(llval, tcx.types.usize)\n+            }\n+\n             _ => span_bug!(span, \"{:?} in constant\", rvalue)\n         };\n \n@@ -870,6 +876,7 @@ pub fn const_scalar_binop(op: mir::BinOp,\n                     llvm::LLVMConstICmp(cmp, lhs, rhs)\n                 }\n             }\n+            mir::BinOp::Offset => unreachable!(\"BinOp::Offset in const-eval!\")\n         }\n     }\n }"}, {"sha": "a7f12babb10f96c01f16b81862e1a2acb3931e81", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -69,6 +69,10 @@ pub struct MirContext<'a, 'tcx:'a> {\n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n+    /// When targeting MSVC, this stores the cleanup info for each funclet\n+    /// BB. This is initialized as we compute the funclets' head block in RPO.\n+    funclets: &'a IndexVec<mir::BasicBlock, Option<Funclet>>,\n+\n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n     landing_pads: IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n@@ -202,8 +206,11 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         debuginfo::create_function_debug_context(ccx, instance, sig, llfn, mir);\n     let bcx = Builder::new_block(ccx, llfn, \"start\");\n \n-    let cleanup_kinds = analyze::cleanup_kinds(&mir);\n+    if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n+        bcx.set_personality_fn(ccx.eh_personality());\n+    }\n \n+    let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n     let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n@@ -218,6 +225,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n     // Compute debuginfo scopes from MIR scopes.\n     let scopes = debuginfo::create_mir_scopes(ccx, mir, &debug_context);\n+    let (landing_pads, funclets) = create_funclets(&bcx, &cleanup_kinds, &block_bcxs);\n \n     let mut mircx = MirContext {\n         mir: mir,\n@@ -228,7 +236,8 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         blocks: block_bcxs,\n         unreachable_block: None,\n         cleanup_kinds: cleanup_kinds,\n-        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n+        landing_pads: landing_pads,\n+        funclets: &funclets,\n         scopes: scopes,\n         locals: IndexVec::new(),\n         debug_context: debug_context,\n@@ -306,28 +315,13 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     // emitting should be enabled.\n     debuginfo::start_emitting_source_locations(&mircx.debug_context);\n \n-    let funclets: IndexVec<mir::BasicBlock, Option<Funclet>> =\n-    mircx.cleanup_kinds.iter_enumerated().map(|(bb, cleanup_kind)| {\n-        if let CleanupKind::Funclet = *cleanup_kind {\n-            let bcx = mircx.get_builder(bb);\n-            unsafe {\n-                llvm::LLVMSetPersonalityFn(mircx.llfn, mircx.ccx.eh_personality());\n-            }\n-            if base::wants_msvc_seh(ccx.sess()) {\n-                return Some(Funclet::new(bcx.cleanup_pad(None, &[])));\n-            }\n-        }\n-\n-        None\n-    }).collect();\n-\n     let rpo = traversal::reverse_postorder(&mir);\n     let mut visited = BitVector::new(mir.basic_blocks().len());\n \n     // Translate the body of each block using reverse postorder\n     for (bb, _) in rpo {\n         visited.insert(bb.index());\n-        mircx.trans_block(bb, &funclets);\n+        mircx.trans_block(bb);\n     }\n \n     // Remove blocks that haven't been visited, or have no\n@@ -343,6 +337,26 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     }\n }\n \n+fn create_funclets<'a, 'tcx>(\n+    bcx: &Builder<'a, 'tcx>,\n+    cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n+    block_bcxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n+    -> (IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n+        IndexVec<mir::BasicBlock, Option<Funclet>>)\n+{\n+    block_bcxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n+        match *cleanup_kind {\n+            CleanupKind::Funclet if base::wants_msvc_seh(bcx.sess()) => {\n+                let cleanup_bcx = bcx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n+                let cleanup = cleanup_bcx.cleanup_pad(None, &[]);\n+                cleanup_bcx.br(llbb);\n+                (Some(cleanup_bcx.llbb()), Some(Funclet::new(cleanup)))\n+            }\n+            _ => (None, None)\n+        }\n+    }).unzip()\n+}\n+\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect."}, {"sha": "a12d0fec1cdd06f31a0a00bb07562f4b06967933", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     pub fn deref(self) -> LvalueRef<'tcx> {\n         let projected_ty = self.ty.builtin_deref(true, ty::NoPreference)\n-            .unwrap().ty;\n+            .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),\n             OperandValue::Pair(llptr, llextra) => (llptr, llextra),"}, {"sha": "61e537c9cc0c9488f5e1e85e5a646a2cd214b6c7", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -432,7 +432,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 })\n             }\n \n-            mir::Rvalue::Box(content_ty) => {\n+            mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n+                assert!(bcx.ccx.shared().type_is_sized(ty));\n+                let val = C_uint(bcx.ccx, bcx.ccx.size_of(ty));\n+                let tcx = bcx.tcx();\n+                (bcx, OperandRef {\n+                    val: OperandValue::Immediate(val),\n+                    ty: tcx.types.usize,\n+                })\n+            }\n+\n+            mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n                 let llty = type_of::type_of(bcx.ccx, content_ty);\n                 let llsize = machine::llsize_of(bcx.ccx, llty);\n@@ -515,6 +525,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::BinOp::BitOr => bcx.or(lhs, rhs),\n             mir::BinOp::BitAnd => bcx.and(lhs, rhs),\n             mir::BinOp::BitXor => bcx.xor(lhs, rhs),\n+            mir::BinOp::Offset => bcx.inbounds_gep(lhs, &[rhs]),\n             mir::BinOp::Shl => common::build_unchecked_lshift(bcx, lhs, rhs),\n             mir::BinOp::Shr => common::build_unchecked_rshift(bcx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n@@ -660,7 +671,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::CheckedBinaryOp(..) |\n             mir::Rvalue::UnaryOp(..) |\n             mir::Rvalue::Discriminant(..) |\n-            mir::Rvalue::Box(..) |\n+            mir::Rvalue::NullaryOp(..) |\n             mir::Rvalue::Use(..) => // (*)\n                 true,\n             mir::Rvalue::Repeat(..) |"}, {"sha": "fb3bcd31e21fcbaffe0dbcf0bca3cd3a9a34f315", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -100,6 +100,7 @@ pub fn provide(providers: &mut Providers) {\n         impl_trait_ref,\n         impl_polarity,\n         is_foreign_item,\n+        is_default_impl,\n         ..*providers\n     };\n }\n@@ -1545,3 +1546,14 @@ fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id)\n     }\n }\n+\n+fn is_default_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             def_id: DefId)\n+                             -> bool {\n+    match tcx.hir.get_if_local(def_id) {\n+        Some(hir_map::NodeItem(&hir::Item { node: hir::ItemDefaultImpl(..), .. }))\n+             => true,\n+        Some(_) => false,\n+        _ => bug!(\"is_default_impl applied to non-local def-id {:?}\", def_id)\n+    }\n+}"}, {"sha": "8f7add14d0a058a70679082c925318eae8a57121", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -290,7 +290,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     }\n \n     // If this is a defaulted impl, then bail out early here\n-    if tcx.sess.cstore.is_default_impl(did) {\n+    if tcx.is_default_impl(did) {\n         return ret.push(clean::Item {\n             inner: clean::DefaultImplItem(clean::DefaultImpl {\n                 // FIXME: this should be decoded"}, {"sha": "838c180c70b75c539f6f0c9f42031b77dc8d5855", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -781,11 +781,15 @@ extern \"C\" void LLVMRustWriteTypeToString(LLVMTypeRef Ty, RustStringRef Str) {\n extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef V,\n                                            RustStringRef Str) {\n   RawRustStringOstream OS(Str);\n-  OS << \"(\";\n-  unwrap<llvm::Value>(V)->getType()->print(OS);\n-  OS << \":\";\n-  unwrap<llvm::Value>(V)->print(OS);\n-  OS << \")\";\n+  if (!V) {\n+    OS << \"(null)\";\n+  } else {\n+    OS << \"(\";\n+    unwrap<llvm::Value>(V)->getType()->print(OS);\n+    OS << \":\";\n+    unwrap<llvm::Value>(V)->print(OS);\n+    OS << \")\";\n+  }\n }\n \n extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef DstRef, char *BC,"}, {"sha": "ea4d7d3165d061f5e5371855e9513129bb7c2e27", "filename": "src/test/mir-opt/issue-41888.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Ftest%2Fmir-opt%2Fissue-41888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Ftest%2Fmir-opt%2Fissue-41888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41888.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that we clear the \"ADT master drop flag\" even when there are\n+// no fields to be dropped.\n+\n+fn main() {\n+    let e;\n+    if cond() {\n+        e = E::F(K);\n+        if let E::F(_k) = e {\n+            // older versions of rustc used to not clear the\n+            // drop flag for `e` in this path.\n+        }\n+    }\n+}\n+\n+fn cond() -> bool { false }\n+\n+struct K;\n+\n+enum E {\n+    F(K),\n+    G(Box<E>)\n+}\n+\n+// END RUST SOURCE\n+// fn main() -> () {\n+//     let mut _0: ();\n+//     scope 1 {\n+//         let _1: E; // `e`\n+//         scope 2 {\n+//             let _6: K;\n+//         }\n+//     }\n+//     let mut _2: bool;\n+//     let mut _3: ();\n+//     let mut _4: E;\n+//     let mut _5: K;\n+//     let mut _7: isize;\n+//     let mut _8: bool; // drop flag for `e`\n+//     let mut _9: bool;\n+//     let mut _10: bool;\n+//     let mut _11: isize;\n+//     let mut _12: isize;\n+//\n+//     bb0: {\n+//         _8 = const false;\n+//         _10 = const false;\n+//         _9 = const false;\n+//         StorageLive(_1);\n+//         StorageLive(_2);\n+//         _2 = const cond() -> [return: bb3, unwind: bb2];\n+//     }\n+//\n+//     bb1: {\n+//         resume;\n+//     }\n+//\n+//     bb2: {\n+//         goto -> bb1;\n+//     }\n+//\n+//     bb3: {\n+//         switchInt(_2) -> [0u8: bb5, otherwise: bb4];\n+//     }\n+//\n+//     bb4: {\n+//         StorageLive(_4);\n+//         StorageLive(_5);\n+//         _5 = K::{{constructor}};\n+//         _4 = E::F(_5,);\n+//         StorageDead(_5);\n+//         goto -> bb15;\n+//     }\n+//\n+//     bb5: {\n+//         _0 = ();\n+//         goto -> bb12;\n+//     }\n+//\n+//     bb6: {\n+//         goto -> bb2;\n+//     }\n+//\n+//     bb7: {\n+//         goto -> bb8;\n+//     }\n+//\n+//     bb8: {\n+//         StorageDead(_4);\n+//         _7 = discriminant(_1);\n+//         switchInt(_7) -> [0isize: bb10, otherwise: bb9];\n+//     }\n+//\n+//     bb9: {\n+//         _0 = ();\n+//         goto -> bb11;\n+//     }\n+//\n+//     bb10: {\n+//         StorageLive(_6);\n+//         _10 = const false;\n+//         _6 = ((_1 as F).0: K);\n+//         _0 = ();\n+//         goto -> bb11;\n+//     }\n+//\n+//     bb11: {\n+//         StorageDead(_6);\n+//         goto -> bb12;\n+//     }\n+//\n+//     bb12: {\n+//         StorageDead(_2);\n+//         goto -> bb22;\n+//     }\n+//\n+//     bb13: {\n+//         StorageDead(_1);\n+//         return;\n+//     }\n+//\n+//     bb14: {\n+//         _8 = const true;\n+//         _9 = const true;\n+//         _10 = const true;\n+//         _1 = _4;\n+//         goto -> bb6;\n+//     }\n+//\n+//     bb15: {\n+//         _8 = const true;\n+//         _9 = const true;\n+//         _10 = const true;\n+//         _1 = _4;\n+//         goto -> bb7;\n+//     }\n+//\n+//     bb16: {\n+//         _8 = const false; // clear the drop flag - must always be reached\n+//         goto -> bb13;\n+//     }\n+//\n+//     bb17: {\n+//         _8 = const false;\n+//         goto -> bb1;\n+//     }\n+//\n+//     bb18: {\n+//         goto -> bb17;\n+//     }\n+//\n+//     bb19: {\n+//         drop(_1) -> [return: bb16, unwind: bb17];\n+//     }\n+//\n+//     bb20: {\n+//         drop(_1) -> bb17;\n+//     }\n+//\n+//     bb21: {\n+//         _11 = discriminant(_1);\n+//         switchInt(_11) -> [0isize: bb16, otherwise: bb19];\n+//     }\n+//\n+//     bb22: {\n+//         switchInt(_8) -> [0u8: bb16, otherwise: bb21];\n+//     }\n+//\n+//     bb23: {\n+//         _12 = discriminant(_1);\n+//         switchInt(_12) -> [0isize: bb18, otherwise: bb20];\n+//     }\n+//\n+//     bb24: {\n+//         switchInt(_8) -> [0u8: bb17, otherwise: bb23];\n+//     }\n+// }"}, {"sha": "6725a0c547f1dfaeb2e680c29774a68ee830c31b", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -90,6 +90,22 @@ fn dynamic_drop(a: &Allocator, c: bool) {\n     };\n }\n \n+struct TwoPtrs<'a>(Ptr<'a>, Ptr<'a>);\n+fn struct_dynamic_drop(a: &Allocator, c0: bool, c1: bool, c: bool) {\n+    for i in 0..2 {\n+        let x;\n+        let y;\n+        if (c0 && i == 0) || (c1 && i == 1) {\n+            x = (a.alloc(), a.alloc(), a.alloc());\n+            y = TwoPtrs(a.alloc(), a.alloc());\n+            if c {\n+                drop(x.1);\n+                drop(y.0);\n+            }\n+        }\n+    }\n+}\n+\n fn assignment2(a: &Allocator, c0: bool, c1: bool) {\n     let mut _v = a.alloc();\n     let mut _w = a.alloc();\n@@ -125,6 +141,14 @@ fn union1(a: &Allocator) {\n     }\n }\n \n+fn array_simple(a: &Allocator) {\n+    let _x = [a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+}\n+\n+fn vec_simple(a: &Allocator) {\n+    let _x = vec![a.alloc(), a.alloc(), a.alloc(), a.alloc()];\n+}\n+\n fn run_test<F>(mut f: F)\n     where F: FnMut(&Allocator)\n {\n@@ -171,5 +195,17 @@ fn main() {\n     run_test(|a| assignment1(a, false));\n     run_test(|a| assignment1(a, true));\n \n+    run_test(|a| array_simple(a));\n+    run_test(|a| vec_simple(a));\n+\n+    run_test(|a| struct_dynamic_drop(a, false, false, false));\n+    run_test(|a| struct_dynamic_drop(a, false, false, true));\n+    run_test(|a| struct_dynamic_drop(a, false, true, false));\n+    run_test(|a| struct_dynamic_drop(a, false, true, true));\n+    run_test(|a| struct_dynamic_drop(a, true, false, false));\n+    run_test(|a| struct_dynamic_drop(a, true, false, true));\n+    run_test(|a| struct_dynamic_drop(a, true, true, false));\n+    run_test(|a| struct_dynamic_drop(a, true, true, true));\n+\n     run_test_nopanic(|a| union1(a));\n }"}, {"sha": "e145cde039dfdcb33ccbc1cd001b149b5f308671", "filename": "src/test/run-pass/issue-41888.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Ftest%2Frun-pass%2Fissue-41888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924898f88a687d381b83fc1ba5bce8cad424ebc8/src%2Ftest%2Frun-pass%2Fissue-41888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41888.rs?ref=924898f88a687d381b83fc1ba5bce8cad424ebc8", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() { let _ = g(Some(E::F(K))); }\n+\n+type R = Result<(), ()>;\n+struct K;\n+\n+enum E {\n+    F(K), // must not be built-in type\n+    #[allow(dead_code)]\n+    G(Box<E>, Box<E>),\n+}\n+\n+fn translate(x: R) -> R { x }\n+\n+fn g(mut status: Option<E>) -> R {\n+    loop {\n+        match status {\n+            Some(infix_or_postfix) => match infix_or_postfix {\n+                E::F(_op) => { // <- must be captured by value\n+                    match Ok(()) {\n+                        Err(err) => return Err(err),\n+                        Ok(_) => {},\n+                    };\n+                }\n+                _ => (),\n+            },\n+            _ => match translate(Err(())) {\n+                Err(err) => return Err(err),\n+                Ok(_) => {},\n+            }\n+        }\n+        status = None;\n+    }\n+}"}]}