{"sha": "0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNmRmYzUxNzc3ZWIzODhiNmU3OTUzOTliZjFkM2Y4YWFjNTdkYjg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-04-21T22:46:23Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-03T15:30:10Z"}, "message": "require the non-last elements of a tuple to be Sized\n\nThis requirement appears to be missing from RFC1214, but is clearly\nnecessary for translation. The last field of a tuple/enum remains in\na state of limbo, compiling but causing an ICE when it is used - we\nshould eventually fix that somehow.\n\nthis is a [breaking-change] - a soundness fix - and requires a\ncrater run.", "tree": {"sha": "01f67adda8847634fa5ae03b3005be6868426f6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01f67adda8847634fa5ae03b3005be6868426f6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "html_url": "https://github.com/rust-lang/rust/commit/0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/babb5df529ceef1cc8c12143d6dd4ab21188cc3e", "html_url": "https://github.com/rust-lang/rust/commit/babb5df529ceef1cc8c12143d6dd4ab21188cc3e"}], "stats": {"total": 65, "additions": 46, "deletions": 19}, "files": [{"sha": "a881b539cedebf0ba5dbb4b2c6342f458c6c89ba", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "patch": "@@ -33,7 +33,7 @@ use mem;\n use intrinsics;\n \n /// Arithmetic operations required by bignums.\n-pub trait FullOps {\n+pub trait FullOps: Sized {\n     /// Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n     /// where `W` is the number of bits in `Self`.\n     fn full_add(self, other: Self, carry: bool) -> (bool /*carry*/, Self);"}, {"sha": "d02dfcd9ea7999d549933db40bf21ecb747a7692", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "patch": "@@ -764,6 +764,11 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n         ObligationCauseCode::SliceOrArrayElem => {\n             err.note(\"slice and array elements must have `Sized` type\");\n         }\n+        ObligationCauseCode::TupleElem => {\n+            err.fileline_note(\n+                cause_span,\n+                \"tuple elements must have `Sized` type\");\n+        }\n         ObligationCauseCode::ProjectionWf(data) => {\n             err.note(&format!(\"required so that the projection `{}` is well-formed\",\n                               data));"}, {"sha": "5921cdeab78677323a10071081d7b41246886410", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "patch": "@@ -106,9 +106,12 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n \n-    /// This is the trait reference from the given projection\n+    /// A slice or array is WF only if `T: Sized`\n     SliceOrArrayElem,\n \n+    /// A tuple is WF only if its middle elements are Sized\n+    TupleElem,\n+\n     /// This is the trait reference from the given projection\n     ProjectionWf(ty::ProjectionTy<'tcx>),\n "}, {"sha": "08a996c142d480e8182f678705a43757eb28582d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "patch": "@@ -1652,14 +1652,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n             ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyRawPtr(..) |\n             ty::TyChar | ty::TyBox(_) | ty::TyRef(..) |\n-            ty::TyArray(..) | ty::TyTuple(..) | ty::TyClosure(..) |\n+            ty::TyArray(..) | ty::TyClosure(..) |\n             ty::TyError => {\n                 // safe for everything\n                 Where(ty::Binder(Vec::new()))\n             }\n \n             ty::TyStr | ty::TySlice(_) | ty::TyTrait(..) => Never,\n \n+            ty::TyTuple(ref tys) => {\n+                Where(ty::Binder(match tys.last() {\n+                    Some(ty) => vec![ty],\n+                    _ => vec![]\n+                }))\n+            }\n+\n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here"}, {"sha": "b4156fde6a3bc592400b8820594fac12ef498ab4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "patch": "@@ -1761,8 +1761,8 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n         let tys : Vec<_> = tys.into_iter()\n             .map(|ty| self.sized_constraint_for_ty(tcx, stack, ty))\n             .flat_map(|ty| match ty.sty {\n-                ty::TyTuple(ref tys) => tys.clone(),\n-                _ => vec![ty]\n+                ty::TyTuple(ref tys) => tys.last().cloned(),\n+                _ => Some(ty)\n             })\n             .filter(|ty| *ty != tcx.types.bool)\n             .collect();"}, {"sha": "2dda63802e0f2dd0ff780649453bebc99edfdfaf", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "patch": "@@ -280,6 +280,22 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n         }\n     }\n \n+    fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n+        if !subty.has_escaping_regions() {\n+            let cause = self.cause(cause);\n+            match traits::trait_ref_for_builtin_bound(self.infcx.tcx,\n+                                                      ty::BoundSized,\n+                                                      subty) {\n+                Ok(trait_ref) => {\n+                    self.out.push(\n+                        traits::Obligation::new(cause,\n+                                                trait_ref.to_predicate()));\n+                }\n+                Err(ErrorReported) => { }\n+            }\n+        }\n+    }\n+\n     /// Push new obligations into `out`. Returns true if it was able\n     /// to generate all the predicates needed to validate that `ty0`\n     /// is WF. Returns false if `ty0` is an unresolved type variable,\n@@ -301,23 +317,18 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n \n                 ty::TySlice(subty) |\n                 ty::TyArray(subty, _) => {\n-                    if !subty.has_escaping_regions() {\n-                        let cause = self.cause(traits::SliceOrArrayElem);\n-                        match traits::trait_ref_for_builtin_bound(self.infcx.tcx,\n-                                                                  ty::BoundSized,\n-                                                                  subty) {\n-                            Ok(trait_ref) => {\n-                                self.out.push(\n-                                    traits::Obligation::new(cause,\n-                                                            trait_ref.to_predicate()));\n-                            }\n-                            Err(ErrorReported) => { }\n+                    self.require_sized(subty, traits::SliceOrArrayElem);\n+                }\n+\n+                ty::TyTuple(ref tys) => {\n+                    if let Some((_last, rest)) = tys.split_last() {\n+                        for elem in rest {\n+                            self.require_sized(elem, traits::TupleElem);\n                         }\n                     }\n                 }\n \n                 ty::TyBox(_) |\n-                ty::TyTuple(_) |\n                 ty::TyRawPtr(_) => {\n                     // simple cases that are WF if their type args are WF\n                 }"}, {"sha": "1d93645fc847f6c3dfcd6750f7dc3271c7771035", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "patch": "@@ -60,6 +60,7 @@ fn f8<X: ?Sized>(x1: &S<X>, x2: &S<X>) {\n fn f9<X: ?Sized>(x1: Box<S<X>>, x2: Box<E<X>>) {\n     f5(&(*x1, 34));\n     //~^ ERROR `X: std::marker::Sized` is not satisfied\n+    //~^^ ERROR `X: std::marker::Sized` is not satisfied\n }\n \n fn f10<X: ?Sized>(x1: Box<S<X>>, x2: Box<E<X>>) {"}, {"sha": "e18ccfee96c7da7994b4f4aec09576a28f89e796", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a6dfc51777eb388b6e795399bf1d3f8aac57db8/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=0a6dfc51777eb388b6e795399bf1d3f8aac57db8", "patch": "@@ -14,9 +14,9 @@ trait T {}\n \n fn f1<X: ?Sized>(x: &X) {\n     let _: X; // <-- this is OK, no bindings created, no initializer.\n-    let _: (isize, (X, isize)); // same\n+    let _: (isize, (X, isize)); //~ERROR `X: std::marker::Sized` is not satisfied\n     let y: X; //~ERROR `X: std::marker::Sized` is not satisfied\n-    let y: (isize, (X, isize)); //~ERROR `X: std::marker::Sized` is not satisfied\n+    let y: (isize, (X, usize)); //~ERROR `X: std::marker::Sized` is not satisfied\n }\n fn f2<X: ?Sized + T>(x: &X) {\n     let y: X; //~ERROR `X: std::marker::Sized` is not satisfied"}]}