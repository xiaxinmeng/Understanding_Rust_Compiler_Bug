{"sha": "e95552c5e624ac1ad0c04db505e34122c9d261ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NTU1MmM1ZTYyNGFjMWFkMGMwNGRiNTA1ZTM0MTIyYzlkMjYxYWU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-08-07T12:35:06Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-08-19T20:35:41Z"}, "message": "serialize: add json bounds checks, support for u64s, and tests", "tree": {"sha": "83d2d04bc942868af85622cde36771ac2e78ca6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83d2d04bc942868af85622cde36771ac2e78ca6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e95552c5e624ac1ad0c04db505e34122c9d261ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e95552c5e624ac1ad0c04db505e34122c9d261ae", "html_url": "https://github.com/rust-lang/rust/commit/e95552c5e624ac1ad0c04db505e34122c9d261ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e95552c5e624ac1ad0c04db505e34122c9d261ae/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3019af6c01fb40def845ac0b7b6f321d09f84e73", "url": "https://api.github.com/repos/rust-lang/rust/commits/3019af6c01fb40def845ac0b7b6f321d09f84e73", "html_url": "https://github.com/rust-lang/rust/commit/3019af6c01fb40def845ac0b7b6f321d09f84e73"}], "stats": {"total": 412, "additions": 268, "deletions": 144}, "files": [{"sha": "3a5e3cfe24022350ac27900d7809931306a9bcfc", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 266, "deletions": 142, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/e95552c5e624ac1ad0c04db505e34122c9d261ae/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95552c5e624ac1ad0c04db505e34122c9d261ae/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e95552c5e624ac1ad0c04db505e34122c9d261ae", "patch": "@@ -209,8 +209,9 @@ use Encodable;\n /// Represents a json value\n #[deriving(Clone, PartialEq, PartialOrd)]\n pub enum Json {\n-    Integer(i64),\n-    Floating(f64),\n+    I64(i64),\n+    U64(u64),\n+    F64(f64),\n     String(String),\n     Boolean(bool),\n     List(List),\n@@ -837,8 +838,9 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n     fn encode(&self, e: &mut E) -> Result<(), S> {\n         match *self {\n-            Integer(v) => v.encode(e),\n-            Floating(v) => v.encode(e),\n+            I64(v) => v.encode(e),\n+            U64(v) => v.encode(e),\n+            F64(v) => v.encode(e),\n             String(ref v) => v.encode(e),\n             Boolean(v) => v.encode(e),\n             List(ref v) => v.encode(e),\n@@ -961,41 +963,62 @@ impl Json {\n     /// Returns true if the Json value is a Number. Returns false otherwise.\n     pub fn is_number(&self) -> bool {\n         match *self {\n-            Integer(_) | Floating(_) => true,\n+            I64(_) | U64(_) | F64(_) => true,\n             _ => false,\n         }\n     }\n \n     /// Returns true if the Json value is a i64. Returns false otherwise.\n     pub fn is_i64(&self) -> bool {\n         match *self {\n-            Integer(_) => true,\n+            I64(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a u64. Returns false otherwise.\n+    pub fn is_u64(&self) -> bool {\n+        match *self {\n+            U64(_) => true,\n             _ => false,\n         }\n     }\n \n     /// Returns true if the Json value is a f64. Returns false otherwise.\n     pub fn is_f64(&self) -> bool {\n         match *self {\n-            Floating(_) => true,\n+            F64(_) => true,\n             _ => false,\n         }\n     }\n \n-    /// If the Json value is a Integer, returns the associated i64.\n+    /// If the Json value is a number, return or cast it to a i64.\n     /// Returns None otherwise.\n     pub fn as_i64(&self) -> Option<i64> {\n         match *self {\n-            Integer(n) => Some(n),\n+            I64(n) => Some(n),\n+            U64(n) => num::cast(n),\n+            _ => None\n+        }\n+    }\n+\n+    /// If the Json value is a number, return or cast it to a u64.\n+    /// Returns None otherwise.\n+    pub fn as_u64(&self) -> Option<u64> {\n+        match *self {\n+            I64(n) => num::cast(n),\n+            U64(n) => Some(n),\n             _ => None\n         }\n     }\n \n-    /// If the Json value is a Floating, returns the associated f64.\n+    /// If the Json value is a number, return or cast it to a f64.\n     /// Returns None otherwise.\n     pub fn as_f64(&self) -> Option<f64> {\n         match *self {\n-            Floating(n) => Some(n),\n+            I64(n) => num::cast(n),\n+            U64(n) => num::cast(n),\n+            F64(n) => Some(n),\n             _ => None\n         }\n     }\n@@ -1037,8 +1060,9 @@ pub enum JsonEvent {\n     ListStart,\n     ListEnd,\n     BooleanValue(bool),\n-    IntegerValue(i64),\n-    FloatingValue(f64),\n+    I64Value(i64),\n+    U64Value(u64),\n+    F64Value(f64),\n     StringValue(String),\n     NullValue,\n     Error(ParserError),\n@@ -1289,14 +1313,14 @@ impl<T: Iterator<char>> Parser<T> {\n     }\n \n     fn parse_number(&mut self) -> JsonEvent {\n-        let mut neg = 1;\n+        let mut neg = false;\n \n         if self.ch_is('-') {\n             self.bump();\n-            neg = -1;\n+            neg = true;\n         }\n \n-        let res = match self.parse_i64() {\n+        let res = match self.parse_u64() {\n             Ok(res) => res,\n             Err(e) => { return Error(e); }\n         };\n@@ -1318,14 +1342,30 @@ impl<T: Iterator<char>> Parser<T> {\n                 };\n             }\n \n-            FloatingValue((neg as f64) * res)\n+            if neg {\n+                res *= -1.0;\n+            }\n+\n+            F64Value(res)\n         } else {\n-            IntegerValue(neg * res)\n+            if neg {\n+                let res = -(res as i64);\n+\n+                // Make sure we didn't underflow.\n+                if res > 0 {\n+                    Error(SyntaxError(InvalidNumber, self.line, self.col))\n+                } else {\n+                    I64Value(res)\n+                }\n+            } else {\n+                U64Value(res)\n+            }\n         }\n     }\n \n-    fn parse_i64(&mut self) -> Result<i64, ParserError> {\n-        let mut res = 0;\n+    fn parse_u64(&mut self) -> Result<u64, ParserError> {\n+        let mut accum = 0;\n+        let last_accum = 0; // necessary to detect overflow.\n \n         match self.ch_or_null() {\n             '0' => {\n@@ -1341,8 +1381,12 @@ impl<T: Iterator<char>> Parser<T> {\n                 while !self.eof() {\n                     match self.ch_or_null() {\n                         c @ '0' .. '9' => {\n-                            res *= 10;\n-                            res += (c as i64) - ('0' as i64);\n+                            accum *= 10;\n+                            accum += (c as u64) - ('0' as u64);\n+\n+                            // Detect overflow by comparing to the last value.\n+                            if accum <= last_accum { return self.error(InvalidNumber); }\n+\n                             self.bump();\n                         }\n                         _ => break,\n@@ -1351,7 +1395,8 @@ impl<T: Iterator<char>> Parser<T> {\n             }\n             _ => return self.error(InvalidNumber),\n         }\n-        Ok(res)\n+\n+        Ok(accum)\n     }\n \n     fn parse_decimal(&mut self, mut res: f64) -> Result<f64, ParserError> {\n@@ -1764,8 +1809,9 @@ impl<T: Iterator<char>> Builder<T> {\n     fn build_value(&mut self) -> Result<Json, BuilderError> {\n         return match self.token {\n             Some(NullValue) => { Ok(Null) }\n-            Some(IntegerValue(n)) => { Ok(Integer(n)) }\n-            Some(FloatingValue(n)) => { Ok(Floating(n)) }\n+            Some(I64Value(n)) => { Ok(I64(n)) }\n+            Some(U64Value(n)) => { Ok(U64(n)) }\n+            Some(F64Value(n)) => { Ok(F64(n)) }\n             Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n             Some(StringValue(ref mut s)) => {\n                 let mut temp = String::new();\n@@ -1880,47 +1926,64 @@ macro_rules! expect(\n     })\n )\n \n+macro_rules! read_primitive {\n+    ($name:ident, $ty:ty) => {\n+        fn $name(&mut self) -> DecodeResult<$ty> {\n+            match self.pop() {\n+                I64(f) => {\n+                    match num::cast(f) {\n+                        Some(f) => Ok(f),\n+                        None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    }\n+                }\n+                U64(f) => {\n+                    match num::cast(f) {\n+                        Some(f) => Ok(f),\n+                        None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    }\n+                }\n+                F64(f) => {\n+                    match num::cast(f) {\n+                        Some(f) => Ok(f),\n+                        None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n+                    }\n+                }\n+                String(s) => {\n+                    // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                    // is going to have a string here, as per JSON spec.\n+                    Ok(std::from_str::from_str(s.as_slice()).unwrap())\n+                },\n+                value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n+            }\n+        }\n+    }\n+}\n+\n impl ::Decoder<DecoderError> for Decoder {\n     fn read_nil(&mut self) -> DecodeResult<()> {\n         debug!(\"read_nil\");\n         expect!(self.pop(), Null)\n     }\n \n-    fn read_u64(&mut self)  -> DecodeResult<u64 > { Ok(try!(self.read_f64()) as u64) }\n-    fn read_u32(&mut self)  -> DecodeResult<u32 > { Ok(try!(self.read_f64()) as u32) }\n-    fn read_u16(&mut self)  -> DecodeResult<u16 > { Ok(try!(self.read_f64()) as u16) }\n-    fn read_u8 (&mut self)  -> DecodeResult<u8  > { Ok(try!(self.read_f64()) as u8) }\n-    fn read_uint(&mut self) -> DecodeResult<uint> { Ok(try!(self.read_f64()) as uint) }\n-\n-    fn read_i64(&mut self) -> DecodeResult<i64> {\n-        debug!(\"read_i64\");\n-        match self.pop() {\n-            Integer(f) => Ok(f),\n-            Floating(f) => Ok(f as i64),\n-            String(s) => {\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n-                // is going to have a string here, as per JSON spec.\n-                Ok(std::from_str::from_str(s.as_slice()).unwrap())\n-            },\n-            value => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", value)))\n-        }\n-    }\n-\n-    fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self.read_f64()) as i32) }\n-    fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self.read_f64()) as i16) }\n-    fn read_i8 (&mut self) -> DecodeResult<i8 > { Ok(try!(self.read_f64()) as i8) }\n-    fn read_int(&mut self) -> DecodeResult<int> { Ok(try!(self.read_f64()) as int) }\n+    read_primitive!(read_uint, uint)\n+    read_primitive!(read_u8, u8)\n+    read_primitive!(read_u16, u16)\n+    read_primitive!(read_u32, u32)\n+    read_primitive!(read_u64, u64)\n+    read_primitive!(read_int, int)\n+    read_primitive!(read_i8, i8)\n+    read_primitive!(read_i16, i16)\n+    read_primitive!(read_i32, i32)\n+    read_primitive!(read_i64, i64)\n \n-    fn read_bool(&mut self) -> DecodeResult<bool> {\n-        debug!(\"read_bool\");\n-        expect!(self.pop(), Boolean)\n-    }\n+    fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n \n     fn read_f64(&mut self) -> DecodeResult<f64> {\n         debug!(\"read_f64\");\n         match self.pop() {\n-            Integer(f) => Ok(f as f64),\n-            Floating(f) => Ok(f),\n+            I64(f) => Ok(f as f64),\n+            U64(f) => Ok(f as f64),\n+            F64(f) => Ok(f),\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec.\n@@ -1931,7 +1994,10 @@ impl ::Decoder<DecoderError> for Decoder {\n         }\n     }\n \n-    fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n+    fn read_bool(&mut self) -> DecodeResult<bool> {\n+        debug!(\"read_bool\");\n+        expect!(self.pop(), Boolean)\n+    }\n \n     fn read_char(&mut self) -> DecodeResult<char> {\n         let s = try!(self.read_str());\n@@ -2142,15 +2208,25 @@ pub trait ToJson {\n     fn to_json(&self) -> Json;\n }\n \n-macro_rules! to_json_impl(\n+macro_rules! to_json_impl_i64(\n+    ($($t:ty), +) => (\n+        $(impl ToJson for $t {\n+            fn to_json(&self) -> Json { I64(*self as i64) }\n+        })+\n+    )\n+)\n+\n+to_json_impl_i64!(int, i8, i16, i32, i64)\n+\n+macro_rules! to_json_impl_u64(\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n-            fn to_json(&self) -> Json { Integer(*self as i64) }\n+            fn to_json(&self) -> Json { U64(*self as u64) }\n         })+\n     )\n )\n \n-to_json_impl!(int, i8, i16, i32, i64, uint, u8, u16, u32, u64)\n+to_json_impl_u64!(uint, u8, u16, u32, u64)\n \n impl ToJson for Json {\n     fn to_json(&self) -> Json { self.clone() }\n@@ -2164,7 +2240,7 @@ impl ToJson for f64 {\n     fn to_json(&self) -> Json {\n         match self.classify() {\n             FPNaN | FPInfinite => Null,\n-            _                  => Floating(*self)\n+            _                  => F64(*self)\n         }\n     }\n }\n@@ -2268,16 +2344,16 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use {Encodable, Decodable};\n-    use super::{Encoder, Decoder, Error, Boolean, Integer, Floating, List, String, Null,\n+    use super::{Encoder, Decoder, Error, Boolean, I64, U64, F64, List, String, Null,\n                 PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n                 MissingFieldError, UnknownVariantError, DecodeResult, DecoderError,\n                 JsonEvent, Parser, StackElement,\n-                ObjectStart, ObjectEnd, ListStart, ListEnd, BooleanValue, IntegerValue, FloatingValue,\n-                StringValue, NullValue, SyntaxError, Key, Index, Stack,\n+                ObjectStart, ObjectEnd, ListStart, ListEnd, BooleanValue, U64Value,\n+                F64Value, StringValue, NullValue, SyntaxError, Key, Index, Stack,\n                 InvalidSyntax, InvalidNumber, EOFWhileParsingObject, EOFWhileParsingList,\n                 EOFWhileParsingValue, EOFWhileParsingString, KeyMustBeAString, ExpectedColon,\n                 TrailingCharacters};\n-    use std::{f32, f64, io};\n+    use std::{i64, u64, f32, f64, io};\n     use std::collections::TreeMap;\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n@@ -2324,38 +2400,38 @@ mod tests {\n \n     #[test]\n     fn test_write_i64() {\n-        assert_eq!(Integer(0).to_string().into_string(), \"0\".to_string());\n-        assert_eq!(Integer(0).to_pretty_str().into_string(), \"0\".to_string());\n+        assert_eq!(U64(0).to_string().into_string(), \"0\".to_string());\n+        assert_eq!(U64(0).to_pretty_str().into_string(), \"0\".to_string());\n \n-        assert_eq!(Integer(1234).to_string().into_string(), \"1234\".to_string());\n-        assert_eq!(Integer(1234).to_pretty_str().into_string(), \"1234\".to_string());\n+        assert_eq!(U64(1234).to_string().into_string(), \"1234\".to_string());\n+        assert_eq!(U64(1234).to_pretty_str().into_string(), \"1234\".to_string());\n \n-        assert_eq!(Integer(-5678).to_string().into_string(), \"-5678\".to_string());\n-        assert_eq!(Integer(-5678).to_pretty_str().into_string(), \"-5678\".to_string());\n+        assert_eq!(I64(-5678).to_string().into_string(), \"-5678\".to_string());\n+        assert_eq!(I64(-5678).to_pretty_str().into_string(), \"-5678\".to_string());\n     }\n \n     #[test]\n     fn test_write_f64() {\n-        assert_eq!(Floating(3.0).to_string().into_string(), \"3\".to_string());\n-        assert_eq!(Floating(3.0).to_pretty_str().into_string(), \"3\".to_string());\n+        assert_eq!(F64(3.0).to_string().into_string(), \"3\".to_string());\n+        assert_eq!(F64(3.0).to_pretty_str().into_string(), \"3\".to_string());\n \n-        assert_eq!(Floating(3.1).to_string().into_string(), \"3.1\".to_string());\n-        assert_eq!(Floating(3.1).to_pretty_str().into_string(), \"3.1\".to_string());\n+        assert_eq!(F64(3.1).to_string().into_string(), \"3.1\".to_string());\n+        assert_eq!(F64(3.1).to_pretty_str().into_string(), \"3.1\".to_string());\n \n-        assert_eq!(Floating(-1.5).to_string().into_string(), \"-1.5\".to_string());\n-        assert_eq!(Floating(-1.5).to_pretty_str().into_string(), \"-1.5\".to_string());\n+        assert_eq!(F64(-1.5).to_string().into_string(), \"-1.5\".to_string());\n+        assert_eq!(F64(-1.5).to_pretty_str().into_string(), \"-1.5\".to_string());\n \n-        assert_eq!(Floating(0.5).to_string().into_string(), \"0.5\".to_string());\n-        assert_eq!(Floating(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n+        assert_eq!(F64(0.5).to_string().into_string(), \"0.5\".to_string());\n+        assert_eq!(F64(0.5).to_pretty_str().into_string(), \"0.5\".to_string());\n \n-        assert_eq!(Floating(f64::NAN).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Floating(f64::NAN).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NAN).to_string().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NAN).to_pretty_str().into_string(), \"null\".to_string());\n \n-        assert_eq!(Floating(f64::INFINITY).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Floating(f64::INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::INFINITY).to_string().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n \n-        assert_eq!(Floating(f64::NEG_INFINITY).to_string().into_string(), \"null\".to_string());\n-        assert_eq!(Floating(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NEG_INFINITY).to_string().into_string(), \"null\".to_string());\n+        assert_eq!(F64(f64::NEG_INFINITY).to_pretty_str().into_string(), \"null\".to_string());\n     }\n \n     #[test]\n@@ -2393,7 +2469,7 @@ mod tests {\n         let long_test_list = List(vec![\n             Boolean(false),\n             Null,\n-            List(vec![String(\"foo\\nbar\".to_string()), Floating(3.5)])]);\n+            List(vec![String(\"foo\\nbar\".to_string()), F64(3.5)])]);\n \n         assert_eq!(long_test_list.to_string().into_string(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_string());\n@@ -2608,14 +2684,21 @@ mod tests {\n         assert_eq!(from_str(\"1e\"),  Err(SyntaxError(InvalidNumber, 1, 3)));\n         assert_eq!(from_str(\"1e+\"), Err(SyntaxError(InvalidNumber, 1, 4)));\n \n-        assert_eq!(from_str(\"3\"), Ok(Integer(3)));\n-        assert_eq!(from_str(\"3.1\"), Ok(Floating(3.1)));\n-        assert_eq!(from_str(\"-1.2\"), Ok(Floating(-1.2)));\n-        assert_eq!(from_str(\"0.4\"), Ok(Floating(0.4)));\n-        assert_eq!(from_str(\"0.4e5\"), Ok(Floating(0.4e5)));\n-        assert_eq!(from_str(\"0.4e+15\"), Ok(Floating(0.4e15)));\n-        assert_eq!(from_str(\"0.4e-01\"), Ok(Floating(0.4e-01)));\n-        assert_eq!(from_str(\" 3 \"), Ok(Integer(3)));\n+        assert_eq!(from_str(\"18446744073709551616\"), Err(SyntaxError(InvalidNumber, 1, 20)));\n+        assert_eq!(from_str(\"-9223372036854775809\"), Err(SyntaxError(InvalidNumber, 1, 21)));\n+\n+        assert_eq!(from_str(\"3\"), Ok(U64(3)));\n+        assert_eq!(from_str(\"3.1\"), Ok(F64(3.1)));\n+        assert_eq!(from_str(\"-1.2\"), Ok(F64(-1.2)));\n+        assert_eq!(from_str(\"0.4\"), Ok(F64(0.4)));\n+        assert_eq!(from_str(\"0.4e5\"), Ok(F64(0.4e5)));\n+        assert_eq!(from_str(\"0.4e+15\"), Ok(F64(0.4e15)));\n+        assert_eq!(from_str(\"0.4e-01\"), Ok(F64(0.4e-01)));\n+        assert_eq!(from_str(\" 3 \"), Ok(U64(3)));\n+\n+        assert_eq!(from_str(\"-9223372036854775808\"), Ok(I64(i64::MIN)));\n+        assert_eq!(from_str(\"9223372036854775807\"), Ok(U64(i64::MAX as u64)));\n+        assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n     }\n \n     #[test]\n@@ -2640,6 +2723,18 @@ mod tests {\n \n         let v: f64 = super::decode(\"0.4e-01\").unwrap();\n         assert_eq!(v, 0.4e-01);\n+\n+        let v: u64 = super::decode(\"0\").unwrap();\n+        assert_eq!(v, 0);\n+\n+        let v: u64 = super::decode(\"18446744073709551615\").unwrap();\n+        assert_eq!(v, u64::MAX);\n+\n+        let v: i64 = super::decode(\"-9223372036854775808\").unwrap();\n+        assert_eq!(v, i64::MIN);\n+\n+        let v: i64 = super::decode(\"9223372036854775807\").unwrap();\n+        assert_eq!(v, i64::MAX);\n     }\n \n     #[test]\n@@ -2691,11 +2786,11 @@ mod tests {\n         assert_eq!(from_str(\"[ false ]\"), Ok(List(vec![Boolean(false)])));\n         assert_eq!(from_str(\"[null]\"), Ok(List(vec![Null])));\n         assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(List(vec![Integer(3), Integer(1)])));\n+                     Ok(List(vec![U64(3), U64(1)])));\n         assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(List(vec![Integer(3), Integer(2)])));\n+                     Ok(List(vec![U64(3), U64(2)])));\n         assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(List(vec![Integer(2), List(vec![Integer(4), Integer(1)])])));\n+               Ok(List(vec![U64(2), List(vec![U64(4), U64(1)])])));\n     }\n \n     #[test]\n@@ -2733,7 +2828,7 @@ mod tests {\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(\"a\".to_string(), Integer(3))]));\n+                  mk_object([(\"a\".to_string(), U64(3))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n@@ -2747,7 +2842,7 @@ mod tests {\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_string(), Floating(1.0)),\n+                      (\"a\".to_string(), F64(1.0)),\n                       (\"b\".to_string(), List(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n@@ -2760,7 +2855,7 @@ mod tests {\n                           ]\\\n                       }\").unwrap(),\n                   mk_object([\n-                      (\"a\".to_string(), Floating(1.0)),\n+                      (\"a\".to_string(), F64(1.0)),\n                       (\"b\".to_string(), List(vec![\n                           Boolean(true),\n                           String(\"foo\\nbar\".to_string()),\n@@ -2968,26 +3063,54 @@ mod tests {\n \n     #[test]\n     fn test_is_i64(){\n-        let json_value = from_str(\"12\").unwrap();\n+        let json_value = from_str(\"-12\").unwrap();\n         assert!(json_value.is_i64());\n \n+        let json_value = from_str(\"12\").unwrap();\n+        assert!(!json_value.is_i64());\n+\n         let json_value = from_str(\"12.0\").unwrap();\n         assert!(!json_value.is_i64());\n     }\n \n+    #[test]\n+    fn test_is_u64(){\n+        let json_value = from_str(\"12\").unwrap();\n+        assert!(json_value.is_u64());\n+\n+        let json_value = from_str(\"-12\").unwrap();\n+        assert!(!json_value.is_u64());\n+\n+        let json_value = from_str(\"12.0\").unwrap();\n+        assert!(!json_value.is_u64());\n+    }\n+\n     #[test]\n     fn test_is_f64(){\n         let json_value = from_str(\"12\").unwrap();\n         assert!(!json_value.is_f64());\n \n+        let json_value = from_str(\"-12\").unwrap();\n+        assert!(!json_value.is_f64());\n+\n         let json_value = from_str(\"12.0\").unwrap();\n         assert!(json_value.is_f64());\n+\n+        let json_value = from_str(\"-12.0\").unwrap();\n+        assert!(json_value.is_f64());\n     }\n \n     #[test]\n     fn test_as_i64(){\n-        let json_value = from_str(\"12\").unwrap();\n+        let json_value = from_str(\"-12\").unwrap();\n         let json_num = json_value.as_i64();\n+        assert_eq!(json_num, Some(-12));\n+    }\n+\n+    #[test]\n+    fn test_as_u64(){\n+        let json_value = from_str(\"12\").unwrap();\n+        let json_num = json_value.as_u64();\n         assert_eq!(json_num, Some(12));\n     }\n \n@@ -3105,12 +3228,12 @@ mod tests {\n                 (ObjectStart,             vec![]),\n                   (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n                   (ListStart,             vec![Key(\"array\")]),\n-                    (IntegerValue(0),         vec![Key(\"array\"), Index(0)]),\n-                    (IntegerValue(1),         vec![Key(\"array\"), Index(1)]),\n-                    (IntegerValue(2),         vec![Key(\"array\"), Index(2)]),\n-                    (IntegerValue(3),         vec![Key(\"array\"), Index(3)]),\n-                    (IntegerValue(4),         vec![Key(\"array\"), Index(4)]),\n-                    (IntegerValue(5),         vec![Key(\"array\"), Index(5)]),\n+                    (U64Value(0),         vec![Key(\"array\"), Index(0)]),\n+                    (U64Value(1),         vec![Key(\"array\"), Index(1)]),\n+                    (U64Value(2),         vec![Key(\"array\"), Index(2)]),\n+                    (U64Value(3),         vec![Key(\"array\"), Index(3)]),\n+                    (U64Value(4),         vec![Key(\"array\"), Index(4)]),\n+                    (U64Value(5),         vec![Key(\"array\"), Index(5)]),\n                   (ListEnd,               vec![Key(\"array\")]),\n                   (ListStart,             vec![Key(\"idents\")]),\n                     (NullValue,           vec![Key(\"idents\"), Index(0)]),\n@@ -3154,7 +3277,7 @@ mod tests {\n             \"{\\\"a\\\": 3}\",\n             vec![\n                 (ObjectStart,        vec![]),\n-                  (IntegerValue(3),      vec![Key(\"a\")]),\n+                  (U64Value(3),      vec![Key(\"a\")]),\n                 (ObjectEnd,          vec![]),\n             ]\n         );\n@@ -3171,7 +3294,7 @@ mod tests {\n             \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n             vec![\n                 (ObjectStart,           vec![]),\n-                  (FloatingValue(1.0),       vec![Key(\"a\")]),\n+                  (F64Value(1.0),       vec![Key(\"a\")]),\n                   (ListStart,           vec![Key(\"b\")]),\n                     (BooleanValue(true),vec![Key(\"b\"), Index(0)]),\n                   (ListEnd,             vec![Key(\"b\")]),\n@@ -3189,7 +3312,7 @@ mod tests {\n             }\"#,\n             vec![\n                 (ObjectStart,                   vec![]),\n-                  (FloatingValue(1.0),               vec![Key(\"a\")]),\n+                  (F64Value(1.0),               vec![Key(\"a\")]),\n                   (ListStart,                   vec![Key(\"b\")]),\n                     (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n                     (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n@@ -3248,28 +3371,28 @@ mod tests {\n             \"[3, 1]\",\n             vec![\n                 (ListStart,     vec![]),\n-                    (IntegerValue(3), vec![Index(0)]),\n-                    (IntegerValue(1), vec![Index(1)]),\n+                    (U64Value(3), vec![Index(0)]),\n+                    (U64Value(1), vec![Index(1)]),\n                 (ListEnd,       vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"\\n[3, 2]\\n\",\n             vec![\n                 (ListStart,     vec![]),\n-                    (IntegerValue(3), vec![Index(0)]),\n-                    (IntegerValue(2), vec![Index(1)]),\n+                    (U64Value(3), vec![Index(0)]),\n+                    (U64Value(2), vec![Index(1)]),\n                 (ListEnd,       vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[2, [4, 1]]\",\n             vec![\n                 (ListStart,            vec![]),\n-                    (IntegerValue(2),      vec![Index(0)]),\n+                    (U64Value(2),      vec![Index(0)]),\n                     (ListStart,        vec![Index(1)]),\n-                        (IntegerValue(4),  vec![Index(1), Index(0)]),\n-                        (IntegerValue(1),  vec![Index(1), Index(1)]),\n+                        (U64Value(4),  vec![Index(1), Index(0)]),\n+                        (U64Value(1),  vec![Index(1), Index(1)]),\n                     (ListEnd,          vec![Index(1)]),\n                 (ListEnd,              vec![]),\n             ]\n@@ -3370,50 +3493,51 @@ mod tests {\n         use std::collections::{HashMap,TreeMap};\n         use super::ToJson;\n \n-        let list2 = List(vec!(Integer(1), Integer(2)));\n-        let list3 = List(vec!(Integer(1), Integer(2), Integer(3)));\n+        let list2 = List(vec!(U64(1), U64(2)));\n+        let list3 = List(vec!(U64(1), U64(2), U64(3)));\n         let object = {\n             let mut tree_map = TreeMap::new();\n-            tree_map.insert(\"a\".to_string(), Integer(1));\n-            tree_map.insert(\"b\".to_string(), Integer(2));\n+            tree_map.insert(\"a\".to_string(), U64(1));\n+            tree_map.insert(\"b\".to_string(), U64(2));\n             Object(tree_map)\n         };\n \n         assert_eq!(list2.to_json(), list2);\n         assert_eq!(object.to_json(), object);\n-        assert_eq!(3_i.to_json(), Integer(3));\n-        assert_eq!(4_i8.to_json(), Integer(4));\n-        assert_eq!(5_i16.to_json(), Integer(5));\n-        assert_eq!(6_i32.to_json(), Integer(6));\n-        assert_eq!(7_i64.to_json(), Integer(7));\n-        assert_eq!(8_u.to_json(), Integer(8));\n-        assert_eq!(9_u8.to_json(), Integer(9));\n-        assert_eq!(10_u16.to_json(), Integer(10));\n-        assert_eq!(11_u32.to_json(), Integer(11));\n-        assert_eq!(12_u64.to_json(), Integer(12));\n-        assert_eq!(13.0_f32.to_json(), Floating(13.0_f64));\n-        assert_eq!(14.0_f64.to_json(), Floating(14.0_f64));\n+        assert_eq!(3_i.to_json(), I64(3));\n+        assert_eq!(4_i8.to_json(), I64(4));\n+        assert_eq!(5_i16.to_json(), I64(5));\n+        assert_eq!(6_i32.to_json(), I64(6));\n+        assert_eq!(7_i64.to_json(), I64(7));\n+        assert_eq!(8_u.to_json(), U64(8));\n+        assert_eq!(9_u8.to_json(), U64(9));\n+        assert_eq!(10_u16.to_json(), U64(10));\n+        assert_eq!(11_u32.to_json(), U64(11));\n+        assert_eq!(12_u64.to_json(), U64(12));\n+        assert_eq!(13.0_f32.to_json(), F64(13.0_f64));\n+        assert_eq!(14.0_f64.to_json(), F64(14.0_f64));\n         assert_eq!(().to_json(), Null);\n         assert_eq!(f32::INFINITY.to_json(), Null);\n         assert_eq!(f64::NAN.to_json(), Null);\n         assert_eq!(true.to_json(), Boolean(true));\n         assert_eq!(false.to_json(), Boolean(false));\n         assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n-        assert_eq!((1i, 2i).to_json(), list2);\n-        assert_eq!((1i, 2i, 3i).to_json(), list3);\n-        assert_eq!([1i, 2].to_json(), list2);\n-        assert_eq!((&[1i, 2, 3]).to_json(), list3);\n-        assert_eq!((vec![1i, 2]).to_json(), list2);\n-        assert_eq!(vec!(1i, 2i, 3i).to_json(), list3);\n+        assert_eq!((1u, 2u).to_json(), list2);\n+        assert_eq!((1u, 2u, 3u).to_json(), list3);\n+        assert_eq!([1u, 2].to_json(), list2);\n+        assert_eq!((&[1u, 2, 3]).to_json(), list3);\n+        assert_eq!((vec![1u, 2]).to_json(), list2);\n+        assert_eq!(vec!(1u, 2, 3).to_json(), list3);\n         let mut tree_map = TreeMap::new();\n-        tree_map.insert(\"a\".to_string(), 1i);\n+        tree_map.insert(\"a\".to_string(), 1u);\n         tree_map.insert(\"b\".to_string(), 2);\n         assert_eq!(tree_map.to_json(), object);\n         let mut hash_map = HashMap::new();\n-        hash_map.insert(\"a\".to_string(), 1i);\n+        hash_map.insert(\"a\".to_string(), 1u);\n         hash_map.insert(\"b\".to_string(), 2);\n         assert_eq!(hash_map.to_json(), object);\n-        assert_eq!(Some(15i).to_json(), Integer(15));\n+        assert_eq!(Some(15i).to_json(), I64(15));\n+        assert_eq!(Some(15u).to_json(), U64(15));\n         assert_eq!(None::<int>.to_json(), Null);\n     }\n "}, {"sha": "f4b162f0dd8109e6c079ab43f985a7d90a1d9cb1", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e95552c5e624ac1ad0c04db505e34122c9d261ae/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95552c5e624ac1ad0c04db505e34122c9d261ae/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=e95552c5e624ac1ad0c04db505e34122c9d261ae", "patch": "@@ -1103,8 +1103,8 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n         let mut map = TreeMap::new();\n-        map.insert(\"value\".to_string(), json::Floating(self.value));\n-        map.insert(\"noise\".to_string(), json::Floating(self.noise));\n+        map.insert(\"value\".to_string(), json::F64(self.value));\n+        map.insert(\"noise\".to_string(), json::F64(self.noise));\n         json::Object(map)\n     }\n }"}]}