{"sha": "98a276b5895697a862b48bcaf07b423de0b0deef", "node_id": "C_kwDOAAsO6NoAKDk4YTI3NmI1ODk1Njk3YTg2MmI0OGJjYWYwN2I0MjNkZTBiMGRlZWY", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-12-14T18:30:46Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-12-14T18:30:46Z"}, "message": "Merge commit '2bb3996244cf1b89878da9e39841e9f6bf061602' into sync_cg_clif-2022-12-14", "tree": {"sha": "5ecf0b879e0e8f95ec7d00951b767c59d9ac7205", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ecf0b879e0e8f95ec7d00951b767c59d9ac7205"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98a276b5895697a862b48bcaf07b423de0b0deef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98a276b5895697a862b48bcaf07b423de0b0deef", "html_url": "https://github.com/rust-lang/rust/commit/98a276b5895697a862b48bcaf07b423de0b0deef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98a276b5895697a862b48bcaf07b423de0b0deef/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7c76ad6624118c96717298fb0a8e6f84b5a9265", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c76ad6624118c96717298fb0a8e6f84b5a9265", "html_url": "https://github.com/rust-lang/rust/commit/f7c76ad6624118c96717298fb0a8e6f84b5a9265"}], "stats": {"total": 2719, "additions": 1691, "deletions": 1028}, "files": [{"sha": "d627c2ee09c4ef7555f820cc2a239b73c3133269", "filename": ".cirrus.yml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/.cirrus.yml", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/.cirrus.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cirrus.yml?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -12,8 +12,6 @@ task:\n     folder: target\n   prepare_script:\n     - . $HOME/.cargo/env\n-    - git config --global user.email \"user@example.com\"\n-    - git config --global user.name \"User\"\n     - ./y.rs prepare\n   test_script:\n     - . $HOME/.cargo/env"}, {"sha": "a6bb12a66a247d66441c390105655e9ff0910978", "filename": ".github/workflows/main.yml", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fmain.yml?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -19,6 +19,7 @@ jobs:\n     - name: Rustfmt\n       run: |\n         cargo fmt --check\n+        rustfmt --check build_system/mod.rs\n \n   build:\n     runs-on: ${{ matrix.os }}\n@@ -28,7 +29,7 @@ jobs:\n       fail-fast: false\n       matrix:\n         include:\n-          - os: ubuntu-latest\n+          - os: ubuntu-20.04 # FIXME switch to ubuntu-22.04 once #1303 is fixed\n             env:\n               TARGET_TRIPLE: x86_64-unknown-linux-gnu\n           - os: macos-latest\n@@ -41,28 +42,32 @@ jobs:\n           - os: ubuntu-latest\n             env:\n               TARGET_TRIPLE: aarch64-unknown-linux-gnu\n+          # s390x requires QEMU 6.1 or greater, we could build it from source, but ubuntu 22.04 comes with 6.2 by default\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: s390x-unknown-linux-gnu\n \n     steps:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ${{ runner.os }}-cargo-installed-crates\n \n     - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: |\n             ~/.cargo/registry\n             ~/.cargo/git\n         key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Install MinGW toolchain and wine\n@@ -78,11 +83,14 @@ jobs:\n         sudo apt-get update\n         sudo apt-get install -y gcc-aarch64-linux-gnu qemu-user\n \n-    - name: Prepare dependencies\n+    - name: Install s390x toolchain and qemu\n+      if: matrix.env.TARGET_TRIPLE == 's390x-unknown-linux-gnu'\n       run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n-        ./y.rs prepare\n+        sudo apt-get update\n+        sudo apt-get install -y gcc-s390x-linux-gnu qemu-user\n+\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n \n     - name: Build without unstable features\n       env:\n@@ -110,7 +118,7 @@ jobs:\n         ./y.rs test\n \n     - name: Package prebuilt cg_clif\n-      run: tar cvfJ cg_clif.tar.xz build\n+      run: tar cvfJ cg_clif.tar.xz dist\n \n     - name: Upload prebuilt cg_clif\n       if: matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n@@ -121,7 +129,7 @@ jobs:\n \n     - name: Upload prebuilt cg_clif (cross compile)\n       if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n-      uses: actions/upload-artifact@v2\n+      uses: actions/upload-artifact@v3\n       with:\n         name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n         path: cg_clif.tar.xz\n@@ -147,23 +155,23 @@ jobs:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-installed-crates\n \n     - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: |\n             ~/.cargo/registry\n             ~/.cargo/git\n         key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Set MinGW as the default toolchain\n@@ -172,8 +180,6 @@ jobs:\n \n     - name: Prepare dependencies\n       run: |\n-        git config --global user.email \"user@example.com\"\n-        git config --global user.name \"User\"\n         git config --global core.autocrlf false\n         rustc y.rs -o y.exe -g\n         ./y.exe prepare\n@@ -198,24 +204,24 @@ jobs:\n \n         # Enable extra checks\n         $Env:CG_CLIF_ENABLE_VERIFIER=1\n-        \n+\n         # WIP Disable some tests\n-        \n+\n         # This fails due to some weird argument handling by hyperfine, not an actual regression\n         # more of a build system issue\n         (Get-Content config.txt) -replace '(bench.simple-raytracer)', '# $1' |  Out-File config.txt\n-        \n-        # This fails with a different output than expected \n+\n+        # This fails with a different output than expected\n         (Get-Content config.txt) -replace '(test.regex-shootout-regex-dna)', '# $1' |  Out-File config.txt\n \n         ./y.exe test\n \n     - name: Package prebuilt cg_clif\n       # don't use compression as xzip isn't supported by tar on windows and bzip2 hangs\n-      run: tar cvf cg_clif.tar build\n+      run: tar cvf cg_clif.tar dist\n \n     - name: Upload prebuilt cg_clif\n-      uses: actions/upload-artifact@v2\n+      uses: actions/upload-artifact@v3\n       with:\n         name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n         path: cg_clif.tar"}, {"sha": "d0d58d2a7eacbd19a07442af167bdb0e2926274a", "filename": ".github/workflows/nightly-cranelift.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/.github%2Fworkflows%2Fnightly-cranelift.yml", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/.github%2Fworkflows%2Fnightly-cranelift.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fnightly-cranelift.yml?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -14,7 +14,7 @@ jobs:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ubuntu-latest-cargo-installed-crates"}, {"sha": "bef806318efa836aeeb8d6df06d880b77be677fb", "filename": ".github/workflows/rustc.yml", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frustc.yml?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -11,23 +11,23 @@ jobs:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ${{ runner.os }}-cargo-installed-crates\n \n     - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: |\n             ~/.cargo/registry\n             ~/.cargo/git\n         key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Prepare dependencies\n@@ -49,23 +49,23 @@ jobs:\n     - uses: actions/checkout@v3\n \n     - name: Cache cargo installed crates\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: ${{ runner.os }}-cargo-installed-crates\n \n     - name: Cache cargo registry and index\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n         path: |\n             ~/.cargo/registry\n             ~/.cargo/git\n         key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v2\n+      uses: actions/cache@v3\n       with:\n-        path: target\n+        path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n     - name: Prepare dependencies"}, {"sha": "b443fd58a1b98344bec2720e26139b6467907d89", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -14,5 +14,6 @@ perf.data.old\n /build_sysroot/sysroot_src\n /build_sysroot/compiler-builtins\n /build_sysroot/rustc_version\n+/dist\n /rust\n /download"}, {"sha": "bc914e37d2b51dda8d3a0e4ef090a4cc1399fc90", "filename": ".vscode/settings.json", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.vscode%2Fsettings.json?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -4,16 +4,10 @@\n     \"rust-analyzer.imports.granularity.enforce\": true,\n     \"rust-analyzer.imports.granularity.group\": \"module\",\n     \"rust-analyzer.imports.prefix\": \"crate\",\n-    \"rust-analyzer.cargo.features\": [\"unstable-features\"],\n+    \"rust-analyzer.cargo.features\": [\"unstable-features\", \"__check_build_system_using_ra\"],\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\",\n-        //\"./build_sysroot/sysroot_src/library/std/Cargo.toml\",\n         {\n-            \"roots\": [\n-                \"./example/mini_core.rs\",\n-                \"./example/mini_core_hello_world.rs\",\n-                \"./example/mod_bench.rs\"\n-            ],\n             \"crates\": [\n                 {\n                     \"root_module\": \"./example/mini_core.rs\",\n@@ -36,34 +30,11 @@\n             ]\n         },\n         {\n-            \"roots\": [\"./example/std_example.rs\"],\n+            \"sysroot_src\": \"./build_sysroot/sysroot_src/library\",\n             \"crates\": [\n                 {\n                     \"root_module\": \"./example/std_example.rs\",\n-                    \"edition\": \"2018\",\n-                    \"deps\": [{ \"crate\": 1, \"name\": \"std\" }],\n-                    \"cfg\": [],\n-                },\n-                {\n-                    \"root_module\": \"./build_sysroot/sysroot_src/library/std/src/lib.rs\",\n-                    \"edition\": \"2018\",\n-                    \"deps\": [],\n-                    \"cfg\": [],\n-                },\n-            ]\n-        },\n-        {\n-            \"roots\": [\"./y.rs\"],\n-            \"crates\": [\n-                {\n-                    \"root_module\": \"./y.rs\",\n-                    \"edition\": \"2018\",\n-                    \"deps\": [{ \"crate\": 1, \"name\": \"std\" }],\n-                    \"cfg\": [],\n-                },\n-                {\n-                    \"root_module\": \"./build_sysroot/sysroot_src/library/std/src/lib.rs\",\n-                    \"edition\": \"2018\",\n+                    \"edition\": \"2015\",\n                     \"deps\": [],\n                     \"cfg\": [],\n                 },"}, {"sha": "e4d3e9ca5ae0a8676863063216c420232248a554", "filename": "Cargo.lock", "status": "modified", "additions": 83, "deletions": 42, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -15,9 +15,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.60\"\n+version = \"1.0.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c794e162a5eff65c72ef524dfe393eb923c354e350bb78b9c7383df13f3bc142\"\n+checksum = \"216261ddc8289130e551ddcd5ce8a064710c0d064a4d2895c67151c92b5443f6\"\n \n [[package]]\n name = \"arrayvec\"\n@@ -39,9 +39,9 @@ checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"bumpalo\"\n-version = \"3.11.0\"\n+version = \"3.11.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1ad822118d20d2c234f427000d5acc36eabe1e29a348c89b63dd60b13f28e5d\"\n+checksum = \"572f695136211188308f16ad2ca5c851a712c464060ae6974944458eb83880ba\"\n \n [[package]]\n name = \"byteorder\"\n@@ -57,24 +57,25 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44409ccf2d0f663920cab563d2b79fcd6b2e9a2bcc6e929fef76c8f82ad6c17a\"\n+checksum = \"b62c772976416112fa4484cbd688cb6fb35fd430005c1c586224fc014018abad\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"98de2018ad96eb97f621f7d6b900a0cc661aec8d02ea4a50e56ecb48e5a2fcaf\"\n+checksum = \"9b40ed2dd13c2ac7e24f88a3090c68ad3414eb1d066a95f8f1f7b3b819cb4e46\"\n dependencies = [\n  \"arrayvec\",\n  \"bumpalo\",\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n  \"cranelift-codegen-shared\",\n+ \"cranelift-egraph\",\n  \"cranelift-entity\",\n  \"cranelift-isle\",\n  \"gimli\",\n@@ -86,30 +87,44 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5287ce36e6c4758fbaf298bd1a8697ad97a4f2375a3d1b61142ea538db4877e5\"\n+checksum = \"bb927a8f1c27c34ee3759b6b0ffa528d2330405d5cc4511f0cab33fe2279f4b5\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2855c24219e2f08827f3f4ffb2da92e134ae8d8ecc185b11ec8f9878cf5f588e\"\n+checksum = \"43dfa417b884a9ab488d95fd6b93b25e959321fe7bfd7a0a960ba5d7fb7ab927\"\n+\n+[[package]]\n+name = \"cranelift-egraph\"\n+version = \"0.90.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e0a66b39785efd8513d2cca967ede56d6cc57c8d7986a595c7c47d0c78de8dce\"\n+dependencies = [\n+ \"cranelift-entity\",\n+ \"fxhash\",\n+ \"hashbrown\",\n+ \"indexmap\",\n+ \"log\",\n+ \"smallvec\",\n+]\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0b65673279d75d34bf11af9660ae2dbd1c22e6d28f163f5c72f4e1dc56d56103\"\n+checksum = \"0637ffde963cb5d759bc4d454cfa364b6509e6c74cdaa21298add0ed9276f346\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ed2b3d7a4751163f6c4a349205ab1b7d9c00eecf19dcea48592ef1f7688eefc\"\n+checksum = \"fb72b8342685e850cb037350418f62cc4fc55d6c2eb9c7ca01b82f9f1a6f3d56\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -119,15 +134,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3be64cecea9d90105fc6a2ba2d003e98c867c1d6c4c86cc878f97ad9fb916293\"\n+checksum = \"850579cb9e4b448f7c301f1e6e6cbad99abe3f1f1d878a4994cb66e33c6db8cd\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f98ed42a70a0c9c388e34ec9477f57fc7300f541b1e5136a0e2ea02b1fac6015\"\n+checksum = \"9add822ad66dcbe152b5ab57de10240a2df4505099f2f6c27159acb711890bd4\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -138,24 +153,25 @@ dependencies = [\n  \"log\",\n  \"region\",\n  \"target-lexicon\",\n+ \"wasmtime-jit-icache-coherence\",\n  \"windows-sys\",\n ]\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d658ac7f156708bfccb647216cc8b9387469f50d352ba4ad80150541e4ae2d49\"\n+checksum = \"406b772626fc2664864cf947f3895a23b619895c7fff635f3622e2d857f4492f\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c4a03a6ac1b063e416ca4b93f6247978c991475e8271465340caa6f92f3c16a4\"\n+checksum = \"2d0a279e5bcba3e0466c734d8d8eb6bfc1ad29e95c37f3e4955b492b5616335e\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -164,9 +180,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.88.1\"\n+version = \"0.90.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"eef0b4119b645b870a43a036d76c0ada3a076b1f82e8b8487659304c8b09049b\"\n+checksum = \"39793c550f0c1d7db96c2fc1324583670c8143befe6edbfbaf1c68aba53be983\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -185,6 +201,12 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"fallible-iterator\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4443176a9f2c162692bd3d352d745ef9413eec5782a80d8fd6f8a1ac692a07f7\"\n+\n [[package]]\n name = \"fxhash\"\n version = \"0.2.1\"\n@@ -196,9 +218,9 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.2.7\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4eb1a864a501629691edf6c15a593b7a51eebaa1e8468e9ddc623de7c9b58ec6\"\n+checksum = \"c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -211,7 +233,9 @@ version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n dependencies = [\n+ \"fallible-iterator\",\n  \"indexmap\",\n+ \"stable_deref_trait\",\n ]\n \n [[package]]\n@@ -225,25 +249,25 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.9.1\"\n+version = \"1.9.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n+checksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.127\"\n+version = \"0.2.138\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"505e71a4706fa491e9b1b55f51b95d4037d0821ee40131190475f692b35b009b\"\n+checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.7.3\"\n+version = \"0.7.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd\"\n+checksum = \"b67380fd3b2fbe7527a606e18729d21c6f3951633d0500574c4dc22d2d638b9f\"\n dependencies = [\n  \"cfg-if\",\n  \"winapi\",\n@@ -287,15 +311,15 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.13.0\"\n+version = \"1.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n+checksum = \"86f0b0d4bf799edbc74508c1e8bf170ff5f41238e5f8225603ca7caaae2b7860\"\n \n [[package]]\n name = \"regalloc2\"\n-version = \"0.3.2\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d43a209257d978ef079f3d446331d0f1794f5e0fc19b306a199983857833a779\"\n+checksum = \"91b2eab54204ea0117fe9a060537e0b07a4e72f7c7d182361ecc346cab2240e5\"\n dependencies = [\n  \"fxhash\",\n  \"log\",\n@@ -342,15 +366,21 @@ checksum = \"03b634d87b960ab1a38c4fe143b508576f075e7c978bfad18217645ebfdfa2ec\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.9.0\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n+\n+[[package]]\n+name = \"stable_deref_trait\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.12.4\"\n+version = \"0.12.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c02424087780c9b71cc96799eaeddff35af2bc513278cda5c99fc1f5d026d3c1\"\n+checksum = \"9410d0f6853b1d94f0e519fb95df60f29d2c1eff2d921ffdf01a4c8a3b54f12d\"\n \n [[package]]\n name = \"version_check\"\n@@ -364,6 +394,17 @@ version = \"0.11.0+wasi-snapshot-preview1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n+[[package]]\n+name = \"wasmtime-jit-icache-coherence\"\n+version = \"2.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e6bbabb309c06cc238ee91b1455b748c45f0bdcab0dda2c2db85b0a1e69fcb66\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"windows-sys\",\n+]\n+\n [[package]]\n name = \"winapi\"\n version = \"0.3.9\""}, {"sha": "2b216ca072f0096832412085a0eae3fda4dc79ff", "filename": "Cargo.toml", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -3,17 +3,24 @@ name = \"rustc_codegen_cranelift\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n+[[bin]]\n+# This is used just to teach rust-analyzer how to check the build system. required-features is used\n+# to disable it for regular builds.\n+name = \"y\"\n+path = \"./y.rs\"\n+required-features = [\"__check_build_system_using_ra\"]\n+\n [lib]\n crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.88.1\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.88.1\"\n-cranelift-module = \"0.88.1\"\n-cranelift-native = \"0.88.1\"\n-cranelift-jit = { version = \"0.88.1\", optional = true }\n-cranelift-object = \"0.88.1\"\n+cranelift-codegen = { version = \"0.90.1\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.90.1\"\n+cranelift-module = \"0.90.1\"\n+cranelift-native = \"0.90.1\"\n+cranelift-jit = { version = \"0.90.1\", optional = true }\n+cranelift-object = \"0.90.1\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n@@ -39,6 +46,7 @@ smallvec = \"1.8.1\"\n unstable-features = [\"jit\", \"inline_asm\"]\n jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n+__check_build_system_using_ra = []\n \n [package.metadata.rust-analyzer]\n rustc_private = true"}, {"sha": "0e9c77244d4cc85d765371e97370db5c0adebf11", "filename": "Readme.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -37,7 +37,7 @@ Assuming `$cg_clif_dir` is the directory you cloned this repo into and you follo\n In the directory with your project (where you can do the usual `cargo build`), run:\n \n ```bash\n-$ $cg_clif_dir/build/cargo-clif build\n+$ $cg_clif_dir/dist/cargo-clif build\n ```\n \n This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend."}, {"sha": "bba3210536ef7832e44ba9dbb5e46c3ee036baf6", "filename": "build_sysroot/Cargo.lock", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.lock?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -4,9 +4,9 @@ version = 3\n \n [[package]]\n name = \"addr2line\"\n-version = \"0.16.0\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3e61f2b7f93d2c7d2b08263acaa4a363b3e276806c68af6134c44f523bf1aacd\"\n+checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n dependencies = [\n  \"compiler_builtins\",\n  \"gimli\",\n@@ -32,27 +32,11 @@ dependencies = [\n  \"core\",\n ]\n \n-[[package]]\n-name = \"autocfg\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n-\n [[package]]\n name = \"cc\"\n-version = \"1.0.73\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n-\n-[[package]]\n-name = \"cfg-if\"\n-version = \"0.1.10\"\n+version = \"1.0.77\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"rustc-std-workspace-core\",\n-]\n+checksum = \"e9f73505338f7d905b19d18738976aae232eb46b8efc15554ffc56deb5d9ebe4\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -66,9 +50,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.82\"\n+version = \"0.1.85\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18cd7635fea7bb481ea543b392789844c1ad581299da70184c7175ce3af76603\"\n+checksum = \"13e81c6cd7ab79f51a0c927d22858d61ad12bd0b3865f0b13ece02a4486aeabb\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -111,9 +95,9 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.25.0\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f0a01e0497841a3b2db4f8afa483cce65f7e96a3498bd6c541734792aeac8fe7\"\n+checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -145,9 +129,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.135\"\n+version = \"0.2.138\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n+checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -164,22 +148,21 @@ dependencies = [\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.4.4\"\n+version = \"0.5.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a92518e98c078586bc6c934028adcca4c92a53d6a958196de835170a01d84e4b\"\n+checksum = \"96590ba8f175222643a85693f33d26e9c8a015f599c216509b1a6894af675d34\"\n dependencies = [\n  \"adler\",\n- \"autocfg\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"object\"\n-version = \"0.26.2\"\n+version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39f37e50073ccad23b6d09bcb5b263f4e76d3bb6038e4a3c08e52162ffa8abc2\"\n+checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n dependencies = [\n  \"compiler_builtins\",\n  \"memchr\",\n@@ -192,7 +175,7 @@ name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -203,7 +186,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -255,7 +238,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"addr2line\",\n  \"alloc\",\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"dlmalloc\",\n@@ -277,7 +260,7 @@ dependencies = [\n name = \"std_detect\"\n version = \"0.1.5\"\n dependencies = [\n- \"cfg-if 1.0.0\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"libc\",\n  \"rustc-std-workspace-alloc\",\n@@ -299,7 +282,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"core\",\n  \"getopts\",\n  \"libc\",\n@@ -325,7 +308,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\","}, {"sha": "a081fdaa1c7e6475a727f764c033f07090b2b87e", "filename": "build_system/abi_cafe.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fabi_cafe.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,16 +1,21 @@\n-use std::env;\n use std::path::Path;\n \n use super::build_sysroot;\n use super::config;\n-use super::prepare;\n-use super::utils::{cargo_command, spawn_and_wait};\n+use super::path::Dirs;\n+use super::prepare::GitRepo;\n+use super::utils::{spawn_and_wait, CargoProject, Compiler};\n use super::SysrootKind;\n \n+pub(crate) static ABI_CAFE_REPO: GitRepo =\n+    GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n+\n+static ABI_CAFE: CargoProject = CargoProject::new(&ABI_CAFE_REPO.source_dir(), \"abi_cafe\");\n+\n pub(crate) fn run(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n-    target_dir: &Path,\n+    dirs: &Dirs,\n     cg_clif_dylib: &Path,\n     host_triple: &str,\n     target_triple: &str,\n@@ -27,26 +32,25 @@ pub(crate) fn run(\n \n     eprintln!(\"Building sysroot for abi-cafe\");\n     build_sysroot::build_sysroot(\n+        dirs,\n         channel,\n         sysroot_kind,\n-        target_dir,\n         cg_clif_dylib,\n         host_triple,\n         target_triple,\n     );\n \n     eprintln!(\"Running abi-cafe\");\n-    let abi_cafe_path = prepare::ABI_CAFE.source_dir();\n-    env::set_current_dir(abi_cafe_path.clone()).unwrap();\n \n     let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n \n-    let mut cmd = cargo_command(\"cargo\", \"run\", Some(target_triple), &abi_cafe_path);\n+    let mut cmd = ABI_CAFE.run(&Compiler::host(), dirs);\n     cmd.arg(\"--\");\n     cmd.arg(\"--pairs\");\n     cmd.args(pairs);\n     cmd.arg(\"--add-rustc-codegen-backend\");\n     cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib.display()));\n+    cmd.current_dir(ABI_CAFE.source_dir(dirs));\n \n     spawn_and_wait(cmd);\n }"}, {"sha": "fde8ef424ccc5441e0198ef7b33b23c39dbe37bc", "filename": "build_system/build_backend.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fbuild_backend.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,16 +1,19 @@\n use std::env;\n use std::path::PathBuf;\n \n+use super::path::{Dirs, RelPath};\n use super::rustc_info::get_file_name;\n-use super::utils::{cargo_command, is_ci};\n+use super::utils::{is_ci, CargoProject, Compiler};\n+\n+static CG_CLIF: CargoProject = CargoProject::new(&RelPath::SOURCE, \"cg_clif\");\n \n pub(crate) fn build_backend(\n+    dirs: &Dirs,\n     channel: &str,\n     host_triple: &str,\n     use_unstable_features: bool,\n ) -> PathBuf {\n-    let source_dir = std::env::current_dir().unwrap();\n-    let mut cmd = cargo_command(\"cargo\", \"build\", Some(host_triple), &source_dir);\n+    let mut cmd = CG_CLIF.build(&Compiler::host(), dirs);\n \n     cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"true\"); // Force incr comp even in release mode\n \n@@ -41,8 +44,8 @@ pub(crate) fn build_backend(\n     eprintln!(\"[BUILD] rustc_codegen_cranelift\");\n     super::utils::spawn_and_wait(cmd);\n \n-    source_dir\n-        .join(\"target\")\n+    CG_CLIF\n+        .target_dir(dirs)\n         .join(host_triple)\n         .join(channel)\n         .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"))"}, {"sha": "cbbf09b9b97b8422ab06caff3b59b34c6352dfd4", "filename": "build_system/build_sysroot.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fbuild_sysroot.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,57 +1,60 @@\n use std::fs;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::process::{self, Command};\n \n+use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n-use super::utils::{cargo_command, spawn_and_wait, try_hard_link};\n+use super::utils::{spawn_and_wait, try_hard_link, CargoProject, Compiler};\n use super::SysrootKind;\n \n+static DIST_DIR: RelPath = RelPath::DIST;\n+static BIN_DIR: RelPath = RelPath::DIST.join(\"bin\");\n+static LIB_DIR: RelPath = RelPath::DIST.join(\"lib\");\n+static RUSTLIB_DIR: RelPath = LIB_DIR.join(\"rustlib\");\n+\n pub(crate) fn build_sysroot(\n+    dirs: &Dirs,\n     channel: &str,\n     sysroot_kind: SysrootKind,\n-    target_dir: &Path,\n     cg_clif_dylib_src: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n     eprintln!(\"[BUILD] sysroot {:?}\", sysroot_kind);\n \n-    if target_dir.exists() {\n-        fs::remove_dir_all(target_dir).unwrap();\n-    }\n-    fs::create_dir_all(target_dir.join(\"bin\")).unwrap();\n-    fs::create_dir_all(target_dir.join(\"lib\")).unwrap();\n+    DIST_DIR.ensure_fresh(dirs);\n+    BIN_DIR.ensure_exists(dirs);\n+    LIB_DIR.ensure_exists(dirs);\n \n     // Copy the backend\n-    let cg_clif_dylib_path = target_dir\n-        .join(if cfg!(windows) {\n-            // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n-            // binaries.\n-            \"bin\"\n-        } else {\n-            \"lib\"\n-        })\n-        .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n+    let cg_clif_dylib_path = if cfg!(windows) {\n+        // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n+        // binaries.\n+        BIN_DIR\n+    } else {\n+        LIB_DIR\n+    }\n+    .to_path(dirs)\n+    .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n     try_hard_link(cg_clif_dylib_src, &cg_clif_dylib_path);\n \n     // Build and copy rustc and cargo wrappers\n-    for wrapper in [\"rustc-clif\", \"cargo-clif\"] {\n+    for wrapper in [\"rustc-clif\", \"rustdoc-clif\", \"cargo-clif\"] {\n         let wrapper_name = get_wrapper_file_name(wrapper, \"bin\");\n \n         let mut build_cargo_wrapper_cmd = Command::new(\"rustc\");\n         build_cargo_wrapper_cmd\n-            .arg(PathBuf::from(\"scripts\").join(format!(\"{wrapper}.rs\")))\n+            .arg(RelPath::SCRIPTS.to_path(dirs).join(&format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n-            .arg(target_dir.join(wrapper_name))\n+            .arg(DIST_DIR.to_path(dirs).join(wrapper_name))\n             .arg(\"-g\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n     }\n \n     let default_sysroot = super::rustc_info::get_default_sysroot();\n \n-    let rustlib = target_dir.join(\"lib\").join(\"rustlib\");\n-    let host_rustlib_lib = rustlib.join(host_triple).join(\"lib\");\n-    let target_rustlib_lib = rustlib.join(target_triple).join(\"lib\");\n+    let host_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(host_triple).join(\"lib\");\n+    let target_rustlib_lib = RUSTLIB_DIR.to_path(dirs).join(target_triple).join(\"lib\");\n     fs::create_dir_all(&host_rustlib_lib).unwrap();\n     fs::create_dir_all(&target_rustlib_lib).unwrap();\n \n@@ -112,24 +115,18 @@ pub(crate) fn build_sysroot(\n             }\n         }\n         SysrootKind::Clif => {\n-            build_clif_sysroot_for_triple(\n-                channel,\n-                target_dir,\n-                host_triple,\n-                &cg_clif_dylib_path,\n-                None,\n-            );\n+            build_clif_sysroot_for_triple(dirs, channel, host_triple, &cg_clif_dylib_path, None);\n \n             if host_triple != target_triple {\n                 // When cross-compiling it is often necessary to manually pick the right linker\n-                let linker = if target_triple == \"aarch64-unknown-linux-gnu\" {\n-                    Some(\"aarch64-linux-gnu-gcc\")\n-                } else {\n-                    None\n+                let linker = match target_triple {\n+                    \"aarch64-unknown-linux-gnu\" => Some(\"aarch64-linux-gnu-gcc\"),\n+                    \"s390x-unknown-linux-gnu\" => Some(\"s390x-linux-gnu-gcc\"),\n+                    _ => None,\n                 };\n                 build_clif_sysroot_for_triple(\n+                    dirs,\n                     channel,\n-                    target_dir,\n                     target_triple,\n                     &cg_clif_dylib_path,\n                     linker,\n@@ -142,21 +139,26 @@ pub(crate) fn build_sysroot(\n                 let file = file.unwrap().path();\n                 let filename = file.file_name().unwrap().to_str().unwrap();\n                 if filename.contains(\"std-\") && !filename.contains(\".rlib\") {\n-                    try_hard_link(&file, target_dir.join(\"lib\").join(file.file_name().unwrap()));\n+                    try_hard_link(&file, LIB_DIR.to_path(dirs).join(file.file_name().unwrap()));\n                 }\n             }\n         }\n     }\n }\n \n+// FIXME move to download/ or dist/\n+pub(crate) static SYSROOT_RUSTC_VERSION: RelPath = RelPath::BUILD_SYSROOT.join(\"rustc_version\");\n+pub(crate) static SYSROOT_SRC: RelPath = RelPath::BUILD_SYSROOT.join(\"sysroot_src\");\n+static STANDARD_LIBRARY: CargoProject = CargoProject::new(&RelPath::BUILD_SYSROOT, \"build_sysroot\");\n+\n fn build_clif_sysroot_for_triple(\n+    dirs: &Dirs,\n     channel: &str,\n-    target_dir: &Path,\n     triple: &str,\n     cg_clif_dylib_path: &Path,\n     linker: Option<&str>,\n ) {\n-    match fs::read_to_string(Path::new(\"build_sysroot\").join(\"rustc_version\")) {\n+    match fs::read_to_string(SYSROOT_RUSTC_VERSION.to_path(dirs)) {\n         Err(e) => {\n             eprintln!(\"Failed to get rustc version for patched sysroot source: {}\", e);\n             eprintln!(\"Hint: Try `./y.rs prepare` to patch the sysroot source\");\n@@ -174,7 +176,7 @@ fn build_clif_sysroot_for_triple(\n         }\n     }\n \n-    let build_dir = Path::new(\"build_sysroot\").join(\"target\").join(triple).join(channel);\n+    let build_dir = STANDARD_LIBRARY.target_dir(dirs).join(triple).join(channel);\n \n     if !super::config::get_bool(\"keep_sysroot\") {\n         // Cleanup the deps dir, but keep build scripts and the incremental cache for faster\n@@ -185,27 +187,27 @@ fn build_clif_sysroot_for_triple(\n     }\n \n     // Build sysroot\n-    let mut build_cmd = cargo_command(\"cargo\", \"build\", Some(triple), Path::new(\"build_sysroot\"));\n     let mut rustflags = \"-Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n     rustflags.push_str(&format!(\" -Zcodegen-backend={}\", cg_clif_dylib_path.to_str().unwrap()));\n-    rustflags.push_str(&format!(\" --sysroot={}\", target_dir.to_str().unwrap()));\n+    rustflags.push_str(&format!(\" --sysroot={}\", DIST_DIR.to_path(dirs).to_str().unwrap()));\n     if channel == \"release\" {\n-        build_cmd.arg(\"--release\");\n         rustflags.push_str(\" -Zmir-opt-level=3\");\n     }\n     if let Some(linker) = linker {\n         use std::fmt::Write;\n         write!(rustflags, \" -Clinker={}\", linker).unwrap();\n     }\n-    build_cmd.env(\"RUSTFLAGS\", rustflags);\n+    let mut compiler = Compiler::with_triple(triple.to_owned());\n+    compiler.rustflags = rustflags;\n+    let mut build_cmd = STANDARD_LIBRARY.build(&compiler, dirs);\n+    if channel == \"release\" {\n+        build_cmd.arg(\"--release\");\n+    }\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     spawn_and_wait(build_cmd);\n \n     // Copy all relevant files to the sysroot\n-    for entry in\n-        fs::read_dir(Path::new(\"build_sysroot/target\").join(triple).join(channel).join(\"deps\"))\n-            .unwrap()\n-    {\n+    for entry in fs::read_dir(build_dir.join(\"deps\")).unwrap() {\n         let entry = entry.unwrap();\n         if let Some(ext) = entry.path().extension() {\n             if ext == \"rmeta\" || ext == \"d\" || ext == \"dSYM\" || ext == \"clif\" {\n@@ -216,7 +218,7 @@ fn build_clif_sysroot_for_triple(\n         };\n         try_hard_link(\n             entry.path(),\n-            target_dir.join(\"lib\").join(\"rustlib\").join(triple).join(\"lib\").join(entry.file_name()),\n+            RUSTLIB_DIR.to_path(dirs).join(triple).join(\"lib\").join(entry.file_name()),\n         );\n     }\n }"}, {"sha": "1afc9a55c73b5318bbc9ed006899c4f5ab3647c3", "filename": "build_system/mod.rs", "status": "modified", "additions": 65, "deletions": 26, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fmod.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -8,20 +8,37 @@ mod abi_cafe;\n mod build_backend;\n mod build_sysroot;\n mod config;\n+mod path;\n mod prepare;\n mod rustc_info;\n mod tests;\n mod utils;\n \n+const USAGE: &str = r#\"The build system of cg_clif.\n+\n+USAGE:\n+    ./y.rs prepare [--out-dir DIR]\n+    ./y.rs build [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+    ./y.rs test [--debug] [--sysroot none|clif|llvm] [--out-dir DIR] [--no-unstable-features]\n+\n+OPTIONS:\n+    --sysroot none|clif|llvm\n+            Which sysroot libraries to use:\n+            `none` will not include any standard library in the sysroot.\n+            `clif` will build the standard library using Cranelift.\n+            `llvm` will use the pre-compiled standard library of rustc which is compiled with LLVM.\n+\n+    --out-dir DIR\n+            Specify the directory in which the download, build and dist directories are stored.\n+            By default this is the working directory.\n+\n+    --no-unstable-features\n+            fSome features are not yet ready for production usage. This option will disable these\n+            features. This includes the JIT mode and inline assembly support.\n+\"#;\n+\n fn usage() {\n-    eprintln!(\"Usage:\");\n-    eprintln!(\"  ./y.rs prepare\");\n-    eprintln!(\n-        \"  ./y.rs build [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n-    );\n-    eprintln!(\n-        \"  ./y.rs test [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--no-unstable-features]\"\n-    );\n+    eprintln!(\"{USAGE}\");\n }\n \n macro_rules! arg_error {\n@@ -34,6 +51,7 @@ macro_rules! arg_error {\n \n #[derive(PartialEq, Debug)]\n enum Command {\n+    Prepare,\n     Build,\n     Test,\n }\n@@ -48,8 +66,6 @@ pub(crate) enum SysrootKind {\n pub fn main() {\n     env::set_var(\"CG_CLIF_DISPLAY_CG_TIME\", \"1\");\n     env::set_var(\"CG_CLIF_DISABLE_INCR_CACHE\", \"1\");\n-    // The target dir is expected in the default location. Guard against the user changing it.\n-    env::set_var(\"CARGO_TARGET_DIR\", \"target\");\n \n     if is_ci() {\n         // Disabling incr comp reduces cache size and incr comp doesn't save as much on CI anyway\n@@ -58,13 +74,7 @@ pub fn main() {\n \n     let mut args = env::args().skip(1);\n     let command = match args.next().as_deref() {\n-        Some(\"prepare\") => {\n-            if args.next().is_some() {\n-                arg_error!(\"./y.rs prepare doesn't expect arguments\");\n-            }\n-            prepare::prepare();\n-            process::exit(0);\n-        }\n+        Some(\"prepare\") => Command::Prepare,\n         Some(\"build\") => Command::Build,\n         Some(\"test\") => Command::Test,\n         Some(flag) if flag.starts_with('-') => arg_error!(\"Expected command found flag {}\", flag),\n@@ -75,15 +85,15 @@ pub fn main() {\n         }\n     };\n \n-    let mut target_dir = PathBuf::from(\"build\");\n+    let mut out_dir = PathBuf::from(\".\");\n     let mut channel = \"release\";\n     let mut sysroot_kind = SysrootKind::Clif;\n     let mut use_unstable_features = true;\n     while let Some(arg) = args.next().as_deref() {\n         match arg {\n-            \"--target-dir\" => {\n-                target_dir = PathBuf::from(args.next().unwrap_or_else(|| {\n-                    arg_error!(\"--target-dir requires argument\");\n+            \"--out-dir\" => {\n+                out_dir = PathBuf::from(args.next().unwrap_or_else(|| {\n+                    arg_error!(\"--out-dir requires argument\");\n                 }))\n             }\n             \"--debug\" => channel = \"debug\",\n@@ -101,7 +111,6 @@ pub fn main() {\n             arg => arg_error!(\"Unexpected argument {}\", arg),\n         }\n     }\n-    target_dir = std::env::current_dir().unwrap().join(target_dir);\n \n     let host_triple = if let Ok(host_triple) = std::env::var(\"HOST_TRIPLE\") {\n         host_triple\n@@ -122,13 +131,43 @@ pub fn main() {\n         host_triple.clone()\n     };\n \n-    let cg_clif_dylib = build_backend::build_backend(channel, &host_triple, use_unstable_features);\n+    // FIXME allow changing the location of these dirs using cli arguments\n+    let current_dir = std::env::current_dir().unwrap();\n+    out_dir = current_dir.join(out_dir);\n+    let dirs = path::Dirs {\n+        source_dir: current_dir.clone(),\n+        download_dir: out_dir.join(\"download\"),\n+        build_dir: out_dir.join(\"build\"),\n+        dist_dir: out_dir.join(\"dist\"),\n+    };\n+\n+    path::RelPath::BUILD.ensure_exists(&dirs);\n+\n+    {\n+        // Make sure we always explicitly specify the target dir\n+        let target =\n+            path::RelPath::BUILD.join(\"target_dir_should_be_set_explicitly\").to_path(&dirs);\n+        env::set_var(\"CARGO_TARGET_DIR\", &target);\n+        let _ = std::fs::remove_file(&target);\n+        std::fs::File::create(target).unwrap();\n+    }\n+\n+    if command == Command::Prepare {\n+        prepare::prepare(&dirs);\n+        process::exit(0);\n+    }\n+\n+    let cg_clif_dylib =\n+        build_backend::build_backend(&dirs, channel, &host_triple, use_unstable_features);\n     match command {\n+        Command::Prepare => {\n+            // Handled above\n+        }\n         Command::Test => {\n             tests::run_tests(\n+                &dirs,\n                 channel,\n                 sysroot_kind,\n-                &target_dir,\n                 &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n@@ -137,17 +176,17 @@ pub fn main() {\n             abi_cafe::run(\n                 channel,\n                 sysroot_kind,\n-                &target_dir,\n+                &dirs,\n                 &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n             );\n         }\n         Command::Build => {\n             build_sysroot::build_sysroot(\n+                &dirs,\n                 channel,\n                 sysroot_kind,\n-                &target_dir,\n                 &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,"}, {"sha": "e93981f1d64d369b28672c0e61ff5a533c271a23", "filename": "build_system/path.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fpath.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -0,0 +1,70 @@\n+use std::fs;\n+use std::path::PathBuf;\n+\n+#[derive(Debug, Clone)]\n+pub(crate) struct Dirs {\n+    pub(crate) source_dir: PathBuf,\n+    pub(crate) download_dir: PathBuf,\n+    pub(crate) build_dir: PathBuf,\n+    pub(crate) dist_dir: PathBuf,\n+}\n+\n+#[doc(hidden)]\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) enum PathBase {\n+    Source,\n+    Download,\n+    Build,\n+    Dist,\n+}\n+\n+impl PathBase {\n+    fn to_path(self, dirs: &Dirs) -> PathBuf {\n+        match self {\n+            PathBase::Source => dirs.source_dir.clone(),\n+            PathBase::Download => dirs.download_dir.clone(),\n+            PathBase::Build => dirs.build_dir.clone(),\n+            PathBase::Dist => dirs.dist_dir.clone(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) enum RelPath {\n+    Base(PathBase),\n+    Join(&'static RelPath, &'static str),\n+}\n+\n+impl RelPath {\n+    pub(crate) const SOURCE: RelPath = RelPath::Base(PathBase::Source);\n+    pub(crate) const DOWNLOAD: RelPath = RelPath::Base(PathBase::Download);\n+    pub(crate) const BUILD: RelPath = RelPath::Base(PathBase::Build);\n+    pub(crate) const DIST: RelPath = RelPath::Base(PathBase::Dist);\n+\n+    pub(crate) const SCRIPTS: RelPath = RelPath::SOURCE.join(\"scripts\");\n+    pub(crate) const BUILD_SYSROOT: RelPath = RelPath::SOURCE.join(\"build_sysroot\");\n+    pub(crate) const PATCHES: RelPath = RelPath::SOURCE.join(\"patches\");\n+\n+    pub(crate) const fn join(&'static self, suffix: &'static str) -> RelPath {\n+        RelPath::Join(self, suffix)\n+    }\n+\n+    pub(crate) fn to_path(&self, dirs: &Dirs) -> PathBuf {\n+        match self {\n+            RelPath::Base(base) => base.to_path(dirs),\n+            RelPath::Join(base, suffix) => base.to_path(dirs).join(suffix),\n+        }\n+    }\n+\n+    pub(crate) fn ensure_exists(&self, dirs: &Dirs) {\n+        fs::create_dir_all(self.to_path(dirs)).unwrap();\n+    }\n+\n+    pub(crate) fn ensure_fresh(&self, dirs: &Dirs) {\n+        let path = self.to_path(dirs);\n+        if path.exists() {\n+            fs::remove_dir_all(&path).unwrap();\n+        }\n+        fs::create_dir_all(path).unwrap();\n+    }\n+}"}, {"sha": "8ac67e8f9422823090a97ffab654c0da5a848e12", "filename": "build_system/prepare.rs", "status": "modified", "additions": 78, "deletions": 76, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fprepare.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,92 +1,75 @@\n-use std::env;\n use std::ffi::OsStr;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n+use super::build_sysroot::{SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n+use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n-use super::utils::{cargo_command, copy_dir_recursively, spawn_and_wait};\n-\n-pub(crate) const ABI_CAFE: GitRepo =\n-    GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n-\n-pub(crate) const RAND: GitRepo =\n-    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n-\n-pub(crate) const REGEX: GitRepo =\n-    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n-\n-pub(crate) const PORTABLE_SIMD: GitRepo = GitRepo::github(\n-    \"rust-lang\",\n-    \"portable-simd\",\n-    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n-    \"portable-simd\",\n-);\n-\n-pub(crate) const SIMPLE_RAYTRACER: GitRepo = GitRepo::github(\n-    \"ebobby\",\n-    \"simple-raytracer\",\n-    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n-    \"<none>\",\n-);\n-\n-pub(crate) fn prepare() {\n-    if Path::new(\"download\").exists() {\n-        std::fs::remove_dir_all(Path::new(\"download\")).unwrap();\n+use super::utils::{copy_dir_recursively, spawn_and_wait, Compiler};\n+\n+pub(crate) fn prepare(dirs: &Dirs) {\n+    if RelPath::DOWNLOAD.to_path(dirs).exists() {\n+        std::fs::remove_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n     }\n-    std::fs::create_dir_all(Path::new(\"download\")).unwrap();\n+    std::fs::create_dir_all(RelPath::DOWNLOAD.to_path(dirs)).unwrap();\n \n-    prepare_sysroot();\n+    prepare_sysroot(dirs);\n \n     // FIXME maybe install this only locally?\n     eprintln!(\"[INSTALL] hyperfine\");\n-    Command::new(\"cargo\").arg(\"install\").arg(\"hyperfine\").spawn().unwrap().wait().unwrap();\n+    Command::new(\"cargo\")\n+        .arg(\"install\")\n+        .arg(\"hyperfine\")\n+        .env_remove(\"CARGO_TARGET_DIR\")\n+        .spawn()\n+        .unwrap()\n+        .wait()\n+        .unwrap();\n \n-    ABI_CAFE.fetch();\n-    RAND.fetch();\n-    REGEX.fetch();\n-    PORTABLE_SIMD.fetch();\n-    SIMPLE_RAYTRACER.fetch();\n+    super::abi_cafe::ABI_CAFE_REPO.fetch(dirs);\n+    super::tests::RAND_REPO.fetch(dirs);\n+    super::tests::REGEX_REPO.fetch(dirs);\n+    super::tests::PORTABLE_SIMD_REPO.fetch(dirs);\n+    super::tests::SIMPLE_RAYTRACER_REPO.fetch(dirs);\n \n     eprintln!(\"[LLVM BUILD] simple-raytracer\");\n-    let build_cmd = cargo_command(\"cargo\", \"build\", None, &SIMPLE_RAYTRACER.source_dir());\n+    let host_compiler = Compiler::host();\n+    let build_cmd = super::tests::SIMPLE_RAYTRACER.build(&host_compiler, dirs);\n     spawn_and_wait(build_cmd);\n     fs::copy(\n-        SIMPLE_RAYTRACER\n-            .source_dir()\n-            .join(\"target\")\n+        super::tests::SIMPLE_RAYTRACER\n+            .target_dir(dirs)\n+            .join(&host_compiler.triple)\n             .join(\"debug\")\n             .join(get_file_name(\"main\", \"bin\")),\n-        SIMPLE_RAYTRACER.source_dir().join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n+        RelPath::BUILD.to_path(dirs).join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n     )\n     .unwrap();\n }\n \n-fn prepare_sysroot() {\n+fn prepare_sysroot(dirs: &Dirs) {\n     let rustc_path = get_rustc_path();\n     let sysroot_src_orig = rustc_path.parent().unwrap().join(\"../lib/rustlib/src/rust\");\n-    let sysroot_src = env::current_dir().unwrap().join(\"build_sysroot\").join(\"sysroot_src\");\n+    let sysroot_src = SYSROOT_SRC;\n \n     assert!(sysroot_src_orig.exists());\n \n-    if sysroot_src.exists() {\n-        fs::remove_dir_all(&sysroot_src).unwrap();\n-    }\n-    fs::create_dir_all(sysroot_src.join(\"library\")).unwrap();\n+    sysroot_src.ensure_fresh(dirs);\n+    fs::create_dir_all(sysroot_src.to_path(dirs).join(\"library\")).unwrap();\n     eprintln!(\"[COPY] sysroot src\");\n-    copy_dir_recursively(&sysroot_src_orig.join(\"library\"), &sysroot_src.join(\"library\"));\n+    copy_dir_recursively(\n+        &sysroot_src_orig.join(\"library\"),\n+        &sysroot_src.to_path(dirs).join(\"library\"),\n+    );\n \n     let rustc_version = get_rustc_version();\n-    fs::write(Path::new(\"build_sysroot\").join(\"rustc_version\"), &rustc_version).unwrap();\n+    fs::write(SYSROOT_RUSTC_VERSION.to_path(dirs), &rustc_version).unwrap();\n \n     eprintln!(\"[GIT] init\");\n-    let mut git_init_cmd = Command::new(\"git\");\n-    git_init_cmd.arg(\"init\").arg(\"-q\").current_dir(&sysroot_src);\n-    spawn_and_wait(git_init_cmd);\n-\n-    init_git_repo(&sysroot_src);\n+    init_git_repo(&sysroot_src.to_path(dirs));\n \n-    apply_patches(\"sysroot\", &sysroot_src);\n+    apply_patches(dirs, \"sysroot\", &sysroot_src.to_path(dirs));\n }\n \n pub(crate) struct GitRepo {\n@@ -100,7 +83,7 @@ enum GitRepoUrl {\n }\n \n impl GitRepo {\n-    const fn github(\n+    pub(crate) const fn github(\n         user: &'static str,\n         repo: &'static str,\n         rev: &'static str,\n@@ -109,21 +92,25 @@ impl GitRepo {\n         GitRepo { url: GitRepoUrl::Github { user, repo }, rev, patch_name }\n     }\n \n-    pub(crate) fn source_dir(&self) -> PathBuf {\n+    pub(crate) const fn source_dir(&self) -> RelPath {\n         match self.url {\n-            GitRepoUrl::Github { user: _, repo } => {\n-                std::env::current_dir().unwrap().join(\"download\").join(repo)\n-            }\n+            GitRepoUrl::Github { user: _, repo } => RelPath::DOWNLOAD.join(repo),\n         }\n     }\n \n-    fn fetch(&self) {\n+    fn fetch(&self, dirs: &Dirs) {\n         match self.url {\n             GitRepoUrl::Github { user, repo } => {\n-                clone_repo_shallow_github(&self.source_dir(), user, repo, self.rev);\n+                clone_repo_shallow_github(\n+                    dirs,\n+                    &self.source_dir().to_path(dirs),\n+                    user,\n+                    repo,\n+                    self.rev,\n+                );\n             }\n         }\n-        apply_patches(self.patch_name, &self.source_dir());\n+        apply_patches(dirs, self.patch_name, &self.source_dir().to_path(dirs));\n     }\n }\n \n@@ -142,18 +129,16 @@ fn clone_repo(download_dir: &Path, repo: &str, rev: &str) {\n     spawn_and_wait(checkout_cmd);\n }\n \n-fn clone_repo_shallow_github(download_dir: &Path, user: &str, repo: &str, rev: &str) {\n+fn clone_repo_shallow_github(dirs: &Dirs, download_dir: &Path, user: &str, repo: &str, rev: &str) {\n     if cfg!(windows) {\n         // Older windows doesn't have tar or curl by default. Fall back to using git.\n         clone_repo(download_dir, &format!(\"https://github.com/{}/{}.git\", user, repo), rev);\n         return;\n     }\n \n-    let downloads_dir = std::env::current_dir().unwrap().join(\"download\");\n-\n     let archive_url = format!(\"https://github.com/{}/{}/archive/{}.tar.gz\", user, repo, rev);\n-    let archive_file = downloads_dir.join(format!(\"{}.tar.gz\", rev));\n-    let archive_dir = downloads_dir.join(format!(\"{}-{}\", repo, rev));\n+    let archive_file = RelPath::DOWNLOAD.to_path(dirs).join(format!(\"{}.tar.gz\", rev));\n+    let archive_dir = RelPath::DOWNLOAD.to_path(dirs).join(format!(\"{}-{}\", repo, rev));\n \n     eprintln!(\"[DOWNLOAD] {}/{} from {}\", user, repo, archive_url);\n \n@@ -169,7 +154,7 @@ fn clone_repo_shallow_github(download_dir: &Path, user: &str, repo: &str, rev: &\n \n     // Unpack tar archive\n     let mut unpack_cmd = Command::new(\"tar\");\n-    unpack_cmd.arg(\"xf\").arg(&archive_file).current_dir(downloads_dir);\n+    unpack_cmd.arg(\"xf\").arg(&archive_file).current_dir(RelPath::DOWNLOAD.to_path(dirs));\n     spawn_and_wait(unpack_cmd);\n \n     // Rename unpacked dir to the expected name\n@@ -191,12 +176,21 @@ fn init_git_repo(repo_dir: &Path) {\n     spawn_and_wait(git_add_cmd);\n \n     let mut git_commit_cmd = Command::new(\"git\");\n-    git_commit_cmd.arg(\"commit\").arg(\"-m\").arg(\"Initial commit\").arg(\"-q\").current_dir(repo_dir);\n+    git_commit_cmd\n+        .arg(\"-c\")\n+        .arg(\"user.name=Dummy\")\n+        .arg(\"-c\")\n+        .arg(\"user.email=dummy@example.com\")\n+        .arg(\"commit\")\n+        .arg(\"-m\")\n+        .arg(\"Initial commit\")\n+        .arg(\"-q\")\n+        .current_dir(repo_dir);\n     spawn_and_wait(git_commit_cmd);\n }\n \n-fn get_patches(source_dir: &Path, crate_name: &str) -> Vec<PathBuf> {\n-    let mut patches: Vec<_> = fs::read_dir(source_dir.join(\"patches\"))\n+fn get_patches(dirs: &Dirs, crate_name: &str) -> Vec<PathBuf> {\n+    let mut patches: Vec<_> = fs::read_dir(RelPath::PATCHES.to_path(dirs))\n         .unwrap()\n         .map(|entry| entry.unwrap().path())\n         .filter(|path| path.extension() == Some(OsStr::new(\"patch\")))\n@@ -215,19 +209,27 @@ fn get_patches(source_dir: &Path, crate_name: &str) -> Vec<PathBuf> {\n     patches\n }\n \n-fn apply_patches(crate_name: &str, target_dir: &Path) {\n+fn apply_patches(dirs: &Dirs, crate_name: &str, target_dir: &Path) {\n     if crate_name == \"<none>\" {\n         return;\n     }\n \n-    for patch in get_patches(&std::env::current_dir().unwrap(), crate_name) {\n+    for patch in get_patches(dirs, crate_name) {\n         eprintln!(\n             \"[PATCH] {:?} <- {:?}\",\n             target_dir.file_name().unwrap(),\n             patch.file_name().unwrap()\n         );\n         let mut apply_patch_cmd = Command::new(\"git\");\n-        apply_patch_cmd.arg(\"am\").arg(patch).arg(\"-q\").current_dir(target_dir);\n+        apply_patch_cmd\n+            .arg(\"-c\")\n+            .arg(\"user.name=Dummy\")\n+            .arg(\"-c\")\n+            .arg(\"user.email=dummy@example.com\")\n+            .arg(\"am\")\n+            .arg(patch)\n+            .arg(\"-q\")\n+            .current_dir(target_dir);\n         spawn_and_wait(apply_patch_cmd);\n     }\n }"}, {"sha": "8e5ab688e131b35325af4fb83a3387b8c6228449", "filename": "build_system/rustc_info.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Frustc_info.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -23,6 +23,16 @@ pub(crate) fn get_host_triple() -> String {\n         .to_owned()\n }\n \n+pub(crate) fn get_cargo_path() -> PathBuf {\n+    let cargo_path = Command::new(\"rustup\")\n+        .stderr(Stdio::inherit())\n+        .args(&[\"which\", \"cargo\"])\n+        .output()\n+        .unwrap()\n+        .stdout;\n+    Path::new(String::from_utf8(cargo_path).unwrap().trim()).to_owned()\n+}\n+\n pub(crate) fn get_rustc_path() -> PathBuf {\n     let rustc_path = Command::new(\"rustup\")\n         .stderr(Stdio::inherit())\n@@ -33,6 +43,16 @@ pub(crate) fn get_rustc_path() -> PathBuf {\n     Path::new(String::from_utf8(rustc_path).unwrap().trim()).to_owned()\n }\n \n+pub(crate) fn get_rustdoc_path() -> PathBuf {\n+    let rustc_path = Command::new(\"rustup\")\n+        .stderr(Stdio::inherit())\n+        .args(&[\"which\", \"rustdoc\"])\n+        .output()\n+        .unwrap()\n+        .stdout;\n+    Path::new(String::from_utf8(rustc_path).unwrap().trim()).to_owned()\n+}\n+\n pub(crate) fn get_default_sysroot() -> PathBuf {\n     let default_sysroot = Command::new(\"rustc\")\n         .stderr(Stdio::inherit())"}, {"sha": "1c372736ed65d9121dccf04ae5bcf504d45127bc", "filename": "build_system/tests.rs", "status": "modified", "additions": 294, "deletions": 259, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Ftests.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,15 +1,20 @@\n use super::build_sysroot;\n use super::config;\n-use super::prepare;\n-use super::rustc_info::get_wrapper_file_name;\n-use super::utils::{cargo_command, hyperfine_command, spawn_and_wait, spawn_and_wait_with_input};\n-use build_system::SysrootKind;\n+use super::path::{Dirs, RelPath};\n+use super::prepare::GitRepo;\n+use super::rustc_info::{get_cargo_path, get_wrapper_file_name};\n+use super::utils::{\n+    hyperfine_command, spawn_and_wait, spawn_and_wait_with_input, CargoProject, Compiler,\n+};\n+use super::SysrootKind;\n use std::env;\n use std::ffi::OsStr;\n use std::fs;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::process::Command;\n \n+static BUILD_EXAMPLE_OUT_DIR: RelPath = RelPath::BUILD.join(\"example\");\n+\n struct TestCase {\n     config: &'static str,\n     func: &'static dyn Fn(&TestRunner),\n@@ -30,7 +35,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"lib,dylib\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"build.example\", &|runner| {\n@@ -39,7 +44,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"lib\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"jit.mini_core_hello_world\", &|runner| {\n@@ -51,7 +56,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--cfg\",\n             \"jit\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n         spawn_and_wait(jit_cmd);\n@@ -65,7 +70,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--cfg\",\n             \"jit\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n         spawn_and_wait(jit_cmd);\n@@ -79,7 +84,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-g\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"mini_core_hello_world\", [\"abc\", \"bcd\"]);\n     }),\n@@ -94,7 +99,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"arbitrary_self_types_pointers_and_wrappers\", []);\n     }),\n@@ -106,7 +111,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"issue_91827_extern_types\", []);\n     }),\n@@ -116,7 +121,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"lib\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"aot.alloc_example\", &|runner| {\n@@ -125,7 +130,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"alloc_example\", []);\n     }),\n@@ -136,7 +141,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"-Cprefer-dynamic\",\n             \"example/std_example.rs\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n \n         eprintln!(\"[JIT-lazy] std_example\");\n@@ -146,7 +151,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"-Cprefer-dynamic\",\n             \"example/std_example.rs\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"aot.std_example\", &|runner| {\n@@ -155,7 +160,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"std_example\", [\"arg\"]);\n     }),\n@@ -167,7 +172,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"dst_field_align\", []);\n     }),\n@@ -178,7 +183,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-Cpanic=abort\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"subslice-patterns-const-eval\", []);\n     }),\n@@ -189,7 +194,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-Cpanic=abort\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"track-caller-attribute\", []);\n     }),\n@@ -200,7 +205,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-Cpanic=abort\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"float-minmax-pass\", []);\n     }),\n@@ -210,205 +215,252 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"mod_bench\", []);\n     }),\n+    TestCase::new(\"aot.issue-72793\", &|runner| {\n+        runner.run_rustc([\n+            \"example/issue-72793.rs\",\n+            \"--crate-type\",\n+            \"bin\",\n+            \"--target\",\n+            &runner.target_compiler.triple,\n+        ]);\n+        runner.run_out_command(\"issue-72793\", []);\n+    }),\n ];\n \n+pub(crate) static RAND_REPO: GitRepo =\n+    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n+\n+static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n+\n+pub(crate) static REGEX_REPO: GitRepo =\n+    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n+\n+static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n+\n+pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n+    \"rust-lang\",\n+    \"portable-simd\",\n+    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n+    \"portable-simd\",\n+);\n+\n+static PORTABLE_SIMD: CargoProject =\n+    CargoProject::new(&PORTABLE_SIMD_REPO.source_dir(), \"portable_simd\");\n+\n+pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n+    \"ebobby\",\n+    \"simple-raytracer\",\n+    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n+    \"<none>\",\n+);\n+\n+pub(crate) static SIMPLE_RAYTRACER: CargoProject =\n+    CargoProject::new(&SIMPLE_RAYTRACER_REPO.source_dir(), \"simple_raytracer\");\n+\n+static LIBCORE_TESTS: CargoProject =\n+    CargoProject::new(&RelPath::BUILD_SYSROOT.join(\"sysroot_src/library/core/tests\"), \"core_tests\");\n+\n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::new(\"test.rust-random/rand\", &|runner| {\n-        runner.in_dir(prepare::RAND.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-\n-            if runner.host_triple == runner.target_triple {\n-                eprintln!(\"[TEST] rust-random/rand\");\n-                runner.run_cargo(\"test\", [\"--workspace\"]);\n-            } else {\n-                eprintln!(\"[AOT] rust-random/rand\");\n-                runner.run_cargo(\"build\", [\"--workspace\", \"--tests\"]);\n-            }\n-        });\n+        spawn_and_wait(RAND.clean(&runner.target_compiler.cargo, &runner.dirs));\n+\n+        if runner.is_native {\n+            eprintln!(\"[TEST] rust-random/rand\");\n+            let mut test_cmd = RAND.test(&runner.target_compiler, &runner.dirs);\n+            test_cmd.arg(\"--workspace\");\n+            spawn_and_wait(test_cmd);\n+        } else {\n+            eprintln!(\"[AOT] rust-random/rand\");\n+            let mut build_cmd = RAND.build(&runner.target_compiler, &runner.dirs);\n+            build_cmd.arg(\"--workspace\").arg(\"--tests\");\n+            spawn_and_wait(build_cmd);\n+        }\n     }),\n     TestCase::new(\"bench.simple-raytracer\", &|runner| {\n-        runner.in_dir(prepare::SIMPLE_RAYTRACER.source_dir(), |runner| {\n-            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n-\n-            if runner.host_triple == runner.target_triple {\n-                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n-                let prepare = runner.cargo_command(\"clean\", []);\n-\n-                let llvm_build_cmd = cargo_command(\"cargo\", \"build\", None, Path::new(\".\"));\n-\n-                let cargo_clif = runner\n-                    .root_dir\n-                    .clone()\n-                    .join(\"build\")\n-                    .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n-                let clif_build_cmd = cargo_command(cargo_clif, \"build\", None, Path::new(\".\"));\n-\n-                let bench_compile =\n-                    hyperfine_command(1, run_runs, Some(prepare), llvm_build_cmd, clif_build_cmd);\n-\n-                spawn_and_wait(bench_compile);\n-\n-                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n-                fs::copy(PathBuf::from(\"./target/debug/main\"), PathBuf::from(\"raytracer_cg_clif\"))\n-                    .unwrap();\n-\n-                let bench_run = hyperfine_command(\n-                    0,\n-                    run_runs,\n-                    None,\n-                    Command::new(\"./raytracer_cg_llvm\"),\n-                    Command::new(\"./raytracer_cg_clif\"),\n-                );\n-                spawn_and_wait(bench_run);\n-            } else {\n-                runner.run_cargo(\"clean\", []);\n-                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n-                eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n-                runner.run_cargo(\"build\", []);\n-                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n-            }\n-        });\n+        let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n+\n+        if runner.is_native {\n+            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n+            let cargo_clif = RelPath::DIST\n+                .to_path(&runner.dirs)\n+                .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n+            let manifest_path = SIMPLE_RAYTRACER.manifest_path(&runner.dirs);\n+            let target_dir = SIMPLE_RAYTRACER.target_dir(&runner.dirs);\n+\n+            let clean_cmd = format!(\n+                \"cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n+                manifest_path = manifest_path.display(),\n+                target_dir = target_dir.display(),\n+            );\n+            let llvm_build_cmd = format!(\n+                \"cargo build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+                manifest_path = manifest_path.display(),\n+                target_dir = target_dir.display(),\n+            );\n+            let clif_build_cmd = format!(\n+                \"{cargo_clif} build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+                cargo_clif = cargo_clif.display(),\n+                manifest_path = manifest_path.display(),\n+                target_dir = target_dir.display(),\n+            );\n+\n+            let bench_compile =\n+                hyperfine_command(1, run_runs, Some(&clean_cmd), &llvm_build_cmd, &clif_build_cmd);\n+\n+            spawn_and_wait(bench_compile);\n+\n+            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n+            fs::copy(\n+                target_dir.join(\"debug\").join(\"main\"),\n+                RelPath::BUILD.to_path(&runner.dirs).join(\"raytracer_cg_clif\"),\n+            )\n+            .unwrap();\n+\n+            let mut bench_run =\n+                hyperfine_command(0, run_runs, None, \"./raytracer_cg_llvm\", \"./raytracer_cg_clif\");\n+            bench_run.current_dir(RelPath::BUILD.to_path(&runner.dirs));\n+            spawn_and_wait(bench_run);\n+        } else {\n+            spawn_and_wait(SIMPLE_RAYTRACER.clean(&runner.target_compiler.cargo, &runner.dirs));\n+            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n+            eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n+            spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler, &runner.dirs));\n+            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n+        }\n     }),\n     TestCase::new(\"test.libcore\", &|runner| {\n-        runner.in_dir(\n-            std::env::current_dir()\n-                .unwrap()\n-                .join(\"build_sysroot\")\n-                .join(\"sysroot_src\")\n-                .join(\"library\")\n-                .join(\"core\")\n-                .join(\"tests\"),\n-            |runner| {\n-                runner.run_cargo(\"clean\", []);\n-\n-                if runner.host_triple == runner.target_triple {\n-                    runner.run_cargo(\"test\", []);\n-                } else {\n-                    eprintln!(\"Cross-Compiling: Not running tests\");\n-                    runner.run_cargo(\"build\", [\"--tests\"]);\n-                }\n-            },\n-        );\n+        spawn_and_wait(LIBCORE_TESTS.clean(&runner.host_compiler.cargo, &runner.dirs));\n+\n+        if runner.is_native {\n+            spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs));\n+        } else {\n+            eprintln!(\"Cross-Compiling: Not running tests\");\n+            let mut build_cmd = LIBCORE_TESTS.build(&runner.target_compiler, &runner.dirs);\n+            build_cmd.arg(\"--tests\");\n+            spawn_and_wait(build_cmd);\n+        }\n     }),\n     TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n-        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-\n-            // newer aho_corasick versions throw a deprecation warning\n-            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n-\n-            let mut build_cmd = runner.cargo_command(\"build\", [\"--example\", \"shootout-regex-dna\"]);\n-            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n-            spawn_and_wait(build_cmd);\n-\n-            if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command(\"run\", [\"--example\", \"shootout-regex-dna\"]);\n-                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n-\n-                let input =\n-                    fs::read_to_string(PathBuf::from(\"examples/regexdna-input.txt\")).unwrap();\n-                let expected_path = PathBuf::from(\"examples/regexdna-output.txt\");\n-                let expected = fs::read_to_string(&expected_path).unwrap();\n-\n-                let output = spawn_and_wait_with_input(run_cmd, input);\n-                // Make sure `[codegen mono items] start` doesn't poison the diff\n-                let output = output\n-                    .lines()\n-                    .filter(|line| !line.contains(\"codegen mono items\"))\n-                    .chain(Some(\"\")) // This just adds the trailing newline\n-                    .collect::<Vec<&str>>()\n-                    .join(\"\\r\\n\");\n-\n-                let output_matches = expected.lines().eq(output.lines());\n-                if !output_matches {\n-                    let res_path = PathBuf::from(\"res.txt\");\n-                    fs::write(&res_path, &output).unwrap();\n-\n-                    if cfg!(windows) {\n-                        println!(\"Output files don't match!\");\n-                        println!(\"Expected Output:\\n{}\", expected);\n-                        println!(\"Actual Output:\\n{}\", output);\n-                    } else {\n-                        let mut diff = Command::new(\"diff\");\n-                        diff.arg(\"-u\");\n-                        diff.arg(res_path);\n-                        diff.arg(expected_path);\n-                        spawn_and_wait(diff);\n-                    }\n-\n-                    std::process::exit(1);\n+        spawn_and_wait(REGEX.clean(&runner.target_compiler.cargo, &runner.dirs));\n+\n+        // newer aho_corasick versions throw a deprecation warning\n+        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n+\n+        let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n+        build_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n+        build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+        spawn_and_wait(build_cmd);\n+\n+        if runner.is_native {\n+            let mut run_cmd = REGEX.run(&runner.target_compiler, &runner.dirs);\n+            run_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n+            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+\n+            let input = fs::read_to_string(\n+                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-input.txt\"),\n+            )\n+            .unwrap();\n+            let expected_path =\n+                REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-output.txt\");\n+            let expected = fs::read_to_string(&expected_path).unwrap();\n+\n+            let output = spawn_and_wait_with_input(run_cmd, input);\n+            // Make sure `[codegen mono items] start` doesn't poison the diff\n+            let output = output\n+                .lines()\n+                .filter(|line| !line.contains(\"codegen mono items\"))\n+                .chain(Some(\"\")) // This just adds the trailing newline\n+                .collect::<Vec<&str>>()\n+                .join(\"\\r\\n\");\n+\n+            let output_matches = expected.lines().eq(output.lines());\n+            if !output_matches {\n+                let res_path = REGEX.source_dir(&runner.dirs).join(\"res.txt\");\n+                fs::write(&res_path, &output).unwrap();\n+\n+                if cfg!(windows) {\n+                    println!(\"Output files don't match!\");\n+                    println!(\"Expected Output:\\n{}\", expected);\n+                    println!(\"Actual Output:\\n{}\", output);\n+                } else {\n+                    let mut diff = Command::new(\"diff\");\n+                    diff.arg(\"-u\");\n+                    diff.arg(res_path);\n+                    diff.arg(expected_path);\n+                    spawn_and_wait(diff);\n                 }\n+\n+                std::process::exit(1);\n             }\n-        });\n+        }\n     }),\n     TestCase::new(\"test.regex\", &|runner| {\n-        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-\n-            // newer aho_corasick versions throw a deprecation warning\n-            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n-\n-            if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command(\n-                    \"test\",\n-                    [\n-                        \"--tests\",\n-                        \"--\",\n-                        \"--exclude-should-panic\",\n-                        \"--test-threads\",\n-                        \"1\",\n-                        \"-Zunstable-options\",\n-                        \"-q\",\n-                    ],\n-                );\n-                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n-                spawn_and_wait(run_cmd);\n-            } else {\n-                eprintln!(\"Cross-Compiling: Not running tests\");\n-                let mut build_cmd =\n-                    runner.cargo_command(\"build\", [\"--tests\", \"--target\", &runner.target_triple]);\n-                build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n-                spawn_and_wait(build_cmd);\n-            }\n-        });\n+        spawn_and_wait(REGEX.clean(&runner.host_compiler.cargo, &runner.dirs));\n+\n+        // newer aho_corasick versions throw a deprecation warning\n+        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n+\n+        if runner.is_native {\n+            let mut run_cmd = REGEX.test(&runner.target_compiler, &runner.dirs);\n+            run_cmd.args([\n+                \"--tests\",\n+                \"--\",\n+                \"--exclude-should-panic\",\n+                \"--test-threads\",\n+                \"1\",\n+                \"-Zunstable-options\",\n+                \"-q\",\n+            ]);\n+            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+            spawn_and_wait(run_cmd);\n+        } else {\n+            eprintln!(\"Cross-Compiling: Not running tests\");\n+            let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n+            build_cmd.arg(\"--tests\");\n+            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+            spawn_and_wait(build_cmd);\n+        }\n     }),\n     TestCase::new(\"test.portable-simd\", &|runner| {\n-        runner.in_dir(prepare::PORTABLE_SIMD.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-            runner.run_cargo(\"build\", [\"--all-targets\", \"--target\", &runner.target_triple]);\n+        spawn_and_wait(PORTABLE_SIMD.clean(&runner.host_compiler.cargo, &runner.dirs));\n \n-            if runner.host_triple == runner.target_triple {\n-                runner.run_cargo(\"test\", [\"-q\"]);\n-            }\n-        });\n+        let mut build_cmd = PORTABLE_SIMD.build(&runner.target_compiler, &runner.dirs);\n+        build_cmd.arg(\"--all-targets\");\n+        spawn_and_wait(build_cmd);\n+\n+        if runner.is_native {\n+            let mut test_cmd = PORTABLE_SIMD.test(&runner.target_compiler, &runner.dirs);\n+            test_cmd.arg(\"-q\");\n+            spawn_and_wait(test_cmd);\n+        }\n     }),\n ];\n \n pub(crate) fn run_tests(\n+    dirs: &Dirs,\n     channel: &str,\n     sysroot_kind: SysrootKind,\n-    target_dir: &Path,\n     cg_clif_dylib: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n-    let runner = TestRunner::new(host_triple.to_string(), target_triple.to_string());\n+    let runner = TestRunner::new(dirs.clone(), host_triple.to_string(), target_triple.to_string());\n \n     if config::get_bool(\"testsuite.no_sysroot\") {\n         build_sysroot::build_sysroot(\n+            dirs,\n             channel,\n             SysrootKind::None,\n-            &target_dir,\n             cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n         );\n \n-        let _ = fs::remove_dir_all(Path::new(\"target\").join(\"out\"));\n+        BUILD_EXAMPLE_OUT_DIR.ensure_fresh(dirs);\n         runner.run_testsuite(NO_SYSROOT_SUITE);\n     } else {\n         eprintln!(\"[SKIP] no_sysroot tests\");\n@@ -419,9 +471,9 @@ pub(crate) fn run_tests(\n \n     if run_base_sysroot || run_extended_sysroot {\n         build_sysroot::build_sysroot(\n+            dirs,\n             channel,\n             sysroot_kind,\n-            &target_dir,\n             cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n@@ -442,40 +494,50 @@ pub(crate) fn run_tests(\n }\n \n struct TestRunner {\n-    root_dir: PathBuf,\n-    out_dir: PathBuf,\n+    is_native: bool,\n     jit_supported: bool,\n-    rust_flags: String,\n-    run_wrapper: Vec<String>,\n-    host_triple: String,\n-    target_triple: String,\n+    dirs: Dirs,\n+    host_compiler: Compiler,\n+    target_compiler: Compiler,\n }\n \n impl TestRunner {\n-    pub fn new(host_triple: String, target_triple: String) -> Self {\n-        let root_dir = env::current_dir().unwrap();\n-\n-        let mut out_dir = root_dir.clone();\n-        out_dir.push(\"target\");\n-        out_dir.push(\"out\");\n-\n+    pub fn new(dirs: Dirs, host_triple: String, target_triple: String) -> Self {\n         let is_native = host_triple == target_triple;\n         let jit_supported =\n             target_triple.contains(\"x86_64\") && is_native && !host_triple.contains(\"windows\");\n \n-        let mut rust_flags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n-        let mut run_wrapper = Vec::new();\n+        let rustc_clif =\n+            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n+        let rustdoc_clif =\n+            RelPath::DIST.to_path(&dirs).join(get_wrapper_file_name(\"rustdoc-clif\", \"bin\"));\n+\n+        let mut rustflags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n+        let mut runner = vec![];\n \n         if !is_native {\n             match target_triple.as_str() {\n                 \"aarch64-unknown-linux-gnu\" => {\n                     // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-                    rust_flags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rust_flags);\n-                    run_wrapper = vec![\"qemu-aarch64\", \"-L\", \"/usr/aarch64-linux-gnu\"];\n+                    rustflags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rustflags);\n+                    runner = vec![\n+                        \"qemu-aarch64\".to_owned(),\n+                        \"-L\".to_owned(),\n+                        \"/usr/aarch64-linux-gnu\".to_owned(),\n+                    ];\n+                }\n+                \"s390x-unknown-linux-gnu\" => {\n+                    // We are cross-compiling for s390x. Use the correct linker and run tests in qemu.\n+                    rustflags = format!(\"-Clinker=s390x-linux-gnu-gcc{}\", rustflags);\n+                    runner = vec![\n+                        \"qemu-s390x\".to_owned(),\n+                        \"-L\".to_owned(),\n+                        \"/usr/s390x-linux-gnu\".to_owned(),\n+                    ];\n                 }\n                 \"x86_64-pc-windows-gnu\" => {\n                     // We are cross-compiling for Windows. Run tests in wine.\n-                    run_wrapper = vec![\"wine\"];\n+                    runner = vec![\"wine\".to_owned()];\n                 }\n                 _ => {\n                     println!(\"Unknown non-native platform\");\n@@ -484,19 +546,31 @@ impl TestRunner {\n         }\n \n         // FIXME fix `#[linkage = \"extern_weak\"]` without this\n-        if host_triple.contains(\"darwin\") {\n-            rust_flags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rust_flags);\n+        if target_triple.contains(\"darwin\") {\n+            rustflags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rustflags);\n         }\n \n-        Self {\n-            root_dir,\n-            out_dir,\n-            jit_supported,\n-            rust_flags,\n-            run_wrapper: run_wrapper.iter().map(|s| s.to_string()).collect(),\n-            host_triple,\n-            target_triple,\n-        }\n+        let host_compiler = Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: rustc_clif.clone(),\n+            rustdoc: rustdoc_clif.clone(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple: host_triple,\n+            runner: vec![],\n+        };\n+\n+        let target_compiler = Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: rustc_clif,\n+            rustdoc: rustdoc_clif,\n+            rustflags: rustflags.clone(),\n+            rustdocflags: rustflags,\n+            triple: target_triple,\n+            runner,\n+        };\n+\n+        Self { is_native, jit_supported, dirs, host_compiler, target_compiler }\n     }\n \n     pub fn run_testsuite(&self, tests: &[TestCase]) {\n@@ -516,29 +590,18 @@ impl TestRunner {\n         }\n     }\n \n-    fn in_dir(&self, new: impl AsRef<Path>, callback: impl FnOnce(&TestRunner)) {\n-        let current = env::current_dir().unwrap();\n-\n-        env::set_current_dir(new).unwrap();\n-        callback(self);\n-        env::set_current_dir(current).unwrap();\n-    }\n-\n+    #[must_use]\n     fn rustc_command<I, S>(&self, args: I) -> Command\n     where\n         I: IntoIterator<Item = S>,\n         S: AsRef<OsStr>,\n     {\n-        let mut rustc_clif = self.root_dir.clone();\n-        rustc_clif.push(\"build\");\n-        rustc_clif.push(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n-\n-        let mut cmd = Command::new(rustc_clif);\n-        cmd.args(self.rust_flags.split_whitespace());\n+        let mut cmd = Command::new(&self.target_compiler.rustc);\n+        cmd.args(self.target_compiler.rustflags.split_whitespace());\n         cmd.arg(\"-L\");\n-        cmd.arg(format!(\"crate={}\", self.out_dir.display()));\n+        cmd.arg(format!(\"crate={}\", BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).display()));\n         cmd.arg(\"--out-dir\");\n-        cmd.arg(format!(\"{}\", self.out_dir.display()));\n+        cmd.arg(format!(\"{}\", BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).display()));\n         cmd.arg(\"-Cdebuginfo=2\");\n         cmd.args(args);\n         cmd\n@@ -559,15 +622,13 @@ impl TestRunner {\n         let mut full_cmd = vec![];\n \n         // Prepend the RUN_WRAPPER's\n-        if !self.run_wrapper.is_empty() {\n-            full_cmd.extend(self.run_wrapper.iter().cloned());\n+        if !self.target_compiler.runner.is_empty() {\n+            full_cmd.extend(self.target_compiler.runner.iter().cloned());\n         }\n \n-        full_cmd.push({\n-            let mut out_path = self.out_dir.clone();\n-            out_path.push(name);\n-            out_path.to_str().unwrap().to_string()\n-        });\n+        full_cmd.push(\n+            BUILD_EXAMPLE_OUT_DIR.to_path(&self.dirs).join(name).to_str().unwrap().to_string(),\n+        );\n \n         for arg in args.into_iter() {\n             full_cmd.push(arg.to_string());\n@@ -581,30 +642,4 @@ impl TestRunner {\n \n         spawn_and_wait(cmd);\n     }\n-\n-    fn cargo_command<'a, I>(&self, subcommand: &str, args: I) -> Command\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-    {\n-        let mut cargo_clif = self.root_dir.clone();\n-        cargo_clif.push(\"build\");\n-        cargo_clif.push(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n-\n-        let mut cmd = cargo_command(\n-            cargo_clif,\n-            subcommand,\n-            if subcommand == \"clean\" { None } else { Some(&self.target_triple) },\n-            Path::new(\".\"),\n-        );\n-        cmd.args(args);\n-        cmd.env(\"RUSTFLAGS\", &self.rust_flags);\n-        cmd\n-    }\n-\n-    fn run_cargo<'a, I>(&self, subcommand: &str, args: I)\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-    {\n-        spawn_and_wait(self.cargo_command(subcommand, args));\n-    }\n }"}, {"sha": "2be70e8e421b2961e97b53c99f38c83256940365", "filename": "build_system/utils.rs", "status": "modified", "additions": 124, "deletions": 21, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/build_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Futils.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,35 +1,138 @@\n use std::env;\n use std::fs;\n use std::io::Write;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::{self, Command, Stdio};\n \n-pub(crate) fn cargo_command(\n-    cargo: impl AsRef<Path>,\n-    subcommand: &str,\n-    triple: Option<&str>,\n-    source_dir: &Path,\n-) -> Command {\n-    let mut cmd = Command::new(cargo.as_ref());\n-    cmd.arg(subcommand)\n-        .arg(\"--manifest-path\")\n-        .arg(source_dir.join(\"Cargo.toml\"))\n-        .arg(\"--target-dir\")\n-        .arg(source_dir.join(\"target\"));\n+use super::path::{Dirs, RelPath};\n+use super::rustc_info::{get_cargo_path, get_host_triple, get_rustc_path, get_rustdoc_path};\n+\n+pub(crate) struct Compiler {\n+    pub(crate) cargo: PathBuf,\n+    pub(crate) rustc: PathBuf,\n+    pub(crate) rustdoc: PathBuf,\n+    pub(crate) rustflags: String,\n+    pub(crate) rustdocflags: String,\n+    pub(crate) triple: String,\n+    pub(crate) runner: Vec<String>,\n+}\n+\n+impl Compiler {\n+    pub(crate) fn host() -> Compiler {\n+        Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: get_rustc_path(),\n+            rustdoc: get_rustdoc_path(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple: get_host_triple(),\n+            runner: vec![],\n+        }\n+    }\n+\n+    pub(crate) fn with_triple(triple: String) -> Compiler {\n+        Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: get_rustc_path(),\n+            rustdoc: get_rustdoc_path(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple,\n+            runner: vec![],\n+        }\n+    }\n+}\n+\n+pub(crate) struct CargoProject {\n+    source: &'static RelPath,\n+    target: &'static str,\n+}\n+\n+impl CargoProject {\n+    pub(crate) const fn new(path: &'static RelPath, target: &'static str) -> CargoProject {\n+        CargoProject { source: path, target }\n+    }\n+\n+    pub(crate) fn source_dir(&self, dirs: &Dirs) -> PathBuf {\n+        self.source.to_path(dirs)\n+    }\n+\n+    pub(crate) fn manifest_path(&self, dirs: &Dirs) -> PathBuf {\n+        self.source_dir(dirs).join(\"Cargo.toml\")\n+    }\n+\n+    pub(crate) fn target_dir(&self, dirs: &Dirs) -> PathBuf {\n+        RelPath::BUILD.join(self.target).to_path(dirs)\n+    }\n \n-    if let Some(triple) = triple {\n-        cmd.arg(\"--target\").arg(triple);\n+    fn base_cmd(&self, command: &str, cargo: &Path, dirs: &Dirs) -> Command {\n+        let mut cmd = Command::new(cargo);\n+\n+        cmd.arg(command)\n+            .arg(\"--manifest-path\")\n+            .arg(self.manifest_path(dirs))\n+            .arg(\"--target-dir\")\n+            .arg(self.target_dir(dirs));\n+\n+        cmd\n+    }\n+\n+    fn build_cmd(&self, command: &str, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        let mut cmd = self.base_cmd(command, &compiler.cargo, dirs);\n+\n+        cmd.arg(\"--target\").arg(&compiler.triple);\n+\n+        cmd.env(\"RUSTC\", &compiler.rustc);\n+        cmd.env(\"RUSTDOC\", &compiler.rustdoc);\n+        cmd.env(\"RUSTFLAGS\", &compiler.rustflags);\n+        cmd.env(\"RUSTDOCFLAGS\", &compiler.rustdocflags);\n+        if !compiler.runner.is_empty() {\n+            cmd.env(\n+                format!(\"CARGO_TARGET_{}_RUNNER\", compiler.triple.to_uppercase().replace('-', \"_\")),\n+                compiler.runner.join(\" \"),\n+            );\n+        }\n+\n+        cmd\n     }\n \n-    cmd\n+    #[must_use]\n+    pub(crate) fn fetch(&self, cargo: impl AsRef<Path>, dirs: &Dirs) -> Command {\n+        let mut cmd = Command::new(cargo.as_ref());\n+\n+        cmd.arg(\"fetch\").arg(\"--manifest-path\").arg(self.manifest_path(dirs));\n+\n+        cmd\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn clean(&self, cargo: &Path, dirs: &Dirs) -> Command {\n+        self.base_cmd(\"clean\", cargo, dirs)\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn build(&self, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        self.build_cmd(\"build\", compiler, dirs)\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn test(&self, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        self.build_cmd(\"test\", compiler, dirs)\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn run(&self, compiler: &Compiler, dirs: &Dirs) -> Command {\n+        self.build_cmd(\"run\", compiler, dirs)\n+    }\n }\n \n+#[must_use]\n pub(crate) fn hyperfine_command(\n     warmup: u64,\n     runs: u64,\n-    prepare: Option<Command>,\n-    a: Command,\n-    b: Command,\n+    prepare: Option<&str>,\n+    a: &str,\n+    b: &str,\n ) -> Command {\n     let mut bench = Command::new(\"hyperfine\");\n \n@@ -42,10 +145,10 @@ pub(crate) fn hyperfine_command(\n     }\n \n     if let Some(prepare) = prepare {\n-        bench.arg(\"--prepare\").arg(format!(\"{:?}\", prepare));\n+        bench.arg(\"--prepare\").arg(prepare);\n     }\n \n-    bench.arg(format!(\"{:?}\", a)).arg(format!(\"{:?}\", b));\n+    bench.arg(a).arg(b);\n \n     bench\n }"}, {"sha": "1760e5836ecce00a48f7a0236748dfb94329fce0", "filename": "clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/clean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/clean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clean_all.sh?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -2,7 +2,7 @@\n set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n-rm -rf target/ build/ perf.data{,.old} y.bin\n+rm -rf target/ build/ dist/ perf.data{,.old} y.bin\n rm -rf download/\n \n # Kept for now in case someone updates their checkout of cg_clif before running clean_all.sh"}, {"sha": "258b67e931476850a25cab17bbc2c3300a243821", "filename": "config.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/config.txt", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/config.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.txt?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -40,6 +40,7 @@ aot.subslice-patterns-const-eval\n aot.track-caller-attribute\n aot.float-minmax-pass\n aot.mod_bench\n+aot.issue-72793\n \n testsuite.extended_sysroot\n test.rust-random/rand"}, {"sha": "4c2b0fa170498812b976b67041cc62ab73ff3f81", "filename": "docs/usage.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/docs%2Fusage.md", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/docs%2Fusage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fusage.md?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -9,7 +9,7 @@ Assuming `$cg_clif_dir` is the directory you cloned this repo into and you follo\n In the directory with your project (where you can do the usual `cargo build`), run:\n \n ```bash\n-$ $cg_clif_dir/build/cargo-clif build\n+$ $cg_clif_dir/dist/cargo-clif build\n ```\n \n This will build your project with rustc_codegen_cranelift instead of the usual LLVM backend.\n@@ -19,7 +19,7 @@ This will build your project with rustc_codegen_cranelift instead of the usual L\n > You should prefer using the Cargo method.\n \n ```bash\n-$ $cg_clif_dir/build/rustc-clif my_crate.rs\n+$ $cg_clif_dir/dist/rustc-clif my_crate.rs\n ```\n \n ## Jit mode\n@@ -32,20 +32,20 @@ In jit mode cg_clif will immediately execute your code without creating an execu\n > The jit mode will probably need cargo integration to make this possible.\n \n ```bash\n-$ $cg_clif_dir/build/cargo-clif jit\n+$ $cg_clif_dir/dist/cargo-clif jit\n ```\n \n or\n \n ```bash\n-$ $cg_clif_dir/build/rustc-clif -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n+$ $cg_clif_dir/dist/rustc-clif -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic my_crate.rs\n ```\n \n There is also an experimental lazy jit mode. In this mode functions are only compiled once they are\n first called.\n \n ```bash\n-$ $cg_clif_dir/build/cargo-clif lazy-jit\n+$ $cg_clif_dir/dist/cargo-clif lazy-jit\n ```\n \n ## Shell\n@@ -54,7 +54,7 @@ These are a few functions that allow you to easily run rust code from the shell\n \n ```bash\n function jit_naked() {\n-    echo \"$@\" | $cg_clif_dir/build/rustc-clif - -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic\n+    echo \"$@\" | $cg_clif_dir/dist/rustc-clif - -Zunstable-features -Cllvm-args=mode=jit -Cprefer-dynamic\n }\n \n function jit() {"}, {"sha": "b1bb9b8e1e73034927ae8f094d1fd997baa80b3a", "filename": "example/issue-72793.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/example%2Fissue-72793.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/example%2Fissue-72793.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fissue-72793.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -0,0 +1,24 @@\n+// Adapted from rustc ui test suite (ui/type-alias-impl-trait/issue-72793.rs)\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait T { type Item; }\n+\n+type Alias<'a> = impl T<Item = &'a ()>;\n+\n+struct S;\n+impl<'a> T for &'a S {\n+    type Item = &'a ();\n+}\n+\n+fn filter_positive<'a>() -> Alias<'a> {\n+    &S\n+}\n+\n+fn with_positive(fun: impl Fn(Alias<'_>)) {\n+    fun(filter_positive());\n+}\n+\n+fn main() {\n+    with_positive(|_| ());\n+}"}, {"sha": "1f9db1eb2a97affce42fe9395435a0b5cd0b8341", "filename": "example/mini_core.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/example%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/example%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -19,6 +19,9 @@ pub trait Sized {}\n #[lang = \"destruct\"]\n pub trait Destruct {}\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -443,7 +446,7 @@ pub struct PhantomData<T: ?Sized>;\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -452,7 +455,7 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n "}, {"sha": "c00f8a2e0cdad3229ad1362047bffeb8a4be2ad9", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -171,8 +171,6 @@ fn main() {\n \n     assert_eq!(slice_ptr as usize % 4, 0);\n \n-    //return;\n-\n     unsafe {\n         printf(\"Hello %s\\n\\0\" as *const str as *const i8, \"printf\\0\" as *const str as *const i8);\n "}, {"sha": "8481d9c39a3cf672e83f85b03220fabdacf61817", "filename": "example/std_example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -164,6 +164,8 @@ unsafe fn test_simd() {\n     let cmp_eq = _mm_cmpeq_epi8(y, y);\n     let cmp_lt = _mm_cmplt_epi8(y, y);\n \n+    let (zero0, zero1) = std::mem::transmute::<_, (u64, u64)>(x);\n+    assert_eq!((zero0, zero1), (0, 0));\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_eq), [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_lt), [0, 0, 0, 0, 0, 0, 0, 0]);"}, {"sha": "d8f28dbcc15c8c43d9631834b087f34ed547cebb", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-10-23\"\n+channel = \"nightly-2022-12-13\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "ebeca8662a5195c6408e8707a06248c189ffab99", "filename": "rustfmt.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,3 +1,5 @@\n+ignore = [\"y.rs\"]\n+\n # Matches rustfmt.toml of rustc\n version = \"Two\"\n use_small_heuristics = \"Max\""}, {"sha": "f782671fe36f9b45fab05a5c6f335d9880211c23", "filename": "scripts/filter_profile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/scripts%2Ffilter_profile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/scripts%2Ffilter_profile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ffilter_profile.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -2,7 +2,7 @@\n #![forbid(unsafe_code)]/* This line is ignored by bash\n # This block is ignored by rustc\n pushd $(dirname \"$0\")/../\n-RUSTC=\"$(pwd)/build/rustc-clif\"\n+RUSTC=\"$(pwd)/dist/rustc-clif\"\n popd\n PROFILE=$1 OUTPUT=$2 exec $RUSTC -Zunstable-options -Cllvm-args=mode=jit -Cprefer-dynamic $0\n #*/"}, {"sha": "a19d72acfa83e037ac857e1719c3ca1a988895f9", "filename": "scripts/rustdoc-clif.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/scripts%2Frustdoc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/scripts%2Frustdoc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Frustdoc-clif.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -0,0 +1,36 @@\n+use std::env;\n+use std::ffi::OsString;\n+#[cfg(unix)]\n+use std::os::unix::process::CommandExt;\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+fn main() {\n+    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+\n+    let cg_clif_dylib_path = sysroot.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n+        env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,\n+    );\n+\n+    let mut args = std::env::args_os().skip(1).collect::<Vec<_>>();\n+    args.push(OsString::from(\"-Cpanic=abort\"));\n+    args.push(OsString::from(\"-Zpanic-abort-tests\"));\n+    let mut codegen_backend_arg = OsString::from(\"-Zcodegen-backend=\");\n+    codegen_backend_arg.push(cg_clif_dylib_path);\n+    args.push(codegen_backend_arg);\n+    if !args.contains(&OsString::from(\"--sysroot\")) {\n+        args.push(OsString::from(\"--sysroot\"));\n+        args.push(OsString::from(sysroot.to_str().unwrap()));\n+    }\n+\n+    // Ensure that the right toolchain is used\n+    env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"RUSTUP_TOOLCHAIN\"));\n+\n+    #[cfg(unix)]\n+    Command::new(\"rustdoc\").args(args).exec();\n+\n+    #[cfg(not(unix))]\n+    std::process::exit(\n+        Command::new(\"rustdoc\").args(args).spawn().unwrap().wait().unwrap().code().unwrap_or(1),\n+    );\n+}"}, {"sha": "6c64b7de7daa10d863a903a186e0ee9c4846aeed", "filename": "scripts/setup_rust_fork.sh", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/scripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/scripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Fsetup_rust_fork.sh?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -27,24 +27,6 @@ index d95b5b7f17f..00b6f0e3635 100644\n  [dev-dependencies]\n  rand = \"0.7\"\n  rand_xorshift = \"0.2\"\n-diff --git a/src/tools/compiletest/src/runtest.rs b/src/tools/compiletest/src/runtest.rs\n-index 8431aa7b818..a3ff7e68ce5 100644\n---- a/src/tools/compiletest/src/runtest.rs\n-+++ b/src/tools/compiletest/src/runtest.rs\n-@@ -3489,12 +3489,7 @@ fn normalize_output(&self, output: &str, custom_rules: &[(String, String)]) -> S\n-         let compiler_src_dir = base_dir.join(\"compiler\");\n-         normalize_path(&compiler_src_dir, \"$(echo '$COMPILER_DIR')\");\n-\n--        if let Some(virtual_rust_source_base_dir) =\n--            option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\").map(PathBuf::from)\n--        {\n--            normalize_path(&virtual_rust_source_base_dir.join(\"library\"), \"$(echo '$SRC_DIR')\");\n--            normalize_path(&virtual_rust_source_base_dir.join(\"compiler\"), \"$(echo '$COMPILER_DIR')\");\n--        }\n-+        normalize_path(&Path::new(\"$(cd ../build_sysroot/sysroot_src/library; pwd)\"), \"$(echo '$SRC_DIR')\");\n-\n-         // Paths into the build directory\n-         let test_build_dir = &self.config.build_base;\n EOF\n \n cat > config.toml <<EOF\n@@ -54,7 +36,7 @@ changelog-seen = 2\n ninja = false\n \n [build]\n-rustc = \"$(pwd)/../build/rustc-clif\"\n+rustc = \"$(pwd)/../dist/rustc-clif\"\n cargo = \"$(rustup which cargo)\"\n full-bootstrap = true\n local-rebuild = true\n@@ -69,6 +51,8 @@ popd\n # FIXME remove once inline asm is fully supported\n export RUSTFLAGS=\"$RUSTFLAGS --cfg=rustix_use_libc\"\n \n+export CFG_VIRTUAL_RUST_SOURCE_BASE_DIR=\"$(cd build_sysroot/sysroot_src; pwd)\"\n+\n # Allow the testsuite to use llvm tools\n host_triple=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n export LLVM_BIN_DIR=\"$(rustc --print sysroot)/lib/rustlib/$host_triple/bin\""}, {"sha": "04ad77ec97eac3a76d01166d875cf18bc073f76f", "filename": "scripts/test_rustc_tests.sh", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/scripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/scripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftest_rustc_tests.sh?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -20,6 +20,7 @@ for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~[^\\|]*\\s*ERR|// error-pat\n done\n \n git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+git checkout -- src/test/ui/proc-macro/pretty-print-hack/\n \n # missing features\n # ================\n@@ -30,6 +31,7 @@ rm src/test/incremental/issue-80691-bad-eval-cache.rs # -Cpanic=abort causes abo\n \n # requires compiling with -Cpanic=unwind\n rm -r src/test/ui/macros/rfc-2011-nicer-assert-messages/\n+rm -r src/test/run-make/test-benches\n \n # vendor intrinsics\n rm src/test/ui/sse2.rs # cpuid not supported, so sse2 not detected\n@@ -64,6 +66,8 @@ rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n rm -r src/test/run-make/emit-named-files # requires full --emit support\n rm src/test/ui/abi/stack-probes.rs # stack probes not yet implemented\n rm src/test/ui/simd/intrinsic/ptr-cast.rs # simd_expose_addr intrinsic unimplemented\n+rm -r src/test/run-make/repr128-dwarf # debuginfo test\n+rm src/test/codegen-units/item-collection/asm-sym.rs # requires support for sym in asm!()\n \n # optimization tests\n # ==================\n@@ -82,20 +86,20 @@ rm src/test/ui/abi/stack-protector.rs # requires stack protector support\n rm src/test/ui/mir/mir_misc_casts.rs # depends on deduplication of constants\n rm src/test/ui/mir/mir_raw_fat_ptr.rs # same\n rm src/test/ui/consts/issue-33537.rs # same\n+rm src/test/ui/layout/valid_range_oob.rs # different ICE message\n \n # doesn't work due to the way the rustc test suite is invoked.\n # should work when using ./x.py test the way it is intended\n # ============================================================\n-rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in build/bin/\n+rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in dist/bin/\n rm -r src/test/run-make/unstable-flag-required # same\n rm -r src/test/run-make/rustdoc-* # same\n rm -r src/test/run-make/issue-88756-default-output # same\n rm -r src/test/run-make/remap-path-prefix-dwarf # requires llvm-dwarfdump\n+rm -r src/test/ui/consts/missing_span_in_backtrace.rs # expects sysroot source to be elsewhere\n \n # genuine bugs\n # ============\n-rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n-\n rm src/test/incremental/spike-neg1.rs # errors out for some reason\n rm src/test/incremental/spike-neg2.rs # same\n rm src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs\n@@ -104,13 +108,17 @@ rm src/test/ui/type-alias-impl-trait/assoc-projection-ice.rs # produces ICE\n \n rm src/test/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n+rm src/test/ui/runtime/out-of-stack.rs # SIGSEGV instead of SIGABRT for some reason (#1301)\n+\n # bugs in the test suite\n # ======================\n rm src/test/ui/backtrace.rs # TODO warning\n rm src/test/ui/simple_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n # not sure if this is actually a bug in the test suite, but the symbol list shows the function without leading _ for some reason\n rm -r src/test/run-make/native-link-modifier-bundle\n+rm src/test/ui/process/nofile-limit.rs # TODO some AArch64 linking issue\n+rm src/test/ui/dyn-star/dispatch-on-pin-mut.rs # TODO failed assertion in vtable::get_ptr_and_method_ref\n \n rm src/test/ui/stdio-is-blocking.rs # really slow with unoptimized libstd\n "}, {"sha": "65cc6b4376713d8c7e855c2fca1f833894a3cd09", "filename": "src/abi/mod.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -56,13 +56,13 @@ pub(crate) fn conv_to_call_conv(c: Conv, default_call_conv: CallConv) -> CallCon\n \n pub(crate) fn get_function_sig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    triple: &target_lexicon::Triple,\n+    default_call_conv: CallConv,\n     inst: Instance<'tcx>,\n ) -> Signature {\n     assert!(!inst.substs.needs_infer());\n     clif_sig_from_fn_abi(\n         tcx,\n-        CallConv::triple_default(triple),\n+        default_call_conv,\n         &RevealAllLayoutCx(tcx).fn_abi_of_instance(inst, ty::List::empty()),\n     )\n }\n@@ -74,7 +74,7 @@ pub(crate) fn import_function<'tcx>(\n     inst: Instance<'tcx>,\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name;\n-    let sig = get_function_sig(tcx, module.isa().triple(), inst);\n+    let sig = get_function_sig(tcx, module.target_config().default_call_conv, inst);\n     match module.declare_function(name, Linkage::Import, &sig) {\n         Ok(func_id) => func_id,\n         Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n@@ -341,14 +341,13 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     destination: Place<'tcx>,\n     target: Option<BasicBlock>,\n ) {\n-    let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n-    let fn_sig =\n-        fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+    let func = codegen_operand(fx, func);\n+    let fn_sig = func.layout().ty.fn_sig(fx.tcx);\n \n     let ret_place = codegen_place(fx, destination);\n \n     // Handle special calls like intrinsics and empty drop glue.\n-    let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n+    let instance = if let ty::FnDef(def_id, substs) = *func.layout().ty.kind() {\n         let instance =\n             ty::Instance::expect_resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n                 .polymorphize(fx.tcx);\n@@ -390,17 +389,17 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         None\n     };\n \n-    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = &args[fn_sig.inputs().skip_binder().len()..];\n     let extra_args = fx\n         .tcx\n         .mk_type_list(extra_args.iter().map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx))));\n     let fn_abi = if let Some(instance) = instance {\n         RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(instance, extra_args)\n     } else {\n-        RevealAllLayoutCx(fx.tcx).fn_abi_of_fn_ptr(fn_ty.fn_sig(fx.tcx), extra_args)\n+        RevealAllLayoutCx(fx.tcx).fn_abi_of_fn_ptr(fn_sig, extra_args)\n     };\n \n-    let is_cold = if fn_sig.abi == Abi::RustCold {\n+    let is_cold = if fn_sig.abi() == Abi::RustCold {\n         true\n     } else {\n         instance\n@@ -417,7 +416,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     }\n \n     // Unpack arguments tuple for closures\n-    let mut args = if fn_sig.abi == Abi::RustCall {\n+    let mut args = if fn_sig.abi() == Abi::RustCall {\n         assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n         let self_arg = codegen_call_argument_operand(fx, &args[0]);\n         let pack_arg = codegen_call_argument_operand(fx, &args[1]);\n@@ -485,7 +484,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 fx.add_comment(nop_inst, \"indirect call\");\n             }\n \n-            let func = codegen_operand(fx, func).load_scalar(fx);\n+            let func = func.load_scalar(fx);\n             let sig = clif_sig_from_fn_abi(fx.tcx, fx.target_config.default_call_conv, &fn_abi);\n             let sig = fx.bcx.import_signature(sig);\n \n@@ -516,11 +515,11 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         };\n \n         // FIXME find a cleaner way to support varargs\n-        if fn_sig.c_variadic {\n-            if !matches!(fn_sig.abi, Abi::C { .. }) {\n+        if fn_sig.c_variadic() {\n+            if !matches!(fn_sig.abi(), Abi::C { .. }) {\n                 fx.tcx.sess.span_fatal(\n                     source_info.span,\n-                    &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n+                    &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi()),\n                 );\n             }\n             let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();"}, {"sha": "8508227179ac611fb77c350c541e5835e0313936", "filename": "src/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -66,7 +66,7 @@ fn codegen_inner(\n         };\n \n         let sig = Signature {\n-            call_conv: CallConv::triple_default(module.isa().triple()),\n+            call_conv: module.target_config().default_call_conv,\n             params: arg_tys.iter().cloned().map(AbiParam::new).collect(),\n             returns: output.into_iter().map(AbiParam::new).collect(),\n         };\n@@ -104,7 +104,7 @@ fn codegen_inner(\n     }\n \n     let sig = Signature {\n-        call_conv: CallConv::triple_default(module.isa().triple()),\n+        call_conv: module.target_config().default_call_conv,\n         params: vec![AbiParam::new(usize_ty), AbiParam::new(usize_ty)],\n         returns: vec![],\n     };"}, {"sha": "89d955e8bf2e1d84c1a40045d0b063140d325525", "filename": "src/base.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -59,7 +59,7 @@ pub(crate) fn codegen_fn<'tcx>(\n \n     // Declare function\n     let symbol_name = tcx.symbol_name(instance).name.to_string();\n-    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n+    let sig = get_function_sig(tcx, module.target_config().default_call_conv, instance);\n     let func_id = module.declare_function(&symbol_name, Linkage::Local, &sig).unwrap();\n \n     // Make the FunctionBuilder\n@@ -390,11 +390,9 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                         _ => unreachable!(\"{:?}\", targets),\n                     };\n \n-                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     let (discr, is_inverted) =\n                         crate::optimize::peephole::maybe_unwrap_bool_not(&mut fx.bcx, discr);\n                     let test_zero = if is_inverted { !test_zero } else { test_zero };\n-                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     if let Some(taken) = crate::optimize::peephole::maybe_known_branch_taken(\n                         &fx.bcx, discr, test_zero,\n                     ) {\n@@ -571,20 +569,14 @@ fn codegen_stmt<'tcx>(\n                         UnOp::Not => match layout.ty.kind() {\n                             ty::Bool => {\n                                 let res = fx.bcx.ins().icmp_imm(IntCC::Equal, val, 0);\n-                                CValue::by_val(fx.bcx.ins().bint(types::I8, res), layout)\n+                                CValue::by_val(res, layout)\n                             }\n                             ty::Uint(_) | ty::Int(_) => {\n                                 CValue::by_val(fx.bcx.ins().bnot(val), layout)\n                             }\n                             _ => unreachable!(\"un op Not for {:?}\", layout.ty),\n                         },\n                         UnOp::Neg => match layout.ty.kind() {\n-                            ty::Int(IntTy::I128) => {\n-                                // FIXME remove this case once ineg.i128 works\n-                                let zero =\n-                                    CValue::const_val(fx, layout, ty::ScalarInt::null(layout.size));\n-                                crate::num::codegen_int_binop(fx, BinOp::Sub, zero, operand)\n-                            }\n                             ty::Int(_) => CValue::by_val(fx.bcx.ins().ineg(val), layout),\n                             ty::Float(_) => CValue::by_val(fx.bcx.ins().fneg(val), layout),\n                             _ => unreachable!(\"un op Neg for {:?}\", layout.ty),"}, {"sha": "5091c5a9fedacbb7f4dda7b4d5ab7f086f17d1d7", "filename": "src/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -149,7 +149,7 @@ pub(crate) fn clif_int_or_float_cast(\n         }\n \n         let is_not_nan = fx.bcx.ins().fcmp(FloatCC::Equal, from, from);\n-        let zero = fx.bcx.ins().iconst(to_ty, 0);\n+        let zero = type_zero_value(&mut fx.bcx, to_ty);\n         fx.bcx.ins().select(is_not_nan, val, zero)\n     } else if from_ty.is_float() && to_ty.is_float() {\n         // float -> float"}, {"sha": "2dcd42fbd8f431833ac46b414c539e40c828f0e8", "filename": "src/common.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -162,11 +162,20 @@ pub(crate) fn codegen_icmp_imm(\n             }\n         }\n     } else {\n-        let rhs = i64::try_from(rhs).expect(\"codegen_icmp_imm rhs out of range for <128bit int\");\n+        let rhs = rhs as i64; // Truncates on purpose in case rhs is actually an unsigned value\n         fx.bcx.ins().icmp_imm(intcc, lhs, rhs)\n     }\n }\n \n+pub(crate) fn type_zero_value(bcx: &mut FunctionBuilder<'_>, ty: Type) -> Value {\n+    if ty == types::I128 {\n+        let zero = bcx.ins().iconst(types::I64, 0);\n+        bcx.ins().iconcat(zero, zero)\n+    } else {\n+        bcx.ins().iconst(ty, 0)\n+    }\n+}\n+\n pub(crate) fn type_min_max_value(\n     bcx: &mut FunctionBuilder<'_>,\n     ty: Type,"}, {"sha": "dee6fb5b5130d1f27abaf1fda1581605a82973b5", "filename": "src/constant.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -28,9 +28,7 @@ impl ConstantCx {\n     }\n \n     pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut dyn Module) {\n-        //println!(\"todo {:?}\", self.todo);\n         define_all_allocs(tcx, module, &mut self);\n-        //println!(\"done {:?}\", self.done);\n         self.done.clear();\n     }\n }\n@@ -268,16 +266,7 @@ fn data_id_for_static(\n     def_id: DefId,\n     definition: bool,\n ) -> DataId {\n-    let rlinkage = tcx.codegen_fn_attrs(def_id).linkage;\n-    let linkage = if definition {\n-        crate::linkage::get_static_linkage(tcx, def_id)\n-    } else if rlinkage == Some(rustc_middle::mir::mono::Linkage::ExternalWeak)\n-        || rlinkage == Some(rustc_middle::mir::mono::Linkage::WeakAny)\n-    {\n-        Linkage::Preemptible\n-    } else {\n-        Linkage::Import\n-    };\n+    let attrs = tcx.codegen_fn_attrs(def_id);\n \n     let instance = Instance::mono(tcx, def_id).polymorphize(tcx);\n     let symbol_name = tcx.symbol_name(instance).name;\n@@ -289,22 +278,30 @@ fn data_id_for_static(\n     };\n     let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n \n-    let attrs = tcx.codegen_fn_attrs(def_id);\n+    if let Some(import_linkage) = attrs.import_linkage {\n+        assert!(!definition);\n \n-    let data_id = match module.declare_data(\n-        &*symbol_name,\n-        linkage,\n-        is_mutable,\n-        attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n-    ) {\n-        Ok(data_id) => data_id,\n-        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n-            \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n-        )),\n-        Err(err) => Err::<_, _>(err).unwrap(),\n-    };\n+        let linkage = if import_linkage == rustc_middle::mir::mono::Linkage::ExternalWeak\n+            || import_linkage == rustc_middle::mir::mono::Linkage::WeakAny\n+        {\n+            Linkage::Preemptible\n+        } else {\n+            Linkage::Import\n+        };\n+\n+        let data_id = match module.declare_data(\n+            &*symbol_name,\n+            linkage,\n+            is_mutable,\n+            attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n+        ) {\n+            Ok(data_id) => data_id,\n+            Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+                \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n+            )),\n+            Err(err) => Err::<_, _>(err).unwrap(),\n+        };\n \n-    if rlinkage.is_some() {\n         // Comment copied from https://github.com/rust-lang/rust/blob/45060c2a66dfd667f88bd8b94261b28a58d85bd5/src/librustc_codegen_llvm/consts.rs#L141\n         // Declare an internal global `extern_with_linkage_foo` which\n         // is initialized with the address of `foo`.  If `foo` is\n@@ -326,10 +323,34 @@ fn data_id_for_static(\n             Err(ModuleError::DuplicateDefinition(_)) => {}\n             res => res.unwrap(),\n         }\n-        ref_data_id\n-    } else {\n-        data_id\n+\n+        return ref_data_id;\n     }\n+\n+    let linkage = if definition {\n+        crate::linkage::get_static_linkage(tcx, def_id)\n+    } else if attrs.linkage == Some(rustc_middle::mir::mono::Linkage::ExternalWeak)\n+        || attrs.linkage == Some(rustc_middle::mir::mono::Linkage::WeakAny)\n+    {\n+        Linkage::Preemptible\n+    } else {\n+        Linkage::Import\n+    };\n+\n+    let data_id = match module.declare_data(\n+        &*symbol_name,\n+        linkage,\n+        is_mutable,\n+        attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n+    ) {\n+        Ok(data_id) => data_id,\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n+        )),\n+        Err(err) => Err::<_, _>(err).unwrap(),\n+    };\n+\n+    data_id\n }\n \n fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut ConstantCx) {\n@@ -348,8 +369,6 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 (data_id, alloc, None)\n             }\n             TodoItem::Static(def_id) => {\n-                //println!(\"static {:?}\", def_id);\n-\n                 let section_name = tcx.codegen_fn_attrs(def_id).link_section;\n \n                 let alloc = tcx.eval_static_initializer(def_id).unwrap();\n@@ -359,7 +378,6 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             }\n         };\n \n-        //(\"data_id {}\", data_id);\n         if cx.done.contains(&data_id) {\n             continue;\n         }"}, {"sha": "493359c743f119d6bcee87920e595c943a009642", "filename": "src/debuginfo/unwind.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Funwind.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -39,7 +39,9 @@ impl UnwindContext {\n     }\n \n     pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n-        let unwind_info = if let Some(unwind_info) = context.create_unwind_info(isa).unwrap() {\n+        let unwind_info = if let Some(unwind_info) =\n+            context.compiled_code().unwrap().create_unwind_info(isa).unwrap()\n+        {\n             unwind_info\n         } else {\n             return;"}, {"sha": "3cbf313adf0df5a69887cdb1f0516245f2b23232", "filename": "src/discriminant.rs", "status": "modified", "additions": 161, "deletions": 46, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,6 +1,7 @@\n //! Handling of enum discriminants\n //!\n-//! Adapted from <https://github.com/rust-lang/rust/blob/d760df5aea483aae041c9a241e7acacf48f75035/src/librustc_codegen_ssa/mir/place.rs>\n+//! Adapted from <https://github.com/rust-lang/rust/blob/31c0645b9d2539f47eecb096142474b29dc542f7/compiler/rustc_codegen_ssa/src/mir/place.rs>\n+//! (<https://github.com/rust-lang/rust/pull/104535>)\n \n use rustc_target::abi::{Int, TagEncoding, Variants};\n \n@@ -47,13 +48,19 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n         } => {\n             if variant_index != untagged_variant {\n                 let niche = place.place_field(fx, mir::Field::new(tag_field));\n+                let niche_type = fx.clif_type(niche.layout().ty).unwrap();\n                 let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n-                let niche_value = ty::ScalarInt::try_from_uint(\n-                    u128::from(niche_value).wrapping_add(niche_start),\n-                    niche.layout().size,\n-                )\n-                .unwrap();\n-                let niche_llval = CValue::const_val(fx, niche.layout(), niche_value);\n+                let niche_value = (niche_value as u128).wrapping_add(niche_start);\n+                let niche_value = match niche_type {\n+                    types::I128 => {\n+                        let lsb = fx.bcx.ins().iconst(types::I64, niche_value as u64 as i64);\n+                        let msb =\n+                            fx.bcx.ins().iconst(types::I64, (niche_value >> 64) as u64 as i64);\n+                        fx.bcx.ins().iconcat(lsb, msb)\n+                    }\n+                    ty => fx.bcx.ins().iconst(ty, niche_value as i64),\n+                };\n+                let niche_llval = CValue::by_val(niche_value, niche.layout());\n                 niche.write_cvalue(fx, niche_llval);\n             }\n         }\n@@ -96,6 +103,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n         }\n     };\n \n+    let cast_to_size = dest_layout.layout.size();\n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n \n     // Read the tag/niche-encoded discriminant from memory.\n@@ -114,21 +122,128 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-            // Rebase from niche values to discriminants, and check\n-            // whether the result is in range for the niche variants.\n-\n-            // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n-            // that is, if `n = niche_variants.end() - niche_variants.start()`,\n-            // we remap `niche_start..=niche_start + n` (which may wrap around)\n-            // to (non-wrap-around) `0..=n`, to be able to check whether the\n-            // discriminant corresponds to a niche variant with one comparison.\n-            // We also can't go directly to the (variant index) discriminant\n-            // and check that it is in the range `niche_variants`, because\n-            // that might not fit in the same type, on top of needing an extra\n-            // comparison (see also the comment on `let niche_discr`).\n-            let relative_discr = if niche_start == 0 {\n-                tag\n+            let tag_size = tag_scalar.size(fx);\n+            let max_unsigned = tag_size.unsigned_int_max();\n+            let max_signed = tag_size.signed_int_max() as u128;\n+            let min_signed = max_signed + 1;\n+            let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n+            let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n+            let range = tag_scalar.valid_range(fx);\n+\n+            let sle = |lhs: u128, rhs: u128| -> bool {\n+                // Signed and unsigned comparisons give the same results,\n+                // except that in signed comparisons an integer with the\n+                // sign bit set is less than one with the sign bit clear.\n+                // Toggle the sign bit to do a signed comparison.\n+                (lhs ^ min_signed) <= (rhs ^ min_signed)\n+            };\n+\n+            // We have a subrange `niche_start..=niche_end` inside `range`.\n+            // If the value of the tag is inside this subrange, it's a\n+            // \"niche value\", an increment of the discriminant. Otherwise it\n+            // indicates the untagged variant.\n+            // A general algorithm to extract the discriminant from the tag\n+            // is:\n+            // relative_tag = tag - niche_start\n+            // is_niche = relative_tag <= (ule) relative_max\n+            // discr = if is_niche {\n+            //     cast(relative_tag) + niche_variants.start()\n+            // } else {\n+            //     untagged_variant\n+            // }\n+            // However, we will likely be able to emit simpler code.\n+\n+            // Find the least and greatest values in `range`, considered\n+            // both as signed and unsigned.\n+            let (low_unsigned, high_unsigned) =\n+                if range.start <= range.end { (range.start, range.end) } else { (0, max_unsigned) };\n+            let (low_signed, high_signed) = if sle(range.start, range.end) {\n+                (range.start, range.end)\n             } else {\n+                (min_signed, max_signed)\n+            };\n+\n+            let niches_ule = niche_start <= niche_end;\n+            let niches_sle = sle(niche_start, niche_end);\n+            let cast_smaller = cast_to_size <= tag_size;\n+\n+            // In the algorithm above, we can change\n+            // cast(relative_tag) + niche_variants.start()\n+            // into\n+            // cast(tag + (niche_variants.start() - niche_start))\n+            // if either the casted type is no larger than the original\n+            // type, or if the niche values are contiguous (in either the\n+            // signed or unsigned sense).\n+            let can_incr = cast_smaller || niches_ule || niches_sle;\n+\n+            let data_for_boundary_niche = || -> Option<(IntCC, u128)> {\n+                if !can_incr {\n+                    None\n+                } else if niche_start == low_unsigned {\n+                    Some((IntCC::UnsignedLessThanOrEqual, niche_end))\n+                } else if niche_end == high_unsigned {\n+                    Some((IntCC::UnsignedGreaterThanOrEqual, niche_start))\n+                } else if niche_start == low_signed {\n+                    Some((IntCC::SignedLessThanOrEqual, niche_end))\n+                } else if niche_end == high_signed {\n+                    Some((IntCC::SignedGreaterThanOrEqual, niche_start))\n+                } else {\n+                    None\n+                }\n+            };\n+\n+            let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n+                // Best case scenario: only one tagged variant. This will\n+                // likely become just a comparison and a jump.\n+                // The algorithm is:\n+                // is_niche = tag == niche_start\n+                // discr = if is_niche {\n+                //     niche_start\n+                // } else {\n+                //     untagged_variant\n+                // }\n+                let is_niche = codegen_icmp_imm(fx, IntCC::Equal, tag, niche_start as i128);\n+                let tagged_discr =\n+                    fx.bcx.ins().iconst(cast_to, niche_variants.start().as_u32() as i64);\n+                (is_niche, tagged_discr, 0)\n+            } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n+                // The niche values are either the lowest or the highest in\n+                // `range`. We can avoid the first subtraction in the\n+                // algorithm.\n+                // The algorithm is now this:\n+                // is_niche = tag <= niche_end\n+                // discr = if is_niche {\n+                //     cast(tag + (niche_variants.start() - niche_start))\n+                // } else {\n+                //     untagged_variant\n+                // }\n+                // (the first line may instead be tag >= niche_start,\n+                // and may be a signed or unsigned comparison)\n+                // The arithmetic must be done before the cast, so we can\n+                // have the correct wrapping behavior. See issue #104519 for\n+                // the consequences of getting this wrong.\n+                let is_niche = codegen_icmp_imm(fx, predicate, tag, constant as i128);\n+                let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n+                let incr_tag = if delta == 0 {\n+                    tag\n+                } else {\n+                    let delta = match fx.bcx.func.dfg.value_type(tag) {\n+                        types::I128 => {\n+                            let lsb = fx.bcx.ins().iconst(types::I64, delta as u64 as i64);\n+                            let msb = fx.bcx.ins().iconst(types::I64, (delta >> 64) as u64 as i64);\n+                            fx.bcx.ins().iconcat(lsb, msb)\n+                        }\n+                        ty => fx.bcx.ins().iconst(ty, delta as i64),\n+                    };\n+                    fx.bcx.ins().iadd(tag, delta)\n+                };\n+\n+                let cast_tag = clif_intcast(fx, incr_tag, cast_to, !niches_ule);\n+\n+                (is_niche, cast_tag, 0)\n+            } else {\n+                // The special cases don't apply, so we'll have to go with\n+                // the general algorithm.\n                 let niche_start = match fx.bcx.func.dfg.value_type(tag) {\n                     types::I128 => {\n                         let lsb = fx.bcx.ins().iconst(types::I64, niche_start as u64 as i64);\n@@ -138,40 +253,40 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                     }\n                     ty => fx.bcx.ins().iconst(ty, niche_start as i64),\n                 };\n-                fx.bcx.ins().isub(tag, niche_start)\n-            };\n-            let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-            let is_niche = {\n-                codegen_icmp_imm(\n+                let relative_discr = fx.bcx.ins().isub(tag, niche_start);\n+                let cast_tag = clif_intcast(fx, relative_discr, cast_to, false);\n+                let is_niche = crate::common::codegen_icmp_imm(\n                     fx,\n                     IntCC::UnsignedLessThanOrEqual,\n                     relative_discr,\n                     i128::from(relative_max),\n-                )\n+                );\n+                (is_niche, cast_tag, niche_variants.start().as_u32() as u128)\n             };\n \n-            // NOTE(eddyb) this addition needs to be performed on the final\n-            // type, in case the niche itself can't represent all variant\n-            // indices (e.g. `u8` niche with more than `256` variants,\n-            // but enough uninhabited variants so that the remaining variants\n-            // fit in the niche).\n-            // In other words, `niche_variants.end - niche_variants.start`\n-            // is representable in the niche, but `niche_variants.end`\n-            // might not be, in extreme cases.\n-            let niche_discr = {\n-                let relative_discr = if relative_max == 0 {\n-                    // HACK(eddyb) since we have only one niche, we know which\n-                    // one it is, and we can avoid having a dynamic value here.\n-                    fx.bcx.ins().iconst(cast_to, 0)\n-                } else {\n-                    clif_intcast(fx, relative_discr, cast_to, false)\n+            let tagged_discr = if delta == 0 {\n+                tagged_discr\n+            } else {\n+                let delta = match cast_to {\n+                    types::I128 => {\n+                        let lsb = fx.bcx.ins().iconst(types::I64, delta as u64 as i64);\n+                        let msb = fx.bcx.ins().iconst(types::I64, (delta >> 64) as u64 as i64);\n+                        fx.bcx.ins().iconcat(lsb, msb)\n+                    }\n+                    ty => fx.bcx.ins().iconst(ty, delta as i64),\n                 };\n-                fx.bcx.ins().iadd_imm(relative_discr, i64::from(niche_variants.start().as_u32()))\n+                fx.bcx.ins().iadd(tagged_discr, delta)\n             };\n \n-            let untagged_variant =\n-                fx.bcx.ins().iconst(cast_to, i64::from(untagged_variant.as_u32()));\n-            let discr = fx.bcx.ins().select(is_niche, niche_discr, untagged_variant);\n+            let untagged_variant = if cast_to == types::I128 {\n+                let zero = fx.bcx.ins().iconst(types::I64, 0);\n+                let untagged_variant =\n+                    fx.bcx.ins().iconst(types::I64, i64::from(untagged_variant.as_u32()));\n+                fx.bcx.ins().iconcat(untagged_variant, zero)\n+            } else {\n+                fx.bcx.ins().iconst(cast_to, i64::from(untagged_variant.as_u32()))\n+            };\n+            let discr = fx.bcx.ins().select(is_niche, tagged_discr, untagged_variant);\n             let res = CValue::by_val(discr, dest_layout);\n             dest.write_cvalue(fx, res);\n         }"}, {"sha": "be1b8c9ead3bf2e133d326818df523e19f201fda", "filename": "src/driver/jit.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -159,7 +159,7 @@ pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n \n     tcx.sess.abort_if_errors();\n \n-    jit_module.finalize_definitions();\n+    jit_module.finalize_definitions().unwrap();\n     unsafe { cx.unwind_context.register_jit(&jit_module) };\n \n     println!(\n@@ -245,7 +245,11 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n             let backend_config = lazy_jit_state.backend_config.clone();\n \n             let name = tcx.symbol_name(instance).name;\n-            let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n+            let sig = crate::abi::get_function_sig(\n+                tcx,\n+                jit_module.target_config().default_call_conv,\n+                instance,\n+            );\n             let func_id = jit_module.declare_function(name, Linkage::Export, &sig).unwrap();\n \n             let current_ptr = jit_module.read_got_entry(func_id);\n@@ -278,7 +282,7 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n             });\n \n             assert!(cx.global_asm.is_empty());\n-            jit_module.finalize_definitions();\n+            jit_module.finalize_definitions().unwrap();\n             unsafe { cx.unwind_context.register_jit(&jit_module) };\n             jit_module.get_finalized_function(func_id)\n         })\n@@ -344,7 +348,7 @@ fn codegen_shim<'tcx>(\n     let pointer_type = module.target_config().pointer_type();\n \n     let name = tcx.symbol_name(inst).name;\n-    let sig = crate::abi::get_function_sig(tcx, module.isa().triple(), inst);\n+    let sig = crate::abi::get_function_sig(tcx, module.target_config().default_call_conv, inst);\n     let func_id = module.declare_function(name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));"}, {"sha": "6e925cea277078b68ac5d03de3cc18fae0e91e71", "filename": "src/driver/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -24,7 +24,8 @@ fn predefine_mono_items<'tcx>(\n                 MonoItem::Fn(instance) => {\n                     let name = tcx.symbol_name(instance).name;\n                     let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n-                    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n+                    let sig =\n+                        get_function_sig(tcx, module.target_config().default_call_conv, instance);\n                     let linkage = crate::linkage::get_clif_linkage(\n                         mono_item,\n                         linkage,"}, {"sha": "f722e52284fe8205f269103a620fec33015ef9a4", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 17, "deletions": 159, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -8,135 +8,37 @@ use rustc_middle::ty::subst::SubstsRef;\n pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     intrinsic: &str,\n-    _substs: SubstsRef<'tcx>,\n+    substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n     target: Option<BasicBlock>,\n ) {\n-    match intrinsic {\n-        \"llvm.x86.sse2.pause\" | \"llvm.aarch64.isb\" => {\n-            // Spin loop hint\n-        }\n+    if intrinsic.starts_with(\"llvm.aarch64\") {\n+        return llvm_aarch64::codegen_aarch64_llvm_intrinsic_call(\n+            fx, intrinsic, substs, args, ret, target,\n+        );\n+    }\n+    if intrinsic.starts_with(\"llvm.x86\") {\n+        return llvm_x86::codegen_x86_llvm_intrinsic_call(fx, intrinsic, substs, args, ret, target);\n+    }\n \n-        // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n-        \"llvm.x86.sse2.pmovmskb.128\" | \"llvm.x86.avx2.pmovmskb\" | \"llvm.x86.sse2.movmsk.pd\" => {\n+    match intrinsic {\n+        _ if intrinsic.starts_with(\"llvm.ctlz.v\") => {\n             intrinsic_args!(fx, args => (a); intrinsic);\n \n-            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n-            let lane_ty = fx.clif_type(lane_ty).unwrap();\n-            assert!(lane_count <= 32);\n-\n-            let mut res = fx.bcx.ins().iconst(types::I32, 0);\n-\n-            for lane in (0..lane_count).rev() {\n-                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n-\n-                // cast float to int\n-                let a_lane = match lane_ty {\n-                    types::F32 => fx.bcx.ins().bitcast(types::I32, a_lane),\n-                    types::F64 => fx.bcx.ins().bitcast(types::I64, a_lane),\n-                    _ => a_lane,\n-                };\n-\n-                // extract sign bit of an int\n-                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_ty.bits() - 1));\n-\n-                // shift sign bit into result\n-                let a_lane_sign = clif_intcast(fx, a_lane_sign, types::I32, false);\n-                res = fx.bcx.ins().ishl_imm(res, 1);\n-                res = fx.bcx.ins().bor(res, a_lane_sign);\n-            }\n-\n-            let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n-            ret.write_cvalue(fx, res);\n-        }\n-        \"llvm.x86.sse2.cmp.ps\" | \"llvm.x86.sse2.cmp.pd\" => {\n-            let (x, y, kind) = match args {\n-                [x, y, kind] => (x, y, kind),\n-                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n-            };\n-            let x = codegen_operand(fx, x);\n-            let y = codegen_operand(fx, y);\n-            let kind = crate::constant::mir_operand_get_const_val(fx, kind)\n-                .expect(\"llvm.x86.sse2.cmp.* kind not const\");\n-\n-            let flt_cc = match kind\n-                .try_to_bits(Size::from_bytes(1))\n-                .unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind))\n-            {\n-                0 => FloatCC::Equal,\n-                1 => FloatCC::LessThan,\n-                2 => FloatCC::LessThanOrEqual,\n-                7 => FloatCC::Ordered,\n-                3 => FloatCC::Unordered,\n-                4 => FloatCC::NotEqual,\n-                5 => FloatCC::UnorderedOrGreaterThanOrEqual,\n-                6 => FloatCC::UnorderedOrGreaterThan,\n-                kind => unreachable!(\"kind {:?}\", kind),\n-            };\n-\n-            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, res_lane_ty, x_lane, y_lane| {\n-                let res_lane = match lane_ty.kind() {\n-                    ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n-                    _ => unreachable!(\"{:?}\", lane_ty),\n-                };\n-                bool_to_zero_or_max_uint(fx, res_lane_ty, res_lane)\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().clz(lane)\n             });\n         }\n-        \"llvm.x86.sse2.psrli.d\" => {\n-            let (a, imm8) = match args {\n-                [a, imm8] => (a, imm8),\n-                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n-            };\n-            let a = codegen_operand(fx, a);\n-            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n-                .expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n \n-            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n-                .try_to_bits(Size::from_bytes(4))\n-                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n-            {\n-                imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n-                _ => fx.bcx.ins().iconst(types::I32, 0),\n-            });\n-        }\n-        \"llvm.x86.sse2.pslli.d\" => {\n-            let (a, imm8) = match args {\n-                [a, imm8] => (a, imm8),\n-                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n-            };\n-            let a = codegen_operand(fx, a);\n-            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n-                .expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n+        _ if intrinsic.starts_with(\"llvm.ctpop.v\") => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n \n-            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n-                .try_to_bits(Size::from_bytes(4))\n-                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n-            {\n-                imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n-                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().popcnt(lane)\n             });\n         }\n-        \"llvm.x86.sse2.storeu.dq\" => {\n-            intrinsic_args!(fx, args => (mem_addr, a); intrinsic);\n-            let mem_addr = mem_addr.load_scalar(fx);\n-\n-            // FIXME correctly handle the unalignment\n-            let dest = CPlace::for_ptr(Pointer::new(mem_addr), a.layout());\n-            dest.write_cvalue(fx, a);\n-        }\n-        \"llvm.x86.addcarry.64\" => {\n-            intrinsic_args!(fx, args => (c_in, a, b); intrinsic);\n-            let c_in = c_in.load_scalar(fx);\n-\n-            llvm_add_sub(fx, BinOp::Add, ret, c_in, a, b);\n-        }\n-        \"llvm.x86.subborrow.64\" => {\n-            intrinsic_args!(fx, args => (b_in, a, b); intrinsic);\n-            let b_in = b_in.load_scalar(fx);\n \n-            llvm_add_sub(fx, BinOp::Sub, ret, b_in, a, b);\n-        }\n         _ => {\n             fx.tcx\n                 .sess\n@@ -150,47 +52,3 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     let ret_block = fx.get_block(dest);\n     fx.bcx.ins().jump(ret_block, &[]);\n }\n-\n-// llvm.x86.avx2.vperm2i128\n-// llvm.x86.ssse3.pshuf.b.128\n-// llvm.x86.avx2.pshuf.b\n-// llvm.x86.avx2.psrli.w\n-// llvm.x86.sse2.psrli.w\n-\n-fn llvm_add_sub<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    bin_op: BinOp,\n-    ret: CPlace<'tcx>,\n-    cb_in: Value,\n-    a: CValue<'tcx>,\n-    b: CValue<'tcx>,\n-) {\n-    assert_eq!(\n-        a.layout().ty,\n-        fx.tcx.types.u64,\n-        \"llvm.x86.addcarry.64/llvm.x86.subborrow.64 second operand must be u64\"\n-    );\n-    assert_eq!(\n-        b.layout().ty,\n-        fx.tcx.types.u64,\n-        \"llvm.x86.addcarry.64/llvm.x86.subborrow.64 third operand must be u64\"\n-    );\n-\n-    // c + carry -> c + first intermediate carry or borrow respectively\n-    let int0 = crate::num::codegen_checked_int_binop(fx, bin_op, a, b);\n-    let c = int0.value_field(fx, mir::Field::new(0));\n-    let cb0 = int0.value_field(fx, mir::Field::new(1)).load_scalar(fx);\n-\n-    // c + carry -> c + second intermediate carry or borrow respectively\n-    let cb_in_as_u64 = fx.bcx.ins().uextend(types::I64, cb_in);\n-    let cb_in_as_u64 = CValue::by_val(cb_in_as_u64, fx.layout_of(fx.tcx.types.u64));\n-    let int1 = crate::num::codegen_checked_int_binop(fx, bin_op, c, cb_in_as_u64);\n-    let (c, cb1) = int1.load_scalar_pair(fx);\n-\n-    // carry0 | carry1 -> carry or borrow respectively\n-    let cb_out = fx.bcx.ins().bor(cb0, cb1);\n-\n-    let layout = fx.layout_of(fx.tcx.mk_tup([fx.tcx.types.u8, fx.tcx.types.u64].iter()));\n-    let val = CValue::by_val_pair(cb_out, c, layout);\n-    ret.write_cvalue(fx, val);\n-}"}, {"sha": "b431158d2690f02d5f3077820ec7c1f36070f7bf", "filename": "src/intrinsics/llvm_aarch64.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fllvm_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fllvm_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm_aarch64.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -0,0 +1,222 @@\n+//! Emulate AArch64 LLVM intrinsics\n+\n+use crate::intrinsics::*;\n+use crate::prelude::*;\n+\n+use rustc_middle::ty::subst::SubstsRef;\n+\n+pub(crate) fn codegen_aarch64_llvm_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    intrinsic: &str,\n+    _substs: SubstsRef<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    ret: CPlace<'tcx>,\n+    target: Option<BasicBlock>,\n+) {\n+    // llvm.aarch64.neon.sqshl.v*i*\n+\n+    match intrinsic {\n+        \"llvm.aarch64.isb\" => {\n+            fx.bcx.ins().fence();\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.abs.v\") => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().iabs(lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.cls.v\") => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().cls(lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.rbit.v\") => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| {\n+                fx.bcx.ins().bitrev(lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sqadd.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane_typed(fx, x, y, ret, &|fx, x_lane, y_lane| {\n+                crate::num::codegen_saturating_int_binop(fx, BinOp::Add, x_lane, y_lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sqsub.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane_typed(fx, x, y, ret, &|fx, x_lane, y_lane| {\n+                crate::num::codegen_saturating_int_binop(fx, BinOp::Sub, x_lane, y_lane)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.smax.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane(\n+                fx,\n+                x,\n+                y,\n+                ret,\n+                &|fx, _lane_ty, _res_lane_ty, x_lane, y_lane| {\n+                    let gt = fx.bcx.ins().icmp(IntCC::SignedGreaterThan, x_lane, y_lane);\n+                    fx.bcx.ins().select(gt, x_lane, y_lane)\n+                },\n+            );\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.umax.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane(\n+                fx,\n+                x,\n+                y,\n+                ret,\n+                &|fx, _lane_ty, _res_lane_ty, x_lane, y_lane| {\n+                    let gt = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, x_lane, y_lane);\n+                    fx.bcx.ins().select(gt, x_lane, y_lane)\n+                },\n+            );\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.smaxv.i\") => {\n+            intrinsic_args!(fx, args => (v); intrinsic);\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| {\n+                let gt = fx.bcx.ins().icmp(IntCC::SignedGreaterThan, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.umaxv.i\") => {\n+            intrinsic_args!(fx, args => (v); intrinsic);\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| {\n+                let gt = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.smin.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane(\n+                fx,\n+                x,\n+                y,\n+                ret,\n+                &|fx, _lane_ty, _res_lane_ty, x_lane, y_lane| {\n+                    let gt = fx.bcx.ins().icmp(IntCC::SignedLessThan, x_lane, y_lane);\n+                    fx.bcx.ins().select(gt, x_lane, y_lane)\n+                },\n+            );\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.umin.v\") => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            simd_pair_for_each_lane(\n+                fx,\n+                x,\n+                y,\n+                ret,\n+                &|fx, _lane_ty, _res_lane_ty, x_lane, y_lane| {\n+                    let gt = fx.bcx.ins().icmp(IntCC::UnsignedLessThan, x_lane, y_lane);\n+                    fx.bcx.ins().select(gt, x_lane, y_lane)\n+                },\n+            );\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sminv.i\") => {\n+            intrinsic_args!(fx, args => (v); intrinsic);\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| {\n+                let gt = fx.bcx.ins().icmp(IntCC::SignedLessThan, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.uminv.i\") => {\n+            intrinsic_args!(fx, args => (v); intrinsic);\n+\n+            simd_reduce(fx, v, None, ret, &|fx, _ty, a, b| {\n+                let gt = fx.bcx.ins().icmp(IntCC::UnsignedLessThan, a, b);\n+                fx.bcx.ins().select(gt, a, b)\n+            });\n+        }\n+\n+        /*\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sshl.v\")\n+            || intrinsic.starts_with(\"llvm.aarch64.neon.sqshl.v\")\n+            // FIXME split this one out once saturating is implemented\n+            || intrinsic.starts_with(\"llvm.aarch64.neon.sqshlu.v\") =>\n+        {\n+            intrinsic_args!(fx, args => (a, b); intrinsic);\n+\n+            simd_pair_for_each_lane(fx, a, b, ret, &|fx, _lane_ty, _res_lane_ty, a, b| {\n+                // FIXME saturate?\n+                fx.bcx.ins().ishl(a, b)\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sqshrn.v\") => {\n+            let (a, imm32) = match args {\n+                [a, imm32] => (a, imm32),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm32 = crate::constant::mir_operand_get_const_val(fx, imm32)\n+                .expect(\"llvm.aarch64.neon.sqshrn.v* imm32 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm32\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm32 not scalar: {:?}\", imm32))\n+            {\n+                imm32 if imm32 < 32 => fx.bcx.ins().sshr_imm(lane, i64::from(imm32 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+\n+        _ if intrinsic.starts_with(\"llvm.aarch64.neon.sqshrun.v\") => {\n+            let (a, imm32) = match args {\n+                [a, imm32] => (a, imm32),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm32 = crate::constant::mir_operand_get_const_val(fx, imm32)\n+                .expect(\"llvm.aarch64.neon.sqshrn.v* imm32 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm32\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm32 not scalar: {:?}\", imm32))\n+            {\n+                imm32 if imm32 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm32 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        */\n+        _ => {\n+            fx.tcx.sess.warn(&format!(\n+                \"unsupported AArch64 llvm intrinsic {}; replacing with trap\",\n+                intrinsic\n+            ));\n+            crate::trap::trap_unimplemented(fx, intrinsic);\n+            return;\n+        }\n+    }\n+\n+    let dest = target.expect(\"all llvm intrinsics used by stdlib should return\");\n+    let ret_block = fx.get_block(dest);\n+    fx.bcx.ins().jump(ret_block, &[]);\n+}"}, {"sha": "7bc161fbe55236a1b03ad08db5a80e274f94d7f8", "filename": "src/intrinsics/llvm_x86.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm_x86.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -0,0 +1,197 @@\n+//! Emulate x86 LLVM intrinsics\n+\n+use crate::intrinsics::*;\n+use crate::prelude::*;\n+\n+use rustc_middle::ty::subst::SubstsRef;\n+\n+pub(crate) fn codegen_x86_llvm_intrinsic_call<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    intrinsic: &str,\n+    _substs: SubstsRef<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    ret: CPlace<'tcx>,\n+    target: Option<BasicBlock>,\n+) {\n+    match intrinsic {\n+        \"llvm.x86.sse2.pause\" | \"llvm.aarch64.isb\" => {\n+            // Spin loop hint\n+        }\n+\n+        // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n+        \"llvm.x86.sse2.pmovmskb.128\" | \"llvm.x86.avx2.pmovmskb\" | \"llvm.x86.sse2.movmsk.pd\" => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_ty = fx.clif_type(lane_ty).unwrap();\n+            assert!(lane_count <= 32);\n+\n+            let mut res = fx.bcx.ins().iconst(types::I32, 0);\n+\n+            for lane in (0..lane_count).rev() {\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+\n+                // cast float to int\n+                let a_lane = match lane_ty {\n+                    types::F32 => fx.bcx.ins().bitcast(types::I32, a_lane),\n+                    types::F64 => fx.bcx.ins().bitcast(types::I64, a_lane),\n+                    _ => a_lane,\n+                };\n+\n+                // extract sign bit of an int\n+                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_ty.bits() - 1));\n+\n+                // shift sign bit into result\n+                let a_lane_sign = clif_intcast(fx, a_lane_sign, types::I32, false);\n+                res = fx.bcx.ins().ishl_imm(res, 1);\n+                res = fx.bcx.ins().bor(res, a_lane_sign);\n+            }\n+\n+            let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n+            ret.write_cvalue(fx, res);\n+        }\n+        \"llvm.x86.sse2.cmp.ps\" | \"llvm.x86.sse2.cmp.pd\" => {\n+            let (x, y, kind) = match args {\n+                [x, y, kind] => (x, y, kind),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let x = codegen_operand(fx, x);\n+            let y = codegen_operand(fx, y);\n+            let kind = crate::constant::mir_operand_get_const_val(fx, kind)\n+                .expect(\"llvm.x86.sse2.cmp.* kind not const\");\n+\n+            let flt_cc = match kind\n+                .try_to_bits(Size::from_bytes(1))\n+                .unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind))\n+            {\n+                0 => FloatCC::Equal,\n+                1 => FloatCC::LessThan,\n+                2 => FloatCC::LessThanOrEqual,\n+                7 => FloatCC::Ordered,\n+                3 => FloatCC::Unordered,\n+                4 => FloatCC::NotEqual,\n+                5 => FloatCC::UnorderedOrGreaterThanOrEqual,\n+                6 => FloatCC::UnorderedOrGreaterThan,\n+                kind => unreachable!(\"kind {:?}\", kind),\n+            };\n+\n+            simd_pair_for_each_lane(fx, x, y, ret, &|fx, lane_ty, res_lane_ty, x_lane, y_lane| {\n+                let res_lane = match lane_ty.kind() {\n+                    ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_ty),\n+                };\n+                bool_to_zero_or_max_uint(fx, res_lane_ty, res_lane)\n+            });\n+        }\n+        \"llvm.x86.sse2.psrli.d\" => {\n+            let (a, imm8) = match args {\n+                [a, imm8] => (a, imm8),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n+                .expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n+            {\n+                imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        \"llvm.x86.sse2.pslli.d\" => {\n+            let (a, imm8) = match args {\n+                [a, imm8] => (a, imm8),\n+                _ => bug!(\"wrong number of args for intrinsic {intrinsic}\"),\n+            };\n+            let a = codegen_operand(fx, a);\n+            let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8)\n+                .expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n+\n+            simd_for_each_lane(fx, a, ret, &|fx, _lane_ty, _res_lane_ty, lane| match imm8\n+                .try_to_bits(Size::from_bytes(4))\n+                .unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8))\n+            {\n+                imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n+                _ => fx.bcx.ins().iconst(types::I32, 0),\n+            });\n+        }\n+        \"llvm.x86.sse2.storeu.dq\" => {\n+            intrinsic_args!(fx, args => (mem_addr, a); intrinsic);\n+            let mem_addr = mem_addr.load_scalar(fx);\n+\n+            // FIXME correctly handle the unalignment\n+            let dest = CPlace::for_ptr(Pointer::new(mem_addr), a.layout());\n+            dest.write_cvalue(fx, a);\n+        }\n+        \"llvm.x86.addcarry.64\" => {\n+            intrinsic_args!(fx, args => (c_in, a, b); intrinsic);\n+            let c_in = c_in.load_scalar(fx);\n+\n+            llvm_add_sub(fx, BinOp::Add, ret, c_in, a, b);\n+        }\n+        \"llvm.x86.subborrow.64\" => {\n+            intrinsic_args!(fx, args => (b_in, a, b); intrinsic);\n+            let b_in = b_in.load_scalar(fx);\n+\n+            llvm_add_sub(fx, BinOp::Sub, ret, b_in, a, b);\n+        }\n+        _ => {\n+            fx.tcx.sess.warn(&format!(\n+                \"unsupported x86 llvm intrinsic {}; replacing with trap\",\n+                intrinsic\n+            ));\n+            crate::trap::trap_unimplemented(fx, intrinsic);\n+            return;\n+        }\n+    }\n+\n+    let dest = target.expect(\"all llvm intrinsics used by stdlib should return\");\n+    let ret_block = fx.get_block(dest);\n+    fx.bcx.ins().jump(ret_block, &[]);\n+}\n+\n+// llvm.x86.avx2.vperm2i128\n+// llvm.x86.ssse3.pshuf.b.128\n+// llvm.x86.avx2.pshuf.b\n+// llvm.x86.avx2.psrli.w\n+// llvm.x86.sse2.psrli.w\n+\n+fn llvm_add_sub<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    bin_op: BinOp,\n+    ret: CPlace<'tcx>,\n+    cb_in: Value,\n+    a: CValue<'tcx>,\n+    b: CValue<'tcx>,\n+) {\n+    assert_eq!(\n+        a.layout().ty,\n+        fx.tcx.types.u64,\n+        \"llvm.x86.addcarry.64/llvm.x86.subborrow.64 second operand must be u64\"\n+    );\n+    assert_eq!(\n+        b.layout().ty,\n+        fx.tcx.types.u64,\n+        \"llvm.x86.addcarry.64/llvm.x86.subborrow.64 third operand must be u64\"\n+    );\n+\n+    // c + carry -> c + first intermediate carry or borrow respectively\n+    let int0 = crate::num::codegen_checked_int_binop(fx, bin_op, a, b);\n+    let c = int0.value_field(fx, mir::Field::new(0));\n+    let cb0 = int0.value_field(fx, mir::Field::new(1)).load_scalar(fx);\n+\n+    // c + carry -> c + second intermediate carry or borrow respectively\n+    let cb_in_as_u64 = fx.bcx.ins().uextend(types::I64, cb_in);\n+    let cb_in_as_u64 = CValue::by_val(cb_in_as_u64, fx.layout_of(fx.tcx.types.u64));\n+    let int1 = crate::num::codegen_checked_int_binop(fx, bin_op, c, cb_in_as_u64);\n+    let (c, cb1) = int1.load_scalar_pair(fx);\n+\n+    // carry0 | carry1 -> carry or borrow respectively\n+    let cb_out = fx.bcx.ins().bor(cb0, cb1);\n+\n+    let layout = fx.layout_of(fx.tcx.mk_tup([fx.tcx.types.u8, fx.tcx.types.u64].iter()));\n+    let val = CValue::by_val_pair(cb_out, c, layout);\n+    ret.write_cvalue(fx, val);\n+}"}, {"sha": "7a380acf798572a7606130959a7517cfecb2462b", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 12, "deletions": 84, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -14,6 +14,8 @@ macro_rules! intrinsic_args {\n \n mod cpuid;\n mod llvm;\n+mod llvm_aarch64;\n+mod llvm_x86;\n mod simd;\n \n pub(crate) use cpuid::codegen_cpuid_call;\n@@ -195,8 +197,7 @@ fn bool_to_zero_or_max_uint<'tcx>(\n         ty => ty,\n     };\n \n-    let val = fx.bcx.ins().bint(int_ty, val);\n-    let mut res = fx.bcx.ins().ineg(val);\n+    let mut res = fx.bcx.ins().bmask(int_ty, val);\n \n     if ty.is_float() {\n         res = fx.bcx.ins().bitcast(ty, res);\n@@ -632,85 +633,15 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, res);\n         }\n         sym::bswap => {\n-            // FIXME(CraneStation/cranelift#794) add bswap instruction to cranelift\n-            fn swap(bcx: &mut FunctionBuilder<'_>, v: Value) -> Value {\n-                match bcx.func.dfg.value_type(v) {\n-                    types::I8 => v,\n-\n-                    // https://code.woboq.org/gcc/include/bits/byteswap.h.html\n-                    types::I16 => {\n-                        let tmp1 = bcx.ins().ishl_imm(v, 8);\n-                        let n1 = bcx.ins().band_imm(tmp1, 0xFF00);\n-\n-                        let tmp2 = bcx.ins().ushr_imm(v, 8);\n-                        let n2 = bcx.ins().band_imm(tmp2, 0x00FF);\n-\n-                        bcx.ins().bor(n1, n2)\n-                    }\n-                    types::I32 => {\n-                        let tmp1 = bcx.ins().ishl_imm(v, 24);\n-                        let n1 = bcx.ins().band_imm(tmp1, 0xFF00_0000);\n-\n-                        let tmp2 = bcx.ins().ishl_imm(v, 8);\n-                        let n2 = bcx.ins().band_imm(tmp2, 0x00FF_0000);\n-\n-                        let tmp3 = bcx.ins().ushr_imm(v, 8);\n-                        let n3 = bcx.ins().band_imm(tmp3, 0x0000_FF00);\n-\n-                        let tmp4 = bcx.ins().ushr_imm(v, 24);\n-                        let n4 = bcx.ins().band_imm(tmp4, 0x0000_00FF);\n-\n-                        let or_tmp1 = bcx.ins().bor(n1, n2);\n-                        let or_tmp2 = bcx.ins().bor(n3, n4);\n-                        bcx.ins().bor(or_tmp1, or_tmp2)\n-                    }\n-                    types::I64 => {\n-                        let tmp1 = bcx.ins().ishl_imm(v, 56);\n-                        let n1 = bcx.ins().band_imm(tmp1, 0xFF00_0000_0000_0000u64 as i64);\n-\n-                        let tmp2 = bcx.ins().ishl_imm(v, 40);\n-                        let n2 = bcx.ins().band_imm(tmp2, 0x00FF_0000_0000_0000u64 as i64);\n-\n-                        let tmp3 = bcx.ins().ishl_imm(v, 24);\n-                        let n3 = bcx.ins().band_imm(tmp3, 0x0000_FF00_0000_0000u64 as i64);\n-\n-                        let tmp4 = bcx.ins().ishl_imm(v, 8);\n-                        let n4 = bcx.ins().band_imm(tmp4, 0x0000_00FF_0000_0000u64 as i64);\n-\n-                        let tmp5 = bcx.ins().ushr_imm(v, 8);\n-                        let n5 = bcx.ins().band_imm(tmp5, 0x0000_0000_FF00_0000u64 as i64);\n-\n-                        let tmp6 = bcx.ins().ushr_imm(v, 24);\n-                        let n6 = bcx.ins().band_imm(tmp6, 0x0000_0000_00FF_0000u64 as i64);\n-\n-                        let tmp7 = bcx.ins().ushr_imm(v, 40);\n-                        let n7 = bcx.ins().band_imm(tmp7, 0x0000_0000_0000_FF00u64 as i64);\n-\n-                        let tmp8 = bcx.ins().ushr_imm(v, 56);\n-                        let n8 = bcx.ins().band_imm(tmp8, 0x0000_0000_0000_00FFu64 as i64);\n-\n-                        let or_tmp1 = bcx.ins().bor(n1, n2);\n-                        let or_tmp2 = bcx.ins().bor(n3, n4);\n-                        let or_tmp3 = bcx.ins().bor(n5, n6);\n-                        let or_tmp4 = bcx.ins().bor(n7, n8);\n-\n-                        let or_tmp5 = bcx.ins().bor(or_tmp1, or_tmp2);\n-                        let or_tmp6 = bcx.ins().bor(or_tmp3, or_tmp4);\n-                        bcx.ins().bor(or_tmp5, or_tmp6)\n-                    }\n-                    types::I128 => {\n-                        let (lo, hi) = bcx.ins().isplit(v);\n-                        let lo = swap(bcx, lo);\n-                        let hi = swap(bcx, hi);\n-                        bcx.ins().iconcat(hi, lo)\n-                    }\n-                    ty => unreachable!(\"bswap {}\", ty),\n-                }\n-            }\n             intrinsic_args!(fx, args => (arg); intrinsic);\n             let val = arg.load_scalar(fx);\n \n-            let res = CValue::by_val(swap(&mut fx.bcx, val), arg.layout());\n+            let res = if fx.bcx.func.dfg.value_type(val) == types::I8 {\n+                val\n+            } else {\n+                fx.bcx.ins().bswap(val)\n+            };\n+            let res = CValue::by_val(res, arg.layout());\n             ret.write_cvalue(fx, res);\n         }\n         sym::assert_inhabited | sym::assert_zero_valid | sym::assert_uninit_valid => {\n@@ -936,8 +867,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let old = fx.bcx.ins().atomic_cas(MemFlags::trusted(), ptr, test_old, new);\n             let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n \n-            let ret_val =\n-                CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n+            let ret_val = CValue::by_val_pair(old, is_eq, ret.layout());\n             ret.write_cvalue(fx, ret_val)\n         }\n \n@@ -1259,8 +1189,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 flags.set_notrap();\n                 let lhs_val = fx.bcx.ins().load(clty, flags, lhs_ref, 0);\n                 let rhs_val = fx.bcx.ins().load(clty, flags, rhs_ref, 0);\n-                let eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val);\n-                fx.bcx.ins().bint(types::I8, eq)\n+                fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val)\n             } else {\n                 // Just call `memcmp` (like slices do in core) when the\n                 // size is too large or it's not a power-of-two.\n@@ -1270,8 +1199,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 let returns = vec![AbiParam::new(types::I32)];\n                 let args = &[lhs_ref, rhs_ref, bytes_val];\n                 let cmp = fx.lib_call(\"memcmp\", params, returns, args)[0];\n-                let eq = fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0);\n-                fx.bcx.ins().bint(types::I8, eq)\n+                fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0)\n             };\n             ret.write_cvalue(fx, CValue::by_val(is_eq_value, ret.layout()));\n         }"}, {"sha": "14f5e9187399fac76f2a64d0147f2f647a904929", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -112,10 +112,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     _ => unreachable!(),\n                 };\n \n-                let ty = fx.clif_type(res_lane_ty).unwrap();\n-\n-                let res_lane = fx.bcx.ins().bint(ty, res_lane);\n-                fx.bcx.ins().ineg(res_lane)\n+                bool_to_zero_or_max_uint(fx, res_lane_ty, res_lane)\n             });\n         }\n \n@@ -716,7 +713,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n \n             let res_type =\n                 Type::int_with_byte_size(u16::try_from(expected_bytes).unwrap()).unwrap();\n-            let mut res = fx.bcx.ins().iconst(res_type, 0);\n+            let mut res = type_zero_value(&mut fx.bcx, res_type);\n \n             let lanes = match fx.tcx.sess.target.endian {\n                 Endian::Big => Box::new(0..lane_count) as Box<dyn Iterator<Item = u64>>,"}, {"sha": "c10054e7f0d2c971711364aafdfe563558e3fd5d", "filename": "src/main_shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -65,7 +65,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n             returns: vec![AbiParam::new(m.target_config().pointer_type() /*isize*/)],\n             call_conv: crate::conv_to_call_conv(\n                 tcx.sess.target.options.entry_abi,\n-                CallConv::triple_default(m.isa().triple()),\n+                m.target_config().default_call_conv,\n             ),\n         };\n \n@@ -75,7 +75,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n         let main_name = tcx.symbol_name(instance).name;\n-        let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n+        let main_sig = get_function_sig(tcx, m.target_config().default_call_conv, instance);\n         let main_func_id = m.declare_function(main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n@@ -119,7 +119,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 .polymorphize(tcx);\n \n                 let report_name = tcx.symbol_name(report).name;\n-                let report_sig = get_function_sig(tcx, m.isa().triple(), report);\n+                let report_sig = get_function_sig(tcx, m.target_config().default_call_conv, report);\n                 let report_func_id =\n                     m.declare_function(report_name, Linkage::Import, &report_sig).unwrap();\n                 let report_func_ref = m.declare_func_in_func(report_func_id, &mut bcx.func);"}, {"sha": "afacbec644582195440bcb8e3e9c58d6d99b3c74", "filename": "src/num.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -49,7 +49,6 @@ fn codegen_compare_bin_op<'tcx>(\n ) -> CValue<'tcx> {\n     let intcc = crate::num::bin_op_to_intcc(bin_op, signed).unwrap();\n     let val = fx.bcx.ins().icmp(intcc, lhs, rhs);\n-    let val = fx.bcx.ins().bint(types::I8, val);\n     CValue::by_val(val, fx.layout_of(fx.tcx.types.bool))\n }\n \n@@ -290,8 +289,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n         _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n-    let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n-\n     let out_layout = fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n@@ -368,7 +365,6 @@ pub(crate) fn codegen_float_binop<'tcx>(\n                 _ => unreachable!(),\n             };\n             let val = fx.bcx.ins().fcmp(fltcc, lhs, rhs);\n-            let val = fx.bcx.ins().bint(types::I8, val);\n             return CValue::by_val(val, fx.layout_of(fx.tcx.types.bool));\n         }\n         _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n@@ -440,7 +436,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n             _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n         };\n \n-        CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n+        CValue::by_val(res, fx.layout_of(fx.tcx.types.bool))\n     }\n }\n "}, {"sha": "7f45bbd8f28136a43b8271ba5f3e2755d19d522d", "filename": "src/optimize/peephole.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fpeephole.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -3,19 +3,6 @@\n use cranelift_codegen::ir::{condcodes::IntCC, InstructionData, Opcode, Value, ValueDef};\n use cranelift_frontend::FunctionBuilder;\n \n-/// If the given value was produced by a `bint` instruction, return it's input, otherwise return the\n-/// given value.\n-pub(crate) fn maybe_unwrap_bint(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n-    if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n-        match bcx.func.dfg[arg_inst] {\n-            InstructionData::Unary { opcode: Opcode::Bint, arg } => arg,\n-            _ => arg,\n-        }\n-    } else {\n-        arg\n-    }\n-}\n-\n /// If the given value was produced by the lowering of `Rvalue::Not` return the input and true,\n /// otherwise return the given value and false.\n pub(crate) fn maybe_unwrap_bool_not(bcx: &mut FunctionBuilder<'_>, arg: Value) -> (Value, bool) {\n@@ -48,13 +35,6 @@ pub(crate) fn maybe_known_branch_taken(\n     };\n \n     match bcx.func.dfg[arg_inst] {\n-        InstructionData::UnaryBool { opcode: Opcode::Bconst, imm } => {\n-            if test_zero {\n-                Some(!imm)\n-            } else {\n-                Some(imm)\n-            }\n-        }\n         InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => {\n             if test_zero {\n                 Some(imm.bits() == 0)"}, {"sha": "fe8af21ac6de567cff94a34ec13e625f8876fe4a", "filename": "src/value_and_place.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -392,7 +392,7 @@ impl<'tcx> CPlace<'tcx> {\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        let var = Variable::with_u32(fx.next_ssa_var);\n+        let var = Variable::from_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n         fx.bcx.declare_var(var, fx.clif_type(layout.ty).unwrap());\n         CPlace { inner: CPlaceInner::Var(local, var), layout }\n@@ -403,9 +403,9 @@ impl<'tcx> CPlace<'tcx> {\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        let var1 = Variable::with_u32(fx.next_ssa_var);\n+        let var1 = Variable::from_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n-        let var2 = Variable::with_u32(fx.next_ssa_var);\n+        let var2 = Variable::from_u32(fx.next_ssa_var);\n         fx.next_ssa_var += 1;\n \n         let (ty1, ty2) = fx.clif_pair_type(layout.ty).unwrap();\n@@ -515,9 +515,7 @@ impl<'tcx> CPlace<'tcx> {\n                 | (types::F32, types::I32)\n                 | (types::I64, types::F64)\n                 | (types::F64, types::I64) => fx.bcx.ins().bitcast(dst_ty, data),\n-                _ if src_ty.is_vector() && dst_ty.is_vector() => {\n-                    fx.bcx.ins().raw_bitcast(dst_ty, data)\n-                }\n+                _ if src_ty.is_vector() && dst_ty.is_vector() => fx.bcx.ins().bitcast(dst_ty, data),\n                 _ if src_ty.is_vector() || dst_ty.is_vector() => {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n                     let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n@@ -590,7 +588,10 @@ impl<'tcx> CPlace<'tcx> {\n                 return;\n             }\n             CPlaceInner::VarPair(_local, var1, var2) => {\n-                let (data1, data2) = CValue(from.0, dst_layout).load_scalar_pair(fx);\n+                let (ptr, meta) = from.force_stack(fx);\n+                assert!(meta.is_none());\n+                let (data1, data2) =\n+                    CValue(CValueInner::ByRef(ptr, None), dst_layout).load_scalar_pair(fx);\n                 let (dst_ty1, dst_ty2) = fx.clif_pair_type(self.layout().ty).unwrap();\n                 transmute_value(fx, var1, data1, dst_ty1);\n                 transmute_value(fx, var2, data2, dst_ty2);"}, {"sha": "13e7784539d5a9b9cdb3c81dd7f548afcb0c418b", "filename": "test.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -1,2 +1,2 @@\n #!/usr/bin/env bash\n-exec ./y.rs test\n+exec ./y.rs test \"$@\""}, {"sha": "02e1e21ade1de98f4d72256adbe70755a3997a55", "filename": "y.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98a276b5895697a862b48bcaf07b423de0b0deef/y.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a276b5895697a862b48bcaf07b423de0b0deef/y.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/y.rs?ref=98a276b5895697a862b48bcaf07b423de0b0deef", "patch": "@@ -3,7 +3,7 @@\n # This block is ignored by rustc\n set -e\n echo \"[BUILD] y.rs\" 1>&2\n-rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1\n+rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1 --edition 2021\n exec ${0/.rs/.bin} $@\n */\n "}]}