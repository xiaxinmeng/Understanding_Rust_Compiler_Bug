{"sha": "fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNzdmNWQ3NjQ5ZWQ2YzY3MzhhOTE2NzBhYzFmZjIyZTdiOWE4ODc=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-06T08:25:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-06T08:25:32Z"}, "message": "Rollup merge of #48573 - Amanieu:bitreverse2, r=sfackler\n\nAdd functions for reversing the bit pattern in an integer\n\nI'm reviving PR #32798 now that the LLVM issues have been resolved.\n\n> This adds the bitreverse intrinsic and adds a reverse_bits function to all integer types.", "tree": {"sha": "7231a2f5eb6c766c4b25eb7b0e16ab8dd39ca302", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7231a2f5eb6c766c4b25eb7b0e16ab8dd39ca302"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJanlB8CRBK7hj4Ov3rIwAAdHIIAIlvQsnk1+tUI0+KAtTkfw6i\nbnYhXydL+lrOYUsegUux5hXS+ZlJ6TjtLlWIjyHeyiIiFtGYrzfs5Wq41nHIJbnH\nH5k9IAn9SUHj3dIA2e7PAJHwC4aiClTjklSjEizEeybcNciULfbN8KPysGFKEiji\nU7mHG1LUDF10J9TWs5ATTWHKEvHfyfx75+V/IKY5Xj4atTugvzT39t8RuASXp1uR\nbbg33nV2eVx7yzAeYyMWWMJV0qm4gI6AJUPsxMq0IZ3cSoEGspg6GDyT4UgsNI5q\n5IN77VHT4/sZopIz6RYR2DWJ2UhomiNyWWxP51qQM7cQDo18hvCE8LHkL6m0dPk=\n=JekC\n-----END PGP SIGNATURE-----\n", "payload": "tree 7231a2f5eb6c766c4b25eb7b0e16ab8dd39ca302\nparent e3451f8cd7fc2b6f7689be5fe69e4c36da987a6e\nparent 88aec91017bf7def8401f47f3f90acd25882a2da\nauthor kennytm <kennytm@gmail.com> 1520324732 +0800\ncommitter GitHub <noreply@github.com> 1520324732 +0800\n\nRollup merge of #48573 - Amanieu:bitreverse2, r=sfackler\n\nAdd functions for reversing the bit pattern in an integer\n\nI'm reviving PR #32798 now that the LLVM issues have been resolved.\n\n> This adds the bitreverse intrinsic and adds a reverse_bits function to all integer types.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "html_url": "https://github.com/rust-lang/rust/commit/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3451f8cd7fc2b6f7689be5fe69e4c36da987a6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3451f8cd7fc2b6f7689be5fe69e4c36da987a6e", "html_url": "https://github.com/rust-lang/rust/commit/e3451f8cd7fc2b6f7689be5fe69e4c36da987a6e"}, {"sha": "88aec91017bf7def8401f47f3f90acd25882a2da", "url": "https://api.github.com/repos/rust-lang/rust/commits/88aec91017bf7def8401f47f3f90acd25882a2da", "html_url": "https://github.com/rust-lang/rust/commit/88aec91017bf7def8401f47f3f90acd25882a2da"}], "stats": {"total": 124, "additions": 120, "deletions": 4}, "files": [{"sha": "830ebad065427fa3954552f99f90595702e96ff2", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "patch": "@@ -1292,6 +1292,10 @@ extern \"rust-intrinsic\" {\n     /// Reverses the bytes in an integer type `T`.\n     pub fn bswap<T>(x: T) -> T;\n \n+    /// Reverses the bits in an integer type `T`.\n+    #[cfg(not(stage0))]\n+    pub fn bitreverse<T>(x: T) -> T;\n+\n     /// Performs checked integer addition.\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `overflowing_add` method. For example,"}, {"sha": "a46ac2b5f0fee1d9af082f160b6c84218592e763", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "patch": "@@ -321,6 +321,33 @@ $EndFeature, \"\n             (self as $UnsignedT).swap_bytes() as Self\n         }\n \n+        /// Reverses the bit pattern of the integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `i16` is used here.\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(reverse_bits)]\n+        ///\n+        /// let n: i16 = 0b0000000_01010101;\n+        /// assert_eq!(n, 85);\n+        ///\n+        /// let m = n.reverse_bits();\n+        ///\n+        /// assert_eq!(m as u16, 0b10101010_00000000);\n+        /// assert_eq!(m, -22016);\n+        /// ```\n+        #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        pub fn reverse_bits(self) -> Self {\n+            (self as $UnsignedT).reverse_bits() as Self\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts an integer from big endian to the target's endianness.\n \n@@ -1773,6 +1800,33 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n             unsafe { intrinsics::bswap(self as $ActualT) as Self }\n         }\n \n+        /// Reverses the bit pattern of the integer.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// Please note that this example is shared between integer types.\n+        /// Which explains why `u16` is used here.\n+        ///\n+        /// ```\n+        /// #![feature(reverse_bits)]\n+        ///\n+        /// let n: u16 = 0b0000000_01010101;\n+        /// assert_eq!(n, 85);\n+        ///\n+        /// let m = n.reverse_bits();\n+        ///\n+        /// assert_eq!(m, 0b10101010_00000000);\n+        /// assert_eq!(m, 43520);\n+        /// ```\n+        #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        pub fn reverse_bits(self) -> Self {\n+            unsafe { intrinsics::bitreverse(self as $ActualT) as Self }\n+        }\n+\n         doc_comment! {\n             concat!(\"Converts an integer from big endian to the target's endianness.\n "}, {"sha": "a9c5683e0ef7b376847563ccc25b19c2c0309856", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "patch": "@@ -46,6 +46,7 @@\n #![feature(try_trait)]\n #![feature(exact_chunks)]\n #![feature(atomic_nand)]\n+#![feature(reverse_bits)]\n \n extern crate core;\n extern crate test;"}, {"sha": "ca6906f731047c62e0091c3a3212756cff2b5c23", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "patch": "@@ -97,6 +97,17 @@ mod tests {\n         assert_eq!(_1.swap_bytes(), _1);\n     }\n \n+    #[test]\n+    fn test_reverse_bits() {\n+        assert_eq!(A.reverse_bits().reverse_bits(), A);\n+        assert_eq!(B.reverse_bits().reverse_bits(), B);\n+        assert_eq!(C.reverse_bits().reverse_bits(), C);\n+\n+        // Swapping these should make no difference\n+        assert_eq!(_0.reverse_bits(), _0);\n+        assert_eq!(_1.reverse_bits(), _1);\n+    }\n+\n     #[test]\n     fn test_le() {\n         assert_eq!($T::from_le(A.to_le()), A);"}, {"sha": "b93e8c2ad21ca60e9bee59b4ff60b7cbf69189ee", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "patch": "@@ -597,6 +597,12 @@ fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     ifn!(\"llvm.bswap.i64\", fn(t_i64) -> t_i64);\n     ifn!(\"llvm.bswap.i128\", fn(t_i128) -> t_i128);\n \n+    ifn!(\"llvm.bitreverse.i8\", fn(t_i8) -> t_i8);\n+    ifn!(\"llvm.bitreverse.i16\", fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.bitreverse.i32\", fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.bitreverse.i64\", fn(t_i64) -> t_i64);\n+    ifn!(\"llvm.bitreverse.i128\", fn(t_i128) -> t_i128);\n+\n     ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});"}, {"sha": "3f87ce7e04792f4c417adc7ba63a0ef705576f37", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "patch": "@@ -287,8 +287,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             ], None)\n         },\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n-        \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" |\n-        \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n+        \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n+        \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n         \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n             let ty = arg_tys[0];\n             match int_type_width_signed(ty, cx) {\n@@ -315,6 +315,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                                         &[args[0].immediate()], None)\n                             }\n                         }\n+                        \"bitreverse\" => {\n+                            bx.call(cx.get_intrinsic(&format!(\"llvm.bitreverse.i{}\", width)),\n+                                &[args[0].immediate()], None)\n+                        }\n                         \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n                             let intrinsic = format!(\"llvm.{}{}.with.overflow.i{}\",\n                                                     if signed { 's' } else { 'u' },"}, {"sha": "2e00040d99a73f58782bc810277aa9346486715b", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "patch": "@@ -275,7 +275,8 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"volatile_store\" =>\n                 (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil()),\n \n-            \"ctpop\" | \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"bswap\" =>\n+            \"ctpop\" | \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" |\n+            \"bswap\" | \"bitreverse\" =>\n                 (1, vec![param(0)], param(0)),\n \n             \"add_with_overflow\" | \"sub_with_overflow\"  | \"mul_with_overflow\" =>"}, {"sha": "bfa3a1e128a9a3e97948d0e8a8b3c41bc28483dc", "filename": "src/test/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe77f5d7649ed6c6738a91670ac1ff22e7b9a887/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs?ref=fe77f5d7649ed6c6738a91670ac1ff22e7b9a887", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(intrinsics)]\n+#![feature(intrinsics, i128_type)]\n \n mod rusti {\n     extern \"rust-intrinsic\" {\n@@ -18,6 +18,7 @@ mod rusti {\n         pub fn cttz<T>(x: T) -> T;\n         pub fn cttz_nonzero<T>(x: T) -> T;\n         pub fn bswap<T>(x: T) -> T;\n+        pub fn bitreverse<T>(x: T) -> T;\n     }\n }\n \n@@ -29,106 +30,127 @@ pub fn main() {\n         assert_eq!(ctpop(0u16), 0); assert_eq!(ctpop(0i16), 0);\n         assert_eq!(ctpop(0u32), 0); assert_eq!(ctpop(0i32), 0);\n         assert_eq!(ctpop(0u64), 0); assert_eq!(ctpop(0i64), 0);\n+        assert_eq!(ctpop(0u128), 0); assert_eq!(ctpop(0i128), 0);\n \n         assert_eq!(ctpop(1u8), 1); assert_eq!(ctpop(1i8), 1);\n         assert_eq!(ctpop(1u16), 1); assert_eq!(ctpop(1i16), 1);\n         assert_eq!(ctpop(1u32), 1); assert_eq!(ctpop(1i32), 1);\n         assert_eq!(ctpop(1u64), 1); assert_eq!(ctpop(1i64), 1);\n+        assert_eq!(ctpop(1u128), 1); assert_eq!(ctpop(1i128), 1);\n \n         assert_eq!(ctpop(10u8), 2); assert_eq!(ctpop(10i8), 2);\n         assert_eq!(ctpop(10u16), 2); assert_eq!(ctpop(10i16), 2);\n         assert_eq!(ctpop(10u32), 2); assert_eq!(ctpop(10i32), 2);\n         assert_eq!(ctpop(10u64), 2); assert_eq!(ctpop(10i64), 2);\n+        assert_eq!(ctpop(10u128), 2); assert_eq!(ctpop(10i128), 2);\n \n         assert_eq!(ctpop(100u8), 3); assert_eq!(ctpop(100i8), 3);\n         assert_eq!(ctpop(100u16), 3); assert_eq!(ctpop(100i16), 3);\n         assert_eq!(ctpop(100u32), 3); assert_eq!(ctpop(100i32), 3);\n         assert_eq!(ctpop(100u64), 3); assert_eq!(ctpop(100i64), 3);\n+        assert_eq!(ctpop(100u128), 3); assert_eq!(ctpop(100i128), 3);\n \n         assert_eq!(ctpop(-1i8 as u8), 8); assert_eq!(ctpop(-1i8), 8);\n         assert_eq!(ctpop(-1i16 as u16), 16); assert_eq!(ctpop(-1i16), 16);\n         assert_eq!(ctpop(-1i32 as u32), 32); assert_eq!(ctpop(-1i32), 32);\n         assert_eq!(ctpop(-1i64 as u64), 64); assert_eq!(ctpop(-1i64), 64);\n+        assert_eq!(ctpop(-1i128 as u128), 128); assert_eq!(ctpop(-1i128), 128);\n \n         assert_eq!(ctlz(0u8), 8); assert_eq!(ctlz(0i8), 8);\n         assert_eq!(ctlz(0u16), 16); assert_eq!(ctlz(0i16), 16);\n         assert_eq!(ctlz(0u32), 32); assert_eq!(ctlz(0i32), 32);\n         assert_eq!(ctlz(0u64), 64); assert_eq!(ctlz(0i64), 64);\n+        assert_eq!(ctlz(0u128), 128); assert_eq!(ctlz(0i128), 128);\n \n         assert_eq!(ctlz(1u8), 7); assert_eq!(ctlz(1i8), 7);\n         assert_eq!(ctlz(1u16), 15); assert_eq!(ctlz(1i16), 15);\n         assert_eq!(ctlz(1u32), 31); assert_eq!(ctlz(1i32), 31);\n         assert_eq!(ctlz(1u64), 63); assert_eq!(ctlz(1i64), 63);\n+        assert_eq!(ctlz(1u128), 127); assert_eq!(ctlz(1i128), 127);\n \n         assert_eq!(ctlz(10u8), 4); assert_eq!(ctlz(10i8), 4);\n         assert_eq!(ctlz(10u16), 12); assert_eq!(ctlz(10i16), 12);\n         assert_eq!(ctlz(10u32), 28); assert_eq!(ctlz(10i32), 28);\n         assert_eq!(ctlz(10u64), 60); assert_eq!(ctlz(10i64), 60);\n+        assert_eq!(ctlz(10u128), 124); assert_eq!(ctlz(10i128), 124);\n \n         assert_eq!(ctlz(100u8), 1); assert_eq!(ctlz(100i8), 1);\n         assert_eq!(ctlz(100u16), 9); assert_eq!(ctlz(100i16), 9);\n         assert_eq!(ctlz(100u32), 25); assert_eq!(ctlz(100i32), 25);\n         assert_eq!(ctlz(100u64), 57); assert_eq!(ctlz(100i64), 57);\n+        assert_eq!(ctlz(100u128), 121); assert_eq!(ctlz(100i128), 121);\n \n         assert_eq!(ctlz_nonzero(1u8), 7); assert_eq!(ctlz_nonzero(1i8), 7);\n         assert_eq!(ctlz_nonzero(1u16), 15); assert_eq!(ctlz_nonzero(1i16), 15);\n         assert_eq!(ctlz_nonzero(1u32), 31); assert_eq!(ctlz_nonzero(1i32), 31);\n         assert_eq!(ctlz_nonzero(1u64), 63); assert_eq!(ctlz_nonzero(1i64), 63);\n+        assert_eq!(ctlz_nonzero(1u128), 127); assert_eq!(ctlz_nonzero(1i128), 127);\n \n         assert_eq!(ctlz_nonzero(10u8), 4); assert_eq!(ctlz_nonzero(10i8), 4);\n         assert_eq!(ctlz_nonzero(10u16), 12); assert_eq!(ctlz_nonzero(10i16), 12);\n         assert_eq!(ctlz_nonzero(10u32), 28); assert_eq!(ctlz_nonzero(10i32), 28);\n         assert_eq!(ctlz_nonzero(10u64), 60); assert_eq!(ctlz_nonzero(10i64), 60);\n+        assert_eq!(ctlz_nonzero(10u128), 124); assert_eq!(ctlz_nonzero(10i128), 124);\n \n         assert_eq!(ctlz_nonzero(100u8), 1); assert_eq!(ctlz_nonzero(100i8), 1);\n         assert_eq!(ctlz_nonzero(100u16), 9); assert_eq!(ctlz_nonzero(100i16), 9);\n         assert_eq!(ctlz_nonzero(100u32), 25); assert_eq!(ctlz_nonzero(100i32), 25);\n         assert_eq!(ctlz_nonzero(100u64), 57); assert_eq!(ctlz_nonzero(100i64), 57);\n+        assert_eq!(ctlz_nonzero(100u128), 121); assert_eq!(ctlz_nonzero(100i128), 121);\n \n         assert_eq!(cttz(-1i8 as u8), 0); assert_eq!(cttz(-1i8), 0);\n         assert_eq!(cttz(-1i16 as u16), 0); assert_eq!(cttz(-1i16), 0);\n         assert_eq!(cttz(-1i32 as u32), 0); assert_eq!(cttz(-1i32), 0);\n         assert_eq!(cttz(-1i64 as u64), 0); assert_eq!(cttz(-1i64), 0);\n+        assert_eq!(cttz(-1i128 as u128), 0); assert_eq!(cttz(-1i128), 0);\n \n         assert_eq!(cttz(0u8), 8); assert_eq!(cttz(0i8), 8);\n         assert_eq!(cttz(0u16), 16); assert_eq!(cttz(0i16), 16);\n         assert_eq!(cttz(0u32), 32); assert_eq!(cttz(0i32), 32);\n         assert_eq!(cttz(0u64), 64); assert_eq!(cttz(0i64), 64);\n+        assert_eq!(cttz(0u128), 128); assert_eq!(cttz(0i128), 128);\n \n         assert_eq!(cttz(1u8), 0); assert_eq!(cttz(1i8), 0);\n         assert_eq!(cttz(1u16), 0); assert_eq!(cttz(1i16), 0);\n         assert_eq!(cttz(1u32), 0); assert_eq!(cttz(1i32), 0);\n         assert_eq!(cttz(1u64), 0); assert_eq!(cttz(1i64), 0);\n+        assert_eq!(cttz(1u128), 0); assert_eq!(cttz(1i128), 0);\n \n         assert_eq!(cttz(10u8), 1); assert_eq!(cttz(10i8), 1);\n         assert_eq!(cttz(10u16), 1); assert_eq!(cttz(10i16), 1);\n         assert_eq!(cttz(10u32), 1); assert_eq!(cttz(10i32), 1);\n         assert_eq!(cttz(10u64), 1); assert_eq!(cttz(10i64), 1);\n+        assert_eq!(cttz(10u128), 1); assert_eq!(cttz(10i128), 1);\n \n         assert_eq!(cttz(100u8), 2); assert_eq!(cttz(100i8), 2);\n         assert_eq!(cttz(100u16), 2); assert_eq!(cttz(100i16), 2);\n         assert_eq!(cttz(100u32), 2); assert_eq!(cttz(100i32), 2);\n         assert_eq!(cttz(100u64), 2); assert_eq!(cttz(100i64), 2);\n+        assert_eq!(cttz(100u128), 2); assert_eq!(cttz(100i128), 2);\n \n         assert_eq!(cttz_nonzero(-1i8 as u8), 0); assert_eq!(cttz_nonzero(-1i8), 0);\n         assert_eq!(cttz_nonzero(-1i16 as u16), 0); assert_eq!(cttz_nonzero(-1i16), 0);\n         assert_eq!(cttz_nonzero(-1i32 as u32), 0); assert_eq!(cttz_nonzero(-1i32), 0);\n         assert_eq!(cttz_nonzero(-1i64 as u64), 0); assert_eq!(cttz_nonzero(-1i64), 0);\n+        assert_eq!(cttz_nonzero(-1i128 as u128), 0); assert_eq!(cttz_nonzero(-1i128), 0);\n \n         assert_eq!(cttz_nonzero(1u8), 0); assert_eq!(cttz_nonzero(1i8), 0);\n         assert_eq!(cttz_nonzero(1u16), 0); assert_eq!(cttz_nonzero(1i16), 0);\n         assert_eq!(cttz_nonzero(1u32), 0); assert_eq!(cttz_nonzero(1i32), 0);\n         assert_eq!(cttz_nonzero(1u64), 0); assert_eq!(cttz_nonzero(1i64), 0);\n+        assert_eq!(cttz_nonzero(1u128), 0); assert_eq!(cttz_nonzero(1i128), 0);\n \n         assert_eq!(cttz_nonzero(10u8), 1); assert_eq!(cttz_nonzero(10i8), 1);\n         assert_eq!(cttz_nonzero(10u16), 1); assert_eq!(cttz_nonzero(10i16), 1);\n         assert_eq!(cttz_nonzero(10u32), 1); assert_eq!(cttz_nonzero(10i32), 1);\n         assert_eq!(cttz_nonzero(10u64), 1); assert_eq!(cttz_nonzero(10i64), 1);\n+        assert_eq!(cttz_nonzero(10u128), 1); assert_eq!(cttz_nonzero(10i128), 1);\n \n         assert_eq!(cttz_nonzero(100u8), 2); assert_eq!(cttz_nonzero(100i8), 2);\n         assert_eq!(cttz_nonzero(100u16), 2); assert_eq!(cttz_nonzero(100i16), 2);\n         assert_eq!(cttz_nonzero(100u32), 2); assert_eq!(cttz_nonzero(100i32), 2);\n         assert_eq!(cttz_nonzero(100u64), 2); assert_eq!(cttz_nonzero(100i64), 2);\n+        assert_eq!(cttz_nonzero(100u128), 2); assert_eq!(cttz_nonzero(100i128), 2);\n \n         assert_eq!(bswap(0x0Au8), 0x0A); // no-op\n         assert_eq!(bswap(0x0Ai8), 0x0A); // no-op\n@@ -138,5 +160,18 @@ pub fn main() {\n         assert_eq!(bswap(0x0ABBCC0Di32), 0x0DCCBB0A);\n         assert_eq!(bswap(0x0122334455667708u64), 0x0877665544332201);\n         assert_eq!(bswap(0x0122334455667708i64), 0x0877665544332201);\n+        assert_eq!(bswap(0x0122334455667708u128), 0x08776655443322010000000000000000);\n+        assert_eq!(bswap(0x0122334455667708i128), 0x08776655443322010000000000000000);\n+\n+        assert_eq!(bitreverse(0x0Au8), 0x50);\n+        assert_eq!(bitreverse(0x0Ai8), 0x50);\n+        assert_eq!(bitreverse(0x0A0Cu16), 0x3050);\n+        assert_eq!(bitreverse(0x0A0Ci16), 0x3050);\n+        assert_eq!(bitreverse(0x0ABBCC0Eu32), 0x7033DD50);\n+        assert_eq!(bitreverse(0x0ABBCC0Ei32), 0x7033DD50);\n+        assert_eq!(bitreverse(0x0122334455667708u64), 0x10EE66AA22CC4480);\n+        assert_eq!(bitreverse(0x0122334455667708i64), 0x10EE66AA22CC4480);\n+        assert_eq!(bitreverse(0x0122334455667708u128), 0x10EE66AA22CC44800000000000000000);\n+        assert_eq!(bitreverse(0x0122334455667708i128), 0x10EE66AA22CC44800000000000000000);\n     }\n }"}]}