{"sha": "61e03ffc6b8284abe34837fc85a82566ee4552ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFlMDNmZmM2YjgyODRhYmUzNDgzN2ZjODVhODI1NjZlZTQ1NTJlZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-01-26T14:06:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-01-26T14:06:20Z"}, "message": "re PR tree-optimization/47237 (builtin_apply_args broken WRT local ABI changes.)\n\n\tPR target/47237\n\t* cgraph.h (cgraph_local_info): New field can_change_signature.\n\t* ipa-cp.c (ipcp_update_callgraph): Only compute args_to_skip if callee\n\tsignature can change.\n\t(ipcp_estimate_growth): Call sequence simplify only if calle signature\n\tcan change.\n\t(ipcp_insert_stage): Only compute args_to_skip if signature can change.\n\t(cgraph_function_versioning): We can not change signature of functions\n\tthat don't allow that.\n\t* lto-cgraph.c (lto_output_node): Stream local.can_change_signature.\n\t(lto_input_node): Likewise.\n\t* ipa-inline.c (compute_inline_parameters): Compute local.can_change_signature.\n\t* ipa-split.c (visit_bb): Never split away APPLY_ARGS.\n\t* tree-sra.c (ipa_sra_preliminary_function_checks): Give up on functions\n\tthat can not change signature.\n\t* i386.c (ix86_function_regparm, ix86_function_sseregparm,\n\tinit_cumulative_args): Do not use local calling conventions for functions\n\tthat can not change signature.\n\nFrom-SVN: r169290", "tree": {"sha": "4e831ce4ac2924d53233e6215470e4dbd88eea9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e831ce4ac2924d53233e6215470e4dbd88eea9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61e03ffc6b8284abe34837fc85a82566ee4552ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61e03ffc6b8284abe34837fc85a82566ee4552ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61e03ffc6b8284abe34837fc85a82566ee4552ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61e03ffc6b8284abe34837fc85a82566ee4552ee/comments", "author": null, "committer": null, "parents": [{"sha": "980ca89173da230e449a8e8017f0b2c2b46a374a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980ca89173da230e449a8e8017f0b2c2b46a374a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/980ca89173da230e449a8e8017f0b2c2b46a374a"}], "stats": {"total": 121, "additions": 94, "deletions": 27}, "files": [{"sha": "6176b4d6a45a82c83ae21f3faf49543eaaeaa8bf", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -2300,6 +2300,8 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n   if (!flag_wpa)\n     gcc_checking_assert  (tree_versionable_function_p (old_decl));\n \n+  gcc_assert (old_node->local.can_change_signature || !args_to_skip);\n+\n   /* Make a new FUNCTION_DECL tree node */\n   if (!args_to_skip)\n     new_decl = copy_node (old_decl);"}, {"sha": "2df3fa54d9fd8ce64bae4f268edcf1ae250a4b79", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -114,6 +114,10 @@ struct GTY(()) cgraph_local_info {\n      Currently computed and used only by ipa-cp.  */\n   unsigned versionable : 1;\n \n+  /* False when function calling convention and signature can not be changed.\n+     This is the case when __builtin_apply_args is used.  */\n+  unsigned can_change_signature : 1;\n+\n   /* True when function should be inlined independently on its size.  */\n   unsigned disregard_inline_limits : 1;\n "}, {"sha": "2245164c3eb81fe785b158c2eb8a76ffd22a5fdf", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -2014,6 +2014,8 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n   if (!tree_versionable_function_p (old_decl))\n     return NULL;\n \n+  gcc_assert (old_version_node->local.can_change_signature || !args_to_skip);\n+\n   /* Make a new FUNCTION_DECL tree node for the\n      new version. */\n   if (!args_to_skip)"}, {"sha": "4d927c2b259b7e3c2b5691f3791f3ec82b6a8657", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -5493,7 +5493,7 @@ ix86_function_regparm (const_tree type, const_tree decl)\n     {\n       /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */\n       struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE (decl));\n-      if (i && i->local)\n+      if (i && i->local && i->can_change_signature)\n \t{\n \t  int local_regparm, globals = 0, regno;\n \n@@ -5570,7 +5570,7 @@ ix86_function_sseregparm (const_tree type, const_tree decl, bool warn)\n     {\n       /* FIXME: remove this CONST_CAST when cgraph.[ch] is constified.  */\n       struct cgraph_local_info *i = cgraph_local_info (CONST_CAST_TREE(decl));\n-      if (i && i->local)\n+      if (i && i->local && i->can_change_signature)\n \treturn TARGET_SSE2 ? 2 : 1;\n     }\n \n@@ -5954,7 +5954,7 @@ init_cumulative_args (CUMULATIVE_ARGS *cum,  /* Argument info to initialize */\n      va_start so for local functions maybe_vaarg can be made aggressive\n      helping K&R code.\n      FIXME: once typesytem is fixed, we won't need this code anymore.  */\n-  if (i && i->local)\n+  if (i && i->local && i->can_change_signature)\n     fntype = TREE_TYPE (fndecl);\n   cum->maybe_vaarg = (fntype\n \t\t      ? (!prototype_p (fntype) || stdarg_p (fntype))"}, {"sha": "b06238d84c892ac045c44710f4a10d205ad9ff8a", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -1040,25 +1040,29 @@ ipcp_update_callgraph (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed && ipcp_node_is_clone (node))\n       {\n-\tbitmap args_to_skip = BITMAP_ALLOC (NULL);\n+\tbitmap args_to_skip = NULL;\n \tstruct cgraph_node *orig_node = ipcp_get_orig_node (node);\n         struct ipa_node_params *info = IPA_NODE_REF (orig_node);\n         int i, count = ipa_get_param_count (info);\n         struct cgraph_edge *cs, *next;\n \n-\tfor (i = 0; i < count; i++)\n+\tif (node->local.can_change_signature)\n \t  {\n-\t    struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n-\n-\t    /* We can proactively remove obviously unused arguments.  */\n-\t    if (!ipa_is_param_used (info, i))\n+\t    args_to_skip = BITMAP_ALLOC (NULL);\n+\t    for (i = 0; i < count; i++)\n \t      {\n-\t\tbitmap_set_bit (args_to_skip, i);\n-\t\tcontinue;\n-\t      }\n+\t\tstruct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+\n+\t\t/* We can proactively remove obviously unused arguments.  */\n+\t\tif (!ipa_is_param_used (info, i))\n+\t\t  {\n+\t\t    bitmap_set_bit (args_to_skip, i);\n+\t\t    continue;\n+\t\t  }\n \n-\t    if (lat->type == IPA_CONST_VALUE)\n-\t      bitmap_set_bit (args_to_skip, i);\n+\t\tif (lat->type == IPA_CONST_VALUE)\n+\t\t  bitmap_set_bit (args_to_skip, i);\n+\t      }\n \t  }\n \tfor (cs = node->callers; cs; cs = next)\n \t  {\n@@ -1130,17 +1134,18 @@ ipcp_estimate_growth (struct cgraph_node *node)\n \n   info = IPA_NODE_REF (node);\n   count = ipa_get_param_count (info);\n-  for (i = 0; i < count; i++)\n-    {\n-      struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n+  if (node->local.can_change_signature)\n+    for (i = 0; i < count; i++)\n+      {\n+\tstruct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n \n-      /* We can proactively remove obviously unused arguments.  */\n-      if (!ipa_is_param_used (info, i))\n-\tremovable_args++;\n+\t/* We can proactively remove obviously unused arguments.  */\n+\tif (!ipa_is_param_used (info, i))\n+\t  removable_args++;\n \n-      if (lat->type == IPA_CONST_VALUE)\n-\tremovable_args++;\n-    }\n+\tif (lat->type == IPA_CONST_VALUE)\n+\t  removable_args++;\n+      }\n \n   /* We make just very simple estimate of savings for removal of operand from\n      call site.  Precise cost is dificult to get, as our size metric counts\n@@ -1386,16 +1391,21 @@ ipcp_insert_stage (void)\n       count = ipa_get_param_count (info);\n \n       replace_trees = VEC_alloc (ipa_replace_map_p, gc, 1);\n-      args_to_skip = BITMAP_GGC_ALLOC ();\n+\n+      if (node->local.can_change_signature)\n+\targs_to_skip = BITMAP_GGC_ALLOC ();\n+      else\n+\targs_to_skip = NULL;\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipcp_lattice *lat = ipcp_get_lattice (info, i);\n \t  parm_tree = ipa_get_param (info, i);\n \n \t  /* We can proactively remove obviously unused arguments.  */\n-          if (!ipa_is_param_used (info, i))\n+\t  if (!ipa_is_param_used (info, i))\n \t    {\n-\t      bitmap_set_bit (args_to_skip, i);\n+\t      if (args_to_skip)\n+\t        bitmap_set_bit (args_to_skip, i);\n \t      continue;\n \t    }\n \n@@ -1404,7 +1414,8 @@ ipcp_insert_stage (void)\n \t      replace_param =\n \t\tipcp_create_replace_map (parm_tree, lat);\n \t      VEC_safe_push (ipa_replace_map_p, gc, replace_trees, replace_param);\n-\t      bitmap_set_bit (args_to_skip, i);\n+\t      if (args_to_skip)\n+\t        bitmap_set_bit (args_to_skip, i);\n \t    }\n \t}\n "}, {"sha": "8087c81896e3670746c3ca2ca667860f3b8e544e", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -1997,6 +1997,22 @@ compute_inline_parameters (struct cgraph_node *node)\n \n   /* Can this function be inlined at all?  */\n   node->local.inlinable = tree_inlinable_function_p (node->decl);\n+\n+  /* Inlinable functions always can change signature.  */\n+  if (node->local.inlinable)\n+    node->local.can_change_signature = true;\n+  else\n+    {\n+      struct cgraph_edge *e;\n+\n+      /* Functions calling builtlin_apply can not change signature.  */\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (DECL_BUILT_IN (e->callee->decl)\n+\t    && DECL_BUILT_IN_CLASS (e->callee->decl) == BUILT_IN_NORMAL\n+\t    && DECL_FUNCTION_CODE (e->callee->decl) == BUILT_IN_APPLY_ARGS)\n+\t  break;\n+      node->local.can_change_signature = !e;\n+    }\n   if (node->local.inlinable && !node->local.disregard_inline_limits)\n     node->local.disregard_inline_limits\n       = DECL_DISREGARD_INLINE_LIMITS (node->decl);"}, {"sha": "dce57eaeb639b77b670c916ea3593b372db35e19", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -670,6 +670,7 @@ visit_bb (basic_block bb, basic_block return_bb,\n \t     way to store builtin_stack_save result in non-SSA variable\n \t     since all calls to those are compiler generated.  */\n \t  case BUILT_IN_APPLY:\n+\t  case BUILT_IN_APPLY_ARGS:\n \t  case BUILT_IN_VA_START:\n \t    if (dump_file && (dump_flags & TDF_DETAILS))\n \t      fprintf (dump_file,"}, {"sha": "fb05a1d05cb14bbdb6582751f3dca555bf57a6b9", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -499,6 +499,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->local.finalized, 1);\n   bp_pack_value (&bp, node->local.inlinable, 1);\n   bp_pack_value (&bp, node->local.versionable, 1);\n+  bp_pack_value (&bp, node->local.can_change_signature, 1);\n   bp_pack_value (&bp, node->local.disregard_inline_limits, 1);\n   bp_pack_value (&bp, node->local.redefined_extern_inline, 1);\n   bp_pack_value (&bp, node->local.vtable_method, 1);\n@@ -950,6 +951,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->local.finalized = bp_unpack_value (bp, 1);\n   node->local.inlinable = bp_unpack_value (bp, 1);\n   node->local.versionable = bp_unpack_value (bp, 1);\n+  node->local.can_change_signature = bp_unpack_value (bp, 1);\n   node->local.disregard_inline_limits = bp_unpack_value (bp, 1);\n   node->local.redefined_extern_inline = bp_unpack_value (bp, 1);\n   node->local.vtable_method = bp_unpack_value (bp, 1);"}, {"sha": "2100e154099ab5c4357551b092c42a910c0571bb", "filename": "gcc/testsuite/gcc.c-torture/execute/pr47237.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr47237.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr47237.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr47237.c?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -0,0 +1,22 @@\n+#define INTEGER_ARG  5\n+\n+extern void abort(void);\n+\n+static void foo(int arg)\n+{\n+  if (arg != INTEGER_ARG)\n+    abort();\n+}\n+\n+static void bar(int arg)\n+{\n+  foo(arg);\n+  __builtin_apply(foo, __builtin_apply_args(), 16);\n+}\n+\n+int main(void)\n+{\n+  bar(INTEGER_ARG);\n+\n+  return 0;\n+}"}, {"sha": "47613f6298a6ca559f6949dd5cbb8dc3a53ca296", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61e03ffc6b8284abe34837fc85a82566ee4552ee/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=61e03ffc6b8284abe34837fc85a82566ee4552ee", "patch": "@@ -4425,6 +4425,13 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n       return false;\n     }\n \n+  if (!node->local.can_change_signature)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function can not change signature.\\n\");\n+      return false;\n+    }\n+\n   if (!tree_versionable_function_p (node->decl))\n     {\n       if (dump_file)"}]}