{"sha": "8bd062e8ad44e70be04108232e1ef597fc3b3e3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJkMDYyZThhZDQ0ZTcwYmUwNDEwODIzMmUxZWY1OTdmYzNiM2UzZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-07-30T07:24:40Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-07-31T10:14:38Z"}, "message": "Do not allocate huge array in output_in_order.\n\nWe noticed that when analyzing LTRANS memory peak that happens right\nafter the start:\nhttps://gist.github.com/marxin/223890df4d8d8e490b6b2918b77dacad\n\nIn case of chrome, we have symtab->order == 200M, so we allocate\n16B * 200M = 3.2GB.\n\ngcc/ChangeLog:\n\n\t* cgraph.h: Remove leading empty lines.\n\t* cgraphunit.c (enum cgraph_order_sort_kind): Remove\n\tORDER_UNDEFINED.\n\t(struct cgraph_order_sort): Add constructors.\n\t(cgraph_order_sort::process): New.\n\t(cgraph_order_cmp): New.\n\t(output_in_order): Simplify and push nodes to vector.", "tree": {"sha": "a5e39e75e1fd5eea596c71dbbebf2f74fd4a2bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5e39e75e1fd5eea596c71dbbebf2f74fd4a2bf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bd062e8ad44e70be04108232e1ef597fc3b3e3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bd062e8ad44e70be04108232e1ef597fc3b3e3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bd062e8ad44e70be04108232e1ef597fc3b3e3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bd062e8ad44e70be04108232e1ef597fc3b3e3e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10231958fcfb13bc4847729eba21470c101b4a88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10231958fcfb13bc4847729eba21470c101b4a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10231958fcfb13bc4847729eba21470c101b4a88"}], "stats": {"total": 160, "additions": 85, "deletions": 75}, "files": [{"sha": "0211f08964f1a53dfecca29057b53c3d15bf21ce", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd062e8ad44e70be04108232e1ef597fc3b3e3e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd062e8ad44e70be04108232e1ef597fc3b3e3e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=8bd062e8ad44e70be04108232e1ef597fc3b3e3e", "patch": "@@ -2171,8 +2171,6 @@ struct GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node\n /* Every top level asm statement is put into a asm_node.  */\n \n struct GTY(()) asm_node {\n-\n-\n   /* Next asm node.  */\n   asm_node *next;\n   /* String for this asm node.  */"}, {"sha": "0a95eb93ce2d05d7dbca04644d13ae96f594b413", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 85, "deletions": 73, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bd062e8ad44e70be04108232e1ef597fc3b3e3e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bd062e8ad44e70be04108232e1ef597fc3b3e3e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=8bd062e8ad44e70be04108232e1ef597fc3b3e3e", "patch": "@@ -2492,7 +2492,6 @@ expand_all_functions (void)\n \n enum cgraph_order_sort_kind\n {\n-  ORDER_UNDEFINED = 0,\n   ORDER_FUNCTION,\n   ORDER_VAR,\n   ORDER_VAR_UNDEF,\n@@ -2501,15 +2500,76 @@ enum cgraph_order_sort_kind\n \n struct cgraph_order_sort\n {\n+  /* Construct from a cgraph_node.  */\n+  cgraph_order_sort (cgraph_node *node)\n+  : kind (ORDER_FUNCTION), order (node->order)\n+  {\n+    u.f = node;\n+  }\n+\n+  /* Construct from a varpool_node.  */\n+  cgraph_order_sort (varpool_node *node)\n+  : kind (node->definition ? ORDER_VAR : ORDER_VAR_UNDEF), order (node->order)\n+  {\n+    u.v = node;\n+  }\n+\n+  /* Construct from a asm_node.  */\n+  cgraph_order_sort (asm_node *node)\n+  : kind (ORDER_ASM), order (node->order)\n+  {\n+    u.a = node;\n+  }\n+\n+  /* Assembly cgraph_order_sort based on its type.  */\n+  void process ();\n+\n   enum cgraph_order_sort_kind kind;\n   union\n   {\n     cgraph_node *f;\n     varpool_node *v;\n     asm_node *a;\n   } u;\n+  int order;\n };\n \n+/* Assembly cgraph_order_sort based on its type.  */\n+\n+void\n+cgraph_order_sort::process ()\n+{\n+  switch (kind)\n+    {\n+    case ORDER_FUNCTION:\n+      u.f->process = 0;\n+      u.f->expand ();\n+      break;\n+    case ORDER_VAR:\n+      u.v->assemble_decl ();\n+      break;\n+    case ORDER_VAR_UNDEF:\n+      assemble_undefined_decl (u.v->decl);\n+      break;\n+    case ORDER_ASM:\n+      assemble_asm (u.a->asm_str);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Compare cgraph_order_sort by order.  */\n+\n+static int\n+cgraph_order_cmp (const void *a_p, const void *b_p)\n+{\n+  const cgraph_order_sort *nodea = (const cgraph_order_sort *)a_p;\n+  const cgraph_order_sort *nodeb = (const cgraph_order_sort *)b_p;\n+\n+  return nodea->order - nodeb->order;\n+}\n+\n /* Output all functions, variables, and asm statements in the order\n    according to their order fields, which is the order in which they\n    appeared in the file.  This implements -fno-toplevel-reorder.  In\n@@ -2519,89 +2579,41 @@ struct cgraph_order_sort\n static void\n output_in_order (void)\n {\n-  int max;\n-  cgraph_order_sort *nodes;\n   int i;\n-  cgraph_node *pf;\n-  varpool_node *pv;\n-  asm_node *pa;\n-  max = symtab->order;\n-  nodes = XCNEWVEC (cgraph_order_sort, max);\n+  cgraph_node *cnode;\n+  varpool_node *vnode;\n+  asm_node *anode;\n+  auto_vec<cgraph_order_sort> nodes;\n+  cgraph_order_sort *node;\n \n-  FOR_EACH_DEFINED_FUNCTION (pf)\n-    {\n-      if (pf->process && !pf->thunk.thunk_p && !pf->alias)\n-\t{\n-\t  if (!pf->no_reorder)\n-\t    continue;\n-\t  i = pf->order;\n-\t  gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n-\t  nodes[i].kind = ORDER_FUNCTION;\n-\t  nodes[i].u.f = pf;\n-\t}\n-    }\n+  FOR_EACH_DEFINED_FUNCTION (cnode)\n+    if (cnode->process && !cnode->thunk.thunk_p\n+\t&& !cnode->alias && cnode->no_reorder)\n+      nodes.safe_push (cgraph_order_sort (cnode));\n \n   /* There is a similar loop in symbol_table::output_variables.\n      Please keep them in sync.  */\n-  FOR_EACH_VARIABLE (pv)\n-    {\n-      if (!pv->no_reorder)\n-\tcontinue;\n-      if (DECL_HARD_REGISTER (pv->decl)\n-\t  || DECL_HAS_VALUE_EXPR_P (pv->decl))\n-\tcontinue;\n-      i = pv->order;\n-      gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n-      nodes[i].kind = pv->definition ? ORDER_VAR : ORDER_VAR_UNDEF;\n-      nodes[i].u.v = pv;\n-    }\n-\n-  for (pa = symtab->first_asm_symbol (); pa; pa = pa->next)\n-    {\n-      i = pa->order;\n-      gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n-      nodes[i].kind = ORDER_ASM;\n-      nodes[i].u.a = pa;\n-    }\n-\n-  /* In toplevel reorder mode we output all statics; mark them as needed.  */\n-\n-  for (i = 0; i < max; ++i)\n-    if (nodes[i].kind == ORDER_VAR)\n-      nodes[i].u.v->finalize_named_section_flags ();\n-\n-  for (i = 0; i < max; ++i)\n-    {\n-      switch (nodes[i].kind)\n-\t{\n-\tcase ORDER_FUNCTION:\n-\t  nodes[i].u.f->process = 0;\n-\t  nodes[i].u.f->expand ();\n-\t  break;\n+  FOR_EACH_VARIABLE (vnode)\n+    if (vnode->no_reorder\n+\t&& !DECL_HARD_REGISTER (vnode->decl)\n+\t&& !DECL_HAS_VALUE_EXPR_P (vnode->decl))\n+      nodes.safe_push (cgraph_order_sort (vnode));\n \n-\tcase ORDER_VAR:\n-\t  nodes[i].u.v->assemble_decl ();\n-\t  break;\n+  for (anode = symtab->first_asm_symbol (); anode; anode = anode->next)\n+    nodes.safe_push (cgraph_order_sort (anode));\n \n-\tcase ORDER_VAR_UNDEF:\n-\t  assemble_undefined_decl (nodes[i].u.v->decl);\n-\t  break;\n+  /* Sort nodes by order.  */\n+  nodes.qsort (cgraph_order_cmp);\n \n-\tcase ORDER_ASM:\n-\t  assemble_asm (nodes[i].u.a->asm_str);\n-\t  break;\n-\n-\tcase ORDER_UNDEFINED:\n-\t  break;\n+  /* In toplevel reorder mode we output all statics; mark them as needed.  */\n+  FOR_EACH_VEC_ELT (nodes, i, node)\n+    if (node->kind == ORDER_VAR)\n+      node->u.v->finalize_named_section_flags ();\n \n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n+  FOR_EACH_VEC_ELT (nodes, i, node)\n+    node->process ();\n \n   symtab->clear_asm_symbols ();\n-\n-  free (nodes);\n }\n \n static void"}]}