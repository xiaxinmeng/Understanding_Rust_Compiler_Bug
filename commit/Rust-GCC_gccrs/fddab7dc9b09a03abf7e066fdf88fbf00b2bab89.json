{"sha": "fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRkYWI3ZGM5YjA5YTAzYWJmN2UwNjZmZGY4OGZiZjAwYjJiYWI4OQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-03-18T07:50:19Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-03-18T07:50:19Z"}, "message": "BufferedOutputStream.java, [...]: More merges from classpath.\n\n2003-03-18  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/BufferedOutputStream.java,\n\tjava/io/DataInput.java,\n\tjava/io/DataInputStream.java,\n\tjava/io/DataOutput.java,\n\tjava/io/Externalizable.java:\n\tMore merges from classpath.\n\nFrom-SVN: r64528", "tree": {"sha": "bcc9d044203d9b0ee62a6e7dc4d0e991ed1d76e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcc9d044203d9b0ee62a6e7dc4d0e991ed1d76e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/comments", "author": null, "committer": null, "parents": [{"sha": "71a15b1586df418072fefeaa88cf780a15880e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71a15b1586df418072fefeaa88cf780a15880e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71a15b1586df418072fefeaa88cf780a15880e93"}], "stats": {"total": 1607, "additions": 799, "deletions": 808}, "files": [{"sha": "d63331d11244e1a9f09b90567c7c0a55f0adacdb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "patch": "@@ -1,3 +1,12 @@\n+2003-03-18  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/BufferedOutputStream.java,\n+\tjava/io/DataInput.java,\n+\tjava/io/DataInputStream.java,\n+\tjava/io/DataOutput.java,\n+\tjava/io/Externalizable.java:\n+\tMore merges from classpath.\n+\n 2003-03-18  Michael Koch  <konqueror@gmx.de>\n \n \t* configure.in: Fixed links to platform dependant java.net files."}, {"sha": "c2f9f6ba955f76a5ae88dd9721e5f9c87f5d0f7b", "filename": "libjava/java/io/BufferedOutputStream.java", "status": "modified", "additions": 165, "deletions": 175, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FBufferedOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FBufferedOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedOutputStream.java?ref=fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "patch": "@@ -46,189 +46,179 @@\n   * efficient mechanism for writing versus doing numerous small unbuffered\n   * writes.\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public class BufferedOutputStream extends FilterOutputStream\n {\n-\n-/*************************************************************************/\n-\n-/*\n- * Class Variables\n- */\n-\n-/**\n-  * This is the default buffer size\n-  */\n-private static final int DEFAULT_BUFFER_SIZE = 512;\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Variables\n- */\n-\n-/**\n-  * This is the internal byte array used for buffering output before\n-  * writing it.\n-  */\n-protected byte[] buf;\n-\n-/**\n-  * This is the number of bytes that are currently in the buffer and\n-  * are waiting to be written to the underlying stream.  It always points to\n-  * the index into the buffer where the next byte of data will be stored\n-  */\n-protected int count;\n-\n-/*************************************************************************/\n-\n-/*\n- * Constructors\n- */\n-\n-/**\n-  * This method initializes a new <code>BufferedOutputStream</code> instance\n-  * that will write to the specified subordinate <code>OutputStream</code>\n-  * and which will use a default buffer size of 512 bytes.\n-  *\n-  * @param out The underlying <code>OutputStream</code> to write data to\n-  */\n-public\n-BufferedOutputStream(OutputStream out)\n-{\n-  this(out, DEFAULT_BUFFER_SIZE);\n-}\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method initializes a new <code>BufferedOutputStream</code> instance\n-  * that will write to the specified subordinate <code>OutputStream</code>\n-  * and which will use the specified buffer size\n-  *\n-  * @param out The underlying <code>OutputStream</code> to write data to\n-  * @param size The size of the internal buffer\n-  */\n-public\n-BufferedOutputStream(OutputStream out, int size)\n-{\n-  super(out);\n-\n-  buf = new byte[size];\n-}\n-\n-/*************************************************************************/\n-\n-/*\n- * Instance Methods\n- */\n-\n-/**\n-  * This method causes any currently buffered bytes to be immediately\n-  * written to the underlying output stream.\n-  *\n-  * @exception IOException If an error occurs\n+  /*\n+   * Class Variables\n+   */\n+\n+  /**\n+    * This is the default buffer size\n+    */\n+  private static final int DEFAULT_BUFFER_SIZE = 512;\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Variables\n+   */\n+\n+  /**\n+    * This is the internal byte array used for buffering output before\n+    * writing it.\n+    */\n+  protected byte[] buf;\n+\n+  /**\n+    * This is the number of bytes that are currently in the buffer and\n+    * are waiting to be written to the underlying stream.  It always points to\n+    * the index into the buffer where the next byte of data will be stored\n+    */\n+  protected int count;\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Constructors\n+   */\n+\n+  /**\n+    * This method initializes a new <code>BufferedOutputStream</code> instance\n+    * that will write to the specified subordinate <code>OutputStream</code>\n+    * and which will use a default buffer size of 512 bytes.\n+    *\n+    * @param out The underlying <code>OutputStream</code> to write data to\n+    */\n+  public BufferedOutputStream(OutputStream out)\n+  {\n+    this(out, DEFAULT_BUFFER_SIZE);\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method initializes a new <code>BufferedOutputStream</code> instance\n+    * that will write to the specified subordinate <code>OutputStream</code>\n+    * and which will use the specified buffer size\n+    *\n+    * @param out The underlying <code>OutputStream</code> to write data to\n+    * @param size The size of the internal buffer\n+    */\n+  public BufferedOutputStream(OutputStream out, int size)\n+  {\n+    super(out);\n+\n+    buf = new byte[size];\n+  }\n+\n+  /*************************************************************************/\n+\n+  /*\n+   * Instance Methods\n+   */\n+\n+  /**\n+    * This method causes any currently buffered bytes to be immediately\n+    * written to the underlying output stream.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public synchronized void flush() throws IOException\n+  {\n+    if (count == 0)\n+      return;\n+\n+    out.write(buf, 0, count);\n+    count = 0;\n+    out.flush();\n+  }\n+\n+  /*************************************************************************/\n+\n+  /*\n+    * This method flushes any remaining buffered bytes then closes the \n+    * underlying output stream.  Any further attempts to write to this stream\n+    * may throw an exception\n+    *\n+  public synchronized void close() throws IOException\n+  {\n+    flush();\n+    out.close();\n+  }\n   */\n-public synchronized void\n-flush() throws IOException\n-{\n-  if (count == 0)\n-    return;\n-\n-  out.write(buf, 0, count);\n-  count = 0;\n-  out.flush();\n-}\n-\n-/*************************************************************************/\n-\n-/*\n-  * This method flushes any remaining buffered bytes then closes the \n-  * underlying output stream.  Any further attempts to write to this stream\n-  * may throw an exception\n-  *\n-public synchronized void\n-close() throws IOException\n-{\n-  flush();\n-  out.close();\n-}\n-*/\n-\n-/*************************************************************************/\n-\n-/*\n-  * This method runs when the object is garbage collected.  It is \n-  * responsible for ensuring that all buffered bytes are written and\n-  * for closing the underlying stream.\n-  *\n-  * @exception IOException If an error occurs (ignored by the Java runtime)\n-  *\n-protected void\n-finalize() throws IOException\n-{\n-  close();\n-}\n-*/\n \n-/*************************************************************************/\n-\n-/**\n-  * This method writes a single byte of data.  This will be written to the\n-  * buffer instead of the underlying data source.  However, if the buffer\n-  * is filled as a result of this write request, it will be flushed to the\n-  * underlying output stream.\n-  *\n-  * @param b The byte of data to be written, passed as an int\n-  *\n-  * @exception IOException If an error occurs\n+  /*************************************************************************/\n+\n+  /*\n+    * This method runs when the object is garbage collected.  It is \n+    * responsible for ensuring that all buffered bytes are written and\n+    * for closing the underlying stream.\n+    *\n+    * @exception IOException If an error occurs (ignored by the Java runtime)\n+    *\n+  protected void finalize() throws IOException\n+  {\n+    close();\n+  }\n   */\n-public synchronized void\n-write(int b) throws IOException\n-{\n-  if (count == buf.length)\n-    flush();\n-\n-  buf[count] = (byte)(b & 0xFF);\n-  ++count;\n-}\n-\n-/*************************************************************************/\n \n-/**\n-  * This method writes <code>len</code> bytes from the byte array \n-  * <code>buf</code> starting at position <code>offset</code> in the buffer. \n-  * These bytes will be written to the internal buffer.  However, if this\n-  * write operation fills the buffer, the buffer will be flushed to the\n-  * underlying output stream.\n-  *\n-  * @param buf The array of bytes to write.\n-  * @param offset The index into the byte array to start writing from.\n-  * @param len The number of bytes to write.\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public synchronized void\n-write(byte[] buf, int offset, int len) throws IOException\n-{\n-  // Buffer can hold everything.  Note that the case where LEN < 0\n-  // is automatically handled by the downstream write.\n-  if (len < (this.buf.length - count))\n-    {\n-      System.arraycopy(buf, offset, this.buf, count, len);\n-      count += len;\n-    }\n-  else\n-    {\n-      // The write was too big.  So flush the buffer and write the new\n-      // bytes directly to the underlying stream, per the JDK 1.2\n-      // docs.\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a single byte of data.  This will be written to the\n+    * buffer instead of the underlying data source.  However, if the buffer\n+    * is filled as a result of this write request, it will be flushed to the\n+    * underlying output stream.\n+    *\n+    * @param b The byte of data to be written, passed as an int\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public synchronized void write(int b) throws IOException\n+  {\n+    if (count == buf.length)\n       flush();\n-      out.write (buf, offset, len);\n-    }\n-}\n+\n+    buf[count] = (byte)(b & 0xFF);\n+    ++count;\n+  }\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes <code>len</code> bytes from the byte array \n+    * <code>buf</code> starting at position <code>offset</code> in the buffer. \n+    * These bytes will be written to the internal buffer.  However, if this\n+    * write operation fills the buffer, the buffer will be flushed to the\n+    * underlying output stream.\n+    *\n+    * @param buf The array of bytes to write.\n+    * @param offset The index into the byte array to start writing from.\n+    * @param len The number of bytes to write.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public synchronized void write(byte[] buf, int offset, int len) \n+    throws IOException\n+  {\n+    // Buffer can hold everything.  Note that the case where LEN < 0\n+    // is automatically handled by the downstream write.\n+    if (len < (this.buf.length - count))\n+      {\n+        System.arraycopy(buf, offset, this.buf, count, len);\n+        count += len;\n+      }\n+    else\n+      {\n+        // The write was too big.  So flush the buffer and write the new\n+        // bytes directly to the underlying stream, per the JDK 1.2\n+        // docs.\n+        flush();\n+        out.write (buf, offset, len);\n+      }\n+  }\n \n } // class BufferedOutputStream \n+"}, {"sha": "d9763e29d2c9995cc802e7edf1e9d69418b138b2", "filename": "libjava/java/io/DataInput.java", "status": "modified", "additions": 420, "deletions": 418, "changes": 838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FDataInput.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FDataInput.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInput.java?ref=fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "patch": "@@ -1,5 +1,5 @@\n /* DataInput.java -- Interface for reading data from a stream\n-   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,9 +40,8 @@\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n+ * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.  \n+ * Status:  Believed complete and correct.  */\n \n /**\n   * This interface is implemented by classes that can data from streams \n@@ -54,419 +53,422 @@\n public interface DataInput\n {\n \n-/**\n-  * This method reads a Java boolean value from an input stream.  It does\n-  * so by reading a single byte of data.  If that byte is zero, then the\n-  * value returned is <code>false</code>.  If the byte is non-zero, then\n-  * the value returned is <code>true</code>.\n-  * <p>\n-  * This method can read a <code>boolean</code> written by an object\n-  * implementing the <code>writeBoolean()</code> method in the\n-  * <code>DataOutput</code> interface.\n-  *\n-  * @return The <code>boolean</code> value read\n-  *\n-  * @exception EOFException If end of file is reached before reading the boolean\n-  * @exception IOException If any other error occurs\n-  */\n-boolean\n-readBoolean() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads a Java byte value from an input stream.  The value\n-  * is in the range of -128 to 127.\n-  * <p>\n-  * This method can read a <code>byte</code> written by an object\n-  * implementing the \n-  * <code>writeByte()</code> method in the <code>DataOutput</code> interface.\n-  * <p>\n-  * @return The <code>byte</code> value read\n-  *\n-  * @exception EOFException If end of file is reached before reading the byte\n-  * @exception IOException If any other error occurs\n-  *\n-  * @see DataOutput\n-  */\n-byte\n-readByte() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads 8 unsigned bits into a Java <code>int</code> value from\n-  * the stream. The value returned is in the range of 0 to 255.\n-  * <p>\n-  * This method can read an unsigned byte written by an object implementing the\n-  * <code>writeUnsignedByte()</code> method in the <code>DataOutput</code>\n-  * interface.\n-  *\n-  * @return The unsigned bytes value read as a Java <code>int</code>.\n-  *\n-  * @exception EOFException If end of file is reached before reading the value\n-  * @exception IOException If any other error occurs\n-  *\n-  * @see DataOutput\n-  */\n-int\n-readUnsignedByte() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads a Java <code>char</code> value from an input stream.  \n-  * It operates by reading two bytes from the stream and converting them to \n-  * a single 16-bit Java <code>char</code>.  The two bytes are stored most\n-  * significant byte first (i.e., \"big endian\") regardless of the native\n-  * host byte ordering. \n-  * <p>\n-  * As an example, if <code>byte1</code> and <code>byte2</code> represent the\n-  * first and second byte read from the stream respectively, they will be\n-  * transformed to a <code>char</code> in the following manner:\n-  * <p>\n-  * <code>(char)((byte1 << 8) + byte2)</code>\n-  * <p>\n-  * This method can read a <code>char</code> written by an object implementing\n-  * the\n-  * <code>writeChar()</code> method in the <code>DataOutput</code> interface.\n-  *\n-  * @return The <code>char</code> value read \n-  *\n-  * @exception EOFException If end of file is reached before reading the char\n-  * @exception IOException If any other error occurs\n-  *\n-  * @see DataOutput\n-  */\n-char\n-readChar() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads a signed 16-bit value into a Java in from the stream.\n-  * It operates by reading two bytes from the stream and converting them to \n-  * a single 16-bit Java <code>short</code>.  The two bytes are stored most\n-  * significant byte first (i.e., \"big endian\") regardless of the native\n-  * host byte ordering. \n-  * <p>\n-  * As an example, if <code>byte1</code> and <code>byte2</code> represent the\n-  * first and second byte read from the stream respectively, they will be\n-  * transformed to a <code>short</code> in the following manner:\n-  * <p>\n-  * <code>(short)((byte1 << 8) + byte2)</code>\n-  * <p>\n-  * The value returned is in the range of -32768 to 32767.\n-  * <p>\n-  * This method can read a <code>short</code> written by an object implementing\n-  * the <code>writeShort()</code> method in the <code>DataOutput</code>\n-  * interface.\n-  *\n-  * @return The <code>short</code> value read\n-  *\n-  * @exception EOFException If end of file is reached before reading the value\n-  * @exception IOException If any other error occurs\n-  *\n-  * @see DataOutput\n-  */\n-short\n-readShort() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads 16 unsigned bits into a Java int value from the stream.\n-  * It operates by reading two bytes from the stream and converting them to \n-  * a single Java <code>int</code>.  The two bytes are stored most\n-  * significant byte first (i.e., \"big endian\") regardless of the native\n-  * host byte ordering. \n-  * <p>\n-  * As an example, if <code>byte1</code> and <code>byte2</code> represent the\n-  * first and second byte read from the stream respectively, they will be\n-  * transformed to an <code>int</code> in the following manner:\n-  * <p>\n-  * <code>(int)((byte1 << 8) + byte2)</code>\n-  * <p>\n-  * The value returned is in the range of 0 to 65535.\n-  * <p>\n-  * This method can read an unsigned short written by an object implementing\n-  * the <code>writeUnsignedShort()</code> method in the <code>DataOutput</code>\n-  * interface.\n-  *\n-  * @return The unsigned short value read as a Java <code>int</code>.\n-  *\n-  * @exception EOFException If end of file is reached before reading the value\n-  * @exception IOException If any other error occurs\n-  */\n-int\n-readUnsignedShort() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads a Java <code>int</code> value from an input stream\n-  * It operates by reading four bytes from the stream and converting them to \n-  * a single Java <code>int</code>.  The bytes are stored most\n-  * significant byte first (i.e., \"big endian\") regardless of the native\n-  * host byte ordering. \n-  * <p>\n-  * As an example, if <code>byte1</code> through <code>byte4</code> represent\n-  * the first four bytes read from the stream, they will be\n-  * transformed to an <code>int</code> in the following manner:\n-  * <p>\n-  * <code>(int)((byte1 << 24) + (byte2 << 16) + (byte3 << 8) + byte4))</code>\n-  * <p>\n-   The value returned is in the range of -2147483648 to 2147483647.\n-  * <p>\n-  * This method can read an <code>int</code> written by an object implementing\n-  * the <code>writeInt()</code> method in the <code>DataOutput</code> interface.\n-  *\n-  * @return The <code>int</code> value read\n-  *\n-  * @exception EOFException If end of file is reached before reading the int\n-  * @exception IOException If any other error occurs\n-  *\n-  * @see DataOutput\n-  */\n-int\n-readInt() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads a Java <code>long</code> value from an input stream\n-  * It operates by reading eight bytes from the stream and converting them to \n-  * a single Java <code>long</code>.  The bytes are stored most\n-  * significant byte first (i.e., \"big endian\") regardless of the native\n-  * host byte ordering. \n-  * <p>\n-  * As an example, if <code>byte1</code> through <code>byte8</code> represent\n-  * the first eight bytes read from the stream, they will be\n-  * transformed to an <code>long</code> in the following manner:\n-  * <p>\n-  * <code>(long)((byte1 << 56) + (byte2 << 48) + (byte3 << 40) + \n-  * (byte4 << 32) + (byte5 << 24) + (byte6 << 16) + (byte7 << 8) + byte9))\n-  * </code>\n-  * <p>\n-  * The value returned is in the range of -9223372036854775808 to\n-  * 9223372036854775807.\n-  * <p>\n-  * This method can read an <code>long</code> written by an object implementing\n-  * the <code>writeLong()</code> method in the <code>DataOutput</code>\n-  * interface.\n-  *\n-  * @return The <code>long</code> value read\n-  *\n-  * @exception EOFException If end of file is reached before reading the long\n-  * @exception IOException If any other error occurs\n-  *\n-  * @see DataOutput\n-  */\n-long\n-readLong() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads a Java float value from an input stream.  It operates\n-  * by first reading an <code>int</code> value from the stream by calling the\n-  * <code>readInt()</code> method in this interface, then converts that\n-  * <code>int</code> to a <code>float</code> using the\n-  * <code>intBitsToFloat</code> method in the class\n-  * <code>java.lang.Float</code>.\n-  * <p>\n-  * This method can read a <code>float</code> written by an object implementing\n-  * the <code>writeFloat()</code> method in the <code>DataOutput</code>\n-  * interface.\n-  *\n-  * @return The <code>float</code> value read\n-  *\n-  * @exception EOFException If end of file is reached before reading the float\n-  * @exception IOException If any other error occurs\n-  *\n-  * @see java.lang.Float\n-  * @see DataOutput\n-  */\n-float\n-readFloat() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads a Java double value from an input stream.  It operates\n-  * by first reading a <code>long</code> value from the stream by calling the\n-  * <code>readLong()</code> method in this interface, then converts that\n-  * <code>long</code> to a <code>double</code> using the\n-  * <code>longBitsToDouble</code> method in the class\n-  * <code>java.lang.Double</code>.\n-  * <p>\n-  * This method can read a <code>double</code> written by an object\n-  * implementing the <code>writeDouble()</code> method in the\n-  * <code>DataOutput</code> interface.\n-  *\n-  * @return The <code>double</code> value read\n-  *\n-  * @exception EOFException If end of file is reached before reading the double\n-  * @exception IOException If any other error occurs\n-  *\n-  * @see java.lang.Double\n-  * @see DataOutput\n-  */\n-double\n-readDouble() throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads the next line of text data from an input stream.\n-  * It operates by reading bytes and converting those bytes to <code>char</code>\n-  * values by treating the byte read as the low eight bits of the\n-  * <code>char</code> and using 0 as the high eight bits.  Because of this,\n-  * it does not support the full 16-bit Unicode character set.\n-  * <P>\n-  * The reading of bytes ends when either the end of file or a line terminator\n-  * is encountered.  The bytes read are then returned as a <code>String</code>.\n-  * A line terminator is a byte sequence consisting of either \n-  * <code>\\r</code>, <code>\\n</code> or <code>\\r\\n</code>.  These termination\n-  * charaters are discarded and are not returned as part of the string.\n-  * <p>\n-  * This method can read data that was written by an object implementing the\n-  * <code>writeLine()</code> method in <code>DataOutput</code>.\n-  *\n-  * @return The line read as a <code>String</code>\n-  *\n-  * @exception IOException If an error occurs\n-  *\n-  * @see DataOutput\n-  */\n-String\n-readLine() throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads a <code>String</code> from an input stream that is\n-  * encoded in a modified UTF-8 format.  This format has a leading two byte\n-  * sequence that contains the remaining number of bytes to read.  This two byte\n-  * sequence is read using the <code>readUnsignedShort()</code> method of this\n-  * interface.\n-  *\n-  * After the number of remaining bytes have been determined, these bytes\n-  * are read an transformed into <code>char</code> values.  These\n-  * <code>char</code> values are encoded in the stream using either a one, two,\n-  * or three byte format.\n-  * The particular format in use can be determined by examining the first\n-  * byte read.  \n-  * <p>\n-  * If the first byte has a high order bit of 0, then\n-  * that character consists on only one byte.  This character value consists\n-  * of seven bits that are at positions 0 through 6 of the byte.  As an\n-  * example, if <code>byte1</code> is the byte read from the stream, it would\n-  * be converted to a <code>char</code> like so:\n-  * <p>\n-  * <code>(char)byte1</code>\n-  * <p>\n-  * If the first byte has 110 as its high order bits, then the \n-  * character consists of two bytes.  The bits that make up the character\n-  * value are in positions 0 through 4 of the first byte and bit positions\n-  * 0 through 5 of the second byte.  (The second byte should have \n-  * 10 as its high order bits).  These values are in most significant\n-  * byte first (i.e., \"big endian\") order.\n-  * <p>\n-  * As an example, if <code>byte1</code> and <code>byte2</code> are the first\n-  * two bytes read respectively, and the high order bits of them match the\n-  * patterns which indicate a two byte character encoding, then they would be\n-  * converted to a Java <code>char</code> like so:\n-  * <p>\n-  * <code>(char)(((byte1 & 0x1F) << 6) + (byte2 & 0x3F))</code>\n-  * <p>\n-  * If the first byte has a 1110 as its high order bits, then the\n-  * character consists of three bytes.  The bits that make up the character\n-  * value are in positions 0 through 3 of the first byte and bit positions\n-  * 0 through 5 of the other two bytes.  (The second and third bytes should\n-  * have 10 as their high order bits).  These values are in most\n-  * significant byte first (i.e., \"big endian\") order.\n-  * <p>\n-  * As an example, if <code>byte1</code>, <code>byte2</code>, and\n-  * <code>byte3</code> are the three bytes read, and the high order bits of\n-  * them match the patterns which indicate a three byte character encoding,\n-  * then they would be converted to a Java <code>char</code> like so:\n-  *\n-  * <code>\n-  * (char)(((byte1 & 0x0F) << 12) + ((byte2 & 0x3F) + (byte3 & 0x3F))\n-  * </code>\n-  *\n-  * Note that all characters are encoded in the method that requires the\n-  * fewest number of bytes with the exception of the character with the\n-  * value of <code>\\<llll>u0000</code> which is encoded as two bytes.  This is\n-  * a modification of the UTF standard used to prevent C language style\n-  * <code>NUL</code> values from appearing in the byte stream.\n-  * <p>\n-  * This method can read data that was written by an object implementing the\n-  * <code>writeUTF()</code> method in <code>DataOutput</code>.\n-  * \n-  * @returns The <code>String</code> read\n-  *\n-  * @exception EOFException If end of file is reached before reading the String\n-  * @exception UTFDataFormatException If the data is not in UTF-8 format\n-  * @exception IOException If any other error occurs\n-  *\n-  * @see DataOutput\n-  */\n-String\n-readUTF() throws EOFException, UTFDataFormatException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads raw bytes into the passed array until the array is\n-  * full.  Note that this method blocks until the data is available and\n-  * throws an exception if there is not enough data left in the stream to\n-  * fill the buffer\n-  *\n-  * @param buf The buffer into which to read the data\n-  *\n-  * @exception EOFException If end of file is reached before filling the buffer\n-  * @exception IOException If any other error occurs\n-  */\n-void\n-readFully(byte[] buf) throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method reads raw bytes into the passed array <code>buf</code> starting\n-  * <code>offset</code> bytes into the buffer.  The number of bytes read will be\n-  * exactly <code>len</code>.  Note that this method blocks until the data is \n-  * available and * throws an exception if there is not enough data left in \n-  * the stream to read <code>len</code> bytes.\n-  *\n-  * @param buf The buffer into which to read the data\n-  * @param offset The offset into the buffer to start storing data\n-  * @param len The number of bytes to read into the buffer\n-  *\n-  * @exception EOFException If end of file is reached before filling the buffer\n-  * @exception IOException If any other error occurs\n-  */\n-void\n-readFully(byte[] buf, int offset, int len) throws EOFException, IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method skips and discards the specified number of bytes in an\n-  * input stream\n-  *\n-  * @param num_bytes The number of bytes to skip\n-  *\n-  * @return The number of bytes actually skipped, which will always be\n-  *         <code>num_bytes</code>\n-  *\n-  * @exception EOFException If end of file is reached before all bytes can be\n-  *                         skipped\n-  * @exception IOException If any other error occurs\n-  */\n-int\n-skipBytes(int n) throws EOFException, IOException;\n+  /**\n+    * This method reads a Java boolean value from an input stream.  It does\n+    * so by reading a single byte of data.  If that byte is zero, then the\n+    * value returned is <code>false</code>.  If the byte is non-zero, then\n+    * the value returned is <code>true</code>.\n+    * <p>\n+    * This method can read a <code>boolean</code> written by an object\n+    * implementing the <code>writeBoolean()</code> method in the\n+    * <code>DataOutput</code> interface.\n+    *\n+    * @return The <code>boolean</code> value read\n+    *\n+    * @exception EOFException If end of file is reached before \n+    * reading the boolean\n+    * @exception IOException If any other error occurs\n+    */\n+  boolean readBoolean() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads a Java byte value from an input stream.  The value\n+    * is in the range of -128 to 127.\n+    * <p>\n+    * This method can read a <code>byte</code> written by an object\n+    * implementing the \n+    * <code>writeByte()</code> method in the <code>DataOutput</code> interface.\n+    * <p>\n+    * @return The <code>byte</code> value read\n+    *\n+    * @exception EOFException If end of file is reached before reading the byte\n+    * @exception IOException If any other error occurs\n+    *\n+    * @see DataOutput\n+    */\n+  byte readByte() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads 8 unsigned bits into a Java <code>int</code> value from\n+    * the stream. The value returned is in the range of 0 to 255.\n+    * <p>\n+    * This method can read an unsigned byte written by an object \n+    * implementing the\n+    * <code>writeUnsignedByte()</code> method in the <code>DataOutput</code>\n+    * interface.\n+    *\n+    * @return The unsigned bytes value read as a Java <code>int</code>.\n+    *\n+    * @exception EOFException If end of file is reached before reading the value\n+    * @exception IOException If any other error occurs\n+    *\n+    * @see DataOutput\n+    */\n+  int readUnsignedByte() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads a Java <code>char</code> value from an input stream.  \n+    * It operates by reading two bytes from the stream and converting them to \n+    * a single 16-bit Java <code>char</code>.  The two bytes are stored most\n+    * significant byte first (i.e., \"big endian\") regardless of the native\n+    * host byte ordering. \n+    * <p>\n+    * As an example, if <code>byte1</code> and <code>byte2</code> represent the\n+    * first and second byte read from the stream respectively, they will be\n+    * transformed to a <code>char</code> in the following manner:\n+    * <p>\n+    * <code>(char)((byte1 << 8) + byte2)</code>\n+    * <p>\n+    * This method can read a <code>char</code> written by an object implementing\n+    * the\n+    * <code>writeChar()</code> method in the <code>DataOutput</code> interface.\n+    *\n+    * @return The <code>char</code> value read \n+    *\n+    * @exception EOFException If end of file is reached before reading the char\n+    * @exception IOException If any other error occurs\n+    *\n+    * @see DataOutput\n+    */\n+  char readChar() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads a signed 16-bit value into a Java in from the stream.\n+    * It operates by reading two bytes from the stream and converting them to \n+    * a single 16-bit Java <code>short</code>.  The two bytes are stored most\n+    * significant byte first (i.e., \"big endian\") regardless of the native\n+    * host byte ordering. \n+    * <p>\n+    * As an example, if <code>byte1</code> and <code>byte2</code> represent the\n+    * first and second byte read from the stream respectively, they will be\n+    * transformed to a <code>short</code> in the following manner:\n+    * <p>\n+    * <code>(short)((byte1 << 8) + byte2)</code>\n+    * <p>\n+    * The value returned is in the range of -32768 to 32767.\n+    * <p>\n+    * This method can read a <code>short</code> written by an object \n+    * implementing\n+    * the <code>writeShort()</code> method in the <code>DataOutput</code>\n+    * interface.\n+    *\n+    * @return The <code>short</code> value read\n+    *\n+    * @exception EOFException If end of file is reached before reading the value\n+    * @exception IOException If any other error occurs\n+    *\n+    * @see DataOutput\n+    */\n+  short readShort() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads 16 unsigned bits into a Java int value from the stream.\n+    * It operates by reading two bytes from the stream and converting them to \n+    * a single Java <code>int</code>.  The two bytes are stored most\n+    * significant byte first (i.e., \"big endian\") regardless of the native\n+    * host byte ordering. \n+    * <p>\n+    * As an example, if <code>byte1</code> and <code>byte2</code> represent the\n+    * first and second byte read from the stream respectively, they will be\n+    * transformed to an <code>int</code> in the following manner:\n+    * <p>\n+    * <code>(int)((byte1 << 8) + byte2)</code>\n+    * <p>\n+    * The value returned is in the range of 0 to 65535.\n+    * <p>\n+    * This method can read an unsigned short written by an object implementing\n+    * the <code>writeUnsignedShort()</code> method in the \n+    * <code>DataOutput</code>\n+    * interface.\n+    *\n+    * @return The unsigned short value read as a Java <code>int</code>.\n+    *\n+    * @exception EOFException If end of file is reached before reading \n+    * the value\n+    * @exception IOException If any other error occurs\n+    */\n+  int readUnsignedShort() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads a Java <code>int</code> value from an input stream\n+    * It operates by reading four bytes from the stream and converting them to \n+    * a single Java <code>int</code>.  The bytes are stored most\n+    * significant byte first (i.e., \"big endian\") regardless of the native\n+    * host byte ordering. \n+    * <p>\n+    * As an example, if <code>byte1</code> through <code>byte4</code> represent\n+    * the first four bytes read from the stream, they will be\n+    * transformed to an <code>int</code> in the following manner:\n+    * <p>\n+    * <code>(int)((byte1 << 24) + (byte2 << 16) + (byte3 << 8) + byte4))</code>\n+    * <p>\n+    * The value returned is in the range of -2147483648 to 2147483647.\n+    * <p>\n+    * This method can read an <code>int</code> written by an object \n+    * implementing the <code>writeInt()</code> method in the \n+    * <code>DataOutput</code> interface.\n+    *\n+    * @return The <code>int</code> value read\n+    *\n+    * @exception EOFException If end of file is reached before reading the int\n+    * @exception IOException If any other error occurs\n+    *\n+    * @see DataOutput\n+    */\n+  int readInt() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads a Java <code>long</code> value from an input stream\n+    * It operates by reading eight bytes from the stream and converting them to \n+    * a single Java <code>long</code>.  The bytes are stored most\n+    * significant byte first (i.e., \"big endian\") regardless of the native\n+    * host byte ordering. \n+    * <p>\n+    * As an example, if <code>byte1</code> through <code>byte8</code> represent\n+    * the first eight bytes read from the stream, they will be\n+    * transformed to an <code>long</code> in the following manner:\n+    * <p>\n+    * <code>(long)((byte1 << 56) + (byte2 << 48) + (byte3 << 40) + \n+    * (byte4 << 32) + (byte5 << 24) + (byte6 << 16) + (byte7 << 8) + byte9))\n+    * </code>\n+    * <p>\n+    * The value returned is in the range of -9223372036854775808 to\n+    * 9223372036854775807.\n+    * <p>\n+    * This method can read an <code>long</code> written by an object \n+    * implementing the <code>writeLong()</code> method in the \n+    * <code>DataOutput</code> interface.\n+    *\n+    * @return The <code>long</code> value read\n+    *\n+    * @exception EOFException If end of file is reached before reading the long\n+    * @exception IOException If any other error occurs\n+    *\n+    * @see DataOutput\n+    */\n+  long readLong() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads a Java float value from an input stream.  It operates\n+    * by first reading an <code>int</code> value from the stream by calling the\n+    * <code>readInt()</code> method in this interface, then converts that\n+    * <code>int</code> to a <code>float</code> using the\n+    * <code>intBitsToFloat</code> method in the class\n+    * <code>java.lang.Float</code>.\n+    * <p>\n+    * This method can read a <code>float</code> written by an object \n+    * implementing\n+    * the <code>writeFloat()</code> method in the <code>DataOutput</code>\n+    * interface.\n+    *\n+    * @return The <code>float</code> value read\n+    *\n+    * @exception EOFException If end of file is reached before reading the \n+    * float\n+    * @exception IOException If any other error occurs\n+    *\n+    * @see java.lang.Float\n+    * @see DataOutput\n+    */\n+  float readFloat() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads a Java double value from an input stream.  It operates\n+    * by first reading a <code>long</code> value from the stream by calling the\n+    * <code>readLong()</code> method in this interface, then converts that\n+    * <code>long</code> to a <code>double</code> using the\n+    * <code>longBitsToDouble</code> method in the class\n+    * <code>java.lang.Double</code>.\n+    * <p>\n+    * This method can read a <code>double</code> written by an object\n+    * implementing the <code>writeDouble()</code> method in the\n+    * <code>DataOutput</code> interface.\n+    *\n+    * @return The <code>double</code> value read\n+    *\n+    * @exception EOFException If end of file is reached before reading the \n+    * double\n+    * @exception IOException If any other error occurs\n+    *\n+    * @see java.lang.Double\n+    * @see DataOutput\n+    */\n+  double readDouble() throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads the next line of text data from an input stream.\n+    * It operates by reading bytes and converting those bytes to \n+    * <code>char</code>\n+    * values by treating the byte read as the low eight bits of the\n+    * <code>char</code> and using 0 as the high eight bits.  Because of this,\n+    * it does not support the full 16-bit Unicode character set.\n+    * <P>\n+    * The reading of bytes ends when either the end of file or a line terminator\n+    * is encountered.  The bytes read are then returned as a \n+    * <code>String</code>.\n+    * A line terminator is a byte sequence consisting of either \n+    * <code>\\r</code>, <code>\\n</code> or <code>\\r\\n</code>.  These termination\n+    * charaters are discarded and are not returned as part of the string.\n+    * <p>\n+    * This method can read data that was written by an object implementing the\n+    * <code>writeLine()</code> method in <code>DataOutput</code>.\n+    *\n+    * @return The line read as a <code>String</code>\n+    *\n+    * @exception IOException If an error occurs\n+    *\n+    * @see DataOutput\n+    */\n+  String readLine() throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads a <code>String</code> from an input stream that is\n+    * encoded in a modified UTF-8 format.  This format has a leading two byte\n+    * sequence that contains the remaining number of bytes to read.  \n+    * This two byte\n+    * sequence is read using the <code>readUnsignedShort()</code> method of this\n+    * interface.\n+    *\n+    * After the number of remaining bytes have been determined, these bytes\n+    * are read an transformed into <code>char</code> values.  These\n+    * <code>char</code> values are encoded in the stream using either a one, \n+    * two, or three byte format.\n+    * The particular format in use can be determined by examining the first\n+    * byte read.  \n+    * <p>\n+    * If the first byte has a high order bit of 0, then\n+    * that character consists on only one byte.  This character value consists\n+    * of seven bits that are at positions 0 through 6 of the byte.  As an\n+    * example, if <code>byte1</code> is the byte read from the stream, it would\n+    * be converted to a <code>char</code> like so:\n+    * <p>\n+    * <code>(char)byte1</code>\n+    * <p>\n+    * If the first byte has 110 as its high order bits, then the \n+    * character consists of two bytes.  The bits that make up the character\n+    * value are in positions 0 through 4 of the first byte and bit positions\n+    * 0 through 5 of the second byte.  (The second byte should have \n+    * 10 as its high order bits).  These values are in most significant\n+    * byte first (i.e., \"big endian\") order.\n+    * <p>\n+    * As an example, if <code>byte1</code> and <code>byte2</code> are the first\n+    * two bytes read respectively, and the high order bits of them match the\n+    * patterns which indicate a two byte character encoding, then they would be\n+    * converted to a Java <code>char</code> like so:\n+    * <p>\n+    * <code>(char)(((byte1 & 0x1F) << 6) + (byte2 & 0x3F))</code>\n+    * <p>\n+    * If the first byte has a 1110 as its high order bits, then the\n+    * character consists of three bytes.  The bits that make up the character\n+    * value are in positions 0 through 3 of the first byte and bit positions\n+    * 0 through 5 of the other two bytes.  (The second and third bytes should\n+    * have 10 as their high order bits).  These values are in most\n+    * significant byte first (i.e., \"big endian\") order.\n+    * <p>\n+    * As an example, if <code>byte1</code>, <code>byte2</code>, and\n+    * <code>byte3</code> are the three bytes read, and the high order bits of\n+    * them match the patterns which indicate a three byte character encoding,\n+    * then they would be converted to a Java <code>char</code> like so:\n+    *\n+    * <code>\n+    * (char)(((byte1 & 0x0F) << 12) + ((byte2 & 0x3F) + (byte3 & 0x3F))\n+    * </code>\n+    *\n+    * Note that all characters are encoded in the method that requires the\n+    * fewest number of bytes with the exception of the character with the\n+    * value of <code>\\<llll>u0000</code> which is encoded as two bytes.  \n+    * This is a modification of the UTF standard used to prevent C language \n+    * style <code>NUL</code> values from appearing in the byte stream.\n+    * <p>\n+    * This method can read data that was written by an object implementing the\n+    * <code>writeUTF()</code> method in <code>DataOutput</code>.\n+    * \n+    * @returns The <code>String</code> read\n+    *\n+    * @exception EOFException If end of file is reached before reading the \n+    * String\n+    * @exception UTFDataFormatException If the data is not in UTF-8 format\n+    * @exception IOException If any other error occurs\n+    *\n+    * @see DataOutput\n+    */\n+  String readUTF() throws EOFException, UTFDataFormatException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads raw bytes into the passed array until the array is\n+    * full.  Note that this method blocks until the data is available and\n+    * throws an exception if there is not enough data left in the stream to\n+    * fill the buffer\n+    *\n+    * @param buf The buffer into which to read the data\n+    *\n+    * @exception EOFException If end of file is reached before filling the \n+    * buffer\n+    * @exception IOException If any other error occurs\n+    */\n+  void readFully(byte[] buf) throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method reads raw bytes into the passed array <code>buf</code> \n+    * starting\n+    * <code>offset</code> bytes into the buffer.  The number of bytes read \n+    * will be\n+    * exactly <code>len</code>.  Note that this method blocks until the data is \n+    * available and * throws an exception if there is not enough data left in \n+    * the stream to read <code>len</code> bytes.\n+    *\n+    * @param buf The buffer into which to read the data\n+    * @param offset The offset into the buffer to start storing data\n+    * @param len The number of bytes to read into the buffer\n+    *\n+    * @exception EOFException If end of file is reached before filling the \n+    * buffer\n+    * @exception IOException If any other error occurs\n+    */\n+  void readFully(byte[] buf, int offset, int len) \n+    throws EOFException, IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method skips and discards the specified number of bytes in an\n+    * input stream\n+    *\n+    * @param num_bytes The number of bytes to skip\n+    *\n+    * @return The number of bytes actually skipped, which will always be\n+    *         <code>num_bytes</code>\n+    *\n+    * @exception EOFException If end of file is reached before all bytes can be\n+    *                         skipped\n+    * @exception IOException If any other error occurs\n+    */\n+  int skipBytes(int n) throws EOFException, IOException;\n \n } // interface DataInput"}, {"sha": "626da900b59c5c4b393ed20985e10c5b3038ddeb", "filename": "libjava/java/io/DataInputStream.java", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FDataInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FDataInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInputStream.java?ref=fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "patch": "@@ -1,5 +1,5 @@\n /* DataInputStream.java -- FilteredInputStream that implements DataInput\n-   Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+   Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -50,8 +50,6 @@\n  *\n  * @see DataInput\n  *\n- * @version 0.0\n- *\n  * @author Warren Levy <warrenl@cygnus.com>\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @date October 20, 1998.  "}, {"sha": "4721f526ac74dec965367301624f452f76cae1ce", "filename": "libjava/java/io/DataOutput.java", "status": "modified", "additions": 160, "deletions": 171, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FDataOutput.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FDataOutput.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataOutput.java?ref=fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "patch": "@@ -53,176 +53,165 @@\n public interface DataOutput\n {\n \n-/**\n-  * This method writes a Java boolean value to an output stream\n-  *\n-  * @param value The boolean value to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeBoolean(boolean value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a Java byte value to an output stream\n-  *\n-  * @param value The int value to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeByte(int value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a Java char value to an output stream\n-  *\n-  * @param value The char value to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeChar(int value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a Java int value to an output stream as a 16 bit value\n-  *\n-  * @param value The int value to write as a 16-bit value\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeShort(int value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a Java int value to an output stream\n-  *\n-  * @param value The int value to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeInt(int value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a Java long value to an output stream\n-  *\n-  * @param value The long value to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeLong(long value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a Java float value to an output stream\n-  *\n-  * @param value The float value to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeFloat(float value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a Java double value to an output stream\n-  *\n-  * @param value The double value to write\n-  *\n-  * @exception IOException If any other error occurs\n-  */\n-void\n-writeDouble(double value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a String to an output stream as an array of bytes\n-  *\n-  * @param value The String to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeBytes(String value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a String to an output stream as an array of char's\n-  *\n-  * @param value The String to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeChars(String value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes a String to an output stream encoded in\n-  * UTF-8 format.\n-  *\n-  * @param value The String to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-writeUTF(String value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes an 8-bit value (passed into the method as a Java\n-  * int) to an output stream.\n-  *\n-  * @param value The byte to write to the output stream\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-write(int value) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes the raw byte array passed in to the output stream.\n-  *\n-  * @param buf The byte array to write\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-void\n-write(byte[] buf) throws IOException;\n-\n-/*************************************************************************/\n-\n-/**\n-  * This method writes raw bytes from the passed array <code>buf</code> starting\n-  * <code>offset</code> bytes into the buffer.  The number of bytes written will be\n-  * exactly <code>len</code>. \n-  *\n-  * @param buf The buffer from which to write the data\n-  * @param offset The offset into the buffer to start writing data from\n-  * @param len The number of bytes to write from the buffer to the output stream\n-  *\n-  * @exception IOException If any other error occurs\n-  */\n-void\n-write(byte[] buf, int offset, int len) throws IOException;\n+  /**\n+    * This method writes a Java boolean value to an output stream\n+    *\n+    * @param value The boolean value to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeBoolean(boolean value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a Java byte value to an output stream\n+    *\n+    * @param value The int value to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeByte(int value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a Java char value to an output stream\n+    *\n+    * @param value The char value to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeChar(int value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a Java int value to an output stream as a 16 bit value\n+    *\n+    * @param value The int value to write as a 16-bit value\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeShort(int value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a Java int value to an output stream\n+    *\n+    * @param value The int value to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeInt(int value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a Java long value to an output stream\n+    *\n+    * @param value The long value to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeLong(long value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a Java float value to an output stream\n+    *\n+    * @param value The float value to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeFloat(float value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a Java double value to an output stream\n+    *\n+    * @param value The double value to write\n+    *\n+    * @exception IOException If any other error occurs\n+    */\n+  void writeDouble(double value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a String to an output stream as an array of bytes\n+    *\n+    * @param value The String to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeBytes(String value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a String to an output stream as an array of char's\n+    *\n+    * @param value The String to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeChars(String value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes a String to an output stream encoded in\n+    * UTF-8 format.\n+    *\n+    * @param value The String to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void writeUTF(String value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes an 8-bit value (passed into the method as a Java\n+    * int) to an output stream.\n+    *\n+    * @param value The byte to write to the output stream\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void write(int value) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes the raw byte array passed in to the output stream.\n+    *\n+    * @param buf The byte array to write\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  void write(byte[] buf) throws IOException;\n+\n+  /*************************************************************************/\n+\n+  /**\n+    * This method writes raw bytes from the passed array <code>buf</code> \n+    * starting\n+    * <code>offset</code> bytes into the buffer.  The number of bytes \n+    * written will be * exactly <code>len</code>. \n+    *\n+    * @param buf The buffer from which to write the data\n+    * @param offset The offset into the buffer to start writing data from\n+    * @param len The number of bytes to write from the buffer to the output \n+    * stream\n+    *\n+    * @exception IOException If any other error occurs\n+    */\n+  void write(byte[] buf, int offset, int len) throws IOException;\n \n } // interface DataOutput\n+"}, {"sha": "f6406b0335aea6d704cbf0079d64dbc48b654041", "filename": "libjava/java/io/Externalizable.java", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FExternalizable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fddab7dc9b09a03abf7e066fdf88fbf00b2bab89/libjava%2Fjava%2Fio%2FExternalizable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FExternalizable.java?ref=fddab7dc9b09a03abf7e066fdf88fbf00b2bab89", "patch": "@@ -56,55 +56,58 @@\n   * created using the default no-argument constructor and the \n   * <code>readExternal</code> method is used to restore the state.\n   *\n-  * @version 0.0\n-  *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n   */\n public interface Externalizable extends Serializable\n {\n   static final long serialVersionUID = -282491828744381764L;\n \n-/**\n-  * This method restores an object's state by reading in the instance data\n-  * for the object from the passed in stream.  Note that this stream is not\n-  * a subclass of <code>InputStream</code>, but rather is a class that implements\n-  * the <code>ObjectInput</code> interface.  That interface provides a mechanism for\n-  * reading in Java data types from a stream.\n-  * <p>\n-  * Note that this method must be compatible with <code>writeExternal</code>.\n-  * It must read back the exact same types that were written by that\n-  * method in the exact order they were written.\n-  * <p>\n-  * If this method needs to read back an object instance, then the class\n-  * for that object must be found and loaded.  If that operation fails,\n-  * then this method throws a <code>ClassNotFoundException</code>\n-  *\n-  * @param in An <code>ObjectInput</code> instance for reading in the object state\n-  *\n-  * @exception ClassNotFoundException If the class of an object being restored cannot be found\n-  * @exception IOException If any other error occurs\n-  */\n-public abstract void\n-readExternal(ObjectInput in) throws ClassNotFoundException, IOException;\n+  /**\n+    * This method restores an object's state by reading in the instance data\n+    * for the object from the passed in stream.  Note that this stream is not\n+    * a subclass of <code>InputStream</code>, but rather is a class that \n+    * implements\n+    * the <code>ObjectInput</code> interface.  That interface provides a \n+    * mechanism for\n+    * reading in Java data types from a stream.\n+    * <p>\n+    * Note that this method must be compatible with <code>writeExternal</code>.\n+    * It must read back the exact same types that were written by that\n+    * method in the exact order they were written.\n+    * <p>\n+    * If this method needs to read back an object instance, then the class\n+    * for that object must be found and loaded.  If that operation fails,\n+    * then this method throws a <code>ClassNotFoundException</code>\n+    *\n+    * @param in An <code>ObjectInput</code> instance for reading in the object \n+    * state\n+    *\n+    * @exception ClassNotFoundException If the class of an object being \n+    * restored cannot be found\n+    * @exception IOException If any other error occurs\n+    */\n+  public abstract void readExternal(ObjectInput in) \n+    throws ClassNotFoundException, IOException;\n \n-/*************************************************************************/\n+  /*************************************************************************/\n \n-/**\n-  * This method is responsible for writing the instance data of an object\n-  * to the passed in stream.  Note that this stream is not a subclass of\n-  * <code>OutputStream</code>, but rather is a class that implements the\n-  * <code>ObjectOutput</code> interface.  That interface provides a number of methods\n-  * for writing Java data values to a stream.\n-  * <p>\n-  * Not that the implementation of this method must be coordinated with\n-  * the implementation of <code>readExternal</code>.\n-  *\n-  * @param out An <code>ObjectOutput</code> instance for writing the object state\n-  *\n-  * @exception IOException If an error occurs\n-  */\n-public abstract void\n-writeExternal(ObjectOutput out) throws IOException;\n+  /**\n+    * This method is responsible for writing the instance data of an object\n+    * to the passed in stream.  Note that this stream is not a subclass of\n+    * <code>OutputStream</code>, but rather is a class that implements the\n+    * <code>ObjectOutput</code> interface.  That interface provides a \n+    * number of methods\n+    * for writing Java data values to a stream.\n+    * <p>\n+    * Not that the implementation of this method must be coordinated with\n+    * the implementation of <code>readExternal</code>.\n+    *\n+    * @param out An <code>ObjectOutput</code> instance for writing the \n+    * object state\n+    *\n+    * @exception IOException If an error occurs\n+    */\n+  public abstract void writeExternal(ObjectOutput out) throws IOException;\n \n } // interface Externalizable\n "}]}