{"sha": "07095a8b8f63625d9535540e14fdc0c32ee43391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDcwOTVhOGI4ZjYzNjI1ZDk1MzU1NDBlMTRmZGMwYzMyZWU0MzM5MQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-09-11T21:13:01Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-09-11T21:13:01Z"}, "message": "Remove trailing whitespace from lines\n\nFrom-SVN: r29283", "tree": {"sha": "dfc366f019a93ac16d08d0597868851d20f510be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfc366f019a93ac16d08d0597868851d20f510be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07095a8b8f63625d9535540e14fdc0c32ee43391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07095a8b8f63625d9535540e14fdc0c32ee43391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07095a8b8f63625d9535540e14fdc0c32ee43391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07095a8b8f63625d9535540e14fdc0c32ee43391/comments", "author": null, "committer": null, "parents": [{"sha": "a611912f138414f88cdfac7fbcb4747160e9b46b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a611912f138414f88cdfac7fbcb4747160e9b46b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a611912f138414f88cdfac7fbcb4747160e9b46b"}], "stats": {"total": 32, "additions": 16, "deletions": 16}, "files": [{"sha": "36ac81e0fdfcec01d8ebeabb977ab5248e7ac2b6", "filename": "gcc/genrecog.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07095a8b8f63625d9535540e14fdc0c32ee43391/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07095a8b8f63625d9535540e14fdc0c32ee43391/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=07095a8b8f63625d9535540e14fdc0c32ee43391", "patch": "@@ -176,7 +176,7 @@ static struct pred_table\n \n static struct decision_head make_insn_sequence PROTO((rtx, enum routine_type));\n static struct decision *add_to_sequence PROTO((rtx, struct decision_head *,\n-\t\t\t\t\t       const char *, \n+\t\t\t\t\t       const char *,\n \t\t\t\t\t       enum routine_type, int));\n static int not_both_true\tPROTO((struct decision *, struct decision *,\n \t\t\t\t       int));\n@@ -243,9 +243,9 @@ make_insn_sequence (insn, type)\n \tlast_real_name = name;\n \tlast_real_code = next_insn_code;\n       }\n-  \n+\n     insn_name_ptr[next_insn_code] = name;\n-  }  \n+  }\n \n   if (type == PEEPHOLE2)\n     {\n@@ -554,7 +554,7 @@ add_to_sequence (pattern, last, position, insn_type, top)\n \t  fatal (\"mode mismatch in SET\");\n \t}\n       newpos[depth] = '0';\n-      new = add_to_sequence (SET_DEST (pattern), &new->success, newpos, \n+      new = add_to_sequence (SET_DEST (pattern), &new->success, newpos,\n \t\t\t     insn_type, 0);\n       this->success.first->enforce_mode = 1;\n       newpos[depth] = '1';\n@@ -572,7 +572,7 @@ add_to_sequence (pattern, last, position, insn_type, top)\n     case ZERO_EXTEND:\n     case STRICT_LOW_PART:\n       newpos[depth] = '0';\n-      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos, \n+      new = add_to_sequence (XEXP (pattern, 0), &new->success, newpos,\n \t\t\t     insn_type, 0);\n       this->success.first->enforce_mode = 1;\n       return new;\n@@ -608,7 +608,7 @@ add_to_sequence (pattern, last, position, insn_type, top)\n \tbreak;\n \n       /* ... fall through ...  */\n-      \n+\n     case COMPARE:\n       /* Enforce the mode on the first operand to avoid ambiguous insns.  */\n       newpos[depth] = '0';\n@@ -619,7 +619,7 @@ add_to_sequence (pattern, last, position, insn_type, top)\n       new = add_to_sequence (XEXP (pattern, 1), &new->success, newpos,\n \t\t\t     insn_type, 0);\n       return new;\n-      \n+\n     default:\n       break;\n     }\n@@ -870,7 +870,7 @@ merge_trees (oldh, addh)\n       /* The semantics of pattern matching state that the tests are done in\n \t the order given in the MD file so that if an insn matches two\n \t patterns, the first one will be used.  However, in practice, most,\n-\t if not all, patterns are unambiguous so that their order is \n+\t if not all, patterns are unambiguous so that their order is\n \t independent.  In that case, we can merge identical tests and\n \t group all similar modes and codes together.\n \n@@ -881,7 +881,7 @@ merge_trees (oldh, addh)\n \t the same code and mode and the last one that tests just the same mode.\n \n \t If we have no match, place NEW after the closest match we found.  */\n-\t \n+\n       for (old = oldh.last; old; old = old->prev)\n \t{\n \t  int our_merit;\n@@ -1183,7 +1183,7 @@ static const char *indents[]\n \n    We generate two nested switch statements, the outer statement for\n    testing modes, and the inner switch for testing RTX codes.  It is\n-   not worth optimizing cases when only a small number of modes or \n+   not worth optimizing cases when only a small number of modes or\n    codes is tested, since the compiler can do that when compiling the\n    resulting function.   We do check for when every test is the same mode\n    or code.  */\n@@ -1225,7 +1225,7 @@ write_tree_1 (tree, prevpos, afterward, type)\n      done.  The exception is a branch from a node that does not test a\n      mode or code to one that does.  In such cases, we set the `retest_mode'\n      or `retest_code' flags.  That will ensure that we start a new switch\n-     at that position and put the label before the switch. \n+     at that position and put the label before the switch.\n \n      The branches in the latter case must set the position to that of the\n      target node.  */\n@@ -1566,7 +1566,7 @@ write_tree_1 (tree, prevpos, afterward, type)\n \t      inner_indent -= 2;\n \t      printf (\"%s}\\n\", indents[inner_indent]);\n \t    }\n-\t  else\t    \n+\t  else\n \t    {\n \t      if (p->num_clobbers_to_add)\n \t\t{\n@@ -1756,7 +1756,7 @@ write_tree (tree, prevpos, afterward, initial, type)\n    actions are necessary to move to NEWPOS. If we fail to move to the\n    new state, branch to node AFTERWARD if non-zero, otherwise return.\n \n-   INDENT says how many blanks to place at the front of lines.  \n+   INDENT says how many blanks to place at the front of lines.\n \n    Failure to move to the new state can only occur if we are trying to\n    match multiple insns and we try to step past the end of the\n@@ -1802,12 +1802,12 @@ change_state (oldpos, newpos, indent, afterward)\n \t  /* We can only fail if we're moving down the tree.  */\n \t  if (old_has_insn >= 0 && oldpos[old_has_insn] >= newpos[depth])\n \t    {\n-\t      printf (\"%s_last_insn = recog_next_insn (insn, %d);\\n\", \n+\t      printf (\"%s_last_insn = recog_next_insn (insn, %d);\\n\",\n \t\t      indents[indent], newpos[depth] - 'A');\n \t    }\n \t  else\n \t    {\n-\t      printf (\"%stem = recog_next_insn (insn, %d);\\n\", \n+\t      printf (\"%stem = recog_next_insn (insn, %d);\\n\",\n \t\t      indents[indent], newpos[depth] - 'A');\n \n \t      printf (\"%sif (tem == NULL_RTX)\\n\", indents[indent]);\n@@ -1931,7 +1931,7 @@ from the machine description file `md'.  */\\n\\n\");\n       else if (GET_CODE (desc) == DEFINE_PEEPHOLE2)\n \tpeephole2_tree = merge_trees (peephole2_tree,\n \t\t\t\t      make_insn_sequence (desc, PEEPHOLE2));\n-\t\n+\n       if (GET_CODE (desc) == DEFINE_PEEPHOLE\n \t  || GET_CODE (desc) == DEFINE_EXPAND)\n \tnext_insn_code++;"}]}