{"sha": "1e60a96e070d15f5daaed0f4966d042640d2ad59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU2MGE5NmUwNzBkMTVmNWRhYWVkMGY0OTY2ZDA0MjY0MGQyYWQ1OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-26T07:03:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-26T07:03:44Z"}, "message": "fix thinko\n\nFrom-SVN: r15719", "tree": {"sha": "31e7420b00982a04ff631ca7160bcfbde96a0366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31e7420b00982a04ff631ca7160bcfbde96a0366"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e60a96e070d15f5daaed0f4966d042640d2ad59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e60a96e070d15f5daaed0f4966d042640d2ad59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e60a96e070d15f5daaed0f4966d042640d2ad59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e60a96e070d15f5daaed0f4966d042640d2ad59/comments", "author": null, "committer": null, "parents": [{"sha": "3055528c86920967f163f990599d6b0810a47a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3055528c86920967f163f990599d6b0810a47a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3055528c86920967f163f990599d6b0810a47a97"}], "stats": {"total": 179, "additions": 95, "deletions": 84}, "files": [{"sha": "38fd5289d86397501b44c590a18ba3e8a09aa71d", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 94, "deletions": 84, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60a96e070d15f5daaed0f4966d042640d2ad59/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60a96e070d15f5daaed0f4966d042640d2ad59/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=1e60a96e070d15f5daaed0f4966d042640d2ad59", "patch": "@@ -1,22 +1,107 @@\n *** Changes since G++ version 2.7.2:\n \n-* A public review copy of the December 1996 Draft of the ANSI C++\n+* A public review copy of the December 1996 Draft of the ANSI/ISO C++\n   proto-standard is now available. See\n \n \thttp://www.cygnus.com/misc/wp/\n \n   for more information.\n \n-* Member function templates are now supported.\n+* g++ now uses a new implementation of templates. The basic idea is that\n+  now templates are minimally parsed when seen and then expanded later.\n+  This allows conformant early name binding and instantiation controls,\n+  since instantiations no longer have to go through the parser.\n+\n+  What you get:\n+\n+     + Inlining of template functions works without any extra effort or\n+       modifications.\n+\n+     + Instantiations of class templates and methods defined in the class\n+       body are deferred until they are actually needed (unless\n+       -fexternal-templates is specified).\n+\n+     + Nested types in class templates work.\n+\n+     + Static data member templates work.\n+\n+     + Member function templates are now supported.\n+\n+     + Partial specialization of class templates is now supported.\n+\n+     + The new 'template <>' specialization syntax is now accepted and\n+       ignored.\n+\n+     + Explicit instantiation of template constructors and destructors is\n+       now supported. Use the following source code, as an example.\n+\n+       template A<int>::A(const A&);\n+\n+  Possible problems (caused by complying with the ANSI/ISO draft):\n+\n+     + Types and class templates used in templates must be declared\n+       first, or the compiler will assume they are not types, and fail.\n+\n+     + Similarly, nested types of template type parameters must be tagged\n+       with the 'typename' keyword.  In many cases, the compiler will tell\n+       you where you need to add 'typename'.\n+\n+     + Syntax errors in templates that are never instantiated will now be\n+       diagnosed.\n+\n+  Other features:\n+\n+     + Default function arguments in templates will not be evaluated (or\n+       checked for semantic validity) unless they are needed.  Default\n+       arguments in class bodies will not be parsed until the class\n+       definition is complete.\n+\n+     + The -ftemplate-depth-NN flag can be used to increase the maximum\n+       recursive template instantiation depth, defaulting to 17. If you need\n+       to use this flag, the compiler will tell you.\n+\n+  Still not supported:\n+\n+     + Template template parameters.\n+\n+* Exception handling support has been significantly improved and is on by\n+  default.  This can result in significant runtime overhead.  You can turn\n+  it off with -fno-exceptions.\n+\n+* Synthesized methods are now emitted in any translation units that need\n+  an out-of-line copy. They are no longer affected by #pragma interface\n+  or #pragma implementation.\n+\n+* On ELF systems, duplicate copies of symbols with 'initialized common'\n+  linkage (such as template instantiations, vtables, and extern inlines)\n+  will now be discarded by the GNU linker, so you don't need to use -frepo.\n+  This support requires GNU ld from binutils 2.8 or later.\n \n * __FUNCTION__ and __PRETTY_FUNCTION__ are now treated as variables by the\n   parser; previously they were treated as string constants.  So code like\n   `printf (__FUNCTION__ \": foo\")' must be rewritten to \n   `printf (\"%s: foo\", __FUNCTION__)'.  This is necessary for templates.\n \n-* New flags -Wsign-promo (warn about potentially confusing promotions in\n-  overload resolution), -Wno-pmf-conversion (don't warn about converting\n-  from a bound member function pointer to function pointer).\n+* New flags:\n+\n+     + New flags -Wsign-promo (warn about potentially confusing promotions\n+       in overload resolution), -Wno-pmf-conversion (don't warn about\n+       converting from a bound member function pointer to function pointer).\n+\n+     + A flag -Weffc++ has been added for violations of some of the style \n+       guidelines in Scott Meyers' _Effective C++_ books.\n+\n+     + -Woverloaded-virtual now warns if a virtual function in a base\n+       class is hidden in a derived class, rather than warning about\n+       virtual functions being overloaded (even if all of the inherited\n+       signatures are overridden) as it did before.\n+\n+     + -Wall no longer implies -W.  The new warning flag, -Wsign-compare,\n+        included in -Wall, warns about dangerous comparisons of signed and\n+        unsigned values. Only the flag is new; it was previously part of\n+        -W.\n+\n+     + The new flag, -fno-weak, disables the use of weak symbols.\n \n * local static variables in extern inline functions will be shared between\n   translation units.\n@@ -25,15 +110,11 @@\n   as an alias for global scope.  General namespaces are still not supported.\n \n * -fvtable-thunks is supported for all targets, and is the default for \n-  Linux with glibc (libc 6 on x86).\n+  Linux with glibc 2.x (also called libc 6.x).\n \n-* Default function arguments in templates will not be evaluated (or\n-  checked for semantic validity) unless they are needed.  Default arguments\n-  in class bodies will not be parsed until the class definition is complete.\n-\n-* The -ftemplate-depth-NN flag can be used to increase the maximum\n-  recursive template instantiation depth, defaulting to 17. If you need\n-  to use this flag, the compiler will tell you.\n+* RTTI support has been rewritten to work properly and is now on by default.\n+  This means code that uses virtual functions will have a modest space\n+  overhead.  You can use the -fno-rtti flag to disable RTTI support.\n \n * The internal interface between RTTI-using code and the RTTI support\n   library has changed, so code that uses dynamic_cast should be\n@@ -48,16 +129,6 @@\n \n * new (nothrow) is now supported.\n \n-* A flag -Weffc++ has been added for violations of some of the style \n-  guidelines in Scott Meyers' _Effective C++_ books.\n-\n-* On ELF systems, duplicate copies of symbols with 'initialized common'\n-  linkage (such as template instantiations, vtables, and extern inlines)\n-  will now be discarded by the GNU linker, so you don't need to use -frepo.\n-  This support requires GNU ld from binutils 2.8 or later.\n-\n-* Partial specialization of class templates is now supported.\n-\n * The overload resolution code has been rewritten to conform to the latest\n   C++ Working Paper.  Built-in operators are now considered as candidates\n   in operator overload resolution.  Function template overloading chooses\n@@ -66,10 +137,6 @@\n   still be selected with -fno-ansi-overloading, although this is not\n   supported and will be removed in a future release.\n \n-* RTTI support has been rewritten to work properly and is now on by default.\n-  This means code that uses virtual functions will have a modest space\n-  overhead.  You can use the -fno-rtti flag to disable RTTI support.\n-\n * Synthesized destructors are no longer made virtual just because the class\n   already has virtual functions, only if they override a virtual destructor\n   in a base class.  The compiler will warn if this affects your code.\n@@ -81,68 +148,16 @@\n   <stddef.h> is now defined as __null, a magic constant of type (void *)\n   normally, or (size_t) with -ansi.\n \n-* The new 'template <>' specialization syntax is now accepted and ignored.\n-\n * The name of a class is now implicitly declared in its own scope; A::A\n   refers to A.\n \n-* g++ now uses a new implementation of templates. The basic idea is that\n-  now templates are minimally parsed when seen and then expanded later.\n-  This allows conformant early name binding and instantiation controls,\n-  since instantiations no longer have to go through the parser.\n-\n-  What you get:\n-\n-     + Inlining of template functions works without any extra effort or\n-       modifications.\n-     + Instantiations of class templates and methods defined in the class\n-       body are deferred until they are actually needed (unless\n-       -fexternal-templates is specified).\n-     + Nested types in class templates work.\n-     + Static data member templates work.\n-\n-  Possible problems:\n-\n-     + Types and class templates used in templates must be declared\n-       first, or the compiler will assume they are not types, and fail.\n-     + Similarly, nested types of template type parameters must be tagged\n-       with the 'typename' keyword.  In many cases, the compiler will tell\n-       you where you need to add 'typename'.\n-     + Syntax errors in templates that are never instantiated will now be\n-       diagnosed.\n-\n-  Still not supported:\n-\n-     + Member class templates.\n-     + Template template parameters.\n-\n-* Synthesized methods are now emitted in any translation units that need\n-  an out-of-line copy. They are no longer affected by #pragma interface\n-  or #pragma implementation.\n-\n * Local classes are now supported.\n \n-* -Wall no longer implies -W.\n-  The new warning flag, -Wsign-compare, included in -Wall, warns about\n-  dangerous comparisons of signed and unsigned values. Only the flag is\n-  new; it was previously part of -W.\n-\n-* The new flag, -fno-weak, disables the use of weak symbols.\n-\n * __attribute__ can now be attached to types as well as declarations.\n \n-* -Woverloaded-virtual now warns if a virtual function in a base class is\n-  hidden in a derived class, rather than warning about virtual functions\n-  being overloaded (even if all of the inherited signatures are\n-  overridden) as it did before.\n-\n * The compiler no longer emits a warning if an ellipsis is used as a\n   function's argument list.\n \n-* Exception handling support has been significantly improved and is on by\n-  default.  This can result in significant runtime overhead.  You can turn\n-  it off with -fno-exceptions.\n-\n * Definition of nested types outside of their containing class is now\n   supported. Use the following source code, as an example.\n \n@@ -155,11 +170,6 @@\n               int member;\n        };\n \n-* Explicit instantiation of template constructors and destructors is now\n-  supported. Use the following source code, as an example.\n-\n-       template A<int>::A(const A&);\n-\n * On the HPPA, some classes that do not define a copy constructor\n   will be passed and returned in memory again so that functions\n   returning those types can be inlined."}, {"sha": "37e61369c409b1495fc29d00d657b1842ec24aa7", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e60a96e070d15f5daaed0f4966d042640d2ad59/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e60a96e070d15f5daaed0f4966d042640d2ad59/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=1e60a96e070d15f5daaed0f4966d042640d2ad59", "patch": "@@ -2435,6 +2435,7 @@ base_class:\n \n base_class.1:\n \t  typename_sub\n+\t\t{ $$ = TYPE_MAIN_DECL ($1); }\n \t| nonnested_type\n \t| SIGOF '(' expr ')'\n \t\t{"}]}