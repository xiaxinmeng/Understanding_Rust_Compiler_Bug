{"sha": "28fabd43d9d249134244eb9d7815917c7ae44b64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhmYWJkNDNkOWQyNDkxMzQyNDRlYjlkNzgxNTkxN2M3YWU0NGI2NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-12-06T10:25:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-12-06T10:25:08Z"}, "message": "genmatch.c (enum tree_code): Remove CONVERT{0,1,2} and VIEW_CONVERT{0,1,2}.\n\n2019-12-06  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (enum tree_code): Remove CONVERT{0,1,2} and\n\tVIEW_CONVERT{0,1,2}.\n\t(expr::opt_grp): Add and initialize.\n\t(lower_opt_convert): Rename to ...\n\t(lower_opt): ... and work on opt_grp, simply switching operations\n\tfrom being optional to being present or not.\n\t(has_opt_convert): Rename to ...\n\t(has_opt): ... and adjust.\n\t(parser::parse_operation): Return the optional opt_grp,\n\tremove special-casing of conditional operations and more generally\n\tparse [digit]'?'.\n\t(parser::parse_expr): Stick on the parsed opt_grp and perform\n\trough verification.\n\t(parser::parse_for): Remove now unnecessary code.\n\t(main): Likewise.\n\t* doc/match-and-simplify.texi: Mention ? now works on all\n\tunary operations and also match predicates.\n\nFrom-SVN: r279037", "tree": {"sha": "03e1b33743852bf29efdbf9d132485c89ed6ea0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03e1b33743852bf29efdbf9d132485c89ed6ea0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28fabd43d9d249134244eb9d7815917c7ae44b64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28fabd43d9d249134244eb9d7815917c7ae44b64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28fabd43d9d249134244eb9d7815917c7ae44b64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28fabd43d9d249134244eb9d7815917c7ae44b64/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7f6be76baf19eab6830870f4a63e17755552577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7f6be76baf19eab6830870f4a63e17755552577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7f6be76baf19eab6830870f4a63e17755552577"}], "stats": {"total": 167, "additions": 80, "deletions": 87}, "files": [{"sha": "cf5b66601f08fce5479ba95227a1394bea809d62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fabd43d9d249134244eb9d7815917c7ae44b64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fabd43d9d249134244eb9d7815917c7ae44b64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28fabd43d9d249134244eb9d7815917c7ae44b64", "patch": "@@ -1,3 +1,23 @@\n+2019-12-06  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (enum tree_code): Remove CONVERT{0,1,2} and\n+\tVIEW_CONVERT{0,1,2}.\n+\t(expr::opt_grp): Add and initialize.\n+\t(lower_opt_convert): Rename to ...\n+\t(lower_opt): ... and work on opt_grp, simply switching operations\n+\tfrom being optional to being present or not.\n+\t(has_opt_convert): Rename to ...\n+\t(has_opt): ... and adjust.\n+\t(parser::parse_operation): Return the optional opt_grp,\n+\tremove special-casing of conditional operations and more generally\n+\tparse [digit]'?'.\n+\t(parser::parse_expr): Stick on the parsed opt_grp and perform\n+\trough verification.\n+\t(parser::parse_for): Remove now unnecessary code.\n+\t(main): Likewise.\n+\t* doc/match-and-simplify.texi: Mention ? now works on all\n+\tunary operations and also match predicates.\n+\n 2019-12-06  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraphclones.c (cgraph_node::create_clone): Only localize toplevel"}, {"sha": "b34b8dbf7b029d733a891d5cc17a22162a273cda", "filename": "gcc/doc/match-and-simplify.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fabd43d9d249134244eb9d7815917c7ae44b64/gcc%2Fdoc%2Fmatch-and-simplify.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fabd43d9d249134244eb9d7815917c7ae44b64/gcc%2Fdoc%2Fmatch-and-simplify.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmatch-and-simplify.texi?ref=28fabd43d9d249134244eb9d7815917c7ae44b64", "patch": "@@ -380,6 +380,9 @@ patterns only.  If you want to match all four combinations you\n have access to two additional conditional converts as in\n @code{(eq (convert1@? @@1) (convert2@? @@2))}.\n \n+The support for @code{?} marking extends to all unary operations\n+including predicates you declare yourself with @code{match}.\n+\n Predicates available from the GCC middle-end need to be made\n available explicitely via @code{define_predicates}:\n "}, {"sha": "76b2551746257ce2bd56ab62ec68082aaf217f66", "filename": "gcc/genmatch.c", "status": "modified", "additions": 57, "deletions": 87, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fabd43d9d249134244eb9d7815917c7ae44b64/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fabd43d9d249134244eb9d7815917c7ae44b64/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=28fabd43d9d249134244eb9d7815917c7ae44b64", "patch": "@@ -224,12 +224,6 @@ output_line_directive (FILE *f, location_t location,\n #define DEFTREECODE(SYM, STRING, TYPE, NARGS)   SYM,\n enum tree_code {\n #include \"tree.def\"\n-CONVERT0,\n-CONVERT1,\n-CONVERT2,\n-VIEW_CONVERT0,\n-VIEW_CONVERT1,\n-VIEW_CONVERT2,\n MAX_TREE_CODES\n };\n #undef DEFTREECODE\n@@ -703,11 +697,12 @@ class expr : public operand\n   expr (id_base *operation_, location_t loc, bool is_commutative_ = false)\n     : operand (OP_EXPR, loc), operation (operation_),\n       ops (vNULL), expr_type (NULL), is_commutative (is_commutative_),\n-      is_generic (false), force_single_use (false) {}\n+      is_generic (false), force_single_use (false), opt_grp (0) {}\n   expr (expr *e)\n     : operand (OP_EXPR, e->location), operation (e->operation),\n       ops (vNULL), expr_type (e->expr_type), is_commutative (e->is_commutative),\n-      is_generic (e->is_generic), force_single_use (e->force_single_use) {}\n+      is_generic (e->is_generic), force_single_use (e->force_single_use),\n+      opt_grp (e->opt_grp) {}\n   void append_op (operand *op) { ops.safe_push (op); }\n   /* The operator and its operands.  */\n   id_base *operation;\n@@ -722,6 +717,8 @@ class expr : public operand\n   /* Whether pushing any stmt to the sequence should be conditional\n      on this expression having a single-use.  */\n   bool force_single_use;\n+  /* If non-zero, the group for optional handling.  */\n+  unsigned char opt_grp;\n   virtual void gen_transform (FILE *f, int, const char *, bool, int,\n \t\t\t      const char *, capture_info *,\n \t\t\t      dt_operand ** = 0, int = 0);\n@@ -1093,18 +1090,17 @@ lower_commutative (simplify *s, vec<simplify *>& simplifiers)\n     }\n }\n \n-/* Strip conditional conversios using operator OPER from O and its\n-   children if STRIP, else replace them with an unconditional convert.  */\n+/* Strip conditional operations using group GRP from O and its\n+   children if STRIP, else replace them with an unconditional operation.  */\n \n operand *\n-lower_opt_convert (operand *o, enum tree_code oper,\n-\t\t   enum tree_code to_oper, bool strip)\n+lower_opt (operand *o, unsigned char grp, bool strip)\n {\n   if (capture *c = dyn_cast<capture *> (o))\n     {\n       if (c->what)\n \treturn new capture (c->location, c->where,\n-\t\t\t    lower_opt_convert (c->what, oper, to_oper, strip),\n+\t\t\t    lower_opt (c->what, grp, strip),\n \t\t\t    c->value_match);\n       else\n \treturn c;\n@@ -1114,36 +1110,34 @@ lower_opt_convert (operand *o, enum tree_code oper,\n   if (!e)\n     return o;\n \n-  if (*e->operation == oper)\n+  if (e->opt_grp == grp)\n     {\n       if (strip)\n-\treturn lower_opt_convert (e->ops[0], oper, to_oper, strip);\n+\treturn lower_opt (e->ops[0], grp, strip);\n \n       expr *ne = new expr (e);\n-      ne->operation = (to_oper == CONVERT_EXPR\n-\t\t       ? get_operator (\"CONVERT_EXPR\")\n-\t\t       : get_operator (\"VIEW_CONVERT_EXPR\"));\n-      ne->append_op (lower_opt_convert (e->ops[0], oper, to_oper, strip));\n+      ne->opt_grp = 0;\n+      ne->append_op (lower_opt (e->ops[0], grp, strip));\n       return ne;\n     }\n \n   expr *ne = new expr (e);\n   for (unsigned i = 0; i < e->ops.length (); ++i)\n-    ne->append_op (lower_opt_convert (e->ops[i], oper, to_oper, strip));\n+    ne->append_op (lower_opt (e->ops[i], grp, strip));\n \n   return ne;\n }\n \n-/* Determine whether O or its children uses the conditional conversion\n-   operator OPER.  */\n+/* Determine whether O or its children uses the conditional operation \n+   group GRP.  */\n \n static bool\n-has_opt_convert (operand *o, enum tree_code oper)\n+has_opt (operand *o, unsigned char grp)\n {\n   if (capture *c = dyn_cast<capture *> (o))\n     {\n       if (c->what)\n-\treturn has_opt_convert (c->what, oper);\n+\treturn has_opt (c->what, grp);\n       else\n \treturn false;\n     }\n@@ -1152,11 +1146,11 @@ has_opt_convert (operand *o, enum tree_code oper)\n   if (!e)\n     return false;\n \n-  if (*e->operation == oper)\n+  if (e->opt_grp == grp)\n     return true;\n \n   for (unsigned i = 0; i < e->ops.length (); ++i)\n-    if (has_opt_convert (e->ops[i], oper))\n+    if (has_opt (e->ops[i], grp))\n       return true;\n \n   return false;\n@@ -1166,34 +1160,24 @@ has_opt_convert (operand *o, enum tree_code oper)\n    if required.  */\n \n static vec<operand *>\n-lower_opt_convert (operand *o)\n+lower_opt (operand *o)\n {\n   vec<operand *> v1 = vNULL, v2;\n \n   v1.safe_push (o);\n \n-  enum tree_code opers[]\n-    = { CONVERT0, CONVERT_EXPR,\n-\tCONVERT1, CONVERT_EXPR,\n-\tCONVERT2, CONVERT_EXPR,\n-\tVIEW_CONVERT0, VIEW_CONVERT_EXPR,\n-\tVIEW_CONVERT1, VIEW_CONVERT_EXPR,\n-\tVIEW_CONVERT2, VIEW_CONVERT_EXPR };\n+  /* Conditional operations are lowered to a pattern with the\n+     operation and one without.  All different conditional operation\n+     groups are lowered separately.  */\n \n-  /* Conditional converts are lowered to a pattern with the\n-     conversion and one without.  The three different conditional\n-     convert codes are lowered separately.  */\n-\n-  for (unsigned i = 0; i < sizeof (opers) / sizeof (enum tree_code); i += 2)\n+  for (unsigned i = 1; i <= 10; ++i)\n     {\n       v2 = vNULL;\n       for (unsigned j = 0; j < v1.length (); ++j)\n-\tif (has_opt_convert (v1[j], opers[i]))\n+\tif (has_opt (v1[j], i))\n \t  {\n-\t    v2.safe_push (lower_opt_convert (v1[j],\n-\t\t\t\t\t     opers[i], opers[i+1], false));\n-\t    v2.safe_push (lower_opt_convert (v1[j],\n-\t\t\t\t\t     opers[i], opers[i+1], true));\n+\t    v2.safe_push (lower_opt (v1[j], i, false));\n+\t    v2.safe_push (lower_opt (v1[j], i, true));\n \t  }\n \n       if (v2 != vNULL)\n@@ -1211,9 +1195,9 @@ lower_opt_convert (operand *o)\n    the resulting multiple patterns to SIMPLIFIERS.  */\n \n static void\n-lower_opt_convert (simplify *s, vec<simplify *>& simplifiers)\n+lower_opt (simplify *s, vec<simplify *>& simplifiers)\n {\n-  vec<operand *> matchers = lower_opt_convert (s->match);\n+  vec<operand *> matchers = lower_opt (s->match);\n   for (unsigned i = 0; i < matchers.length (); ++i)\n     {\n       simplify *ns = new simplify (s->kind, s->id, matchers[i], s->result,\n@@ -1557,7 +1541,7 @@ lower (vec<simplify *>& simplifiers, bool gimple)\n {\n   auto_vec<simplify *> out_simplifiers;\n   for (unsigned i = 0; i < simplifiers.length (); ++i)\n-    lower_opt_convert (simplifiers[i], out_simplifiers);\n+    lower_opt (simplifiers[i], out_simplifiers);\n \n   simplifiers.truncate (0);\n   for (unsigned i = 0; i < out_simplifiers.length (); ++i)\n@@ -3966,7 +3950,7 @@ class parser\n \n   unsigned get_internal_capture_id ();\n \n-  id_base *parse_operation ();\n+  id_base *parse_operation (unsigned char &);\n   operand *parse_capture (operand *, bool);\n   operand *parse_expr ();\n   c_expr *parse_c_expr (cpp_ttype);\n@@ -4157,47 +4141,36 @@ parser::record_operlist (location_t loc, user_id *p)\n    convert2?  */\n \n id_base *\n-parser::parse_operation ()\n+parser::parse_operation (unsigned char &opt_grp)\n {\n   const cpp_token *id_tok = peek ();\n+  char *alt_id = NULL;\n   const char *id = get_ident ();\n   const cpp_token *token = peek ();\n-  if (strcmp (id, \"convert0\") == 0)\n-    fatal_at (id_tok, \"use 'convert?' here\");\n-  else if (strcmp (id, \"view_convert0\") == 0)\n-    fatal_at (id_tok, \"use 'view_convert?' here\");\n+  opt_grp = 0;\n   if (token->type == CPP_QUERY\n       && !(token->flags & PREV_WHITE))\n     {\n-      if (strcmp (id, \"convert\") == 0)\n-\tid = \"convert0\";\n-      else if (strcmp (id, \"convert1\") == 0)\n-\t;\n-      else if (strcmp (id, \"convert2\") == 0)\n-\t;\n-      else if (strcmp (id, \"view_convert\") == 0)\n-\tid = \"view_convert0\";\n-      else if (strcmp (id, \"view_convert1\") == 0)\n-\t;\n-      else if (strcmp (id, \"view_convert2\") == 0)\n-\t;\n-      else\n-\tfatal_at (id_tok, \"non-convert operator conditionalized\");\n-\n       if (!parsing_match_operand)\n \tfatal_at (id_tok, \"conditional convert can only be used in \"\n \t\t  \"match expression\");\n+      if (ISDIGIT (id[strlen (id) - 1]))\n+\t{\n+\t  opt_grp = id[strlen (id) - 1] - '0' + 1;\n+\t  alt_id = xstrdup (id);\n+\t  alt_id[strlen (id) - 1] = '\\0';\n+\t  if (opt_grp == 1)\n+\t    fatal_at (id_tok, \"use '%s?' here\", alt_id);\n+\t}\n+      else\n+\topt_grp = 1;\n       eat_token (CPP_QUERY);\n     }\n-  else if (strcmp (id, \"convert1\") == 0\n-\t   || strcmp (id, \"convert2\") == 0\n-\t   || strcmp (id, \"view_convert1\") == 0\n-\t   || strcmp (id, \"view_convert2\") == 0)\n-    fatal_at (id_tok, \"expected '?' after conditional operator\");\n-  id_base *op = get_operator (id);\n+  id_base *op = get_operator (alt_id ? alt_id : id);\n   if (!op)\n-    fatal_at (id_tok, \"unknown operator %s\", id);\n-\n+    fatal_at (id_tok, \"unknown operator %s\", alt_id ? alt_id : id);\n+  if (alt_id)\n+    free (alt_id);\n   user_id *p = dyn_cast<user_id *> (op);\n   if (p && p->is_oper_list)\n     {\n@@ -4253,7 +4226,8 @@ class operand *\n parser::parse_expr ()\n {\n   const cpp_token *token = peek ();\n-  expr *e = new expr (parse_operation (), token->src_loc);\n+  unsigned char opt_grp;\n+  expr *e = new expr (parse_operation (opt_grp), token->src_loc);\n   token = peek ();\n   operand *op;\n   bool is_commutative = false;\n@@ -4349,6 +4323,12 @@ parser::parse_expr ()\n \t\t\t  \"commutative\");\n \t    }\n \t  e->expr_type = expr_type;\n+\t  if (opt_grp != 0)\n+\t    {\n+\t      if (e->ops.length () != 1)\n+\t\tfatal_at (token, \"only unary operations can be conditional\");\n+\t      e->opt_grp = opt_grp;\n+\t    }\n \t  return op;\n \t}\n       else if (!(token->flags & PREV_WHITE))\n@@ -4731,10 +4711,6 @@ parser::parse_for (location_t)\n \t  id_base *idb = get_operator (oper, true);\n \t  if (idb == NULL)\n \t    fatal_at (token, \"no such operator '%s'\", oper);\n-\t  if (*idb == CONVERT0 || *idb == CONVERT1 || *idb == CONVERT2\n-\t      || *idb == VIEW_CONVERT0 || *idb == VIEW_CONVERT1\n-\t      || *idb == VIEW_CONVERT2)\n-\t    fatal_at (token, \"conditional operators cannot be used inside for\");\n \n \t  if (arity == -1)\n \t    arity = idb->nargs;\n@@ -5141,12 +5117,6 @@ main (int argc, char **argv)\n   add_operator (SYM, # SYM, # TYPE, NARGS);\n #define END_OF_BASE_TREE_CODES\n #include \"tree.def\"\n-add_operator (CONVERT0, \"convert0\", \"tcc_unary\", 1);\n-add_operator (CONVERT1, \"convert1\", \"tcc_unary\", 1);\n-add_operator (CONVERT2, \"convert2\", \"tcc_unary\", 1);\n-add_operator (VIEW_CONVERT0, \"view_convert0\", \"tcc_unary\", 1);\n-add_operator (VIEW_CONVERT1, \"view_convert1\", \"tcc_unary\", 1);\n-add_operator (VIEW_CONVERT2, \"view_convert2\", \"tcc_unary\", 1);\n #undef END_OF_BASE_TREE_CODES\n #undef DEFTREECODE\n "}]}