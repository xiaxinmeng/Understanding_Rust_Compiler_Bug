{"sha": "7b2cf5041460859ca4f58e5da1308b7ef9129d8b", "node_id": "C_kwDOANBUbNoAKDdiMmNmNTA0MTQ2MDg1OWNhNGY1OGU1ZGExMzA4YjdlZjkxMjlkOGI", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-12-22T08:36:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-12-22T11:21:06Z"}, "message": "tree-optimization/107451 - SLP load vectorization issue\n\nWhen vectorizing SLP loads with permutations we can access excess\nelements when the load vector type is bigger than the group size\nand the vectorization factor covers less groups than necessary\nto fill it.  Since we know the code will only access up to\ngroup_size * VF elements in the unpermuted vector we can simply\nfill the rest of the vector with whatever we want.  For simplicity\nthis patch chooses to repeat the last group.\n\n\tPR tree-optimization/107451\n\t* tree-vect-stmts.cc (vectorizable_load): Avoid loading\n\tSLP group members from group numbers in excess of the\n\tvectorization factor.\n\n\t* gcc.dg/torture/pr107451.c: New testcase.", "tree": {"sha": "a34b605c914848d8c3aef462b5b0049ea3847989", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a34b605c914848d8c3aef462b5b0049ea3847989"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b2cf5041460859ca4f58e5da1308b7ef9129d8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b2cf5041460859ca4f58e5da1308b7ef9129d8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b2cf5041460859ca4f58e5da1308b7ef9129d8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b2cf5041460859ca4f58e5da1308b7ef9129d8b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b30e9bc211fede06cf85b54e466012540bef14d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b30e9bc211fede06cf85b54e466012540bef14d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b30e9bc211fede06cf85b54e466012540bef14d"}], "stats": {"total": 47, "additions": 41, "deletions": 6}, "files": [{"sha": "a17574c6896ab68e03f85f0060408f366e906adb", "filename": "gcc/testsuite/gcc.dg/torture/pr107451.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b2cf5041460859ca4f58e5da1308b7ef9129d8b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr107451.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b2cf5041460859ca4f58e5da1308b7ef9129d8b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr107451.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr107451.c?ref=7b2cf5041460859ca4f58e5da1308b7ef9129d8b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-ftree-vectorize -fno-vect-cost-model\" } */\n+/* { dg-additional-options \"-mavx2\" { target avx2_runtime } } */\n+\n+double getdot(int n, const double *x, int inc_x, const double *y)\n+{\n+  int i, ix = 0;\n+  double dot[4] = { 0.0, 0.0, 0.0, 0.0 } ;\n+\n+  for(i = 0; i < n; i++) {\n+      dot[0] += x[ix]   * y[ix]   ;\n+      dot[1] += x[ix+1] * y[ix+1] ;\n+      dot[2] += x[ix]   * y[ix+1] ;\n+      dot[3] += x[ix+1] * y[ix]   ;\n+      ix += inc_x ;\n+  }\n+\n+  return dot[0] + dot[1] + dot[2] + dot[3];\n+}\n+\n+int main()\n+{\n+  double x[2] = {0, 0}, y[2] = {0, 0};\n+  if (getdot(1, x, 4096*4096, y) != 0.)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "8f8deaf82bc86d3e0288019abd653d57ac3be347", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b2cf5041460859ca4f58e5da1308b7ef9129d8b/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b2cf5041460859ca4f58e5da1308b7ef9129d8b/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=7b2cf5041460859ca4f58e5da1308b7ef9129d8b", "patch": "@@ -9235,6 +9235,7 @@ vectorizable_load (vec_info *vinfo,\n       unsigned int group_el = 0;\n       unsigned HOST_WIDE_INT\n \telsz = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n+      unsigned int n_groups = 0;\n       for (j = 0; j < ncopies; j++)\n \t{\n \t  if (nloads > 1)\n@@ -9256,12 +9257,19 @@ vectorizable_load (vec_info *vinfo,\n \t      if (! slp\n \t\t  || group_el == group_size)\n \t\t{\n-\t\t  tree newoff = copy_ssa_name (running_off);\n-\t\t  gimple *incr = gimple_build_assign (newoff, POINTER_PLUS_EXPR,\n-\t\t\t\t\t\t      running_off, stride_step);\n-\t\t  vect_finish_stmt_generation (vinfo, stmt_info, incr, gsi);\n-\n-\t\t  running_off = newoff;\n+\t\t  n_groups++;\n+\t\t  /* When doing SLP make sure to not load elements from\n+\t\t     the next vector iteration, those will not be accessed\n+\t\t     so just use the last element again.  See PR107451.  */\n+\t\t  if (!slp || known_lt (n_groups, vf))\n+\t\t    {\n+\t\t      tree newoff = copy_ssa_name (running_off);\n+\t\t      gimple *incr\n+\t\t\t= gimple_build_assign (newoff, POINTER_PLUS_EXPR,\n+\t\t\t\t\t       running_off, stride_step);\n+\t\t      vect_finish_stmt_generation (vinfo, stmt_info, incr, gsi);\n+\t\t      running_off = newoff;\n+\t\t    }\n \t\t  group_el = 0;\n \t\t}\n \t    }"}]}