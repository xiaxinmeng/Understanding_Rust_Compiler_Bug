{"sha": "9b2b801af5011d6b1f92899f682107776019766c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIyYjgwMWFmNTAxMWQ2YjFmOTI4OTlmNjgyMTA3Nzc2MDE5NzY2Yw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2010-12-04T02:37:46Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2010-12-04T02:37:46Z"}, "message": "mutex (try_lock, [...]): Fix.\n\n2010-12-04  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\t* include/std/mutex (try_lock, __try_lock_impl): Fix.\n\t(lock): Implement using __try_lock_impl.\n\t* testsuite/30_threads/try_lock/2.cc: Fix logic.\n\t* testsuite/30_threads/try_lock/4.cc: New.\n\t* testsuite/30_threads/lock/1.cc: New.\n\t* testsuite/30_threads/lock/2.cc: New.\n\t* testsuite/30_threads/lock/3.cc: New.\n\t* testsuite/30_threads/lock/4.cc: New.\n\nFrom-SVN: r167452", "tree": {"sha": "753d60e92b2485fcd325165bbbce91beca03bd0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/753d60e92b2485fcd325165bbbce91beca03bd0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b2b801af5011d6b1f92899f682107776019766c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2b801af5011d6b1f92899f682107776019766c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b2b801af5011d6b1f92899f682107776019766c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b2b801af5011d6b1f92899f682107776019766c/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dcdeeb24bb56e82edc9c6a136028df504ba1d1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dcdeeb24bb56e82edc9c6a136028df504ba1d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dcdeeb24bb56e82edc9c6a136028df504ba1d1e"}], "stats": {"total": 638, "additions": 601, "deletions": 37}, "files": [{"sha": "1096742ba030880a92b05b03e710cd5f32b676a8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9b2b801af5011d6b1f92899f682107776019766c", "patch": "@@ -1,3 +1,14 @@\n+2010-12-04  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/std/mutex (try_lock, __try_lock_impl): Fix.\n+\t(lock): Implement using __try_lock_impl.\n+\t* testsuite/30_threads/try_lock/2.cc: Fix logic.\n+\t* testsuite/30_threads/try_lock/4.cc: New.\n+\t* testsuite/30_threads/lock/1.cc: New.\n+\t* testsuite/30_threads/lock/2.cc: New.\n+\t* testsuite/30_threads/lock/3.cc: New.\n+\t* testsuite/30_threads/lock/4.cc: New.\n+\n 2010-12-02  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* src/future.cc (future_category): Export compatibility symbol."}, {"sha": "4c155113625f4d52d82cecd50fe36a3363056039", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=9b2b801af5011d6b1f92899f682107776019766c", "patch": "@@ -656,40 +656,44 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t{ }\n     };\n \n+  template<typename _Lock>\n+    unique_lock<_Lock>\n+    __try_to_lock(_Lock& __l)\n+    { return unique_lock<_Lock>(__l, try_to_lock); }\n+\n   template<int _Idx, bool _Continue = true>\n     struct __try_lock_impl\n     {\n       template<typename... _Lock>\n-\tstatic int\n-\t__do_try_lock(tuple<_Lock&...>& __locks)\n+\tstatic void\n+\t__do_try_lock(tuple<_Lock&...>& __locks, int& __idx)\n \t{\n-\t  if(std::get<_Idx>(__locks).try_lock())\n-\t    {\n-\t      return __try_lock_impl<_Idx + 1,\n-\t\t_Idx + 2 < sizeof...(_Lock)>::__do_try_lock(__locks);\n-\t    }\n-\t  else\n-\t    {\n-\t      __unlock_impl<_Idx>::__do_unlock(__locks);\n-\t      return _Idx;\n-\t    }\n+          __idx = _Idx;\n+          auto __lock = __try_to_lock(std::get<_Idx>(__locks));\n+          if (__lock.owns_lock())\n+            {\n+              __try_lock_impl<_Idx + 1, _Idx + 2 < sizeof...(_Lock)>::\n+                __do_try_lock(__locks, __idx);\n+              if (__idx == -1)\n+                __lock.release();\n+            }\n \t}\n     };\n \n   template<int _Idx>\n     struct __try_lock_impl<_Idx, false>\n     {\n       template<typename... _Lock>\n-\tstatic int\n-\t__do_try_lock(tuple<_Lock&...>& __locks)\n+\tstatic void\n+\t__do_try_lock(tuple<_Lock&...>& __locks, int& __idx)\n \t{\n-\t  if(std::get<_Idx>(__locks).try_lock())\n-\t    return -1;\n-\t  else\n-\t    {\n-\t      __unlock_impl<_Idx>::__do_unlock(__locks);\n-\t      return _Idx;\n-\t    }\n+          __idx = _Idx;\n+          auto __lock = __try_to_lock(std::get<_Idx>(__locks));\n+          if (__lock.owns_lock())\n+            {\n+              __idx = -1;\n+              __lock.release();\n+            }\n \t}\n     };\n \n@@ -707,14 +711,43 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     int\n     try_lock(_Lock1& __l1, _Lock2& __l2, _Lock3&... __l3)\n     {\n-      tuple<_Lock1&, _Lock2&, _Lock3&...> __locks(__l1, __l2, __l3...);\n-      return __try_lock_impl<0>::__do_try_lock(__locks);\n+      int __idx;\n+      auto __locks = std::tie(__l1, __l2, __l3...);\n+      __try\n+      { __try_lock_impl<0>::__do_try_lock(__locks, __idx); }\n+      __catch(...)\n+      { }\n+      return __idx;\n     }\n \n-  /// lock\n+  /** @brief Generic lock.\n+   *  @param __l1 Meets Mutex requirements (try_lock() may throw).\n+   *  @param __l2 Meets Mutex requirements (try_lock() may throw).\n+   *  @param __l3 Meets Mutex requirements (try_lock() may throw).\n+   *  @throw An exception thrown by an argument's lock() or try_lock() member.\n+   *  @post All arguments are locked.\n+   *\n+   *  All arguments are locked via a sequence of calls to lock(), try_lock()\n+   *  and unlock().  If the call exits via an exception any locks that were\n+   *  obtained will be released.\n+   */\n   template<typename _L1, typename _L2, typename ..._L3>\n     void\n-    lock(_L1&, _L2&, _L3&...);\n+    lock(_L1& __l1, _L2& __l2, _L3&... __l3)\n+    {\n+      while (true)\n+        {\n+          unique_lock<_L1> __first(__l1);\n+          int __idx;\n+          auto __locks = std::tie(__l2, __l3...);\n+          __try_lock_impl<0, sizeof...(_L3)>::__do_try_lock(__locks, __idx);\n+          if (__idx == -1)\n+            {\n+              __first.release();\n+              return;\n+            }\n+        }\n+    }\n \n   /// once_flag\n   struct once_flag"}, {"sha": "3f4f657aaf65ed176acb74f8de09bf7db7c39a3d", "filename": "libstdc++-v3/testsuite/30_threads/lock/1.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F1.cc?ref=9b2b801af5011d6b1f92899f682107776019766c", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <mutex>\n+#include <system_error>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef std::mutex mutex_type;\n+  typedef std::unique_lock<mutex_type> lock_type;\n+\n+  try\n+    {\n+      mutex_type m1, m2, m3;\n+      lock_type l1(m1, std::defer_lock), \n+\tl2(m2, std::defer_lock),\n+\tl3(m3, std::defer_lock);\n+\n+      try\n+\t{\n+\t  std::lock(l1, l2, l3);\n+\t  VERIFY( l1.owns_lock() );\n+\t  VERIFY( l2.owns_lock() );\n+\t  VERIFY( l3.owns_lock() );\n+\t}\n+      catch (const std::system_error& e)\n+\t{\n+\t  VERIFY( false );\n+\t}\n+    }\n+  catch (const std::system_error& e)\n+    {\n+      VERIFY( false );\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  return 0;\n+}"}, {"sha": "bf3c8a86aca85ed18288356f5ea0ed09492f6cd6", "filename": "libstdc++-v3/testsuite/30_threads/lock/2.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F2.cc?ref=9b2b801af5011d6b1f92899f682107776019766c", "patch": "@@ -0,0 +1,58 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <mutex>\n+#include <thread>\n+#include <testsuite_hooks.h>\n+\n+void locker(std::mutex& m1, std::mutex& m2, std::mutex& m3)\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unique_lock<std::mutex> lock_type;\n+\n+  lock_type l1(m1, std::defer_lock);\n+  lock_type l2(m2, std::defer_lock);\n+  lock_type l3(m3, std::defer_lock);\n+  std::lock(l1, l2, l3);\n+  VERIFY( l1.owns_lock() );\n+  VERIFY( l2.owns_lock() );\n+  VERIFY( l3.owns_lock() );\n+}\n+\n+void test01()\n+{\n+  std::mutex m1, m2, m3;\n+  std::thread t1(locker, std::ref(m1), std::ref(m2), std::ref(m3));\n+  std::thread t2(locker, std::ref(m3), std::ref(m2), std::ref(m1));\n+  t1.join();\n+  t2.join();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "18681c0d708fbec5a0e53fe93afeb122b282950d", "filename": "libstdc++-v3/testsuite/30_threads/lock/3.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F3.cc?ref=9b2b801af5011d6b1f92899f682107776019766c", "patch": "@@ -0,0 +1,90 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <mutex>\n+#include <system_error>\n+#include <testsuite_hooks.h>\n+\n+struct user_lock\n+{\n+  user_lock() : is_locked(false) { }\n+  ~user_lock() = default;\n+  user_lock(const user_lock&) = default;\n+\n+  void lock()\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( !is_locked );\n+    is_locked = true;\n+  }\n+\n+  bool try_lock() \n+  { return is_locked ? false : (is_locked = true); }\n+\n+  void unlock()\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( is_locked );\n+    is_locked = false;\n+  }\n+\n+private:\n+  bool is_locked;\n+};\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  try\n+    {\n+      std::mutex m1;\n+      std::recursive_mutex m2;\n+      user_lock m3;\n+\n+      try\n+\t{\n+\t  //heterogeneous types\n+\t  std::lock(m1, m2, m3);\n+\t  m1.unlock();\n+\t  m2.unlock();\n+\t  m3.unlock();\n+\t}\n+      catch (const std::system_error& e)\n+\t{\n+\t  VERIFY( false );\n+\t}\n+    }\n+  catch (const std::system_error& e)\n+    {\n+      VERIFY( false );\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+\n+  return 0;\n+}"}, {"sha": "c71a8a0aeaceb5ff25c038c023e1196d83bedbed", "filename": "libstdc++-v3/testsuite/30_threads/lock/4.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Flock%2F4.cc?ref=9b2b801af5011d6b1f92899f682107776019766c", "patch": "@@ -0,0 +1,152 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <mutex>\n+#include <testsuite_hooks.h>\n+\n+struct unreliable_lock\n+{\n+  std::mutex m;\n+  std::unique_lock<std::mutex> l;\n+\n+  static int count;\n+  static int throw_on;\n+  static int lock_on;\n+\n+  unreliable_lock() : l(m, std::defer_lock) { }\n+\n+  ~unreliable_lock()\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( !l.owns_lock() );\n+  }\n+\n+  void lock()\n+  {\n+    if (count == throw_on)\n+      throw throw_on;\n+    ++count;\n+    l.lock();\n+  }\n+  bool try_lock()\n+  {\n+    if (count == throw_on)\n+      throw throw_on;\n+    std::unique_lock<std::mutex> l2(m, std::defer_lock);\n+    if (count == lock_on)\n+      l2.lock();\n+    ++count;\n+    return l.try_lock();\n+  }\n+\n+  void unlock()\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( l.owns_lock() );\n+    l.unlock();\n+  }\n+\n+};\n+\n+int unreliable_lock::count = 0;\n+int unreliable_lock::throw_on = -1;\n+int unreliable_lock::lock_on = -1;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  unreliable_lock l1, l2, l3;\n+\n+  try\n+    {\n+      unreliable_lock::count = 0;\n+      std::lock(l1, l2, l3);\n+      VERIFY( unreliable_lock::count == 3 );\n+      l1.unlock();\n+      l2.unlock();\n+      l3.unlock();\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  // test behaviour when a lock is already held\n+  try\n+    {\n+      unreliable_lock::lock_on = 1;\n+      while (unreliable_lock::lock_on < 3)\n+      {\n+        unreliable_lock::count = 0;\n+        unreliable_lock l1, l2, l3;\n+        std::lock(l1, l2, l3);\n+        VERIFY( unreliable_lock::count > 3 );\n+        l1.unlock();\n+        l2.unlock();\n+        l3.unlock();\n+        ++unreliable_lock::lock_on;\n+      }\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}\n+\n+void test03()\n+{\n+  // test behaviour when an exception is thrown\n+  unreliable_lock::throw_on = 0;\n+  while (unreliable_lock::throw_on < 3)\n+  {\n+    unreliable_lock::count = 0;\n+    unreliable_lock l1, l2, l3;\n+    bool test = false;\n+    try\n+      {\n+        std::lock(l1, l2, l3);\n+      }\n+    catch (...)\n+      {\n+        test = true;\n+      }\n+    VERIFY( test );\n+    ++unreliable_lock::throw_on;\n+  }\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "b24e7e396571f357099a4b373a8bca72b4272931", "filename": "libstdc++-v3/testsuite/30_threads/try_lock/2.cc", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftry_lock%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftry_lock%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftry_lock%2F2.cc?ref=9b2b801af5011d6b1f92899f682107776019766c", "patch": "@@ -27,19 +27,21 @@\n #include <system_error>\n #include <testsuite_hooks.h>\n \n+typedef std::unique_lock<std::mutex> lock_type;\n+\n void test01()\n {\n   bool test __attribute__((unused)) = true;\n \n   try\n     {\n       std::mutex m1, m2, m3;\n-      m1.lock();\n+      lock_type l1(m1);\n       int result = std::try_lock(m1, m2, m3);\n       VERIFY( result == 0 );\n-      m1.lock();\n-      m2.lock();\n-      m3.lock();\n+      VERIFY( l1.owns_lock() );\n+      lock_type l2(m2);\n+      lock_type l3(m3);\n     }\n   catch (const std::system_error& e)\n     {\n@@ -58,12 +60,12 @@ void test02()\n   try\n     {\n       std::mutex m1, m2, m3;\n-      m2.lock();\n+      lock_type l2(m2);\n       int result = std::try_lock(m1, m2, m3);\n       VERIFY( result == 1 );\n-      m1.lock();\n-      m2.lock();\n-      m3.lock();\n+      VERIFY( l2.owns_lock() );\n+      lock_type l1(m1);\n+      lock_type l3(m3);\n     }\n   catch (const std::system_error& e)\n     {\n@@ -82,12 +84,12 @@ void test03()\n   try\n     {\n       std::mutex m1, m2, m3;\n-      m3.lock();\n+      lock_type l3(m3);\n       int result = std::try_lock(m1, m2, m3);\n       VERIFY( result == 2 );\n-      m1.lock();\n-      m2.lock();\n-      m3.lock();\n+      VERIFY( l3.owns_lock() );\n+      lock_type l1(m1);\n+      lock_type l2(m2);\n     }\n   catch (const std::system_error& e)\n     {"}, {"sha": "7750fc92478aeb2543daa384f0c75fa89e0e64d9", "filename": "libstdc++-v3/testsuite/30_threads/try_lock/4.cc", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftry_lock%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b2b801af5011d6b1f92899f682107776019766c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftry_lock%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Ftry_lock%2F4.cc?ref=9b2b801af5011d6b1f92899f682107776019766c", "patch": "@@ -0,0 +1,153 @@\n+// { dg-do run { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* alpha*-*-osf* mips-sgi-irix6* } }\n+// { dg-options \" -std=gnu++0x -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++0x \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <mutex>\n+#include <testsuite_hooks.h>\n+\n+struct unreliable_lock\n+{\n+  std::mutex m;\n+  std::unique_lock<std::mutex> l;\n+\n+  static int count;\n+  static int throw_on;\n+  static int lock_on;\n+\n+  unreliable_lock() : l(m, std::defer_lock) { }\n+\n+  ~unreliable_lock()\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( !l.owns_lock() );\n+  }\n+\n+  void lock()\n+  {\n+    if (count == throw_on)\n+      throw throw_on;\n+    ++count;\n+    l.lock();\n+  }\n+  bool try_lock()\n+  {\n+    if (count == throw_on)\n+      throw throw_on;\n+    std::unique_lock<std::mutex> l2(m, std::defer_lock);\n+    if (count == lock_on)\n+      l2.lock();\n+    ++count;\n+    return l.try_lock();\n+  }\n+\n+  void unlock()\n+  {\n+    bool test __attribute__((unused)) = true;\n+    VERIFY( l.owns_lock() );\n+    l.unlock();\n+  }\n+\n+};\n+\n+int unreliable_lock::count = 0;\n+int unreliable_lock::throw_on = -1;\n+int unreliable_lock::lock_on = -1;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  unreliable_lock l1, l2, l3;\n+\n+  try\n+    {\n+      unreliable_lock::count = 0;\n+      int result = std::try_lock(l1, l2, l3);\n+      VERIFY( result == -1 );\n+      VERIFY( unreliable_lock::count == 3 );\n+      l1.unlock();\n+      l2.unlock();\n+      l3.unlock();\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  unreliable_lock l1, l2, l3;\n+\n+  try\n+    {\n+      // test behaviour when a lock is already held\n+      unreliable_lock::lock_on = 0;\n+      while (unreliable_lock::lock_on < 3)\n+      {\n+        unreliable_lock::count = 0;\n+        int failed = std::try_lock(l1, l2, l3);\n+        VERIFY( failed == unreliable_lock::lock_on );\n+        ++unreliable_lock::lock_on;\n+      }\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  unreliable_lock l1, l2, l3;\n+\n+  try\n+    {\n+      // test behaviour when an exception is thrown\n+      unreliable_lock::throw_on = 0;\n+      while (unreliable_lock::throw_on < 3)\n+      {\n+        unreliable_lock::count = 0;\n+        int failed = std::try_lock(l1, l2, l3);\n+        VERIFY( failed == unreliable_lock::throw_on );\n+        ++unreliable_lock::throw_on;\n+      }\n+    }\n+  catch (...)\n+    {\n+      VERIFY( false );\n+    }\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}]}