{"sha": "83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMxNDRjZmNmYWNhNDRiYjZkMGNhZTdkMmMwZmE0NDcxOTNjYjgxOQ==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-12T22:07:53Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-12T22:07:53Z"}, "message": "Makefile.am: Add new files.\n\n2002-06-12  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* include/Makefile.am:  Add new files.\n\t* include/Makefile.in:  Regenerate.\n\n\t* include/bits/stl_deque.h, include/bits/stl_list.h,\n\tinclude/bits/stl_vector.h:  Clean up, reformat.  Move definitions...\n\t* include/bits/deque.tcc, include/bits/list.tcc,\n\tinclude/bits/vector.tcc:  ...to here.  New files.\n\n\t* include/ext/stl_hashtable.h:  Inclide correct full headers.\n\t* include/std/std_deque.h:  Include .tcc files for now.\n\t* include/std/std_list.h:  Likewise.\n\t* include/std/std_vector.h:  Likewise.\n\nFrom-SVN: r54562", "tree": {"sha": "865ef1d15b88e90e0782f554095ba1d3a7c3cfd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/865ef1d15b88e90e0782f554095ba1d3a7c3cfd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/comments", "author": null, "committer": null, "parents": [{"sha": "ec01703c829df9d31e1dcc410b1dc5271b2d814b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec01703c829df9d31e1dcc410b1dc5271b2d814b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec01703c829df9d31e1dcc410b1dc5271b2d814b"}], "stats": {"total": 3346, "additions": 1997, "deletions": 1349}, "files": [{"sha": "a60aec61646de35185c2494b277d57b3e2263395", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -1,3 +1,18 @@\n+2002-06-12  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* include/Makefile.am:  Add new files.\n+\t* include/Makefile.in:  Regenerate.\n+\n+\t* include/bits/stl_deque.h, include/bits/stl_list.h,\n+\tinclude/bits/stl_vector.h:  Clean up, reformat.  Move definitions...\n+\t* include/bits/deque.tcc, include/bits/list.tcc,\n+\tinclude/bits/vector.tcc:  ...to here.  New files.\n+\n+\t* include/ext/stl_hashtable.h:  Inclide correct full headers.\n+\t* include/std/std_deque.h:  Include .tcc files for now.\n+\t* include/std/std_list.h:  Likewise.\n+\t* include/std/std_vector.h:  Likewise.\n+\n 2002-06-12  Daniel Jacobowitz  <drow@mvista.com>\n \n \t* Makefile.am: Add FLAGS_TO_PASS."}, {"sha": "9994b31020c92377592e74a338c58056583adc5e", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -43,6 +43,7 @@ bits_headers = \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n \t${bits_srcdir}/cpp_type_traits.h \\\n+\t${bits_srcdir}/deque.tcc \\\n \t${bits_srcdir}/fpos.h \\\n \t${bits_srcdir}/fstream.tcc \\\n \t${bits_srcdir}/functexcept.h \\\n@@ -52,6 +53,7 @@ bits_headers = \\\n \t${bits_srcdir}/indirect_array.h \\\n \t${bits_srcdir}/ios_base.h \\\n \t${bits_srcdir}/istream.tcc \\\n+\t${bits_srcdir}/list.tcc \\\n \t${bits_srcdir}/locale_facets.h \\\n \t${bits_srcdir}/locale_facets.tcc \\\n \t${bits_srcdir}/localefwd.h \\\n@@ -96,7 +98,8 @@ bits_headers = \\\n \t${bits_srcdir}/type_traits.h \\\n \t${bits_srcdir}/valarray_array.h \\\n \t${bits_srcdir}/valarray_array.tcc \\\n-\t${bits_srcdir}/valarray_meta.h\n+\t${bits_srcdir}/valarray_meta.h \\\n+\t${bits_srcdir}/vector.tcc\n \n backward_srcdir = ${glibcpp_srcdir}/include/backward\n backward_builddir = ./backward"}, {"sha": "11b8a0624cdcdec56285784966d2ac155eafa434", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 248, "deletions": 17, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -141,51 +141,282 @@ glibcpp_builddir = @glibcpp_builddir@\n \n bits_srcdir = ${glibcpp_srcdir}/include/bits\n bits_builddir = ./bits\n-bits_headers =  \t${bits_srcdir}/basic_ios.h \t${bits_srcdir}/basic_ios.tcc \t${bits_srcdir}/basic_string.h \t${bits_srcdir}/basic_string.tcc \t${bits_srcdir}/boost_concept_check.h \t${bits_srcdir}/char_traits.h \t${bits_srcdir}/codecvt.h \t${bits_srcdir}/concept_check.h \t${bits_srcdir}/cpp_type_traits.h \t${bits_srcdir}/fpos.h \t${bits_srcdir}/fstream.tcc \t${bits_srcdir}/functexcept.h \t${bits_srcdir}/generic_shadow.h \t${bits_srcdir}/gslice.h \t${bits_srcdir}/gslice_array.h \t${bits_srcdir}/indirect_array.h \t${bits_srcdir}/ios_base.h \t${bits_srcdir}/istream.tcc \t${bits_srcdir}/locale_facets.h \t${bits_srcdir}/locale_facets.tcc \t${bits_srcdir}/localefwd.h \t${bits_srcdir}/mask_array.h \t${bits_srcdir}/ostream.tcc \t${bits_srcdir}/pthread_allocimpl.h \t${bits_srcdir}/stream_iterator.h \t${bits_srcdir}/streambuf_iterator.h \t${bits_srcdir}/slice.h \t${bits_srcdir}/slice_array.h \t${bits_srcdir}/sstream.tcc \t${bits_srcdir}/stl_algo.h \t${bits_srcdir}/stl_algobase.h \t${bits_srcdir}/stl_alloc.h \t${bits_srcdir}/stl_bvector.h \t${bits_srcdir}/stl_construct.h \t${bits_srcdir}/stl_deque.h \t${bits_srcdir}/stl_function.h \t${bits_srcdir}/stl_heap.h \t${bits_srcdir}/stl_iterator.h \t${bits_srcdir}/stl_iterator_base_funcs.h \t${bits_srcdir}/stl_iterator_base_types.h \t${bits_srcdir}/stl_list.h \t${bits_srcdir}/stl_map.h \t${bits_srcdir}/stl_multimap.h \t${bits_srcdir}/stl_multiset.h \t${bits_srcdir}/stl_numeric.h \t${bits_srcdir}/stl_pair.h \t${bits_srcdir}/stl_pthread_alloc.h \t${bits_srcdir}/stl_queue.h \t${bits_srcdir}/stl_raw_storage_iter.h \t${bits_srcdir}/stl_relops.h \t${bits_srcdir}/stl_set.h \t${bits_srcdir}/stl_stack.h \t${bits_srcdir}/stl_tempbuf.h \t${bits_srcdir}/stl_threads.h \t${bits_srcdir}/stl_tree.h \t${bits_srcdir}/stl_uninitialized.h \t${bits_srcdir}/stl_vector.h \t${bits_srcdir}/streambuf.tcc \t${bits_srcdir}/stringfwd.h \t${bits_srcdir}/type_traits.h \t${bits_srcdir}/valarray_array.h \t${bits_srcdir}/valarray_array.tcc \t${bits_srcdir}/valarray_meta.h\n+bits_headers = \\\n+\t${bits_srcdir}/basic_ios.h \\\n+\t${bits_srcdir}/basic_ios.tcc \\\n+\t${bits_srcdir}/basic_string.h \\\n+\t${bits_srcdir}/basic_string.tcc \\\n+\t${bits_srcdir}/boost_concept_check.h \\\n+\t${bits_srcdir}/char_traits.h \\\n+\t${bits_srcdir}/codecvt.h \\\n+\t${bits_srcdir}/concept_check.h \\\n+\t${bits_srcdir}/cpp_type_traits.h \\\n+\t${bits_srcdir}/deque.tcc \\\n+\t${bits_srcdir}/fpos.h \\\n+\t${bits_srcdir}/fstream.tcc \\\n+\t${bits_srcdir}/functexcept.h \\\n+\t${bits_srcdir}/generic_shadow.h \\\n+\t${bits_srcdir}/gslice.h \\\n+\t${bits_srcdir}/gslice_array.h \\\n+\t${bits_srcdir}/indirect_array.h \\\n+\t${bits_srcdir}/ios_base.h \\\n+\t${bits_srcdir}/istream.tcc \\\n+\t${bits_srcdir}/list.tcc \\\n+\t${bits_srcdir}/locale_facets.h \\\n+\t${bits_srcdir}/locale_facets.tcc \\\n+\t${bits_srcdir}/localefwd.h \\\n+\t${bits_srcdir}/mask_array.h \\\n+\t${bits_srcdir}/ostream.tcc \\\n+\t${bits_srcdir}/pthread_allocimpl.h \\\n+\t${bits_srcdir}/stream_iterator.h \\\n+\t${bits_srcdir}/streambuf_iterator.h \\\n+\t${bits_srcdir}/slice.h \\\n+\t${bits_srcdir}/slice_array.h \\\n+\t${bits_srcdir}/sstream.tcc \\\n+\t${bits_srcdir}/stl_algo.h \\\n+\t${bits_srcdir}/stl_algobase.h \\\n+\t${bits_srcdir}/stl_alloc.h \\\n+\t${bits_srcdir}/stl_bvector.h \\\n+\t${bits_srcdir}/stl_construct.h \\\n+\t${bits_srcdir}/stl_deque.h \\\n+\t${bits_srcdir}/stl_function.h \\\n+\t${bits_srcdir}/stl_heap.h \\\n+\t${bits_srcdir}/stl_iterator.h \\\n+\t${bits_srcdir}/stl_iterator_base_funcs.h \\\n+\t${bits_srcdir}/stl_iterator_base_types.h \\\n+\t${bits_srcdir}/stl_list.h \\\n+\t${bits_srcdir}/stl_map.h \\\n+\t${bits_srcdir}/stl_multimap.h \\\n+\t${bits_srcdir}/stl_multiset.h \\\n+\t${bits_srcdir}/stl_numeric.h \\\n+\t${bits_srcdir}/stl_pair.h \\\n+\t${bits_srcdir}/stl_pthread_alloc.h \\\n+\t${bits_srcdir}/stl_queue.h \\\n+\t${bits_srcdir}/stl_raw_storage_iter.h \\\n+\t${bits_srcdir}/stl_relops.h \\\n+\t${bits_srcdir}/stl_set.h \\\n+\t${bits_srcdir}/stl_stack.h \\\n+\t${bits_srcdir}/stl_tempbuf.h \\\n+\t${bits_srcdir}/stl_threads.h \\\n+\t${bits_srcdir}/stl_tree.h \\\n+\t${bits_srcdir}/stl_uninitialized.h \\\n+\t${bits_srcdir}/stl_vector.h \\\n+\t${bits_srcdir}/streambuf.tcc \\\n+\t${bits_srcdir}/stringfwd.h \\\n+\t${bits_srcdir}/type_traits.h \\\n+\t${bits_srcdir}/valarray_array.h \\\n+\t${bits_srcdir}/valarray_array.tcc \\\n+\t${bits_srcdir}/valarray_meta.h \\\n+\t${bits_srcdir}/vector.tcc\n \n \n backward_srcdir = ${glibcpp_srcdir}/include/backward\n backward_builddir = ./backward\n-backward_headers =  \t${backward_srcdir}/complex.h \t${backward_srcdir}/iomanip.h \t${backward_srcdir}/istream.h \t${backward_srcdir}/ostream.h \t${backward_srcdir}/stream.h \t${backward_srcdir}/streambuf.h \t${backward_srcdir}/algo.h \t${backward_srcdir}/algobase.h \t${backward_srcdir}/alloc.h \t${backward_srcdir}/bvector.h \t${backward_srcdir}/defalloc.h \t${backward_srcdir}/deque.h \t${backward_srcdir}/function.h \t${backward_srcdir}/hash_map.h \t${backward_srcdir}/hash_set.h \t${backward_srcdir}/hashtable.h \t${backward_srcdir}/heap.h \t${backward_srcdir}/iostream.h \t${backward_srcdir}/iterator.h \t${backward_srcdir}/list.h \t${backward_srcdir}/map.h \t${backward_srcdir}/multimap.h \t${backward_srcdir}/new.h \t${backward_srcdir}/multiset.h \t${backward_srcdir}/pair.h \t${backward_srcdir}/queue.h \t${backward_srcdir}/rope.h \t${backward_srcdir}/set.h \t${backward_srcdir}/slist.h \t${backward_srcdir}/stack.h \t${backward_srcdir}/tempbuf.h \t${backward_srcdir}/tree.h \t${backward_srcdir}/vector.h \t${backward_srcdir}/fstream.h \t${backward_srcdir}/strstream.h \t${backward_srcdir}/strstream \t${backward_srcdir}/backward_warning.h\n+backward_headers = \\\n+\t${backward_srcdir}/complex.h \\\n+\t${backward_srcdir}/iomanip.h \\\n+\t${backward_srcdir}/istream.h \\\n+\t${backward_srcdir}/ostream.h \\\n+\t${backward_srcdir}/stream.h \\\n+\t${backward_srcdir}/streambuf.h \\\n+\t${backward_srcdir}/algo.h \\\n+\t${backward_srcdir}/algobase.h \\\n+\t${backward_srcdir}/alloc.h \\\n+\t${backward_srcdir}/bvector.h \\\n+\t${backward_srcdir}/defalloc.h \\\n+\t${backward_srcdir}/deque.h \\\n+\t${backward_srcdir}/function.h \\\n+\t${backward_srcdir}/hash_map.h \\\n+\t${backward_srcdir}/hash_set.h \\\n+\t${backward_srcdir}/hashtable.h \\\n+\t${backward_srcdir}/heap.h \\\n+\t${backward_srcdir}/iostream.h \\\n+\t${backward_srcdir}/iterator.h \\\n+\t${backward_srcdir}/list.h \\\n+\t${backward_srcdir}/map.h \\\n+\t${backward_srcdir}/multimap.h \\\n+\t${backward_srcdir}/new.h \\\n+\t${backward_srcdir}/multiset.h \\\n+\t${backward_srcdir}/pair.h \\\n+\t${backward_srcdir}/queue.h \\\n+\t${backward_srcdir}/rope.h \\\n+\t${backward_srcdir}/set.h \\\n+\t${backward_srcdir}/slist.h \\\n+\t${backward_srcdir}/stack.h \\\n+\t${backward_srcdir}/tempbuf.h \\\n+\t${backward_srcdir}/tree.h \\\n+\t${backward_srcdir}/vector.h \\\n+\t${backward_srcdir}/fstream.h \\\n+\t${backward_srcdir}/strstream.h \\\n+\t${backward_srcdir}/strstream \\\n+\t${backward_srcdir}/backward_warning.h\n \n \n ext_srcdir = ${glibcpp_srcdir}/include/ext\n ext_builddir = ./ext\n-ext_headers =  \t${ext_srcdir}/algorithm \t${ext_srcdir}/enc_filebuf.h \t${ext_srcdir}/stdio_filebuf.h \t${ext_srcdir}/functional \t${ext_srcdir}/hash_map \t${ext_srcdir}/hash_set \t${ext_srcdir}/iterator \t${ext_srcdir}/memory \t${ext_srcdir}/numeric \t${ext_srcdir}/rb_tree \t${ext_srcdir}/rope \t${ext_srcdir}/ropeimpl.h \t${ext_srcdir}/slist \t${ext_srcdir}/stl_hash_fun.h \t${ext_srcdir}/stl_hashtable.h \t${ext_srcdir}/stl_rope.h\n+ext_headers = \\\n+\t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/enc_filebuf.h \\\n+\t${ext_srcdir}/stdio_filebuf.h \\\n+\t${ext_srcdir}/functional \\\n+\t${ext_srcdir}/hash_map \\\n+\t${ext_srcdir}/hash_set \\\n+\t${ext_srcdir}/iterator \\\n+\t${ext_srcdir}/memory \\\n+\t${ext_srcdir}/numeric \\\n+\t${ext_srcdir}/rb_tree \\\n+\t${ext_srcdir}/rope \\\n+\t${ext_srcdir}/ropeimpl.h \\\n+\t${ext_srcdir}/slist \\\n+\t${ext_srcdir}/stl_hash_fun.h \\\n+\t${ext_srcdir}/stl_hashtable.h \\\n+\t${ext_srcdir}/stl_rope.h\n \n \n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = @C_INCLUDE_DIR@\n c_base_builddir = .\n-c_base_headers =  \t${c_base_srcdir}/std_cassert.h \t${c_base_srcdir}/std_cctype.h \t${c_base_srcdir}/std_cerrno.h \t${c_base_srcdir}/std_cfloat.h \t${c_base_srcdir}/std_ciso646.h \t${c_base_srcdir}/std_climits.h \t${c_base_srcdir}/std_clocale.h \t${c_base_srcdir}/std_cmath.h \t${c_base_srcdir}/std_csetjmp.h \t${c_base_srcdir}/std_csignal.h \t${c_base_srcdir}/std_cstdarg.h \t${c_base_srcdir}/std_cstddef.h \t${c_base_srcdir}/std_cstdio.h \t${c_base_srcdir}/std_cstdlib.h \t${c_base_srcdir}/std_cstring.h \t${c_base_srcdir}/std_ctime.h \t${c_base_srcdir}/std_cwchar.h \t${c_base_srcdir}/std_cwctype.h \n-\n-c_base_headers_rename =  \tcassert \tcctype \tcerrno \tcfloat \tciso646 \tclimits \tclocale \tcmath \tcsetjmp \tcsignal \tcstdarg \tcstddef \tcstdio \tcstdlib \tcstring \tctime \tcwchar \tcwctype \n-\n-@GLIBCPP_C_HEADERS_C_STD_TRUE@c_base_headers_extra = \t${c_base_srcdir}/cmath.tcc \n+c_base_headers = \\\n+\t${c_base_srcdir}/std_cassert.h \\\n+\t${c_base_srcdir}/std_cctype.h \\\n+\t${c_base_srcdir}/std_cerrno.h \\\n+\t${c_base_srcdir}/std_cfloat.h \\\n+\t${c_base_srcdir}/std_ciso646.h \\\n+\t${c_base_srcdir}/std_climits.h \\\n+\t${c_base_srcdir}/std_clocale.h \\\n+\t${c_base_srcdir}/std_cmath.h \\\n+\t${c_base_srcdir}/std_csetjmp.h \\\n+\t${c_base_srcdir}/std_csignal.h \\\n+\t${c_base_srcdir}/std_cstdarg.h \\\n+\t${c_base_srcdir}/std_cstddef.h \\\n+\t${c_base_srcdir}/std_cstdio.h \\\n+\t${c_base_srcdir}/std_cstdlib.h \\\n+\t${c_base_srcdir}/std_cstring.h \\\n+\t${c_base_srcdir}/std_ctime.h \\\n+\t${c_base_srcdir}/std_cwchar.h \\\n+\t${c_base_srcdir}/std_cwctype.h \n+\n+c_base_headers_rename = \\\n+\tcassert \\\n+\tcctype \\\n+\tcerrno \\\n+\tcfloat \\\n+\tciso646 \\\n+\tclimits \\\n+\tclocale \\\n+\tcmath \\\n+\tcsetjmp \\\n+\tcsignal \\\n+\tcstdarg \\\n+\tcstddef \\\n+\tcstdio \\\n+\tcstdlib \\\n+\tcstring \\\n+\tctime \\\n+\tcwchar \\\n+\tcwctype \n+\n+@GLIBCPP_C_HEADERS_C_STD_TRUE@c_base_headers_extra = @GLIBCPP_C_HEADERS_C_STD_TRUE@\\\n+@GLIBCPP_C_HEADERS_C_STD_TRUE@\t${c_base_srcdir}/cmath.tcc \n @GLIBCPP_C_HEADERS_C_STD_FALSE@c_base_headers_extra = \n \n std_srcdir = ${glibcpp_srcdir}/include/std\n std_builddir = .\n-std_headers =  \t${std_srcdir}/std_algorithm.h \t${std_srcdir}/std_bitset.h \t${std_srcdir}/std_complex.h \t${std_srcdir}/std_deque.h \t${std_srcdir}/std_fstream.h \t${std_srcdir}/std_functional.h \t${std_srcdir}/std_iomanip.h \t${std_srcdir}/std_ios.h \t${std_srcdir}/std_iosfwd.h \t${std_srcdir}/std_iostream.h \t${std_srcdir}/std_istream.h \t${std_srcdir}/std_iterator.h \t${std_srcdir}/std_limits.h \t${std_srcdir}/std_list.h \t${std_srcdir}/std_locale.h \t${std_srcdir}/std_map.h \t${std_srcdir}/std_memory.h \t${std_srcdir}/std_numeric.h \t${std_srcdir}/std_ostream.h \t${std_srcdir}/std_queue.h \t${std_srcdir}/std_set.h \t${std_srcdir}/std_sstream.h \t${std_srcdir}/std_stack.h \t${std_srcdir}/std_stdexcept.h \t${std_srcdir}/std_streambuf.h \t${std_srcdir}/std_string.h \t${std_srcdir}/std_utility.h \t${std_srcdir}/std_valarray.h \t${std_srcdir}/std_vector.h\n+std_headers = \\\n+\t${std_srcdir}/std_algorithm.h \\\n+\t${std_srcdir}/std_bitset.h \\\n+\t${std_srcdir}/std_complex.h \\\n+\t${std_srcdir}/std_deque.h \\\n+\t${std_srcdir}/std_fstream.h \\\n+\t${std_srcdir}/std_functional.h \\\n+\t${std_srcdir}/std_iomanip.h \\\n+\t${std_srcdir}/std_ios.h \\\n+\t${std_srcdir}/std_iosfwd.h \\\n+\t${std_srcdir}/std_iostream.h \\\n+\t${std_srcdir}/std_istream.h \\\n+\t${std_srcdir}/std_iterator.h \\\n+\t${std_srcdir}/std_limits.h \\\n+\t${std_srcdir}/std_list.h \\\n+\t${std_srcdir}/std_locale.h \\\n+\t${std_srcdir}/std_map.h \\\n+\t${std_srcdir}/std_memory.h \\\n+\t${std_srcdir}/std_numeric.h \\\n+\t${std_srcdir}/std_ostream.h \\\n+\t${std_srcdir}/std_queue.h \\\n+\t${std_srcdir}/std_set.h \\\n+\t${std_srcdir}/std_sstream.h \\\n+\t${std_srcdir}/std_stack.h \\\n+\t${std_srcdir}/std_stdexcept.h \\\n+\t${std_srcdir}/std_streambuf.h \\\n+\t${std_srcdir}/std_string.h \\\n+\t${std_srcdir}/std_utility.h \\\n+\t${std_srcdir}/std_valarray.h \\\n+\t${std_srcdir}/std_vector.h\n \n # Renamed at build time. \n-std_headers_rename =  \talgorithm \tbitset \tcomplex \tdeque \tfstream \tfunctional \tiomanip \tios \tiosfwd \tiostream \tistream \titerator \tlimits \tlist \tlocale \tmap \tmemory \tnumeric \tostream \tqueue \tset \tsstream \tstack \tstdexcept \tstreambuf \tstring \tutility \tvalarray \tvector\n+std_headers_rename = \\\n+\talgorithm \\\n+\tbitset \\\n+\tcomplex \\\n+\tdeque \\\n+\tfstream \\\n+\tfunctional \\\n+\tiomanip \\\n+\tios \\\n+\tiosfwd \\\n+\tiostream \\\n+\tistream \\\n+\titerator \\\n+\tlimits \\\n+\tlist \\\n+\tlocale \\\n+\tmap \\\n+\tmemory \\\n+\tnumeric \\\n+\tostream \\\n+\tqueue \\\n+\tset \\\n+\tsstream \\\n+\tstack \\\n+\tstdexcept \\\n+\tstreambuf \\\n+\tstring \\\n+\tutility \\\n+\tvalarray \\\n+\tvector\n \n \n target_srcdir = ${glibcpp_srcdir}/@OS_INC_SRCDIR@\n target_builddir = ./${target_alias}/bits\n-target_headers =  \t${target_srcdir}/ctype_base.h \t${target_srcdir}/ctype_inline.h \t${target_srcdir}/ctype_noninline.h \t${target_srcdir}/os_defines.h \t${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h \t${glibcpp_srcdir}/@CPU_LIMITS_INC_SRCDIR@/cpu_limits.h \n+target_headers = \\\n+\t${target_srcdir}/ctype_base.h \\\n+\t${target_srcdir}/ctype_inline.h \\\n+\t${target_srcdir}/ctype_noninline.h \\\n+\t${target_srcdir}/os_defines.h \\\n+\t${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h \\\n+\t${glibcpp_srcdir}/@CPU_LIMITS_INC_SRCDIR@/cpu_limits.h \n \n # These extra_target_headers files are all built with ad hoc naming rules.\n-extra_target_headers =  \t${target_builddir}/basic_file.h \t${target_builddir}/c++config.h \t${target_builddir}/c++io.h \t${target_builddir}/c++locale.h \t${target_builddir}/messages_members.h \t${target_builddir}/codecvt_specializations.h\n+extra_target_headers = \\\n+\t${target_builddir}/basic_file.h \\\n+\t${target_builddir}/c++config.h \\\n+\t${target_builddir}/c++io.h \\\n+\t${target_builddir}/c++locale.h \\\n+\t${target_builddir}/messages_members.h \\\n+\t${target_builddir}/codecvt_specializations.h\n \n \n-thread_target_headers =  \t${target_builddir}/gthr.h \t${target_builddir}/gthr-single.h \t${target_builddir}/gthr-posix.h \t${target_builddir}/gthr-default.h\n+thread_target_headers = \\\n+\t${target_builddir}/gthr.h \\\n+\t${target_builddir}/gthr-single.h \\\n+\t${target_builddir}/gthr-posix.h \\\n+\t${target_builddir}/gthr-default.h\n \n \n # List of all timestamp files.  By keeping only one copy of this list, both\n # CLEANFILES and all-local are kept up-to-date.\n-allstamps = stamp-std stamp-bits stamp-c_base stamp-backward stamp-ext \t${target_builddir}/stamp-target\n+allstamps = stamp-std stamp-bits stamp-c_base stamp-backward stamp-ext \\\n+\t${target_builddir}/stamp-target\n \n \n # Target includes for threads\n@@ -208,7 +439,7 @@ DIST_COMMON =  Makefile.am Makefile.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:"}, {"sha": "37cc0155838acc36ff0dc2e055a8494c0278e3ae", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "added", "additions": 784, "deletions": 0, "changes": 784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -0,0 +1,784 @@\n+// Deque implementation (out of line) -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/** @file deque.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef __GLIBCPP_INTERNAL_DEQUE_TCC\n+#define __GLIBCPP_INTERNAL_DEQUE_TCC\n+\n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n+namespace std\n+{ \n+\n+template <typename _Tp, typename _Alloc>\n+  deque<_Tp,_Alloc>&\n+  deque<_Tp,_Alloc>::\n+  operator=(const deque& __x)\n+  {\n+    const size_type __len = size();\n+    if (&__x != this)\n+    {\n+      if (__len >= __x.size())\n+        erase(copy(__x.begin(), __x.end(), _M_start), _M_finish);\n+      else\n+      {\n+        const_iterator __mid = __x.begin() + difference_type(__len);\n+        copy(__x.begin(), __mid, _M_start);\n+        insert(_M_finish, __mid, __x.end());\n+      }\n+    }\n+    return *this;\n+  }        \n+\n+template <typename _Tp, typename _Alloc>\n+  typename deque<_Tp,_Alloc>::iterator \n+  deque<_Tp,_Alloc>::\n+  insert(iterator position, const value_type& __x)\n+  {\n+    if (position._M_cur == _M_start._M_cur)\n+    {\n+      push_front(__x);\n+      return _M_start;\n+    }\n+    else if (position._M_cur == _M_finish._M_cur)\n+    {\n+      push_back(__x);\n+      iterator __tmp = _M_finish;\n+      --__tmp;\n+      return __tmp;\n+    }\n+    else\n+      return _M_insert_aux(position, __x);\n+  }\n+\n+template <typename _Tp, typename _Alloc>\n+  typename deque<_Tp,_Alloc>::iterator \n+  deque<_Tp,_Alloc>::\n+  erase(iterator __position)\n+  {\n+    iterator __next = __position;\n+    ++__next;\n+    size_type __index = __position - _M_start;\n+    if (__index < (size() >> 1))\n+    {\n+      copy_backward(_M_start, __position, __next);\n+      pop_front();\n+    }\n+    else\n+    {\n+      copy(__next, _M_finish, __position);\n+      pop_back();\n+    }\n+    return _M_start + __index;\n+  }\n+\n+template <typename _Tp, typename _Alloc>\n+  typename deque<_Tp,_Alloc>::iterator \n+  deque<_Tp,_Alloc>::\n+  erase(iterator __first, iterator __last)\n+  {\n+    if (__first == _M_start && __last == _M_finish)\n+    {\n+      clear();\n+      return _M_finish;\n+    }\n+    else\n+    {\n+      difference_type __n = __last - __first;\n+      difference_type __elems_before = __first - _M_start;\n+      if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)\n+      {\n+        copy_backward(_M_start, __first, __last);\n+        iterator __new_start = _M_start + __n;\n+        _Destroy(_M_start, __new_start);\n+        _M_destroy_nodes(_M_start._M_node, __new_start._M_node);\n+        _M_start = __new_start;\n+      }\n+      else\n+      {\n+        copy(__last, _M_finish, __first);\n+        iterator __new_finish = _M_finish - __n;\n+        _Destroy(__new_finish, _M_finish);\n+        _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);\n+        _M_finish = __new_finish;\n+      }\n+      return _M_start + __elems_before;\n+    }\n+  }\n+  \n+template <typename _Tp, typename _Alloc> \n+  void\n+  deque<_Tp,_Alloc>::\n+  clear()\n+  {\n+    for (_Map_pointer __node = _M_start._M_node + 1;\n+         __node < _M_finish._M_node;\n+         ++__node)\n+    {\n+      _Destroy(*__node, *__node + _S_buffer_size());\n+      _M_deallocate_node(*__node);\n+    }\n+  \n+    if (_M_start._M_node != _M_finish._M_node)\n+    {\n+      _Destroy(_M_start._M_cur, _M_start._M_last);\n+      _Destroy(_M_finish._M_first, _M_finish._M_cur);\n+      _M_deallocate_node(_M_finish._M_first);\n+    }\n+    else\n+      _Destroy(_M_start._M_cur, _M_finish._M_cur);\n+  \n+    _M_finish = _M_start;\n+  }\n+  \n+template <typename _Tp, class _Alloc>\n+  template <typename _InputIter>\n+    void\n+    deque<_Tp,_Alloc>\n+    ::_M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n+    {\n+      iterator __cur = begin();\n+      for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n+        *__cur = *__first;\n+      if (__first == __last)\n+        erase(__cur, end());\n+      else\n+        insert(end(), __first, __last);\n+    }\n+  \n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n+  {\n+    if (__pos._M_cur == _M_start._M_cur)\n+    {\n+      iterator __new_start = _M_reserve_elements_at_front(__n);\n+      try\n+        {\n+          uninitialized_fill(__new_start, _M_start, __x);\n+          _M_start = __new_start;\n+        }\n+      catch(...)\n+        {\n+          _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+          __throw_exception_again;\n+        }\n+    }\n+    else if (__pos._M_cur == _M_finish._M_cur)\n+    {\n+      iterator __new_finish = _M_reserve_elements_at_back(__n);\n+      try\n+        {\n+          uninitialized_fill(_M_finish, __new_finish, __x);\n+          _M_finish = __new_finish;\n+        }\n+      catch(...)\n+        {\n+          _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);    \n+          __throw_exception_again;\n+        }\n+    }\n+    else \n+      _M_insert_aux(__pos, __n, __x);\n+  }\n+  \n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_fill_initialize(const value_type& __value)\n+  {\n+    _Map_pointer __cur;\n+    try\n+      {\n+        for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)\n+          uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n+        uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);\n+      }\n+    catch(...)\n+      {\n+        _Destroy(_M_start, iterator(*__cur, __cur));\n+        __throw_exception_again;\n+      }\n+  }\n+  \n+template <typename _Tp, typename _Alloc>\n+  template <typename _InputIterator>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_range_initialize(_InputIterator __first, _InputIterator __last,\n+                        input_iterator_tag)\n+    {\n+      _M_initialize_map(0);\n+      try\n+        {\n+          for ( ; __first != __last; ++__first)\n+            push_back(*__first);\n+        }\n+      catch(...)\n+        {\n+          clear();\n+          __throw_exception_again;\n+        }\n+    }\n+  \n+template <typename _Tp, typename _Alloc>\n+  template <typename _ForwardIterator>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n+                        forward_iterator_tag)\n+    {\n+      size_type __n = distance(__first, __last);\n+      _M_initialize_map(__n);\n+    \n+      _Map_pointer __cur_node;\n+      try\n+        {\n+          for (__cur_node = _M_start._M_node; \n+               __cur_node < _M_finish._M_node; \n+               ++__cur_node)\n+          {\n+            _ForwardIterator __mid = __first;\n+            advance(__mid, _S_buffer_size());\n+            uninitialized_copy(__first, __mid, *__cur_node);\n+            __first = __mid;\n+          }\n+          uninitialized_copy(__first, __last, _M_finish._M_first);\n+        }\n+      catch(...)\n+        {\n+          _Destroy(_M_start, iterator(*__cur_node, __cur_node));\n+          __throw_exception_again;\n+        }\n+    }\n+  \n+// Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_push_back_aux(const value_type& __t)\n+  {\n+    value_type __t_copy = __t;\n+    _M_reserve_map_at_back();\n+    *(_M_finish._M_node + 1) = _M_allocate_node();\n+    try\n+      {\n+        _Construct(_M_finish._M_cur, __t_copy);\n+        _M_finish._M_set_node(_M_finish._M_node + 1);\n+        _M_finish._M_cur = _M_finish._M_first;\n+      }\n+    catch(...)\n+      {\n+        _M_deallocate_node(*(_M_finish._M_node + 1));\n+        __throw_exception_again;\n+      }\n+  }\n+  \n+#ifdef _GLIBCPP_DEPRECATED\n+// Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_push_back_aux()\n+  {\n+    _M_reserve_map_at_back();\n+    *(_M_finish._M_node + 1) = _M_allocate_node();\n+    try\n+      {\n+        _Construct(_M_finish._M_cur);\n+        _M_finish._M_set_node(_M_finish._M_node + 1);\n+        _M_finish._M_cur = _M_finish._M_first;\n+      }\n+    catch(...)\n+      {\n+        _M_deallocate_node(*(_M_finish._M_node + 1));\n+        __throw_exception_again;\n+      }\n+  }\n+#endif\n+  \n+// Called only if _M_start._M_cur == _M_start._M_first.\n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_push_front_aux(const value_type& __t)\n+  {\n+    value_type __t_copy = __t;\n+    _M_reserve_map_at_front();\n+    *(_M_start._M_node - 1) = _M_allocate_node();\n+    try\n+      {\n+        _M_start._M_set_node(_M_start._M_node - 1);\n+        _M_start._M_cur = _M_start._M_last - 1;\n+        _Construct(_M_start._M_cur, __t_copy);\n+      }\n+    catch(...)\n+      {\n+        ++_M_start;\n+        _M_deallocate_node(*(_M_start._M_node - 1));\n+        __throw_exception_again;\n+      }\n+  } \n+  \n+#ifdef _GLIBCPP_DEPRECATED\n+// Called only if _M_start._M_cur == _M_start._M_first.\n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_push_front_aux()\n+  {\n+    _M_reserve_map_at_front();\n+    *(_M_start._M_node - 1) = _M_allocate_node();\n+    try\n+      {\n+        _M_start._M_set_node(_M_start._M_node - 1);\n+        _M_start._M_cur = _M_start._M_last - 1;\n+        _Construct(_M_start._M_cur);\n+      }\n+    catch(...)\n+      {\n+        ++_M_start;\n+        _M_deallocate_node(*(_M_start._M_node - 1));\n+        __throw_exception_again;\n+      }\n+  } \n+#endif\n+  \n+// Called only if _M_finish._M_cur == _M_finish._M_first.\n+template <typename _Tp, typename _Alloc>\n+  void deque<_Tp,_Alloc>::\n+  _M_pop_back_aux()\n+  {\n+    _M_deallocate_node(_M_finish._M_first);\n+    _M_finish._M_set_node(_M_finish._M_node - 1);\n+    _M_finish._M_cur = _M_finish._M_last - 1;\n+    _Destroy(_M_finish._M_cur);\n+  }\n+  \n+// Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that \n+// if the deque has at least one element (a precondition for this member \n+// function), and if _M_start._M_cur == _M_start._M_last, then the deque \n+// must have at least two nodes.\n+template <typename _Tp, typename _Alloc>\n+  void deque<_Tp,_Alloc>::\n+  _M_pop_front_aux()\n+  {\n+    _Destroy(_M_start._M_cur);\n+    _M_deallocate_node(_M_start._M_first);\n+    _M_start._M_set_node(_M_start._M_node + 1);\n+    _M_start._M_cur = _M_start._M_first;\n+  }      \n+  \n+template <typename _Tp, typename _Alloc>\n+  template <typename _InputIterator>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_range_insert_aux(iterator __pos,\n+                        _InputIterator __first, _InputIterator __last,\n+                        input_iterator_tag)\n+    {\n+      copy(__first, __last, inserter(*this, __pos));\n+    }\n+  \n+template <typename _Tp, typename _Alloc>\n+  template <typename _ForwardIterator>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_range_insert_aux(iterator __pos,\n+                        _ForwardIterator __first, _ForwardIterator __last,\n+                        forward_iterator_tag)\n+    {\n+      size_type __n = distance(__first, __last);\n+      if (__pos._M_cur == _M_start._M_cur)\n+      {\n+        iterator __new_start = _M_reserve_elements_at_front(__n);\n+        try\n+          {\n+            uninitialized_copy(__first, __last, __new_start);\n+            _M_start = __new_start;\n+          }\n+        catch(...)\n+          {\n+            _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+            __throw_exception_again;\n+          }\n+      }\n+      else if (__pos._M_cur == _M_finish._M_cur)\n+      {\n+        iterator __new_finish = _M_reserve_elements_at_back(__n);\n+        try\n+          {\n+            uninitialized_copy(__first, __last, _M_finish);\n+            _M_finish = __new_finish;\n+          }\n+        catch(...)\n+          {\n+            _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+            __throw_exception_again;\n+          }\n+      }\n+      else\n+        _M_insert_aux(__pos, __first, __last, __n);\n+    }\n+  \n+template <typename _Tp, typename _Alloc>\n+  typename deque<_Tp, _Alloc>::iterator\n+  deque<_Tp,_Alloc>::\n+  _M_insert_aux(iterator __pos, const value_type& __x)\n+  {\n+    difference_type __index = __pos - _M_start;\n+    value_type __x_copy = __x; // XXX copy\n+    if (static_cast<size_type>(__index) < size() / 2)\n+    {\n+      push_front(front());\n+      iterator __front1 = _M_start;\n+      ++__front1;\n+      iterator __front2 = __front1;\n+      ++__front2;\n+      __pos = _M_start + __index;\n+      iterator __pos1 = __pos;\n+      ++__pos1;\n+      copy(__front2, __pos1, __front1);\n+    }\n+    else\n+    {\n+      push_back(back());\n+      iterator __back1 = _M_finish;\n+      --__back1;\n+      iterator __back2 = __back1;\n+      --__back2;\n+      __pos = _M_start + __index;\n+      copy_backward(__pos, __back2, __back1);\n+    }\n+    *__pos = __x_copy;\n+    return __pos;\n+  }\n+  \n+#ifdef _GLIBCPP_DEPRECATED\n+// Nothing seems to actually use this.  According to the pattern followed by\n+// the rest of the SGI code, it would be called by the deprecated insert(pos)\n+// function, but that has been replaced.  We'll take our time removing this\n+// anyhow; mark for 3.3.  -pme\n+template <typename _Tp, typename _Alloc>\n+  typename deque<_Tp,_Alloc>::iterator \n+  deque<_Tp,_Alloc>::\n+  _M_insert_aux(iterator __pos)\n+  {\n+    difference_type __index = __pos - _M_start;\n+    if (static_cast<size_type>(__index) < size() / 2)\n+    {\n+      push_front(front());\n+      iterator __front1 = _M_start;\n+      ++__front1;\n+      iterator __front2 = __front1;\n+      ++__front2;\n+      __pos = _M_start + __index;\n+      iterator __pos1 = __pos;\n+      ++__pos1;\n+      copy(__front2, __pos1, __front1);\n+    }\n+    else\n+    {\n+      push_back(back());\n+      iterator __back1 = _M_finish;\n+      --__back1;\n+      iterator __back2 = __back1;\n+      --__back2;\n+      __pos = _M_start + __index;\n+      copy_backward(__pos, __back2, __back1);\n+    }\n+    *__pos = value_type();\n+    return __pos;\n+  }\n+#endif\n+  \n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)\n+  {\n+    const difference_type __elems_before = __pos - _M_start;\n+    size_type __length = this->size();\n+    value_type __x_copy = __x;\n+    if (__elems_before < difference_type(__length / 2))\n+    {\n+      iterator __new_start = _M_reserve_elements_at_front(__n);\n+      iterator __old_start = _M_start;\n+      __pos = _M_start + __elems_before;\n+      try\n+        {\n+          if (__elems_before >= difference_type(__n))\n+          {\n+            iterator __start_n = _M_start + difference_type(__n);\n+            uninitialized_copy(_M_start, __start_n, __new_start);\n+            _M_start = __new_start;\n+            copy(__start_n, __pos, __old_start);\n+            fill(__pos - difference_type(__n), __pos, __x_copy);\n+          }\n+          else\n+          {\n+            __uninitialized_copy_fill(_M_start, __pos, __new_start, \n+                                      _M_start, __x_copy);\n+            _M_start = __new_start;\n+            fill(__old_start, __pos, __x_copy);\n+          }\n+        }\n+      catch(...)\n+        { \n+          _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+          __throw_exception_again;\n+        }\n+    }\n+    else\n+    {\n+      iterator __new_finish = _M_reserve_elements_at_back(__n);\n+      iterator __old_finish = _M_finish;\n+      const difference_type __elems_after = \n+        difference_type(__length) - __elems_before;\n+      __pos = _M_finish - __elems_after;\n+      try\n+        {\n+          if (__elems_after > difference_type(__n))\n+          {\n+            iterator __finish_n = _M_finish - difference_type(__n);\n+            uninitialized_copy(__finish_n, _M_finish, _M_finish);\n+            _M_finish = __new_finish;\n+            copy_backward(__pos, __finish_n, __old_finish);\n+            fill(__pos, __pos + difference_type(__n), __x_copy);\n+          }\n+          else\n+          {\n+            __uninitialized_fill_copy(_M_finish, __pos + difference_type(__n),\n+                                      __x_copy, __pos, _M_finish);\n+            _M_finish = __new_finish;\n+            fill(__pos, __old_finish, __x_copy);\n+          }\n+        }\n+      catch(...)\n+        { \n+          _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+          __throw_exception_again;\n+        }\n+    }\n+  }\n+  \n+template <typename _Tp, typename _Alloc>\n+  template <typename _ForwardIterator>\n+    void\n+    deque<_Tp,_Alloc>::\n+    _M_insert_aux(iterator __pos,\n+                  _ForwardIterator __first, _ForwardIterator __last,\n+                  size_type __n)\n+    {\n+      const difference_type __elemsbefore = __pos - _M_start;\n+      size_type __length = size();\n+      if (static_cast<size_type>(__elemsbefore) < __length / 2)\n+      {\n+        iterator __new_start = _M_reserve_elements_at_front(__n);\n+        iterator __old_start = _M_start;\n+        __pos = _M_start + __elemsbefore;\n+        try\n+          {\n+            if (__elemsbefore >= difference_type(__n))\n+            {\n+              iterator __start_n = _M_start + difference_type(__n); \n+              uninitialized_copy(_M_start, __start_n, __new_start);\n+              _M_start = __new_start;\n+              copy(__start_n, __pos, __old_start);\n+              copy(__first, __last, __pos - difference_type(__n));\n+            }\n+            else\n+            {\n+              _ForwardIterator __mid = __first;\n+              advance(__mid, difference_type(__n) - __elemsbefore);\n+              __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n+                                        __new_start);\n+              _M_start = __new_start;\n+              copy(__mid, __last, __old_start);\n+            }\n+          }\n+        catch(...)\n+          {\n+            _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+            __throw_exception_again;\n+          }\n+      }\n+      else\n+      {\n+        iterator __new_finish = _M_reserve_elements_at_back(__n);\n+        iterator __old_finish = _M_finish;\n+        const difference_type __elemsafter = \n+          difference_type(__length) - __elemsbefore;\n+        __pos = _M_finish - __elemsafter;\n+        try\n+          {\n+            if (__elemsafter > difference_type(__n))\n+            {\n+              iterator __finish_n = _M_finish - difference_type(__n);\n+              uninitialized_copy(__finish_n, _M_finish, _M_finish);\n+              _M_finish = __new_finish;\n+              copy_backward(__pos, __finish_n, __old_finish);\n+              copy(__first, __last, __pos);\n+            }\n+            else\n+            {\n+              _ForwardIterator __mid = __first;\n+              advance(__mid, __elemsafter);\n+              __uninitialized_copy_copy(__mid, __last, __pos,\n+                                        _M_finish, _M_finish);\n+              _M_finish = __new_finish;\n+              copy(__first, __mid, __pos);\n+            }\n+          }\n+        catch(...)\n+          {\n+            _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+            __throw_exception_again;\n+          }\n+      }\n+    }\n+  \n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_new_elements_at_front(size_type __new_elems)\n+  {\n+    size_type __new_nodes\n+        = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n+    _M_reserve_map_at_front(__new_nodes);\n+    size_type __i;\n+    try\n+      {\n+        for (__i = 1; __i <= __new_nodes; ++__i)\n+          *(_M_start._M_node - __i) = _M_allocate_node();\n+      }\n+    catch(...)\n+      {\n+        for (size_type __j = 1; __j < __i; ++__j)\n+          _M_deallocate_node(*(_M_start._M_node - __j));      \n+        __throw_exception_again;\n+      }\n+  }\n+  \n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_new_elements_at_back(size_type __new_elems)\n+  {\n+    size_type __new_nodes\n+        = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n+    _M_reserve_map_at_back(__new_nodes);\n+    size_type __i;\n+    try\n+      {\n+        for (__i = 1; __i <= __new_nodes; ++__i)\n+          *(_M_finish._M_node + __i) = _M_allocate_node();\n+      }\n+    catch(...)\n+      {\n+        for (size_type __j = 1; __j < __i; ++__j)\n+          _M_deallocate_node(*(_M_finish._M_node + __j));      \n+        __throw_exception_again;\n+      }\n+  }\n+  \n+template <typename _Tp, typename _Alloc>\n+  void\n+  deque<_Tp,_Alloc>::\n+  _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)\n+  {\n+    size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;\n+    size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;\n+  \n+    _Map_pointer __new_nstart;\n+    if (_M_map_size > 2 * __new_num_nodes)\n+    {\n+      __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 \n+                       + (__add_at_front ? __nodes_to_add : 0);\n+      if (__new_nstart < _M_start._M_node)\n+        copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n+      else\n+        copy_backward(_M_start._M_node, _M_finish._M_node + 1, \n+                      __new_nstart + __old_num_nodes);\n+    }\n+    else\n+    {\n+      size_type __new_map_size = \n+        _M_map_size + max(_M_map_size, __nodes_to_add) + 2;\n+  \n+      _Map_pointer __new_map = _M_allocate_map(__new_map_size);\n+      __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n+                           + (__add_at_front ? __nodes_to_add : 0);\n+      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n+      _M_deallocate_map(_M_map, _M_map_size);\n+  \n+      _M_map = __new_map;\n+      _M_map_size = __new_map_size;\n+    }\n+  \n+    _M_start._M_set_node(__new_nstart);\n+    _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n+  }\n+\n+} // namespace std \n+  \n+#endif /* __GLIBCPP_INTERNAL_DEQUE_TCC */\n+"}, {"sha": "7fbfa9dd375eaa88076a64c2b35cf5e4c236b8b8", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -0,0 +1,374 @@\n+// List implementation (out of line) -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/** @file list.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef __GLIBCPP_INTERNAL_LIST_TCC\n+#define __GLIBCPP_INTERNAL_LIST_TCC\n+\n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n+namespace std\n+{\n+\n+template<typename _Tp, typename _Alloc>\n+  void\n+  _List_base<_Tp,_Alloc>::\n+  __clear()\n+  {\n+    typedef _List_node<_Tp>  _Node;\n+    _Node* __cur = static_cast<_Node*>(_M_node->_M_next);\n+    while (__cur != _M_node)\n+    {\n+      _Node* __tmp = __cur;\n+      __cur = static_cast<_Node*>(__cur->_M_next);\n+      _Destroy(&__tmp->_M_data);\n+      _M_put_node(__tmp);\n+    }\n+    _M_node->_M_next = _M_node;\n+    _M_node->_M_prev = _M_node;\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  typename list<_Tp,_Alloc>::iterator\n+  list<_Tp,_Alloc>::\n+  insert(iterator __position, const value_type& __x)\n+  {\n+    _Node* __tmp = _M_create_node(__x);\n+    __tmp->_M_next = __position._M_node;\n+    __tmp->_M_prev = __position._M_node->_M_prev;\n+    __position._M_node->_M_prev->_M_next = __tmp;\n+    __position._M_node->_M_prev = __tmp;\n+    return __tmp;\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  typename list<_Tp,_Alloc>::iterator\n+  list<_Tp,_Alloc>::\n+  erase(iterator __position)\n+  {\n+    _List_node_base* __next_node = __position._M_node->_M_next;\n+    _List_node_base* __prev_node = __position._M_node->_M_prev;\n+    _Node* __n = static_cast<_Node*>(__position._M_node);\n+    __prev_node->_M_next = __next_node;\n+    __next_node->_M_prev = __prev_node;\n+    _Destroy(&__n->_M_data);\n+    _M_put_node(__n);\n+    return iterator(static_cast<_Node*>(__next_node));\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  void\n+  list<_Tp,_Alloc>::\n+  resize(size_type __new_size, const value_type& __x)\n+  {\n+    iterator __i = begin();\n+    size_type __len = 0;\n+    for ( ; __i != end() && __len < __new_size; ++__i, ++__len)\n+      ;\n+    if (__len == __new_size)\n+      erase(__i, end());\n+    else                          // __i == end()\n+      insert(end(), __new_size - __len, __x);\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  list<_Tp,_Alloc>&\n+  list<_Tp,_Alloc>::\n+  operator=(const list& __x)\n+  {\n+    if (this != &__x)\n+    {\n+      iterator __first1 = begin();\n+      iterator __last1 = end();\n+      const_iterator __first2 = __x.begin();\n+      const_iterator __last2 = __x.end();\n+      while (__first1 != __last1 && __first2 != __last2)\n+        *__first1++ = *__first2++;\n+      if (__first2 == __last2)\n+        erase(__first1, __last1);\n+      else\n+        insert(__last1, __first2, __last2);\n+    }\n+    return *this;\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  void\n+  list<_Tp,_Alloc>::\n+  _M_fill_assign(size_type __n, const value_type& __val)\n+  {\n+    iterator __i = begin();\n+    for ( ; __i != end() && __n > 0; ++__i, --__n)\n+      *__i = __val;\n+    if (__n > 0)\n+      insert(end(), __n, __val);\n+    else\n+      erase(__i, end());\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  template <typename _InputIter>\n+    void\n+    list<_Tp,_Alloc>::\n+    _M_assign_dispatch(_InputIter __first2, _InputIter __last2, __false_type)\n+    {\n+      iterator __first1 = begin();\n+      iterator __last1 = end();\n+      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n+        *__first1 = *__first2;\n+      if (__first2 == __last2)\n+        erase(__first1, __last1);\n+      else\n+        insert(__last1, __first2, __last2);\n+    }\n+\n+template<typename _Tp, typename _Alloc>\n+  void\n+  list<_Tp,_Alloc>::\n+  remove(const value_type& __value)\n+  {\n+    iterator __first = begin();\n+    iterator __last = end();\n+    while (__first != __last)\n+    {\n+      iterator __next = __first;\n+      ++__next;\n+      if (*__first == __value)\n+        erase(__first);\n+      __first = __next;\n+    }\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  void\n+  list<_Tp,_Alloc>::\n+  unique()\n+  {\n+    iterator __first = begin();\n+    iterator __last = end();\n+    if (__first == __last) return;\n+    iterator __next = __first;\n+    while (++__next != __last)\n+    {\n+      if (*__first == *__next)\n+        erase(__next);\n+      else\n+        __first = __next;\n+      __next = __first;\n+    }\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  void\n+  list<_Tp,_Alloc>::\n+  merge(list& __x)\n+  {\n+    iterator __first1 = begin();\n+    iterator __last1 = end();\n+    iterator __first2 = __x.begin();\n+    iterator __last2 = __x.end();\n+    while (__first1 != __last1 && __first2 != __last2)\n+      if (*__first2 < *__first1)\n+      {\n+        iterator __next = __first2;\n+        _M_transfer(__first1, __first2, ++__next);\n+        __first2 = __next;\n+      }\n+      else\n+        ++__first1;\n+    if (__first2 != __last2)\n+      _M_transfer(__last1, __first2, __last2);\n+  }\n+\n+// FIXME put this somewhere else\n+inline void\n+__List_base_reverse(_List_node_base* __p)\n+{\n+  _List_node_base* __tmp = __p;\n+  do {\n+    std::swap(__tmp->_M_next, __tmp->_M_prev);\n+    __tmp = __tmp->_M_prev;     // Old next node is now prev.\n+  } while (__tmp != __p);\n+}\n+\n+template<typename _Tp, typename _Alloc>\n+  void\n+  list<_Tp,_Alloc>::\n+  sort()\n+  {\n+    // Do nothing if the list has length 0 or 1.\n+    if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)\n+    {\n+      list __carry;\n+      list __counter[64];\n+      int __fill = 0;\n+      while (!empty())\n+      {\n+        __carry.splice(__carry.begin(), *this, begin());\n+        int __i = 0;\n+        while(__i < __fill && !__counter[__i].empty())\n+        {\n+          __counter[__i].merge(__carry);\n+          __carry.swap(__counter[__i++]);\n+        }\n+        __carry.swap(__counter[__i]);\n+        if (__i == __fill) ++__fill;\n+      }\n+\n+      for (int __i = 1; __i < __fill; ++__i)\n+        __counter[__i].merge(__counter[__i-1]);\n+      swap(__counter[__fill-1]);\n+    }\n+  }\n+\n+template<typename _Tp, typename _Alloc>\n+  template <typename _Predicate>\n+    void\n+    list<_Tp,_Alloc>::\n+    remove_if(_Predicate __pred)\n+    {\n+      iterator __first = begin();\n+      iterator __last = end();\n+      while (__first != __last)\n+      {\n+        iterator __next = __first;\n+        ++__next;\n+        if (__pred(*__first)) erase(__first);\n+        __first = __next;\n+      }\n+    }\n+\n+template<typename _Tp, typename _Alloc>\n+  template <typename _BinaryPredicate>\n+    void\n+    list<_Tp,_Alloc>::\n+    unique(_BinaryPredicate __binary_pred)\n+    {\n+      iterator __first = begin();\n+      iterator __last = end();\n+      if (__first == __last) return;\n+      iterator __next = __first;\n+      while (++__next != __last)\n+      {\n+        if (__binary_pred(*__first, *__next))\n+          erase(__next);\n+        else\n+          __first = __next;\n+        __next = __first;\n+      }\n+    }\n+\n+template<typename _Tp, typename _Alloc>\n+  template <typename _StrictWeakOrdering>\n+    void\n+    list<_Tp,_Alloc>::\n+    merge(list& __x, _StrictWeakOrdering __comp)\n+    {\n+      iterator __first1 = begin();\n+      iterator __last1 = end();\n+      iterator __first2 = __x.begin();\n+      iterator __last2 = __x.end();\n+      while (__first1 != __last1 && __first2 != __last2)\n+        if (__comp(*__first2, *__first1))\n+        {\n+          iterator __next = __first2;\n+          _M_transfer(__first1, __first2, ++__next);\n+          __first2 = __next;\n+        }\n+        else\n+          ++__first1;\n+      if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n+    }\n+\n+template<typename _Tp, typename _Alloc>\n+  template <typename _StrictWeakOrdering>\n+  void\n+  list<_Tp,_Alloc>::\n+  sort(_StrictWeakOrdering __comp)\n+  {\n+    // Do nothing if the list has length 0 or 1.\n+    if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)\n+    {\n+      list __carry;\n+      list __counter[64];\n+      int __fill = 0;\n+      while (!empty())\n+      {\n+        __carry.splice(__carry.begin(), *this, begin());\n+        int __i = 0;\n+        while(__i < __fill && !__counter[__i].empty())\n+        {\n+          __counter[__i].merge(__carry, __comp);\n+          __carry.swap(__counter[__i++]);\n+        }\n+        __carry.swap(__counter[__i]);\n+        if (__i == __fill) ++__fill;\n+      }\n+\n+      for (int __i = 1; __i < __fill; ++__i)\n+        __counter[__i].merge(__counter[__i-1], __comp);\n+      swap(__counter[__fill-1]);\n+    }\n+  }\n+\n+} // namespace std\n+\n+#endif /* __GLIBCPP_INTERNAL_LIST_TCC */\n+"}, {"sha": "1eedc6a1abf59c40637578a00557df2245fcdaa0", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 67, "deletions": 674, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -100,7 +100,7 @@ __deque_buf_size(size_t __size)\n  *  All the functions are op overloads except for _M_set_node.\n  *  @endif\n */\n-template <class _Tp, class _Ref, class _Ptr>\n+template <typename _Tp, typename _Ref, typename _Ptr>\n   struct _Deque_iterator\n {\n   typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n@@ -214,39 +214,41 @@ template <class _Tp, class _Ref, class _Ptr>\n // Note: we also provide overloads whose operands are of the same type in\n // order to avoid ambiguous overload resolution when std::rel_ops operators\n // are in scope (for additional details, see libstdc++/3628)\n-template <class _Tp, class _Ref, class _Ptr>\n+template <typename _Tp, typename _Ref, typename _Ptr>\n inline bool\n operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n {\n   return __x._M_cur == __y._M_cur;\n }\n \n-template <class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR>\n+template <typename _Tp, typename _RefL, typename _PtrL,\n+                        typename _RefR, typename _PtrR>\n inline bool\n operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n {\n   return __x._M_cur == __y._M_cur;\n }\n \n-template <class _Tp, class _Ref, class _Ptr>\n+template <typename _Tp, typename _Ref, typename _Ptr>\n inline bool\n operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n {\n   return !(__x == __y);\n }\n \n-template <class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR>\n+template <typename _Tp, typename _RefL, typename _PtrL,\n+                        typename _RefR, typename _PtrR>\n inline bool\n operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n {\n   return !(__x == __y);\n }\n \n-template <class _Tp, class _Ref, class _Ptr>\n+template <typename _Tp, typename _Ref, typename _Ptr>\n inline bool\n operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n@@ -255,7 +257,8 @@ operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n     (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);\n }\n \n-template <class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR>\n+template <typename _Tp, typename _RefL, typename _PtrL,\n+                        typename _RefR, typename _PtrR>\n inline bool\n operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n@@ -264,55 +267,58 @@ operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n     (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);\n }\n \n-template <class _Tp, class _Ref, class _Ptr>\n+template <typename _Tp, typename _Ref, typename _Ptr>\n inline bool\n operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n {\n   return __y < __x;\n }\n \n-template <class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR>\n+template <typename _Tp, typename _RefL, typename _PtrL,\n+                        typename _RefR, typename _PtrR>\n inline bool\n operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n {\n   return __y < __x;\n }\n \n-template <class _Tp, class _Ref, class _Ptr>\n+template <typename _Tp, typename _Ref, typename _Ptr>\n inline bool\n operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n {\n   return !(__y < __x);\n }\n \n-template <class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR>\n+template <typename _Tp, typename _RefL, typename _PtrL,\n+                        typename _RefR, typename _PtrR>\n inline bool\n operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n {\n   return !(__y < __x);\n }\n \n-template <class _Tp, class _Ref, class _Ptr>\n+template <typename _Tp, typename _Ref, typename _Ptr>\n inline bool\n operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n {\n   return !(__x < __y);\n }\n \n-template <class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR>\n+template <typename _Tp, typename _RefL, typename _PtrL,\n+                        typename _RefR, typename _PtrR>\n inline bool\n operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n \t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n {\n   return !(__x < __y);\n }\n \n-template <class _Tp, class _Ref, class _Ptr>\n+template <typename _Tp, typename _Ref, typename _Ptr>\n inline _Deque_iterator<_Tp, _Ref, _Ptr>\n operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n {\n@@ -332,7 +338,7 @@ operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n  *  instanceless allocators.\n  *  @endif\n */\n-template <class _Tp, class _Alloc, bool __is_static>\n+template <typename _Tp, typename _Alloc, bool __is_static>\n   class _Deque_alloc_base\n {\n public:\n@@ -375,7 +381,7 @@ template <class _Tp, class _Alloc, bool __is_static>\n };\n \n /// @if maint Specialization for instanceless allocators.  @endif\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n   class _Deque_alloc_base<_Tp, _Alloc, true>\n {\n public:\n@@ -425,7 +431,7 @@ template <class _Tp, class _Alloc>\n  *  (Deque handles that itself.)  Only/All memory management is performed here.\n  *  @endif\n */\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n   class _Deque_base\n   : public _Deque_alloc_base<_Tp,_Alloc,\n                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n@@ -456,7 +462,7 @@ template <class _Tp, class _Alloc>\n };\n \n \n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n _Deque_base<_Tp,_Alloc>::~_Deque_base()\n {\n   if (_M_map)\n@@ -475,7 +481,7 @@ _Deque_base<_Tp,_Alloc>::~_Deque_base()\n  *  The initial underlying memory layout is a bit complicated...\n  *  @endif\n */\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n void\n _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n {\n@@ -509,7 +515,7 @@ _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n                      __num_elements % __deque_buf_size(sizeof(_Tp));\n }\n \n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n void _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n {\n   _Tp** __cur;\n@@ -525,7 +531,7 @@ void _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n     }\n }\n \n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n void\n _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n {\n@@ -616,7 +622,7 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n  *  use other standard algorithms as well.\n  *  @endif\n */\n-template <class _Tp, class _Alloc = allocator<_Tp> >\n+template <typename _Tp, typename _Alloc = allocator<_Tp> >\n   class deque : protected _Deque_base<_Tp, _Alloc>\n {\n   // concept requirements\n@@ -720,7 +726,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  input iterators are used, then this will do at most 2N calls to the\n    *  copy constructor, and logN memory reallocations.\n   */\n-  template<class _InputIterator>\n+  template<typename _InputIterator>\n     deque(_InputIterator __first, _InputIterator __last,\n           const allocator_type& __a = allocator_type())\n       : _Base(__a)\n@@ -745,20 +751,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  allocator object is not copied.\n   */\n   deque&\n-  operator=(const deque& __x)  // FIXME move to tcc\n-  {\n-    const size_type __len = size();\n-    if (&__x != this) {\n-      if (__len >= __x.size())\n-        erase(copy(__x.begin(), __x.end(), _M_start), _M_finish);\n-      else {\n-        const_iterator __mid = __x.begin() + difference_type(__len);\n-        copy(__x.begin(), __mid, _M_start);\n-        insert(_M_finish, __mid, __x.end());\n-      }\n-    }\n-    return *this;\n-  }        \n+  operator=(const deque& __x);\n \n   /**\n    *  @brief  Assigns a given value to a %deque.\n@@ -785,7 +778,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  resulting %deque's size is the same as the number of elements assigned.\n    *  Old data may be lost.\n   */\n-  template<class _InputIterator>\n+  template<typename _InputIterator>\n     void\n     assign(_InputIterator __first, _InputIterator __last)\n     {\n@@ -1138,22 +1131,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  location.\n   */\n   iterator\n-  insert(iterator position, const value_type& __x)\n-  {\n-    if (position._M_cur == _M_start._M_cur) {\n-      push_front(__x);\n-      return _M_start;\n-    }\n-    else if (position._M_cur == _M_finish._M_cur) {\n-      push_back(__x);\n-      iterator __tmp = _M_finish;\n-      --__tmp;\n-      return __tmp;\n-    }\n-    else {\n-      return _M_insert_aux(position, __x);\n-    }\n-  }\n+  insert(iterator position, const value_type& __x);\n \n #ifdef _GLIBCPP_DEPRECATED\n   /**\n@@ -1197,7 +1175,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  into the %deque before the location specified by @a pos.  This is\n    *  known as \"range insert.\"\n   */\n-  template<class _InputIterator>\n+  template<typename _InputIterator>\n     void\n     insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n     {\n@@ -1220,21 +1198,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  the pointer is the user's responsibilty.\n   */\n   iterator\n-  erase(iterator __position)\n-  {\n-    iterator __next = __position;\n-    ++__next;\n-    size_type __index = __position - _M_start;\n-    if (__index < (size() >> 1)) {\n-      copy_backward(_M_start, __position, __next);\n-      pop_front();\n-    }\n-    else {\n-      copy(__next, _M_finish, __position);\n-      pop_back();\n-    }\n-    return _M_start + __index;\n-  }\n+  erase(iterator __position);\n \n   /**\n    *  @brief  Remove a range of elements.\n@@ -1284,7 +1248,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n   // Internal constructor functions follow.\n \n   // called by the range constructor to implement [23.1.1]/9\n-  template<class _Integer>\n+  template<typename _Integer>\n     void\n     _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n     {\n@@ -1293,7 +1257,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the range constructor to implement [23.1.1]/9\n-  template<class _InputIter>\n+  template<typename _InputIter>\n     void\n     _M_initialize_dispatch(_InputIter __first, _InputIter __last, __false_type)\n     {\n@@ -1303,16 +1267,29 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the second initialize_dispatch above\n-  template <class _InputIterator>\n+  /** @{\n+   *  @if maint\n+   *  @brief Fills the deque with whatever is in [first,last).\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   *  @return   Nothing.\n+   *\n+   *  If the iterators are actually forward iterators (or better), then the\n+   *  memory layout can be done all at once.  Else we move forward using\n+   *  push_back on each value from the iterator.\n+   *  @endif\n+  */\n+  template <typename _InputIterator>\n     void\n     _M_range_initialize(_InputIterator __first, _InputIterator __last,\n                         input_iterator_tag);\n \n   // called by the second initialize_dispatch above\n-  template <class _ForwardIterator>\n+  template <typename _ForwardIterator>\n     void\n     _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n                         forward_iterator_tag);\n+  /** @} */\n \n   /**\n    *  @if maint\n@@ -1334,7 +1311,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n   // assignment work for the range versions.\n \n   // called by the range assign to implement [23.1.1]/9\n-  template<class _Integer>\n+  template<typename _Integer>\n     void\n     _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n     {\n@@ -1343,7 +1320,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the range assign to implement [23.1.1]/9\n-  template<class _InputIter>\n+  template<typename _InputIter>\n     void\n     _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n     {\n@@ -1353,13 +1330,13 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the second assign_dispatch above\n-  template <class _InputIterator>\n+  template <typename _InputIterator>\n     void\n     _M_assign_aux(_InputIterator __first, _InputIterator __last,\n                   input_iterator_tag);\n \n   // called by the second assign_dispatch above\n-  template <class _ForwardIterator>\n+  template <typename _ForwardIterator>\n     void\n     _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n                   forward_iterator_tag)\n@@ -1413,7 +1390,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n   // insertion work when all shortcuts fail.\n \n   // called by the range insert to implement [23.1.1]/9\n-  template<class _Integer>\n+  template<typename _Integer>\n     void\n     _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)\n     {\n@@ -1422,7 +1399,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the range insert to implement [23.1.1]/9\n-  template<class _InputIterator>\n+  template<typename _InputIterator>\n     void\n     _M_insert_dispatch(iterator __pos,\n                        _InputIterator __first, _InputIterator __last,\n@@ -1434,13 +1411,13 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the second insert_dispatch above\n-  template <class _InputIterator>\n+  template <typename _InputIterator>\n     void\n     _M_range_insert_aux(iterator __pos, _InputIterator __first,\n                         _InputIterator __last, input_iterator_tag);\n \n   // called by the second insert_dispatch above\n-  template <class _ForwardIterator>\n+  template <typename _ForwardIterator>\n     void\n     _M_range_insert_aux(iterator __pos, _ForwardIterator __first,\n                         _ForwardIterator __last, forward_iterator_tag);\n@@ -1460,7 +1437,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n   _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n \n   // called by range_insert_aux for forward iterators\n-  template <class _ForwardIterator>\n+  template <typename _ForwardIterator>\n     void\n     _M_insert_aux(iterator __pos, \n                   _ForwardIterator __first, _ForwardIterator __last,\n@@ -1531,590 +1508,6 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n };\n \n \n-template <class _Tp, class _Alloc>\n-template <class _InputIter>\n-void deque<_Tp, _Alloc>\n-  ::_M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n-{\n-  iterator __cur = begin();\n-  for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n-    *__cur = *__first;\n-  if (__first == __last)\n-    erase(__cur, end());\n-  else\n-    insert(end(), __first, __last);\n-}\n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp, _Alloc>::_M_fill_insert(iterator __pos,\n-                                        size_type __n, const value_type& __x)\n-{\n-  if (__pos._M_cur == _M_start._M_cur)\n-  {\n-    iterator __new_start = _M_reserve_elements_at_front(__n);\n-    try {\n-      uninitialized_fill(__new_start, _M_start, __x);\n-      _M_start = __new_start;\n-    }\n-    catch(...)\n-      {\n-\t_M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n-\t__throw_exception_again;\n-      }\n-  }\n-  else if (__pos._M_cur == _M_finish._M_cur)\n-  {\n-    iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    try {\n-      uninitialized_fill(_M_finish, __new_finish, __x);\n-      _M_finish = __new_finish;\n-    }\n-    catch(...)\n-      {\n-\t_M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);    \n-\t__throw_exception_again;\n-      }\n-  }\n-  else \n-    _M_insert_aux(__pos, __n, __x);\n-}\n-\n-template <class _Tp, class _Alloc>\n-typename deque<_Tp,_Alloc>::iterator \n-deque<_Tp,_Alloc>::erase(iterator __first, iterator __last)\n-{\n-  if (__first == _M_start && __last == _M_finish) {\n-    clear();\n-    return _M_finish;\n-  }\n-  else {\n-    difference_type __n = __last - __first;\n-    difference_type __elems_before = __first - _M_start;\n-    if (static_cast<size_type>(__elems_before) < (size() - __n) / 2) {\n-      copy_backward(_M_start, __first, __last);\n-      iterator __new_start = _M_start + __n;\n-      _Destroy(_M_start, __new_start);\n-      _M_destroy_nodes(_M_start._M_node, __new_start._M_node);\n-      _M_start = __new_start;\n-    }\n-    else {\n-      copy(__last, _M_finish, __first);\n-      iterator __new_finish = _M_finish - __n;\n-      _Destroy(__new_finish, _M_finish);\n-      _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);\n-      _M_finish = __new_finish;\n-    }\n-    return _M_start + __elems_before;\n-  }\n-}\n-\n-template <class _Tp, class _Alloc> \n-void deque<_Tp,_Alloc>::clear()\n-{\n-  for (_Map_pointer __node = _M_start._M_node + 1;\n-       __node < _M_finish._M_node;\n-       ++__node) {\n-    _Destroy(*__node, *__node + _S_buffer_size());\n-    _M_deallocate_node(*__node);\n-  }\n-\n-  if (_M_start._M_node != _M_finish._M_node) {\n-    _Destroy(_M_start._M_cur, _M_start._M_last);\n-    _Destroy(_M_finish._M_first, _M_finish._M_cur);\n-    _M_deallocate_node(_M_finish._M_first);\n-  }\n-  else\n-    _Destroy(_M_start._M_cur, _M_finish._M_cur);\n-\n-  _M_finish = _M_start;\n-}\n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value)\n-{\n-  _Map_pointer __cur;\n-  try {\n-    for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)\n-      uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n-    uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);\n-  }\n-  catch(...)\n-    {\n-      _Destroy(_M_start, iterator(*__cur, __cur));\n-      __throw_exception_again;\n-    }\n-}\n-\n-/** @{\n- *  @if maint\n- *  @brief Fills the deque with whatever is in [first,last).\n- *  @param  first  An input iterator.\n- *  @param  last  An input iterator.\n- *  @return   Nothing.\n- *\n- *  If the iterators are actually forward iterators (or better), then the\n- *  memory layout can be done all at once.  Else we move forward using\n- *  push_back on each value from the iterator.\n- *  @endif\n-*/\n-template <class _Tp, class _Alloc> template <class _InputIterator>\n-void deque<_Tp,_Alloc>::_M_range_initialize(_InputIterator __first,\n-                                            _InputIterator __last,\n-                                            input_iterator_tag)\n-{\n-  _M_initialize_map(0);\n-  try {\n-    for ( ; __first != __last; ++__first)\n-      push_back(*__first);\n-  }\n-  catch(...)\n-    {\n-      clear();\n-      __throw_exception_again;\n-    }\n-}\n-\n-template <class _Tp, class _Alloc> template <class _ForwardIterator>\n-void deque<_Tp,_Alloc>::_M_range_initialize(_ForwardIterator __first,\n-                                            _ForwardIterator __last,\n-                                            forward_iterator_tag)\n-{\n-  size_type __n = distance(__first, __last);\n-  _M_initialize_map(__n);\n-\n-  _Map_pointer __cur_node;\n-  try {\n-    for (__cur_node = _M_start._M_node; \n-         __cur_node < _M_finish._M_node; \n-         ++__cur_node) {\n-      _ForwardIterator __mid = __first;\n-      advance(__mid, _S_buffer_size());\n-      uninitialized_copy(__first, __mid, *__cur_node);\n-      __first = __mid;\n-    }\n-    uninitialized_copy(__first, __last, _M_finish._M_first);\n-  }\n-  catch(...)\n-    {\n-      _Destroy(_M_start, iterator(*__cur_node, __cur_node));\n-      __throw_exception_again;\n-    }\n-}\n-/** @} */\n-\n-// Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n-template <class _Tp, class _Alloc>\n-void\n-deque<_Tp,_Alloc>::_M_push_back_aux(const value_type& __t)\n-{\n-  value_type __t_copy = __t;\n-  _M_reserve_map_at_back();\n-  *(_M_finish._M_node + 1) = _M_allocate_node();\n-  try {\n-    _Construct(_M_finish._M_cur, __t_copy);\n-    _M_finish._M_set_node(_M_finish._M_node + 1);\n-    _M_finish._M_cur = _M_finish._M_first;\n-  }\n-  catch(...)\n-    {\n-      _M_deallocate_node(*(_M_finish._M_node + 1));\n-      __throw_exception_again;\n-    }\n-}\n-\n-#ifdef _GLIBCPP_DEPRECATED\n-// Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n-template <class _Tp, class _Alloc>\n-void\n-deque<_Tp,_Alloc>::_M_push_back_aux()\n-{\n-  _M_reserve_map_at_back();\n-  *(_M_finish._M_node + 1) = _M_allocate_node();\n-  try {\n-    _Construct(_M_finish._M_cur);\n-    _M_finish._M_set_node(_M_finish._M_node + 1);\n-    _M_finish._M_cur = _M_finish._M_first;\n-  }\n-  catch(...)\n-    {\n-      _M_deallocate_node(*(_M_finish._M_node + 1));\n-      __throw_exception_again;\n-    }\n-}\n-#endif\n-\n-// Called only if _M_start._M_cur == _M_start._M_first.\n-template <class _Tp, class _Alloc>\n-void\n-deque<_Tp,_Alloc>::_M_push_front_aux(const value_type& __t)\n-{\n-  value_type __t_copy = __t;\n-  _M_reserve_map_at_front();\n-  *(_M_start._M_node - 1) = _M_allocate_node();\n-  try {\n-    _M_start._M_set_node(_M_start._M_node - 1);\n-    _M_start._M_cur = _M_start._M_last - 1;\n-    _Construct(_M_start._M_cur, __t_copy);\n-  }\n-  catch(...)\n-    {\n-      ++_M_start;\n-      _M_deallocate_node(*(_M_start._M_node - 1));\n-      __throw_exception_again;\n-    }\n-} \n-\n-#ifdef _GLIBCPP_DEPRECATED\n-// Called only if _M_start._M_cur == _M_start._M_first.\n-template <class _Tp, class _Alloc>\n-void\n-deque<_Tp,_Alloc>::_M_push_front_aux()\n-{\n-  _M_reserve_map_at_front();\n-  *(_M_start._M_node - 1) = _M_allocate_node();\n-  try {\n-    _M_start._M_set_node(_M_start._M_node - 1);\n-    _M_start._M_cur = _M_start._M_last - 1;\n-    _Construct(_M_start._M_cur);\n-  }\n-  catch(...)\n-    {\n-      ++_M_start;\n-      _M_deallocate_node(*(_M_start._M_node - 1));\n-      __throw_exception_again;\n-    }\n-} \n-#endif\n-\n-// Called only if _M_finish._M_cur == _M_finish._M_first.\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_pop_back_aux()\n-{\n-  _M_deallocate_node(_M_finish._M_first);\n-  _M_finish._M_set_node(_M_finish._M_node - 1);\n-  _M_finish._M_cur = _M_finish._M_last - 1;\n-  _Destroy(_M_finish._M_cur);\n-}\n-\n-// Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that \n-// if the deque has at least one element (a precondition for this member \n-// function), and if _M_start._M_cur == _M_start._M_last, then the deque \n-// must have at least two nodes.\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_pop_front_aux()\n-{\n-  _Destroy(_M_start._M_cur);\n-  _M_deallocate_node(_M_start._M_first);\n-  _M_start._M_set_node(_M_start._M_node + 1);\n-  _M_start._M_cur = _M_start._M_first;\n-}      \n-\n-template <class _Tp, class _Alloc> template <class _InputIterator>\n-void deque<_Tp,_Alloc>::_M_range_insert_aux(iterator __pos,\n-                               _InputIterator __first, _InputIterator __last,\n-                               input_iterator_tag)\n-{\n-  copy(__first, __last, inserter(*this, __pos));\n-}\n-\n-template <class _Tp, class _Alloc> template <class _ForwardIterator>\n-void\n-deque<_Tp,_Alloc>::_M_range_insert_aux(iterator __pos,\n-                          _ForwardIterator __first, _ForwardIterator __last,\n-                          forward_iterator_tag) {\n-  size_type __n = distance(__first, __last);\n-  if (__pos._M_cur == _M_start._M_cur) {\n-    iterator __new_start = _M_reserve_elements_at_front(__n);\n-    try {\n-      uninitialized_copy(__first, __last, __new_start);\n-      _M_start = __new_start;\n-    }\n-    catch(...)\n-      {\n-\t_M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n-\t__throw_exception_again;\n-      }\n-  }\n-  else if (__pos._M_cur == _M_finish._M_cur) {\n-    iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    try {\n-      uninitialized_copy(__first, __last, _M_finish);\n-      _M_finish = __new_finish;\n-    }\n-    catch(...)\n-      {\n-\t_M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n-\t__throw_exception_again;\n-      }\n-  }\n-  else\n-    _M_insert_aux(__pos, __first, __last, __n);\n-}\n-\n-template <class _Tp, class _Alloc>\n-typename deque<_Tp, _Alloc>::iterator\n-deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos, const value_type& __x)\n-{\n-  difference_type __index = __pos - _M_start;\n-  value_type __x_copy = __x; // XXX copy\n-  if (static_cast<size_type>(__index) < size() / 2) {\n-    push_front(front());\n-    iterator __front1 = _M_start;\n-    ++__front1;\n-    iterator __front2 = __front1;\n-    ++__front2;\n-    __pos = _M_start + __index;\n-    iterator __pos1 = __pos;\n-    ++__pos1;\n-    copy(__front2, __pos1, __front1);\n-  }\n-  else {\n-    push_back(back());\n-    iterator __back1 = _M_finish;\n-    --__back1;\n-    iterator __back2 = __back1;\n-    --__back2;\n-    __pos = _M_start + __index;\n-    copy_backward(__pos, __back2, __back1);\n-  }\n-  *__pos = __x_copy;\n-  return __pos;\n-}\n-\n-#ifdef _GLIBCPP_DEPRECATED\n-// Nothing seems to actually use this.  According to the pattern followed by\n-// the rest of the SGI code, it would be called by the deprecated insert(pos)\n-// function, but that has been replaced.  We'll take our time removing this\n-// anyhow; mark for 3.3.  -pme\n-template <class _Tp, class _Alloc>\n-typename deque<_Tp,_Alloc>::iterator \n-deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos)\n-{\n-  difference_type __index = __pos - _M_start;\n-  if (static_cast<size_type>(__index) < size() / 2) {\n-    push_front(front());\n-    iterator __front1 = _M_start;\n-    ++__front1;\n-    iterator __front2 = __front1;\n-    ++__front2;\n-    __pos = _M_start + __index;\n-    iterator __pos1 = __pos;\n-    ++__pos1;\n-    copy(__front2, __pos1, __front1);\n-  }\n-  else {\n-    push_back(back());\n-    iterator __back1 = _M_finish;\n-    --__back1;\n-    iterator __back2 = __back1;\n-    --__back2;\n-    __pos = _M_start + __index;\n-    copy_backward(__pos, __back2, __back1);\n-  }\n-  *__pos = value_type();\n-  return __pos;\n-}\n-#endif\n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n-                                      size_type __n,\n-                                      const value_type& __x)\n-{\n-  const difference_type __elems_before = __pos - _M_start;\n-  size_type __length = this->size();\n-  value_type __x_copy = __x;\n-  if (__elems_before < difference_type(__length / 2)) {\n-    iterator __new_start = _M_reserve_elements_at_front(__n);\n-    iterator __old_start = _M_start;\n-    __pos = _M_start + __elems_before;\n-    try {\n-      if (__elems_before >= difference_type(__n)) {\n-        iterator __start_n = _M_start + difference_type(__n);\n-        uninitialized_copy(_M_start, __start_n, __new_start);\n-        _M_start = __new_start;\n-        copy(__start_n, __pos, __old_start);\n-        fill(__pos - difference_type(__n), __pos, __x_copy);\n-      }\n-      else {\n-        __uninitialized_copy_fill(_M_start, __pos, __new_start, \n-                                  _M_start, __x_copy);\n-        _M_start = __new_start;\n-        fill(__old_start, __pos, __x_copy);\n-      }\n-    }\n-    catch(...)\n-      { \n-\t_M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n-\t__throw_exception_again;\n-      }\n-  }\n-  else {\n-    iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    iterator __old_finish = _M_finish;\n-    const difference_type __elems_after = \n-      difference_type(__length) - __elems_before;\n-    __pos = _M_finish - __elems_after;\n-    try {\n-      if (__elems_after > difference_type(__n)) {\n-        iterator __finish_n = _M_finish - difference_type(__n);\n-        uninitialized_copy(__finish_n, _M_finish, _M_finish);\n-        _M_finish = __new_finish;\n-        copy_backward(__pos, __finish_n, __old_finish);\n-        fill(__pos, __pos + difference_type(__n), __x_copy);\n-      }\n-      else {\n-        __uninitialized_fill_copy(_M_finish, __pos + difference_type(__n),\n-                                  __x_copy, __pos, _M_finish);\n-        _M_finish = __new_finish;\n-        fill(__pos, __old_finish, __x_copy);\n-      }\n-    }\n-    catch(...)\n-      { \n-\t_M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n-\t__throw_exception_again;\n-      }\n-  }\n-}\n-\n-template <class _Tp, class _Alloc> template <class _ForwardIterator>\n-void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,\n-                                      _ForwardIterator __first,\n-                                      _ForwardIterator __last,\n-                                      size_type __n)\n-{\n-  const difference_type __elemsbefore = __pos - _M_start;\n-  size_type __length = size();\n-  if (static_cast<size_type>(__elemsbefore) < __length / 2) {\n-    iterator __new_start = _M_reserve_elements_at_front(__n);\n-    iterator __old_start = _M_start;\n-    __pos = _M_start + __elemsbefore;\n-    try {\n-      if (__elemsbefore >= difference_type(__n)) {\n-        iterator __start_n = _M_start + difference_type(__n); \n-        uninitialized_copy(_M_start, __start_n, __new_start);\n-        _M_start = __new_start;\n-        copy(__start_n, __pos, __old_start);\n-        copy(__first, __last, __pos - difference_type(__n));\n-      }\n-      else {\n-        _ForwardIterator __mid = __first;\n-        advance(__mid, difference_type(__n) - __elemsbefore);\n-        __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n-                                  __new_start);\n-        _M_start = __new_start;\n-        copy(__mid, __last, __old_start);\n-      }\n-    }\n-    catch(...)\n-      {\n-\t_M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n-\t__throw_exception_again;\n-      }\n-  }\n-  else {\n-    iterator __new_finish = _M_reserve_elements_at_back(__n);\n-    iterator __old_finish = _M_finish;\n-    const difference_type __elemsafter = \n-      difference_type(__length) - __elemsbefore;\n-    __pos = _M_finish - __elemsafter;\n-    try {\n-      if (__elemsafter > difference_type(__n)) {\n-        iterator __finish_n = _M_finish - difference_type(__n);\n-        uninitialized_copy(__finish_n, _M_finish, _M_finish);\n-        _M_finish = __new_finish;\n-        copy_backward(__pos, __finish_n, __old_finish);\n-        copy(__first, __last, __pos);\n-      }\n-      else {\n-        _ForwardIterator __mid = __first;\n-        advance(__mid, __elemsafter);\n-        __uninitialized_copy_copy(__mid, __last, __pos, _M_finish, _M_finish);\n-        _M_finish = __new_finish;\n-        copy(__first, __mid, __pos);\n-      }\n-    }\n-    catch(...)\n-      {\n-\t_M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n-\t__throw_exception_again;\n-      }\n-  }\n-}\n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_new_elements_at_front(size_type __new_elems)\n-{\n-  size_type __new_nodes\n-      = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n-  _M_reserve_map_at_front(__new_nodes);\n-  size_type __i;\n-  try {\n-    for (__i = 1; __i <= __new_nodes; ++__i)\n-      *(_M_start._M_node - __i) = _M_allocate_node();\n-  }\n-  catch(...) {\n-    for (size_type __j = 1; __j < __i; ++__j)\n-      _M_deallocate_node(*(_M_start._M_node - __j));      \n-    __throw_exception_again;\n-  }\n-}\n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_new_elements_at_back(size_type __new_elems)\n-{\n-  size_type __new_nodes\n-      = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();\n-  _M_reserve_map_at_back(__new_nodes);\n-  size_type __i;\n-  try {\n-    for (__i = 1; __i <= __new_nodes; ++__i)\n-      *(_M_finish._M_node + __i) = _M_allocate_node();\n-  }\n-  catch(...) {\n-    for (size_type __j = 1; __j < __i; ++__j)\n-      _M_deallocate_node(*(_M_finish._M_node + __j));      \n-    __throw_exception_again;\n-  }\n-}\n-\n-template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_reallocate_map(size_type __nodes_to_add,\n-                                          bool __add_at_front)\n-{\n-  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;\n-  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;\n-\n-  _Map_pointer __new_nstart;\n-  if (_M_map_size > 2 * __new_num_nodes) {\n-    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 \n-                     + (__add_at_front ? __nodes_to_add : 0);\n-    if (__new_nstart < _M_start._M_node)\n-      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n-    else\n-      copy_backward(_M_start._M_node, _M_finish._M_node + 1, \n-                    __new_nstart + __old_num_nodes);\n-  }\n-  else {\n-    size_type __new_map_size = \n-      _M_map_size + max(_M_map_size, __nodes_to_add) + 2;\n-\n-    _Map_pointer __new_map = _M_allocate_map(__new_map_size);\n-    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n-                         + (__add_at_front ? __nodes_to_add : 0);\n-    copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n-    _M_deallocate_map(_M_map, _M_map_size);\n-\n-    _M_map = __new_map;\n-    _M_map_size = __new_map_size;\n-  }\n-\n-  _M_start._M_set_node(__new_nstart);\n-  _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n-}\n-\n-\n /**\n  *  @brief  Deque equality comparison.\n  *  @param  x  A %deque.\n@@ -2125,7 +1518,7 @@ void deque<_Tp,_Alloc>::_M_reallocate_map(size_type __nodes_to_add,\n  *  deques.  Deques are considered equivalent if their sizes are equal,\n  *  and if corresponding elements compare equal.\n */\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool operator==(const deque<_Tp, _Alloc>& __x,\n                        const deque<_Tp, _Alloc>& __y)\n {\n@@ -2144,7 +1537,7 @@ inline bool operator==(const deque<_Tp, _Alloc>& __x,\n  *\n  *  See std::lexographical_compare() for how the determination is made.\n */\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool operator<(const deque<_Tp, _Alloc>& __x,\n                       const deque<_Tp, _Alloc>& __y)\n {\n@@ -2153,35 +1546,35 @@ inline bool operator<(const deque<_Tp, _Alloc>& __x,\n }\n \n /// Based on operator==\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool operator!=(const deque<_Tp, _Alloc>& __x,\n                        const deque<_Tp, _Alloc>& __y) {\n   return !(__x == __y);\n }\n \n /// Based on operator<\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool operator>(const deque<_Tp, _Alloc>& __x,\n                       const deque<_Tp, _Alloc>& __y) {\n   return __y < __x;\n }\n \n /// Based on operator<\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool operator<=(const deque<_Tp, _Alloc>& __x,\n                        const deque<_Tp, _Alloc>& __y) {\n   return !(__y < __x);\n }\n \n /// Based on operator<\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool operator>=(const deque<_Tp, _Alloc>& __x,\n                        const deque<_Tp, _Alloc>& __y) {\n   return !(__x < __y);\n }\n \n /// See std::deque::swap().\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline void swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)\n {\n   __x.swap(__y);"}, {"sha": "75931cb09343ce6c683cbc5fb93cb62a86b228bd", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 19, "deletions": 299, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -796,15 +796,7 @@ template<typename _Tp, typename _Alloc = allocator<_Tp> >\n    *  time, and does not invalidate iterators and references.\n   */\n   iterator\n-  insert(iterator __position, const value_type& __x)\n-  {\n-    _Node* __tmp = _M_create_node(__x);\n-    __tmp->_M_next = __position._M_node;\n-    __tmp->_M_prev = __position._M_node->_M_prev;\n-    __position._M_node->_M_prev->_M_next = __tmp;\n-    __position._M_node->_M_prev = __tmp;\n-    return __tmp;\n-  }\n+  insert(iterator __position, const value_type& __x);\n \n #ifdef _GLIBCPP_DEPRECATED\n   /**\n@@ -880,17 +872,7 @@ template<typename _Tp, typename _Alloc = allocator<_Tp> >\n    *  the pointer is the user's responsibilty.\n   */\n   iterator\n-  erase(iterator __position)\n-  {\n-    _List_node_base* __next_node = __position._M_node->_M_next;\n-    _List_node_base* __prev_node = __position._M_node->_M_prev;\n-    _Node* __n = static_cast<_Node*>(__position._M_node);\n-    __prev_node->_M_next = __next_node;\n-    __next_node->_M_prev = __prev_node;\n-    _Destroy(&__n->_M_data);\n-    _M_put_node(__n);\n-    return iterator(static_cast<_Node*>(__next_node));\n-  }\n+  erase(iterator __position);\n \n   /**\n    *  @brief  Remove a range of elements.\n@@ -911,7 +893,12 @@ template<typename _Tp, typename _Alloc = allocator<_Tp> >\n    *  way.  Managing the pointer is the user's responsibilty.\n   */\n   iterator\n-  erase(iterator __first, iterator __last);\n+  erase(iterator __first, iterator __last)\n+  {\n+    while (__first != __last)\n+      erase(__first++);\n+    return __last;\n+  }\n \n   /**\n    *  @brief  Swaps data with another %list.\n@@ -1010,7 +997,7 @@ template<typename _Tp, typename _Alloc = allocator<_Tp> >\n    *  @doctodo\n   */\n   void\n-  reverse();\n+  reverse() { __List_base_reverse(this->_M_node); }\n \n   /**\n    *  @doctodo\n@@ -1064,12 +1051,20 @@ template<typename _Tp, typename _Alloc = allocator<_Tp> >\n     void\n     _M_insert_dispatch(iterator __pos,\n                        _InputIterator __first, _InputIterator __last,\n-                       __false_type);\n+                       __false_type)\n+    {\n+      for ( ; __first != __last; ++__first)\n+        insert(__pos, *__first);\n+    }\n \n   // Called by insert(p,n,x), and the range insert when it turns out to be\n   // the same thing.\n   void\n-  _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);\n+  _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n+  {\n+    for ( ; __n > 0; --__n)\n+      insert(__pos, __x);\n+  }\n \n \n   // Moves the elements from [first,last) before position.\n@@ -1168,281 +1163,6 @@ template<typename _Tp, typename _Alloc>\n   swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n   { __x.swap(__y); }\n \n-\n-template<typename _Tp, typename _Alloc>\n-  void _List_base<_Tp,_Alloc>::\n-  __clear()\n-  {\n-    _List_node<_Tp>* __cur = static_cast<_List_node<_Tp>*>(_M_node->_M_next);\n-    while (__cur != _M_node) {\n-      _List_node<_Tp>* __tmp = __cur;\n-      __cur = static_cast<_List_node<_Tp>*>(__cur->_M_next);\n-      _Destroy(&__tmp->_M_data);\n-      _M_put_node(__tmp);\n-    }\n-    _M_node->_M_next = _M_node;\n-    _M_node->_M_prev = _M_node;\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _InputIter>\n-    void list<_Tp, _Alloc>::\n-    _M_insert_dispatch(iterator __position, _InputIter __first, _InputIter __last,\n-                                          __false_type)\n-    {\n-      for ( ; __first != __last; ++__first)\n-        insert(__position, *__first);\n-\n-    }\n-\n-template<typename _Tp, typename _Alloc>\n-  void list<_Tp, _Alloc>::\n-  _M_fill_insert(iterator __position, size_type __n, const _Tp& __x)\n-  {\n-    for ( ; __n > 0; --__n)\n-      insert(__position, __x);\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  typename list<_Tp,_Alloc>::iterator list<_Tp, _Alloc>::\n-  erase(iterator __first, iterator __last)\n-  {\n-    while (__first != __last)\n-      erase(__first++);\n-    return __last;\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  void list<_Tp, _Alloc>::\n-  resize(size_type __new_size, const _Tp& __x)\n-  {\n-    iterator __i = begin();\n-    size_type __len = 0;\n-    for ( ; __i != end() && __len < __new_size; ++__i, ++__len)\n-      ;\n-    if (__len == __new_size)\n-      erase(__i, end());\n-    else                          // __i == end()\n-      insert(end(), __new_size - __len, __x);\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  list<_Tp, _Alloc>& list<_Tp, _Alloc>::\n-  operator=(const list<_Tp, _Alloc>& __x)\n-  {\n-    if (this != &__x) {\n-      iterator __first1 = begin();\n-      iterator __last1 = end();\n-      const_iterator __first2 = __x.begin();\n-      const_iterator __last2 = __x.end();\n-      while (__first1 != __last1 && __first2 != __last2)\n-        *__first1++ = *__first2++;\n-      if (__first2 == __last2)\n-        erase(__first1, __last1);\n-      else\n-        insert(__last1, __first2, __last2);\n-    }\n-    return *this;\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  void list<_Tp, _Alloc>::\n-  _M_fill_assign(size_type __n, const _Tp& __val) {\n-    iterator __i = begin();\n-    for ( ; __i != end() && __n > 0; ++__i, --__n)\n-      *__i = __val;\n-    if (__n > 0)\n-      insert(end(), __n, __val);\n-    else\n-      erase(__i, end());\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _InputIter>\n-    void list<_Tp, _Alloc>::\n-    _M_assign_dispatch(_InputIter __first2, _InputIter __last2, __false_type)\n-    {\n-      iterator __first1 = begin();\n-      iterator __last1 = end();\n-      for ( ; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n-        *__first1 = *__first2;\n-      if (__first2 == __last2)\n-        erase(__first1, __last1);\n-      else\n-        insert(__last1, __first2, __last2);\n-    }\n-\n-template<typename _Tp, typename _Alloc>\n-  void list<_Tp, _Alloc>::\n-  remove(const _Tp& __value)\n-  {\n-    iterator __first = begin();\n-    iterator __last = end();\n-    while (__first != __last) {\n-      iterator __next = __first;\n-      ++__next;\n-      if (*__first == __value) erase(__first);\n-      __first = __next;\n-    }\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  void list<_Tp, _Alloc>::\n-  unique()\n-  {\n-    iterator __first = begin();\n-    iterator __last = end();\n-    if (__first == __last) return;\n-    iterator __next = __first;\n-    while (++__next != __last) {\n-      if (*__first == *__next)\n-        erase(__next);\n-      else\n-        __first = __next;\n-      __next = __first;\n-    }\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  void list<_Tp, _Alloc>::\n-  merge(list<_Tp, _Alloc>& __x)\n-  {\n-    iterator __first1 = begin();\n-    iterator __last1 = end();\n-    iterator __first2 = __x.begin();\n-    iterator __last2 = __x.end();\n-    while (__first1 != __last1 && __first2 != __last2)\n-      if (*__first2 < *__first1) {\n-        iterator __next = __first2;\n-        _M_transfer(__first1, __first2, ++__next);\n-        __first2 = __next;\n-      }\n-      else\n-        ++__first1;\n-    if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n-  }\n-\n-inline void\n-__List_base_reverse(_List_node_base* __p)\n-{\n-  _List_node_base* __tmp = __p;\n-  do {\n-    std::swap(__tmp->_M_next, __tmp->_M_prev);\n-    __tmp = __tmp->_M_prev;     // Old next node is now prev.\n-  } while (__tmp != __p);\n-}\n-\n-template<typename _Tp, typename _Alloc>\n-inline void list<_Tp, _Alloc>::\n-reverse()\n-{ __List_base_reverse(this->_M_node); }\n-\n-template<typename _Tp, typename _Alloc>\n-  void list<_Tp, _Alloc>::\n-  sort()\n-  {\n-    // Do nothing if the list has length 0 or 1.\n-    if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n-      list<_Tp, _Alloc> __carry;\n-      list<_Tp, _Alloc> __counter[64];\n-      int __fill = 0;\n-      while (!empty()) {\n-        __carry.splice(__carry.begin(), *this, begin());\n-        int __i = 0;\n-        while(__i < __fill && !__counter[__i].empty()) {\n-          __counter[__i].merge(__carry);\n-          __carry.swap(__counter[__i++]);\n-        }\n-        __carry.swap(__counter[__i]);\n-        if (__i == __fill) ++__fill;\n-      }\n-\n-      for (int __i = 1; __i < __fill; ++__i)\n-        __counter[__i].merge(__counter[__i-1]);\n-      swap(__counter[__fill-1]);\n-    }\n-  }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _Predicate>\n-    void list<_Tp, _Alloc>::\n-    remove_if(_Predicate __pred)\n-    {\n-      iterator __first = begin();\n-      iterator __last = end();\n-      while (__first != __last) {\n-        iterator __next = __first;\n-        ++__next;\n-        if (__pred(*__first)) erase(__first);\n-        __first = __next;\n-      }\n-    }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _BinaryPredicate>\n-    void list<_Tp, _Alloc>::\n-    unique(_BinaryPredicate __binary_pred)\n-    {\n-      iterator __first = begin();\n-      iterator __last = end();\n-      if (__first == __last) return;\n-      iterator __next = __first;\n-      while (++__next != __last) {\n-        if (__binary_pred(*__first, *__next))\n-          erase(__next);\n-        else\n-          __first = __next;\n-        __next = __first;\n-      }\n-    }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _StrictWeakOrdering>\n-    void list<_Tp, _Alloc>::\n-    merge(list<_Tp, _Alloc>& __x, _StrictWeakOrdering __comp)\n-    {\n-      iterator __first1 = begin();\n-      iterator __last1 = end();\n-      iterator __first2 = __x.begin();\n-      iterator __last2 = __x.end();\n-      while (__first1 != __last1 && __first2 != __last2)\n-        if (__comp(*__first2, *__first1)) {\n-          iterator __next = __first2;\n-          _M_transfer(__first1, __first2, ++__next);\n-          __first2 = __next;\n-        }\n-        else\n-          ++__first1;\n-      if (__first2 != __last2) _M_transfer(__last1, __first2, __last2);\n-    }\n-\n-template<typename _Tp, typename _Alloc>\n-  template <typename _StrictWeakOrdering>\n-  void list<_Tp, _Alloc>::\n-  sort(_StrictWeakOrdering __comp)\n-  {\n-    // Do nothing if the list has length 0 or 1.\n-    if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {\n-      list<_Tp, _Alloc> __carry;\n-      list<_Tp, _Alloc> __counter[64];\n-      int __fill = 0;\n-      while (!empty()) {\n-        __carry.splice(__carry.begin(), *this, begin());\n-        int __i = 0;\n-        while(__i < __fill && !__counter[__i].empty()) {\n-          __counter[__i].merge(__carry, __comp);\n-          __carry.swap(__counter[__i++]);\n-        }\n-        __carry.swap(__counter[__i]);\n-        if (__i == __fill) ++__fill;\n-      }\n-\n-      for (int __i = 1; __i < __fill; ++__i)\n-        __counter[__i].merge(__counter[__i-1], __comp);\n-      swap(__counter[__fill-1]);\n-    }\n-  }\n-\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_LIST_H */"}, {"sha": "a948d5f8f87c196dcf7d955419bd97695c2074aa", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 33, "deletions": 344, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -77,7 +77,7 @@ namespace std\n  *  See bits/stl_deque.h's _Deque_alloc_base for an explanation.\n  *  @endif\n */\n-template <class _Tp, class _Allocator, bool _IsStatic>\n+template <typename _Tp, typename _Allocator, bool _IsStatic>\n   class _Vector_alloc_base\n {\n public:\n@@ -106,7 +106,7 @@ template <class _Tp, class _Allocator, bool _IsStatic>\n };\n \n /// @if maint Specialization for instanceless allocators.  @endif\n-template <class _Tp, class _Allocator>\n+template <typename _Tp, typename _Allocator>\n   class _Vector_alloc_base<_Tp, _Allocator, true>\n {\n public:\n@@ -140,7 +140,7 @@ template <class _Tp, class _Allocator>\n  *  See bits/stl_deque.h's _Deque_base for an explanation.\n  *  @endif\n */\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n   struct _Vector_base\n   : public _Vector_alloc_base<_Tp, _Alloc,\n                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n@@ -183,7 +183,7 @@ template <class _Tp, class _Alloc>\n  *  and saves the user from worrying about memory and size allocation.\n  *  Subscripting ( @c [] ) access is also provided as with C-style arrays.\n */\n-template <class _Tp, class _Alloc = allocator<_Tp> >\n+template <typename _Tp, typename _Alloc = allocator<_Tp> >\n   class vector : protected _Vector_base<_Tp, _Alloc>\n {\n   // concept requirements\n@@ -280,7 +280,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  input iterators are used, then this will do at most 2N calls to the\n    *  copy constructor, and logN memory reallocations.\n   */\n-  template <class _InputIterator>\n+  template <typename _InputIterator>\n     vector(_InputIterator __first, _InputIterator __last,\n            const allocator_type& __a = allocator_type())\n       : _Base(__a)\n@@ -333,7 +333,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  resulting %vector's size is the same as the number of elements assigned.\n    *  Old data may be lost.\n   */\n-  template<class _InputIterator>\n+  template<typename _InputIterator>\n     void\n     assign(_InputIterator __first, _InputIterator __last)\n     {\n@@ -475,19 +475,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  reallocation of memory and copying of %vector data.\n   */\n   void\n-  reserve(size_type __n)   // FIXME should be out of class\n-  {\n-    if (capacity() < __n)\n-    {\n-      const size_type __old_size = size();\n-      pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);\n-      _Destroy(_M_start, _M_finish);\n-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-      _M_start = __tmp;\n-      _M_finish = __tmp + __old_size;\n-      _M_end_of_storage = _M_start + __n;\n-    }\n-  }\n+  reserve(size_type __n);\n \n   // element access\n   /**\n@@ -593,7 +581,8 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n   void\n   push_back(const value_type& __x)\n   {\n-    if (_M_finish != _M_end_of_storage) {\n+    if (_M_finish != _M_end_of_storage)\n+    {\n       _Construct(_M_finish, __x);\n       ++_M_finish;\n     }\n@@ -628,18 +617,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  it is frequently used the user should consider using std::list.\n   */\n   iterator\n-  insert(iterator __position, const value_type& __x)\n-  {\n-    size_type __n = __position - begin();\n-    if (_M_finish != _M_end_of_storage && __position == end())\n-    {\n-      _Construct(_M_finish, __x);\n-      ++_M_finish;\n-    }\n-    else\n-      _M_insert_aux(__position, __x);\n-    return begin() + __n;\n-  }\n+  insert(iterator __position, const value_type& __x);\n \n #ifdef _GLIBCPP_DEPRECATED\n   /**\n@@ -690,7 +668,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  Note that this kind of operation could be expensive for a %vector and if\n    *  it is frequently used the user should consider using std::list.\n   */\n-  template<class _InputIterator>\n+  template<typename _InputIterator>\n     void\n     insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n       {\n@@ -714,14 +692,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  the pointer is the user's responsibilty.\n   */\n   iterator\n-  erase(iterator __position)\n-  {\n-    if (__position + 1 != end())\n-      copy(__position + 1, end(), __position);\n-    --_M_finish;\n-    _Destroy(_M_finish);\n-    return __position;\n-  }\n+  erase(iterator __position);\n \n   /**\n    *  @brief  Remove a range of elements.\n@@ -740,13 +711,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  way.  Managing the pointer is the user's responsibilty.\n   */\n   iterator\n-  erase(iterator __first, iterator __last)\n-  {\n-    iterator __i(copy(__last, end(), __first));\n-    _Destroy(__i, end());\n-    _M_finish = _M_finish - (__last - __first);\n-    return __first;\n-  }\n+  erase(iterator __first, iterator __last);\n \n   /**\n    *  @brief  Swaps data with another %vector.\n@@ -781,7 +746,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n    *  obtain @a n bytes of memory, and then copies [first,last) into it.\n    *  @endif\n   */\n-  template <class _ForwardIterator>\n+  template <typename _ForwardIterator>\n   pointer\n     _M_allocate_and_copy(size_type __n,\n                          _ForwardIterator __first, _ForwardIterator __last)\n@@ -803,7 +768,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n   // Internal constructor functions follow.\n \n   // called by the range constructor to implement [23.1.1]/9\n-  template<class _Integer>\n+  template<typename _Integer>\n     void\n     _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n     {\n@@ -813,7 +778,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the range constructor to implement [23.1.1]/9\n-  template<class _InputIter>\n+  template<typename _InputIter>\n     void\n     _M_initialize_dispatch(_InputIter __first, _InputIter __last, __false_type)\n     {\n@@ -823,7 +788,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the second initialize_dispatch above\n-  template <class _InputIterator>\n+  template <typename _InputIterator>\n   void\n     _M_range_initialize(_InputIterator __first,\n                         _InputIterator __last, input_iterator_tag)\n@@ -833,7 +798,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n   }\n \n   // called by the second initialize_dispatch above\n-  template <class _ForwardIterator>\n+  template <typename _ForwardIterator>\n   void _M_range_initialize(_ForwardIterator __first,\n                            _ForwardIterator __last, forward_iterator_tag)\n   {\n@@ -848,7 +813,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n   // assignment work for the range versions.\n \n   // called by the range assign to implement [23.1.1]/9\n-  template<class _Integer>\n+  template<typename _Integer>\n     void\n      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n      {\n@@ -857,7 +822,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n      }\n \n   // called by the range assign to implement [23.1.1]/9\n-  template<class _InputIter>\n+  template<typename _InputIter>\n     void\n     _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n     {\n@@ -867,13 +832,13 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the second assign_dispatch above\n-  template <class _InputIterator>\n+  template <typename _InputIterator>\n     void \n     _M_assign_aux(_InputIterator __first, _InputIterator __last,\n \t\t  input_iterator_tag);\n \n   // called by the second assign_dispatch above\n-  template <class _ForwardIterator>\n+  template <typename _ForwardIterator>\n     void \n     _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n \t\t  forward_iterator_tag);\n@@ -887,7 +852,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n   // Internal insert functions follow.\n \n   // called by the range insert to implement [23.1.1]/9\n-  template<class _Integer>\n+  template<typename _Integer>\n     void\n     _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n                        __true_type)\n@@ -897,7 +862,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the range insert to implement [23.1.1]/9\n-  template<class _InputIterator>\n+  template<typename _InputIterator>\n     void\n     _M_insert_dispatch(iterator __pos, _InputIterator __first,\n                        _InputIterator __last, __false_type)\n@@ -908,14 +873,14 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n     }\n \n   // called by the second insert_dispatch above\n-  template <class _InputIterator>\n+  template <typename _InputIterator>\n     void\n     _M_range_insert(iterator __pos,\n                     _InputIterator __first, _InputIterator __last,\n                     input_iterator_tag);\n \n   // called by the second insert_dispatch above\n-  template <class _ForwardIterator>\n+  template <typename _ForwardIterator>\n     void\n     _M_range_insert(iterator __pos,\n                     _ForwardIterator __first, _ForwardIterator __last,\n@@ -947,7 +912,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n  *  vectors.  Vectors are considered equivalent if their sizes are equal,\n  *  and if corresponding elements compare equal.\n */\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n   inline bool\n   operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n   {\n@@ -966,7 +931,7 @@ template <class _Tp, class _Alloc>\n  *\n  *  See std::lexographical_compare() for how the determination is made.\n */\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n   inline bool\n   operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n   {\n@@ -975,316 +940,40 @@ template <class _Tp, class _Alloc>\n   }\n \n /// Based on operator==\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool\n operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return !(__x == __y);\n }\n \n /// Based on operator<\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool\n operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return __y < __x;\n }\n \n /// Based on operator<\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool\n operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return !(__y < __x);\n }\n \n /// Based on operator<\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline bool\n operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {\n   return !(__x < __y);\n }\n \n /// See std::vector::swap().\n-template <class _Tp, class _Alloc>\n+template <typename _Tp, typename _Alloc>\n inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)\n {\n   __x.swap(__y);\n }\n \n-\n-template <class _Tp, class _Alloc>\n-vector<_Tp,_Alloc>&\n-vector<_Tp,_Alloc>::operator=(const vector<_Tp,_Alloc>& __x)\n-{\n-  if (&__x != this) {\n-    const size_type __xlen = __x.size();\n-    if (__xlen > capacity()) {\n-      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());\n-      _Destroy(_M_start, _M_finish);\n-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-      _M_start = __tmp;\n-      _M_end_of_storage = _M_start + __xlen;\n-    }\n-    else if (size() >= __xlen) {\n-      iterator __i(copy(__x.begin(), __x.end(), begin()));\n-      _Destroy(__i, end());\n-    }\n-    else {\n-      copy(__x.begin(), __x.begin() + size(), _M_start);\n-      uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);\n-    }\n-    _M_finish = _M_start + __xlen;\n-  }\n-  return *this;\n-}\n-\n-template <class _Tp, class _Alloc>\n-void\n-vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val)\n-{\n-  if (__n > capacity()) {\n-    vector __tmp(__n, __val, get_allocator());\n-    __tmp.swap(*this);\n-  }\n-  else if (__n > size()) {\n-    fill(begin(), end(), __val);\n-    _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);\n-  }\n-  else\n-    erase(fill_n(begin(), __n, __val), end());\n-}\n-\n-template <class _Tp, class _Alloc> template <class _InputIter>\n-void vector<_Tp, _Alloc>::_M_assign_aux(_InputIter __first, _InputIter __last,\n-                                        input_iterator_tag) {\n-  iterator __cur(begin());\n-  for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n-    *__cur = *__first;\n-  if (__first == __last)\n-    erase(__cur, end());\n-  else\n-    insert(end(), __first, __last);\n-}\n-\n-template <class _Tp, class _Alloc> template <class _ForwardIter>\n-void\n-vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIter __first, _ForwardIter __last,\n-                                   forward_iterator_tag) {\n-  size_type __len = distance(__first, __last);\n-\n-  if (__len > capacity()) {\n-    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n-    _Destroy(_M_start, _M_finish);\n-    _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-    _M_start = __tmp;\n-    _M_end_of_storage = _M_finish = _M_start + __len;\n-  }\n-  else if (size() >= __len) {\n-    iterator __new_finish(copy(__first, __last, _M_start));\n-    _Destroy(__new_finish, end());\n-    _M_finish = __new_finish.base();\n-  }\n-  else {\n-    _ForwardIter __mid = __first;\n-    advance(__mid, size());\n-    copy(__first, __mid, _M_start);\n-    _M_finish = uninitialized_copy(__mid, __last, _M_finish);\n-  }\n-}\n-\n-template <class _Tp, class _Alloc>\n-void\n-vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)\n-{\n-  if (_M_finish != _M_end_of_storage) {\n-    _Construct(_M_finish, *(_M_finish - 1));\n-    ++_M_finish;\n-    _Tp __x_copy = __x;\n-    copy_backward(__position, iterator(_M_finish - 2), iterator(_M_finish- 1));\n-    *__position = __x_copy;\n-  }\n-  else {\n-    const size_type __old_size = size();\n-    const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n-    iterator __new_start(_M_allocate(__len));\n-    iterator __new_finish(__new_start);\n-    try {\n-      __new_finish = uninitialized_copy(iterator(_M_start), __position,\n-                                        __new_start);\n-      _Construct(__new_finish.base(), __x);\n-      ++__new_finish;\n-      __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n-                                        __new_finish);\n-    }\n-    catch(...)\n-      {\n-\t_Destroy(__new_start,__new_finish);\n-\t_M_deallocate(__new_start.base(),__len);\n-\t__throw_exception_again;\n-      }\n-    _Destroy(begin(), end());\n-    _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-    _M_start = __new_start.base();\n-    _M_finish = __new_finish.base();\n-    _M_end_of_storage = __new_start.base() + __len;\n-  }\n-}\n-\n-#ifdef _GLIBCPP_DEPRECATED\n-template <class _Tp, class _Alloc>\n-void\n-vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)\n-{\n-  if (_M_finish != _M_end_of_storage) {\n-    _Construct(_M_finish, *(_M_finish - 1));\n-    ++_M_finish;\n-    copy_backward(__position, iterator(_M_finish - 2),\n-\t\t  iterator(_M_finish - 1));\n-    *__position = _Tp();\n-  }\n-  else {\n-    const size_type __old_size = size();\n-    const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n-    pointer __new_start = _M_allocate(__len);\n-    pointer __new_finish = __new_start;\n-    try {\n-      __new_finish = uninitialized_copy(iterator(_M_start), __position,\n-\t\t\t\t\t__new_start);\n-      _Construct(__new_finish);\n-      ++__new_finish;\n-      __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n-\t\t\t\t\t__new_finish);\n-    }\n-    catch(...)\n-      {\n-\t_Destroy(__new_start,__new_finish);\n-\t_M_deallocate(__new_start,__len);\n-\t__throw_exception_again;\n-      }\n-    _Destroy(begin(), end());\n-    _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-    _M_start = __new_start;\n-    _M_finish = __new_finish;\n-    _M_end_of_storage = __new_start + __len;\n-  }\n-}\n-#endif\n-\n-template <class _Tp, class _Alloc>\n-void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,\n-                                         const _Tp& __x)\n-{\n-  if (__n != 0) {\n-    if (size_type(_M_end_of_storage - _M_finish) >= __n) {\n-      _Tp __x_copy = __x;\n-      const size_type __elems_after = end() - __position;\n-      iterator __old_finish(_M_finish);\n-      if (__elems_after > __n) {\n-        uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n-        _M_finish += __n;\n-        copy_backward(__position, __old_finish - __n, __old_finish);\n-        fill(__position, __position + __n, __x_copy);\n-      }\n-      else {\n-        uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);\n-        _M_finish += __n - __elems_after;\n-        uninitialized_copy(__position, __old_finish, _M_finish);\n-        _M_finish += __elems_after;\n-        fill(__position, __old_finish, __x_copy);\n-      }\n-    }\n-    else {\n-      const size_type __old_size = size();\n-      const size_type __len = __old_size + max(__old_size, __n);\n-      iterator __new_start(_M_allocate(__len));\n-      iterator __new_finish(__new_start);\n-      try {\n-        __new_finish = uninitialized_copy(begin(), __position, __new_start);\n-        __new_finish = uninitialized_fill_n(__new_finish, __n, __x);\n-        __new_finish\n-          = uninitialized_copy(__position, end(), __new_finish);\n-      }\n-      catch(...)\n-\t{\n-\t  _Destroy(__new_start,__new_finish);\n-\t  _M_deallocate(__new_start.base(),__len);\n-\t  __throw_exception_again;\n-\t}\n-      _Destroy(_M_start, _M_finish);\n-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-      _M_start = __new_start.base();\n-      _M_finish = __new_finish.base();\n-      _M_end_of_storage = __new_start.base() + __len;\n-    }\n-  }\n-}\n-\n-template <class _Tp, class _Alloc> template <class _InputIterator>\n-void\n-vector<_Tp, _Alloc>::_M_range_insert(iterator __pos,\n-                                     _InputIterator __first,\n-                                     _InputIterator __last,\n-                                     input_iterator_tag)\n-{\n-  for ( ; __first != __last; ++__first) {\n-    __pos = insert(__pos, *__first);\n-    ++__pos;\n-  }\n-}\n-\n-template <class _Tp, class _Alloc> template <class _ForwardIterator>\n-void\n-vector<_Tp, _Alloc>::_M_range_insert(iterator __position,\n-                                     _ForwardIterator __first,\n-                                     _ForwardIterator __last,\n-                                     forward_iterator_tag)\n-{\n-  if (__first != __last) {\n-    size_type __n = distance(__first, __last);\n-    if (size_type(_M_end_of_storage - _M_finish) >= __n) {\n-      const size_type __elems_after = end() - __position;\n-      iterator __old_finish(_M_finish);\n-      if (__elems_after > __n) {\n-        uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n-        _M_finish += __n;\n-        copy_backward(__position, __old_finish - __n, __old_finish);\n-        copy(__first, __last, __position);\n-      }\n-      else {\n-        _ForwardIterator __mid = __first;\n-        advance(__mid, __elems_after);\n-        uninitialized_copy(__mid, __last, _M_finish);\n-        _M_finish += __n - __elems_after;\n-        uninitialized_copy(__position, __old_finish, _M_finish);\n-        _M_finish += __elems_after;\n-        copy(__first, __mid, __position);\n-      }\n-    }\n-    else {\n-      const size_type __old_size = size();\n-      const size_type __len = __old_size + max(__old_size, __n);\n-      iterator __new_start(_M_allocate(__len));\n-      iterator __new_finish(__new_start);\n-      try {\n-        __new_finish = uninitialized_copy(iterator(_M_start),\n-\t\t\t\t\t  __position, __new_start);\n-        __new_finish = uninitialized_copy(__first, __last, __new_finish);\n-        __new_finish\n-          = uninitialized_copy(__position, iterator(_M_finish), __new_finish);\n-      }\n-      catch(...)\n-\t{\n-\t  _Destroy(__new_start,__new_finish);\n-\t  _M_deallocate(__new_start.base(), __len);\n-\t  __throw_exception_again;\n-\t}\n-      _Destroy(_M_start, _M_finish);\n-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-      _M_start = __new_start.base();\n-      _M_finish = __new_finish.base();\n-      _M_end_of_storage = __new_start.base() + __len;\n-    }\n-  }\n-}\n-\n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_VECTOR_H */"}, {"sha": "d63742f949887952c43a2e6be35b01cbb1bb1c64", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -0,0 +1,439 @@\n+// Vector implementation (out of line) -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this  software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/** @file vector.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef __GLIBCPP_INTERNAL_VECTOR_TCC\n+#define __GLIBCPP_INTERNAL_VECTOR_TCC\n+\n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n+namespace std\n+{\n+\n+template <typename _Tp, typename _Alloc>\n+  void\n+  vector<_Tp,_Alloc>::\n+  reserve(size_type __n)\n+  {\n+    if (capacity() < __n)\n+    {\n+      const size_type __old_size = size();\n+      pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);\n+      _Destroy(_M_start, _M_finish);\n+      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+      _M_start = __tmp;\n+      _M_finish = __tmp + __old_size;\n+      _M_end_of_storage = _M_start + __n;\n+    }\n+  }\n+\n+template <typename _Tp, typename _Alloc>\n+  typename vector<_Tp,_Alloc>::iterator\n+  vector<_Tp,_Alloc>::\n+  insert(iterator __position, const value_type& __x)\n+  {\n+    size_type __n = __position - begin();\n+    if (_M_finish != _M_end_of_storage && __position == end())\n+    {\n+      _Construct(_M_finish, __x);\n+      ++_M_finish;\n+    }\n+    else\n+      _M_insert_aux(__position, __x);\n+    return begin() + __n;\n+  }\n+\n+template <typename _Tp, typename _Alloc>\n+  typename vector<_Tp,_Alloc>::iterator\n+  vector<_Tp,_Alloc>::\n+  erase(iterator __position)\n+  {\n+    if (__position + 1 != end())\n+      copy(__position + 1, end(), __position);\n+    --_M_finish;\n+    _Destroy(_M_finish);\n+    return __position;\n+  }\n+\n+template <typename _Tp, typename _Alloc>\n+  typename vector<_Tp,_Alloc>::iterator\n+  vector<_Tp,_Alloc>::\n+  erase(iterator __first, iterator __last)\n+  {\n+    iterator __i(copy(__last, end(), __first));\n+    _Destroy(__i, end());\n+    _M_finish = _M_finish - (__last - __first);\n+    return __first;\n+  }\n+\n+template <typename _Tp, typename _Alloc>\n+  vector<_Tp,_Alloc>&\n+  vector<_Tp,_Alloc>::\n+  operator=(const vector<_Tp,_Alloc>& __x)\n+  {\n+    if (&__x != this)\n+    {\n+      const size_type __xlen = __x.size();\n+      if (__xlen > capacity())\n+      {\n+        pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());\n+        _Destroy(_M_start, _M_finish);\n+        _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+        _M_start = __tmp;\n+        _M_end_of_storage = _M_start + __xlen;\n+      }\n+      else if (size() >= __xlen)\n+      {\n+        iterator __i(copy(__x.begin(), __x.end(), begin()));\n+        _Destroy(__i, end());\n+      }\n+      else\n+      {\n+        copy(__x.begin(), __x.begin() + size(), _M_start);\n+        uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);\n+      }\n+      _M_finish = _M_start + __xlen;\n+    }\n+    return *this;\n+  }\n+\n+template <typename _Tp, typename _Alloc>\n+  void\n+  vector<_Tp,_Alloc>::\n+  _M_fill_assign(size_t __n, const value_type& __val)\n+  {\n+    if (__n > capacity())\n+    {\n+      vector __tmp(__n, __val, get_allocator());\n+      __tmp.swap(*this);\n+    }\n+    else if (__n > size())\n+    {\n+      fill(begin(), end(), __val);\n+      _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);\n+    }\n+    else\n+      erase(fill_n(begin(), __n, __val), end());\n+  }\n+\n+template <typename _Tp, typename _Alloc> template <typename _InputIter>\n+  void\n+  vector<_Tp,_Alloc>::\n+  _M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)\n+  {\n+    iterator __cur(begin());\n+    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)\n+      *__cur = *__first;\n+    if (__first == __last)\n+      erase(__cur, end());\n+    else\n+      insert(end(), __first, __last);\n+  }\n+\n+template <typename _Tp, typename _Alloc> template <typename _ForwardIter>\n+  void\n+  vector<_Tp,_Alloc>::\n+  _M_assign_aux(_ForwardIter __first, _ForwardIter __last, forward_iterator_tag)\n+  {\n+    size_type __len = distance(__first, __last);\n+\n+    if (__len > capacity())\n+    {\n+      pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n+      _Destroy(_M_start, _M_finish);\n+      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+      _M_start = __tmp;\n+      _M_end_of_storage = _M_finish = _M_start + __len;\n+    }\n+    else if (size() >= __len)\n+    {\n+      iterator __new_finish(copy(__first, __last, _M_start));\n+      _Destroy(__new_finish, end());\n+      _M_finish = __new_finish.base();\n+    }\n+    else\n+    {\n+      _ForwardIter __mid = __first;\n+      advance(__mid, size());\n+      copy(__first, __mid, _M_start);\n+      _M_finish = uninitialized_copy(__mid, __last, _M_finish);\n+    }\n+  }\n+\n+template <typename _Tp, typename _Alloc>\n+  void\n+  vector<_Tp,_Alloc>::\n+  _M_insert_aux(iterator __position, const _Tp& __x)\n+  {\n+    if (_M_finish != _M_end_of_storage)\n+    {\n+      _Construct(_M_finish, *(_M_finish - 1));\n+      ++_M_finish;\n+      _Tp __x_copy = __x;\n+      copy_backward(__position, iterator(_M_finish-2), iterator(_M_finish-1));\n+      *__position = __x_copy;\n+    }\n+    else\n+    {\n+      const size_type __old_size = size();\n+      const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n+      iterator __new_start(_M_allocate(__len));\n+      iterator __new_finish(__new_start);\n+      try\n+        {\n+          __new_finish = uninitialized_copy(iterator(_M_start), __position,\n+                                            __new_start);\n+          _Construct(__new_finish.base(), __x);\n+          ++__new_finish;\n+          __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n+                                            __new_finish);\n+        }\n+      catch(...)\n+        {\n+          _Destroy(__new_start,__new_finish);\n+          _M_deallocate(__new_start.base(),__len);\n+          __throw_exception_again;\n+        }\n+      _Destroy(begin(), end());\n+      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+      _M_start = __new_start.base();\n+      _M_finish = __new_finish.base();\n+      _M_end_of_storage = __new_start.base() + __len;\n+    }\n+  }\n+\n+#ifdef _GLIBCPP_DEPRECATED\n+template <typename _Tp, typename _Alloc>\n+  void\n+  vector<_Tp,_Alloc>::\n+  _M_insert_aux(iterator __position)\n+  {\n+    if (_M_finish != _M_end_of_storage)\n+    {\n+      _Construct(_M_finish, *(_M_finish - 1));\n+      ++_M_finish;\n+      copy_backward(__position, iterator(_M_finish - 2),\n+                    iterator(_M_finish - 1));\n+      *__position = value_type();\n+    }\n+    else\n+    {\n+      const size_type __old_size = size();\n+      const size_type __len = __old_size != 0 ? 2 * __old_size : 1;\n+      pointer __new_start = _M_allocate(__len);\n+      pointer __new_finish = __new_start;\n+      try\n+        {\n+          __new_finish = uninitialized_copy(iterator(_M_start), __position,\n+                                            __new_start);\n+          _Construct(__new_finish);\n+          ++__new_finish;\n+          __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n+                                            __new_finish);\n+        }\n+      catch(...)\n+        {\n+          _Destroy(__new_start,__new_finish);\n+          _M_deallocate(__new_start,__len);\n+          __throw_exception_again;\n+        }\n+      _Destroy(begin(), end());\n+      _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+      _M_start = __new_start;\n+      _M_finish = __new_finish;\n+      _M_end_of_storage = __new_start + __len;\n+    }\n+  }\n+#endif\n+\n+template <typename _Tp, typename _Alloc>\n+  void\n+  vector<_Tp,_Alloc>::\n+  _M_fill_insert(iterator __position, size_type __n, const value_type& __x)\n+  {\n+    if (__n != 0)\n+    {\n+      if (size_type(_M_end_of_storage - _M_finish) >= __n) {\n+        value_type __x_copy = __x;\n+        const size_type __elems_after = end() - __position;\n+        iterator __old_finish(_M_finish);\n+        if (__elems_after > __n)\n+        {\n+          uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n+          _M_finish += __n;\n+          copy_backward(__position, __old_finish - __n, __old_finish);\n+          fill(__position, __position + __n, __x_copy);\n+        }\n+        else\n+        {\n+          uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);\n+          _M_finish += __n - __elems_after;\n+          uninitialized_copy(__position, __old_finish, _M_finish);\n+          _M_finish += __elems_after;\n+          fill(__position, __old_finish, __x_copy);\n+        }\n+      }\n+      else\n+      {\n+        const size_type __old_size = size();\n+        const size_type __len = __old_size + max(__old_size, __n);\n+        iterator __new_start(_M_allocate(__len));\n+        iterator __new_finish(__new_start);\n+        try\n+          {\n+            __new_finish = uninitialized_copy(begin(), __position, __new_start);\n+            __new_finish = uninitialized_fill_n(__new_finish, __n, __x);\n+            __new_finish\n+              = uninitialized_copy(__position, end(), __new_finish);\n+          }\n+        catch(...)\n+          {\n+            _Destroy(__new_start,__new_finish);\n+            _M_deallocate(__new_start.base(),__len);\n+            __throw_exception_again;\n+          }\n+        _Destroy(_M_start, _M_finish);\n+        _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+        _M_start = __new_start.base();\n+        _M_finish = __new_finish.base();\n+        _M_end_of_storage = __new_start.base() + __len;\n+      }\n+    }\n+  }\n+\n+template <typename _Tp, typename _Alloc> template <typename _InputIterator>\n+  void\n+  vector<_Tp,_Alloc>::\n+  _M_range_insert(iterator __pos,\n+                  _InputIterator __first, _InputIterator __last,\n+                  input_iterator_tag)\n+  {\n+    for ( ; __first != __last; ++__first)\n+    {\n+      __pos = insert(__pos, *__first);\n+      ++__pos;\n+    }\n+  }\n+\n+template <typename _Tp, typename _Alloc> template <typename _ForwardIterator>\n+  void\n+  vector<_Tp,_Alloc>::\n+  _M_range_insert(iterator __position,\n+                  _ForwardIterator __first, _ForwardIterator __last,\n+                  forward_iterator_tag)\n+  {\n+    if (__first != __last)\n+    {\n+      size_type __n = distance(__first, __last);\n+      if (size_type(_M_end_of_storage - _M_finish) >= __n)\n+      {\n+        const size_type __elems_after = end() - __position;\n+        iterator __old_finish(_M_finish);\n+        if (__elems_after > __n)\n+        {\n+          uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n+          _M_finish += __n;\n+          copy_backward(__position, __old_finish - __n, __old_finish);\n+          copy(__first, __last, __position);\n+        }\n+        else\n+        {\n+          _ForwardIterator __mid = __first;\n+          advance(__mid, __elems_after);\n+          uninitialized_copy(__mid, __last, _M_finish);\n+          _M_finish += __n - __elems_after;\n+          uninitialized_copy(__position, __old_finish, _M_finish);\n+          _M_finish += __elems_after;\n+          copy(__first, __mid, __position);\n+        }\n+      }\n+      else\n+      {\n+        const size_type __old_size = size();\n+        const size_type __len = __old_size + max(__old_size, __n);\n+        iterator __new_start(_M_allocate(__len));\n+        iterator __new_finish(__new_start);\n+        try\n+          {\n+            __new_finish = uninitialized_copy(iterator(_M_start),\n+                                              __position, __new_start);\n+            __new_finish = uninitialized_copy(__first, __last, __new_finish);\n+            __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n+                                              __new_finish);\n+          }\n+        catch(...)\n+          {\n+            _Destroy(__new_start,__new_finish);\n+            _M_deallocate(__new_start.base(), __len);\n+            __throw_exception_again;\n+          }\n+        _Destroy(_M_start, _M_finish);\n+        _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n+        _M_start = __new_start.base();\n+        _M_finish = __new_finish.base();\n+        _M_end_of_storage = __new_start.base() + __len;\n+      }\n+    }\n+  }\n+\n+} // namespace std\n+\n+#endif /* __GLIBCPP_INTERNAL_VECTOR_TCC */\n+"}, {"sha": "c4fab34c474f6a7f0252382c1dd6e37d63d392f6", "filename": "libstdc++-v3/include/ext/stl_hashtable.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_hashtable.h?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -65,13 +65,10 @@\n // Hashtable class, used to implement the hashed associative containers\n // hash_set, hash_map, hash_multiset, and hash_multimap.\n \n-#include <bits/stl_algobase.h>\n-#include <bits/stl_alloc.h>\n-#include <bits/stl_construct.h>\n+#include <vector>\n+#include <iterator>\n #include <bits/stl_algo.h>\n-#include <bits/stl_uninitialized.h>\n #include <bits/stl_function.h>\n-#include <bits/stl_vector.h>\n #include <ext/stl_hash_fun.h>\n \n namespace __gnu_cxx"}, {"sha": "921c25fa4931bd90ff76baf2f692f66d0dbc9812", "filename": "libstdc++-v3/include/std/std_deque.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_deque.h?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -70,8 +70,9 @@\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_deque.h>\n \n+#ifdef _GLIBCPP_NO_TEMPLATE_EXPORT\n+#  include <bits/deque.tcc>\n+#endif\n+\n #endif /* _CPP_DEQUE */\n \n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "84523ad8e4fad1ed69842036e841d2408afa5278", "filename": "libstdc++-v3/include/std/std_list.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_list.h?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -70,8 +70,9 @@\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_list.h>\n \n+#ifdef _GLIBCPP_NO_TEMPLATE_EXPORT\n+#  include <bits/list.tcc>\n+#endif\n+\n #endif /* _CPP_LIST */\n \n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "5738ef7ade89b6e9c5eb8bd1e5a9919dd8cafe4c", "filename": "libstdc++-v3/include/std/std_vector.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83144cfcfaca44bb6d0cae7d2c0fa447193cb819/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_vector.h?ref=83144cfcfaca44bb6d0cae7d2c0fa447193cb819", "patch": "@@ -71,8 +71,9 @@\n #include <bits/stl_vector.h>\n #include <bits/stl_bvector.h> \n \n+#ifdef _GLIBCPP_NO_TEMPLATE_EXPORT\n+#  include <bits/vector.tcc>\n+#endif\n+\n #endif /* _CPP_VECTOR */\n \n-// Local Variables:\n-// mode:C++\n-// End:"}]}