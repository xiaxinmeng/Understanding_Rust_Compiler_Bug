{"sha": "01955e96133ba8678e25523e1b8eabafc06df7fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE5NTVlOTYxMzNiYTg2NzhlMjU1MjNlMWI4ZWFiYWZjMDZkZjdmYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-19T00:59:51Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-19T00:59:51Z"}, "message": "class.c (check_bitfield_decl): Remove restriction on really long bitfields.\n\n\t* class.c (check_bitfield_decl): Remove restriction on really long\n\tbitfields.\n\t(layout_class_type): Implement new ABI handling of bitfields\n\tlonger than their types.\n\nFrom-SVN: r32625", "tree": {"sha": "512546cebe1ff950e9d991831a3bc0f707811dd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/512546cebe1ff950e9d991831a3bc0f707811dd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01955e96133ba8678e25523e1b8eabafc06df7fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01955e96133ba8678e25523e1b8eabafc06df7fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01955e96133ba8678e25523e1b8eabafc06df7fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01955e96133ba8678e25523e1b8eabafc06df7fc/comments", "author": null, "committer": null, "parents": [{"sha": "7145ef21d8e9c8a3ebe3198f9222a90e9cd060ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7145ef21d8e9c8a3ebe3198f9222a90e9cd060ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7145ef21d8e9c8a3ebe3198f9222a90e9cd060ec"}], "stats": {"total": 101, "additions": 81, "deletions": 20}, "files": [{"sha": "892a466bd2ea344ae8144aa3aec75ead0b63f768", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01955e96133ba8678e25523e1b8eabafc06df7fc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01955e96133ba8678e25523e1b8eabafc06df7fc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=01955e96133ba8678e25523e1b8eabafc06df7fc", "patch": "@@ -1,3 +1,10 @@\n+2000-03-18  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (check_bitfield_decl): Remove restriction on really long\n+\tbitfields.\n+\t(layout_class_type): Implement new ABI handling of bitfields\n+\tlonger than their types.\n+\n 2000-03-18  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* parse.y (extdefs): Call ggc_collect."}, {"sha": "5475ac4ba9253575bbca85887e528a3c9ce90005", "filename": "gcc/cp/class.c", "status": "modified", "additions": 67, "deletions": 20, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01955e96133ba8678e25523e1b8eabafc06df7fc/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01955e96133ba8678e25523e1b8eabafc06df7fc/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=01955e96133ba8678e25523e1b8eabafc06df7fc", "patch": "@@ -3658,17 +3658,6 @@ check_bitfield_decl (field)\n \t  DECL_INITIAL (field) = NULL;\n \t  cp_error_at (\"zero width for bit-field `%D'\", field);\n \t}\n-      else if (0 < compare_tree_int (w,\n-\t\t\t\t     TYPE_PRECISION\n-\t\t\t\t     (long_long_unsigned_type_node)))\n-\t{\n-\t  /* The backend will dump if you try to use something too\n-\t     big; avoid that.  */\n-\t  DECL_INITIAL (field) = NULL;\n-\t  sorry (\"bit-fields larger than %d bits\",\n-\t\t TYPE_PRECISION (long_long_unsigned_type_node));\n-\t  cp_error_at (\"  in declaration of `%D'\", field);\n-\t}\n       else if (compare_tree_int (w, TYPE_PRECISION (type)) > 0\n \t       && TREE_CODE (type) != ENUMERAL_TYPE\n \t       && TREE_CODE (type) != BOOLEAN_TYPE)\n@@ -4168,8 +4157,10 @@ dfs_search_base_offsets (binfo, data)\n    non-static data member of the type indicated by RLI.  BINFO is the\n    binfo corresponding to the base subobject, or, if this is a\n    non-static data-member, a dummy BINFO for the type of the data\n-   member.  V maps offsets to types already located at those offsets.\n-   This function determines the position of the DECL.  */\n+   member.  BINFO may be NULL if checks to see if the field overlaps\n+   an existing field with the same type are not required.  V maps\n+   offsets to types already located at those offsets.  This function\n+   determines the position of the DECL.  */\n \n static void\n layout_nonempty_base_or_field (rli, decl, binfo, v)\n@@ -4192,7 +4183,8 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n \t BINFO_OFFSET.  */\n       offset = size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (decl)),\n \t\t\t       BITS_PER_UNIT));\n-      propagate_binfo_offsets (binfo, offset);\n+      if (binfo)\n+\tpropagate_binfo_offsets (binfo, offset);\n  \n       /* We have to check to see whether or not there is already\n \t something of the same type at the offset we're about to use.\n@@ -4209,10 +4201,10 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n \t empty class, have non-zero size, any overlap can happen only\n \t with a direct or indirect base-class -- it can't happen with\n \t a data member.  */\n-      if (flag_new_abi && dfs_walk (binfo,\n-\t\t\t\t    dfs_search_base_offsets,\n-\t\t\t\t    dfs_skip_vbases,\n-\t\t\t\t    v))\n+      if (binfo && flag_new_abi && dfs_walk (binfo,\n+\t\t\t\t\t     dfs_search_base_offsets,\n+\t\t\t\t\t     dfs_skip_vbases,\n+\t\t\t\t\t     v))\n \t{\n \t  /* Undo the propogate_binfo_offsets call.  */\n \t  offset = convert (sizetype,\n@@ -4930,6 +4922,8 @@ layout_class_type (t, empty_p, has_virtual_p,\n        field = TREE_CHAIN (field))\n     {\n       tree binfo;\n+      tree type;\n+      tree padding;\n \n       /* We still pass things that aren't non-static data members to\n \t the back-end, in case it wants to do something with them.  */\n@@ -4939,11 +4933,64 @@ layout_class_type (t, empty_p, has_virtual_p,\n \t  continue;\n \t}\n \n+      type = TREE_TYPE (field);\n+\n+      /* If this field is a bit-field whose width is greater than its\n+\t type, then there are some special rules for allocating it\n+\t under the new ABI.  Under the old ABI, there were no special\n+\t rules, but the back-end can't handle bitfields longer than a\n+\t `long long', so we use the same mechanism.  */\n+      if (DECL_C_BIT_FIELD (field)\n+\t  && ((flag_new_abi \n+\t       && INT_CST_LT (TYPE_SIZE (type), DECL_SIZE (field)))\n+\t      || (!flag_new_abi\n+\t\t  && compare_tree_int (DECL_SIZE (field),\n+\t\t\t\t       TYPE_PRECISION\n+\t\t\t\t       (long_long_unsigned_type_node)) > 0)))\n+\t{\n+\t  integer_type_kind itk;\n+\t  tree integer_type;\n+\n+\t  /* We must allocate the bits as if suitably aligned for the\n+\t     longest integer type that fits in this many bits.  type\n+\t     of the field.  Then, we are supposed to use the left over\n+\t     bits as additional padding.  */\n+\t  for (itk = itk_char; itk != itk_none; ++itk)\n+\t    if (INT_CST_LT (DECL_SIZE (field), \n+\t\t\t    TYPE_SIZE (integer_types[itk])))\n+\t      break;\n+\n+\t  /* ITK now indicates a type that is too large for the\n+\t     field.  We have to back up by one to find the largest\n+\t     type that fits.  */\n+\t  integer_type = integer_types[itk - 1];\n+\t  padding = size_diffop (DECL_SIZE (field), \n+\t\t\t\t TYPE_SIZE (integer_type));\n+\t  DECL_SIZE (field) = TYPE_SIZE (integer_type);\n+\t  DECL_ALIGN (field) = TYPE_ALIGN (integer_type);\n+\t}\n+      else\n+\tpadding = NULL_TREE;\n+\n       /* Create a dummy BINFO corresponding to this field.  */\n-      binfo = make_binfo (size_zero_node, TREE_TYPE (field),\n-\t\t\t  NULL_TREE, NULL_TREE);\n+      binfo = make_binfo (size_zero_node, type, NULL_TREE, NULL_TREE);\n       unshare_base_binfos (binfo);\n       layout_nonempty_base_or_field (rli, field, binfo, v);\n+\n+      /* If we needed additional padding after this field, add it\n+\t now.  */\n+      if (padding)\n+\t{\n+\t  tree padding_field;\n+\n+\t  padding_field = build_decl (FIELD_DECL, \n+\t\t\t\t      NULL_TREE,\n+\t\t\t\t      char_type_node); \n+\t  DECL_BIT_FIELD (padding_field) = 1;\n+\t  DECL_SIZE (padding_field) = padding;\n+\t  DECL_ALIGN (padding_field) = 1;\n+\t  layout_nonempty_base_or_field (rli, padding_field, NULL_TREE, v);\n+\t}\n     }\n \n   /* Clean up.  */"}, {"sha": "a9e54ecbcd166a3db6c71a8ad17babf27fb5e947", "filename": "gcc/testsuite/g++.old-deja/g++.other/bitfld5.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01955e96133ba8678e25523e1b8eabafc06df7fc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbitfld5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01955e96133ba8678e25523e1b8eabafc06df7fc/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbitfld5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbitfld5.C?ref=01955e96133ba8678e25523e1b8eabafc06df7fc", "patch": "@@ -0,0 +1,7 @@\n+// Build don't link:\n+// Special g++ Options: -w\n+\n+struct S\n+{\n+  int i : 1756;\n+};"}]}