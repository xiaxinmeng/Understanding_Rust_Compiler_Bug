{"sha": "47ddf4c7b1d4471cb9534f27844ab5e4279c2168", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdkZGY0YzdiMWQ0NDcxY2I5NTM0ZjI3ODQ0YWI1ZTQyNzljMjE2OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-08T12:49:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-10T09:18:18Z"}, "message": "tree-optimization/96043 - BB vectorization costing improvement\n\nThis makes the BB vectorizer cost independent SLP subgraphs\nseparately.  While on pristine trunk and for x86_64 I failed to\ndistill a testcase where the vectorizer would think _any_\nbasic-block vectorization opportunity is not profitable I do\nhave pending work that would make the cost savings of a\nprofitable opportunity make another independently not\nprofitable opportunity vectorized.\n\n2020-09-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/96043\n\t* tree-vectorizer.h (_slp_instance::cost_vec): New.\n\t(_slp_instance::subgraph_entries): Likewise.\n\t(BB_VINFO_TARGET_COST_DATA): Remove.\n\t* tree-vect-slp.c (vect_free_slp_instance): Free\n\tcost_vec and subgraph_entries.\n\t(vect_analyze_slp_instance): Initialize them.\n\t(vect_slp_analyze_operations): Defer passing costs to\n\tthe target, instead record them in the SLP graph entry.\n\t(get_ultimate_leader): New helper for graph partitioning.\n\t(vect_bb_partition_graph_r): Likewise.\n\t(vect_bb_partition_graph): New function to partition the\n\tSLP graph into independently costable parts.\n\t(vect_bb_vectorization_profitable_p): Adjust to work on\n\ta subgraph.\n\t(vect_bb_vectorization_profitable_p): New wrapper,\n\tdiscarding non-profitable vectorization of subgraphs.\n\t(vect_slp_analyze_bb_1): Call vect_bb_partition_graph before\n\tcosting.\n\n\t* gcc.dg/vect/costmodel/x86_64/costmodel-pr69297.c: Adjust.", "tree": {"sha": "5983e9d8c24326c178aa7f721b107e4651fa1628", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5983e9d8c24326c178aa7f721b107e4651fa1628"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47ddf4c7b1d4471cb9534f27844ab5e4279c2168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ddf4c7b1d4471cb9534f27844ab5e4279c2168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ddf4c7b1d4471cb9534f27844ab5e4279c2168", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ddf4c7b1d4471cb9534f27844ab5e4279c2168/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "484af18ee1c63eb8d212563e40aa765da5be7f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/484af18ee1c63eb8d212563e40aa765da5be7f82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/484af18ee1c63eb8d212563e40aa765da5be7f82"}], "stats": {"total": 213, "additions": 194, "deletions": 19}, "files": [{"sha": "ef74785f6a8cc3b44db5c794d349461f4152a8a5", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-pr69297.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ddf4c7b1d4471cb9534f27844ab5e4279c2168/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-pr69297.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ddf4c7b1d4471cb9534f27844ab5e4279c2168/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-pr69297.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-pr69297.c?ref=47ddf4c7b1d4471cb9534f27844ab5e4279c2168", "patch": "@@ -74,10 +74,28 @@ foo (int* diff)\n     d[13] = m[12] - m[13];\n     d[14] = m[14] + m[15];\n     d[15] = m[15] - m[14];\n+    /* The following obviously profitable part should not make\n+       the former unprofitable one profitable.  */\n+    diff[16 + 16] = diff[16];\n+    diff[17 + 16] = diff[17];\n+    diff[18 + 16] = diff[18];\n+    diff[19 + 16] = diff[19];\n+    diff[20 + 16] = diff[20];\n+    diff[21 + 16] = diff[21];\n+    diff[22 + 16] = diff[22];\n+    diff[23 + 16] = diff[23];\n+    diff[24 + 16] = diff[24];\n+    diff[25 + 16] = diff[25];\n+    diff[26 + 16] = diff[26];\n+    diff[27 + 16] = diff[27];\n+    diff[28 + 16] = diff[28];\n+    diff[29 + 16] = diff[29];\n+    diff[30 + 16] = diff[30];\n+    diff[31 + 16] = diff[31];\n     for (k=0; k<16; k++)\n       satd += abs(d[k]);\n   return satd;\n }\n \n /* { dg-final { scan-tree-dump \"vectorization is not profitable\" \"slp1\" } } */\n-/* { dg-final { scan-tree-dump-not \"basic block vectorized\" \"slp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"Vectorizing SLP tree\" 1 \"slp1\" } } */"}, {"sha": "458a2c5bb301157f4f843776943435eba8c49d65", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 168, "deletions": 17, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ddf4c7b1d4471cb9534f27844ab5e4279c2168/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ddf4c7b1d4471cb9534f27844ab5e4279c2168/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=47ddf4c7b1d4471cb9534f27844ab5e4279c2168", "patch": "@@ -126,6 +126,8 @@ vect_free_slp_instance (slp_instance instance, bool final_p)\n {\n   vect_free_slp_tree (SLP_INSTANCE_TREE (instance), final_p);\n   SLP_INSTANCE_LOADS (instance).release ();\n+  instance->subgraph_entries.release ();\n+  instance->cost_vec.release ();\n   free (instance);\n }\n \n@@ -2263,6 +2265,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  SLP_INSTANCE_LOADS (new_instance) = vNULL;\n \t  SLP_INSTANCE_ROOT_STMT (new_instance) = constructor ? stmt_info : NULL;\n \t  new_instance->reduc_phis = NULL;\n+\t  new_instance->cost_vec = vNULL;\n+\t  new_instance->subgraph_entries = vNULL;\n \n \t  vect_gather_slp_loads (new_instance, node);\n \t  if (dump_enabled_p ())\n@@ -3133,27 +3137,117 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t    visited.add (*x);\n \t  i++;\n \n-\t  add_stmt_costs (vinfo, vinfo->target_cost_data, &cost_vec);\n-\t  cost_vec.release ();\n+\t  /* Remember the SLP graph entry cost for later.  */\n+\t  instance->cost_vec = cost_vec;\n \t}\n     }\n \n   /* Compute vectorizable live stmts.  */\n   if (bb_vec_info bb_vinfo = dyn_cast <bb_vec_info> (vinfo))\n     {\n       hash_set<stmt_vec_info> svisited;\n-      stmt_vector_for_cost cost_vec;\n-      cost_vec.create (2);\n       for (i = 0; vinfo->slp_instances.iterate (i, &instance); ++i)\n \tvect_bb_slp_mark_live_stmts (bb_vinfo, SLP_INSTANCE_TREE (instance),\n-\t\t\t\t     instance, &cost_vec, svisited);\n-      add_stmt_costs (vinfo, vinfo->target_cost_data, &cost_vec);\n-      cost_vec.release ();\n+\t\t\t\t     instance, &instance->cost_vec, svisited);\n     }\n \n   return !vinfo->slp_instances.is_empty ();\n }\n \n+/* Get the SLP instance leader from INSTANCE_LEADER thereby transitively\n+   closing the eventual chain.  */\n+\n+static slp_instance\n+get_ultimate_leader (slp_instance instance,\n+\t\t     hash_map<slp_instance, slp_instance> &instance_leader)\n+{\n+  auto_vec<slp_instance *, 8> chain;\n+  slp_instance *tem;\n+  while (*(tem = instance_leader.get (instance)) != instance)\n+    {\n+      chain.safe_push (tem);\n+      instance = *tem;\n+    }\n+  while (!chain.is_empty ())\n+    *chain.pop () = instance;\n+  return instance;\n+}\n+\n+/* Worker of vect_bb_partition_graph, recurse on NODE.  */\n+\n+static void\n+vect_bb_partition_graph_r (bb_vec_info bb_vinfo,\n+\t\t\t   slp_instance instance, slp_tree node,\n+\t\t\t   hash_map<stmt_vec_info, slp_instance> &stmt_to_instance,\n+\t\t\t   hash_map<slp_instance, slp_instance> &instance_leader)\n+{\n+  stmt_vec_info stmt_info;\n+  unsigned i;\n+  bool all = true;\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n+    {\n+      bool existed_p;\n+      slp_instance &stmt_instance\n+\t= stmt_to_instance.get_or_insert (stmt_info, &existed_p);\n+      if (!existed_p)\n+\tall = false;\n+      else if (stmt_instance != instance)\n+\t{\n+\t  /* If we're running into a previously marked stmt make us the\n+\t     leader of the current ultimate leader.  This keeps the\n+\t     leader chain acyclic and works even when the current instance\n+\t     connects two previously independent graph parts.  */\n+\t  slp_instance stmt_leader\n+\t    = get_ultimate_leader (stmt_instance, instance_leader);\n+\t  if (stmt_leader != instance)\n+\t    instance_leader.put (stmt_leader, instance);\n+\t}\n+      stmt_instance = instance;\n+    }\n+  /* If not all stmts had been visited we have to recurse on children.  */\n+  if (all)\n+    return;\n+\n+  slp_tree child;\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n+      vect_bb_partition_graph_r (bb_vinfo, instance, child, stmt_to_instance,\n+\t\t\t\t instance_leader);\n+}\n+\n+/* Partition the SLP graph into pieces that can be costed independently.  */\n+\n+static void\n+vect_bb_partition_graph (bb_vec_info bb_vinfo)\n+{\n+  DUMP_VECT_SCOPE (\"vect_bb_partition_graph\");\n+\n+  /* First walk the SLP graph assigning each involved scalar stmt a\n+     corresponding SLP graph entry and upon visiting a previously\n+     marked stmt, make the stmts leader the current SLP graph entry.  */\n+  hash_map<stmt_vec_info, slp_instance> stmt_to_instance;\n+  hash_map<slp_instance, slp_instance> instance_leader;\n+  slp_instance instance;\n+  for (unsigned i = 0; bb_vinfo->slp_instances.iterate (i, &instance); ++i)\n+    {\n+      instance_leader.put (instance, instance);\n+      vect_bb_partition_graph_r (bb_vinfo,\n+\t\t\t\t instance, SLP_INSTANCE_TREE (instance),\n+\t\t\t\t stmt_to_instance, instance_leader);\n+    }\n+\n+  /* Then collect entries to each independent subgraph.  */\n+  for (unsigned i = 0; bb_vinfo->slp_instances.iterate (i, &instance); ++i)\n+    {\n+      slp_instance leader = get_ultimate_leader (instance, instance_leader);\n+      leader->subgraph_entries.safe_push (instance);\n+      if (dump_enabled_p ()\n+\t  && leader != instance)\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"instance %p is leader of %p\\n\",\n+\t\t\t leader, instance);\n+    }\n+}\n \n /* Compute the scalar cost of the SLP node NODE and its children\n    and return it.  Do not account defs that are marked in LIFE and\n@@ -3261,18 +3355,22 @@ vect_bb_slp_scalar_cost (vec_info *vinfo,\n     }\n }\n \n-/* Check if vectorization of the basic block is profitable.  */\n+/* Check if vectorization of the basic block is profitable for the\n+   subgraph denoted by SLP_INSTANCES.  */\n \n static bool\n-vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n+vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo,\n+\t\t\t\t    vec<slp_instance> slp_instances)\n {\n-  vec<slp_instance> slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n   slp_instance instance;\n   int i;\n   unsigned int vec_inside_cost = 0, vec_outside_cost = 0, scalar_cost = 0;\n   unsigned int vec_prologue_cost = 0, vec_epilogue_cost = 0;\n \n-  /* Calculate scalar cost.  */\n+  void *vect_target_cost_data = init_cost (NULL);\n+\n+  /* Calculate scalar cost and sum the cost for the vector stmts\n+     previously collected.  */\n   stmt_vector_for_cost scalar_costs;\n   scalar_costs.create (0);\n   hash_set<slp_tree> visited;\n@@ -3284,22 +3382,25 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n       vect_bb_slp_scalar_cost (bb_vinfo,\n \t\t\t       SLP_INSTANCE_TREE (instance),\n \t\t\t       &life, &scalar_costs, visited);\n+      add_stmt_costs (bb_vinfo, vect_target_cost_data, &instance->cost_vec);\n+      instance->cost_vec.release ();\n     }\n   /* Unset visited flag.  */\n   stmt_info_for_cost *si;\n   FOR_EACH_VEC_ELT (scalar_costs, i, si)\n     gimple_set_visited  (si->stmt_info->stmt, false);\n \n-  void *target_cost_data = init_cost (NULL);\n-  add_stmt_costs (bb_vinfo, target_cost_data, &scalar_costs);\n+  void *scalar_target_cost_data = init_cost (NULL);\n+  add_stmt_costs (bb_vinfo, scalar_target_cost_data, &scalar_costs);\n   scalar_costs.release ();\n   unsigned dummy;\n-  finish_cost (target_cost_data, &dummy, &scalar_cost, &dummy);\n-  destroy_cost_data (target_cost_data);\n+  finish_cost (scalar_target_cost_data, &dummy, &scalar_cost, &dummy);\n+  destroy_cost_data (scalar_target_cost_data);\n \n-  /* Complete the target-specific cost calculation.  */\n-  finish_cost (BB_VINFO_TARGET_COST_DATA (bb_vinfo), &vec_prologue_cost,\n+  /* Complete the target-specific vector cost calculation.  */\n+  finish_cost (vect_target_cost_data, &vec_prologue_cost,\n \t       &vec_inside_cost, &vec_epilogue_cost);\n+  destroy_cost_data (vect_target_cost_data);\n \n   vec_outside_cost = vec_prologue_cost + vec_epilogue_cost;\n \n@@ -3324,6 +3425,54 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   return true;\n }\n \n+/* For each SLP subgraph determine profitability and remove parts not so.\n+   Returns true if any profitable to vectorize subgraph remains.  */\n+\n+static bool\n+vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n+{\n+  slp_instance instance;\n+  unsigned i;\n+\n+  auto_vec<slp_instance> subgraphs (BB_VINFO_SLP_INSTANCES (bb_vinfo).length ());\n+  FOR_EACH_VEC_ELT (BB_VINFO_SLP_INSTANCES (bb_vinfo), i, instance)\n+    if (!instance->subgraph_entries.is_empty ())\n+      subgraphs.quick_push (instance);\n+  BB_VINFO_SLP_INSTANCES (bb_vinfo).truncate (0);\n+  for (i = 0; i < subgraphs.length ();)\n+    {\n+      instance = subgraphs[i];\n+      if (!vect_bb_vectorization_profitable_p (bb_vinfo,\n+\t\t\t\t\t       instance->subgraph_entries))\n+\t{\n+\t  /* ???  We need to think of providing better dump/opt-report\n+\t     locations here.  */\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"not vectorized: vectorization is not \"\n+\t\t\t       \"profitable.\\n\");\n+\t    }\n+\t  slp_instance entry;\n+\t  unsigned j;\n+\t  FOR_EACH_VEC_ELT (instance->subgraph_entries, j, entry)\n+\t    if (entry != instance)\n+\t      vect_free_slp_instance (entry, false);\n+\t  vect_free_slp_instance (instance, false);\n+\t  subgraphs.ordered_remove (i);\n+\t}\n+      else\n+\t{\n+\t  slp_instance entry;\n+\t  unsigned j;\n+\t  FOR_EACH_VEC_ELT (instance->subgraph_entries, j, entry)\n+\t    BB_VINFO_SLP_INSTANCES (bb_vinfo).safe_push (entry);\n+\t  ++i;\n+\t}\n+    }\n+  return !BB_VINFO_SLP_INSTANCES (bb_vinfo).is_empty ();\n+}\n+\n /* Find any vectorizable constructors and add them to the grouped_store\n    array.  */\n \n@@ -3465,6 +3614,8 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n       return false;\n     }\n \n+  vect_bb_partition_graph (bb_vinfo);\n+\n   /* Cost model: check if the vectorization is worthwhile.  */\n   if (!unlimited_cost_model (NULL)\n       && !vect_bb_vectorization_profitable_p (bb_vinfo))"}, {"sha": "8bf33137395db61f15dae24383e57b289abf7dff", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ddf4c7b1d4471cb9534f27844ab5e4279c2168/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ddf4c7b1d4471cb9534f27844ab5e4279c2168/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=47ddf4c7b1d4471cb9534f27844ab5e4279c2168", "patch": "@@ -183,6 +183,13 @@ typedef class _slp_instance {\n \n   /* The SLP node containing the reduction PHIs.  */\n   slp_tree reduc_phis;\n+\n+  /* Vector cost of this entry to the SLP graph.  */\n+  stmt_vector_for_cost cost_vec;\n+\n+  /* If this instance is the main entry of a subgraph the set of\n+     entries into the same subgraph, including itself.  */\n+  vec<_slp_instance *> subgraph_entries;\n } *slp_instance;\n \n \n@@ -913,7 +920,6 @@ typedef class _bb_vec_info : public vec_info\n #define BB_VINFO_SLP_INSTANCES(B)    (B)->slp_instances\n #define BB_VINFO_DATAREFS(B)         (B)->shared->datarefs\n #define BB_VINFO_DDRS(B)             (B)->shared->ddrs\n-#define BB_VINFO_TARGET_COST_DATA(B) (B)->target_cost_data\n \n static inline bb_vec_info\n vec_info_for_bb (basic_block bb)"}]}