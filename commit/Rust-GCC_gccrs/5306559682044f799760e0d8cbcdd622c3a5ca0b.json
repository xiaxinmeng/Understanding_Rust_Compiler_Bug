{"sha": "5306559682044f799760e0d8cbcdd622c3a5ca0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMwNjU1OTY4MjA0NGY3OTk3NjBlMGQ4Y2JjZGQ2MjJjM2E1Y2EwYg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-30T13:59:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-03-30T13:59:11Z"}, "message": "(enum attrs): New enum class.\n\n(attrtab, attrtab_idx): New variables.\n(add_attribute, init_attributes): New functions.\n(decl_attributes): Major rewrite.\n\nFrom-SVN: r9261", "tree": {"sha": "11e6272a09f47a1750e57043e3c14ac3bdb5a667", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11e6272a09f47a1750e57043e3c14ac3bdb5a667"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5306559682044f799760e0d8cbcdd622c3a5ca0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5306559682044f799760e0d8cbcdd622c3a5ca0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5306559682044f799760e0d8cbcdd622c3a5ca0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5306559682044f799760e0d8cbcdd622c3a5ca0b/comments", "author": null, "committer": null, "parents": [{"sha": "5d7a33dca49325ab3e4c83b1fd0cf9dfc152aa20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d7a33dca49325ab3e4c83b1fd0cf9dfc152aa20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d7a33dca49325ab3e4c83b1fd0cf9dfc152aa20"}], "stats": {"total": 652, "additions": 370, "deletions": 282}, "files": [{"sha": "b625447cd073b68c860d4b44f1a760c893eecf2d", "filename": "gcc/c-common.c", "status": "modified", "additions": 370, "deletions": 282, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5306559682044f799760e0d8cbcdd622c3a5ca0b/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5306559682044f799760e0d8cbcdd622c3a5ca0b/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=5306559682044f799760e0d8cbcdd622c3a5ca0b", "patch": "@@ -28,7 +28,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n extern struct obstack permanent_obstack;\n \n-static void declare_hidden_char_array PROTO((char *, char *));\n+enum attrs {A_PACKED, A_NORETURN, A_CONST, A_T_UNION, A_CONSTRUCTOR,\n+\t    A_DESTRUCTOR, A_MODE, A_SECTION, A_ALIGNED, A_FORMAT};\n+\n+static void declare_hidden_char_array\tPROTO((char *, char *));\n+static void add_attribute\t\tPROTO((enum attrs, char *,\n+\t\t\t\t\t       int, int, int));\n+static void init_attributes\t\tPROTO((void));\n \n /* Make bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */\n \n@@ -199,318 +205,400 @@ combine_strings (strings)\n   return value;\n }\n \f\n+/* To speed up processing of attributes, we maintain an array of\n+   IDENTIFIER_NODES and the corresponding attribute types.  */\n+\n+/* Array to hold attribute information.  */\n+\n+static struct {enum attrs id; tree name; int min, max, decl_req;} attrtab[50];\n+\n+static int attrtab_idx = 0;\n+\n+/* Add an entry to the attribute table above.  */\n+\n+static void\n+add_attribute (id, string, min_len, max_len, decl_req)\n+     enum attrs id;\n+     char *string;\n+     int min_len, max_len;\n+     int decl_req;\n+{\n+  char buf[100];\n+\n+  attrtab[attrtab_idx].id = id;\n+  attrtab[attrtab_idx].name = get_identifier (string);\n+  attrtab[attrtab_idx].min = min_len;\n+  attrtab[attrtab_idx].max = max_len;\n+  attrtab[attrtab_idx++].decl_req = decl_req;\n+\n+  sprintf (buf, \"__%s__\", string);\n+\n+  attrtab[attrtab_idx].id = id;\n+  attrtab[attrtab_idx].name = get_identifier (buf);\n+  attrtab[attrtab_idx].min = min_len;\n+  attrtab[attrtab_idx].max = max_len;\n+  attrtab[attrtab_idx++].decl_req = decl_req;\n+}\n+\n+/* Initialize attribute table.  */\n+\n+static void\n+init_attributes ()\n+{\n+  add_attribute (A_PACKED, \"packed\", 0, 0, 1);\n+  add_attribute (A_NORETURN, \"noreturn\", 0, 0, 1);\n+  add_attribute (A_NORETURN, \"volatile\", 0, 0, 1);\n+  add_attribute (A_CONST, \"const\", 0, 0, 1);\n+  add_attribute (A_T_UNION, \"transparent_union\", 0, 0, 0);\n+  add_attribute (A_CONSTRUCTOR, \"constructor\", 0, 0, 1);\n+  add_attribute (A_DESTRUCTOR, \"destructor\", 0, 0, 1);\n+  add_attribute (A_MODE, \"mode\", 1, 1, 1);\n+  add_attribute (A_SECTION, \"section\", 1, 1, 1);\n+  add_attribute (A_ALIGNED, \"aligned\", 0, 1, 0);\n+  add_attribute (A_FORMAT, \"format\", 3, 3, 0);\n+}\n+\f\n /* Process the attributes listed in ATTRIBUTES and PREFIX_ATTRIBUTES\n-   and install them in DECL.  PREFIX_ATTRIBUTES can appear after the\n-   declaration specifiers and declaration modifiers but before the\n-   declaration proper. */\n+   and install them in NODE, which is either a DECL (including a TYPE_DECL)\n+   or a TYPE.  PREFIX_ATTRIBUTES can appear after the declaration specifiers\n+   and declaration modifiers but before the declaration proper. */\n \n void\n-decl_attributes (decl, attributes, prefix_attributes)\n-     tree decl, attributes, prefix_attributes;\n+decl_attributes (node, attributes, prefix_attributes)\n+     tree node, attributes, prefix_attributes;\n {\n-  tree a, name, args, type;\n+  tree decl = 0, type;\n+  int is_type;\n+  tree a;\n+\n+  if (attrtab_idx == 0)\n+    init_attributes ();\n+\n+  if (TREE_CODE_CLASS (TREE_CODE (node)) == 'd')\n+    {\n+      decl = node;\n+      type = TREE_TYPE (decl);\n+      is_type = TREE_CODE (node) == TYPE_DECL;\n+    }\n+  else if (TREE_CODE_CLASS (TREE_CODE (node)) == 't')\n+    type = node, is_type = 1;\n \n-  type = TREE_TYPE (decl);\n   attributes = chainon (prefix_attributes, attributes);\n \n   for (a = attributes; a; a = TREE_CHAIN (a))\n-    if (!(name = TREE_VALUE (a)))\n-\tcontinue;\n-    else if (name == get_identifier (\"packed\")\n-\t     || name == get_identifier (\"__packed__\"))\n-      {\n-\tif (TREE_CODE (decl) == FIELD_DECL)\n-\t  DECL_PACKED (decl) = 1;\n-\t/* We can't set DECL_PACKED for a VAR_DECL, because the bit is\n-\t   used for DECL_REGISTER.  It wouldn't mean anything anyway.  */\n-\telse\n-\t  warning_with_decl (decl, \"`packed' attribute ignored\");\n-      }\n-    else if (name == get_identifier (\"noreturn\")\n-\t     || name == get_identifier (\"__noreturn__\")\n-\t     || name == get_identifier (\"volatile\")\n-\t     || name == get_identifier (\"__volatile__\"))\n-      {\n-\tif (TREE_CODE (decl) == FUNCTION_DECL)\n-\t  TREE_THIS_VOLATILE (decl) = 1;\n-\telse if (TREE_CODE (type) == POINTER_TYPE\n-\t\t && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-\t  TREE_TYPE (decl) = type \n-\t    = build_pointer_type\n-\t      (build_type_variant (TREE_TYPE (type),\n-\t\t\t\t   TREE_READONLY (TREE_TYPE (type)), 1));\n-\telse\n-\t  warning_with_decl (decl,\n-\t\t\t     (IDENTIFIER_POINTER (name)[0] == 'n'\n-\t\t\t      || IDENTIFIER_POINTER (name)[2] == 'n')\n-\t\t\t     ? \"`noreturn' attribute ignored\"\n-\t\t\t     : \"`volatile' attribute ignored\");\n-      }\n-    else if (name == get_identifier (\"const\")\n-\t     || name == get_identifier (\"__const__\"))\n-      {\n-\tif (TREE_CODE (decl) == FUNCTION_DECL)\n-\t  TREE_READONLY (decl) = 1;\n-\telse if (TREE_CODE (type) == POINTER_TYPE\n-\t\t && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-\t  TREE_TYPE (decl) = type\n-\t    = build_pointer_type\n-\t      (build_type_variant (TREE_TYPE (type), 1,\n-\t\t\t\t   TREE_THIS_VOLATILE (TREE_TYPE (type))));\n-\telse\n-\t  warning_with_decl (decl, \"`const' attribute ignored\");\n-      }\n-    else if (name == get_identifier (\"transparent_union\")\n-\t     || name == get_identifier (\"__transparent_union__\"))\n-      {\n-\tif (TREE_CODE (decl) == PARM_DECL\n-\t    && TREE_CODE (type) == UNION_TYPE\n-\t    && TYPE_MODE (type) == DECL_MODE (TYPE_FIELDS (type)))\n-\t  DECL_TRANSPARENT_UNION (decl) = 1;\n-\telse if (TREE_CODE (decl) == TYPE_DECL\n-\t\t && TREE_CODE (type) == UNION_TYPE\n-\t\t && TYPE_MODE (type) == DECL_MODE (TYPE_FIELDS (type)))\n-\t  TYPE_TRANSPARENT_UNION (type) = 1;\n-\telse\n-\t  warning_with_decl (decl, \"`transparent_union' attribute ignored\");\n-      }\n-    else if (name == get_identifier (\"constructor\")\n-\t     || name == get_identifier (\"__constructor__\"))\n-      {\n-\tif (TREE_CODE (decl) != FUNCTION_DECL\n-\t    || TREE_CODE (TREE_TYPE (decl)) != FUNCTION_TYPE\n-\t    || decl_function_context (decl))\n-\t  {\n-\t    error_with_decl (decl,\n-\t\t    \"`constructor' attribute meaningless for non-function %s\");\n-\t    continue;\n-\t  }\n-\tDECL_STATIC_CONSTRUCTOR (decl) = 1;\n-      }\n-    else if (name == get_identifier (\"destructor\")\n-\t     || name == get_identifier (\"__destructor__\"))\n-      {\n-\tif (TREE_CODE (decl) != FUNCTION_DECL\n-\t    || TREE_CODE (TREE_TYPE (decl)) != FUNCTION_TYPE\n-\t    || decl_function_context (decl))\n-\t  {\n-\t    error_with_decl (decl,\n-\t\t    \"`destructor' attribute meaningless for non-function %s\");\n-\t    continue;\n-\t  }\n-\tDECL_STATIC_DESTRUCTOR (decl) = 1;\n-      }\n-    else if ((args = TREE_CHAIN (name)) != 0\n-\t     && (name == get_identifier (\"mode\")\n-\t\t || name == get_identifier (\"__mode__\"))\n-\t     && list_length (args) == 1\n-\t     && TREE_CODE (TREE_VALUE (args)) == IDENTIFIER_NODE)\n-      {\n-\tint i;\n-\tchar *specified_name = IDENTIFIER_POINTER (TREE_VALUE (args));\n-\tenum machine_mode mode = VOIDmode;\n-\ttree typefm;\n-\n-\t/* Give this decl a type with the specified mode.\n-\t   First check for the special modes.  */\n-\tif (! strcmp (specified_name, \"byte\")\n-\t    || ! strcmp (specified_name, \"__byte__\"))\n-\t  mode = byte_mode;\n-\telse if (!strcmp (specified_name, \"word\")\n-\t\t || ! strcmp (specified_name, \"__word__\"))\n-\t  mode = word_mode;\n-\telse if (! strcmp (specified_name, \"pointer\")\n-\t\t || !strcmp (specified_name, \"__pointer__\"))\n-\t  mode = ptr_mode;\n-\telse\n-\t  for (i = 0; i < NUM_MACHINE_MODES; i++)\n-\t    if (!strcmp (specified_name, GET_MODE_NAME (i)))\n-\t      mode = (enum machine_mode) i;\n-\n-\tif (mode == VOIDmode)\n-\t  error (\"unknown machine mode `%s'\", specified_name);\n-\telse if ((typefm = type_for_mode (mode, TREE_UNSIGNED (type))) == 0)\n-\t  error (\"no data type for mode `%s'\", specified_name);\n-\telse\n-\t  {\n-\t    TREE_TYPE (decl) = type = typefm;\n-\t    DECL_SIZE (decl) = 0;\n-\t    layout_decl (decl, 0);\n-\t  }\n-      }\n-    else if ((!strcmp (IDENTIFIER_POINTER (name), \"section\")\n-\t      || !strcmp (IDENTIFIER_POINTER (name), \"__section__\"))\n-\t     && list_length (args) == 1\n-\t     && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n-      {\n+    {\n+      tree name = TREE_PURPOSE (a);\n+      tree args = TREE_VALUE (a);\n+      int i;\n+      enum attrs id;\n+      \n+      for (i = 0; i < attrtab_idx; i++)\n+\tif (attrtab[i].name == name)\n+\t  break;\n+\n+      if (i == attrtab_idx\n+\t  && ! valid_machine_attribute (name, args, decl, type))\n+\t{\n+\t  warning (\"`%s' attribute directive ignored\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  continue;\n+\t}\n+      else if (attrtab[i].decl_req && decl == 0)\n+\t{\n+\t  warning (\"`%s' attribute does not apply to types\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  continue;\n+\t}\n+      else if (list_length (args) < attrtab[i].min\n+\t       || list_length (args) > attrtab[i].max)\n+\t{\n+\t  error (\"wrong number of arguments specified for `%s' attribute\",\n+\t\t IDENTIFIER_POINTER (name));\n+\t  continue;\n+\t}\n+\n+      id = attrtab[i].id;\n+      switch (id)\n+\t{\n+\tcase A_PACKED:\n+\t  if (TREE_CODE (decl) == FIELD_DECL)\n+\t    DECL_PACKED (decl) = 1;\n+\t  /* We can't set DECL_PACKED for a VAR_DECL, because the bit is\n+\t     used for DECL_REGISTER.  It wouldn't mean anything anyway.  */\n+\t  else\n+\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  break;\n+\n+\tcase A_NORETURN:\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    TREE_THIS_VOLATILE (decl) = 1;\n+\t  else if (TREE_CODE (type) == POINTER_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+\t    TREE_TYPE (decl) = type \n+\t      = build_pointer_type\n+\t\t(build_type_variant (TREE_TYPE (type),\n+\t\t\t\t     TREE_READONLY (TREE_TYPE (type)), 1));\n+\t  else\n+\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  break;\n+\n+\tcase A_CONST:\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    TREE_READONLY (decl) = 1;\n+\t  else if (TREE_CODE (type) == POINTER_TYPE\n+\t\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+\t    TREE_TYPE (decl) = type\n+\t      = build_pointer_type\n+\t\t(build_type_variant (TREE_TYPE (type), 1,\n+\t\t\t\t     TREE_THIS_VOLATILE (TREE_TYPE (type))));\n+\t  else\n+\t    warning ( \"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  break;\n+\n+\tcase A_T_UNION:\n+\t  if (decl != 0 && TREE_CODE (decl) == PARM_DECL\n+\t      && TREE_CODE (type) == UNION_TYPE\n+\t      && TYPE_MODE (type) == DECL_MODE (TYPE_FIELDS (type)))\n+\t    DECL_TRANSPARENT_UNION (decl) = 1;\n+\t  else if (is_type\n+\t\t   && TREE_CODE (type) == UNION_TYPE\n+\t\t   && TYPE_MODE (type) == DECL_MODE (TYPE_FIELDS (type)))\n+\t    TYPE_TRANSPARENT_UNION (type) = 1;\n+\t  else\n+\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  break;\n+\n+\tcase A_CONSTRUCTOR:\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && TREE_CODE (type) == FUNCTION_TYPE\n+\t      && decl_function_context (decl) == 0)\n+\t    DECL_STATIC_CONSTRUCTOR (decl) = 1;\n+\t  else\n+\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  break;\n+\n+\tcase A_DESTRUCTOR:\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && TREE_CODE (type) == FUNCTION_TYPE\n+\t      && decl_function_context (decl) == 0)\n+\t    DECL_STATIC_DESTRUCTOR (decl) = 1;\n+\t  else\n+\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  break;\n+\n+\tcase A_MODE:\n+\t  if (TREE_CODE (TREE_VALUE (args)) != IDENTIFIER_NODE)\n+\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  else\n+\t    {\n+\t      int j;\n+\t      char *p = IDENTIFIER_POINTER (TREE_VALUE (args));\n+\t      int len = strlen (p);\n+\t      enum machine_mode mode = VOIDmode;\n+\t      tree typefm;\n+\n+\t      if (len > 4 && p[0] == '_' && p[1] == '_'\n+\t\t  && p[len - 1] == '_' && p[len - 2] == '_')\n+\t\t{\n+\t\t  char *newp = (char *) alloca (len - 2);\n+\n+\t\t  strcpy (newp, &p[2]);\n+\t\t  newp[len - 4] = '\\0';\n+\t\t  p = newp;\n+\t\t}\n+\n+\t      /* Give this decl a type with the specified mode.\n+\t\t First check for the special modes.  */\n+\t      if (! strcmp (p, \"byte\"))\n+\t\tmode = byte_mode;\n+\t      else if (!strcmp (p, \"word\"))\n+\t\tmode = word_mode;\n+\t      else if (! strcmp (p, \"pointer\"))\n+\t\tmode = ptr_mode;\n+\t      else\n+\t\tfor (j = 0; j < NUM_MACHINE_MODES; j++)\n+\t\t  if (!strcmp (p, GET_MODE_NAME (j)))\n+\t\t    mode = (enum machine_mode) j;\n+\n+\t      if (mode == VOIDmode)\n+\t\terror (\"unknown machine mode `%s'\", p);\n+\t      else if (0 == (typefm = type_for_mode (mode,\n+\t\t\t\t\t\t     TREE_UNSIGNED (type))))\n+\t\terror (\"no data type for mode `%s'\", p);\n+\t      else\n+\t\t{\n+\t\t  TREE_TYPE (decl) = type = typefm;\n+\t\t  DECL_SIZE (decl) = 0;\n+\t\t  layout_decl (decl, 0);\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase A_SECTION:\n #ifdef ASM_OUTPUT_SECTION_NAME\n-\tif (TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n-\t  {\n-\t    if (TREE_CODE (decl) == VAR_DECL \n-                && current_function_decl != NULL_TREE)\n-\t      error_with_decl (decl,\n-\t\t\t       \"section attribute cannot be specified for local variables\");\n-\t    /* The decl may have already been given a section attribute from\n-\t       a previous declaration.  Ensure they match.  */\n-\t    else if (DECL_SECTION_NAME (decl) != NULL_TREE\n-\t\t     && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n-\t\t\t\tTREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n-\t      error_with_decl (decl,\n-\t\t\t       \"section of `%s' conflicts with previous declaration\");\n-\t    else\n-\t      DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n-\t  }\n-\telse\n-\t  error_with_decl (decl,\n+\t  if ((TREE_CODE (decl) == FUNCTION_DECL\n+\t       || TREE_CODE (decl) == VAR_DECL)\n+\t      && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n+\t    {\n+\t      if (TREE_CODE (decl) == VAR_DECL \n+\t\t  && current_function_decl != NULL_TREE)\n+\t\terror_with_decl (decl,\n+\t\t  \"section attribute cannot be specified for local variables\");\n+\t      /* The decl may have already been given a section attribute from\n+\t\t a previous declaration.  Ensure they match.  */\n+\t      else if (DECL_SECTION_NAME (decl) != NULL_TREE\n+\t\t       && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n+\t\t\t\t  TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n+\t\terror_with_decl (node,\n+\t\t\t\t \"section of `%s' conflicts with previous declaration\");\n+\t      else\n+\t\tDECL_SECTION_NAME (decl) = TREE_VALUE (args);\n+\t    }\n+\t  else\n+\t    error_with_decl (node,\n \t\t\t   \"section attribute not allowed for `%s'\");\n #else\n-\terror_with_decl (decl, \"section attributes are not supported for this target\");\n+\t  error_with_decl (node,\n+\t\t  \"section attributes are not supported for this target\");\n #endif\n-      }\n-    else if ((!strcmp (IDENTIFIER_POINTER (name), \"aligned\")\n-\t      || !strcmp (IDENTIFIER_POINTER (name), \"__aligned__\"))\n-\t     && list_length (args) == 1\n-\t     && TREE_CODE (TREE_VALUE (args)) == INTEGER_CST)\n-      {\n-\ttree align_expr = TREE_VALUE (args);\n-\tint align;\n-\n-\t/* Strip any NOPs of any kind.  */\n-\twhile (TREE_CODE (align_expr) == NOP_EXPR\n-\t       || TREE_CODE (align_expr) == CONVERT_EXPR\n-\t       || TREE_CODE (align_expr) == NON_LVALUE_EXPR)\n-\t  align_expr = TREE_OPERAND (align_expr, 0);\n-\n-\tif (TREE_CODE (align_expr) != INTEGER_CST)\n+\t  break;\n+\n+\tcase A_ALIGNED:\n \t  {\n-\t    error_with_decl (decl,\n-\t\t\t     \"requested alignment of `%s' is not a constant\");\n-\t    continue;\n+\t    tree align_expr\n+\t      = args ? TREE_VALUE (args) : size_int (BIGGEST_ALIGNMENT);\n+\t    int align;\n+\n+\t    /* Strip any NOPs of any kind.  */\n+\t    while (TREE_CODE (align_expr) == NOP_EXPR\n+\t\t   || TREE_CODE (align_expr) == CONVERT_EXPR\n+\t\t   || TREE_CODE (align_expr) == NON_LVALUE_EXPR)\n+\t      align_expr = TREE_OPERAND (align_expr, 0);\n+\t  \n+\t    if (TREE_CODE (align_expr) != INTEGER_CST)\n+\t      {\n+\t\terror (\"requested alignment is not a constant\");\n+\t\tcontinue;\n+\t      }\n+\n+\t    align = TREE_INT_CST_LOW (align_expr) * BITS_PER_UNIT;\n+\n+\t    if (exact_log2 (align) == -1)\n+\t      error (\"requested alignment is not a power of 2\");\n+\t    else if (is_type)\n+\t      TYPE_ALIGN (TREE_TYPE (decl)) = align;\n+\t    else if (TREE_CODE (decl) != VAR_DECL\n+\t\t     && TREE_CODE (decl) != FIELD_DECL)\n+\t      error_with_decl (decl,\n+\t\t\t       \"alignment may not be specified for `%s'\");\n+\t    else\n+\t      DECL_ALIGN (decl) = align;\n \t  }\n+\t  break;\n \n-\talign = TREE_INT_CST_LOW (align_expr) * BITS_PER_UNIT;\n-\t\n-\tif (exact_log2 (align) == -1)\n-\t  error_with_decl (decl,\n-\t\t\t   \"requested alignment of `%s' is not a power of 2\");\n-\telse if (TREE_CODE (decl) == TYPE_DECL)\n-\t  TYPE_ALIGN (TREE_TYPE (decl)) = align;\n-\telse if (TREE_CODE (decl) != VAR_DECL\n-\t\t && TREE_CODE (decl) != FIELD_DECL)\n-\t  error_with_decl (decl,\n-\t\t\t   \"alignment may not be specified for `%s'\");\n-\telse\n-\t  DECL_ALIGN (decl) = align;\n-      }\n-    else if ((!strcmp (IDENTIFIER_POINTER (name), \"format\")\n-\t      || !strcmp (IDENTIFIER_POINTER (name), \"__format__\"))\n-\t     && list_length (args) == 3\n-\t     && TREE_CODE (TREE_VALUE (args)) == IDENTIFIER_NODE\n-\t     && TREE_CODE (TREE_VALUE (TREE_CHAIN (args))) == INTEGER_CST\n-\t     && TREE_CODE (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)))) \n-                == INTEGER_CST )\n-      {\n-        tree format_type = TREE_VALUE (args);\n-\ttree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n-\ttree first_arg_num_expr = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n-\tint format_num;\n-\tint first_arg_num;\n-\tint is_scan;\n-\ttree argument;\n-\tint arg_num;\n-\t\n-\tif (TREE_CODE (decl) != FUNCTION_DECL)\n+\tcase A_FORMAT:\n \t  {\n-\t    error_with_decl (decl,\n-\t\t\t     \"argument format specified for non-function `%s'\");\n-\t    continue;\n-\t  }\n+\t    tree format_type = TREE_VALUE (args);\n+\t    tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n+\t    tree first_arg_num_expr\n+\t      = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n+\t    int format_num;\n+\t    int first_arg_num;\n+\t    int is_scan;\n+\t    tree argument;\n+\t    int arg_num;\n \t\n-\tif (!strcmp (IDENTIFIER_POINTER (format_type), \"printf\")\n-\t    || !strcmp (IDENTIFIER_POINTER (format_type), \"__printf__\"))\n-\t  is_scan = 0;\n-\telse if (!strcmp (IDENTIFIER_POINTER (format_type), \"scanf\")\n-\t\t || !strcmp (IDENTIFIER_POINTER (format_type), \"__scanf__\"))\n-\t  is_scan = 1;\n-\telse\n-\t  {\n-\t    error_with_decl (decl, \"unrecognized format specifier for `%s'\");\n-\t    continue;\n-\t  }\n+\t    if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t      {\n+\t\terror_with_decl (decl,\n+\t\t\t \"argument format specified for non-function `%s'\");\n+\t\tcontinue;\n+\t      }\n \t\n-\t/* Strip any conversions from the string index and first arg number\n-\t   and verify they are constants.  */\n-\twhile (TREE_CODE (format_num_expr) == NOP_EXPR\n-\t       || TREE_CODE (format_num_expr) == CONVERT_EXPR\n-\t       || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n-\t  format_num_expr = TREE_OPERAND (format_num_expr, 0);\n-\n-\twhile (TREE_CODE (first_arg_num_expr) == NOP_EXPR\n-\t       || TREE_CODE (first_arg_num_expr) == CONVERT_EXPR\n-\t       || TREE_CODE (first_arg_num_expr) == NON_LVALUE_EXPR)\n-\t  first_arg_num_expr = TREE_OPERAND (first_arg_num_expr, 0);\n-\n-\tif (TREE_CODE (format_num_expr) != INTEGER_CST\n-\t    || TREE_CODE (first_arg_num_expr) != INTEGER_CST)\n-\t  {\n-\t    error_with_decl (decl,\n-\t\t   \"format string for `%s' has non-constant operand number\");\n-\t    continue;\n-\t  }\n+\t    if (TREE_CODE (format_type) == IDENTIFIER_NODE\n+\t\t&& (!strcmp (IDENTIFIER_POINTER (format_type), \"printf\")\n+\t\t    || !strcmp (IDENTIFIER_POINTER (format_type),\n+\t\t\t\t\"__printf__\")))\n+\t      is_scan = 0;\n+\t    else if (TREE_CODE (format_type) == IDENTIFIER_NODE\n+\t\t     && (!strcmp (IDENTIFIER_POINTER (format_type), \"scanf\")\n+\t\t\t || !strcmp (IDENTIFIER_POINTER (format_type),\n+\t\t\t\t     \"__scanf__\")))\n+\t      is_scan = 1;\n+\t    else\n+\t      {\n+\t\terror (\"unrecognized format specifier for `%s'\");\n+\t\tcontinue;\n+\t      }\n \n-\tformat_num = TREE_INT_CST_LOW (format_num_expr);\n-\tfirst_arg_num = TREE_INT_CST_LOW (first_arg_num_expr);\n-\tif (first_arg_num != 0 && first_arg_num <= format_num)\n-\t  {\n-\t    error_with_decl (decl,\n-\t      \"format string arg follows the args to be formatted, for `%s'\");\n-\t    continue;\n-\t  }\n+\t    /* Strip any conversions from the string index and first arg number\n+\t       and verify they are constants.  */\n+\t    while (TREE_CODE (format_num_expr) == NOP_EXPR\n+\t\t   || TREE_CODE (format_num_expr) == CONVERT_EXPR\n+\t\t   || TREE_CODE (format_num_expr) == NON_LVALUE_EXPR)\n+\t      format_num_expr = TREE_OPERAND (format_num_expr, 0);\n \n-\t/* If a parameter list is specified, verify that the format_num\n-\t   argument is actually a string, in case the format attribute\n-\t   is in error.  */\n-\targument = TYPE_ARG_TYPES (type);\n-\tif (argument)\n-\t  {\n-\t    for (arg_num = 1; ; ++arg_num)\n+\t    while (TREE_CODE (first_arg_num_expr) == NOP_EXPR\n+\t\t   || TREE_CODE (first_arg_num_expr) == CONVERT_EXPR\n+\t\t   || TREE_CODE (first_arg_num_expr) == NON_LVALUE_EXPR)\n+\t      first_arg_num_expr = TREE_OPERAND (first_arg_num_expr, 0);\n+\n+\t    if (TREE_CODE (format_num_expr) != INTEGER_CST\n+\t\t|| TREE_CODE (first_arg_num_expr) != INTEGER_CST)\n \t      {\n-\t\tif (argument == 0 || arg_num == format_num)\n-\t\t  break;\n-\t\targument = TREE_CHAIN (argument);\n+\t\terror (\"format string has non-constant operand number\");\n+\t\tcontinue;\n \t      }\n-\t    if (! argument\n-\t\t|| TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n-\t\t|| (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n-\t\t    != char_type_node))\n+\n+\t    format_num = TREE_INT_CST_LOW (format_num_expr);\n+\t    first_arg_num = TREE_INT_CST_LOW (first_arg_num_expr);\n+\t    if (first_arg_num != 0 && first_arg_num <= format_num)\n \t      {\n-\t\terror_with_decl (decl,\n-\t\t\t     \"format string arg not a string type, for `%s'\");\n+\t\terror (\"format string arg follows the args to be formatted\");\n \t\tcontinue;\n \t      }\n-\t    if (first_arg_num != 0)\n+\n+\t    /* If a parameter list is specified, verify that the format_num\n+\t       argument is actually a string, in case the format attribute\n+\t       is in error.  */\n+\t    argument = TYPE_ARG_TYPES (type);\n+\t    if (argument)\n \t      {\n-\t\t/* Verify that first_arg_num points to the last arg, the ... */\n-\t\twhile (argument)\n-\t\t  arg_num++, argument = TREE_CHAIN (argument);\n-\t\tif (arg_num != first_arg_num)\n+\t\tfor (arg_num = 1; ; ++arg_num)\n+\t\t  {\n+\t\t    if (argument == 0 || arg_num == format_num)\n+\t\t      break;\n+\t\t    argument = TREE_CHAIN (argument);\n+\t\t  }\n+\t\tif (! argument\n+\t\t    || TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE\n+\t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (argument)))\n+\t\t      != char_type_node))\n \t\t  {\n-\t\t    error_with_decl (decl,\n-\t\t\t\t \"args to be formatted is not ..., for `%s'\");\n+\t\t    error (\"format string arg not a string type\");\n \t\t    continue;\n \t\t  }\n+\t\tif (first_arg_num != 0)\n+\t\t  {\n+\t\t    /* Verify that first_arg_num points to the last arg,\n+\t\t       the ... */\n+\t\t    while (argument)\n+\t\t      arg_num++, argument = TREE_CHAIN (argument);\n+\t\t  if (arg_num != first_arg_num)\n+\t\t    {\n+\t\t      error (\"args to be formatted is not ...\");\n+\t\t      continue;\n+\t\t    }\n+\t\t  }\n \t      }\n-\t  }\n-\n-\trecord_function_format (DECL_NAME (decl), DECL_ASSEMBLER_NAME (decl),\n-\t\t\t\tis_scan, format_num, first_arg_num);\n-      }\n-    else if (valid_machine_attribute (name, decl, type))\n-      ;\n-    else\n-      warning (\"`%s' attribute directive ignored\",\n-\t       IDENTIFIER_POINTER (name));\n \n+\t    record_function_format (DECL_NAME (decl),\n+\t\t\t\t    DECL_ASSEMBLER_NAME (decl),\n+\t\t\t\t    is_scan, format_num, first_arg_num);\n+\t    break;\n+\t  }\n+\t}\n+    }\n }\n \f\n /* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against"}]}