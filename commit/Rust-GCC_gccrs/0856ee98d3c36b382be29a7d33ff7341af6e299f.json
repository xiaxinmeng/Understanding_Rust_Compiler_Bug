{"sha": "0856ee98d3c36b382be29a7d33ff7341af6e299f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg1NmVlOThkM2MzNmIzODJiZTI5YTdkMzNmZjczNDFhZjZlMjk5Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-09-17T20:58:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2005-09-17T20:58:14Z"}, "message": "except.c (struct eh_status): Turn region_array into vec.\n\n2005-09-17  Jan Hubicka  <jh@suse.cz>\n\n\t* except.c (struct eh_status): Turn region_array into vec.\n\t(expand_resx_expr, collect_eh_region_array, remove_unreachable_regions,\n\tconvert_from_eh_region_ranges, find_exception_handler_labels,\n\tcurrent_function_has_exception_handlers, assign_filter_values,\n\tbuild_post_landing_pads, dw2_build_landing_pads,\n\tsjlj_find_directly_reachable_regions, sjlj_mark_call_sites,\n\tsjlj_emit_dispatch_table, remove_eh_handler, for_each_eh_region,\n\tforeach_reachable_handler, can_throw_internal_1,\n\tconvert_to_eh_region_ranges, verify_eh_tree): Update uses of\n\tregion_array.\n\t(duplicate_eh_region_1): Update region_array.\n\t(duplicate_eh_regions): Resize region_array and avoid recomputing.\n\nFrom-SVN: r104375", "tree": {"sha": "6007379a8d48eef764853cdfda1b553008358a60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6007379a8d48eef764853cdfda1b553008358a60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0856ee98d3c36b382be29a7d33ff7341af6e299f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0856ee98d3c36b382be29a7d33ff7341af6e299f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0856ee98d3c36b382be29a7d33ff7341af6e299f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0856ee98d3c36b382be29a7d33ff7341af6e299f/comments", "author": null, "committer": null, "parents": [{"sha": "53c4ca47aefe9fe454964b4db1e007044132f550", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53c4ca47aefe9fe454964b4db1e007044132f550", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53c4ca47aefe9fe454964b4db1e007044132f550"}], "stats": {"total": 120, "additions": 82, "deletions": 38}, "files": [{"sha": "d0a683bfa75c801fd224c88018daa03b22852f82", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0856ee98d3c36b382be29a7d33ff7341af6e299f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0856ee98d3c36b382be29a7d33ff7341af6e299f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0856ee98d3c36b382be29a7d33ff7341af6e299f", "patch": "@@ -1,3 +1,18 @@\n+2005-09-17  Jan Hubicka  <jh@suse.cz>\n+\n+\t* except.c (struct eh_status): Turn region_array into vec.\n+\t(expand_resx_expr, collect_eh_region_array, remove_unreachable_regions,\n+\tconvert_from_eh_region_ranges, find_exception_handler_labels, \n+\tcurrent_function_has_exception_handlers, assign_filter_values, \n+\tbuild_post_landing_pads, dw2_build_landing_pads,\n+\tsjlj_find_directly_reachable_regions, sjlj_mark_call_sites,\n+\tsjlj_emit_dispatch_table, remove_eh_handler, for_each_eh_region,\n+\tforeach_reachable_handler, can_throw_internal_1,\n+\tconvert_to_eh_region_ranges, verify_eh_tree): Update uses of\n+\tregion_array.\n+\t(duplicate_eh_region_1): Update region_array.\n+\t(duplicate_eh_regions): Resize region_array and avoid recomputing.\n+\n 2005-09-17  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR middle-end/22067"}, {"sha": "4e51d3ef251127ce2d6a35ccfc4a88ab56afcef0", "filename": "gcc/except.c", "status": "modified", "additions": 67, "deletions": 38, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0856ee98d3c36b382be29a7d33ff7341af6e299f/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0856ee98d3c36b382be29a7d33ff7341af6e299f/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=0856ee98d3c36b382be29a7d33ff7341af6e299f", "patch": "@@ -199,20 +199,25 @@ struct eh_region GTY(())\n   unsigned may_contain_throw : 1;\n };\n \n+typedef struct eh_region *eh_region;\n+\n struct call_site_record GTY(())\n {\n   rtx landing_pad;\n   int action;\n };\n \n+DEF_VEC_P(eh_region);\n+DEF_VEC_ALLOC_P(eh_region, gc);\n+\n /* Used to save exception status for each function.  */\n struct eh_status GTY(())\n {\n   /* The tree of all regions for this function.  */\n   struct eh_region *region_tree;\n \n   /* The same information as an indexable array.  */\n-  struct eh_region ** GTY ((length (\"%h.last_region_number\"))) region_array;\n+  VEC(eh_region,gc) *region_array;\n \n   /* The most recently open region.  */\n   struct eh_region *cur_region;\n@@ -562,7 +567,8 @@ void\n expand_resx_expr (tree exp)\n {\n   int region_nr = TREE_INT_CST_LOW (TREE_OPERAND (exp, 0));\n-  struct eh_region *reg = cfun->eh->region_array[region_nr];\n+  struct eh_region *reg = VEC_index (eh_region,\n+\t\t\t\t     cfun->eh->region_array, region_nr);\n \n   gcc_assert (!reg->resume);\n   reg->resume = emit_jump_insn (gen_rtx_RESX (VOIDmode, region_nr));\n@@ -626,19 +632,19 @@ get_exception_filter (struct function *fun)\n void\n collect_eh_region_array (void)\n {\n-  struct eh_region **array, *i;\n+  struct eh_region *i;\n \n   i = cfun->eh->region_tree;\n   if (! i)\n     return;\n \n-  array = ggc_alloc_cleared ((cfun->eh->last_region_number + 1)\n-\t\t\t     * sizeof (*array));\n-  cfun->eh->region_array = array;\n+  VEC_safe_grow (eh_region, gc, cfun->eh->region_array,\n+\t\t cfun->eh->last_region_number + 1);\n+  VEC_replace (eh_region, cfun->eh->region_array, 0, 0);\n \n   while (1)\n     {\n-      array[i->region_number] = i;\n+      VEC_replace (eh_region, cfun->eh->region_array, i->region_number, i);\n \n       /* If there are sub-regions, process them.  */\n       if (i->inner)\n@@ -674,7 +680,7 @@ remove_unreachable_regions (rtx insns)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      r = cfun->eh->region_array[i];\n+      r = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (!r || r->region_number != i)\n \tcontinue;\n \n@@ -695,7 +701,7 @@ remove_unreachable_regions (rtx insns)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      r = cfun->eh->region_array[i];\n+      r = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (r && r->region_number == i && !reachable[i])\n \t{\n \t  bool kill_it = true;\n@@ -756,7 +762,9 @@ convert_from_eh_region_ranges (void)\n      we allocated earlier.  */\n   for (i = 1; i <= n; ++i)\n     {\n-      struct eh_region *region = cfun->eh->region_array[i];\n+      struct eh_region *region;\n+\n+      region = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (region && region->tree_label)\n \tregion->label = DECL_RTL_IF_SET (region->tree_label);\n     }\n@@ -808,9 +816,10 @@ find_exception_handler_labels (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region = cfun->eh->region_array[i];\n+      struct eh_region *region;\n       rtx lab;\n \n+      region = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (! region || region->region_number != i)\n \tcontinue;\n       if (cfun->eh->built_landing_pads)\n@@ -837,8 +846,9 @@ current_function_has_exception_handlers (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region = cfun->eh->region_array[i];\n+      struct eh_region *region;\n \n+      region = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (region\n \t  && region->region_number == i\n \t  && region->type != ERT_THROW)\n@@ -856,6 +866,7 @@ duplicate_eh_region_1 (struct eh_region *o)\n   *n = *o;\n   \n   n->region_number = o->region_number + cfun->eh->last_region_number;\n+  VEC_replace (eh_region, cfun->eh->region_array, n->region_number, n);\n   gcc_assert (!o->aka);\n   \n   return n;\n@@ -916,19 +927,28 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n     return 0;\n   \n   n_array = xcalloc (ifun_last_region_number + 1, sizeof (*n_array));\n-  \n+  VEC_safe_grow (eh_region, gc, cfun->eh->region_array,\n+\t\t cfun->eh->last_region_number + 1 + ifun_last_region_number);\n+\n+  /* We might've created new cfun->eh->region_array so zero out nonexisting region 0.  */\n+  VEC_replace (eh_region, cfun->eh->region_array, 0, 0);\n+\n+  for (i = cfun->eh->last_region_number + 1;\n+       i < cfun->eh->last_region_number + 1 + ifun_last_region_number; i++)\n+    VEC_replace (eh_region, cfun->eh->region_array, i, 0);\n+    \n   /* Search for the containing ERT_TRY region to fix up\n      the prev_try short-cuts for ERT_CLEANUP regions.  */\n   prev_try = NULL;\n   if (outer_region > 0)\n-    for (prev_try = cfun->eh->region_array[outer_region];\n+    for (prev_try = VEC_index (eh_region, cfun->eh->region_array, outer_region);\n          prev_try && prev_try->type != ERT_TRY;\n \t prev_try = prev_try->outer)\n       ;\n \n   for (i = 1; i <= ifun_last_region_number; ++i)\n     {\n-      cur = ifun->eh->region_array[i];\n+      cur = VEC_index (eh_region, ifun->eh->region_array, i);\n       if (!cur || cur->region_number != i)\n \tcontinue;\n       n_array[i] = duplicate_eh_region_1 (cur);\n@@ -942,7 +962,7 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n     }\n   for (i = 1; i <= ifun_last_region_number; ++i)\n     {\n-      cur = ifun->eh->region_array[i];\n+      cur = VEC_index (eh_region, ifun->eh->region_array, i);\n       if (!cur || cur->region_number != i)\n \tcontinue;\n       duplicate_eh_region_2 (cur, n_array, prev_try);\n@@ -952,7 +972,8 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n   gcc_assert (root->outer == NULL);\n   if (outer_region > 0)\n     {\n-      struct eh_region *cur = cfun->eh->region_array[outer_region];\n+      struct eh_region *cur\n+         = VEC_index (eh_region, cfun->eh->region_array, outer_region);\n       struct eh_region *p = cur->inner;\n \n       if (p)\n@@ -985,8 +1006,6 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n   i = cfun->eh->last_region_number;\n   cfun->eh->last_region_number = i + ifun_last_region_number;\n   \n-  collect_eh_region_array ();\n-  \n   return i;\n }\n \f\n@@ -1180,7 +1199,9 @@ assign_filter_values (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *r = cfun->eh->region_array[i];\n+      struct eh_region *r;\n+\n+      r = VEC_index (eh_region, cfun->eh->region_array, i);\n \n       /* Mind we don't process a region more than once.  */\n       if (!r || r->region_number != i)\n@@ -1273,9 +1294,10 @@ build_post_landing_pads (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region = cfun->eh->region_array[i];\n+      struct eh_region *region;\n       rtx seq;\n \n+      region = VEC_index (eh_region, cfun->eh->region_array, i);\n       /* Mind we don't process a region more than once.  */\n       if (!region || region->region_number != i)\n \tcontinue;\n@@ -1392,11 +1414,12 @@ connect_post_landing_pads (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region = cfun->eh->region_array[i];\n+      struct eh_region *region;\n       struct eh_region *outer;\n       rtx seq;\n       rtx barrier;\n \n+      region = VEC_index (eh_region, cfun->eh->region_array, i);\n       /* Mind we don't process a region more than once.  */\n       if (!region || region->region_number != i)\n \tcontinue;\n@@ -1469,12 +1492,13 @@ dw2_build_landing_pads (void)\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n-      struct eh_region *region = cfun->eh->region_array[i];\n+      struct eh_region *region;\n       rtx seq;\n       basic_block bb;\n       bool clobbers_hard_regs = false;\n       edge e;\n \n+      region = VEC_index (eh_region, cfun->eh->region_array, i);\n       /* Mind we don't process a region more than once.  */\n       if (!region || region->region_number != i)\n \tcontinue;\n@@ -1570,7 +1594,7 @@ sjlj_find_directly_reachable_regions (struct sjlj_lp_info *lp_info)\n       if (!note || INTVAL (XEXP (note, 0)) <= 0)\n \tcontinue;\n \n-      region = cfun->eh->region_array[INTVAL (XEXP (note, 0))];\n+      region = VEC_index (eh_region, cfun->eh->region_array, INTVAL (XEXP (note, 0)));\n \n       type_thrown = NULL_TREE;\n       if (region->type == ERT_THROW)\n@@ -1612,7 +1636,8 @@ sjlj_assign_call_site_values (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     if (lp_info[i].directly_reachable)\n       {\n-\tstruct eh_region *r = cfun->eh->region_array[i];\n+\tstruct eh_region *r = VEC_index (eh_region, cfun->eh->region_array, i);\n+\n \tr->landing_pad = dispatch_label;\n \tlp_info[i].action_index = collect_one_action_chain (ar_hash, r);\n \tif (lp_info[i].action_index != -1)\n@@ -1698,7 +1723,7 @@ sjlj_mark_call_sites (struct sjlj_lp_info *lp_info)\n \t  if (INTVAL (XEXP (note, 0)) <= 0)\n \t    continue;\n \n-\t  region = cfun->eh->region_array[INTVAL (XEXP (note, 0))];\n+\t  region = VEC_index (eh_region, cfun->eh->region_array, INTVAL (XEXP (note, 0)));\n \t  this_call_site = lp_info[region->region_number].call_site_index;\n \t}\n \n@@ -1911,13 +1936,15 @@ sjlj_emit_dispatch_table (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n \n       emit_cmp_and_jump_insns (dispatch, GEN_INT (lp_info[i].dispatch_index),\n \t\t\t       EQ, NULL_RTX, TYPE_MODE (integer_type_node), 0,\n-\t\t\t       cfun->eh->region_array[i]->post_landing_pad);\n+\t                       ((struct eh_region *)VEC_index (eh_region, cfun->eh->region_array, i))\n+\t\t\t\t->post_landing_pad);\n     }\n \n   seq = get_insns ();\n   end_sequence ();\n \n-  before = cfun->eh->region_array[first_reachable]->post_landing_pad;\n+  before = (((struct eh_region *)VEC_index (eh_region, cfun->eh->region_array, first_reachable))\n+\t    ->post_landing_pad);\n \n   bb = emit_to_new_bb_before (seq, before);\n   e = make_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n@@ -2069,15 +2096,15 @@ remove_eh_handler (struct eh_region *region)\n      list of alternate numbers by which we are known.  */\n \n   outer = region->outer;\n-  cfun->eh->region_array[region->region_number] = outer;\n+  VEC_replace (eh_region, cfun->eh->region_array, region->region_number, outer);\n   if (region->aka)\n     {\n       unsigned i;\n       bitmap_iterator bi;\n \n       EXECUTE_IF_SET_IN_BITMAP (region->aka, 0, i, bi)\n \t{\n-\t  cfun->eh->region_array[i] = outer;\n+          VEC_replace (eh_region, cfun->eh->region_array, i, outer);\n \t}\n     }\n \n@@ -2211,7 +2238,9 @@ for_each_eh_region (void (*callback) (struct eh_region *))\n   int i, n = cfun->eh->last_region_number;\n   for (i = 1; i <= n; ++i)\n     {\n-      struct eh_region *region = cfun->eh->region_array[i];\n+      struct eh_region *region;\n+\n+      region = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (region)\n \t(*callback) (region);\n     }\n@@ -2461,7 +2490,7 @@ foreach_reachable_handler (int region_number, bool is_resx,\n   info.callback = callback;\n   info.callback_data = callback_data;\n \n-  region = cfun->eh->region_array[region_number];\n+  region = VEC_index (eh_region, cfun->eh->region_array, region_number);\n \n   type_thrown = NULL_TREE;\n   if (is_resx)\n@@ -2550,7 +2579,7 @@ can_throw_internal_1 (int region_number, bool is_resx)\n   struct eh_region *region;\n   tree type_thrown;\n \n-  region = cfun->eh->region_array[region_number];\n+  region = VEC_index (eh_region, cfun->eh->region_array, region_number);\n \n   type_thrown = NULL_TREE;\n   if (is_resx)\n@@ -2610,7 +2639,7 @@ can_throw_external_1 (int region_number, bool is_resx)\n   struct eh_region *region;\n   tree type_thrown;\n \n-  region = cfun->eh->region_array[region_number];\n+  region = VEC_index (eh_region, cfun->eh->region_array, region_number);\n \n   type_thrown = NULL_TREE;\n   if (is_resx)\n@@ -3158,7 +3187,7 @@ convert_to_eh_region_ranges (void)\n \t  {\n \t    if (INTVAL (XEXP (note, 0)) <= 0)\n \t      continue;\n-\t    region = cfun->eh->region_array[INTVAL (XEXP (note, 0))];\n+\t    region = VEC_index (eh_region, cfun->eh->region_array, INTVAL (XEXP (note, 0)));\n \t    this_action = collect_one_action_chain (ar_hash, region);\n \t  }\n \n@@ -3730,10 +3759,10 @@ verify_eh_tree (struct function *fun)\n   if (! i)\n     return;\n   for (j = fun->eh->last_region_number; j > 0; --j)\n-    if (fun->eh->region_array[j])\n+    if ((i = VEC_index (eh_region, cfun->eh->region_array, j)))\n       {\n \tcount++;\n-\tif (fun->eh->region_array[j]->region_number != j)\n+\tif (i->region_number != j)\n \t  {\n \t    error (\"region_array is corrupted for region %i\", i->region_number);\n \t    err = true;\n@@ -3742,7 +3771,7 @@ verify_eh_tree (struct function *fun)\n \n   while (1)\n     {\n-      if (fun->eh->region_array[i->region_number] != i)\n+      if (VEC_index (eh_region, cfun->eh->region_array, i->region_number) != i)\n \t{\n \t  error (\"region_array is corrupted for region %i\", i->region_number);\n \t  err = true;"}]}