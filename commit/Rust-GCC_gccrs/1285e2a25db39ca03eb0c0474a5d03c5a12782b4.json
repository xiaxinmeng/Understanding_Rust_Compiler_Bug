{"sha": "1285e2a25db39ca03eb0c0474a5d03c5a12782b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI4NWUyYTI1ZGIzOWNhMDNlYjBjMDQ3NGE1ZDAzYzVhMTI3ODJiNA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2008-03-20T14:20:49Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2008-03-20T14:20:49Z"}, "message": "re PR libstdc++/35256 (Bad link on http://gcc.gnu.org/onlinedocs/libstdc++/parallel_mode.html)\n\n\n2008-03-19  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/35256\n\t* doc/xml/manual/parallel_mode.xml: Correct configuration documentation.\n\t* doc/html/manual/bk01pt12ch31s04.html: Regenerate.\n\nFrom-SVN: r133378", "tree": {"sha": "f8420e783a074cdd0190903ad3f7a9c2aa2df111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8420e783a074cdd0190903ad3f7a9c2aa2df111"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1285e2a25db39ca03eb0c0474a5d03c5a12782b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1285e2a25db39ca03eb0c0474a5d03c5a12782b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1285e2a25db39ca03eb0c0474a5d03c5a12782b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1285e2a25db39ca03eb0c0474a5d03c5a12782b4/comments", "author": null, "committer": null, "parents": [{"sha": "6fd85d214441ab1760f2d650399433fbcb7681d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fd85d214441ab1760f2d650399433fbcb7681d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fd85d214441ab1760f2d650399433fbcb7681d2"}], "stats": {"total": 435, "additions": 334, "deletions": 101}, "files": [{"sha": "d794b80684b75ab16575a8b73aa3ac2862eb4891", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1285e2a25db39ca03eb0c0474a5d03c5a12782b4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1285e2a25db39ca03eb0c0474a5d03c5a12782b4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1285e2a25db39ca03eb0c0474a5d03c5a12782b4", "patch": "@@ -1,3 +1,9 @@\n+2008-03-19  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/35256\n+\t* doc/xml/manual/parallel_mode.xml: Correct configuration documentation.\n+\t* doc/html/manual/bk01pt12ch31s04.html: Regenerate.\n+\n 2008-03-18  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* configure.ac (libtool_VERSION): To 6:11:0."}, {"sha": "3db7d912e6317d98d689928a0d3a451204c38c81", "filename": "libstdc++-v3/doc/html/manual/bk01pt12ch31s04.html", "status": "modified", "additions": 114, "deletions": 25, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1285e2a25db39ca03eb0c0474a5d03c5a12782b4/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fbk01pt12ch31s04.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1285e2a25db39ca03eb0c0474a5d03c5a12782b4/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fbk01pt12ch31s04.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Fmanual%2Fbk01pt12ch31s04.html?ref=1285e2a25db39ca03eb0c0474a5d03c5a12782b4", "patch": "@@ -1,9 +1,10 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n <html xmlns=\"http://www.w3.org/1999/xhtml\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /><title>Design</title><meta name=\"generator\" content=\"DocBook XSL Stylesheets V1.73.2\" /><meta name=\"keywords\" content=\"&#10;      C++&#10;    , &#10;      library&#10;    , &#10;      parallel&#10;    \" /><meta name=\"keywords\" content=\"&#10;      ISO C++&#10;    , &#10;      library&#10;    \" /><link rel=\"start\" href=\"../spine.html\" title=\"The GNU C++ Library Documentation\" /><link rel=\"up\" href=\"parallel_mode.html\" title=\"Chapter\u00a031.\u00a0Parallel Mode\" /><link rel=\"prev\" href=\"bk01pt12ch31s03.html\" title=\"Using\" /><link rel=\"next\" href=\"bk01pt12ch31s05.html\" title=\"Testing\" /></head><body><div class=\"navheader\"><table width=\"100%\" summary=\"Navigation header\"><tr><th colspan=\"3\" align=\"center\">Design</th></tr><tr><td width=\"20%\" align=\"left\"><a accesskey=\"p\" href=\"bk01pt12ch31s03.html\">Prev</a>\u00a0</td><th width=\"60%\" align=\"center\">Chapter\u00a031.\u00a0Parallel Mode</th><td width=\"20%\" align=\"right\">\u00a0<a accesskey=\"n\" href=\"bk01pt12ch31s05.html\">Next</a></td></tr></table><hr /></div><div class=\"sect1\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h2 class=\"title\" style=\"clear: both\"><a id=\"manual.ext.parallel_mode.design\"></a>Design</h2></div></div></div><p>\n-  </p><div class=\"sect2\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"manual.ext.parallel_mode.design.intro\"></a>Interface Basics</h3></div></div></div><p>All parallel algorithms are intended to have signatures that are\n+  </p><div class=\"sect2\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"manual.ext.parallel_mode.design.intro\"></a>Interface Basics</h3></div></div></div><p>\n+All parallel algorithms are intended to have signatures that are\n equivalent to the ISO C++ algorithms replaced. For instance, the\n-<code class=\"code\">std::adjacent_find</code> function is declared as:\n+<code class=\"function\">std::adjacent_find</code> function is declared as:\n </p><pre class=\"programlisting\">\n namespace std\n {\n@@ -57,36 +58,124 @@\n ISO C++ signature to the correct parallel version. Also, some of the\n algorithms do not have support for run-time conditions, so the last\n overload is therefore missing.\n-</p></div><div class=\"sect2\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"manual.ext.parallel_mode.design.tuning\"></a>Configuration and Tuning</h3></div></div></div><p> Some algorithm variants can be enabled/disabled/selected at compile-time.\n-See <a class=\"ulink\" href=\"latest-doxygen/compiletime__settings_8h.html\" target=\"_top\">\n-<code class=\"code\">&lt;compiletime_settings.h&gt;</code></a> and\n-See <a class=\"ulink\" href=\"latest-doxygen/compiletime__settings_8h.html\" target=\"_top\">\n-<code class=\"code\">&lt;features.h&gt;</code></a> for details.\n+</p></div><div class=\"sect2\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"manual.ext.parallel_mode.design.tuning\"></a>Configuration and Tuning</h3></div></div></div><div class=\"sect3\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h4 class=\"title\"><a id=\"parallel_mode.design.tuning.omp\"></a>Setting up the OpenMP Environment</h4></div></div></div><p>\n+Several aspects of the overall runtime environment can be manipulated\n+by standard OpenMP function calls.\n </p><p>\n-To specify the number of threads to be used for an algorithm,\n-use <code class=\"code\">omp_set_num_threads</code>.\n-To force a function to execute sequentially,\n-even though parallelism is switched on in general,\n-add <code class=\"code\">__gnu_parallel::sequential_tag()</code>\n-to the end of the argument list.\n+To specify the number of threads to be used for an algorithm, use the\n+function <code class=\"function\">omp_set_num_threads</code>. An example:\n+</p><pre class=\"programlisting\">\n+#include &lt;stdlib.h&gt;\n+#include &lt;omp.h&gt;\n+\n+int main()\n+{\n+  // Explicitly set number of threads.\n+  const int threads_wanted = 20;\n+  omp_set_dynamic(false);\n+  omp_set_num_threads(threads_wanted);\n+  if (omp_get_num_threads() != threads_wanted)\n+    abort();\n+\n+  // Do work.\n+\n+  return 0;\n+}\n+</pre><p>\n+Other parts of the runtime environment able to be manipulated include\n+nested parallelism (<code class=\"function\">omp_set_nested</code>), schedule kind\n+(<code class=\"function\">omp_set_schedule</code>), and others. See the OpenMP\n+documentation for more information.\n+</p></div><div class=\"sect3\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h4 class=\"title\"><a id=\"parallel_mode.design.tuning.compile\"></a>Compile Time Switches</h4></div></div></div><p>\n+To force an algorithm to execute sequentially, even though parallelism\n+is switched on in general via the macro <code class=\"constant\">_GLIBCXX_PARALLEL</code>,\n+add <code class=\"classname\">__gnu_parallel::sequential_tag()</code> to the end\n+of the algorithm's argument list, or explicitly qualify the algorithm\n+with the <code class=\"code\">__gnu_parallel::</code> namespace.\n+</p><p>\n+Like so:\n+</p><pre class=\"programlisting\">\n+std::sort(v.begin(), v.end(), __gnu_parallel::sequential_tag());\n+</pre><p>\n+or\n+</p><pre class=\"programlisting\">\n+__gnu_serial::sort(v.begin(), v.end());\n+</pre><p> \n+In addition, some parallel algorithm variants can be enabled/disabled/selected \n+at compile-time.\n+</p><p>\n+See <a class=\"ulink\" href=\"http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00446.html\" target=\"_top\"><code class=\"filename\">compiletime_settings.h</code></a> and\n+See <a class=\"ulink\" href=\"http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00505.html\" target=\"_top\"><code class=\"filename\">features.h</code></a> for details.\n+</p></div><div class=\"sect3\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h4 class=\"title\"><a id=\"parallel_mode.design.tuning.settings\"></a>Run Time Settings and Defaults</h4></div></div></div><p>\n+The default parallization strategy, the choice of specific algorithm\n+strategy, the minimum threshold limits for individual parallel\n+algorithms, and aspects of the underlying hardware can be specified as\n+desired via manipulation\n+of <code class=\"classname\">__gnu_parallel::_Settings</code> member data.\n </p><p>\n-Parallelism always incurs some overhead. Thus, it is not\n-helpful to parallelize operations on very small sets of data.\n-There are measures to avoid parallelizing stuff that is not worth it.\n-For each algorithm, a minimum problem size can be stated,\n-usually using the variable\n-<code class=\"code\">__gnu_parallel::Settings::[algorithm]_minimal_n</code>.\n-Please see <a class=\"ulink\" href=\"latest-doxygen/settings_8h.html\" target=\"_top\">\n-<code class=\"code\">&lt;settings.h&gt;</code></a> for details.</p></div><div class=\"sect2\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"manual.ext.parallel_mode.design.impl\"></a>Implementation Namespaces</h3></div></div></div><p> One namespace contain versions of code that are explicitly sequential:\n+First off, the choice of parallelization strategy: serial, parallel,\n+or implementation-deduced. This corresponds\n+to <code class=\"code\">__gnu_parallel::_Settings::algorithm_strategy</code> and is a\n+value of enum <span class=\"type\">__gnu_parallel::_AlgorithmStrategy</span>\n+type. Choices\n+include: <span class=\"type\">heuristic</span>, <span class=\"type\">force_sequential</span>,\n+and <span class=\"type\">force_parallel</span>. The default is\n+implementation-deduced, ie <span class=\"type\">heuristic</span>.\n+</p><p>\n+Next, the sub-choices for algorithm implementation. Specific\n+algorithms like <code class=\"function\">find</code> or <code class=\"function\">sort</code>\n+can be implemented in multiple ways: when this is the case,\n+a <code class=\"classname\">__gnu_parallel::_Settings</code> member exists to\n+pick the default strategy. For\n+example, <code class=\"code\">__gnu_parallel::_Settings::sort_algorithm</code> can\n+have any values of\n+enum <span class=\"type\">__gnu_parallel::_SortAlgorithm</span>: <span class=\"type\">MWMS</span>, <span class=\"type\">QS</span>,\n+or <span class=\"type\">QS_BALANCED</span>.\n+</p><p>\n+Likewise for setting the minimal threshold for algorithm\n+paralleization.  Parallelism always incurs some overhead. Thus, it is\n+not helpful to parallelize operations on very small sets of\n+data. Because of this, measures are taken to avoid parallelizing below\n+a certain, pre-determined threshold. For each algorithm, a minimum\n+problem size is encoded as a variable in the\n+active <code class=\"classname\">__gnu_parallel::_Settings</code> object.  This\n+threshold variable follows the following naming scheme:\n+<code class=\"code\">__gnu_parallel::_Settings::[algorithm]_minimal_n</code>.  So,\n+for <code class=\"function\">fill</code>, the threshold variable\n+is <code class=\"code\">__gnu_parallel::_Settings::fill_minimal_n</code>\n+</p><p>\n+Finally, hardware details like L1/L2 cache size can be hardwired\n+via <code class=\"code\">__gnu_parallel::_Settings::L1_cache_size</code> and friends.\n+</p><p>\n+All these configuration variables can be changed by the user, if\n+desired.  Please\n+see <a class=\"ulink\" href=\"http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00640.html\" target=\"_top\"><code class=\"filename\">settings.h</code></a>\n+for complete details.\n+</p><p>\n+A small example of tuning the default:\n+</p><pre class=\"programlisting\">\n+#include &lt;parallel/algorithm&gt;\n+#include &lt;parallel/settings.h&gt;\n+\n+int main()\n+{\n+  __gnu_parallel::_Settings s;\n+  s.algorithm_strategy = __gnu_parallel::force_parallel;\n+  __gnu_parallel::_Settings::set(s);\n+\n+  // Do work... all algorithms will be parallelized, always.\n+\n+  return 0;\n+}\n+</pre></div></div><div class=\"sect2\" lang=\"en\" xml:lang=\"en\"><div class=\"titlepage\"><div><div><h3 class=\"title\"><a id=\"manual.ext.parallel_mode.design.impl\"></a>Implementation Namespaces</h3></div></div></div><p> One namespace contain versions of code that are always\n+explicitly sequential:\n <code class=\"code\">__gnu_serial</code>.\n </p><p> Two namespaces contain the parallel mode:\n <code class=\"code\">std::__parallel</code> and <code class=\"code\">__gnu_parallel</code>. \n </p><p> Parallel implementations of standard components, including\n template helpers to select parallelism, are defined in <code class=\"code\">namespace\n-std::__parallel</code>. For instance, <code class=\"code\">std::transform</code> from\n-&lt;algorithm&gt; has a parallel counterpart in\n-<code class=\"code\">std::__parallel::transform</code> from\n-&lt;parallel/algorithm&gt;. In addition, these parallel\n+std::__parallel</code>. For instance, <code class=\"function\">std::transform</code> from <code class=\"filename\">algorithm</code> has a parallel counterpart in\n+<code class=\"function\">std::__parallel::transform</code> from <code class=\"filename\">parallel/algorithm</code>. In addition, these parallel\n implementations are injected into <code class=\"code\">namespace\n __gnu_parallel</code> with using declarations.\n </p><p> Support and general infrastructure is in <code class=\"code\">namespace"}, {"sha": "0bcbbcab04d76e8e8a6646eeaca684d47c525070", "filename": "libstdc++-v3/doc/xml/manual/parallel_mode.xml", "status": "modified", "additions": 214, "deletions": 76, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1285e2a25db39ca03eb0c0474a5d03c5a12782b4/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fparallel_mode.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1285e2a25db39ca03eb0c0474a5d03c5a12782b4/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fparallel_mode.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fparallel_mode.xml?ref=1285e2a25db39ca03eb0c0474a5d03c5a12782b4", "patch": "@@ -28,7 +28,7 @@ implementation of many algorithms the C++ Standard Library.\n \n <para>\n Several of the standard algorithms, for instance\n-<code>std::sort</code>, are made parallel using OpenMP\n+<function>std::sort</function>, are made parallel using OpenMP\n annotations. These parallel mode constructs and can be invoked by\n explicit source declaration or by compiling existing sources with a\n specific compiler flag.\n@@ -39,52 +39,52 @@ specific compiler flag.\n   <title>Intro</title>\n \n <para>The following library components in the include\n-<code>&lt;numeric&gt;</code> are included in the parallel mode:</para>\n+<filename class=\"headerfile\">numeric</filename> are included in the parallel mode:</para>\n <itemizedlist>\n-  <listitem><para><code>std::accumulate</code></para></listitem>\n-  <listitem><para><code>std::adjacent_difference</code></para></listitem>\n-  <listitem><para><code>std::inner_product</code></para></listitem>\n-  <listitem><para><code>std::partial_sum</code></para></listitem>\n+  <listitem><para><function>std::accumulate</function></para></listitem>\n+  <listitem><para><function>std::adjacent_difference</function></para></listitem>\n+  <listitem><para><function>std::inner_product</function></para></listitem>\n+  <listitem><para><function>std::partial_sum</function></para></listitem>\n </itemizedlist>\n \n <para>The following library components in the include\n-<code>&lt;algorithm&gt;</code> are included in the parallel mode:</para>\n+<filename class=\"headerfile\">algorithm</filename> are included in the parallel mode:</para>\n <itemizedlist>\n-  <listitem><para><code>std::adjacent_find</code></para></listitem>\n-  <listitem><para><code>std::count</code></para></listitem>\n-  <listitem><para><code>std::count_if</code></para></listitem>\n-  <listitem><para><code>std::equal</code></para></listitem>\n-  <listitem><para><code>std::find</code></para></listitem>\n-  <listitem><para><code>std::find_if</code></para></listitem>\n-  <listitem><para><code>std::find_first_of</code></para></listitem>\n-  <listitem><para><code>std::for_each</code></para></listitem>\n-  <listitem><para><code>std::generate</code></para></listitem>\n-  <listitem><para><code>std::generate_n</code></para></listitem>\n-  <listitem><para><code>std::lexicographical_compare</code></para></listitem>\n-  <listitem><para><code>std::mismatch</code></para></listitem>\n-  <listitem><para><code>std::search</code></para></listitem>\n-  <listitem><para><code>std::search_n</code></para></listitem>\n-  <listitem><para><code>std::transform</code></para></listitem>\n-  <listitem><para><code>std::replace</code></para></listitem>\n-  <listitem><para><code>std::replace_if</code></para></listitem>\n-  <listitem><para><code>std::max_element</code></para></listitem>\n-  <listitem><para><code>std::merge</code></para></listitem>\n-  <listitem><para><code>std::min_element</code></para></listitem>\n-  <listitem><para><code>std::nth_element</code></para></listitem>\n-  <listitem><para><code>std::partial_sort</code></para></listitem>\n-  <listitem><para><code>std::partition</code></para></listitem>\n-  <listitem><para><code>std::random_shuffle</code></para></listitem>\n-  <listitem><para><code>std::set_union</code></para></listitem>\n-  <listitem><para><code>std::set_intersection</code></para></listitem>\n-  <listitem><para><code>std::set_symmetric_difference</code></para></listitem>\n-  <listitem><para><code>std::set_difference</code></para></listitem>\n-  <listitem><para><code>std::sort</code></para></listitem>\n-  <listitem><para><code>std::stable_sort</code></para></listitem>\n-  <listitem><para><code>std::unique_copy</code></para></listitem>\n+  <listitem><para><function>std::adjacent_find</function></para></listitem>\n+  <listitem><para><function>std::count</function></para></listitem>\n+  <listitem><para><function>std::count_if</function></para></listitem>\n+  <listitem><para><function>std::equal</function></para></listitem>\n+  <listitem><para><function>std::find</function></para></listitem>\n+  <listitem><para><function>std::find_if</function></para></listitem>\n+  <listitem><para><function>std::find_first_of</function></para></listitem>\n+  <listitem><para><function>std::for_each</function></para></listitem>\n+  <listitem><para><function>std::generate</function></para></listitem>\n+  <listitem><para><function>std::generate_n</function></para></listitem>\n+  <listitem><para><function>std::lexicographical_compare</function></para></listitem>\n+  <listitem><para><function>std::mismatch</function></para></listitem>\n+  <listitem><para><function>std::search</function></para></listitem>\n+  <listitem><para><function>std::search_n</function></para></listitem>\n+  <listitem><para><function>std::transform</function></para></listitem>\n+  <listitem><para><function>std::replace</function></para></listitem>\n+  <listitem><para><function>std::replace_if</function></para></listitem>\n+  <listitem><para><function>std::max_element</function></para></listitem>\n+  <listitem><para><function>std::merge</function></para></listitem>\n+  <listitem><para><function>std::min_element</function></para></listitem>\n+  <listitem><para><function>std::nth_element</function></para></listitem>\n+  <listitem><para><function>std::partial_sort</function></para></listitem>\n+  <listitem><para><function>std::partition</function></para></listitem>\n+  <listitem><para><function>std::random_shuffle</function></para></listitem>\n+  <listitem><para><function>std::set_union</function></para></listitem>\n+  <listitem><para><function>std::set_intersection</function></para></listitem>\n+  <listitem><para><function>std::set_symmetric_difference</function></para></listitem>\n+  <listitem><para><function>std::set_difference</function></para></listitem>\n+  <listitem><para><function>std::sort</function></para></listitem>\n+  <listitem><para><function>std::stable_sort</function></para></listitem>\n+  <listitem><para><function>std::unique_copy</function></para></listitem>\n </itemizedlist>\n \n <para>The following library components in the includes\n-<code>&lt;set&gt;</code> and <code>&lt;map&gt;</code> are included in the parallel mode:</para>\n+<filename class=\"headerfile\">set</filename> and <filename class=\"headerfile\">map</filename> are included in the parallel mode:</para>\n <itemizedlist>\n   <listitem><para><code>std::(multi_)map/set&lt;T&gt;::(multi_)map/set(Iterator begin, Iterator end)</code> (bulk construction)</para></listitem>\n   <listitem><para><code>std::(multi_)map/set&lt;T&gt;::insert(Iterator begin, Iterator end)</code> (bulk insertion)</para></listitem>\n@@ -113,23 +113,25 @@ It might work with other compilers, though.</para>\n <sect2 id=\"parallel_mode.using.parallel_mode\" xreflabel=\"using.parallel_mode\">\n   <title>Using Parallel Mode</title>\n \n-<para>To use the libstdc++ parallel mode, compile your application with\n-  the compiler flag <code>-D_GLIBCXX_PARALLEL -fopenmp</code>. This\n+<para>\n+  To use the libstdc++ parallel mode, compile your application with\n+  the compiler flag <constant>-D_GLIBCXX_PARALLEL -fopenmp</constant>. This\n   will link in <code>libgomp</code>, the GNU OpenMP <ulink url=\"http://gcc.gnu.org/onlinedocs/libgomp\">implementation</ulink>,\n   whose presence is mandatory. In addition, hardware capable of atomic\n   operations is mandatory. Actually activating these atomic\n   operations may require explicit compiler flags on some targets\n-  (like sparc and x86), such as <code>-march=i686</code>,\n-  <code>-march=native</code> or <code>-mcpu=v9</code>.\n+  (like sparc and x86), such as <literal>-march=i686</literal>,\n+  <literal>-march=native</literal> or <literal>-mcpu=v9</literal>.\n </para>\n \n-<para>Note that the <code>_GLIBCXX_PARALLEL</code> define may change the\n+<para>Note that the <constant>_GLIBCXX_PARALLEL</constant> define may change the\n   sizes and behavior of standard class templates such as\n-  <code>std::search</code>, and therefore one can only link code\n+  <function>std::search</function>, and therefore one can only link code\n   compiled with parallel mode and code compiled without parallel mode\n   if no instantiation of a container is passed between the two\n   translation units. Parallel mode functionality has distinct linkage,\n-  and cannot be confused with normal mode symbols.</para>\n+  and cannot be confused with normal mode symbols.\n+</para>\n </sect2>\n \n <sect2 id=\"manual.ext.parallel_mode.usings\" xreflabel=\"using.specific\">\n@@ -420,9 +422,10 @@ It might work with other compilers, though.</para>\n   <title>Interface Basics</title>\n \n \n-<para>All parallel algorithms are intended to have signatures that are\n+<para>\n+All parallel algorithms are intended to have signatures that are\n equivalent to the ISO C++ algorithms replaced. For instance, the\n-<code>std::adjacent_find</code> function is declared as:\n+<function>std::adjacent_find</function> function is declared as:\n </para>\n <programlisting>\n namespace std\n@@ -506,39 +509,176 @@ overload is therefore missing.\n <sect2 id=\"manual.ext.parallel_mode.design.tuning\" xreflabel=\"Tuning\">\n   <title>Configuration and Tuning</title>\n \n-<para> Some algorithm variants can be enabled/disabled/selected at compile-time.\n-See <ulink url=\"latest-doxygen/compiletime__settings_8h.html\">\n-<code>&lt;compiletime_settings.h&gt;</code></ulink> and\n-See <ulink url=\"latest-doxygen/compiletime__settings_8h.html\">\n-<code>&lt;features.h&gt;</code></ulink> for details.\n+\n+<sect3 id=\"parallel_mode.design.tuning.omp\" xreflabel=\"OpenMP Environment\">\n+  <title>Setting up the OpenMP Environment</title>\n+\n+<para>\n+Several aspects of the overall runtime environment can be manipulated\n+by standard OpenMP function calls.\n+</para>\n+\n+<para>\n+To specify the number of threads to be used for an algorithm, use the\n+function <function>omp_set_num_threads</function>. An example:\n+</para>\n+\n+<programlisting>\n+#include &lt;stdlib.h&gt;\n+#include &lt;omp.h&gt;\n+\n+int main()\n+{\n+  // Explicitly set number of threads.\n+  const int threads_wanted = 20;\n+  omp_set_dynamic(false);\n+  omp_set_num_threads(threads_wanted);\n+  if (omp_get_num_threads() != threads_wanted)\n+    abort();\n+\n+  // Do work.\n+\n+  return 0;\n+}\n+</programlisting>\n+\n+<para>\n+Other parts of the runtime environment able to be manipulated include\n+nested parallelism (<function>omp_set_nested</function>), schedule kind\n+(<function>omp_set_schedule</function>), and others. See the OpenMP\n+documentation for more information.\n+</para>\n+\n+</sect3>\n+\n+<sect3 id=\"parallel_mode.design.tuning.compile\" xreflabel=\"Compile Switches\">\n+  <title>Compile Time Switches</title>\n+\n+<para>\n+To force an algorithm to execute sequentially, even though parallelism\n+is switched on in general via the macro <constant>_GLIBCXX_PARALLEL</constant>,\n+add <classname>__gnu_parallel::sequential_tag()</classname> to the end\n+of the algorithm's argument list, or explicitly qualify the algorithm\n+with the <code>__gnu_parallel::</code> namespace.\n+</para>\n+\n+<para>\n+Like so:\n+</para>\n+\n+<programlisting>\n+std::sort(v.begin(), v.end(), __gnu_parallel::sequential_tag());\n+</programlisting>\n+\n+<para>\n+or\n+</para>\n+\n+<programlisting>\n+__gnu_serial::sort(v.begin(), v.end());\n+</programlisting>\n+\n+<para> \n+In addition, some parallel algorithm variants can be enabled/disabled/selected \n+at compile-time.\n+</para>\n+\n+<para>\n+See <ulink url=\"http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00446.html\"><filename class=\"headerfile\">compiletime_settings.h</filename></ulink> and\n+See <ulink url=\"http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00505.html\"><filename class=\"headerfile\">features.h</filename></ulink> for details.\n+</para>\n+</sect3>\n+\n+<sect3 id=\"parallel_mode.design.tuning.settings\" xreflabel=\"_Settings\">\n+  <title>Run Time Settings and Defaults</title>\n+\n+<para>\n+The default parallization strategy, the choice of specific algorithm\n+strategy, the minimum threshold limits for individual parallel\n+algorithms, and aspects of the underlying hardware can be specified as\n+desired via manipulation\n+of <classname>__gnu_parallel::_Settings</classname> member data.\n+</para>\n+\n+<para>\n+First off, the choice of parallelization strategy: serial, parallel,\n+or implementation-deduced. This corresponds\n+to <code>__gnu_parallel::_Settings::algorithm_strategy</code> and is a\n+value of enum <type>__gnu_parallel::_AlgorithmStrategy</type>\n+type. Choices\n+include: <type>heuristic</type>, <type>force_sequential</type>,\n+and <type>force_parallel</type>. The default is\n+implementation-deduced, ie <type>heuristic</type>.\n+</para>\n+\n+\n+<para>\n+Next, the sub-choices for algorithm implementation. Specific\n+algorithms like <function>find</function> or <function>sort</function>\n+can be implemented in multiple ways: when this is the case,\n+a <classname>__gnu_parallel::_Settings</classname> member exists to\n+pick the default strategy. For\n+example, <code>__gnu_parallel::_Settings::sort_algorithm</code> can\n+have any values of\n+enum <type>__gnu_parallel::_SortAlgorithm</type>: <type>MWMS</type>, <type>QS</type>,\n+or <type>QS_BALANCED</type>.\n+</para>\n+\n+<para>\n+Likewise for setting the minimal threshold for algorithm\n+paralleization.  Parallelism always incurs some overhead. Thus, it is\n+not helpful to parallelize operations on very small sets of\n+data. Because of this, measures are taken to avoid parallelizing below\n+a certain, pre-determined threshold. For each algorithm, a minimum\n+problem size is encoded as a variable in the\n+active <classname>__gnu_parallel::_Settings</classname> object.  This\n+threshold variable follows the following naming scheme:\n+<code>__gnu_parallel::_Settings::[algorithm]_minimal_n</code>.  So,\n+for <function>fill</function>, the threshold variable\n+is <code>__gnu_parallel::_Settings::fill_minimal_n</code>\n </para>\n \n <para>\n-To specify the number of threads to be used for an algorithm,\n-use <code>omp_set_num_threads</code>.\n-To force a function to execute sequentially,\n-even though parallelism is switched on in general,\n-add <code>__gnu_parallel::sequential_tag()</code>\n-to the end of the argument list.\n+Finally, hardware details like L1/L2 cache size can be hardwired\n+via <code>__gnu_parallel::_Settings::L1_cache_size</code> and friends.\n </para>\n \n <para>\n-Parallelism always incurs some overhead. Thus, it is not\n-helpful to parallelize operations on very small sets of data.\n-There are measures to avoid parallelizing stuff that is not worth it.\n-For each algorithm, a minimum problem size can be stated,\n-usually using the variable\n-<code>__gnu_parallel::Settings::[algorithm]_minimal_n</code>.\n-Please see <ulink url=\"latest-doxygen/settings_8h.html\">\n-<code>&lt;settings.h&gt;</code></ulink> for details.</para>\n+All these configuration variables can be changed by the user, if\n+desired.  Please\n+see <ulink url=\"http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00640.html\"><filename class=\"headerfile\">settings.h</filename></ulink>\n+for complete details.\n+</para>\n+\n+<para>\n+A small example of tuning the default:\n+</para>\n+\n+<programlisting>\n+#include &lt;parallel/algorithm&gt;\n+#include &lt;parallel/settings.h&gt;\n+\n+int main()\n+{\n+  __gnu_parallel::_Settings s;\n+  s.algorithm_strategy = __gnu_parallel::force_parallel;\n+  __gnu_parallel::_Settings::set(s);\n+\n+  // Do work... all algorithms will be parallelized, always.\n+\n+  return 0;\n+}\n+</programlisting>\n \n+</sect3>\n \n </sect2>\n \n <sect2 id=\"manual.ext.parallel_mode.design.impl\" xreflabel=\"Impl\">\n   <title>Implementation Namespaces</title>\n \n-<para> One namespace contain versions of code that are explicitly sequential:\n+<para> One namespace contain versions of code that are always\n+explicitly sequential:\n <code>__gnu_serial</code>.\n </para>\n \n@@ -548,10 +688,8 @@ Please see <ulink url=\"latest-doxygen/settings_8h.html\">\n \n <para> Parallel implementations of standard components, including\n template helpers to select parallelism, are defined in <code>namespace\n-std::__parallel</code>. For instance, <code>std::transform</code> from\n-&lt;algorithm&gt; has a parallel counterpart in\n-<code>std::__parallel::transform</code> from\n-&lt;parallel/algorithm&gt;. In addition, these parallel\n+std::__parallel</code>. For instance, <function>std::transform</function> from <filename class=\"headerfile\">algorithm</filename> has a parallel counterpart in\n+<function>std::__parallel::transform</function> from <filename class=\"headerfile\">parallel/algorithm</filename>. In addition, these parallel\n implementations are injected into <code>namespace\n __gnu_parallel</code> with using declarations.\n </para>\n@@ -588,21 +726,21 @@ the generated source documentation.\n   \n   <para>\n     The log and summary files for conformance testing are in the\n-    <code>testsuite/parallel</code> directory.\n+    <filename class=\"directory\">testsuite/parallel</filename> directory.\n   </para>\n \n   <para> \n     To run the performance tests with the parallel mode active,\n   </para>\n \n   <screen>\n-  <userinput>check-performance-parallel</userinput>\n+  <userinput>make check-performance-parallel</userinput>\n   </screen>\n \n   <para>\n     The result file for performance testing are in the\n-    <code>testsuite</code> directory, in the file\n-    <code>libstdc++_performance.sum</code>. In addition, the\n+    <filename class=\"directory\">testsuite</filename> directory, in the file\n+    <filename>libstdc++_performance.sum</filename>. In addition, the\n     policy-based containers have their own visualizations, which have\n     additional software dependencies than the usual bare-boned text\n     file, and can be generated by using the <code>make"}]}