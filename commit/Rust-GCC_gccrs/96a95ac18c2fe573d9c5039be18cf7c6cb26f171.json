{"sha": "96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZhOTVhYzE4YzJmZTU3M2Q5YzUwMzliZTE4Y2Y3YzZjYjI2ZjE3MQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2017-12-12T02:16:07Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2017-12-12T02:16:07Z"}, "message": "[SFN] introduce statement frontier notes, still disabled\n\nThis patch completes the infrastructure for the introduction of\nstatement frontiers in C-family languages.\n\nIt brings in all the code remaining code needed to introduce and\ntransform begin stmt trees, gimple stmts, insns and notes, and\nultimately use them to generate the is_stmt column in DWARF2+ line\nnumber tables/programs, however none of it is activated: the option\nthat would do so will be introduced in a subsequent patch.\n\nThis patch depends on an earlier patch with not-quite-boilerplate\nchanges towards SFN.\n\nfor  gcc/c-family/ChangeLog\n\n\t* c-semantics.c (pop_stmt_list): Move begin stmt marker into\n\tsubsequent statement list.\n\nfor  gcc/c/ChangeLog\n\n\t* c-objc-common.h (LANG_HOOKS_EMITS_BEGIN_STMT): Redefine as true.\n\t* c-parser.c (add_debug_begin_stmt): New.\n\t(c_parser_declaration_or_fndef): Call it.\n\t(c_parser_compound_statement_nostart): Likewise.\n\t(c_parser_statement_after_labels): Likewise.\n\t* c-typeck (c_finish_stmt_expr): Skip begin stmts markers.\n\nfor  gcc/cp/ChangeLog\n\n\t* constexpr.c (check_constexpr_ctor_body_1): Skip begin stmt\n\tmarkers.\n\t(constexpr_fn_retval): Likewise.\n\t(potential_constant_expression_1): Likewise.\n\t(cxx_eval_statement_list): Check that a begin stmt marker is\n\tnot used as the value of a statement list.\n\t(cxx_eval_constant_expression): Return begin stmt markers\n\tunchanged.\n\t* cp-array-notation.c (stmt_location): New.\n\t(cp_expand_cond_array_notations): Use it.\n\t* cp-objcp-common.h (LANG_HOOKS_EMITS_BEGIN_STMT): Redefine as true.\n\t* parser.c (add_debug_begin_stmt): New.\n\t(cp_parser_statement): Call it.\n\t* pt.c (tsubst_copy): Handle begin stmt markers.\n\nfor  gcc/ChangeLog\n\n\t* cfgexpand.c (expand_gimple_basic_block): Handle begin stmt\n\tmarkers.  Integrate source bind into debug stmt expand loop.\n\t(pass_expand::execute): Check debug marker limit.  Avoid deep\n\tTER and expand debug locations for debug bind insns only.\n\t* cse.c (insn_live_p): Keep nonbind markers and debug bindings\n\tfollowed by them.\n\t* df-scan.c (df_insn_delete): Accept out-of-block debug insn.\n\t* final.c (reemit_insn_block_notes): Take current block from\n\tnonbind markers.  Declare note where it's first set.\n\t(final_scan_insn): Handle begin stmt notes.  Emit is_stmt according to\n\tbegin stmt markers if enabled.\n\t(notice_source_line): Handle nonbind markers.  Fail if their\n\tlocation is unknown or that of builtins.\n\t(rest_of_handle_final): Convert begin stmt markers to notes if\n\tvar-tracking didn't run.\n\t(rest_of_clean_state): Skip begin stmt markers.\n\t* gimple-pretty-print.c (dump_gimple_debug): Handle begin stmt\n\tmarkers.\n\t* function.c (allocate_struct_function): Set begin_stmt_markers.\n\t* function.h (struct function): Add debug_marker_count counter\n\tand debug_nonbind_markers flag.\n\t* gimple-iterator.c (gsi_remove): Adjust debug_marker_count.\n\t* gimple-low.c (lower_function_body): Adjust\n\tdebug_nonbind_markers.\n\t(lower_stmt): Drop or skip gimple debug stmts.\n\t(lower_try_catch): Skip debug stmts.\n\t* gimple.c (gimple_build_debug_begin_stmt): New.\n\t(gimple_copy): Increment debug_marker_count if copying one.\n\t* gimple.h (gimple_build_debug_begin_stmt): Declare.\n\t* gimplify.c (rexpr_location): New.\n\t(rexpr_has_location): New.\n\t(warn_switch_unreachable_r): Handle gimple debug stmts.\n\t(shortcut_cond_r): Call expr_location.\n\t(find_goto): New.\n\t(find_goto_label): New.\n\t(shortcut_cond_expr): Call expr_has_location, expr_location, and\n\tfind_goto_label.\n\t(gimplify_cond_expr): Call find_goto_label, expr_has_location, and\n\texpr_location.\n\t(gimplify_expr): Handle begin stmt markers.  Reject debug expr decls.\n\t* langhooks-def.h (LANG_HOOKS_EMITS_BEGIN_STMT): New.  Add to...\n\t(LANG_HOOKS_INITIALIZER): ... this.\n\t* langhooks.h (struct lang_hooks): Add emits_begin_stmt.\n\t* lra-contraints.c (inherit_reload_reg): Tolerate between-blocks\n\tdebug insns.\n\t(update_ebb_live_info): Skip debug insn markers.\n\t* lra.c (debug_insn_static_data): Rename to...\n\t(debug_bind_static_data): ... this.\n\t(debug_marker_static_data): New.\n\t(lra_set_insn_recog_data): Select one of the above depending\n\ton debug insn kind.\n\t(lra_update_isn_regno_info): Don't assume debug insns have\n\tfreqs.\n\t(push_insns): Skip debug insns.\n\t* lto-streamer-in.c (input_function): Drop debug stmts\n\tdepending on active options.  Adjust debug_nonbind_markers.\n\t* params.def (PARAM_MAX_DEBUG_MARKER_COUNT): New.\n\t* print-rtl.c (rtx_writer::print_rtx_operand_code_0): Handle\n\tbegin stmt marker notes.\n\t(print_insn): Likewise.\n\t* recog.c (extract_insn): Recognize rtl for debug markers.\n\t* rtl.def (DEBUG_MARKER): New.\n\t* tree-inline.c: Include params.h.\n\t(remap_gimple_stmt): Handle nonbind markers.\n\t(maybe_move_debug_stmts_to_successors): Likewise.\n\t(copy_debug_stmt): Likewise.\n\t* tree-iterator.c (append_to_statement_list_1): Append begin stmt\n\tmarkers regardless of no side effects.\n\t(tsi_link_before): Don't update container's side effects when adding\n\ta begin stmt marker.\n\t(tsi_link_after): Likewise.\n\t(expr_first): Skip begin stmt markers.\n\t(expr_last): Likewise.\n\t* tree-pretty-print (dump_generic_node): Handle begin stmt markers.\n\t* tree-ssa-threadedge.c (propagate_threaded_block_debug_info):\n\tDisregard nonbind markers.\n\t* tree.c (make_node_stat): Don't set side effects for begin stmt\n\tmarkers.\n\t(build1_stat): Likewise.\n\t* tree.def (DEBUG_BEGIN_STMT): New.\n\t* tree.h (GOTO_DESTINATION): Require a GOTO_EXPR.\n\t* var-tracking.c (delete_debug_insns): Renamed to...\n\t(delete_vta_debug_insns): ... this.\n\t(reemit_marker_as_note): New.\n\t(vt_initialize): Reemit markers.\n\t(delete_vta_debug_insns): Likewise.\n\t(vt_debug_insns_local): Reemit or delete markers.\n\t(variable_tracking_main_1): Likewise.\n\t* doc/generic.texi (DEBUG_BEGIN_STMT): Document.\n\t* doc/gimple.texi (gimple_debug_begin_stmt_p): New.\n\t(gimple_debug_nonbind_marker_p): New.\n\t(gimple_build_debug_bind): Adjust.\n\t(gimple_build_debug_begin_stmt): New.\n\t* doc/invoke.texi (max-debug-marker-count): New param.\n\t* doc/rtl.texi (debug_implicit_ptr, entry_value): New.\n\t(debug_parameter_ref, debug_marker): New.\n\t(NOTE_INSN_BEGIN_STMT): New.\n\t(DEBUG_INSN): Describe begin stmt markers.\n\nFrom-SVN: r255568", "tree": {"sha": "b00f1071af75663b02d851d1219441346ab742ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b00f1071af75663b02d851d1219441346ab742ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/comments", "author": null, "committer": null, "parents": [{"sha": "eb8b347423582a66758699748ffc3c499f6bdde2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb8b347423582a66758699748ffc3c499f6bdde2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb8b347423582a66758699748ffc3c499f6bdde2"}], "stats": {"total": 1049, "additions": 895, "deletions": 154}, "files": [{"sha": "01bd2b9f49ad8f73ced4b05218dd8bb7befae661", "filename": "gcc/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1,5 +1,104 @@\n 2017-12-12  Alexandre Oliva <aoliva@redhat.com>\n \n+\t* cfgexpand.c (expand_gimple_basic_block): Handle begin stmt\n+\tmarkers.  Integrate source bind into debug stmt expand loop.\n+\t(pass_expand::execute): Check debug marker limit.  Avoid deep\n+\tTER and expand debug locations for debug bind insns only.\n+\t* cse.c (insn_live_p): Keep nonbind markers and debug bindings\n+\tfollowed by them.\n+\t* df-scan.c (df_insn_delete): Accept out-of-block debug insn.\n+\t* final.c (reemit_insn_block_notes): Take current block from\n+\tnonbind markers.  Declare note where it's first set.\n+\t(final_scan_insn): Handle begin stmt notes.  Emit is_stmt according to\n+\tbegin stmt markers if enabled.\n+\t(notice_source_line): Handle nonbind markers.  Fail if their\n+\tlocation is unknown or that of builtins.\n+\t(rest_of_handle_final): Convert begin stmt markers to notes if\n+\tvar-tracking didn't run.\n+\t(rest_of_clean_state): Skip begin stmt markers.\n+\t* gimple-pretty-print.c (dump_gimple_debug): Handle begin stmt\n+\tmarkers.\n+\t* function.c (allocate_struct_function): Set begin_stmt_markers.\n+\t* function.h (struct function): Add debug_marker_count counter\n+\tand debug_nonbind_markers flag.\n+\t* gimple-iterator.c (gsi_remove): Adjust debug_marker_count.\n+\t* gimple-low.c (lower_function_body): Adjust\n+\tdebug_nonbind_markers.\n+\t(lower_stmt): Drop or skip gimple debug stmts.\n+\t(lower_try_catch): Skip debug stmts.\n+\t* gimple.c (gimple_build_debug_begin_stmt): New.\n+\t(gimple_copy): Increment debug_marker_count if copying one.\n+\t* gimple.h (gimple_build_debug_begin_stmt): Declare.\n+\t* gimplify.c (rexpr_location): New.\n+\t(rexpr_has_location): New.\n+\t(warn_switch_unreachable_r): Handle gimple debug stmts.\n+\t(shortcut_cond_r): Call expr_location.\n+\t(find_goto): New.\n+\t(find_goto_label): New.\n+\t(shortcut_cond_expr): Call expr_has_location, expr_location, and\n+\tfind_goto_label.\n+\t(gimplify_cond_expr): Call find_goto_label, expr_has_location, and\n+\texpr_location.\n+\t(gimplify_expr): Handle begin stmt markers.  Reject debug expr decls.\n+\t* langhooks-def.h (LANG_HOOKS_EMITS_BEGIN_STMT): New.  Add to...\n+\t(LANG_HOOKS_INITIALIZER): ... this.\n+\t* langhooks.h (struct lang_hooks): Add emits_begin_stmt.\n+\t* lra-contraints.c (inherit_reload_reg): Tolerate between-blocks\n+\tdebug insns.\n+\t(update_ebb_live_info): Skip debug insn markers.\n+\t* lra.c (debug_insn_static_data): Rename to...\n+\t(debug_bind_static_data): ... this.\n+\t(debug_marker_static_data): New.\n+\t(lra_set_insn_recog_data): Select one of the above depending\n+\ton debug insn kind.\n+\t(lra_update_isn_regno_info): Don't assume debug insns have\n+\tfreqs.\n+\t(push_insns): Skip debug insns.\n+\t* lto-streamer-in.c (input_function): Drop debug stmts\n+\tdepending on active options.  Adjust debug_nonbind_markers.\n+\t* params.def (PARAM_MAX_DEBUG_MARKER_COUNT): New.\n+\t* print-rtl.c (rtx_writer::print_rtx_operand_code_0): Handle\n+\tbegin stmt marker notes.\n+\t(print_insn): Likewise.\n+\t* recog.c (extract_insn): Recognize rtl for debug markers.\n+\t* rtl.def (DEBUG_MARKER): New.\n+\t* tree-inline.c: Include params.h.\n+\t(remap_gimple_stmt): Handle nonbind markers.\n+\t(maybe_move_debug_stmts_to_successors): Likewise.\n+\t(copy_debug_stmt): Likewise.\n+\t* tree-iterator.c (append_to_statement_list_1): Append begin stmt\n+\tmarkers regardless of no side effects.\n+\t(tsi_link_before): Don't update container's side effects when adding\n+\ta begin stmt marker.\n+\t(tsi_link_after): Likewise.\n+\t(expr_first): Skip begin stmt markers.\n+\t(expr_last): Likewise.\n+\t* tree-pretty-print (dump_generic_node): Handle begin stmt markers.\n+\t* tree-ssa-threadedge.c (propagate_threaded_block_debug_info):\n+\tDisregard nonbind markers.\n+\t* tree.c (make_node_stat): Don't set side effects for begin stmt\n+\tmarkers.\n+\t(build1_stat): Likewise.\n+\t* tree.def (DEBUG_BEGIN_STMT): New.\n+\t* tree.h (GOTO_DESTINATION): Require a GOTO_EXPR.\n+\t* var-tracking.c (delete_debug_insns): Renamed to...\n+\t(delete_vta_debug_insns): ... this.\n+\t(reemit_marker_as_note): New.\n+\t(vt_initialize): Reemit markers.\n+\t(delete_vta_debug_insns): Likewise.\n+\t(vt_debug_insns_local): Reemit or delete markers.\n+\t(variable_tracking_main_1): Likewise.\n+\t* doc/generic.texi (DEBUG_BEGIN_STMT): Document.\n+\t* doc/gimple.texi (gimple_debug_begin_stmt_p): New.\n+\t(gimple_debug_nonbind_marker_p): New.\n+\t(gimple_build_debug_bind): Adjust.\n+\t(gimple_build_debug_begin_stmt): New.\n+\t* doc/invoke.texi (max-debug-marker-count): New param.\n+\t* doc/rtl.texi (debug_implicit_ptr, entry_value): New.\n+\t(debug_parameter_ref, debug_marker): New.\n+\t(NOTE_INSN_BEGIN_STMT): New.\n+\t(DEBUG_INSN): Describe begin stmt markers.\n+\n \t* cfgbuild.c (find_bb_boundaries): Don't purge dead edges if,\n \twithout debug insns, we wouldn't, but clean up debug insns\n \tafter a control flow insn nevertheless."}, {"sha": "6c31dbef45e04d79e29f79677ecd64cd4d68fb90", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1,3 +1,8 @@\n+2017-12-12  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* c-semantics.c (pop_stmt_list): Move begin stmt marker into\n+\tsubsequent statement list.\n+\n 2017-12-07  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/81544"}, {"sha": "cd872d8ac740592f1201096c3acd7a3bef36e9a6", "filename": "gcc/c-family/c-semantics.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc-family%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc-family%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-semantics.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -76,6 +76,27 @@ pop_stmt_list (tree t)\n \t  free_stmt_list (t);\n \t  t = u;\n \t}\n+      /* If the statement list contained a debug begin stmt and a\n+\t statement list, move the debug begin stmt into the statement\n+\t list and return it.  */\n+      else if (!tsi_end_p (i)\n+\t       && TREE_CODE (tsi_stmt (i)) == DEBUG_BEGIN_STMT)\n+\t{\n+\t  u = tsi_stmt (i);\n+\t  tsi_next (&i);\n+\t  if (tsi_one_before_end_p (i)\n+\t      && TREE_CODE (tsi_stmt (i)) == STATEMENT_LIST)\n+\t    {\n+\t      tree l = tsi_stmt (i);\n+\t      tsi_prev (&i);\n+\t      tsi_delink (&i);\n+\t      tsi_delink (&i);\n+\t      i = tsi_start (l);\n+\t      free_stmt_list (t);\n+\t      t = l;\n+\t      tsi_link_before (&i, u, TSI_SAME_STMT);\n+\t    }\n+\t}\n     }\n \n   return t;"}, {"sha": "f9812665069712d842d812d01da23b169cabf20a", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1,3 +1,12 @@\n+2017-12-12  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* c-objc-common.h (LANG_HOOKS_EMITS_BEGIN_STMT): Redefine as true.\n+\t* c-parser.c (add_debug_begin_stmt): New.\n+\t(c_parser_declaration_or_fndef): Call it.\n+\t(c_parser_compound_statement_nostart): Likewise.\n+\t(c_parser_statement_after_labels): Likewise.\n+\t* c-typeck (c_finish_stmt_expr): Skip begin stmts markers.\n+\n 2017-12-07  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-decl.c (build_compound_literal): Add parameter alignas_align"}, {"sha": "27ceabcdfb2fea3941fdef7d35da89b983f1b500", "filename": "gcc/c/c-objc-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.h?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -60,6 +60,8 @@ along with GCC; see the file COPYING3.  If not see\n #define LANG_HOOKS_BUILTIN_FUNCTION c_builtin_function\n #undef  LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE\n #define LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE c_builtin_function_ext_scope\n+#undef LANG_HOOKS_EMITS_BEGIN_STMT\n+#define LANG_HOOKS_EMITS_BEGIN_STMT true\n \n /* Attribute hooks.  */\n #undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE"}, {"sha": "f1bae8abdf380962fd4c29bf646d28a8780e107e", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1649,6 +1649,19 @@ c_parser_external_declaration (c_parser *parser)\n static void c_finish_omp_declare_simd (c_parser *, tree, tree, vec<c_token>);\n static void c_finish_oacc_routine (struct oacc_routine_data *, tree, bool);\n \n+/* Build and add a DEBUG_BEGIN_STMT statement with location LOC.  */\n+\n+static void\n+add_debug_begin_stmt (location_t loc)\n+{\n+  if (!MAY_HAVE_DEBUG_MARKER_STMTS)\n+    return;\n+\n+  tree stmt = build0 (DEBUG_BEGIN_STMT, void_type_node);\n+  SET_EXPR_LOCATION (stmt, loc);\n+  add_stmt (stmt);\n+}\n+\n /* Parse a declaration or function definition (C90 6.5, 6.7.1, C99\n    6.7, 6.9.1, C11 6.7, 6.9.1).  If FNDEF_OK is true, a function definition\n    is accepted; otherwise (old-style parameter declarations) only other\n@@ -1749,6 +1762,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n   bool diagnosed_no_specs = false;\n   location_t here = c_parser_peek_token (parser)->location;\n \n+  add_debug_begin_stmt (c_parser_peek_token (parser)->location);\n+\n   if (static_assert_ok\n       && c_parser_next_token_is_keyword (parser, RID_STATIC_ASSERT))\n     {\n@@ -4911,6 +4926,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n   location_t label_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n     {\n+      add_debug_begin_stmt (c_parser_peek_token (parser)->location);\n       c_parser_consume_token (parser);\n       return;\n     }\n@@ -5365,6 +5381,10 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n   parser->in_if_block = false;\n   if (if_p != NULL)\n     *if_p = false;\n+\n+  if (c_parser_peek_token (parser)->type != CPP_OPEN_BRACE)\n+    add_debug_begin_stmt (loc);\n+\n   switch (c_parser_peek_token (parser)->type)\n     {\n     case CPP_OPEN_BRACE:"}, {"sha": "13b26845d97a8be17504a11f35fc3a2733ea1e4c", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -10710,6 +10710,10 @@ c_finish_stmt_expr (location_t loc, tree body)\n \t}\n       else\n \ti = tsi_last (last);\n+      if (TREE_CODE (tsi_stmt (i)) == DEBUG_BEGIN_STMT)\n+\tdo\n+\t  tsi_prev (&i);\n+\twhile (TREE_CODE (tsi_stmt (i)) == DEBUG_BEGIN_STMT);\n       last_p = tsi_stmt_ptr (i);\n       last = *last_p;\n     }\n@@ -10729,7 +10733,9 @@ c_finish_stmt_expr (location_t loc, tree body)\n \n   /* In the case that the BIND_EXPR is not necessary, return the\n      expression out from inside it.  */\n-  if (last == BIND_EXPR_BODY (body)\n+  if ((last == BIND_EXPR_BODY (body)\n+       /* Skip nested debug stmts.  */\n+       || last == expr_first (BIND_EXPR_BODY (body)))\n       && BIND_EXPR_VARS (body) == NULL)\n     {\n       /* Even if this looks constant, do not allow it in a constant"}, {"sha": "ce98264214ae17a60d2394eb68d769799b51e2bc", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -5657,49 +5657,83 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t  if (new_bb)\n \t    return new_bb;\n \t}\n-      else if (gimple_debug_bind_p (stmt))\n+      else if (is_gimple_debug (stmt))\n \t{\n \t  location_t sloc = curr_insn_location ();\n \t  gimple_stmt_iterator nsi = gsi;\n \n \t  for (;;)\n \t    {\n-\t      tree var = gimple_debug_bind_get_var (stmt);\n-\t      tree value;\n-\t      rtx val;\n+\t      tree var;\n+\t      tree value = NULL_TREE;\n+\t      rtx val = NULL_RTX;\n \t      machine_mode mode;\n \n-\t      if (TREE_CODE (var) != DEBUG_EXPR_DECL\n-\t\t  && TREE_CODE (var) != LABEL_DECL\n-\t\t  && !target_for_debug_bind (var))\n-\t\tgoto delink_debug_stmt;\n+\t      if (!gimple_debug_nonbind_marker_p (stmt))\n+\t\t{\n+\t\t  if (gimple_debug_bind_p (stmt))\n+\t\t    {\n+\t\t      var = gimple_debug_bind_get_var (stmt);\n \n-\t      if (gimple_debug_bind_has_value_p (stmt))\n-\t\tvalue = gimple_debug_bind_get_value (stmt);\n-\t      else\n-\t\tvalue = NULL_TREE;\n+\t\t      if (TREE_CODE (var) != DEBUG_EXPR_DECL\n+\t\t\t  && TREE_CODE (var) != LABEL_DECL\n+\t\t\t  && !target_for_debug_bind (var))\n+\t\t\tgoto delink_debug_stmt;\n \n-\t      last = get_last_insn ();\n+\t\t      if (DECL_P (var))\n+\t\t\tmode = DECL_MODE (var);\n+\t\t      else\n+\t\t\tmode = TYPE_MODE (TREE_TYPE (var));\n \n-\t      set_curr_insn_location (gimple_location (stmt));\n+\t\t      if (gimple_debug_bind_has_value_p (stmt))\n+\t\t\tvalue = gimple_debug_bind_get_value (stmt);\n+\n+\t\t      val = gen_rtx_VAR_LOCATION\n+\t\t\t(mode, var, (rtx)value, VAR_INIT_STATUS_INITIALIZED);\n+\t\t    }\n+\t\t  else if (gimple_debug_source_bind_p (stmt))\n+\t\t    {\n+\t\t      var = gimple_debug_source_bind_get_var (stmt);\n+\n+\t\t      value = gimple_debug_source_bind_get_value (stmt);\n+\n+\t\t      mode = DECL_MODE (var);\n \n-\t      if (DECL_P (var))\n-\t\tmode = DECL_MODE (var);\n+\t\t      val = gen_rtx_VAR_LOCATION (mode, var, (rtx)value,\n+\t\t\t\t\t\t  VAR_INIT_STATUS_UNINITIALIZED);\n+\t\t    }\n+\t\t  else\n+\t\t    gcc_unreachable ();\n+\t\t}\n+\t      /* If this function was first compiled with markers\n+\t\t enabled, but they're now disable (e.g. LTO), drop\n+\t\t them on the floor.  */\n+\t      else if (gimple_debug_nonbind_marker_p (stmt)\n+\t\t       && !MAY_HAVE_DEBUG_MARKER_INSNS)\n+\t\tgoto delink_debug_stmt;\n+\t      else if (gimple_debug_begin_stmt_p (stmt))\n+\t\tval = GEN_RTX_DEBUG_MARKER_BEGIN_STMT_PAT ();\n \t      else\n-\t\tmode = TYPE_MODE (TREE_TYPE (var));\n+\t\tgcc_unreachable ();\n \n-\t      val = gen_rtx_VAR_LOCATION\n-\t\t(mode, var, (rtx)value, VAR_INIT_STATUS_INITIALIZED);\n+\t      last = get_last_insn ();\n+\n+\t      set_curr_insn_location (gimple_location (stmt));\n \n \t      emit_debug_insn (val);\n \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n \t\t  /* We can't dump the insn with a TREE where an RTX\n \t\t     is expected.  */\n-\t\t  PAT_VAR_LOCATION_LOC (val) = const0_rtx;\n+\t\t  if (GET_CODE (val) == VAR_LOCATION)\n+\t\t    {\n+\t\t      gcc_checking_assert (PAT_VAR_LOCATION_LOC (val) == (rtx)value);\n+\t\t      PAT_VAR_LOCATION_LOC (val) = const0_rtx;\n+\t\t    }\n \t\t  maybe_dump_rtl_for_gimple_stmt (stmt, last);\n-\t\t  PAT_VAR_LOCATION_LOC (val) = (rtx)value;\n+\t\t  if (GET_CODE (val) == VAR_LOCATION)\n+\t\t    PAT_VAR_LOCATION_LOC (val) = (rtx)value;\n \t\t}\n \n \t    delink_debug_stmt:\n@@ -5715,40 +5749,10 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t      if (gsi_end_p (nsi))\n \t\tbreak;\n \t      stmt = gsi_stmt (nsi);\n-\t      if (!gimple_debug_bind_p (stmt))\n+\t      if (!is_gimple_debug (stmt))\n \t\tbreak;\n \t    }\n \n-\t  set_curr_insn_location (sloc);\n-\t}\n-      else if (gimple_debug_source_bind_p (stmt))\n-\t{\n-\t  location_t sloc = curr_insn_location ();\n-\t  tree var = gimple_debug_source_bind_get_var (stmt);\n-\t  tree value = gimple_debug_source_bind_get_value (stmt);\n-\t  rtx val;\n-\t  machine_mode mode;\n-\n-\t  last = get_last_insn ();\n-\n-\t  set_curr_insn_location (gimple_location (stmt));\n-\n-\t  mode = DECL_MODE (var);\n-\n-\t  val = gen_rtx_VAR_LOCATION (mode, var, (rtx)value,\n-\t\t\t\t      VAR_INIT_STATUS_UNINITIALIZED);\n-\n-\t  emit_debug_insn (val);\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      /* We can't dump the insn with a TREE where an RTX\n-\t\t is expected.  */\n-\t      PAT_VAR_LOCATION_LOC (val) = const0_rtx;\n-\t      maybe_dump_rtl_for_gimple_stmt (stmt, last);\n-\t      PAT_VAR_LOCATION_LOC (val) = (rtx)value;\n-\t    }\n-\n \t  set_curr_insn_location (sloc);\n \t}\n       else\n@@ -6383,6 +6387,11 @@ pass_expand::execute (function *fun)\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (fun)->succs)\n     e->flags &= ~EDGE_EXECUTABLE;\n \n+  /* If the function has too many markers, drop them while expanding.  */\n+  if (cfun->debug_marker_count\n+      >= PARAM_VALUE (PARAM_MAX_DEBUG_MARKER_COUNT))\n+    cfun->debug_nonbind_markers = false;\n+\n   lab_rtx_for_bb = new hash_map<basic_block, rtx_code_label *>;\n   FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR_FOR_FN (fun),\n \t\t  next_bb)"}, {"sha": "4f1be5bd8ac1b9069aa4a59e21ca54f03ae1ba3f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1,3 +1,20 @@\n+2017-12-12  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* constexpr.c (check_constexpr_ctor_body_1): Skip begin stmt\n+\tmarkers.\n+\t(constexpr_fn_retval): Likewise.\n+\t(potential_constant_expression_1): Likewise.\n+\t(cxx_eval_statement_list): Check that a begin stmt marker is\n+\tnot used as the value of a statement list.\n+\t(cxx_eval_constant_expression): Return begin stmt markers\n+\tunchanged.\n+\t* cp-array-notation.c (stmt_location): New.\n+\t(cp_expand_cond_array_notations): Use it.\n+\t* cp-objcp-common.h (LANG_HOOKS_EMITS_BEGIN_STMT): Redefine as true.\n+\t* parser.c (add_debug_begin_stmt): New.\n+\t(cp_parser_statement): Call it.\n+\t* pt.c (tsubst_copy): Handle begin stmt markers.\n+\n 2017-12-07  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/81544"}, {"sha": "0455be1d6dae2742691da4948ad462fc8eccd79a", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -455,6 +455,7 @@ check_constexpr_ctor_body_1 (tree last, tree list)\n \n     case USING_STMT:\n     case STATIC_ASSERT:\n+    case DEBUG_BEGIN_STMT:\n       return true;\n \n     default:\n@@ -694,6 +695,7 @@ constexpr_fn_retval (tree body)\n       return constexpr_fn_retval (BIND_EXPR_BODY (body));\n \n     case USING_STMT:\n+    case DEBUG_BEGIN_STMT:\n       return NULL_TREE;\n \n     case CALL_EXPR:\n@@ -3856,6 +3858,14 @@ cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n       if (returns (jump_target) || breaks (jump_target))\n \tbreak;\n     }\n+  /* Make sure we don't use the \"result\" of a debug-only marker.  That\n+     would be wrong.  We should be using the result of the previous\n+     statement, or NULL if there isn't one.  In practice, this should\n+     never happen: the statement after the marker should override the\n+     result of the marker, so its value shouldn't survive in R.  Now,\n+     should that ever change, we'll need some fixing here to stop\n+     markers from modifying the generated executable code.  */\n+  gcc_checking_assert (!r || TREE_CODE (r) != DEBUG_BEGIN_STMT);\n   return r;\n }\n \n@@ -4081,6 +4091,11 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t}\n       break;\n \n+    case DEBUG_BEGIN_STMT:\n+      /* ??? It might be nice to retain this information somehow, so\n+\t as to be able to step into a constexpr function call.  */\n+      /* Fall through.  */\n+\n     case FUNCTION_DECL:\n     case TEMPLATE_DECL:\n     case LABEL_DECL:\n@@ -5187,6 +5202,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case CONTINUE_STMT:\n     case REQUIRES_EXPR:\n     case STATIC_ASSERT:\n+    case DEBUG_BEGIN_STMT:\n       return true;\n \n     case PARM_DECL:"}, {"sha": "8d3bc8767589f3ffd94c1fa62782f521bd1565d9", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -107,6 +107,8 @@ extern void cp_register_dumps (gcc::dump_manager *);\n #define LANG_HOOKS_MISSING_NORETURN_OK_P cp_missing_noreturn_ok_p\n #undef LANG_HOOKS_BLOCK_MAY_FALLTHRU\n #define LANG_HOOKS_BLOCK_MAY_FALLTHRU cxx_block_may_fallthru\n+#undef LANG_HOOKS_EMITS_BEGIN_STMT\n+#define LANG_HOOKS_EMITS_BEGIN_STMT true\n \n /* Attribute hooks.  */\n #undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE"}, {"sha": "94e87c235f1bfec09f01a072bf6cda24c4e32f13", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -10684,6 +10684,19 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n \n /* Statements [gram.stmt.stmt]  */\n \n+/* Build and add a DEBUG_BEGIN_STMT statement with location LOC.  */\n+\n+static void\n+add_debug_begin_stmt (location_t loc)\n+{\n+  if (!MAY_HAVE_DEBUG_MARKER_STMTS)\n+    return;\n+\n+  tree stmt = build0 (DEBUG_BEGIN_STMT, void_type_node);\n+  SET_EXPR_LOCATION (stmt, loc);\n+  add_stmt (stmt);\n+}\n+\n /* Parse a statement.\n \n    statement:\n@@ -10759,6 +10772,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n   token = cp_lexer_peek_token (parser->lexer);\n   /* Remember the location of the first token in the statement.  */\n   statement_location = token->location;\n+  add_debug_begin_stmt (statement_location);\n   /* If this is a keyword, then that will often determine what kind of\n      statement we have.  */\n   if (token->type == CPP_KEYWORD)"}, {"sha": "0cf6509c247b6ace9ba8debef788c2d7ae34d6d1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -15305,6 +15305,12 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case PREDICT_EXPR:\n       return t;\n \n+    case DEBUG_BEGIN_STMT:\n+      /* ??? There's no point in copying it for now, but maybe some\n+\t day it will contain more information, such as a pointer back\n+\t to the containing function, inlined copy or so.  */\n+      return t;\n+\n     default:\n       /* We shouldn't get here, but keep going if !flag_checking.  */\n       if (flag_checking)"}, {"sha": "c0db32b9f11d61da0f2f5e0fbd718103c6606a87", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -6962,11 +6962,18 @@ insn_live_p (rtx_insn *insn, int *counts)\n     {\n       rtx_insn *next;\n \n+      if (DEBUG_MARKER_INSN_P (insn))\n+\treturn true;\n+\n       for (next = NEXT_INSN (insn); next; next = NEXT_INSN (next))\n \tif (NOTE_P (next))\n \t  continue;\n \telse if (!DEBUG_INSN_P (next))\n \t  return true;\n+\t/* If we find an inspection point, such as a debug begin stmt,\n+\t   we want to keep the earlier debug insn.  */\n+\telse if (DEBUG_MARKER_INSN_P (next))\n+\t  return true;\n \telse if (INSN_VAR_LOCATION_DECL (insn) == INSN_VAR_LOCATION_DECL (next))\n \t  return false;\n "}, {"sha": "429dab8a99b4035e83dc93aad7e50c4eb9430fd1", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -945,7 +945,7 @@ df_insn_delete (rtx_insn *insn)\n      In any case, we expect BB to be non-NULL at least up to register\n      allocation, so disallow a non-NULL BB up to there.  Not perfect\n      but better than nothing...  */\n-  gcc_checking_assert (bb != NULL || reload_completed);\n+  gcc_checking_assert (bb != NULL || DEBUG_INSN_P (insn) || reload_completed);\n \n   df_grow_bb_info (df_scan);\n   df_grow_reg_info ();"}, {"sha": "b01cdaa4d88941b109708101905d1b058331e948", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -2006,6 +2006,11 @@ case 2 ... 5:\n The first value will be @code{CASE_LOW}, while the second will be\n @code{CASE_HIGH}.\n \n+@item DEBUG_BEGIN_STMT\n+\n+Marks the beginning of a source statement, for purposes of debug\n+information generation.\n+\n @end table\n \n "}, {"sha": "492678705c6f3f1bbbd387581ddc954c86be0356", "filename": "gcc/doc/gimple.texi", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdoc%2Fgimple.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdoc%2Fgimple.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgimple.texi?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -831,6 +831,16 @@ expression to a variable.\n Return true if g is any of the OpenMP codes.\n @end deftypefn\n \n+@deftypefn {GIMPLE function} gimple_debug_begin_stmt_p (gimple g)\n+Return true if g is a @code{GIMPLE_DEBUG} that marks the beginning of\n+a source statement.\n+@end deftypefn\n+\n+@deftypefn {GIMPLE function} gimple_debug_nonbind_marker_p (gimple g)\n+Return true if g is a @code{GIMPLE_DEBUG} that marks a program location,\n+without any variable binding.\n+@end deftypefn\n+\n @node Manipulating GIMPLE statements\n @section Manipulating GIMPLE statements\n @cindex Manipulating GIMPLE statements\n@@ -1530,10 +1540,11 @@ Set the conditional @code{COND_STMT} to be of the form 'if (1 == 1)'.\n @subsection @code{GIMPLE_DEBUG}\n @cindex @code{GIMPLE_DEBUG}\n @cindex @code{GIMPLE_DEBUG_BIND}\n+@cindex @code{GIMPLE_DEBUG_BEGIN_STMT}\n \n @deftypefn {GIMPLE function} gdebug *gimple_build_debug_bind (tree var, @\n tree value, gimple stmt)\n-Build a @code{GIMPLE_DEBUG} statement with @code{GIMPLE_DEBUG_BIND} of\n+Build a @code{GIMPLE_DEBUG} statement with @code{GIMPLE_DEBUG_BIND}\n @code{subcode}.  The effect of this statement is to tell debug\n information generation machinery that the value of user variable\n @code{var} is given by @code{value} at that point, and to remain with\n@@ -1604,6 +1615,17 @@ Return @code{TRUE} if @code{stmt} binds a user variable to a value,\n and @code{FALSE} if it unbinds the variable.\n @end deftypefn\n \n+@deftypefn {GIMPLE function} gimple gimple_build_debug_begin_stmt (tree block, location_t location)\n+Build a @code{GIMPLE_DEBUG} statement with\n+@code{GIMPLE_DEBUG_BEGIN_STMT} @code{subcode}.  The effect of this\n+statement is to tell debug information generation machinery that the\n+user statement at the given @code{location} and @code{block} starts at\n+the point at which the statement is inserted.  The intent is that side\n+effects (e.g. variable bindings) of all prior user statements are\n+observable, and that none of the side effects of subsequent user\n+statements are.\n+@end deftypefn\n+\n @node @code{GIMPLE_EH_FILTER}\n @subsection @code{GIMPLE_EH_FILTER}\n @cindex @code{GIMPLE_EH_FILTER}"}, {"sha": "189b3e438fff9753cd5c86f4d6af27ec48510e77", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -10609,6 +10609,13 @@ debug information may end up not being used; setting this higher may\n enable the compiler to find more complex debug expressions, but compile\n time and memory use may grow.  The default is 12.\n \n+@item max-debug-marker-count\n+Sets a threshold on the number of debug markers (e.g. begin stmt\n+markers) to avoid complexity explosion at inlining or expanding to RTL.\n+If a function has more such gimple stmts than the set limit, such stmts\n+will be dropped from the inlined copy of a function, and from its RTL\n+expansion.  The default is 100000.\n+\n @item min-nondebug-insn-uid\n Use uids starting at this parameter for nondebug insns.  The range below\n the parameter is reserved exclusively for debug insns created by"}, {"sha": "dd3c0d3cfc1ec80612391102898fd04eeaf3e234", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -3448,6 +3448,25 @@ Stands for the value bound to the @code{DEBUG_EXPR_DECL} @var{decl},\n that points back to it, within value expressions in\n @code{VAR_LOCATION} nodes.\n \n+@findex debug_implicit_ptr\n+@item (debug_implicit_ptr:@var{mode} @var{decl})\n+Stands for the location of a @var{decl} that is no longer addressable.\n+\n+@findex entry_value\n+@item (entry_value:@var{mode} @var{decl})\n+Stands for the value a @var{decl} had at the entry point of the\n+containing function.\n+\n+@findex debug_parameter_ref\n+@item (debug_parameter_ref:@var{mode} @var{decl})\n+Refers to a parameter that was completely optimized out.\n+\n+@findex debug_marker\n+@item (debug_marker:@var{mode})\n+Marks a program location.  With @code{VOIDmode}, it stands for the\n+beginning of a statement, a recommended inspection point logically after\n+all prior side effects, and before any subsequent side effects.\n+\n @end table\n \n @node Insns\n@@ -3724,6 +3743,12 @@ can be computed by evaluating the RTL expression from that static\n point in the program up to the next such note for the same user\n variable.\n \n+@findex NOTE_INSN_BEGIN_STMT\n+@item NOTE_INSN_BEGIN_STMT\n+This note is used to generate @code{is_stmt} markers in line number\n+debuggign information.  It indicates the beginning of a user\n+statement.\n+\n @end table\n \n These codes are printed symbolically when they appear in debugging dumps.\n@@ -3741,15 +3766,25 @@ binds a user variable tree to an RTL representation of the\n it stands for the value bound to the corresponding\n @code{DEBUG_EXPR_DECL}.\n \n-Throughout optimization passes, binding information is kept in\n-pseudo-instruction form, so that, unlike notes, it gets the same\n-treatment and adjustments that regular instructions would.  It is the\n-variable tracking pass that turns these pseudo-instructions into var\n-location notes, analyzing control flow, value equivalences and changes\n-to registers and memory referenced in value expressions, propagating\n-the values of debug temporaries and determining expressions that can\n-be used to compute the value of each user variable at as many points\n-(ranges, actually) in the program as possible.\n+@code{GIMPLE_DEBUG_BEGIN_STMT} is expanded to RTL as a @code{DEBUG_INSN}\n+with a @code{VOIDmode} @code{DEBUG_MARKER} @code{PATTERN}.  These\n+@code{DEBUG_INSN}s, that do not carry @code{VAR_LOCATION} information,\n+just @code{DEBUG_MARKER}s, can be detected by testing\n+@code{DEBUG_MARKER_INSN_P}, whereas those that do can be recognized as\n+@code{DEBUG_BIND_INSN_P}.\n+\n+Throughout optimization passes, @code{DEBUG_INSN}s are not reordered\n+with respect to each other, particularly during scheduling.  Binding\n+information is kept in pseudo-instruction form, so that, unlike notes,\n+it gets the same treatment and adjustments that regular instructions\n+would.  It is the variable tracking pass that turns these\n+pseudo-instructions into @code{NOTE_INSN_VAR_LOCATION} and\n+@code{NOTE_INSN_BEGIN_STMT} notes,\n+analyzing control flow, value equivalences and changes to registers and\n+memory referenced in value expressions, propagating the values of debug\n+temporaries and determining expressions that can be used to compute the\n+value of each user variable at as many points (ranges, actually) in the\n+program as possible.\n \n Unlike @code{NOTE_INSN_VAR_LOCATION}, the value expression in an\n @code{INSN_VAR_LOCATION} denotes a value at that specific point in the"}, {"sha": "3bcb9c5a2dd628e518d1ee0699465a77a54ef9fa", "filename": "gcc/final.c", "status": "modified", "additions": 71, "deletions": 18, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1652,25 +1652,36 @@ reemit_insn_block_notes (void)\n {\n   tree cur_block = DECL_INITIAL (cfun->decl);\n   rtx_insn *insn;\n-  rtx_note *note;\n \n   insn = get_insns ();\n   for (; insn; insn = NEXT_INSN (insn))\n     {\n       tree this_block;\n \n       /* Prevent lexical blocks from straddling section boundaries.  */\n-      if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n-        {\n-          for (tree s = cur_block; s != DECL_INITIAL (cfun->decl);\n-               s = BLOCK_SUPERCONTEXT (s))\n-            {\n-              rtx_note *note = emit_note_before (NOTE_INSN_BLOCK_END, insn);\n-              NOTE_BLOCK (note) = s;\n-              note = emit_note_after (NOTE_INSN_BLOCK_BEG, insn);\n-              NOTE_BLOCK (note) = s;\n-            }\n-        }\n+      if (NOTE_P (insn))\n+\tswitch (NOTE_KIND (insn))\n+\t  {\n+\t  case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n+\t    {\n+\t      for (tree s = cur_block; s != DECL_INITIAL (cfun->decl);\n+\t\t   s = BLOCK_SUPERCONTEXT (s))\n+\t\t{\n+\t\t  rtx_note *note = emit_note_before (NOTE_INSN_BLOCK_END, insn);\n+\t\t  NOTE_BLOCK (note) = s;\n+\t\t  note = emit_note_after (NOTE_INSN_BLOCK_BEG, insn);\n+\t\t  NOTE_BLOCK (note) = s;\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case NOTE_INSN_BEGIN_STMT:\n+\t    this_block = LOCATION_BLOCK (NOTE_MARKER_LOCATION (insn));\n+\t    goto set_cur_block_to_this_block;\n+\n+\t  default:\n+\t    continue;\n+\t}\n \n       if (!active_insn_p (insn))\n         continue;\n@@ -1691,6 +1702,7 @@ reemit_insn_block_notes (void)\n \t    this_block = choose_inner_scope (this_block,\n \t\t\t\t\t     insn_scope (body->insn (i)));\n \t}\n+    set_cur_block_to_this_block:\n       if (! this_block)\n \t{\n \t  if (INSN_LOCATION (insn) == UNKNOWN_LOCATION)\n@@ -1707,7 +1719,7 @@ reemit_insn_block_notes (void)\n     }\n \n   /* change_scope emits before the insn, not after.  */\n-  note = emit_note (NOTE_INSN_DELETED);\n+  rtx_note *note = emit_note (NOTE_INSN_DELETED);\n   change_scope (note, cur_block, DECL_INITIAL (cfun->decl));\n   delete_insn (note);\n \n@@ -2413,6 +2425,17 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    debug_hooks->var_location (insn);\n \t  break;\n \n+\tcase NOTE_INSN_BEGIN_STMT:\n+\t  gcc_checking_assert (cfun->debug_nonbind_markers);\n+\t  if (!DECL_IGNORED_P (current_function_decl)\n+\t      && notice_source_line (insn, NULL))\n+\t    {\n+\t      (*debug_hooks->source_line) (last_linenum, last_columnnum,\n+\t\t\t\t\t   last_filename, last_discriminator,\n+\t\t\t\t\t   true);\n+\t    }\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t  break;\n@@ -2499,7 +2522,15 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \trtx body = PATTERN (insn);\n \tint insn_code_number;\n \tconst char *templ;\n-\tbool is_stmt;\n+\tbool is_stmt, *is_stmt_p;\n+\n+\tif (MAY_HAVE_DEBUG_MARKER_INSNS && cfun->debug_nonbind_markers)\n+\t  {\n+\t    is_stmt = false;\n+\t    is_stmt_p = NULL;\n+\t  }\n+\telse\n+\t  is_stmt_p = &is_stmt;\n \n \t/* Reset this early so it is correct for ASM statements.  */\n \tcurrent_insn_predicate = NULL_RTX;\n@@ -2602,7 +2633,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t/* Output this line note if it is the first or the last line\n \t   note in a row.  */\n \tif (!DECL_IGNORED_P (current_function_decl)\n-\t    && notice_source_line (insn, &is_stmt))\n+\t    && notice_source_line (insn, is_stmt_p))\n \t  {\n \t    if (flag_verbose_asm)\n \t      asm_show_source (last_filename, last_linenum);\n@@ -3095,7 +3126,22 @@ notice_source_line (rtx_insn *insn, bool *is_stmt)\n   const char *filename;\n   int linenum, columnnum;\n \n-  if (override_filename)\n+  if (NOTE_MARKER_P (insn))\n+    {\n+      location_t loc = NOTE_MARKER_LOCATION (insn);\n+      expanded_location xloc = expand_location (loc);\n+      if (xloc.line == 0)\n+\t{\n+\t  gcc_checking_assert (LOCATION_LOCUS (loc) == UNKNOWN_LOCATION\n+\t\t\t       || LOCATION_LOCUS (loc) == BUILTINS_LOCATION);\n+\t  return false;\n+\t}\n+      filename = xloc.file;\n+      linenum = xloc.line;\n+      columnnum = xloc.column;\n+      force_source_line = true;\n+    }\n+  else if (override_filename)\n     {\n       filename = override_filename;\n       linenum = override_linenum;\n@@ -3128,7 +3174,8 @@ notice_source_line (rtx_insn *insn, bool *is_stmt)\n       last_linenum = linenum;\n       last_columnnum = columnnum;\n       last_discriminator = discriminator;\n-      *is_stmt = true;\n+      if (is_stmt)\n+\t*is_stmt = true;\n       high_block_linenum = MAX (last_linenum, high_block_linenum);\n       high_function_linenum = MAX (last_linenum, high_function_linenum);\n       return true;\n@@ -3140,7 +3187,8 @@ notice_source_line (rtx_insn *insn, bool *is_stmt)\n          output the line table entry with is_stmt false so the\n          debugger does not treat this as a breakpoint location.  */\n       last_discriminator = discriminator;\n-      *is_stmt = false;\n+      if (is_stmt)\n+\t*is_stmt = false;\n       return true;\n     }\n \n@@ -4493,6 +4541,10 @@ rest_of_handle_final (void)\n {\n   const char *fnname = get_fnname_from_decl (current_function_decl);\n \n+  /* Turn debug markers into notes.  */\n+  if (!MAY_HAVE_DEBUG_BIND_INSNS && MAY_HAVE_DEBUG_MARKER_INSNS)\n+    variable_tracking_main ();\n+\n   assemble_start_function (current_function_decl, fnname);\n   final_start_function (get_insns (), asm_out_file, optimize);\n   final (get_insns (), asm_out_file, optimize);\n@@ -4680,6 +4732,7 @@ rest_of_clean_state (void)\n       if (final_output\n \t  && (!NOTE_P (insn) ||\n \t      (NOTE_KIND (insn) != NOTE_INSN_VAR_LOCATION\n+\t       && NOTE_KIND (insn) != NOTE_INSN_BEGIN_STMT\n \t       && NOTE_KIND (insn) != NOTE_INSN_CALL_ARG_LOCATION\n \t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_BEG\n \t       && NOTE_KIND (insn) != NOTE_INSN_BLOCK_END"}, {"sha": "cdb2fc8a557b4e7220d496a50bcf0416066abd42", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -4939,6 +4939,12 @@ allocate_struct_function (tree fndecl, bool abstract_p)\n       if (!profile_flag && !flag_instrument_function_entry_exit)\n \tDECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (fndecl) = 1;\n     }\n+\n+  /* Don't enable begin stmt markers if var-tracking at assignments is\n+     disabled.  The markers make little sense without the variable\n+     binding annotations among them.  */\n+  cfun->debug_nonbind_markers = lang_hooks.emits_begin_stmt\n+    && MAY_HAVE_DEBUG_MARKER_STMTS;\n }\n \n /* This is like allocate_struct_function, but pushes a new cfun for FNDECL"}, {"sha": "b94abb65b7f9825f58b64c9f143973bead29478f", "filename": "gcc/function.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -281,6 +281,12 @@ struct GTY(()) function {\n   /* Last statement uid.  */\n   int last_stmt_uid;\n \n+  /* Debug marker counter.  Count begin stmt markers.  We don't have\n+     to keep it exact, it's more of a rough estimate to enable us to\n+     decide whether they are too many to copy during inlining, or when\n+     expanding to RTL.  */\n+  int debug_marker_count;\n+\n   /* Function sequence number for profiling, debugging, etc.  */\n   int funcdef_no;\n \n@@ -381,6 +387,10 @@ struct GTY(()) function {\n \n   /* Nonzero if the current function contains a #pragma GCC unroll.  */\n   unsigned int has_unroll : 1;\n+\n+  /* Set when the function was compiled with generation of debug\n+     (begin stmt, inline entry, ...) markers enabled.  */\n+  unsigned int debug_nonbind_markers : 1;\n };\n \n /* Add the decl D to the local_decls list of FUN.  */"}, {"sha": "46d3c6ab69281650d8dde79328e6f3320e43990b", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -568,6 +568,10 @@ gsi_remove (gimple_stmt_iterator *i, bool remove_permanently)\n \n   if (remove_permanently)\n     {\n+      if (gimple_debug_nonbind_marker_p (stmt))\n+\t/* We don't need this to be exact, but try to keep it at least\n+\t   close.  */\n+\tcfun->debug_marker_count--;\n       require_eh_edge_purge = remove_stmt_from_eh_lp (stmt);\n       gimple_remove_stmt_histograms (cfun, stmt);\n     }"}, {"sha": "95f3f4561f9fb43a3ea6250a9743f89c5e47c1e5", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -110,6 +110,17 @@ lower_function_body (void)\n \n   i = gsi_last (lowered_body);\n \n+  /* If we had begin stmt markers from e.g. PCH, but this compilation\n+     doesn't want them, lower_stmt will have cleaned them up; we can\n+     now clear the flag that indicates we had them.  */\n+  if (!MAY_HAVE_DEBUG_MARKER_STMTS && cfun->debug_nonbind_markers)\n+    {\n+      /* This counter needs not be exact, but before lowering it will\n+\t most certainly be.  */\n+      gcc_assert (cfun->debug_marker_count == 0);\n+      cfun->debug_nonbind_markers = false;\n+    }\n+\n   /* If the function falls off the end, we need a null return statement.\n      If we've already got one in the return_statements vector, we don't\n      need to do anything special.  Otherwise build one by hand.  */\n@@ -296,6 +307,20 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n       }\n       break;\n \n+    case GIMPLE_DEBUG:\n+      gcc_checking_assert (cfun->debug_nonbind_markers);\n+      /* We can't possibly have debug bind stmts before lowering, we\n+\t first emit them when entering SSA.  */\n+      gcc_checking_assert (gimple_debug_nonbind_marker_p (stmt));\n+      /* Propagate fallthruness.  */\n+      /* If the function (e.g. from PCH) had debug stmts, but they're\n+\t disabled for this compilation, remove them.  */\n+      if (!MAY_HAVE_DEBUG_MARKER_STMTS)\n+\tgsi_remove (gsi, true);\n+      else\n+\tgsi_next (gsi);\n+      return;\n+\n     case GIMPLE_NOP:\n     case GIMPLE_ASM:\n     case GIMPLE_ASSIGN:\n@@ -503,6 +528,10 @@ lower_try_catch (gimple_stmt_iterator *gsi, struct lower_data *data)\n \tcannot_fallthru = false;\n       break;\n \n+    case GIMPLE_DEBUG:\n+      gcc_checking_assert (gimple_debug_begin_stmt_p (stmt));\n+      break;\n+\n     default:\n       /* This case represents statements to be executed when an\n \t exception occurs.  Those statements are implicitly followed"}, {"sha": "aee2ad8f1ea15fc216ee04caf66137bf858e6cf3", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1363,6 +1363,13 @@ dump_gimple_debug (pretty_printer *buffer, gdebug *gs, int spc,\n \t\t\t gimple_debug_source_bind_get_value (gs));\n       break;\n \n+    case GIMPLE_DEBUG_BEGIN_STMT:\n+      if (flags & TDF_RAW)\n+\tdump_gimple_fmt (buffer, spc, flags, \"%G BEGIN_STMT\", gs);\n+      else\n+\tdump_gimple_fmt (buffer, spc, flags, \"# DEBUG BEGIN_STMT\");\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "5a118e9095caf3ec19e81c9771fbc230741f2b1e", "filename": "gcc/gimple.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -853,6 +853,27 @@ gimple_build_debug_source_bind (tree var, tree value,\n }\n \n \n+/* Build a new GIMPLE_DEBUG_BEGIN_STMT statement in BLOCK at\n+   LOCATION.  */\n+\n+gdebug *\n+gimple_build_debug_begin_stmt (tree block, location_t location\n+\t\t\t\t    MEM_STAT_DECL)\n+{\n+  gdebug *p\n+    = as_a <gdebug *> (\n+        gimple_build_with_ops_stat (GIMPLE_DEBUG,\n+\t\t\t\t    (unsigned)GIMPLE_DEBUG_BEGIN_STMT, 0\n+\t\t\t\t    PASS_MEM_STAT));\n+\n+  gimple_set_location (p, location);\n+  gimple_set_block (p, block);\n+  cfun->debug_marker_count++;\n+\n+  return p;\n+}\n+\n+\n /* Build a GIMPLE_OMP_CRITICAL statement.\n \n    BODY is the sequence of statements for which only one thread can execute.\n@@ -1915,6 +1936,9 @@ gimple_copy (gimple *stmt)\n       gimple_set_modified (copy, true);\n     }\n \n+  if (gimple_debug_nonbind_marker_p (stmt))\n+    cfun->debug_marker_count++;\n+\n   return copy;\n }\n "}, {"sha": "7c36679d092fcf1e65723e62871a79fa9e0e1fd1", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1453,6 +1453,7 @@ gswitch *gimple_build_switch (tree, tree, vec<tree> );\n geh_dispatch *gimple_build_eh_dispatch (int);\n gdebug *gimple_build_debug_bind (tree, tree, gimple * CXX_MEM_STAT_INFO);\n gdebug *gimple_build_debug_source_bind (tree, tree, gimple * CXX_MEM_STAT_INFO);\n+gdebug *gimple_build_debug_begin_stmt (tree, location_t CXX_MEM_STAT_INFO);\n gomp_critical *gimple_build_omp_critical (gimple_seq, tree, tree);\n gomp_for *gimple_build_omp_for (gimple_seq, int, tree, size_t, gimple_seq);\n gomp_parallel *gimple_build_omp_parallel (gimple_seq, tree, tree, tree);"}, {"sha": "8e1d400f303e35616252ca8c5f8c2244f34c0b7d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 125, "deletions": 33, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -983,6 +983,48 @@ unshare_expr_without_location (tree expr)\n     walk_tree (&expr, prune_expr_location, NULL, NULL);\n   return expr;\n }\n+\n+/* Return the EXPR_LOCATION of EXPR, if it (maybe recursively) has\n+   one, OR_ELSE otherwise.  The location of a STATEMENT_LISTs\n+   comprising at least one DEBUG_BEGIN_STMT followed by exactly one\n+   EXPR is the location of the EXPR.  */\n+\n+static location_t\n+rexpr_location (tree expr, location_t or_else = UNKNOWN_LOCATION)\n+{\n+  if (!expr)\n+    return or_else;\n+\n+  if (EXPR_HAS_LOCATION (expr))\n+    return EXPR_LOCATION (expr);\n+\n+  if (TREE_CODE (expr) != STATEMENT_LIST)\n+    return or_else;\n+\n+  tree_stmt_iterator i = tsi_start (expr);\n+\n+  bool found = false;\n+  while (!tsi_end_p (i) && TREE_CODE (tsi_stmt (i)) == DEBUG_BEGIN_STMT)\n+    {\n+      found = true;\n+      tsi_next (&i);\n+    }\n+\n+  if (!found || !tsi_one_before_end_p (i))\n+    return or_else;\n+\n+  return rexpr_location (tsi_stmt (i), or_else);\n+}\n+\n+/* Return TRUE iff EXPR (maybe recursively) has a location; see\n+   rexpr_location for the potential recursion.  */\n+\n+static inline bool\n+rexpr_has_location (tree expr)\n+{\n+  return rexpr_location (expr) != UNKNOWN_LOCATION;\n+}\n+\n \f\n /* WRAPPER is a code such as BIND_EXPR or CLEANUP_POINT_EXPR which can both\n    contain statements and have a value.  Assign its value to a temporary\n@@ -1764,6 +1806,13 @@ warn_switch_unreachable_r (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n       /* Walk the sub-statements.  */\n       *handled_ops_p = false;\n       break;\n+\n+    case GIMPLE_DEBUG:\n+      /* Ignore these.  We may generate them before declarations that\n+\t are never executed.  If there's something to warn about,\n+\t there will be non-debug stmts too, and we'll catch those.  */\n+      break;\n+\n     case GIMPLE_CALL:\n       if (gimple_call_internal_p (stmt, IFN_ASAN_MARK))\n \t{\n@@ -3466,7 +3515,7 @@ shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p,\n       append_to_statement_list (t, &expr);\n \n       /* Set the source location of the && on the second 'if'.  */\n-      new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;\n+      new_locus = rexpr_location (pred, locus);\n       t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p, false_label_p,\n \t\t\t   new_locus);\n       append_to_statement_list (t, &expr);\n@@ -3489,7 +3538,7 @@ shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p,\n       append_to_statement_list (t, &expr);\n \n       /* Set the source location of the || on the second 'if'.  */\n-      new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;\n+      new_locus = rexpr_location (pred, locus);\n       t = shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p, false_label_p,\n \t\t\t   new_locus);\n       append_to_statement_list (t, &expr);\n@@ -3511,7 +3560,7 @@ shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p,\n \n       /* Keep the original source location on the first 'if'.  Set the source\n \t location of the ? on the second 'if'.  */\n-      new_locus = EXPR_HAS_LOCATION (pred) ? EXPR_LOCATION (pred) : locus;\n+      new_locus = rexpr_location (pred, locus);\n       expr = build3 (COND_EXPR, void_type_node, TREE_OPERAND (pred, 0),\n \t\t     shortcut_cond_r (TREE_OPERAND (pred, 1), true_label_p,\n \t\t\t\t      false_label_p, locus),\n@@ -3535,6 +3584,45 @@ shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p,\n   return expr;\n }\n \n+/* If EXPR is a GOTO_EXPR, return it.  If it is a STATEMENT_LIST, skip\n+   any of its leading DEBUG_BEGIN_STMTS and recurse on the subsequent\n+   statement, if it is the last one.  Otherwise, return NULL.  */\n+\n+static tree\n+find_goto (tree expr)\n+{\n+  if (!expr)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (expr) == GOTO_EXPR)\n+    return expr;\n+\n+  if (TREE_CODE (expr) != STATEMENT_LIST)\n+    return NULL_TREE;\n+\n+  tree_stmt_iterator i = tsi_start (expr);\n+\n+  while (!tsi_end_p (i) && TREE_CODE (tsi_stmt (i)) == DEBUG_BEGIN_STMT)\n+    tsi_next (&i);\n+\n+  if (!tsi_one_before_end_p (i))\n+    return NULL_TREE;\n+\n+  return find_goto (tsi_stmt (i));\n+}\n+\n+/* Same as find_goto, except that it returns NULL if the destination\n+   is not a LABEL_DECL.  */\n+\n+static inline tree\n+find_goto_label (tree expr)\n+{\n+  tree dest = find_goto (expr);\n+  if (dest && TREE_CODE (GOTO_DESTINATION (dest)) == LABEL_DECL)\n+    return dest;\n+  return NULL_TREE;\n+}\n+\n /* Given a conditional expression EXPR with short-circuit boolean\n    predicates using TRUTH_ANDIF_EXPR or TRUTH_ORIF_EXPR, break the\n    predicate apart into the equivalent sequence of conditionals.  */\n@@ -3565,8 +3653,8 @@ shortcut_cond_expr (tree expr)\n \t  location_t locus = EXPR_LOC_OR_LOC (expr, input_location);\n \t  TREE_OPERAND (expr, 0) = TREE_OPERAND (pred, 1);\n \t  /* Set the source location of the && on the second 'if'.  */\n-\t  if (EXPR_HAS_LOCATION (pred))\n-\t    SET_EXPR_LOCATION (expr, EXPR_LOCATION (pred));\n+\t  if (rexpr_has_location (pred))\n+\t    SET_EXPR_LOCATION (expr, rexpr_location (pred));\n \t  then_ = shortcut_cond_expr (expr);\n \t  then_se = then_ && TREE_SIDE_EFFECTS (then_);\n \t  pred = TREE_OPERAND (pred, 0);\n@@ -3587,8 +3675,8 @@ shortcut_cond_expr (tree expr)\n \t  location_t locus = EXPR_LOC_OR_LOC (expr, input_location);\n \t  TREE_OPERAND (expr, 0) = TREE_OPERAND (pred, 1);\n \t  /* Set the source location of the || on the second 'if'.  */\n-\t  if (EXPR_HAS_LOCATION (pred))\n-\t    SET_EXPR_LOCATION (expr, EXPR_LOCATION (pred));\n+\t  if (rexpr_has_location (pred))\n+\t    SET_EXPR_LOCATION (expr, rexpr_location (pred));\n \t  else_ = shortcut_cond_expr (expr);\n \t  else_se = else_ && TREE_SIDE_EFFECTS (else_);\n \t  pred = TREE_OPERAND (pred, 0);\n@@ -3615,20 +3703,16 @@ shortcut_cond_expr (tree expr)\n   /* If our arms just jump somewhere, hijack those labels so we don't\n      generate jumps to jumps.  */\n \n-  if (then_\n-      && TREE_CODE (then_) == GOTO_EXPR\n-      && TREE_CODE (GOTO_DESTINATION (then_)) == LABEL_DECL)\n+  if (tree then_goto = find_goto_label (then_))\n     {\n-      true_label = GOTO_DESTINATION (then_);\n+      true_label = GOTO_DESTINATION (then_goto);\n       then_ = NULL;\n       then_se = false;\n     }\n \n-  if (else_\n-      && TREE_CODE (else_) == GOTO_EXPR\n-      && TREE_CODE (GOTO_DESTINATION (else_)) == LABEL_DECL)\n+  if (tree else_goto = find_goto_label (else_))\n     {\n-      false_label = GOTO_DESTINATION (else_);\n+      false_label = GOTO_DESTINATION (else_goto);\n       else_ = NULL;\n       else_se = false;\n     }\n@@ -3692,8 +3776,8 @@ shortcut_cond_expr (tree expr)\n \t{\n \t  tree last = expr_last (expr);\n \t  t = build_and_jump (&end_label);\n-\t  if (EXPR_HAS_LOCATION (last))\n-\t    SET_EXPR_LOCATION (t, EXPR_LOCATION (last));\n+\t  if (rexpr_has_location (last))\n+\t    SET_EXPR_LOCATION (t, rexpr_location (last));\n \t  append_to_statement_list (t, &expr);\n \t}\n       if (emit_false)\n@@ -3988,39 +4072,35 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n   gimple_push_condition ();\n \n   have_then_clause_p = have_else_clause_p = false;\n-  if (TREE_OPERAND (expr, 1) != NULL\n-      && TREE_CODE (TREE_OPERAND (expr, 1)) == GOTO_EXPR\n-      && TREE_CODE (GOTO_DESTINATION (TREE_OPERAND (expr, 1))) == LABEL_DECL\n-      && (DECL_CONTEXT (GOTO_DESTINATION (TREE_OPERAND (expr, 1)))\n-\t  == current_function_decl)\n+  label_true = find_goto_label (TREE_OPERAND (expr, 1));\n+  if (label_true\n+      && DECL_CONTEXT (GOTO_DESTINATION (label_true)) == current_function_decl\n       /* For -O0 avoid this optimization if the COND_EXPR and GOTO_EXPR\n \t have different locations, otherwise we end up with incorrect\n \t location information on the branches.  */\n       && (optimize\n \t  || !EXPR_HAS_LOCATION (expr)\n-\t  || !EXPR_HAS_LOCATION (TREE_OPERAND (expr, 1))\n-\t  || EXPR_LOCATION (expr) == EXPR_LOCATION (TREE_OPERAND (expr, 1))))\n+\t  || !rexpr_has_location (label_true)\n+\t  || EXPR_LOCATION (expr) == rexpr_location (label_true)))\n     {\n-      label_true = GOTO_DESTINATION (TREE_OPERAND (expr, 1));\n       have_then_clause_p = true;\n+      label_true = GOTO_DESTINATION (label_true);\n     }\n   else\n     label_true = create_artificial_label (UNKNOWN_LOCATION);\n-  if (TREE_OPERAND (expr, 2) != NULL\n-      && TREE_CODE (TREE_OPERAND (expr, 2)) == GOTO_EXPR\n-      && TREE_CODE (GOTO_DESTINATION (TREE_OPERAND (expr, 2))) == LABEL_DECL\n-      && (DECL_CONTEXT (GOTO_DESTINATION (TREE_OPERAND (expr, 2)))\n-\t  == current_function_decl)\n+  label_false = find_goto_label (TREE_OPERAND (expr, 2));\n+  if (label_false\n+      && DECL_CONTEXT (GOTO_DESTINATION (label_false)) == current_function_decl\n       /* For -O0 avoid this optimization if the COND_EXPR and GOTO_EXPR\n \t have different locations, otherwise we end up with incorrect\n \t location information on the branches.  */\n       && (optimize\n \t  || !EXPR_HAS_LOCATION (expr)\n-\t  || !EXPR_HAS_LOCATION (TREE_OPERAND (expr, 2))\n-\t  || EXPR_LOCATION (expr) == EXPR_LOCATION (TREE_OPERAND (expr, 2))))\n+\t  || !rexpr_has_location (label_false)\n+\t  || EXPR_LOCATION (expr) == rexpr_location (label_false)))\n     {\n-      label_false = GOTO_DESTINATION (TREE_OPERAND (expr, 2));\n       have_else_clause_p = true;\n+      label_false = GOTO_DESTINATION (label_false);\n     }\n   else\n     label_false = create_artificial_label (UNKNOWN_LOCATION);\n@@ -11809,6 +11889,18 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  ret = GS_ALL_DONE;\n \t  break;\n \n+\tcase DEBUG_EXPR_DECL:\n+\t  gcc_unreachable ();\n+\n+\tcase DEBUG_BEGIN_STMT:\n+\t  gimplify_seq_add_stmt (pre_p,\n+\t\t\t\t gimple_build_debug_begin_stmt\n+\t\t\t\t (TREE_BLOCK (*expr_p),\n+\t\t\t\t  EXPR_LOCATION (*expr_p)));\n+\t  ret = GS_ALL_DONE;\n+\t  *expr_p = NULL;\n+\t  break;\n+\n \tcase SSA_NAME:\n \t  /* Allow callbacks into the gimplifier during optimization.  */\n \t  ret = GS_ALL_DONE;"}, {"sha": "9362d9674ede08e26c4b9f128433198f76814180", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -132,6 +132,7 @@ extern int lhd_type_dwarf_attribute (const_tree, int);\n #define LANG_HOOKS_EH_USE_CXA_END_CLEANUP\tfalse\n #define LANG_HOOKS_DEEP_UNSHARING\tfalse\n #define LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS\tfalse\n+#define LANG_HOOKS_EMITS_BEGIN_STMT\tfalse\n #define LANG_HOOKS_RUN_LANG_SELFTESTS   lhd_do_nothing\n #define LANG_HOOKS_GET_SUBSTRING_LOCATION lhd_get_substring_location\n \n@@ -346,6 +347,7 @@ extern void lhd_end_section (void);\n   LANG_HOOKS_EH_USE_CXA_END_CLEANUP, \\\n   LANG_HOOKS_DEEP_UNSHARING, \\\n   LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS, \\\n+  LANG_HOOKS_EMITS_BEGIN_STMT, \\\n   LANG_HOOKS_RUN_LANG_SELFTESTS, \\\n   LANG_HOOKS_GET_SUBSTRING_LOCATION \\\n }"}, {"sha": "dddb0270d498c7840abb31f4005548011e5b9392", "filename": "gcc/langhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -532,6 +532,9 @@ struct lang_hooks\n      instead of trampolines.  */\n   bool custom_function_descriptors;\n \n+  /* True if this language emits begin stmt notes.  */\n+  bool emits_begin_stmt;\n+\n   /* Run all lang-specific selftests.  */\n   void (*run_lang_selftests) (void);\n "}, {"sha": "4adf4bfea8b02d6f7b0d5607932eb9c3f9e40223", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -5265,10 +5265,11 @@ inherit_reload_reg (bool def_p, int original_regno,\n       lra_update_insn_regno_info (as_a <rtx_insn *> (usage_insn));\n       if (lra_dump_file != NULL)\n \t{\n+\t  basic_block bb = BLOCK_FOR_INSN (usage_insn);\n \t  fprintf (lra_dump_file,\n \t\t   \"    Inheritance reuse change %d->%d (bb%d):\\n\",\n \t\t   original_regno, REGNO (new_reg),\n-\t\t   BLOCK_FOR_INSN (usage_insn)->index);\n+\t\t   bb ? bb->index : -1);\n \t  dump_insn_slim (lra_dump_file, as_a <rtx_insn *> (usage_insn));\n \t}\n     }\n@@ -5807,6 +5808,13 @@ update_ebb_live_info (rtx_insn *head, rtx_insn *tail)\n       if (NOTE_P (curr_insn) && NOTE_KIND (curr_insn) != NOTE_INSN_BASIC_BLOCK)\n \tcontinue;\n       curr_bb = BLOCK_FOR_INSN (curr_insn);\n+      if (!curr_bb)\n+\t{\n+\t  gcc_assert (DEBUG_INSN_P (curr_insn));\n+\t  if (DEBUG_MARKER_INSN_P (curr_insn))\n+\t    continue;\n+\t  curr_bb = prev_bb;\n+\t}\n       if (curr_bb != prev_bb)\n \t{\n \t  if (prev_bb != NULL)"}, {"sha": "943d1ca65d973bd59f09cfeb16e0b77aeea81b66", "filename": "gcc/lra.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -602,9 +602,9 @@ static struct lra_operand_data debug_operand_data =\n   };\n \n /* The following data are used as static insn data for all debug\n-   insns.  If structure lra_static_insn_data is changed, the\n+   bind insns.  If structure lra_static_insn_data is changed, the\n    initializer should be changed too.  */\n-static struct lra_static_insn_data debug_insn_static_data =\n+static struct lra_static_insn_data debug_bind_static_data =\n   {\n     &debug_operand_data,\n     0,\t/* Duplication operands #.  */\n@@ -618,6 +618,22 @@ static struct lra_static_insn_data debug_insn_static_data =\n     NULL  /* Descriptions of operands in alternatives.\t*/\n   };\n \n+/* The following data are used as static insn data for all debug\n+   marker insns.  If structure lra_static_insn_data is changed, the\n+   initializer should be changed too.  */\n+static struct lra_static_insn_data debug_marker_static_data =\n+  {\n+    &debug_operand_data,\n+    0,\t/* Duplication operands #.  */\n+    -1, /* Commutative operand #.  */\n+    0,\t/* Operands #.\tThere isn't any operand.  */\n+    0,\t/* Duplications #.  */\n+    0,\t/* Alternatives #.  We are not interesting in alternatives\n+\t   because we does not proceed debug_insns for reloads.\t */\n+    NULL, /* Hard registers referenced in machine description.\t*/\n+    NULL  /* Descriptions of operands in alternatives.\t*/\n+  };\n+\n /* Called once per compiler work to initialize some LRA data related\n    to insns.  */\n static void\n@@ -947,12 +963,20 @@ lra_set_insn_recog_data (rtx_insn *insn)\n   data->regs = NULL;\n   if (DEBUG_INSN_P (insn))\n     {\n-      data->insn_static_data = &debug_insn_static_data;\n       data->dup_loc = NULL;\n       data->arg_hard_regs = NULL;\n       data->preferred_alternatives = ALL_ALTERNATIVES;\n-      data->operand_loc = XNEWVEC (rtx *, 1);\n-      data->operand_loc[0] = &INSN_VAR_LOCATION_LOC (insn);\n+      if (DEBUG_BIND_INSN_P (insn))\n+\t{\n+\t  data->insn_static_data = &debug_bind_static_data;\n+\t  data->operand_loc = XNEWVEC (rtx *, 1);\n+\t  data->operand_loc[0] = &INSN_VAR_LOCATION_LOC (insn);\n+\t}\n+      else if (DEBUG_MARKER_INSN_P (insn))\n+\t{\n+\t  data->insn_static_data = &debug_marker_static_data;\n+\t  data->operand_loc = NULL;\n+\t}\n       return data;\n     }\n   if (icode < 0)\n@@ -1597,7 +1621,7 @@ lra_update_insn_regno_info (rtx_insn *insn)\n     return;\n   data = lra_get_insn_recog_data (insn);\n   static_data = data->insn_static_data;\n-  freq = get_insn_freq (insn);\n+  freq = NONDEBUG_INSN_P (insn) ? get_insn_freq (insn) : 0;\n   invalidate_insn_data_regno_info (data, insn, freq);\n   for (i = static_data->n_operands - 1; i >= 0; i--)\n     add_regs_to_insn_regno_info (data, *data->operand_loc[i], insn,"}, {"sha": "9b785ff365d75c27839dfbabf96a239de7ee81d6", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1128,7 +1128,10 @@ input_function (tree fn_decl, struct data_in *data_in,\n \t     Similarly remove all IFN_*SAN_* internal calls   */\n \t  if (!flag_wpa)\n \t    {\n-\t      if (!MAY_HAVE_DEBUG_STMTS && is_gimple_debug (stmt))\n+\t      if (is_gimple_debug (stmt)\n+\t\t  && (gimple_debug_nonbind_marker_p (stmt)\n+\t\t      ? !MAY_HAVE_DEBUG_MARKER_STMTS\n+\t\t      : !MAY_HAVE_DEBUG_BIND_STMTS))\n \t\tremove = true;\n \t      if (is_gimple_call (stmt)\n \t\t  && gimple_call_internal_p (stmt))\n@@ -1182,6 +1185,13 @@ input_function (tree fn_decl, struct data_in *data_in,\n \t    {\n \t      gsi_next (&bsi);\n \t      stmts[gimple_uid (stmt)] = stmt;\n+\n+\t      /* Remember that the input function has begin stmt\n+\t\t markers, so that we know to expect them when emitting\n+\t\t debug info.  */\n+\t      if (!cfun->debug_nonbind_markers\n+\t\t  && gimple_debug_nonbind_marker_p (stmt))\n+\t\tcfun->debug_nonbind_markers = true;\n \t    }\n \t}\n     }"}, {"sha": "9d7f34fb003a4497e3985d30731e346935d2f8c0", "filename": "gcc/params.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -976,6 +976,15 @@ DEFPARAM (PARAM_MAX_VARTRACK_REVERSE_OP_SIZE,\n \t  \"Max. size of loc list for which reverse ops should be added.\",\n \t  50, 0, 0)\n \n+/* Set a threshold to discard debug markers (e.g. debug begin stmt\n+   markers) when expanding a function to RTL, or inlining it into\n+   another function.  */\n+\n+DEFPARAM (PARAM_MAX_DEBUG_MARKER_COUNT,\n+\t  \"max-debug-marker-count\",\n+\t  \"Max. count of debug markers to expand or inline.\",\n+\t  100000, 0, 0)\n+\n /* Set minimum insn uid for non-debug insns.  */\n \n DEFPARAM (PARAM_MIN_NONDEBUG_INSN_UID,"}, {"sha": "0af739da0be649a78b14549b3a47fe2c2b3aa249", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -258,6 +258,16 @@ rtx_writer::print_rtx_operand_code_0 (const_rtx in_rtx ATTRIBUTE_UNUSED,\n \t  fputc ('\\t', m_outfile);\n \t  break;\n \n+\tcase NOTE_INSN_BEGIN_STMT:\n+#ifndef GENERATOR_FILE\n+\t  {\n+\t    expanded_location xloc\n+\t      = expand_location (NOTE_MARKER_LOCATION (in_rtx));\n+\t    fprintf (m_outfile, \" %s:%i\", xloc.file, xloc.line);\n+\t  }\n+#endif\n+\t  break;\n+\n \tdefault:\n \t  break;\n \t}\n@@ -1808,6 +1818,20 @@ print_insn (pretty_printer *pp, const rtx_insn *x, int verbose)\n \n     case DEBUG_INSN:\n       {\n+\tif (DEBUG_MARKER_INSN_P (x))\n+\t  {\n+\t    switch (INSN_DEBUG_MARKER_KIND (x))\n+\t      {\n+\t      case NOTE_INSN_BEGIN_STMT:\n+\t\tpp_string (pp, \"debug begin stmt marker\");\n+\t\tbreak;\n+\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t    break;\n+\t  }\n+\n \tconst char *name = \"?\";\n \tchar idbuf[32];\n "}, {"sha": "3da6e5b827c85dad49ba13062bed347164016807", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -2252,6 +2252,7 @@ extract_insn (rtx_insn *insn)\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:\n     case VAR_LOCATION:\n+    case DEBUG_MARKER:\n       return;\n \n     case SET:"}, {"sha": "0000808c9e99ab85bd4c353c348946527e4488c7", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -766,6 +766,9 @@ DEF_RTL_EXPR(ENTRY_VALUE, \"entry_value\", \"0\", RTX_OBJ)\n    been optimized away completely.  */\n DEF_RTL_EXPR(DEBUG_PARAMETER_REF, \"debug_parameter_ref\", \"t\", RTX_OBJ)\n \n+/* Used in marker DEBUG_INSNs to avoid being recognized as an insn.  */\n+DEF_RTL_EXPR(DEBUG_MARKER, \"debug_marker\", \"\", RTX_EXTRA)\n+\n /* All expressions from this point forward appear only in machine\n    descriptions.  */\n #ifdef GENERATOR_FILE"}, {"sha": "8604ba14a00a418b17b1ded79052996fef4a0fc4", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa.h\"\n #include \"except.h\"\n #include \"debug.h\"\n+#include \"params.h\"\n #include \"value-prof.h\"\n #include \"cfgloop.h\"\n #include \"builtins.h\"\n@@ -1355,7 +1356,9 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n   gimple_seq stmts = NULL;\n \n   if (is_gimple_debug (stmt)\n-      && !opt_for_fn (id->dst_fn, flag_var_tracking_assignments))\n+      && (gimple_debug_nonbind_marker_p (stmt)\n+\t  ? !DECL_STRUCT_FUNCTION (id->dst_fn)->debug_nonbind_markers\n+\t  : !opt_for_fn (id->dst_fn, flag_var_tracking_assignments)))\n     return stmts;\n \n   /* Begin by recognizing trees that we'll completely rewrite for the\n@@ -1638,6 +1641,20 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t  gimple_seq_add_stmt (&stmts, copy);\n \t  return stmts;\n \t}\n+      if (gimple_debug_nonbind_marker_p (stmt))\n+\t{\n+\t  /* If the inlined function has too many debug markers,\n+\t     don't copy them.  */\n+\t  if (id->src_cfun->debug_marker_count\n+\t      > PARAM_VALUE (PARAM_MAX_DEBUG_MARKER_COUNT))\n+\t    return stmts;\n+\n+\t  gdebug *copy = as_a <gdebug *> (gimple_copy (stmt));\n+\t  id->debug_stmts.safe_push (copy);\n+\t  gimple_seq_add_stmt (&stmts, copy);\n+\t  return stmts;\n+\t}\n+      gcc_checking_assert (!is_gimple_debug (stmt));\n \n       /* Create a new deep copy of the statement.  */\n       copy = gimple_copy (stmt);\n@@ -1733,7 +1750,8 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n       gimple_set_block (copy, *n);\n     }\n \n-  if (gimple_debug_bind_p (copy) || gimple_debug_source_bind_p (copy))\n+  if (gimple_debug_bind_p (copy) || gimple_debug_source_bind_p (copy)\n+      || gimple_debug_nonbind_marker_p (copy))\n     {\n       gimple_seq_add_stmt (&stmts, copy);\n       return stmts;\n@@ -2555,6 +2573,8 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n \t      value = gimple_debug_source_bind_get_value (stmt);\n \t      new_stmt = gimple_build_debug_source_bind (var, value, stmt);\n \t    }\n+\t  else if (gimple_debug_nonbind_marker_p (stmt))\n+\t    new_stmt = as_a <gdebug *> (gimple_copy (stmt));\n \t  else\n \t    gcc_unreachable ();\n \t  gsi_insert_before (&dsi, new_stmt, GSI_SAME_STMT);\n@@ -2825,6 +2845,9 @@ copy_debug_stmt (gdebug *stmt, copy_body_data *id)\n       gimple_set_block (stmt, n ? *n : id->block);\n     }\n \n+  if (gimple_debug_nonbind_marker_p (stmt))\n+    return;\n+\n   /* Remap all the operands in COPY.  */\n   memset (&wi, 0, sizeof (wi));\n   wi.info = id;\n@@ -2833,8 +2856,10 @@ copy_debug_stmt (gdebug *stmt, copy_body_data *id)\n \n   if (gimple_debug_source_bind_p (stmt))\n     t = gimple_debug_source_bind_get_var (stmt);\n-  else\n+  else if (gimple_debug_bind_p (stmt))\n     t = gimple_debug_bind_get_var (stmt);\n+  else\n+    gcc_unreachable ();\n \n   if (TREE_CODE (t) == PARM_DECL && id->debug_map\n       && (n = id->debug_map->get (t)))"}, {"sha": "10e510db0921715657c3fad466ca4725bf10dc8e", "filename": "gcc/tree-iterator.c", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -89,7 +89,7 @@ append_to_statement_list_1 (tree t, tree *list_p)\n void\n append_to_statement_list (tree t, tree *list_p)\n {\n-  if (t && TREE_SIDE_EFFECTS (t))\n+  if (t && (TREE_SIDE_EFFECTS (t) || TREE_CODE (t) == DEBUG_BEGIN_STMT))\n     append_to_statement_list_1 (t, list_p);\n }\n \n@@ -137,7 +137,8 @@ tsi_link_before (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n       tail = head;\n     }\n \n-  TREE_SIDE_EFFECTS (i->container) = 1;\n+  if (TREE_CODE (t) != DEBUG_BEGIN_STMT)\n+    TREE_SIDE_EFFECTS (i->container) = 1;\n \n   cur = i->ptr;\n \n@@ -213,7 +214,8 @@ tsi_link_after (tree_stmt_iterator *i, tree t, enum tsi_iterator_update mode)\n       tail = head;\n     }\n \n-  TREE_SIDE_EFFECTS (i->container) = 1;\n+  if (TREE_CODE (t) != DEBUG_BEGIN_STMT)\n+    TREE_SIDE_EFFECTS (i->container) = 1;\n \n   cur = i->ptr;\n \n@@ -279,8 +281,9 @@ tsi_delink (tree_stmt_iterator *i)\n   i->ptr = next;\n }\n \n-/* Return the first expression in a sequence of COMPOUND_EXPRs,\n-   or in a STATEMENT_LIST.  */\n+/* Return the first expression in a sequence of COMPOUND_EXPRs, or in\n+   a STATEMENT_LIST, disregarding DEBUG_BEGIN_STMTs, recursing into a\n+   STATEMENT_LIST if that's the first non-DEBUG_BEGIN_STMT.  */\n \n tree\n expr_first (tree expr)\n@@ -291,7 +294,20 @@ expr_first (tree expr)\n   if (TREE_CODE (expr) == STATEMENT_LIST)\n     {\n       struct tree_statement_list_node *n = STATEMENT_LIST_HEAD (expr);\n-      return n ? n->stmt : NULL_TREE;\n+      if (!n)\n+\treturn NULL_TREE;\n+      while (TREE_CODE (n->stmt) == DEBUG_BEGIN_STMT)\n+\t{\n+\t  n = n->next;\n+\t  if (!n)\n+\t    return NULL_TREE;\n+\t}\n+      /* If the first non-debug stmt is not a statement list, we\n+\t already know it's what we're looking for.  */\n+      if (TREE_CODE (n->stmt) != STATEMENT_LIST)\n+\treturn n->stmt;\n+\n+      return expr_first (n->stmt);\n     }\n \n   while (TREE_CODE (expr) == COMPOUND_EXPR)\n@@ -300,8 +316,9 @@ expr_first (tree expr)\n   return expr;\n }\n \n-/* Return the last expression in a sequence of COMPOUND_EXPRs,\n-   or in a STATEMENT_LIST.  */\n+/* Return the last expression in a sequence of COMPOUND_EXPRs, or in a\n+   STATEMENT_LIST, disregarding DEBUG_BEGIN_STMTs, recursing into a\n+   STATEMENT_LIST if that's the last non-DEBUG_BEGIN_STMT.  */\n \n tree\n expr_last (tree expr)\n@@ -312,7 +329,20 @@ expr_last (tree expr)\n   if (TREE_CODE (expr) == STATEMENT_LIST)\n     {\n       struct tree_statement_list_node *n = STATEMENT_LIST_TAIL (expr);\n-      return n ? n->stmt : NULL_TREE;\n+      if (!n)\n+\treturn NULL_TREE;\n+      while (TREE_CODE (n->stmt) == DEBUG_BEGIN_STMT)\n+\t{\n+\t  n = n->prev;\n+\t  if (!n)\n+\t    return NULL_TREE;\n+\t}\n+      /* If the last non-debug stmt is not a statement list, we\n+\t already know it's what we're looking for.  */\n+      if (TREE_CODE (n->stmt) != STATEMENT_LIST)\n+\treturn n->stmt;\n+\n+      return expr_last (n->stmt);\n     }\n \n   while (TREE_CODE (expr) == COMPOUND_EXPR)"}, {"sha": "6519f3e35481f330864fa75dadb21fa80e0882ef", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -3230,6 +3230,10 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n       dump_block_node (pp, node, spc, flags);\n       break;\n \n+    case DEBUG_BEGIN_STMT:\n+      pp_string (pp, \"# DEBUG BEGIN STMT\");\n+      break;\n+\n     default:\n       NIY;\n     }"}, {"sha": "91793bfa59d347d8dc653472db6fcf3c61456eef", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -712,6 +712,8 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n       gimple *stmt = gsi_stmt (si);\n       if (!is_gimple_debug (stmt))\n \tbreak;\n+      if (gimple_debug_nonbind_marker_p (stmt))\n+\tcontinue;\n       i++;\n     }\n \n@@ -739,6 +741,8 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n \tvar = gimple_debug_bind_get_var (stmt);\n       else if (gimple_debug_source_bind_p (stmt))\n \tvar = gimple_debug_source_bind_get_var (stmt);\n+      else if (gimple_debug_nonbind_marker_p (stmt))\n+\tcontinue;\n       else\n \tgcc_unreachable ();\n \n@@ -766,17 +770,23 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n \t    var = gimple_debug_bind_get_var (stmt);\n \t  else if (gimple_debug_source_bind_p (stmt))\n \t    var = gimple_debug_source_bind_get_var (stmt);\n+\t  else if (gimple_debug_nonbind_marker_p (stmt))\n+\t    continue;\n \t  else\n \t    gcc_unreachable ();\n \n-\t  /* Discard debug bind overlaps.  ??? Unlike stmts from src,\n+\t  /* Discard debug bind overlaps.  Unlike stmts from src,\n \t     copied into a new block that will precede BB, debug bind\n \t     stmts in bypassed BBs may actually be discarded if\n-\t     they're overwritten by subsequent debug bind stmts, which\n-\t     might be a problem once we introduce stmt frontier notes\n-\t     or somesuch.  Adding `&& bb == src' to the condition\n-\t     below will preserve all potentially relevant debug\n-\t     notes.  */\n+\t     they're overwritten by subsequent debug bind stmts.  We\n+\t     want to copy binds for all modified variables, so that we\n+\t     retain a bind to the shared def if there is one, or to a\n+\t     newly introduced PHI node if there is one.  Our bind will\n+\t     end up reset if the value is dead, but that implies the\n+\t     variable couldn't have survived, so it's fine.  We are\n+\t     not actually running the code that performed the binds at\n+\t     this point, we're just adding binds so that they survive\n+\t     the new confluence, so markers should not be copied.  */\n \t  if (vars && vars->add (var))\n \t    continue;\n \t  else if (!vars)\n@@ -787,8 +797,7 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n \t\t  break;\n \t      if (i >= 0)\n \t\tcontinue;\n-\n-\t      if (fewvars.length () < (unsigned) alloc_count)\n+\t      else if (fewvars.length () < (unsigned) alloc_count)\n \t\tfewvars.quick_push (var);\n \t      else\n \t\t{"}, {"sha": "ed1852b3e66b1879fe6b1a265ad093c9b9b7f509", "filename": "gcc/tree.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1040,7 +1040,8 @@ make_node (enum tree_code code MEM_STAT_DECL)\n   switch (type)\n     {\n     case tcc_statement:\n-      TREE_SIDE_EFFECTS (t) = 1;\n+      if (code != DEBUG_BEGIN_STMT)\n+\tTREE_SIDE_EFFECTS (t) = 1;\n       break;\n \n     case tcc_declaration:\n@@ -4397,7 +4398,10 @@ build1 (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n     }\n \n   if (TREE_CODE_CLASS (code) == tcc_statement)\n-    TREE_SIDE_EFFECTS (t) = 1;\n+    {\n+      if (code != DEBUG_BEGIN_STMT)\n+\tTREE_SIDE_EFFECTS (t) = 1;\n+    }\n   else switch (code)\n     {\n     case VA_ARG_EXPR:"}, {"sha": "137e63f255f9867a24a4426452e6a7569e3f4516", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -382,6 +382,9 @@ DEFTREECODE (RESULT_DECL, \"result_decl\", tcc_declaration, 0)\n    DEBUG stmts.  */\n DEFTREECODE (DEBUG_EXPR_DECL, \"debug_expr_decl\", tcc_declaration, 0)\n \n+/* A stmt that marks the beginning of a source statement.  */\n+DEFTREECODE (DEBUG_BEGIN_STMT, \"debug_begin_stmt\", tcc_statement, 0)\n+\n /* A namespace declaration.  Namespaces appear in DECL_CONTEXT of other\n    _DECLs, providing a hierarchy of names.  */\n DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", tcc_declaration, 0)"}, {"sha": "892a8ba7f707f32d1f505049f90d4b6bddee1ab5", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -1223,7 +1223,7 @@ extern void protected_set_expr_location (tree, location_t);\n \n /* GOTO_EXPR accessor. This gives access to the label associated with\n    a goto statement.  */\n-#define GOTO_DESTINATION(NODE)  TREE_OPERAND ((NODE), 0)\n+#define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_EXPR_CHECK (NODE), 0)\n \n /* ASM_EXPR accessors. ASM_STRING returns a STRING_CST for the\n    instruction (e.g., \"mov x, y\"). ASM_OUTPUTS, ASM_INPUTS, and"}, {"sha": "8e500b144712a2007f8f171486bfb201498663ad", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a95ac18c2fe573d9c5039be18cf7c6cb26f171/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=96a95ac18c2fe573d9c5039be18cf7c6cb26f171", "patch": "@@ -9926,6 +9926,36 @@ vt_init_cfa_base (void)\n   cselib_preserve_cfa_base_value (val, REGNO (cfa_base_rtx));\n }\n \n+/* Reemit INSN, a MARKER_DEBUG_INSN, as a note.  */\n+\n+static rtx_insn *\n+reemit_marker_as_note (rtx_insn *insn, basic_block *bb)\n+{\n+  gcc_checking_assert (DEBUG_MARKER_INSN_P (insn));\n+\n+  enum insn_note kind = INSN_DEBUG_MARKER_KIND (insn);\n+\n+  switch (kind)\n+    {\n+    case NOTE_INSN_BEGIN_STMT:\n+      {\n+\trtx_insn *note = NULL;\n+\tif (cfun->debug_nonbind_markers)\n+\t  {\n+\t    note = emit_note_before (kind, insn);\n+\t    NOTE_MARKER_LOCATION (note) = INSN_LOCATION (insn);\n+\t    if (bb)\n+\t      BLOCK_FOR_INSN (note) = *bb;\n+\t  }\n+\tdelete_insn (insn);\n+\treturn note;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Allocate and initialize the data structures for variable tracking\n    and parse the RTL to get the micro operations.  */\n \n@@ -10169,6 +10199,12 @@ vt_initialize (void)\n \n \t\t  cselib_hook_called = false;\n \t\t  adjust_insn (bb, insn);\n+\t\t  if (DEBUG_MARKER_INSN_P (insn))\n+\t\t    {\n+\t\t      insn = reemit_marker_as_note (insn, &save_bb);\n+\t\t      continue;\n+\t\t    }\n+\n \t\t  if (MAY_HAVE_DEBUG_BIND_INSNS)\n \t\t    {\n \t\t      if (CALL_P (insn))\n@@ -10245,10 +10281,11 @@ vt_initialize (void)\n \n static int debug_label_num = 1;\n \n-/* Get rid of all debug insns from the insn stream.  */\n+/* Remove from the insn stream all debug insns used for variable\n+   tracking at assignments.  */\n \n static void\n-delete_debug_insns (void)\n+delete_vta_debug_insns (void)\n {\n   basic_block bb;\n   rtx_insn *insn, *next;\n@@ -10264,6 +10301,12 @@ delete_debug_insns (void)\n \t   insn = next)\n \tif (DEBUG_INSN_P (insn))\n \t  {\n+\t    if (DEBUG_MARKER_INSN_P (insn))\n+\t      {\n+\t\tinsn = reemit_marker_as_note (insn, NULL);\n+\t\tcontinue;\n+\t      }\n+\n \t    tree decl = INSN_VAR_LOCATION_DECL (insn);\n \t    if (TREE_CODE (decl) == LABEL_DECL\n \t\t&& DECL_NAME (decl)\n@@ -10289,10 +10332,13 @@ delete_debug_insns (void)\n    handled as well..  */\n \n static void\n-vt_debug_insns_local (bool skipped ATTRIBUTE_UNUSED)\n+vt_debug_insns_local (bool skipped)\n {\n-  /* ??? Just skip it all for now.  */\n-  delete_debug_insns ();\n+  /* ??? Just skip it all for now.  If we skipped the global pass,\n+     arrange for stmt markers to be dropped as well.  */\n+  if (skipped)\n+    cfun->debug_nonbind_markers = 0;\n+  delete_vta_debug_insns ();\n }\n \n /* Free the data structures needed for variable tracking.  */\n@@ -10357,15 +10403,21 @@ variable_tracking_main_1 (void)\n {\n   bool success;\n \n-  if (flag_var_tracking_assignments < 0\n+  /* We won't be called as a separate pass if flag_var_tracking is not\n+     set, but final may call us to turn debug markers into notes.  */\n+  if ((!flag_var_tracking && MAY_HAVE_DEBUG_INSNS)\n+      || flag_var_tracking_assignments < 0\n       /* Var-tracking right now assumes the IR doesn't contain\n \t any pseudos at this point.  */\n       || targetm.no_register_allocation)\n     {\n-      delete_debug_insns ();\n+      delete_vta_debug_insns ();\n       return 0;\n     }\n \n+  if (!flag_var_tracking)\n+    return 0;\n+\n   if (n_basic_blocks_for_fn (cfun) > 500 &&\n       n_edges_for_fn (cfun) / n_basic_blocks_for_fn (cfun) >= 20)\n     {\n@@ -10387,7 +10439,9 @@ variable_tracking_main_1 (void)\n     {\n       vt_finalize ();\n \n-      delete_debug_insns ();\n+      cfun->debug_nonbind_markers = 0;\n+\n+      delete_vta_debug_insns ();\n \n       /* This is later restored by our caller.  */\n       flag_var_tracking_assignments = 0;"}]}