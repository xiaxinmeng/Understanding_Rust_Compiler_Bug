{"sha": "1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM1ZmQzNDNkZWQyZjI2ZDZiZjFlNjQ1OWQ2ZDdiODBjYjg1NjRlNg==", "commit": {"author": {"name": "Felix Yang", "email": "felix.yang@huawei.com", "date": "2014-11-13T16:04:30Z"}, "committer": {"name": "Fei Yang", "email": "fyang@gcc.gnu.org", "date": "2014-11-13T16:04:30Z"}, "message": "ipa-utils.h: Fix typo in comments.\n\n        * ipa-utils.h: Fix typo in comments.\n        * ipa-profile.c: Likewise.\n        * tree-ssa-loop-ivcanon.c: Fix typo in comments and debugging dump.\n\nFrom-SVN: r217507", "tree": {"sha": "58f0786912197642f74ea73465708a52ca33d0cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58f0786912197642f74ea73465708a52ca33d0cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6/comments", "author": null, "committer": null, "parents": [{"sha": "37e10165c13e9860dabbf6eaf85481debec459e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37e10165c13e9860dabbf6eaf85481debec459e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37e10165c13e9860dabbf6eaf85481debec459e9"}], "stats": {"total": 18, "additions": 12, "deletions": 6}, "files": [{"sha": "7bc943ad9fb351f9f64484e54d07d2e2ca64c6e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6", "patch": "@@ -1,3 +1,9 @@\n+2014-11-13  Felix Yang  <felix.yang@huawei.com>\n+\n+\t* ipa-utils.h: Fix typo in comments.\n+\t* ipa-profile.c: Likewise.\n+\t* tree-ssa-loop-ivcanon.c: Fix typo in comments and debugging dumps.\n+\n 2014-11-13  Teresa Johnson  <tejohnson@google.com>\n \n \tPR tree-optimization/63841"}, {"sha": "99d13098534550828995f87d02cfec10da74b603", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    - Count histogram construction.  This is a histogram analyzing how much\n      time is spent executing statements with a given execution count read\n-     from profile feedback. This histogram is complette only with LTO,\n+     from profile feedback. This histogram is complete only with LTO,\n      otherwise it contains information only about the current unit.\n \n      Similar histogram is also estimated by coverage runtime.  This histogram"}, {"sha": "e285722b190317a2fa1dfa5ff76d15290e03f8c7", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6", "patch": "@@ -85,7 +85,7 @@ cgraph_node *try_speculative_devirtualization (tree, HOST_WIDE_INT,\n \t\t\t\t\t       ipa_polymorphic_call_context);\n \n /* Return vector containing possible targets of polymorphic call E.\n-   If COMPLETEP is non-NULL, store true if the list is complette. \n+   If COMPLETEP is non-NULL, store true if the list is complete. \n    CACHE_TOKEN (if non-NULL) will get stored to an unique ID of entry\n    in the target cache.  If user needs to visit every target list\n    just once, it can memoize them."}, {"sha": "9bc8842946c6030c0be8e7126f9099befaafef47", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=1c5fd343ded2f26d6bf1e6459d6d7b80cb8564e6", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n    to pay up.\n \n    We also perform\n-     - complette unrolling (or peeling) when the loops is rolling few enough\n+     - complete unrolling (or peeling) when the loops is rolling few enough\n        times\n      - simple peeling (i.e. copying few initial iterations prior the loop)\n        when number of iteration estimate is known (typically by the profile\n@@ -422,7 +422,7 @@ estimated_unrolled_size (struct loop_size *size,\n    the same time it does not make any code potentially executed \n    during the last iteration dead.  \n \n-   After complette unrolling we still may get rid of the conditional\n+   After complete unrolling we still may get rid of the conditional\n    on the exit in the last copy even if we have no idea what it does.\n    This is quite common case for loops of form\n \n@@ -775,7 +775,7 @@ try_unroll_loop_completely (struct loop *loop,\n \t\t     loop->num);\n \t  return false;\n \t}\n-      /* Outer loops tend to be less interesting candidates for complette\n+      /* Outer loops tend to be less interesting candidates for complete\n \t unrolling unless we can do a lot of propagation into the inner loop\n \t body.  For now we disable outer loop unrolling when the code would\n \t grow.  */\n@@ -986,7 +986,7 @@ try_peel_loop (struct loop *loop,\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Not peeling: upper bound is known so can \"\n-\t\t \"unroll complettely\\n\");\n+\t\t \"unroll completely\\n\");\n       return false;\n     }\n "}]}