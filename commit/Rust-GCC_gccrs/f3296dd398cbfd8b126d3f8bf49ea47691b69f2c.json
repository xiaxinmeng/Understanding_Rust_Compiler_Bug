{"sha": "f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMyOTZkZDM5OGNiZmQ4YjEyNmQzZjhiZjQ5ZWE0NzY5MWI2OWYyYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T12:28:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T12:28:48Z"}, "message": "[multiple changes]\n\n2014-07-31  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_util.adb: Minor reformatting.\n\n2014-07-31  Vincent Celier  <celier@adacore.com>\n\n\t* errutil.adb (Error_Msg): Make sure that all components of\n\tthe error message object are initialized.\n\n2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Try_Container_Indexing): If the container type is\n\tclass-wide, use specific type to locate iteration primitives.\n\t* sem_ch13.adb (Check_Indexing_Functions): Add legality checks for\n\trules in RM 4.1.6 (Illegal_Indexing): New diagnostic procedure.\n\tMinor error message reformating.\n\t* exp_ch5.adb (Expand_Iterator_Loop): Handle properly Iterator\n\taspect for a derived type.\n\n2014-07-31  Robert Dewar  <dewar@adacore.com>\n\n\t* debug.adb: Document debug flag d.X.\n\nFrom-SVN: r213346", "tree": {"sha": "fead9dc32cef55566b1f1def80ef48b4ac91a389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fead9dc32cef55566b1f1def80ef48b4ac91a389"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/comments", "author": null, "committer": null, "parents": [{"sha": "3dddb11ea42ee8c8cbb235f99ef6986e84919b4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dddb11ea42ee8c8cbb235f99ef6986e84919b4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dddb11ea42ee8c8cbb235f99ef6986e84919b4e"}], "stats": {"total": 326, "additions": 256, "deletions": 70}, "files": [{"sha": "03aa74363a7aa9533d8a2e2a3de902db40f063e7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "patch": "@@ -1,3 +1,26 @@\n+2014-07-31  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_util.adb: Minor reformatting.\n+\n+2014-07-31  Vincent Celier  <celier@adacore.com>\n+\n+\t* errutil.adb (Error_Msg): Make sure that all components of\n+\tthe error message object are initialized.\n+\n+2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Try_Container_Indexing): If the container type is\n+\tclass-wide, use specific type to locate iteration primitives.\n+\t* sem_ch13.adb (Check_Indexing_Functions): Add legality checks for\n+\trules in RM 4.1.6 (Illegal_Indexing): New diagnostic procedure.\n+\tMinor error message reformating.\n+\t* exp_ch5.adb (Expand_Iterator_Loop): Handle properly Iterator\n+\taspect for a derived type.\n+\n+2014-07-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: Document debug flag d.X.\n+\n 2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_util.ads (Find_Specific_Type): Moved here from exp_disp.adb."}, {"sha": "a1a1d8c1a1369e7076b118fed86e178a10dbdd3d", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "patch": "@@ -141,7 +141,7 @@ package body Debug is\n    --  d.U  Ignore indirect calls for static elaboration\n    --  d.V\n    --  d.W  Print out debugging information for Walk_Library_Items\n-   --  d.X\n+   --  d.X  Old treatment of indexing aspects\n    --  d.Y\n    --  d.Z\n \n@@ -685,6 +685,12 @@ package body Debug is\n    --       the order in which units are walked. This is primarily for use in\n    --       debugging CodePeer mode.\n \n+   --  d.X  A previous version of GNAT allowed indexing aspects to be\n+   --       redefined on derived container types, while the default iterator\n+   --       was inherited from the aprent type. This non-standard extension\n+   --       is preserved temporarily for use by the modelling project under\n+   --       debug flag d.X.\n+\n    --  d1   Error messages have node numbers where possible. Normally error\n    --       messages have only source locations. This option is useful when\n    --       debugging errors caused by expanded code, where the source location"}, {"sha": "4121ba983b9dfe7295d9a4e736d189641b197dba", "filename": "gcc/ada/errutil.adb", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Ferrutil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Ferrutil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrutil.adb?ref=f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "patch": "@@ -201,24 +201,27 @@ package body Errutil is\n \n       --  Otherwise build error message object for new message\n \n-      Errors.Increment_Last;\n-      Cur_Msg := Errors.Last;\n-      Errors.Table (Cur_Msg).Text     := new String'(Msg_Buffer (1 .. Msglen));\n-      Errors.Table (Cur_Msg).Next     := No_Error_Msg;\n-      Errors.Table (Cur_Msg).Sptr     := Sptr;\n-      Errors.Table (Cur_Msg).Optr     := Optr;\n-      Errors.Table (Cur_Msg).Sfile    := Get_Source_File_Index (Sptr);\n-      Errors.Table (Cur_Msg).Line     := Get_Physical_Line_Number (Sptr);\n-      Errors.Table (Cur_Msg).Col      := Get_Column_Number (Sptr);\n-      Errors.Table (Cur_Msg).Style    := Is_Style_Msg;\n-      Errors.Table (Cur_Msg).Warn     := Is_Warning_Msg;\n-      Errors.Table (Cur_Msg).Info     := Is_Info_Msg;\n-      Errors.Table (Cur_Msg).Warn_Chr := Warning_Msg_Char;\n-      Errors.Table (Cur_Msg).Serious  := Is_Serious_Error;\n-      Errors.Table (Cur_Msg).Uncond   := Is_Unconditional_Msg;\n-      Errors.Table (Cur_Msg).Msg_Cont := Continuation;\n-      Errors.Table (Cur_Msg).Deleted  := False;\n-\n+      Errors.Append\n+        (New_Val =>\n+           (Text     => new String'(Msg_Buffer (1 .. Msglen)),\n+            Next     => No_Error_Msg,\n+            Prev     => No_Error_Msg,\n+            Sfile    => Get_Source_File_Index (Sptr),\n+            Sptr     => Sptr,\n+            Optr     => Optr,\n+            Line     => Get_Physical_Line_Number (Sptr),\n+            Col      => Get_Column_Number (Sptr),\n+            Warn     => Is_Warning_Msg,\n+            Info     => Is_Info_Msg,\n+            Warn_Err => Warning_Mode = Treat_As_Error,\n+            Warn_Chr => Warning_Msg_Char,\n+            Style    => Is_Style_Msg,\n+            Serious  => Is_Serious_Error,\n+            Uncond   => Is_Unconditional_Msg,\n+            Msg_Cont => Continuation,\n+            Deleted  => False));\n+\n+      Cur_Msg  := Errors.Last;\n       Prev_Msg := No_Error_Msg;\n       Next_Msg := First_Error_Msg;\n "}, {"sha": "120200f891541f4e09998f707871c734ce1ca036", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 86, "deletions": 28, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "patch": "@@ -28,6 +28,7 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch6;  use Exp_Ch6;\n@@ -58,6 +59,7 @@ with Stand;    use Stand;\n with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n \n package body Exp_Ch5 is\n@@ -3292,17 +3294,90 @@ package body Exp_Ch5 is\n          --  type of the iterator must be obtained from the aspect.\n \n          if Of_Present (I_Spec) then\n-            declare\n-               Default_Iter : constant Entity_Id :=\n-                                Entity\n-                                  (Find_Value_Of_Aspect\n-                                    (Etype (Container),\n-                                     Aspect_Default_Iterator));\n-\n+            Handle_Of : declare\n+               Default_Iter  : Entity_Id;\n                Container_Arg : Node_Id;\n                Ent           : Entity_Id;\n \n+               function Get_Default_Iterator\n+                 (T : Entity_Id) return Entity_Id;\n+               --  If the container is a derived type, the aspect holds the\n+               --  parent operation. The required one is a primitive of the\n+               --  derived type and is either inherited or overridden.\n+\n+               --------------------------\n+               -- Get_Default_Iterator --\n+               --------------------------\n+\n+               function Get_Default_Iterator\n+                 (T : Entity_Id) return Entity_Id\n+               is\n+                  Iter : constant Entity_Id :=\n+                    Entity (Find_Value_Of_Aspect (T, Aspect_Default_Iterator));\n+                  Prim : Elmt_Id;\n+                  Op   : Entity_Id;\n+\n+               begin\n+                  Container_Arg := New_Copy_Tree (Container);\n+\n+                  --  A previous version of GNAT allowed indexing aspects to\n+                  --  be redefined on derived container types, while the\n+                  --  default iterator was inherited from the aprent type.\n+                  --  This non-standard extension is preserved temporarily for\n+                  --  use by the modelling project under debug flag d.X.\n+\n+                  if Debug_Flag_Dot_XX then\n+                     if Base_Type (Etype (Container)) /=\n+                        Base_Type (Etype (First_Formal (Iter)))\n+                     then\n+                        Container_Arg :=\n+                          Make_Type_Conversion (Loc,\n+                            Subtype_Mark =>\n+                              New_Occurrence_Of\n+                                (Etype (First_Formal (Iter)), Loc),\n+                            Expression   => Container_Arg);\n+                     end if;\n+\n+                     return Iter;\n+\n+                  elsif Is_Derived_Type (T) then\n+\n+                     --  The default iterator must be a primitive operation\n+                     --  of the type, at the same dispatch slot position.\n+\n+                     Prim := First_Elmt (Primitive_Operations (T));\n+                     while Present (Prim) loop\n+                        Op := Node (Prim);\n+\n+                        if Chars (Op) = Chars (Iter)\n+                          and then DT_Position (Op) = DT_Position (Iter)\n+                        then\n+                           return Op;\n+                        end if;\n+\n+                        Next_Elmt (Prim);\n+                     end loop;\n+\n+                     --  default iterator must exist.\n+\n+                     pragma Assert (False);\n+\n+                  else              --  not a derived type\n+                     return Iter;\n+                  end if;\n+               end Get_Default_Iterator;\n+\n+            --  Start of processing for Handle_Of\n+\n             begin\n+               if Is_Class_Wide_Type (Container_Typ) then\n+                  Default_Iter :=\n+                    Get_Default_Iterator (Etype (Base_Type (Container_Typ)));\n+\n+               else\n+                  Default_Iter := Get_Default_Iterator (Etype (Container));\n+               end if;\n+\n                Cursor := Make_Temporary (Loc, 'C');\n \n                --  For an container element iterator, the iterator type\n@@ -3320,24 +3395,7 @@ package body Exp_Ch5 is\n                Pack := Scope (Root_Type (Etype (Iter_Type)));\n \n                --  Rewrite domain of iteration as a call to the default\n-               --  iterator for the container type. If the container is\n-               --  a derived type and the aspect is inherited, convert\n-               --  container to parent type. The Cursor type is also\n-               --  inherited from the scope of the parent.\n-\n-               if Base_Type (Etype (Container)) =\n-                  Base_Type (Etype (First_Formal (Default_Iter)))\n-               then\n-                  Container_Arg := New_Copy_Tree (Container);\n-\n-               else\n-                  Container_Arg :=\n-                    Make_Type_Conversion (Loc,\n-                      Subtype_Mark =>\n-                        New_Occurrence_Of\n-                          (Etype (First_Formal (Default_Iter)), Loc),\n-                      Expression => New_Copy_Tree (Container));\n-               end if;\n+               --  iterator for the container type.\n \n                Rewrite (Name (I_Spec),\n                  Make_Function_Call (Loc,\n@@ -3367,9 +3425,9 @@ package body Exp_Ch5 is\n                Decl :=\n                  Make_Object_Renaming_Declaration (Loc,\n                    Defining_Identifier => Id,\n-                   Subtype_Mark     =>\n+                   Subtype_Mark        =>\n                      New_Occurrence_Of (Element_Type, Loc),\n-                   Name             =>\n+                   Name                =>\n                      Make_Indexed_Component (Loc,\n                        Prefix      => Relocate_Node (Container_Arg),\n                        Expressions =>\n@@ -3415,7 +3473,7 @@ package body Exp_Ch5 is\n                else\n                   Prepend_To (Stats, Decl);\n                end if;\n-            end;\n+            end Handle_Of;\n \n          --  X in Iterate (S) : type of iterator is type of explicitly\n          --  given Iterate function, and the loop variable is the cursor."}, {"sha": "c99a67446f30e495030613019399e58f38f0dfb7", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "patch": "@@ -786,7 +786,7 @@ package body Exp_Util is\n          if Is_Allocate or else not Is_Class_Wide_Type (Desig_Typ) then\n             Append_To (Actuals, New_Occurrence_Of (Alig_Id, Loc));\n \n-         --  For deallocation of class wide types we obtain the value of\n+         --  For deallocation of class-wide types we obtain the value of\n          --  alignment from the Type Specific Record of the deallocated object.\n          --  This is needed because the frontend expansion of class-wide types\n          --  into equivalent types confuses the backend.\n@@ -5860,7 +5860,7 @@ package body Exp_Util is\n \n       Set_Is_Class_Wide_Equivalent_Type (Equiv_Type);\n \n-      --  A class_wide equivalent type does not require initialization\n+      --  A class-wide equivalent type does not require initialization\n \n       Set_Suppress_Initialization (Equiv_Type);\n \n@@ -6097,7 +6097,7 @@ package body Exp_Util is\n    --  2. If Expr is a unconstrained discriminated type expression, creates\n    --    Unc_Type(Expr.Discr1, ... , Expr.Discr_n)\n \n-   --  3. If Expr is class-wide, creates an implicit class wide subtype\n+   --  3. If Expr is class-wide, creates an implicit class-wide subtype\n \n    function Make_Subtype_From_Expr\n      (E       : Node_Id;\n@@ -6186,8 +6186,8 @@ package body Exp_Util is\n \n             if Expander_Active and then Tagged_Type_Expansion then\n \n-               --  If this is the class_wide type of a completion that is a\n-               --  record subtype, set the type of the class_wide type to be\n+               --  If this is the class-wide type of a completion that is a\n+               --  record subtype, set the type of the class-wide type to be\n                --  the full base type, for use in the expanded code for the\n                --  equivalent type. Should this be done earlier when the\n                --  completion is analyzed ???"}, {"sha": "e58614d4b5a719ad3e33419f71caf20195711700", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 103, "deletions": 16, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "patch": "@@ -1671,7 +1671,9 @@ package body Sem_Ch13 is\n                     and then not (Is_Type (E)\n                                    and then Is_Tagged_Type (E))\n                   then\n-                     Error_Msg_N (\"indexing applies to a tagged type\", N);\n+                     Error_Msg_N\n+                       (\"indexing aspect can only apply to a tagged type\",\n+                         Aspect);\n                      goto Continue;\n                   end if;\n \n@@ -3471,53 +3473,138 @@ package body Sem_Ch13 is\n          --  Check one possible interpretation. Sets Indexing_Found True if an\n          --  indexing function is found.\n \n+         procedure Illegal_Indexing (Msg : String);\n+         --  Diagnose illegal indexing function if not overloaded. In the\n+         --  overloaded case indicate that no legal interpretation  exists.\n+\n          ------------------------\n          -- Check_One_Function --\n          ------------------------\n \n          procedure Check_One_Function (Subp : Entity_Id) is\n-            Default_Element : constant Node_Id :=\n-                                Find_Value_Of_Aspect\n-                                  (Etype (First_Formal (Subp)),\n-                                   Aspect_Iterator_Element);\n+            Default_Element : Node_Id;\n+            Ret_Type        : constant Entity_Id := Etype (Subp);\n \n          begin\n+            if not Is_Overloadable (Subp) then\n+               Illegal_Indexing (\"illegal indexing function for type&\");\n+               return;\n+\n+            elsif Scope (Subp) /= Current_Scope then\n+               Illegal_Indexing\n+                 (\"indexing function must be declared in scope of type&\");\n+               return;\n+\n+            elsif No (First_Formal (Subp)) then\n+               Illegal_Indexing\n+                 (\"Indexing requires a function that applies to type&\");\n+               return;\n+\n+            elsif No (Next_Formal (First_Formal (Subp))) then\n+               Illegal_Indexing\n+                  (\"indexing function must have at least two parameters\");\n+               return;\n+\n+            elsif Is_Derived_Type (Ent) then\n+               if (Attr = Name_Constant_Indexing\n+                    and then Present\n+                      (Find_Aspect (Etype (Ent), Aspect_Constant_Indexing)))\n+\n+                 or else (Attr = Name_Variable_Indexing\n+                    and then Present\n+                      (Find_Aspect (Etype (Ent), Aspect_Variable_Indexing)))\n+               then\n+                  if Debug_Flag_Dot_XX then\n+                     null;\n+\n+                  else\n+                     Illegal_Indexing\n+                        (\"indexing function already inherited \"\n+                          & \"from parent type\");\n+                  end if;\n+\n+                  return;\n+               end if;\n+            end if;\n+\n             if not Check_Primitive_Function (Subp)\n               and then not Is_Overloaded (Expr)\n             then\n-               Error_Msg_NE\n-                 (\"aspect Indexing requires a function that applies to type&\",\n-                    Subp, Ent);\n+               Illegal_Indexing\n+                 (\"Indexing aspect requires a function that applies to type&\");\n+               return;\n             end if;\n \n             --  An indexing function must return either the default element of\n             --  the container, or a reference type. For variable indexing it\n             --  must be the latter.\n \n+            Default_Element :=\n+              Find_Value_Of_Aspect\n+               (Etype (First_Formal (Subp)), Aspect_Iterator_Element);\n+\n             if Present (Default_Element) then\n                Analyze (Default_Element);\n \n                if Is_Entity_Name (Default_Element)\n-                 and then Covers (Entity (Default_Element), Etype (Subp))\n+                 and then not Covers (Entity (Default_Element), Ret_Type)\n+                 and then False\n                then\n-                  Indexing_Found := True;\n+                  Illegal_Indexing\n+                    (\"wrong return type for indexing function\");\n                   return;\n                end if;\n             end if;\n \n             --  For variable_indexing the return type must be a reference type\n \n-            if Attr = Name_Variable_Indexing\n-              and then not Has_Implicit_Dereference (Etype (Subp))\n-            then\n-               Error_Msg_N\n-                 (\"function for indexing must return a reference type\", Subp);\n+            if Attr = Name_Variable_Indexing then\n+               if not Has_Implicit_Dereference (Ret_Type) then\n+                  Illegal_Indexing\n+                     (\"variable indexing must return a reference type\");\n+                  return;\n+\n+               elsif Is_Access_Constant (Etype (First_Discriminant (Ret_Type)))\n+               then\n+                  Illegal_Indexing\n+                    (\"variable indexing must return an access to variable\");\n+                  return;\n+               end if;\n \n             else\n-               Indexing_Found := True;\n+               if  Has_Implicit_Dereference (Ret_Type)\n+                 and then not\n+                   Is_Access_Constant (Etype (First_Discriminant (Ret_Type)))\n+               then\n+                  Illegal_Indexing\n+                    (\"constant indexing must return an access to constant\");\n+                  return;\n+\n+               elsif Is_Access_Type (Etype (First_Formal (Subp)))\n+                 and then not Is_Access_Constant (Etype (First_Formal (Subp)))\n+               then\n+                  Illegal_Indexing\n+                    (\"constant indexing must apply to an access to constant\");\n+                  return;\n+               end if;\n             end if;\n+\n+            --  All checks succeeded.\n+\n+            Indexing_Found := True;\n          end Check_One_Function;\n \n+         -----------------------\n+         --  Illegal_Indexing --\n+         -----------------------\n+\n+         procedure Illegal_Indexing (Msg : String) is\n+         begin\n+            if not Is_Overloaded (Expr) then\n+               Error_Msg_NE (Msg, N, Ent);\n+            end if;\n+         end Illegal_Indexing;\n+\n       --  Start of processing for Check_Indexing_Functions\n \n       begin"}, {"sha": "7b2969798234dc25be5257bd8f9700ce592e9cb7", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3296dd398cbfd8b126d3f8bf49ea47691b69f2c/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=f3296dd398cbfd8b126d3f8bf49ea47691b69f2c", "patch": "@@ -6959,13 +6959,22 @@ package body Sem_Ch4 is\n       Exprs  : List_Id) return Boolean\n    is\n       Loc       : constant Source_Ptr := Sloc (N);\n+      C_Type    : Entity_Id;\n       Assoc     : List_Id;\n       Disc      : Entity_Id;\n       Func      : Entity_Id;\n       Func_Name : Node_Id;\n       Indexing  : Node_Id;\n \n    begin\n+      C_Type := Etype (Prefix);\n+\n+      --  If indexing a class-wide container, obtain indexing primitive\n+      --  from specific type.\n+\n+      if Is_Class_Wide_Type (C_Type) then\n+         C_Type := Etype (Base_Type (C_Type));\n+      end if;\n \n       --  Check whether type has a specified indexing aspect\n \n@@ -7013,10 +7022,10 @@ package body Sem_Ch4 is\n       --  Additional machinery may be needed for types that have several user-\n       --  defined Reference operations with different signatures ???\n \n-      elsif Is_Derived_Type (Etype (Prefix))\n+      elsif Is_Derived_Type (C_Type)\n         and then Etype (First_Formal (Entity (Func_Name))) /= Etype (Prefix)\n       then\n-         Func := Find_Prim_Op (Etype (Prefix), Chars (Func_Name));\n+         Func := Find_Prim_Op (C_Type, Chars (Func_Name));\n          Func_Name := New_Occurrence_Of (Func, Loc);\n       end if;\n "}]}