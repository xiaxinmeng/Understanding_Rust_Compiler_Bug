{"sha": "6a71677713a891ed583f065f21e40e3d4d89562c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE3MTY3NzcxM2E4OTFlZDU4M2YwNjVmMjFlNDBlM2Q0ZDg5NTYyYw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-07-14T05:33:30Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-07-14T05:33:30Z"}, "message": "MemoryImageSource.java, [...]: New versions from classpath.\n\n2003-07-14  Michael Koch  <konqueror@gmx.de>\n\n\t* java/awt/image/MemoryImageSource.java,\n\tjava/beans/PropertyEditorManager.java,\n\tjavax/naming/CompoundName.java,\n\tjavax/naming/spi/NamingManager.java,\n\tjavax/swing/AbstractButton.java,\n\tjavax/swing/ButtonModel.java,\n\tjavax/swing/SwingUtilities.java,\n\tjavax/swing/UIManager.java,\n\tjavax/swing/colorchooser/DefaultColorSelectionModel.java,\n\tjavax/swing/event/AncestorEvent.java,\n\tjavax/swing/event/InternalFrameEvent.java,\n\tjava/util/zip/ZipFile.java:\n\tNew versions from classpath.\n\nFrom-SVN: r69321", "tree": {"sha": "325c55b07a6af031947ba6f55a84fc7897bf374b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/325c55b07a6af031947ba6f55a84fc7897bf374b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a71677713a891ed583f065f21e40e3d4d89562c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a71677713a891ed583f065f21e40e3d4d89562c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a71677713a891ed583f065f21e40e3d4d89562c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a71677713a891ed583f065f21e40e3d4d89562c/comments", "author": null, "committer": null, "parents": [{"sha": "6e98504002b3ee32c9b3d17da648b01e1424f833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e98504002b3ee32c9b3d17da648b01e1424f833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e98504002b3ee32c9b3d17da648b01e1424f833"}], "stats": {"total": 2194, "additions": 1106, "deletions": 1088}, "files": [{"sha": "cc46804b0c0edcd2531978492d2529a667de1c6c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -1,3 +1,19 @@\n+2003-07-14  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/awt/image/MemoryImageSource.java,\n+\tjava/beans/PropertyEditorManager.java,\n+\tjavax/naming/CompoundName.java,\n+\tjavax/naming/spi/NamingManager.java,\n+\tjavax/swing/AbstractButton.java,\n+\tjavax/swing/ButtonModel.java,\n+\tjavax/swing/SwingUtilities.java,\n+\tjavax/swing/UIManager.java,\n+\tjavax/swing/colorchooser/DefaultColorSelectionModel.java,\n+\tjavax/swing/event/AncestorEvent.java,\n+\tjavax/swing/event/InternalFrameEvent.java,\n+\tjava/util/zip/ZipFile.java:\n+\tNew versions from classpath.\n+\n 2003-07-13  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/nio/FileChannelImpl.java,"}, {"sha": "5006afe79e56071845e7f9a3b5712f2e58f662ef", "filename": "libjava/java/awt/image/MemoryImageSource.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FMemoryImageSource.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -74,7 +74,7 @@ public MemoryImageSource( int w, int h, ColorModel cm,\n \tthis.props = props;\n \tint max = (( scansize > width ) ? scansize : width );\n \tpixelb = new byte[ max  * height ];\n-\tSystem.arraycopy( pix, 0, pixelb, 0, max );\n+\tSystem.arraycopy( pix, 0, pixelb, 0, max * height );\n     }\n     /**\n        Constructs an ImageProducer from memory\n@@ -100,7 +100,7 @@ public MemoryImageSource(int w, int h, ColorModel cm,\n \tthis.props = props;\n \tint max = (( scansize > width ) ? scansize : width );\n \tpixeli = new int[ max  * height ];\n-\tSystem.arraycopy( pix, 0, pixeli, 0, max );\n+\tSystem.arraycopy( pix, 0, pixeli, 0, max * height );\n     }\n     /**\n        Constructs an ImageProducer from memory using the default RGB ColorModel\n@@ -226,6 +226,7 @@ private void sendPicture ( ImageConsumer ic )\n \tif( props != null ) {\n \t    ic.setProperties( props );\n \t}\n+\tic.setDimensions(width, height);\n \tif( pixeli != null ) {\n \t    ic.setPixels( 0, 0, width, height, cm, pixeli, offset, scansize );\n \t} else {"}, {"sha": "aa0e1776dea9d4860927b932981208ef12256961", "filename": "libjava/java/beans/PropertyEditorManager.java", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjava%2Fbeans%2FPropertyEditorManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjava%2Fbeans%2FPropertyEditorManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fbeans%2FPropertyEditorManager.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -140,24 +140,32 @@ public static PropertyEditor findEditor(Class editedClass)\n             return (PropertyEditor)found.newInstance();\n           }\n \n+\tClassLoader contextClassLoader\n+\t\t= Thread.currentThread().getContextClassLoader();\n+\n         try\n           {\n-            found = Class.forName(editedClass.getName()+\"Editor\");\n+            found = Class.forName(editedClass.getName()+\"Editor\", true,\n+\t\t\t\t  contextClassLoader);\n             registerEditor(editedClass,found);\n             return (PropertyEditor)found.newInstance();\n           }\n         catch(ClassNotFoundException E)\n           {\n           }\n \n-        String appendName = \".\" + ClassHelper.getTruncatedClassName(editedClass) + \"Editor\";\n+        String appendName\n+\t\t= \".\"\n+\t\t+ ClassHelper.getTruncatedClassName(editedClass)\n+\t\t+ \"Editor\";\n         synchronized(editorSearchPath)\n           {\n             for(int i=0;i<editorSearchPath.length;i++)\n               {\n                 try\n                   {\n-                    found = Class.forName(editorSearchPath[i] + appendName);\n+                    found = Class.forName(editorSearchPath[i] + appendName,\n+\t\t\t\t\t  true, contextClassLoader);\n                     registerEditor(editedClass,found);\n                     return (PropertyEditor)found.newInstance();\n                   }"}, {"sha": "b6bc5414d0897f71d2d19cd04b27f24f872010b0", "filename": "libjava/java/util/zip/ZipFile.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -308,7 +308,7 @@ public void close() throws IOException\n    */\n   protected void finalize() throws IOException\n   {\n-    if (!closed) close();\n+    if (!closed && raf != null) close();\n   }\n \n   /**"}, {"sha": "20396398d101011849d3241362e4ee48dd36e9af", "filename": "libjava/javax/naming/CompoundName.java", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fnaming%2FCompoundName.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fnaming%2FCompoundName.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2FCompoundName.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -142,13 +142,17 @@ else if (quote != null)\n \t    // Otherwise, fall through.\n \t  }\n \t// Quotes are only special at the start of a component.\n-\telse if (new_element.length () == 0 && special == beginQuote)\n+\telse if (new_element.length () == 0\n+\t\t && special == beginQuote\n+\t\t && beginQuote != null)\n \t  {\n \t    quote = endQuote;\n \t    i += special.length ();\n \t    continue;\n \t  }\n-\telse if (new_element.length () == 0 && special == beginQuote2)\n+\telse if (new_element.length () == 0\n+\t\t && special == beginQuote2\n+\t\t && beginQuote2 != null)\n \t  {\n \t    quote = endQuote2;\n \t    i += special.length ();"}, {"sha": "8b215cee5c516c673bb7aa2a7d1d53fd0c264e09", "filename": "libjava/javax/naming/spi/NamingManager.java", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fnaming%2Fspi%2FNamingManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fnaming%2Fspi%2FNamingManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fnaming%2Fspi%2FNamingManager.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -83,13 +83,17 @@ public static Context getInitialContext (Hashtable environment)\n \n \ttry\n \t  {\n-\t    icf = (InitialContextFactory) Class.forName (java_naming_factory_initial).newInstance ();\n+\t    icf = (InitialContextFactory)Class.forName\n+\t\t(java_naming_factory_initial, true,\n+\t\t Thread.currentThread().getContextClassLoader())\n+\t\t.newInstance ();\n \t  }\n \tcatch (Exception exception)\n \t  {\n \t    NoInitialContextException e\n-\t      = new NoInitialContextException (\"Can't load InitialContextFactory class: \"\n-\t\t\t\t\t       + java_naming_factory_initial);\n+\t      = new NoInitialContextException\n+\t      (\"Can't load InitialContextFactory class: \"\n+\t       + java_naming_factory_initial);\n \t    e.setRootCause(exception);\n \t    throw e;\n \t  }"}, {"sha": "d44d9775f3ac6fe2e10cb8dc6abd3313a2df66d2", "filename": "libjava/javax/swing/AbstractButton.java", "status": "modified", "additions": 727, "deletions": 736, "changes": 1463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2FAbstractButton.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2FAbstractButton.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FAbstractButton.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -71,740 +71,731 @@\n public abstract class AbstractButton extends JComponent\n   implements ItemSelectable, SwingConstants\n {\n-\tIcon default_icon, pressed_button, disabled_button,\n-\tselected_button, disabled_selected_button, current_icon;\n-\tString text;\n-\n-\tint vert_align = CENTER;\n-\tint hori_align = CENTER;\n-\tint hori_text_pos = CENTER;\n-\tint vert_text_pos = CENTER;\n-\n-\tboolean paint_border = true, paint_focus;\n-\tAction action_taken;\n-\tButtonModel model;\n-\tInsets margin;\n-\n-\n-\tpublic static final String FOCUS_PAINTED_CHANGED_PROPERTY = \"focusPainted\";\n-\n-\t/**\n-\t * AccessibleAbstractButton\n-\t */\n-\tprotected abstract class AccessibleAbstractButton \n-\t\textends AccessibleJComponent \n-\t\timplements AccessibleAction, AccessibleValue, AccessibleText {\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Initialization ---------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * Constructor AccessibleAbstractButton\n-\t\t * @param component TODO\n-\t\t */\n-\t\tprotected AccessibleAbstractButton(AbstractButton component) {\n-\t\t\tsuper(component);\n-\t\t\t// TODO\n-\t\t} // AccessibleAbstractButton()\n-\n-\n-\t\t//-------------------------------------------------------------\n-\t\t// Methods ----------------------------------------------------\n-\t\t//-------------------------------------------------------------\n-\n-\t\t/**\n-\t\t * getAccessibleStateSet\n-\t\t * @returns AccessibleStateSet\n-\t\t */\n-\t\tpublic AccessibleStateSet getAccessibleStateSet() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleStateSet()\n-\n-\t\t/**\n-\t\t * getAccessibleName\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String getAccessibleName() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleName()\n-\n-\t\t/**\n-\t\t * getAccessibleIcon\n-\t\t * @returns AccessibleIcon[]\n-\t\t */\n-\t\tpublic AccessibleIcon[] getAccessibleIcon() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleIcon()\n-\n-\t\t/**\n-\t\t * getAccessibleRelationSet\n-\t\t * @returns AccessibleRelationSet\n-\t\t */\n-\t\tpublic AccessibleRelationSet getAccessibleRelationSet() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleRelationSet()\n-\n-\t\t/**\n-\t\t * getAccessibleAction\n-\t\t * @returns AccessibleAction\n-\t\t */\n-\t\tpublic AccessibleAction getAccessibleAction() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleAction()\n-\n-\t\t/**\n-\t\t * getAccessibleValue\n-\t\t * @returns AccessibleValue\n-\t\t */\n-\t\tpublic AccessibleValue getAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleValue()\n-\n-\t\t/**\n-\t\t * getAccessibleActionCount\n-\t\t * @returns int\n-\t\t */\n-\t\tpublic int getAccessibleActionCount() {\n-\t\t\treturn 0; // TODO\n-\t\t} // getAccessibleActionCount()\n-\n-\t\t/**\n-\t\t * getAccessibleActionDescription\n-\t\t * @param value0 TODO\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String getAccessibleActionDescription(int value0) {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleActionDescription()\n-\n-\t\t/**\n-\t\t * doAccessibleAction\n-\t\t * @param value0 TODO\n-\t\t * @returns boolean\n-\t\t */\n-\t\tpublic boolean doAccessibleAction(int value0) {\n-\t\t\treturn false; // TODO\n-\t\t} // doAccessibleAction()\n-\n-\t\t/**\n-\t\t * getCurrentAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getCurrentAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getCurrentAccessibleValue()\n-\n-\t\t/**\n-\t\t * setCurrentAccessibleValue\n-\t\t * @param value0 TODO\n-\t\t * @returns boolean\n-\t\t */\n-\t\tpublic boolean setCurrentAccessibleValue(Number value0) {\n-\t\t\treturn false; // TODO\n-\t\t} // setCurrentAccessibleValue()\n-\n-\t\t/**\n-\t\t * getMinimumAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getMinimumAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getMinimumAccessibleValue()\n-\n-\t\t/**\n-\t\t * getMaximumAccessibleValue\n-\t\t * @returns Number\n-\t\t */\n-\t\tpublic Number getMaximumAccessibleValue() {\n-\t\t\treturn null; // TODO\n-\t\t} // getMaximumAccessibleValue()\n-\n-\t\t/**\n-\t\t * getAccessibleText\n-\t\t * @returns AccessibleText\n-\t\t */\n-\t\tpublic AccessibleText getAccessibleText() {\n-\t\t\treturn null; // TODO\n-\t\t} // getAccessibleText()\n-\n-\t\t/**\n-\t\t * getIndexAtPoint\n-\t\t * @param value0 TODO\n-\t\t * @returns int\n-\t\t */\n-\t\tpublic int getIndexAtPoint(Point value0) {\n-\t\t\treturn 0; // TODO\n-\t\t} // getIndexAtPoint()\n-\n-\t\t/**\n-\t\t * getCharacterBounds\n-\t\t * @param value0 TODO\n-\t\t * @returns Rectangle\n-\t\t */\n-\t\tpublic Rectangle getCharacterBounds(int value0) {\n-\t\t\treturn null; // TODO\n-\t\t} // getCharacterBounds()\n-\n-\t\t/**\n-\t\t * getCharCount\n-\t\t * @returns int\n-\t\t */\n-\t\tpublic int getCharCount() {\n-\t\t\treturn 0; // TODO\n-\t\t} // getCharCount()\n-\n-\t\t/**\n-\t\t * getCaretPosition\n-\t\t * @returns int\n-\t\t */\n-\t\tpublic int getCaretPosition() {\n-\t\t\treturn 0; // TODO\n-\t\t} // getCaretPosition()\n-\n-\t\t/**\n-\t\t * getAtIndex\n-\t\t * @param value0 TODO\n-\t\t * @param value1 TODO\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String getAtIndex(int value0, int value1) {\n-\t\t\treturn null; // TODO\n-\t\t} // getAtIndex()\n-\n-\t\t/**\n-\t\t * getAfterIndex\n-\t\t * @param value0 TODO\n-\t\t * @param value1 TODO\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String getAfterIndex(int value0, int value1) {\n-\t\t\treturn null; // TODO\n-\t\t} // getAfterIndex()\n-\n-\t\t/**\n-\t\t * getBeforeIndex\n-\t\t * @param value0 TODO\n-\t\t * @param value1 TODO\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String getBeforeIndex(int value0, int value1) {\n-\t\t\treturn null; // TODO\n-\t\t} // getBeforeIndex()\n-\n-\t\t/**\n-\t\t * getCharacterAttribute\n-\t\t * @param value0 TODO\n-\t\t * @returns AttributeSet\n-\t\t */\n-\t\tpublic AttributeSet getCharacterAttribute(int value0) {\n-\t\t\treturn null; // TODO\n-\t\t} // getCharacterAttribute()\n-\n-\t\t/**\n-\t\t * getSelectionStart\n-\t\t * @returns int\n-\t\t */\n-\t\tpublic int getSelectionStart() {\n-\t\t\treturn 0; // TODO\n-\t\t} // getSelectionStart()\n-\n-\t\t/**\n-\t\t * getSelectionEnd\n-\t\t * @returns int\n-\t\t */\n-\t\tpublic int getSelectionEnd() {\n-\t\t\treturn 0; // TODO\n-\t\t} // getSelectionEnd()\n-\n-\t\t/**\n-\t\t * getSelectedText\n-\t\t * @returns String\n-\t\t */\n-\t\tpublic String getSelectedText() {\n-\t\t\treturn null; // TODO\n-\t\t} // getSelectedText()\n-\n-\t\t/**\n-\t\t * getTextRectangle\n-\t\t * @returns Rectangle\n-\t\t */\n-\t\tprivate Rectangle getTextRectangle() {\n-\t\t\treturn null; // TODO\n-\t\t} // getTextRectangle()\n-\n-\n-\t} // AccessibleAbstractButton\n-\n-\n-\tstatic private class JFocusListener implements FocusListener\n-\t{\n-\t\tAbstractButton c;\n-\n-\t\tJFocusListener(AbstractButton c)\n-\t\t{\n-\t\t\tthis.c = c;\n-\t\t}\n-\n-\t\tpublic void focusLost(FocusEvent event)\n-\t\t{\n-\t\t\tc.getModel().setArmed(false);\n-\n-\t\t\tSystem.out.println(\"LOST FOCUS\");\n-\t\t\tif (c.isFocusPainted())\n-\t\t\t{\n-\t\t\t\tc.repaint();\n-\t\t\t}\n-\t\t}\n-\t\tpublic void focusGained(FocusEvent event)\n-\t\t{\n-\t\t\tSystem.out.println(\"GAIN FOCUS\");\n-\t\t}\n-\t}\n-\n-\n-\t/**********************************************\n-\t *\n-\t * \n-\t *       Constructors\n-\t *\n-\t *\n-\t ****************/\n-\n-\tAbstractButton()\n-\t{\n-\t\tthis(\"\",null);\n-\t}\n-\n-\tAbstractButton(String text,\n-\t               Icon icon)\n-\t{\n-\t\tthis.text    = text;\n-\t\tsetIcon(icon);\n-\n-\t\tsetAlignmentX(LEFT_ALIGNMENT);\n-\t\tsetAlignmentY(CENTER_ALIGNMENT);\n-\n-\t\taddFocusListener( new JFocusListener(this) );\n-\n-\t\tsetModel(new DefaultButtonModel(this));\n-\n-\t\tupdateUI(); // get a proper ui\n-\t}\n-\n-\n-\t/**********************************************\n-\t *\n-\t * \n-\t *       Actions etc\n-\t *\n-\t *\n-\t ****************/\n-\n-\tpublic ButtonModel getModel()\n-\t{\treturn model;    }\n-\tpublic void setModel(ButtonModel newModel)\n-\t{\tmodel = newModel;    }\n-\n-\tpublic String getActionCommand()\n-\t{\treturn getModel().getActionCommand();    }\n-\tpublic void setActionCommand(String aCommand)\n-\t{   getModel().setActionCommand(aCommand);   }\n-\n-\tpublic void addActionListener(ActionListener l)\n-\t{\tgetModel().addActionListener(l);    }\n-\tpublic void removeActionListener(ActionListener l)\n-\t{\tgetModel().removeActionListener(l);    }\n-\n-\tpublic void addChangeListener(ChangeListener l)\n-\t{   getModel().addChangeListener(l);     }\n-\tpublic void removeChangeListener(ChangeListener l)\n-\t{  getModel().removeChangeListener(l);    }\n-\n-        public void addItemListener(ItemListener l)\n-\t{  getModel().addItemListener(l);    }\n-        public void removeItemListener(ItemListener l)\n-\t{  getModel().removeItemListener(l);  }\n-\n-\tpublic int getHorizontalAlignment()\n-\t{\treturn hori_align;    }\n-\tpublic int getHorizontalTextPosition()\n-\t{\treturn hori_text_pos;    }\n-\tpublic int getVerticalAlignment()\n-\t{\treturn vert_align;   }\n-\tpublic int getVerticalTextPosition()\n-\t{\treturn vert_text_pos;  }\n-\n-\n-\tprotected  void fireItemStateChanged(ItemEvent event)\n-\t{    getModel().fireItemStateChanged(event);    }\n-\tprotected  void fireStateChanged(ChangeEvent event)\n-\t{\t getModel().fireStateChanged(event);    }\n-\tprotected void fireActionPerformed(ActionEvent event)\n-\t{\tgetModel().fireActionPerformed(event);    }\n-\n-\tpublic void setVerticalAlignment(int alignment)\n-\t{\tvert_align = alignment;    }\n-\tpublic void setHorizontalAlignment(int alignment)\n-\t{   hori_align = alignment;   }\n-\tpublic void setVerticalTextPosition(int textPosition)\n-\t{\tvert_text_pos = textPosition;    }\n-\tpublic void setHorizontalTextPosition(int textPosition)\n-\t{   hori_text_pos = textPosition;   }\n-\n-\tpublic int getMnemonic()\n-\t{\treturn getModel().getMnemonic();    }\n-\tpublic void setMnemonic(char mne)\n-\t{\tgetModel().setMnemonic(mne);    }\n-\tpublic void setMnemonic(int mne)\n-\t{\tgetModel().setMnemonic(mne);    }\n-\n-\tpublic void setRolloverEnabled(boolean b)\n-\t{    getModel().setRollover(b);    }\n-\tpublic boolean isRolloverEnabled()\n-\t{    return getModel().isRollover();     }\n-\n-\n-\tpublic boolean isBorderPainted()\n-\t{\treturn paint_border;    }\n-\tpublic void setBorderPainted(boolean b)\n-\t{\n-\t\tif (b != paint_border)\n-\t\t{\n-\t\t\tpaint_border = b;\n-\t\t\trevalidate();\n-\t\t\trepaint();\n-\t\t}\n-\t}\n-\n-\tpublic Action getAction()\n-\t{\treturn action_taken;    }\n-\tpublic void setAction(Action a)\n-\t{\n-\t\taction_taken = a;\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\tpublic void setSelected(boolean b)\n-\t{\tgetModel().setSelected(b);    }\n-\tpublic boolean isSelected()\n-\t{\treturn getModel().isSelected();     }\n-\n-\n-        public Icon getIcon()\n-\t{\treturn default_icon;    }\n-\tpublic void setIcon(Icon defaultIcon)\n-\t{\n-\t\tif (default_icon == defaultIcon)\n-\t\t\treturn;\n-\n-\t\tdefault_icon = defaultIcon;\n-\t\tif (default_icon != null)\n-\t\t{\n-                  // XXX FIXME - icons do not know their parent\n-//  \t\t\tdefault_icon.setParent(this);\n-\t\t}\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\tpublic String getText()\n-\t{\treturn text;    }\n-\tpublic void setLabel(String label)\n-\t{\tsetText(label);    }\n-\tpublic String getLabel()\n-\t{\treturn getText();    }\n-\tpublic void setText(String text)\n-\t{\n-\t\tthis.text = text;\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\n-        public \tInsets getMargin()\n-\t{      return margin; }\n-\tpublic void setMargin(Insets m)\n-\t{\n-\t\tmargin = m;\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\tpublic void setEnabled(boolean b)\n-\t{\n-\t\tsuper.setEnabled(b);\n-\t\tgetModel().setEnabled(b);\n-\t\trepaint();\n-\t}\n-\n-\tpublic Icon getPressedIcon()\n-\t{\treturn pressed_button;    }\n-\tpublic void setPressedIcon(Icon pressedIcon)\n-\t{\n-\t\tpressed_button = pressedIcon;\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\n-\tpublic Icon getDisabledIcon()\n-\t{\treturn disabled_button;    }\n-\tpublic void setDisabledIcon(Icon disabledIcon)\n-\t{\n-\t\tdisabled_button = disabledIcon;\n-\t\trevalidate();\n-\t\trepaint();\n-\t}\n-\n-\tpublic boolean isFocusPainted()\n-\t{   return paint_focus;   }\n-\tpublic void setFocusPainted(boolean b)\n-\t{\n-\t\tboolean old = paint_focus;\n-\t\tpaint_focus = b;\n-\n-\t\tfirePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY,\n-\t\t                   old,\n-\t\t                   b);\n-\t\tif (hasFocus())\n-\t\t{\n-\t\t\trevalidate();\n-\t\t\trepaint();\n-\t\t}\n-\t}\n-\n-\tpublic boolean isFocusTraversable()\n-\t{\n-\t\t//Identifies whether or not this component can receive the focus.\n-\t\treturn true;\n-\t}\n-\n-\n-\tprotected  int checkHorizontalKey(int key, String exception)\n-\t{\n-\t\t//       Verify that key is a legal value for the horizontalAlignment properties.\n-\t\treturn 0;\n-\t}\n-\tprotected  int checkVerticalKey(int key, String exception)\n-\t{\n-\t\t//       Ensures that the key is a valid.\n-\t\treturn 0;\n-\t}\n-\tprotected  void configurePropertiesFromAction(Action a)\n-\t{\n-\t\t//Factory method which sets the ActionEvent source's properties according to values from the Action instance.\n-\t}\n-\n-\tprotected  ActionListener createActionListener()\n-\t{\n-\t\treturn new ActionListener()\n-\t\t       {\n-\t\t\t       public void actionPerformed(ActionEvent e) { }\n-\t\t       };\n-\t}\n-\n-\tprotected  PropertyChangeListener createActionPropertyChangeListener(Action a)\n-\t{\n-\t\t//Factory method which creates the PropertyChangeListener used to update the ActionEvent source as properties change on its Action instance.\n-\t\treturn null;\n-\t}\n-\tprotected  ChangeListener createChangeListener()\n-\t{\n-\t\t//       Subclasses that want to handle ChangeEvents differently can override this to return another ChangeListener implementation.\n-\t\treturn new ChangeListener()\n-\t\t       {\n-\t\t\t       public void stateChanged(ChangeEvent e) { }\n-\t\t       };\n-\t}\n-\n-\tprotected  ItemListener createItemListener()\n-\t{\n-\t\treturn new ItemListener()\n-\t\t       {\n-\t\t\t       public void itemStateChanged(ItemEvent e) { }\n-\t\t       };\n-\t}\n-\n-\n-\tpublic void doClick()\n-\t{\n-\t\tdoClick(100);\n-\t}\n-\tpublic void doClick(int pressTime)\n-\t{\n-\t    //Toolkit.tlkBeep ();\n-\t\t//Programmatically perform a \"click\".\n-\t}\n-\n-\n-\tpublic Icon getDisabledSelectedIcon()\n-\t{\n-\t\t//Returns the icon used by the button when it's disabled and selected.\n-\t\treturn disabled_selected_button;\n-\t}\n-\n-\n-\tpublic Icon getRolloverIcon()\n-\t{\n-\t\t//       Returns the rollover icon for the button.\n-\t\treturn null;\n-\t}\n-\n-\tIcon getRolloverSelectedIcon()\n-\t{\n-\t\t//       Returns the rollover selection icon for the button.\n-\t\treturn null;\n-\t}\n-\tIcon getSelectedIcon()\n-\t{\n-\t\t//       Returns the selected icon for the button.\n-\t\treturn selected_button;\n-\t}\n-\n-\n-\tpublic Object[] getSelectedObjects()\n-\t{\n-\t\t//Returns an array (length 1) containing the label or null if the button is not selected.\n-\t\treturn null;\n-\t}\n-\n-\n-\tpublic boolean imageUpdate(Image img, int infoflags, int x, int y, int w, int h)\n-\t{\n-\t\t//This is overridden to return false if the current Icon's Image is not equal to the passed in Image img.\n-\t\treturn current_icon == img;\n-\t}\n-\n-        public boolean isContentAreaFilled()\n-\t{\n-\t\t//       Checks whether the \"content area\" of the button should be filled.\n-\t\treturn false;\n-\t}\n-\n-\n-\n-\tprotected  void paintBorder(Graphics g)\n-\t{\n-\t\t//       Paint the button's border if BorderPainted property is true.\n-\t\tif (isBorderPainted())\n-\t\t\tsuper.paintBorder(g);\n-\t}\n-\tprotected  String paramString()\n-\t{\n-\t\t//        Returns a string representation of this AbstractButton.\n-\t\treturn \"AbstractButton\";\n-\t}\n-\n-\n-\tpublic void setContentAreaFilled(boolean b)\n-\t{\n-\t\t//Sets whether the button should paint the content area or leave it transparent.\n-\t}\n-\n-\n-\tpublic void setDisabledSelectedIcon(Icon disabledSelectedIcon)\n-\t{\n-\t\t//          Sets the disabled selection icon for the button.\n-\t}\n-\n-\tpublic void setRolloverIcon(Icon rolloverIcon)\n-\t{\n-\t\t//       Sets the rollover icon for the button.\n-\t}\n-        public void setRolloverSelectedIcon(Icon rolloverSelectedIcon)\n-\t{\n-\t\t//       Sets the rollover selected icon for the button.\n-\t}\n-\n-\n-\tpublic void setSelectedIcon(Icon selectedIcon)\n-\t{\n-\t\t//       Sets the selected icon for the button.\n-\t}\n-\n-\n-\tpublic void setUI(ButtonUI ui)\n-\t{\t//       Sets the L&F object that renders this component.\n-\t\tsuper.setUI(ui);\n-\t}\n-\n-\tpublic ButtonUI getUI()\n-\t{\n-\t\t//Returns the L&F object that renders this component.\n-\t\treturn (ButtonUI) ui;\n-\t}\n-\n-        public void updateUI()\n-\t{\n-\t\t/*\n-\t\t  //          Notification from the UIFactory that the L&F has changed.\n-\t\t  if (getUI() == null)\n-\t\t  {\n-\t\t  setUI(getUI());\n-\t\t  }\n-\t\t*/\n-\t}\n-\n-\tprotected void processActionEvent(ActionEvent e)\n-\t{\n-\t\tSystem.out.println(\"PROCESS-ACTION-EVENT: \" + e);\n-\t}\n-\n-\n-\tprotected void processMouseEvent(MouseEvent e)\n-\t{\n-\t\t//\tSystem.out.println(\"PROCESS-MOUSE-EVENT: \" + e + \", PRESSED-IN-MODEL=\"+getModel().isPressed());\n-\n-\t\tswitch (e.getID())\n-\t\t{\n-\t\tcase MouseEvent.MOUSE_MOVED:\n-\t\t\t{\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\tcase MouseEvent.MOUSE_PRESSED:\n-\t\t\t{\n-\t\t\t\tif (! isEnabled())\n-\t\t\t\t{\n-\t\t\t\t\tSystem.out.println(\"button not enabled, ignoring press\");\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tSystem.out.println(\"telling model:press: \" + getModel());\n-\t\t\t\t\tgetModel().setPressed(true);\n-\t\t\t\t\trepaint();\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\n-\t\tcase MouseEvent.MOUSE_RELEASED:\n-\t\t\t{\n-\t\t\t\tif (! isEnabled())\n-\t\t\t\t{\n-\t\t\t\t\tSystem.out.println(\"button not enabled, ignoring release\");\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tint flags = 0;\n-\n-\t\t\t\t\tSystem.out.println(\"        XXX--> \" + getActionCommand());\n-\n-\t\t\t\t\tfireActionPerformed(new ActionEvent(this,\n-\t\t\t\t\t                                    ActionEvent.ACTION_PERFORMED,\n-\t\t\t\t\t                                    getActionCommand(),\n-\t\t\t\t\t                                    flags));\n-\n-\t\t\t\t\t//System.out.println(\"telling model:release\");\n-\t\t\t\t\tgetModel().setPressed(false);\n-\t\t\t\t\trepaint();\n-\t\t\t\t}\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\tcase MouseEvent.MOUSE_CLICKED:\n-\t\t\t{\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t}\n+  Icon default_icon, pressed_button, disabled_button,\n+    selected_button, disabled_selected_button, current_icon;\n+  String text;\n+\n+  int vert_align = CENTER;\n+  int hori_align = CENTER;\n+  int hori_text_pos = CENTER;\n+  int vert_text_pos = CENTER;\n+\n+  boolean paint_border = true, paint_focus;\n+  Action action_taken;\n+  ButtonModel model;\n+  Insets margin;\n+\n+  public static final String FOCUS_PAINTED_CHANGED_PROPERTY = \"focusPainted\";\n+\n+  /**\n+   * AccessibleAbstractButton\n+   */\n+  protected abstract class AccessibleAbstractButton \n+    extends AccessibleJComponent \n+    implements AccessibleAction, AccessibleValue, AccessibleText {\n+\n+    /**\n+     * Constructor AccessibleAbstractButton\n+     * @param component TODO\n+     */\n+    protected AccessibleAbstractButton(AbstractButton component) {\n+      super(component);\n+      // TODO\n+    } // AccessibleAbstractButton()\n+\n+    /**\n+     * getAccessibleStateSet\n+     * @returns AccessibleStateSet\n+     */\n+    public AccessibleStateSet getAccessibleStateSet() {\n+      return null; // TODO\n+    } // getAccessibleStateSet()\n+\n+    /**\n+     * getAccessibleName\n+     * @returns String\n+     */\n+    public String getAccessibleName() {\n+      return null; // TODO\n+    } // getAccessibleName()\n+\n+    /**\n+     * getAccessibleIcon\n+     * @returns AccessibleIcon[]\n+     */\n+    public AccessibleIcon[] getAccessibleIcon() {\n+      return null; // TODO\n+    } // getAccessibleIcon()\n+\n+    /**\n+     * getAccessibleRelationSet\n+     * @returns AccessibleRelationSet\n+     */\n+    public AccessibleRelationSet getAccessibleRelationSet() {\n+      return null; // TODO\n+    } // getAccessibleRelationSet()\n+\n+    /**\n+     * getAccessibleAction\n+     * @returns AccessibleAction\n+     */\n+    public AccessibleAction getAccessibleAction() {\n+      return null; // TODO\n+    } // getAccessibleAction()\n+\n+    /**\n+     * getAccessibleValue\n+     * @returns AccessibleValue\n+     */\n+    public AccessibleValue getAccessibleValue() {\n+      return null; // TODO\n+    } // getAccessibleValue()\n+\n+    /**\n+     * getAccessibleActionCount\n+     * @returns int\n+     */\n+    public int getAccessibleActionCount() {\n+      return 0; // TODO\n+    } // getAccessibleActionCount()\n+\n+    /**\n+     * getAccessibleActionDescription\n+     * @param value0 TODO\n+     * @returns String\n+     */\n+    public String getAccessibleActionDescription(int value0) {\n+      return null; // TODO\n+    } // getAccessibleActionDescription()\n+\n+    /**\n+     * doAccessibleAction\n+     * @param value0 TODO\n+     * @returns boolean\n+     */\n+    public boolean doAccessibleAction(int value0) {\n+      return false; // TODO\n+    } // doAccessibleAction()\n+\n+    /**\n+     * getCurrentAccessibleValue\n+     * @returns Number\n+     */\n+    public Number getCurrentAccessibleValue() {\n+      return null; // TODO\n+    } // getCurrentAccessibleValue()\n+\n+    /**\n+     * setCurrentAccessibleValue\n+     * @param value0 TODO\n+     * @returns boolean\n+     */\n+    public boolean setCurrentAccessibleValue(Number value0) {\n+      return false; // TODO\n+    } // setCurrentAccessibleValue()\n+\n+    /**\n+     * getMinimumAccessibleValue\n+     * @returns Number\n+     */\n+    public Number getMinimumAccessibleValue() {\n+      return null; // TODO\n+    } // getMinimumAccessibleValue()\n+\n+    /**\n+     * getMaximumAccessibleValue\n+     * @returns Number\n+     */\n+    public Number getMaximumAccessibleValue() {\n+      return null; // TODO\n+    } // getMaximumAccessibleValue()\n+\n+    /**\n+     * getAccessibleText\n+     * @returns AccessibleText\n+     */\n+    public AccessibleText getAccessibleText() {\n+      return null; // TODO\n+    } // getAccessibleText()\n+\n+    /**\n+     * getIndexAtPoint\n+     * @param value0 TODO\n+     * @returns int\n+     */\n+    public int getIndexAtPoint(Point value0) {\n+      return 0; // TODO\n+    } // getIndexAtPoint()\n+\n+    /**\n+     * getCharacterBounds\n+     * @param value0 TODO\n+     * @returns Rectangle\n+     */\n+    public Rectangle getCharacterBounds(int value0) {\n+      return null; // TODO\n+    } // getCharacterBounds()\n+\n+    /**\n+     * getCharCount\n+     * @returns int\n+     */\n+    public int getCharCount() {\n+      return 0; // TODO\n+    } // getCharCount()\n+\n+    /**\n+     * getCaretPosition\n+     * @returns int\n+     */\n+    public int getCaretPosition() {\n+      return 0; // TODO\n+    } // getCaretPosition()\n+\n+    /**\n+     * getAtIndex\n+     * @param value0 TODO\n+     * @param value1 TODO\n+     * @returns String\n+     */\n+    public String getAtIndex(int value0, int value1) {\n+      return null; // TODO\n+    } // getAtIndex()\n+\n+    /**\n+     * getAfterIndex\n+     * @param value0 TODO\n+     * @param value1 TODO\n+     * @returns String\n+     */\n+    public String getAfterIndex(int value0, int value1) {\n+      return null; // TODO\n+    } // getAfterIndex()\n+\n+    /**\n+     * getBeforeIndex\n+     * @param value0 TODO\n+     * @param value1 TODO\n+     * @returns String\n+     */\n+    public String getBeforeIndex(int value0, int value1) {\n+      return null; // TODO\n+    } // getBeforeIndex()\n+\n+    /**\n+     * getCharacterAttribute\n+     * @param value0 TODO\n+     * @returns AttributeSet\n+     */\n+    public AttributeSet getCharacterAttribute(int value0) {\n+      return null; // TODO\n+    } // getCharacterAttribute()\n+\n+    /**\n+     * getSelectionStart\n+     * @returns int\n+     */\n+    public int getSelectionStart() {\n+      return 0; // TODO\n+    } // getSelectionStart()\n+\n+    /**\n+     * getSelectionEnd\n+     * @returns int\n+     */\n+    public int getSelectionEnd() {\n+      return 0; // TODO\n+    } // getSelectionEnd()\n+\n+    /**\n+     * getSelectedText\n+     * @returns String\n+     */\n+    public String getSelectedText() {\n+      return null; // TODO\n+    } // getSelectedText()\n+\n+    /**\n+     * getTextRectangle\n+     * @returns Rectangle\n+     */\n+    private Rectangle getTextRectangle() {\n+      return null; // TODO\n+    } // getTextRectangle()\n+\n+\n+  } // AccessibleAbstractButton\n+\n+\n+  static private class JFocusListener implements FocusListener\n+  {\n+    AbstractButton c;\n+\n+    JFocusListener(AbstractButton c)\n+    {\n+      this.c = c;\n+    }\n+\n+    public void focusLost(FocusEvent event)\n+    {\n+      c.getModel().setArmed(false);\n+\n+      System.out.println(\"LOST FOCUS\");\n+      if (c.isFocusPainted())\n+        {\n+          c.repaint();\n+        }\n+    }\n+    public void focusGained(FocusEvent event)\n+    {\n+      System.out.println(\"GAIN FOCUS\");\n+    }\n+  }\n+\n+  AbstractButton()\n+  {\n+    this(\"\",null);\n+  }\n+\n+  AbstractButton(String text,\n+                 Icon icon)\n+  {\n+    this.text    = text;\n+    setIcon(icon);\n+\n+    setAlignmentX(LEFT_ALIGNMENT);\n+    setAlignmentY(CENTER_ALIGNMENT);\n+\n+    addFocusListener( new JFocusListener(this) );\n+\n+    setModel(new DefaultButtonModel(this));\n+\n+    updateUI(); // get a proper ui\n+  }\n+\n+  public ButtonModel getModel()\n+  {\treturn model;    }\n+\n+  public void setModel(ButtonModel newModel)\n+  {\tmodel = newModel;    }\n+\n+  public String getActionCommand()\n+  {\treturn getModel().getActionCommand();    }\n+\n+  public void setActionCommand(String aCommand)\n+  {   getModel().setActionCommand(aCommand);   }\n+\n+  public void addActionListener(ActionListener l)\n+  {\tgetModel().addActionListener(l);    }\n+\n+  public void removeActionListener(ActionListener l)\n+  {\tgetModel().removeActionListener(l);    }\n+\n+  public void addChangeListener(ChangeListener l)\n+  {   getModel().addChangeListener(l);     }\n+\n+  public void removeChangeListener(ChangeListener l)\n+  {  getModel().removeChangeListener(l);    }\n+\n+  public void addItemListener(ItemListener l)\n+  {  getModel().addItemListener(l);    }\n+\n+  public void removeItemListener(ItemListener l)\n+  {  getModel().removeItemListener(l);  }\n+\n+  public int getHorizontalAlignment()\n+  {\treturn hori_align;    }\n+\n+  public int getHorizontalTextPosition()\n+  {\treturn hori_text_pos;    }\n+\n+  public int getVerticalAlignment()\n+  {\treturn vert_align;   }\n+\n+  public int getVerticalTextPosition()\n+  {\treturn vert_text_pos;  }\n+\n+  protected  void fireItemStateChanged(ItemEvent event)\n+  {\n+  }\n+  \n+  protected  void fireStateChanged(ChangeEvent event)\n+  {\n+  }\n+  \n+  protected void fireActionPerformed(ActionEvent event)\n+  {\n+  }\n+\n+  public void setVerticalAlignment(int alignment)\n+  {\tvert_align = alignment;    }\n+\n+  public void setHorizontalAlignment(int alignment)\n+  {   hori_align = alignment;   }\n+\n+  public void setVerticalTextPosition(int textPosition)\n+  {\tvert_text_pos = textPosition;    }\n+\n+  public void setHorizontalTextPosition(int textPosition)\n+  {   hori_text_pos = textPosition;   }\n+\n+  public int getMnemonic()\n+  {\treturn getModel().getMnemonic();    }\n+\n+  public void setMnemonic(char mne)\n+  {\tgetModel().setMnemonic(mne);    }\n+\n+  public void setMnemonic(int mne)\n+  {\tgetModel().setMnemonic(mne);    }\n+\n+  public void setRolloverEnabled(boolean b)\n+  {    getModel().setRollover(b);    }\n+\n+  public boolean isRolloverEnabled()\n+  {    return getModel().isRollover();     }\n+\n+  public boolean isBorderPainted()\n+  {\treturn paint_border;    }\n+\n+  public void setBorderPainted(boolean b)\n+  {\n+    if (b != paint_border)\n+      {\n+        paint_border = b;\n+        revalidate();\n+        repaint();\n+      }\n+  }\n+\n+  public Action getAction()\n+  {\treturn action_taken;    }\n+\n+  public void setAction(Action a)\n+  {\n+    action_taken = a;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  public void setSelected(boolean b)\n+  {\tgetModel().setSelected(b);    }\n+\n+  public boolean isSelected()\n+  {\treturn getModel().isSelected();     }\n+\n+  public Icon getIcon()\n+  {\treturn default_icon;    }\n+\n+  public void setIcon(Icon defaultIcon)\n+  {\n+    if (default_icon == defaultIcon)\n+      return;\n+\n+    default_icon = defaultIcon;\n+    if (default_icon != null)\n+      {\n+        // XXX FIXME - icons do not know their parent\n+        //  \t\t\tdefault_icon.setParent(this);\n+      }\n+    revalidate();\n+    repaint();\n+  }\n+\n+  public String getText()\n+  {\treturn text;    }\n+\n+  public void setLabel(String label)\n+  {\tsetText(label);    }\n+\n+  public String getLabel()\n+  {\treturn getText();    }\n+\n+  public void setText(String text)\n+  {\n+    this.text = text;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  public \tInsets getMargin()\n+  {      return margin; }\n+\n+  public void setMargin(Insets m)\n+  {\n+    margin = m;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  public void setEnabled(boolean b)\n+  {\n+    super.setEnabled(b);\n+    getModel().setEnabled(b);\n+    repaint();\n+  }\n+\n+  public Icon getPressedIcon()\n+  {\treturn pressed_button;    }\n+\n+  public void setPressedIcon(Icon pressedIcon)\n+  {\n+    pressed_button = pressedIcon;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  public Icon getDisabledIcon()\n+  {\treturn disabled_button;    }\n+\n+  public void setDisabledIcon(Icon disabledIcon)\n+  {\n+    disabled_button = disabledIcon;\n+    revalidate();\n+    repaint();\n+  }\n+\n+  public boolean isFocusPainted()\n+  {   return paint_focus;   }\n+\n+  public void setFocusPainted(boolean b)\n+  {\n+    boolean old = paint_focus;\n+    paint_focus = b;\n+\n+    firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY,\n+                       old,\n+                       b);\n+    if (hasFocus())\n+      {\n+        revalidate();\n+        repaint();\n+      }\n+  }\n+\n+  public boolean isFocusTraversable()\n+  {\n+    //Identifies whether or not this component can receive the focus.\n+    return true;\n+  }\n+\n+\n+  protected  int checkHorizontalKey(int key, String exception)\n+  {\n+    //       Verify that key is a legal value for the horizontalAlignment properties.\n+    return 0;\n+  }\n+\n+  protected  int checkVerticalKey(int key, String exception)\n+  {\n+    //       Ensures that the key is a valid.\n+    return 0;\n+  }\n+\n+  protected  void configurePropertiesFromAction(Action a)\n+  {\n+    //Factory method which sets the ActionEvent source's properties according to values from the Action instance.\n+  }\n+\n+  protected  ActionListener createActionListener()\n+  {\n+    return new ActionListener()\n+      {\n+        public void actionPerformed(ActionEvent e) { }\n+      };\n+  }\n+\n+  protected  PropertyChangeListener createActionPropertyChangeListener(Action a)\n+  {\n+    //Factory method which creates the PropertyChangeListener used to update the ActionEvent source as properties change on its Action instance.\n+    return null;\n+  }\n+\n+  protected  ChangeListener createChangeListener()\n+  {\n+    //       Subclasses that want to handle ChangeEvents differently can override this to return another ChangeListener implementation.\n+    return new ChangeListener()\n+      {\n+        public void stateChanged(ChangeEvent e) { }\n+      };\n+  }\n+\n+  protected  ItemListener createItemListener()\n+  {\n+    return new ItemListener()\n+      {\n+        public void itemStateChanged(ItemEvent e) { }\n+      };\n+  }\n+\n+  public void doClick()\n+  {\n+    doClick(100);\n+  }\n+\n+  public void doClick(int pressTime)\n+  {\n+    //Toolkit.tlkBeep ();\n+    //Programmatically perform a \"click\".\n+  }\n+\n+  public Icon getDisabledSelectedIcon()\n+  {\n+    //Returns the icon used by the button when it's disabled and selected.\n+    return disabled_selected_button;\n+  }\n+\n+  public Icon getRolloverIcon()\n+  {\n+    //       Returns the rollover icon for the button.\n+    return null;\n+  }\n+\n+  Icon getRolloverSelectedIcon()\n+  {\n+    //       Returns the rollover selection icon for the button.\n+    return null;\n+  }\n+\n+  Icon getSelectedIcon()\n+  {\n+    //       Returns the selected icon for the button.\n+    return selected_button;\n+  }\n+\n+  public Object[] getSelectedObjects()\n+  {\n+    //Returns an array (length 1) containing the label or null if the button is not selected.\n+    return null;\n+  }\n+\n+  public boolean imageUpdate(Image img, int infoflags, int x, int y, int w, int h)\n+  {\n+    //This is overridden to return false if the current Icon's Image is not equal to the passed in Image img.\n+    return current_icon == img;\n+  }\n+\n+  public boolean isContentAreaFilled()\n+  {\n+    //       Checks whether the \"content area\" of the button should be filled.\n+    return false;\n+  }\n+\n+  protected  void paintBorder(Graphics g)\n+  {\n+    //       Paint the button's border if BorderPainted property is true.\n+    if (isBorderPainted())\n+      super.paintBorder(g);\n+  }\n+\n+  protected  String paramString()\n+  {\n+    //        Returns a string representation of this AbstractButton.\n+    return \"AbstractButton\";\n+  }\n+\n+  public void setContentAreaFilled(boolean b)\n+  {\n+    //Sets whether the button should paint the content area or leave it transparent.\n+  }\n+\n+  public void setDisabledSelectedIcon(Icon disabledSelectedIcon)\n+  {\n+    //          Sets the disabled selection icon for the button.\n+  }\n+\n+  public void setRolloverIcon(Icon rolloverIcon)\n+  {\n+    //       Sets the rollover icon for the button.\n+  }\n+  public void setRolloverSelectedIcon(Icon rolloverSelectedIcon)\n+  {\n+    //       Sets the rollover selected icon for the button.\n+  }\n+\n+  public void setSelectedIcon(Icon selectedIcon)\n+  {\n+    //       Sets the selected icon for the button.\n+  }\n+\n+  public void setUI(ButtonUI ui)\n+  {\t//       Sets the L&F object that renders this component.\n+    super.setUI(ui);\n+  }\n+\n+  public ButtonUI getUI()\n+  {\n+    //Returns the L&F object that renders this component.\n+    return (ButtonUI) ui;\n+  }\n+\n+  public void updateUI()\n+  {\n+    /*\n+    //          Notification from the UIFactory that the L&F has changed.\n+    if (getUI() == null)\n+    {\n+    setUI(getUI());\n+    }\n+    */\n+  }\n+\n+  protected void processActionEvent(ActionEvent e)\n+  {\n+    System.out.println(\"PROCESS-ACTION-EVENT: \" + e);\n+  }\n+\n+  protected void processMouseEvent(MouseEvent e)\n+  {\n+    //\tSystem.out.println(\"PROCESS-MOUSE-EVENT: \" + e + \", PRESSED-IN-MODEL=\"+getModel().isPressed());\n+\n+    switch (e.getID())\n+      {\n+      case MouseEvent.MOUSE_MOVED:\n+        {\n+          break;\n+        }\n+      case MouseEvent.MOUSE_PRESSED:\n+        {\n+          if (! isEnabled())\n+            {\n+              System.out.println(\"button not enabled, ignoring press\");\n+            }\n+          else\n+            {\n+              System.out.println(\"telling model:press: \" + getModel());\n+              getModel().setPressed(true);\n+              repaint();\n+            }\n+          break;\n+        }\n+\n+      case MouseEvent.MOUSE_RELEASED:\n+        {\n+          if (! isEnabled())\n+            {\n+              System.out.println(\"button not enabled, ignoring release\");\n+            }\n+          else\n+            {\n+              int flags = 0;\n+\n+              System.out.println(\"        XXX--> \" + getActionCommand());\n+\n+              fireActionPerformed(new ActionEvent(this,\n+                                                  ActionEvent.ACTION_PERFORMED,\n+                                                  getActionCommand(),\n+                                                  flags));\n+\n+              //System.out.println(\"telling model:release\");\n+              getModel().setPressed(false);\n+              repaint();\n+            }\n+          break;\n+        }\n+      case MouseEvent.MOUSE_CLICKED:\n+        {\n+          break;\n+        }\n+      }\n+  }\n }"}, {"sha": "ae0c721003b6f96eec36c91ba19f1f154215d6d9", "filename": "libjava/javax/swing/ButtonModel.java", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2FButtonModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2FButtonModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FButtonModel.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -76,12 +76,4 @@ public interface ButtonModel extends ItemSelectable\n \n     void setSelected(boolean b);\n     boolean isSelected();\n-\n-\n-    // there are not in the spec !!\n-\n-\n-    void fireItemStateChanged(ItemEvent event);\n-    void fireStateChanged(ChangeEvent event);    \n-    void fireActionPerformed(ActionEvent event);\n }"}, {"sha": "a9113f0ff406b4e472096b0c5d9eb48aa798e033", "filename": "libjava/javax/swing/SwingUtilities.java", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2FSwingUtilities.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FSwingUtilities.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -58,70 +58,71 @@\n public class SwingUtilities implements SwingConstants\n {\n   public static FontMetrics getFontMetrics (Font font)\n-{\n-\treturn Toolkit.getDefaultToolkit().getFontMetrics(font);\n-    }\n+  {\n+    return Toolkit.getDefaultToolkit ().getFontMetrics (font);\n+  }\n \n   public static JRootPane getRootPane (Component a)\n-    {\n-\tif (a instanceof JRootPane)\n-\t    return (JRootPane) a;\n+  {\n+    if (a instanceof JRootPane)\n+      return (JRootPane) a;\n \t\n-\ta = a.getParent();\n-\n-\tif (a != null)\n-\t    {\n-\t\treturn getRootPane(a);\n-\t    }\n+    a = a.getParent();\n \n-\treturn null;\n-    }\n+    if (a != null)\n+      {\n+        return getRootPane(a);\n+      }\n+    \n+    return null;\n+  }\n \n   public static void updateComponentTreeUI(JFrame comp)\n-    {\n-    }\n+  {\n+  }\n \n   public static String layoutCompoundLabel(JComponent c, \n-\t\t\t\t\t     FontMetrics fm,\n-\t\t\t\t\t     String text,\n-\t\t\t\t\t     Icon i,\n-\t\t\t\t\t     int vert_a, \n-\t\t\t\t\t     int hor_i, \n-\t\t\t\t\t     int vert_text_pos,\n-\t\t\t\t\t     int hor_text_pos, \n-\t\t\t\t\t     Rectangle vr,\n-\t\t\t\t\t     Rectangle ir, \n-\t\t\t\t\t     Rectangle tr,\n-\t\t\t\t\t     int gap)\n-    {\n-\t// view rect 'vr' already ok, \n-\t// we need to compute ir (icon rect) and tr (text-rect)\n+                                           FontMetrics fm,\n+                                           String text,\n+                                           Icon i,\n+                                           int vert_a, \n+                                           int hor_i, \n+                                           int vert_text_pos,\n+                                           int hor_text_pos, \n+                                           Rectangle vr,\n+                                           Rectangle ir, \n+                                           Rectangle tr,\n+                                           int gap)\n+  {\n+    // view rect 'vr' already ok, \n+    // we need to compute ir (icon rect) and tr (text-rect)\n \t\n-\tint next_x = 0;//vr.x;\n-\tint next_y = 0;//vr.y;\n+    int next_x = 0;//vr.x;\n+    int next_y = 0;//vr.y;\n \t\n-\tir.height = ir.width = ir.y = ir.x = 0;\n+    ir.height = ir.width = ir.y = ir.x = 0;\n \n-\tif (i != null)\n-\t    {\n-\t\tir.x = vr.x;\n-\t\tir.y = vr.y;\n-\t\tir.width = i.getIconWidth();\n-\t\tir.height = i.getIconWidth();\n+    if (i != null)\n+      {\n+        ir.x = vr.x;\n+        ir.y = vr.y;\n+        ir.width = i.getIconWidth();\n+        ir.height = i.getIconWidth();\n \n \n-\t\tnext_x += gap + i.getIconWidth();\n-\t\tnext_y += gap + i.getIconHeight();\n-\t    }\n+        next_x += gap + i.getIconWidth();\n+        next_y += gap + i.getIconHeight();\n+      }\n \t\n-\ttr.x = next_x;\n-\ttr.y = vr.y + (vr.height/2);\n+    tr.x = next_x;\n+    tr.y = vr.y + (vr.height/2);\n+\n+    tr.width  = fm.stringWidth(text);\n+    tr.height = fm.getHeight() +  fm.getAscent()/2;\n \n-\ttr.width  = fm.stringWidth(text);\n-\ttr.height = fm.getHeight() +  fm.getAscent()/2;\n+    return text;\n+  }\n \n-\treturn text;\n-    }\n }\n \n "}, {"sha": "7defebd2b095b4fe9c6ab84f6dfe8ffb19f942d6", "filename": "libjava/javax/swing/UIManager.java", "status": "modified", "additions": 195, "deletions": 194, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2FUIManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2FUIManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FUIManager.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -50,131 +50,137 @@\n \n public class UIManager implements Serializable\n {\n-  static final long serialVersionUID = -5547433830339189365L;\n-\n-    static class LookAndFeelInfo\n-    {\n-\tString name, clazz;\n+  public static class LookAndFeelInfo\n+  {\n+    String name, clazz;\n \t\n-\tLookAndFeelInfo(String name, \n-\t\t\tString clazz)\n-\t{\n-\t    this.name  = name;\n-\t    this.clazz = clazz;\n-\t}\n-\tString getName()      { return name;  }\n-\tString getClassName() { return clazz; }\n+    LookAndFeelInfo(String name, \n+                    String clazz)\n+    {\n+      this.name  = name;\n+      this.clazz = clazz;\n     }\n \n-    \n-    static LookAndFeelInfo [] installed = {\n-\tnew LookAndFeelInfo(\"Metal\",\n-\t\t\t    \"javax.swing.plaf.metal.MetalLookAndFeel\")\n-    };\n+    String getName()      { return name;  }\n+    String getClassName() { return clazz; }\n+  }\n \n+  private static final long serialVersionUID = -5547433830339189365L;\n+\n+  static LookAndFeelInfo [] installed = {\n+    new LookAndFeelInfo (\"Metal\", \"javax.swing.plaf.metal.MetalLookAndFeel\")\n+  };\n+\n+  static LookAndFeel[] aux_installed;\n+  \n+  static LookAndFeel look_and_feel = new MetalLookAndFeel();\n     \n-    static LookAndFeel[] aux_installed;\n-    \n-    static LookAndFeel look_and_feel  = new MetalLookAndFeel();\n-    \n+  public UIManager()\n+  {\n+    // Do nothing here.\n+  }\n \n-    UIManager()\n-    {\n-    }\n+  public static void addPropertyChangeListener (PropertyChangeListener listener)\n+  {\n+    // FIXME\n+  }\n \n-    public static  void addPropertyChangeListener(PropertyChangeListener listener)\n-    {\n-\t//      Add a PropertyChangeListener to the listener list. \n-    }\n+  public static void removePropertyChangeListener (PropertyChangeListener listener)\n+    // Remove a PropertyChangeListener from the listener list. \n+  {\n+    // FIXME\n+  }\n \n-    public static  void addAuxiliaryLookAndFeel(LookAndFeel l)\n-    {\n-\t//          Add a LookAndFeel to the list of auxiliary look and feels. \n-\tif (aux_installed == null)\n-\t    {\n-\t\taux_installed = new LookAndFeel[1];\n-\t\taux_installed[0] = l;\n-\t\treturn;\n-\t    }\n+  /**\n+   * @since 1.4\n+   */\n+  public static PropertyChangeListener[] getPropertyChangeListeners ()\n+  {\n+    // FIXME\n+    throw new Error (\"Not implemented\");\n+  }\n+\n+  public static void addAuxiliaryLookAndFeel (LookAndFeel l)\n+  {\n+    // Add a LookAndFeel to the list of auxiliary look and feels. \n+    if (aux_installed == null)\n+      {\n+        aux_installed = new LookAndFeel[1];\n+        aux_installed[0] = l;\n+        return;\n+      }\n \t\n-\tLookAndFeel[] T = new LookAndFeel[ aux_installed.length+1 ];\n-\tSystem.arraycopy(aux_installed, 0,\n-\t\t\t T,             0,\n-\t\t\t aux_installed.length);\t\t\t \n-\taux_installed = T;\n-\taux_installed[aux_installed.length-1] = l;\n-    }\n+    LookAndFeel[] T = new LookAndFeel[ aux_installed.length+1 ];\n+    System.arraycopy(aux_installed, 0, T, 0, aux_installed.length);\t\t\t \n+    aux_installed = T;\n+    aux_installed[aux_installed.length-1] = l;\n+  }\n     \n-    public static  boolean removeAuxiliaryLookAndFeel(LookAndFeel laf)\n-    {\n-\tif (aux_installed == null)\n-\t    return false;\n-\n-\tfor (int i=0;i<aux_installed.length;i++)\n-\t    {\n-\t\tif (aux_installed[i] == laf)\n-\t\t    {\n-\t\t\taux_installed[ i ] = aux_installed[aux_installed.length-1];\n-\t\t\t\n-\t\t\tLookAndFeel[] T = new LookAndFeel[ aux_installed.length-1 ];\n-\t\t\tSystem.arraycopy(aux_installed, 0,\n-\t\t\t\t\t T,             0,\n-\t\t\t\t\t aux_installed.length-1);\t\t\t \n-\t\t\taux_installed = T;\n-\t\t\treturn true;\n-\t\t    }\t\t\n-\t    }\n-\treturn false;\n-    }\n-\n-    public static  LookAndFeel[] getAuxiliaryLookAndFeels()\n-    {\treturn aux_installed;    }\n+  public static boolean removeAuxiliaryLookAndFeel(LookAndFeel laf)\n+  {\n+    if (aux_installed == null)\n+      return false;\n+\n+    for (int i=0;i<aux_installed.length;i++)\n+      {\n+        if (aux_installed[i] == laf)\n+          {\n+            aux_installed[ i ] = aux_installed[aux_installed.length-1];\n+            LookAndFeel[] T = new LookAndFeel[ aux_installed.length-1 ];\n+            System.arraycopy (aux_installed, 0, T, 0, aux_installed.length-1);\n+            aux_installed = T;\n+            return true;\n+          }\t\t\n+      }\n+    return false;\n+  }\n \n+  public static  LookAndFeel[] getAuxiliaryLookAndFeels()\n+  {\treturn aux_installed;    }\n \n-    public static  Object get(Object key)\n-    {\treturn getLookAndFeel().getDefaults().get(key);    }\n+  public static  Object get(Object key)\n+  {\treturn getLookAndFeel().getDefaults().get(key);    }\n     \n-    /**\n-     * Returns a border from the defaults table. \n-     */\n-    public static  Border getBorder(Object key)\n-    {\n-\treturn (Border) getLookAndFeel().getDefaults().get(key);\n-    }\n+  /**\n+   * Returns a border from the defaults table. \n+   */\n+  public static Border getBorder(Object key)\n+  {\n+    return (Border) getLookAndFeel().getDefaults().get(key);\n+  }\n     \n-    /**\n-     * Returns a drawing color from the defaults table. \n-     */\n-    public static  Color getColor(Object key)\n-    {\n-\treturn (Color) getLookAndFeel().getDefaults().get(key);\n-    }\n-\n-    /**\n-     * this string can be passed to Class.forName()\n-     */\n-    public static  String getCrossPlatformLookAndFeelClassName()\n-    {\t\n-\treturn \"javax.swing.plaf.metal.MetalLookAndFeel\";\n-    }\n+  /**\n+   * Returns a drawing color from the defaults table. \n+   */\n+  public static  Color getColor(Object key)\n+  {\n+    return (Color) getLookAndFeel().getDefaults().get(key);\n+  }\n \n-    /**\n-     * Returns the default values for this look and feel. \n-     */\n-    static  UIDefaults getDefaults()\n-    {\n-\treturn getLookAndFeel().getDefaults();\n-    }\n+  /**\n+   * this string can be passed to Class.forName()\n+   */\n+  public static  String getCrossPlatformLookAndFeelClassName()\n+  {\t\n+    return \"javax.swing.plaf.metal.MetalLookAndFeel\";\n+  }\n \n-    /**\n-     * Returns a dimension from the defaults table. \n-     */\n-    static  Dimension getDimension(Object key)\n-    {\n-\tSystem.out.println(\"UIManager.getDim\");\n-\treturn new Dimension(200,100);\n-    }\n+  /**\n+   * Returns the default values for this look and feel. \n+   */\n+  static  UIDefaults getDefaults()\n+  {\n+    return getLookAndFeel().getDefaults();\n+  }\n \n+  /**\n+   * Returns a dimension from the defaults table. \n+   */\n+  static  Dimension getDimension(Object key)\n+  {\n+    System.out.println(\"UIManager.getDim\");\n+    return new Dimension(200,100);\n+  }\n \n   /**\n    * Retrieves a font from the defaults table of the current\n@@ -189,34 +195,35 @@ public static Font getFont(Object key)\n     return (Font) getLookAndFeel().getDefaults().get(key);\n   }\n \n-    static  Icon getIcon(Object key)\n-    //      Returns an Icon from the defaults table. \n-    {\n-\treturn (Icon) getLookAndFeel().getDefaults().get(key);\n-    }\n-    static  Insets getInsets(Object key)\n-    //      Returns an Insets object from the defaults table. \n-    {\n-\treturn (Insets) getLookAndFeel().getDefaults().getInsets(key);\n-    }\n+  static Icon getIcon(Object key)\n+    // Returns an Icon from the defaults table. \n+  {\n+    return (Icon) getLookAndFeel().getDefaults().get(key);\n+  }\n+  \n+  static Insets getInsets(Object key)\n+    // Returns an Insets object from the defaults table. \n+  {\n+    return (Insets) getLookAndFeel().getDefaults().getInsets(key);\n+  }\n \n-    static LookAndFeelInfo[] getInstalledLookAndFeels()\n-    {\n-\treturn installed;\n-    }\n+  static LookAndFeelInfo[] getInstalledLookAndFeels()\n+  {\n+    return installed;\n+  }\n \n-    static  int getInt(Object key)\n-    {\n-\tInteger x = (Integer) getLookAndFeel().getDefaults().get(key);\n-\tif (x == null)\n-\t    return 0;\n-\treturn x.intValue();\n-    }\n-    static  LookAndFeel getLookAndFeel()\n-    {\n-\treturn look_and_feel;\n-    }\n+  static  int getInt(Object key)\n+  {\n+    Integer x = (Integer) getLookAndFeel().getDefaults().get(key);\n+    if (x == null)\n+      return 0;\n+    return x.intValue();\n+  }\n \n+  static  LookAndFeel getLookAndFeel()\n+  {\n+    return look_and_feel;\n+  }\n \n   /**\n    * Returns the <code>UIDefaults</code> table of the currently active\n@@ -227,73 +234,67 @@ public static UIDefaults getLookAndFeelDefaults()\n     return getLookAndFeel().getDefaults();\n   }\n \n+  static String getString(Object key)\n+    // Returns a string from the defaults table. \n+  {\n+    return (String) getLookAndFeel().getDefaults().get(key);\n+  }\n+  \n+  static String getSystemLookAndFeelClassName()\n+    // Returns the name of the LookAndFeel class that implements the native systems look and feel if there is one, otherwise the name of the default cross platform LookAndFeel class. \n+  {\n+    return getCrossPlatformLookAndFeelClassName();\n+  }\n \n-    static  String getString(Object key)\n-    //      Returns a string from the defaults table. \n-    {\n-\treturn (String) getLookAndFeel().getDefaults().get(key);\n-    }\n-    static  String getSystemLookAndFeelClassName()\n-    //      Returns the name of the LookAndFeel class that implements the native systems look and feel if there is one, otherwise the name of the default cross platform LookAndFeel class. \n-    {\n-\treturn getCrossPlatformLookAndFeelClassName();\n-    }\n+  public static ComponentUI getUI(JComponent target)\n+    // Returns the L&F object that renders the target component. \n+  {\n+    ComponentUI ui = getDefaults().getUI(target);\n+    //System.out.println(\"GET-UI-> \" + ui + \", for \" + target);\n+    return ui;\n+  }\n \n+  public static void installLookAndFeel(String name, String className)\n+    // Creates a new look and feel and adds it to the current array. \n+  {\n+  }\n \n-    public static  ComponentUI getUI(JComponent target)\n-    //      Returns the L&F object that renders the target component. \n-    {\n-\tComponentUI ui = getDefaults().getUI(target);\n-\t//System.out.println(\"GET-UI-> \" + ui + \", for \" + target);\n-\treturn ui;\n-    }\n+  public static void installLookAndFeel(LookAndFeelInfo info)\n+    // Adds the specified look and feel to the current array and then calls setInstalledLookAndFeels(javax.swing.UIManager.LookAndFeelInfo[]). \n+  {\n+  }\n \n+  public static Object put(Object key, Object value)\n+    // Stores an object in the defaults table. \n+  {\n+    return getLookAndFeel().getDefaults().put(key,value);\n+  }\n \n-    public static  void installLookAndFeel(String name, String className)\n-    //      Creates a new look and feel and adds it to the current array. \n-    {\n-    }\n-    public static  void installLookAndFeel(LookAndFeelInfo info)\n-    //      Adds the specified look and feel to the current array and then calls setInstalledLookAndFeels(javax.swing.UIManager.LookAndFeelInfo[]). \n-    {\n-    }\n-    public static  Object put(Object key, Object value)\n-    //      Stores an object in the defaults table. \n-    {\n-\treturn getLookAndFeel().getDefaults().put(key,value);\n-    }\n-    public static  void removePropertyChangeListener(PropertyChangeListener listener)\n-    //      Remove a PropertyChangeListener from the listener list. \n-    {\n-    }\n-    public static  void setInstalledLookAndFeels(UIManager.LookAndFeelInfo[] infos)\n-    //      Replaces the current array of installed LookAndFeelInfos. \n-    {\n-    }\n-    public static  void setLookAndFeel(LookAndFeel newLookAndFeel)\n-    {\n-\tif (look_and_feel != null)\n-\t    look_and_feel.uninitialize();\n+  public static void setInstalledLookAndFeels(UIManager.LookAndFeelInfo[] infos)\n+    // Replaces the current array of installed LookAndFeelInfos. \n+  {\n+  }\n+  \n+  public static void setLookAndFeel(LookAndFeel newLookAndFeel)\n+  {\n+    if (look_and_feel != null)\n+      look_and_feel.uninitialize();\n \n-\t//      Set the current default look and feel using a LookAndFeel object. \n-\tlook_and_feel = newLookAndFeel;\n-\tlook_and_feel.initialize();\n+    // Set the current default look and feel using a LookAndFeel object. \n+    look_and_feel = newLookAndFeel;\n+    look_and_feel.initialize();\n \t\n-\t//\trevalidate();\n-\t//\trepaint();\n-    }\n-\n-    public static  void setLookAndFeel(String className)\n-        throws ClassNotFoundException, \n-               InstantiationException, \n-               IllegalAccessException,\n-\t       UnsupportedLookAndFeelException\n-    {\n-\t//          Set the current default look and feel using a class name.\n-\tClass c = Class.forName(className);\n-\tLookAndFeel a = (LookAndFeel) c.newInstance(); // throws class-cast-exception\n-\tsetLookAndFeel(a);\n-    }\n-\n+    //revalidate();\n+    //repaint();\n+  }\n \n+  public static void setLookAndFeel (String className)\n+    throws ClassNotFoundException, InstantiationException, IllegalAccessException,\n+    UnsupportedLookAndFeelException\n+  {\n+    //          Set the current default look and feel using a class name.\n+    Class c = Class.forName(className);\n+    LookAndFeel a = (LookAndFeel) c.newInstance(); // throws class-cast-exception\n+    setLookAndFeel(a);\n+  }\n }"}, {"sha": "43df7edffb9f23c11a90de409ed11d0d30eb0c1a", "filename": "libjava/javax/swing/colorchooser/DefaultColorSelectionModel.java", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultColorSelectionModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultColorSelectionModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fcolorchooser%2FDefaultColorSelectionModel.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -52,90 +52,90 @@\n public class DefaultColorSelectionModel \n   implements ColorSelectionModel, Serializable\n {\n-  static final long serialVersionUID = 580150227676302096L;\n-\n-\t//-------------------------------------------------------------\n-\t// Variables --------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * changeEvent\n-\t */\n-\tprotected transient ChangeEvent changeEvent;\n-\n-\t/**\n-\t * listenerList\n-\t */\n-\tprotected EventListenerList listenerList;\n-\n-\t/**\n-\t * selectedColor\n-\t */\n-\tprivate Color selectedColor;\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Initialization ---------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * Constructor DefaultColorSelectionModel\n-\t */\n-\tpublic DefaultColorSelectionModel() {\n-\t\t// TODO\n-\t} // DefaultColorSelectionModel()\n-\n-\t/**\n-\t * Constructor DefaultColorSelectionModel\n-\t * @param color TODO\n-\t */\n-\tpublic DefaultColorSelectionModel(Color color) {\n-\t\t// TODO\n-\t} // DefaultColorSelectionModel()\n-\n-\n-\t//-------------------------------------------------------------\n-\t// Methods ----------------------------------------------------\n-\t//-------------------------------------------------------------\n-\n-\t/**\n-\t * getSelectedColor\n-\t * @returns Color\n-\t */\n-\tpublic Color getSelectedColor() {\n-\t\treturn null; // TODO\n-\t} // getSelectedColor()\n-\n-\t/**\n-\t * setSelectedColor\n-\t * @param color TODO\n-\t */\n-\tpublic void setSelectedColor(Color color) {\n-\t\t// TODO\n-\t} // setSelectedColor()\n-\n-\t/**\n-\t * addChangeListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void addChangeListener(ChangeListener listener) {\n-\t\t// TODO\n-\t} // addChangeListener()\n-\n-\t/**\n-\t * removeChangeListener\n-\t * @param listener TODO\n-\t */\n-\tpublic void removeChangeListener(ChangeListener listener) {\n-\t\t// TODO\n-\t} // removeChangeListener()\n-\n-\t/**\n-\t * fireStateChanged\n-\t */\n-\tprotected void fireStateChanged() {\n-\t\t// TODO\n-\t} // fireStateChanged()\n-\n-\n-} // DefaultColorSelectionModel\n+  private static final long serialVersionUID = -8117143602864778804L;\n+\n+  private Color selectedColor;\n+\n+  protected transient ChangeEvent changeEvent = new ChangeEvent (this);\n+  protected EventListenerList listenerList = new EventListenerList ();\n+\n+  /**\n+   * Creates a new color selection model.\n+   */\n+  public DefaultColorSelectionModel()\n+  {\n+    this (Color.white);\n+  }\n+\n+  /**\n+   * Creates a new color selection model with a given selected color.\n+   * \n+   * @param color The selected color.\n+   */\n+  public DefaultColorSelectionModel (Color color)\n+  {\n+    super();\n+    this.selectedColor = color;\n+  }\n+\n+  /**\n+   * Returns the selected color.\n+   * \n+   * @return The selected color.\n+   */\n+  public Color getSelectedColor()\n+  {\n+    return selectedColor;\n+  }\n+\n+  /**\n+   * @param color The color to set.\n+   */\n+  public void setSelectedColor (Color color)\n+  {\n+    this.selectedColor = color;\n+  }\n+\n+  /**\n+   * Adds a listener to this model.\n+   * \n+   * @param listener The listener to add.\n+   */\n+  public void addChangeListener (ChangeListener listener)\n+  {\n+    listenerList.add (ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * Removes a listener from this model.\n+   * \n+   * @param listener The listener to remove.\n+   */\n+  public void removeChangeListener (ChangeListener listener)\n+  {\n+    listenerList.remove (ChangeListener.class, listener);\n+  }\n+\n+  /**\n+   * Returns all currently added <code>ChangeListener</code> objects.\n+   *\n+   * @return Array of <code>ChangeListener</code> objects.\n+   */\n+  public ChangeListener[] getChangeListeners()\n+  {\n+    return (ChangeListener[]) listenerList.getListeners (ChangeListener.class);\n+  }\n+\n+  /**\n+   * Calls all the <code>stateChanged()</code> method of all added\n+   * <code>ChangeListener</code> objects with <code>changeEvent</code>\n+   * as argument.\n+   */\n+  protected void fireStateChanged()\n+  {\n+    ChangeListener[] listeners = getChangeListeners();\n+\n+    for (int i = 0; i < listeners.length; i++)\n+      listeners [i].stateChanged (changeEvent);\n+  }\n+}"}, {"sha": "d62be28ba2913fbca454bad12986ab5991c1c466", "filename": "libjava/javax/swing/event/AncestorEvent.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2Fevent%2FAncestorEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2Fevent%2FAncestorEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fevent%2FAncestorEvent.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -50,9 +50,9 @@ public class AncestorEvent extends AWTEvent\n {\n   private static final long serialVersionUID = -8079801679695605002L;\n   \n-  public static final int ANCESTOR_ADDED = 0;\n-  public static final int ANCESTOR_MOVED = 1;\n+  public static final int ANCESTOR_ADDED = 1;\n   public static final int ANCESTOR_REMOVED = 2;\n+  public static final int ANCESTOR_MOVED = 3;\n \n   private JComponent sourceComponent;\n   private Container ancestor;"}, {"sha": "863fd292f88707462d55e4371496ef1773e02c8d", "filename": "libjava/javax/swing/event/InternalFrameEvent.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2Fevent%2FInternalFrameEvent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a71677713a891ed583f065f21e40e3d4d89562c/libjava%2Fjavax%2Fswing%2Fevent%2FInternalFrameEvent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2Fevent%2FInternalFrameEvent.java?ref=6a71677713a891ed583f065f21e40e3d4d89562c", "patch": "@@ -81,7 +81,7 @@ public class InternalFrameEvent extends AWTEvent\n   /**\n    * Internal frame iconified event\n    */\n-  public static final int INTERNAL_FRAME_ICONIFIED = 2552;\n+  public static final int INTERNAL_FRAME_ICONIFIED = 25552;\n \n   /**\n    * Internal frame last event\n@@ -91,7 +91,7 @@ public class InternalFrameEvent extends AWTEvent\n   /**\n    * Internal frame opened event\n    */\n-  public static final int INTERNAL_FRAME_OPENED = 25550;\n+  public static final int INTERNAL_FRAME_OPENED = 25549;\n \n   /**\n    * Creates a <code>JInternalFrameEvent</code> object."}]}