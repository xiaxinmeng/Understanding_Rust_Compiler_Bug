{"sha": "3674d8e6fc6305507ed50b501f049f25f868458a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY3NGQ4ZTZmYzYzMDU1MDdlZDUwYjUwMWYwNDlmMjVmODY4NDU4YQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-09-15T18:43:51Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-09-17T18:06:15Z"}, "message": "Virtualize relation oracle and various cleanups.\n\nStandardize equiv_oracle API onto the new relation_oracle virtual base, and\nthen have dom_oracle inherit from that.\nequiv_set always returns an equivalency set now, never NULL.\nEQ_EXPR requires symmetry now.  Each SSA name must be in the other equiv set.\nShuffle some routines around, simplify.\n\n\t* gimple-range-cache.cc (ranger_cache::ranger_cache): Create a DOM\n\tbased oracle.\n\t* gimple-range-fold.cc (fur_depend::register_relation): Use\n\tregister_stmt/edge routines.\n\t* value-relation.cc (equiv_chain::find): Relocate from equiv_oracle.\n\t(equiv_oracle::equiv_oracle): Create self equivalence cache.\n\t(equiv_oracle::~equiv_oracle): Release same.\n\t(equiv_oracle::equiv_set): Return entry from self equiv cache if there\n\tare no equivalences.\n\t(equiv_oracle::find_equiv_block): Move list find to equiv_chain.\n\t(equiv_oracle::register_relation): Rename from register_equiv.\n\t(relation_chain_head::find_relation): Relocate from dom_oracle.\n\t(relation_oracle::register_stmt): New.\n\t(relation_oracle::register_edge): New.\n\t(dom_oracle::*): Rename from relation_oracle.\n\t(dom_oracle::register_relation): Adjust to call equiv_oracle.\n\t(dom_oracle::set_one_relation): Split from register_relation.\n\t(dom_oracle::register_transitives): Consolidate 2 methods.\n\t(dom_oracle::find_relation_block): Move core to relation_chain.\n\t(dom_oracle::query_relation): Rename from find_relation_dom and adjust.\n\t* value-relation.h (class relation_oracle): New pure virtual base.\n\t(class equiv_oracle): Inherit from relation_oracle and adjust.\n\t(class dom_oracle): Rename from old relation_oracle and adjust.", "tree": {"sha": "b49fd671aec6bc4968383f0a6eaf076b369a1bdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b49fd671aec6bc4968383f0a6eaf076b369a1bdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3674d8e6fc6305507ed50b501f049f25f868458a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3674d8e6fc6305507ed50b501f049f25f868458a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3674d8e6fc6305507ed50b501f049f25f868458a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3674d8e6fc6305507ed50b501f049f25f868458a/comments", "author": null, "committer": null, "parents": [{"sha": "896fec24c8ef59b3520f5ded69dcd5bcf643c1f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/896fec24c8ef59b3520f5ded69dcd5bcf643c1f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/896fec24c8ef59b3520f5ded69dcd5bcf643c1f9"}], "stats": {"total": 384, "additions": 206, "deletions": 178}, "files": [{"sha": "fbf0f95eef90203d65d9bbfc150d5c0e449933fc", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3674d8e6fc6305507ed50b501f049f25f868458a/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3674d8e6fc6305507ed50b501f049f25f868458a/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=3674d8e6fc6305507ed50b501f049f25f868458a", "patch": "@@ -760,7 +760,7 @@ ranger_cache::ranger_cache ()\n   m_temporal = new temporal_cache;\n   // If DOM info is available, spawn an oracle as well.\n   if (dom_info_available_p (CDI_DOMINATORS))\n-      m_oracle = new relation_oracle ();\n+      m_oracle = new dom_oracle ();\n     else\n       m_oracle = NULL;\n "}, {"sha": "997d02dd4b99de85ed800f471946b783cd907da5", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3674d8e6fc6305507ed50b501f049f25f868458a/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3674d8e6fc6305507ed50b501f049f25f868458a/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=3674d8e6fc6305507ed50b501f049f25f868458a", "patch": "@@ -195,7 +195,7 @@ void\n fur_depend::register_relation (gimple *s, relation_kind k, tree op1, tree op2)\n {\n   if (m_oracle)\n-    m_oracle->register_relation (s, k, op1, op2);\n+    m_oracle->register_stmt (s, k, op1, op2);\n }\n \n // Register a relation on an edge if there is an oracle.\n@@ -204,7 +204,7 @@ void\n fur_depend::register_relation (edge e, relation_kind k, tree op1, tree op2)\n {\n   if (m_oracle)\n-    m_oracle->register_relation (e, k, op1, op2);\n+    m_oracle->register_edge (e, k, op1, op2);\n }\n \n // This version of fur_source will pick a range up from a list of ranges"}, {"sha": "3e077d38a110291bb2442231fe4e9b881840e424", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 159, "deletions": 157, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3674d8e6fc6305507ed50b501f049f25f868458a/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3674d8e6fc6305507ed50b501f049f25f868458a/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=3674d8e6fc6305507ed50b501f049f25f868458a", "patch": "@@ -199,7 +199,7 @@ relation_transitive (relation_kind r1, relation_kind r2)\n // This allows for much faster traversal of the DOM chain, as a search for\n // SSA_NAME simply requires walking the DOM chain until a block is found\n // which has the bit for SSA_NAME set. Then scan for the equivalency set in\n-// that block.   No previous blcoks need be searched.\n+// that block.   No previous lists need be searched.\n \n class equiv_chain\n {\n@@ -208,8 +208,26 @@ class equiv_chain\n   basic_block m_bb;\t\t// Block this belongs to\n   equiv_chain *m_next;\t\t// Next in block list.\n   void dump (FILE *f) const;\t// Show names in this list.\n+  equiv_chain *find (unsigned ssa);\n };\n \n+// If SSA has an equivalence in this list, find and return it.\n+// Otherwise return NULL.\n+\n+equiv_chain *\n+equiv_chain::find (unsigned ssa)\n+{\n+  equiv_chain *ptr = NULL;\n+  // If there are equiv sets and SSA is in one in this list, find it.\n+  // Otherwise return NULL.\n+  if (bitmap_bit_p (m_names, ssa))\n+    {\n+      for (ptr = m_next; ptr; ptr = ptr->m_next)\n+\tif (bitmap_bit_p (ptr->m_names, ssa))\n+\t  break;\n+    }\n+  return ptr;\n+}\n \n // Dump the names in this equivalence set.\n \n@@ -244,12 +262,15 @@ equiv_oracle::equiv_oracle ()\n   m_equiv.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n   m_equiv_set = BITMAP_ALLOC (&m_bitmaps);\n   obstack_init (&m_chain_obstack);\n+  m_self_equiv.create (0);\n+  m_self_equiv.safe_grow_cleared (num_ssa_names + 1);\n }\n \n // Destruct an equivalency oracle.\n \n equiv_oracle::~equiv_oracle ()\n {\n+  m_self_equiv.release ();\n   obstack_free (&m_chain_obstack, NULL);\n   m_equiv.release ();\n   bitmap_obstack_release (&m_bitmaps);\n@@ -259,36 +280,59 @@ equiv_oracle::~equiv_oracle ()\n // This is the external API.\n \n const_bitmap\n-equiv_oracle::equiv_set (tree ssa, basic_block bb) const\n+equiv_oracle::equiv_set (tree ssa, basic_block bb)\n {\n   // Search the dominator tree for an equivalency.\n   equiv_chain *equiv = find_equiv_dom (ssa, bb);\n   if (equiv)\n     return equiv->m_names;\n \n-  return NULL;\n+  // Otherwise return a cached equiv set containing just this SSA.\n+  unsigned v = SSA_NAME_VERSION (ssa);\n+  if (v >= m_self_equiv.length ())\n+    m_self_equiv.safe_grow_cleared (num_ssa_names + 1);\n+\n+  if (!m_self_equiv[v])\n+    {\n+      m_self_equiv[v] = BITMAP_ALLOC (&m_bitmaps);\n+      bitmap_set_bit (m_self_equiv[v], v);\n+    }\n+  return m_self_equiv[v];\n }\n \n+// Query if thre is a relation (equivalence) between 2 SSA_NAMEs.\n+\n+relation_kind\n+equiv_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n+{\n+  // If the 2 ssa names share the same equiv set, they are equal.\n+  if (equiv_set (ssa1, bb) == equiv_set (ssa2, bb))\n+    return EQ_EXPR;\n+  return VREL_NONE;\n+}\n+\n+// Query if thre is a relation (equivalence) between 2 SSA_NAMEs.\n+\n+relation_kind\n+equiv_oracle::query_relation (basic_block bb ATTRIBUTE_UNUSED, const_bitmap e1,\n+\t\t\t      const_bitmap e2)\n+{\n+  // If the 2 ssa names share the same equiv set, they are equal.\n+  if (bitmap_equal_p (e1, e2))\n+    return EQ_EXPR;\n+  return VREL_NONE;\n+}\n \n // If SSA has an equivalence in block BB, find and return it.\n // Otherwise return NULL.\n \n equiv_chain *\n equiv_oracle::find_equiv_block (unsigned ssa, int bb) const\n {\n-  equiv_chain *ptr = NULL;\n-  if (bb >= (int)m_equiv.length ())\n+  if (bb >= (int)m_equiv.length () || !m_equiv[bb])\n     return NULL;\n \n-  // If there are equiv sets and SSA is in one in this block, find it.\n-  // Otherwise return NULL.\n-  if (m_equiv[bb] && bitmap_bit_p (m_equiv[bb]->m_names, ssa))\n-    {\n-      for (ptr = m_equiv[bb]->m_next; ptr; ptr = ptr->m_next)\n-\tif (bitmap_bit_p (ptr->m_names, ssa))\n-\t  break;\n-    }\n-  return ptr;\n+  return m_equiv[bb]->find (ssa);\n }\n \n // Starting at block BB, walk the dominator chain looking for the nearest\n@@ -385,8 +429,13 @@ equiv_oracle::register_equiv (basic_block bb, equiv_chain *equiv_1,\n // containing all the ssa_names in this basic block.\n \n void\n-equiv_oracle::register_equiv (basic_block bb, tree ssa1, tree ssa2)\n+equiv_oracle::register_relation (basic_block bb, relation_kind k, tree ssa1,\n+\t\t\t\t tree ssa2)\n {\n+  // Only handle equality relations.\n+  if (k != EQ_EXPR)\n+    return;\n+\n   unsigned v1 = SSA_NAME_VERSION (ssa1);\n   unsigned v2 = SSA_NAME_VERSION (ssa2);\n   equiv_chain *equiv_1 = find_equiv_dom (ssa1, bb);\n@@ -681,9 +730,37 @@ class relation_chain : public value_relation\n \n // ------------------------------------------------------------------------\n \n+// Find the relation between any ssa_name in B1 and any name in B2 in LIST.\n+// This will allow equivalencies to be applied to any SSA_NAME in a relation.\n+\n+relation_kind\n+relation_chain_head::find_relation (const_bitmap b1, const_bitmap b2) const\n+{\n+  if (!m_names)\n+    return VREL_NONE;\n+\n+  // If both b1 and b2 aren't referenced in thie block, cant be a relation\n+  if (!bitmap_intersect_p (m_names, b1) || !bitmap_intersect_p (m_names, b2))\n+    return VREL_NONE;\n+\n+  // Search for the fiorst relation that contains BOTH an element from B1\n+  // and B2, and return that relation.\n+  for (relation_chain *ptr = m_head; ptr ; ptr = ptr->m_next)\n+    {\n+      unsigned op1 = SSA_NAME_VERSION (ptr->op1 ());\n+      unsigned op2 = SSA_NAME_VERSION (ptr->op2 ());\n+      if (bitmap_bit_p (b1, op1) && bitmap_bit_p (b2, op2))\n+\treturn ptr->kind ();\n+      if (bitmap_bit_p (b1, op2) && bitmap_bit_p (b2, op1))\n+\treturn relation_swap (ptr->kind ());\n+    }\n+\n+  return VREL_NONE;\n+}\n+\n // Instantiate a relation oracle.\n \n-relation_oracle::relation_oracle ()\n+dom_oracle::dom_oracle ()\n {\n   m_relations.create (0);\n   m_relations.safe_grow_cleared (last_basic_block_for_fn (cfun) + 1);\n@@ -694,16 +771,16 @@ relation_oracle::relation_oracle ()\n \n // Destruct a relation oracle.\n \n-relation_oracle::~relation_oracle ()\n+dom_oracle::~dom_oracle ()\n {\n   m_relations.release ();\n }\n \n // Register relation K between ssa_name OP1 and OP2 on STMT.\n \n void\n-relation_oracle::register_relation (gimple *stmt, relation_kind k, tree op1,\n-\t\t\t\t    tree op2)\n+relation_oracle::register_stmt (gimple *stmt, relation_kind k, tree op1,\n+\t\t\t\ttree op2)\n {\n   gcc_checking_assert (TREE_CODE (op1) == SSA_NAME);\n   gcc_checking_assert (TREE_CODE (op2) == SSA_NAME);\n@@ -722,19 +799,13 @@ relation_oracle::register_relation (gimple *stmt, relation_kind k, tree op1,\n       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n     }\n \n-  // This relation applies to the entire block, use STMT's block.\n-  // Equivalencies are handled by the equivalence oracle.\n-  if (k == EQ_EXPR)\n-    register_equiv (gimple_bb (stmt), op1, op2);\n-  else\n-    register_relation (gimple_bb (stmt), k, op1, op2);\n+  register_relation (gimple_bb (stmt), k, op1, op2);\n }\n \n // Register relation K between ssa_name OP1 and OP2 on edge E.\n \n void\n-relation_oracle::register_relation (edge e, relation_kind k, tree op1,\n-\t\t\t\t    tree op2)\n+relation_oracle::register_edge (edge e, relation_kind k, tree op1, tree op2)\n {\n   gcc_checking_assert (TREE_CODE (op1) == SSA_NAME);\n   gcc_checking_assert (TREE_CODE (op2) == SSA_NAME);\n@@ -752,24 +823,35 @@ relation_oracle::register_relation (edge e, relation_kind k, tree op1,\n       fprintf (dump_file, \" on (%d->%d)\\n\", e->src->index, e->dest->index);\n     }\n \n-  // Equivalencies are handled by the equivalence oracle.\n+  register_relation (e->dest, k, op1, op2);\n+}\n+\n+// Register relation K between OP! and OP2 in block BB.\n+// This creates the record and searches for existing records in the dominator\n+// tree to merge with.\n+\n+void\n+dom_oracle::register_relation (basic_block bb, relation_kind k, tree op1,\n+\t\t\t       tree op2)\n+{  // Equivalencies are handled by the equivalence oracle.\n   if (k == EQ_EXPR)\n-    register_equiv (e->dest, op1, op2);\n+    equiv_oracle::register_relation (bb, k, op1, op2);\n   else\n-    register_relation (e->dest, k, op1, op2);\n+    {\n+      relation_chain *ptr = set_one_relation (bb, k, op1, op2);\n+      register_transitives (bb, *ptr);\n+    }\n }\n \n // Register relation K between OP! and OP2 in block BB.\n // This creates the record and searches for existing records in the dominator\n // tree to merge with.\n-// TRANSITIVE_P is true if this is being registered as a transitive operation,\n-// and should not try to register further transitives.\n \n-void\n-relation_oracle::register_relation (basic_block bb, relation_kind k, tree op1,\n-\t\t\t\t    tree op2, bool transitive_p)\n+relation_chain *\n+dom_oracle::set_one_relation (basic_block bb, relation_kind k, tree op1,\n+\t\t\t      tree op2)\n {\n-  gcc_checking_assert (k != VREL_NONE);\n+  gcc_checking_assert (k != VREL_NONE && k != EQ_EXPR);\n \n   value_relation vr(k, op1, op2);\n   int bbi = bb->index;\n@@ -824,11 +906,9 @@ relation_oracle::register_relation (basic_block bb, relation_kind k, tree op1,\n \t\t\t\t\t      sizeof (relation_chain));\n       ptr->set_relation (k, op1, op2);\n       ptr->m_next = m_relations[bbi].m_head;\n-      m_relations[bbi].m_head = ptr;;\n+      m_relations[bbi].m_head = ptr;\n     }\n-\n-  if (!transitive_p)\n-    register_transitives (bb, *ptr);\n+  return ptr;\n }\n \n // Starting at ROOT_BB search the DOM tree  looking for relations which\n@@ -837,12 +917,25 @@ relation_oracle::register_relation (basic_block bb, relation_kind k, tree op1,\n // considered.\n \n void\n-relation_oracle::register_transitives (basic_block root_bb,\n-\t\t\t\t       const value_relation &relation,\n-\t\t\t\t       const_bitmap equiv1,\n-\t\t\t\t       const_bitmap equiv2)\n+dom_oracle::register_transitives (basic_block root_bb,\n+\t\t\t\t  const value_relation &relation)\n {\n   basic_block bb;\n+  // Only apply transitives to certain kinds of operations.\n+  switch (relation.kind ())\n+    {\n+      case LE_EXPR:\n+      case LT_EXPR:\n+      case GT_EXPR:\n+      case GE_EXPR:\n+\tbreak;\n+      default:\n+\treturn;\n+    }\n+\n+  const_bitmap equiv1 = equiv_set (relation.op1 (), root_bb);\n+  const_bitmap equiv2 = equiv_set (relation.op2 (), root_bb);\n+\n   for (bb = root_bb; bb; bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n     {\n       int bbi = bb->index;\n@@ -897,8 +990,7 @@ relation_oracle::register_transitives (basic_block root_bb,\n \t  value_relation nr (relation.kind (), r1, r2);\n \t  if (nr.apply_transitive (*ptr))\n \t    {\n-\t      register_relation (root_bb, nr.kind (), nr.op1 (), nr.op2 (),\n-\t\t\t\t true);\n+\t      set_one_relation (root_bb, nr.kind (), nr.op1 (), nr.op2 ());\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n \t\t  fprintf (dump_file, \"   Registering transitive relation \");\n@@ -911,98 +1003,30 @@ relation_oracle::register_transitives (basic_block root_bb,\n     }\n }\n \n-// Find adn register any transitive relations implied by RELATION occuring\n-// in block BB.\n-\n-void\n-relation_oracle::register_transitives (basic_block bb,\n-\t\t\t\t       const value_relation &relation)\n-{\n-  // Only apply transitives to certain kinds of operations.\n-  switch (relation.kind ())\n-    {\n-      case LE_EXPR:\n-      case LT_EXPR:\n-      case GT_EXPR:\n-      case GE_EXPR:\n-\tbreak;\n-      default:\n-\treturn;\n-    }\n-\n-  // Set up the bitmaps for op1 and op2, and if there are no equivalencies,\n-  // set just op1 or op2 in their own bitmap.\n-  const_bitmap equiv1 = equiv_set (relation.op1 (), bb);\n-  const_bitmap equiv2 = equiv_set (relation.op2 (), bb);\n-  if (equiv1)\n-    {\n-      if (equiv2)\n-\tregister_transitives (bb, relation, equiv1, equiv2);\n-      else\n-\t{\n-\t  bitmap_clear (m_tmp);\n-\t  bitmap_set_bit (m_tmp, SSA_NAME_VERSION (relation.op2 ()));\n-\t  register_transitives (bb, relation, equiv1, m_tmp);\n-\t}\n-    }\n-  else if (equiv2)\n-    {\n-      bitmap_clear (m_tmp);\n-      bitmap_set_bit (m_tmp, SSA_NAME_VERSION (relation.op1 ()));\n-      register_transitives (bb, relation, m_tmp, equiv2);\n-    }\n-  else\n-    {\n-      bitmap_clear (m_tmp);\n-      bitmap_clear (m_tmp2);\n-      bitmap_set_bit (m_tmp, SSA_NAME_VERSION (relation.op1 ()));\n-      bitmap_set_bit (m_tmp2, SSA_NAME_VERSION (relation.op2 ()));\n-      register_transitives (bb, relation, m_tmp, m_tmp2);\n-    }\n-}\n-\n // Find the relation between any ssa_name in B1 and any name in B2 in block BB.\n // This will allow equivalencies to be applied to any SSA_NAME in a relation.\n \n relation_kind\n-relation_oracle::find_relation_block (unsigned bb, const_bitmap b1,\n-\t\t\t\t      const_bitmap b2)\n+dom_oracle::find_relation_block (unsigned bb, const_bitmap b1,\n+\t\t\t\t      const_bitmap b2) const\n {\n-  const_bitmap bm;\n   if (bb >= m_relations.length())\n     return VREL_NONE;\n \n-  bm = m_relations[bb].m_names;\n-  if (!bm)\n-    return VREL_NONE;\n-\n-  // If both b1 and b2 aren't referenced in thie block, cant be a relation\n-  if (!bitmap_intersect_p (bm, b1) || !bitmap_intersect_p (bm, b2))\n-    return VREL_NONE;\n-\n-  // Search for the fiorst relation that contains BOTH an element from B1\n-  // and B2, and return that relation.\n-  for (relation_chain *ptr = m_relations[bb].m_head; ptr ; ptr = ptr->m_next)\n-    {\n-      unsigned op1 = SSA_NAME_VERSION (ptr->op1 ());\n-      unsigned op2 = SSA_NAME_VERSION (ptr->op2 ());\n-      if (bitmap_bit_p (b1, op1) && bitmap_bit_p (b2, op2))\n-\treturn ptr->kind ();\n-      if (bitmap_bit_p (b1, op2) && bitmap_bit_p (b2, op1))\n-\treturn relation_swap (ptr->kind ());\n-    }\n-\n-  return VREL_NONE;\n+  return m_relations[bb].find_relation (b1, b2);\n }\n \n-// Search the DOM tree for a relation between an element of B1 and B2, starting\n-// with block BB.\n+// Search the DOM tree for a relation between an element of equivalency set B1\n+// and B2, starting with block BB.\n \n relation_kind\n-relation_oracle::find_relation_dom (basic_block bb, const_bitmap b1,\n-\t\t\t\t    const_bitmap b2)\n+dom_oracle::query_relation (basic_block bb, const_bitmap b1,\n+\t\t\t    const_bitmap b2)\n {\n   relation_kind r;\n+  if (bitmap_equal_p (b1, b2))\n+    return EQ_EXPR;\n+\n   // If either name does not occur in a relation anywhere, there isnt one.\n   if (!bitmap_intersect_p (m_relation_set, b1)\n       || !bitmap_intersect_p (m_relation_set, b2))\n@@ -1023,8 +1047,8 @@ relation_oracle::find_relation_dom (basic_block bb, const_bitmap b1,\n // is found, return a pointer to the chain object in OBJ.\n \n relation_kind\n-relation_oracle::find_relation_block (int bb, unsigned v1, unsigned v2,\n-\t\t\t\t     relation_chain **obj)\n+dom_oracle::find_relation_block (int bb, unsigned v1, unsigned v2,\n+\t\t\t\t     relation_chain **obj) const\n {\n   if (bb >= (int)m_relations.length())\n     return VREL_NONE;\n@@ -1063,7 +1087,7 @@ relation_oracle::find_relation_block (int bb, unsigned v1, unsigned v2,\n // starting with block BB\n \n relation_kind\n-relation_oracle::find_relation_dom (basic_block bb, unsigned v1, unsigned v2)\n+dom_oracle::find_relation_dom (basic_block bb, unsigned v1, unsigned v2) const\n {\n   relation_kind r;\n   // IF either name does not occur in a relation anywhere, there isnt one.\n@@ -1084,56 +1108,34 @@ relation_oracle::find_relation_dom (basic_block bb, unsigned v1, unsigned v2)\n // dominator of BB\n \n relation_kind\n-relation_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n+dom_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n {\n   relation_kind kind;\n   unsigned v1 = SSA_NAME_VERSION (ssa1);\n   unsigned v2 = SSA_NAME_VERSION (ssa2);\n   if (v1 == v2)\n     return EQ_EXPR;\n \n-  // Check for equivalence first.\n+  // Check for equivalence first.  They must be in each equivalency set.\n   const_bitmap equiv1 = equiv_set (ssa1, bb);\n-  if (equiv1 && bitmap_bit_p (equiv1, v2))\n+  const_bitmap equiv2 = equiv_set (ssa2, bb);\n+  if (bitmap_bit_p (equiv1, v2) && bitmap_bit_p (equiv2, v1))\n     return EQ_EXPR;\n \n   // Initially look for a direct relationship and just return that.\n   kind = find_relation_dom (bb, v1, v2);\n   if (kind != VREL_NONE)\n     return kind;\n \n-  // If v2 isn't in v1s equiv set, then v1 shouldn't be in v2's set either.\n-  // It is possible for out-of-order dominator processing to have an out of\n-  // sync set of equivalences..  Down the road, when we do full updates,\n-  // change this to an assert to ensure everything is in sync.\n-  const_bitmap equiv2 = equiv_set (ssa2, bb);\n-  if (equiv2 && bitmap_bit_p (equiv2, v1))\n-    return EQ_EXPR;\n-\n-  // If not equal, see if there is a relationship between equivalences.\n-  if (!equiv1 && !equiv2)\n-    kind = VREL_NONE;\n-  else if (!equiv1)\n-    {\n-      bitmap_clear (m_tmp);\n-      bitmap_set_bit (m_tmp, v1);\n-      kind = find_relation_dom (bb, m_tmp, equiv2);\n-    }\n-  else if (!equiv2)\n-    {\n-      bitmap_clear (m_tmp);\n-      bitmap_set_bit (m_tmp, v2);\n-      kind = find_relation_dom (bb, equiv1, m_tmp);\n-    }\n-  else\n-    kind = find_relation_dom (bb, equiv1, equiv2);\n+  // Query using the equiovalence sets.\n+  kind = query_relation (bb, equiv1, equiv2);\n   return kind;\n }\n \n // Dump all the relations in block BB to file F.\n \n void\n-relation_oracle::dump (FILE *f, basic_block bb) const\n+dom_oracle::dump (FILE *f, basic_block bb) const\n {\n   equiv_oracle::dump (f,bb);\n \n@@ -1154,7 +1156,7 @@ relation_oracle::dump (FILE *f, basic_block bb) const\n // Dump all the relations known to file F.\n \n void\n-relation_oracle::dump (FILE *f) const\n+dom_oracle::dump (FILE *f) const\n {\n   fprintf (f, \"Relation dump\\n\");\n   for (unsigned i = 0; i < m_relations.length (); i++)"}, {"sha": "323b1e6be8d4b77febe484351684aa22486bf099", "filename": "gcc/value-relation.h", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3674d8e6fc6305507ed50b501f049f25f868458a/gcc%2Fvalue-relation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3674d8e6fc6305507ed50b501f049f25f868458a/gcc%2Fvalue-relation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.h?ref=3674d8e6fc6305507ed50b501f049f25f868458a", "patch": "@@ -73,6 +73,31 @@ relation_kind relation_negate (relation_kind r);\n relation_kind relation_swap (relation_kind r);\n void print_relation (FILE *f, relation_kind rel);\n \n+\n+class relation_oracle\n+{\n+public:\n+  virtual ~relation_oracle () { }\n+  // register a relation between 2 ssa names at a stmt.\n+  void register_stmt (gimple *, relation_kind, tree, tree);\n+  // register a relation between 2 ssa names on an edge.\n+  void register_edge (edge, relation_kind, tree, tree);\n+\n+  // Return equivalency set for an SSA name in a basic block.\n+  virtual const_bitmap equiv_set (tree, basic_block) = 0;\n+  // register a relation between 2 ssa names in a basic block.\n+  virtual void register_relation (basic_block, relation_kind, tree, tree) = 0;\n+  // Query for a relation between two ssa names in a basic block.\n+  virtual relation_kind query_relation (basic_block, tree, tree) = 0;\n+  // Query for a relation between two equivalency stes in a basic block.\n+  virtual relation_kind query_relation (basic_block, const_bitmap,\n+\t\t\t\t\tconst_bitmap) = 0;\n+\n+  virtual void dump (FILE *, basic_block) const = 0;\n+  virtual void dump (FILE *) const = 0;\n+  void debug () const;\n+};\n+\n // Declared internally in value-relation.cc\n class equiv_chain;\n \n@@ -81,15 +106,18 @@ class equiv_chain;\n // can be represented only on edges whose destination is a single-pred block,\n // and the equivalence is simply applied to that succesor block.\n \n-class equiv_oracle\n+class equiv_oracle : public relation_oracle\n {\n public:\n   equiv_oracle ();\n   ~equiv_oracle ();\n \n-  const_bitmap equiv_set (tree ssa, basic_block bb) const;\n-  void register_equiv (basic_block bb, tree ssa1, tree ssa2);\n+  const_bitmap equiv_set (tree ssa, basic_block bb);\n+  void register_relation (basic_block bb, relation_kind k, tree ssa1,\n+\t\t\t  tree ssa2);\n \n+  relation_kind query_relation (basic_block, tree, tree);\n+  relation_kind query_relation (basic_block, const_bitmap, const_bitmap);\n   void dump (FILE *f, basic_block bb) const;\n   void dump (FILE *f) const;\n \n@@ -99,6 +127,7 @@ class equiv_oracle\n private:\n   bitmap m_equiv_set;\t// Index by ssa-name. true if an equivalence exists.\n   vec <equiv_chain *> m_equiv;\t// Index by BB.  list of equivalences.\n+  vec <bitmap> m_self_equiv;  // Index by ssa-name, self equivalency set.\n \n   void limit_check (basic_block bb = NULL);\n   equiv_chain *find_equiv_block (unsigned ssa, int bb) const;\n@@ -117,6 +146,7 @@ class relation_chain_head\n public:\n   bitmap m_names;\t\t// ssa_names with relations in this block.\n   class relation_chain *m_head; // List of relations in block.\n+  relation_kind find_relation (const_bitmap b1, const_bitmap b2) const;\n };\n \n // A relation oracle maintains a set of relations between ssa_names using the\n@@ -129,36 +159,32 @@ class relation_chain_head\n // relation to the destination block of the edge, but ONLY if that block\n // has a single successor.  For now.\n \n-class relation_oracle : public equiv_oracle\n+class dom_oracle : public equiv_oracle\n {\n public:\n-  relation_oracle ();\n-  ~relation_oracle ();\n+  dom_oracle ();\n+  ~dom_oracle ();\n \n-  void register_relation (gimple *stmt, relation_kind k, tree op1, tree op2);\n-  void register_relation (edge e, relation_kind k, tree op1, tree op2);\n+  void register_relation (basic_block bb, relation_kind k, tree op1, tree op2);\n \n   relation_kind query_relation (basic_block bb, tree ssa1, tree ssa2);\n+  relation_kind query_relation (basic_block bb, const_bitmap b1,\n+\t\t\t\t   const_bitmap b2);\n \n   void dump (FILE *f, basic_block bb) const;\n   void dump (FILE *f) const;\n-  void debug () const;\n private:\n   bitmap m_tmp, m_tmp2;\n   bitmap m_relation_set;  // Index by ssa-name. True if a relation exists\n   vec <relation_chain_head> m_relations;  // Index by BB, list of relations.\n   relation_kind find_relation_block (unsigned bb, const_bitmap b1,\n-\t\t\t\t     const_bitmap b2);\n-  relation_kind find_relation_dom (basic_block bb, const_bitmap b1,\n-\t\t\t\t   const_bitmap b2);\n+\t\t\t\t     const_bitmap b2) const;\n   relation_kind find_relation_block (int bb, unsigned v1, unsigned v2,\n-\t\t\t\t     relation_chain **obj = NULL);\n-  relation_kind find_relation_dom (basic_block bb, unsigned v1, unsigned v2);\n-  void register_relation (basic_block bb, relation_kind k, tree op1, tree op2,\n-\t\t\t  bool transitive_p = false);\n+\t\t\t\t     relation_chain **obj = NULL) const;\n+  relation_kind find_relation_dom (basic_block bb, unsigned v1, unsigned v2) const;\n+  relation_chain *set_one_relation (basic_block bb, relation_kind k, tree op1,\n+\t\t\t\t    tree op2);\n   void register_transitives (basic_block, const class value_relation &);\n-  void register_transitives (basic_block, const value_relation &, const_bitmap,\n-\t\t\t     const_bitmap);\n \n };\n "}]}