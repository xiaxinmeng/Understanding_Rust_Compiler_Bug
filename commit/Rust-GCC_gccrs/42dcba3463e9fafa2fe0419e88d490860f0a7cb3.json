{"sha": "42dcba3463e9fafa2fe0419e88d490860f0a7cb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJkY2JhMzQ2M2U5ZmFmYTJmZTA0MTllODhkNDkwODYwZjBhN2NiMw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-08-07T17:55:01Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-07T17:55:01Z"}, "message": "cpplib.h, line-map.h: Update comments.\n\n\t* cpplib.h, line-map.h: Update comments.\n\t* cppmain.c (printer_init): Move inline.\n\t(maybe_print_line, print_line): Take a map pointer.\n\t(cb_ident, cb_define, cb_undef, cb_include, cb_def_pragma): Update.\n\t(cb_file_change): Don't use prior value of print.map.\n\nFrom-SVN: r44697", "tree": {"sha": "eeb068aafafef2b19aa1d78e652937139b129316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeb068aafafef2b19aa1d78e652937139b129316"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42dcba3463e9fafa2fe0419e88d490860f0a7cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42dcba3463e9fafa2fe0419e88d490860f0a7cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42dcba3463e9fafa2fe0419e88d490860f0a7cb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42dcba3463e9fafa2fe0419e88d490860f0a7cb3/comments", "author": null, "committer": null, "parents": [{"sha": "e85152835015727927dcece51f9d73f2a92c12f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e85152835015727927dcece51f9d73f2a92c12f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e85152835015727927dcece51f9d73f2a92c12f4"}], "stats": {"total": 89, "additions": 49, "deletions": 40}, "files": [{"sha": "01ee1fae466ecb82f2fc48bc0b1b475935a47711", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dcba3463e9fafa2fe0419e88d490860f0a7cb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dcba3463e9fafa2fe0419e88d490860f0a7cb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42dcba3463e9fafa2fe0419e88d490860f0a7cb3", "patch": "@@ -1,3 +1,11 @@\n+2001-08-07  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpplib.h, line-map.h: Update comments.\n+\t* cppmain.c (printer_init): Move inline.\n+\t(maybe_print_line, print_line): Take a map pointer.\n+\t(cb_ident, cb_define, cb_undef, cb_include, cb_def_pragma): Update.\n+\t(cb_file_change): Don't use prior value of print.map.\n+\n 2001-08-07  David Edelsohn  <edelsohn@gnu.org>\n \n \t* doc/install.texi: Document fine-grained multilib configuration."}, {"sha": "32b3d8905e3e098c590fc24a167468278329fc13", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dcba3463e9fafa2fe0419e88d490860f0a7cb3/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dcba3463e9fafa2fe0419e88d490860f0a7cb3/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=42dcba3463e9fafa2fe0419e88d490860f0a7cb3", "patch": "@@ -390,7 +390,7 @@ struct cpp_options\n typedef struct cpp_file_change cpp_file_change;\n struct cpp_file_change\n {\n-  struct line_map *map;\t\t/* Line map to use until next callback.  */\n+  struct line_map *map;\t\t/* Line map, valid until next callback.  */\n   unsigned int line;\t\t/* Logical line number of next line.  */\n   enum lc_reason reason;\t/* Reason for change.  */\n   unsigned char sysp;\t\t/* Nonzero if system header.  */"}, {"sha": "b8cd7af18fbd7cdc3db7688466c408393dbc28ee", "filename": "gcc/cppmain.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dcba3463e9fafa2fe0419e88d490860f0a7cb3/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dcba3463e9fafa2fe0419e88d490860f0a7cb3/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=42dcba3463e9fafa2fe0419e88d490860f0a7cb3", "patch": "@@ -32,9 +32,9 @@ struct printer\n {\n   FILE *outf;\t\t\t/* Stream to write to.  */\n   const char *syshdr_flags;\t/* System header flags, if any.  */\n+  struct line_map *map;\t\t/* Logical to physical line mappings.  */\n   unsigned int line;\t\t/* Line currently being written.  */\n   unsigned char printed;\t/* Nonzero if something output at line.  */\n-  struct line_map *map;\t\t/* Logical to physical line mappings.  */\n };\n \n int main\t\tPARAMS ((int, char **));\n@@ -45,11 +45,11 @@ static void setup_callbacks PARAMS ((void));\n /* General output routines.  */\n static void scan_translation_unit PARAMS ((cpp_reader *));\n static void check_multiline_token PARAMS ((cpp_string *));\n-static void printer_init PARAMS ((void));\n static int dump_macro PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n \n-static void print_line PARAMS ((unsigned int, const char *));\n-static void maybe_print_line PARAMS ((unsigned int));\n+static void print_line PARAMS ((struct line_map *, unsigned int,\n+\t\t\t\tconst char *));\n+static void maybe_print_line PARAMS ((struct line_map *, unsigned int));\n \n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n@@ -139,14 +139,26 @@ do_preprocessing (argc, argv)\n   if (options->help_only)\n     return;\n \n+  /* Initialize the printer structure.  Setting print.line to -1 here\n+     is a trick to guarantee that the first token of the file will\n+     cause a linemarker to be output by maybe_print_line.  */\n+  print.line = (unsigned int) -1;\n+  print.printed = 0;\n+  print.map = 0;\n+  \n   /* Open the output now.  We must do so even if no_output is on,\n      because there may be other output than from the actual\n      preprocessing (e.g. from -dM).  */\n-  printer_init ();\n-  if (print.outf == NULL)\n+  if (options->out_fname[0] == '\\0')\n+    print.outf = stdout;\n+  else\n     {\n-      cpp_notice_from_errno (pfile, options->out_fname);\n-      return;\n+      print.outf = fopen (options->out_fname, \"w\");\n+      if (print.outf == NULL)\n+\t{\n+\t  cpp_notice_from_errno (pfile, options->out_fname);\n+\t  return;\n+\t}\n     }\n \n   setup_callbacks ();\n@@ -226,7 +238,7 @@ scan_translation_unit (pfile)\n \t     column.  Don't bother trying to reconstruct tabs; we can't\n \t     get it right in general, and nothing ought to care.  (Yes,\n \t     some things do care; the fault lies with them.)  */\n-\t  maybe_print_line (line);\n+\t  maybe_print_line (print.map, line);\n \t  if (col > 1)\n \t    {\n \t      if (token->flags & PREV_WHITE)\n@@ -267,29 +279,13 @@ check_multiline_token (str)\n       print.line++;\n }\n \n-/* Initialize a cpp_printer structure.  As a side effect, open the\n-   output file.  If print.outf is NULL an error occurred.  */\n-static void\n-printer_init ()\n-{\n-  /* Setting print.line to -1 here guarantees that the first token of\n-     the file will cause a linemarker to be output by maybe_print_line.  */\n-  print.line = (unsigned int) -1;\n-  print.printed = 0;\n-  print.map = 0;\n-\n-  if (options->out_fname[0] == '\\0')\n-    print.outf = stdout;\n-  else\n-    print.outf = fopen (options->out_fname, \"w\");\n-}\n-\n /* If the token read on logical line LINE needs to be output on a\n    different line to the current one, output the required newlines or\n    a line marker, and return 1.  Otherwise return 0.  */\n \n static void\n-maybe_print_line (line)\n+maybe_print_line (map, line)\n+     struct line_map *map;\n      unsigned int line;\n {\n   /* End the previous line of text.  */\n@@ -309,11 +305,12 @@ maybe_print_line (line)\n \t}\n     }\n   else\n-    print_line (line, \"\");\n+    print_line (map, line, \"\");\n }\n \n static void\n-print_line (line, special_flags)\n+print_line (map, line, special_flags)\n+     struct line_map *map;\n      unsigned int line;\n      const char *special_flags;\n {\n@@ -325,8 +322,8 @@ print_line (line, special_flags)\n   print.line = line;\n   if (! options->no_line_commands)\n     fprintf (print.outf, \"# %u \\\"%s\\\"%s%s\\n\",\n-\t     SOURCE_LINE (print.map, print.line),\n-\t     print.map->to_file, special_flags, print.syshdr_flags);\n+\t     SOURCE_LINE (map, print.line), map->to_file,\n+\t     special_flags, print.syshdr_flags);\n }\n \n /* Callbacks.  */\n@@ -337,7 +334,7 @@ cb_ident (pfile, line, str)\n      unsigned int line;\n      const cpp_string * str;\n {\n-  maybe_print_line (line);\n+  maybe_print_line (print.map, line);\n   fprintf (print.outf, \"#ident \\\"%s\\\"\\n\", str->text);\n   print.line++;\n }\n@@ -348,7 +345,7 @@ cb_define (pfile, line, node)\n      unsigned int line;\n      cpp_hashnode *node;\n {\n-  maybe_print_line (line);\n+  maybe_print_line (print.map, line);\n   fputs (\"#define \", print.outf);\n \n   /* -dD command line option.  */\n@@ -367,7 +364,7 @@ cb_undef (pfile, line, node)\n      unsigned int line;\n      cpp_hashnode *node;\n {\n-  maybe_print_line (line);\n+  maybe_print_line (print.map, line);\n   fprintf (print.outf, \"#undef %s\\n\", NODE_NAME (node));\n   print.line++;\n }\n@@ -379,11 +376,14 @@ cb_include (pfile, line, dir, header)\n      const unsigned char *dir;\n      const cpp_token *header;\n {\n-  maybe_print_line (line);\n+  maybe_print_line (print.map, line);\n   fprintf (print.outf, \"#%s %s\\n\", dir, cpp_token_as_text (pfile, header));\n   print.line++;\n }\n \n+/* The file name, line number or system header flags have changed, as\n+   described in FC.  NB: the old print.map must be considered invalid.  */\n+\n static void\n cb_file_change (pfile, fc)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n@@ -395,7 +395,7 @@ cb_file_change (pfile, fc)\n      change callback specially, so that a first line of \"# 1 \"foo.c\"\n      in file foo.i outputs just the foo.c line, and not a foo.i line.  */\n   if (fc->reason == LC_ENTER && !first_time)\n-    maybe_print_line (fc->line - 1);\n+    maybe_print_line (fc->map - 1, fc->line - 1);\n \n   print.map = fc->map;\n   if (fc->externc)\n@@ -414,7 +414,7 @@ cb_file_change (pfile, fc)\n       else if (fc->reason == LC_LEAVE)\n \tflags = \" 2\";\n \n-      print_line (fc->line, flags);\n+      print_line (print.map, fc->line, flags);\n     }\n }\n \n@@ -425,7 +425,7 @@ cb_def_pragma (pfile, line)\n      cpp_reader *pfile;\n      unsigned int line;\n {\n-  maybe_print_line (line);\n+  maybe_print_line (print.map, line);\n   fputs (\"#pragma \", print.outf);\n   cpp_output_line (pfile, print.outf);\n   print.line++;"}, {"sha": "865fbced5b6dd1e1938ebfe82346d58c6dcaaa74", "filename": "gcc/line-map.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42dcba3463e9fafa2fe0419e88d490860f0a7cb3/gcc%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42dcba3463e9fafa2fe0419e88d490860f0a7cb3/gcc%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.h?ref=42dcba3463e9fafa2fe0419e88d490860f0a7cb3", "patch": "@@ -69,7 +69,8 @@ extern void free_line_maps\n    at least as long as the final call to lookup_line ().\n \n    FROM_LINE should be monotonic increasing across calls to this\n-   function.  */\n+   function.  A call to this function can relocate the previous set of\n+   maps, so any stored line_map pointers should not be used.  */\n extern struct line_map *add_line_map\n   PARAMS ((struct line_maps *, enum lc_reason,\n \t   unsigned int from_line, const char *to_file, unsigned int to_line));"}]}