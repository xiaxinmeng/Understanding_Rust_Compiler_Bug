{"sha": "de12b919c74307c5c2a4c79a29683d21e622422e", "node_id": "C_kwDOANBUbNoAKGRlMTJiOTE5Yzc0MzA3YzVjMmE0Yzc5YTI5NjgzZDIxZTYyMjQyMmU", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-02-03T08:21:58Z"}, "committer": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2022-02-10T08:01:54Z"}, "message": "nvptx: Expand QI mode operations using SI mode instructions\n\nOne of the unusual target features of the Nvidia PTX ISA is that it\ndoesn't provide QI mode (byte sized) operations or registers.  Somewhat\nconventionally, 8-bit quantities are read from/written to memory using\nspecial instructions, but stored internally using SImode (32-bit) registers.\nGCC's middle-end accomodates targets without QImode optabs, by widening\noperations until suitable support is found, and with the current nvptx\nbackend this means 16-bit HImode operations.  The inconvenience is that\nnvptx is also a TARGET_TRULY_NOOP_TRUNCATION=false target, meaning that\nadditional instructions are required to convert between the SImode\nregisters used to hold QImode values, and the HImode registers used to\noperate on them (and back again).  This results in a large amount of\nshuffling and type conversion in code dealing with bytes, i.e. using\nchar or Boolean types.\n\nThis patch improves the situation by providing expanders in the nvptx\nmachine description to perform QImode operations natively in SImode\ninstead of HImode.  An alternate implementation might be to provide\nsome form of target hook to specify which fallback modes to use during\nRTL expansion, but I think this requirement is unusual, and a solution\nentirely in the nvptx backend doesn't disturb/affect other targets.\n\nThe improvements can be quite dramatic, as shown in the example below:\n\nint foo(int x, int y) { return (x==21) && (y==69); }\n\npreviously with -O2 required 15 instructions:\n\n                mov.u32 %r26, %ar0;\n                mov.u32 %r27, %ar1;\n                setp.eq.u32     %r31, %r26, 21;\n                selp.u32        %r30, 1, 0, %r31;\n                mov.u32 %r29, %r30;\n                setp.eq.u32     %r34, %r27, 69;\n                selp.u32        %r33, 1, 0, %r34;\n                mov.u32 %r32, %r33;\n                cvt.u16.u8      %r39, %r29;\n                mov.u16 %r36, %r39;\n                cvt.u16.u8      %r39, %r32;\n                mov.u16 %r37, %r39;\n                and.b16 %r35, %r36, %r37;\n                cvt.u32.u16     %r38, %r35;\n                cvt.u32.u8      %value, %r38;\n\nwith this patch, now requires only 7 instructions:\n\n                mov.u32 %r26, %ar0;\n                mov.u32 %r27, %ar1;\n                setp.eq.u32     %r31, %r26, 21;\n                setp.eq.u32     %r34, %r27, 69;\n                selp.u32        %r37, 1, 0, %r31;\n                selp.u32        %r38, 1, 0, %r34;\n                and.b32 %value, %r37, %r38;\n\nThis patch has been tested on nvptx-none hosted on x86_64-pc-linux-gnu\n(including newlib) with a make and make -k check with no new failures.\n\ngcc/ChangeLog:\n\n\t* config/nvptx/nvptx.md (cmp<mode>): Renamed from *cmp<mode>.\n\t(setcc<mode>_from_bi): Additionally support QImode.\n\t(extendbi<mode>2): Additionally support QImode.\n\t(zero_extendbi<mode>2): Additionally support QImode.\n\t(any_sbinary, any_ubinary, any_sunary, any_uunary): New code\n\titerators for signed and unsigned, binary and unary operations.\n\t(<sbinary>qi3, <ubinary>qi3, <sunary>qi2, <uunary>qi2): New\n\texpanders to perform QImode operations using SImode instructions.\n\t(cstoreqi4): New define_expand.\n\t(*ext_truncsi2_qi): New define_insn.\n\t(*zext_truncsi2_qi): New define_insn.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/nvptx/bool-1.c: New test case.", "tree": {"sha": "4e6714ec543a2ae1ea948e56adc30f9839f00837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e6714ec543a2ae1ea948e56adc30f9839f00837"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de12b919c74307c5c2a4c79a29683d21e622422e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de12b919c74307c5c2a4c79a29683d21e622422e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de12b919c74307c5c2a4c79a29683d21e622422e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de12b919c74307c5c2a4c79a29683d21e622422e/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91a7e1daa7520489fafc0001d03c68bad4304f15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91a7e1daa7520489fafc0001d03c68bad4304f15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91a7e1daa7520489fafc0001d03c68bad4304f15"}], "stats": {"total": 130, "additions": 123, "deletions": 7}, "files": [{"sha": "f53809eacf52ad8992c274605595b2014ef38187", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 107, "deletions": 7, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de12b919c74307c5c2a4c79a29683d21e622422e/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de12b919c74307c5c2a4c79a29683d21e622422e/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=de12b919c74307c5c2a4c79a29683d21e622422e", "patch": "@@ -767,7 +767,7 @@\n \n ;; Comparisons and branches\n \n-(define_insn \"*cmp<mode>\"\n+(define_insn \"cmp<mode>\"\n   [(set (match_operand:BI 0 \"nvptx_register_operand\" \"=R\")\n \t(match_operator:BI 1 \"nvptx_comparison_operator\"\n \t   [(match_operand:HSDIM 2 \"nvptx_register_operand\" \"R\")\n@@ -879,22 +879,22 @@\n ;; Conditional stores\n \n (define_insn \"setcc<mode>_from_bi\"\n-  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n-\t(ne:HSDIM (match_operand:BI 1 \"nvptx_register_operand\" \"R\")\n+  [(set (match_operand:QHSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(ne:QHSDIM (match_operand:BI 1 \"nvptx_register_operand\" \"R\")\n \t\t   (const_int 0)))]\n   \"\"\n   \"%.\\\\tselp%t0\\\\t%0, 1, 0, %1;\")\n \n (define_insn \"extendbi<mode>2\"\n-  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n-\t(sign_extend:HSDIM\n+  [(set (match_operand:QHSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(sign_extend:QHSDIM\n \t (match_operand:BI 1 \"nvptx_register_operand\" \"R\")))]\n   \"\"\n   \"%.\\\\tselp%t0\\\\t%0, -1, 0, %1;\")\n \n (define_insn \"zero_extendbi<mode>2\"\n-  [(set (match_operand:HSDIM 0 \"nvptx_register_operand\" \"=R\")\n-\t(zero_extend:HSDIM\n+  [(set (match_operand:QHSDIM 0 \"nvptx_register_operand\" \"=R\")\n+\t(zero_extend:QHSDIM\n \t (match_operand:BI 1 \"nvptx_register_operand\" \"R\")))]\n   \"\"\n   \"%.\\\\tselp%t0\\\\t%0, 1, 0, %1;\")\n@@ -2117,3 +2117,103 @@\n     return nvptx_output_red_partition (operands[0], operands[1]);\n   }\n   [(set_attr \"predicable\" \"false\")])\n+\n+;; Expand QI mode operations using SI mode instructions.\n+(define_code_iterator any_sbinary [plus minus smin smax])\n+(define_code_attr sbinary [(plus \"add\") (minus \"sub\") (smin \"smin\") (smax \"smax\")])\n+\n+(define_code_iterator any_ubinary [and ior xor umin umax])\n+(define_code_attr ubinary [(and \"and\") (ior \"ior\") (xor \"xor\") (umin \"umin\")\n+\t\t\t   (umax \"umax\")])\n+\n+(define_code_iterator any_sunary [neg abs])\n+(define_code_attr sunary [(neg \"neg\") (abs \"abs\")])\n+\n+(define_code_iterator any_uunary [not])\n+(define_code_attr uunary [(not \"one_cmpl\")])\n+\n+(define_expand \"<sbinary>qi3\"\n+  [(set (match_operand:QI 0 \"nvptx_register_operand\")\n+\t(any_sbinary:QI (match_operand:QI 1 \"nvptx_nonmemory_operand\")\n+\t\t\t(match_operand:QI 2 \"nvptx_nonmemory_operand\")))]\n+  \"\"\n+{\n+  rtx reg = gen_reg_rtx (SImode);\n+  rtx op0 = convert_modes (SImode, QImode, operands[1], 0);\n+  rtx op1 = convert_modes (SImode, QImode, operands[2], 0);\n+  if (<CODE> == MINUS)\n+    op0 = force_reg (SImode, op0);\n+  emit_insn (gen_<sbinary>si3 (reg, op0, op1));\n+  emit_insn (gen_truncsiqi2 (operands[0], reg));\n+  DONE;\n+})\n+\n+(define_expand \"<ubinary>qi3\"\n+  [(set (match_operand:QI 0 \"nvptx_register_operand\")\n+\t(any_ubinary:QI (match_operand:QI 1 \"nvptx_nonmemory_operand\")\n+\t\t\t(match_operand:QI 2 \"nvptx_nonmemory_operand\")))]\n+  \"\"\n+{\n+  rtx reg = gen_reg_rtx (SImode);\n+  rtx op0 = convert_modes (SImode, QImode, operands[1], 1);\n+  rtx op1 = convert_modes (SImode, QImode, operands[2], 1);\n+  emit_insn (gen_<ubinary>si3 (reg, op0, op1));\n+  emit_insn (gen_truncsiqi2 (operands[0], reg));\n+  DONE;\n+})\n+\n+(define_expand \"<sunary>qi2\"\n+  [(set (match_operand:QI 0 \"nvptx_register_operand\")\n+\t(any_sunary:QI (match_operand:QI 1 \"nvptx_nonmemory_operand\")))]\n+  \"\"\n+{\n+  rtx reg = gen_reg_rtx (SImode);\n+  rtx op0 = convert_modes (SImode, QImode, operands[1], 0);\n+  emit_insn (gen_<sunary>si2 (reg, op0));\n+  emit_insn (gen_truncsiqi2 (operands[0], reg));\n+  DONE;\n+})\n+\n+(define_expand \"<uunary>qi2\"\n+  [(set (match_operand:QI 0 \"nvptx_register_operand\")\n+\t(any_uunary:QI (match_operand:QI 1 \"nvptx_nonmemory_operand\")))]\n+  \"\"\n+{\n+  rtx reg = gen_reg_rtx (SImode);\n+  rtx op0 = convert_modes (SImode, QImode, operands[1], 1);\n+  emit_insn (gen_<uunary>si2 (reg, op0));\n+  emit_insn (gen_truncsiqi2 (operands[0], reg));\n+  DONE;\n+})\n+\n+(define_expand \"cstoreqi4\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\")\n+\t(match_operator:SI 1 \"nvptx_comparison_operator\"\n+\t  [(match_operand:QI 2 \"nvptx_nonmemory_operand\")\n+\t   (match_operand:QI 3 \"nvptx_nonmemory_operand\")]))]\n+  \"\"\n+{\n+  rtx reg = gen_reg_rtx (BImode);\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  int unsignedp = unsigned_condition_p (code);\n+  rtx op2 = convert_modes (SImode, QImode, operands[2], unsignedp);\n+  rtx op3 = convert_modes (SImode, QImode, operands[3], unsignedp);\n+  rtx cmp = gen_rtx_fmt_ee (code, SImode, op2, op3);\n+  emit_insn (gen_cmpsi (reg, cmp, op2, op3));\n+  emit_insn (gen_setccsi_from_bi (operands[0], reg));\n+  DONE;\n+})\n+\n+(define_insn \"*ext_truncsi2_qi\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(sign_extend:SI\n+\t (truncate:QI (match_operand:SI 1 \"nvptx_register_operand\" \"R\"))))]\n+  \"\"\n+  \"%.\\\\tcvt.s32.s8\\\\t%0, %1;\")\n+\n+(define_insn \"*zext_truncsi2_qi\"\n+  [(set (match_operand:SI 0 \"nvptx_register_operand\" \"=R\")\n+\t(zero_extend:SI\n+\t (truncate:QI (match_operand:SI 1 \"nvptx_register_operand\" \"R\"))))]\n+  \"\"\n+  \"%.\\\\tcvt.u32.u8\\\\t%0, %1;\")"}, {"sha": "58df2b014eab034f13ec9635ac939dd27c480279", "filename": "gcc/testsuite/gcc.target/nvptx/bool-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de12b919c74307c5c2a4c79a29683d21e622422e/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fbool-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de12b919c74307c5c2a4c79a29683d21e622422e/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fbool-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fbool-1.c?ref=de12b919c74307c5c2a4c79a29683d21e622422e", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+int\n+foo (int x, int y)\n+{\n+  return (x == 21) && (y == 69);\n+}\n+\n+/* { dg-final { scan-assembler-not \"cvt.u16.u8\" } } */\n+/* { dg-final { scan-assembler-not \"cvt.u32.u16\" } } */\n+/* { dg-final { scan-assembler-not \"cvt.u32.u8\" } } */\n+\n+/* { dg-final { scan-assembler-times \"setp.eq.u32\" 2 } } */\n+/* { dg-final { scan-assembler-times \"selp.u32\" 2 } } */\n+/* { dg-final { scan-assembler-times \"and.b32\" 1 } } */"}]}