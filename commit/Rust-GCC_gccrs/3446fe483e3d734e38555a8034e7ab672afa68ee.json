{"sha": "3446fe483e3d734e38555a8034e7ab672afa68ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ0NmZlNDgzZTNkNzM0ZTM4NTU1YTgwMzRlN2FiNjcyYWZhNjhlZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-06-30T12:12:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-06-30T12:12:42Z"}, "message": "re PR middle-end/66702 (#pragma omp declare simd uniform and linear issues)\n\n\tPR middle-end/66702\n\t* omp-low.c (simd_clone_adjust): Handle addressable linear\n\tor uniform parameters or non-gimple type uniform parameters.\n\n\t* testsuite/libgomp.c++/pr66702-1.C: New test.\n\t* testsuite/libgomp.c++/pr66702-2.C: New test.\n\nFrom-SVN: r225179", "tree": {"sha": "3f50a5e4d765602e07b37879ad1f3e725d473799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f50a5e4d765602e07b37879ad1f3e725d473799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3446fe483e3d734e38555a8034e7ab672afa68ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3446fe483e3d734e38555a8034e7ab672afa68ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3446fe483e3d734e38555a8034e7ab672afa68ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3446fe483e3d734e38555a8034e7ab672afa68ee/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b14a9c57cff644851084c4f602437c7fa353c5d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b14a9c57cff644851084c4f602437c7fa353c5d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b14a9c57cff644851084c4f602437c7fa353c5d0"}], "stats": {"total": 194, "additions": 178, "deletions": 16}, "files": [{"sha": "4d11ef546ccd353426910705dca01b512677dfb2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3446fe483e3d734e38555a8034e7ab672afa68ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3446fe483e3d734e38555a8034e7ab672afa68ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3446fe483e3d734e38555a8034e7ab672afa68ee", "patch": "@@ -1,3 +1,9 @@\n+2015-06-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/66702\n+\t* omp-low.c (simd_clone_adjust): Handle addressable linear\n+\tor uniform parameters or non-gimple type uniform parameters.\n+\n 2015-06-30  Richard Biener  <rguenther@suse.de>\n \n \t* fold-const.c (fold_unary_loc): Move abs(abs(x)) -> abs(x),"}, {"sha": "2e2070a739756ef8790232e5f0eb2f3480cf8eef", "filename": "gcc/omp-low.c", "status": "modified", "additions": 83, "deletions": 16, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3446fe483e3d734e38555a8034e7ab672afa68ee/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3446fe483e3d734e38555a8034e7ab672afa68ee/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=3446fe483e3d734e38555a8034e7ab672afa68ee", "patch": "@@ -13425,12 +13425,54 @@ simd_clone_adjust (struct cgraph_node *node)\n      uniform args with __builtin_assume_aligned (arg_N(D), alignment)\n      lhs.  Handle linear by adding PHIs.  */\n   for (unsigned i = 0; i < node->simdclone->nargs; i++)\n-    if (node->simdclone->args[i].alignment\n-\t&& node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM\n-\t&& (node->simdclone->args[i].alignment\n-\t    & (node->simdclone->args[i].alignment - 1)) == 0\n-\t&& TREE_CODE (TREE_TYPE (node->simdclone->args[i].orig_arg))\n-\t   == POINTER_TYPE)\n+    if (node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM\n+\t&& (TREE_ADDRESSABLE (node->simdclone->args[i].orig_arg)\n+\t    || !is_gimple_reg_type\n+\t\t\t(TREE_TYPE (node->simdclone->args[i].orig_arg))))\n+      {\n+\ttree orig_arg = node->simdclone->args[i].orig_arg;\n+\tif (is_gimple_reg_type (TREE_TYPE (orig_arg)))\n+\t  iter1 = make_ssa_name (TREE_TYPE (orig_arg));\n+\telse\n+\t  {\n+\t    iter1 = create_tmp_var_raw (TREE_TYPE (orig_arg));\n+\t    gimple_add_tmp_var (iter1);\n+\t  }\n+\tgsi = gsi_after_labels (entry_bb);\n+\tg = gimple_build_assign (iter1, orig_arg);\n+\tgsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\tgsi = gsi_after_labels (body_bb);\n+\tg = gimple_build_assign (orig_arg, iter1);\n+\tgsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+      }\n+    else if (node->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_UNIFORM\n+\t     && DECL_BY_REFERENCE (node->simdclone->args[i].orig_arg)\n+\t     && TREE_CODE (TREE_TYPE (node->simdclone->args[i].orig_arg))\n+\t\t== REFERENCE_TYPE\n+\t     && TREE_ADDRESSABLE\n+\t\t  (TREE_TYPE (TREE_TYPE (node->simdclone->args[i].orig_arg))))\n+      {\n+\ttree orig_arg = node->simdclone->args[i].orig_arg;\n+\ttree def = ssa_default_def (cfun, orig_arg);\n+\tif (def && !has_zero_uses (def))\n+\t  {\n+\t    iter1 = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (orig_arg)));\n+\t    gimple_add_tmp_var (iter1);\n+\t    gsi = gsi_after_labels (entry_bb);\n+\t    g = gimple_build_assign (iter1, build_simple_mem_ref (def));\n+\t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t    gsi = gsi_after_labels (body_bb);\n+\t    g = gimple_build_assign (build_simple_mem_ref (def), iter1);\n+\t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t  }\n+      }\n+    else if (node->simdclone->args[i].alignment\n+\t     && node->simdclone->args[i].arg_type\n+\t\t== SIMD_CLONE_ARG_TYPE_UNIFORM\n+\t     && (node->simdclone->args[i].alignment\n+\t\t & (node->simdclone->args[i].alignment - 1)) == 0\n+\t     && TREE_CODE (TREE_TYPE (node->simdclone->args[i].orig_arg))\n+\t\t== POINTER_TYPE)\n       {\n \tunsigned int alignment = node->simdclone->args[i].alignment;\n \ttree orig_arg = node->simdclone->args[i].orig_arg;\n@@ -13480,13 +13522,31 @@ simd_clone_adjust (struct cgraph_node *node)\n \t     == SIMD_CLONE_ARG_TYPE_LINEAR_CONSTANT_STEP)\n       {\n \ttree orig_arg = node->simdclone->args[i].orig_arg;\n-\ttree def = ssa_default_def (cfun, orig_arg);\n \tgcc_assert (INTEGRAL_TYPE_P (TREE_TYPE (orig_arg))\n \t\t    || POINTER_TYPE_P (TREE_TYPE (orig_arg)));\n-\tif (def && !has_zero_uses (def))\n+\ttree def = NULL_TREE;\n+\tif (TREE_ADDRESSABLE (orig_arg))\n+\t  {\n+\t    def = make_ssa_name (TREE_TYPE (orig_arg));\n+\t    iter1 = make_ssa_name (TREE_TYPE (orig_arg));\n+\t    iter2 = make_ssa_name (TREE_TYPE (orig_arg));\n+\t    gsi = gsi_after_labels (entry_bb);\n+\t    g = gimple_build_assign (def, orig_arg);\n+\t    gsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t  }\n+\telse\n+\t  {\n+\t    def = ssa_default_def (cfun, orig_arg);\n+\t    if (!def || has_zero_uses (def))\n+\t      def = NULL_TREE;\n+\t    else\n+\t      {\n+\t\titer1 = make_ssa_name (orig_arg);\n+\t\titer2 = make_ssa_name (orig_arg);\n+\t      }\n+\t  }\n+\tif (def)\n \t  {\n-\t    iter1 = make_ssa_name (orig_arg);\n-\t    iter2 = make_ssa_name (orig_arg);\n \t    phi = create_phi_node (iter1, body_bb);\n \t    add_phi_arg (phi, def, preheader_edge, UNKNOWN_LOCATION);\n \t    add_phi_arg (phi, iter2, latch_edge, UNKNOWN_LOCATION);\n@@ -13503,12 +13563,19 @@ simd_clone_adjust (struct cgraph_node *node)\n \t    imm_use_iterator iter;\n \t    use_operand_p use_p;\n \t    gimple use_stmt;\n-\t    FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n-\t      if (use_stmt == phi)\n-\t\tcontinue;\n-\t      else\n-\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t\t  SET_USE (use_p, iter1);\n+\t    if (TREE_ADDRESSABLE (orig_arg))\n+\t      {\n+\t\tgsi = gsi_after_labels (body_bb);\n+\t\tg = gimple_build_assign (orig_arg, iter1);\n+\t\tgsi_insert_before (&gsi, g, GSI_NEW_STMT);\n+\t      }\n+\t    else\n+\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, def)\n+\t\tif (use_stmt == phi)\n+\t\t  continue;\n+\t\telse\n+\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t    SET_USE (use_p, iter1);\n \t  }\n       }\n "}, {"sha": "2f1346de106f2b28926715090271107037a7bce5", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3446fe483e3d734e38555a8034e7ab672afa68ee/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3446fe483e3d734e38555a8034e7ab672afa68ee/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=3446fe483e3d734e38555a8034e7ab672afa68ee", "patch": "@@ -1,3 +1,9 @@\n+2015-06-30  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/66702\n+\t* testsuite/libgomp.c++/pr66702-1.C: New test.\n+\t* testsuite/libgomp.c++/pr66702-2.C: New test.\n+\n 2015-06-30  Tom de Vries  <tom@codesourcery.com>\n \n \t* testsuite/libgomp.c/parloops-exit-first-loop-alt-5.c: New test."}, {"sha": "15772561b1a1f0914f7865ad421cc59fc1cb4773", "filename": "libgomp/testsuite/libgomp.c++/pr66702-1.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3446fe483e3d734e38555a8034e7ab672afa68ee/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66702-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3446fe483e3d734e38555a8034e7ab672afa68ee/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66702-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66702-1.C?ref=3446fe483e3d734e38555a8034e7ab672afa68ee", "patch": "@@ -0,0 +1,49 @@\n+// PR middle-end/66702\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+void\n+bar (int &a, int &b, int *&c, int &d)\n+{\n+  volatile int x;\n+  int *volatile y;\n+  x = a; a = x;\n+  x = b; b = x;\n+  y = c; c = y;\n+  x = d; d = x;\n+}\n+\n+void (*volatile barp) (int &, int &, int *&, int &) = bar;\n+\n+#pragma omp declare simd uniform(b, c) linear(d:2) aligned(c:32) notinbranch\n+int\n+foo (int a, int b, int *c, int d)\n+{\n+  a++;\n+  b++;\n+  c += 8;\n+  d += 2;\n+  barp (a, b, c, d);\n+  return a + b + *c + d;\n+}\n+\n+volatile int e = 5;\n+int c[64] __attribute__((aligned (32)));\n+\n+int\n+main ()\n+{\n+  int d = 7, r = 0;\n+  int b = e;\n+  for (int i = 0; i < 64; i++)\n+    c[i] = i;\n+  #pragma omp simd reduction(+:r) linear(d:2)\n+  for (int i = 0; i < 64; i++)\n+    {\n+      r += foo (i, b, c, d);\n+      d += 2;\n+    }\n+  if (r != 7584)\n+    __builtin_abort ();\n+}"}, {"sha": "7de3de010a7eeab8c4b72dabc579bfb6620c511c", "filename": "libgomp/testsuite/libgomp.c++/pr66702-2.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3446fe483e3d734e38555a8034e7ab672afa68ee/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66702-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3446fe483e3d734e38555a8034e7ab672afa68ee/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66702-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Fpr66702-2.C?ref=3446fe483e3d734e38555a8034e7ab672afa68ee", "patch": "@@ -0,0 +1,34 @@\n+// PR middle-end/66702\n+// { dg-options \"-O2\" }\n+// { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+struct S { int s1, s2; };\n+struct T { T (); ~T (); int t; };\n+\n+T::T () : t(0) {}\n+T::~T () {}\n+\n+#pragma omp declare simd uniform(b, c) notinbranch\n+__attribute__((noinline)) int\n+foo (int a, S b, T c)\n+{\n+  a++;\n+  b.s1++;\n+  b.s2++;\n+  c.t++;\n+  return a + b.s1 + b.s2 + c.t;\n+}\n+\n+int\n+main ()\n+{\n+  int r = 0;\n+  S s = { 2, 3 };\n+  T t;\n+  #pragma omp simd reduction(+:r)\n+  for (int i = 0; i < 64; i++)\n+    r += foo (i, s, t);\n+  if (r != 2592)\n+    __builtin_abort ();\n+}"}]}