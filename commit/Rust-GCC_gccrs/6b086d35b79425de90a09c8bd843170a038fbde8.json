{"sha": "6b086d35b79425de90a09c8bd843170a038fbde8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIwODZkMzViNzk0MjVkZTkwYTA5YzhiZDg0MzE3MGEwMzhmYmRlOA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2017-04-21T09:02:03Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2017-04-21T09:02:03Z"}, "message": "libiberty: Limit demangler maximum d_print_comp recursion call depth.\n\nThe fix for PR demangler/70909 and 67264 (endless demangler recursion)\ncatches when a demangle_component is printed in a cycle. But that doesn't\nprotect the call stack blowing up from non-cyclic nested types printed\nrecursively through d_print_comp. This can happen by a (very) long mangled\nstring that simply creates a very deep pointer or qualifier chain. Limit\nthe recursive d_print_comp call depth for a d_print_info to 1K nested\ntypes.\n\nlibiberty/ChangeLog:\n\n        * cp-demangle.c (MAX_RECURSION_COUNT): New constant.\n        (struct d_print_info): Add recursion field.\n        (d_print_init): Initialize recursion.\n        (d_print_comp): Check and update d_print_info recursion depth.\n\nFrom-SVN: r247056", "tree": {"sha": "8229f4b0678829d2f4ee36ac3f394bc4b2c195cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8229f4b0678829d2f4ee36ac3f394bc4b2c195cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b086d35b79425de90a09c8bd843170a038fbde8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b086d35b79425de90a09c8bd843170a038fbde8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b086d35b79425de90a09c8bd843170a038fbde8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b086d35b79425de90a09c8bd843170a038fbde8/comments", "author": null, "committer": null, "parents": [{"sha": "13b6ef76dc275232310ebfca27db08aeef9b858c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13b6ef76dc275232310ebfca27db08aeef9b858c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13b6ef76dc275232310ebfca27db08aeef9b858c"}], "stats": {"total": 22, "additions": 19, "deletions": 3}, "files": [{"sha": "34e585eacaa3188f5bf548625bcb11764e0dfe72", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b086d35b79425de90a09c8bd843170a038fbde8/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b086d35b79425de90a09c8bd843170a038fbde8/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=6b086d35b79425de90a09c8bd843170a038fbde8", "patch": "@@ -1,3 +1,10 @@\n+2017-04-21  Mark Wielaard  <mark@klomp.org>\n+\n+\t* cp-demangle.c (MAX_RECURSION_COUNT): New constant.\n+\t(struct d_print_info): Add recursion field.\n+\t(d_print_init): Initialize recursion.\n+\t(d_print_comp): Check and update d_print_info recursion depth.\n+\n 2017-04-21  Mark Wielaard  <mark@klomp.org>\n \n \t* cp-demangle.c (d_substitution): Return NULL if d_add_substitution"}, {"sha": "e1db9005e150530dbdced905574095b3e8481421", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b086d35b79425de90a09c8bd843170a038fbde8/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b086d35b79425de90a09c8bd843170a038fbde8/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=6b086d35b79425de90a09c8bd843170a038fbde8", "patch": "@@ -319,6 +319,9 @@ struct d_info_checkpoint\n   int expansion;\n };\n \n+/* Maximum number of times d_print_comp may be called recursively.  */\n+#define MAX_RECURSION_COUNT 1024\n+\n enum { D_PRINT_BUFFER_LENGTH = 256 };\n struct d_print_info\n {\n@@ -341,6 +344,9 @@ struct d_print_info\n   struct d_print_mod *modifiers;\n   /* Set to 1 if we saw a demangling error.  */\n   int demangle_failure;\n+  /* Number of times d_print_comp was recursively called.  Should not\n+     be bigger than MAX_RECURSION_COUNT.  */\n+  int recursion;\n   /* Non-zero if we're printing a lambda argument.  A template\n      parameter reference actually means 'auto'.  */\n   int is_lambda_arg;\n@@ -4151,6 +4157,7 @@ d_print_init (struct d_print_info *dpi, demangle_callbackref callback,\n   dpi->opaque = opaque;\n \n   dpi->demangle_failure = 0;\n+  dpi->recursion = 0;\n   dpi->is_lambda_arg = 0;\n \n   dpi->component_stack = NULL;\n@@ -5685,13 +5692,14 @@ d_print_comp (struct d_print_info *dpi, int options,\n \t      struct demangle_component *dc)\n {\n   struct d_component_stack self;\n-  if (dc == NULL || dc->d_printing > 1)\n+  if (dc == NULL || dc->d_printing > 1 || dpi->recursion > MAX_RECURSION_COUNT)\n     {\n       d_print_error (dpi);\n       return;\n     }\n-  else\n-    dc->d_printing++;\n+\n+  dc->d_printing++;\n+  dpi->recursion++;\n \n   self.dc = dc;\n   self.parent = dpi->component_stack;\n@@ -5701,6 +5709,7 @@ d_print_comp (struct d_print_info *dpi, int options,\n \n   dpi->component_stack = self.parent;\n   dc->d_printing--;\n+  dpi->recursion--;\n }\n \n /* Print a Java dentifier.  For Java we try to handle encoded extended"}]}