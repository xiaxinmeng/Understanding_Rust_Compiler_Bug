{"sha": "214747148c684eeb297268f115b58b7e99c0cf38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE0NzQ3MTQ4YzY4NGVlYjI5NzI2OGYxMTViNThiN2U5OWMwY2YzOA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-06-30T01:51:05Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-06-30T01:51:05Z"}, "message": "42nd Cygnus<->FSF merge\n\nFrom-SVN: r7612", "tree": {"sha": "06e502c729aa2b1b232118cf80da2eec66ef2733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06e502c729aa2b1b232118cf80da2eec66ef2733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/214747148c684eeb297268f115b58b7e99c0cf38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214747148c684eeb297268f115b58b7e99c0cf38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/214747148c684eeb297268f115b58b7e99c0cf38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214747148c684eeb297268f115b58b7e99c0cf38/comments", "author": null, "committer": null, "parents": [{"sha": "725fc5a08d59d147b38a004367b79e724b9f4655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/725fc5a08d59d147b38a004367b79e724b9f4655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/725fc5a08d59d147b38a004367b79e724b9f4655"}], "stats": {"total": 336, "additions": 239, "deletions": 97}, "files": [{"sha": "921ba7358bf78e09ad8183e78ffec71adf0cc517", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -1,5 +1,65 @@\n+Wed Jun 29 16:44:45 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\tFixes a problem of the this pointer being wrong in virtual calls to\n+\tmethods that are not overridden in more derived classes.\n+\n+\t* class.c (fixup_vtable_delta): New routine.  It will fixup the\n+\tdelta entries in vtables, wheever they need updating.\n+\t* class.c (finish_struct): Call the new routine for all virtual\n+\tbases, as they can have different offsets, than those used in base\n+\tclasses that we derive our vtable from.\n+\n+Tue Jun 28 23:49:28 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_binary_op): Use the types before default\n+\tconversions in the error message.\n+\n+\t* *.c: Use c_build_type_variant instead of build_type_variant where\n+\tthe type might be an array.\n+\n+\t* call.c (build_method_call): Call build_type_variant and\n+\tbuild_reference_type in the right order.\n+\t* decl.c (record_builtin_type): Ditto.\n+\n+Wed Jun 29 16:58:53 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* call.c (build_method_call): Call build_type_variant and\n+\tbuild_reference_type in the right order.\n+\t* decl.c (record_builtin_type): Ditto.\n+\n+Tue Jun 28 23:49:28 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (build_binary_op): Use the types before default\n+\tconversions in the error message.\n+\n+\t* *.c: Use c_build_type_variant instead of build_type_variant where\n+\tthe type might be an array.\n+\n+Sat Jun 25 11:50:54 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* cvt.c (convert_to_reference): Try UDC's before doing the\n+\treinterpret_cast thang, though.\n+\n+Fri Jun 24 01:24:01 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* typeck.c (c_expand_return): Don't USE the return value location\n+\tafter we've expanded the jump.\n+\n+\t* decl2.c (finish_file): Make sure DECL_SAVED_INSNS is not 0 before\n+\ttrying to write out an inline.\n+\n+\t* cvt.c (build_up_reference): Also do address adjustment when the\n+\ttarget type uses MI.\n+\t(convert_to_reference): Try UDCs only after built-in conversions.\n+\t(build_type_conversion_1): Don't play games with the argument to the\n+\tmethod.\n+\t(build_type_conversion): #if 0 out code for binding to reference.\n+\n Thu Jun 23 00:22:28 1994  Jason Merrill  (jason@deneb.cygnus.com)\n \n+\t* decl2.c (finish_file): Use TREE_SYMBOL_REFERENCED to decide\n+\twhether to emit inlines.\n+\n \t* decl.c (grokdeclarator): Set explicit_int for decls that just\n \tspecify, say, 'long'.\n "}, {"sha": "131263b3ae3e70287c037cbfc2745b0930f4cbc3", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -762,8 +762,8 @@ compute_conversion_costs (function, tta_in, cp, arglen)\n #endif\n \n \t  h = convert_harshness (TREE_VALUE (ttf),\n-\t\t\t\t      TREE_TYPE (TREE_VALUE (tta)),\n-\t\t\t\t      TREE_VALUE (tta));\n+\t\t\t\t TREE_TYPE (TREE_VALUE (tta)),\n+\t\t\t\t TREE_VALUE (tta));\n \n #ifdef DEBUG_MATCHING\n \t  cp_error (\"     evaluated %s\", print_harshness (&h));\n@@ -2062,9 +2062,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t{\n \t\t  tree new_type;\n \t\t  parm = build_indirect_ref (parm, \"friendifying parms (compiler error)\");\n-\t\t  new_type = build_reference_type (TREE_TYPE (parm));\n-\t\t  /* It is possible that this should go down a layer. */\n-\t\t  new_type = build_type_variant (new_type, constp, volatilep);\n+\t\t  new_type = c_build_type_variant (TREE_TYPE (parm), constp,\n+\t\t\t\t\t\t   volatilep);\n+\t\t  new_type = build_reference_type (new_type);\n \t\t  parm = convert (new_type, parm);\n \t\t  friend_parms = tree_cons (NULL_TREE, parm, TREE_CHAIN (parms));\n \t\t}"}, {"sha": "159dd8743c7e24047f1c733c2f97f2bcd595bf7c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -2262,6 +2262,91 @@ modify_all_direct_vtables (binfo, do_self, t, fndecl, pfn)\n     }\n }\n \n+/* Fixup all the delta entries in this vtable that need updating.\n+   This happens when we have non-overridden virtual functions from a\n+   virtual base class, that are at a different offset, in the new\n+   hierarchy, because the layout of the virtual bases has changed.  */\n+static void\n+fixup_vtable_deltas (binfo, t)\n+     tree binfo, t;\n+{\n+  tree virtuals = BINFO_VIRTUALS (binfo);\n+  unsigned HOST_WIDE_INT n;\n+  \n+  n = 0;\n+  /* Skip initial vtable length field and RTTI fake object. */\n+  for (; virtuals && n < 1 + flag_dossier; n++)\n+      virtuals = TREE_CHAIN (virtuals);\n+  while (virtuals)\n+    {\n+      tree fndecl = TREE_VALUE (virtuals);\n+      tree pfn = FNADDR_FROM_VTABLE_ENTRY (fndecl);\n+      tree delta = DELTA_FROM_VTABLE_ENTRY (fndecl);\n+      fndecl = TREE_OPERAND (pfn, 0);\n+      if (fndecl)\n+\t{\n+\t  tree base_offset, offset;\n+\t  tree context = DECL_CLASS_CONTEXT (fndecl);\n+\t  tree vfield = CLASSTYPE_VFIELD (t);\n+\t  tree this_offset;\n+\n+\t  offset = integer_zero_node;\n+\t  if (context != t && TYPE_USES_COMPLEX_INHERITANCE (t))\n+\t    {\n+\t      offset = virtual_offset (context, CLASSTYPE_VBASECLASSES (t), offset);\n+\t      if (offset == NULL_TREE)\n+\t\t{\n+\t\t  tree binfo = get_binfo (context, t, 0);\n+\t\t  offset = BINFO_OFFSET (binfo);\n+\t\t}\n+\t    }\n+\n+\t  /* Find the right offset for the this pointer based on the\n+\t     base class we just found.  We have to take into\n+\t     consideration the virtual base class pointers that we\n+\t     stick in before the virtual function table pointer.\n+\n+\t     Also, we want just the delta bewteen the most base class\n+\t     that we derived this vfield from and us.  */\n+\t  base_offset = size_binop (PLUS_EXPR,\n+\t\t\t\t    get_derived_offset (binfo),\n+\t\t\t\t    BINFO_OFFSET (binfo));\n+\t  this_offset = size_binop (MINUS_EXPR, offset, base_offset);\n+\n+\t  if (! tree_int_cst_equal (this_offset, delta))\n+\t    {\n+\t      /* Make sure we can modify the derived association with immunity.  */\n+\t      if (TREE_USED (binfo))\n+\t\tmy_friendly_assert (0, 999);\n+\n+\t      if (binfo == TYPE_BINFO (t))\n+\t\t{\n+\t\t  /* In this case, it is *type*'s vtable we are modifying.\n+\t\t     We start with the approximation that it's vtable is that\n+\t\t     of the immediate base class.  */\n+\t\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n+\t\t    build_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* This is our very own copy of `basetype' to play with.\n+\t\t     Later, we will fill in all the virtual functions\n+\t\t     that override the virtual functions in these base classes\n+\t\t     which are not defined by the current type.  */\n+\t\t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n+\t\t    prepare_fresh_vtable (binfo, t);\n+\t\t}\n+\n+\t      modify_vtable_entry (get_vtable_entry_n (BINFO_VIRTUALS (binfo), n),\n+\t\t\t\t   build_vtable_entry (this_offset, pfn),\n+\t\t\t\t   fndecl);\n+\t    }\n+\t}\n+      ++n;\n+      virtuals = TREE_CHAIN (virtuals);\n+    }\n+}\n+\n /* These are the ones that are through virtual base classes. */\n static void\n modify_all_indirect_vtables (binfo, do_self, via_virtual, t, fndecl, pfn)\n@@ -3534,6 +3619,19 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n \t      }\n \t  }\n \t}\n+\n+      /* Now fixup any virtual function entries from virtual bases\n+\t that have different deltas.  */\n+      vbases = CLASSTYPE_VBASECLASSES (t);\n+      while (vbases)\n+\t{\n+\t  /* We might be able to shorten the ammount of work we do by\n+\t     only doing this for vtables that come from virtual bases\n+\t     that have differing offsets, but don't want to miss any\n+\t     entries.  */\n+\t  fixup_vtable_deltas (vbases, t);\n+\t  vbases = TREE_CHAIN (vbases);\n+\t}\n     }\n \n   /* Set up the DECL_FIELD_BITPOS of the vfield if we need to, as we"}, {"sha": "f6891e8fb26c4ee9d19921c321b7d01d08da18d2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -332,6 +332,11 @@ enum languages { lang_c, lang_cplusplus };\n \n /* Macros which might want to be replaced by function calls.  */\n \n+#define DELTA_FROM_VTABLE_ENTRY(ENTRY) \\\n+  (!flag_vtable_thunks ? \\\n+     TREE_VALUE (CONSTRUCTOR_ELTS (ENTRY)) \\\n+   : TREE_CODE (TREE_OPERAND ((ENTRY), 0)) != THUNK_DECL ? integer_zero_node \\\n+   : build_int_2 (THUNK_DELTA (TREE_OPERAND ((ENTRY), 0)), 0))\n #if 1\n /* Virtual function addresses can be gotten from a virtual function\n    table entry using this macro.  */"}, {"sha": "db28cff1cf445567b31e3063624a4cac31f81298", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 28, "deletions": 58, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -304,8 +304,8 @@ build_up_reference (type, arg, flags, checkconst)\n \n   /* Pass along const and volatile down into the type. */\n   if (TYPE_READONLY (type) || TYPE_VOLATILE (type))\n-    target_type = build_type_variant (target_type, TYPE_READONLY (type),\n-\t\t\t\t      TYPE_VOLATILE (type));\n+    target_type = c_build_type_variant (target_type, TYPE_READONLY (type),\n+\t\t\t\t\tTYPE_VOLATILE (type));\n   targ = arg;\n   if (TREE_CODE (targ) == SAVE_EXPR)\n     targ = TREE_OPERAND (targ, 0);\n@@ -337,20 +337,7 @@ build_up_reference (type, arg, flags, checkconst)\n \t  TREE_READONLY (arg) = 0;\n \t}\n \n-#if 0\n-      if (TREE_CODE (TREE_TYPE (arg)) == REFERENCE_TYPE)\n-\t{\n-\t  rval = copy_node (arg);\n-\t  TREE_TYPE (rval) = build_pointer_type (TREE_TYPE (TREE_TYPE (arg)));\n-\t}\n-      else\n-\trval = arg;\n-\n-      rval = convert (build_pointer_type (TREE_TYPE (type)), rval);\n-      TREE_TYPE (rval) = type;\n-#else\n       rval = build1 (CONVERT_EXPR, type, arg);\n-#endif\n       TREE_REFERENCE_EXPR (rval) = 1;\n \n       /* propagate the const flag on something like:\n@@ -591,7 +578,8 @@ build_up_reference (type, arg, flags, checkconst)\n     rval = build1 (ADDR_EXPR, type, arg);\n \n  done:\n-  if (TYPE_USES_COMPLEX_INHERITANCE (argtype))\n+  if (TYPE_USES_COMPLEX_INHERITANCE (argtype)\n+      || TYPE_USES_COMPLEX_INHERITANCE (target_type))\n     {\n       TREE_TYPE (rval) = build_pointer_type (argtype);\n       if (flags & LOOKUP_PROTECT)\n@@ -629,16 +617,6 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n     intype = TREE_TYPE (intype);\n   intype = TYPE_MAIN_VARIANT (intype);\n \n-  if (IS_AGGR_TYPE (intype)\n-      && ! (flags & LOOKUP_NO_CONVERSION)\n-      && (rval = build_type_conversion (CONVERT_EXPR, reftype, expr, 1)))\n-    {\n-      if (rval == error_mark_node)\n-\tcp_error (\"conversion from `%T' to `%T' is ambiguous\",\n-\t\t  intype, reftype);\n-      return rval;\n-    }\n-\n   if (((convtype & CONV_STATIC) && comptypes (type, intype, -1))\n       || ((convtype & CONV_IMPLICIT) && comptypes (type, intype, 0)))\n     {\n@@ -692,7 +670,17 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n \t\t\t\t ! (convtype & CONV_CONST));\n     }\n \n-  if ((convtype & CONV_REINTERPRET) && lvalue_p (expr))\n+  if ((convtype & CONV_IMPLICIT)\n+      && IS_AGGR_TYPE (intype)\n+      && ! (flags & LOOKUP_NO_CONVERSION)\n+      && (rval = build_type_conversion (CONVERT_EXPR, reftype, expr, 1)))\n+    {\n+      if (rval == error_mark_node)\n+\tcp_error (\"conversion from `%T' to `%T' is ambiguous\",\n+\t\t  intype, reftype);\n+      return rval;\n+    }\n+  else if ((convtype & CONV_REINTERPRET) && lvalue_p (expr))\n     {\n       /* When casting an lvalue to a reference type, just convert into\n \t a pointer to the new type and deference it.  This is allowed\n@@ -1486,32 +1474,21 @@ build_type_conversion_1 (xtype, basetype, expr, typename, for_sure)\n      tree typename;\n      int for_sure;\n {\n-  tree first_arg = expr;\n   tree rval;\n   int flags;\n \n   if (for_sure == 0)\n-    {\n-      if (! lvalue_p (expr))\n-\tfirst_arg = build1 (NOP_EXPR, TYPE_POINTER_TO (basetype), integer_zero_node);\n-      flags = LOOKUP_PROTECT;\n-    }\n+    flags = LOOKUP_PROTECT;\n   else\n     flags = LOOKUP_NORMAL;\n \n-  rval = build_method_call (first_arg, typename, NULL_TREE, NULL_TREE, flags);\n+  rval = build_method_call (expr, typename, NULL_TREE, NULL_TREE, flags);\n   if (rval == error_mark_node)\n     {\n       if (for_sure == 0)\n \treturn NULL_TREE;\n       return error_mark_node;\n     }\n-  if (first_arg != expr)\n-    {\n-      expr = build_up_reference (build_reference_type (TREE_TYPE (expr)), expr,\n-\t\t\t\t LOOKUP_COMPLAIN, 1);\n-      TREE_VALUE (TREE_OPERAND (rval, 1)) = build_unary_op (ADDR_EXPR, expr, 0);\n-    }\n   if (TREE_CODE (TREE_TYPE (rval)) == REFERENCE_TYPE\n       && TREE_CODE (xtype) != REFERENCE_TYPE)\n     rval = default_conversion (rval);\n@@ -1616,8 +1593,13 @@ build_type_conversion (code, xtype, expr, for_sure)\n \n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      tree first_arg = expr;\n+#if 0\n+      /* Only reference variable initializations can use a temporary; this\n+         must be handled elsewhere (like convert_to_reference and\n+         compute_conversion_costs).  */\n+\n       type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+      typename = build_typename_overload (type);\n       basetype = save_basetype;\n \n       /* May need to build a temporary for this.  */\n@@ -1628,39 +1610,27 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t      int flags;\n \n \t      if (for_sure == 0)\n-\t\t{\n-\t\t  if (! lvalue_p (expr))\n-\t\t    first_arg = build1 (NOP_EXPR, TYPE_POINTER_TO (basetype), integer_zero_node);\n-\t\t  flags = LOOKUP_PROTECT;\n-\t\t}\n+\t\tflags = LOOKUP_PROTECT;\n \t      else\n \t\tflags = LOOKUP_NORMAL;\n-\t      rval = build_method_call (first_arg, constructor_name_full (typename),\n+\t      rval = build_method_call (expr,\n+\t\t\t\t\tconstructor_name_full (typename),\n \t\t\t\t\tNULL_TREE, NULL_TREE, flags);\n \t      if (rval == error_mark_node)\n \t\t{\n \t\t  if (for_sure == 0)\n \t\t    return NULL_TREE;\n \t\t  return error_mark_node;\n \t\t}\n-\t      TREE_VALUE (TREE_OPERAND (rval, 1)) = expr;\n \n-\t      if (IS_AGGR_TYPE (type))\n-\t\t{\n-\t\t  tree init = build_method_call (NULL_TREE,\n-\t\t\t\t\t\t constructor_name_full (type),\n-\t\t\t\t\t\t build_tree_list (NULL_TREE, rval), NULL_TREE, LOOKUP_NORMAL);\n-\t\t  tree temp = build_cplus_new (type, init, 1);\n-\t\t  return build_up_reference (TYPE_REFERENCE_TO (type), temp,\n-\t\t\t\t\t     LOOKUP_COMPLAIN, 1);\n-\t\t}\n \t      return convert (xtype, rval);\n \t    }\n \t  if (TYPE_BINFO_BASETYPES (basetype))\n \t    basetype = TYPE_BINFO_BASETYPE (basetype, 0);\n \t  else\n \t    break;\n \t}\n+#endif\n       /* No free conversions for reference types, right?.  */\n       return NULL_TREE;\n     }\n@@ -2068,5 +2038,5 @@ type_promotes_to (type)\n   else if (type == float_type_node)\n     type = double_type_node;\n \n-  return build_type_variant (type, constp, volatilep);\n+  return c_build_type_variant (type, constp, volatilep);\n }"}, {"sha": "d8dd1f367ed64df982f061fa320bea98debe2807", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -4128,14 +4128,14 @@ record_builtin_type (rid_index, name, type)\n \t  builtin_type_tdescs_arr[builtin_type_tdescs_len++]\n \t    = build_pointer_type (type);\n \t  builtin_type_tdescs_arr[builtin_type_tdescs_len++]\n-\t    = build_type_variant (TYPE_POINTER_TO (type), 1, 0);\n+\t    = build_pointer_type (build_type_variant (type, 1, 0));\n \t}\n       if (TREE_CODE (type) != VOID_TYPE)\n \t{\n \t  builtin_type_tdescs_arr[builtin_type_tdescs_len++]\n \t    = build_reference_type (type);\n \t  builtin_type_tdescs_arr[builtin_type_tdescs_len++]\n-\t    = build_type_variant (TYPE_REFERENCE_TO (type), 1, 0);\n+\t    = build_reference_type (build_type_variant (type, 1, 0));\n \t}\n     }\n }\n@@ -4757,7 +4757,7 @@ init_decl_processing ()\n   vtbl_type_node\n     = build_array_type (vtable_entry_type, NULL_TREE);\n   layout_type (vtbl_type_node);\n-  vtbl_type_node = build_type_variant (vtbl_type_node, 1, 0);\n+  vtbl_type_node = c_build_type_variant (vtbl_type_node, 1, 0);\n   record_builtin_type (RID_MAX, NULL_PTR, vtbl_type_node);\n \n   /* Simplify life by making a \"sigtable_entry_type\".  Give its\n@@ -8010,12 +8010,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    if (pedantic && (constp || volatilep))\n \t      pedwarn (\"function declared to return const or volatile result\");\n #else\n-\t    /* Merge any constancy or volatility into the target type\n-\t       for the pointer.  */\n+\t    /* Merge any constancy or volatility into the function return\n+               type.  */\n \n \t    if (constp || volatilep)\n \t      {\n-\t\ttype = build_type_variant (type, constp, volatilep);\n+\t\ttype = c_build_type_variant (type, constp, volatilep);\n \t\tif (IS_AGGR_TYPE (type))\n \t\t  build_pointer_type (type);\n \t\tconstp = 0;\n@@ -8226,7 +8226,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t signature pointer/reference itself.  */\n \t      if (! IS_SIGNATURE (type))\n \t\t{\n-\t\t  type = build_type_variant (type, constp, volatilep);\n+\t\t  type = c_build_type_variant (type, constp, volatilep);\n \t\t  if (IS_AGGR_TYPE (type))\n \t\t    build_pointer_type (type);\n \t\t  constp = 0;\n@@ -8519,7 +8519,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       /* Note that the grammar rejects storage classes\n \t in typenames, fields or parameters.  */\n       if (constp || volatilep)\n-\ttype = build_type_variant (type, constp, volatilep);\n+\ttype = c_build_type_variant (type, constp, volatilep);\n \n       /* If the user declares \"struct {...} foo\" then `foo' will have\n \t an anonymous name.  Fill that name in now.  Nothing can\n@@ -8608,7 +8608,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \tif (IS_SIGNATURE (type))\n \t  error (\"`const' or `volatile' specified with signature type\");\n \telse  \n-\t  type = build_type_variant (type, constp, volatilep);\n+\t  type = c_build_type_variant (type, constp, volatilep);\n \n       /* Special case: \"friend class foo\" looks like a TYPENAME context.  */\n       if (friendp)\n@@ -8690,7 +8690,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  {\n \t    /* Transfer const-ness of array into that of type pointed to. */\n \t    type = build_pointer_type\n-\t      (build_type_variant (TREE_TYPE (type), constp, volatilep));\n+\t      (c_build_type_variant (TREE_TYPE (type), constp, volatilep));\n \t    volatilep = constp = 0;\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)"}, {"sha": "0f2b5952a9ee7e64f21f5b738f6627ef12c86b0d", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -507,6 +507,8 @@ lang_decode_option (p)\n \twarn_conversion = setting;\n       else if (!strcmp (p, \"parentheses\"))\n \twarn_parentheses = setting;\n+      else if (!strcmp (p, \"non-virtual-dtor\"))\n+\twarn_nonvdtor = setting;\n       else if (!strcmp (p, \"extern-inline\"))\n \twarn_extern_inline = setting;\n       else if (!strcmp (p, \"comment\"))\n@@ -2765,7 +2767,9 @@ finish_file ()\n     {\n       tree decl = TREE_VALUE (saved_inlines);\n       saved_inlines = TREE_CHAIN (saved_inlines);\n-      if (TREE_ASM_WRITTEN (decl))\n+      /* Redefinition of a member function can cause DECL_SAVED_INSNS to be\n+         0; don't crash.  */\n+      if (TREE_ASM_WRITTEN (decl) || DECL_SAVED_INSNS (decl) == 0)\n \tcontinue;\n       if (DECL_FUNCTION_MEMBER_P (decl) && !TREE_PUBLIC (decl))\n \t{\n@@ -2778,7 +2782,8 @@ finish_file ()\n \t\t   || (DECL_INLINE (decl) && ! flag_implement_inlines));\n \t    }\n \t}\n-      if (TREE_PUBLIC (decl) || TREE_ADDRESSABLE (decl)\n+      if (TREE_PUBLIC (decl)\n+\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n \t  || flag_keep_inline_functions)\n \t{\n \t  if (DECL_EXTERNAL (decl)"}, {"sha": "c808cf4abec5c874b36ab612ea8c1da92f87bce6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -317,9 +317,9 @@ grok_template_type (tvec, type)\n         {\n \t  /* we are here for cases like const T* etc. */\n \t  grok_template_type (tvec, &TYPE_MAIN_VARIANT (*type));\n-\t  *type = build_type_variant (TYPE_MAIN_VARIANT (*type),\n-\t\t\t\t      TYPE_READONLY (*type),\n-\t\t\t\t      TYPE_VOLATILE (*type));\n+\t  *type = c_build_type_variant (TYPE_MAIN_VARIANT (*type),\n+\t\t\t\t\tTYPE_READONLY (*type),\n+\t\t\t\t\tTYPE_VOLATILE (*type));\n \t}\n       else\n \t  *type = TREE_VEC_ELT (tvec, TEMPLATE_TYPE_IDX (*type));\n@@ -1125,9 +1125,9 @@ tsubst (t, args, nargs, in_decl)\n       && type != integer_type_node\n       && type != void_type_node\n       && type != char_type_node)\n-    type = build_type_variant (tsubst (type, args, nargs, in_decl),\n-\t\t\t       TYPE_READONLY (type),\n-\t\t\t       TYPE_VOLATILE (type));\n+    type = c_build_type_variant (tsubst (type, args, nargs, in_decl),\n+\t\t\t\t TYPE_READONLY (type),\n+\t\t\t\t TYPE_VOLATILE (type));\n   switch (TREE_CODE (t))\n     {\n     case RECORD_TYPE:\n@@ -1162,9 +1162,9 @@ tsubst (t, args, nargs, in_decl)\n \t tsubst (TYPE_MAX_VALUE (t), args, nargs, in_decl));\n \n     case TEMPLATE_TYPE_PARM:\n-      return build_type_variant (args[TEMPLATE_TYPE_IDX (t)],\n-\t\t\t\t TYPE_READONLY (t),\n-\t\t\t\t TYPE_VOLATILE (t));\n+      return c_build_type_variant (args[TEMPLATE_TYPE_IDX (t)],\n+\t\t\t\t   TYPE_READONLY (t),\n+\t\t\t\t   TYPE_VOLATILE (t));\n \n     case TEMPLATE_CONST_PARM:\n       return args[TEMPLATE_CONST_IDX (t)];\n@@ -1472,7 +1472,7 @@ tsubst (t, args, nargs, in_decl)\n \t  r = build_pointer_type (type);\n \telse\n \t  r = build_reference_type (type);\n-\tr = build_type_variant (r, TYPE_READONLY (t), TYPE_VOLATILE (t));\n+\tr = c_build_type_variant (r, TYPE_READONLY (t), TYPE_VOLATILE (t));\n \t/* Will this ever be needed for TYPE_..._TO values?  */\n \tlayout_type (r);\n \treturn r;"}, {"sha": "a59b5fd959c4676379ee8d92362ac609d66a403b", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -177,7 +177,7 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n       }\n     else\n       {\n-\ttree sig_tbl_type = build_type_variant (to_type, 1, 0);\n+\ttree sig_tbl_type = c_build_type_variant (to_type, 1, 0);\n \t\n \tsptr = build_lang_field_decl (FIELD_DECL,\n \t\t\t\t      get_identifier (SIGNATURE_SPTR_NAME),"}, {"sha": "a133250f2238cd9a8700da4da13179a3ca74462a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/214747148c684eeb297268f115b58b7e99c0cf38/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=214747148c684eeb297268f115b58b7e99c0cf38", "patch": "@@ -161,7 +161,7 @@ qualify_type (type, like)\n   int constflag = TYPE_READONLY (type) || TYPE_READONLY (like);\n   int volflag = TYPE_VOLATILE (type) || TYPE_VOLATILE (like);\n   /* @@ Must do member pointers here.  */\n-  return build_type_variant (type, constflag, volflag);\n+  return c_build_type_variant (type, constflag, volflag);\n }\n \f\n /* Return the common type of two parameter lists.\n@@ -372,7 +372,7 @@ common_type (t1, t2)\n \t  = TYPE_READONLY (TREE_TYPE (t1)) || TYPE_READONLY (TREE_TYPE (t2));\n \tint volatilep\n \t  = TYPE_VOLATILE (TREE_TYPE (t1)) || TYPE_VOLATILE (TREE_TYPE (t2));\n-\ttarget = build_type_variant (target, constp, volatilep);\n+\ttarget = c_build_type_variant (target, constp, volatilep);\n \tif (code1 == POINTER_TYPE)\n \t  t1 = build_pointer_type (target);\n \telse\n@@ -1380,9 +1380,9 @@ default_conversion (exp)\n       restype = TREE_TYPE (type);\n       if (TYPE_READONLY (type) || TYPE_VOLATILE (type)\n \t  || constp || volatilep)\n-\trestype = build_type_variant (restype,\n-\t\t\t\t      TYPE_READONLY (type) || constp,\n-\t\t\t\t      TYPE_VOLATILE (type) || volatilep);\n+\trestype = c_build_type_variant (restype,\n+\t\t\t\t\tTYPE_READONLY (type) || constp,\n+\t\t\t\t\tTYPE_VOLATILE (type) || volatilep);\n       ptrtype = build_pointer_type (restype);\n \n       if (TREE_CODE (exp) == VAR_DECL)\n@@ -2753,7 +2753,7 @@ build_binary_op (code, arg1, arg2, convert_p)\n \t  if (try == 0)\n \t    {\n \t      cp_error (\"no match for `%O(%#T, %#T)'\", code,\n-\t\t\ttypes[convert_index], types[convert_index ^ 1]);\n+\t\t\tTREE_TYPE (arg1), TREE_TYPE (arg2));\n \t      return error_mark_node;\n \t    }\n \t  if (try == error_mark_node)\n@@ -4177,9 +4177,9 @@ build_unary_op (code, xarg, noconvert)\n \t  || TREE_CODE_CLASS (TREE_CODE (arg)) == 'r')\n \t{\n \t  if (TREE_READONLY (arg) || TREE_THIS_VOLATILE (arg))\n-\t    argtype = build_type_variant (argtype,\n-\t\t\t\t\t  TREE_READONLY (arg),\n-\t\t\t\t\t  TREE_THIS_VOLATILE (arg));\n+\t    argtype = c_build_type_variant (argtype,\n+\t\t\t\t\t    TREE_READONLY (arg),\n+\t\t\t\t\t    TREE_THIS_VOLATILE (arg));\n \t}\n \n       argtype = build_pointer_type (argtype);\n@@ -4585,7 +4585,7 @@ build_conditional_expr (ifexp, op1, op2)\n       else if (TREE_READONLY_DECL_P (op2))\n \top2 = decl_constant_value (op2);\n       if (type1 != type2)\n-\ttype1 = build_type_variant\n+\ttype1 = c_build_type_variant\n \t\t\t(type1,\n \t\t\t TREE_READONLY (op1) || TREE_READONLY (op2),\n \t\t\t TREE_THIS_VOLATILE (op1) || TREE_THIS_VOLATILE (op2));\n@@ -4634,7 +4634,7 @@ build_conditional_expr (ifexp, op1, op2)\n       if (type1 == type2)\n \tresult_type = type1;\n       else\n-\tresult_type = build_type_variant\n+\tresult_type = c_build_type_variant\n \t\t\t(type1,\n \t\t\t TREE_READONLY (op1) || TREE_READONLY (op2),\n \t\t\t TREE_THIS_VOLATILE (op1) || TREE_THIS_VOLATILE (op2));\n@@ -7139,10 +7139,14 @@ c_expand_return (retval)\n     }\n \n   current_function_returns_value = returns_value;\n+#if 0\n+  /* These wind up after the BARRIER, which causes problems for\n+     expand_end_binding.  What purpose were they supposed to serve?  */\n   if (original_result_rtx)\n     use_variable (original_result_rtx);\n   if (use_temp)\n     use_variable (DECL_RTL (DECL_RESULT (current_function_decl)));\n+#endif\n \n   /* One way to clear out cleanups that EXPR might\n      generate.  Note that this code will really be"}]}