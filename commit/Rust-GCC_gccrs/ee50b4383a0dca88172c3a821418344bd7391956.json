{"sha": "ee50b4383a0dca88172c3a821418344bd7391956", "node_id": "C_kwDOANBUbNoAKGVlNTBiNDM4M2EwZGNhODgxNzJjM2E4MjE0MTgzNDRiZDczOTE5NTY", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-02-09T16:33:04Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-02-09T16:33:04Z"}, "message": "c++: memfn lookup consistency and using-decls [PR104432]\n\nIn filter_memfn_lookup, we weren't correctly recognizing and matching up\nmember functions introduced via a non-dependent using-decl.  This caused\nus to crash in the below testcases in which we correctly pruned the\noverload set for the non-dependent call ahead of time, but then at\ninstantiation time filter_memfn_lookup failed to match the selected\nfunction (introduced in each case by a non-dependent using-decl) to the\ncorresponding function from the new lookup set.  Such member functions\nneed special handling in filter_memfn_lookup because they look exactly\nthe same in the old and new lookup sets, whereas ordinary member\nfunctions that're defined in the (dependent) current class become more\nspecialized in the new lookup set.\n\nThis patch reworks the matching logic in filter_memfn_lookup so that it\nhandles (member functions introduced by) non-dependent using-decls\ncorrectly, and is hopefully simpler overall.\n\n\tPR c++/104432\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (build_new_method_call): When a non-dependent call\n\tresolves to a specialization of a member template, always build\n\tthe pruned overload set using the member template, not the\n\tspecialization.\n\t* pt.cc (filter_memfn_lookup): New parameter newtype.  Simplify\n\tand correct how members from the new lookup set are matched to\n\tthose from the old one.\n\t(tsubst_baselink): Pass binfo_type as newtype to\n\tfilter_memfn_lookup.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/non-dependent19.C: New test.\n\t* g++.dg/template/non-dependent19a.C: New test.\n\t* g++.dg/template/non-dependent20.C: New test.", "tree": {"sha": "c904f8d103b670a8fefdbff46504b72b66c71160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c904f8d103b670a8fefdbff46504b72b66c71160"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee50b4383a0dca88172c3a821418344bd7391956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee50b4383a0dca88172c3a821418344bd7391956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee50b4383a0dca88172c3a821418344bd7391956", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee50b4383a0dca88172c3a821418344bd7391956/comments", "author": null, "committer": null, "parents": [{"sha": "1ce5395977f37e8d0c03394f7b932a584ce85cc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce5395977f37e8d0c03394f7b932a584ce85cc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce5395977f37e8d0c03394f7b932a584ce85cc7"}], "stats": {"total": 104, "additions": 73, "deletions": 31}, "files": [{"sha": "d6eed5ed83510340ca6bda32f61da4793090d3e4", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=ee50b4383a0dca88172c3a821418344bd7391956", "patch": "@@ -11189,12 +11189,11 @@ build_new_method_call (tree instance, tree fns, vec<tree, va_gc> **args,\n       if (really_overloaded_fn (fns))\n \t{\n \t  if (DECL_TEMPLATE_INFO (fn)\n-\t      && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (fn))\n-\t      && dependent_type_p (DECL_CONTEXT (fn)))\n+\t      && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (fn)))\n \t    {\n-\t      /* FIXME: We're not prepared to fully instantiate \"inside-out\"\n-\t\t partial instantiations such as A<T>::f<int>().  So instead\n-\t\t use the selected template, not the specialization.  */\n+\t      /* Use the selected template, not the specialization, so that\n+\t\t this looks like an actual lookup result for sake of\n+\t\t filter_memfn_lookup.  */\n \n \t      if (OVL_SINGLE_P (fns))\n \t\t/* If the original overload set consists of a single function"}, {"sha": "86b6ddc634ff36a0c2e5550b1ed9a4db85bad45e", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=ee50b4383a0dca88172c3a821418344bd7391956", "patch": "@@ -16317,12 +16317,12 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n }\n \n /* OLDFNS is a lookup set of member functions from some class template, and\n-   NEWFNS is a lookup set of member functions from a specialization of that\n-   class template.  Return the subset of NEWFNS which are specializations of\n-   a function from OLDFNS.  */\n+   NEWFNS is a lookup set of member functions from NEWTYPE, a specialization\n+   of that class template.  Return the subset of NEWFNS which are\n+   specializations of a function from OLDFNS.  */\n \n static tree\n-filter_memfn_lookup (tree oldfns, tree newfns)\n+filter_memfn_lookup (tree oldfns, tree newfns, tree newtype)\n {\n   /* Record all member functions from the old lookup set OLDFNS into\n      VISIBLE_SET.  */\n@@ -16332,38 +16332,34 @@ filter_memfn_lookup (tree oldfns, tree newfns)\n       if (TREE_CODE (fn) == USING_DECL)\n \t{\n \t  /* FIXME: Punt on (dependent) USING_DECL for now; mapping\n-\t     a dependent USING_DECL to its instantiation seems\n-\t     tricky.  */\n+\t     a dependent USING_DECL to the member functions it introduces\n+\t     seems tricky.  */\n \t  gcc_checking_assert (DECL_DEPENDENT_P (fn));\n \t  return newfns;\n \t}\n-      else if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t/* A member function template.  */\n-\tvisible_set.add (fn);\n-      else if (TREE_CODE (fn) == FUNCTION_DECL)\n-\t{\n-\t  if (DECL_TEMPLATE_INFO (fn))\n-\t    /* A non-template member function.  */\n-\t    visible_set.add (DECL_TI_TEMPLATE (fn));\n-\t  else\n-\t    /* A non-template member function from a non-template base,\n-\t       injected via a using-decl.  */\n-\t    visible_set.add (fn);\n-\t}\n       else\n-\tgcc_unreachable ();\n+\tvisible_set.add (fn);\n     }\n \n   /* Returns true iff (a less specialized version of) FN appeared in\n      the old lookup set OLDFNS.  */\n-  auto visible_p = [&visible_set] (tree fn) {\n-    if (TREE_CODE (fn) == FUNCTION_DECL\n-\t&& !DECL_TEMPLATE_INFO (fn))\n+  auto visible_p = [newtype, &visible_set] (tree fn) {\n+    if (DECL_CONTEXT (fn) != newtype)\n+      /* FN is a member function from a base class, introduced via a\n+\t non-dependent using-decl; look in the old lookup set for\n+\t FN exactly.  */\n       return visible_set.contains (fn);\n-    else if (DECL_TEMPLATE_INFO (fn))\n+    else if (TREE_CODE (fn) == TEMPLATE_DECL)\n+      /* FN is a member function template from the current class;\n+\t look in the old lookup set for the TEMPLATE_DECL from which\n+\t it was specialized.  */\n       return visible_set.contains (DECL_TI_TEMPLATE (fn));\n     else\n-      gcc_unreachable ();\n+      /* FN is a non-template member function from the current class;\n+\t look in the old lookup set for the FUNCTION_DECL from which\n+\t it was specialized.  */\n+      return visible_set.contains (DECL_TEMPLATE_RESULT\n+\t\t\t\t   (DECL_TI_TEMPLATE (fn)));\n   };\n \n   bool lookup_changed_p = false;\n@@ -16455,7 +16451,8 @@ tsubst_baselink (tree baselink, tree object_type,\n \t     performed in an incomplete-class context, within which\n \t     later-declared members ought to remain invisible.  */\n \t  BASELINK_FUNCTIONS (baselink)\n-\t    = filter_memfn_lookup (fns, BASELINK_FUNCTIONS (baselink));\n+\t    = filter_memfn_lookup (fns, BASELINK_FUNCTIONS (baselink),\n+\t\t\t\t   binfo_type);\n \t  BASELINK_FUNCTIONS_MAYBE_INCOMPLETE_P (baselink) = true;\n \t}\n "}, {"sha": "d690e80f2ebc6483923ca032dd305006e79d16f1", "filename": "gcc/testsuite/g++.dg/template/non-dependent19.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent19.C?ref=ee50b4383a0dca88172c3a821418344bd7391956", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/104432\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  template<class=int> void f();\n+  void f(int);\n+};\n+\n+template<class> struct B : A {\n+  using A::f;\n+  void g() { f(); }\n+};\n+\n+template struct B<int>;"}, {"sha": "2f523c8198856f01d8401114e0015062c1976fa2", "filename": "gcc/testsuite/g++.dg/template/non-dependent19a.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent19a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent19a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent19a.C?ref=ee50b4383a0dca88172c3a821418344bd7391956", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/104432\n+// { dg-do compile { target c++11 } }\n+// A variant of non-dependent19.C where A is a template.\n+\n+template<class>\n+struct A {\n+  template<class=int> void f();\n+  void f(int);\n+};\n+\n+template<class> struct B : A<int> {\n+  using A<int>::f;\n+  void g() { f(); }\n+};\n+\n+template struct B<int>;"}, {"sha": "ebf7d7f40fb51035e1646f15f88b80c6ed779bb0", "filename": "gcc/testsuite/g++.dg/template/non-dependent20.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee50b4383a0dca88172c3a821418344bd7391956/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent20.C?ref=ee50b4383a0dca88172c3a821418344bd7391956", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/104432\n+// { dg-do compile { target c++11 } }\n+\n+template<class T>\n+struct A {\n+  template<class=int> static void f(T);\n+  static void f();\n+};\n+\n+template<class> struct B : A<int>, A<int&> {\n+  using A<int>::f;\n+  using A<int&>::f;\n+  void g() { f(0); }\n+};\n+\n+template struct B<int>;"}]}