{"sha": "f1008e52f1060e8f84ed41b6d129ae38e8262516", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEwMDhlNTJmMTA2MGU4Zjg0ZWQ0MWI2ZDEyOWFlMzhlODI2MjUxNg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2000-12-02T17:10:29Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-12-02T17:10:29Z"}, "message": "arm.h (ARM_REGNO_OK_FOR_BASE_P, [...]): New macros.\n\n* arm.h (ARM_REGNO_OK_FOR_BASE_P, THUMB_REGNO_MODE_OK_FOR_BASE_P): New\nmacros.\n(REGNO_MODE_OK_FOR_BASE_P): Define in terms of above.\n(REGNO_OK_FOR_FOR_BASE_P): Delete.\n(ARM_REG_OK_FOR_BASE_P, THUMB_REG_MODE_OK_FOR_BASE_P): New macros for\nboth strict and non-strict uses.\n(REG_MODE_OK_FOR_BASE_P): Define in terms of above.\n(ARM_REG_OK_FOR_INDEX_P, THUMB_REG_OK_FOR_INDEX_P): New macros.\n(REG_OK_FOR_INDEX_P): Define in terms of above.\n(REG_OK_FOR_BASE_P): Delete.\n(REG_OK_FOR_PRE_POST_P): Delete.\n(ARM_BASE_REGISTER_RTX_P): Renamed from BASE_REGISTER_RTX_P.\n(ARM_INDEX_REGISTER_RTX_P): Renamed from INDEX_REGISTER_RTX_P.\n(ARM_GO_IF_LEGITIMATE_INDEX): Renamed from GO_IF_LEGITIMATE_INDEX.\n(THUMB_LEGITIMATE_OFFSET): Renamed from LEGITIMATE_OFFSET.\n(ARM_GO_IF_LEGITIMATE_ADDRESS): Adjust for name changes.  Use ARM\nspecific variants rather than general ones.  Use ARM_REG_OK_FOR_BASE_P\nin pre/post increment cases.\n(THUMB_GO_IF_LEGITIMATE_ADDRESS): Similarly for Thumb.\n(ARM_LEGITIMIZE_ADDRESS): Similarly.\n(THUMB_LEGITIMIZE_RELOAD_ADDRESS): Similarly.\n* arm.c (legitimate_pic_address): Similarly.\n\nFrom-SVN: r37954", "tree": {"sha": "69891c379a55b396ed5ee726eedbfd3e4ce8838e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69891c379a55b396ed5ee726eedbfd3e4ce8838e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1008e52f1060e8f84ed41b6d129ae38e8262516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1008e52f1060e8f84ed41b6d129ae38e8262516", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1008e52f1060e8f84ed41b6d129ae38e8262516", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1008e52f1060e8f84ed41b6d129ae38e8262516/comments", "author": null, "committer": null, "parents": [{"sha": "4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eb191f350e0321bef21f6ad9ed6f17c3ffcaf8b"}], "stats": {"total": 391, "additions": 212, "deletions": 179}, "files": [{"sha": "0d8f01a06e93a0887f1f7a7ad021b42ef515a892", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1008e52f1060e8f84ed41b6d129ae38e8262516/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1008e52f1060e8f84ed41b6d129ae38e8262516/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1008e52f1060e8f84ed41b6d129ae38e8262516", "patch": "@@ -1,3 +1,28 @@\n+2000-12-02  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.h (ARM_REGNO_OK_FOR_BASE_P, THUMB_REGNO_MODE_OK_FOR_BASE_P): New\n+\tmacros.\n+\t(REGNO_MODE_OK_FOR_BASE_P): Define in terms of above.\n+\t(REGNO_OK_FOR_FOR_BASE_P): Delete.\n+\t(ARM_REG_OK_FOR_BASE_P, THUMB_REG_MODE_OK_FOR_BASE_P): New macros for\n+\tboth strict and non-strict uses.\n+\t(REG_MODE_OK_FOR_BASE_P): Define in terms of above.\n+\t(ARM_REG_OK_FOR_INDEX_P, THUMB_REG_OK_FOR_INDEX_P): New macros.\n+\t(REG_OK_FOR_INDEX_P): Define in terms of above.\n+\t(REG_OK_FOR_BASE_P): Delete.\n+\t(REG_OK_FOR_PRE_POST_P): Delete.\n+\t(ARM_BASE_REGISTER_RTX_P): Renamed from BASE_REGISTER_RTX_P.\n+\t(ARM_INDEX_REGISTER_RTX_P): Renamed from INDEX_REGISTER_RTX_P.\n+\t(ARM_GO_IF_LEGITIMATE_INDEX): Renamed from GO_IF_LEGITIMATE_INDEX.\n+\t(THUMB_LEGITIMATE_OFFSET): Renamed from LEGITIMATE_OFFSET.\n+\t(ARM_GO_IF_LEGITIMATE_ADDRESS): Adjust for name changes.  Use ARM\n+\tspecific variants rather than general ones.  Use ARM_REG_OK_FOR_BASE_P\n+\tin pre/post increment cases.\n+\t(THUMB_GO_IF_LEGITIMATE_ADDRESS): Similarly for Thumb.\n+\t(ARM_LEGITIMIZE_ADDRESS): Similarly.\n+\t(THUMB_LEGITIMIZE_RELOAD_ADDRESS): Similarly.\n+\t* arm.c (legitimate_pic_address): Similarly.\n+\n 2000-12-02  Neil Booth  <neilb@earthling.net>\n \n         * tradcpp.c (struct answer, parse_assertion, parse_answer,"}, {"sha": "6e14350dff01856c73e634d524c103eaa8f3c9ab", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1008e52f1060e8f84ed41b6d129ae38e8262516/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1008e52f1060e8f84ed41b6d129ae38e8262516/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f1008e52f1060e8f84ed41b6d129ae38e8262516", "patch": "@@ -1967,7 +1967,7 @@ legitimize_pic_address (orig, mode, reg)\n \t{\n \t  /* The base register doesn't really matter, we only want to\n \t     test the index for the appropriate mode.  */\n-\t  GO_IF_LEGITIMATE_INDEX (mode, 0, offset, win);\n+\t  ARM_GO_IF_LEGITIMATE_INDEX (mode, 0, offset, win);\n \n \t  if (!no_new_pseudos)\n \t    offset = force_reg (Pmode, offset);"}, {"sha": "c1a3215c7a2d56c793c6bdf41b2993266ab41113", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 186, "deletions": 178, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1008e52f1060e8f84ed41b6d129ae38e8262516/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1008e52f1060e8f84ed41b6d129ae38e8262516/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f1008e52f1060e8f84ed41b6d129ae38e8262516", "patch": "@@ -1269,7 +1269,7 @@ enum reg_class\n       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n       && XEXP (X, 0) == stack_pointer_rtx\t\t\t\t\\\n       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-      && ! LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\t\\\n+      && ! THUMB_LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx orig_X = X;\t\t\t\t\t\t\t\\\n       X = copy_rtx (X);\t\t\t\t\t\t\t\\\n@@ -1781,23 +1781,23 @@ typedef struct\n   ((R TEST VALUE) || ((unsigned) reg_renumber[R] TEST VALUE))\n \n /*   On the ARM, don't allow the pc to be used.  */\n-#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE)\t\t\t\\\n-  (TARGET_THUMB ?\t\t\t\t\t\t\\\n-    (    TEST_REGNO (REGNO, <=, LAST_LO_REGNUM)\t\t\t\\\n-      || (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n-\t  && TEST_REGNO (REGNO, ==, STACK_POINTER_REGNUM)))\t\\\n-   :(   \t\t\t\t\t\t\t\\\n-         TEST_REGNO (REGNO, <, PC_REGNUM)\t\t\t\\\n-      || TEST_REGNO (REGNO, ==, FRAME_POINTER_REGNUM)\t\t\\\n-      || TEST_REGNO (REGNO, ==, ARG_POINTER_REGNUM)))\n-\n-/* This is like REGNO_MODE_OF_FOR_BASE_P, except that in Thumb mode\n-   the stack pointer is always acceptable, hence the passing of SImode  */\n-#define REGNO_OK_FOR_BASE_P(REGNO) \t\\\n-  REGNO_MODE_OK_FOR_BASE_P (REGNO, SImode)\n-\n-/* We play tricks with REGNO_MODE_OK... here, so that for ARM the macros\n-   are the same, but for Thumb only registers 0 - 7 are OK.  */\n+#define ARM_REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\\\n+  (TEST_REGNO (REGNO, <, PC_REGNUM)\t\t\t\\\n+   || TEST_REGNO (REGNO, ==, FRAME_POINTER_REGNUM)\t\\\n+   || TEST_REGNO (REGNO, ==, ARG_POINTER_REGNUM))\n+\n+#define THUMB_REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE)\t\t\\\n+  (TEST_REGNO (REGNO, <=, LAST_LO_REGNUM)\t\t\t\\\n+   || (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\\\n+       && TEST_REGNO (REGNO, ==, STACK_POINTER_REGNUM)))\n+\n+#define REGNO_MODE_OK_FOR_BASE_P(REGNO, MODE)\t\t\\\n+  (TARGET_THUMB\t\t\t\t\t\t\\\n+   ? THUMB_REGNO_MODE_OK_FOR_BASE_P (REGNO, MODE)\t\\\n+   : ARM_REGNO_OK_FOR_BASE_P (REGNO))\n+\n+/* For ARM code, we don't care about the mode, but for Thumb, the index\n+   must be suitable for use in a QImode load.  */\n #define REGNO_OK_FOR_INDEX_P(REGNO)\t\\\n   REGNO_MODE_OK_FOR_BASE_P (REGNO, QImode)\n \n@@ -1928,48 +1928,51 @@ typedef struct\n    The symbol REG_OK_STRICT causes the latter definition to be used.  */\n #ifndef REG_OK_STRICT\n \n-#define REG_MODE_OK_FOR_BASE_P(X, MODE)\t   \t\\\n-  (TARGET_THUMB ?\t\t\t\t\\\n-    (   REGNO (X) <= LAST_LO_REGNUM\t\t\\\n-     || REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n-     || (GET_MODE_SIZE (MODE) >= 4\t\t\\\n-\t && (REGNO (X) == STACK_POINTER_REGNUM\t\\\n-\t      ||   (X) == hard_frame_pointer_rtx \\\n-\t      ||   (X) == arg_pointer_rtx)))\t\\\n-   :(\t\t\t\t\t\t\\\n-        REGNO (X) <= LAST_ARM_REGNUM\t\t\\\n-     || REGNO (X) >= FIRST_PSEUDO_REGISTER \t\\\n-     || REGNO (X) == FRAME_POINTER_REGNUM\t\\\n-     || REGNO (X) == ARG_POINTER_REGNUM))\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)  \t\t\t\t\\\n-  REG_MODE_OK_FOR_BASE_P (X, SImode)  \n+#define ARM_REG_OK_FOR_BASE_P(X)\t\t\\\n+  (REGNO (X) <= LAST_ARM_REGNUM\t\t\t\\\n+   || REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n+   || REGNO (X) == FRAME_POINTER_REGNUM\t\t\\\n+   || REGNO (X) == ARG_POINTER_REGNUM)\n \n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  On the Thumb, the stack pointer\n-   is not suitable.  */\n-#define REG_OK_FOR_INDEX_P(X)  \\\n-  REG_MODE_OK_FOR_BASE_P (X, QImode)  \n-\n-/* Just like REG_OK_FOR_BASE_P except that we also allow the PC.  */\n-#define REG_OK_FOR_PRE_POST_P(X) \\\n-  (REG_OK_FOR_BASE_P (X) || REGNO(X) == PC_REGNUM)\n+#define THUMB_REG_MODE_OK_FOR_BASE_P(X, MODE)\t\\\n+  (REGNO (X) <= LAST_LO_REGNUM\t\t\t\\\n+   || REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n+   || (GET_MODE_SIZE (MODE) >= 4\t\t\\\n+       && (REGNO (X) == STACK_POINTER_REGNUM\t\\\n+\t   || (X) == hard_frame_pointer_rtx\t\\\n+\t   || (X) == arg_pointer_rtx)))\n \n #else /* REG_OK_STRICT */\n \n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X)  REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define ARM_REG_OK_FOR_BASE_P(X) \t\t\\\n+  ARM_REGNO_OK_FOR_BASE_P (REGNO (X))\n \n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X)  REGNO_OK_FOR_INDEX_P (REGNO (X))\n-\n-/* Just like REG_OK_FOR_BASE_P except that we also allow the PC.  */\n-#define REG_OK_FOR_PRE_POST_P(X) \\\n-  (REG_OK_FOR_BASE_P (X) || TEST_REGNO (REGNO (X), ==, PC_REGNUM))\n+#define THUMB_REG_MODE_OK_FOR_BASE_P(X, MODE)\t\\\n+  THUMB_REGNO_MODE_OK_FOR_BASE_P (REGNO (X), MODE)\n \n #endif /* REG_OK_STRICT */\n+\n+/* Now define some helpers in terms of the above.  */\n+\n+#define REG_MODE_OK_FOR_BASE_P(X, MODE)\t\t\\\n+  (TARGET_THUMB\t\t\t\t\t\\\n+   ? THUMB_REG_MODE_OK_FOR_BASE_P (X, MODE)\t\\\n+   : ARM_REG_OK_FOR_BASE_P (X))\n+\n+#define ARM_REG_OK_FOR_INDEX_P(X) ARM_REG_OK_FOR_BASE_P (X)\n+\n+/* For Thumb, a valid index register is anything that can be used in\n+   a byte load instruction.  */\n+#define THUMB_REG_OK_FOR_INDEX_P(X) THUMB_REG_MODE_OK_FOR_BASE_P (X, QImode)\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  On the Thumb, the stack pointer\n+   is not suitable.  */\n+#define REG_OK_FOR_INDEX_P(X)\t\t\t\\\n+  (TARGET_THUMB\t\t\t\t\t\\\n+   ? THUMB_REG_OK_FOR_INDEX_P (X)\t\t\\\n+   : ARM_REG_OK_FOR_INDEX_P (X))\n+\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n@@ -1979,132 +1982,135 @@ typedef struct\n    The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS. */\n      \n /* --------------------------------arm version----------------------------- */\n-#define BASE_REGISTER_RTX_P(X)  \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n+#define ARM_BASE_REGISTER_RTX_P(X)  \\\n+  (GET_CODE (X) == REG && ARM_REG_OK_FOR_BASE_P (X))\n \n-#define INDEX_REGISTER_RTX_P(X)  \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n+#define ARM_INDEX_REGISTER_RTX_P(X)  \\\n+  (GET_CODE (X) == REG && ARM_REG_OK_FOR_INDEX_P (X))\n \n /* A C statement (sans semicolon) to jump to LABEL for legitimate index RTXs\n    used by the macro GO_IF_LEGITIMATE_ADDRESS.  Floating point indices can\n    only be small constants. */\n-#define GO_IF_LEGITIMATE_INDEX(MODE, BASE_REGNO, INDEX, LABEL)  \t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT range;\t\t\t\t\t\t\t\t\\\n-      enum rtx_code code = GET_CODE (INDEX);\t\t\t\t\t\t\\\n-      \t\t\t\t\t\t\t\t\t\t\t\\\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\t\t\\\n-\t  if (code == CONST_INT && INTVAL (INDEX) < 1024\t\t\t\t\\\n-\t      && INTVAL (INDEX) > -1024\t\t\t\t\t\t\t\\\n-\t      && (INTVAL (INDEX) & 3) == 0)\t\t\t\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\t\t\\\n-\t  if (INDEX_REGISTER_RTX_P (INDEX) && GET_MODE_SIZE (MODE) <= 4)\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\t\t\\\n-\t  if (GET_MODE_SIZE (MODE) <= 4  && code == MULT\t\t\t\t\\\n-\t      && (! arm_arch4 || (MODE) != HImode))\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\t\t\\\n-\t      rtx xiop0 = XEXP (INDEX, 0);\t\t\t\t\t\t\\\n-\t      rtx xiop1 = XEXP (INDEX, 1);\t\t\t\t\t\t\\\n-\t      if (INDEX_REGISTER_RTX_P (xiop0)\t\t\t\t\t\t\\\n-\t\t  && power_of_two_operand (xiop1, SImode))\t\t\t\t\\\n-\t\tgoto LABEL;\t\t\t\t\t\t\t\t\\\n-\t      if (INDEX_REGISTER_RTX_P (xiop1)\t\t\t\t\t\t\\\n-\t\t  && power_of_two_operand (xiop0, SImode))\t\t\t\t\\\n-\t\tgoto LABEL;\t\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\t\t\\\n-\t  if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\t\t\\\n-\t      && (code == LSHIFTRT || code == ASHIFTRT\t\t\t\t\t\\\n-\t\t  || code == ASHIFT || code == ROTATERT)\t\t\t\t\\\n-\t      && (! arm_arch4 || (MODE) != HImode))\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\t\t\\\n-\t      rtx op = XEXP (INDEX, 1);\t\t\t\t\t\t\t\\\n-\t      if (INDEX_REGISTER_RTX_P (XEXP (INDEX, 0))\t\t\t\t\\\n-\t\t  && GET_CODE (op) == CONST_INT && INTVAL (op) > 0\t\t\t\\\n-\t\t  && INTVAL (op) <= 31)\t\t\t\t\t\t\t\\\n-\t\tgoto LABEL;\t\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\t\t\\\n-\t  /* NASTY: Since this limits the addressing of unsigned byte loads */\t\t\\\n-\t  range = ((MODE) == HImode || (MODE) == QImode)                    \t\t\\\n-\t    ? (arm_arch4 ? 256 : 4095) : 4096;                        \t\t\t\\\n-\t  if (code == CONST_INT && INTVAL (INDEX) < range\t\t\t\t\\\n-\t      && INTVAL (INDEX) > -range)  \t      \t\t\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Jump to LABEL if X is a valid address RTX.  This must also take\n-   REG_OK_STRICT into account when deciding about valid registers, but it uses\n-   the above macros so we are in luck.  Allow REG, REG+REG, REG+INDEX,\n-   INDEX+REG, REG-INDEX, and non floating SYMBOL_REF to the constant pool.\n-   Allow REG-only and AUTINC-REG if handling TImode or HImode.  Other symbol\n-   refs must be forced though a static cell to ensure addressability.  */\n-#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)  \t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t\\\n-\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t\\\n-\t       || (GET_CODE (X) == CONST\t\t\t\t\\\n-\t\t   && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t\\\n-\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 0)) == LABEL_REF\t\\\n-\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 1)) == CONST_INT)))\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if ((MODE) == TImode)\t\t\t\t\t\t\\\n-    ;\t\t\t\t\t\t\t\t\t\\\n-  else if ((MODE) == DImode || (TARGET_SOFT_FLOAT && (MODE) == DFmode))\t\\\n-    {                                                              \t\\\n-      if (GET_CODE (X) == PLUS && BASE_REGISTER_RTX_P (XEXP (X, 0)) \t\\\n-\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)   \t\t\t\\\n-\t{                                          \t\t\t\\\n-\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1)); \t\t\t\\\n-          if (val == 4 || val == -4 || val == -8)\t\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+#define ARM_GO_IF_LEGITIMATE_INDEX(MODE, BASE_REGNO, INDEX, LABEL)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t\\\n-      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t\\\n+      HOST_WIDE_INT range;\t\t\t\t\t\t\\\n+      enum rtx_code code = GET_CODE (INDEX);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (BASE_REGISTER_RTX_P (xop0))\t\t\t\t\t\\\n-\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL);\t\\\n-      else if (BASE_REGISTER_RTX_P (xop1))\t\t\t\t\\\n-\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL);\t\\\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (code == CONST_INT && INTVAL (INDEX) < 1024\t\t\\\n+\t      && INTVAL (INDEX) > -1024\t\t\t\t\t\\\n+\t      && (INTVAL (INDEX) & 3) == 0)\t\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (ARM_INDEX_REGISTER_RTX_P (INDEX)\t\t\t\t\\\n+\t      && GET_MODE_SIZE (MODE) <= 4)\t\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t  if (GET_MODE_SIZE (MODE) <= 4  && code == MULT\t\t\\\n+\t      && (! arm_arch4 || (MODE) != HImode))\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      rtx xiop0 = XEXP (INDEX, 0);\t\t\t\t\\\n+\t      rtx xiop1 = XEXP (INDEX, 1);\t\t\t\t\\\n+\t      if (ARM_INDEX_REGISTER_RTX_P (xiop0)\t\t\t\\\n+\t\t  && power_of_two_operand (xiop1, SImode))\t\t\\\n+\t\tgoto LABEL;\t\t\t\t\t\t\\\n+\t      if (ARM_INDEX_REGISTER_RTX_P (xiop1)\t\t\t\\\n+\t\t  && power_of_two_operand (xiop0, SImode))\t\t\\\n+\t\tgoto LABEL;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n+\t      && (code == LSHIFTRT || code == ASHIFTRT\t\t\t\\\n+\t\t  || code == ASHIFT || code == ROTATERT)\t\t\\\n+\t      && (! arm_arch4 || (MODE) != HImode))\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      rtx op = XEXP (INDEX, 1);\t\t\t\t\t\\\n+\t      if (ARM_INDEX_REGISTER_RTX_P (XEXP (INDEX, 0))\t\t\\\n+\t\t  && GET_CODE (op) == CONST_INT && INTVAL (op) > 0\t\\\n+\t\t  && INTVAL (op) <= 31)\t\t\t\t\t\\\n+\t\tgoto LABEL;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  /* NASTY: Since this limits the addressing of unsigned\t\\\n+\t     byte loads.  */\t\t\t\t\t\t\\\n+\t  range = ((MODE) == HImode || (MODE) == QImode)\t\t\\\n+\t    ? (arm_arch4 ? 256 : 4095) : 4096;\t\t\t\t\\\n+\t  if (code == CONST_INT && INTVAL (INDEX) < range\t\t\\\n+\t      && INTVAL (INDEX) > -range)\t\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  /* Reload currently can't handle MINUS, so disable this for now */\t\\\n-  /* else if (GET_CODE (X) == MINUS)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx xop0 = XEXP (X,0);\t\t\t\t\t\t\\\n-      rtx xop1 = XEXP (X,1);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (BASE_REGISTER_RTX_P (xop0))\t\t\t\t\t\\\n-\tGO_IF_LEGITIMATE_INDEX (MODE, -1, xop1, LABEL);\t\t\t\\\n-    } */\t\t\t\t\t\t\t\t\\\n-  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n-\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n-\t   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\\\n-\t   && ! (flag_pic\t\t\t\t\t\t\\\n-\t\t && symbol_mentioned_p (get_pool_constant (X))))\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)\t\\\n-\t   && (GET_MODE_SIZE (MODE) <= 4)\t\t\t\t\\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Jump to LABEL if X is a valid address RTX.  This must take\n+   REG_OK_STRICT into account when deciding about valid registers.\n+\n+   Allow REG, REG+REG, REG+INDEX, INDEX+REG, REG-INDEX, and non\n+   floating SYMBOL_REF to the constant pool.  Allow REG-only and\n+   AUTINC-REG if handling TImode or HImode.  Other symbol refs must be\n+   forced though a static cell to ensure addressability.  */\n+#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t \\\n+{\t\t\t\t\t\t\t\t\t \\\n+  if (ARM_BASE_REGISTER_RTX_P (X))\t\t\t\t\t \\\n+    goto LABEL;\t\t\t\t\t\t\t\t \\\n+  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t \\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t \\\n+\t   && ARM_REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t \\\n+    goto LABEL;\t\t\t\t\t\t\t\t \\\n+  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t \\\n+\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t \\\n+\t       || (GET_CODE (X) == CONST\t\t\t\t \\\n+\t\t   && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t \\\n+\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 0)) == LABEL_REF\t \\\n+\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 1)) == CONST_INT))) \\\n+    goto LABEL;\t\t\t\t\t\t\t\t \\\n+  else if ((MODE) == TImode)\t\t\t\t\t\t \\\n+    ;\t\t\t\t\t\t\t\t\t \\\n+  else if ((MODE) == DImode || (TARGET_SOFT_FLOAT && (MODE) == DFmode))\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      if (GET_CODE (X) == PLUS && ARM_BASE_REGISTER_RTX_P (XEXP (X, 0))\t \\\n+\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t \\\n+          if (val == 4 || val == -4 || val == -8)\t\t\t \\\n+\t    goto LABEL;\t\t\t\t\t\t\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t \\\n+      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+      if (ARM_BASE_REGISTER_RTX_P (xop0))\t\t\t\t \\\n+\tARM_GO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL);\t \\\n+      else if (ARM_BASE_REGISTER_RTX_P (xop1))\t\t\t\t \\\n+\tARM_GO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL);\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+  /* Reload currently can't handle MINUS, so disable this for now */\t \\\n+  /* else if (GET_CODE (X) == MINUS)\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      rtx xop0 = XEXP (X,0);\t\t\t\t\t\t \\\n+      rtx xop1 = XEXP (X,1);\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+      if (ARM_BASE_REGISTER_RTX_P (xop0))\t\t\t\t \\\n+\tARM_GO_IF_LEGITIMATE_INDEX (MODE, -1, xop1, LABEL);\t\t \\\n+    } */\t\t\t\t\t\t\t\t \\\n+  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t \\\n+\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t \\\n+\t   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t \\\n+\t   && ! (flag_pic\t\t\t\t\t\t \\\n+\t\t && symbol_mentioned_p (get_pool_constant (X))))\t \\\n+    goto LABEL;\t\t\t\t\t\t\t\t \\\n+  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)\t \\\n+\t   && (GET_MODE_SIZE (MODE) <= 4)\t\t\t\t \\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t \\\n+\t   && ARM_REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t \\\n+    goto LABEL;\t\t\t\t\t\t\t\t \\\n }\n      \n /* ---------------------thumb version----------------------------------*/     \n-#define LEGITIMATE_OFFSET(MODE, VAL)\t\t\t\t\t\\\n+#define THUMB_LEGITIMATE_OFFSET(MODE, VAL)\t\t\t\t\\\n   (GET_MODE_SIZE (MODE) == 1 ? ((unsigned HOST_WIDE_INT) (VAL) < 32)\t\\\n    : GET_MODE_SIZE (MODE) == 2 ? ((unsigned HOST_WIDE_INT) (VAL) < 64\t\\\n \t \t\t\t  && ((VAL) & 1) == 0)\t\t\t\\\n@@ -2123,9 +2129,9 @@ typedef struct\n    better ways to solve some of these problems.  */\n \n /* Although it is not incorrect, we don't accept QImode and HImode\n-   addresses based on the frame pointer or arg pointer until the reload pass starts.\n-   This is so that eliminating such addresses into stack based ones\n-   won't produce impossible code.  */\n+   addresses based on the frame pointer or arg pointer until the\n+   reload pass starts.  This is so that eliminating such addresses\n+   into stack based ones won't produce impossible code.  */\n #define THUMB_GO_IF_LEGITIMATE_ADDRESS(MODE, X, WIN)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n /* ??? Not clear if this is right.  Experiment.  */\t\t\t\\\n@@ -2139,7 +2145,8 @@ typedef struct\n \t  || reg_mentioned_p (virtual_stack_vars_rtx, X)))\t\t\\\n     ;\t\t\t\t\t\t\t\t\t\\\n   /* Accept any base register.  SP only in SImode or larger.  */\t\\\n-  else if (GET_CODE (X) == REG && REG_MODE_OK_FOR_BASE_P (X, MODE))\t\\\n+  else if (GET_CODE (X) == REG\t\t\t\t\t\t\\\n+\t   && THUMB_REG_MODE_OK_FOR_BASE_P (X, MODE))\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\t\\\n   /* This is PC relative data before MACHINE_DEPENDENT_REORG runs.  */\t\\\n   else if (GET_MODE_SIZE (MODE) >= 4 && CONSTANT_P (X)\t\t\t\\\n@@ -2156,7 +2163,7 @@ typedef struct\n   /* Post-inc indexing only supported for SImode and larger.  */\t\\\n   else if (GET_CODE (X) == POST_INC && GET_MODE_SIZE (MODE) >= 4\t\\\n \t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t   && REG_OK_FOR_INDEX_P (XEXP (X, 0)))\t\t\t\t\\\n+\t   && THUMB_REG_OK_FOR_INDEX_P (XEXP (X, 0)))\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -2171,15 +2178,15 @@ typedef struct\n \t  && XEXP (X, 1) != frame_pointer_rtx\t\t\t\t\\\n \t  && XEXP (X, 0) != virtual_stack_vars_rtx\t\t\t\\\n \t  && XEXP (X, 1) != virtual_stack_vars_rtx\t\t\t\\\n-\t  && REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\t\\\n-\t  && REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\t\t\t\\\n+\t  && THUMB_REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\\\n+\t  && THUMB_REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\t\t\\\n \tgoto WIN;\t\t\t\t\t\t\t\\\n       /* REG+const has 5-7 bit offset for non-SP registers.  */\t\t\\\n       else if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t       && (REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\t\\\n+\t       && (THUMB_REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\\\n \t\t   || XEXP (X, 0) == arg_pointer_rtx)\t\t\t\\\n \t       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-\t       && LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\\\n+\t       && THUMB_LEGITIMATE_OFFSET (MODE, INTVAL (XEXP (X, 1))))\t\\\n \tgoto WIN;\t\t\t\t\t\t\t\\\n       /* REG+const has 10 bit offset for SP, but only SImode and\t\\\n \t larger is supported.  */\t\t\t\t\t\\\n@@ -2243,7 +2250,8 @@ typedef struct\n \txop0 = force_reg (SImode, xop0);\t\t\t\t \\\n       if (CONSTANT_P (xop1) && ! symbol_mentioned_p (xop1))\t\t \\\n \txop1 = force_reg (SImode, xop1);\t\t\t\t \\\n-      if (BASE_REGISTER_RTX_P (xop0) && GET_CODE (xop1) == CONST_INT)\t \\\n+      if (ARM_BASE_REGISTER_RTX_P (xop0)\t\t\t\t \\\n+\t  && GET_CODE (xop1) == CONST_INT)\t\t\t\t \\\n \t{\t\t\t\t\t\t\t\t \\\n \t  HOST_WIDE_INT n, low_n;\t\t\t\t\t \\\n \t  rtx base_reg, val;\t\t\t\t\t\t \\"}]}