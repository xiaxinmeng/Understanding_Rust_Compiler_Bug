{"sha": "72a931432542edeb7e222774af95942663e66ff2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJhOTMxNDMyNTQyZWRlYjdlMjIyNzc0YWY5NTk0MjY2M2U2NmZmMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-11-23T01:14:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-11-23T01:14:55Z"}, "message": "class.c (finish_struct_1): Set things up for 0-width bitfields like we do for others.\n\n\t* class.c (finish_struct_1): Set things up for 0-width bitfields\n\tlike we do for others.\n\t* decl.c (check_tag_decl): New fn.\n\t(shadow_tag): Split out from here.\n\t* decl2.c (grok_x_components): Call it.\n\nFrom-SVN: r23762", "tree": {"sha": "088be5fe665d74f30c3058b147464cb4006c1d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/088be5fe665d74f30c3058b147464cb4006c1d4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72a931432542edeb7e222774af95942663e66ff2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a931432542edeb7e222774af95942663e66ff2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72a931432542edeb7e222774af95942663e66ff2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72a931432542edeb7e222774af95942663e66ff2/comments", "author": null, "committer": null, "parents": [{"sha": "64b7869acb648286176938c866ad9cbd0d966893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64b7869acb648286176938c866ad9cbd0d966893", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64b7869acb648286176938c866ad9cbd0d966893"}], "stats": {"total": 166, "additions": 97, "deletions": 69}, "files": [{"sha": "9616c2c18a090371e9499a9bbb0ea27b6f69ab2a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=72a931432542edeb7e222774af95942663e66ff2", "patch": "@@ -1,3 +1,12 @@\n+1998-11-23  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* class.c (finish_struct_1): Set things up for 0-width bitfields\n+\tlike we do for others.\n+\n+\t* decl.c (check_tag_decl): New fn.\n+\t(shadow_tag): Split out from here.\n+\t* decl2.c (grok_x_components): Call it.\n+\n 1998-11-22  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c: Lose warn_about_return_type."}, {"sha": "17f728f78f1dbaa125e40b710859c86731cdb9e0", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=72a931432542edeb7e222774af95942663e66ff2", "patch": "@@ -3669,23 +3669,24 @@ finish_struct_1 (t, warn_anon)\n \t\t\t\t x, TREE_TYPE (x));\n \t\t}\n \n-\t      if (DECL_INITIAL (x) == NULL_TREE)\n-\t\t;\n-\t      else if (width == 0)\n+\t      if (DECL_INITIAL (x))\n \t\t{\n+\t\t  DECL_INITIAL (x) = NULL_TREE;\n+\t\t  DECL_FIELD_SIZE (x) = width;\n+\t\t  DECL_BIT_FIELD (x) = 1;\n+\n+\t\t  if (width == 0)\n+\t\t    {\n #ifdef EMPTY_FIELD_BOUNDARY\n-\t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x), EMPTY_FIELD_BOUNDARY);\n+\t\t      DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n+\t\t\t\t\t    EMPTY_FIELD_BOUNDARY);\n #endif\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n-\t\t  DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n-\t\t\t\t\tTYPE_ALIGN (TREE_TYPE (x)));\n+\t\t      if (PCC_BITFIELD_TYPE_MATTERS)\n+\t\t\tDECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n+\t\t\t\t\t      TYPE_ALIGN (TREE_TYPE (x)));\n #endif\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  DECL_INITIAL (x) = NULL_TREE;\n-\t\t  DECL_FIELD_SIZE (x) = width;\n-\t\t  DECL_BIT_FIELD (x) = 1;\n+\t\t    }\n \t\t}\n \t    }\n \t  else"}, {"sha": "4f2fccbce471b848f0df8e20725bd664e59b4dc8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=72a931432542edeb7e222774af95942663e66ff2", "patch": "@@ -2706,6 +2706,7 @@ extern int init_type_desc\t\t\tPROTO((void));\n extern tree define_function\n \tPROTO((char *, tree, enum built_in_function,\n \t       void (*) (tree), char *));\n+extern tree check_tag_decl\t\t\tPROTO((tree));\n extern void shadow_tag\t\t\t\tPROTO((tree));\n extern tree groktypename\t\t\tPROTO((tree));\n extern tree start_decl\t\t\t\tPROTO((tree, tree, int, tree, tree));"}, {"sha": "cacdf05a18e085cb66b25c76a2e54599db3ed8ae", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 69, "deletions": 49, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=72a931432542edeb7e222774af95942663e66ff2", "patch": "@@ -6452,73 +6452,56 @@ fixup_anonymous_union (t)\n     error (\"an anonymous union cannot have function members\");\n }\n \n-/* Called when a declaration is seen that contains no names to declare.\n-   If its type is a reference to a structure, union or enum inherited\n-   from a containing scope, shadow that tag name for the current scope\n-   with a forward reference.\n-   If its type defines a new named structure or union\n-   or defines an enum, it is valid but we need not do anything here.\n-   Otherwise, it is an error.\n+/* Make sure that a declaration with no declarator is well-formed, i.e.\n+   just defines a tagged type or anonymous union.\n \n-   C++: may have to grok the declspecs to learn about static,\n-   complain for anonymous unions.  */\n+   Returns the type defined, if any.  */\n \n-void\n-shadow_tag (declspecs)\n+tree\n+check_tag_decl (declspecs)\n      tree declspecs;\n {\n-  int found_tag = 0;\n+  int found_type = 0;\n   tree ob_modifier = NULL_TREE;\n   register tree link;\n-  register enum tree_code code, ok_code = ERROR_MARK;\n   register tree t = NULL_TREE;\n \n   for (link = declspecs; link; link = TREE_CHAIN (link))\n     {\n       register tree value = TREE_VALUE (link);\n \n-      code = TREE_CODE (value);\n-      if (IS_AGGR_TYPE_CODE (code) || code == ENUMERAL_TYPE)\n+      if (TYPE_P (value))\n \t{\n-\t  my_friendly_assert (TYPE_MAIN_DECL (value) != NULL_TREE, 261);\n-\n-\t  maybe_process_partial_specialization (value);\n+\t  ++found_type;\n \n-\t  t = value;\n-\t  ok_code = code;\n-\t  found_tag++;\n+\t  if (IS_AGGR_TYPE (value) || TREE_CODE (value) == ENUMERAL_TYPE)\n+\t    {\n+\t      my_friendly_assert (TYPE_MAIN_DECL (value) != NULL_TREE, 261);\n+\t      t = value;\n+\t    }\n \t}\n       else if (value == ridpointers[(int) RID_STATIC]\n \t       || value == ridpointers[(int) RID_EXTERN]\n \t       || value == ridpointers[(int) RID_AUTO]\n \t       || value == ridpointers[(int) RID_REGISTER]\n \t       || value == ridpointers[(int) RID_INLINE]\n \t       || value == ridpointers[(int) RID_VIRTUAL]\n+\t       || (value == ridpointers[(int) RID_FRIEND]\n+\t\t   && (current_class_type == NULL_TREE\n+\t\t       || current_scope () != current_class_type))\n+\t       || value == ridpointers[(int) RID_CONST]\n+\t       || value == ridpointers[(int) RID_VOLATILE]\n \t       || value == ridpointers[(int) RID_EXPLICIT])\n \tob_modifier = value;\n     }\n \n-  /* This is where the variables in an anonymous union are\n-     declared.  An anonymous union declaration looks like:\n-     union { ... } ;\n-     because there is no declarator after the union, the parser\n-     sends that declaration here.  */\n-  if (ok_code == UNION_TYPE\n-      && t != NULL_TREE\n-      && ((TREE_CODE (TYPE_NAME (t)) == IDENTIFIER_NODE\n-\t   && ANON_AGGRNAME_P (TYPE_NAME (t)))\n-\t  || (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n-\t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))))\n-    {\n-      fixup_anonymous_union (t);\n-\n-      if (TYPE_FIELDS (t))\n-\t{\n-\t  tree decl = grokdeclarator (NULL_TREE, declspecs, NORMAL, 0,\n-\t\t\t\t      NULL_TREE);\n-\t  finish_anon_union (decl);\n-\t}\n-    }\n+  if (found_type > 1)\n+    error (\"multiple types in one declaration\");\n+    \n+  if (t == NULL_TREE)\n+    pedwarn (\"declaration does not declare anything\");\n+  else if (ANON_UNION_TYPE_P (t))\n+    return t;\n   else\n     {\n       /* Anonymous unions are objects, that's why we only check for\n@@ -6529,18 +6512,55 @@ shadow_tag (declspecs)\n \t  if (ob_modifier == ridpointers[(int) RID_INLINE]\n \t      || ob_modifier == ridpointers[(int) RID_VIRTUAL])\n \t    cp_error (\"`%D' can only be specified for functions\", ob_modifier);\n+\t  else if (ob_modifier == ridpointers[(int) RID_FRIEND])\n+\t    cp_error (\"`%D' can only be specified inside a class\", ob_modifier);\n \t  else if (ob_modifier == ridpointers[(int) RID_EXPLICIT])\n \t    cp_error (\"`%D' can only be specified for constructors\",\n \t\t      ob_modifier);\n \t  else\n \t    cp_error (\"`%D' can only be specified for objects and functions\",\n \t\t      ob_modifier);\n \t}\n+    }\n \n-      if (found_tag == 0)\n-\tcp_error (\"abstract declarator used as declaration\");\n-      else if (found_tag > 1)\n-\tpedwarn (\"multiple types in one declaration\");\n+  return t;\n+}\n+\n+/* Called when a declaration is seen that contains no names to declare.\n+   If its type is a reference to a structure, union or enum inherited\n+   from a containing scope, shadow that tag name for the current scope\n+   with a forward reference.\n+   If its type defines a new named structure or union\n+   or defines an enum, it is valid but we need not do anything here.\n+   Otherwise, it is an error.\n+\n+   C++: may have to grok the declspecs to learn about static,\n+   complain for anonymous unions.  */\n+\n+void\n+shadow_tag (declspecs)\n+     tree declspecs;\n+{\n+  tree t = check_tag_decl (declspecs);\n+\n+  if (t)\n+    maybe_process_partial_specialization (t);\n+\n+  /* This is where the variables in an anonymous union are\n+     declared.  An anonymous union declaration looks like:\n+     union { ... } ;\n+     because there is no declarator after the union, the parser\n+     sends that declaration here.  */\n+  if (t && ANON_UNION_TYPE_P (t))\n+    {\n+      fixup_anonymous_union (t);\n+\n+      if (TYPE_FIELDS (t))\n+\t{\n+\t  tree decl = grokdeclarator (NULL_TREE, declspecs, NORMAL, 0,\n+\t\t\t\t      NULL_TREE);\n+\t  finish_anon_union (decl);\n+\t}\n     }\n }\n \f\n@@ -10761,9 +10781,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t\t\t\t\t   type))\n \t\t  /* If we just return the declaration, crashes\n \t\t     will sometimes occur.  We therefore return\n-\t\t\t void_type_node, as if this was a friend\n-\t\t\t declaration, to cause callers to completely\n-\t\t\t ignore this declaration.  */\n+\t\t     void_type_node, as if this was a friend\n+\t\t     declaration, to cause callers to completely\n+\t\t     ignore this declaration.  */\n \t\t  return void_type_node;\n \t      }\n "}, {"sha": "bd09ebaad2dc8cd7fdcec68ef780462b1dfa28ca", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72a931432542edeb7e222774af95942663e66ff2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=72a931432542edeb7e222774af95942663e66ff2", "patch": "@@ -858,17 +858,14 @@ grok_x_components (specs)\n   struct pending_inline **p;\n   tree t;\n \n-  t = groktypename (build_decl_list (strip_attrs (specs), NULL_TREE)); \n-  \n-  if (t == NULL_TREE)\n-    {\n-      cp_error (\"invalid member declaration\");\n-      return;\n-    }\n+  specs = strip_attrs (specs);\n+\n+  check_tag_decl (specs);\n+  t = groktypename (build_decl_list (specs, NULL_TREE)); \n \n   /* The only case where we need to do anything additional here is an\n      anonymous union field, e.g.: `struct S { union { int i; }; };'.  */\n-  if (!ANON_UNION_TYPE_P (t))\n+  if (t == NULL_TREE || !ANON_UNION_TYPE_P (t))\n     return;\n \n   fixup_anonymous_union (t);"}]}