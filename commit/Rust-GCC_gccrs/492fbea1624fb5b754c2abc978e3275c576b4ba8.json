{"sha": "492fbea1624fb5b754c2abc978e3275c576b4ba8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkyZmJlYTE2MjRmYjViNzU0YzJhYmM5NzhlMzI3NWM1NzZiNGJhOA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2012-06-09T17:32:27Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-06-09T17:32:27Z"}, "message": "sfp-machine.h (__gcc_CMPtype, [...]): Move ...\n\n\t* config/i386/32/sfp-machine.h (__gcc_CMPtype, CMPtype,\n\t_FP_KEEPNANFRACP, _FP_CHOOSENAN, FP_EX_INVALID, FP_EX_DENORM,\n\tFP_EX_DIVZERO, FP_EX_OVERFLOW, FP_EX_UNDERFLOW, FP_EX_INEXACT,\n\tFP_HANDLE_EXCEPTIONS, FP_RND_NEAREST, FP_RND_ZERO, FP_RND_PINF,\n\tFP_RND_MINF, _FP_DEXL_EX, FP_INIT_ROUNDMODE, FP_ROUNDMODE,\n\t__LITTLE_ENDIAN, __BIG_ENDIAN, strong_alias): Move ...\n\t* config/i386/64/sfp-machine: ... (delete here) ...\n\t* config/i386/sfp-machine.h: ... to here.\n\t(FP_EX_MASK): New.\n\t(__sfp_handle_exceptions): New function declaration.\n\t(FP_HANDLE_EXCEPTIONS): Use __sfp_handle_exceptions.\n\t* config/i386/sfp-exceptions.c: New.\n\t* config/i386/t-softfp: New.\n\t* config.host (i[34567]86-*-* and x86_64-*-* soft-fp targets): Add\n\ti386/t-softfp to tmake_file.\n\nFrom-SVN: r188361", "tree": {"sha": "d50efe04123885becee1d0784b756e916011f814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d50efe04123885becee1d0784b756e916011f814"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/492fbea1624fb5b754c2abc978e3275c576b4ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/492fbea1624fb5b754c2abc978e3275c576b4ba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/492fbea1624fb5b754c2abc978e3275c576b4ba8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/492fbea1624fb5b754c2abc978e3275c576b4ba8/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11a687e750e810ac085dfda840ce10f73ee2ce81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11a687e750e810ac085dfda840ce10f73ee2ce81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11a687e750e810ac085dfda840ce10f73ee2ce81"}], "stats": {"total": 439, "additions": 185, "deletions": 254}, "files": [{"sha": "dd1dc5504a5a10f9cbc51f2d0794081d69b640ea", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=492fbea1624fb5b754c2abc978e3275c576b4ba8", "patch": "@@ -1,3 +1,21 @@\n+2012-06-09  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/32/sfp-machine.h (__gcc_CMPtype, CMPtype,\n+\t_FP_KEEPNANFRACP, _FP_CHOOSENAN, FP_EX_INVALID, FP_EX_DENORM,\n+\tFP_EX_DIVZERO, FP_EX_OVERFLOW, FP_EX_UNDERFLOW, FP_EX_INEXACT,\n+\tFP_HANDLE_EXCEPTIONS, FP_RND_NEAREST, FP_RND_ZERO, FP_RND_PINF,\n+\tFP_RND_MINF, _FP_DEXL_EX, FP_INIT_ROUNDMODE, FP_ROUNDMODE,\n+\t__LITTLE_ENDIAN, __BIG_ENDIAN, strong_alias): Move ...\n+\t* config/i386/64/sfp-machine: ... (delete here) ...\n+\t* config/i386/sfp-machine.h: ... to here.\n+\t(FP_EX_MASK): New.\n+\t(__sfp_handle_exceptions): New function declaration.\n+\t(FP_HANDLE_EXCEPTIONS): Use __sfp_handle_exceptions.\n+\t* config/i386/sfp-exceptions.c: New.\n+\t* config/i386/t-softfp: New.\n+\t* config.host (i[34567]86-*-* and x86_64-*-* soft-fp targets): Add\n+\ti386/t-softfp to tmake_file.\n+\n 2012-06-03  David S. Miller  <davem@davemloft.net>\n \n \t* longlong.h [SPARC] (sub_ddmmss): Fix thinko in previous 64-bit"}, {"sha": "d8ad48c5e042f572cee3cd2334a9559f62e35280", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=492fbea1624fb5b754c2abc978e3275c576b4ba8", "patch": "@@ -1153,7 +1153,7 @@ i[34567]86-*-darwin* | x86_64-*-darwin* | \\\n \tif test \"${host_address}\" = 32; then\n \t\ttmake_file=\"${tmake_file} i386/${host_address}/t-softfp\"\n \tfi\n-\ttmake_file=\"${tmake_file} t-softfp\"\n+\ttmake_file=\"${tmake_file} i386/t-softfp t-softfp\"\n \t;;\n esac\n "}, {"sha": "6d4e5e17912f79f8b404f903e060e3d757569858", "filename": "libgcc/config/i386/32/sfp-machine.h", "status": "modified", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2F32%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2F32%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2F32%2Fsfp-machine.h?ref=492fbea1624fb5b754c2abc978e3275c576b4ba8", "patch": "@@ -3,11 +3,6 @@\n #define _FP_WS_TYPE\t\tsigned int\n #define _FP_I_TYPE\t\tint\n \n-/* The type of the result of a floating point comparison.  This must\n-   match `__libgcc_cmp_return__' in GCC for the target.  */\n-typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n-#define CMPtype __gcc_CMPtype\n-\n #define __FP_FRAC_ADD_4(r3,r2,r1,r0,x3,x2,x1,x0,y3,y2,y1,y0)\t\\\n   __asm__ (\"add{l} {%11,%3|%3,%11}\\n\\t\"\t\t\t\t\\\n \t   \"adc{l} {%9,%2|%2,%9}\\n\\t\"\t\t\t\t\\\n@@ -85,122 +80,3 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n #define _FP_NANSIGN_D\t\t1\n #define _FP_NANSIGN_E\t\t1\n #define _FP_NANSIGN_Q\t\t1\n-\n-#define _FP_KEEPNANFRACP 1\n-\n-/* Here is something Intel misdesigned: the specs don't define\n-   the case where we have two NaNs with same mantissas, but\n-   different sign. Different operations pick up different NaNs.  */\n-#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    if (_FP_FRAC_GT_##wc(X, Y)\t\t\t\t\t\\\n-\t|| (_FP_FRAC_EQ_##wc(X,Y) && (OP == '+' || OP == '*')))\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = X##_s;\t\t\t\t\t\t\\\n-        _FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = Y##_s;\t\t\t\t\t\t\\\n-        _FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_EX_INVALID\t\t0x01\n-#define FP_EX_DENORM\t\t0x02\n-#define FP_EX_DIVZERO\t\t0x04\n-#define FP_EX_OVERFLOW\t\t0x08\n-#define FP_EX_UNDERFLOW\t\t0x10\n-#define FP_EX_INEXACT\t\t0x20\n-\n-struct fenv\n-{\n-  unsigned short int __control_word;\n-  unsigned short int __unused1;\n-  unsigned short int __status_word;\n-  unsigned short int __unused2;\n-  unsigned short int __tags;\n-  unsigned short int __unused3;\n-  unsigned int __eip;\n-  unsigned short int __cs_selector;\n-  unsigned int __opcode:11;\n-  unsigned int __unused4:5;\n-  unsigned int __data_offset;\n-  unsigned short int __data_selector;\n-  unsigned short int __unused5;\n-};\n-\n-#define FP_HANDLE_EXCEPTIONS\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_INVALID)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfloat f = 0.0;\t\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fdiv {%y0, %0|%0, %y0}\" : \"+t\" (f));\t\\\n-\t__asm__ __volatile__ (\"fwait\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_DIVZERO)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfloat f = 1.0, g = 0.0;\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fdivp {%0, %y1|%y1, %0}\"\t\t\t\\\n-\t\t\t\t      : \"+t\" (f) : \"u\" (g)\t\t\\\n-\t\t\t\t      : \"st(1)\");\t\t\t\\\n-\t__asm__ __volatile__ (\"fwait\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_OVERFLOW)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct fenv temp;\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fnstenv %0\" : \"=m\" (temp));\t\t\\\n-\ttemp.__status_word |= FP_EX_OVERFLOW;\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fldenv %0\" : : \"m\" (temp));\t\t\\\n-\t__asm__ __volatile__ (\"fwait\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_UNDERFLOW)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct fenv temp;\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fnstenv %0\" : \"=m\" (temp));\t\t\\\n-\ttemp.__status_word |= FP_EX_UNDERFLOW;\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fldenv %0\" : : \"m\" (temp));\t\t\\\n-\t__asm__ __volatile__ (\"fwait\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_INEXACT)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct fenv temp;\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fnstenv %0\" : \"=m\" (temp));\t\t\\\n-\ttemp.__status_word |= FP_EX_INEXACT;\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fldenv %0\" : : \"m\" (temp));\t\t\\\n-\t__asm__ __volatile__ (\"fwait\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_RND_NEAREST\t\t0\n-#define FP_RND_ZERO\t\t0xc00\n-#define FP_RND_PINF\t\t0x800\n-#define FP_RND_MINF\t\t0x400\n-\n-#define _FP_DECL_EX \\\n-  unsigned short _fcw __attribute__ ((unused)) = FP_RND_NEAREST\n-\n-#define FP_INIT_ROUNDMODE\t\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    __asm__ (\"fnstcw %0\" : \"=m\" (_fcw));\t\\\n-  } while (0)\n-\n-#define FP_ROUNDMODE\t\t(_fcw & 0xc00)\n-\n-#define\t__LITTLE_ENDIAN\t1234\n-#define\t__BIG_ENDIAN\t4321\n-\n-#define __BYTE_ORDER __LITTLE_ENDIAN\n-\n-/* Define ALIASNAME as a strong alias for NAME.  */\n-#if defined __MACH__\n-/* Mach-O doesn't support aliasing.  If these functions ever return\n-   anything but CMPtype we need to revisit this... */\n-#define strong_alias(name, aliasname) \\\n-  CMPtype aliasname (TFtype a, TFtype b) { return name(a, b); }\n-#else\n-# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n-# define _strong_alias(name, aliasname) \\\n-  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n-#endif"}, {"sha": "469c28cfbc3963d4db9ae59ad2de29107dc5e29b", "filename": "libgcc/config/i386/64/sfp-machine.h", "status": "modified", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2F64%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2F64%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2F64%2Fsfp-machine.h?ref=492fbea1624fb5b754c2abc978e3275c576b4ba8", "patch": "@@ -1,5 +1,4 @@\n #define _FP_W_TYPE_SIZE\t\t64\n-\n #define _FP_W_TYPE\t\tunsigned long long\n #define _FP_WS_TYPE\t\tsigned long long\n #define _FP_I_TYPE\t\tlong long\n@@ -9,11 +8,6 @@ typedef unsigned int UTItype __attribute__ ((mode (TI)));\n \n #define TI_BITS (__CHAR_BIT__ * (int)sizeof(TItype))\n \n-/* The type of the result of a floating point comparison.  This must\n-   match `__libgcc_cmp_return__' in GCC for the target.  */\n-typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n-#define CMPtype __gcc_CMPtype\n-\n #define _FP_MUL_MEAT_Q(R,X,Y)                           \\\n   _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n \n@@ -27,126 +21,3 @@ typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n #define _FP_NANSIGN_D\t\t1\n #define _FP_NANSIGN_E\t\t1\n #define _FP_NANSIGN_Q\t\t1\n-\n-#define _FP_KEEPNANFRACP 1\n-\n-/* Here is something Intel misdesigned: the specs don't define\n-   the case where we have two NaNs with same mantissas, but\n-   different sign. Different operations pick up different NaNs.  */\n-#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    if (_FP_FRAC_GT_##wc(X, Y)\t\t\t\t\t\\\n-\t|| (_FP_FRAC_EQ_##wc(X,Y) && (OP == '+' || OP == '*')))\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = X##_s;\t\t\t\t\t\t\\\n-        _FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tR##_s = Y##_s;\t\t\t\t\t\t\\\n-        _FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_EX_INVALID\t\t0x01\n-#define FP_EX_DENORM\t\t0x02\n-#define FP_EX_DIVZERO\t\t0x04\n-#define FP_EX_OVERFLOW\t\t0x08\n-#define FP_EX_UNDERFLOW\t\t0x10\n-#define FP_EX_INEXACT\t\t0x20\n-\n-struct fenv\n-{\n-  unsigned short int __control_word;\n-  unsigned short int __unused1;\n-  unsigned short int __status_word;\n-  unsigned short int __unused2;\n-  unsigned short int __tags;\n-  unsigned short int __unused3;\n-  unsigned int __eip;\n-  unsigned short int __cs_selector;\n-  unsigned int __opcode:11;\n-  unsigned int __unused4:5;\n-  unsigned int __data_offset;\n-  unsigned short int __data_selector;\n-  unsigned short int __unused5;\n-};\n-\n-#ifdef __AVX__\n- #define ASM_INVALID \"vdivss %0, %0, %0\"\n- #define ASM_DIVZERO \"vdivss %1, %0, %0\"\n-#else\n- #define ASM_INVALID \"divss %0, %0\"\n- #define ASM_DIVZERO \"divss %1, %0\"\n-#endif\n-\n-#define FP_HANDLE_EXCEPTIONS\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_INVALID)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfloat f = 0.0;\t\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (ASM_INVALID : : \"x\" (f));\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_DIVZERO)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfloat f = 1.0, g = 0.0;\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (ASM_DIVZERO : : \"x\" (f), \"x\" (g));\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_OVERFLOW)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct fenv temp;\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fnstenv %0\" : \"=m\" (temp));\t\t\\\n-\ttemp.__status_word |= FP_EX_OVERFLOW;\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fldenv %0\" : : \"m\" (temp));\t\t\\\n-\t__asm__ __volatile__ (\"fwait\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_UNDERFLOW)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct fenv temp;\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fnstenv %0\" : \"=m\" (temp));\t\t\\\n-\ttemp.__status_word |= FP_EX_UNDERFLOW;\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fldenv %0\" : : \"m\" (temp));\t\t\\\n-\t__asm__ __volatile__ (\"fwait\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (_fex & FP_EX_INEXACT)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tstruct fenv temp;\t\t\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fnstenv %0\" : \"=m\" (temp));\t\t\\\n-\ttemp.__status_word |= FP_EX_INEXACT;\t\t\t\t\\\n-\t__asm__ __volatile__ (\"fldenv %0\" : : \"m\" (temp));\t\t\\\n-\t__asm__ __volatile__ (\"fwait\");\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define FP_RND_NEAREST\t\t0\n-#define FP_RND_ZERO\t\t0xc00\n-#define FP_RND_PINF\t\t0x800\n-#define FP_RND_MINF\t\t0x400\n-\n-#define _FP_DECL_EX \\\n-  unsigned short _fcw __attribute__ ((unused)) = FP_RND_NEAREST\n-\n-#define FP_INIT_ROUNDMODE\t\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    __asm__ (\"fnstcw %0\" : \"=m\" (_fcw));\t\\\n-  } while (0)\n-\n-#define FP_ROUNDMODE\t\t(_fcw & 0xc00)\n-\n-#define\t__LITTLE_ENDIAN\t1234\n-#define\t__BIG_ENDIAN\t4321\n-\n-#define __BYTE_ORDER __LITTLE_ENDIAN\n-\n-/* Define ALIASNAME as a strong alias for NAME.  */\n-#if defined __MACH__\n-/* Mach-O doesn't support aliasing.  If these functions ever return\n-   anything but CMPtype we need to revisit this... */\n-#define strong_alias(name, aliasname) \\\n-  CMPtype aliasname (TFtype a, TFtype b) { return name(a, b); }\n-#else\n-# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n-# define _strong_alias(name, aliasname) \\\n-  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n-#endif"}, {"sha": "14b5ca1dbb3120787084122ddb2fd8fc53dc5de2", "filename": "libgcc/config/i386/sfp-exceptions.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2Fsfp-exceptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2Fsfp-exceptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fsfp-exceptions.c?ref=492fbea1624fb5b754c2abc978e3275c576b4ba8", "patch": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (C) 2012 Free Software Foundation, Inc.\n+ *\n+ * This file is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License as published by the\n+ * Free Software Foundation; either version 3, or (at your option) any\n+ * later version.\n+ * \n+ * This file is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * General Public License for more details.\n+ * \n+ * Under Section 7 of GPL version 3, you are granted additional\n+ * permissions described in the GCC Runtime Library Exception, version\n+ * 3.1, as published by the Free Software Foundation.\n+ *\n+ * You should have received a copy of the GNU General Public License and\n+ * a copy of the GCC Runtime Library Exception along with this program;\n+ * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+ * <http://www.gnu.org/licenses/>.\n+ */\n+\n+#include \"sfp-machine.h\"\n+\n+struct fenv\n+{\n+  unsigned short int __control_word;\n+  unsigned short int __unused1;\n+  unsigned short int __status_word;\n+  unsigned short int __unused2;\n+  unsigned short int __tags;\n+  unsigned short int __unused3;\n+  unsigned int __eip;\n+  unsigned short int __cs_selector;\n+  unsigned int __opcode:11;\n+  unsigned int __unused4:5;\n+  unsigned int __data_offset;\n+  unsigned short int __data_selector;\n+  unsigned short int __unused5;\n+};\n+\n+void\n+__sfp_handle_exceptions (int _fex)\n+{\n+  if (_fex & FP_EX_INVALID)\n+    {\n+      float f = 0.0f;\n+#ifdef __SSE__\n+      asm volatile (\"%vdivss\\t{%0, %d0|%d0, %0}\" : \"+x\" (f));\n+#else\n+      asm volatile (\"fdiv\\t{%y0, %0|%0, %y0}\" : \"+t\" (f));\n+      asm volatile (\"fwait\");\n+#endif\n+    }\n+  if (_fex & FP_EX_DIVZERO)\n+    {\n+      float f = 1.0f, g = 0.0f;\n+#ifdef __SSE__\n+      asm volatile (\"%vdivss\\t{%1, %d0|%d0, %1}\" : \"+x\" (f) : \"xm\" (g));\n+#else\n+      asm volatile (\"fdivs\\t%1\" : \"+t\" (f) : \"m\" (g));\n+      asm volatile (\"fwait\");\n+#endif\n+    }\n+  if (_fex & FP_EX_OVERFLOW)\n+    {\n+      struct fenv temp;\n+      asm volatile (\"fnstenv\\t%0\" : \"=m\" (temp));\n+      temp.__status_word |= FP_EX_OVERFLOW;\n+      asm volatile (\"fldenv\\t%0\" : : \"m\" (temp));\n+      asm volatile (\"fwait\");\n+    }\n+  if (_fex & FP_EX_UNDERFLOW)\n+    {\n+      struct fenv temp;\n+      asm volatile (\"fnstenv\\t%0\" : \"=m\" (temp));\n+      temp.__status_word |= FP_EX_UNDERFLOW;\n+      asm volatile (\"fldenv\\t%0\" : : \"m\" (temp));\n+      asm volatile (\"fwait\");\n+    }\n+  if (_fex & FP_EX_INEXACT)\n+    {\n+      struct fenv temp;\n+      asm volatile (\"fnstenv\\t%0\" : \"=m\" (temp));\n+      temp.__status_word |= FP_EX_INEXACT;\n+      asm volatile (\"fldenv\\t%0\" : : \"m\" (temp));\n+      asm volatile (\"fwait\");\n+    }\n+};"}, {"sha": "f84a368ebd1ebdba61d19e67fbeee02c76d73d80", "filename": "libgcc/config/i386/sfp-machine.h", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fsfp-machine.h?ref=492fbea1624fb5b754c2abc978e3275c576b4ba8", "patch": "@@ -3,8 +3,83 @@\n #define _FP_STRUCT_LAYOUT  __attribute__ ((gcc_struct))\n #endif\n \n+/* The type of the result of a floating point comparison.  This must\n+   match `__libgcc_cmp_return__' in GCC for the target.  */\n+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+#define CMPtype __gcc_CMPtype\n+\n #ifdef __x86_64__\n #include \"config/i386/64/sfp-machine.h\"\n #else\n #include \"config/i386/32/sfp-machine.h\"\n #endif\n+\n+#define _FP_KEEPNANFRACP 1\n+\n+/* Here is something Intel misdesigned: the specs don't define\n+   the case where we have two NaNs with same mantissas, but\n+   different sign. Different operations pick up different NaNs.  */\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (_FP_FRAC_GT_##wc(X, Y)\t\t\t\t\t\\\n+\t|| (_FP_FRAC_EQ_##wc(X,Y) && (OP == '+' || OP == '*')))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+        _FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+        _FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_EX_INVALID\t\t0x01\n+#define FP_EX_DENORM\t\t0x02\n+#define FP_EX_DIVZERO\t\t0x04\n+#define FP_EX_OVERFLOW\t\t0x08\n+#define FP_EX_UNDERFLOW\t\t0x10\n+#define FP_EX_INEXACT\t\t0x20\n+\n+#define FP_EX_MASK\t\t0x3f\n+\n+void __sfp_handle_exceptions (int);\n+\n+#define FP_HANDLE_EXCEPTIONS\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    if (_fex & FP_EX_MASK)\t\t\t\\\n+      __sfp_handle_exceptions (_fex);\t\t\\\n+  } while (0);\n+\n+#define FP_RND_NEAREST\t\t0\n+#define FP_RND_ZERO\t\t0xc00\n+#define FP_RND_PINF\t\t0x800\n+#define FP_RND_MINF\t\t0x400\n+\n+#define _FP_DECL_EX \\\n+  unsigned short _fcw __attribute__ ((unused)) = FP_RND_NEAREST\n+\n+#define FP_INIT_ROUNDMODE\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    __asm__ (\"fnstcw %0\" : \"=m\" (_fcw));\t\\\n+  } while (0)\n+\n+#define FP_ROUNDMODE\t\t(_fcw & 0xc00)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+#define __BYTE_ORDER __LITTLE_ENDIAN\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+#if defined __MACH__\n+/* Mach-O doesn't support aliasing.  If these functions ever return\n+   anything but CMPtype we need to revisit this... */\n+#define strong_alias(name, aliasname) \\\n+  CMPtype aliasname (TFtype a, TFtype b) { return name(a, b); }\n+#else\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));\n+#endif"}, {"sha": "685d9cf85028208ea2c6baed5c14478f7dc26ce3", "filename": "libgcc/config/i386/t-softfp", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2Ft-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/492fbea1624fb5b754c2abc978e3275c576b4ba8/libgcc%2Fconfig%2Fi386%2Ft-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-softfp?ref=492fbea1624fb5b754c2abc978e3275c576b4ba8", "patch": "@@ -0,0 +1 @@\n+LIB2ADD += $(srcdir)/config/i386/sfp-exceptions.c"}]}