{"sha": "e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTllYThiZDU4ZTQ3NTM2ZmM0NGI2MWJmNjU3YzIwZmIyMmM3NDdhZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-07-25T23:26:59Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-07-25T23:26:59Z"}, "message": "fold-const.c (constant_boolean_node): Make extern.\n\n\n\t* fold-const.c (constant_boolean_node): Make extern.\n\t(make_range): Wrap long lines.\n\t(fold_cond_expr_with_comparison): Remove unnecessary call to\n\tpedantic_non_lvalue.  Add missing calls to fold_convert.\n\t(fold_truthop): Add missing calls to fold_convert.\n\t(fold): Likewise.\n\t* tree.h (constant_boolean_node): Add prototype here.\n\t* builtins.c (expand_builtin_strncmp): Add missing calls to\n\tfold_convert.\n\t* tree-ssa-dom.c (record_equivalences_from_incoming_edge):\n\tCall fold_convert and constant_boolean_node to correct types.\n\t* tree-ssa-forwprop.c (substitute_single_use_vars): Add\n\tmissing call to fold_convert to correct types.\n\nFrom-SVN: r85169", "tree": {"sha": "95b7cdaa4a1488e04ee4b25d2031e455b1aa2318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95b7cdaa4a1488e04ee4b25d2031e455b1aa2318"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/comments", "author": null, "committer": null, "parents": [{"sha": "70502b2caf55e0a198048a5beac5f08850af3916", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70502b2caf55e0a198048a5beac5f08850af3916", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70502b2caf55e0a198048a5beac5f08850af3916"}], "stats": {"total": 98, "additions": 66, "deletions": 32}, "files": [{"sha": "14c97c66b7cca5d5e06f14a0b2e0ef9ac9abbc79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "patch": "@@ -1,3 +1,19 @@\n+2004-07-25  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (constant_boolean_node): Make extern.\n+\t(make_range): Wrap long lines.\n+\t(fold_cond_expr_with_comparison): Remove unnecessary call to\n+\tpedantic_non_lvalue.  Add missing calls to fold_convert.\n+\t(fold_truthop): Add missing calls to fold_convert.\n+\t(fold): Likewise.\n+\t* tree.h (constant_boolean_node): Add prototype here.\n+\t* builtins.c (expand_builtin_strncmp): Add missing calls to\n+\tfold_convert.\n+\t* tree-ssa-dom.c (record_equivalences_from_incoming_edge):\n+\tCall fold_convert and constant_boolean_node to correct types.\n+\t* tree-ssa-forwprop.c (substitute_single_use_vars): Add\n+\tmissing call to fold_convert to correct types.\n+\n 2004-07-26  Niall Douglas  <s_fsfeurope2@nedprod.com>\n \t    Brian Ryner  <bryner@brianryner.com>\n "}, {"sha": "bb32f1202e94efe9c4bc8fb385fc15bed345e6ea", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "patch": "@@ -3830,7 +3830,8 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n       return 0;\n \n     /* The actual new length parameter is MIN(len,arg3).  */\n-    len = fold (build2 (MIN_EXPR, TREE_TYPE (len), len, arg3));\n+    len = fold (build2 (MIN_EXPR, TREE_TYPE (len), len,\n+\t\t\tfold_convert (TREE_TYPE (len), arg3)));\n \n     /* If we don't have POINTER_TYPE, call the function.  */\n     if (arg1_align == 0 || arg2_align == 0)"}, {"sha": "bacf2b6153229328f4305a8243ce3efd7149f4cd", "filename": "gcc/fold-const.c", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "patch": "@@ -123,7 +123,6 @@ static tree optimize_minmax_comparison (tree);\n static tree extract_muldiv (tree, tree, enum tree_code, tree);\n static tree extract_muldiv_1 (tree, tree, enum tree_code, tree);\n static int multiple_of_p (tree, tree, tree);\n-static tree constant_boolean_node (int, tree);\n static tree fold_binary_op_with_conditional_arg (enum tree_code, tree, tree,\n \t\t\t\t\t\t tree, int);\n static bool fold_real_zero_addition_p (tree, tree, int);\n@@ -3634,8 +3633,9 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t     of, e.g. EQ_EXPR, is boolean.  */\n \t  if (TYPE_UNSIGNED (arg0_type) && (low == 0 || high == 0))\n \t    {\n-\t      if (! merge_ranges (&n_in_p, &n_low, &n_high, in_p, low, high,\n-\t\t\t\t  1, fold_convert (arg0_type, integer_zero_node),\n+\t      if (! merge_ranges (&n_in_p, &n_low, &n_high,\n+\t\t\t\t  in_p, low, high, 1,\n+\t\t\t\t  fold_convert (arg0_type, integer_zero_node),\n \t\t\t\t  NULL_TREE))\n \t\tbreak;\n \n@@ -3769,7 +3769,8 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t{\n \t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n \t\t\t\t      1, n_low, n_high, 1,\n-\t\t\t\t      fold_convert (arg0_type, integer_zero_node),\n+\t\t\t\t      fold_convert (arg0_type,\n+\t\t\t\t\t\t    integer_zero_node),\n \t\t\t\t      high_positive))\n \t\t    break;\n \n@@ -3781,7 +3782,8 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t\t     that will be interpreted as negative.  */\n \t\t  if (! merge_ranges (&n_in_p, &n_low, &n_high,\n \t\t\t\t      0, n_low, n_high, 1,\n-\t\t\t\t      fold_convert (arg0_type, integer_zero_node),\n+\t\t\t\t      fold_convert (arg0_type,\n+\t\t\t\t\t\t    integer_zero_node),\n \t\t\t\t      high_positive))\n \t\t    break;\n \n@@ -4210,7 +4212,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n       if (comp_code == NE_EXPR)\n \treturn pedantic_non_lvalue (fold_convert (type, arg1));\n       else if (comp_code == EQ_EXPR)\n-\treturn pedantic_non_lvalue (fold_convert (type, integer_zero_node));\n+\treturn fold_convert (type, integer_zero_node);\n     }\n \n   /* Try some transformations of A op B ? A : B.\n@@ -4266,22 +4268,31 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t     so that we can convert this back to the\n \t     corresponding COND_EXPR.  */\n \t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n-\t    return pedantic_non_lvalue (\n-\t\t     fold_convert (type, fold (build2 (MIN_EXPR, comp_type,\n-\t\t\t\t         (comp_code == LE_EXPR\n-\t\t\t\t          ? comp_op0 : comp_op1),\n-\t\t\t\t         (comp_code == LE_EXPR\n-\t\t\t\t          ? comp_op1 : comp_op0)))));\n+\t    {\n+\t      comp_op0 = fold_convert (comp_type, comp_op0);\n+\t      comp_op1 = fold_convert (comp_type, comp_op1);\n+\t      tem = fold (build2 (MIN_EXPR, comp_type,\n+\t\t\t\t  (comp_code == LE_EXPR\n+\t\t\t\t   ? comp_op0 : comp_op1),\n+\t\t\t\t  (comp_code == LE_EXPR\n+\t\t\t\t   ? comp_op1 : comp_op0)));\n+\t      return pedantic_non_lvalue (fold_convert (type, tem));\n+\t    }\n \t  break;\n \tcase GE_EXPR:\n \tcase GT_EXPR:\n \t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1))))\n-\t    return pedantic_non_lvalue (\n-\t\t     fold_convert (type, fold (build2 (MAX_EXPR, comp_type,\n-\t\t\t\t         (comp_code == GE_EXPR\n-\t\t\t\t          ? comp_op0 : comp_op1),\n-\t\t\t\t         (comp_code == GE_EXPR\n-\t\t\t\t          ? comp_op1 : comp_op0)))));\n+\t    {\n+\t      comp_op0 = fold_convert (comp_type, comp_op0);\n+\t      comp_op1 = fold_convert (comp_type, comp_op1);\n+\t      tem = fold (build2 (MAX_EXPR, comp_type,\n+\t\t\t\t  (comp_code == GE_EXPR\n+\t\t\t\t   ? comp_op0 : comp_op1),\n+\t\t\t\t  (comp_code == GE_EXPR\n+\t\t\t\t   ? comp_op1 : comp_op0)));\n+\t      tem = fold (build2 (MAX_EXPR, comp_type, comp_op0, comp_op1));\n+\t      return pedantic_non_lvalue (fold_convert (type, tem));\n+\t    }\n \t  break;\n \tdefault:\n \t  abort ();\n@@ -4544,13 +4555,15 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n \n   if (lcode == BIT_AND_EXPR && integer_onep (TREE_OPERAND (lhs, 1)))\n     {\n-      lhs = build2 (NE_EXPR, truth_type, lhs, integer_zero_node);\n+      lhs = build2 (NE_EXPR, truth_type, lhs,\n+\t\t    fold_convert (TREE_TYPE (lhs), integer_zero_node));\n       lcode = NE_EXPR;\n     }\n \n   if (rcode == BIT_AND_EXPR && integer_onep (TREE_OPERAND (rhs, 1)))\n     {\n-      rhs = build2 (NE_EXPR, truth_type, rhs, integer_zero_node);\n+      rhs = build2 (NE_EXPR, truth_type, rhs,\n+\t\t    fold_convert (TREE_TYPE (rhs), integer_zero_node));\n       rcode = NE_EXPR;\n     }\n \n@@ -5312,7 +5325,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n /* Return a node which has the indicated constant VALUE (either 0 or\n    1), and is of the indicated TYPE.  */\n \n-static tree\n+tree\n constant_boolean_node (int value, tree type)\n {\n   if (type == integer_type_node)\n@@ -8376,7 +8389,8 @@ fold (tree expr)\n \t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n \t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n \treturn fold (build2 (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n-\t\t\t     arg0, integer_zero_node));\n+\t\t\t     arg0, fold_convert (TREE_TYPE (arg0),\n+\t\t\t\t\t\t integer_zero_node)));\n \n       /* If we have (A & C) != 0 or (A & C) == 0 and C is a power of\n \t 2, then fold the expression into shifts and logical operations.  */\n@@ -8644,8 +8658,9 @@ fold (tree expr)\n \t      && ! TREE_CHAIN (arglist))\n \t    return fold (build2 (code, type,\n \t\t\t\t build1 (INDIRECT_REF, char_type_node,\n-\t\t\t\t\t TREE_VALUE(arglist)),\n-\t\t\t\t integer_zero_node));\n+\t\t\t\t\t TREE_VALUE (arglist)),\n+\t\t\t\t fold_convert (char_type_node,\n+\t\t\t\t\t       integer_zero_node)));\n \t}\n \n       /* We can fold X/C1 op C2 where C1 and C2 are integer constants"}, {"sha": "7382d5f8875ef17f264c8f31183cd87d9dd70be2", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "patch": "@@ -1541,7 +1541,8 @@ record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data,\n \t      && !CASE_HIGH (match_case))\n \t    {\n \t      eq_expr_value.dst = switch_cond;\n-\t      eq_expr_value.src = CASE_LOW (match_case);\n+\t      eq_expr_value.src = fold_convert (TREE_TYPE (switch_cond),\n+\t\t\t\t\t\tCASE_LOW (match_case));\n \t    }\n \t}\n     }\n@@ -3489,7 +3490,7 @@ get_eq_expr_value (tree if_stmt,\n   if (TREE_CODE (cond) == SSA_NAME)\n     {\n       retval.dst = cond;\n-      retval.src = (true_arm ? integer_one_node : integer_zero_node);\n+      retval.src = constant_boolean_node (true_arm, TREE_TYPE (cond));\n       return retval;\n     }\n "}, {"sha": "7df513f4e8aff694a9fe297dddf5981492f7591b", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "patch": "@@ -391,6 +391,7 @@ substitute_single_use_vars (varray_type *cond_worklist,\n \t    {\n \t      bool invert = false;\n \t      enum tree_code new_code;\n+\t      tree new_arg;\n \n \t      /* TEST_VAR was set from a TRUTH_NOT_EXPR or a NOP_EXPR.  */\n \t      if (def_rhs_code == TRUTH_NOT_EXPR)\n@@ -408,11 +409,10 @@ substitute_single_use_vars (varray_type *cond_worklist,\n \t      if (invert)\n \t\tnew_code = (new_code == EQ_EXPR ? NE_EXPR  : EQ_EXPR);\n \n-\t      new_cond = build (new_code, \n-\t\t\t\tboolean_type_node,\n-\t\t\t\tTREE_OPERAND (def_rhs, 0),\n-\t\t\t\tconvert (TREE_TYPE (def_rhs),\n-\t\t\t\t\t integer_zero_node));\n+\t      new_arg = TREE_OPERAND (def_rhs, 0);\n+\t      new_cond = build2 (new_code, boolean_type_node, new_arg,\n+\t\t\t\t fold_convert (TREE_TYPE (new_arg),\n+\t\t\t\t\t       integer_zero_node));\n \t    }\n \n \t  /* Dump details.  */"}, {"sha": "c20944ac04e81bcaa233c923c3bd1de5362307ee", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ea8bd58e47536fc44b61bf657c20fb22c747ad/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e9ea8bd58e47536fc44b61bf657c20fb22c747ad", "patch": "@@ -3442,6 +3442,7 @@ extern tree int_const_binop (enum tree_code, tree, tree, int);\n extern tree build_fold_addr_expr (tree);\n extern tree build_fold_addr_expr_with_type (tree, tree);\n extern tree build_fold_indirect_ref (tree);\n+extern tree constant_boolean_node (int, tree);\n \n extern bool tree_swap_operands_p (tree, tree, bool);\n extern enum tree_code swap_tree_comparison (enum tree_code);"}]}