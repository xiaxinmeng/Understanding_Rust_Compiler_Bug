{"sha": "308216549297c41fb602dced560fa1ed8af0f8f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA4MjE2NTQ5Mjk3YzQxZmI2MDJkY2VkNTYwZmExZWQ4YWYwZjhmNg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2008-09-11T14:45:05Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2008-09-11T14:45:05Z"}, "message": "dojump.c (do_jump): Move below.\n\n2008-09-11  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* dojump.c (do_jump) [BIT_AND_EXPR]: Move below.  Fall through to\n\tTRUTH_AND_EXPR for boolean (1-bit precision) expressions.\n\t(do_jump) [BIT_IOR_EXPR]: Compile as TRUTH_OR_EXPR.\n\n\t* tree-flow.h (simplify_stmt_using_ranges): Accept a GSI, return a bool.\n\t* tree-ssa-propagate.c (substitute_and_fold): Pass a GSI to\n\tVRP's simplify_stmt_using_ranges.  Do simplify_stmt_using_ranges\n\tbefore finalizing the changes.\n\t* tree-vrp.c (extract_range_from_binary_expr): Add limited support\n\tfor BIT_IOR_EXPR.\n\t(simplify_truth_ops_using_ranges): New.\n\t(simplify_div_or_mod_using_ranges, simplify_abs_using_ranges,\n\tsimplify_cond_using_ranges, simplify_switch_using_ranges): Return\n\twhether a simplification was made.\n\t(simplify_stmt_using_ranges): Ditto, and accept a GSI.  For GS_ASSIGN,\n\tuse a switch statement and also call simplify_truth_ops_using_ranges.\n\ntestsuite:\n2008-09-11  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* gcc.dg/tree-ssa/vrp47.c: New.\n\t* gcc.target/i386/andor-2.c: New.\n\nFrom-SVN: r140288", "tree": {"sha": "92b409e6b2cc1567926f357bf36f519f4895571f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92b409e6b2cc1567926f357bf36f519f4895571f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/308216549297c41fb602dced560fa1ed8af0f8f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308216549297c41fb602dced560fa1ed8af0f8f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/308216549297c41fb602dced560fa1ed8af0f8f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/308216549297c41fb602dced560fa1ed8af0f8f6/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf9757477e367cf9ab4e8dae6489dcd09178033e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf9757477e367cf9ab4e8dae6489dcd09178033e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf9757477e367cf9ab4e8dae6489dcd09178033e"}], "stats": {"total": 525, "additions": 416, "deletions": 109}, "files": [{"sha": "2f4e784fc632b320667ed7b29af87480781de8c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=308216549297c41fb602dced560fa1ed8af0f8f6", "patch": "@@ -1,3 +1,22 @@\n+2008-09-11  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* dojump.c (do_jump) [BIT_AND_EXPR]: Move below.  Fall through to\n+\tTRUTH_AND_EXPR for boolean (1-bit precision) expressions.\n+\t(do_jump) [BIT_IOR_EXPR]: Compile as TRUTH_OR_EXPR.\n+\n+\t* tree-flow.h (simplify_stmt_using_ranges): Accept a GSI, return a bool.\n+\t* tree-ssa-propagate.c (substitute_and_fold): Pass a GSI to\n+\tVRP's simplify_stmt_using_ranges.  Do simplify_stmt_using_ranges\n+\tbefore finalizing the changes.\n+\t* tree-vrp.c (extract_range_from_binary_expr): Add limited support\n+\tfor BIT_IOR_EXPR.\n+\t(simplify_truth_ops_using_ranges): New.\n+\t(simplify_div_or_mod_using_ranges, simplify_abs_using_ranges,\n+\tsimplify_cond_using_ranges, simplify_switch_using_ranges): Return\n+\twhether a simplification was made.\n+\t(simplify_stmt_using_ranges): Ditto, and accept a GSI.  For GS_ASSIGN,\n+\tuse a switch statement and also call simplify_truth_ops_using_ranges.\n+\n 2008-09-11  Jan Hubicka  <jh@suse.cz>\n \n \t* ggc-common.c (loc_array): Make static."}, {"sha": "849f69f07cdfcb8c894ac9c53af3a0d136eeb9d5", "filename": "gcc/dojump.c", "status": "modified", "additions": 80, "deletions": 74, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=308216549297c41fb602dced560fa1ed8af0f8f6", "patch": "@@ -208,79 +208,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n       break;\n \n-    case BIT_AND_EXPR:\n-      /* fold_single_bit_test() converts (X & (1 << C)) into (X >> C) & 1.\n-\t See if the former is preferred for jump tests and restore it\n-\t if so.  */\n-      if (integer_onep (TREE_OPERAND (exp, 1)))\n-\t{\n-\t  tree exp0 = TREE_OPERAND (exp, 0);\n-\t  rtx set_label, clr_label;\n-\n-\t  /* Strip narrowing integral type conversions.  */\n-\t  while (CONVERT_EXPR_P (exp0)\n-\t\t && TREE_OPERAND (exp0, 0) != error_mark_node\n-\t\t && TYPE_PRECISION (TREE_TYPE (exp0))\n-\t\t    <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (exp0, 0))))\n-\t    exp0 = TREE_OPERAND (exp0, 0);\n-\n-\t  /* \"exp0 ^ 1\" inverts the sense of the single bit test.  */\n-\t  if (TREE_CODE (exp0) == BIT_XOR_EXPR\n-\t      && integer_onep (TREE_OPERAND (exp0, 1)))\n-\t    {\n-\t      exp0 = TREE_OPERAND (exp0, 0);\n-\t      clr_label = if_true_label;\n-\t      set_label = if_false_label;\n-\t    }\n-\t  else\n-\t    {\n-\t      clr_label = if_false_label;\n-\t      set_label = if_true_label;\n-\t    }\n-\n-\t  if (TREE_CODE (exp0) == RSHIFT_EXPR)\n-\t    {\n-\t      tree arg = TREE_OPERAND (exp0, 0);\n-\t      tree shift = TREE_OPERAND (exp0, 1);\n-\t      tree argtype = TREE_TYPE (arg);\n-\t      if (TREE_CODE (shift) == INTEGER_CST\n-\t\t  && compare_tree_int (shift, 0) >= 0\n-\t\t  && compare_tree_int (shift, HOST_BITS_PER_WIDE_INT) < 0\n-\t\t  && prefer_and_bit_test (TYPE_MODE (argtype),\n-\t\t\t\t\t  TREE_INT_CST_LOW (shift)))\n-\t\t{\n-\t\t  HOST_WIDE_INT mask = (HOST_WIDE_INT) 1\n-\t\t\t\t       << TREE_INT_CST_LOW (shift);\n-\t\t  do_jump (build2 (BIT_AND_EXPR, argtype, arg,\n-\t\t\t\t   build_int_cst_type (argtype, mask)),\n-\t\t\t   clr_label, set_label);\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* If we are AND'ing with a small constant, do this comparison in the\n-         smallest type that fits.  If the machine doesn't have comparisons\n-         that small, it will be converted back to the wider comparison.\n-         This helps if we are testing the sign bit of a narrower object.\n-         combine can't do this for us because it can't know whether a\n-         ZERO_EXTRACT or a compare in a smaller mode exists, but we do.  */\n-\n-      if (! SLOW_BYTE_ACCESS\n-          && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n-          && TYPE_PRECISION (TREE_TYPE (exp)) <= HOST_BITS_PER_WIDE_INT\n-          && (i = tree_floor_log2 (TREE_OPERAND (exp, 1))) >= 0\n-          && (mode = mode_for_size (i + 1, MODE_INT, 0)) != BLKmode\n-          && (type = lang_hooks.types.type_for_mode (mode, 1)) != 0\n-          && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n-          && (optab_handler (cmp_optab, TYPE_MODE (type))->insn_code\n-              != CODE_FOR_nothing))\n-        {\n-          do_jump (fold_convert (type, exp), if_false_label, if_true_label);\n-          break;\n-        }\n-      goto normal;\n-\n     case TRUTH_NOT_EXPR:\n       do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);\n       break;\n@@ -504,8 +431,86 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t    do_jump (cmp0, 0, if_true_label);\n \t    do_jump (cmp1, if_false_label, if_true_label);\n           }\n-      }\n       break;\n+    }\n+\n+    case BIT_AND_EXPR:\n+      /* fold_single_bit_test() converts (X & (1 << C)) into (X >> C) & 1.\n+\t See if the former is preferred for jump tests and restore it\n+\t if so.  */\n+      if (integer_onep (TREE_OPERAND (exp, 1)))\n+\t{\n+\t  tree exp0 = TREE_OPERAND (exp, 0);\n+\t  rtx set_label, clr_label;\n+\n+\t  /* Strip narrowing integral type conversions.  */\n+\t  while (CONVERT_EXPR_P (exp0)\n+\t\t && TREE_OPERAND (exp0, 0) != error_mark_node\n+\t\t && TYPE_PRECISION (TREE_TYPE (exp0))\n+\t\t    <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (exp0, 0))))\n+\t    exp0 = TREE_OPERAND (exp0, 0);\n+\n+\t  /* \"exp0 ^ 1\" inverts the sense of the single bit test.  */\n+\t  if (TREE_CODE (exp0) == BIT_XOR_EXPR\n+\t      && integer_onep (TREE_OPERAND (exp0, 1)))\n+\t    {\n+\t      exp0 = TREE_OPERAND (exp0, 0);\n+\t      clr_label = if_true_label;\n+\t      set_label = if_false_label;\n+\t    }\n+\t  else\n+\t    {\n+\t      clr_label = if_false_label;\n+\t      set_label = if_true_label;\n+\t    }\n+\n+\t  if (TREE_CODE (exp0) == RSHIFT_EXPR)\n+\t    {\n+\t      tree arg = TREE_OPERAND (exp0, 0);\n+\t      tree shift = TREE_OPERAND (exp0, 1);\n+\t      tree argtype = TREE_TYPE (arg);\n+\t      if (TREE_CODE (shift) == INTEGER_CST\n+\t\t  && compare_tree_int (shift, 0) >= 0\n+\t\t  && compare_tree_int (shift, HOST_BITS_PER_WIDE_INT) < 0\n+\t\t  && prefer_and_bit_test (TYPE_MODE (argtype),\n+\t\t\t\t\t  TREE_INT_CST_LOW (shift)))\n+\t\t{\n+\t\t  HOST_WIDE_INT mask = (HOST_WIDE_INT) 1\n+\t\t\t\t       << TREE_INT_CST_LOW (shift);\n+\t\t  do_jump (build2 (BIT_AND_EXPR, argtype, arg,\n+\t\t\t\t   build_int_cst_type (argtype, mask)),\n+\t\t\t   clr_label, set_label);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* If we are AND'ing with a small constant, do this comparison in the\n+         smallest type that fits.  If the machine doesn't have comparisons\n+         that small, it will be converted back to the wider comparison.\n+         This helps if we are testing the sign bit of a narrower object.\n+         combine can't do this for us because it can't know whether a\n+         ZERO_EXTRACT or a compare in a smaller mode exists, but we do.  */\n+\n+      if (! SLOW_BYTE_ACCESS\n+          && TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n+          && TYPE_PRECISION (TREE_TYPE (exp)) <= HOST_BITS_PER_WIDE_INT\n+          && (i = tree_floor_log2 (TREE_OPERAND (exp, 1))) >= 0\n+          && (mode = mode_for_size (i + 1, MODE_INT, 0)) != BLKmode\n+          && (type = lang_hooks.types.type_for_mode (mode, 1)) != 0\n+          && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n+          && (optab_handler (cmp_optab, TYPE_MODE (type))->insn_code\n+              != CODE_FOR_nothing))\n+        {\n+          do_jump (fold_convert (type, exp), if_false_label, if_true_label);\n+          break;\n+        }\n+\n+      if (TYPE_PRECISION (TREE_TYPE (exp)) > 1\n+\t  || TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)\n+\tgoto normal;\n+\n+      /* Boolean comparisons can be compiled as TRUTH_AND_EXPR.  */\n \n     case TRUTH_AND_EXPR:\n       /* High branch cost, expand as the bitwise AND of the conditions.\n@@ -530,6 +535,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t}\n       break;\n \n+    case BIT_IOR_EXPR:\n     case TRUTH_OR_EXPR:\n       /* High branch cost, expand as the bitwise OR of the conditions.\n \t Do the same if the RHS has side effects, because we're effectively"}, {"sha": "84ba7755e36aa54261f834d2dd5786e458e55db0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=308216549297c41fb602dced560fa1ed8af0f8f6", "patch": "@@ -1,3 +1,8 @@\n+2008-09-11  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* gcc.dg/tree-ssa/vrp47.c: New.\n+\t* gcc.target/i386/andor-2.c: New.\n+\n 2008-09-11  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/37474"}, {"sha": "a1ee927816cb19f7e7981f2cdca0ffa58d8feefb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp47.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp47.c?ref=308216549297c41fb602dced560fa1ed8af0f8f6", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp -fdump-tree-dom\" } */\n+\n+int h(int x, int y)\n+{\n+  if ((x >= 0 && x <= 1) && (y >= 0 && y <= 1))\n+    return x && y;\n+  else\n+    return -1;\n+}\n+\n+int g(int x, int y)\n+{\n+  if ((x >= 0 && x <= 1) && (y >= 0 && y <= 1))\n+    return x || y;\n+  else\n+    return -1;\n+}\n+\n+int f(int x)\n+{\n+  if (x != 0 && x != 1)\n+    return -2;\n+\n+  else\n+    return !x;\n+}\n+\n+/* Test that x and y are never compared to 0 -- they're always known to be\n+   0 or 1.  */\n+/* { dg-final { scan-tree-dump-times \"\\[xy\\]\\[^ \\]* !=\" 0 \"vrp1\" } } */\n+\n+/* This one needs more copy propagation that only happens in dom1.  */\n+/* { dg-final { scan-tree-dump-times \"x\\[^ \\]* & y\" 1 \"dom1\" } } */\n+/* { dg-final { scan-tree-dump-times \"x\\[^ \\]* & y\" 1 \"vrp1\" { xfail *-*-* } } } */\n+\n+/* These two are fully simplified by VRP.  */\n+/* { dg-final { scan-tree-dump-times \"x\\[^ \\]* \\[|\\] y\" 1 \"vrp1\" } } */\n+/* { dg-final { scan-tree-dump-times \"x\\[^ \\]* \\\\^ 1\" 1 \"vrp1\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"vrp\\[0-9\\]\" } } */\n+/* { dg-final { cleanup-tree-dump \"dom\\[0-9\\]\" } } */"}, {"sha": "88118aab575902b1acbc8cabe7e0808c9ccf1ce2", "filename": "gcc/testsuite/gcc.target/i386/andor-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fandor-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fandor-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fandor-2.c?ref=308216549297c41fb602dced560fa1ed8af0f8f6", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mtune=i686\" } */\n+\n+int h(int x, int y)\n+{\n+  if ((x >= 0 && x <= 1) && (y >= 0 && y <= 1))\n+    return x && y;\n+  else\n+    return -1;\n+}\n+\n+int g(int x, int y)\n+{\n+  if ((x >= 0 && x <= 1) && (y >= 0 && y <= 1))\n+    return x || y;\n+  else\n+    return -1;\n+}\n+\n+int f(int x, int y)\n+{\n+  if (x != 0 && x != 1)\n+    return -2;\n+\n+  else\n+    return !x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"setne\" } } */\n+/* { dg-final { scan-assembler-not \"sete\" } } */"}, {"sha": "7f3c0dddeb57a04945f302d79bf3c72c8dbe3c8d", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=308216549297c41fb602dced560fa1ed8af0f8f6", "patch": "@@ -913,7 +913,7 @@ tree fold_const_aggregate_ref (tree);\n \n /* In tree-vrp.c  */\n tree vrp_evaluate_conditional (enum tree_code, tree, tree, gimple);\n-void simplify_stmt_using_ranges (gimple);\n+bool simplify_stmt_using_ranges (gimple_stmt_iterator *);\n \n /* In tree-ssa-dom.c  */\n extern void dump_dominator_optimization_stats (FILE *);"}, {"sha": "86bc23812145543824aeca139a71e66014afc2b0", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=308216549297c41fb602dced560fa1ed8af0f8f6", "patch": "@@ -1098,6 +1098,7 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t{\n           bool did_replace;\n \t  gimple stmt = gsi_stmt (i);\n+\t  gimple old_stmt;\n \t  enum gimple_code code = gimple_code (stmt);\n \n \t  /* Ignore ASSERT_EXPRs.  They are used by VRP to generate\n@@ -1162,12 +1163,24 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t      && !did_replace)\n \t    did_replace |= replace_uses_in (stmt, prop_value);\n \n-\t  /* If we made a replacement, fold and cleanup the statement.  */\n+\t  /* If we made a replacement, fold the statement.  */\n+\n+\t  old_stmt = stmt;\n \t  if (did_replace)\n-\t    {\n-\t      gimple old_stmt = stmt;\n+\t    fold_stmt (&i);\n+\n+\t  /* Some statements may be simplified using ranges.  For\n+\t     example, division may be replaced by shifts, modulo\n+\t     replaced with bitwise and, etc.   Do this after \n+\t     substituting constants, folding, etc so that we're\n+\t     presented with a fully propagated, canonicalized\n+\t     statement.  */\n+\t  if (use_ranges_p)\n+\t    did_replace |= simplify_stmt_using_ranges (&i);\n \n-\t      fold_stmt (&i);\n+\t  /* Now cleanup.  */\n+\t  if (did_replace)\n+\t    {\n \t      stmt = gsi_stmt (i);\n \n               /* If we cleaned up EH information from the statement,\n@@ -1207,15 +1220,6 @@ substitute_and_fold (prop_value_t *prop_value, bool use_ranges_p)\n \t\tfprintf (dump_file, \"Not folded\\n\");\n \t    }\n \n-\t  /* Some statements may be simplified using ranges.  For\n-\t     example, division may be replaced by shifts, modulo\n-\t     replaced with bitwise and, etc.   Do this after \n-\t     substituting constants, folding, etc so that we're\n-\t     presented with a fully propagated, canonicalized\n-\t     statement.  */\n-\t  if (use_ranges_p)\n-\t    simplify_stmt_using_ranges (stmt);\n-\n \t  gsi_prev (&i);\n \t}\n     }"}, {"sha": "fffa224ff43340a17cc5bc38273996ac1197fdac", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 222, "deletions": 21, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/308216549297c41fb602dced560fa1ed8af0f8f6/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=308216549297c41fb602dced560fa1ed8af0f8f6", "patch": "@@ -2055,6 +2055,7 @@ extract_range_from_binary_expr (value_range_t *vr,\n       && code != MIN_EXPR\n       && code != MAX_EXPR\n       && code != BIT_AND_EXPR\n+      && code != BIT_IOR_EXPR\n       && code != TRUTH_AND_EXPR\n       && code != TRUTH_OR_EXPR)\n     {\n@@ -2415,6 +2416,45 @@ extract_range_from_binary_expr (value_range_t *vr,\n \t  return;\n \t}\n     }\n+  else if (code == BIT_IOR_EXPR)\n+    {\n+      if (vr0.type == VR_RANGE\n+          && vr1.type == VR_RANGE\n+\t  && TREE_CODE (vr0.min) == INTEGER_CST\n+\t  && TREE_CODE (vr1.min) == INTEGER_CST\n+\t  && TREE_CODE (vr0.max) == INTEGER_CST\n+\t  && TREE_CODE (vr1.max) == INTEGER_CST\n+\t  && tree_int_cst_sgn (vr0.min) >= 0\n+\t  && tree_int_cst_sgn (vr1.min) >= 0)\n+\t{\n+\t  double_int vr0_max = tree_to_double_int (vr0.max);\n+\t  double_int vr1_max = tree_to_double_int (vr1.max);\n+\t  double_int ior_max;\n+\n+\t  /* Set all bits to the right of the most significant one to 1.\n+\t     For example, [0, 4] | [4, 4] = [4, 7]. */\n+\t  ior_max.low = vr0_max.low | vr1_max.low;\n+\t  ior_max.high = vr0_max.high | vr1_max.high;\n+\t  if (ior_max.high != 0)\n+\t    {\n+\t      ior_max.low = ~0u;\n+\t      ior_max.high |= ((HOST_WIDE_INT) 1\n+\t\t\t       << floor_log2 (ior_max.high)) - 1;\n+\t    }\n+\t  else\n+\t    ior_max.low |= ((unsigned HOST_WIDE_INT) 1u\n+\t\t\t    << floor_log2 (ior_max.low)) - 1;\n+\n+\t  /* Both of these endpoints are conservative.  */\n+          min = vrp_int_const_binop (MAX_EXPR, vr0.min, vr1.min);\n+          max = double_int_to_tree (expr_type, ior_max);\n+\t}\n+      else\n+\t{\n+\t  set_value_range_to_varying (vr);\n+\t  return;\n+\t}\n+    }\n   else\n     gcc_unreachable ();\n \n@@ -6251,11 +6291,137 @@ vrp_visit_phi_node (gimple phi)\n   return SSA_PROP_VARYING;\n }\n \n+/* Simplify boolean operations if the source is known\n+   to be already a boolean.  */\n+static bool\n+simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n+{\n+  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n+  tree val = NULL;\n+  tree op0, op1;\n+  value_range_t *vr;\n+  bool sop = false;\n+  bool need_conversion;\n+\n+  op0 = gimple_assign_rhs1 (stmt);\n+  vr = get_value_range (op0);\n+  if (TYPE_PRECISION (TREE_TYPE (op0)) != 1)\n+    {\n+      val = compare_range_with_value (GE_EXPR, vr, integer_zero_node, &sop);\n+      if (!val || !integer_onep (val))\n+        return false;\n+\n+      val = compare_range_with_value (LE_EXPR, vr, integer_one_node, &sop);\n+      if (!val || !integer_onep (val))\n+        return false;\n+    }\n+\n+  if (rhs_code == TRUTH_NOT_EXPR)\n+    {\n+      rhs_code = NE_EXPR;\n+      op1 = integer_one_node;\n+    }\n+\n+  else\n+    {\n+      op1 = gimple_assign_rhs2 (stmt);\n+\n+      /* Reduce number of cases to handle.  */\n+      if (is_gimple_min_invariant (op1))\n+\t{\n+          /* Exclude anything that should have been already folded.  */\n+\t  gcc_assert (rhs_code == EQ_EXPR || rhs_code == NE_EXPR\n+\t\t      || rhs_code == TRUTH_XOR_EXPR);\n+\t  gcc_assert (integer_zerop (op1) || integer_onep (op1));\n+\n+\t  /* Limit the number of cases we have to consider.  */\n+\t  if (rhs_code == EQ_EXPR)\n+\t    {\n+\t      rhs_code = NE_EXPR;\n+\t      op1 = fold_unary (TRUTH_NOT_EXPR, TREE_TYPE (op1), op1);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Punt on A == B as there is no BIT_XNOR_EXPR.  */\n+\t  if (rhs_code == EQ_EXPR)\n+\t    return false;\n+\n+\t  if (TYPE_PRECISION (TREE_TYPE (op1)) != 1)\n+\t    {\n+\t      vr = get_value_range (op1);\n+\t      val = compare_range_with_value (GE_EXPR, vr, integer_zero_node, &sop);\n+\t      if (!val || !integer_onep (val))\n+\t        return false;\n+\n+\t      val = compare_range_with_value (LE_EXPR, vr, integer_one_node, &sop);\n+\t      if (!val || !integer_onep (val))\n+\t        return false;\n+\t    }\n+\t}\n+    }\n+\n+  if (sop && issue_strict_overflow_warning (WARN_STRICT_OVERFLOW_MISC))\n+    {\n+      location_t location;\n+\n+      if (!gimple_has_location (stmt))\n+\tlocation = input_location;\n+      else\n+\tlocation = gimple_location (stmt);\n+\n+      if (rhs_code == TRUTH_AND_EXPR || rhs_code == TRUTH_OR_EXPR)\n+        warning_at (location, OPT_Wstrict_overflow,\n+\t            _(\"assuming signed overflow does not occur when \"\n+\t\t      \"simplifying && or || to & or |\"));\n+      else\n+        warning_at (location, OPT_Wstrict_overflow,\n+\t            _(\"assuming signed overflow does not occur when \"\n+\t\t      \"simplifying ==, != or ! to identity or ^\"));\n+    }\n+\n+  need_conversion =\n+    !useless_type_conversion_p (TREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\t\t        TREE_TYPE (op0));\n+\n+  switch (rhs_code)\n+    {\n+    case TRUTH_AND_EXPR:\n+      rhs_code = BIT_AND_EXPR;\n+      break;\n+    case TRUTH_OR_EXPR:\n+      rhs_code = BIT_IOR_EXPR;\n+      break;\n+    case TRUTH_XOR_EXPR:\n+    case NE_EXPR:\n+      if (integer_zerop (op1))\n+\t{\n+\t  gimple_assign_set_rhs_with_ops (gsi,\n+\t\t\t\t\t  need_conversion ? NOP_EXPR : SSA_NAME,\n+\t\t\t\t\t  op0, NULL);\n+\t  update_stmt (gsi_stmt (*gsi));\n+\t  return true;\n+\t}\n+\n+      rhs_code = BIT_XOR_EXPR;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (need_conversion)\n+    return false;\n+\n+  gimple_assign_set_rhs_with_ops (gsi, rhs_code, op0, op1);\n+  update_stmt (gsi_stmt (*gsi));\n+  return true;\n+}\n+\n /* Simplify a division or modulo operator to a right shift or\n    bitwise and if the first operand is unsigned or is greater\n    than zero and the second operand is an exact power of two.  */\n \n-static void\n+static bool\n simplify_div_or_mod_using_ranges (gimple stmt)\n {\n   enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n@@ -6315,14 +6481,17 @@ simplify_div_or_mod_using_ranges (gimple stmt)\n \t}\n \n       update_stmt (stmt);\n+      return true;\n     }\n+\n+  return false;\n }\n \n /* If the operand to an ABS_EXPR is >= 0, then eliminate the\n    ABS_EXPR.  If the operand is <= 0, then simplify the\n    ABS_EXPR into a NEGATE_EXPR.  */\n \n-static void\n+static bool\n simplify_abs_using_ranges (gimple stmt)\n {\n   tree val = NULL;\n@@ -6377,8 +6546,11 @@ simplify_abs_using_ranges (gimple stmt)\n \t  else\n \t    gimple_assign_set_rhs_code (stmt, SSA_NAME);\n \t  update_stmt (stmt);\n+\t  return true;\n \t}\n     }\n+\n+  return false;\n }\n \n /* We are comparing trees OP0 and OP1 using COND_CODE.  OP0 has\n@@ -6453,7 +6625,7 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n    test if the range information indicates only one value can satisfy\n    the original conditional.  */\n \n-static void\n+static bool\n simplify_cond_using_ranges (gimple stmt)\n {\n   tree op0 = gimple_cond_lhs (stmt);\n@@ -6494,8 +6666,8 @@ simplify_cond_using_ranges (gimple stmt)\n \t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n-\t      return;\n \n+\t      return true;\n \t    }\n \n \t  /* Try again after inverting the condition.  We only deal\n@@ -6524,17 +6696,19 @@ simplify_cond_using_ranges (gimple stmt)\n \t\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n-\t      return;\n \n+\t      return true;\n \t    }\n \t}\n     }\n+\n+  return false;\n }\n \n /* Simplify a switch statement using the value range of the switch\n    argument.  */\n \n-static void\n+static bool\n simplify_switch_using_ranges (gimple stmt)\n {\n   tree op = gimple_switch_index (stmt);\n@@ -6547,14 +6721,14 @@ simplify_switch_using_ranges (gimple stmt)\n   switch_update su;\n \n   if (TREE_CODE (op) != SSA_NAME)\n-    return;\n+    return false;\n \n   vr = get_value_range (op);\n \n   /* We can only handle integer ranges.  */\n   if (vr->type != VR_RANGE\n       || symbolic_range_p (vr))\n-    return;\n+    return false;\n \n   /* Find case label for min/max of the value range.  */\n   n = gimple_switch_num_labels (stmt);\n@@ -6564,7 +6738,7 @@ simplify_switch_using_ranges (gimple stmt)\n   if (i == 1\n       && j == n - 1\n       && take_default)\n-    return;\n+    return false;\n \n   /* Build a new vector of taken case labels.  */\n   vec2 = make_tree_vec (j - i + 1 + (int)take_default);\n@@ -6605,35 +6779,62 @@ simplify_switch_using_ranges (gimple stmt)\n   su.stmt = stmt;\n   su.vec = vec2;\n   VEC_safe_push (switch_update, heap, to_update_switch_stmts, &su);\n+  return false;\n }\n \n /* Simplify STMT using ranges if possible.  */\n \n-void\n-simplify_stmt_using_ranges (gimple stmt)\n+bool\n+simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n {\n+  gimple stmt = gsi_stmt (*gsi);\n   if (is_gimple_assign (stmt))\n     {\n       enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n \n+      switch (rhs_code)\n+\t{\n+\tcase EQ_EXPR:\n+\tcase NE_EXPR:\n+\tcase TRUTH_NOT_EXPR:\n+\tcase TRUTH_AND_EXPR:\n+\tcase TRUTH_OR_EXPR:\n+        case TRUTH_XOR_EXPR:\n+          /* Transform EQ_EXPR, NE_EXPR, TRUTH_NOT_EXPR into BIT_XOR_EXPR\n+\t     or identity if the RHS is zero or one, and the LHS are known\n+\t     to be boolean values.  Transform all TRUTH_*_EXPR into\n+             BIT_*_EXPR if both arguments are known to be boolean values.  */\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n+\t    return simplify_truth_ops_using_ranges (gsi, stmt);\n+\t  break;\n+\n       /* Transform TRUNC_DIV_EXPR and TRUNC_MOD_EXPR into RSHIFT_EXPR\n \t and BIT_AND_EXPR respectively if the first operand is greater\n \t than zero and the second operand is an exact power of two.  */\n-      if ((rhs_code == TRUNC_DIV_EXPR || rhs_code == TRUNC_MOD_EXPR)\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt)))\n-\t  && integer_pow2p (gimple_assign_rhs2 (stmt)))\n-\tsimplify_div_or_mod_using_ranges (stmt);\n+\tcase TRUNC_DIV_EXPR:\n+\tcase TRUNC_MOD_EXPR:\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt)))\n+\t      && integer_pow2p (gimple_assign_rhs2 (stmt)))\n+\t    return simplify_div_or_mod_using_ranges (stmt);\n+\t  break;\n \n       /* Transform ABS (X) into X or -X as appropriate.  */\n-      if (rhs_code == ABS_EXPR\n-\t  && TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n-\tsimplify_abs_using_ranges (stmt);\n+\tcase ABS_EXPR:\n+\t  if (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n+\t    return simplify_abs_using_ranges (stmt);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n     }\n   else if (gimple_code (stmt) == GIMPLE_COND)\n-    simplify_cond_using_ranges (stmt);\n+    return simplify_cond_using_ranges (stmt);\n   else if (gimple_code (stmt) == GIMPLE_SWITCH)\n-    simplify_switch_using_ranges (stmt);\n+    return simplify_switch_using_ranges (stmt);\n+\n+  return false;\n }\n \n /* Stack of dest,src equivalency pairs that need to be restored after"}]}