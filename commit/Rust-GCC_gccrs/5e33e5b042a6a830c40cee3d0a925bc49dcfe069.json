{"sha": "5e33e5b042a6a830c40cee3d0a925bc49dcfe069", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUzM2U1YjA0MmE2YTgzMGM0MGNlZTNkMGE5MjViYzQ5ZGNmZTA2OQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-11T22:45:10Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-11T22:45:10Z"}, "message": "analyzer: support reverse direction in shortest-paths.h\n\nThis patch generalizes shortest-path.h so that it can be used to\nfind the shortest path from each node to a given target node (on top\nof the existing support for finding the shortest path from a given\norigin node to each node).\n\nI've marked this as \"analyzer\" as this is the only code using\nshortest-paths.h.\n\nThis patch is required by followup work to fix PR analyzer/96374.\n\ngcc/analyzer/ChangeLog:\n\t* diagnostic-manager.cc (epath_finder::epath_finder):\n\tUpdate shortest_paths init for new param.\n\ngcc/ChangeLog:\n\t* digraph.cc (selftest::test_shortest_paths): Update\n\tshortest_paths init for new param.  Add test of\n\tSPS_TO_GIVEN_TARGET.\n\t* shortest-paths.h (enum shortest_path_sense): New.\n\t(shortest_paths::shortest_paths): Add \"sense\" param.\n\tUpdate for renamings.  Generalize to use \"sense\" param.\n\t(shortest_paths::get_shortest_path): Rename param.\n\t(shortest_paths::m_sense): New field.\n\t(shortest_paths::m_prev): Rename...\n\t(shortest_paths::m_best_edge): ...to this.\n\t(shortest_paths::get_shortest_path): Update for renamings.\n\tConditionalize flipping of path on sense of traversal.", "tree": {"sha": "65f3ab1dcfe34675960c710ed78b202e07783992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65f3ab1dcfe34675960c710ed78b202e07783992"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e33e5b042a6a830c40cee3d0a925bc49dcfe069", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e33e5b042a6a830c40cee3d0a925bc49dcfe069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e33e5b042a6a830c40cee3d0a925bc49dcfe069", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e33e5b042a6a830c40cee3d0a925bc49dcfe069/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f958348e78f38d91f0611618bb909182170c0f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f958348e78f38d91f0611618bb909182170c0f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f958348e78f38d91f0611618bb909182170c0f3"}], "stats": {"total": 162, "additions": 125, "deletions": 37}, "files": [{"sha": "e84953e82eebbfd3a4524ce51b7ac6dad812fbcb", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e33e5b042a6a830c40cee3d0a925bc49dcfe069/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e33e5b042a6a830c40cee3d0a925bc49dcfe069/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=5e33e5b042a6a830c40cee3d0a925bc49dcfe069", "patch": "@@ -73,7 +73,7 @@ class epath_finder\n public:\n   epath_finder (const exploded_graph &eg)\n   : m_eg (eg),\n-    m_sep (eg, eg.get_origin ())\n+    m_sep (eg, eg.get_origin (), SPS_FROM_GIVEN_ORIGIN)\n   {\n   }\n "}, {"sha": "e6966b076ca427a126befb1a2131b90eba1dec42", "filename": "gcc/digraph.cc", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e33e5b042a6a830c40cee3d0a925bc49dcfe069/gcc%2Fdigraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e33e5b042a6a830c40cee3d0a925bc49dcfe069/gcc%2Fdigraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdigraph.cc?ref=5e33e5b042a6a830c40cee3d0a925bc49dcfe069", "patch": "@@ -147,7 +147,8 @@ test_shortest_paths ()\n \n   /* Use \"A\" as the origin; all nodes should be reachable.  */\n   {\n-    shortest_paths<test_graph_traits, test_path> sp (g, a);\n+    shortest_paths<test_graph_traits, test_path> sp (g, a,\n+\t\t\t\t\t\t     SPS_FROM_GIVEN_ORIGIN);\n \n     test_path path_to_a = sp.get_shortest_path (a);\n     ASSERT_EQ (path_to_a.m_edges.length (), 0); /* Trivial path.  */\n@@ -181,7 +182,8 @@ test_shortest_paths ()\n \n   /* Use \"B\" as the origin, so only E and F are reachable.  */\n   {\n-    shortest_paths<test_graph_traits, test_path> sp (g, b);\n+    shortest_paths<test_graph_traits, test_path> sp (g, b,\n+\t\t\t\t\t\t     SPS_FROM_GIVEN_ORIGIN);\n \n     test_path path_to_a = sp.get_shortest_path (a);\n     ASSERT_EQ (path_to_a.m_edges.length (), 0); /* No path.  */\n@@ -207,7 +209,8 @@ test_shortest_paths ()\n \n   /* Use \"C\" as the origin, so only D and F are reachable.  */\n   {\n-    shortest_paths<test_graph_traits, test_path> sp (g, c);\n+    shortest_paths<test_graph_traits, test_path> sp (g, c,\n+\t\t\t\t\t\t     SPS_FROM_GIVEN_ORIGIN);\n \n     test_path path_to_a = sp.get_shortest_path (a);\n     ASSERT_EQ (path_to_a.m_edges.length (), 0); /* No path.  */\n@@ -229,6 +232,36 @@ test_shortest_paths ()\n     ASSERT_EQ (path_to_f.m_edges.length (), 1);\n     ASSERT_EQ (path_to_f.m_edges[0], cf);\n   }\n+\n+  /* Test of SPS_TO_GIVEN_TARGET.  Use \"F\" as the target.  */\n+  {\n+    shortest_paths<test_graph_traits, test_path> sp (g, f,\n+\t\t\t\t\t\t     SPS_TO_GIVEN_TARGET);\n+\n+    test_path path_to_a = sp.get_shortest_path (a);\n+    ASSERT_EQ (path_to_a.m_edges.length (), 2);\n+    ASSERT_EQ (path_to_a.m_edges[0], ac);\n+    ASSERT_EQ (path_to_a.m_edges[1], cf);\n+\n+    test_path path_to_b = sp.get_shortest_path (b);\n+    ASSERT_EQ (path_to_b.m_edges.length (), 2);\n+    ASSERT_EQ (path_to_b.m_edges[0], be);\n+    ASSERT_EQ (path_to_b.m_edges[1], ef);\n+\n+    test_path path_to_c = sp.get_shortest_path (c);\n+    ASSERT_EQ (path_to_c.m_edges.length (), 1);\n+    ASSERT_EQ (path_to_c.m_edges[0], cf);\n+\n+    test_path path_to_d = sp.get_shortest_path (d);\n+    ASSERT_EQ (path_to_d.m_edges.length (), 0); /* No path.  */\n+\n+    test_path path_to_e = sp.get_shortest_path (e);\n+    ASSERT_EQ (path_to_e.m_edges.length (), 1);\n+    ASSERT_EQ (path_to_e.m_edges[0], ef);\n+\n+    test_path path_to_f = sp.get_shortest_path (f);\n+    ASSERT_EQ (path_to_f.m_edges.length (), 0);\n+  }\n }\n \n /* Run all of the selftests within this file.  */"}, {"sha": "40d2c2a015a0d79b90a86ec8b967f5f43f7c4c22", "filename": "gcc/shortest-paths.h", "status": "modified", "additions": 88, "deletions": 33, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e33e5b042a6a830c40cee3d0a925bc49dcfe069/gcc%2Fshortest-paths.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e33e5b042a6a830c40cee3d0a925bc49dcfe069/gcc%2Fshortest-paths.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshortest-paths.h?ref=5e33e5b042a6a830c40cee3d0a925bc49dcfe069", "patch": "@@ -23,8 +23,24 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"timevar.h\"\n \n-/* A record of the shortest path to each node in an graph\n-   from the origin node.\n+enum shortest_path_sense\n+{\n+  /* Find the shortest path from the given origin node to each\n+     node in the graph.  */\n+  SPS_FROM_GIVEN_ORIGIN,\n+\n+  /* Find the shortest path from each node in the graph to the\n+     given target node.  */\n+  SPS_TO_GIVEN_TARGET\n+};\n+\n+/* A record of the shortest path for each node relative to a special\n+   \"given node\", either:\n+   SPS_FROM_GIVEN_ORIGIN:\n+     from the given origin node to each node in a graph, or\n+   SPS_TO_GIVEN_TARGET:\n+     from each node in a graph to the given target node.\n+\n    The constructor runs Dijkstra's algorithm, and the results are\n    stored in this class.  */\n \n@@ -37,35 +53,46 @@ class shortest_paths\n   typedef typename GraphTraits::edge_t edge_t;\n   typedef Path_t path_t;\n \n-  shortest_paths (const graph_t &graph, const node_t *origin);\n+  shortest_paths (const graph_t &graph, const node_t *given_node,\n+\t\t  enum shortest_path_sense sense);\n \n-  path_t get_shortest_path (const node_t *to) const;\n+  path_t get_shortest_path (const node_t *other_node) const;\n \n private:\n   const graph_t &m_graph;\n \n-  /* For each node (by index), the minimal distance to that node from the\n-     origin.  */\n+  enum shortest_path_sense m_sense;\n+\n+  /* For each node (by index), the minimal distance between that node\n+     and the given node (with direction depending on m_sense).  */\n   auto_vec<int> m_dist;\n \n-  /* For each exploded_node (by index), the previous edge in the shortest\n-     path from the origin.  */\n-  auto_vec<const edge_t *> m_prev;\n+  /* For each node (by index):\n+     SPS_FROM_GIVEN_ORIGIN:\n+       the previous edge in the shortest path from the origin,\n+     SPS_TO_GIVEN_TARGET:\n+       the next edge in the shortest path to the target.  */\n+  auto_vec<const edge_t *> m_best_edge;\n };\n \n /* shortest_paths's constructor.\n \n-   Use Dijkstra's algorithm relative to ORIGIN to populate m_dist and\n-   m_prev with enough information to be able to generate Path_t instances\n-   to give the shortest path to any node in GRAPH from ORIGIN.  */\n+   Use Dijkstra's algorithm relative to GIVEN_NODE to populate m_dist and\n+   m_best_edge with enough information to be able to generate Path_t instances\n+   to give the shortest path...\n+   SPS_FROM_GIVEN_ORIGIN: to each node in a graph from the origin node, or\n+   SPS_TO_GIVEN_TARGET: from each node in a graph to the target node.  */\n \n template <typename GraphTraits, typename Path_t>\n inline\n-shortest_paths<GraphTraits, Path_t>::shortest_paths (const graph_t &graph,\n-\t\t\t\t\t\t     const node_t *origin)\n+shortest_paths<GraphTraits, Path_t>::\n+shortest_paths (const graph_t &graph,\n+\t\tconst node_t *given_node,\n+\t\tenum shortest_path_sense sense)\n : m_graph (graph),\n+  m_sense (sense),\n   m_dist (graph.m_nodes.length ()),\n-  m_prev (graph.m_nodes.length ())\n+  m_best_edge (graph.m_nodes.length ())\n {\n   auto_timevar tv (TV_ANALYZER_SHORTEST_PATHS);\n \n@@ -74,10 +101,10 @@ shortest_paths<GraphTraits, Path_t>::shortest_paths (const graph_t &graph,\n   for (unsigned i = 0; i < graph.m_nodes.length (); i++)\n     {\n       m_dist.quick_push (INT_MAX);\n-      m_prev.quick_push (NULL);\n+      m_best_edge.quick_push (NULL);\n       queue.quick_push (i);\n     }\n-  m_dist[origin->m_index] = 0;\n+  m_dist[given_node->m_index] = 0;\n \n   while (queue.length () > 0)\n     {\n@@ -107,39 +134,67 @@ shortest_paths<GraphTraits, Path_t>::shortest_paths (const graph_t &graph,\n       node_t *n\n \t= static_cast <node_t *> (m_graph.m_nodes[idx_with_min_dist]);\n \n-      int i;\n-      edge_t *succ;\n-      FOR_EACH_VEC_ELT (n->m_succs, i, succ)\n+      if (m_sense == SPS_FROM_GIVEN_ORIGIN)\n \t{\n-\t  // TODO: only for dest still in queue\n-\t  node_t *dest = succ->m_dest;\n-\t  int alt = m_dist[n->m_index] + 1;\n-\t  if (alt < m_dist[dest->m_index])\n+\t  int i;\n+\t  edge_t *succ;\n+\t  FOR_EACH_VEC_ELT (n->m_succs, i, succ)\n \t    {\n-\t      m_dist[dest->m_index] = alt;\n-\t      m_prev[dest->m_index] = succ;\n+\t      // TODO: only for dest still in queue\n+\t      node_t *dest = succ->m_dest;\n+\t      int alt = m_dist[n->m_index] + 1;\n+\t      if (alt < m_dist[dest->m_index])\n+\t\t{\n+\t\t  m_dist[dest->m_index] = alt;\n+\t\t  m_best_edge[dest->m_index] = succ;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  int i;\n+\t  edge_t *pred;\n+\t  FOR_EACH_VEC_ELT (n->m_preds, i, pred)\n+\t    {\n+\t      // TODO: only for dest still in queue\n+\t      node_t *src = pred->m_src;\n+\t      int alt = m_dist[n->m_index] + 1;\n+\t      if (alt < m_dist[src->m_index])\n+\t\t{\n+\t\t  m_dist[src->m_index] = alt;\n+\t\t  m_best_edge[src->m_index] = pred;\n+\t\t}\n \t    }\n \t}\n    }\n }\n \n-/* Generate an Path_t instance giving the shortest path to the node\n-   TO from the origin node.\n+/* Generate an Path_t instance giving the shortest path between OTHER_NODE\n+   and the given node.\n+\n+   SPS_FROM_GIVEN_ORIGIN: shortest path from given origin node to OTHER_NODE\n+   SPS_TO_GIVEN_TARGET: shortest path from OTHER_NODE to given target node.\n+\n    If no such path exists, return an empty path.  */\n \n template <typename GraphTraits, typename Path_t>\n inline Path_t\n-shortest_paths<GraphTraits, Path_t>::get_shortest_path (const node_t *to) const\n+shortest_paths<GraphTraits, Path_t>::\n+get_shortest_path (const node_t *other_node) const\n {\n   Path_t result;\n \n-  while (m_prev[to->m_index])\n+  while (m_best_edge[other_node->m_index])\n     {\n-      result.m_edges.safe_push (m_prev[to->m_index]);\n-      to = m_prev[to->m_index]->m_src;\n+      result.m_edges.safe_push (m_best_edge[other_node->m_index]);\n+      if (m_sense == SPS_FROM_GIVEN_ORIGIN)\n+\tother_node = m_best_edge[other_node->m_index]->m_src;\n+      else\n+\tother_node = m_best_edge[other_node->m_index]->m_dest;\n     }\n \n-  result.m_edges.reverse ();\n+  if (m_sense == SPS_FROM_GIVEN_ORIGIN)\n+    result.m_edges.reverse ();\n \n   return result;\n }"}]}