{"sha": "a9c9d3fa23bf97cd72cfffd9fff018734145e056", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTljOWQzZmEyM2JmOTdjZDcyY2ZmZmQ5ZmZmMDE4NzM0MTQ1ZTA1Ng==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2005-06-01T00:45:24Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2005-06-01T00:45:24Z"}, "message": "Index: ChangeLog\n2005-05-31  Geoffrey Keating  <geoffk@geoffk.org>\n\n\t* config/rs6000/rs6000.md (sync_boolcshort_internal): New.\n\t* config/rs6000/rs6000.c (rs6000_emit_sync): Shift count must\n\tbe complemented for big-endian.  Mask for AND must be rotated,\n\tnot shifted.  Handle short operands with NOT on the memory\n\toperation.\n\nIndex: testsuite/ChangeLog\n2005-05-31  Geoffrey Keating  <geoffk@geoffk.org>\n\n\t* lib/target-supports.exp\n\t(check_effective_target_sync_char_short): New.\n\t* gcc.dg/sync-2.c: New.\n\nFrom-SVN: r100418", "tree": {"sha": "03c489c612650d4829919ca9551af6bcb76c3f2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03c489c612650d4829919ca9551af6bcb76c3f2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9c9d3fa23bf97cd72cfffd9fff018734145e056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c9d3fa23bf97cd72cfffd9fff018734145e056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c9d3fa23bf97cd72cfffd9fff018734145e056", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c9d3fa23bf97cd72cfffd9fff018734145e056/comments", "author": null, "committer": null, "parents": [{"sha": "f991abd12d6a68ed648edb6e01b34778afd74b6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f991abd12d6a68ed648edb6e01b34778afd74b6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f991abd12d6a68ed648edb6e01b34778afd74b6f"}], "stats": {"total": 154, "additions": 151, "deletions": 3}, "files": [{"sha": "ec8ed235f8e747fa29aa92ee7450c2004d128803", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a9c9d3fa23bf97cd72cfffd9fff018734145e056", "patch": "@@ -1,3 +1,11 @@\n+2005-05-31  Geoffrey Keating  <geoffk@geoffk.org>\n+\n+\t* config/rs6000/rs6000.md (sync_boolcshort_internal): New.\n+\t* config/rs6000/rs6000.c (rs6000_emit_sync): Shift count must\n+\tbe complemented for big-endian.  Mask for AND must be rotated,\n+\tnot shifted.  Handle short operands with NOT on the memory\n+\toperation.\n+\n 2005-05-30  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* c-objc-common.c (c_tree_printer): Check flag before hashtable."}, {"sha": "9f8bbd78ca837335468b79d0c29e601510aea842", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a9c9d3fa23bf97cd72cfffd9fff018734145e056", "patch": "@@ -11409,13 +11409,15 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n       else\n \t{\n \t  rtx addrSI, aligned_addr;\n+\t  int shift_mask = mode == QImode ? 0x18 : 0x10;\n \t  \n \t  addrSI = force_reg (SImode, gen_lowpart_common (SImode,\n \t\t\t\t\t\t\t  XEXP (used_m, 0)));\n \t  shift = gen_reg_rtx (SImode);\n \n \t  emit_insn (gen_rlwinm (shift, addrSI, GEN_INT (3),\n-\t\t\t\t GEN_INT (0x18)));\n+\t\t\t\t GEN_INT (shift_mask)));\n+\t  emit_insn (gen_xorsi3 (shift, shift, GEN_INT (shift_mask)));\n \n \t  aligned_addr = expand_binop (Pmode, and_optab,\n \t\t\t\t       XEXP (used_m, 0),\n@@ -11453,7 +11455,7 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n \t  newop = expand_binop (SImode, ior_optab,\n \t\t\t\toldop, GEN_INT (~imask), NULL_RTX,\n \t\t\t\t1, OPTAB_LIB_WIDEN);\n-\t  emit_insn (gen_ashlsi3 (newop, newop, shift));\n+\t  emit_insn (gen_rotlsi3 (newop, newop, shift));\n \t  break;\n \n \tcase PLUS:\n@@ -11482,6 +11484,19 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n \t  gcc_unreachable ();\n \t}\n \n+      if (GET_CODE (m) == NOT)\n+\t{\n+\t  rtx mask, xorm;\n+\n+\t  mask = gen_reg_rtx (SImode);\n+\t  emit_move_insn (mask, GEN_INT (imask));\n+\t  emit_insn (gen_ashlsi3 (mask, mask, shift));\n+\n+\t  xorm = gen_rtx_XOR (SImode, used_m, mask);\n+\t  /* Depending on the value of 'op', the XOR or the operation might\n+\t     be able to be simplified away.  */\n+\t  newop = simplify_gen_binary (code, SImode, xorm, newop);\n+\t}\n       op = newop;\n       used_mode = SImode;\n       before = gen_reg_rtx (used_mode);\n@@ -11499,7 +11514,7 @@ rs6000_emit_sync (enum rtx_code code, enum machine_mode mode,\n \tafter = gen_reg_rtx (used_mode);\n     }\n   \n-  if (code == PLUS && used_mode != mode)\n+  if ((code == PLUS || GET_CODE (m) == NOT) && used_mode != mode)\n     the_op = op;  /* Computed above.  */\n   else if (GET_CODE (op) == NOT && GET_CODE (m) != NOT)\n     the_op = gen_rtx_fmt_ee (code, used_mode, op, m);"}, {"sha": "53e4884b4b24b87b81cf818bfe5244cf7dbd4108", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=a9c9d3fa23bf97cd72cfffd9fff018734145e056", "patch": "@@ -14868,6 +14868,23 @@\n   \"<larx> %3,%y0\\n\\t%q4 %2,%1,%3\\n\\t<stcx> %2,%y0\\n\\tbne- $-12\"\n   [(set_attr \"length\" \"16\")])\n \n+; This pattern could also take immediate values of operand 1,\n+; since the non-NOT version of the operator is used; but this is not\n+; very useful, since in practise operand 1 is a full 32-bit value.\n+; Likewise, operand 5 is in practise either <= 2^16 or it is a register.\n+(define_insn \"*sync_boolcshort_internal\"\n+  [(set (match_operand:SI 2 \"gpc_reg_operand\" \"=&r\")\n+\t(match_operator:SI 4 \"boolean_operator\"\n+\t [(xor:SI (match_operand:SI 0 \"memory_operand\" \"+Z\")\n+\t\t  (match_operand:SI 5 \"logical_operand\" \"rK\"))\n+\t  (match_operand:SI 1 \"gpc_reg_operand\" \"r\")]))\n+   (set (match_operand:SI 3 \"gpc_reg_operand\" \"=&b\") (match_dup 0))\n+   (set (match_dup 0) (unspec:SI [(match_dup 4)] UNSPEC_SYNC_OP))\n+   (clobber (match_scratch:CC 6 \"=&x\"))]\n+  \"TARGET_POWERPC\"\n+  \"lwarx %3,%y0\\n\\txor%I2 %2,%3,%5\\n\\t%q4 %2,%2,%1\\n\\tstwcx. %2,%y0\\n\\tbne- $-16\"\n+  [(set_attr \"length\" \"20\")])\n+\n (define_insn \"*sync_boolc<mode>_internal2\"\n   [(set (match_operand:GPR 2 \"gpc_reg_operand\" \"=&r\")\n \t(match_operator:GPR 4 \"boolean_operator\""}, {"sha": "5b5fce64d409db2729e8b06bea82666185133d6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a9c9d3fa23bf97cd72cfffd9fff018734145e056", "patch": "@@ -1,3 +1,9 @@\n+2005-05-31  Geoffrey Keating  <geoffk@geoffk.org>\n+\n+\t* lib/target-supports.exp \n+\t(check_effective_target_sync_char_short): New.\n+\t* gcc.dg/sync-2.c: New.\n+\n 2005-05-31  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/21817\n@@ -83,6 +89,9 @@\n \n 2005-05-29  Geoffrey Keating  <geoffk@apple.com>\n \n+\tPR c++/17413\n+\t* g++.dg/template/local5.C: New.\n+\n \tPR target/21761\n \t* gcc.c-torture/compile/pr21761.c: New.\n "}, {"sha": "41f8ac1c0a532e5be2f39e69fab0f95ef56bc60b", "filename": "gcc/testsuite/gcc.dg/sync-2.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2Ftestsuite%2Fgcc.dg%2Fsync-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c9d3fa23bf97cd72cfffd9fff018734145e056/gcc%2Ftestsuite%2Fgcc.dg%2Fsync-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsync-2.c?ref=a9c9d3fa23bf97cd72cfffd9fff018734145e056", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test functionality of the intrinsics for 'short' and 'char'.  */\n+\n+extern void abort (void);\n+extern void *memcpy (void *, const void *, __SIZE_TYPE__);\n+\n+static char AI[18];\n+static char init_qi[18] = { 3,5,7,9,0,0,0,0,-1,0,0,0,0,0,-1,0,0,0 };\n+static char test_qi[18] = { 3,5,7,9,1,4,22,-12,7,8,9,7,1,-12,7,8,9,7 };\n+\n+static void\n+do_qi (void)\n+{\n+  if (__sync_fetch_and_add(AI+4, 1) != 0)\n+    abort ();\n+  if (__sync_fetch_and_add(AI+5, 4) != 0)\n+    abort ();\n+  if (__sync_fetch_and_add(AI+6, 22) != 0)\n+    abort ();\n+  if (__sync_fetch_and_sub(AI+7, 12) != 0)\n+    abort ();\n+  if (__sync_fetch_and_and(AI+8, 7) != -1)\n+    abort ();\n+  if (__sync_fetch_and_or(AI+9, 8) != 0)\n+    abort ();\n+  if (__sync_fetch_and_xor(AI+10, 9) != 0)\n+    abort ();\n+  if (__sync_fetch_and_nand(AI+11, 7) != 0)\n+    abort ();\n+\n+  if (__sync_add_and_fetch(AI+12, 1) != 1)\n+    abort ();\n+  if (__sync_sub_and_fetch(AI+13, 12) != -12)\n+    abort ();\n+  if (__sync_and_and_fetch(AI+14, 7) != 7)\n+    abort ();\n+  if (__sync_or_and_fetch(AI+15, 8) != 8)\n+    abort ();\n+  if (__sync_xor_and_fetch(AI+16, 9) != 9)\n+    abort ();\n+  if (__sync_nand_and_fetch(AI+17, 7) != 7)\n+    abort ();\n+}\n+\n+static short AL[18];\n+static short init_hi[18] = { 3,5,7,9,0,0,0,0,-1,0,0,0,0,0,-1,0,0,0 };\n+static short test_hi[18] = { 3,5,7,9,1,4,22,-12,7,8,9,7,1,-12,7,8,9,7 };\n+\n+static void\n+do_hi (void)\n+{\n+  if (__sync_fetch_and_add(AL+4, 1) != 0)\n+    abort ();\n+  if (__sync_fetch_and_add(AL+5, 4) != 0)\n+    abort ();\n+  if (__sync_fetch_and_add(AL+6, 22) != 0)\n+    abort ();\n+  if (__sync_fetch_and_sub(AL+7, 12) != 0)\n+    abort ();\n+  if (__sync_fetch_and_and(AL+8, 7) != -1)\n+    abort ();\n+  if (__sync_fetch_and_or(AL+9, 8) != 0)\n+    abort ();\n+  if (__sync_fetch_and_xor(AL+10, 9) != 0)\n+    abort ();\n+  if (__sync_fetch_and_nand(AL+11, 7) != 0)\n+    abort ();\n+\n+  if (__sync_add_and_fetch(AL+12, 1) != 1)\n+    abort ();\n+  if (__sync_sub_and_fetch(AL+13, 12) != -12)\n+    abort ();\n+  if (__sync_and_and_fetch(AL+14, 7) != 7)\n+    abort ();\n+  if (__sync_or_and_fetch(AL+15, 8) != 8)\n+    abort ();\n+  if (__sync_xor_and_fetch(AL+16, 9) != 9)\n+    abort ();\n+  if (__sync_nand_and_fetch(AL+17, 7) != 7)\n+    abort ();\n+}\n+\n+int main()\n+{\n+  memcpy(AI, init_qi, sizeof(init_qi));\n+  memcpy(AL, init_hi, sizeof(init_hi));\n+\n+  do_qi ();\n+  do_hi ();\n+\n+  if (memcmp (AI, test_qi, sizeof(test_qi)))\n+    abort ();\n+  if (memcmp (AL, test_hi, sizeof(test_hi)))\n+    abort ();\n+\n+  return 0;\n+}"}]}