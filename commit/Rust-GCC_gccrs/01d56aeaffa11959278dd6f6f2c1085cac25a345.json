{"sha": "01d56aeaffa11959278dd6f6f2c1085cac25a345", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFkNTZhZWFmZmExMTk1OTI3OGRkNmY2ZjJjMTA4NWNhYzI1YTM0NQ==", "commit": {"author": {"name": "Jojo R", "email": "jiejie_rong@c-sky.com", "date": "2020-09-15T08:08:01Z"}, "committer": {"name": "Xianmiao Qu", "email": "xianmiao_qu@c-sky.com", "date": "2020-09-16T02:13:49Z"}, "message": "C-SKY: Support -mfloat-abi=hard.\n\ngcc/ChangeLog:\n\n\t* config/csky/csky.md (CSKY_NPARM_FREGS): New.\n\t(call_value_internal_vs/d): New.\n\t(untyped_call): New.\n\t* config/csky/csky.h (TARGET_SINGLE_FPU): New.\n\t(TARGET_DOUBLE_FPU): New.\n\t(FUNCTION_VARG_REGNO_P): New.\n\t(CSKY_VREG_MODE_P): New.\n\t(FUNCTION_VARG_MODE_P): New.\n\t(CUMULATIVE_ARGS): Add extra regs info.\n\t(INIT_CUMULATIVE_ARGS): Use csky_init_cumulative_args.\n\t(FUNCTION_ARG_REGNO_P): Use FUNCTION_VARG_REGNO_P.\n\t* config/csky/csky-protos.h (csky_init_cumulative_args): Extern.\n\t* config/csky/csky.c (csky_cpu_cpp_builtins): Support TARGET_HARD_FLOAT_ABI.\n\t(csky_function_arg): Likewise.\n\t(csky_num_arg_regs): Likewise.\n\t(csky_function_arg_advance): Likewise.\n\t(csky_function_value): Likewise.\n\t(csky_libcall_value): Likewise.\n\t(csky_function_value_regno_p): Likewise.\n\t(csky_arg_partial_bytes): Likewise.\n\t(csky_setup_incoming_varargs): Likewise.\n\t(csky_init_cumulative_args): New.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/builtin-apply2.c : Skip if CSKY.\n\t* gcc.dg/torture/stackalign/builtin-apply-2.c : Likewise.", "tree": {"sha": "985e7fdf9c0ce505c28a3903d688376f082bcd1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/985e7fdf9c0ce505c28a3903d688376f082bcd1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01d56aeaffa11959278dd6f6f2c1085cac25a345", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d56aeaffa11959278dd6f6f2c1085cac25a345", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d56aeaffa11959278dd6f6f2c1085cac25a345", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d56aeaffa11959278dd6f6f2c1085cac25a345/comments", "author": null, "committer": null, "parents": [{"sha": "3f3f28de3f62ce6d3b1454d54c4da7569a60e2c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3f28de3f62ce6d3b1454d54c4da7569a60e2c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f3f28de3f62ce6d3b1454d54c4da7569a60e2c6"}], "stats": {"total": 220, "additions": 200, "deletions": 20}, "files": [{"sha": "2c023996d58518c58f22981fb2ef8bc485840da0", "filename": "gcc/config/csky/csky-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Fconfig%2Fcsky%2Fcsky-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Fconfig%2Fcsky%2Fcsky-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky-protos.h?ref=01d56aeaffa11959278dd6f6f2c1085cac25a345", "patch": "@@ -68,4 +68,6 @@ extern int csky_compute_pushpop_length (rtx *);\n \n extern int csky_default_branch_cost (bool, bool);\n extern bool csky_default_logical_op_non_short_circuit (void);\n+\n+extern void csky_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree);\n #endif /* GCC_CSKY_PROTOS_H */"}, {"sha": "5aa233677bcc78ac6c63905a70bf278d2cd37809", "filename": "gcc/config/csky/csky.c", "status": "modified", "additions": 83, "deletions": 13, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Fconfig%2Fcsky%2Fcsky.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Fconfig%2Fcsky%2Fcsky.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.c?ref=01d56aeaffa11959278dd6f6f2c1085cac25a345", "patch": "@@ -328,6 +328,16 @@ csky_cpu_cpp_builtins (cpp_reader *pfile)\n     {\n       builtin_define (\"__csky_hard_float__\");\n       builtin_define (\"__CSKY_HARD_FLOAT__\");\n+      if (TARGET_HARD_FLOAT_ABI)\n+\t{\n+\t  builtin_define (\"__csky_hard_float_abi__\");\n+\t  builtin_define (\"__CSKY_HARD_FLOAT_ABI__\");\n+\t}\n+      if (TARGET_SINGLE_FPU)\n+\t{\n+\t  builtin_define (\"__csky_hard_float_fpu_sf__\");\n+\t  builtin_define (\"__CSKY_HARD_FLOAT_FPU_SF__\");\n+\t}\n     }\n   else\n     {\n@@ -1790,9 +1800,22 @@ static rtx\n csky_function_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n+  int reg = pcum->reg;\n+  machine_mode mode = arg.mode;\n \n-  if (*pcum < CSKY_NPARM_REGS)\n-    return gen_rtx_REG (arg.mode, CSKY_FIRST_PARM_REGNUM + *pcum);\n+  if (FUNCTION_VARG_MODE_P(mode)\n+      && !pcum->is_stdarg)\n+    {\n+      reg = pcum->freg;\n+\n+      if (reg < CSKY_NPARM_FREGS)\n+\treturn gen_rtx_REG (mode, CSKY_FIRST_VFP_REGNUM + reg);\n+      else\n+\treturn NULL_RTX;\n+    }\n+\n+  if (reg < CSKY_NPARM_REGS)\n+    return gen_rtx_REG (mode, CSKY_FIRST_PARM_REGNUM + reg);\n \n   return NULL_RTX;\n }\n@@ -1802,7 +1825,7 @@ csky_function_arg (cumulative_args_t pcum_v, const function_arg_info &arg)\n    MODE and TYPE.  */\n \n static int\n-csky_num_arg_regs (machine_mode mode, const_tree type)\n+csky_num_arg_regs (machine_mode mode, const_tree type, bool is_stdarg)\n {\n   int size;\n \n@@ -1811,6 +1834,14 @@ csky_num_arg_regs (machine_mode mode, const_tree type)\n   else\n     size = GET_MODE_SIZE (mode);\n \n+  if (TARGET_HARD_FLOAT_ABI\n+      && !is_stdarg)\n+    {\n+      if (CSKY_VREG_MODE_P(mode)\n+\t  && !TARGET_SINGLE_FPU)\n+\treturn ((CSKY_NUM_WORDS (size) + 1) / 2);\n+    }\n+\n   return CSKY_NUM_WORDS (size);\n }\n \n@@ -1822,12 +1853,23 @@ csky_function_arg_advance (cumulative_args_t pcum_v,\n \t\t\t   const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n-  int param_size = csky_num_arg_regs (arg.mode, arg.type);\n+  int *reg = &pcum->reg;\n+  machine_mode mode = arg.mode;\n \n-  if (*pcum + param_size > CSKY_NPARM_REGS)\n-    *pcum = CSKY_NPARM_REGS;\n+  int param_size = csky_num_arg_regs (mode, arg.type, pcum->is_stdarg);\n+  int param_regs_nums = CSKY_NPARM_REGS;\n+\n+  if (FUNCTION_VARG_MODE_P(mode)\n+      && !pcum->is_stdarg)\n+    {\n+      reg = &pcum->freg;\n+      param_regs_nums = CSKY_NPARM_FREGS;\n+    }\n+\n+  if (*reg + param_size > param_regs_nums)\n+    *reg = param_regs_nums;\n   else\n-    *pcum += param_size;\n+    *reg += param_size;\n }\n \n \n@@ -1843,6 +1885,12 @@ csky_function_value (const_tree type, const_tree func,\n   mode = TYPE_MODE (type);\n   size = int_size_in_bytes (type);\n \n+  if (FUNCTION_VARG_MODE_P(mode))\n+    {\n+      mode = promote_function_mode (type, mode, &unsignedp, func, 1);\n+      return gen_rtx_REG (mode, CSKY_FIRST_VFP_REGNUM);\n+    }\n+\n   /* Since we promote return types, we must promote the mode here too.  */\n   if (INTEGRAL_TYPE_P (type))\n     {\n@@ -1877,6 +1925,10 @@ static rtx\n csky_libcall_value (machine_mode mode,\n \t\t    const_rtx libcall ATTRIBUTE_UNUSED)\n {\n+  if (FUNCTION_VARG_MODE_P(mode))\n+    {\n+      return gen_rtx_REG (mode, CSKY_FIRST_VFP_REGNUM);\n+    }\n   return gen_rtx_REG (mode, CSKY_FIRST_RET_REGNUM);\n }\n \n@@ -1887,7 +1939,11 @@ csky_libcall_value (machine_mode mode,\n static bool\n csky_function_value_regno_p (const unsigned int regno)\n {\n-  return (regno == CSKY_FIRST_RET_REGNUM);\n+  if (regno == CSKY_FIRST_RET_REGNUM\n+      || (TARGET_HARD_FLOAT_ABI\n+\t  && regno == CSKY_FIRST_VFP_REGNUM))\n+    return true;\n+  return false;\n }\n \n \n@@ -1912,11 +1968,16 @@ static int\n csky_arg_partial_bytes (cumulative_args_t pcum_v, const function_arg_info &arg)\n {\n   CUMULATIVE_ARGS *pcum = get_cumulative_args (pcum_v);\n-  int param_size = csky_num_arg_regs (arg.mode, arg.type);\n+  int param_size = csky_num_arg_regs (arg.mode, arg.type, pcum->is_stdarg);\n+  int reg = pcum->reg;\n+\n+  if (FUNCTION_VARG_MODE_P(arg.mode)\n+      && !pcum->is_stdarg)\n+    return 0;\n \n-  if (*pcum < CSKY_NPARM_REGS\n-      && *pcum + param_size > CSKY_NPARM_REGS)\n-    return (CSKY_NPARM_REGS - *pcum) * UNITS_PER_WORD;\n+  if (reg < CSKY_NPARM_REGS\n+      && reg + param_size > CSKY_NPARM_REGS)\n+    return (CSKY_NPARM_REGS - reg) * UNITS_PER_WORD;\n \n   return 0;\n }\n@@ -1941,7 +2002,7 @@ csky_setup_incoming_varargs (cumulative_args_t pcum_v,\n   cfun->machine->uses_anonymous_args = 1;\n   local_cum = *pcum;\n   csky_function_arg_advance (local_cum_v, arg);\n-  regs_to_push = CSKY_NPARM_REGS - local_cum;\n+  regs_to_push = CSKY_NPARM_REGS - local_cum.reg;\n   if (regs_to_push)\n     *pretend_size  = regs_to_push * UNITS_PER_WORD;\n }\n@@ -6775,6 +6836,15 @@ csky_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n   return true;\n }\n \n+void\n+csky_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n+\t\t\t   rtx libname ATTRIBUTE_UNUSED,\n+\t\t\t   tree fndecl ATTRIBUTE_UNUSED)\n+{\n+  memset(pcum, 0, sizeof(*pcum));\n+  if (stdarg_p (fntype))\n+    pcum->is_stdarg = true;\n+}\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "190a668c2aa27b1c887b82d6d9329cd5fc88889a", "filename": "gcc/config/csky/csky.h", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Fconfig%2Fcsky%2Fcsky.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Fconfig%2Fcsky%2Fcsky.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.h?ref=01d56aeaffa11959278dd6f6f2c1085cac25a345", "patch": "@@ -133,6 +133,22 @@\n /* Use hardware floating point calling convention.  */\n #define TARGET_HARD_FLOAT_ABI   (csky_float_abi == CSKY_FLOAT_ABI_HARD)\n \n+#define TARGET_SINGLE_FPU     (csky_fpu_index == TARGET_FPU_fpv2_sf)\n+#define TARGET_DOUBLE_FPU     (TARGET_HARD_FLOAT && !TARGET_SINGLE_FPU)\n+\n+#define FUNCTION_VARG_REGNO_P(REGNO)      \\\n+  (TARGET_HARD_FLOAT_ABI                  \\\n+   && IN_RANGE ((REGNO), CSKY_FIRST_VFP_REGNUM, \\\n+\t\tCSKY_FIRST_VFP_REGNUM + CSKY_NPARM_FREGS - 1))\n+\n+#define CSKY_VREG_MODE_P(mode) \\\n+  ((mode) == SFmode || (mode) == DFmode)\n+\n+#define FUNCTION_VARG_MODE_P(mode)  \\\n+  (TARGET_HARD_FLOAT_ABI            \\\n+   && CSKY_VREG_MODE_P(mode)        \\\n+   && !(mode == DFmode && TARGET_SINGLE_FPU))\n+\n /* Number of loads/stores handled by ldm/stm.  */\n #define CSKY_MIN_MULTIPLE_STLD\t3\n #define CSKY_MAX_MULTIPLE_STLD\t12\n@@ -360,7 +376,14 @@ extern int csky_arch_isa_features[];\n \n /* A C type for declaring a variable that is used as the first argument of\n    TARGET_ FUNCTION_ARG and other related values.  */\n-#define CUMULATIVE_ARGS\t int\n+#if !defined (USED_FOR_TARGET)\n+typedef struct\n+{\n+  int reg;\n+  int freg;\n+  bool is_stdarg;\n+} CUMULATIVE_ARGS;\n+#endif\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n@@ -369,15 +392,16 @@ extern int csky_arch_isa_features[];\n    On CSKY, the offset always starts at 0: the first parm reg is always\n    the same reg.  */\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-  ((CUM) = 0)\n+  csky_init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME), (INDIRECT))\n \n /* True if N is a possible register number for function argument passing.\n    On the CSKY, r0-r3 are used to pass args.\n    The int cast is to prevent a complaint about unsigned comparison to\n    zero, since CSKY_FIRST_PARM_REGNUM is zero.  */\n-#define FUNCTION_ARG_REGNO_P(REGNO)\t    \\\n-  (((int)(REGNO) >= CSKY_FIRST_PARM_REGNUM) &&\t\t\\\n-   ((REGNO) < (CSKY_NPARM_REGS + CSKY_FIRST_PARM_REGNUM)))\n+#define FUNCTION_ARG_REGNO_P(REGNO)                          \\\n+  (((REGNO) >= CSKY_FIRST_PARM_REGNUM                        \\\n+    && (REGNO) < (CSKY_NPARM_REGS + CSKY_FIRST_PARM_REGNUM)) \\\n+   || FUNCTION_VARG_REGNO_P(REGNO))\n \n /* How Large Values Are Returned  */\n "}, {"sha": "78c9b8049a994706ac10074437a269e75151721d", "filename": "gcc/config/csky/csky.md", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Fconfig%2Fcsky%2Fcsky.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Fconfig%2Fcsky%2Fcsky.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.md?ref=01d56aeaffa11959278dd6f6f2c1085cac25a345", "patch": "@@ -50,6 +50,7 @@\n    (CSKY_LAST_EH_RETDATA_REGNUM\t\t1)\n    (CSKY_EH_STACKADJ_REGNUM\t\t2)\n    (CSKY_STACKADJUST_REGNUM\t\t4)\n+   (CSKY_NPARM_FREGS 4)\n ])\n \n ;; Supported TLS relocations.\n@@ -100,6 +101,7 @@\n \n    ; Support for the eh_return pattern.\n    VUNSPEC_EH_RETURN\n+   VUNSPEC_BLOCKAGE\n   ])\n \n \n@@ -3310,6 +3312,88 @@\n \t\t\t\t force_reg (Pmode, XEXP (operands[1], 0)));\n   }\")\n \n+;; Call subroutine returning any type.\n+\n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+        (const_int 0))\n+        (match_operand 1 \"\" \"\")\n+        (match_operand 2 \"\" \"\")])]\n+  \"\"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+})\n+\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n+(define_insn \"*call_value_internal_vs\"\n+  [(set (match_operand:SF               0 \"register_operand\"          \"=v,v,v\")\n+        (call (mem:SI (match_operand:SI 1 \"csky_call_address_operand\" \"b, r,S\"))\n+              (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI CSKY_LR_REGNUM))]\n+  \"TARGET_HARD_FLOAT_ABI\"\n+  \"@\n+    jsr\\t%1\n+    jsr\\t%1\n+    jbsr\\t%1\"\n+  [(set_attr \"length\" \"2,4,4\")\n+   (set_attr \"type\"   \"call_jsr,call_jsr,call\")]\n+)\n+\n+(define_insn \"*call_value_internal_vd\"\n+  [(set (match_operand:DF               0 \"register_operand\"          \"=v,v,v\")\n+        (call (mem:SI (match_operand:SI 1 \"csky_call_address_operand\" \"b, r,S\"))\n+              (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI CSKY_LR_REGNUM))]\n+  \"TARGET_HARD_FLOAT_ABI && TARGET_DOUBLE_FPU\"\n+  \"@\n+    jsr\\t%1\n+    jsr\\t%1\n+    jbsr\\t%1\"\n+  [(set_attr \"length\" \"2,4,4\")\n+   (set_attr \"type\"   \"call_jsr,call_jsr,call\")]\n+)\n+\n+(define_insn \"*call_value_internal_pic_vs\"\n+  [(set (match_operand:SF               0 \"register_operand\"    \"=v\")\n+        (call (mem:SI (match_operand:SI 1 \"csky_unspec_operand\" \"X\"))\n+                      (match_operand    2 \"\" \"\")))\n+   (clobber (reg:SI CSKY_LR_REGNUM))]\n+  \"flag_pic && TARGET_HARD_FLOAT_ABI\"\n+  \"* return csky_output_call (operands, 1);\"\n+)\n+\n+(define_insn \"*call_value_internal_pic_vd\"\n+  [(set (match_operand:DF               0 \"register_operand\"    \"=v\")\n+        (call (mem:SI (match_operand:SI 1 \"csky_unspec_operand\" \"X\"))\n+                      (match_operand    2 \"\" \"\")))\n+   (clobber (reg:SI CSKY_LR_REGNUM))]\n+  \"flag_pic && TARGET_HARD_FLOAT_ABI && TARGET_DOUBLE_FPU\"\n+  \"* return csky_output_call (operands, 1);\"\n+)\n \n (define_insn \"*call_value_internal\"\n   [(set (match_operand\t\t\t0 \"register_operand\"\t      \"=r,r,r\")"}, {"sha": "9049af5821f7f07cfa6af4db8c82726fc3cfc06d", "filename": "gcc/testsuite/gcc.dg/builtin-apply2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c?ref=01d56aeaffa11959278dd6f6f2c1085cac25a345", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do run } */\n /* { dg-require-effective-target untyped_assembly } */\n /* { dg-skip-if \"Variadic funcs have all args on stack. Normal funcs have args in registers.\" { \"avr-*-* nds32*-*-* amdgcn-*-*\" } } */\n-/* { dg-skip-if \"Variadic funcs use different argument passing from normal funcs.\" { \"riscv*-*-* or1k*-*-* msp430-*-* pru-*-*\" } } */\n+/* { dg-skip-if \"Variadic funcs use different argument passing from normal funcs.\" { \"csky*-*-* riscv*-*-* or1k*-*-* msp430-*-* pru-*-*\" } } */\n /* { dg-skip-if \"Variadic funcs use Base AAPCS.  Normal funcs use VFP variant.\" { arm*-*-* && arm_hf_eabi } } */\n \n /* PR target/12503 */"}, {"sha": "5ec05587dbac02eeb732dc92c5564d04a8d14f48", "filename": "gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fbuiltin-apply-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d56aeaffa11959278dd6f6f2c1085cac25a345/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fbuiltin-apply-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fbuiltin-apply-2.c?ref=01d56aeaffa11959278dd6f6f2c1085cac25a345", "patch": "@@ -9,7 +9,7 @@\n /* arm_hf_eabi: Variadic funcs use Base AAPCS.  Normal funcs use VFP variant.\n    avr: Variadic funcs don't pass arguments in registers, while normal funcs\n         do.  */\n-/* { dg-skip-if \"Variadic funcs use different argument passing from normal funcs\" { arm_hf_eabi || { avr-*-* riscv*-*-* or1k*-*-* msp430-*-* amdgcn-*-* pru-*-* } } } */\n+/* { dg-skip-if \"Variadic funcs use different argument passing from normal funcs\" { arm_hf_eabi || { csky*-*-* avr-*-* riscv*-*-* or1k*-*-* msp430-*-* amdgcn-*-* pru-*-* } } } */\n /* { dg-skip-if \"Variadic funcs have all args on stack. Normal funcs have args in registers.\" { nds32*-*-* } { v850*-*-* } } */\n /* { dg-require-effective-target untyped_assembly } */\n    "}]}