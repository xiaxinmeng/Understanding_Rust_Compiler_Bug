{"sha": "d275ab8b8056a692e67d0f1a46bc766762f62806", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI3NWFiOGI4MDU2YTY5MmU2N2QwZjFhNDZiYzc2Njc2MmY2MjgwNg==", "commit": {"author": {"name": "Enkovich Ilya", "email": "ilya.enkovich@intel.com", "date": "2011-09-08T13:41:27Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2011-09-08T13:41:27Z"}, "message": "Improve AGU stalls avoidance optimization.\n\n2011-09-08  Enkovich Ilya  <ilya.enkovich@intel.com>\n\n\t* config/i386/i386-protos.h (ix86_lea_outperforms): New.\n\t(ix86_avoid_lea_for_add): Likewise.\n\t(ix86_avoid_lea_for_addr): Likewise.\n\t(ix86_split_lea_for_addr): Likewise.\n\n\t* config/i386/i386.c (LEA_MAX_STALL): New.\n\t(increase_distance): Likewise.\n\t(insn_defines_reg): Likewise.\n\t(insn_uses_reg_mem): Likewise.\n\t(distance_non_agu_define_in_bb): Likewise.\n\t(distance_agu_use_in_bb): Likewise.\n\t(ix86_lea_outperforms): Likewise.\n\t(ix86_ok_to_clobber_flags): Likewise.\n\t(ix86_avoid_lea_for_add): Likewise.\n\t(ix86_avoid_lea_for_addr): Likewise.\n\t(ix86_split_lea_for_addr): Likewise.\n\t(distance_non_agu_define): Search in pred BBs added.\n\t(distance_agu_use): Search in succ BBs added.\n\t(IX86_LEA_PRIORITY): Value changed from 2 to 0.\n\t(LEA_SEARCH_THRESHOLD): Now depends on LEA_MAX_STALL.\n\t(ix86_lea_for_add_ok): Use ix86_lea_outperforms to make decision.\n\n\t* config/i386/i386.md: Split added to transform non destructive\n\tadd into move and add.\n\t(lea_1): transformed into insn_and_split to avoid AGU stalls.\n\t(lea<mode>_2): Likewise.\n\nFrom-SVN: r178689", "tree": {"sha": "7ab64f0e1c0d2389927e770b85b9d813bf850f3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ab64f0e1c0d2389927e770b85b9d813bf850f3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d275ab8b8056a692e67d0f1a46bc766762f62806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d275ab8b8056a692e67d0f1a46bc766762f62806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d275ab8b8056a692e67d0f1a46bc766762f62806", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d275ab8b8056a692e67d0f1a46bc766762f62806/comments", "author": {"login": "ienkovich", "id": 18308708, "node_id": "MDQ6VXNlcjE4MzA4NzA4", "avatar_url": "https://avatars.githubusercontent.com/u/18308708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ienkovich", "html_url": "https://github.com/ienkovich", "followers_url": "https://api.github.com/users/ienkovich/followers", "following_url": "https://api.github.com/users/ienkovich/following{/other_user}", "gists_url": "https://api.github.com/users/ienkovich/gists{/gist_id}", "starred_url": "https://api.github.com/users/ienkovich/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ienkovich/subscriptions", "organizations_url": "https://api.github.com/users/ienkovich/orgs", "repos_url": "https://api.github.com/users/ienkovich/repos", "events_url": "https://api.github.com/users/ienkovich/events{/privacy}", "received_events_url": "https://api.github.com/users/ienkovich/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "868141900a1c1c7a76c5a48625dbfa1e81d8051c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/868141900a1c1c7a76c5a48625dbfa1e81d8051c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/868141900a1c1c7a76c5a48625dbfa1e81d8051c"}], "stats": {"total": 731, "additions": 598, "deletions": 133}, "files": [{"sha": "a0a89bbc7a099a288b437f9aee09db0abab11a03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d275ab8b8056a692e67d0f1a46bc766762f62806/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d275ab8b8056a692e67d0f1a46bc766762f62806/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d275ab8b8056a692e67d0f1a46bc766762f62806", "patch": "@@ -1,3 +1,32 @@\n+2011-09-08  Enkovich Ilya  <ilya.enkovich@intel.com>\n+\n+\t* config/i386/i386-protos.h (ix86_lea_outperforms): New.\n+\t(ix86_avoid_lea_for_add): Likewise.\n+\t(ix86_avoid_lea_for_addr): Likewise.\n+\t(ix86_split_lea_for_addr): Likewise.\n+\n+\t* config/i386/i386.c (LEA_MAX_STALL): New.\n+\t(increase_distance): Likewise.\n+\t(insn_defines_reg): Likewise.\n+\t(insn_uses_reg_mem): Likewise.\n+\t(distance_non_agu_define_in_bb): Likewise.\n+\t(distance_agu_use_in_bb): Likewise.\n+\t(ix86_lea_outperforms): Likewise.\n+\t(ix86_ok_to_clobber_flags): Likewise.\n+\t(ix86_avoid_lea_for_add): Likewise.\n+\t(ix86_avoid_lea_for_addr): Likewise.\n+\t(ix86_split_lea_for_addr): Likewise.\n+\t(distance_non_agu_define): Search in pred BBs added.\n+\t(distance_agu_use): Search in succ BBs added.\n+\t(IX86_LEA_PRIORITY): Value changed from 2 to 0.\n+\t(LEA_SEARCH_THRESHOLD): Now depends on LEA_MAX_STALL.\n+\t(ix86_lea_for_add_ok): Use ix86_lea_outperforms to make decision.\n+\n+\t* config/i386/i386.md: Split added to transform non destructive\n+\tadd into move and add.\n+\t(lea_1): transformed into insn_and_split to avoid AGU stalls.\n+\t(lea<mode>_2): Likewise.\n+\n 2011-09-08  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/50287"}, {"sha": "900d1c50f179ad8eb6f1711312b65eabbbf3844e", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d275ab8b8056a692e67d0f1a46bc766762f62806/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d275ab8b8056a692e67d0f1a46bc766762f62806/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=d275ab8b8056a692e67d0f1a46bc766762f62806", "patch": "@@ -90,6 +90,11 @@ extern void ix86_fixup_binary_operands_no_copy (enum rtx_code,\n extern void ix86_expand_binary_operator (enum rtx_code,\n \t\t\t\t\t enum machine_mode, rtx[]);\n extern bool ix86_binary_operator_ok (enum rtx_code, enum machine_mode, rtx[]);\n+extern bool ix86_lea_outperforms (rtx, unsigned int, unsigned int,\n+\t\t\t\t  unsigned int, unsigned int);\n+extern bool ix86_avoid_lea_for_add (rtx, rtx[]);\n+extern bool ix86_avoid_lea_for_addr (rtx, rtx[]);\n+extern void ix86_split_lea_for_addr (rtx[], enum machine_mode);\n extern bool ix86_lea_for_add_ok (rtx, rtx[]);\n extern bool ix86_vec_interleave_v2df_operator_ok (rtx operands[3], bool high);\n extern bool ix86_dep_by_shift_count (const_rtx set_insn, const_rtx use_insn);"}, {"sha": "64deb77deddaa59e2e02c9764c74e23f47069d0a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 539, "deletions": 131, "changes": 670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d275ab8b8056a692e67d0f1a46bc766762f62806/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d275ab8b8056a692e67d0f1a46bc766762f62806/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d275ab8b8056a692e67d0f1a46bc766762f62806", "patch": "@@ -15969,12 +15969,125 @@ ix86_split_idivmod (enum machine_mode mode, rtx operands[],\n   emit_label (end_label);\n }\n \n-#define LEA_SEARCH_THRESHOLD 12\n+#define LEA_MAX_STALL (3)\n+#define LEA_SEARCH_THRESHOLD (LEA_MAX_STALL << 1)\n+\n+/* Increase given DISTANCE in half-cycles according to\n+   dependencies between PREV and NEXT instructions.\n+   Add 1 half-cycle if there is no dependency and\n+   go to next cycle if there is some dependecy.  */\n+\n+static unsigned int\n+increase_distance (rtx prev, rtx next, unsigned int distance)\n+{\n+  df_ref *use_rec;\n+  df_ref *def_rec;\n+\n+  if (!prev || !next)\n+    return distance + (distance & 1) + 2;\n+\n+  if (!DF_INSN_USES (next) || !DF_INSN_DEFS (prev))\n+    return distance + 1;\n+\n+  for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)\n+    for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)\n+      if (!DF_REF_IS_ARTIFICIAL (*def_rec)\n+\t  && DF_REF_REGNO (*use_rec) == DF_REF_REGNO (*def_rec))\n+\treturn distance + (distance & 1) + 2;\n+\n+  return distance + 1;\n+}\n+\n+/* Function checks if instruction INSN defines register number\n+   REGNO1 or REGNO2.  */\n+\n+static bool\n+insn_defines_reg (unsigned int regno1, unsigned int regno2,\n+\t\t  rtx insn)\n+{\n+  df_ref *def_rec;\n+\n+  for (def_rec = DF_INSN_DEFS (insn); *def_rec; def_rec++)\n+    if (DF_REF_REG_DEF_P (*def_rec)\n+\t&& !DF_REF_IS_ARTIFICIAL (*def_rec)\n+\t&& (regno1 == DF_REF_REGNO (*def_rec)\n+\t    || regno2 == DF_REF_REGNO (*def_rec)))\n+      {\n+\treturn true;\n+      }\n+\n+  return false;\n+}\n+\n+/* Function checks if instruction INSN uses register number\n+   REGNO as a part of address expression.  */\n+\n+static bool\n+insn_uses_reg_mem (unsigned int regno, rtx insn)\n+{\n+  df_ref *use_rec;\n+\n+  for (use_rec = DF_INSN_USES (insn); *use_rec; use_rec++)\n+    if (DF_REF_REG_MEM_P (*use_rec) && regno == DF_REF_REGNO (*use_rec))\n+      return true;\n+\n+  return false;\n+}\n+\n+/* Search backward for non-agu definition of register number REGNO1\n+   or register number REGNO2 in basic block starting from instruction\n+   START up to head of basic block or instruction INSN.\n+\n+   Function puts true value into *FOUND var if definition was found\n+   and false otherwise.\n+\n+   Distance in half-cycles between START and found instruction or head\n+   of BB is added to DISTANCE and returned.  */\n+\n+static int\n+distance_non_agu_define_in_bb (unsigned int regno1, unsigned int regno2,\n+\t\t\t       rtx insn, int distance,\n+\t\t\t       rtx start, bool *found)\n+{\n+  basic_block bb = start ? BLOCK_FOR_INSN (start) : NULL;\n+  rtx prev = start;\n+  rtx next = NULL;\n+  enum attr_type insn_type;\n+\n+  *found = false;\n+\n+  while (prev\n+\t && prev != insn\n+\t && distance < LEA_SEARCH_THRESHOLD)\n+    {\n+      if (NONDEBUG_INSN_P (prev) && NONJUMP_INSN_P (prev))\n+\t{\n+\t  distance = increase_distance (prev, next, distance);\n+\t  if (insn_defines_reg (regno1, regno2, prev))\n+\t    {\n+\t      insn_type = get_attr_type (prev);\n+\t      if (insn_type != TYPE_LEA)\n+\t\t{\n+\t\t  *found = true;\n+\t\t  return distance;\n+\t\t}\n+\t    }\n+\n+\t  next = prev;\n+\t}\n+      if (prev == BB_HEAD (bb))\n+\tbreak;\n+\n+      prev = PREV_INSN (prev);\n+    }\n+\n+  return distance;\n+}\n \n /* Search backward for non-agu definition of register number REGNO1\n    or register number REGNO2 in INSN's basic block until\n    1. Pass LEA_SEARCH_THRESHOLD instructions, or\n-   2. Reach BB boundary, or\n+   2. Reach neighbour BBs boundary, or\n    3. Reach agu definition.\n    Returns the distance between the non-agu definition point and INSN.\n    If no definition point, returns -1.  */\n@@ -15985,35 +16098,14 @@ distance_non_agu_define (unsigned int regno1, unsigned int regno2,\n {\n   basic_block bb = BLOCK_FOR_INSN (insn);\n   int distance = 0;\n-  df_ref *def_rec;\n-  enum attr_type insn_type;\n+  bool found = false;\n \n   if (insn != BB_HEAD (bb))\n-    {\n-      rtx prev = PREV_INSN (insn);\n-      while (prev && distance < LEA_SEARCH_THRESHOLD)\n-\t{\n-\t  if (NONDEBUG_INSN_P (prev))\n-\t    {\n-\t      distance++;\n-              for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)\n-                if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF\n-                    && !DF_REF_IS_ARTIFICIAL (*def_rec)\n-                    && (regno1 == DF_REF_REGNO (*def_rec)\n-\t\t\t|| regno2 == DF_REF_REGNO (*def_rec)))\n-\t\t  {\n-\t\t    insn_type = get_attr_type (prev);\n-\t\t    if (insn_type != TYPE_LEA)\n-\t\t      goto done;\n-\t\t  }\n-\t    }\n-\t  if (prev == BB_HEAD (bb))\n-\t    break;\n-\t  prev = PREV_INSN (prev);\n-\t}\n-    }\n+    distance = distance_non_agu_define_in_bb (regno1, regno2, insn,\n+\t\t\t\t\t      distance, PREV_INSN (insn),\n+\t\t\t\t\t      &found);\n \n-  if (distance < LEA_SEARCH_THRESHOLD)\n+  if (!found && distance < LEA_SEARCH_THRESHOLD)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -16027,88 +16119,121 @@ distance_non_agu_define (unsigned int regno1, unsigned int regno2,\n \t  }\n \n       if (simple_loop)\n+\tdistance = distance_non_agu_define_in_bb (regno1, regno2,\n+\t\t\t\t\t\t  insn, distance,\n+\t\t\t\t\t\t  BB_END (bb), &found);\n+      else\n \t{\n-\t  rtx prev = BB_END (bb);\n-\t  while (prev\n-\t\t && prev != insn\n-\t\t && distance < LEA_SEARCH_THRESHOLD)\n+\t  int shortest_dist = -1;\n+\t  bool found_in_bb = false;\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n-\t      if (NONDEBUG_INSN_P (prev))\n+\t      int bb_dist = distance_non_agu_define_in_bb (regno1, regno2,\n+\t\t\t\t\t\t\t   insn, distance,\n+\t\t\t\t\t\t\t   BB_END (e->src),\n+\t\t\t\t\t\t\t   &found_in_bb);\n+\t      if (found_in_bb)\n \t\t{\n-\t\t  distance++;\n-\t\t  for (def_rec = DF_INSN_DEFS (prev); *def_rec; def_rec++)\n-\t\t    if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF\n-\t\t\t&& !DF_REF_IS_ARTIFICIAL (*def_rec)\n-\t\t\t&& (regno1 == DF_REF_REGNO (*def_rec)\n-\t\t\t    || regno2 == DF_REF_REGNO (*def_rec)))\n-\t\t      {\n-\t\t\tinsn_type = get_attr_type (prev);\n-\t\t\tif (insn_type != TYPE_LEA)\n-\t\t\t  goto done;\n-\t\t      }\n+\t\t  if (shortest_dist < 0)\n+\t\t    shortest_dist = bb_dist;\n+\t\t  else if (bb_dist > 0)\n+\t\t    shortest_dist = MIN (bb_dist, shortest_dist);\n \t\t}\n-\t      prev = PREV_INSN (prev);\n+\n+\t      found = found || found_in_bb;\n \t    }\n+\n+\t  distance = shortest_dist;\n \t}\n     }\n \n-  distance = -1;\n-\n-done:\n   /* get_attr_type may modify recog data.  We want to make sure\n      that recog data is valid for instruction INSN, on which\n      distance_non_agu_define is called.  INSN is unchanged here.  */\n   extract_insn_cached (insn);\n+\n+  if (!found)\n+    distance = -1;\n+  else\n+    distance = distance >> 1;\n+\n   return distance;\n }\n \n-/* Return the distance between INSN and the next insn that uses\n-   register number REGNO0 in memory address.  Return -1 if no such\n-   a use is found within LEA_SEARCH_THRESHOLD or REGNO0 is set.  */\n+/* Return the distance in half-cycles between INSN and the next\n+   insn that uses register number REGNO in memory address added\n+   to DISTANCE.  Return -1 if REGNO0 is set.\n+\n+   Put true value into *FOUND if register usage was found and\n+   false otherwise.\n+   Put true value into *REDEFINED if register redefinition was\n+   found and false otherwise.  */\n \n static int\n-distance_agu_use (unsigned int regno0, rtx insn)\n+distance_agu_use_in_bb(unsigned int regno,\n+\t\t       rtx insn, int distance, rtx start,\n+\t\t       bool *found, bool *redefined)\n {\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n-  int distance = 0;\n-  df_ref *def_rec;\n-  df_ref *use_rec;\n+  basic_block bb = start ? BLOCK_FOR_INSN (start) : NULL;\n+  rtx next = start;\n+  rtx prev = NULL;\n \n-  if (insn != BB_END (bb))\n+  *found = false;\n+  *redefined = false;\n+\n+  while (next\n+\t && next != insn\n+\t && distance < LEA_SEARCH_THRESHOLD)\n     {\n-      rtx next = NEXT_INSN (insn);\n-      while (next && distance < LEA_SEARCH_THRESHOLD)\n+      if (NONDEBUG_INSN_P (next) && NONJUMP_INSN_P (next))\n \t{\n-\t  if (NONDEBUG_INSN_P (next))\n+\t  distance = increase_distance(prev, next, distance);\n+\t  if (insn_uses_reg_mem (regno, next))\n \t    {\n-\t      distance++;\n-\n-\t      for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)\n-\t\tif ((DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_LOAD\n-\t\t     || DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_STORE)\n-\t\t    && regno0 == DF_REF_REGNO (*use_rec))\n-\t\t  {\n-\t\t    /* Return DISTANCE if OP0 is used in memory\n-\t\t       address in NEXT.  */\n-\t\t    return distance;\n-\t\t  }\n+\t      /* Return DISTANCE if OP0 is used in memory\n+\t\t address in NEXT.  */\n+\t      *found = true;\n+\t      return distance;\n+\t    }\n \n-\t      for (def_rec = DF_INSN_DEFS (next); *def_rec; def_rec++)\n-\t\tif (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF\n-\t\t    && !DF_REF_IS_ARTIFICIAL (*def_rec)\n-\t\t    && regno0 == DF_REF_REGNO (*def_rec))\n-\t\t  {\n-\t\t    /* Return -1 if OP0 is set in NEXT.  */\n-\t\t    return -1;\n-\t\t  }\n+\t  if (insn_defines_reg (regno, INVALID_REGNUM, next))\n+\t    {\n+\t      /* Return -1 if OP0 is set in NEXT.  */\n+\t      *redefined = true;\n+\t      return -1;\n \t    }\n-\t  if (next == BB_END (bb))\n-\t    break;\n-\t  next = NEXT_INSN (next);\n+\n+\t  prev = next;\n \t}\n+\n+      if (next == BB_END (bb))\n+\tbreak;\n+\n+      next = NEXT_INSN (next);\n     }\n \n-  if (distance < LEA_SEARCH_THRESHOLD)\n+  return distance;\n+}\n+\n+/* Return the distance between INSN and the next insn that uses\n+   register number REGNO0 in memory address.  Return -1 if no such\n+   a use is found within LEA_SEARCH_THRESHOLD or REGNO0 is set.  */\n+\n+static int\n+distance_agu_use (unsigned int regno0, rtx insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+  int distance = 0;\n+  bool found = false;\n+  bool redefined = false;\n+\n+  if (insn != BB_END (bb))\n+    distance = distance_agu_use_in_bb (regno0, insn, distance,\n+\t\t\t\t       NEXT_INSN (insn),\n+\t\t\t\t       &found, &redefined);\n+\n+  if (!found && !redefined && distance < LEA_SEARCH_THRESHOLD)\n     {\n       edge e;\n       edge_iterator ei;\n@@ -16122,50 +16247,351 @@ distance_agu_use (unsigned int regno0, rtx insn)\n \t  }\n \n       if (simple_loop)\n+\tdistance = distance_agu_use_in_bb (regno0, insn,\n+\t\t\t\t\t   distance, BB_HEAD (bb),\n+\t\t\t\t\t   &found, &redefined);\n+      else\n \t{\n-\t  rtx next = BB_HEAD (bb);\n-\t  while (next\n-\t\t && next != insn\n-\t\t && distance < LEA_SEARCH_THRESHOLD)\n+\t  int shortest_dist = -1;\n+\t  bool found_in_bb = false;\n+\t  bool redefined_in_bb = false;\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n-\t      if (NONDEBUG_INSN_P (next))\n+\t      int bb_dist = distance_agu_use_in_bb (regno0, insn,\n+\t\t\t\t\t\t    distance, BB_HEAD (e->dest),\n+\t\t\t\t\t\t    &found_in_bb, &redefined_in_bb);\n+\t      if (found_in_bb)\n \t\t{\n-\t\t  distance++;\n-\n-\t\t  for (use_rec = DF_INSN_USES (next); *use_rec; use_rec++)\n-\t\t    if ((DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_LOAD\n-\t\t\t || DF_REF_TYPE (*use_rec) == DF_REF_REG_MEM_STORE)\n-\t\t\t&& regno0 == DF_REF_REGNO (*use_rec))\n-\t\t      {\n-\t\t\t/* Return DISTANCE if OP0 is used in memory\n-\t\t\t   address in NEXT.  */\n-\t\t\treturn distance;\n-\t\t      }\n-\n-\t\t  for (def_rec = DF_INSN_DEFS (next); *def_rec; def_rec++)\n-\t\t    if (DF_REF_TYPE (*def_rec) == DF_REF_REG_DEF\n-\t\t\t&& !DF_REF_IS_ARTIFICIAL (*def_rec)\n-\t\t\t&& regno0 == DF_REF_REGNO (*def_rec))\n-\t\t      {\n-\t\t\t/* Return -1 if OP0 is set in NEXT.  */\n-\t\t\treturn -1;\n-\t\t      }\n-\n+\t\t  if (shortest_dist < 0)\n+\t\t    shortest_dist = bb_dist;\n+\t\t  else if (bb_dist > 0)\n+\t\t    shortest_dist = MIN (bb_dist, shortest_dist);\n \t\t}\n-\t      next = NEXT_INSN (next);\n+\n+\t      found = found || found_in_bb;\n \t    }\n+\n+\t  distance = shortest_dist;\n \t}\n     }\n \n-  return -1;\n+  if (!found || redefined)\n+    distance = -1;\n+  else\n+    distance = distance >> 1;\n+\n+  return distance;\n }\n \n /* Define this macro to tune LEA priority vs ADD, it take effect when\n    there is a dilemma of choicing LEA or ADD\n    Negative value: ADD is more preferred than LEA\n    Zero: Netrual\n    Positive value: LEA is more preferred than ADD*/\n-#define IX86_LEA_PRIORITY 2\n+#define IX86_LEA_PRIORITY 0\n+\n+/* Return true if usage of lea INSN has performance advantage\n+   over a sequence of instructions.  Instructions sequence has\n+   SPLIT_COST cycles higher latency than lea latency.  */\n+\n+bool\n+ix86_lea_outperforms (rtx insn, unsigned int regno0, unsigned int regno1,\n+\t\t      unsigned int regno2, unsigned int split_cost)\n+{\n+  int dist_define, dist_use;\n+\n+  dist_define = distance_non_agu_define (regno1, regno2, insn);\n+  dist_use = distance_agu_use (regno0, insn);\n+\n+  if (dist_define < 0 || dist_define >= LEA_MAX_STALL)\n+    {\n+      /* If there is no non AGU operand definition, no AGU\n+\t operand usage and split cost is 0 then both lea\n+\t and non lea variants have same priority.  Currently\n+\t we prefer lea for 64 bit code and non lea on 32 bit\n+\t code.  */\n+      if (dist_use < 0 && split_cost == 0)\n+\treturn TARGET_64BIT || IX86_LEA_PRIORITY;\n+      else\n+\treturn true;\n+    }\n+\n+  /* With longer definitions distance lea is more preferable.\n+     Here we change it to take into account splitting cost and\n+     lea priority.  */\n+  dist_define += split_cost + IX86_LEA_PRIORITY;\n+\n+  /* If there is no use in memory addess then we just check\n+     that split cost does not exceed AGU stall.  */\n+  if (dist_use < 0)\n+    return dist_define >= LEA_MAX_STALL;\n+\n+  /* If this insn has both backward non-agu dependence and forward\n+     agu dependence, the one with short distance takes effect.  */\n+  return dist_define >= dist_use;\n+}\n+\n+/* Return true if it is legal to clobber flags by INSN and\n+   false otherwise.  */\n+\n+static bool\n+ix86_ok_to_clobber_flags(rtx insn)\n+{\n+  basic_block bb = BLOCK_FOR_INSN (insn);\n+  df_ref *use;\n+  bitmap live;\n+\n+  while (insn)\n+    {\n+      if (NONDEBUG_INSN_P (insn))\n+\t{\n+\t  for (use = DF_INSN_USES (insn); *use; use++)\n+\t    if (DF_REF_REG_USE_P (*use) && DF_REF_REGNO (*use) == FLAGS_REG)\n+\t      return false;\n+\n+\t  if (insn_defines_reg (FLAGS_REG, INVALID_REGNUM, insn))\n+\t    return true;\n+\t}\n+\n+      if (insn == BB_END (bb))\n+\tbreak;\n+\n+      insn = NEXT_INSN (insn);\n+    }\n+\n+  live = df_get_live_out(bb);\n+  return !REGNO_REG_SET_P (live, FLAGS_REG);\n+}\n+\n+/* Return true if we need to split op0 = op1 + op2 into a sequence of\n+   move and add to avoid AGU stalls.  */\n+\n+bool\n+ix86_avoid_lea_for_add (rtx insn, rtx operands[])\n+{\n+  unsigned int regno0 = true_regnum (operands[0]);\n+  unsigned int regno1 = true_regnum (operands[1]);\n+  unsigned int regno2 = true_regnum (operands[2]);\n+\n+  /* Check if we need to optimize.  */\n+  if (!TARGET_OPT_AGU || optimize_function_for_size_p (cfun))\n+    return false;\n+\n+  /* Check it is correct to split here.  */\n+  if (!ix86_ok_to_clobber_flags(insn))\n+    return false;\n+\n+  /* We need to split only adds with non destructive\n+     destination operand.  */\n+  if (regno0 == regno1 || regno0 == regno2)\n+    return false;\n+  else\n+    return !ix86_lea_outperforms (insn, regno0, regno1, regno2, 1);\n+}\n+\n+/* Return true if we need to split lea into a sequence of\n+   instructions to avoid AGU stalls. */\n+\n+bool\n+ix86_avoid_lea_for_addr (rtx insn, rtx operands[])\n+{\n+  unsigned int regno0 = true_regnum (operands[0]) ;\n+  unsigned int regno1 = -1;\n+  unsigned int regno2 = -1;\n+  unsigned int split_cost = 0;\n+  struct ix86_address parts;\n+  int ok;\n+\n+  /* Check we need to optimize.  */\n+  if (!TARGET_OPT_AGU || optimize_function_for_size_p (cfun))\n+    return false;\n+\n+  /* Check it is correct to split here.  */\n+  if (!ix86_ok_to_clobber_flags(insn))\n+    return false;\n+\n+  ok = ix86_decompose_address (operands[1], &parts);\n+  gcc_assert (ok);\n+\n+  /* We should not split into add if non legitimate pic\n+     operand is used as displacement. */\n+  if (parts.disp && flag_pic && !LEGITIMATE_PIC_OPERAND_P (parts.disp))\n+    return false;\n+\n+  if (parts.base)\n+    regno1 = true_regnum (parts.base);\n+  if (parts.index)\n+    regno2 = true_regnum (parts.index);\n+\n+  /* Compute how many cycles we will add to execution time\n+     if split lea into a sequence of instructions.  */\n+  if (parts.base || parts.index)\n+    {\n+      /* Have to use mov instruction if non desctructive\n+\t destination form is used.  */\n+      if (regno1 != regno0 && regno2 != regno0)\n+\tsplit_cost += 1;\n+\n+      /* Have to add index to base if both exist.  */\n+      if (parts.base && parts.index)\n+\tsplit_cost += 1;\n+\n+      /* Have to use shift and adds if scale is 2 or greater.  */\n+      if (parts.scale > 1)\n+\t{\n+\t  if (regno0 != regno1)\n+\t    split_cost += 1;\n+\t  else if (regno2 == regno0)\n+\t    split_cost += 4;\n+\t  else\n+\t    split_cost += parts.scale;\n+\t}\n+\n+      /* Have to use add instruction with immediate if\n+\t disp is non zero.  */\n+      if (parts.disp && parts.disp != const0_rtx)\n+\tsplit_cost += 1;\n+\n+      /* Subtract the price of lea.  */\n+      split_cost -= 1;\n+    }\n+\n+  return !ix86_lea_outperforms (insn, regno0, regno1, regno2, split_cost);\n+}\n+\n+/* Split lea instructions into a sequence of instructions\n+   which are executed on ALU to avoid AGU stalls.\n+   It is assumed that it is allowed to clobber flags register\n+   at lea position.  */\n+\n+extern void\n+ix86_split_lea_for_addr (rtx operands[], enum machine_mode mode)\n+{\n+  unsigned int regno0 = true_regnum (operands[0]) ;\n+  unsigned int regno1 = INVALID_REGNUM;\n+  unsigned int regno2 = INVALID_REGNUM;\n+  struct ix86_address parts;\n+  rtx tmp, clob;\n+  rtvec par;\n+  int ok, adds;\n+\n+  ok = ix86_decompose_address (operands[1], &parts);\n+  gcc_assert (ok);\n+\n+  if (parts.base)\n+    {\n+      if (GET_MODE (parts.base) != mode)\n+\tparts.base = gen_rtx_SUBREG (mode, parts.base, 0);\n+      regno1 = true_regnum (parts.base);\n+    }\n+\n+  if (parts.index)\n+    {\n+      if (GET_MODE (parts.index) != mode)\n+\tparts.index = gen_rtx_SUBREG (mode, parts.index, 0);\n+      regno2 = true_regnum (parts.index);\n+    }\n+\n+  if (parts.scale > 1)\n+    {\n+      /* Case r1 = r1 + ...  */\n+      if (regno1 == regno0)\n+\t{\n+\t  /* If we have a case r1 = r1 + C * r1 then we\n+\t     should use multiplication which is very\n+\t     expensive.  Assume cost model is wrong if we\n+\t     have such case here.  */\n+\t  gcc_assert (regno2 != regno0);\n+\n+\t  for (adds = parts.scale; adds > 0; adds--)\n+\t    {\n+\t      tmp = gen_rtx_PLUS (mode, operands[0], parts.index);\n+\t      tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n+\t      clob = gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t      gen_rtx_REG (CCmode, FLAGS_REG));\n+\t      par = gen_rtvec (2, tmp, clob);\n+\t      emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* r1 = r2 + r3 * C case.  Need to move r3 into r1.  */\n+\t  if (regno0 != regno2)\n+\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.index));\n+\n+\t  /* Use shift for scaling.  */\n+\t  tmp = gen_rtx_ASHIFT (mode, operands[0],\n+\t\t\t\tGEN_INT (exact_log2 (parts.scale)));\n+\t  tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n+\t  clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+\t  par = gen_rtvec (2, tmp, clob);\n+\t  emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n+\n+\t  if (parts.base)\n+\t    {\n+\t      tmp = gen_rtx_PLUS (mode, operands[0], parts.base);\n+\t      tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n+\t      clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+\t      par = gen_rtvec (2, tmp, clob);\n+\t      emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n+\t    }\n+\n+\t  if (parts.disp && parts.disp != const0_rtx)\n+\t    {\n+\t      tmp = gen_rtx_PLUS (mode, operands[0], parts.disp);\n+\t      tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n+\t      clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+\t      par = gen_rtvec (2, tmp, clob);\n+\t      emit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n+\t    }\n+\t}\n+    }\n+  else if (!parts.base && !parts.index)\n+    {\n+      gcc_assert(parts.disp);\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.disp));\n+    }\n+  else\n+    {\n+      if (!parts.base)\n+      {\n+        if (regno0 != regno2)\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.index));\n+      }\n+      else if (!parts.index)\n+      {\n+        if (regno0 != regno1)\n+          emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.base));\n+      }\n+      else\n+      {\n+\tif (regno0 == regno1)\n+\t  tmp = gen_rtx_PLUS (mode, operands[0], parts.index);\n+\telse if (regno0 == regno2)\n+\t  tmp = gen_rtx_PLUS (mode, operands[0], parts.base);\n+\telse\n+\t  {\n+\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0], parts.base));\n+\t    tmp = gen_rtx_PLUS (mode, operands[0], parts.index);\n+\t  }\n+\n+        tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n+\tclob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+\tpar = gen_rtvec (2, tmp, clob);\n+\temit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n+      }\n+\n+      if (parts.disp && parts.disp != const0_rtx)\n+      {\n+        tmp = gen_rtx_PLUS (mode, operands[0], parts.disp);\n+        tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n+\tclob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+\tpar = gen_rtvec (2, tmp, clob);\n+\temit_insn (gen_rtx_PARALLEL (VOIDmode, par));\n+      }\n+    }\n+}\n \n /* Return true if it is ok to optimize an ADD operation to LEA\n    operation to avoid flag register consumation.  For most processors,\n@@ -16186,26 +16612,8 @@ ix86_lea_for_add_ok (rtx insn, rtx operands[])\n \n   if (!TARGET_OPT_AGU || optimize_function_for_size_p (cfun))\n     return false;\n-  else\n-    {\n-      int dist_define, dist_use;\n \n-      /* Return false if REGNO0 isn't used in memory address. */\n-      dist_use = distance_agu_use (regno0, insn);\n-      if (dist_use <= 0)\n-\treturn false;\n-\n-      dist_define = distance_non_agu_define (regno1, regno2, insn);\n-      if (dist_define <= 0)\n-        return true;\n-\n-      /* If this insn has both backward non-agu dependence and forward\n-         agu dependence, the one with short distance take effect. */\n-      if ((dist_define + IX86_LEA_PRIORITY) < dist_use)\n-        return false;\n-\n-      return true;\n-    }\n+  return ix86_lea_outperforms (insn, regno0, regno1, regno2, 0);\n }\n \n /* Return true if destination reg of SET_BODY is shift count of"}, {"sha": "52c57fa9b7cfbbc836224304a8b26b489e330c6e", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d275ab8b8056a692e67d0f1a46bc766762f62806/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d275ab8b8056a692e67d0f1a46bc766762f62806/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d275ab8b8056a692e67d0f1a46bc766762f62806", "patch": "@@ -5463,19 +5463,31 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*lea_1\"\n+(define_insn_and_split \"*lea_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(subreg:SI (match_operand:DI 1 \"lea_address_operand\" \"p\") 0))]\n   \"TARGET_64BIT\"\n   \"lea{l}\\t{%a1, %0|%0, %a1}\"\n+  \"&& reload_completed && ix86_avoid_lea_for_addr (insn, operands)\"\n+  [(const_int 0)]\n+{\n+  ix86_split_lea_for_addr (operands, SImode);\n+  DONE;\n+}\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*lea<mode>_2\"\n+(define_insn_and_split \"*lea<mode>_2\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(match_operand:SWI48 1 \"lea_address_operand\" \"p\"))]\n   \"\"\n   \"lea{<imodesuffix>}\\t{%a1, %0|%0, %a1}\"\n+  \"reload_completed && ix86_avoid_lea_for_addr (insn, operands)\"\n+  [(const_int 0)]\n+{\n+  ix86_split_lea_for_addr (operands, <MODE>mode);\n+  DONE;\n+}\n   [(set_attr \"type\" \"lea\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -5777,6 +5789,17 @@\n         (const_string \"none\")))\n    (set_attr \"mode\" \"QI\")])\n \n+;; Split non destructive adds if we cannot use lea.\n+(define_split\n+  [(set (match_operand:SWI48 0 \"register_operand\" \"\")\n+\t(plus:SWI48 (match_operand:SWI48 1 \"register_operand\" \"\")\n+              (match_operand:SWI48 2 \"nonmemory_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"reload_completed && ix86_avoid_lea_for_add (insn, operands)\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (parallel [(set (match_dup 0) (plus:<MODE> (match_dup 0) (match_dup 2)))\n+\t      (clobber (reg:CC FLAGS_REG))])])\n+\n ;; Convert add to the lea pattern to avoid flags dependency.\n (define_split\n   [(set (match_operand:SWI 0 \"register_operand\" \"\")"}]}