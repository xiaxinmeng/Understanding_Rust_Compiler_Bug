{"sha": "b08e03394034a615de40842823ab849d78c8ecb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA4ZTAzMzk0MDM0YTYxNWRlNDA4NDI4MjNhYjg0OWQ3OGM4ZWNiMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-19T19:38:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-19T19:38:42Z"}, "message": "gengtype.c (start_root_entry): New function, split out from write_root.\n\ngcc/\n\t* gengtype.c (start_root_entry): New function, split out from\n\twrite_root.  Check whether V is null and raise an error if so.\n\t(write_field_root): Check for V being null.  Don't raise an error here;\n\tset V to null instead.\n\t(write_root): Update comment above function.  Use start_root_entry.\n\nFrom-SVN: r162314", "tree": {"sha": "b8c7274fbcd315cae8aea11f8e2b6c9c724f0d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8c7274fbcd315cae8aea11f8e2b6c9c724f0d0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b08e03394034a615de40842823ab849d78c8ecb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b08e03394034a615de40842823ab849d78c8ecb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b08e03394034a615de40842823ab849d78c8ecb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b08e03394034a615de40842823ab849d78c8ecb2/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770", "html_url": "https://github.com/Rust-GCC/gccrs/commit/974df0f87f1ecd3da2b2f88b807aa9f6c0f23770"}], "stats": {"total": 85, "additions": 61, "deletions": 24}, "files": [{"sha": "1f37815b0c52d4d2d84e7e1109959327223cfdd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08e03394034a615de40842823ab849d78c8ecb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08e03394034a615de40842823ab849d78c8ecb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b08e03394034a615de40842823ab849d78c8ecb2", "patch": "@@ -1,3 +1,11 @@\n+2010-07-19  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* gengtype.c (start_root_entry): New function, split out from\n+\twrite_root.  Check whether V is null and raise an error if so.\n+\t(write_field_root): Check for V being null.  Don't raise an error here;\n+\tset V to null instead.\n+\t(write_root): Update comment above function.  Use start_root_entry.\n+\n 2010-07-19  Xinliang David Li  <davidxl@google.com>\n \n \tPR testsuite/44932"}, {"sha": "9a7de9fb9a9f29adbe4f371d1a333c54c00e6789", "filename": "gcc/gengtype.c", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b08e03394034a615de40842823ab849d78c8ecb2/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b08e03394034a615de40842823ab849d78c8ecb2/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=b08e03394034a615de40842823ab849d78c8ecb2", "patch": "@@ -3174,6 +3174,39 @@ finish_root_table (struct flist *flp, const char *pfx, const char *lastname,\n   }\n }\n \n+/* Write the first three fields (pointer, count and stride) for\n+   root NAME to F.  V and LINE are as for write_root.\n+\n+   Return true if the entry could be written; return false on error.  */\n+\n+static bool\n+start_root_entry (outf_p f, pair_p v, const char *name, struct fileloc *line)\n+{\n+  type_p ap;\n+\n+  if (!v)\n+    {\n+      error_at_line (line, \"`%s' is too complex to be a root\", name);\n+      return false;\n+    }\n+\n+  oprintf (f, \"  {\\n\");\n+  oprintf (f, \"    &%s,\\n\", name);\n+  oprintf (f, \"    1\");\n+\n+  for (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n+    if (ap->u.a.len[0])\n+      oprintf (f, \" * (%s)\", ap->u.a.len);\n+    else if (ap == v->type)\n+      oprintf (f, \" * ARRAY_SIZE (%s)\", v->name);\n+  oprintf (f, \",\\n\");\n+  oprintf (f, \"    sizeof (%s\", v->name);\n+  for (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n+    oprintf (f, \"[0]\");\n+  oprintf (f, \"),\\n\");\n+  return true;\n+}\n+\n /* A subroutine of write_root for writing the roots for field FIELD_NAME,\n    which has type FIELD_TYPE.  Parameters F to EMIT_PCH are the parameters\n    of the caller.  */\n@@ -3187,7 +3220,7 @@ write_field_root (outf_p f, pair_p v, type_p type, const char *name,\n      subcomponent of V, we can mark any subarrays with a single stride.\n      We're effectively treating the field as a global variable in its\n      own right.  */\n-  if (type == v->type)\n+  if (v && type == v->type)\n     {\n       struct pair newv;\n \n@@ -3199,14 +3232,23 @@ write_field_root (outf_p f, pair_p v, type_p type, const char *name,\n   /* Otherwise, any arrays nested in the structure are too complex to\n      handle.  */\n   else if (field_type->kind == TYPE_ARRAY)\n-    error_at_line (line, \"nested array `%s.%s' is too complex to be a root\",\n-\t\t   name, field_name);\n+    v = NULL;\n   write_root (f, v, field_type, ACONCAT ((name, \".\", field_name, NULL)),\n \t      has_length, line, if_marked, emit_pch);\n }\n \n /* Write out to F the table entry and any marker routines needed to\n-   mark NAME as TYPE.  The original variable is V, at LINE.\n+   mark NAME as TYPE.  V can be one of three values:\n+\n+     - null, if NAME is too complex to represent using a single\n+       count and stride.  In this case, it is an error for NAME to\n+       contain any gc-ed data.\n+\n+     - the outermost array that contains NAME, if NAME is part of an array.\n+\n+     - the C variable that contains NAME, if NAME is not part of an array.\n+\n+   LINE is the line of the C source that declares the root variable.\n    HAS_LENGTH is nonzero iff V was a variable-length array.  IF_MARKED\n    is nonzero iff we are building the root table for hash table caches.  */\n \n@@ -3291,22 +3333,10 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \n     case TYPE_POINTER:\n       {\n-\ttype_p ap, tp;\n-\n-\toprintf (f, \"  {\\n\");\n-\toprintf (f, \"    &%s,\\n\", name);\n-\toprintf (f, \"    1\");\n-\n-\tfor (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n-\t  if (ap->u.a.len[0])\n-\t    oprintf (f, \" * (%s)\", ap->u.a.len);\n-\t  else if (ap == v->type)\n-\t    oprintf (f, \" * ARRAY_SIZE (%s)\", v->name);\n-\toprintf (f, \",\\n\");\n-\toprintf (f, \"    sizeof (%s\", v->name);\n-\tfor (ap = v->type; ap->kind == TYPE_ARRAY; ap = ap->u.a.p)\n-\t  oprintf (f, \"[0]\");\n-\toprintf (f, \"),\\n\");\n+\ttype_p tp;\n+\n+\tif (!start_root_entry (f, v, name, line))\n+\t  return;\n \n \ttp = type->u.p;\n \n@@ -3353,10 +3383,9 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \n     case TYPE_STRING:\n       {\n-\toprintf (f, \"  {\\n\");\n-\toprintf (f, \"    &%s,\\n\", name);\n-\toprintf (f, \"    1, \\n\");\n-\toprintf (f, \"    sizeof (%s),\\n\", v->name);\n+\tif (!start_root_entry (f, v, name, line))\n+\t  return;\n+\n \toprintf (f, \"    (gt_pointer_walker) &gt_ggc_m_S,\\n\");\n \toprintf (f, \"    (gt_pointer_walker) &gt_pch_n_S\\n\");\n \toprintf (f, \"  },\\n\");"}]}