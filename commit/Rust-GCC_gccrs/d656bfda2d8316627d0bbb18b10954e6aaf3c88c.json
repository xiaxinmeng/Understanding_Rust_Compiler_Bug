{"sha": "d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY1NmJmZGEyZDgzMTY2MjdkMGJiYjE4YjEwOTU0ZTZhYWYzYzg4Yw==", "commit": {"author": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2021-01-21T13:38:47Z"}, "committer": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2021-02-25T22:47:11Z"}, "message": "openmp: Fix intermittent hanging of task-detach-6 libgomp tests [PR98738]\n\nThis adds support for the task detach clause to taskwait and taskgroup, and\nsimplifies the handling of the detach clause by moving most of the extra\nhandling required for detach tasks to omp_fulfill_event.\n\n2021-02-25  Kwok Cheung Yeung  <kcy@codesourcery.com>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\tlibgomp/\n\n\tPR libgomp/98738\n\t* libgomp.h (enum gomp_task_kind): Add GOMP_TASK_DETACHED.\n\t(struct gomp_task): Replace detach and completion_sem fields with\n\tunion containing completion_sem and detach_team.  Add deferred_p\n\tfield.\n\t(struct gomp_team): Remove task_detach_queue.\n\t* task.c: Include assert.h.\n\t(gomp_init_task): Initialize deferred_p and completion_sem fields.\n\tRearrange initialization order of fields.\n\t(task_fulfilled_p): Delete.\n\t(GOMP_task): Use address of task as the event handle.  Remove\n\tinitialization of detach field.  Initialize deferred_p field.\n\tUse automatic local for completion_sem.  Initialize detach_team field\n\tfor deferred tasks.\n\t(gomp_barrier_handle_tasks): Remove handling of task_detach_queue.\n\tSet kind of suspended detach task to GOMP_TASK_DETACHED and\n\tdecrement task_running_count.  Move finish_cancelled block out of\n\telse branch.  Relocate call to gomp_team_barrier_done.\n\t(GOMP_taskwait): Handle tasks with completion events that have not\n\tbeen fulfilled.\n\t(GOMP_taskgroup_end): Likewise.\n\t(omp_fulfill_event): Use address of task as event handle.  Post to\n\tcompletion_sem for undeferred tasks.  Clear detach_team if task\n\thas not finished.  For finished tasks, handle post-execution tasks,\n\tcall gomp_team_barrier_wake if necessary, and free task.\n\t* team.c (gomp_new_team): Remove initialization of task_detach_queue.\n\t(free_team): Remove free of task_detach_queue.\n\t* testsuite/libgomp.c-c++-common/task-detach-1.c: Fix formatting.\n\t* testsuite/libgomp.c-c++-common/task-detach-2.c: Fix formatting.\n\t* testsuite/libgomp.c-c++-common/task-detach-3.c: Fix formatting.\n\t* testsuite/libgomp.c-c++-common/task-detach-4.c: Fix formatting.\n\t* testsuite/libgomp.c-c++-common/task-detach-5.c: Fix formatting.\n\tChange data-sharing of detach events on enclosing parallel to private.\n\t* testsuite/libgomp.c-c++-common/task-detach-6.c: Likewise.  Remove\n\ttaskwait directive.\n\t* testsuite/libgomp.c-c++-common/task-detach-7.c: New.\n\t* testsuite/libgomp.c-c++-common/task-detach-8.c: New.\n\t* testsuite/libgomp.c-c++-common/task-detach-9.c: New.\n\t* testsuite/libgomp.c-c++-common/task-detach-10.c: New.\n\t* testsuite/libgomp.c-c++-common/task-detach-11.c: New.\n\t* testsuite/libgomp.fortran/task-detach-1.f90: Fix formatting.\n\t* testsuite/libgomp.fortran/task-detach-2.f90: Fix formatting.\n\t* testsuite/libgomp.fortran/task-detach-3.f90: Fix formatting.\n\t* testsuite/libgomp.fortran/task-detach-4.f90: Fix formatting.\n\t* testsuite/libgomp.fortran/task-detach-5.f90: Fix formatting.\n\tChange data-sharing of detach events on enclosing parallel to private.\n\t* testsuite/libgomp.fortran/task-detach-6.f90: Likewise.  Remove\n\ttaskwait directive.\n\t* testsuite/libgomp.fortran/task-detach-7.f90: New.\n\t* testsuite/libgomp.fortran/task-detach-8.f90: New.\n\t* testsuite/libgomp.fortran/task-detach-9.f90: New.\n\t* testsuite/libgomp.fortran/task-detach-10.f90: New.\n\t* testsuite/libgomp.fortran/task-detach-11.f90: New.", "tree": {"sha": "9054f33271d1e28f4bb63a203980b5ca35fd7df6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9054f33271d1e28f4bb63a203980b5ca35fd7df6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/comments", "author": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fb9a1e929db520fd741e60d84ec1a58581a8299", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb9a1e929db520fd741e60d84ec1a58581a8299", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fb9a1e929db520fd741e60d84ec1a58581a8299"}], "stats": {"total": 729, "additions": 591, "deletions": 138}, "files": [{"sha": "ef1bb4907b6774a56868e1bd8d03177722ff59cb", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -481,7 +481,10 @@ enum gomp_task_kind\n      but not yet completed.  Once that completes, they will be readded\n      into the queues as GOMP_TASK_WAITING in order to perform the var\n      unmapping.  */\n-  GOMP_TASK_ASYNC_RUNNING\n+  GOMP_TASK_ASYNC_RUNNING,\n+  /* Task that has finished executing but is waiting for its\n+     completion event to be fulfilled.  */\n+  GOMP_TASK_DETACHED\n };\n \n struct gomp_task_depend_entry\n@@ -537,6 +540,16 @@ struct gomp_task\n      into the various queues to be scheduled.  */\n   size_t num_dependees;\n \n+  union {\n+      /* Valid only if deferred_p is false.  */\n+      gomp_sem_t *completion_sem;\n+      /* Valid only if deferred_p is true.  Set to the team that executes the\n+\t task if the task is detached and the completion event has yet to be\n+\t fulfilled.  */\n+      struct gomp_team *detach_team;\n+    };\n+  bool deferred_p;\n+\n   /* Priority of this task.  */\n   int priority;\n   /* The priority node for this task in each of the different queues.\n@@ -545,9 +558,6 @@ struct gomp_task\n      entries and the gomp_task in which they reside.  */\n   struct priority_node pnode[3];\n \n-  bool detach;\n-  gomp_sem_t completion_sem;\n-\n   struct gomp_task_icv icv;\n   void (*fn) (void *);\n   void *fn_data;\n@@ -688,8 +698,7 @@ struct gomp_team\n   int work_share_cancelled;\n   int team_cancelled;\n \n-  /* Tasks waiting for their completion event to be fulfilled.  */\n-  struct priority_queue task_detach_queue;\n+  /* Number of tasks waiting for their completion event to be fulfilled.  */\n   unsigned int task_detach_count;\n \n   /* This array contains structures for implicit tasks.  */"}, {"sha": "1c73c759a8d1a37c4fa5ba5c45b216a2830e44d5", "filename": "libgomp/task.c", "status": "modified", "additions": 160, "deletions": 88, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -29,6 +29,7 @@\n #include \"libgomp.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n #include \"gomp-constants.h\"\n \n typedef struct gomp_task_depend_entry *hash_entry_type;\n@@ -74,19 +75,20 @@ gomp_init_task (struct gomp_task *task, struct gomp_task *parent_task,\n      benchmark the overhead of creating tasks as there are millions of\n      tiny tasks created that all run undeferred.  */\n   task->parent = parent_task;\n+  priority_queue_init (&task->children_queue);\n+  task->taskgroup = NULL;\n+  task->dependers = NULL;\n+  task->depend_hash = NULL;\n+  task->taskwait = NULL;\n+  task->depend_count = 0;\n+  task->completion_sem = NULL;\n+  task->deferred_p = false;\n   task->icv = *prev_icv;\n   task->kind = GOMP_TASK_IMPLICIT;\n-  task->taskwait = NULL;\n   task->in_tied_task = false;\n   task->final_task = false;\n   task->copy_ctors_done = false;\n   task->parent_depends_on = false;\n-  priority_queue_init (&task->children_queue);\n-  task->taskgroup = NULL;\n-  task->dependers = NULL;\n-  task->depend_hash = NULL;\n-  task->depend_count = 0;\n-  task->detach = false;\n }\n \n /* Clean up a task, after completing it.  */\n@@ -327,12 +329,6 @@ gomp_task_handle_depend (struct gomp_task *task, struct gomp_task *parent,\n     }\n }\n \n-static bool\n-task_fulfilled_p (struct gomp_task *task)\n-{\n-  return gomp_sem_getcount (&task->completion_sem) > 0;\n-}\n-\n /* Called when encountering an explicit task directive.  If IF_CLAUSE is\n    false, then we must not delay in executing the task.  If UNTIED is true,\n    then the task may be executed by any member of the team.\n@@ -398,6 +394,7 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n       || team->task_count > 64 * team->nthreads)\n     {\n       struct gomp_task task;\n+      gomp_sem_t completion_sem;\n \n       /* If there are depend clauses and earlier deferred sibling tasks\n \t with depend clauses, check if there isn't a dependency.  If there\n@@ -417,13 +414,14 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n \n       if ((flags & GOMP_TASK_FLAG_DETACH) != 0)\n \t{\n-\t  task.detach = true;\n-\t  gomp_sem_init (&task.completion_sem, 0);\n-\t  *(void **) detach = &task.completion_sem;\n+\t  gomp_sem_init (&completion_sem, 0);\n+\t  task.completion_sem = &completion_sem;\n+\t  *(void **) detach = &task;\n \t  if (data)\n-\t    *(void **) data = &task.completion_sem;\n+\t    *(void **) data = &task;\n \n-\t  gomp_debug (0, \"New event: %p\\n\", &task.completion_sem);\n+\t  gomp_debug (0, \"Thread %d: new event: %p\\n\",\n+\t\t      thr->ts.team_id, &task);\n \t}\n \n       if (thr->task)\n@@ -443,8 +441,11 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n       else\n \tfn (data);\n \n-      if (task.detach && !task_fulfilled_p (&task))\n-\tgomp_sem_wait (&task.completion_sem);\n+      if ((flags & GOMP_TASK_FLAG_DETACH) != 0)\n+\t{\n+\t  gomp_sem_wait (&completion_sem);\n+\t  gomp_sem_destroy (&completion_sem);\n+\t}\n \n       /* Access to \"children\" is normally done inside a task_lock\n \t mutex region, but the only way this particular task.children\n@@ -484,15 +485,16 @@ GOMP_task (void (*fn) (void *), void *data, void (*cpyfn) (void *, void *),\n       task->kind = GOMP_TASK_UNDEFERRED;\n       task->in_tied_task = parent->in_tied_task;\n       task->taskgroup = taskgroup;\n+      task->deferred_p = true;\n       if ((flags & GOMP_TASK_FLAG_DETACH) != 0)\n \t{\n-\t  task->detach = true;\n-\t  gomp_sem_init (&task->completion_sem, 0);\n-\t  *(void **) detach = &task->completion_sem;\n+\t  task->detach_team = team;\n+\n+\t  *(void **) detach = task;\n \t  if (data)\n-\t    *(void **) data = &task->completion_sem;\n+\t    *(void **) data = task;\n \n-\t  gomp_debug (0, \"New event: %p\\n\", &task->completion_sem);\n+\t  gomp_debug (0, \"Thread %d: new event: %p\\n\", thr->ts.team_id, task);\n \t}\n       thr->task = task;\n       if (cpyfn)\n@@ -1362,27 +1364,6 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n     {\n       bool cancelled = false;\n \n-      /* Look for a queued detached task with a fulfilled completion event\n-\t that is ready to finish.  */\n-      child_task = priority_queue_find (PQ_TEAM, &team->task_detach_queue,\n-\t\t\t\t\ttask_fulfilled_p);\n-      if (child_task)\n-\t{\n-\t  priority_queue_remove (PQ_TEAM, &team->task_detach_queue,\n-\t\t\t\t child_task, MEMMODEL_RELAXED);\n-\t  --team->task_detach_count;\n-\t  gomp_debug (0, \"thread %d: found task with fulfilled event %p\\n\",\n-\t\t      thr->ts.team_id, &child_task->completion_sem);\n-\n-\tif (to_free)\n-\t  {\n-\t    gomp_finish_task (to_free);\n-\t    free (to_free);\n-\t    to_free = NULL;\n-\t  }\n-\t  goto finish_cancelled;\n-\t}\n-\n       if (!priority_queue_empty_p (&team->task_queue, MEMMODEL_RELAXED))\n \t{\n \t  bool ignored;\n@@ -1405,6 +1386,19 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n \t  team->task_running_count++;\n \t  child_task->in_tied_task = true;\n \t}\n+      else if (team->task_count == 0\n+\t       && gomp_team_barrier_waiting_for_tasks (&team->barrier))\n+\t{\n+\t  gomp_team_barrier_done (&team->barrier, state);\n+\t  gomp_mutex_unlock (&team->task_lock);\n+\t  gomp_team_barrier_wake (&team->barrier, 0);\n+\t  if (to_free)\n+\t    {\n+\t      gomp_finish_task (to_free);\n+\t      free (to_free);\n+\t    }\n+\t  return;\n+\t}\n       gomp_mutex_unlock (&team->task_lock);\n       if (do_wake)\n \t{\n@@ -1450,44 +1444,37 @@ gomp_barrier_handle_tasks (gomp_barrier_state_t state)\n       gomp_mutex_lock (&team->task_lock);\n       if (child_task)\n \t{\n-\t  if (child_task->detach && !task_fulfilled_p (child_task))\n+\t  if (child_task->detach_team)\n \t    {\n-\t      priority_queue_insert (PQ_TEAM, &team->task_detach_queue,\n-\t\t\t\t     child_task, child_task->priority,\n-\t\t\t\t     PRIORITY_INSERT_END,\n-\t\t\t\t     false, false);\n+\t      assert (child_task->detach_team == team);\n+\t      child_task->kind = GOMP_TASK_DETACHED;\n \t      ++team->task_detach_count;\n-\t      gomp_debug (0, \"thread %d: queueing task with event %p\\n\",\n-\t\t\t  thr->ts.team_id, &child_task->completion_sem);\n+\t      --team->task_running_count;\n+\t      gomp_debug (0,\n+\t\t\t  \"thread %d: task with event %p finished without \"\n+\t\t\t  \"completion event fulfilled in team barrier\\n\",\n+\t\t\t  thr->ts.team_id, child_task);\n \t      child_task = NULL;\n+\t      continue;\n \t    }\n-\t  else\n+\n+\t finish_cancelled:;\n+\t  size_t new_tasks\n+\t    = gomp_task_run_post_handle_depend (child_task, team);\n+\t  gomp_task_run_post_remove_parent (child_task);\n+\t  gomp_clear_parent (&child_task->children_queue);\n+\t  gomp_task_run_post_remove_taskgroup (child_task);\n+\t  to_free = child_task;\n+\t  if (!cancelled)\n+\t    team->task_running_count--;\n+\t  child_task = NULL;\n+\t  if (new_tasks > 1)\n \t    {\n-\t     finish_cancelled:;\n-\t      size_t new_tasks\n-\t\t= gomp_task_run_post_handle_depend (child_task, team);\n-\t      gomp_task_run_post_remove_parent (child_task);\n-\t      gomp_clear_parent (&child_task->children_queue);\n-\t      gomp_task_run_post_remove_taskgroup (child_task);\n-\t      to_free = child_task;\n-\t      child_task = NULL;\n-\t      if (!cancelled)\n-\t\tteam->task_running_count--;\n-\t      if (new_tasks > 1)\n-\t\t{\n-\t\t  do_wake = team->nthreads - team->task_running_count;\n-\t\t  if (do_wake > new_tasks)\n-\t\t    do_wake = new_tasks;\n-\t\t}\n-\t      if (--team->task_count == 0\n-\t\t  && gomp_team_barrier_waiting_for_tasks (&team->barrier))\n-\t\t{\n-\t\t  gomp_team_barrier_done (&team->barrier, state);\n-\t\t  gomp_mutex_unlock (&team->task_lock);\n-\t\t  gomp_team_barrier_wake (&team->barrier, 0);\n-\t\t  gomp_mutex_lock (&team->task_lock);\n-\t\t}\n+\t      do_wake = team->nthreads - team->task_running_count;\n+\t      if (do_wake > new_tasks)\n+\t\tdo_wake = new_tasks;\n \t    }\n+\t  --team->task_count;\n \t}\n     }\n }\n@@ -1559,7 +1546,8 @@ GOMP_taskwait (void)\n       else\n \t{\n \t/* All tasks we are waiting for are either running in other\n-\t   threads, or they are tasks that have not had their\n+\t   threads, are detached and waiting for the completion event to be\n+\t   fulfilled, or they are tasks that have not had their\n \t   dependencies met (so they're not even in the queue).  Wait\n \t   for them.  */\n \t  if (task->taskwait == NULL)\n@@ -1614,6 +1602,19 @@ GOMP_taskwait (void)\n       gomp_mutex_lock (&team->task_lock);\n       if (child_task)\n \t{\n+\t  if (child_task->detach_team)\n+\t    {\n+\t      assert (child_task->detach_team == team);\n+\t      child_task->kind = GOMP_TASK_DETACHED;\n+\t      ++team->task_detach_count;\n+\t      gomp_debug (0,\n+\t\t\t  \"thread %d: task with event %p finished without \"\n+\t\t\t  \"completion event fulfilled in taskwait\\n\",\n+\t\t\t  thr->ts.team_id, child_task);\n+\t      child_task = NULL;\n+\t      continue;\n+\t    }\n+\n \t finish_cancelled:;\n \t  size_t new_tasks\n \t    = gomp_task_run_post_handle_depend (child_task, team);\n@@ -2069,6 +2070,19 @@ GOMP_taskgroup_end (void)\n       gomp_mutex_lock (&team->task_lock);\n       if (child_task)\n \t{\n+\t  if (child_task->detach_team)\n+\t    {\n+\t      assert (child_task->detach_team == team);\n+\t      child_task->kind = GOMP_TASK_DETACHED;\n+\t      ++team->task_detach_count;\n+\t      gomp_debug (0,\n+\t\t\t  \"thread %d: task with event %p finished without \"\n+\t\t\t  \"completion event fulfilled in taskgroup\\n\",\n+\t\t\t  thr->ts.team_id, child_task);\n+\t      child_task = NULL;\n+\t      continue;\n+\t    }\n+\n \t finish_cancelled:;\n \t  size_t new_tasks\n \t    = gomp_task_run_post_handle_depend (child_task, team);\n@@ -2402,17 +2416,75 @@ ialias (omp_in_final)\n void\n omp_fulfill_event (omp_event_handle_t event)\n {\n-  gomp_sem_t *sem = (gomp_sem_t *) event;\n-  struct gomp_thread *thr = gomp_thread ();\n-  struct gomp_team *team = thr ? thr->ts.team : NULL;\n+  struct gomp_task *task = (struct gomp_task *) event;\n+  if (!task->deferred_p)\n+    {\n+      if (gomp_sem_getcount (task->completion_sem) > 0)\n+\tgomp_fatal (\"omp_fulfill_event: %p event already fulfilled!\\n\", task);\n \n-  if (gomp_sem_getcount (sem) > 0)\n-    gomp_fatal (\"omp_fulfill_event: %p event already fulfilled!\\n\", sem);\n+      gomp_debug (0, \"omp_fulfill_event: %p event for undeferred task\\n\",\n+\t\t  task);\n+      gomp_sem_post (task->completion_sem);\n+      return;\n+    }\n \n-  gomp_debug (0, \"omp_fulfill_event: %p\\n\", sem);\n-  gomp_sem_post (sem);\n-  if (team)\n-    gomp_team_barrier_wake (&team->barrier, 1);\n+  struct gomp_team *team = __atomic_load_n (&task->detach_team,\n+\t\t\t\t\t    MEMMODEL_RELAXED);\n+  if (!team)\n+    gomp_fatal (\"omp_fulfill_event: %p event is invalid or has already \"\n+\t\t\"been fulfilled!\\n\", task);\n+\n+  gomp_mutex_lock (&team->task_lock);\n+  if (task->kind != GOMP_TASK_DETACHED)\n+    {\n+      /* The task has not finished running yet.  */\n+      gomp_debug (0,\n+\t\t  \"omp_fulfill_event: %p event fulfilled for unfinished \"\n+\t\t  \"task\\n\", task);\n+      __atomic_store_n (&task->detach_team, NULL, MEMMODEL_RELAXED);\n+      gomp_mutex_unlock (&team->task_lock);\n+      return;\n+    }\n+\n+  gomp_debug (0, \"omp_fulfill_event: %p event fulfilled for finished task\\n\",\n+\t      task);\n+  size_t new_tasks = gomp_task_run_post_handle_depend (task, team);\n+  gomp_task_run_post_remove_parent (task);\n+  gomp_clear_parent (&task->children_queue);\n+  gomp_task_run_post_remove_taskgroup (task);\n+  team->task_count--;\n+  team->task_detach_count--;\n+\n+  int do_wake = 0;\n+  bool shackled_thread_p = team == gomp_thread ()->ts.team;\n+  if (new_tasks > 0)\n+    {\n+      /* Wake up threads to run new tasks.  */\n+      do_wake = team->nthreads - team->task_running_count;\n+      if (do_wake > new_tasks)\n+\tdo_wake = new_tasks;\n+    }\n+\n+  if (!shackled_thread_p\n+      && !do_wake\n+      && team->task_detach_count == 0\n+      && gomp_team_barrier_waiting_for_tasks (&team->barrier))\n+    /* Ensure that at least one thread is woken up to signal that the\n+       barrier can finish.  */\n+    do_wake = 1;\n+\n+  /* If we are running in an unshackled thread, the team might vanish before\n+     gomp_team_barrier_wake is run if we release the lock first, so keep the\n+     lock for the call in that case.  */\n+  if (shackled_thread_p)\n+    gomp_mutex_unlock (&team->task_lock);\n+  if (do_wake)\n+    gomp_team_barrier_wake (&team->barrier, do_wake);\n+  if (!shackled_thread_p)\n+    gomp_mutex_unlock (&team->task_lock);\n+\n+  gomp_finish_task (task);\n+  free (task);\n }\n \n ialias (omp_fulfill_event)"}, {"sha": "96622345b103eb2520c4dad1e8b4dcee1f45bc10", "filename": "libgomp/team.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -206,7 +206,6 @@ gomp_new_team (unsigned nthreads)\n   team->work_share_cancelled = 0;\n   team->team_cancelled = 0;\n \n-  priority_queue_init (&team->task_detach_queue);\n   team->task_detach_count = 0;\n \n   return team;\n@@ -224,7 +223,6 @@ free_team (struct gomp_team *team)\n   gomp_barrier_destroy (&team->barrier);\n   gomp_mutex_destroy (&team->task_lock);\n   priority_queue_free (&team->task_queue);\n-  priority_queue_free (&team->task_detach_queue);\n   team_free (team);\n }\n "}, {"sha": "14932b02b9cb239fadcfb1cdb71d9192b9fe41ab", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-1.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -14,10 +14,10 @@ int main (void)\n   #pragma omp parallel\n     #pragma omp single\n     {\n-      #pragma omp task detach(detach_event1)\n+      #pragma omp task detach (detach_event1)\n \tx++;\n \n-      #pragma omp task detach(detach_event2)\n+      #pragma omp task detach (detach_event2)\n       {\n \ty++;\n \tomp_fulfill_event (detach_event1);"}, {"sha": "10d6746f61a0ef128ab5c01e4135a57ec6747243", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-10.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-10.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test tasks with detach clause on an offload device.  Each device\n+   thread spawns off a chain of tasks in a taskgroup, that can then\n+   be executed by any available thread.  */\n+\n+int main (void)\n+{\n+  int x = 0, y = 0, z = 0;\n+  int thread_count;\n+  omp_event_handle_t detach_event1, detach_event2;\n+\n+  #pragma omp target map (tofrom: x, y, z) map (from: thread_count)\n+    #pragma omp parallel private (detach_event1, detach_event2)\n+      #pragma omp taskgroup\n+\t{\n+\t  #pragma omp single\n+\t    thread_count = omp_get_num_threads ();\n+\n+\t  #pragma omp task detach (detach_event1) untied\n+\t    #pragma omp atomic update\n+\t      x++;\n+\n+\t  #pragma omp task detach (detach_event2) untied\n+\t  {\n+\t    #pragma omp atomic update\n+\t      y++;\n+\t    omp_fulfill_event (detach_event1);\n+\t  }\n+\n+\t  #pragma omp task untied\n+\t  {\n+\t    #pragma omp atomic update\n+\t      z++;\n+\t    omp_fulfill_event (detach_event2);\n+\t  }\n+\t}\n+\n+  assert (x == thread_count);\n+  assert (y == thread_count);\n+  assert (z == thread_count);\n+}"}, {"sha": "dd002dcc8120b890b861a32972ca4719db23d34f", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-11.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-11.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+\n+/* Test the detach clause when the task is undeferred.  */\n+\n+int main (void)\n+{\n+  omp_event_handle_t event;\n+\n+  #pragma omp task detach (event)\n+    omp_fulfill_event (event);\n+}"}, {"sha": "3e33c409fe80d6417d6db4f574155de0cc89eded", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-2.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -12,13 +12,13 @@ int main (void)\n   omp_event_handle_t detach_event1, detach_event2;\n   int x = 0, y = 0, z = 0;\n \n-  #pragma omp parallel num_threads(1)\n+  #pragma omp parallel num_threads (1)\n     #pragma omp single\n     {\n-      #pragma omp task detach(detach_event1)\n+      #pragma omp task detach (detach_event1)\n \tx++;\n \n-      #pragma omp task detach(detach_event2)\n+      #pragma omp task detach (detach_event2)\n       {\n \ty++;\n \tomp_fulfill_event (detach_event1);"}, {"sha": "c85857de21c97de8ff0e6b05dc52f43be66544eb", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-3.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -14,16 +14,16 @@ int main (void)\n   #pragma omp parallel\n     #pragma omp single\n     {\n-      #pragma omp task depend(out:dep) detach(detach_event)\n+      #pragma omp task depend (out:dep) detach (detach_event)\n \tx++;\n \n       #pragma omp task\n       {\n \ty++;\n-\tomp_fulfill_event(detach_event);\n+\tomp_fulfill_event (detach_event);\n       }\n \n-      #pragma omp task depend(in:dep)\n+      #pragma omp task depend (in:dep)\n \tz++;\n     }\n "}, {"sha": "cd0d2b353d6d17c3d5709b520db7abc2cbc42a5a", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-4.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -14,10 +14,10 @@ int main (void)\n \n   #pragma omp parallel\n     #pragma omp single\n-      #pragma omp task detach(detach_event)\n+      #pragma omp task detach (detach_event)\n       {\n \tx++;\n-\tomp_fulfill_event(detach_event);\n+\tomp_fulfill_event (detach_event);\n       }\n \n   assert (x == 1);"}, {"sha": "382f377881f771f59c642f183d670ca05d4930b9", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-5.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -12,16 +12,16 @@ int main (void)\n   int thread_count;\n   omp_event_handle_t detach_event1, detach_event2;\n \n-  #pragma omp parallel firstprivate(detach_event1, detach_event2)\n+  #pragma omp parallel private (detach_event1, detach_event2)\n   {\n     #pragma omp single\n-      thread_count = omp_get_num_threads();\n+      thread_count = omp_get_num_threads ();\n \n-    #pragma omp task detach(detach_event1) untied\n+    #pragma omp task detach (detach_event1) untied\n       #pragma omp atomic update\n \tx++;\n \n-    #pragma omp task detach(detach_event2) untied\n+    #pragma omp task detach (detach_event2) untied\n     {\n       #pragma omp atomic update\n \ty++;"}, {"sha": "e5c2291e6ff0c0070d874cd593143ef65076e9e6", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-6.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-6.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -13,11 +13,11 @@ int main (void)\n   int thread_count;\n   omp_event_handle_t detach_event1, detach_event2;\n \n-  #pragma omp target map(tofrom: x, y, z) map(from: thread_count)\n-    #pragma omp parallel firstprivate(detach_event1, detach_event2)\n+  #pragma omp target map (tofrom: x, y, z) map (from: thread_count)\n+    #pragma omp parallel private (detach_event1, detach_event2)\n       {\n \t#pragma omp single\n-\t  thread_count = omp_get_num_threads();\n+\t  thread_count = omp_get_num_threads ();\n \n \t#pragma omp task detach(detach_event1) untied\n \t  #pragma omp atomic update\n@@ -36,8 +36,6 @@ int main (void)\n \t    z++;\n \t  omp_fulfill_event (detach_event2);\n \t}\n-\n-\t#pragma omp taskwait\n       }\n \n   assert (x == thread_count);"}, {"sha": "3f025d6a13f343ef2a34d93f8fce9532347cd82a", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-7.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-7.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test tasks with detach clause.  Each thread spawns off a chain of tasks,\n+   that can then be executed by any available thread.  Each thread uses\n+   taskwait to wait for the child tasks to complete.  */\n+\n+int main (void)\n+{\n+  int x = 0, y = 0, z = 0;\n+  int thread_count;\n+  omp_event_handle_t detach_event1, detach_event2;\n+\n+  #pragma omp parallel private (detach_event1, detach_event2)\n+  {\n+    #pragma omp single\n+      thread_count = omp_get_num_threads ();\n+\n+    #pragma omp task detach (detach_event1) untied\n+      #pragma omp atomic update\n+\tx++;\n+\n+    #pragma omp task detach (detach_event2) untied\n+    {\n+      #pragma omp atomic update\n+\ty++;\n+      omp_fulfill_event (detach_event1);\n+    }\n+\n+    #pragma omp task untied\n+    {\n+      #pragma omp atomic update\n+\tz++;\n+      omp_fulfill_event (detach_event2);\n+    }\n+\n+    #pragma omp taskwait\n+  }\n+\n+  assert (x == thread_count);\n+  assert (y == thread_count);\n+  assert (z == thread_count);\n+}"}, {"sha": "6f77f1263ab9c5a86e4a4e00f4049b7e1eea08ac", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-8.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-8.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test tasks with detach clause on an offload device.  Each device\n+   thread spawns off a chain of tasks, that can then be executed by\n+   any available thread.  Each thread uses taskwait to wait for the\n+   child tasks to complete.  */\n+\n+int main (void)\n+{\n+  int x = 0, y = 0, z = 0;\n+  int thread_count;\n+  omp_event_handle_t detach_event1, detach_event2;\n+\n+  #pragma omp target map (tofrom: x, y, z) map (from: thread_count)\n+    #pragma omp parallel private (detach_event1, detach_event2)\n+      {\n+\t#pragma omp single\n+\t  thread_count = omp_get_num_threads ();\n+\n+\t#pragma omp task detach (detach_event1) untied\n+\t  #pragma omp atomic update\n+\t    x++;\n+\n+\t#pragma omp task detach (detach_event2) untied\n+\t{\n+\t  #pragma omp atomic update\n+\t    y++;\n+\t  omp_fulfill_event (detach_event1);\n+\t}\n+\n+\t#pragma omp task untied\n+\t{\n+\t  #pragma omp atomic update\n+\t    z++;\n+\t  omp_fulfill_event (detach_event2);\n+\t}\n+\n+\t#pragma omp taskwait\n+      }\n+\n+  assert (x == thread_count);\n+  assert (y == thread_count);\n+  assert (z == thread_count);\n+}"}, {"sha": "5316ca545b528045b20f661df21571830c0dcbc0", "filename": "libgomp/testsuite/libgomp.c-c++-common/task-detach-9.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Ftask-detach-9.c?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <assert.h>\n+\n+/* Test tasks with detach clause.  Each thread spawns off a chain of tasks\n+   in a taskgroup, that can then be executed by any available thread.  */\n+\n+int main (void)\n+{\n+  int x = 0, y = 0, z = 0;\n+  int thread_count;\n+  omp_event_handle_t detach_event1, detach_event2;\n+\n+  #pragma omp parallel private (detach_event1, detach_event2)\n+    #pragma omp taskgroup\n+    {\n+      #pragma omp single\n+\tthread_count = omp_get_num_threads ();\n+\n+      #pragma omp task detach (detach_event1) untied\n+\t#pragma omp atomic update\n+\t  x++;\n+\n+      #pragma omp task detach (detach_event2) untied\n+      {\n+\t#pragma omp atomic update\n+\t  y++;\n+\tomp_fulfill_event (detach_event1);\n+      }\n+\n+      #pragma omp task untied\n+      {\n+\t#pragma omp atomic update\n+\t  z++;\n+\tomp_fulfill_event (detach_event2);\n+      }\n+    }\n+\n+  assert (x == thread_count);\n+  assert (y == thread_count);\n+  assert (z == thread_count);\n+}"}, {"sha": "c53b1ca0029a79d39d4a0863f6e0909e723bd098", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-1.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -11,11 +11,11 @@ program task_detach_1\n \n   !$omp parallel\n     !$omp single\n-      !$omp task detach(detach_event1)\n+      !$omp task detach (detach_event1)\n         x = x + 1\n       !$omp end task\n \n-      !$omp task detach(detach_event2)\n+      !$omp task detach (detach_event2)\n         y = y + 1\n \tcall omp_fulfill_event (detach_event1)\n       !$omp end task"}, {"sha": "61f0ea8ba0aa1802b6ae2bfa5b1f749799f107b7", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-10.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-10.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+\n+! Test tasks with detach clause on an offload device.  Each device\n+! thread spawns off a chain of tasks in a taskgroup, that can then\n+! be executed by any available thread.\n+\n+program task_detach_10\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event1, detach_event2\n+  integer :: x = 0, y = 0, z = 0\n+  integer :: thread_count\n+\n+  !$omp target map (tofrom: x, y, z) map (from: thread_count)\n+    !$omp parallel private (detach_event1, detach_event2)\n+      !$omp taskgroup\n+\t!$omp single\n+\t  thread_count = omp_get_num_threads ()\n+\t!$omp end single\n+\n+\t!$omp task detach (detach_event1) untied\n+\t  !$omp atomic update\n+\t    x = x + 1\n+\t!$omp end task\n+\n+\t!$omp task detach (detach_event2) untied\n+\t  !$omp atomic update\n+\t    y = y + 1\n+\t  call omp_fulfill_event (detach_event1)\n+\t!$omp end task\n+\n+\t!$omp task untied\n+\t  !$omp atomic update\n+\t    z = z + 1\n+\t  call omp_fulfill_event (detach_event2)\n+\t!$omp end task\n+      !$omp end taskgroup\n+    !$omp end parallel\n+  !$omp end target\n+\n+  if (x /= thread_count) stop 1\n+  if (y /= thread_count) stop 2\n+  if (z /= thread_count) stop 3\n+end program"}, {"sha": "b33baff7f687d9e61554ebbe6f228f56b45eafb7", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-11.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-11.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+\n+! Test the detach clause when the task is undeferred.\n+\n+program task_detach_11\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event\n+\n+  !$omp task detach (detach_event)\n+    call omp_fulfill_event (detach_event)\n+  !$omp end task\n+end program"}, {"sha": "68e3ff2ef816fd9c7a08260305ef5153e5f39c0c", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-2.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-2.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -10,13 +10,13 @@ program task_detach_2\n   integer (kind=omp_event_handle_kind) :: detach_event1, detach_event2\n   integer :: x = 0, y = 0, z = 0\n \n-  !$omp parallel num_threads(1)\n+  !$omp parallel num_threads (1)\n     !$omp single\n-      !$omp task detach(detach_event1)\n+      !$omp task detach (detach_event1)\n         x = x + 1\n       !$omp end task\n \n-      !$omp task detach(detach_event2)\n+      !$omp task detach (detach_event2)\n         y = y + 1\n \tcall omp_fulfill_event (detach_event1)\n       !$omp end task"}, {"sha": "5ac68d55802c2c04a871141b3473acdbb649bc74", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-3.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-3.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -12,16 +12,16 @@ program task_detach_3\n \n   !$omp parallel\n     !$omp single\n-      !$omp task depend(out:dep) detach(detach_event)\n+      !$omp task depend (out:dep) detach (detach_event)\n         x = x + 1\n       !$omp end task\n \n       !$omp task\n         y = y + 1\n-\tcall omp_fulfill_event(detach_event)\n+\tcall omp_fulfill_event (detach_event)\n       !$omp end task\n \n-      !$omp task depend(in:dep)\n+      !$omp task depend (in:dep)\n         z = z + 1\n       !$omp end task\n     !$omp end single"}, {"sha": "159624cc74b136433dad32f8c90773bfdf20e71c", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-4.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-4.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -11,9 +11,9 @@ program task_detach_4\n \n   !$omp parallel\n     !$omp single\n-      !$omp task detach(detach_event)\n+      !$omp task detach (detach_event)\n         x = x + 1\n-\tcall omp_fulfill_event(detach_event)\n+\tcall omp_fulfill_event (detach_event)\n       !$omp end task\n     !$omp end single\n   !$omp end parallel"}, {"sha": "95bd1325e41b602da5348cf6a59a6d12341419c4", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-5.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-5.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -10,17 +10,17 @@ program task_detach_5\n   integer :: x = 0, y = 0, z = 0\n   integer :: thread_count\n \n-  !$omp parallel firstprivate(detach_event1, detach_event2)\n+  !$omp parallel private (detach_event1, detach_event2)\n     !$omp single\n-      thread_count = omp_get_num_threads()\n+      thread_count = omp_get_num_threads ()\n     !$omp end single\n \n-    !$omp task detach(detach_event1) untied\n+    !$omp task detach (detach_event1) untied\n       !$omp atomic update\n \tx = x + 1\n     !$omp end task\n \n-    !$omp task detach(detach_event2) untied\n+    !$omp task detach (detach_event2) untied\n       !$omp atomic update\n \ty = y + 1\n       call omp_fulfill_event (detach_event1);"}, {"sha": "b2c476fd6a6b219281b7f4dee2b02ef9734ecb34", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-6.f90", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-6.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -11,30 +11,28 @@ program task_detach_6\n   integer :: x = 0, y = 0, z = 0\n   integer :: thread_count\n \n-  !$omp target map(tofrom: x, y, z) map(from: thread_count)\n-    !$omp parallel firstprivate(detach_event1, detach_event2)\n+  !$omp target map (tofrom: x, y, z) map (from: thread_count)\n+    !$omp parallel private (detach_event1, detach_event2)\n       !$omp single\n-\tthread_count = omp_get_num_threads()\n+\tthread_count = omp_get_num_threads ()\n       !$omp end single\n \n-      !$omp task detach(detach_event1) untied\n+      !$omp task detach (detach_event1) untied\n \t!$omp atomic update\n \t  x = x + 1\n       !$omp end task\n \n-      !$omp task detach(detach_event2) untied\n+      !$omp task detach (detach_event2) untied\n \t!$omp atomic update\n \t  y = y + 1\n-\tcall omp_fulfill_event (detach_event1);\n+\tcall omp_fulfill_event (detach_event1)\n       !$omp end task\n \n       !$omp task untied\n \t!$omp atomic update\n \t  z = z + 1\n-\tcall omp_fulfill_event (detach_event2);\n+\tcall omp_fulfill_event (detach_event2)\n       !$omp end task\n-\n-      !$omp taskwait\n     !$omp end parallel\n   !$omp end target\n "}, {"sha": "32e715e0f81acff868051ef3c1edbc443537be5b", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-7.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-7.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+\n+! Test tasks with detach clause.  Each thread spawns off a chain of tasks,\n+! that can then be executed by any available thread.  Each thread uses\n+! taskwait to wait for the child tasks to complete.\n+\n+program task_detach_7\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event1, detach_event2\n+  integer :: x = 0, y = 0, z = 0\n+  integer :: thread_count\n+\n+  !$omp parallel private (detach_event1, detach_event2)\n+    !$omp single\n+      thread_count = omp_get_num_threads()\n+    !$omp end single\n+\n+    !$omp task detach (detach_event1) untied\n+      !$omp atomic update\n+\tx = x + 1\n+    !$omp end task\n+\n+    !$omp task detach (detach_event2) untied\n+      !$omp atomic update\n+\ty = y + 1\n+      call omp_fulfill_event (detach_event1)\n+    !$omp end task\n+\n+    !$omp task untied\n+      !$omp atomic update\n+\tz = z + 1\n+      call omp_fulfill_event (detach_event2)\n+    !$omp end task\n+\n+    !$omp taskwait\n+  !$omp end parallel\n+\n+  if (x /= thread_count) stop 1\n+  if (y /= thread_count) stop 2\n+  if (z /= thread_count) stop 3\n+end program"}, {"sha": "e760eabe158d2ea7dfa16b634d23269633a2f972", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-8.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-8.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+\n+! Test tasks with detach clause on an offload device.  Each device\n+! thread spawns off a chain of tasks, that can then be executed by\n+! any available thread.  Each thread uses taskwait to wait for the\n+! child tasks to complete.\n+\n+program task_detach_8\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event1, detach_event2\n+  integer :: x = 0, y = 0, z = 0\n+  integer :: thread_count\n+\n+  !$omp target map (tofrom: x, y, z) map (from: thread_count)\n+    !$omp parallel private (detach_event1, detach_event2)\n+      !$omp single\n+\tthread_count = omp_get_num_threads ()\n+      !$omp end single\n+\n+      !$omp task detach (detach_event1) untied\n+\t!$omp atomic update\n+\t  x = x + 1\n+      !$omp end task\n+\n+      !$omp task detach (detach_event2) untied\n+\t!$omp atomic update\n+\t  y = y + 1\n+\tcall omp_fulfill_event (detach_event1)\n+      !$omp end task\n+\n+      !$omp task untied\n+\t!$omp atomic update\n+\t  z = z + 1\n+\tcall omp_fulfill_event (detach_event2)\n+      !$omp end task\n+\n+      !$omp taskwait\n+    !$omp end parallel\n+  !$omp end target\n+\n+  if (x /= thread_count) stop 1\n+  if (y /= thread_count) stop 2\n+  if (z /= thread_count) stop 3\n+end program"}, {"sha": "540c6deaef3c95e816209c9c65110630c7553273", "filename": "libgomp/testsuite/libgomp.fortran/task-detach-9.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d656bfda2d8316627d0bbb18b10954e6aaf3c88c/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ftask-detach-9.f90?ref=d656bfda2d8316627d0bbb18b10954e6aaf3c88c", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+\n+! Test tasks with detach clause.  Each thread spawns off a chain of tasks\n+! in a taskgroup, that can then be executed by any available thread.\n+\n+program task_detach_9\n+  use omp_lib\n+\n+  integer (kind=omp_event_handle_kind) :: detach_event1, detach_event2\n+  integer :: x = 0, y = 0, z = 0\n+  integer :: thread_count\n+\n+  !$omp parallel private (detach_event1, detach_event2)\n+    !$omp taskgroup\n+      !$omp single\n+\tthread_count = omp_get_num_threads ()\n+      !$omp end single\n+\n+      !$omp task detach (detach_event1) untied\n+\t!$omp atomic update\n+\t  x = x + 1\n+      !$omp end task\n+\n+      !$omp task detach (detach_event2) untied\n+\t!$omp atomic update\n+\t  y = y + 1\n+\tcall omp_fulfill_event (detach_event1);\n+      !$omp end task\n+\n+      !$omp task untied\n+\t!$omp atomic update\n+\t  z = z + 1\n+\tcall omp_fulfill_event (detach_event2);\n+      !$omp end task\n+    !$omp end taskgroup\n+  !$omp end parallel\n+\n+  if (x /= thread_count) stop 1\n+  if (y /= thread_count) stop 2\n+  if (z /= thread_count) stop 3\n+end program"}]}