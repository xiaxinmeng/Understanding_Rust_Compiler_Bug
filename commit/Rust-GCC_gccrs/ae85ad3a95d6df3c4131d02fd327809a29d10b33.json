{"sha": "ae85ad3a95d6df3c4131d02fd327809a29d10b33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU4NWFkM2E5NWQ2ZGYzYzQxMzFkMDJmZDMyNzgwOWEyOWQxMGIzMw==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2017-09-05T13:27:58Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-09-05T13:27:58Z"}, "message": "Improve alloca alignment\n\nThis patch improves alloca alignment.  Currently alloca reserves\ntoo much space as it aligns twice, and generates unnecessary stack\nalignment code.\n\nWhen the requested alignment is lower than the stack alignment, no\nextra alignment is needed.  If the requested alignment is higher,\nwe need to increase the size by the difference of the requested \nalignment and the stack alignment.  As a result, the alloca alignment\nis exactly as expected:\n\nalloca (16):\n\tsub\tsp, sp, #16\n\tmov\tx1, sp\n\nalloca (x):\n\tadd\tx0, x0, 15\n\tand\tx0, x0, -16\n\tsub\tsp, sp, x0\n\tmov\tx0, sp\n\n__builtin_alloca_with_align (x, 512):\n\tadd\tx0, x0, 63\n\tand\tx0, x0, -16\n\tsub\tsp, sp, x0\n\tadd\tx0, sp, 63\n\tand\tx0, x0, -64\n\n    gcc/\n\t* explow.c (get_dynamic_stack_size): Improve dynamic alignment.\n\nFrom-SVN: r251713", "tree": {"sha": "7280c7e1c75597c2c29f62ff781b46e1369249c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7280c7e1c75597c2c29f62ff781b46e1369249c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae85ad3a95d6df3c4131d02fd327809a29d10b33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae85ad3a95d6df3c4131d02fd327809a29d10b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae85ad3a95d6df3c4131d02fd327809a29d10b33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae85ad3a95d6df3c4131d02fd327809a29d10b33/comments", "author": null, "committer": null, "parents": [{"sha": "54c430044ba9a35a590e591108b184535eba5763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54c430044ba9a35a590e591108b184535eba5763", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54c430044ba9a35a590e591108b184535eba5763"}], "stats": {"total": 25, "additions": 17, "deletions": 8}, "files": [{"sha": "58d162972ba9de64dc5d002be2fb4c51ad78d380", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae85ad3a95d6df3c4131d02fd327809a29d10b33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae85ad3a95d6df3c4131d02fd327809a29d10b33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae85ad3a95d6df3c4131d02fd327809a29d10b33", "patch": "@@ -1,3 +1,7 @@\n+2017-09-05  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* explow.c (get_dynamic_stack_size): Improve dynamic alignment.\n+\n 2017-09-05  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82084"}, {"sha": "638dc5f8f0fcadb4c71aa2727b4ad0a3a4a3209e", "filename": "gcc/explow.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae85ad3a95d6df3c4131d02fd327809a29d10b33/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae85ad3a95d6df3c4131d02fd327809a29d10b33/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=ae85ad3a95d6df3c4131d02fd327809a29d10b33", "patch": "@@ -1240,15 +1240,20 @@ get_dynamic_stack_size (rtx *psize, unsigned size_align,\n      example), so we must preventively align the value.  We leave space\n      in SIZE for the hole that might result from the alignment operation.  */\n \n-  extra = (required_align - BITS_PER_UNIT) / BITS_PER_UNIT;\n-  size = plus_constant (Pmode, size, extra);\n-  size = force_operand (size, NULL_RTX);\n-\n-  if (flag_stack_usage_info && pstack_usage_size)\n-    *pstack_usage_size += extra;\n+  /* Since the stack is presumed to be aligned before this allocation,\n+     we only need to increase the size of the allocation if the required\n+     alignment is more than the stack alignment.  */\n+  if (required_align > STACK_BOUNDARY)\n+    {\n+      extra = (required_align - STACK_BOUNDARY) / BITS_PER_UNIT;\n+      size = plus_constant (Pmode, size, extra);\n+      size = force_operand (size, NULL_RTX);\n+      if (size_align > STACK_BOUNDARY)\n+\tsize_align = STACK_BOUNDARY;\n \n-  if (extra && size_align > BITS_PER_UNIT)\n-    size_align = BITS_PER_UNIT;\n+      if (flag_stack_usage_info && pstack_usage_size)\n+\t*pstack_usage_size += extra;\n+    }\n \n   /* Round the size to a multiple of the required stack alignment.\n      Since the stack is presumed to be rounded before this allocation,"}]}