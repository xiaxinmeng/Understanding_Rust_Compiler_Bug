{"sha": "8071b771263555ea070313762f0d6c552934bc10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA3MWI3NzEyNjM1NTVlYTA3MDMxMzc2MmYwZDZjNTUyOTM0YmMxMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T13:43:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T13:43:32Z"}, "message": "[multiple changes]\n\n2014-07-30  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem.ads (Scope_Table_Entry): New component Locked_Shared_Objects.\n\t* sem_ch8.adb (Push_Scope): Initialize Locked_Shared_Objects.\n\t* exp_smem.adb (Add_Shared_Var_Lock_Procs): Handle the case where\n\tthe call returns an unconstrained type: in this case there is\n\talready a transient scope, and we should not establish a new one.\n\t* exp_ch7.adb (Insert_Actions_In_Scope_Around): New formal Clean. If\n\tTrue, also insert cleanup actions in the tree.\n\t(Wrap_Transient_Declaration): Call Insert_Actions_In_Scope_Around\n\twith Clean set True.\n\n2014-07-30  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-taskin.ads (Direct_Index, Direct_Index_Range,\n\tDirect_Attribute_Element, Direct_Attribute_Array,\n\tDirect_Index_Vector, Direct_Attributes, Is_Defined,\n\tIndirect_Attributes): Removed.\t(Atomic_Address,\n\tAttribute_Array, Attributes): New.\n\t* s-tasini.ads, s-tasini.adb (Proc_T, Initialize_Attributes,\n\tFinalize_Attributes_Link, Initialize_Attributes_Link): Removed.\n\t(Finalize_Attributes): Reimplement.\n\t* s-tassta.adb (Create_Task): Remove call to\n\tInitialize_Attributes_Link (Free_Task, Vulnerable_Free_Task):\n\tReplace Finalize_Attributes_Link by Finalize_Attributes.\n\t* a-tasatt.ads, a-tasatt.adb, s-tataat.ads, s-tataat.adb:\n\tReimplement from scratch, using a simpler and more efficient\n\timplementation.\n\t* s-tporft.adb (Register_Foreign_Thread): Remove now obsolete comment.\n\t* s-parame.ads, s-parame-hpux.ads,\n\t* s-parame-vms-alpha.ads, s-parame-vms-ia64.ads,\n\t* s-parame-vxworks.ads (Max_Attribute_Count): New, replace\n\tDefault_Attribute_Count.\n\nFrom-SVN: r213265", "tree": {"sha": "aa83c41fe57469afbf0b87936c68290e5b8b675c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa83c41fe57469afbf0b87936c68290e5b8b675c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8071b771263555ea070313762f0d6c552934bc10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8071b771263555ea070313762f0d6c552934bc10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8071b771263555ea070313762f0d6c552934bc10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8071b771263555ea070313762f0d6c552934bc10/comments", "author": null, "committer": null, "parents": [{"sha": "4bd4bb7f0c86291a3b6a9506739de19f87379a0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bd4bb7f0c86291a3b6a9506739de19f87379a0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bd4bb7f0c86291a3b6a9506739de19f87379a0f"}], "stats": {"total": 1261, "additions": 459, "deletions": 802}, "files": [{"sha": "499853eb9dfce17300173e3c362fc7fa4446f766", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -1,3 +1,37 @@\n+2014-07-30  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem.ads (Scope_Table_Entry): New component Locked_Shared_Objects.\n+\t* sem_ch8.adb (Push_Scope): Initialize Locked_Shared_Objects.\n+\t* exp_smem.adb (Add_Shared_Var_Lock_Procs): Handle the case where\n+\tthe call returns an unconstrained type: in this case there is\n+\talready a transient scope, and we should not establish a new one.\n+\t* exp_ch7.adb (Insert_Actions_In_Scope_Around): New formal Clean. If\n+\tTrue, also insert cleanup actions in the tree.\n+\t(Wrap_Transient_Declaration): Call Insert_Actions_In_Scope_Around\n+\twith Clean set True.\n+\n+2014-07-30  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-taskin.ads (Direct_Index, Direct_Index_Range,\n+\tDirect_Attribute_Element, Direct_Attribute_Array,\n+\tDirect_Index_Vector, Direct_Attributes, Is_Defined,\n+\tIndirect_Attributes): Removed.\t(Atomic_Address,\n+\tAttribute_Array, Attributes): New.\n+\t* s-tasini.ads, s-tasini.adb (Proc_T, Initialize_Attributes,\n+\tFinalize_Attributes_Link, Initialize_Attributes_Link): Removed.\n+\t(Finalize_Attributes): Reimplement.\n+\t* s-tassta.adb (Create_Task): Remove call to\n+\tInitialize_Attributes_Link (Free_Task, Vulnerable_Free_Task):\n+\tReplace Finalize_Attributes_Link by Finalize_Attributes.\n+\t* a-tasatt.ads, a-tasatt.adb, s-tataat.ads, s-tataat.adb:\n+\tReimplement from scratch, using a simpler and more efficient\n+\timplementation.\n+\t* s-tporft.adb (Register_Foreign_Thread): Remove now obsolete comment.\n+\t* s-parame.ads, s-parame-hpux.ads,\n+\t* s-parame-vms-alpha.ads, s-parame-vms-ia64.ads,\n+\t* s-parame-vxworks.ads (Max_Attribute_Count): New, replace\n+\tDefault_Attribute_Count.\n+\n 2014-07-30  Olivier Hainque  <hainque@adacore.com>\n \n \t* vxworks-ppc-link.spec: New file. Extra link"}, {"sha": "bd7f4a74e906454879e09fd25f52b872089ce6c9", "filename": "gcc/ada/a-tasatt.adb", "status": "modified", "additions": 179, "deletions": 407, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fa-tasatt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fa-tasatt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tasatt.adb?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -6,8 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2014, AdaCore                     --\n+--          Copyright (C) 1995-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,213 +29,189 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Storage_Elements;\n-with System.Task_Primitives.Operations;\n with System.Tasking;\n with System.Tasking.Initialization;\n with System.Tasking.Task_Attributes;\n+pragma Elaborate_All (System.Tasking.Task_Attributes);\n+\n+with System.Task_Primitives.Operations;\n \n-with Ada.Exceptions;\n+with Ada.Finalization; use Ada.Finalization;\n with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n \n-pragma Elaborate_All (System.Tasking.Task_Attributes);\n---  To ensure the initialization of object Local (below) will work\n-\n package body Ada.Task_Attributes is\n \n-   use System.Tasking.Initialization,\n+   use System,\n+       System.Tasking.Initialization,\n        System.Tasking,\n-       System.Tasking.Task_Attributes,\n-       Ada.Exceptions;\n+       System.Tasking.Task_Attributes;\n+\n+   package STPO renames System.Task_Primitives.Operations;\n+\n+   type Attribute_Cleanup is new Limited_Controlled with null record;\n+   procedure Finalize (Cleanup : in out Attribute_Cleanup);\n+   --  Finalize all tasks' attribute for this package\n \n-   package POP renames System.Task_Primitives.Operations;\n+   Cleanup : Attribute_Cleanup;\n+   pragma Unreferenced (Cleanup);\n+   --  Will call Finalize when this instantiation gets out of scope\n \n    ---------------------------\n    -- Unchecked Conversions --\n    ---------------------------\n \n-   --  The following type corresponds to Dummy_Wrapper, declared in\n-   --  System.Tasking.Task_Attributes.\n-\n-   type Wrapper;\n-   type Access_Wrapper is access all Wrapper;\n-\n+   type Real_Attribute is record\n+      Free  : Deallocator;\n+      Value : Attribute;\n+   end record;\n+   type Real_Attribute_Access is access all Real_Attribute;\n+   pragma No_Strict_Aliasing (Real_Attribute_Access);\n+   --  Each value in the task control block's Attributes array is either\n+   --  mapped to the attribute value directly if Fast_Path is True, or\n+   --  is in effect a Real_Attribute_Access.\n+   --  Note: the Deallocator field must be first, for compatibility with\n+   --  System.Tasking.Task_Attributes.Attribute_Record and to allow unchecked\n+   --  conversions between Attribute_Access and Real_Attribute_Access.\n+\n+   function New_Attribute (Val : Attribute) return Atomic_Address;\n+   --  Create a new Real_Attribute using Val, and return its address.\n+   --  The returned value can be converted via To_Real_Attribute.\n+\n+   procedure Deallocate (Ptr : Atomic_Address);\n+   --  Free memory associated with Ptr, a Real_Attribute_Access in reality\n+\n+   function To_Real_Attribute is new\n+     Ada.Unchecked_Conversion (Atomic_Address, Real_Attribute_Access);\n+\n+   --  Kill warning about possible size mismatch\n    pragma Warnings (Off);\n-   --  We turn warnings off for the following To_Attribute_Handle conversions,\n-   --  since these are used only for small attributes where we know that there\n-   --  are no problems with alignment, but the compiler will generate warnings\n-   --  for the occurrences in the large attribute case, even though they will\n-   --  not actually be used.\n-\n-   function To_Attribute_Handle is new Ada.Unchecked_Conversion\n-     (System.Address, Attribute_Handle);\n-   function To_Direct_Attribute_Element is new Ada.Unchecked_Conversion\n-     (System.Address, Direct_Attribute_Element);\n-   --  For reference to directly addressed task attributes\n-\n-   type Access_Integer_Address is access all\n-     System.Storage_Elements.Integer_Address;\n-\n-   function To_Attribute_Handle is new Ada.Unchecked_Conversion\n-     (Access_Integer_Address, Attribute_Handle);\n-   --  For reference to directly addressed task attributes\n-\n+   function To_Address is new\n+     Ada.Unchecked_Conversion (Attribute, Atomic_Address);\n+   function To_Attribute is new\n+     Ada.Unchecked_Conversion (Atomic_Address, Attribute);\n    pragma Warnings (On);\n-   --  End warnings off region for directly addressed attribute conversions\n \n-   function To_Access_Address is new Ada.Unchecked_Conversion\n-     (Access_Node, Access_Address);\n-   --  To store pointer to list of indirect attributes\n+   function To_Address is new\n+     Ada.Unchecked_Conversion (Real_Attribute_Access, Atomic_Address);\n \n+   --  Kill warning about possible aliasing\n    pragma Warnings (Off);\n-   function To_Access_Wrapper is new Ada.Unchecked_Conversion\n-     (Access_Dummy_Wrapper, Access_Wrapper);\n+   function To_Handle is new\n+     Ada.Unchecked_Conversion (System.Address, Attribute_Handle);\n    pragma Warnings (On);\n-   --  To fetch pointer to actual wrapper of attribute node. We turn off\n-   --  warnings since this may generate an alignment warning. The warning can\n-   --  be ignored since Dummy_Wrapper is only a non-generic standin for the\n-   --  real wrapper type (we never actually allocate objects of type\n-   --  Dummy_Wrapper).\n-\n-   function To_Access_Dummy_Wrapper is new Ada.Unchecked_Conversion\n-     (Access_Wrapper, Access_Dummy_Wrapper);\n-   --  To store pointer to actual wrapper of attribute node\n \n    function To_Task_Id is new Ada.Unchecked_Conversion\n      (Task_Identification.Task_Id, Task_Id);\n    --  To access TCB of identified task\n \n-   type Local_Deallocator is access procedure (P : in out Access_Node);\n+   procedure Free is new\n+     Ada.Unchecked_Deallocation (Real_Attribute, Real_Attribute_Access);\n \n-   function To_Lib_Level_Deallocator is new Ada.Unchecked_Conversion\n-     (Local_Deallocator, Deallocator);\n-   --  To defeat accessibility check\n+   Fast_Path : constant Boolean :=\n+     Attribute'Size <= Atomic_Address'Size and then\n+     To_Address (Initial_Value) = 0;\n+   --  If the attribute fits in an Atomic_Address and Initial_Value is 0 (or\n+   --  null), then we will map the attribute directly into\n+   --  ATCB.Attributes (Index), otherwise we will create a level of indirection\n+   --  and instead use Attributes (Index) as a Real_Attribute_Access.\n \n-   ------------------------\n-   -- Storage Management --\n-   ------------------------\n+   Index : constant Integer :=\n+     Next_Index (Require_Finalization => not Fast_Path);\n+   --  Index in the task control block's Attributes array\n \n-   procedure Deallocate (P : in out Access_Node);\n-   --  Passed to the RTS via unchecked conversion of a pointer to permit\n-   --  finalization and deallocation of attribute storage nodes.\n+   --------------\n+   -- Finalize --\n+   --------------\n \n-   --------------------------\n-   -- Instantiation Record --\n-   --------------------------\n+   procedure Finalize (Cleanup : in out Attribute_Cleanup) is\n+      pragma Unreferenced (Cleanup);\n+   begin\n+      STPO.Lock_RTS;\n \n-   Local : aliased Instance;\n-   --  Initialized in package body\n+      declare\n+         C : System.Tasking.Task_Id := System.Tasking.All_Tasks_List;\n+      begin\n+         while C /= null loop\n+            STPO.Write_Lock (C);\n+\n+            if C.Attributes (Index) /= 0\n+              and then Require_Finalization (Index)\n+            then\n+               Deallocate (C.Attributes (Index));\n+               C.Attributes (Index) := 0;\n+            end if;\n \n-   type Wrapper is record\n-      Dummy_Node : aliased Node;\n+            STPO.Unlock (C);\n+            C := C.Common.All_Tasks_Link;\n+         end loop;\n+      end;\n \n-      Value : aliased Attribute := Initial_Value;\n-      --  The generic formal type, may be controlled\n-   end record;\n+      Finalize (Index);\n+      STPO.Unlock_RTS;\n+   end Finalize;\n \n-   --  A number of unchecked conversions involving Wrapper_Access sources are\n-   --  performed in this unit. We have to ensure that the designated object is\n-   --  always strictly enough aligned.\n+   ----------------\n+   -- Deallocate --\n+   ----------------\n \n-   for Wrapper'Alignment use Standard'Maximum_Alignment;\n+   procedure Deallocate (Ptr : Atomic_Address) is\n+      Obj : Real_Attribute_Access := To_Real_Attribute (Ptr);\n+   begin\n+      Free (Obj);\n+   end Deallocate;\n \n-   procedure Free is\n-      new Ada.Unchecked_Deallocation (Wrapper, Access_Wrapper);\n+   -------------------\n+   -- New_Attribute --\n+   -------------------\n \n-   procedure Deallocate (P : in out Access_Node) is\n-      T : Access_Wrapper := To_Access_Wrapper (P.Wrapper);\n+   function New_Attribute (Val : Attribute) return Atomic_Address is\n+      Tmp : Real_Attribute_Access;\n    begin\n-      Free (T);\n-   end Deallocate;\n+      Tmp := new Real_Attribute'\n+        (Free  => Deallocate'Unrestricted_Access,\n+         Value => Val);\n+      return To_Address (Tmp);\n+   end New_Attribute;\n \n    ---------------\n    -- Reference --\n    ---------------\n \n    function Reference\n-     (T    : Task_Identification.Task_Id := Task_Identification.Current_Task)\n+     (T : Task_Identification.Task_Id := Task_Identification.Current_Task)\n       return Attribute_Handle\n    is\n+      Self_Id       : Task_Id;\n       TT            : constant Task_Id := To_Task_Id (T);\n       Error_Message : constant String  := \"Trying to get the reference of a \";\n+      Result        : Attribute_Handle;\n \n    begin\n       if TT = null then\n-         Raise_Exception (Program_Error'Identity, Error_Message & \"null task\");\n+         raise Program_Error with Error_Message & \"null task\";\n       end if;\n \n       if TT.Common.State = Terminated then\n-         Raise_Exception (Tasking_Error'Identity,\n-           Error_Message & \"terminated task\");\n+         raise Tasking_Error with Error_Message & \"terminated task\";\n       end if;\n \n-      --  Directly addressed case\n-\n-      if Local.Index /= 0 then\n-\n-         --  Return the attribute handle. Warnings off because this return\n-         --  statement generates alignment warnings for large attributes\n-         --  (but will never be executed in this case anyway).\n-\n-         pragma Warnings (Off);\n-         return\n-           To_Attribute_Handle (TT.Direct_Attributes (Local.Index)'Address);\n-         pragma Warnings (On);\n-\n-      --  Not directly addressed\n-\n+      if Fast_Path then\n+         return To_Handle (TT.Attributes (Index)'Address);\n       else\n-         declare\n-            P       : Access_Node := To_Access_Node (TT.Indirect_Attributes);\n-            W       : Access_Wrapper;\n-            Self_Id : constant Task_Id := POP.Self;\n+         Self_Id := STPO.Self;\n+         Task_Lock (Self_Id);\n \n-         begin\n-            Defer_Abort (Self_Id);\n-            POP.Lock_RTS;\n-\n-            while P /= null loop\n-               if P.Instance = Access_Instance'(Local'Unchecked_Access) then\n-                  POP.Unlock_RTS;\n-                  Undefer_Abort (Self_Id);\n-                  return To_Access_Wrapper (P.Wrapper).Value'Access;\n-               end if;\n-\n-               P := P.Next;\n-            end loop;\n-\n-            --  Unlock the RTS here to follow the lock ordering rule that\n-            --  prevent us from using new (i.e the Global_Lock) while holding\n-            --  any other lock.\n-\n-            POP.Unlock_RTS;\n-            W := new Wrapper'\n-                  ((null, Local'Unchecked_Access, null), Initial_Value);\n-            POP.Lock_RTS;\n-\n-            P := W.Dummy_Node'Unchecked_Access;\n-            P.Wrapper := To_Access_Dummy_Wrapper (W);\n-            P.Next := To_Access_Node (TT.Indirect_Attributes);\n-            TT.Indirect_Attributes := To_Access_Address (P);\n-            POP.Unlock_RTS;\n-            Undefer_Abort (Self_Id);\n-            return W.Value'Access;\n-\n-         exception\n-            when others =>\n-               POP.Unlock_RTS;\n-               Undefer_Abort (Self_Id);\n-               raise;\n-         end;\n-      end if;\n+         if TT.Attributes (Index) = 0 then\n+            TT.Attributes (Index) := New_Attribute (Initial_Value);\n+         end if;\n \n-   exception\n-      when Tasking_Error | Program_Error =>\n-         raise;\n+         Result := To_Handle\n+           (To_Real_Attribute (TT.Attributes (Index)).Value'Address);\n+         Task_Unlock (Self_Id);\n \n-      when others =>\n-         raise Program_Error;\n+         return Result;\n+      end if;\n    end Reference;\n \n    ------------------\n@@ -246,68 +221,37 @@ package body Ada.Task_Attributes is\n    procedure Reinitialize\n      (T : Task_Identification.Task_Id := Task_Identification.Current_Task)\n    is\n+      Self_Id       : Task_Id;\n       TT            : constant Task_Id := To_Task_Id (T);\n       Error_Message : constant String  := \"Trying to Reinitialize a \";\n \n    begin\n       if TT = null then\n-         Raise_Exception (Program_Error'Identity, Error_Message & \"null task\");\n+         raise Program_Error with Error_Message & \"null task\";\n       end if;\n \n       if TT.Common.State = Terminated then\n-         Raise_Exception (Tasking_Error'Identity,\n-           Error_Message & \"terminated task\");\n+         raise Tasking_Error with Error_Message & \"terminated task\";\n       end if;\n \n-      if Local.Index /= 0 then\n-         Set_Value (Initial_Value, T);\n+      if Fast_Path then\n+         --  No finalization needed, simply reset to Initial_Value\n+         TT.Attributes (Index) := To_Address (Initial_Value);\n       else\n-         declare\n-            P, Q    : Access_Node;\n-            W       : Access_Wrapper;\n-            Self_Id : constant Task_Id := POP.Self;\n+         Self_Id := STPO.Self;\n+         Task_Lock (Self_Id);\n \n+         declare\n+            Attr : Atomic_Address renames TT.Attributes (Index);\n          begin\n-            Defer_Abort (Self_Id);\n-            POP.Lock_RTS;\n-            Q := To_Access_Node (TT.Indirect_Attributes);\n-\n-            while Q /= null loop\n-               if Q.Instance = Access_Instance'(Local'Unchecked_Access) then\n-                  if P = null then\n-                     TT.Indirect_Attributes := To_Access_Address (Q.Next);\n-                  else\n-                     P.Next := Q.Next;\n-                  end if;\n-\n-                  W := To_Access_Wrapper (Q.Wrapper);\n-                  Free (W);\n-                  POP.Unlock_RTS;\n-                  Undefer_Abort (Self_Id);\n-                  return;\n-               end if;\n-\n-               P := Q;\n-               Q := Q.Next;\n-            end loop;\n-\n-            POP.Unlock_RTS;\n-            Undefer_Abort (Self_Id);\n-\n-         exception\n-            when others =>\n-               POP.Unlock_RTS;\n-               Undefer_Abort (Self_Id);\n-               raise;\n+            if Attr /= 0 then\n+               Deallocate (Attr);\n+               Attr := 0;\n+            end if;\n          end;\n-      end if;\n-\n-   exception\n-      when Tasking_Error | Program_Error =>\n-         raise;\n \n-      when others =>\n-         raise Program_Error;\n+         Task_Unlock (Self_Id);\n+      end if;\n    end Reinitialize;\n \n    ---------------\n@@ -318,85 +262,38 @@ package body Ada.Task_Attributes is\n      (Val : Attribute;\n       T   : Task_Identification.Task_Id := Task_Identification.Current_Task)\n    is\n+      Self_Id       : Task_Id;\n       TT            : constant Task_Id := To_Task_Id (T);\n       Error_Message : constant String  := \"Trying to Set the Value of a \";\n \n    begin\n       if TT = null then\n-         Raise_Exception (Program_Error'Identity, Error_Message & \"null task\");\n+         raise Program_Error with Error_Message & \"null task\";\n       end if;\n \n       if TT.Common.State = Terminated then\n-         Raise_Exception (Tasking_Error'Identity,\n-           Error_Message & \"terminated task\");\n+         raise Tasking_Error with Error_Message & \"terminated task\";\n       end if;\n \n-      --  Directly addressed case\n-\n-      if Local.Index /= 0 then\n-\n-         --  Set attribute handle, warnings off, because this code can generate\n-         --  alignment warnings with large attributes (but of course will not\n-         --  be executed in this case, since we never have direct addressing in\n-         --  such cases).\n-\n-         pragma Warnings (Off);\n-         To_Attribute_Handle\n-            (TT.Direct_Attributes (Local.Index)'Address).all := Val;\n-         pragma Warnings (On);\n-         return;\n-      end if;\n-\n-      --  Not directly addressed\n-\n-      declare\n-         P       : Access_Node := To_Access_Node (TT.Indirect_Attributes);\n-         W       : Access_Wrapper;\n-         Self_Id : constant Task_Id := POP.Self;\n-\n-      begin\n-         Defer_Abort (Self_Id);\n-         POP.Lock_RTS;\n-\n-         while P /= null loop\n+      if Fast_Path then\n+         --  No finalization needed, simply set to Val\n+         TT.Attributes (Index) := To_Address (Val);\n+      else\n+         Self_Id := STPO.Self;\n+         Task_Lock (Self_Id);\n \n-            if P.Instance = Access_Instance'(Local'Unchecked_Access) then\n-               To_Access_Wrapper (P.Wrapper).Value := Val;\n-               POP.Unlock_RTS;\n-               Undefer_Abort (Self_Id);\n-               return;\n+         declare\n+            Attr : Atomic_Address renames TT.Attributes (Index);\n+         begin\n+            if Attr /= 0 then\n+               Deallocate (Attr);\n             end if;\n \n-            P := P.Next;\n-         end loop;\n-\n-         --  Unlock RTS here to follow the lock ordering rule that prevent us\n-         --  from using new (i.e the Global_Lock) while holding any other lock.\n-\n-         POP.Unlock_RTS;\n-         W := new Wrapper'((null, Local'Unchecked_Access, null), Val);\n-         POP.Lock_RTS;\n-         P := W.Dummy_Node'Unchecked_Access;\n-         P.Wrapper := To_Access_Dummy_Wrapper (W);\n-         P.Next := To_Access_Node (TT.Indirect_Attributes);\n-         TT.Indirect_Attributes := To_Access_Address (P);\n-\n-         POP.Unlock_RTS;\n-         Undefer_Abort (Self_Id);\n-\n-      exception\n-         when others =>\n-            POP.Unlock_RTS;\n-            Undefer_Abort (Self_Id);\n-            raise;\n-      end;\n-\n-   exception\n-      when Tasking_Error | Program_Error =>\n-         raise;\n+            Attr := New_Attribute (Val);\n+         end;\n \n-      when others =>\n-         raise Program_Error;\n+         Task_Unlock (Self_Id);\n+      end if;\n    end Set_Value;\n \n    -----------\n@@ -407,167 +304,42 @@ package body Ada.Task_Attributes is\n      (T : Task_Identification.Task_Id := Task_Identification.Current_Task)\n       return Attribute\n    is\n+      Self_Id       : Task_Id;\n       TT            : constant Task_Id := To_Task_Id (T);\n       Error_Message : constant String  := \"Trying to get the Value of a \";\n \n    begin\n       if TT = null then\n-         Raise_Exception (Program_Error'Identity, Error_Message & \"null task\");\n+         raise Program_Error with Error_Message & \"null task\";\n       end if;\n \n       if TT.Common.State = Terminated then\n-         Raise_Exception\n-           (Program_Error'Identity, Error_Message & \"terminated task\");\n+         raise Tasking_Error with Error_Message & \"terminated task\";\n       end if;\n \n-      --  Directly addressed case\n-\n-      if Local.Index /= 0 then\n-\n-         --  Get value of attribute. We turn Warnings off, because for large\n-         --  attributes, this code can generate alignment warnings. But of\n-         --  course large attributes are never directly addressed so in fact\n-         --  we will never execute the code in this case.\n-\n-         pragma Warnings (Off);\n-         return To_Attribute_Handle\n-           (TT.Direct_Attributes (Local.Index)'Address).all;\n-         pragma Warnings (On);\n-      end if;\n-\n-      --  Not directly addressed\n-\n-      declare\n-         P       : Access_Node;\n-         Result  : Attribute;\n-         Self_Id : constant Task_Id := POP.Self;\n-\n-      begin\n-         Defer_Abort (Self_Id);\n-         POP.Lock_RTS;\n-         P := To_Access_Node (TT.Indirect_Attributes);\n-\n-         while P /= null loop\n-            if P.Instance = Access_Instance'(Local'Unchecked_Access) then\n-               Result := To_Access_Wrapper (P.Wrapper).Value;\n-               POP.Unlock_RTS;\n-               Undefer_Abort (Self_Id);\n-               return Result;\n-            end if;\n-\n-            P := P.Next;\n-         end loop;\n-\n-         POP.Unlock_RTS;\n-         Undefer_Abort (Self_Id);\n-         return Initial_Value;\n-\n-      exception\n-         when others =>\n-            POP.Unlock_RTS;\n-            Undefer_Abort (Self_Id);\n-            raise;\n-      end;\n-\n-   exception\n-      when Tasking_Error | Program_Error =>\n-         raise;\n-\n-      when others =>\n-         raise Program_Error;\n-   end Value;\n-\n---  Start of elaboration code for package Ada.Task_Attributes\n-\n-begin\n-   --  This unchecked conversion can give warnings when alignments are\n-   --  incorrect, but they will not be used in such cases anyway, so the\n-   --  warnings can be safely ignored.\n-\n-   pragma Warnings (Off);\n-   Local.Deallocate := To_Lib_Level_Deallocator (Deallocate'Access);\n-   pragma Warnings (On);\n-\n-   declare\n-      Two_To_J : Direct_Index_Vector;\n-      Self_Id  : constant Task_Id := POP.Self;\n-   begin\n-      Defer_Abort (Self_Id);\n-\n-      --  Need protection for updating links to per-task initialization and\n-      --  finalization routines, in case some task is being created or\n-      --  terminated concurrently.\n-\n-      POP.Lock_RTS;\n-\n-      --  Add this instantiation to the list of all instantiations\n-\n-      Local.Next := System.Tasking.Task_Attributes.All_Attributes;\n-      System.Tasking.Task_Attributes.All_Attributes :=\n-        Local'Unchecked_Access;\n-\n-      --  Try to find space for the attribute in the TCB\n-\n-      Local.Index := 0;\n-      Two_To_J := 1;\n-\n-      if Attribute'Size <= System.Address'Size then\n-         for J in Direct_Index_Range loop\n-            if (Two_To_J and In_Use) = 0 then\n-\n-               --  Reserve location J for this attribute\n-\n-               In_Use := In_Use or Two_To_J;\n-               Local.Index := J;\n-\n-               --  This unchecked conversion can give a warning when the\n-               --  alignment is incorrect, but it will not be used in such\n-               --  a case anyway, so the warning can be safely ignored.\n-\n-               pragma Warnings (Off);\n-               To_Attribute_Handle (Local.Initial_Value'Access).all :=\n-                 Initial_Value;\n-               pragma Warnings (On);\n-\n-               exit;\n-            end if;\n-\n-            Two_To_J := Two_To_J * 2;\n-         end loop;\n-      end if;\n-\n-      --  Attribute goes directly in the TCB\n-\n-      if Local.Index /= 0 then\n-         --  Replace stub for initialization routine that is called at task\n-         --  creation.\n-\n-         Initialization.Initialize_Attributes_Link :=\n-           System.Tasking.Task_Attributes.Initialize_Attributes'Access;\n-\n-         --  Initialize the attribute, for all tasks\n+      if Fast_Path then\n+         return To_Attribute (TT.Attributes (Index));\n+      else\n+         Self_Id := STPO.Self;\n+         Task_Lock (Self_Id);\n \n          declare\n-            C : System.Tasking.Task_Id := System.Tasking.All_Tasks_List;\n+            Attr : Atomic_Address renames TT.Attributes (Index);\n          begin\n-            while C /= null loop\n-               C.Direct_Attributes (Local.Index) :=\n-                 To_Direct_Attribute_Element\n-                   (System.Storage_Elements.To_Address (Local.Initial_Value));\n-               C := C.Common.All_Tasks_Link;\n-            end loop;\n+            if Attr = 0 then\n+               Task_Unlock (Self_Id);\n+               return Initial_Value;\n+            else\n+               declare\n+                  Result : constant Attribute :=\n+                    To_Real_Attribute (Attr).Value;\n+               begin\n+                  Task_Unlock (Self_Id);\n+                  return Result;\n+               end;\n+            end if;\n          end;\n-\n-      --  Attribute goes into a node onto a linked list\n-\n-      else\n-         --  Replace stub for finalization routine called at task termination\n-\n-         Initialization.Finalize_Attributes_Link :=\n-           System.Tasking.Task_Attributes.Finalize_Attributes'Access;\n       end if;\n+   end Value;\n \n-      POP.Unlock_RTS;\n-      Undefer_Abort (Self_Id);\n-   end;\n end Ada.Task_Attributes;"}, {"sha": "32b254f3e7d3dce20de26233a309a4b4a8b7d6b8", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -130,9 +130,10 @@ package body Exp_Ch7 is\n    --  pointers of N until it find the appropriate node to wrap. If it returns\n    --  Empty, it means that no transient scope is needed in this context.\n \n-   procedure Insert_Actions_In_Scope_Around (N : Node_Id);\n+   procedure Insert_Actions_In_Scope_Around (N : Node_Id; Clean : Boolean);\n    --  Insert the before-actions kept in the scope stack before N, and the\n-   --  after-actions after N, which must be a member of a list.\n+   --  after-actions after N, which must be a member of a list. If Clean is\n+   --  True, also insert the cleanup actions.\n \n    function Make_Transient_Block\n      (Loc    : Source_Ptr;\n@@ -4589,11 +4590,13 @@ package body Exp_Ch7 is\n    -- Insert_Actions_In_Scope_Around --\n    ------------------------------------\n \n-   procedure Insert_Actions_In_Scope_Around (N : Node_Id) is\n-      Act_After   : constant List_Id :=\n-        Scope_Stack.Table (Scope_Stack.Last).Actions_To_Be_Wrapped (After);\n+   procedure Insert_Actions_In_Scope_Around (N : Node_Id; Clean : Boolean) is\n       Act_Before  : constant List_Id :=\n         Scope_Stack.Table (Scope_Stack.Last).Actions_To_Be_Wrapped (Before);\n+      Act_After   : constant List_Id :=\n+        Scope_Stack.Table (Scope_Stack.Last).Actions_To_Be_Wrapped (After);\n+      Act_Cleanup : constant List_Id :=\n+        Scope_Stack.Table (Scope_Stack.Last).Actions_To_Be_Wrapped (Cleanup);\n       --  Note: We used to use renamings of Scope_Stack.Table (Scope_Stack.\n       --  Last), but this was incorrect as Process_Transient_Object may\n       --  introduce new scopes and cause a reallocation of Scope_Stack.Table.\n@@ -4930,6 +4933,14 @@ package body Exp_Ch7 is\n             Next (Stmt);\n          end loop;\n \n+         if Clean then\n+            if Present (Prev_Fin) then\n+               Insert_List_Before_And_Analyze (Prev_Fin, Act_Cleanup);\n+            else\n+               Insert_List_After_And_Analyze (Fin_Insrt, Act_Cleanup);\n+            end if;\n+         end if;\n+\n          --  Generate:\n          --    if Raised and then not Abort then\n          --       Raise_From_Controlled_Operation (E);\n@@ -4944,7 +4955,7 @@ package body Exp_Ch7 is\n    --  Start of processing for Insert_Actions_In_Scope_Around\n \n    begin\n-      if No (Act_Before) and then No (Act_After) then\n+      if No (Act_Before) and then No (Act_After) and then No (Act_Cleanup) then\n          return;\n       end if;\n \n@@ -5011,14 +5022,13 @@ package body Exp_Ch7 is\n \n          --  Reset the action lists\n \n-         if Present (Act_Before) then\n-            Scope_Stack.Table (Scope_Stack.Last).\n-              Actions_To_Be_Wrapped (Before) := No_List;\n-         end if;\n-\n-         if Present (Act_After) then\n+         Scope_Stack.Table (Scope_Stack.Last).\n+           Actions_To_Be_Wrapped (Before) := No_List;\n+         Scope_Stack.Table (Scope_Stack.Last).\n+           Actions_To_Be_Wrapped (After) := No_List;\n+         if Clean then\n             Scope_Stack.Table (Scope_Stack.Last).\n-              Actions_To_Be_Wrapped (After) := No_List;\n+              Actions_To_Be_Wrapped (Cleanup) := No_List;\n          end if;\n       end;\n    end Insert_Actions_In_Scope_Around;\n@@ -8005,9 +8015,10 @@ package body Exp_Ch7 is\n       Set_Parent (Block, Par);\n \n       --  Insert actions stuck in the transient scopes as well as all freezing\n-      --  nodes needed by those actions.\n+      --  nodes needed by those actions. Do not insert cleanup actions here,\n+      --  they will be transferred to the newly created block.\n \n-      Insert_Actions_In_Scope_Around (Action);\n+      Insert_Actions_In_Scope_Around (Action, Clean => False);\n \n       Insert := Prev (Action);\n       if Present (Insert) then\n@@ -8117,7 +8128,7 @@ package body Exp_Ch7 is\n    --  declaration into a transient block as usual case, otherwise the object\n    --  would be itself declared in the wrong scope. Therefore, all entities (if\n    --  any) defined in the transient block are moved to the proper enclosing\n-   --  scope, furthermore, if they are controlled variables they are finalized\n+   --  scope. Furthermore, if they are controlled variables they are finalized\n    --  right after the declaration. The finalization list of the transient\n    --  scope is defined as a renaming of the enclosing one so during their\n    --  initialization they will be attached to the proper finalization list.\n@@ -8141,9 +8152,10 @@ package body Exp_Ch7 is\n       S := Current_Scope;\n       Encl_S := Scope (S);\n \n-      --  Insert Actions kept in the Scope stack\n+      --  Insert Actions kept in the Scope stack. Since we are not generating\n+      --  a block, we must also insert the cleanup actions in the tree now.\n \n-      Insert_Actions_In_Scope_Around (N);\n+      Insert_Actions_In_Scope_Around (N, Clean => True);\n \n       --  If the declaration is consuming some secondary stack, mark the\n       --  enclosing scope appropriately."}, {"sha": "a8706603724e7ac69444469fa226b1708da1a36a", "filename": "gcc/ada/exp_smem.adb", "status": "modified", "additions": 95, "deletions": 28, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fexp_smem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fexp_smem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_smem.adb?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -25,6 +25,7 @@\n \n with Atree;    use Atree;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Tss;  use Exp_Tss;\n@@ -133,61 +134,127 @@ package body Exp_Smem is\n       Obj : constant Entity_Id  := Entity (Expression (First_Actual (N)));\n       Vnm : String_Id;\n       Vid : Entity_Id;\n+      Vde : Node_Id;\n       Aft : constant List_Id := New_List;\n \n+      In_Transient : constant Boolean := Scope_Is_Transient;\n+\n+      function Build_Shared_Var_Lock_Call (RE : RE_Id) return Node_Id;\n+      --  Return a procedure call statement for lock proc RTE\n+\n+      --------------------------------\n+      -- Build_Shared_Var_Lock_Call --\n+      --------------------------------\n+\n+      function Build_Shared_Var_Lock_Call (RE : RE_Id) return Node_Id is\n+      begin\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE), Loc),\n+             Parameter_Associations =>\n+               New_List (New_Occurrence_Of (Vid, Loc)));\n+      end Build_Shared_Var_Lock_Call;\n+\n+   --  Start of processing for Add_Shared_Var_Lock_Procs\n+\n    begin\n+      --  Discussion of transient scopes: we need to have a transient scope\n+      --  to hold the required lock/unlock actions. Either the current scope\n+      --  is transient, in which case we reuse it, or we establish a new\n+      --  transient scope. If this is a function call with unconstrained\n+      --  return type, we can't introduce a transient scope here (because\n+      --  Wrap_Transient_Expression would need to declare a temporary with\n+      --  the unconstrained type outside of the transient block), but in that\n+      --  case we know that we have already established one at an outer level\n+      --  for secondary stack management purposes.\n+\n+      --  If the lock/read/write/unlock actions for this object have already\n+      --  been emitted in the current scope, no need to perform them anew.\n+\n+      if In_Transient\n+        and then Contains (Scope_Stack.Table (Scope_Stack.Last)\n+                             .Locked_Shared_Objects,\n+                           Obj)\n+      then\n+         return;\n+      end if;\n+\n       Build_Full_Name (Obj, Vnm);\n \n-      --  Create constant string. Note that this must be done prior to\n-      --  establishing the transient scope, as the finalizer needs to have\n-      --  access to this object.\n+      --  Declare a constant string to hold the name of the shared object.\n+      --  Note that this must occur outside of the transient scope, as the\n+      --  scope's finalizer needs to have access to this object. Also, it\n+      --  appears that GIGI does not support elaborating string literal\n+      --  subtypes in transient scopes.\n \n       Vid := Make_Temporary (Loc, 'N', Obj);\n-      Insert_Action (N,\n-        Make_Object_Declaration (Loc,\n+      Vde := Make_Object_Declaration (Loc,\n           Defining_Identifier => Vid,\n           Constant_Present    => True,\n           Object_Definition   => New_Occurrence_Of (Standard_String, Loc),\n-          Expression          => Make_String_Literal (Loc, Vnm)));\n+          Expression          => Make_String_Literal (Loc, Vnm));\n \n-      --  Now set up a transient scope around the call, which will hold the\n-      --  required lock/unlock actions.\n+      if In_Transient then\n \n-      Establish_Transient_Scope (N, Sec_Stack => False);\n+         --  Already in a transient scope: make sure we insert Vde outside\n+         --  that scope.\n+\n+         Insert_Before_And_Analyze (Node_To_Be_Wrapped, Vde);\n+\n+      else\n+         --  Not in a transient scope yet: insert Vde as an action on N prio\n+         --  to establishing one.\n+\n+         Insert_Action (N, Vde);\n+\n+         Establish_Transient_Scope (N, Sec_Stack => False);\n+      end if;\n+\n+      --  Mark object as locked in the current (transient) scope\n+\n+      declare\n+         Locked_Shared_Objects : Elist_Id renames\n+           Scope_Stack.Table (Scope_Stack.Last).Locked_Shared_Objects;\n+      begin\n+         if Locked_Shared_Objects = No_Elist then\n+            Locked_Shared_Objects := New_Elmt_List;\n+         end if;\n+\n+         Append_Elmt (Obj, To => Locked_Shared_Objects);\n+      end;\n \n       --  First insert the Lock call before\n \n-      Insert_Action (N,\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Occurrence_Of (RTE (RE_Shared_Var_Lock), Loc),\n-          Parameter_Associations => New_List (New_Occurrence_Of (Vid, Loc))));\n+      Insert_Action (N, Build_Shared_Var_Lock_Call (RE_Shared_Var_Lock));\n \n       --  Now, right after the Lock, insert a call to read the object\n \n-      Insert_Action (N,\n-        Build_Shared_Var_Proc_Call (Loc, Obj, Name_Read));\n+      Insert_Action (N, Build_Shared_Var_Proc_Call (Loc, Obj, Name_Read));\n \n-      --  Now for a procedure call, but not a function call, insert the\n-      --  call to write the object just before the unlock.\n+      --  For a procedure call only, insert the call to write the object prior\n+      --  to unlocking.\n \n       if Nkind (N) = N_Procedure_Call_Statement then\n-         Append_To (Aft,\n-           Build_Shared_Var_Proc_Call (Loc, Obj, Name_Write));\n+         Append_To (Aft, Build_Shared_Var_Proc_Call (Loc, Obj, Name_Write));\n       end if;\n \n-      --  Finally insert the Unlock call after\n+      --  Finally insert the Unlock call\n+\n+      Append_To (Aft, Build_Shared_Var_Lock_Call (RE_Shared_Var_Unlock));\n \n-      Append_To (Aft,\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Occurrence_Of (RTE (RE_Shared_Var_Unlock), Loc),\n-          Parameter_Associations => New_List (New_Occurrence_Of (Vid, Loc))));\n+      --  Store cleanup actions in transient scope\n \n       Store_Cleanup_Actions_In_Scope (Aft);\n \n-      if Nkind (N) = N_Procedure_Call_Statement then\n-         Wrap_Transient_Statement (N);\n-      else\n-         Wrap_Transient_Expression (N);\n+      --  If we have established a transient scope here, wrap it now\n+\n+      if not In_Transient then\n+         if Nkind (N) = N_Procedure_Call_Statement then\n+            Wrap_Transient_Statement (N);\n+         else\n+            Wrap_Transient_Expression (N);\n+         end if;\n       end if;\n    end Add_Shared_Var_Lock_Procs;\n "}, {"sha": "b5e5d32fb5e3451920c7c74e762657e875f89307", "filename": "gcc/ada/s-parame-hpux.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame-hpux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame-hpux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-hpux.ads?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -180,9 +180,8 @@ package System.Parameters is\n    -- Task Attributes --\n    ---------------------\n \n-   Default_Attribute_Count : constant := 16;\n-   --  Number of pre-allocated Address-sized task attributes stored in the\n-   --  task control block.\n+   Max_Attribute_Count : constant := 32;\n+   --  Number of task attributes stored in the task control block.\n \n    --------------------\n    -- Runtime Traces --"}, {"sha": "a76048d2157b5a709348ca7342641e76f493ece9", "filename": "gcc/ada/s-parame-vms-alpha.ads", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame-vms-alpha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame-vms-alpha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vms-alpha.ads?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -183,9 +183,8 @@ package System.Parameters is\n    -- Task Attributes --\n    ---------------------\n \n-   Default_Attribute_Count : constant := 4;\n-   --  Number of pre-allocated Address-sized task attributes stored in the\n-   --  task control block.\n+   Max_Attribute_Count : constant := 32;\n+   --  Number of task attributes stored in the task control block.\n \n    --------------------\n    -- Runtime Traces --"}, {"sha": "f64b0bb218e9b6ed51dd0f3906bee8e959c8851f", "filename": "gcc/ada/s-parame-vms-ia64.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame-vms-ia64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame-vms-ia64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vms-ia64.ads?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -183,9 +183,8 @@ package System.Parameters is\n    -- Task Attributes --\n    ---------------------\n \n-   Default_Attribute_Count : constant := 16;\n-   --  Number of pre-allocated Address-sized task attributes stored in the\n-   --  task control block.\n+   Max_Attribute_Count : constant := 32;\n+   --  Number of task attributes stored in the task control block.\n \n    --------------------\n    -- Runtime Traces --"}, {"sha": "73007b9b0ad7a1e31536cd142666757a3e8a9146", "filename": "gcc/ada/s-parame-vxworks.ads", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vxworks.ads?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -182,9 +182,8 @@ package System.Parameters is\n    -- Task Attributes --\n    ---------------------\n \n-   Default_Attribute_Count : constant := 4;\n-   --  Number of pre-allocated Address-sized task attributes stored in the\n-   --  task control block.\n+   Max_Attribute_Count : constant := 16;\n+   --  Number of task attributes stored in the task control block.\n \n    --------------------\n    -- Runtime Traces --"}, {"sha": "4ba08803d9b88a056d939466a82c9b382b6b8011", "filename": "gcc/ada/s-parame.ads", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-parame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame.ads?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -182,9 +182,8 @@ package System.Parameters is\n    -- Task Attributes --\n    ---------------------\n \n-   Default_Attribute_Count : constant := 16;\n-   --  Number of pre-allocated Address-sized task attributes stored in the\n-   --  task control block.\n+   Max_Attribute_Count : constant := 32;\n+   --  Number of task attributes stored in the task control block.\n \n    --------------------\n    -- Runtime Traces --"}, {"sha": "66734b1651f4706acfd4a20c1407e756745e4c02", "filename": "gcc/ada/s-tasini.adb", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tasini.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tasini.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.adb?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -45,6 +45,7 @@ with System.Task_Primitives.Operations;\n with System.Soft_Links;\n with System.Soft_Links.Tasking;\n with System.Tasking.Debug;\n+with System.Tasking.Task_Attributes;\n with System.Parameters;\n \n with System.Secondary_Stack;\n@@ -807,26 +808,22 @@ package body System.Tasking.Initialization is\n       end if;\n    end Wakeup_Entry_Caller;\n \n-   -----------------------\n-   -- Soft-Link Dummies --\n-   -----------------------\n-\n-   --  These are dummies for subprograms that are only needed by certain\n-   --  optional run-time system packages. If they are needed, the soft links\n-   --  will be redirected to the real subprogram by elaboration of the\n-   --  subprogram body where the real subprogram is declared.\n+   -------------------------\n+   -- Finalize_Attributes --\n+   -------------------------\n \n    procedure Finalize_Attributes (T : Task_Id) is\n-      pragma Unreferenced (T);\n+      Attr : Atomic_Address;\n    begin\n-      null;\n-   end Finalize_Attributes;\n+      for J in T.Attributes'Range loop\n+         Attr := T.Attributes (J);\n \n-   procedure Initialize_Attributes (T : Task_Id) is\n-      pragma Unreferenced (T);\n-   begin\n-      null;\n-   end Initialize_Attributes;\n+         if Attr /= 0 and then Task_Attributes.Require_Finalization (J) then\n+            Task_Attributes.To_Attribute (Attr).Free (Attr);\n+            T.Attributes (J) := 0;\n+         end if;\n+      end loop;\n+   end Finalize_Attributes;\n \n begin\n    Init_RTS;"}, {"sha": "831961a44bf3dde30364d734603282c5da57169d", "filename": "gcc/ada/s-tasini.ads", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tasini.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tasini.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasini.ads?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,27 +37,15 @@ package System.Tasking.Initialization is\n    procedure Remove_From_All_Tasks_List (T : Task_Id);\n    --  Remove T from All_Tasks_List. Call this function with RTS_Lock taken\n \n+   procedure Finalize_Attributes (T : Task_Id);\n+   --  Finalize all attributes from T\n+   --  This is to be called just before the ATCB is deallocated.\n+   --  It relies on the caller holding T.L write-lock on entry.\n+\n    ---------------------------------\n    -- Tasking-Specific Soft Links --\n    ---------------------------------\n \n-   --  These permit us to leave out certain portions of the tasking\n-   --  run-time system if they are not used.  They are only used internally\n-   --  by the tasking run-time system.\n-\n-   --  So far, the only example is support for Ada.Task_Attributes\n-\n-   type Proc_T is access procedure (T : Task_Id);\n-\n-   procedure Finalize_Attributes (T : Task_Id);\n-   procedure Initialize_Attributes (T : Task_Id);\n-\n-   Finalize_Attributes_Link : Proc_T := Finalize_Attributes'Access;\n-   --  should be called with abort deferred and T.L write-locked\n-\n-   Initialize_Attributes_Link : Proc_T := Initialize_Attributes'Access;\n-   --  should be called with abort deferred, but holding no locks\n-\n    -------------------------\n    -- Abort Defer/Undefer --\n    -------------------------"}, {"sha": "9a47c6abe44405c3b8862539651918e076821882", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 9, "deletions": 25, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -938,22 +938,13 @@ package System.Tasking is\n    type Entry_Call_Array is array (ATC_Level_Index) of\n      aliased Entry_Call_Record;\n \n-   type Direct_Index is range 0 .. Parameters.Default_Attribute_Count;\n-   subtype Direct_Index_Range is Direct_Index range 1 .. Direct_Index'Last;\n-   --  Attributes with indexes in this range are stored directly in the task\n-   --  control block. Such attributes must be Address-sized. Other attributes\n-   --  will be held in dynamically allocated records chained off of the task\n-   --  control block.\n-\n-   type Direct_Attribute_Element is mod Memory_Size;\n-   pragma Atomic (Direct_Attribute_Element);\n-\n-   type Direct_Attribute_Array is\n-     array (Direct_Index_Range) of aliased Direct_Attribute_Element;\n-\n-   type Direct_Index_Vector is mod 2 ** Parameters.Default_Attribute_Count;\n-   --  This is a bit-vector type, used to store information about\n-   --  the usage of the direct attribute fields.\n+   type Atomic_Address is mod Memory_Size;\n+   pragma Atomic (Atomic_Address);\n+   type Attribute_Array is\n+     array (1 .. Parameters.Max_Attribute_Count) of Atomic_Address;\n+   --  Array of task attributes.\n+   --  The value (Atomic_Address) will either be converted to a task\n+   --  attribute if it fits, or to a pointer to a record by Ada.Task_Attributes\n \n    type Task_Serial_Number is mod 2 ** 64;\n    --  Used to give each task a unique serial number\n@@ -1139,15 +1130,8 @@ package System.Tasking is\n       --  User-writeable location, for use in debugging tasks; also provides a\n       --  simple task specific data.\n \n-      Direct_Attributes : Direct_Attribute_Array;\n-      --  For task attributes that have same size as Address\n-\n-      Is_Defined : Direct_Index_Vector := 0;\n-      --  Bit I is 1 iff Direct_Attributes (I) is defined\n-\n-      Indirect_Attributes : Access_Address;\n-      --  A pointer to chain of records for other attributes that are not\n-      --  address-sized, including all tagged types.\n+      Attributes : Attribute_Array := (others => 0);\n+      --  Task attributes\n \n       Entry_Queues : Task_Entry_Queue_Array (1 .. Entry_Num);\n       --  An array of task entry queues"}, {"sha": "b11656970bd28caee1202a45041d8e62674971ff", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -707,7 +707,6 @@ package body System.Tasking.Stages is\n       SSL.Create_TSD (T.Common.Compiler_Data);\n       T.Common.Activation_Link := Chain.T_ID;\n       Chain.T_ID := T;\n-      Initialization.Initialize_Attributes_Link.all (T);\n       Created_Task := T;\n       Initialization.Undefer_Abort_Nestable (Self_ID);\n \n@@ -953,7 +952,7 @@ package body System.Tasking.Stages is\n          Initialization.Task_Lock (Self_Id);\n \n          Lock_RTS;\n-         Initialization.Finalize_Attributes_Link.all (T);\n+         Initialization.Finalize_Attributes (T);\n          Initialization.Remove_From_All_Tasks_List (T);\n          Unlock_RTS;\n \n@@ -2076,7 +2075,7 @@ package body System.Tasking.Stages is\n       end if;\n \n       Write_Lock (T);\n-      Initialization.Finalize_Attributes_Link.all (T);\n+      Initialization.Finalize_Attributes (T);\n       Unlock (T);\n \n       if Single_Lock then"}, {"sha": "14440263fb4f35a615449691cca2b72e2af61598", "filename": "gcc/ada/s-tataat.adb", "status": "modified", "additions": 41, "deletions": 171, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tataat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tataat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tataat.adb?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -6,8 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2013, AdaCore                     --\n+--          Copyright (C) 1995-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,189 +29,60 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Unchecked_Conversion;\n-\n-with System.Task_Primitives.Operations;\n-with System.Tasking.Initialization;\n+with System.Parameters; use System.Parameters;\n+with System.Tasking.Initialization; use System.Tasking.Initialization;\n \n package body System.Tasking.Task_Attributes is\n \n-   use Task_Primitives.Operations;\n-   use Tasking.Initialization;\n+   ----------------\n+   -- Next_Index --\n+   ----------------\n \n-   function To_Access_Address is new Ada.Unchecked_Conversion\n-     (Access_Node, Access_Address);\n-   --  Store pointer to indirect attribute list\n+   type Index_Info is record\n+      Used, Require_Finalization : Boolean;\n+   end record;\n+   --  Used is True if a given index is used by an instantiation of\n+   --  Ada.Task_Attributes, False otherwise.\n+   --  Require_Finalization is True is the attribute requires finalization.\n \n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (X : in out Instance) is\n-      Q, To_Be_Freed : Access_Node;\n-      Self_Id        : constant Task_Id := Self;\n+   Index_Array : array (1 .. Max_Attribute_Count) of Index_Info :=\n+     (others => (False, False));\n \n+   function Next_Index (Require_Finalization : Boolean) return Integer is\n+      Self_Id : constant Task_Id := Self;\n    begin\n-      --  Defer abort. Note that we use the nestable versions of Defer_Abort\n-      --  and Undefer_Abort, because abort can already deferred when this is\n-      --  called during finalization, which would cause an assert failure\n-      --  in Defer_Abort.\n-\n-      Defer_Abort_Nestable (Self_Id);\n-      Lock_RTS;\n-\n-      --  Remove this instantiation from the list of all instantiations\n-\n-      declare\n-         P : Access_Instance;\n-         Q : Access_Instance := All_Attributes;\n-\n-      begin\n-         while Q /= null and then Q /= X'Unchecked_Access loop\n-            P := Q; Q := Q.Next;\n-         end loop;\n-\n-         pragma Assert (Q /= null);\n-\n-         if P = null then\n-            All_Attributes := Q.Next;\n-         else\n-            P.Next := Q.Next;\n+      Task_Lock (Self_Id);\n+\n+      for J in Index_Array'Range loop\n+         if not Index_Array (J).Used then\n+            Index_Array (J).Used := True;\n+            Index_Array (J).Require_Finalization := Require_Finalization;\n+            Task_Unlock (Self_Id);\n+            return J;\n          end if;\n-      end;\n-\n-      if X.Index /= 0 then\n-\n-         --  Free location of this attribute, for reuse\n-\n-         In_Use := In_Use and not (2**Natural (X.Index));\n-\n-         --  There is no need for finalization in this case, since controlled\n-         --  types are too big to fit in the TCB.\n-\n-      else\n-         --  Remove nodes for this attribute from the lists of all tasks,\n-         --  and deallocate the nodes. Deallocation does finalization, if\n-         --  necessary.\n-\n-         declare\n-            C : System.Tasking.Task_Id := All_Tasks_List;\n-            P : Access_Node;\n-\n-         begin\n-            while C /= null loop\n-               Write_Lock (C);\n-\n-               Q := To_Access_Node (C.Indirect_Attributes);\n-               while Q /= null\n-                 and then Q.Instance /= X'Unchecked_Access\n-               loop\n-                  P := Q;\n-                  Q := Q.Next;\n-               end loop;\n-\n-               if Q /= null then\n-                  if P = null then\n-                     C.Indirect_Attributes := To_Access_Address (Q.Next);\n-                  else\n-                     P.Next := Q.Next;\n-                  end if;\n-\n-                  --  Can't Deallocate now since we are holding RTS_Lock\n-\n-                  Q.Next := To_Be_Freed;\n-                  To_Be_Freed := Q;\n-               end if;\n-\n-               Unlock (C);\n-               C := C.Common.All_Tasks_Link;\n-            end loop;\n-         end;\n-      end if;\n-\n-      Unlock_RTS;\n-\n-      while To_Be_Freed /= null loop\n-         Q := To_Be_Freed;\n-         To_Be_Freed := To_Be_Freed.Next;\n-         X.Deallocate.all (Q);\n       end loop;\n \n-      Undefer_Abort_Nestable (Self_Id);\n+      Task_Unlock (Self_Id);\n+      raise Storage_Error with \"Out of task attributes\";\n+   end Next_Index;\n \n-   exception\n-      when others =>\n-         null;\n-         pragma Assert (False,\n-           \"Exception in task attribute instance finalization\");\n-   end Finalize;\n-\n-   -------------------------\n-   -- Finalize Attributes --\n-   -------------------------\n-\n-   --  This is to be called just before the ATCB is deallocated.\n-   --  It relies on the caller holding T.L write-lock on entry.\n-\n-   procedure Finalize_Attributes (T : Task_Id) is\n-      P : Access_Node;\n-      Q : Access_Node := To_Access_Node (T.Indirect_Attributes);\n-\n-   begin\n-      --  Deallocate all the indirect attributes of this task\n-\n-      while Q /= null loop\n-         P := Q;\n-         Q := Q.Next; P.Instance.Deallocate.all (P);\n-      end loop;\n-\n-      T.Indirect_Attributes := null;\n-\n-   exception\n-      when others =>\n-         null;\n-         pragma Assert (False,\n-           \"Exception in per-task attributes finalization\");\n-   end Finalize_Attributes;\n-\n-   ---------------------------\n-   -- Initialize Attributes --\n-   ---------------------------\n-\n-   --  This is to be called by System.Tasking.Stages.Create_Task\n+   --------------\n+   -- Finalize --\n+   --------------\n \n-   procedure Initialize_Attributes (T : Task_Id) is\n-      P       : Access_Instance;\n+   procedure Finalize (Index : Integer) is\n       Self_Id : constant Task_Id := Self;\n-\n    begin\n-      --  Note: we call [Un]Defer_Abort_Nestable, rather than [Un]Defer_Abort,\n-      --  because Abort might already be deferred in Create_Task.\n-\n-      Defer_Abort_Nestable (Self_Id);\n-      Lock_RTS;\n-\n-      --  Initialize all the direct-access attributes of this task\n-\n-      P := All_Attributes;\n-\n-      while P /= null loop\n-         if P.Index /= 0 then\n-            T.Direct_Attributes (P.Index) :=\n-              Direct_Attribute_Element\n-                (System.Storage_Elements.To_Address (P.Initial_Value));\n-         end if;\n-\n-         P := P.Next;\n-      end loop;\n-\n-      Unlock_RTS;\n-      Undefer_Abort_Nestable (Self_Id);\n+      pragma Assert (Index in Index_Array'Range);\n+      Task_Lock (Self_Id);\n+      Index_Array (Index).Used := False;\n+      Task_Unlock (Self_Id);\n+   end Finalize;\n \n-   exception\n-      when others =>\n-         null;\n-         pragma Assert (False);\n-   end Initialize_Attributes;\n+   function Require_Finalization (Index : Integer) return Boolean is\n+   begin\n+      pragma Assert (Index in Index_Array'Range);\n+      return Index_Array (Index).Require_Finalization;\n+   end Require_Finalization;\n \n end System.Tasking.Task_Attributes;"}, {"sha": "878dc40d34daac857ad1f8b52e1ca279718888de", "filename": "gcc/ada/s-tataat.ads", "status": "modified", "additions": 33, "deletions": 89, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tataat.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tataat.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tataat.ads?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -6,8 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2010, AdaCore                     --\n+--          Copyright (C) 1995-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,96 +31,41 @@\n \n --  This package provides support for the body of Ada.Task_Attributes\n \n-with Ada.Finalization;\n-\n-with System.Storage_Elements;\n+with Ada.Unchecked_Conversion;\n \n package System.Tasking.Task_Attributes is\n \n-   type Attribute is new Integer;\n-   --  A stand-in for the generic formal type of Ada.Task_Attributes\n-   --  in the following declarations.\n-\n-   type Node;\n-   type Access_Node is access all Node;\n-   --  This needs comments ???\n-\n-   function To_Access_Node is new Ada.Unchecked_Conversion\n-     (Access_Address, Access_Node);\n-   --  Used to fetch pointer to indirect attribute list. Declaration is in\n-   --  spec to avoid any problems with aliasing assumptions.\n-\n-   type Dummy_Wrapper;\n-   type Access_Dummy_Wrapper is access all Dummy_Wrapper;\n-   pragma No_Strict_Aliasing (Access_Dummy_Wrapper);\n-   --  Needed to avoid possible incorrect aliasing situations from\n-   --  instantiation of Unchecked_Conversion in body of Ada.Task_Attributes.\n-\n-   for Access_Dummy_Wrapper'Storage_Size use 0;\n-   --  Access_Dummy_Wrapper is a stand-in for the generic type Wrapper defined\n-   --  in Ada.Task_Attributes. The real objects allocated are always\n-   --  of type Wrapper, no Dummy_Wrapper objects are ever created.\n-\n-   type Deallocator is access procedure (P : in out Access_Node);\n-   --  Called to deallocate an Wrapper. P is a pointer to a Node within\n+   type Deallocator is access procedure (Ptr : Atomic_Address);\n \n-   type Instance;\n-\n-   type Access_Instance is access all Instance;\n-\n-   type Instance is new Ada.Finalization.Limited_Controlled with record\n-      Deallocate    : Deallocator;\n-      Initial_Value : aliased System.Storage_Elements.Integer_Address;\n-\n-      Index : Direct_Index;\n-      --  The index of the TCB location used by this instantiation, if it is\n-      --  stored in the TCB, otherwise zero.\n-\n-      Next : Access_Instance;\n-      --  Next instance in All_Attributes list\n+   type Attribute_Record is record\n+      Free : Deallocator;\n    end record;\n-\n-   procedure Finalize (X : in out Instance);\n-\n-   type Node is record\n-      Wrapper  : Access_Dummy_Wrapper;\n-      Instance : Access_Instance;\n-      Next     : Access_Node;\n-   end record;\n-\n-   --  The following type is a stand-in for the actual wrapper type, which is\n-   --  different for each instantiation of Ada.Task_Attributes.\n-\n-   type Dummy_Wrapper is record\n-      Dummy_Node : aliased Node;\n-\n-      Value : aliased Attribute;\n-      --  The generic formal type, may be controlled\n-   end record;\n-\n-   for Dummy_Wrapper'Alignment use Standard'Maximum_Alignment;\n-   --  A number of unchecked conversions involving Dummy_Wrapper_Access\n-   --  sources are performed in other units (e.g. Ada.Task_Attributes).\n-   --  Ensure that the designated object is always strictly enough aligned.\n-\n-   In_Use : Direct_Index_Vector := 0;\n-   --  Set True for direct indexes that are already used (True??? type???)\n-\n-   All_Attributes : Access_Instance;\n-   --  A linked list of all indirectly access attributes, which includes all\n-   --  those that require finalization.\n-\n-   procedure Initialize_Attributes (T : Task_Id);\n-   --  Initialize all attributes created via Ada.Task_Attributes for T. This\n-   --  must be called by the creator of the task, inside Create_Task, via\n-   --  soft-link Initialize_Attributes_Link. On entry, abort must be deferred\n-   --  and the caller must hold no locks\n-\n-   procedure Finalize_Attributes (T : Task_Id);\n-   --  Finalize all attributes created via Ada.Task_Attributes for T.\n-   --  This is to be called by the task after it is marked as terminated\n-   --  (and before it actually dies), inside Vulnerable_Free_Task, via the\n-   --  soft-link Finalize_Attributes_Link. On entry, abort must be deferred\n-   --  and T.L must be write-locked.\n-\n+   --  The real type is declared in Ada.Task_Attributes body: Real_Attribute\n+   --  As long as the first field is the deallocator we are good.\n+\n+   type Attribute_Access is access all Attribute_Record;\n+   pragma No_Strict_Aliasing (Attribute_Access);\n+\n+   function To_Attribute is new\n+     Ada.Unchecked_Conversion (Atomic_Address, Attribute_Access);\n+\n+   function Next_Index (Require_Finalization : Boolean) return Integer;\n+   --  Return the next attribute index available.\n+   --  Require_Finalization is True if the attribute requires finalization\n+   --  and in particular its deallocator (Free field in Attribute_Record)\n+   --  should be called.\n+   --  Raise Storage_Error if no index is available.\n+\n+   function Require_Finalization (Index : Integer) return Boolean;\n+   --  Return True if a given attribute index requires call to Free.\n+   --  This call is not protected against concurrent access, should only\n+   --  be called during finalization of the corresponding instantiation of\n+   --  Ada.Task_Attributes, or during finalization of a task.\n+\n+   procedure Finalize (Index : Integer);\n+   --  Finalize given Index, possibly allowing future reuse\n+\n+private\n+   pragma Inline (Finalize);\n+   pragma Inline (Require_Finalization);\n end System.Tasking.Task_Attributes;"}, {"sha": "32bb1f08db90c007a239083da60a2366ce30d5fd", "filename": "gcc/ada/s-tporft.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tporft.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fs-tporft.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tporft.adb?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---          Copyright (C) 2002-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2002-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -94,15 +94,6 @@ begin\n \n    System.Soft_Links.Create_TSD (Self_Id.Common.Compiler_Data);\n \n-   --  ???\n-   --  The following call is commented out to avoid dependence on the\n-   --  System.Tasking.Initialization package. It seems that if we want\n-   --  Ada.Task_Attributes to work correctly for C threads we will need to\n-   --  raise the visibility of this soft link to System.Soft_Links. We are\n-   --  putting that off until this new functionality is otherwise stable.\n-\n-   --  System.Tasking.Initialization.Initialize_Attributes_Link.all (T);\n-\n    Enter_Task (Self_Id);\n \n    return Self_Id;"}, {"sha": "f70c0568554e7a739392348a5fde672497c50d3c", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -538,6 +538,9 @@ package Sem is\n       --  Standard_Standard can be pushed anew on the scope stack to start a\n       --  new active section (see comment above).\n \n+      Locked_Shared_Objects : Elist_Id;\n+      --  List of shared passive protected objects that have been locked in\n+      --  this transient scope (always No_Elist for non-transient scopes).\n    end record;\n \n    package Scope_Stack is new Table.Table ("}, {"sha": "03e59d6634d019ea101fd44788c0d6b2242c82d0", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8071b771263555ea070313762f0d6c552934bc10/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=8071b771263555ea070313762f0d6c552934bc10", "patch": "@@ -7646,6 +7646,7 @@ package body Sem_Ch8 is\n          SST.First_Use_Clause               := Empty;\n          SST.Is_Active_Stack_Base           := False;\n          SST.Previous_Visibility            := False;\n+         SST.Locked_Shared_Objects          := No_Elist;\n       end;\n \n       if Debug_Flag_W then"}]}