{"sha": "6883a6662fc7728a539230ea1b02efd47815d705", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg4M2E2NjYyZmM3NzI4YTUzOTIzMGVhMWIwMmVmZDQ3ODE1ZDcwNQ==", "commit": {"author": {"name": "Nicolas Pitre", "email": "nico@cam.org", "date": "2004-10-21T04:22:01Z"}, "committer": {"name": "Nicolas Pitre", "email": "nico@gcc.gnu.org", "date": "2004-10-21T04:22:01Z"}, "message": "ieee754-sf.S: Large speed improvements.\n\n* config/arm/ieee754-sf.S: Large speed improvements. Fix NAN handling.\n* config/arm/ieee754-df.S: Ditto.\n\nFrom-SVN: r89364", "tree": {"sha": "9fda943368aa15ad74a4a037362c1ee02af23752", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fda943368aa15ad74a4a037362c1ee02af23752"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6883a6662fc7728a539230ea1b02efd47815d705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6883a6662fc7728a539230ea1b02efd47815d705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6883a6662fc7728a539230ea1b02efd47815d705", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6883a6662fc7728a539230ea1b02efd47815d705/comments", "author": null, "committer": null, "parents": [{"sha": "0aab7a4b725f565fcd1dbc85c798a2dc88914c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aab7a4b725f565fcd1dbc85c798a2dc88914c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aab7a4b725f565fcd1dbc85c798a2dc88914c2c"}], "stats": {"total": 1868, "additions": 868, "deletions": 1000}, "files": [{"sha": "e5265e70a0daf914e271e3af36fee72914432c44", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6883a6662fc7728a539230ea1b02efd47815d705/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6883a6662fc7728a539230ea1b02efd47815d705/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6883a6662fc7728a539230ea1b02efd47815d705", "patch": "@@ -1,3 +1,8 @@\n+2004-10-21  Nicolas Pitre <nico@cam.org>\n+\n+\t* config/arm/ieee754-sf.S: Large speed improvements. Fix NAN handling.\n+\t* config/arm/ieee754-df.S: Ditto.\n+\n 2004-10-20  Zack Weinberg  <zack@codesourcery.com>\n \n \t* dbxout.c (asmfile): Delete.  All uses changed to asm_out_file."}, {"sha": "b9cf52e64582ec9a8ab881ee7833f262bb84ca98", "filename": "gcc/config/arm/ieee754-df.S", "status": "modified", "additions": 461, "deletions": 522, "changes": 983, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6883a6662fc7728a539230ea1b02efd47815d705/gcc%2Fconfig%2Farm%2Fieee754-df.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6883a6662fc7728a539230ea1b02efd47815d705/gcc%2Fconfig%2Farm%2Fieee754-df.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fieee754-df.S?ref=6883a6662fc7728a539230ea1b02efd47815d705", "patch": "@@ -60,6 +60,7 @@\n \n ARM_FUNC_START negdf2\n ARM_FUNC_ALIAS aeabi_dneg negdf2\n+\n \t@ flip sign bit\n \teor\txh, xh, #0x80000000\n \tRET\n@@ -76,47 +77,34 @@ ARM_FUNC_START aeabi_drsub\n \teor\txh, xh, #0x80000000\t@ flip sign bit of first arg\n \tb\t1f\t\n \n-\tARM_FUNC_START subdf3\n+ARM_FUNC_START subdf3\n ARM_FUNC_ALIAS aeabi_dsub subdf3\n-\t@ flip sign bit of second arg\n-\teor\tyh, yh, #0x80000000\n+\n+\teor\tyh, yh, #0x80000000\t@ flip sign bit of second arg\n #if defined(__thumb__) && !defined(__THUMB_INTERWORK__)\n \tb\t1f\t\t\t@ Skip Thumb-code prologue\n #endif\n \n ARM_FUNC_START adddf3\n ARM_FUNC_ALIAS aeabi_dadd adddf3\n \n-1:\t@ Compare both args, return zero if equal but the sign.\n-\tteq\txl, yl\n-\teoreq\tip, xh, yh\n-\tteqeq\tip, #0x80000000\n-\tbeq\tLSYM(Lad_z)\n-\n-\t@ If first arg is 0 or -0, return second arg.\n-\t@ If second arg is 0 or -0, return first arg.\n-\torrs\tip, xl, xh, lsl #1\n-\tmoveq\txl, yl\n-\tmoveq\txh, yh\n-\torrnes\tip, yl, yh, lsl #1\n-\tRETc(eq)\n-\n-\tstmfd\tsp!, {r4, r5, lr}\n-\n-\t@ Mask out exponents.\n-\tmov\tip, #0x7f000000\n-\torr\tip, ip, #0x00f00000\n-\tand\tr4, xh, ip\n-\tand\tr5, yh, ip\n+1:\tstmfd\tsp!, {r4, r5, lr}\n \n-\t@ If either of them is 0x7ff, result will be INF or NAN\n-\tteq\tr4, ip\n-\tteqne\tr5, ip\n-\tbeq\tLSYM(Lad_i)\n+\t@ Look for zeroes, equal values, INF, or NAN.\n+\tmov\tr4, xh, lsl #1\n+\tmov\tr5, yh, lsl #1\n+\tteq\tr4, r5\n+\tteqeq\txl, yl\n+\torrnes\tip, r4, xl\n+\torrnes\tip, r5, yl\n+\tmvnnes\tip, r4, asr #21\n+\tmvnnes\tip, r5, asr #21\n+\tbeq\tLSYM(Lad_s)\n \n \t@ Compute exponent difference.  Make largest exponent in r4,\n \t@ corresponding arg in xh-xl, and positive exponent difference in r5.\n-\tsubs\tr5, r5, r4\n+\tmov\tr4, r4, lsr #21\n+\trsbs\tr5, r4, r5, lsr #21\n \trsblt\tr5, r5, #0\n \tble\t1f\n \tadd\tr4, r4, r5\n@@ -127,24 +115,24 @@ ARM_FUNC_ALIAS aeabi_dadd adddf3\n \teor\tyl, xl, yl\n \teor\tyh, xh, yh\n 1:\n-\n \t@ If exponent difference is too large, return largest argument\n \t@ already in xh-xl.  We need up to 54 bit to handle proper rounding\n \t@ of 0x1p54 - 1.1.\n-\tcmp\tr5, #(54 << 20)\n+\tcmp\tr5, #54\n \tRETLDM\t\"r4, r5\" hi\n \n \t@ Convert mantissa to signed integer.\n \ttst\txh, #0x80000000\n-\tbic\txh, xh, ip, lsl #1\n-\torr\txh, xh, #0x00100000\n+\tmov\txh, xh, lsl #12\n+\tmov\tip, #0x00100000\n+\torr\txh, ip, xh, lsr #12\n \tbeq\t1f\n \trsbs\txl, xl, #0\n \trsc\txh, xh, #0\n 1:\n \ttst\tyh, #0x80000000\n-\tbic\tyh, yh, ip, lsl #1\n-\torr\tyh, yh, #0x00100000\n+\tmov\tyh, yh, lsl #12\n+\torr\tyh, ip, yh, lsr #12\n \tbeq\t1f\n \trsbs\tyl, yl, #0\n \trsc\tyh, yh, #0\n@@ -154,42 +142,30 @@ ARM_FUNC_ALIAS aeabi_dadd adddf3\n \tteq\tr4, r5\n \tbeq\tLSYM(Lad_d)\n LSYM(Lad_x):\n-\t@ Scale down second arg with exponent difference.\n-\t@ Apply shift one bit left to first arg and the rest to second arg\n-\t@ to simplify things later, but only if exponent does not become 0.\n-\tmov\tip, #0\n-\tmovs\tr5, r5, lsr #20\n-\tbeq\t3f\n-\tteq\tr4, #(1 << 20)\n-\tbeq\t1f\n-\tmovs\txl, xl, lsl #1\n-\tadc\txh, ip, xh, lsl #1\n-\tsub\tr4, r4, #(1 << 20)\n-\tsubs\tr5, r5, #1\n-\tbeq\t3f\n \n-\t@ Shift yh-yl right per r5, keep leftover bits into ip.\n-1:\trsbs\tlr, r5, #32\n-\tblt\t2f\n+\t@ Compensate for the exponent overlapping the mantissa MSB added later\n+\tsub\tr4, r4, #1\n+\n+\t@ Shift yh-yl right per r5, add to xh-xl, keep leftover bits into ip.\n+\trsbs\tlr, r5, #32\n+\tblt\t1f\n \tmov\tip, yl, lsl lr\n-\tmov\tyl, yl, lsr r5\n-\torr\tyl, yl, yh, lsl lr\n-\tmov\tyh, yh, asr r5\n-\tb\t3f\n-2:\tsub\tr5, r5, #32\n+\tadds\txl, xl, yl, lsr r5\n+\tadc\txh, xh, #0\n+\tadds\txl, xl, yh, lsl lr\n+\tadcs\txh, xh, yh, asr r5\n+\tb\t2f\n+1:\tsub\tr5, r5, #32\n \tadd\tlr, lr, #32\n \tcmp\tyl, #1\n-\tadc\tip, ip, yh, lsl lr\n-\tmov\tyl, yh, asr r5\n-\tmov\tyh, yh, asr #32\n-3:\n-\t@ the actual addition\n-\tadds\txl, xl, yl\n-\tadc\txh, xh, yh\n-\n+\tmov\tip, yh, lsl lr\n+\torrcs\tip, ip, #2\t\t@ 2 not 1, to allow lsr #1 later\n+\tadds\txl, xl, yh, asr r5\n+\tadcs\txh, xh, yh, asr #31\n+2:\n \t@ We now have a result in xh-xl-ip.\n-\t@ Keep absolute value in xh-xl-ip, sign in r5.\n-\tands\tr5, xh, #0x80000000\n+\t@ Keep absolute value in xh-xl-ip, sign in r5 (the n bit was set above)\n+\tand\tr5, xh, #0x80000000\n \tbpl\tLSYM(Lad_p)\n \trsbs\tip, ip, #0\n \trscs\txl, xl, #0\n@@ -198,75 +174,66 @@ LSYM(Lad_x):\n \t@ Determine how to normalize the result.\n LSYM(Lad_p):\n \tcmp\txh, #0x00100000\n-\tbcc\tLSYM(Lad_l)\n+\tbcc\tLSYM(Lad_a)\n \tcmp\txh, #0x00200000\n-\tbcc\tLSYM(Lad_r0)\n-\tcmp\txh, #0x00400000\n-\tbcc\tLSYM(Lad_r1)\n+\tbcc\tLSYM(Lad_e)\n \n \t@ Result needs to be shifted right.\n \tmovs\txh, xh, lsr #1\n \tmovs\txl, xl, rrx\n-\tmovs\tip, ip, rrx\n-\torrcs\tip, ip, #1\n-\tadd\tr4, r4, #(1 << 20)\n-LSYM(Lad_r1):\n-\tmovs\txh, xh, lsr #1\n-\tmovs\txl, xl, rrx\n-\tmovs\tip, ip, rrx\n-\torrcs\tip, ip, #1\n-\tadd\tr4, r4, #(1 << 20)\n+\tmov\tip, ip, rrx\n+\tadd\tr4, r4, #1\n+\n+\t@ Make sure we did not bust our exponent.\n+\tmov\tr2, r4, lsl #21\n+\tcmn\tr2, #(2 << 21)\n+\tbcs\tLSYM(Lad_o)\n \n \t@ Our result is now properly aligned into xh-xl, remaining bits in ip.\n \t@ Round with MSB of ip. If halfway between two numbers, round towards\n \t@ LSB of xl = 0.\n-LSYM(Lad_r0):\n-\tadds\txl, xl, ip, lsr #31\n-\tadc\txh, xh, #0\n-\tteq\tip, #0x80000000\n-\tbiceq\txl, xl, #1\n-\n-\t@ One extreme rounding case may add a new MSB.  Adjust exponent.\n-\t@ That MSB will be cleared when exponent is merged below. \n-\ttst\txh, #0x00200000\n-\taddne\tr4, r4, #(1 << 20)\n-\n-\t@ Make sure we did not bust our exponent.\n-\tadds\tip, r4, #(1 << 20)\n-\tbmi\tLSYM(Lad_o)\n-\n \t@ Pack final result together.\n LSYM(Lad_e):\n-\tbic\txh, xh, #0x00300000\n-\torr\txh, xh, r4\n+\tcmp\tip, #0x80000000\n+\tmoveqs\tip, xl, lsr #1\n+\tadcs\txl, xl, #0\n+\tadc\txh, xh, r4, lsl #20\n \torr\txh, xh, r5\n \tRETLDM\t\"r4, r5\"\n \n-LSYM(Lad_l):\n \t@ Result must be shifted left and exponent adjusted.\n-\t@ No rounding necessary since ip will always be 0.\n+LSYM(Lad_a):\n+\tmovs\tip, ip, lsl #1\n+\tadcs\txl, xl, xl\n+\tadc\txh, xh, xh\n+\ttst\txh, #0x00100000\n+\tsub\tr4, r4, #1\n+\tbne\tLSYM(Lad_e)\n+\n+\t@ No rounding necessary since ip will always be 0 at this point.\n+LSYM(Lad_l):\n+\n #if __ARM_ARCH__ < 5\n \n \tteq\txh, #0\n-\tmovne\tr3, #-11\n-\tmoveq\tr3, #21\n+\tmovne\tr3, #20\n+\tmoveq\tr3, #52\n \tmoveq\txh, xl\n \tmoveq\txl, #0\n \tmov\tr2, xh\n-\tmovs\tip, xh, lsr #16\n-\tmoveq\tr2, r2, lsl #16\n-\taddeq\tr3, r3, #16\n-\ttst\tr2, #0xff000000\n-\tmoveq\tr2, r2, lsl #8\n-\taddeq\tr3, r3, #8\n-\ttst\tr2, #0xf0000000\n-\tmoveq\tr2, r2, lsl #4\n-\taddeq\tr3, r3, #4\n-\ttst\tr2, #0xc0000000\n-\tmoveq\tr2, r2, lsl #2\n-\taddeq\tr3, r3, #2\n-\ttst\tr2, #0x80000000\n-\taddeq\tr3, r3, #1\n+\tcmp\tr2, #(1 << 16)\n+\tmovhs\tr2, r2, lsr #16\n+\tsubhs\tr3, r3, #16\n+\tcmp\tr2, #(1 << 8)\n+\tmovhs\tr2, r2, lsr #8\n+\tsubhs\tr3, r3, #8\n+\tcmp\tr2, #(1 << 4)\n+\tmovhs\tr2, r2, lsr #4\n+\tsubhs\tr3, r3, #4\n+\tcmp\tr2, #(1 << 2)\n+\tsubhs\tr3, r3, #2\n+\tsublo\tr3, r3, r2, lsr #1\n+\tsub\tr3, r3, r2, lsr #3\n \n #else\n \n@@ -302,13 +269,15 @@ LSYM(Lad_l):\n \tmovle\txl, xl, lsl r2\n \n \t@ adjust exponent accordingly.\n-3:\tsubs\tr4, r4, r3, lsl #20\n-\tbgt\tLSYM(Lad_e)\n+3:\tsubs\tr4, r4, r3\n+\taddge\txh, xh, r4, lsl #20\n+\torrge\txh, xh, r5\n+\tRETLDM\t\"r4, r5\" ge\n \n \t@ Exponent too small, denormalize result.\n \t@ Find out proper shift value.\n-\tmvn\tr4, r4, asr #20\n-\tsubs\tr4, r4, #30\n+\tmvn\tr4, r4\n+\tsubs\tr4, r4, #31\n \tbge\t2f\n \tadds\tr4, r4, #12\n \tbgt\t1f\n@@ -337,23 +306,49 @@ LSYM(Lad_l):\n \tRETLDM\t\"r4, r5\"\n \n \t@ Adjust exponents for denormalized arguments.\n+\t@ Note that r4 must not remain equal to 0.\n LSYM(Lad_d):\n \tteq\tr4, #0\n-\teoreq\txh, xh, #0x00100000\n-\taddeq\tr4, r4, #(1 << 20)\n \teor\tyh, yh, #0x00100000\n-\tsubne\tr5, r5, #(1 << 20)\n+\teoreq\txh, xh, #0x00100000\n+\taddeq\tr4, r4, #1\n+\tsubne\tr5, r5, #1\n \tb\tLSYM(Lad_x)\n \n-\t@ Result is x - x = 0, unless x = INF or NAN.\n-LSYM(Lad_z):\n-\tsub\tip, ip, #0x00100000\t@ ip becomes 0x7ff00000\n-\tand\tr2, xh, ip\n-\tteq\tr2, ip\n-\torreq\txh, ip, #0x00080000\n+\n+LSYM(Lad_s):\n+\tmvns\tip, r4, asr #21\n+\tmvnnes\tip, r5, asr #21\n+\tbeq\tLSYM(Lad_i)\n+\n+\tteq\tr4, r5\n+\tteqeq\txl, yl\n+\tbeq\t1f\n+\n+\t@ Result is x + 0.0 = x or 0.0 + y = y.\n+\tteq\tr4, #0\n+\tmoveq\txh, yh\n+\tmoveq\txl, yl\n+\tRETLDM\t\"r4, r5\"\n+\n+1:\tteq\txh, yh\n+\n+\t@ Result is x - x = 0.\n \tmovne\txh, #0\n-\tmov\txl, #0\n-\tRET\n+\tmovne\txl, #0\n+\tRETLDM\t\"r4, r5\" ne\n+\n+\t@ Result is x + x = 2x.\n+\tmovs\tip, r4, lsr #21\n+\tbne\t2f\n+\tmovs\txl, xl, lsl #1\n+\tadcs\txh, xh, xh\n+\torrcs\txh, xh, #0x80000000\n+\tRETLDM\t\"r4, r5\"\n+2:\tadds\tr4, r4, #(2 << 21)\n+\taddcc\txh, xh, #(1 << 20)\n+\tRETLDM\t\"r4, r5\" cc\n+\tand\tr5, xh, #0x80000000\n \n \t@ Overflow: return INF.\n LSYM(Lad_o):\n@@ -367,19 +362,18 @@ LSYM(Lad_o):\n \t@   if yh-yl != INF/NAN: return xh-xl (which is INF/NAN)\n \t@   if either is NAN: return NAN\n \t@   if opposite sign: return NAN\n-\t@   return xh-xl (which is INF or -INF)\n+\t@   otherwise return xh-xl (which is INF or -INF)\n LSYM(Lad_i):\n-\tteq\tr4, ip\n+\tmvns\tip, r4, asr #21\n \tmovne\txh, yh\n \tmovne\txl, yl\n-\tteqeq\tr5, ip\n-\tRETLDM\t\"r4, r5\" ne\n-\n+\tmvneqs\tip, r5, asr #21\n+\tmovne\tyh, xh\n+\tmovne\tyl, xl\n \torrs\tr4, xl, xh, lsl #12\n-\torreqs\tr4, yl, yh, lsl #12\n+\torreqs\tr5, yl, yh, lsl #12\n \tteqeq\txh, yh\n-\torrne\txh, r5, #0x00080000\n-\tmovne\txl, #0\n+\torrne\txh, xh, #0x00080000\t@ quiet NAN\n \tRETLDM\t\"r4, r5\"\n \n \tFUNC_END aeabi_dsub\n@@ -389,14 +383,17 @@ LSYM(Lad_i):\n \n ARM_FUNC_START floatunsidf\n ARM_FUNC_ALIAS aeabi_ui2d floatunsidf\n+\n \tteq\tr0, #0\n \tmoveq\tr1, #0\n \tRETc(eq)\n \tstmfd\tsp!, {r4, r5, lr}\n-\tmov\tr4, #(0x400 << 20)\t@ initial exponent\n-\tadd\tr4, r4, #((52-1) << 20)\n+\tmov\tr4, #0x400\t\t@ initial exponent\n+\tadd\tr4, r4, #(52-1 - 1)\n \tmov\tr5, #0\t\t\t@ sign bit is 0\n+\t.ifnc\txl, r0\n \tmov\txl, r0\n+\t.endif\n \tmov\txh, #0\n \tb\tLSYM(Lad_l)\n \n@@ -405,15 +402,18 @@ ARM_FUNC_ALIAS aeabi_ui2d floatunsidf\n \n ARM_FUNC_START floatsidf\n ARM_FUNC_ALIAS aeabi_i2d floatsidf\n+\n \tteq\tr0, #0\n \tmoveq\tr1, #0\n \tRETc(eq)\n \tstmfd\tsp!, {r4, r5, lr}\n-\tmov\tr4, #(0x400 << 20)\t@ initial exponent\n-\tadd\tr4, r4, #((52-1) << 20)\n+\tmov\tr4, #0x400\t\t@ initial exponent\n+\tadd\tr4, r4, #(52-1 - 1)\n \tands\tr5, r0, #0x80000000\t@ sign bit in r5\n \trsbmi\tr0, r0, #0\t\t@ absolute value\n+\t.ifnc\txl, r0\n \tmov\txl, r0\n+\t.endif\n \tmov\txh, #0\n \tb\tLSYM(Lad_l)\n \n@@ -422,26 +422,23 @@ ARM_FUNC_ALIAS aeabi_i2d floatsidf\n \n ARM_FUNC_START extendsfdf2\n ARM_FUNC_ALIAS aeabi_f2d extendsfdf2\n-\t\n-\tmovs\tr2, r0, lsl #1\n-\tbeq\t1f\t\t\t@ value is 0.0 or -0.0\n+\n+\tmovs\tr2, r0, lsl #1\t\t@ toss sign bit\n \tmov\txh, r2, asr #3\t\t@ stretch exponent\n \tmov\txh, xh, rrx\t\t@ retrieve sign bit\n \tmov\txl, r2, lsl #28\t\t@ retrieve remaining bits\n-\tands\tr2, r2, #0xff000000\t@ isolate exponent\n-\tbeq\t2f\t\t\t@ exponent was 0 but not mantissa\n-\tteq\tr2, #0xff000000\t\t@ check if INF or NAN\n+\tandnes\tr3, r2, #0xff000000\t@ isolate exponent\n+\tteqne\tr3, #0xff000000\t\t@ if not 0, check if INF or NAN\n \teorne\txh, xh, #0x38000000\t@ fixup exponent otherwise.\n-\tRET\n+\tRETc(ne)\t\t\t@ and return it.\n \n-1:\tmov\txh, r0\n-\tmov\txl, #0\n-\tRET\n+\tteq\tr2, #0\t\t\t@ if actually 0\n+\tteqne\tr3, #0xff000000\t\t@ or INF or NAN\n+\tRETc(eq)\t\t\t@ we are done already.\n \n-2:\t@ value was denormalized.  We can normalize it now.\n+\t@ value was denormalized.  We can normalize it now.\n \tstmfd\tsp!, {r4, r5, lr}\n-\tmov\tr4, #(0x380 << 20)\t@ setup corresponding exponent\n-\tadd\tr4, r4, #(1 << 20)\n+\tmov\tr4, #0x380\t\t@ setup corresponding exponent\n \tand\tr5, xh, #0x80000000\t@ move sign bit in r5\n \tbic\txh, xh, #0x80000000\n \tb\tLSYM(Lad_l)\n@@ -451,76 +448,90 @@ ARM_FUNC_ALIAS aeabi_f2d extendsfdf2\n \n ARM_FUNC_START floatundidf\n ARM_FUNC_ALIAS aeabi_ul2d floatundidf\n-\t\n+\n \torrs\tr2, r0, r1\n #if !defined (__VFP_FP__) && !defined(__SOFTFP__)\n \tmvfeqd\tf0, #0.0\n #endif\n \tRETc(eq)\n+\n #if !defined (__VFP_FP__) && !defined(__SOFTFP__)\n \t@ For hard FPA code we want to return via the tail below so that\n \t@ we can return the result in f0 as well as in r0/r1 for backwards\n \t@ compatibility.\n-\tadr\tip, 1f\n+\tadr\tip, LSYM(f0_ret)\n \tstmfd\tsp!, {r4, r5, ip, lr}\n #else\n \tstmfd\tsp!, {r4, r5, lr}\n #endif\n+\n \tmov\tr5, #0\n \tb\t2f\n \n ARM_FUNC_START floatdidf\n ARM_FUNC_ALIAS aeabi_l2d floatdidf\n+\n \torrs\tr2, r0, r1\n #if !defined (__VFP_FP__) && !defined(__SOFTFP__)\n \tmvfeqd\tf0, #0.0\n #endif\n \tRETc(eq)\n+\n #if !defined (__VFP_FP__) && !defined(__SOFTFP__)\n \t@ For hard FPA code we want to return via the tail below so that\n \t@ we can return the result in f0 as well as in r0/r1 for backwards\n \t@ compatibility.\n-\tadr\tip, 1f\n+\tadr\tip, LSYM(f0_ret)\n \tstmfd\tsp!, {r4, r5, ip, lr}\n #else\n \tstmfd\tsp!, {r4, r5, lr}\n #endif\n+\n \tands\tr5, ah, #0x80000000\t@ sign bit in r5\n \tbpl\t2f\n \trsbs\tal, al, #0\n \trsc\tah, ah, #0\n 2:\n-\tmov\tr4, #(0x400 << 20)\t@ initial exponent\n-\tadd\tr4, r4, #((52 - 1) << 20)\n-#if !defined (__VFP_FP__) && !defined(__ARMEB__)\n+\tmov\tr4, #0x400\t\t@ initial exponent\n+\tadd\tr4, r4, #(52-1 - 1)\n+\n \t@ FPA little-endian: must swap the word order.\n+\t.ifnc\txh, ah\n \tmov\tip, al\n \tmov\txh, ah\n \tmov\txl, ip\n-#endif\n-\tmovs\tip, xh, lsr #23\n+\t.endif\n+\n+\tmovs\tip, xh, lsr #22\n \tbeq\tLSYM(Lad_p)\n-\t@ The value's too big.  Scale it down a bit...\n+\n+\t@ The value is too big.  Scale it down a bit...\n \tmov\tr2, #3\n \tmovs\tip, ip, lsr #3\n \taddne\tr2, r2, #3\n \tmovs\tip, ip, lsr #3\n \taddne\tr2, r2, #3\n+\tadd\tr2, r2, ip\n+\n \trsb\tr3, r2, #32\n \tmov\tip, xl, lsl r3\n \tmov\txl, xl, lsr r2\n \torr\txl, xl, xh, lsl r3\n \tmov\txh, xh, lsr r2\n-\tadd\tr4, r4, r2, lsl #20\n+\tadd\tr4, r4, r2\n \tb\tLSYM(Lad_p)\n+\n #if !defined (__VFP_FP__) && !defined(__SOFTFP__)\n-1:\n+\n \t@ Legacy code expects the result to be returned in f0.  Copy it\n \t@ there as well.\n+LSYM(f0_ret):\n \tstmfd\tsp!, {r0, r1}\n \tldfd\tf0, [sp], #8\n \tRETLDM\n+\n #endif\n+\n \tFUNC_END floatdidf\n \tFUNC_END aeabi_l2d\n \tFUNC_END floatundidf\n@@ -534,46 +545,38 @@ ARM_FUNC_START muldf3\n ARM_FUNC_ALIAS aeabi_dmul muldf3\n \tstmfd\tsp!, {r4, r5, r6, lr}\n \n-\t@ Mask out exponents.\n-\tmov\tip, #0x7f000000\n-\torr\tip, ip, #0x00f00000\n-\tand\tr4, xh, ip\n-\tand\tr5, yh, ip\n-\n-\t@ Trap any INF/NAN.\n-\tteq\tr4, ip\n+\t@ Mask out exponents, trap any zero/denormal/INF/NAN.\n+\tmov\tip, #0xff\n+\torr\tip, ip, #0x700\n+\tands\tr4, ip, xh, lsr #20\n+\tandnes\tr5, ip, yh, lsr #20\n+\tteqne\tr4, ip\n \tteqne\tr5, ip\n-\tbeq\tLSYM(Lml_s)\n+\tbleq\tLSYM(Lml_s)\n \n-\t@ Trap any multiplication by 0.\n-\torrs\tr6, xl, xh, lsl #1\n-\torrnes\tr6, yl, yh, lsl #1\n-\tbeq\tLSYM(Lml_z)\n-\n-\t@ Shift exponents right one bit to make room for overflow bit.\n-\t@ If either of them is 0, scale denormalized arguments off line.\n-\t@ Then add both exponents together.\n-\tmovs\tr4, r4, lsr #1\n-\tteqne\tr5, #0\n-\tbeq\tLSYM(Lml_d)\n-LSYM(Lml_x):\n-\tadd\tr4, r4, r5, asr #1\n-\n-\t@ Preserve final sign in r4 along with exponent for now.\n-\tteq\txh, yh\n-\torrmi\tr4, r4, #0x8000\n+\t@ Add exponents together\n+\tadd\tr4, r4, r5\n+\n+\t@ Determine final sign.\n+\teor\tr6, xh, yh\n \n \t@ Convert mantissa to unsigned integer.\n-\tbic\txh, xh, ip, lsl #1\n-\tbic\tyh, yh, ip, lsl #1\n+\t@ If power of two, branch to a separate path.\n+\tbic\txh, xh, ip, lsl #21\n+\tbic\tyh, yh, ip, lsl #21\n+\torrs\tr5, xl, xh, lsl #12\n+\torrnes\tr5, yl, yh, lsl #12\n \torr\txh, xh, #0x00100000\n \torr\tyh, yh, #0x00100000\n+\tbeq\tLSYM(Lml_1)\n \n #if __ARM_ARCH__ < 4\n \n+\t@ Put sign bit in r6, which will be restored in yl later.\n+\tand   r6, r6, #0x80000000\n+\n \t@ Well, no way to make it shorter without the umull instruction.\n-\t@ We must perform that 53 x 53 bit multiplication by hand.\n-\tstmfd\tsp!, {r7, r8, r9, sl, fp}\n+\tstmfd\tsp!, {r6, r7, r8, r9, sl, fp}\n \tmov\tr7, xl, lsr #16\n \tmov\tr8, yl, lsr #16\n \tmov\tr9, xh, lsr #16\n@@ -625,92 +628,83 @@ LSYM(Lml_x):\n \tmul\tfp, xh, yh\n \tadcs\tr5, r5, fp\n \tadc\tr6, r6, #0\n-\tldmfd\tsp!, {r7, r8, r9, sl, fp}\n+\tldmfd\tsp!, {yl, r7, r8, r9, sl, fp}\n \n #else\n \n-\t@ Here is the actual multiplication: 53 bits * 53 bits -> 106 bits.\n+\t@ Here is the actual multiplication.\n \tumull\tip, lr, xl, yl\n \tmov\tr5, #0\n-\tumlal\tlr, r5, xl, yh\n \tumlal\tlr, r5, xh, yl\n+\tand\tyl, r6, #0x80000000\n+\tumlal\tlr, r5, xl, yh\n \tmov\tr6, #0\n \tumlal\tr5, r6, xh, yh\n \n #endif\n \n \t@ The LSBs in ip are only significant for the final rounding.\n-\t@ Fold them into one bit of lr.\n+\t@ Fold them into lr.\n \tteq\tip, #0\n \torrne\tlr, lr, #1\n \n-\t@ Put final sign in xh.\n-\tmov\txh, r4, lsl #16\n-\tbic\tr4, r4, #0x8000\n-\n-\t@ Adjust result if one extra MSB appeared (one of four times).\n-\ttst\tr6, #(1 << 9)\n-\tbeq\t1f\n-\tadd\tr4, r4, #(1 << 19)\n-\tmovs\tr6, r6, lsr #1\n-\tmovs\tr5, r5, rrx\n-\tmovs\tlr, lr, rrx\n-\torrcs\tlr, lr, #1\n-1:\n-\t@ Scale back to 53 bits.\n-\t@ xh contains sign bit already.\n-\torr\txh, xh, r6, lsl #12\n-\torr\txh, xh, r5, lsr #20\n-\tmov\txl, r5, lsl #12\n-\torr\txl, xl, lr, lsr #20\n-\n-\t@ Apply exponent bias, check range for underflow.\n-\tsub\tr4, r4, #0x00f80000\n-\tsubs\tr4, r4, #0x1f000000\n-\tble\tLSYM(Lml_u)\n-\n-\t@ Round the result.\n-\tmovs\tlr, lr, lsl #12\n-\tbpl\t1f\n-\tadds\txl, xl, #1\n-\tadc\txh, xh, #0\n-\tteq\tlr, #0x80000000\n-\tbiceq\txl, xl, #1\n-\n-\t@ Rounding may have produced an extra MSB here.\n-\t@ The extra bit is cleared before merging the exponent below.\n-\ttst\txh, #0x00200000\n-\taddne\tr4, r4, #(1 << 19)\n+\t@ Adjust result upon the MSB position.\n+\tsub\tr4, r4, #0xff\n+\tcmp\tr6, #(1 << (20-11))\n+\tsbc\tr4, r4, #0x300\n+\tbcs\t1f\n+\tmovs\tlr, lr, lsl #1\n+\tadcs\tr5, r5, r5\n+\tadc\tr6, r6, r6\n 1:\n-\t@ Check exponent for overflow.\n-\tadds\tip, r4, #(1 << 19)\n-\ttst\tip, #(1 << 30)\n-\tbne\tLSYM(Lml_o)\n-\n-\t@ Add final exponent.\n-\tbic\txh, xh, #0x00300000\n-\torr\txh, xh, r4, lsl #1\n+\t@ Shift to final position, add sign to result.\n+\torr\txh, yl, r6, lsl #11\n+\torr\txh, xh, r5, lsr #21\n+\tmov\txl, r5, lsl #11\n+\torr\txl, xl, lr, lsr #21\n+\tmov\tlr, lr, lsl #11\n+\n+\t@ Check exponent range for under/overflow.\n+\tsubs\tip, r4, #(254 - 1)\n+\tcmphi\tip, #0x700\n+\tbhi\tLSYM(Lml_u)\n+\n+\t@ Round the result, merge final exponent.\n+\tcmp\tlr, #0x80000000\n+\tmoveqs\tlr, xl, lsr #1\n+\tadcs\txl, xl, #0\n+\tadc\txh, xh, r4, lsl #20\n \tRETLDM\t\"r4, r5, r6\"\n \n-\t@ Result is 0, but determine sign anyway.\n-LSYM(Lml_z):\n+\t@ Multiplication by 0x1p*: let''s shortcut a lot of code.\n+LSYM(Lml_1):\n+\tand\tr6, r6, #0x80000000\n+\torr\txh, r6, xh\n+\torr\txl, xl, yl\n \teor\txh, xh, yh\n-LSYM(Ldv_z):\n-\tbic\txh, xh, #0x7fffffff\n-\tmov\txl, #0\n-\tRETLDM\t\"r4, r5, r6\"\n+\tsubs\tr4, r4, ip, lsr #1\n+\trsbgts\tr5, r4, ip\n+\torrgt\txh, xh, r4, lsl #20\n+\tRETLDM\t\"r4, r5, r6\" gt\n+\n+\t@ Under/overflow: fix things up for the code below.\n+\torr\txh, xh, #0x00100000\n+\tmov\tlr, #0\n+\tsubs\tr4, r4, #1\n \n-\t@ Check if denormalized result is possible, otherwise return signed 0.\n LSYM(Lml_u):\n-\tcmn\tr4, #(53 << 19)\n+\t@ Overflow?\n+\tbgt\tLSYM(Lml_o)\n+\n+\t@ Check if denormalized result is possible, otherwise return signed 0.\n+\tcmn\tr4, #(53 + 1)\n \tmovle\txl, #0\n \tbicle\txh, xh, #0x7fffffff\n \tRETLDM\t\"r4, r5, r6\" le\n \n \t@ Find out proper shift value.\n-LSYM(Lml_r):\n-\tmvn\tr4, r4, asr #19\n-\tsubs\tr4, r4, #30\n+\trsb\tr4, r4, #0\n+\tsubs\tr4, r4, #32\n \tbge\t2f\n \tadds\tr4, r4, #12\n \tbgt\t1f\n@@ -721,14 +715,12 @@ LSYM(Lml_r):\n \tmov\tr3, xl, lsl r5\n \tmov\txl, xl, lsr r4\n \torr\txl, xl, xh, lsl r5\n-\tmovs\txh, xh, lsl #1\n-\tmov\txh, xh, lsr r4\n-\tmov\txh, xh, rrx\n+\tand\tr2, xh, #0x80000000\n+\tbic\txh, xh, #0x80000000\n \tadds\txl, xl, r3, lsr #31\n-\tadc\txh, xh, #0\n-\tteq\tlr, #0\n-\tteqeq\tr3, #0x80000000\n-\tbiceq\txl, xl, #1\n+\tadc\txh, r2, xh, lsr r4\n+\torrs\tlr, lr, r3, lsl #1\n+\tbiceq\txl, xl, r3, lsr #31\n \tRETLDM\t\"r4, r5, r6\"\n \n \t@ shift result right of 21 to 31 bits, or left 11 to 1 bits after\n@@ -741,53 +733,70 @@ LSYM(Lml_r):\n \tbic\txh, xh, #0x7fffffff\n \tadds\txl, xl, r3, lsr #31\n \tadc\txh, xh, #0\n-\tteq\tlr, #0\n-\tteqeq\tr3, #0x80000000\n-\tbiceq\txl, xl, #1\n+\torrs\tlr, lr, r3, lsl #1\n+\tbiceq\txl, xl, r3, lsr #31\n \tRETLDM\t\"r4, r5, r6\"\n \n \t@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch\n \t@ from xh to xl.  Leftover bits are in r3-r6-lr for rounding.\n 2:\trsb\tr5, r4, #32\n-\tmov\tr6, xl, lsl r5\n+\torr\tlr, lr, xl, lsl r5\n \tmov\tr3, xl, lsr r4\n \torr\tr3, r3, xh, lsl r5\n \tmov\txl, xh, lsr r4\n \tbic\txh, xh, #0x7fffffff\n \tbic\txl, xl, xh, lsr r4\n \tadd\txl, xl, r3, lsr #31\n-\torrs\tr6, r6, lr\n-\tteqeq\tr3, #0x80000000\n-\tbiceq\txl, xl, #1\n+\torrs\tlr, lr, r3, lsl #1\n+\tbiceq\txl, xl, r3, lsr #31\n \tRETLDM\t\"r4, r5, r6\"\n \n \t@ One or both arguments are denormalized.\n \t@ Scale them leftwards and preserve sign bit.\n LSYM(Lml_d):\n-\tmov\tlr, #0\n \tteq\tr4, #0\n \tbne\t2f\n \tand\tr6, xh, #0x80000000\n 1:\tmovs\txl, xl, lsl #1\n-\tadc\txh, lr, xh, lsl #1\n+\tadc\txh, xh, xh\n \ttst\txh, #0x00100000\n-\tsubeq\tr4, r4, #(1 << 19)\n+\tsubeq\tr4, r4, #1\n \tbeq\t1b\n \torr\txh, xh, r6\n \tteq\tr5, #0\n-\tbne\tLSYM(Lml_x)\n+\tmovne\tpc, lr\n 2:\tand\tr6, yh, #0x80000000\n 3:\tmovs\tyl, yl, lsl #1\n-\tadc\tyh, lr, yh, lsl #1\n+\tadc\tyh, yh, yh\n \ttst\tyh, #0x00100000\n-\tsubeq\tr5, r5, #(1 << 20)\n+\tsubeq\tr5, r5, #1\n \tbeq\t3b\n \torr\tyh, yh, r6\n-\tb\tLSYM(Lml_x)\n+\tmov\tpc, lr\n \n-\t@ One or both args are INF or NAN.\n LSYM(Lml_s):\n+\t@ Isolate the INF and NAN cases away\n+\tteq\tr4, ip\n+\tand\tr5, ip, yh, lsr #20\n+\tteqne\tr5, ip\n+\tbeq\t1f\n+\n+\t@ Here, one or more arguments are either denormalized or zero.\n+\torrs\tr6, xl, xh, lsl #1\n+\torrnes\tr6, yl, yh, lsl #1\n+\tbne\tLSYM(Lml_d)\n+\n+\t@ Result is 0, but determine sign anyway.\n+LSYM(Lml_z):\n+\teor\txh, xh, yh\n+\tbic\txh, xh, #0x7fffffff\n+\tmov\txl, #0\n+\tRETLDM\t\"r4, r5, r6\"\n+\n+1:\t@ One or both args are INF or NAN.\n \torrs\tr6, xl, xh, lsl #1\n+\tmoveq\txl, yl\n+\tmoveq\txh, yh\n \torrnes\tr6, yl, yh, lsl #1\n \tbeq\tLSYM(Lml_n)\t\t@ 0 * INF or INF * 0 -> NAN\n \tteq\tr4, ip\n@@ -797,6 +806,8 @@ LSYM(Lml_s):\n 1:\tteq\tr5, ip\n \tbne\tLSYM(Lml_i)\n \torrs\tr6, yl, yh, lsl #12\n+\tmovne\txl, yl\n+\tmovne\txh, yh\n \tbne\tLSYM(Lml_n)\t\t@ <anything> * NAN -> NAN\n \n \t@ Result is INF, but we need to determine its sign.\n@@ -811,9 +822,9 @@ LSYM(Lml_o):\n \tmov\txl, #0\n \tRETLDM\t\"r4, r5, r6\"\n \n-\t@ Return NAN.\n+\t@ Return a quiet NAN.\n LSYM(Lml_n):\n-\tmov\txh, #0x7f000000\n+\torr\txh, xh, #0x7f000000\n \torr\txh, xh, #0x00f80000\n \tRETLDM\t\"r4, r5, r6\"\n \n@@ -825,41 +836,31 @@ ARM_FUNC_ALIAS aeabi_ddiv divdf3\n \t\n \tstmfd\tsp!, {r4, r5, r6, lr}\n \n-\t@ Mask out exponents.\n-\tmov\tip, #0x7f000000\n-\torr\tip, ip, #0x00f00000\n-\tand\tr4, xh, ip\n-\tand\tr5, yh, ip\n-\n-\t@ Trap any INF/NAN or zeroes.\n-\tteq\tr4, ip\n+\t@ Mask out exponents, trap any zero/denormal/INF/NAN.\n+\tmov\tip, #0xff\n+\torr\tip, ip, #0x700\n+\tands\tr4, ip, xh, lsr #20\n+\tandnes\tr5, ip, yh, lsr #20\n+\tteqne\tr4, ip\n \tteqne\tr5, ip\n-\torrnes\tr6, xl, xh, lsl #1\n-\torrnes\tr6, yl, yh, lsl #1\n-\tbeq\tLSYM(Ldv_s)\n+\tbleq\tLSYM(Ldv_s)\n \n-\t@ Shift exponents right one bit to make room for overflow bit.\n-\t@ If either of them is 0, scale denormalized arguments off line.\n-\t@ Then substract divisor exponent from dividend''s.\n-\tmovs\tr4, r4, lsr #1\n-\tteqne\tr5, #0\n-\tbeq\tLSYM(Ldv_d)\n-LSYM(Ldv_x):\n-\tsub\tr4, r4, r5, asr #1\n+\t@ Substract divisor exponent from dividend''s.\n+\tsub\tr4, r4, r5\n \n \t@ Preserve final sign into lr.\n \teor\tlr, xh, yh\n \n \t@ Convert mantissa to unsigned integer.\n \t@ Dividend -> r5-r6, divisor -> yh-yl.\n-\tmov\tr5, #0x10000000\n+\torrs\tr5, yl, yh, lsl #12\n+\tmov\txh, xh, lsl #12\n+\tbeq\tLSYM(Ldv_1)\n \tmov\tyh, yh, lsl #12\n+\tmov\tr5, #0x10000000\n \torr\tyh, r5, yh, lsr #4\n \torr\tyh, yh, yl, lsr #24\n-\tmovs\tyl, yl, lsl #8\n-\tmov\txh, xh, lsl #12\n-\tteqeq\tyh, r5\n-\tbeq\tLSYM(Ldv_1)\n+\tmov\tyl, yl, lsl #8\n \torr\tr5, r5, xh, lsr #4\n \torr\tr5, r5, xl, lsr #24\n \tmov\tr6, xl, lsl #8\n@@ -868,21 +869,15 @@ LSYM(Ldv_x):\n \tand\txh, lr, #0x80000000\n \n \t@ Ensure result will land to known bit position.\n+\t@ Apply exponent bias accordingly.\n \tcmp\tr5, yh\n \tcmpeq\tr6, yl\n+\tadc\tr4, r4, #(255 - 2)\n+\tadd\tr4, r4, #0x300\n \tbcs\t1f\n-\tsub\tr4, r4, #(1 << 19)\n \tmovs\tyh, yh, lsr #1\n \tmov\tyl, yl, rrx\n 1:\n-\t@ Apply exponent bias, check range for over/underflow.\n-\tadd\tr4, r4, #0x1f000000\n-\tadd\tr4, r4, #0x00f80000\n-\tcmn\tr4, #(53 << 19)\n-\tble\tLSYM(Ldv_z)\n-\tcmp\tr4, ip, lsr #1\n-\tbge\tLSYM(Lml_o)\n-\n \t@ Perform first substraction to align result to a nibble.\n \tsubs\tr6, r6, yl\n \tsbc\tr5, r5, yh\n@@ -944,87 +939,66 @@ LSYM(Ldv_x):\n \torreq\txh, xh, xl\n \tmoveq\txl, #0\n 3:\n-\t@ Check if denormalized result is needed.\n-\tcmp\tr4, #0\n-\tble\tLSYM(Ldv_u)\n+\t@ Check exponent range for under/overflow.\n+\tsubs\tip, r4, #(254 - 1)\n+\tcmphi\tip, #0x700\n+\tbhi\tLSYM(Lml_u)\n \n-\t@ Apply proper rounding.\n+\t@ Round the result, merge final exponent.\n \tsubs\tip, r5, yh\n \tsubeqs\tip, r6, yl\n+\tmoveqs\tip, xl, lsr #1\n \tadcs\txl, xl, #0\n-\tadc\txh, xh, #0\n-\tteq\tip, #0\n-\tbiceq\txl, xl, #1\n-\n-\t@ Add exponent to result.\n-\tbic\txh, xh, #0x00100000\n-\torr\txh, xh, r4, lsl #1\n+\tadc\txh, xh, r4, lsl #20\n \tRETLDM\t\"r4, r5, r6\"\n \n \t@ Division by 0x1p*: shortcut a lot of code.\n LSYM(Ldv_1):\n \tand\tlr, lr, #0x80000000\n \torr\txh, lr, xh, lsr #12\n-\tadd\tr4, r4, #0x1f000000\n-\tadd\tr4, r4, #0x00f80000\n-\tcmp\tr4, ip, lsr #1\n-\tbge\tLSYM(Lml_o)\n-\tcmp\tr4, #0\n-\torrgt\txh, xh, r4, lsl #1\n+\tadds\tr4, r4, ip, lsr #1\n+\trsbgts\tr5, r4, ip\n+\torrgt\txh, xh, r4, lsl #20\n \tRETLDM\t\"r4, r5, r6\" gt\n \n-\tcmn\tr4, #(53 << 19)\n-\tble\tLSYM(Ldv_z)\n \torr\txh, xh, #0x00100000\n \tmov\tlr, #0\n-\tb\tLSYM(Lml_r)\n+\tsubs\tr4, r4, #1\n+\tb\tLSYM(Lml_u)\n \n-\t@ Result must be denormalized: put remainder in lr for\n-\t@ rounding considerations.\n+\t@ Result mightt need to be denormalized: put remainder bits\n+\t@ in lr for rounding considerations.\n LSYM(Ldv_u):\n \torr\tlr, r5, r6\n-\tb\tLSYM(Lml_r)\n-\n-\t@ One or both arguments are denormalized.\n-\t@ Scale them leftwards and preserve sign bit.\n-LSYM(Ldv_d):\n-\tmov\tlr, #0\n-\tteq\tr4, #0\n-\tbne\t2f\n-\tand\tr6, xh, #0x80000000\n-1:\tmovs\txl, xl, lsl #1\n-\tadc\txh, lr, xh, lsl #1\n-\ttst\txh, #0x00100000\n-\tsubeq\tr4, r4, #(1 << 19)\n-\tbeq\t1b\n-\torr\txh, xh, r6\n-\tteq\tr5, #0\n-\tbne\tLSYM(Ldv_x)\n-2:\tand\tr6, yh, #0x80000000\n-3:\tmovs\tyl, yl, lsl #1\n-\tadc\tyh, lr, yh, lsl #1\n-\ttst\tyh, #0x00100000\n-\tsubeq\tr5, r5, #(1 << 20)\n-\tbeq\t3b\n-\torr\tyh, yh, r6\n-\tb\tLSYM(Ldv_x)\n+\tb\tLSYM(Lml_u)\n \n \t@ One or both arguments is either INF, NAN or zero.\n LSYM(Ldv_s):\n+\tand\tr5, ip, yh, lsr #20\n \tteq\tr4, ip\n \tteqeq\tr5, ip\n \tbeq\tLSYM(Lml_n)\t\t@ INF/NAN / INF/NAN -> NAN\n \tteq\tr4, ip\n \tbne\t1f\n \torrs\tr4, xl, xh, lsl #12\n \tbne\tLSYM(Lml_n)\t\t@ NAN / <anything> -> NAN\n-\tb\tLSYM(Lml_i)\t\t@ INF / <anything> -> INF\n+\tteq\tr5, ip\n+\tbne\tLSYM(Lml_i)\t\t@ INF / <anything> -> INF\n+\tmov\txl, yl\n+\tmov\txh, yh\n+\tb\tLSYM(Lml_n)\t\t@ INF / (INF or NAN) -> NAN\n 1:\tteq\tr5, ip\n \tbne\t2f\n \torrs\tr5, yl, yh, lsl #12\n-\tbne\tLSYM(Lml_n)\t\t@ <anything> / NAN -> NAN\n-\tb\tLSYM(Lml_z)\t\t@ <anything> / INF -> 0\n-2:\t@ One or both arguments are 0.\n+\tbeq\tLSYM(Lml_z)\t\t@ <anything> / INF -> 0\n+\tmov\txl, yl\n+\tmov\txh, yh\n+\tb\tLSYM(Lml_n)\t\t@ <anything> / NAN -> NAN\n+2:\t@ If both are non-zero, we need to normalize and resume above.\n+\torrs\tr6, xl, xh, lsl #1\n+\torrnes\tr6, yl, yh, lsl #1\n+\tbne\tLSYM(Lml_d)\n+\t@ One or both arguments are 0.\n \torrs\tr4, xl, xh, lsl #1\n \tbne\tLSYM(Lml_i)\t\t@ <non_zero> / 0 -> INF\n \torrs\tr5, yl, yh, lsl #1\n@@ -1038,6 +1012,8 @@ LSYM(Ldv_s):\n \n #ifdef L_cmpdf2\n \n+@ Note: only r0 (return value) and ip are clobbered here.\n+\n ARM_FUNC_START gtdf2\n ARM_FUNC_ALIAS gedf2 gtdf2\n \tmov\tip, #-1\n@@ -1053,15 +1029,13 @@ ARM_FUNC_ALIAS nedf2 cmpdf2\n ARM_FUNC_ALIAS eqdf2 cmpdf2\n \tmov\tip, #1\t\t\t@ how should we specify unordered here?\n \n-1:\tstmfd\tsp!, {r4, r5, lr}\n+1:\tstr\tip, [sp, #-4]\n \n \t@ Trap any INF/NAN first.\n-\tmov\tlr, #0x7f000000\n-\torr\tlr, lr, #0x00f00000\n-\tand\tr4, xh, lr\n-\tand\tr5, yh, lr\n-\tteq\tr4, lr\n-\tteqne\tr5, lr\n+\tmov\tip, xh, lsl #1\n+\tmvns\tip, ip, asr #21\n+\tmov\tip, yh, lsl #1\n+\tmvnnes\tip, ip, asr #21\n \tbeq\t3f\n \n \t@ Test for equality.\n@@ -1071,37 +1045,37 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2\n \tteqne\txh, yh\t\t\t@ or xh == yh\n \tteqeq\txl, yl\t\t\t@ and xl == yl\n \tmoveq\tr0, #0\t\t\t@ then equal.\n-\tRETLDM\t\"r4, r5\" eq\n+\tRETc(eq)\n \n-\t@ Check for sign difference.\n-\tteq\txh, yh\n-\tmovmi\tr0, xh, asr #31\n-\torrmi\tr0, r0, #1\n-\tRETLDM\t\"r4, r5\" mi\n+\t@ Clear C flag\n+\tcmn\tr0, #0\n \n-\t@ Compare exponents.\n-\tcmp\tr4, r5\n+\t@ Compare sign, \n+\tteq\txh, yh\n \n-\t@ Compare mantissa if exponents are equal.\n-\tmoveq\txh, xh, lsl #12\n-\tcmpeq\txh, yh, lsl #12\n+\t@ Compare values if same sign\n+\tcmppl\txh, yh\n \tcmpeq\txl, yl\n+\n+\t@ Result:\n \tmovcs\tr0, yh, asr #31\n \tmvncc\tr0, yh, asr #31\n \torr\tr0, r0, #1\n-\tRETLDM\t\"r4, r5\"\n+\tRET\n \n \t@ Look for a NAN.\n-3:\tteq\tr4, lr\n+3:\tmov\tip, xh, lsl #1\n+\tmvns\tip, ip, asr #21\n \tbne\t4f\n-\torrs\txl, xl, xh, lsl #12\n+\torrs\tip, xl, xh, lsl #12\n \tbne\t5f\t\t\t@ x is NAN\n-4:\tteq\tr5, lr\n+4:\tmov\tip, yh, lsl #1\n+\tmvns\tip, ip, asr #21\n \tbne\t2b\n-\torrs\tyl, yl, yh, lsl #12\n+\torrs\tip, yl, yh, lsl #12\n \tbeq\t2b\t\t\t@ y is not NAN\n-5:\tmov\tr0, ip\t\t\t@ return unordered code from ip\n-\tRETLDM\t\"r4, r5\"\n+5:\tldr\tr0, [sp, #-4]\t\t@ unordered return code\n+\tRET\n \n \tFUNC_END gedf2\n \tFUNC_END gtdf2\n@@ -1112,6 +1086,7 @@ ARM_FUNC_ALIAS eqdf2 cmpdf2\n \tFUNC_END cmpdf2\n \n ARM_FUNC_START aeabi_cdrcmple\n+\n \tmov\tip, r0\n \tmov\tr0, r2\n \tmov\tr2, ip\n@@ -1122,85 +1097,95 @@ ARM_FUNC_START aeabi_cdrcmple\n \t\n ARM_FUNC_START aeabi_cdcmpeq\n ARM_FUNC_ALIAS aeabi_cdcmple aeabi_cdcmpeq\n+\n \t@ The status-returning routines are required to preserve all\n \t@ registers except ip, lr, and cpsr.\n-6:\tstmfd\tsp!, {r0, r1, r2, r3, lr}\n+6:\tstmfd\tsp!, {r0, lr}\n \tARM_CALL cmpdf2\n \t@ Set the Z flag correctly, and the C flag unconditionally.\n \tcmp\t r0, #0\n \t@ Clear the C flag if the return value was -1, indicating\n \t@ that the first operand was smaller than the second.\n \tcmnmi\t r0, #0\n-\tRETLDM   \"r0, r1, r2, r3\"\n+\tRETLDM   \"r0\"\n+\n \tFUNC_END aeabi_cdcmple\n \tFUNC_END aeabi_cdcmpeq\n+\tFUNC_END aeabi_cdrcmple\n \t\n ARM_FUNC_START\taeabi_dcmpeq\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cdcmple\n \tmoveq\tr0, #1\t@ Equal to.\n \tmovne\tr0, #0\t@ Less than, greater than, or unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_dcmpeq\n \n ARM_FUNC_START\taeabi_dcmplt\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cdcmple\n \tmovcc\tr0, #1\t@ Less than.\n \tmovcs\tr0, #0\t@ Equal to, greater than, or unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_dcmplt\n \n ARM_FUNC_START\taeabi_dcmple\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cdcmple\n \tmovls\tr0, #1  @ Less than or equal to.\n \tmovhi\tr0, #0\t@ Greater than or unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_dcmple\n \n ARM_FUNC_START\taeabi_dcmpge\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cdrcmple\n \tmovls\tr0, #1\t@ Operand 2 is less than or equal to operand 1.\n \tmovhi\tr0, #0\t@ Operand 2 greater than operand 1, or unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_dcmpge\n \n ARM_FUNC_START\taeabi_dcmpgt\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cdrcmple\n \tmovcc\tr0, #1\t@ Operand 2 is less than operand 1.\n \tmovcs\tr0, #0  @ Operand 2 is greater than or equal to operand 1,\n \t\t\t@ or they are unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_dcmpgt\n-\t\t\n+\n #endif /* L_cmpdf2 */\n \n #ifdef L_unorddf2\n \n ARM_FUNC_START unorddf2\n ARM_FUNC_ALIAS aeabi_dcmpun unorddf2\n-\t\n-\tstr\tlr, [sp, #-4]!\n-\tmov\tip, #0x7f000000\n-\torr\tip, ip, #0x00f00000\n-\tand\tlr, xh, ip\n-\tteq\tlr, ip\n+\n+\tmov\tip, xh, lsl #1\n+\tmvns\tip, ip, asr #21\n \tbne\t1f\n-\torrs\txl, xl, xh, lsl #12\n+\torrs\tip, xl, xh, lsl #12\n \tbne\t3f\t\t\t@ x is NAN\n-1:\tand\tlr, yh, ip\n-\tteq\tlr, ip\n+1:\tmov\tip, yh, lsl #1\n+\tmvns\tip, ip, asr #21\n \tbne\t2f\n-\torrs\tyl, yl, yh, lsl #12\n+\torrs\tip, yl, yh, lsl #12\n \tbne\t3f\t\t\t@ y is NAN\n 2:\tmov\tr0, #0\t\t\t@ arguments are ordered.\n-\tRETLDM\n+\tRET\n \n 3:\tmov\tr0, #1\t\t\t@ arguments are unordered.\n-\tRETLDM\n+\tRET\n \n \tFUNC_END aeabi_dcmpun\n \tFUNC_END unorddf2\n@@ -1211,40 +1196,31 @@ ARM_FUNC_ALIAS aeabi_dcmpun unorddf2\n \n ARM_FUNC_START fixdfsi\n ARM_FUNC_ALIAS aeabi_d2iz fixdfsi\n-\torrs\tip, xl, xh, lsl #1\n-\tbeq\t1f\t\t\t@ value is 0.\n-\n-\tmov\tr3, r3, rrx\t\t@ preserve C flag (the actual sign)\n \n \t@ check exponent range.\n-\tmov\tip, #0x7f000000\n-\torr\tip, ip, #0x00f00000\n-\tand\tr2, xh, ip\n-\tteq\tr2, ip\n-\tbeq\t2f\t\t\t@ value is INF or NAN\n-\tbic\tip, ip, #0x40000000\n-\tcmp\tr2, ip\n-\tbcc\t1f\t\t\t@ value is too small\n-\tadd\tip, ip, #(31 << 20)\n-\tcmp\tr2, ip\n-\tbcs\t3f\t\t\t@ value is too large\n-\n-\trsb\tr2, r2, ip\n-\tmov\tip, xh, lsl #11\n-\torr\tip, ip, #0x80000000\n-\torr\tip, ip, xl, lsr #21\n-\tmov\tr2, r2, lsr #20\n-\ttst\tr3, #0x80000000\t\t@ the sign bit\n-\tmov\tr0, ip, lsr r2\n+\tmov\tr2, xh, lsl #1\n+\tadds\tr2, r2, #(1 << 21)\n+\tbcs\t2f\t\t\t@ value is INF or NAN\n+\tbpl\t1f\t\t\t@ value is too small\n+\tmov\tr3, #(0xfffffc00 + 31)\n+\tsubs\tr2, r3, r2, asr #21\n+\tbls\t3f\t\t\t@ value is too large\n+\n+\t@ scale value\n+\tmov\tr3, xh, lsl #11\n+\torr\tr3, r3, #0x80000000\n+\torr\tr3, r3, xl, lsr #21\n+\ttst\txh, #0x80000000\t\t@ the sign bit\n+\tmov\tr0, r3, lsr r2\n \trsbne\tr0, r0, #0\n \tRET\n \n 1:\tmov\tr0, #0\n \tRET\n \n 2:\torrs\txl, xl, xh, lsl #12\n-\tbne\t4f\t\t\t@ r0 is NAN.\n-3:\tands\tr0, r3, #0x80000000\t@ the sign bit\n+\tbne\t4f\t\t\t@ x is NAN.\n+3:\tands\tr0, xh, #0x80000000\t@ the sign bit\n \tmoveq\tr0, #0x7fffffff\t\t@ maximum signed positive si\n \tRET\n \n@@ -1260,29 +1236,22 @@ ARM_FUNC_ALIAS aeabi_d2iz fixdfsi\n \n ARM_FUNC_START fixunsdfsi\n ARM_FUNC_ALIAS aeabi_d2uiz fixunsdfsi\n-\torrs\tip, xl, xh, lsl #1\n-\tmovcss\tr0, #0\t\t\t@ value is negative\n-\tRETc(eq)\t\t\t@ or 0 (xl, xh overlap r0)\n \n \t@ check exponent range.\n-\tmov\tip, #0x7f000000\n-\torr\tip, ip, #0x00f00000\n-\tand\tr2, xh, ip\n-\tteq\tr2, ip\n-\tbeq\t2f\t\t\t@ value is INF or NAN\n-\tbic\tip, ip, #0x40000000\n-\tcmp\tr2, ip\n-\tbcc\t1f\t\t\t@ value is too small\n-\tadd\tip, ip, #(31 << 20)\n-\tcmp\tr2, ip\n-\tbhi\t3f\t\t\t@ value is too large\n-\n-\trsb\tr2, r2, ip\n-\tmov\tip, xh, lsl #11\n-\torr\tip, ip, #0x80000000\n-\torr\tip, ip, xl, lsr #21\n-\tmov\tr2, r2, lsr #20\n-\tmov\tr0, ip, lsr r2\n+\tmovs\tr2, xh, lsl #1\n+\tbcs\t1f\t\t\t@ value is negative\n+\tadds\tr2, r2, #(1 << 21)\n+\tbcs\t2f\t\t\t@ value is INF or NAN\n+\tbpl\t1f\t\t\t@ value is too small\n+\tmov\tr3, #(0xfffffc00 + 31)\n+\tsubs\tr2, r3, r2, asr #21\n+\tbmi\t3f\t\t\t@ value is too large\n+\n+\t@ scale value\n+\tmov\tr3, xh, lsl #11\n+\torr\tr3, r3, #0x80000000\n+\torr\tr3, r3, xl, lsr #21\n+\tmov\tr0, r3, lsr r2\n \tRET\n \n 1:\tmov\tr0, #0\n@@ -1305,90 +1274,60 @@ ARM_FUNC_ALIAS aeabi_d2uiz fixunsdfsi\n \n ARM_FUNC_START truncdfsf2\n ARM_FUNC_ALIAS aeabi_d2f truncdfsf2\n-\torrs\tr2, xl, xh, lsl #1\n-\tmoveq\tr0, r2, rrx\n-\tRETc(eq)\t\t\t@ value is 0.0 or -0.0\n-\t\n+\n \t@ check exponent range.\n-\tmov\tip, #0x7f000000\n-\torr\tip, ip, #0x00f00000\n-\tand\tr2, ip, xh\n-\tteq\tr2, ip\n-\tbeq\t2f\t\t\t@ value is INF or NAN\n-\tbic\txh, xh, ip\n-\tcmp\tr2, #(0x380 << 20)\n-\tbls\t4f\t\t\t@ value is too small\n-\n-\t@ shift and round mantissa\n-1:\tmovs\tr3, xl, lsr #29\n-\tadc\tr3, r3, xh, lsl #3\n-\n-\t@ if halfway between two numbers, round towards LSB = 0.\n-\tmov\txl, xl, lsl #3\n-\tteq\txl, #0x80000000\n-\tbiceq\tr3, r3, #1\n-\n-\t@ rounding might have created an extra MSB.  If so adjust exponent.\n-\ttst\tr3, #0x00800000\n-\taddne\tr2, r2, #(1 << 20)\n-\tbicne\tr3, r3, #0x00800000\n-\n-\t@ check exponent for overflow\n-\tmov\tip, #(0x400 << 20)\n-\torr\tip, ip, #(0x07f << 20)\n-\tcmp\tr2, ip\n-\tbcs\t3f\t\t\t@ overflow\n-\n-\t@ adjust exponent, merge with sign bit and mantissa.\n-\tmovs\txh, xh, lsl #1\n-\tmov\tr2, r2, lsl #4\n-\torr\tr0, r3, r2, rrx\n-\teor\tr0, r0, #0x40000000\n+\tmov\tr2, xh, lsl #1\n+\tsubs\tr3, r2, #((1023 - 127) << 21)\n+\tsubcss\tip, r3, #(1 << 21)\n+\trsbcss\tip, ip, #(254 << 21)\n+\tbls\t2f\t\t\t@ value is out of range\n+\n+1:\t@ shift and round mantissa\n+\tand\tip, xh, #0x80000000\n+\tmov\tr2, xl, lsl #3\n+\torr\txl, ip, xl, lsr #29\n+\tcmp\tr2, #0x80000000\n+\tadc\tr0, xl, r3, lsl #2\n+\tbiceq\tr0, r0, #1\n \tRET\n \n-2:\t@ chech for NAN\n-\torrs\txl, xl, xh, lsl #12\n-\tmovne\tr0, #0x7f000000\n-\torrne\tr0, r0, #0x00c00000\n-\tRETc(ne)\t\t\t@ return NAN\n+2:\t@ either overflow or underflow\n+\ttst\txh, #0x40000000\n+\tbne\t3f\t\t\t@ overflow\n \n-3:\t@ return INF with sign\n-\tand\tr0, xh, #0x80000000\n-\torr\tr0, r0, #0x7f000000\n-\torr\tr0, r0, #0x00800000\n-\tRET\n+\t@ check if denormalized value is possible\n+\tadds\tr2, r3, #(23 << 21)\n+\tandlt\tr0, xh, #0x80000000\t@ too small, return signed 0.\n+\tRETc(lt)\n \n-4:\t@ check if denormalized value is possible\n-\tsubs\tr2, r2, #((0x380 - 24) << 20)\n-\tandle\tr0, xh, #0x80000000\t@ too small, return signed 0.\n-\tRETc(le)\n-\t\n \t@ denormalize value so we can resume with the code above afterwards.\n \torr\txh, xh, #0x00100000\n-\tmov\tr2, r2, lsr #20\n-\trsb\tr2, r2, #25\n-\tcmp\tr2, #20\n-\tbgt\t6f\n-\n+\tmov\tr2, r2, lsr #21\n+\trsb\tr2, r2, #24\n \trsb\tip, r2, #32\n-\tmov\tr3, xl, lsl ip\n+\tmovs\tr3, xl, lsl ip\n \tmov\txl, xl, lsr r2\n-\torr\txl, xl, xh, lsl ip\n-\tmovs\txh, xh, lsl #1\n-\tmov\txh, xh, lsr r2\n-\tmov\txh, xh, rrx\n-5:\tteq\tr3, #0\t\t\t@ fold r3 bits into the LSB\n-\torrne\txl, xl, #1\t\t@ for rounding considerations. \n-\tmov\tr2, #(0x380 << 20)\t@ equivalent to the 0 float exponent\n+\torrne\txl, xl, #1\t\t@ fold r3 for rounding considerations. \n+\tmov\tr3, xh, lsl #11\n+\tmov\tr3, r3, lsr #11\n+\torr\txl, xl, r3, lsl ip\n+\tmov\tr3, r3, lsr r2\n+\tmov\tr3, r3, lsl #1\n \tb\t1b\n \n-6:\trsb\tr2, r2, #(12 + 20)\n-\trsb\tip, r2, #32\n-\tmov\tr3, xl, lsl r2\n-\tmov\txl, xl, lsr ip\n-\torr\txl, xl, xh, lsl r2\n-\tand\txh, xh, #0x80000000\n-\tb\t5b\n+3:\t@ chech for NAN\n+\tmvns\tr3, r2, asr #21\n+\tbne\t5f\t\t\t@ simple overflow\n+\torrs\tr3, xl, xh, lsl #12\n+\tmovne\tr0, #0x7f000000\n+\torrne\tr0, r0, #0x00c00000\n+\tRETc(ne)\t\t\t@ return NAN\n+\n+5:\t@ return INF with sign\n+\tand\tr0, xh, #0x80000000\n+\torr\tr0, r0, #0x7f000000\n+\torr\tr0, r0, #0x00800000\n+\tRET\n \n \tFUNC_END aeabi_d2f\n \tFUNC_END truncdfsf2"}, {"sha": "8eae6e9325d225e0e0c6d245ca306686267eb024", "filename": "gcc/config/arm/ieee754-sf.S", "status": "modified", "additions": 402, "deletions": 478, "changes": 880, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6883a6662fc7728a539230ea1b02efd47815d705/gcc%2Fconfig%2Farm%2Fieee754-sf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6883a6662fc7728a539230ea1b02efd47815d705/gcc%2Fconfig%2Farm%2Fieee754-sf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fieee754-sf.S?ref=6883a6662fc7728a539230ea1b02efd47815d705", "patch": "@@ -42,7 +42,7 @@\n \t\n ARM_FUNC_START negsf2\n ARM_FUNC_ALIAS aeabi_fneg negsf2\n-\t\n+\n \teor\tr0, r0, #0x80000000\t@ flip sign bit\n \tRET\n \n@@ -56,44 +56,31 @@ ARM_FUNC_ALIAS aeabi_fneg negsf2\n ARM_FUNC_START aeabi_frsub\n \n \teor\tr0, r0, #0x80000000\t@ flip sign bit of first arg\n-\tb\t1f\t\n-\t\n+\tb\t1f\n+\n ARM_FUNC_START subsf3\n ARM_FUNC_ALIAS aeabi_fsub subsf3\n-\t\n+\n \teor\tr1, r1, #0x80000000\t@ flip sign bit of second arg\n #if defined(__thumb__) && !defined(__THUMB_INTERWORK__)\n \tb\t1f\t\t\t@ Skip Thumb-code prologue\n #endif\n \n ARM_FUNC_START addsf3\n ARM_FUNC_ALIAS aeabi_fadd addsf3\n-\t\n-1:\t@ Compare both args, return zero if equal but the sign.\n-\teor\tr2, r0, r1\n-\tteq\tr2, #0x80000000\n-\tbeq\tLSYM(Lad_z)\n \n-\t@ If first arg is 0 or -0, return second arg.\n-\t@ If second arg is 0 or -0, return first arg.\n-\tbics\tr2, r0, #0x80000000\n-\tmoveq\tr0, r1\n-\tbicnes\tr2, r1, #0x80000000\n-\tRETc(eq)\n-\n-\t@ Mask out exponents.\n-\tmov\tip, #0xff000000\n-\tand\tr2, r0, ip, lsr #1\n-\tand\tr3, r1, ip, lsr #1\n-\n-\t@ If either of them is 255, result will be INF or NAN\n-\tteq\tr2, ip, lsr #1\n-\tteqne\tr3, ip, lsr #1\n-\tbeq\tLSYM(Lad_i)\n+1:\t@ Look for zeroes, equal values, INF, or NAN.\n+\tmovs\tr2, r0, lsl #1\n+\tmovnes\tr3, r1, lsl #1\n+\tteqne\tr2, r3\n+\tmvnnes\tip, r2, asr #24\n+\tmvnnes\tip, r3, asr #24\n+\tbeq\tLSYM(Lad_s)\n \n \t@ Compute exponent difference.  Make largest exponent in r2,\n \t@ corresponding arg in r0, and positive exponent difference in r3.\n-\tsubs\tr3, r3, r2\n+\tmov\tr2, r2, lsr #24\n+\trsbs\tr3, r2, r3, lsr #24\n \taddgt\tr2, r2, r3\n \teorgt\tr1, r0, r1\n \teorgt\tr0, r1, r0\n@@ -103,7 +90,7 @@ ARM_FUNC_ALIAS aeabi_fadd addsf3\n \t@ If exponent difference is too large, return largest argument\n \t@ already in r0.  We need up to 25 bit to handle proper rounding\n \t@ of 0x1p25 - 1.1.\n-\tcmp\tr3, #(25 << 23)\n+\tcmp\tr3, #25\n \tRETc(hi)\n \n \t@ Convert mantissa to signed integer.\n@@ -122,129 +109,135 @@ ARM_FUNC_ALIAS aeabi_fadd addsf3\n \tbeq\tLSYM(Lad_d)\n LSYM(Lad_x):\n \n-\t@ Scale down second arg with exponent difference.\n-\t@ Apply shift one bit left to first arg and the rest to second arg\n-\t@ to simplify things later, but only if exponent does not become 0.\n-\tmovs\tr3, r3, lsr #23\n-\tteqne\tr2, #(1 << 23)\n-\tmovne\tr0, r0, lsl #1\n-\tsubne\tr2, r2, #(1 << 23)\n-\tsubne\tr3, r3, #1\n+\t@ Compensate for the exponent overlapping the mantissa MSB added later\n+\tsub\tr2, r2, #1\n \n-\t@ Shift second arg into ip, keep leftover bits into r1.\n-\tmov\tip, r1, asr r3\n+\t@ Shift and add second arg to first arg in r0.\n+\t@ Keep leftover bits into r1.\n+\tadds\tr0, r0, r1, asr r3\n \trsb\tr3, r3, #32\n \tmov\tr1, r1, lsl r3\n \n-\tadd\tr0, r0, ip\t\t@ the actual addition\n-\n-\t@ We now have a 64 bit result in r0-r1.\n-\t@ Keep absolute value in r0-r1, sign in r3.\n-\tands\tr3, r0, #0x80000000\n+\t@ Keep absolute value in r0-r1, sign in r3 (the n bit was set above)\n+\tand\tr3, r0, #0x80000000\n \tbpl\tLSYM(Lad_p)\n \trsbs\tr1, r1, #0\n \trsc\tr0, r0, #0\n \n \t@ Determine how to normalize the result.\n LSYM(Lad_p):\n \tcmp\tr0, #0x00800000\n-\tbcc\tLSYM(Lad_l)\n+\tbcc\tLSYM(Lad_a)\n \tcmp\tr0, #0x01000000\n-\tbcc\tLSYM(Lad_r0)\n-\tcmp\tr0, #0x02000000\n-\tbcc\tLSYM(Lad_r1)\n+\tbcc\tLSYM(Lad_e)\n \n \t@ Result needs to be shifted right.\n \tmovs\tr0, r0, lsr #1\n \tmov\tr1, r1, rrx\n-\tadd\tr2, r2, #(1 << 23)\n-LSYM(Lad_r1):\n-\tmovs\tr0, r0, lsr #1\n-\tmov\tr1, r1, rrx\n-\tadd\tr2, r2, #(1 << 23)\n-\n-\t@ Our result is now properly aligned into r0, remaining bits in r1.\n-\t@ Round with MSB of r1. If halfway between two numbers, round towards\n-\t@ LSB of r0 = 0. \n-LSYM(Lad_r0):\n-\tadd\tr0, r0, r1, lsr #31\n-\tteq\tr1, #0x80000000\n-\tbiceq\tr0, r0, #1\n-\n-\t@ Rounding may have added a new MSB.  Adjust exponent.\n-\t@ That MSB will be cleared when exponent is merged below.\n-\ttst\tr0, #0x01000000\n-\taddne\tr2, r2, #(1 << 23)\n+\tadd\tr2, r2, #1\n \n \t@ Make sure we did not bust our exponent.\n-\tcmp\tr2, #(254 << 23)\n-\tbhi\tLSYM(Lad_o)\n+\tcmp\tr2, #254\n+\tbhs\tLSYM(Lad_o)\n \n+\t@ Our result is now properly aligned into r0, remaining bits in r1.\n \t@ Pack final result together.\n+\t@ Round with MSB of r1. If halfway between two numbers, round towards\n+\t@ LSB of r0 = 0. \n LSYM(Lad_e):\n-\tbic\tr0, r0, #0x01800000\n-\torr\tr0, r0, r2\n+\tcmp\tr1, #0x80000000\n+\tadc\tr0, r0, r2, lsl #23\n+\tbiceq\tr0, r0, #1\n \torr\tr0, r0, r3\n \tRET\n \n-\t@ Result must be shifted left.\n-\t@ No rounding necessary since r1 will always be 0.\n+\t@ Result must be shifted left and exponent adjusted.\n+LSYM(Lad_a):\n+\tmovs\tr1, r1, lsl #1\n+\tadc\tr0, r0, r0\n+\ttst\tr0, #0x00800000\n+\tsub\tr2, r2, #1\n+\tbne\tLSYM(Lad_e)\n+\t\n+\t@ No rounding necessary since r1 will always be 0 at this point.\n LSYM(Lad_l):\n \n #if __ARM_ARCH__ < 5\n \n \tmovs\tip, r0, lsr #12\n \tmoveq\tr0, r0, lsl #12\n-\tsubeq\tr2, r2, #(12 << 23)\n+\tsubeq\tr2, r2, #12\n \ttst\tr0, #0x00ff0000\n \tmoveq\tr0, r0, lsl #8\n-\tsubeq\tr2, r2, #(8 << 23)\n+\tsubeq\tr2, r2, #8\n \ttst\tr0, #0x00f00000\n \tmoveq\tr0, r0, lsl #4\n-\tsubeq\tr2, r2, #(4 << 23)\n+\tsubeq\tr2, r2, #4\n \ttst\tr0, #0x00c00000\n \tmoveq\tr0, r0, lsl #2\n-\tsubeq\tr2, r2, #(2 << 23)\n-\ttst\tr0, #0x00800000\n-\tmoveq\tr0, r0, lsl #1\n-\tsubeq\tr2, r2, #(1 << 23)\n-\tcmp\tr2, #0\n-\tbgt\tLSYM(Lad_e)\n+\tsubeq\tr2, r2, #2\n+\tcmp\tr0, #0x00800000\n+\tmovcc\tr0, r0, lsl #1\n+\tsbcs\tr2, r2, #0\n \n #else\n \n \tclz\tip, r0\n \tsub\tip, ip, #8\n+\tsubs\tr2, r2, ip\n \tmov\tr0, r0, lsl ip\n-\tsubs\tr2, r2, ip, lsl #23\n-\tbgt\tLSYM(Lad_e)\n \n #endif\n \n-\t@ Exponent too small, denormalize result.\n-\tmvn\tr2, r2, asr #23\n-\tadd\tr2, r2, #2\n-\torr\tr0, r3, r0, lsr r2\n+\t@ Final result with sign\n+\t@ If exponent negative, denormalize result.\n+\taddge\tr0, r0, r2, lsl #23\n+\trsblt\tr2, r2, #0\n+\torrge\tr0, r0, r3\n+\torrlt\tr0, r3, r0, lsr r2\n \tRET\n \n \t@ Fixup and adjust bit position for denormalized arguments.\n \t@ Note that r2 must not remain equal to 0.\n LSYM(Lad_d):\n \tteq\tr2, #0\n-\teoreq\tr0, r0, #0x00800000\n-\taddeq\tr2, r2, #(1 << 23)\n \teor\tr1, r1, #0x00800000\n-\tsubne\tr3, r3, #(1 << 23)\n+\teoreq\tr0, r0, #0x00800000\n+\taddeq\tr2, r2, #1\n+\tsubne\tr3, r3, #1\n \tb\tLSYM(Lad_x)\n \n-\t@ Result is x - x = 0, unless x is INF or NAN.\n-LSYM(Lad_z):\n-\tmov\tip, #0xff000000\n-\tand\tr2, r0, ip, lsr #1\n-\tteq\tr2, ip, lsr #1\n-\tmoveq\tr0, ip, asr #2\n+LSYM(Lad_s):\n+\tmov\tr3, r1, lsl #1\n+\n+\tmvns\tip, r2, asr #24\n+\tmvnnes\tip, r3, asr #24\n+\tbeq\tLSYM(Lad_i)\n+\n+\tteq\tr2, r3\n+\tbeq\t1f\n+\n+\t@ Result is x + 0.0 = x or 0.0 + y = y.\n+\tteq\tr2, #0\n+\tmoveq\tr0, r1\n+\tRET\n+\n+1:\tteq\tr0, r1\n+\n+\t@ Result is x - x = 0.\n \tmovne\tr0, #0\n+\tRETc(ne)\n+\n+\t@ Result is x + x = 2x.\n+\ttst\tr2, #0xff000000\n+\tbne\t2f\n+\tmovs\tr0, r0, lsl #1\n+\torrcs\tr0, r0, #0x80000000\n \tRET\n+2:\tadds\tr2, r2, #(2 << 24)\n+\taddcc\tr0, r0, #(1 << 23)\n+\tRETc(cc)\n+\tand\tr3, r0, #0x80000000\n \n \t@ Overflow: return INF.\n LSYM(Lad_o):\n@@ -257,16 +250,16 @@ LSYM(Lad_o):\n \t@   if r1 != INF/NAN: return r0 (which is INF/NAN)\n \t@   if r0 or r1 is NAN: return NAN\n \t@   if opposite sign: return NAN\n-\t@   return r0 (which is INF or -INF)\n+\t@   otherwise return r0 (which is INF or -INF)\n LSYM(Lad_i):\n-\tteq\tr2, ip, lsr #1\n+\tmvns\tr2, r2, asr #24\n \tmovne\tr0, r1\n-\tteqeq\tr3, ip, lsr #1\n-\tRETc(ne)\n+\tmvneqs\tr3, r3, asr #24\n+\tmovne\tr1, r0\n \tmovs\tr2, r0, lsl #9\n-\tmoveqs\tr2, r1, lsl #9\n+\tmoveqs\tr3, r1, lsl #9\n \tteqeq\tr0, r1\n-\torrne\tr0, r3, #0x00400000\t@ NAN\n+\torrne\tr0, r0, #0x00400000\t@ quiet NAN\n \tRET\n \n \tFUNC_END aeabi_frsub\n@@ -287,28 +280,17 @@ ARM_FUNC_ALIAS aeabi_i2f floatsisf\n \tands\tr3, r0, #0x80000000\n \trsbmi\tr0, r0, #0\n \n-1:\tteq\tr0, #0\n+1:\tmovs\tip, r0\n \tRETc(eq)\n \n-3:\n-\tmov\tr1, #0\n-\tmov\tr2, #((127 + 23) << 23)\n-\ttst\tr0, #0xfc000000\n-\tbeq\tLSYM(Lad_p)\n-\n-\t@ We need to scale the value a little before branching to code above.\n-\ttst\tr0, #0xf0000000\n-4:\n-\torrne\tr1, r1, r0, lsl #28\n-\tmovne\tr0, r0, lsr #4\n-\taddne\tr2, r2, #(4 << 23)\n-\ttst\tr0, #0x0c000000\n-\tbeq\tLSYM(Lad_p)\n-\tmov\tr1, r1, lsr #2\n-\torr\tr1, r1, r0, lsl #30\n-\tmov\tr0, r0, lsr #2\n-\tadd\tr2, r2, #(2 << 23)\n-\tb\tLSYM(Lad_p)\n+\t@ Add initial exponent to sign\n+\torr\tr3, r3, #((127 + 23) << 23)\n+\n+\t.ifnc\tah, r0\n+\tmov\tah, r0\n+\t.endif\n+\tmov\tal, #0\n+\tb\t2f\n \n \tFUNC_END aeabi_i2f\n \tFUNC_END floatsisf\n@@ -317,22 +299,15 @@ ARM_FUNC_ALIAS aeabi_i2f floatsisf\n \n ARM_FUNC_START floatundisf\n ARM_FUNC_ALIAS aeabi_ul2f floatundisf\n+\n \torrs\tr2, r0, r1\n #if !defined (__VFP_FP__) && !defined(__SOFTFP__)\n \tmvfeqs\tf0, #0.0\n #endif\n \tRETc(eq)\n-\t\n-#if !defined (__VFP_FP__) && !defined(__SOFTFP__)\n-\t@ For hard FPA code we want to return via the tail below so that\n-\t@ we can return the result in f0 as well as in r0 for backwards\n-\t@ compatibility.\n-\tstr\tlr, [sp, #-4]!\n-\tadr\tlr, 4f\n-#endif\n \n \tmov\tr3, #0\n-\tb\t2f\n+\tb\t1f\n \n ARM_FUNC_START floatdisf\n ARM_FUNC_ALIAS aeabi_l2f floatdisf\n@@ -342,78 +317,80 @@ ARM_FUNC_ALIAS aeabi_l2f floatdisf\n \tmvfeqs\tf0, #0.0\n #endif\n \tRETc(eq)\n-\t\n+\n+\tands\tr3, ah, #0x80000000\t@ sign bit in r3\n+\tbpl\t1f\n+\trsbs\tal, al, #0\n+\trsc\tah, ah, #0\n+1:\n #if !defined (__VFP_FP__) && !defined(__SOFTFP__)\n \t@ For hard FPA code we want to return via the tail below so that\n \t@ we can return the result in f0 as well as in r0 for backwards\n \t@ compatibility.\n \tstr\tlr, [sp, #-4]!\n-\tadr\tlr, 4f\n+\tadr\tlr, LSYM(f0_ret)\n #endif\n-\tands\tr3, ah, #0x80000000\t@ sign bit in r3\n-\tbpl\t2f\n-\trsbs\tal, al, #0\n-\trsc\tah, ah, #0\n-2:\n+\n \tmovs\tip, ah\n-#ifdef __ARMEB__\n-\tmoveq\tr0, al\n-#endif\n-\tbeq\t3b\n-\tmov\tr2, #((127 + 23 + 32) << 23)\t@ initial exponent\n-#ifndef __ARMEB__\n-\tmov\tr1, al\n-\tmov\tr0, ip\n-#endif\n-\ttst\tr0, #0xfc000000\n-\tbne\t3f\n+\tmoveq\tip, al\n+\n+\t@ Add initial exponent to sign\n+\torr\tr3, r3, #((127 + 23 + 32) << 23)\n+\tsubeq\tr3, r3, #(32 << 23)\n+2:\tsub\tr3, r3, #(1 << 23)\n \n #if __ARM_ARCH__ < 5\n-\tcmp\tr0, #(1 << 13)\n-\tmovlo\tip, #13\n-\tmovlo\tr0, r0, lsl #13\n-\tmovhs\tip, #0\n-\ttst\tr0, #0x03fc0000\n-\taddeq\tip, ip, #8\n-\tmoveq\tr0, r0, lsl #8\n-\ttst\tr0, #0x03c00000\n-\taddeq\tip, ip, #4\n-\tmoveq\tr0, r0, lsl #4\n-\ttst\tr0, #0x03000000\n-\taddeq\tip, ip, #2\n-\tmoveq\tr0, r0, lsl #2\n+\n+\tmov\tr2, #23\n+\tcmp\tip, #(1 << 16)\n+\tmovhs\tip, ip, lsr #16\n+\tsubhs\tr2, r2, #16\n+\tcmp\tip, #(1 << 8)\n+\tmovhs\tip, ip, lsr #8\n+\tsubhs\tr2, r2, #8\n+\tcmp\tip, #(1 << 4)\n+\tmovhs\tip, ip, lsr #4\n+\tsubhs\tr2, r2, #4\n+\tcmp\tip, #(1 << 2)\n+\tsubhs\tr2, r2, #2\n+\tsublo\tr2, r2, ip, lsr #1\n+\tsubs\tr2, r2, ip, lsr #3\n+\n #else\n-\tclz\tip, r0\n-\tsub\tip, ip, #6\n-\tmov\tr0, r0, lsl ip\n+\n+\tclz\tr2, ip\n+\tsubs\tr2, r2, #8\n+\n #endif\n-\tsub\tr2, r2, ip, lsl #23\n-\trsb\tip, ip, #32\n-\torr\tr0, r0, r1, lsr ip\n-\trsb\tip, ip, #32\n-\tmov\tr1, r1, asl ip\n-\t@ At this point we no-longer care about the precise value in r1, only\n-\t@ whether only the top bit is set, or if the top bit and some others\n-\t@ are set.\n-\tand\tip, r1, #0xff\n-\torr\tr1, r1, ip, lsl #8\n-\tb\tLSYM(Lad_p)\n-3:\n-\t@ We need to scale the value a little before branching to code above.\n-\t@ At this point we no-longer care about the precise value in r1, only\n-\t@ whether only the top bit is set, or if the top bit and some others\n-\t@ are set.\n-\tand\tip, r1, #0xff\n-\torr\tr1, r1, ip, lsl #8\n-\ttst\tr0, #0xf0000000\n-\tmovne\tr1, r1, lsr #4\n-\tb\t4b\n+\n+\tsub\tr3, r3, r2, lsl #23\n+\tblt\t3f\n+\n+\tadd\tr3, r3, ah, lsl r2\n+\tmov\tip, al, lsl r2\n+\trsb\tr2, r2, #32\n+\tcmp\tip, #0x80000000\n+\tadc\tr0, r3, al, lsr r2\n+\tbiceq\tr0, r0, #1\n+\tRET\n+\n+3:\tadd\tr2, r2, #32\n+\tmov\tip, ah, lsl r2\n+\trsb\tr2, r2, #32\n+\torrs\tal, al, ip, lsl #1\n+\tadc\tr0, r3, ah, lsr r2\n+\tbiceq\tr0, r0, ip, lsr #31\n+\tRET\n+\n #if !defined (__VFP_FP__) && !defined(__SOFTFP__)\n-4:\n+\n+LSYM(f0_ret)\n \tstr\tr0, [sp, #-4]!\n \tldfs\tf0, [sp], #4\n \tRETLDM\n+\n #endif\n+\n \tFUNC_END floatdisf\n \tFUNC_END aeabi_l2f\n \tFUNC_END floatundisf\n@@ -425,139 +402,117 @@ ARM_FUNC_ALIAS aeabi_l2f floatdisf\n \n ARM_FUNC_START mulsf3\n ARM_FUNC_ALIAS aeabi_fmul mulsf3\n-\t\n-\t@ Mask out exponents.\n-\tmov\tip, #0xff000000\n-\tand\tr2, r0, ip, lsr #1\n-\tand\tr3, r1, ip, lsr #1\n-\n-\t@ Trap any INF/NAN.\n-\tteq\tr2, ip, lsr #1\n-\tteqne\tr3, ip, lsr #1\n-\tbeq\tLSYM(Lml_s)\n \n-\t@ Trap any multiplication by 0.\n-\tbics\tip, r0, #0x80000000\n-\tbicnes\tip, r1, #0x80000000\n-\tbeq\tLSYM(Lml_z)\n-\n-\t@ Shift exponents right one bit to make room for overflow bit.\n-\t@ If either of them is 0, scale denormalized arguments off line.\n-\t@ Then add both exponents together.\n-\tmovs\tr2, r2, lsr #1\n-\tteqne\tr3, #0\n-\tbeq\tLSYM(Lml_d)\n+\t@ Mask out exponents, trap any zero/denormal/INF/NAN.\n+\tmov\tip, #0xff\n+\tands\tr2, ip, r0, lsr #23\n+\tandnes\tr3, ip, r1, lsr #23\n+\tteqne\tr2, ip\n+\tteqne\tr3, ip\n+\tbeq\tLSYM(Lml_s)\n LSYM(Lml_x):\n-\tadd\tr2, r2, r3, asr #1\n \n-\t@ Preserve final sign in r2 along with exponent for now.\n-\tteq\tr0, r1\n-\torrmi\tr2, r2, #0x8000\n+\t@ Add exponents together\n+\tadd\tr2, r2, r3\n+\n+\t@ Determine final sign.\n+\teor\tip, r0, r1\n \n \t@ Convert mantissa to unsigned integer.\n-\tbic\tr0, r0, #0xff000000\n-\tbic\tr1, r1, #0xff000000\n-\torr\tr0, r0, #0x00800000\n-\torr\tr1, r1, #0x00800000\n+\t@ If power of two, branch to a separate path.\n+\t@ Make up for final alignment.\n+\tmovs\tr0, r0, lsl #9\n+\tmovnes\tr1, r1, lsl #9\n+\tbeq\tLSYM(Lml_1)\n+\tmov\tr3, #0x08000000\n+\torr\tr0, r3, r0, lsr #5\n+\torr\tr1, r3, r1, lsr #5\n \n #if __ARM_ARCH__ < 4\n \n+\t@ Put sign bit in r3, which will be restored into r0 later.\n+\tand\tr3, ip, #0x80000000\n+\n \t@ Well, no way to make it shorter without the umull instruction.\n-\t@ We must perform that 24 x 24 -> 48 bit multiplication by hand.\n-\tstmfd\tsp!, {r4, r5}\n+\tstmfd\tsp!, {r3, r4, r5}\n \tmov\tr4, r0, lsr #16\n \tmov\tr5, r1, lsr #16\n-\tbic\tr0, r0, #0x00ff0000\n-\tbic\tr1, r1, #0x00ff0000\n+\tbic\tr0, r0, r4, lsl #16\n+\tbic\tr1, r1, r5, lsl #16\n \tmul\tip, r4, r5\n \tmul\tr3, r0, r1\n \tmul\tr0, r5, r0\n \tmla\tr0, r4, r1, r0\n \tadds\tr3, r3, r0, lsl #16\n-\tadc\tip, ip, r0, lsr #16\n-\tldmfd\tsp!, {r4, r5}\n+\tadc\tr1, ip, r0, lsr #16\n+\tldmfd\tsp!, {r0, r4, r5}\n \n #else\n \n-\tumull\tr3, ip, r0, r1\t\t@ The actual multiplication.\n+\t@ The actual multiplication.\n+\tumull\tr3, r1, r0, r1\n+\n+\t@ Put final sign in r0.\n+\tand\tr0, ip, #0x80000000\n \n #endif\n \n-\t@ Put final sign in r0.\n-\tmov\tr0, r2, lsl #16\n-\tbic\tr2, r2, #0x8000\n-\n-\t@ Adjust result if one extra MSB appeared.\n-\t@ The LSB may be lost but this never changes the result in this case.\n-\ttst\tip, #(1 << 15)\n-\taddne\tr2, r2, #(1 << 22)\n-\tmovnes\tip, ip, lsr #1\n-\tmovne\tr3, r3, rrx\n-\n-\t@ Apply exponent bias, check range for underflow.\n-\tsubs\tr2, r2, #(127 << 22)\n-\tble\tLSYM(Lml_u)\n-\n-\t@ Scale back to 24 bits with rounding.\n-\t@ r0 contains sign bit already.\n-\torrs\tr0, r0, r3, lsr #23\n-\tadc\tr0, r0, ip, lsl #9\n-\n-\t@ If halfway between two numbers, rounding should be towards LSB = 0.\n-\tmov\tr3, r3, lsl #9\n-\tteq\tr3, #0x80000000\n-\tbiceq\tr0, r0, #1\n+\t@ Adjust result upon the MSB position.\n+\tcmp\tr1, #(1 << 23)\n+\tmovcc\tr1, r1, lsl #1\n+\torrcc\tr1, r1, r3, lsr #31\n+\tmovcc\tr3, r3, lsl #1\n \n-\t@ Note: rounding may have produced an extra MSB here.\n-\t@ The extra bit is cleared before merging the exponent below.\n-\ttst\tr0, #0x01000000\n-\taddne\tr2, r2, #(1 << 22)\n+\t@ Add sign to result.\n+\torr\tr0, r0, r1\n \n-\t@ Check for exponent overflow\n-\tcmp\tr2, #(255 << 22)\n-\tbge\tLSYM(Lml_o)\n+\t@ Apply exponent bias, check for under/overflow.\n+\tsbc\tr2, r2, #127\n+\tcmp\tr2, #(254 - 1)\n+\tbhi\tLSYM(Lml_u)\n \n-\t@ Add final exponent.\n-\tbic\tr0, r0, #0x01800000\n-\torr\tr0, r0, r2, lsl #1\n+\t@ Round the result, merge final exponent.\n+\tcmp\tr3, #0x80000000\n+\tadc\tr0, r0, r2, lsl #23\n+\tbiceq\tr0, r0, #1\n \tRET\n \n-\t@ Result is 0, but determine sign anyway.\n-LSYM(Lml_z):\n-\teor\tr0, r0, r1\n-\tbic\tr0, r0, #0x7fffffff\n-\tRET\n+\t@ Multiplication by 0x1p*: let''s shortcut a lot of code.\n+LSYM(Lml_1):\n+\tteq\tr0, #0\n+\tand\tip, ip, #0x80000000\n+\tmoveq\tr1, r1, lsl #9\n+\torr\tr0, ip, r0, lsr #9\n+\torr\tr0, r0, r1, lsr #9\n+\tsubs\tr2, r2, #127\n+\trsbgts\tr3, r2, #255\n+\torrgt\tr0, r0, r2, lsl #23\n+\tRETc(gt)\n+\n+\t@ Under/overflow: fix things up for the code below.\n+\torr\tr0, r0, #0x00800000\n+\tmov\tr3, #0\n+\tsubs\tr2, r2, #1\n \n-\t@ Check if denormalized result is possible, otherwise return signed 0.\n LSYM(Lml_u):\n-\tcmn\tr2, #(24 << 22)\n-\tRETc(le)\n+\t@ Overflow?\n+\tbgt\tLSYM(Lml_o)\n \n-\t@ Find out proper shift value.\n-\tmvn\tr1, r2, asr #22\n-\tsubs\tr1, r1, #7\n-\tbgt\tLSYM(Lml_ur)\n-\n-\t@ Shift value left, round, etc.\n-\tadd\tr1, r1, #32\n-\torrs\tr0, r0, r3, lsr r1\n-\trsb\tr1, r1, #32\n-\tadc\tr0, r0, ip, lsl r1\n-\tmov\tip, r3, lsl r1\n-\tteq\tip, #0x80000000\n-\tbiceq\tr0, r0, #1\n-\tRET\n+\t@ Check if denormalized result is possible, otherwise return signed 0.\n+\tcmn\tr2, #(24 + 1)\n+\tbicle\tr0, r0, #0x7fffffff\n+\tRETc(le)\n \n \t@ Shift value right, round, etc.\n-\t@ Note: r1 must not be 0 otherwise carry does not get set.\n-LSYM(Lml_ur):\n-\torrs\tr0, r0, ip, lsr r1\n+\trsb\tr2, r2, #0\n+\tmovs\tr1, r0, lsl #1\n+\tmov\tr1, r1, lsr r2\n+\trsb\tr2, r2, #32\n+\tmov\tip, r0, lsl r2\n+\tmovs\tr0, r1, rrx\n \tadc\tr0, r0, #0\n-\trsb\tr1, r1, #32\n-\tmov\tip, ip, lsl r1\n-\tteq\tr3, #0\n-\tteqeq\tip, #0x80000000\n-\tbiceq\tr0, r0, #1\n+\torrs\tr3, r3, ip, lsl #1\n+\tbiceq\tr0, r0, ip, lsr #31\n \tRET\n \n \t@ One or both arguments are denormalized.\n@@ -567,32 +522,51 @@ LSYM(Lml_d):\n \tand\tip, r0, #0x80000000\n 1:\tmoveq\tr0, r0, lsl #1\n \ttsteq\tr0, #0x00800000\n-\tsubeq\tr2, r2, #(1 << 22)\n+\tsubeq\tr2, r2, #1\n \tbeq\t1b\n \torr\tr0, r0, ip\n \tteq\tr3, #0\n \tand\tip, r1, #0x80000000\n 2:\tmoveq\tr1, r1, lsl #1\n \ttsteq\tr1, #0x00800000\n-\tsubeq\tr3, r3, #(1 << 23)\n+\tsubeq\tr3, r3, #1\n \tbeq\t2b\n \torr\tr1, r1, ip\n \tb\tLSYM(Lml_x)\n \n-\t@ One or both args are INF or NAN.\n LSYM(Lml_s):\n+\t@ Isolate the INF and NAN cases away\n+\tand\tr3, ip, r1, lsr #23\n+\tteq\tr2, ip\n+\tteqne\tr3, ip\n+\tbeq\t1f\n+\n+\t@ Here, one or more arguments are either denormalized or zero.\n+\tbics\tip, r0, #0x80000000\n+\tbicnes\tip, r1, #0x80000000\n+\tbne\tLSYM(Lml_d)\n+\n+\t@ Result is 0, but determine sign anyway.\n+LSYM(Lml_z):\n+\teor\tr0, r0, r1\n+\tbic\tr0, r0, #0x7fffffff\n+\tRET\n+\n+1:\t@ One or both args are INF or NAN.\n \tteq\tr0, #0x0\n-\tteqne\tr1, #0x0\n \tteqne\tr0, #0x80000000\n+\tmoveq\tr0, r1\n+\tteqne\tr1, #0x0\n \tteqne\tr1, #0x80000000\n \tbeq\tLSYM(Lml_n)\t\t@ 0 * INF or INF * 0 -> NAN\n-\tteq\tr2, ip, lsr #1\n+\tteq\tr2, ip\n \tbne\t1f\n \tmovs\tr2, r0, lsl #9\n \tbne\tLSYM(Lml_n)\t\t@ NAN * <anything> -> NAN\n-1:\tteq\tr3, ip, lsr #1\n+1:\tteq\tr3, ip\n \tbne\tLSYM(Lml_i)\n \tmovs\tr3, r1, lsl #9\n+\tmovne\tr0, r1\n \tbne\tLSYM(Lml_n)\t\t@ <anything> * NAN -> NAN\n \n \t@ Result is INF, but we need to determine its sign.\n@@ -606,9 +580,9 @@ LSYM(Lml_o):\n \torr\tr0, r0, #0x00800000\n \tRET\n \n-\t@ Return NAN.\n+\t@ Return a quiet NAN.\n LSYM(Lml_n):\n-\tmov\tr0, #0x7f000000\n+\torr\tr0, r0, #0x7f000000\n \torr\tr0, r0, #0x00c00000\n \tRET\n \n@@ -617,54 +591,39 @@ LSYM(Lml_n):\n \n ARM_FUNC_START divsf3\n ARM_FUNC_ALIAS aeabi_fdiv divsf3\n-\t\n-\t@ Mask out exponents.\n-\tmov\tip, #0xff000000\n-\tand\tr2, r0, ip, lsr #1\n-\tand\tr3, r1, ip, lsr #1\n-\n-\t@ Trap any INF/NAN or zeroes.\n-\tteq\tr2, ip, lsr #1\n-\tteqne\tr3, ip, lsr #1\n-\tbicnes\tip, r0, #0x80000000\n-\tbicnes\tip, r1, #0x80000000\n-\tbeq\tLSYM(Ldv_s)\n \n-\t@ Shift exponents right one bit to make room for overflow bit.\n-\t@ If either of them is 0, scale denormalized arguments off line.\n-\t@ Then substract divisor exponent from dividend''s.\n-\tmovs\tr2, r2, lsr #1\n-\tteqne\tr3, #0\n-\tbeq\tLSYM(Ldv_d)\n+\t@ Mask out exponents, trap any zero/denormal/INF/NAN.\n+\tmov\tip, #0xff\n+\tands\tr2, ip, r0, lsr #23\n+\tandnes\tr3, ip, r1, lsr #23\n+\tteqne\tr2, ip\n+\tteqne\tr3, ip\n+\tbeq\tLSYM(Ldv_s)\n LSYM(Ldv_x):\n-\tsub\tr2, r2, r3, asr #1\n+\n+\t@ Substract divisor exponent from dividend''s\n+\tsub\tr2, r2, r3\n \n \t@ Preserve final sign into ip.\n \teor\tip, r0, r1\n \n \t@ Convert mantissa to unsigned integer.\n \t@ Dividend -> r3, divisor -> r1.\n-\tmov\tr3, #0x10000000\n \tmovs\tr1, r1, lsl #9\n \tmov\tr0, r0, lsl #9\n \tbeq\tLSYM(Ldv_1)\n+\tmov\tr3, #0x10000000\n \torr\tr1, r3, r1, lsr #4\n \torr\tr3, r3, r0, lsr #4\n \n \t@ Initialize r0 (result) with final sign bit.\n \tand\tr0, ip, #0x80000000\n \n \t@ Ensure result will land to known bit position.\n+\t@ Apply exponent bias accordingly.\n \tcmp\tr3, r1\n-\tsubcc\tr2, r2, #(1 << 22)\n \tmovcc\tr3, r3, lsl #1\n-\n-\t@ Apply exponent bias, check range for over/underflow.\n-\tadd\tr2, r2, #(127 << 22)\n-\tcmn\tr2, #(24 << 22)\n-\tRETc(le)\n-\tcmp\tr2, #(255 << 22)\n-\tbge\tLSYM(Lml_o)\n+\tadc\tr2, r2, #(127 - 2)\n \n \t@ The actual division loop.\n \tmov\tip, #0x00800000\n@@ -684,44 +643,29 @@ LSYM(Ldv_x):\n \tmovnes\tip, ip, lsr #4\n \tbne\t1b\n \n-\t@ Check if denormalized result is needed.\n-\tcmp\tr2, #0\n-\tble\tLSYM(Ldv_u)\n+\t@ Check exponent for under/overflow.\n+\tcmp\tr2, #(254 - 1)\n+\tbhi\tLSYM(Lml_u)\n \n-\t@ Apply proper rounding.\n+\t@ Round the result, merge final exponent.\n \tcmp\tr3, r1\n-\taddcs\tr0, r0, #1\n+\tadc\tr0, r0, r2, lsl #23\n \tbiceq\tr0, r0, #1\n-\n-\t@ Add exponent to result.\n-\tbic\tr0, r0, #0x00800000\n-\torr\tr0, r0, r2, lsl #1\n \tRET\n \n \t@ Division by 0x1p*: let''s shortcut a lot of code.\n LSYM(Ldv_1):\n \tand\tip, ip, #0x80000000\n \torr\tr0, ip, r0, lsr #9\n-\tadd\tr2, r2, #(127 << 22)\n-\tcmp\tr2, #(255 << 22)\n-\tbge\tLSYM(Lml_o)\n-\tcmp\tr2, #0\n-\torrgt\tr0, r0, r2, lsl #1\n+\tadds\tr2, r2, #127\n+\trsbgts\tr3, r2, #255\n+\torrgt\tr0, r0, r2, lsl #23\n \tRETc(gt)\n-\tcmn\tr2, #(24 << 22)\n-\tmovle\tr0, ip\n-\tRETc(le)\n+\n \torr\tr0, r0, #0x00800000\n \tmov\tr3, #0\n-\n-\t@ Result must be denormalized: prepare parameters to use code above.\n-\t@ r3 already contains remainder for rounding considerations.\n-LSYM(Ldv_u):\n-\tbic\tip, r0, #0x80000000\n-\tand\tr0, r0, #0x80000000\n-\tmvn\tr1, r2, asr #22\n-\tadd\tr1, r1, #2\n-\tb\tLSYM(Lml_ur)\n+\tsubs\tr2, r2, #1\n+\tb\tLSYM(Lml_u)\n \n \t@ One or both arguments are denormalized.\n \t@ Scale them leftwards and preserve sign bit.\n@@ -730,35 +674,40 @@ LSYM(Ldv_d):\n \tand\tip, r0, #0x80000000\n 1:\tmoveq\tr0, r0, lsl #1\n \ttsteq\tr0, #0x00800000\n-\tsubeq\tr2, r2, #(1 << 22)\n+\tsubeq\tr2, r2, #1\n \tbeq\t1b\n \torr\tr0, r0, ip\n \tteq\tr3, #0\n \tand\tip, r1, #0x80000000\n 2:\tmoveq\tr1, r1, lsl #1\n \ttsteq\tr1, #0x00800000\n-\tsubeq\tr3, r3, #(1 << 23)\n+\tsubeq\tr3, r3, #1\n \tbeq\t2b\n \torr\tr1, r1, ip\n \tb\tLSYM(Ldv_x)\n \n-\t@ One or both arguments is either INF, NAN or zero.\n+\t@ One or both arguments are either INF, NAN, zero or denormalized.\n LSYM(Ldv_s):\n-\tmov\tip, #0xff000000\n-\tteq\tr2, ip, lsr #1\n-\tteqeq\tr3, ip, lsr #1\n-\tbeq\tLSYM(Lml_n)\t\t@ INF/NAN / INF/NAN -> NAN\n-\tteq\tr2, ip, lsr #1\n+\tand\tr3, ip, r1, lsr #23\n+\tteq\tr2, ip\n \tbne\t1f\n \tmovs\tr2, r0, lsl #9\n \tbne\tLSYM(Lml_n)\t\t@ NAN / <anything> -> NAN\n-\tb\tLSYM(Lml_i)\t\t@ INF / <anything> -> INF\n-1:\tteq\tr3, ip, lsr #1\n+\tteq\tr3, ip\n+\tbne\tLSYM(Lml_i)\t\t@ INF / <anything> -> INF\n+\tmov\tr0, r1\n+\tb\tLSYM(Lml_n)\t\t@ INF / (INF or NAN) -> NAN\n+1:\tteq\tr3, ip\n \tbne\t2f\n \tmovs\tr3, r1, lsl #9\n-\tbne\tLSYM(Lml_n)\t\t@ <anything> / NAN -> NAN\n-\tb\tLSYM(Lml_z)\t\t@ <anything> / INF -> 0\n-2:\t@ One or both arguments are 0.\n+\tbeq\tLSYM(Lml_z)\t\t@ <anything> / INF -> 0\n+\tmov\tr0, r1\n+\tb\tLSYM(Lml_n)\t\t@ <anything> / NAN -> NAN\n+2:\t@ If both are non-zero, we need to normalize and resume above.\n+\tbics\tip, r0, #0x80000000\n+\tbicnes\tip, r1, #0x80000000\n+\tbne\tLSYM(Ldv_d)\n+\t@ One or both arguments are zero.\n \tbics\tr2, r0, #0x80000000\n \tbne\tLSYM(Lml_i)\t\t@ <non_zero> / 0 -> INF\n \tbics\tr3, r1, #0x80000000\n@@ -789,85 +738,50 @@ LSYM(Ldv_s):\n \n ARM_FUNC_START gtsf2\n ARM_FUNC_ALIAS gesf2 gtsf2\n-\tmov\tr3, #-1\n+\tmov\tip, #-1\n \tb\t1f\n \n ARM_FUNC_START ltsf2\n ARM_FUNC_ALIAS lesf2 ltsf2\n-\tmov\tr3, #1\n+\tmov\tip, #1\n \tb\t1f\n \n ARM_FUNC_START cmpsf2\n ARM_FUNC_ALIAS nesf2 cmpsf2\n ARM_FUNC_ALIAS eqsf2 cmpsf2\n-\tmov\tr3, #1\t\t\t@ how should we specify unordered here?\n-\n-\t@ Both Inf and NaN have an exponent of 255.  Therefore, we\n-\t@ compute (r1 & 0x8f80000) || (r2 & 0x8f8000).\n-1:\tmov\tip, #0xff000000\n-\tand\tr2, r1, ip, lsr #1\n-\tteq\tr2, ip, lsr #1\n-\tand\tr2, r0, ip, lsr #1\n-\tteqne\tr2, ip, lsr #1\n+\tmov\tip, #1\t\t\t@ how should we specify unordered here?\n+\n+1:\tstr\tip, [sp, #-4]\n+\n+\t@ Trap any INF/NAN first.\n+\tmov\tr2, r0, lsl #1\n+\tmov\tr3, r1, lsl #1\n+\tmvns\tip, r2, asr #24\n+\tmvnnes\tip, r3, asr #24\n \tbeq\t3f\n \n-\t@ Test for equality.  The representations of +0.0 and -0.0\n-\t@ have all bits set to zero, except for the sign bit.  Since\n-\t@ 0.0 is equal to -0.0, we begin by testing \n-\t@ ((r0 | r1) & ~0x8000000).\n-2:\torr\tr3, r0, r1\n-\t@ If the result of the bitwise and is zero, then the Z flag\n-\t@ will be set.  In any case, the C flag will be set.\n-\tbics\tr3, r3, #0x80000000\t@ either 0.0 or -0.0\n-\tteqne\tr0, r1\t\t\t@ or both the same\n-\t@ If the Z flag is set, the two operands were equal.  Return zero.\n-\tmoveq\tr0, #0\n-\tRETc(eq)\n+\t@ Compare values.\n+\t@ Note that 0.0 is equal to -0.0.\n+2:\torrs\tip, r2, r3, lsr #1\t@ test if both are 0, clear C flag\n+\tteqne\tr0, r1\t\t\t@ if not 0 compare sign\n+\tsubpls\tr0, r2, r3\t\t@ if same sign compare values, set r0\n \n-\t@ Check for sign difference.  The N flag is set (due to the\n-\t@ use of teq above) if the sign bit is set on exactly one\n-\t@ of the operands.  Return the sign of the first operand.\n-\tmovmi\tr0, r0, asr #31\n-\torrmi\tr0, r0, #1\n-\tRETc(mi)\n-\n-\t@ Compare exponents.\n-\tand\tr3, r1, ip, lsr #1\n-\tcmp\tr2, r3\n-\n-\t@ Compare mantissa if exponents are equal\n-\tmoveq\tr0, r0, lsl #9\n-\tcmpeq\tr0, r1, lsl #9\n-\n-\t@ We know the operands cannot be equal at this point, so the\n-\t@ Z flag is clear.  The C flag is set if the first operand has\n-\t@ the greater exponent, or the exponents are equal and the \n-\t@ first operand has the greater mantissa.  Therefore, if the C\n-\t@ flag is set, the first operand is greater iff the sign is\n-\t@ positive.  These next two instructions will put zero in\n-\t@ r0 if the first operand is greater, and -1 if the second\n-\t@ operand is greater.\n-\tmovcs\tr0, r1, asr #31\n-\tmvncc\tr0, r1, asr #31\n-\t@ If r0 is 0, the first operand is greater, so return 1.  Leave\n-\t@ -1 unchanged.\n-\torr\tr0, r0, #1\n+\t@ Result:\n+\tmovhi\tr0, r1, asr #31\n+\tmvnlo\tr0, r1, asr #31\n+\torrne\tr0, r0, #1\n \tRET\n \n-\t@ We know that at least one argument is either Inf or NaN.\n-\t@ Look for a NaN. \n-3:\tand\tr2, r1, ip, lsr #1\n-\tteq\tr2, ip, lsr #1\n+\t@ Look for a NAN. \n+3:\tmvns\tip, r2, asr #24\n \tbne\t4f\n-\tmovs\tr2, r1, lsl #9\n-\tbne\t5f\t\t\t@ r1 is NAN\n-4:\tand\tr2, r0, ip, lsr #1\n-\tteq\tr2, ip, lsr #1\n-\tbne\t2b\n \tmovs\tip, r0, lsl #9\n-\tbeq\t2b\t\t\t@ r0 is not NAN\n-5:\t@ The Z flag is clear at this point.\n-\tmov\tr0, r3\t\t\t@ return unordered code from r3.\n+\tbne\t5f\t\t\t@ r0 is NAN\n+4:\tmvns\tip, r3, asr #24\n+\tbne\t2b\n+\tmovs\tip, r1, lsl #9\n+\tbeq\t2b\t\t\t@ r1 is not NAN\n+5:\tldr\tr0, [sp, #-4]\t\t@ return unordered code.\n \tRET\n \n \tFUNC_END gesf2\n@@ -879,13 +793,15 @@ ARM_FUNC_ALIAS eqsf2 cmpsf2\n \tFUNC_END cmpsf2\n \n ARM_FUNC_START aeabi_cfrcmple\n+\n \tmov\tip, r0\n \tmov\tr0, r1\n \tmov\tr1, ip\n \tb\t6f\n-\t\n+\n ARM_FUNC_START aeabi_cfcmpeq\n ARM_FUNC_ALIAS aeabi_cfcmple aeabi_cfcmpeq\n+\n \t@ The status-returning routines are required to preserve all\n \t@ registers except ip, lr, and cpsr.\n 6:\tstmfd\tsp!, {r0, r1, r2, r3, lr}\n@@ -896,68 +812,79 @@ ARM_FUNC_ALIAS aeabi_cfcmple aeabi_cfcmpeq\n \t@ that the first operand was smaller than the second.\n \tcmnmi\t r0, #0\n \tRETLDM  \"r0, r1, r2, r3\"\n+\n \tFUNC_END aeabi_cfcmple\n \tFUNC_END aeabi_cfcmpeq\n-\t\n+\tFUNC_END aeabi_cfrcmple\n+\n ARM_FUNC_START\taeabi_fcmpeq\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cfcmple\n \tmoveq\tr0, #1\t@ Equal to.\n \tmovne\tr0, #0\t@ Less than, greater than, or unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_fcmpeq\n \n ARM_FUNC_START\taeabi_fcmplt\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cfcmple\n \tmovcc\tr0, #1\t@ Less than.\n \tmovcs\tr0, #0\t@ Equal to, greater than, or unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_fcmplt\n \n ARM_FUNC_START\taeabi_fcmple\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cfcmple\n \tmovls\tr0, #1  @ Less than or equal to.\n \tmovhi\tr0, #0\t@ Greater than or unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_fcmple\n \n ARM_FUNC_START\taeabi_fcmpge\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cfrcmple\n \tmovls\tr0, #1\t@ Operand 2 is less than or equal to operand 1.\n \tmovhi\tr0, #0\t@ Operand 2 greater than operand 1, or unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_fcmpge\n \n ARM_FUNC_START\taeabi_fcmpgt\n+\n \tstr\tlr, [sp, #-4]!\n \tARM_CALL aeabi_cfrcmple\n \tmovcc\tr0, #1\t@ Operand 2 is less than operand 1.\n \tmovcs\tr0, #0  @ Operand 2 is greater than or equal to operand 1,\n \t\t\t@ or they are unordered.\n \tRETLDM\n+\n \tFUNC_END aeabi_fcmpgt\n-\t\t\n+\n #endif /* L_cmpsf2 */\n \n #ifdef L_unordsf2\n \n ARM_FUNC_START unordsf2\n ARM_FUNC_ALIAS aeabi_fcmpun unordsf2\n-\t\n-\tmov\tip, #0xff000000\n-\tand\tr2, r1, ip, lsr #1\n-\tteq\tr2, ip, lsr #1\n+\n+\tmov\tr2, r0, lsl #1\n+\tmov\tr3, r1, lsl #1\n+\tmvns\tip, r2, asr #24\n \tbne\t1f\n-\tmovs\tr2, r1, lsl #9\n-\tbne\t3f\t\t\t@ r1 is NAN\n-1:\tand\tr2, r0, ip, lsr #1\n-\tteq\tr2, ip, lsr #1\n-\tbne\t2f\n-\tmovs\tr2, r0, lsl #9\n+\tmovs\tip, r0, lsl #9\n \tbne\t3f\t\t\t@ r0 is NAN\n+1:\tmvns\tip, r3, asr #24\n+\tbne\t2f\n+\tmovs\tip, r1, lsl #9\n+\tbne\t3f\t\t\t@ r1 is NAN\n 2:\tmov\tr0, #0\t\t\t@ arguments are ordered.\n \tRET\n 3:\tmov\tr0, #1\t\t\t@ arguments are unordered.\n@@ -972,37 +899,35 @@ ARM_FUNC_ALIAS aeabi_fcmpun unordsf2\n \n ARM_FUNC_START fixsfsi\n ARM_FUNC_ALIAS aeabi_f2iz fixsfsi\n-\tmovs\tr0, r0, lsl #1\n-\tRETc(eq)\t\t\t@ value is 0.\n-\n-\tmov\tr1, r1, rrx\t\t@ preserve C flag (the actual sign)\n \n \t@ check exponent range.\n-\tand\tr2, r0, #0xff000000\n+\tmov\tr2, r0, lsl #1\n \tcmp\tr2, #(127 << 24)\n-\tmovcc\tr0, #0\t\t\t@ value is too small\n-\tRETc(cc)\n-\tcmp\tr2, #((127 + 31) << 24)\n-\tbcs\t1f\t\t\t@ value is too large\n-\n-\tmov\tr0, r0, lsl #7\n-\torr\tr0, r0, #0x80000000\n-\tmov\tr2, r2, lsr #24\n-\trsb\tr2, r2, #(127 + 31)\n-\ttst\tr1, #0x80000000\t\t@ the sign bit\n-\tmov\tr0, r0, lsr r2\n+\tbcc\t1f\t\t\t@ value is too small\n+\tmov\tr3, #(127 + 31)\n+\tsubs\tr2, r3, r2, lsr #24\n+\tbls\t2f\t\t\t@ value is too large\n+\n+\t@ scale value\n+\tmov\tr3, r0, lsl #8\n+\torr\tr3, r3, #0x80000000\n+\ttst\tr0, #0x80000000\t\t@ the sign bit\n+\tmov\tr0, r3, lsr r2\n \trsbne\tr0, r0, #0\n \tRET\n \n-1:\tteq\tr2, #0xff000000\n-\tbne\t2f\n-\tmovs\tr0, r0, lsl #8\n-\tbne\t3f\t\t\t@ r0 is NAN.\n-2:\tands\tr0, r1, #0x80000000\t@ the sign bit\n+1:\tmov\tr0, #0\n+\tRET\n+\n+2:\tcmp\tr2, #(127 + 31 - 0xff)\n+\tbne\t3f\n+\tmovs\tr2, r0, lsl #9\n+\tbne\t4f\t\t\t@ r0 is NAN.\n+3:\tands\tr0, r0, #0x80000000\t@ the sign bit\n \tmoveq\tr0, #0x7fffffff\t\t@ the maximum signed positive si\n \tRET\n \n-3:\tmov\tr0, #0\t\t\t@ What should we convert NAN to?\n+4:\tmov\tr0, #0\t\t\t@ What should we convert NAN to?\n \tRET\n \n \tFUNC_END aeabi_f2iz\n@@ -1014,34 +939,33 @@ ARM_FUNC_ALIAS aeabi_f2iz fixsfsi\n \n ARM_FUNC_START fixunssfsi\n ARM_FUNC_ALIAS aeabi_f2uiz fixunssfsi\n-\tmovs\tr0, r0, lsl #1\n-\tmovcss\tr0, #0\t\t\t@ value is negative...\n-\tRETc(eq)\t\t\t@ ... or 0.\n-\n \n \t@ check exponent range.\n-\tand\tr2, r0, #0xff000000\n+\tmovs\tr2, r0, lsl #1\n+\tbcs\t1f\t\t\t@ value is negative\n \tcmp\tr2, #(127 << 24)\n-\tmovcc\tr0, #0\t\t\t@ value is too small\n-\tRETc(cc)\n-\tcmp\tr2, #((127 + 32) << 24)\n-\tbcs\t1f\t\t\t@ value is too large\n+\tbcc\t1f\t\t\t@ value is too small\n+\tmov\tr3, #(127 + 31)\n+\tsubs\tr2, r3, r2, lsr #24\n+\tbmi\t2f\t\t\t@ value is too large\n+\n+\t@ scale the value\n+\tmov\tr3, r0, lsl #8\n+\torr\tr3, r3, #0x80000000\n+\tmov\tr0, r3, lsr r2\n+\tRET\n \n-\tmov\tr0, r0, lsl #7\n-\torr\tr0, r0, #0x80000000\n-\tmov\tr2, r2, lsr #24\n-\trsb\tr2, r2, #(127 + 31)\n-\tmov\tr0, r0, lsr r2\n+1:\tmov\tr0, #0\n \tRET\n \n-1:\tteq\tr2, #0xff000000\n-\tbne\t2f\n-\tmovs\tr0, r0, lsl #8\n-\tbne\t3f\t\t\t@ r0 is NAN.\n-2:\tmov\tr0, #0xffffffff\t\t@ maximum unsigned si\n+2:\tcmp\tr2, #(127 + 31 - 0xff)\n+\tbne\t3f\n+\tmovs\tr2, r0, lsl #9\n+\tbne\t4f\t\t\t@ r0 is NAN.\n+3:\tmov\tr0, #0xffffffff\t\t@ maximum unsigned si\n \tRET\n \n-3:\tmov\tr0, #0\t\t\t@ What should we convert NAN to?\n+4:\tmov\tr0, #0\t\t\t@ What should we convert NAN to?\n \tRET\n \n \tFUNC_END aeabi_f2uiz"}]}