{"sha": "7e842ef8c598036fa32d6d87fa350c04f0b037e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U4NDJlZjhjNTk4MDM2ZmEzMmQ2ZDg3ZmEzNTBjMDRmMGIwMzdlMw==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1996-02-16T20:13:23Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1996-02-16T20:13:23Z"}, "message": "c-typeck.c (convert_for_assignment): Bring back conversion to union without a cast...\n\n* c-typeck.c (convert_for_assignment):\nBring back conversion to union without a cast,\nundoing the Jan 16 change, but with the following differences:\n\n* The union must have the transparent_union attribute.\n* The conversion must be for a function argument.\n* Warn consistently about such conversions if pedantic.\n* Do not warn about an assignment incompatibility for one union member\n  if another union member is compatible with no warning.\n\nFrom-SVN: r11290", "tree": {"sha": "b3619e35c7de9421ce6e20393e8eec04ff376451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3619e35c7de9421ce6e20393e8eec04ff376451"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e842ef8c598036fa32d6d87fa350c04f0b037e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e842ef8c598036fa32d6d87fa350c04f0b037e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e842ef8c598036fa32d6d87fa350c04f0b037e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e842ef8c598036fa32d6d87fa350c04f0b037e3/comments", "author": null, "committer": null, "parents": [{"sha": "0afeb08a70db2010b7c0fc5db09c1c5c454271d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0afeb08a70db2010b7c0fc5db09c1c5c454271d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0afeb08a70db2010b7c0fc5db09c1c5c454271d7"}], "stats": {"total": 105, "additions": 105, "deletions": 0}, "files": [{"sha": "986e69946cadabf77f3c56ea1be9414651fc8fe7", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e842ef8c598036fa32d6d87fa350c04f0b037e3/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e842ef8c598036fa32d6d87fa350c04f0b037e3/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=7e842ef8c598036fa32d6d87fa350c04f0b037e3", "patch": "@@ -3996,6 +3996,111 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t  || coder == COMPLEX_TYPE))\n     return convert_and_check (type, rhs);\n \n+  /* Conversion to a transparent union from its member types.\n+     This applies only to function arguments.  */\n+  else if (codel == UNION_TYPE && TYPE_TRANSPARENT_UNION (type) && ! errtype)\n+    {\n+      tree memb_types;\n+      tree marginal_memb_type = 0;\n+\n+      for (memb_types = TYPE_FIELDS (type); memb_types;\n+\t   memb_types = TREE_CHAIN (memb_types))\n+\t{\n+\t  tree memb_type = TREE_TYPE (memb_types);\n+\n+\t  if (comptypes (TYPE_MAIN_VARIANT (memb_type),\n+\t\t\t TYPE_MAIN_VARIANT (rhstype)))\n+\t    break;\n+\n+\t  if (TREE_CODE (memb_type) != POINTER_TYPE)\n+\t    continue;\n+\n+\t  if (coder == POINTER_TYPE)\n+\t    {\n+\t      register tree ttl = TREE_TYPE (memb_type);\n+\t      register tree ttr = TREE_TYPE (rhstype);\n+\n+\t      /* Any non-function converts to a [const][volatile] void *\n+\t\t and vice versa; otherwise, targets must be the same.\n+\t\t Meanwhile, the lhs target must have all the qualifiers of\n+\t\t the rhs.  */\n+\t      if (TYPE_MAIN_VARIANT (ttl) == void_type_node\n+\t\t  || TYPE_MAIN_VARIANT (ttr) == void_type_node\n+\t\t  || comp_target_types (memb_type, rhstype))\n+\t\t{\n+\t\t  /* If this type won't generate any warnings, use it.  */\n+\t\t  if ((TREE_CODE (ttr) == FUNCTION_TYPE\n+\t\t       && TREE_CODE (ttl) == FUNCTION_TYPE)\n+\t\t      ? ((! TYPE_READONLY (ttl) | TYPE_READONLY (ttr))\n+\t\t\t & (! TYPE_VOLATILE (ttl) | TYPE_VOLATILE (ttr)))\n+\t\t      : ((TYPE_READONLY (ttl) | ! TYPE_READONLY (ttr))\n+\t\t\t & (TYPE_VOLATILE (ttl) | ! TYPE_VOLATILE (ttr))))\n+\t\t    break;\n+\n+\t\t  /* Keep looking for a better type, but remember this one.  */\n+\t\t  if (! marginal_memb_type)\n+\t\t    marginal_memb_type = memb_type;\n+\t\t}\n+\t    }\n+\n+\t  /* Can convert integer zero to any pointer type.  */\n+\t  if (integer_zerop (rhs)\n+\t      || (TREE_CODE (rhs) == NOP_EXPR\n+\t\t  && integer_zerop (TREE_OPERAND (rhs, 0))))\n+\t    {\n+\t      rhs = null_pointer_node;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (memb_types || marginal_memb_type)\n+\t{\n+\t  if (! memb_types)\n+\t    {\n+\t      /* We have only a marginally acceptable member type;\n+\t\t it needs a warning. */\n+\t      register tree ttl = TREE_TYPE (marginal_memb_type);\n+\t      register tree ttr = TREE_TYPE (rhstype);\n+\n+\t      /* Const and volatile mean something different for function\n+\t\t types, so the usual warnings are not appropriate.  */\n+\t      if (TREE_CODE (ttr) == FUNCTION_TYPE\n+\t\t  && TREE_CODE (ttl) == FUNCTION_TYPE)\n+\t\t{\n+\t\t  /* Because const and volatile on functions are\n+\t\t     restrictions that say the function will not do\n+\t\t     certain things, it is okay to use a const or volatile\n+\t\t     function where an ordinary one is wanted, but not\n+\t\t     vice-versa.  */\n+\t\t  if (TYPE_READONLY (ttl) && ! TYPE_READONLY (ttr))\n+\t\t    warn_for_assignment (\"%s makes `const *' function pointer from non-const\",\n+\t\t\t\t\t get_spelling (errtype), funname,\n+\t\t\t\t\t parmnum);\n+\t\t  if (TYPE_VOLATILE (ttl) && ! TYPE_VOLATILE (ttr))\n+\t\t    warn_for_assignment (\"%s makes `volatile *' function pointer from non-volatile\",\n+\t\t\t\t\t get_spelling (errtype), funname,\n+\t\t\t\t\t parmnum);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (! TYPE_READONLY (ttl) && TYPE_READONLY (ttr))\n+\t\t    warn_for_assignment (\"%s discards `const' from pointer target type\",\n+\t\t\t\t\t get_spelling (errtype), funname,\n+\t\t\t\t\t parmnum);\n+\t\t  if (! TYPE_VOLATILE (ttl) && TYPE_VOLATILE (ttr))\n+\t\t    warn_for_assignment (\"%s discards `volatile' from pointer target type\",\n+\t\t\t\t\t get_spelling (errtype), funname,\n+\t\t\t\t\t parmnum);\n+\t\t}\n+\t    }\n+\t  \n+\t  if (pedantic && ! DECL_IN_SYSTEM_HEADER (fundecl))\n+\t    pedwarn (\"ANSI C prohibits argument conversion to union type\");\n+\n+\t  return build1 (NOP_EXPR, type, rhs);\n+\t}\n+    }\n+\n   /* Conversions among pointers */\n   else if (codel == POINTER_TYPE && coder == POINTER_TYPE)\n     {"}]}