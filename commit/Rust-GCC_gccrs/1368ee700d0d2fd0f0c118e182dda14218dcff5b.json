{"sha": "1368ee700d0d2fd0f0c118e182dda14218dcff5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM2OGVlNzAwZDBkMmZkMGYwYzExOGUxODJkZGExNDIxOGRjZmY1Yg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-20T19:33:11Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-20T19:33:11Z"}, "message": "cpplib.h (enum cpp_ttype): Add token types for all punctuators.\n\n\t* cpplib.h (enum cpp_ttype): Add token types for all\n\tpunctuators.  Distinguish pp-numbers from valid C numbers.\n\tGive some tokens better names.  Initialize from macro.\n\t(struct cpp_name, cpp_token, cpp_toklist): New data\n\tstructures.\n\tUpdate prototypes.\n\t* cpplex.c (bump_column, expand_name_space,\n\texpand_token_space, init_token_list, cpp_output_list,\n\t_cpp_scan_line):  New functions.\n\t(output_line_command): Add third argument, new line number.\n\t* cpphash.h: Update prototypes.\n\t* cppexp.c, cpphash.c, cpplib.c, scan-decls.c: Update for new\n\ttoken names.\n\nFrom-SVN: r33289", "tree": {"sha": "b131b13cc8013ec316c7583f27a31866d32d9a99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b131b13cc8013ec316c7583f27a31866d32d9a99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1368ee700d0d2fd0f0c118e182dda14218dcff5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1368ee700d0d2fd0f0c118e182dda14218dcff5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1368ee700d0d2fd0f0c118e182dda14218dcff5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1368ee700d0d2fd0f0c118e182dda14218dcff5b/comments", "author": null, "committer": null, "parents": [{"sha": "70994f30394bd41eeb3173fcbd40b3db609cb445", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70994f30394bd41eeb3173fcbd40b3db609cb445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70994f30394bd41eeb3173fcbd40b3db609cb445"}], "stats": {"total": 472, "additions": 391, "deletions": 81}, "files": [{"sha": "8488dd919be2e7ad82f98e611a1efd1a8e90b1b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1368ee700d0d2fd0f0c118e182dda14218dcff5b", "patch": "@@ -1,3 +1,19 @@\n+2000-04-20  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.h (enum cpp_ttype): Add token types for all\n+\tpunctuators.  Distinguish pp-numbers from valid C numbers.\n+\tGive some tokens better names.  Initialize from macro.    \n+\t(struct cpp_name, cpp_token, cpp_toklist): New data   \n+\tstructures.\n+\tUpdate prototypes.\n+\t* cpplex.c (bump_column, expand_name_space,\n+\texpand_token_space, init_token_list, cpp_output_list,\n+\t_cpp_scan_line):  New functions.\n+\t(output_line_command): Add third argument, new line number.\n+\t* cpphash.h: Update prototypes.\n+\t* cppexp.c, cpphash.c, cpplib.c, scan-decls.c: Update for new\n+\ttoken names.\n+\n 2000-04-20  Richard Henderson  <rth@cygnus.com>\n \n \t* config/alpha/alpha.c (alpha_emit_floatuns): Emit missing barrier.\n@@ -1836,7 +1852,7 @@ Wed Apr  5 12:35:18 2000  Hans-Peter Nilsson  <hp@axis.com>\n \tall (op (minus A B) 0) with (op A B).\n \n Wed Apr  5 18:03:31 2000  Toshiyasu Morita  (toshi.morita@sega.com)\n-\t                  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\t\t\t  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* sh.md (block_lump_real_i4): Add missing clobber of T_REG\n \t(block_lump_real): Likewise."}, {"sha": "1489dc961230652067cbc431cc72ce8ea1658c5c", "filename": "gcc/cppexp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=1368ee700d0d2fd0f0c118e182dda14218dcff5b", "patch": "@@ -348,7 +348,7 @@ parse_defined (pfile)\n \n   pfile->no_macro_expand++;\n   token = _cpp_get_directive_token (pfile);\n-  if (token == CPP_LPAREN)\n+  if (token == CPP_OPEN_PAREN)\n     {\n       paren++;\n       CPP_SET_WRITTEN (pfile, old_written);\n@@ -364,7 +364,7 @@ parse_defined (pfile)\n \n   if (paren)\n     {\n-      if (_cpp_get_directive_token (pfile) != CPP_RPAREN)\n+      if (_cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n \tgoto oops;\n     }\n   CPP_SET_WRITTEN (pfile, old_written);"}, {"sha": "439cc805f453d7fb5a00322d86a865e65d8f02d7", "filename": "gcc/cpphash.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=1368ee700d0d2fd0f0c118e182dda14218dcff5b", "patch": "@@ -335,7 +335,7 @@ collect_expansion (pfile, arglist)\n \t    CPP_SET_WRITTEN (pfile, here);\n \t  break;\n \n-\tcase CPP_STRINGIZE:\n+\tcase CPP_HASH:\n \t  /* # is not special in object-like macros.  It is special in\n \t     function-like macros with no args.  (6.10.3.2 para 1.) */\n \t  if (arglist == NULL)\n@@ -348,7 +348,7 @@ collect_expansion (pfile, arglist)\n \t  CPP_SET_WRITTEN (pfile, here);  /* delete from replacement text */\n \t  break;\n \n-\tcase CPP_TOKPASTE:\n+\tcase CPP_PASTE:\n \t  /* If the last token was an argument, discard this token and\n \t     any hspace between it and the argument's position.  Then\n \t     mark the arg raw_after.  */\n@@ -577,10 +577,10 @@ collect_formal_parameters (pfile)\n \n   old_written = CPP_WRITTEN (pfile);\n   token = _cpp_get_directive_token (pfile);\n-  if (token != CPP_LPAREN)\n+  if (token != CPP_OPEN_PAREN)\n     {\n       cpp_ice (pfile, \"first token = %d not %d in collect_formal_parameters\",\n-\t       token, CPP_LPAREN);\n+\t       token, CPP_OPEN_PAREN);\n       goto invalid;\n     }\n \n@@ -626,10 +626,10 @@ collect_formal_parameters (pfile)\n \t  argv[argc].len = 0;\n \t  break;\n \n-\tcase CPP_RPAREN:\n+\tcase CPP_CLOSE_PAREN:\n \t  goto done;\n \n-\tcase CPP_3DOTS:\n+\tcase CPP_ELLIPSIS:\n \t  goto rest_arg;\n \n \tcase CPP_VSPACE:\n@@ -668,7 +668,7 @@ collect_formal_parameters (pfile)\n   argv[argc].rest_arg = 1;\n   \n   token = _cpp_get_directive_token (pfile);\n-  if (token != CPP_RPAREN)\n+  if (token != CPP_CLOSE_PAREN)\n     {\n       cpp_error (pfile, \"another parameter follows `...'\");\n       goto invalid;\n@@ -776,10 +776,10 @@ macarg (pfile, rest_args)\n \t  if (!CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n \t    return token;\n \t  break;\n-\tcase CPP_LPAREN:\n+\tcase CPP_OPEN_PAREN:\n \t  paren++;\n \t  break;\n-\tcase CPP_RPAREN:\n+\tcase CPP_CLOSE_PAREN:\n \t  if (--paren < 0)\n \t    goto found;\n \t  break;\n@@ -1042,7 +1042,7 @@ _cpp_macroexpand (pfile, hp)\n       pfile->no_directives++;\n \n       token = cpp_get_non_space_token (pfile);\n-      if (token != CPP_LPAREN)\n+      if (token != CPP_OPEN_PAREN)\n \tcpp_ice (pfile, \"macroexpand: unexpected token %d (wanted LPAREN)\",\n \t\t token);\n       CPP_ADJUST_WRITTEN (pfile, -1);\n@@ -1072,7 +1072,7 @@ _cpp_macroexpand (pfile, hp)\n       CPP_OPTION (pfile, discard_comments)--;\n       pfile->no_macro_expand--;\n       pfile->no_directives--;\n-      if (token != CPP_RPAREN)\n+      if (token != CPP_CLOSE_PAREN)\n \treturn;\n \n       /* foo ( ) is equivalent to foo () unless foo takes exactly one"}, {"sha": "b0ac3c654b78a985ba9540117cad204d02e630d4", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=1368ee700d0d2fd0f0c118e182dda14218dcff5b", "patch": "@@ -120,12 +120,6 @@ struct hashnode\n   enum node_type type;\t\t/* type of special token */\n };\n \n-/* Directive flags.  */\n-\n-#define SYNTAX_INCLUDE (1 << 8)\n-#define SYNTAX_ASSERT  (1 << 9)\n-typedef int (* directive_handler) PARAMS ((cpp_reader *));\n-\n /* List of directories to look for include files in. */\n struct file_name_list\n {\n@@ -315,6 +309,7 @@ extern enum cpp_ttype _cpp_get_directive_token\n \t\t\t\t\tPARAMS ((cpp_reader *));\n extern enum cpp_ttype _cpp_get_define_token\n \t\t\t\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_scan_line\t\tPARAMS ((cpp_reader *, cpp_toklist *));\n \n /* In cpplib.c */\n extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));"}, {"sha": "deae87e94475fc4af75a6ccf99f2fb31f942c1d1", "filename": "gcc/cpplex.c", "status": "modified", "additions": 194, "deletions": 21, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=1368ee700d0d2fd0f0c118e182dda14218dcff5b", "patch": "@@ -50,7 +50,13 @@ static void null_warning        PARAMS ((cpp_reader *, unsigned int));\n \n static void safe_fwrite\t\tPARAMS ((cpp_reader *, const U_CHAR *,\n \t\t\t\t\t size_t, FILE *));\n-static void output_line_command\tPARAMS ((cpp_reader *, cpp_printer *));\n+static void output_line_command\tPARAMS ((cpp_reader *, cpp_printer *,\n+\t\t\t\t\t unsigned int));\n+static void bump_column\t\tPARAMS ((cpp_printer *, unsigned int,\n+\t\t\t\t\t unsigned int));\n+static void expand_name_space\tPARAMS ((cpp_toklist *));\n+static void expand_token_space\tPARAMS ((cpp_toklist *));\n+static void init_token_list\tPARAMS ((cpp_reader *, cpp_toklist *, int));\n \n /* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n \n@@ -149,23 +155,18 @@ safe_fwrite (pfile, buf, len, fp)\n    or the current file name has changed.  */\n \n static void\n-output_line_command (pfile, print)\n+output_line_command (pfile, print, line)\n      cpp_reader *pfile;\n      cpp_printer *print;\n+     unsigned int line;\n {\n-  unsigned int line;\n-  cpp_buffer *ip;\n+  cpp_buffer *ip = cpp_file_buffer (pfile);\n   enum { same = 0, enter, leave, rname } change;\n   static const char * const codes[] = { \"\", \" 1\", \" 2\", \"\" };\n \n   if (CPP_OPTION (pfile, no_line_commands))\n     return;\n \n-  ip = cpp_file_buffer (pfile);\n-  if (ip == NULL)\n-    return;\n-  line = CPP_BUF_LINE (ip);\n-\n   /* Determine whether the current filename has changed, and if so,\n      how.  'nominal_fname' values are unique, so they can be compared\n      by comparing pointers.  */\n@@ -224,17 +225,88 @@ cpp_output_tokens (pfile, print)\n      cpp_reader *pfile;\n      cpp_printer *print;\n {\n+  cpp_buffer *ip;\n+\n   if (CPP_WRITTEN (pfile) - print->written)\n     {\n       if (CPP_PWRITTEN (pfile)[-1] == '\\n' && print->lineno)\n \tprint->lineno++;\n       safe_fwrite (pfile, pfile->token_buffer,\n \t\t   CPP_WRITTEN (pfile) - print->written, print->outf);\n     }\n-  output_line_command (pfile, print);\n+\n+  ip = cpp_file_buffer (pfile);\n+  if (ip)\n+    output_line_command (pfile, print, CPP_BUF_LINE (ip));\n+\n   CPP_SET_WRITTEN (pfile, print->written);\n }\n \n+/* Helper for cpp_output_list - increases the column number to match\n+   what we expect it to be.  */\n+\n+static void\n+bump_column (print, from, to)\n+     cpp_printer *print;\n+     unsigned int from, to;\n+{\n+  unsigned int tabs, spcs;\n+  unsigned int delta = to - from;\n+\n+  /* Only if FROM is 0, advance by tabs.  */\n+  if (from == 0)\n+    tabs = delta / 8, spcs = delta % 8;\n+  else\n+    tabs = 0, spcs = delta;\n+\n+  while (tabs--) putc ('\\t', print->outf);\n+  while (spcs--) putc (' ', print->outf);\n+}\n+\n+/* Write out the list L onto pfile->token_buffer.  This function is\n+   incomplete:\n+\n+   1) pfile->token_buffer is not going to continue to exist.\n+   2) At the moment, tokens don't carry the information described\n+   in cpplib.h; they are all strings.\n+   3) The list has to be a complete line, and has to be written starting\n+   at the beginning of a line.  */\n+\n+void\n+cpp_output_list (pfile, print, list)\n+     cpp_reader *pfile;\n+     cpp_printer *print;\n+     const cpp_toklist *list;\n+{\n+  unsigned int i;\n+  unsigned int curcol = 1;\n+\n+  /* XXX Probably does not do what is intended.  */\n+  if (print->lineno != list->line)\n+    output_line_command (pfile, print, list->line);\n+  \n+  for (i = 0; i < list->tokens_used; i++)\n+    {\n+      if (list->tokens[i].type == CPP_VSPACE)\n+\t{\n+\t  output_line_command (pfile, print, list->tokens[i].aux);\n+\t  continue;\n+\t}\n+\t  \n+      if (curcol < list->tokens[i].col)\n+\t{\n+\t  /* Insert space to bring the column to what it should be.  */\n+\t  bump_column (print, curcol - 1, list->tokens[i].col);\n+\t  curcol = list->tokens[i].col;\n+\t}\n+      /* XXX We may have to insert space to prevent an accidental\n+\t token paste.  */\n+      safe_fwrite (pfile, list->namebuf + list->tokens[i].val.name.offset,\n+\t\t   list->tokens[i].val.name.len, print->outf);\n+      curcol += list->tokens[i].val.name.len;\n+    }\n+}\n+\n /* Scan a string (which may have escape marks), perform macro expansion,\n    and write the result to the token_buffer.  */\n \n@@ -353,6 +425,107 @@ cpp_file_buffer (pfile)\n   return NULL;\n }\n \n+/* Token-buffer helper functions.  */\n+\n+/* Expand a token list's string space.  */\n+static void\n+expand_name_space (list)\n+     cpp_toklist *list;\n+{  \n+  list->name_cap *= 2;\n+  list->namebuf = (unsigned char *) xrealloc (list->namebuf,\n+\t\t\t\t\t      list->name_cap);\n+}\n+\n+/* Expand the number of tokens in a list.  */\n+static void\n+expand_token_space (list)\n+     cpp_toklist *list;\n+{\n+  list->tokens_cap *= 2;\n+  list->tokens = (cpp_token *)\n+    xrealloc (list->tokens, list->tokens_cap * sizeof (cpp_token));\n+}\n+\n+/* Initialise a token list.  */\n+static void\n+init_token_list (pfile, list, recycle)\n+     cpp_reader *pfile;\n+     cpp_toklist *list;\n+     int recycle;\n+{\n+  /* Recycling a used list saves 2 free-malloc pairs.  */\n+  if (recycle)\n+    {\n+      list->tokens_used = 0;\n+      list->name_used = 0;\n+    }\n+  else\n+    {\n+      /* Initialise token space.  */\n+      list->tokens_cap = 256;\t/* 4K on Intel.\t */\n+      list->tokens_used = 0;\n+      list->tokens = (cpp_token *)\n+\txmalloc (list->tokens_cap * sizeof (cpp_token));\n+\n+      /* Initialise name space.\t */\n+      list->name_cap = 1024;\n+      list->name_used = 0;\n+      list->namebuf = (unsigned char *) xmalloc (list->name_cap);\n+    }\n+\n+  list->line = pfile->buffer->lineno;\n+  list->dir_handler = 0;\n+  list->dir_flags = 0;\n+}\n+\n+/* Scan an entire line and create a token list for it.  Does not\n+   macro-expand or execute directives.  */\n+\n+void\n+_cpp_scan_line (pfile, list)\n+     cpp_reader *pfile;\n+     cpp_toklist *list;\n+{\n+  int i, col;\n+  long written, len;\n+  enum cpp_ttype type;\n+\n+  init_token_list (pfile, list, 1);\n+\n+  written = CPP_WRITTEN (pfile);\n+  i = 0;\n+  for (;;)\n+    {\n+      col = CPP_BUFFER (pfile)->cur - CPP_BUFFER (pfile)->line_base;\n+      type = _cpp_lex_token (pfile);\n+      len = CPP_WRITTEN (pfile) - written;\n+      CPP_SET_WRITTEN (pfile, written);\n+      if (type == CPP_HSPACE)\n+\tcontinue;\n+\n+      if (list->tokens_used >= list->tokens_cap)\n+\texpand_token_space (list);\n+      if (list->name_used + len >= list->name_cap)\n+\texpand_name_space (list);\n+\n+      list->tokens_used++;\n+      list->tokens[i].type = type;\n+      list->tokens[i].col = col;\n+\n+      if (type == CPP_VSPACE)\n+\tbreak;\n+\n+      list->tokens[i].val.name.len = len;\n+      list->tokens[i].val.name.offset = list->name_used;\n+      memcpy (list->namebuf + list->name_used, CPP_PWRITTEN (pfile), len);\n+      list->name_used += len;\n+      i++;\n+    }\n+  list->tokens[i].aux =  CPP_BUFFER (pfile)->lineno + 1;\n+}\n+\n+\n /* Skip a C-style block comment.  We know it's a comment, and point is\n    at the second character of the starter.  */\n static void\n@@ -904,9 +1077,9 @@ _cpp_lex_token (pfile)\n \t      CPP_PUTC_Q (pfile, GETC ());\n \t    }\n \t  else\n-\t    return CPP_STRINGIZE;\n+\t    return CPP_HASH;\n \n-\t  return CPP_TOKPASTE;\n+\t  return CPP_PASTE;\n \t}\n \n       if (!pfile->only_seen_white)\n@@ -959,7 +1132,7 @@ _cpp_lex_token (pfile)\n \t  CPP_RESERVE (pfile, 2);\n \t  CPP_PUTC_Q (pfile, c);\n \t  CPP_PUTC_Q (pfile, c2);\n-\t  return CPP_RBRACE;\n+\t  return CPP_OPEN_BRACE;\n \t}\n       /* else fall through */\n \n@@ -1042,7 +1215,7 @@ _cpp_lex_token (pfile)\n \t  CPP_RESERVE (pfile, 2);\n \t  CPP_PUTC_Q (pfile, c);\n \t  CPP_PUTC_Q (pfile, c2);\n-\t  return CPP_LBRACE;\n+\t  return CPP_CLOSE_BRACE;\n \t}\n       else if (c2 == ':')\n \tgoto op2;\n@@ -1082,7 +1255,7 @@ _cpp_lex_token (pfile)\n \t  CPP_PUTC_Q (pfile, '.');\n \t  CPP_PUTC_Q (pfile, '.');\n \t  FORWARD (2);\n-\t  return CPP_3DOTS;\n+\t  return CPP_ELLIPSIS;\n \t}\n       goto randomchar;\n \n@@ -1228,12 +1401,12 @@ _cpp_lex_token (pfile)\n       CPP_PUTC (pfile, c);\n       return CPP_VSPACE;\n \n-    case '(': token = CPP_LPAREN;    goto char1;\n-    case ')': token = CPP_RPAREN;    goto char1;\n-    case '{': token = CPP_LBRACE;    goto char1;\n-    case '}': token = CPP_RBRACE;    goto char1;\n-    case ',': token = CPP_COMMA;     goto char1;\n-    case ';': token = CPP_SEMICOLON; goto char1;\n+    case '(': token = CPP_OPEN_PAREN;  goto char1;\n+    case ')': token = CPP_CLOSE_PAREN; goto char1;\n+    case '{': token = CPP_OPEN_BRACE;  goto char1;\n+    case '}': token = CPP_CLOSE_BRACE; goto char1;\n+    case ',': token = CPP_COMMA;       goto char1;\n+    case ';': token = CPP_SEMICOLON;   goto char1;\n \n     randomchar:\n     default:"}, {"sha": "fb6b77099493fb3bfc8e633cb4edd1053d34be1c", "filename": "gcc/cpplib.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=1368ee700d0d2fd0f0c118e182dda14218dcff5b", "patch": "@@ -377,7 +377,7 @@ do_define (pfile)\n   token = _cpp_get_directive_token (pfile);\n   if (token == CPP_VSPACE)\n     empty = 0;  /* Empty definition of object like macro.  */\n-  else if (token == CPP_LPAREN && ADJACENT_TO_MARK (pfile))\n+  else if (token == CPP_OPEN_PAREN && ADJACENT_TO_MARK (pfile))\n     funlike = 1;\n   else if (ADJACENT_TO_MARK (pfile))\n     /* If this is an object-like macro, C99 requires white space after\n@@ -688,11 +688,13 @@ do_line (pfile)\n \t  if (action_number == 1)\n \t    {\n \t      pfile->buffer_stack_depth++;\n+\t      ip->system_header_p = 0;\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  else if (action_number == 2)\n \t    {\n \t      pfile->buffer_stack_depth--;\n+\t      ip->system_header_p = 0;\n \t      read_line_number (pfile, &action_number);\n \t    }\n \t  if (action_number == 3)\n@@ -1108,7 +1110,7 @@ detect_if_not_defined (pfile)\n   /* ...then an optional '(' and the name, */\n   token_offset = CPP_WRITTEN (pfile);\n   token = _cpp_get_directive_token (pfile);\n-  if (token == CPP_LPAREN)\n+  if (token == CPP_OPEN_PAREN)\n     {\n       token_offset = CPP_WRITTEN (pfile);\n       need_rparen = 1;\n@@ -1120,7 +1122,7 @@ detect_if_not_defined (pfile)\n   token_len = CPP_WRITTEN (pfile) - token_offset;\n \n   /* ...then the ')', if necessary, */\n-  if (need_rparen && _cpp_get_directive_token (pfile) != CPP_RPAREN)\n+  if (need_rparen && _cpp_get_directive_token (pfile) != CPP_CLOSE_PAREN)\n     goto restore;\n \n   /* ...and make sure there's nothing else on the line.  */"}, {"sha": "6e3561ac01b632a2308b36b7db6df893d1264d4b", "filename": "gcc/cpplib.h", "status": "modified", "additions": 150, "deletions": 26, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=1368ee700d0d2fd0f0c118e182dda14218dcff5b", "patch": "@@ -32,36 +32,156 @@ typedef struct cpp_reader cpp_reader;\n typedef struct cpp_buffer cpp_buffer;\n typedef struct cpp_options cpp_options;\n typedef struct cpp_printer cpp_printer;\n-\n+typedef struct cpp_token cpp_token;\n+typedef struct cpp_toklist cpp_toklist;\n+\n+  /* Put operators that can appear in a preprocessor expression first.\n+     This allows a lookup table to be implemented in _cpp_parse_expr.\n+     Ordering within this group is currently not significant, apart\n+     from those ending in '=' being at the end.  */\n+#define TTYPE_TABLE\t\t\t\t\\\n+  T(CPP_PLUS = 0,\t\"+\")\t/* math */\t\\\n+  T(CPP_MINUS,\t\t\"-\")\t\t\t\\\n+  T(CPP_MULT,\t\t\"*\")\t\t\t\\\n+  T(CPP_DIV,\t\t\"/\")\t\t\t\\\n+  T(CPP_MOD,\t\t\"%\")\t\t\t\\\n+  T(CPP_AND,\t\t\"&\")\t/* bit ops */\t\\\n+  T(CPP_OR,\t\t\"|\")\t\t\t\\\n+  T(CPP_XOR,\t\t\"^\")\t\t\t\\\n+  T(CPP_COMPL,\t\t\"~\")\t\t\t\\\n+  T(CPP_RSHIFT,\t\t\">>\")\t\t\t\\\n+  T(CPP_LSHIFT,\t\t\"<<\")\t\t\t\\\n+  T(CPP_NOT,\t\t\"!\")\t/* logicals */\t\\\n+  T(CPP_AND_AND,\t\"&&\")\t\t\t\\\n+  T(CPP_OR_OR,\t\t\"||\")\t\t\t\\\n+  T(CPP_QUERY,\t\t\"?\")\t\t\t\\\n+  T(CPP_COLON,\t\t\":\")\t\t\t\\\n+  T(CPP_COMMA,\t\t\",\")\t/* grouping */\t\\\n+  T(CPP_OPEN_PAREN,\t\"(\")\t\t\t\\\n+  T(CPP_CLOSE_PAREN,\t\")\")\t\t\t\\\n+  T(CPP_GREATER,\t\">\")\t/* compare */\t\\\n+  T(CPP_LESS,\t\t\"<\")\t\t\t\\\n+  T(CPP_EQ_EQ,\t\t\"==\")\t\t\t\\\n+  T(CPP_NOT_EQ,\t\t\"!=\")\t\t\t\\\n+  T(CPP_GREATER_EQ,\t\">=\")\t\t\t\\\n+  T(CPP_LESS_EQ,\t\"<=\")\t\t\t\\\n+\\\n+  /* The remainder of the punctuation.  Order is not significant. */\t\\\n+  T(CPP_PLUS_EQ,\t\"+=\")\t/* math */\t\\\n+  T(CPP_MINUS_EQ,\t\"-=\")\t\t\t\\\n+  T(CPP_MULT_EQ,\t\"*=\")\t\t\t\\\n+  T(CPP_DIV_EQ,\t\t\"/=\")\t\t\t\\\n+  T(CPP_MOD_EQ,\t\t\"%=\")\t\t\t\\\n+  T(CPP_AND_EQ,\t\t\"&=\")\t/* bit ops */\t\\\n+  T(CPP_OR_EQ,\t\t\"|=\")\t\t\t\\\n+  T(CPP_XOR_EQ,\t\t\"^=\")\t\t\t\\\n+  T(CPP_COMPL_EQ,\t\"~=\")\t\t\t\\\n+  T(CPP_RSHIFT_EQ,\t\">>=\")\t\t\t\\\n+  T(CPP_LSHIFT_EQ,\t\"<<=\")\t\t\t\\\n+  T(CPP_EQ,\t\t\"=\")\t/* assign */\t\\\n+  T(CPP_PLUS_PLUS,\t\"++\")\t/* increment */\t\\\n+  T(CPP_MINUS_MINUS,\t\"--\")\t\t\t\\\n+  T(CPP_DEREF,\t\t\"->\")\t/* accessors */\t\\\n+  T(CPP_DOT,\t\t\".\")\t\t\t\\\n+  T(CPP_OPEN_SQUARE,\t\"[\")\t\t\t\\\n+  T(CPP_CLOSE_SQUARE,\t\"]\")\t\t\t\\\n+  T(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n+  T(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n+  T(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n+  T(CPP_OPEN_BRACE,\t\"{\")\t/* structure */\t\\\n+  T(CPP_CLOSE_BRACE,\t\"}\")\t\t\t\\\n+  T(CPP_SEMICOLON,\t\";\")\t\t\t\\\n+  T(CPP_ELLIPSIS,\t\"...\")\t\t\t\\\n+  T(CPP_HASH,\t\t\"#\")\t\t\t\\\n+  T(CPP_PASTE,\t\t\"##\")\t\t\t\\\n+  T(CPP_BACKSLASH,\t\"\\\\\")\t\t\t\\\n+  T(CPP_MIN,\t\t\"<?\")\t/* extension */\t\\\n+  T(CPP_MAX,\t\t\">?\")\t\t\t\\\n+  T(CPP_OTHER,\t\tspell_other) /* stray punctuation */ \\\n+\\\n+  T(CPP_NAME,\t\tspell_name)\t/* word */\t\\\n+  T(CPP_INT,\t\t0)\t\t/* 23 */\t\\\n+  T(CPP_FLOAT,\t\t0)\t\t/* 3.14159 */\t\\\n+  T(CPP_NUMBER,\t\tspell_name)\t/* 34_be+ta  */\t\\\n+  T(CPP_CHAR,\t\tspell_char)\t/* 'char' */\t\\\n+  T(CPP_WCHAR,\t\tspell_char)\t/* L'char' */\t\\\n+  T(CPP_STRING,\t\tspell_string)\t/* \"string\" */\t\\\n+  T(CPP_WSTRING,\tspell_string)\t/* L\"string\" */\t\\\n+\\\n+  T(CPP_COMMENT,\tspell_comment)\t/* Only if output comments.  */ \\\n+  T(CPP_VSPACE,\t\t\"\\n\")\t\t/* End of line.  */\t\t\\\n+  T(CPP_EOF,\t\t0)\t\t/* End of file.  */\t\t\\\n+  T(CPP_HEADER_NAME,\t0)\t\t/* <stdio.h> in #include */\t\\\n+  T(CPP_ASSERTION,\t0)\t\t/* (...) in #assert */\t\t\\\n+\\\n+  /* Obsolete - will be removed when no code uses them still.  */\t\\\n+  T(CPP_HSPACE,\t\t0)\t\t/* Horizontal white space.  */\t\\\n+  T(CPP_POP,\t\t0)\t\t/* End of buffer.  */\t\t\\\n+  T(CPP_DIRECTIVE,\t0)\t\t/* #define and the like */\t\\\n+  T(CPP_MACRO,\t\t0)\t\t/* Like a NAME, but expanded.  */\n+\n+#define T(e, s) e,\n enum cpp_ttype\n {\n-  CPP_EOF = -1,\n-  CPP_OTHER = 0,\n-  CPP_COMMENT = 1,\n-  CPP_HSPACE,\n-  CPP_VSPACE, /* newlines and #line directives */\n-  CPP_NAME,\n-  CPP_MACRO,\n-  CPP_NUMBER,\n-  CPP_CHAR,\n-  CPP_WCHAR,\n-  CPP_STRING,\n-  CPP_WSTRING,\n-  CPP_DIRECTIVE,\n-  CPP_ASSERTION,\t/* #machine(a29k) */\n-  CPP_STRINGIZE,\t/* stringize macro argument */\n-  CPP_TOKPASTE,\t\t/* paste macro arg with next/prev token */\n-  CPP_LPAREN,\t\t/* \"(\" */\n-  CPP_RPAREN,\t\t/* \")\" */\n-  CPP_LBRACE,\t\t/* \"{\" */\n-  CPP_RBRACE,\t\t/* \"}\" */\n-  CPP_COMMA,\t\t/* \",\" */\n-  CPP_SEMICOLON,\t/* \";\" */\n-  CPP_3DOTS,\t\t/* \"...\" */\n-  CPP_POP\t\t/* We're about to pop the buffer stack.  */\n+  TTYPE_TABLE\n+  N_TTYPES\n+};\n+#undef T\n+\n+/* Payload of a NAME, NUMBER, FLOAT, STRING, or COMMENT token.  */\n+struct cpp_name\n+{\n+  unsigned int len;\n+  unsigned int offset;\t\t/* from list->namebuf */\n+};\n+\n+/* A preprocessing token.\n+   This has been carefully packed and should occupy 16 bytes on\n+   both 32- and 64-bit hosts.  */\n+struct cpp_token\n+{\n+  unsigned short col;\t\t\t/* starting column of this token */\n+#ifdef ENUM_BITFIELDS_ARE_UNSIGNED\n+  enum cpp_ttype type : CHAR_BIT;\t/* node type */\n+#else\n+  unsigned char type;\n+#endif\n+  unsigned char flags;\t\t\t/* flags - not presently used */\n+  unsigned int aux;\t\t\t/* hash of a NAME, or something -\n+\t\t\t\t\t   see uses in the code */\n+  union\n+  {\n+    struct cpp_name name;\t\t/* a string */\n+    HOST_WIDEST_INT integer;\t\t/* an integer */\n+  } val;\n };\n \n-typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader *));\n+/* Directive flags.  */\n+#define SYNTAX_INCLUDE (1 << 8)\n+#define SYNTAX_ASSERT  (1 << 9)\n+\n+typedef int (*directive_handler) PARAMS ((cpp_reader *));\n+typedef int (*parse_cleanup_t) PARAMS ((cpp_buffer *, cpp_reader *));\n+\n+struct cpp_toklist\n+{\n+  struct cpp_token *tokens;\t/* actual tokens as an array */\n+  unsigned int tokens_used;\t/* tokens used */\n+  unsigned int tokens_cap;\t/* tokens allocated */\n+\n+  unsigned char *namebuf;\t/* names buffer */\n+  unsigned int name_used;\t/* _bytes_ used */\n+  unsigned int name_cap;\t/* _bytes_ allocated */\n+\n+  unsigned int line;\t\t/* starting line number */\n+\n+  /* Only used if tokens[0].type == CPP_DIRECTIVE.  This is the\n+     handler to call after lexing the rest of this line.  The flags\n+     indicate whether the rest of the line gets special treatment\n+     during lexing (#include, #if, #assert, #unassert).  */\n+  directive_handler dir_handler;\n+  unsigned short dir_flags;\n+};\n \n struct cpp_buffer\n {\n@@ -442,6 +562,8 @@ extern void cpp_reader_init PARAMS ((cpp_reader *));\n extern cpp_printer *cpp_printer_init PARAMS ((cpp_reader *, cpp_printer *));\n extern int cpp_start_read PARAMS ((cpp_reader *, cpp_printer *, const char *));\n extern void cpp_output_tokens PARAMS ((cpp_reader *, cpp_printer *));\n+extern void cpp_output_list PARAMS ((cpp_reader *, cpp_printer *,\n+\t\t\t\t     const cpp_toklist *));\n extern void cpp_finish PARAMS ((cpp_reader *, cpp_printer *));\n extern void cpp_cleanup PARAMS ((cpp_reader *));\n \n@@ -487,6 +609,8 @@ extern cpp_buffer *cpp_pop_buffer\tPARAMS ((cpp_reader *));\n extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *, cpp_printer *));\n extern void cpp_scan_buffer_nooutput\tPARAMS ((cpp_reader *));\n \n+\n+\n /* In cpphash.c */\n extern int cpp_defined\t\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const unsigned char *, int));"}, {"sha": "3c33a1cc6590ad8a7abcf94b2a34931138a34800", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1368ee700d0d2fd0f0c118e182dda14218dcff5b/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=1368ee700d0d2fd0f0c118e182dda14218dcff5b", "patch": "@@ -48,9 +48,9 @@ skip_to_closing_brace (pfile)\n       enum cpp_ttype token = cpp_get_token (pfile);\n       if (token == CPP_EOF)\n \tbreak;\n-      if (token == CPP_LBRACE)\n+      if (token == CPP_OPEN_BRACE)\n \tnesting++;\n-      if (token == CPP_RBRACE && --nesting == 0)\n+      if (token == CPP_CLOSE_BRACE && --nesting == 0)\n \tbreak;\n     }\n }\n@@ -101,7 +101,7 @@ scan_decls (pfile, argc, argv)\n   current_extern_C = 0;\n   saw_extern = 0;\n   saw_inline = 0;\n-  if (token == CPP_RBRACE)\n+  if (token == CPP_OPEN_BRACE)\n     {\n       /* Pop an 'extern \"C\"' nesting level, if appropriate.  */\n       if (extern_C_braces_length\n@@ -110,7 +110,7 @@ scan_decls (pfile, argc, argv)\n       brace_nesting--;\n       goto new_statement;\n     }\n-  if (token == CPP_LBRACE)\n+  if (token == CPP_OPEN_BRACE)\n     {\n       brace_nesting++;\n       goto new_statement;\n@@ -128,7 +128,7 @@ scan_decls (pfile, argc, argv)\n     {\n       switch (token)\n \t{\n-\tcase CPP_LPAREN:\n+\tcase CPP_OPEN_PAREN:\n \t  /* Looks like this is the start of a formal parameter list.  */\n \t  if (prev_id_start)\n \t    {\n@@ -139,17 +139,17 @@ scan_decls (pfile, argc, argv)\n \t      for (;;)\n \t\t{\n \t\t  token = cpp_get_token (pfile);\n-\t\t  if (token == CPP_LPAREN)\n+\t\t  if (token == CPP_OPEN_PAREN)\n \t\t    nesting++;\n-\t\t  else if (token == CPP_RPAREN)\n+\t\t  else if (token == CPP_CLOSE_PAREN)\n \t\t    {\n \t\t      nesting--;\n \t\t      if (nesting == 0)\n \t\t\tbreak;\n \t\t    }\n \t\t  else if (token == CPP_EOF)\n \t\t    break;\n-\t\t  else if (token == CPP_NAME || token == CPP_3DOTS)\n+\t\t  else if (token == CPP_NAME || token == CPP_ELLIPSIS)\n \t\t    have_arg_list = 1;\n \t\t}\n \t      recognized_function (pfile->token_buffer + prev_id_start,\n@@ -161,7 +161,7 @@ scan_decls (pfile, argc, argv)\n \t\t\t\t   have_arg_list,\n \t\t\t\t   fbuf->nominal_fname, func_lineno);\n \t      token = cpp_get_non_space_token (pfile);\n-\t      if (token == CPP_LBRACE)\n+\t      if (token == CPP_OPEN_BRACE)\n \t\t{\n \t\t  /* skip body of (normally) inline function */\n \t\t  skip_to_closing_brace (pfile);\n@@ -218,7 +218,7 @@ scan_decls (pfile, argc, argv)\n \t\t  CPP_SET_WRITTEN (pfile, start_written);\n \t\t  current_extern_C = 1;\n \t\t  token = cpp_get_non_space_token (pfile);\n-\t\t  if (token == CPP_LBRACE)\n+\t\t  if (token == CPP_OPEN_BRACE)\n \t\t    {\n \t\t      brace_nesting++;\n \t\t      extern_C_braces[extern_C_braces_length++]\n@@ -238,7 +238,7 @@ scan_decls (pfile, argc, argv)\n \tcase CPP_EOF:\n \t  return 0;\n \n-\tcase CPP_LBRACE:  case CPP_RBRACE:  case CPP_DIRECTIVE:\n+\tcase CPP_OPEN_BRACE:  case CPP_CLOSE_BRACE:  case CPP_DIRECTIVE:\n \t  goto new_statement;  /* handle_statement? */\n \t  \n \tcase CPP_HSPACE:  case CPP_VSPACE:  case CPP_COMMENT:  case CPP_POP:"}]}