{"sha": "7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UyYTg0MTdmNzZiMTNmMDZjNmE1ZTIxYTMyZTFiODNkNzYzZDExOQ==", "commit": {"author": {"name": "Tony Reix", "email": "tony.reix@atos.net", "date": "2017-07-26T21:43:28Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-07-26T21:43:28Z"}, "message": "configure.ac: Check for XCOFF32/XCOFF64.\n\n\t* configure.ac: Check for XCOFF32/XCOFF64.  Check for loadquery.\n\t* filetype.awk: Separate AIX XCOFF32 and XCOFF64.\n\t* xcoff.c: Add support for AIX XCOFF32 and XCOFF64 formats.\n\t* configure, config.h.in: Regenerate.\n\nFrom-SVN: r250590", "tree": {"sha": "d8214f197401a1dc972b412aa4994ee671871b1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8214f197401a1dc972b412aa4994ee671871b1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/comments", "author": {"login": "trex58", "id": 5690106, "node_id": "MDQ6VXNlcjU2OTAxMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/5690106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/trex58", "html_url": "https://github.com/trex58", "followers_url": "https://api.github.com/users/trex58/followers", "following_url": "https://api.github.com/users/trex58/following{/other_user}", "gists_url": "https://api.github.com/users/trex58/gists{/gist_id}", "starred_url": "https://api.github.com/users/trex58/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/trex58/subscriptions", "organizations_url": "https://api.github.com/users/trex58/orgs", "repos_url": "https://api.github.com/users/trex58/repos", "events_url": "https://api.github.com/users/trex58/events{/privacy}", "received_events_url": "https://api.github.com/users/trex58/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "993323a14f46c25b18c5b9c69d577a4907c9e04c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/993323a14f46c25b18c5b9c69d577a4907c9e04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/993323a14f46c25b18c5b9c69d577a4907c9e04c"}], "stats": {"total": 1577, "additions": 1544, "deletions": 33}, "files": [{"sha": "52154f01e825ee567ccde30da1b64d710c3349ae", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "patch": "@@ -1,3 +1,10 @@\n+2017-07-26  Tony Reix  <tony.reix@atos.net>\n+\n+\t* configure.ac: Check for XCOFF32/XCOFF64.  Check for loadquery.\n+\t* filetype.awk: Separate AIX XCOFF32 and XCOFF64.\n+\t* xcoff.c: Add support for AIX XCOFF32 and XCOFF64 formats.\n+\t* configure, config.h.in: Regenerate.\n+\n 2017-07-21  Tony Reix  <tony.reix@atos.net>\n \n \t* filetype.awk: Add AIX XCOFF type detection."}, {"sha": "9fc771564ba1598f5aa40ad1cee16a9fd09c6c75", "filename": "libbacktrace/config.h.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfig.h.in?ref=7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "patch": "@@ -3,6 +3,9 @@\n /* ELF size: 32 or 64 */\n #undef BACKTRACE_ELF_SIZE\n \n+/* XCOFF size: 32 or 64 */\n+#undef BACKTRACE_XCOFF_SIZE\n+\n /* Define to 1 if you have the __atomic functions */\n #undef HAVE_ATOMIC_FUNCTIONS\n \n@@ -31,6 +34,9 @@\n /* Define to 1 if you have the <link.h> header file. */\n #undef HAVE_LINK_H\n \n+/* Define if AIX loadquery is available. */\n+#undef HAVE_LOADQUERY\n+\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n@@ -49,6 +55,9 @@\n /* Define to 1 if you have the __sync functions */\n #undef HAVE_SYNC_FUNCTIONS\n \n+/* Define to 1 if you have the <sys/ldr.h> header file. */\n+#undef HAVE_SYS_LDR_H\n+\n /* Define to 1 if you have the <sys/mman.h> header file. */\n #undef HAVE_SYS_MMAN_H\n "}, {"sha": "35767344f250288083a7c5d86d389531c26a065d", "filename": "libbacktrace/configure", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "patch": "@@ -12048,9 +12048,9 @@ elf*) FORMAT_FILE=\"elf.lo\" ;;\n pecoff) FORMAT_FILE=\"pecoff.lo\"\n         backtrace_supports_data=no\n \t;;\n-xcoff) FORMAT_FILE=\"xcoff.lo\"\n-       backtrace_supports_data=no\n-       ;;\n+xcoff*) FORMAT_FILE=\"xcoff.lo\"\n+        backtrace_supports_data=no\n+        ;;\n *) { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: could not determine output file type\" >&5\n $as_echo \"$as_me: WARNING: could not determine output file type\" >&2;}\n    FORMAT_FILE=\"unknown.lo\"\n@@ -12072,6 +12072,19 @@ cat >>confdefs.h <<_ACEOF\n _ACEOF\n \n \n+# XCOFF defines.\n+xcoffsize=\n+case \"$libbacktrace_cv_sys_filetype\" in\n+xcoff32) xcoffsize=32 ;;\n+xcoff64) xcoffsize=64 ;;\n+*)       xcoffsize=unused\n+esac\n+\n+cat >>confdefs.h <<_ACEOF\n+#define BACKTRACE_XCOFF_SIZE $xcoffsize\n+_ACEOF\n+\n+\n BACKTRACE_SUPPORTED=0\n if test \"$backtrace_supported\" = \"yes\"; then\n   BACKTRACE_SUPPORTED=1\n@@ -12610,6 +12623,53 @@ $as_echo \"#define HAVE_DL_ITERATE_PHDR 1\" >>confdefs.h\n \n fi\n \n+# Check for loadquery.\n+for ac_header in sys/ldr.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"sys/ldr.h\" \"ac_cv_header_sys_ldr_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_sys_ldr_h\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_SYS_LDR_H 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+if test \"$ac_cv_header_sys_ldr_h\" = \"no\"; then\n+  have_loadquery=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <sys/ldr.h>\n+\n+_ACEOF\n+if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n+  $EGREP \"loadquery\" >/dev/null 2>&1; then :\n+  have_loadquery=yes\n+else\n+  have_loadquery=no\n+fi\n+rm -f conftest*\n+\n+  else\n+    ac_fn_c_check_func \"$LINENO\" \"loadquery\" \"ac_cv_func_loadquery\"\n+if test \"x$ac_cv_func_loadquery\" = x\"\"yes; then :\n+  have_loadquery=yes\n+else\n+  have_loadquery=no\n+fi\n+\n+  fi\n+fi\n+if test \"$have_loadquery\" = \"yes\"; then\n+\n+$as_echo \"#define HAVE_LOADQUERY 1\" >>confdefs.h\n+\n+fi\n+\n # Check for the fcntl function.\n if test -n \"${with_target_subdir}\"; then\n    case \"${host}\" in"}, {"sha": "e644c7da796b719cafb226d8b6694d69d6868b4a", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "patch": "@@ -233,9 +233,9 @@ elf*) FORMAT_FILE=\"elf.lo\" ;;\n pecoff) FORMAT_FILE=\"pecoff.lo\"\n         backtrace_supports_data=no\n \t;;\n-xcoff) FORMAT_FILE=\"xcoff.lo\"\n-       backtrace_supports_data=no\n-       ;;\n+xcoff*) FORMAT_FILE=\"xcoff.lo\"\n+        backtrace_supports_data=no\n+        ;;\n *) AC_MSG_WARN([could not determine output file type])\n    FORMAT_FILE=\"unknown.lo\"\n    backtrace_supported=no\n@@ -252,6 +252,15 @@ elf64) elfsize=64 ;;\n esac\n AC_DEFINE_UNQUOTED([BACKTRACE_ELF_SIZE], [$elfsize], [ELF size: 32 or 64])\n \n+# XCOFF defines.\n+xcoffsize=\n+case \"$libbacktrace_cv_sys_filetype\" in\n+xcoff32) xcoffsize=32 ;;\n+xcoff64) xcoffsize=64 ;;\n+*)       xcoffsize=unused\n+esac\n+AC_DEFINE_UNQUOTED([BACKTRACE_XCOFF_SIZE], [$xcoffsize], [XCOFF size: 32 or 64])\n+\n BACKTRACE_SUPPORTED=0\n if test \"$backtrace_supported\" = \"yes\"; then\n   BACKTRACE_SUPPORTED=1\n@@ -330,6 +339,24 @@ if test \"$have_dl_iterate_phdr\" = \"yes\"; then\n   AC_DEFINE(HAVE_DL_ITERATE_PHDR, 1, [Define if dl_iterate_phdr is available.])\n fi\n \n+# Check for loadquery.\n+AC_CHECK_HEADERS(sys/ldr.h)\n+if test \"$ac_cv_header_sys_ldr_h\" = \"no\"; then\n+  have_loadquery=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.\n+    AC_EGREP_HEADER([loadquery], [sys/ldr.h], [have_loadquery=yes],\n+\t\t    [have_loadquery=no])\n+  else\n+    AC_CHECK_FUNC([loadquery], [have_loadquery=yes],\n+\t\t  [have_loadquery=no])\n+  fi\n+fi\n+if test \"$have_loadquery\" = \"yes\"; then\n+  AC_DEFINE(HAVE_LOADQUERY, 1, [Define if AIX loadquery is available.])\n+fi\n+\n # Check for the fcntl function.\n if test -n \"${with_target_subdir}\"; then\n    case \"${host}\" in"}, {"sha": "1471007d4ea6866f04c1c8fc770ad6ef233ebfef", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "patch": "@@ -70,7 +70,7 @@ dl_iterate_phdr (int (*callback) (struct dl_phdr_info *,\n    ELF.  We could make this code test and support either possibility,\n    but there is no point.  This code only works for the currently\n    running executable, which means that we know the ELF mode at\n-   configure mode.  */\n+   configure time.  */\n \n #if BACKTRACE_ELF_SIZE != 32 && BACKTRACE_ELF_SIZE != 64\n #error \"Unknown BACKTRACE_ELF_SIZE\""}, {"sha": "cf6e1b695d23c0861c0b7bf803df5b9e5a9d50cb", "filename": "libbacktrace/filetype.awk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ffiletype.awk?ref=7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "patch": "@@ -3,6 +3,6 @@\n /\\177ELF\\002/ { if (NR == 1) { print \"elf64\"; exit } }\n /\\114\\001/    { if (NR == 1) { print \"pecoff\"; exit } }\n /\\144\\206/    { if (NR == 1) { print \"pecoff\"; exit } }\n-/\\001\\337/    { if (NR == 1) { print \"xcoff\"; exit } }\n-/\\001\\367/    { if (NR == 1) { print \"xcoff\"; exit } }\n+/\\001\\337/    { if (NR == 1) { print \"xcoff32\"; exit } }\n+/\\001\\367/    { if (NR == 1) { print \"xcoff64\"; exit } }\n "}, {"sha": "76210733f015bd1691a99102cc07554c247681ff", "filename": "libbacktrace/xcoff.c", "status": "modified", "additions": 1432, "deletions": 24, "changes": 1456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Fxcoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2a8417f76b13f06c6a5e21a32e1b83d763d119/libbacktrace%2Fxcoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fxcoff.c?ref=7e2a8417f76b13f06c6a5e21a32e1b83d763d119", "patch": "@@ -1,5 +1,6 @@\n-/* xcoff.c -- Get debug data from a XCOFFF file for backtraces.\n-   Copyright (C) 2017 Free Software Foundation, Inc.\n+/* xcoff.c -- Get debug data from an XCOFF file for backtraces.\n+   Copyright (C) 2012-2017 Free Software Foundation, Inc.\n+   Adapted from elf.c.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n@@ -31,46 +32,1453 @@ POSSIBILITY OF SUCH DAMAGE.  */\n \n #include \"config.h\"\n \n+#include <errno.h>\n+#include <stdlib.h>\n+#include <string.h>\n #include <sys/types.h>\n \n+#ifdef HAVE_LOADQUERY\n+#include <sys/ldr.h>\n+#endif\n+\n #include \"backtrace.h\"\n #include \"internal.h\"\n \n-/* A trivial routine that always fails to find fileline data.  */\n+/* The configure script must tell us whether we are 32-bit or 64-bit\n+   XCOFF.  We could make this code test and support either possibility,\n+   but there is no point.  This code only works for the currently\n+   running executable, which means that we know the XCOFF mode at\n+   configure time.  */\n+\n+#if BACKTRACE_XCOFF_SIZE != 32 && BACKTRACE_XCOFF_SIZE != 64\n+#error \"Unknown BACKTRACE_XCOFF_SIZE\"\n+#endif\n+\n+/* XCOFF file header.  */\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\n+typedef struct {\n+  uint16_t f_magic;\n+  uint16_t f_nscns;\n+  uint32_t f_timdat;\n+  uint32_t f_symptr;\n+  uint32_t f_nsyms;\n+  uint16_t f_opthdr;\n+  uint16_t f_flags;\n+} b_xcoff_filhdr;\n+\n+#define XCOFF_MAGIC\t0737\n+\n+#else /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+typedef struct {\n+  uint16_t f_magic;\n+  uint16_t f_nscns;\n+  uint32_t f_timdat;\n+  uint64_t f_symptr;\n+  uint16_t f_opthdr;\n+  uint16_t f_flags;\n+  uint32_t f_nsyms;\n+} b_xcoff_filhdr;\n+\n+#define XCOFF_MAGIC\t0767\n+\n+#endif /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+#define F_SHROBJ\t0x2000\t/* File is a shared object.  */\n+\n+/* XCOFF section header.  */\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\n+typedef struct {\n+  char s_name[8];\n+  uint32_t s_paddr;\n+  uint32_t s_vaddr;\n+  uint32_t s_size;\n+  uint32_t s_scnptr;\n+  uint32_t s_relptr;\n+  uint32_t s_lnnoptr;\n+  uint16_t s_nreloc;\n+  uint16_t s_nlnno;\n+  uint32_t s_flags;\n+} b_xcoff_scnhdr;\n+\n+#define _OVERFLOW_MARKER\t65535\n+\n+#else /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+typedef struct {\n+  char name[8];\n+  uint64_t s_paddr;\n+  uint64_t s_vaddr;\n+  uint64_t s_size;\n+  uint64_t s_scnptr;\n+  uint64_t s_relptr;\n+  uint64_t s_lnnoptr;\n+  uint32_t s_nreloc;\n+  uint32_t s_nlnno;\n+  uint32_t s_flags;\n+} b_xcoff_scnhdr;\n+\n+#endif /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+#define STYP_TEXT\t0x20\t/* Executable text (code) section.  */\n+#define STYP_OVRFLO\t0x8000\t/* Line-number field overflow section.  */\n+\n+/* XCOFF symbol.  */\n+\n+#define SYMNMLEN\t8\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\n+typedef struct {\n+  union {\n+    char _name[SYMNMLEN];\n+    struct {\n+      uint32_t _zeroes;\n+      uint32_t _offset;\n+    } _s;\n+  } _u;\n+#define n_name\t\t_u._name\n+#define n_zeroes\t_u._s._zeroes\n+#define n_offset_\t_u._s._offset\n+\n+  uint32_t n_value;\n+  int16_t  n_scnum;\n+  uint16_t n_type;\n+  uint8_t  n_sclass;\n+  uint8_t  n_numaux;\n+} __attribute__ ((packed)) b_xcoff_syment;\n+\n+#else /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+typedef struct {\n+  uint64_t n_value;\n+  uint32_t n_offset_;\n+  int16_t  n_scnum;\n+  uint16_t n_type;\n+  uint8_t  n_sclass;\n+  uint8_t  n_numaux;\n+} __attribute__ ((packed)) b_xcoff_syment;\n+\n+#endif /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+#define SYMESZ\t18\n+\n+#define C_EXT\t\t2\t/* External symbol.  */\n+#define C_FCN\t\t101\t/* Beginning or end of function.  */\n+#define C_FILE\t\t103\t/* Source file name.  */\n+#define C_HIDEXT\t107\t/* Unnamed external symbol.  */\n+#define C_BINCL\t\t108\t/* Beginning of include file.  */\n+#define C_EINCL\t\t109\t/* End of include file.  */\n+#define C_WEAKEXT\t111\t/* Weak external symbol.  */\n+\n+#define ISFCN(x)\t((x) & 0x0020)\n+\n+/* XCOFF AUX entry.  */\n+\n+#define AUXESZ\t\t18\n+#define FILNMLEN\t14\n+\n+typedef union {\n+#if BACKTRACE_XCOFF_SIZE == 32\n+  struct {\n+    uint16_t pad;\n+    uint16_t x_lnnohi;\n+    uint16_t x_lnno;\n+  } x_block;\n+#else\n+  struct {\n+    uint32_t x_lnno;\n+  } x_block;\n+#endif\n+  union {\n+    char x_fname[FILNMLEN];\n+    struct {\n+      uint32_t x_zeroes;\n+      uint32_t x_offset;\n+      char     pad[FILNMLEN-8];\n+      uint8_t  x_ftype;\n+    } _x;\n+  } x_file;\n+#if BACKTRACE_XCOFF_SIZE == 32\n+  struct {\n+    uint32_t x_exptr;\n+    uint32_t x_fsize;\n+    uint32_t x_lnnoptr;\n+    uint32_t x_endndx;\n+  } x_fcn;\n+#else\n+  struct {\n+    uint64_t x_lnnoptr;\n+    uint32_t x_fsize;\n+    uint32_t x_endndx;\n+  } x_fcn;\n+#endif\n+  struct {\n+    uint8_t pad[AUXESZ-1];\n+    uint8_t x_auxtype;\n+  } x_auxtype;\n+} __attribute__ ((packed)) b_xcoff_auxent;\n+\n+/* XCOFF line number entry.  */\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\n+typedef struct {\n+  union {\n+    uint32_t l_symndx;\n+    uint32_t l_paddr;\n+  } l_addr;\n+  uint16_t l_lnno;\n+} b_xcoff_lineno;\n+\n+#define LINESZ\t6\n+\n+#else /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+typedef struct {\n+  union {\n+    uint32_t l_symndx;\n+    uint64_t l_paddr;\n+  } l_addr;\n+  uint32_t l_lnno;\n+} b_xcoff_lineno;\n+\n+#define LINESZ\t12\n+\n+#endif /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+#define XCOFF_AIX_TEXTBASE\t0x10000000u\n+#else\n+#define XCOFF_AIX_TEXTBASE\t0x100000000ul\n+#endif\n+\n+/* AIX big archive fixed-length header.  */\n+\n+#define AIAMAGBIG\t\"<bigaf>\\n\"\n+\n+typedef struct {\n+  char fl_magic[8];\t/* Archive magic string.  */\n+  char fl_memoff[20];\t/* Offset to member table.  */\n+  char fl_gstoff[20];\t/* Offset to global symbol table.  */\n+  char fl_gst64off[20];\t/* Offset to global symbol table for 64-bit objects.  */\n+  char fl_fstmoff[20];\t/* Offset to first archive member.  */\n+  char fl_freeoff[20];\t/* Offset to first member on free list.  */\n+} b_ar_fl_hdr;\n+\n+/* AIX big archive file member header.  */\n+\n+typedef struct {\n+  char ar_size[20];\t/* File member size - decimal.  */\n+  char ar_nxtmem[20];\t/* Next member offset - decimal.  */\n+  char ar_prvmem[20];\t/* Previous member offset - decimal.  */\n+  char ar_date[12];\t/* File member date - decimal.  */\n+  char ar_uid[12];\t/* File member userid - decimal.  */\n+  char ar_gid[12];\t/* File member group id - decimal.  */\n+  char ar_mode[12];\t/* File member mode - octal.  */\n+  char ar_namlen[4];\t/* File member name length - decimal.  */\n+  char ar_name[2];\t/* Start of member name.  */\n+} b_ar_hdr;\n+\n+\n+/* Information we keep for an XCOFF symbol.  */\n+\n+struct xcoff_symbol\n+{\n+  /* The name of the symbol.  */\n+  const char *name;\n+  /* The address of the symbol.  */\n+  uintptr_t address;\n+  /* The size of the symbol.  */\n+  size_t size;\n+};\n+\n+/* Information to pass to xcoff_syminfo.  */\n+\n+struct xcoff_syminfo_data\n+{\n+  /* Symbols for the next module.  */\n+  struct xcoff_syminfo_data *next;\n+  /* The XCOFF symbols, sorted by address.  */\n+  struct xcoff_symbol *symbols;\n+  /* The number of symbols.  */\n+  size_t count;\n+};\n+\n+/* Information about an include file.  */\n+\n+struct xcoff_incl\n+{\n+  /* File name.  */\n+  const char *filename;\n+  /* Offset to first line number from the include file.  */\n+  uintptr_t begin;\n+  /* Offset to last line number from the include file.  */\n+  uintptr_t end;\n+};\n+\n+/* A growable vector of include files information.  */\n+\n+struct xcoff_incl_vector\n+{\n+  /* Memory.  This is an array of struct xcoff_incl.  */\n+  struct backtrace_vector vec;\n+  /* Number of include files.  */\n+  size_t count;\n+};\n+\n+/* Map a single PC value to a file/function/line.  */\n+\n+struct xcoff_line\n+{\n+  /* PC.  */\n+  uintptr_t pc;\n+  /* File name.  Many entries in the array are expected to point to\n+     the same file name.  */\n+  const char *filename;\n+  /* Function name.  */\n+  const char *function;\n+  /* Line number.  */\n+  int lineno;\n+};\n+\n+/* A growable vector of line number information.  This is used while\n+   reading the line numbers.  */\n+\n+struct xcoff_line_vector\n+{\n+  /* Memory.  This is an array of struct xcoff_line.  */\n+  struct backtrace_vector vec;\n+  /* Number of valid mappings.  */\n+  size_t count;\n+};\n+\n+/* The information we need to map a PC to a file and line.  */\n+\n+struct xcoff_fileline_data\n+{\n+  /* The data for the next file we know about.  */\n+  struct xcoff_fileline_data *next;\n+  /* Line number information.  */\n+  struct xcoff_line_vector vec;\n+};\n+\n+\n+/* A dummy callback function used when we can't find any debug info.  */\n \n static int\n-xcoff_fileline (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\tuintptr_t pc, backtrace_full_callback callback,\n-\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-\t\tvoid *data)\n+xcoff_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t       uintptr_t pc ATTRIBUTE_UNUSED,\n+\t       backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t       backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in XCOFF executable\", -1);\n+  return 0;\n+}\n \n+/* A dummy callback function used when we can't find a symbol\n+   table.  */\n+\n+static void\n+xcoff_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t      uintptr_t addr ATTRIBUTE_UNUSED,\n+\t      backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+\t      backtrace_error_callback error_callback, void *data)\n {\n-  static char buf[32];\n+  error_callback (data, \"no symbol table in XCOFF executable\", -1);\n+}\n+\n+/* Compare struct xcoff_symbol for qsort.  */\n \n-  snprintf (buf, sizeof(buf), \"pc=0x%llx\", (unsigned long long) pc);\n-  return callback (data, pc, \"unknown_file\", 123, buf);\n+static int\n+xcoff_symbol_compare (const void *v1, const void *v2)\n+{\n+  const struct xcoff_symbol *e1 = (const struct xcoff_symbol *) v1;\n+  const struct xcoff_symbol *e2 = (const struct xcoff_symbol *) v2;\n+\n+  if (e1->address < e2->address)\n+    return -1;\n+  else if (e1->address > e2->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Compare an ADDR against an xcoff_symbol for bsearch.  */\n+\n+static int\n+xcoff_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct xcoff_symbol *entry = (const struct xcoff_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->address)\n+    return -1;\n+  else if ((entry->size == 0 && addr > entry->address)\n+\t   || (entry->size > 0 && addr >= entry->address + entry->size))\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Add XDATA to the list in STATE.  */\n+\n+static void\n+xcoff_add_syminfo_data (struct backtrace_state *state,\n+\t\t\tstruct xcoff_syminfo_data *xdata)\n+{\n+  if (!state->threaded)\n+    {\n+      struct xcoff_syminfo_data **pp;\n+\n+      for (pp = (struct xcoff_syminfo_data **) (void *) &state->syminfo_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = xdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct xcoff_syminfo_data **pp;\n+\n+\t  pp = (struct xcoff_syminfo_data **) (void *) &state->syminfo_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct xcoff_syminfo_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, xdata))\n+\t    break;\n+\t}\n+    }\n }\n \n+/* Return the symbol name and value for an ADDR.  */\n+\n static void\n xcoff_syminfo (struct backtrace_state *state ATTRIBUTE_UNUSED, uintptr_t addr,\n-               backtrace_syminfo_callback callback,\n-               backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-               void *data)\n+\t       backtrace_syminfo_callback callback,\n+\t       backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t       void *data)\n+{\n+  struct xcoff_syminfo_data *edata;\n+  struct xcoff_symbol *sym = NULL;\n+\n+  if (!state->threaded)\n+    {\n+      for (edata = (struct xcoff_syminfo_data *) state->syminfo_data;\n+\t   edata != NULL;\n+\t   edata = edata->next)\n+\t{\n+\t  sym = ((struct xcoff_symbol *)\n+\t\t bsearch (&addr, edata->symbols, edata->count,\n+\t\t\t  sizeof (struct xcoff_symbol), xcoff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      struct xcoff_syminfo_data **pp;\n+\n+      pp = (struct xcoff_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+\t{\n+\t  edata = backtrace_atomic_load_pointer (pp);\n+\t  if (edata == NULL)\n+\t    break;\n+\n+\t  sym = ((struct xcoff_symbol *)\n+\t\t bsearch (&addr, edata->symbols, edata->count,\n+\t\t\t  sizeof (struct xcoff_symbol), xcoff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\n+\t  pp = &edata->next;\n+\t}\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    callback (data, addr, sym->name, sym->address, sym->size);\n+}\n+\n+/* Return the name of an XCOFF symbol.  */\n+\n+static const char *\n+xcoff_symname (const b_xcoff_syment *asym,\n+\t       const unsigned char *strtab, size_t strtab_size)\n+{\n+#if BACKTRACE_XCOFF_SIZE == 32\n+  if (asym->n_zeroes != 0)\n+    {\n+      /* Make a copy as we will release the symtab view.  */\n+      char name[SYMNMLEN+1];\n+      strncpy (name, asym->n_name, SYMNMLEN);\n+      name[SYMNMLEN] = '\\0';\n+      return strdup (name);\n+    }\n+#endif\n+  if (asym->n_sclass & 0x80)\n+    return NULL; /* .debug */\n+  if (asym->n_offset_ >= strtab_size)\n+    return NULL;\n+  return (const char *) strtab + asym->n_offset_;\n+}\n+\n+/* Initialize the symbol table info for xcoff_syminfo.  */\n+\n+static int\n+xcoff_initialize_syminfo (struct backtrace_state *state,\n+\t\t\t  uintptr_t base_address,\n+\t\t\t  const b_xcoff_scnhdr *sects,\n+\t\t\t  const b_xcoff_syment *syms, size_t nsyms,\n+\t\t\t  const unsigned char *strtab, size_t strtab_size,\n+\t\t\t  backtrace_error_callback error_callback, void *data,\n+\t\t\t  struct xcoff_syminfo_data *sdata)\n+{\n+  size_t xcoff_symbol_count;\n+  size_t xcoff_symbol_size;\n+  struct xcoff_symbol *xcoff_symbols;\n+  size_t i;\n+  unsigned int j;\n+\n+  /* We only care about function symbols.  Count them.  */\n+  xcoff_symbol_count = 0;\n+  for (i = 0; i < nsyms; ++i)\n+    {\n+      const b_xcoff_syment *asym = &syms[i];\n+      if ((asym->n_sclass == C_EXT || asym->n_sclass == C_HIDEXT\n+\t    || asym->n_sclass == C_WEAKEXT)\n+\t  && ISFCN (asym->n_type) && asym->n_numaux > 0 && asym->n_scnum > 0)\n+\t++xcoff_symbol_count;\n+\n+      i += asym->n_numaux;\n+    }\n+\n+  xcoff_symbol_size = xcoff_symbol_count * sizeof (struct xcoff_symbol);\n+  xcoff_symbols = ((struct xcoff_symbol *)\n+\t\t   backtrace_alloc (state, xcoff_symbol_size, error_callback,\n+\t\t\t\t    data));\n+  if (xcoff_symbols == NULL)\n+    return 0;\n+\n+  j = 0;\n+  for (i = 0; i < nsyms; ++i)\n+    {\n+      const b_xcoff_syment *asym = &syms[i];\n+      if ((asym->n_sclass == C_EXT || asym->n_sclass == C_HIDEXT\n+\t    || asym->n_sclass == C_WEAKEXT)\n+\t  && ISFCN (asym->n_type) && asym->n_numaux > 0 && asym->n_scnum > 0)\n+\t{\n+\t  const b_xcoff_auxent *aux = (const b_xcoff_auxent *) (asym + 1);\n+\t  xcoff_symbols[j].name = xcoff_symname (asym, strtab, strtab_size);\n+\t  xcoff_symbols[j].address = base_address + asym->n_value\n+\t\t\t\t   - sects[asym->n_scnum - 1].s_paddr;\n+\t  /* x_fsize will be 0 if there is no debug information.  */\n+\t  xcoff_symbols[j].size = aux->x_fcn.x_fsize;\n+\t  ++j;\n+\t}\n+\n+      i += asym->n_numaux;\n+    }\n+\n+  backtrace_qsort (xcoff_symbols, xcoff_symbol_count,\n+\t\t   sizeof (struct xcoff_symbol), xcoff_symbol_compare);\n+\n+  sdata->next = NULL;\n+  sdata->symbols = xcoff_symbols;\n+  sdata->count = xcoff_symbol_count;\n+\n+  return 1;\n+}\n+\n+/* Compare struct xcoff_line for qsort.  */\n+\n+static int\n+xcoff_line_compare (const void *v1, const void *v2)\n+{\n+  const struct xcoff_line *ln1 = (const struct xcoff_line *) v1;\n+  const struct xcoff_line *ln2 = (const struct xcoff_line *) v2;\n+\n+  if (ln1->pc < ln2->pc)\n+    return -1;\n+  else if (ln1->pc > ln2->pc)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Find a PC in a line vector.  We always allocate an extra entry at\n+   the end of the lines vector, so that this routine can safely look\n+   at the next entry.  */\n+\n+static int\n+xcoff_line_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct xcoff_line *entry = (const struct xcoff_line *) ventry;\n+  uintptr_t pc;\n+\n+  pc = *key;\n+  if (pc < entry->pc)\n+    return -1;\n+  else if ((entry + 1)->pc == (uintptr_t) -1 || pc >= (entry + 1)->pc)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Look for a PC in the line vector for one module.  On success,\n+   call CALLBACK and return whatever it returns.  On error, call\n+   ERROR_CALLBACK and return 0.  Sets *FOUND to 1 if the PC is found,\n+   0 if not.  */\n+\n+static int\n+xcoff_lookup_pc (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t struct xcoff_fileline_data *fdata, uintptr_t pc,\n+\t\t backtrace_full_callback callback,\n+\t\t backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\t void *data, int *found)\n+{\n+  const struct xcoff_line *ln;\n+  const char *function;\n+\n+  *found = 1;\n+\n+  ln = (struct xcoff_line *) bsearch (&pc, fdata->vec.vec.base,\n+\t\t\t\t      fdata->vec.count,\n+\t\t\t\t      sizeof (struct xcoff_line),\n+\t\t\t\t      xcoff_line_search);\n+  if (ln == NULL)\n+    {\n+      *found = 0;\n+      return 0;\n+    }\n+\n+  function = ln->function;\n+  /* AIX prepends a '.' to function entry points, remove it.  */\n+  if (*function == '.')\n+    ++function;\n+  return callback (data, pc, ln->filename, ln->lineno, function);\n+}\n+\n+/* Return the file/line information for a PC using the XCOFF lineno\n+   mapping we built earlier.  */\n+\n+static int\n+xcoff_fileline (struct backtrace_state *state, uintptr_t pc,\n+\t\tbacktrace_full_callback callback,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+\n+{\n+  struct xcoff_fileline_data *fdata;\n+  int found;\n+  int ret;\n+\n+  if (!state->threaded)\n+    {\n+      for (fdata = (struct xcoff_fileline_data *) state->fileline_data;\n+\t   fdata != NULL;\n+\t   fdata = fdata->next)\n+\t{\n+\t  ret = xcoff_lookup_pc (state, fdata, pc, callback, error_callback,\n+\t\t\t\t data, &found);\n+\t  if (ret != 0 || found)\n+\t    return ret;\n+\t}\n+    }\n+  else\n+    {\n+      struct xcoff_fileline_data **pp;\n+\n+      pp = (struct xcoff_fileline_data **) (void *) &state->fileline_data;\n+      while (1)\n+\t{\n+\t  fdata = backtrace_atomic_load_pointer (pp);\n+\t  if (fdata == NULL)\n+\t    break;\n+\n+\t  ret = xcoff_lookup_pc (state, fdata, pc, callback, error_callback,\n+\t\t\t\t data, &found);\n+\t  if (ret != 0 || found)\n+\t    return ret;\n+\n+\t  pp = &fdata->next;\n+\t}\n+    }\n+\n+  /* FIXME: See if any libraries have been dlopen'ed.  */\n+\n+  return callback (data, pc, NULL, 0, NULL);\n+}\n+\n+/* Add a new mapping to the vector of line mappings that we are\n+   building.  Returns 1 on success, 0 on failure.  */\n+\n+static int\n+xcoff_add_line (struct backtrace_state *state, uintptr_t pc,\n+\t\tconst char *filename, const char *function, uint32_t lnno,\n+\t\tbacktrace_error_callback error_callback, void *data,\n+\t\tstruct xcoff_line_vector *vec)\n {\n-  callback (data, addr, \"unknown\", 0, 0);\n+  struct xcoff_line *ln;\n+\n+  ln = ((struct xcoff_line *)\n+\tbacktrace_vector_grow (state, sizeof (struct xcoff_line),\n+\t\t\t       error_callback, data, &vec->vec));\n+  if (ln == NULL)\n+    return 0;\n+\n+  ln->pc = pc;\n+  ln->filename = filename;\n+  ln->function = function;\n+  ln->lineno = lnno;\n+\n+  ++vec->count;\n+\n+  return 1;\n }\n \n-/* Initialize the backtrace data when we don't know how to read the\n-   debug info.  */\n+/* Add the line number entries for a function to the line vector.  */\n+\n+static int\n+xcoff_process_linenos (struct backtrace_state *state, uintptr_t base_address,\n+\t\t       const b_xcoff_syment *fsym, const char *filename,\n+\t\t       const b_xcoff_scnhdr *sects,\n+\t\t       const unsigned char *strtab, size_t strtab_size,\n+\t\t       uint32_t fcn_lnno, struct xcoff_incl_vector *vec,\n+\t\t       struct xcoff_line_vector *lvec,\n+\t\t       const unsigned char *linenos, size_t linenos_size,\n+\t\t       uintptr_t lnnoptr0,\n+\t\t       backtrace_error_callback error_callback, void *data)\n+{\n+  const b_xcoff_auxent *aux;\n+  const b_xcoff_lineno *lineno;\n+  const unsigned char *lineptr;\n+  const char *function;\n+  struct xcoff_incl *incl;\n+  uintptr_t lnnoptr;\n+  uintptr_t pc;\n+  uint32_t lnno;\n+  int begincl;\n+  size_t i;\n+\n+  aux = (const b_xcoff_auxent *) (fsym + 1);\n+  lnnoptr = aux->x_fcn.x_lnnoptr;\n+\n+  if (lnnoptr < lnnoptr0 || lnnoptr + LINESZ > lnnoptr0 + linenos_size)\n+    return 0;\n+\n+  function = xcoff_symname (fsym, strtab, strtab_size);\n+  if (function == NULL)\n+    return 0;\n+\n+  /* Skip first entry that points to symtab.  */\n+\n+  lnnoptr += LINESZ;\n+\n+  lineptr = linenos + (lnnoptr - lnnoptr0);\n+\n+  begincl = -1;\n+  while (lineptr + LINESZ <= linenos + linenos_size)\n+    {\n+      lineno = (const b_xcoff_lineno *) lineptr;\n+\n+      lnno = lineno->l_lnno;\n+      if (lnno == 0)\n+\t  break;\n+\n+      /* If part of a function other than the beginning comes from an\n+\t include file, the line numbers are absolute, rather than\n+\t relative to the beginning of the function.  */\n+      for (i = 0; i < vec->count; ++i)\n+\t{\n+\t  incl = (struct xcoff_incl *) vec->vec.base + i;\n+\t  if (incl->begin <= lnnoptr && lnnoptr <= incl->end)\n+\t    break;\n+\t}\n+      if (begincl == -1)\n+\tbegincl = (i < vec->count);\n+      if (i < vec->count)\n+\t{\n+\t  filename = incl->filename;\n+\t  if (begincl == 1)\n+\t    lnno += fcn_lnno - 1;\n+\t}\n+      else\n+\tlnno += fcn_lnno - 1;\n+\n+      pc = base_address + lineno->l_addr.l_paddr\n+\t - sects[fsym->n_scnum - 1].s_paddr;\n+      xcoff_add_line (state, pc, filename, function, lnno, error_callback,\n+\t\t      data, lvec);\n+\n+      lnnoptr += LINESZ;\n+      lineptr += LINESZ;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Initialize the line vector info for xcoff_fileline.  */\n+\n+static int\n+xcoff_initialize_fileline (struct backtrace_state *state,\n+\t\t\t   uintptr_t base_address,\n+\t\t\t   const b_xcoff_scnhdr *sects,\n+\t\t\t   const b_xcoff_syment *syms, size_t nsyms,\n+\t\t\t   const unsigned char *strtab, size_t strtab_size,\n+\t\t\t   const unsigned char *linenos, size_t linenos_size,\n+\t\t\t   uint64_t lnnoptr0,\n+\t\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  struct xcoff_fileline_data *fdata;\n+  struct xcoff_incl_vector vec;\n+  struct xcoff_line *ln;\n+  const b_xcoff_syment *fsym;\n+  const b_xcoff_auxent *aux;\n+  const char *filename;\n+  const char *name;\n+  struct xcoff_incl *incl;\n+  uintptr_t begin, end;\n+  uintptr_t lnno;\n+  size_t i;\n+\n+  fdata = ((struct xcoff_fileline_data *)\n+\t   backtrace_alloc (state, sizeof (struct xcoff_fileline_data),\n+\t\t\t    error_callback, data));\n+  if (fdata == NULL)\n+    return 0;\n+\n+  memset (fdata, 0, sizeof *fdata);\n+  memset (&vec, 0, sizeof vec);\n+\n+  /* Process include files first.  */\n+\n+  begin = 0;\n+  for (i = 0; i < nsyms; ++i)\n+    {\n+      const b_xcoff_syment *asym = &syms[i];\n+\n+      switch (asym->n_sclass)\n+\t{\n+\t  case C_BINCL:\n+\t    begin = asym->n_value;\n+\t    break;\n+\n+\t  case C_EINCL:\n+\t    if (begin == 0)\n+\t      break;\n+\t    end = asym->n_value;\n+\t    incl = ((struct xcoff_incl *)\n+\t\t    backtrace_vector_grow (state, sizeof (struct xcoff_incl),\n+\t\t\t\t\t   error_callback, data, &vec.vec));\n+\t    if (incl != NULL)\n+\t      {\n+\t\tincl->filename = xcoff_symname (asym, strtab, strtab_size);\n+\t\tincl->begin = begin;\n+\t\tincl->end = end;\n+\t\t++vec.count;\n+\t      }\n+\t    begin = 0;\n+\t    break;\n+\t}\n+\n+      i += asym->n_numaux;\n+    }\n+\n+  filename = NULL;\n+  fsym = NULL;\n+  for (i = 0; i < nsyms; ++i)\n+    {\n+      const b_xcoff_syment *asym = &syms[i];\n+\n+      switch (asym->n_sclass)\n+\t{\n+\t  case C_FILE:\n+\t    filename = xcoff_symname (asym, strtab, strtab_size);\n+\t    if (filename == NULL)\n+\t      break;\n+\n+\t    /* If the file auxiliary entry is not used, the symbol name is\n+\t       the name of the source file. If the file auxiliary entry is\n+\t       used, then the symbol name should be .file, and the first\n+\t       file auxiliary entry (by convention) contains the source\n+\t       file name.  */\n+\n+\t    if (asym->n_numaux > 0 && !strcmp (filename, \".file\"))\n+\t      {\n+\t\taux = (const b_xcoff_auxent *) (asym + 1);\n+\t\tif (aux->x_file._x.x_zeroes != 0)\n+\t\t  {\n+\t\t    /* Make a copy as we will release the symtab view.  */\n+\t\t    char name[FILNMLEN+1];\n+\t\t    strncpy (name, aux->x_file.x_fname, FILNMLEN);\n+\t\t    name[FILNMLEN] = '\\0';\n+\t\t    filename = strdup (name);\n+\t\t  }\n+\t\telse if (aux->x_file._x.x_offset < strtab_size)\n+\t\t  filename = (const char *) strtab + aux->x_file._x.x_offset;\n+\t\telse\n+\t\t  filename = NULL;\n+\t      }\n+\t    break;\n+\n+\t  case C_EXT:\n+\t  case C_HIDEXT:\n+\t  case C_WEAKEXT:\n+\t    fsym = NULL;\n+\t    if (!ISFCN (asym->n_type) || asym->n_numaux == 0)\n+\t      break;\n+\t    if (filename == NULL)\n+\t      break;\n+\t    fsym = asym;\n+\t    break;\n+\n+\t  case C_FCN:\n+\t    if (asym->n_numaux == 0)\n+\t      break;\n+\t    if (fsym == NULL)\n+\t      break;\n+\t    name = xcoff_symname (asym, strtab, strtab_size);\n+\t    if (name == NULL)\n+\t      break;\n+\t    aux = (const b_xcoff_auxent *) (asym + 1);\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\t    lnno = (uint32_t) aux->x_block.x_lnnohi << 16\n+\t\t | aux->x_block.x_lnno;\n+#else\n+\t    lnno = aux->x_block.x_lnno;\n+#endif\n+\t    if (!strcmp (name, \".bf\"))\n+\t      {\n+\t\txcoff_process_linenos (state, base_address, fsym, filename,\n+\t\t\t\t       sects, strtab, strtab_size, lnno, &vec,\n+\t\t\t\t       &fdata->vec, linenos, linenos_size,\n+\t\t\t\t       lnnoptr0, error_callback, data);\n+\t      }\n+\t    else if (!strcmp (name, \".ef\"))\n+\t      {\n+\t\tfsym = NULL;\n+\t      }\n+\t    break;\n+\t}\n+\n+      i += asym->n_numaux;\n+    }\n+\n+  /* Allocate one extra entry at the end.  */\n+  ln = ((struct xcoff_line *)\n+\tbacktrace_vector_grow (state, sizeof (struct xcoff_line),\n+\t\t\t       error_callback, data, &fdata->vec.vec));\n+  if (ln == NULL)\n+    goto fail;\n+  ln->pc = (uintptr_t) -1;\n+  ln->filename = NULL;\n+  ln->function = NULL;\n+  ln->lineno = 0;\n+\n+  if (!backtrace_vector_release (state, &fdata->vec.vec, error_callback, data))\n+    goto fail;\n+\n+  backtrace_qsort (fdata->vec.vec.base, fdata->vec.count,\n+\t\t   sizeof (struct xcoff_line), xcoff_line_compare);\n+\n+  if (!state->threaded)\n+    {\n+      struct xcoff_fileline_data **pp;\n+\n+      for (pp = (struct xcoff_fileline_data **) (void *) &state->fileline_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = fdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct xcoff_fileline_data **pp;\n+\n+\t  pp = (struct xcoff_fileline_data **) (void *) &state->fileline_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct xcoff_fileline_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, fdata))\n+\t    break;\n+\t}\n+    }\n+\n+  return 1;\n+\n+fail:\n+  return 0;\n+}\n+\n+/* Add the backtrace data for one XCOFF file.  Returns 1 on success,\n+   0 on failure (in both cases descriptor is closed).  */\n+\n+static int\n+xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n+\t   uintptr_t base_address, backtrace_error_callback error_callback,\n+\t   void *data, fileline *fileline_fn, int *found_sym, int exe)\n+{\n+  struct backtrace_view fhdr_view;\n+  struct backtrace_view sects_view;\n+  struct backtrace_view linenos_view;\n+  struct backtrace_view syms_view;\n+  struct backtrace_view str_view;\n+  b_xcoff_filhdr fhdr;\n+  const b_xcoff_scnhdr *sects;\n+  const b_xcoff_scnhdr *stext;\n+  uint64_t lnnoptr;\n+  uint32_t nlnno;\n+  off_t str_off;\n+  size_t sects_size;\n+  size_t syms_size;\n+  int32_t str_size;\n+  int sects_view_valid;\n+  int linenos_view_valid;\n+  int syms_view_valid;\n+  int str_view_valid;\n+  int magic_ok;\n+  int i;\n+\n+  *found_sym = 0;\n+\n+  sects_view_valid = 0;\n+  linenos_view_valid = 0;\n+  syms_view_valid = 0;\n+  str_view_valid = 0;\n+\n+  /* Map the XCOFF file header.  */\n+  if (!backtrace_get_view (state, descriptor, offset, sizeof (b_xcoff_filhdr),\n+\t\t\t   error_callback, data, &fhdr_view))\n+    goto fail;\n+\n+  memcpy (&fhdr, fhdr_view.data, sizeof fhdr);\n+  magic_ok = (fhdr.f_magic == XCOFF_MAGIC);\n+\n+  backtrace_release_view (state, &fhdr_view, error_callback, data);\n+\n+  if (!magic_ok)\n+    {\n+      if (exe)\n+        error_callback (data, \"executable file is not XCOFF\", 0);\n+      goto fail;\n+    }\n+\n+  /* Verify object is of expected type.  */\n+  if ((exe && (fhdr.f_flags & F_SHROBJ))\n+      || (!exe && !(fhdr.f_flags & F_SHROBJ)))\n+    goto fail;\n+\n+  /* Read the section headers.  */\n+\n+  sects_size = fhdr.f_nscns * sizeof (b_xcoff_scnhdr);\n+\n+  if (!backtrace_get_view (state, descriptor,\n+\t\t\t   offset + sizeof (fhdr) + fhdr.f_opthdr,\n+\t\t\t   sects_size, error_callback, data, &sects_view))\n+    goto fail;\n+  sects_view_valid = 1;\n+  sects = (const b_xcoff_scnhdr *) sects_view.data;\n+\n+  /* FIXME: assumes only one .text section.  */\n+  for (i = 0; i < fhdr.f_nscns; ++i)\n+      if ((sects[i].s_flags & 0xffff) == STYP_TEXT)\n+\t  break;\n+  if (i == fhdr.f_nscns)\n+    goto fail;\n+\n+  stext = &sects[i];\n+\n+  /* AIX ldinfo_textorg includes the XCOFF headers.  */\n+  base_address = (exe ? XCOFF_AIX_TEXTBASE : base_address) + stext->s_scnptr;\n+\n+  lnnoptr = stext->s_lnnoptr;\n+  nlnno = stext->s_nlnno;\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+  if (nlnno == _OVERFLOW_MARKER)\n+    {\n+      int sntext = i + 1;\n+      /* Find the matching .ovrflo section.  */\n+      for (i = 0; i < fhdr.f_nscns; ++i)\n+\t{\n+\t    if (((sects[i].s_flags & 0xffff) == STYP_OVRFLO)\n+\t\t&& sects[i].s_nlnno == sntext)\n+\t      {\n+\t\tnlnno = sects[i].s_vaddr;\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+#endif\n+\n+  /* Read the symbol table and the string table.  */\n+\n+  if (fhdr.f_symptr != 0)\n+    {\n+      struct xcoff_syminfo_data *sdata;\n+\n+      /* Symbol table is followed by the string table.  The string table\n+\t starts with its length (on 4 bytes).\n+\t Map the symbol table and the length of the string table.  */\n+      syms_size = fhdr.f_nsyms * sizeof (b_xcoff_syment);\n+\n+      if (!backtrace_get_view (state, descriptor, offset + fhdr.f_symptr,\n+\t\t\t       syms_size + 4, error_callback, data,\n+\t\t\t       &syms_view))\n+\tgoto fail;\n+      syms_view_valid = 1;\n+\n+      memcpy (&str_size, syms_view.data + syms_size, 4);\n+\n+      str_off = fhdr.f_symptr + syms_size;\n+\n+      if (str_size > 4)\n+\t{\n+\t  /* Map string table (including the length word).  */\n+\n+\t  if (!backtrace_get_view (state, descriptor, offset + str_off,\n+\t\t\t\t   str_size, error_callback, data, &str_view))\n+\t    goto fail;\n+\t  str_view_valid = 1;\n+\t}\n+\n+      sdata = ((struct xcoff_syminfo_data *)\n+\t       backtrace_alloc (state, sizeof *sdata, error_callback, data));\n+      if (sdata == NULL)\n+\tgoto fail;\n+\n+      if (!xcoff_initialize_syminfo (state, base_address, sects,\n+\t\t\t\t     syms_view.data, fhdr.f_nsyms,\n+\t\t\t\t     str_view.data, str_size,\n+\t\t\t\t     error_callback, data, sdata))\n+\t{\n+\t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n+\t  goto fail;\n+\t}\n+\n+      *found_sym = 1;\n+\n+      xcoff_add_syminfo_data (state, sdata);\n+    }\n+\n+  /* Read the line number entries.  */\n+\n+  if (fhdr.f_symptr != 0 && lnnoptr != 0)\n+    {\n+      size_t linenos_size = (size_t) nlnno * LINESZ;\n+\n+      if (!backtrace_get_view (state, descriptor, offset + lnnoptr,\n+\t\t\t       linenos_size,\n+\t\t\t       error_callback, data, &linenos_view))\n+\tgoto fail;\n+      linenos_view_valid = 1;\n+\n+      if (xcoff_initialize_fileline (state, base_address, sects,\n+\t\t\t\t     syms_view.data, fhdr.f_nsyms,\n+\t\t\t\t     str_view.data, str_size,\n+\t\t\t\t     linenos_view.data, linenos_size,\n+\t\t\t\t     lnnoptr, error_callback, data))\n+\t*fileline_fn = xcoff_fileline;\n+\n+      backtrace_release_view (state, &linenos_view, error_callback, data);\n+      linenos_view_valid = 0;\n+    }\n+\n+  backtrace_release_view (state, &sects_view, error_callback, data);\n+  sects_view_valid = 0;\n+  if (syms_view_valid)\n+    backtrace_release_view (state, &syms_view, error_callback, data);\n+  syms_view_valid = 0;\n+\n+  /* We've read all we need from the executable.  */\n+  if (!backtrace_close (descriptor, error_callback, data))\n+    goto fail;\n+  descriptor = -1;\n+\n+  return 1;\n+\n+ fail:\n+  if (sects_view_valid)\n+    backtrace_release_view (state, &sects_view, error_callback, data);\n+  if (str_view_valid)\n+    backtrace_release_view (state, &str_view, error_callback, data);\n+  if (syms_view_valid)\n+    backtrace_release_view (state, &syms_view, error_callback, data);\n+  if (linenos_view_valid)\n+    backtrace_release_view (state, &linenos_view, error_callback, data);\n+  if (descriptor != -1 && offset == 0)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+#ifdef HAVE_LOADQUERY\n+\n+/* Read an integer value in human-readable format from an AIX\n+   big archive fixed-length or member header.  */\n+\n+static int\n+xcoff_parse_decimal (const char *buf, size_t size, off_t *off)\n+{\n+  char str[32];\n+  char *end;\n+\n+  if (size >= sizeof str)\n+    return 0;\n+  memcpy (str, buf, size);\n+  str[size] = '\\0';\n+  *off = strtol (str, &end, 10);\n+  if (*end != '\\0' && *end != ' ')\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Add the backtrace data for a member of an AIX big archive.\n+   Returns 1 on success, 0 on failure.  */\n+\n+static int\n+xcoff_armem_add (struct backtrace_state *state, int descriptor,\n+\t\t uintptr_t base_address, const char *member,\n+\t\t backtrace_error_callback error_callback, void *data,\n+\t\t fileline *fileline_fn, int *found_sym)\n+{\n+  struct backtrace_view view;\n+  b_ar_fl_hdr fl_hdr;\n+  const b_ar_hdr *ar_hdr;\n+  off_t off;\n+  off_t len;\n+  int memlen;\n+\n+  *found_sym = 0;\n+\n+  /* Map archive fixed-length header.  */\n+\n+  if (!backtrace_get_view (state, descriptor, 0, sizeof (b_ar_fl_hdr),\n+\t\t\t   error_callback, data, &view))\n+    return 0;\n+\n+  memcpy (&fl_hdr, view.data, sizeof (b_ar_fl_hdr));\n+\n+  backtrace_release_view (state, &view, error_callback, data);\n+\n+  if (memcmp (fl_hdr.fl_magic, AIAMAGBIG, 8) != 0)\n+    return 0;\n+\n+  memlen = strlen (member);\n+\n+  /* Read offset of first archive member.  */\n+  if (!xcoff_parse_decimal (fl_hdr.fl_fstmoff, sizeof fl_hdr.fl_fstmoff, &off))\n+    return 0;\n+  while (off != 0)\n+    {\n+      /* Map archive member header and member name.  */\n+\n+      if (!backtrace_get_view (state, descriptor, off,\n+\t\t\t       sizeof (b_ar_hdr) + memlen,\n+\t\t\t       error_callback, data, &view))\n+\treturn 0;\n+\n+      ar_hdr = (const b_ar_hdr *) view.data;\n+\n+      /* Read archive member name length.  */\n+      if (!xcoff_parse_decimal (ar_hdr->ar_namlen, sizeof ar_hdr->ar_namlen,\n+\t\t\t\t&len))\n+\t{\n+\t  backtrace_release_view (state, &view, error_callback, data);\n+\t  break;\n+\t}\n+      if (len == memlen && !memcmp (ar_hdr->ar_name, member, memlen))\n+\t{\n+\t  off = (off + sizeof (b_ar_hdr) + memlen + 1) & ~1;\n+\n+\t  /* The archive can contain several members with the same name\n+\t     (e.g. 32-bit and 64-bit), so continue if not ok.  */\n+\n+\t  if (xcoff_add (state, descriptor, off, base_address, error_callback,\n+\t\t\t data, fileline_fn, found_sym, 0))\n+\t    {\n+\t      backtrace_release_view (state, &view, error_callback, data);\n+\t      return 1;\n+\t    }\n+\t}\n+\n+      /* Read offset of next archive member.  */\n+      if (!xcoff_parse_decimal (ar_hdr->ar_nxtmem, sizeof ar_hdr->ar_nxtmem,\n+\t\t\t\t&off))\n+\t{\n+\t  backtrace_release_view (state, &view, error_callback, data);\n+\t  break;\n+\t}\n+      backtrace_release_view (state, &view, error_callback, data);\n+    }\n+\n+  /* No matching member found.  */\n+  backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+/* Add the backtrace data for dynamically loaded libraries.  */\n+\n+static void\n+xcoff_add_shared_libs (struct backtrace_state *state,\n+\t\t       backtrace_error_callback error_callback,\n+\t\t       void *data, fileline *fileline_fn, int *found_sym)\n+{\n+  const struct ld_info *ldinfo;\n+  void *buf;\n+  unsigned int buflen;\n+  const char *member;\n+  int descriptor;\n+  int does_not_exist;\n+  int lib_found_sym;\n+  int ret;\n+\n+  /* Retrieve the list of loaded libraries.  */\n+\n+  buf = NULL;\n+  buflen = 512;\n+  do\n+    {\n+      buf = realloc (buf, buflen);\n+      if (buf == NULL)\n+\t{\n+\t  ret = -1;\n+\t  break;\n+\t}\n+      ret = loadquery (L_GETINFO, buf, buflen);\n+      if (ret == 0)\n+\tbreak;\n+      buflen *= 2;\n+    }\n+  while (ret == -1 && errno == ENOMEM);\n+  if (ret != 0)\n+    {\n+      free (buf);\n+      return;\n+    }\n+\n+  ldinfo = (const struct ld_info *) buf;\n+  while ((const char *) ldinfo < (const char *) buf + buflen)\n+    {\n+      if (*ldinfo->ldinfo_filename != '/')\n+\tgoto next;\n+\n+      descriptor = backtrace_open (ldinfo->ldinfo_filename, error_callback,\n+\t\t\t\t   data, &does_not_exist);\n+      if (descriptor < 0)\n+\tgoto next;\n+\n+      /* Check if it is an archive (member name not empty).  */\n+\n+      member = ldinfo->ldinfo_filename + strlen (ldinfo->ldinfo_filename) + 1;\n+      if (*member)\n+\t{\n+\t  xcoff_armem_add (state, descriptor,\n+\t\t\t   (uintptr_t) ldinfo->ldinfo_textorg, member,\n+\t\t\t   error_callback, data, fileline_fn, &lib_found_sym);\n+\t}\n+      else\n+\t{\n+\t  xcoff_add (state, descriptor, 0, (uintptr_t) ldinfo->ldinfo_textorg,\n+\t\t     error_callback, data, fileline_fn, &lib_found_sym, 0);\n+\t}\n+      if (lib_found_sym)\n+\t*found_sym = 1;\n+\n+ next:\n+      if (ldinfo->ldinfo_next == 0)\n+\tbreak;\n+      ldinfo = (const struct ld_info *) ((const char *) ldinfo\n+\t\t\t\t\t + ldinfo->ldinfo_next);\n+    }\n+\n+    free (buf);\n+}\n+#endif /* HAVE_LOADQUERY */\n+\n+/* Initialize the backtrace data we need from an XCOFF executable.\n+   Returns 1 on success, 0 on failure.  */\n \n int\n-backtrace_initialize (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t      int descriptor ATTRIBUTE_UNUSED,\n-\t\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-\t\t      void *data ATTRIBUTE_UNUSED, fileline *fileline_fn)\n-{\n-  state->syminfo_fn = xcoff_syminfo;\n-  state->fileline_data = NULL;\n-  *fileline_fn = xcoff_fileline;\n+backtrace_initialize (struct backtrace_state *state, int descriptor,\n+\t\t      backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  int ret;\n+  int found_sym;\n+  fileline xcoff_fileline_fn = xcoff_nodebug;\n+\n+  ret = xcoff_add (state, descriptor, 0, 0, error_callback, data,\n+\t\t   &xcoff_fileline_fn, &found_sym, 1);\n+  if (!ret)\n+    return 0;\n+\n+#ifdef HAVE_LOADQUERY\n+  xcoff_add_shared_libs (state, error_callback, data, &xcoff_fileline_fn,\n+\t\t\t &found_sym);\n+#endif\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = xcoff_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = xcoff_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, xcoff_syminfo);\n+      else\n+\t__sync_bool_compare_and_swap (&state->syminfo_fn, NULL, xcoff_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (state->fileline_fn == NULL || state->fileline_fn == xcoff_nodebug)\n+\t*fileline_fn = xcoff_fileline_fn;\n+    }\n+  else\n+    {\n+      fileline current_fn;\n+\n+      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+      if (current_fn == NULL || current_fn == xcoff_nodebug)\n+\t*fileline_fn = xcoff_fileline_fn;\n+    }\n+\n   return 1;\n }"}]}