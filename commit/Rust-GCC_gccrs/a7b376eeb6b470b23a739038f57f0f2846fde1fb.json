{"sha": "a7b376eeb6b470b23a739038f57f0f2846fde1fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdiMzc2ZWViNmI0NzBiMjNhNzM5MDM4ZjU3ZjBmMjg0NmZkZTFmYg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-02-20T02:26:06Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-02-20T02:26:06Z"}, "message": "c4x.md, [...]: Follow spelling conventions.\n\n\t* config/c4x/c4x.md, config/cris/cris.c, config/crx/crx.c,\n\tconfig/fr30/fr30.md, config/i386/i386.h,\n\tconfig/iq2000/iq2000.h, config/iq2000/predicates.md,\n\tconfig/pa/milli64.S, config/pa/pa.c, config/pa/pa.h,\n\tconfig/pa/pa.md, config/pa/pa32-regs.h, config/pa/pa64-regs.h,\n\tconfig/pdp11/pdp11.c, config/pdp11/pdp11.h,\n\tconfig/rs6000/altivec.md, config/rs6000/rs6000.c,\n\tconfig/s390/s390-modes.def, config/sparc/netbsd-elf.h,\n\tconfig/sparc/sparc.c, config/sparc/sparc.h,\n\tconfig/sparc/sparc.md, config/spu/constraints.md,\n\tconfig/spu/spu.c, config/stormy16/stormy16.md: Follow spelling\n\tconventions.\n\nFrom-SVN: r122151", "tree": {"sha": "c743bf814d7cb42b897746f31213730d00e36ae4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c743bf814d7cb42b897746f31213730d00e36ae4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7b376eeb6b470b23a739038f57f0f2846fde1fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7b376eeb6b470b23a739038f57f0f2846fde1fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7b376eeb6b470b23a739038f57f0f2846fde1fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7b376eeb6b470b23a739038f57f0f2846fde1fb/comments", "author": null, "committer": null, "parents": [{"sha": "a50aa827413db12b5a850b61f5a03546ac0381d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a50aa827413db12b5a850b61f5a03546ac0381d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a50aa827413db12b5a850b61f5a03546ac0381d3"}], "stats": {"total": 187, "additions": 100, "deletions": 87}, "files": [{"sha": "4af0ac0134657de6d69df209237d2967022c6398", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -6,6 +6,19 @@\n \tconfig/arc/arc.h, config/arm/arm.c, config/arm/arm.md,\n \tconfig/arm/lib1funcs.asm: Follow spelling conventions.\n \n+\t* config/c4x/c4x.md, config/cris/cris.c, config/crx/crx.c,\n+\tconfig/fr30/fr30.md, config/i386/i386.h,\n+\tconfig/iq2000/iq2000.h, config/iq2000/predicates.md,\n+\tconfig/pa/milli64.S, config/pa/pa.c, config/pa/pa.h,\n+\tconfig/pa/pa.md, config/pa/pa32-regs.h, config/pa/pa64-regs.h,\n+\tconfig/pdp11/pdp11.c, config/pdp11/pdp11.h,\n+\tconfig/rs6000/altivec.md, config/rs6000/rs6000.c,\n+\tconfig/s390/s390-modes.def, config/sparc/netbsd-elf.h,\n+\tconfig/sparc/sparc.c, config/sparc/sparc.h,\n+\tconfig/sparc/sparc.md, config/spu/constraints.md,\n+\tconfig/spu/spu.c, config/stormy16/stormy16.md: Follow spelling\n+\tconventions.\n+\n 2007-02-20  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/29943"}, {"sha": "1d2833f3a333be1f81ad5c393b9250c44d6cbb1c", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -29,7 +29,7 @@\n ;        for QImode and Pmode, whether Pmode was QImode or PQImode.\n ;        For addresses we wouldn't have to have a clobber of the CC\n ;        associated with each insn and we could use MPYI in address\n-;        calculations without having to synthesize a proper 32 bit multiply.\n+;        calculations without having to synthesize a proper 32-bit multiply.\n \n ; Additional C30/C40 instructions not coded:\n ; CALLcond, IACK, IDLE, LDE, LDFI, LDII, LDM, NORM, RETIcond\n@@ -123,7 +123,7 @@\n ; L   unsigned 16-bit\n ; M   unsigned 8-bit  (C4x only)\n ; N   ones complement of unsigned 16-bit\n-; O   16 bit high constant\n+; O   16-bit high constant\n ; Q   ARx + 9-bit signed disp\n ; R   ARx + 5-bit unsigned disp  (C4x only)\n ; S   ARx + 0, 1, IRx disp"}, {"sha": "2158295f9a49f1c3f878141957809bac096e37f4", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -1632,7 +1632,7 @@ cris_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t/* Eight or 16 bits are a word and cycle more expensive.  */\n \telse if (val <= 32767 && val >= -32768)\n \t  *total = 2;\n-\t/* A 32 bit constant (or very seldom, unsigned 16 bits) costs\n+\t/* A 32-bit constant (or very seldom, unsigned 16 bits) costs\n \t   another word.  FIXME: This isn't linear to 16 bits.  */\n \telse\n \t  *total = 4;"}, {"sha": "7b8efee42b05c60d80d46bb393e1875b34bcdd1a", "filename": "gcc/config/crx/crx.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -546,12 +546,12 @@ crx_function_arg_regno_p (int n)\n  * The following addressing modes are supported on CRX:\n  *\n  * Relocations\t\t--> const | symbol_ref | label_ref\n- * Absolute address\t--> 32 bit absolute\n- * Post increment\t--> reg + 12 bit disp.\n- * Post modify\t\t--> reg + 12 bit disp.\n- * Register relative\t--> reg | 32 bit disp. + reg | 4 bit + reg\n- * Scaled index\t\t--> reg + reg | 22 bit disp. + reg + reg |\n- *\t\t\t    22 disp. + reg + reg + (2 | 4 | 8) */\n+ * Absolute address\t--> 32-bit absolute\n+ * Post increment\t--> reg + 12-bit disp.\n+ * Post modify\t\t--> reg + 12-bit disp.\n+ * Register relative\t--> reg | 32-bit disp. + reg | 4 bit + reg\n+ * Scaled index\t\t--> reg + reg | 22-bit disp. + reg + reg |\n+ *\t\t\t    22-disp. + reg + reg + (2 | 4 | 8) */\n \n static int crx_addr_reg_p (rtx addr_reg)\n {"}, {"sha": "4e8e93acfa2f431f6c5739b5357547069c4c203e", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -746,7 +746,7 @@\n ;;}}}\n ;;{{{ Multiplication \n \n-;; Signed multiplication producing 64 bit results from 32 bit inputs\n+;; Signed multiplication producing 64-bit results from 32-bit inputs\n (define_insn \"mulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\"                             \"=r\")\n \t   (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n@@ -757,7 +757,7 @@\n   [(set_attr \"length\" \"6\")]\n )\n \n-;; Unsigned multiplication producing 64 bit results from 32 bit inputs\n+;; Unsigned multiplication producing 64-bit results from 32-bit inputs\n (define_insn \"umulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\"                             \"=r\")\n \t   (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n@@ -768,7 +768,7 @@\n   [(set_attr \"length\" \"6\")]\n )\n \n-;; Signed multiplication producing 32 bit result from 16 bit inputs\n+;; Signed multiplication producing 32-bit result from 16-bit inputs\n (define_insn \"mulhisi3\"\n   [(set (match_operand:SI 0 \"register_operand\"                             \"=r\")\n \t   (mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%r\"))\n@@ -779,7 +779,7 @@\n   [(set_attr \"length\" \"4\")]\n )\n \n-;; Unsigned multiplication producing 32 bit result from 16 bit inputs\n+;; Unsigned multiplication producing 32-bit result from 16-bit inputs\n (define_insn \"umulhisi3\"\n   [(set (match_operand:SI 0 \"register_operand\"                             \"=r\")\n \t   (mult:SI (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%r\"))\n@@ -790,7 +790,7 @@\n   [(set_attr \"length\" \"4\")]\n )\n \n-;; Signed multiplication producing 32 bit result from 32 bit inputs\n+;; Signed multiplication producing 32-bit result from 32-bit inputs\n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"             \"=r\")\n \t   (mult:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n@@ -884,7 +884,7 @@\n ;;}}} \f\n ;;{{{ Logical Operations \n \n-;; Logical AND, 32 bit integers\n+;; Logical AND, 32-bit integers\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"         \"=r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n@@ -894,7 +894,7 @@\n   \"and\t%1, %0\"\n )\n \n-;; Inclusive OR, 32 bit integers\n+;; Inclusive OR, 32-bit integers\n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"         \"=r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n@@ -904,7 +904,7 @@\n   \"or\t%1, %0\"\n )\n \n-;; Exclusive OR, 32 bit integers\n+;; Exclusive OR, 32-bit integers\n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"         \"=r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n@@ -914,7 +914,7 @@\n   \"eor\t%1, %0\"\n )\n \n-;; One's complement, 32 bit integers\n+;; One's complement, 32-bit integers\n (define_expand \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"register_operand\"         \"\")\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n@@ -1152,7 +1152,7 @@\n ;; far away the destination is.\n \n ;; The calculation for the instruction length is derived as follows:\n-;; The branch instruction has a 9 bit signed displacement so we have\n+;; The branch instruction has a 9-bit signed displacement so we have\n ;; this inequality for the displacement:\n ;;\n ;;               -256 <= pc < 256"}, {"sha": "4dab579130dc96c4fd98354c4b828307523c0062", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -1955,7 +1955,7 @@ do {\t\t\t\t\t\t\t\\\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n-/* In order to refer to the first 8 regs as 32 bit regs, prefix an \"e\".\n+/* In order to refer to the first 8 regs as 32-bit regs, prefix an \"e\".\n    For non floating point regs, the following are the HImode names.\n \n    For float regs, the stack top is sometimes referred to as \"%st(0)\""}, {"sha": "24ea3e0ba1dd1c479038419e1af1741b4a876c41", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -252,12 +252,12 @@ enum reg_class\n /* For IQ2000:\n \n    `I'\tis used for the range of constants an arithmetic insn can\n-\tactually contain (16 bits signed integers).\n+\tactually contain (16-bits signed integers).\n \n    `J'\tis used for the range which is just zero (i.e., $r0).\n \n    `K'\tis used for the range of constants a logical insn can actually\n-\tcontain (16 bit zero-extended integers).\n+\tcontain (16-bit zero-extended integers).\n \n    `L'\tis used for the range of constants that be loaded with lui\n \t(i.e., the bottom 16 bits are zero).\n@@ -267,7 +267,7 @@ enum reg_class\n \n    `N'\tis used for constants 0xffffnnnn or 0xnnnnffff\n \n-   `O'\tis a 5 bit zero-extended integer.  */\n+   `O'\tis a 5-bit zero-extended integer.  */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n   ((C) == 'I' ? ((unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000)\t\\"}, {"sha": "996d0ce8b34098bb6acd51f934bba339c3b4076c", "filename": "gcc/config/iq2000/predicates.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fiq2000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fiq2000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fpredicates.md?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -18,7 +18,7 @@\n ;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n ;; Boston, MA 02110-1301, USA.\n \n-;; Return 1 if OP can be used as an operand where a register or 16 bit\n+;; Return 1 if OP can be used as an operand where a register or 16-bit\n ;; unsigned integer is needed.\n \n (define_predicate \"uns_arith_operand\"\n@@ -30,7 +30,7 @@\n   return register_operand (op, mode);\n })\n \n-;; Return 1 if OP can be used as an operand where a 16 bit integer is\n+;; Return 1 if OP can be used as an operand where a 16-bit integer is\n ;; needed.\n \n (define_predicate \"arith_operand\"\n@@ -50,7 +50,7 @@\n   return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n })\n \n-;; Return 1 if OP is a 32 bit integer which is too big to be loaded\n+;; Return 1 if OP is a 32-bit integer which is too big to be loaded\n ;; with one instruction.\n \n (define_predicate \"large_int\""}, {"sha": "ffcafa30a6d83e757d09303529101d9a2f95203c", "filename": "gcc/config/pa/milli64.S", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fmilli64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fmilli64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fmilli64.S?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -411,7 +411,7 @@ LSYM(small_divisor)\n \n #if defined(pa64)\n /*  Clear the upper 32 bits of the arg1 register.  We are working with\t*/\n-/*  small divisors (and 32 bit integers)   We must not be mislead  */\n+/*  small divisors (and 32-bit integers)   We must not be mislead  */\n /*  by \"1\" bits left in the upper 32 bits.  */\n \tdepd %r0,31,32,%r25\n #endif\n@@ -626,7 +626,7 @@ LSYM(special_divisor)\n \n #if defined(pa64)\n /* Clear the upper 32 bits of the arg1 register.  We are working with\n-   small divisors (and 32 bit unsigned integers)   We must not be mislead\n+   small divisors (and 32-bit unsigned integers)   We must not be mislead\n    by \"1\" bits left in the upper 32 bits.  */\n \tdepd %r0,31,32,%r25\n #endif"}, {"sha": "e39ddc79a325a69fe311ff98c3b00443cde55ca4", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -576,7 +576,7 @@ adddi3_operand (rtx op, enum machine_mode mode)\n }\n \n /* True iff zdepi can be used to generate this CONST_INT.\n-   zdepi first sign extends a 5 bit signed number to a given field\n+   zdepi first sign extends a 5-bit signed number to a given field\n    length, then places this field anywhere in a zero.  */\n int\n zdepi_cint_p (unsigned HOST_WIDE_INT x)"}, {"sha": "60a724595817a246a8f84514939cf81408481a7e", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -487,10 +487,10 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n    C is the letter, and VALUE is a constant value.\n    Return 1 if VALUE is in the range specified by C.\n \n-   `I' is used for the 11 bit constants.\n-   `J' is used for the 14 bit constants.\n+   `I' is used for the 11-bit constants.\n+   `J' is used for the 14-bit constants.\n    `K' is used for values that can be moved with a zdepi insn.\n-   `L' is used for the 5 bit constants.\n+   `L' is used for the 5-bit constants.\n    `M' is used for 0.\n    `N' is used for values with the least significant 11 bits equal to zero\n \t                  and when sign extended from 32 to 64 bits the\n@@ -1321,7 +1321,7 @@ extern int may_call_alloca;\n    function's constant-pool, because such addresses can actually be\n    output as REG+SMALLINT. \n \n-   Note we only allow 5 bit immediates for access to a constant address;\n+   Note we only allow 5-bit immediates for access to a constant address;\n    doing so avoids losing for loading/storing a FP register at an address\n    which will not fit in 5 bits.  */\n "}, {"sha": "d686cb82b575eddb0d669e6176f78b5659c41af6", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -4638,7 +4638,7 @@\n   \"!TARGET_64BIT\"\n   \"*\n {\n-  /* Don't output a 64 bit constant, since we can't trust the assembler to\n+  /* Don't output a 64-bit constant, since we can't trust the assembler to\n      handle it correctly.  */\n   if (GET_CODE (operands[2]) == CONST_DOUBLE)\n     operands[2] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));"}, {"sha": "fa0f0f9c36efb0f3cd71614ee9d2601a5b1b08f7", "filename": "gcc/config/pa/pa32-regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa32-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa32-regs.h?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -15,7 +15,7 @@\n    HP-PA 1.1 has 32 fullword registers and 32 floating point\n    registers. However, the floating point registers behave\n    differently: the left and right halves of registers are addressable\n-   as 32 bit registers. So, we will set things up like the 68k which\n+   as 32-bit registers. So, we will set things up like the 68k which\n    has different fp units: define separate register sets for the 1.0\n    and 1.1 fp units.  */\n "}, {"sha": "e356407f8fd0480737fa4e2d169fec6d73ba6a6b", "filename": "gcc/config/pa/pa64-regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpa%2Fpa64-regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa64-regs.h?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -31,7 +31,7 @@ Boston, MA 02110-1301, USA.  */\n    HP-PA 2.0w has 32 fullword registers and 32 floating point\n    registers. However, the floating point registers behave\n    differently: the left and right halves of registers are addressable\n-   as 32 bit registers.\n+   as 32-bit registers.\n \n    Due to limitations within GCC itself, we do not expose the left/right\n    half addressability when in wide mode.  This is not a major performance"}, {"sha": "92320593d99f4df974582dbf7d38bf3d50a60d64", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -584,7 +584,7 @@ output_move_double (rtx *operands)\n \t    operands[1] = GEN_INT (INTVAL(operands[1]) & 0xff);\n \t}\n \telse\n-\t  /* immediate 32 bit values not allowed */\n+\t  /* immediate 32-bit values not allowed */\n \t  gcc_assert (GET_CODE (operands[1]) != CONST_DOUBLE);\n     }\n   else"}, {"sha": "a018914db4b6084c45f0fa85d14b7482863bc9ac", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -97,7 +97,7 @@ Boston, MA 02110-1301, USA.  */\n #define UNITS_PER_WORD 2\n \n /* This machine doesn't use IEEE floats.  */\n-/* Because the pdp11 (at least Unix) convention for 32 bit ints is\n+/* Because the pdp11 (at least Unix) convention for 32-bit ints is\n    big endian, opposite for what you need for float, the vax float\n    conversion routines aren't actually used directly.  But the underlying\n    format is indeed the vax/pdp11 float format.  */\n@@ -286,10 +286,10 @@ extern const struct real_format pdp11_d_format;\n    \n /* The pdp has a couple of classes:\n \n-MUL_REGS are used for odd numbered regs, to use in 16 bit multiplication\n-         (even numbered do 32 bit multiply)\n+MUL_REGS are used for odd numbered regs, to use in 16-bit multiplication\n+         (even numbered do 32-bit multiply)\n LMUL_REGS long multiply registers (even numbered regs )\n-\t  (don't need them, all 32 bit regs are even numbered!)\n+\t  (don't need them, all 32-bit regs are even numbered!)\n GENERAL_REGS is all cpu\n LOAD_FPU_REGS is the first four cpu regs, they are easier to load\n NO_LOAD_FPU_REGS is ac4 and ac5, currently - difficult to load them"}, {"sha": "006fcfbe3694ff50bacb3145fec2580bcec7738d", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -587,7 +587,7 @@\n   DONE;\n }\")\n \n-;; 32 bit integer multiplication\n+;; 32-bit integer multiplication\n ;; A_high = Operand_0 & 0xFFFF0000 >> 16\n ;; A_low = Operand_0 & 0xFFFF\n ;; B_high = Operand_1 & 0xFFFF0000 >> 16"}, {"sha": "ecedffd8fec69a547b910fe02b7da2dd49fa6309", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -3530,7 +3530,7 @@ rs6000_legitimize_tls_address (rtx addr, enum tls_model model)\n \t}\n       else\n \t{\n-\t  /* IE, or 64 bit offset LE.  */\n+\t  /* IE, or 64-bit offset LE.  */\n \t  tmp2 = gen_reg_rtx (Pmode);\n \t  if (TARGET_64BIT)\n \t    insn = gen_tls_got_tprel_64 (tmp2, got, addr);\n@@ -9271,22 +9271,22 @@ rs6000_common_init_builtins (void)\n \t       && mode3 == V4SImode)\n \ttype = v4sf_ftype_v4sf_v4sf_v4si;\n \n-      /* vchar, vchar, vchar, 4 bit literal.  */\n+      /* vchar, vchar, vchar, 4-bit literal.  */\n       else if (mode0 == V16QImode && mode1 == mode0 && mode2 == mode0\n \t       && mode3 == QImode)\n \ttype = v16qi_ftype_v16qi_v16qi_int;\n \n-      /* vshort, vshort, vshort, 4 bit literal.  */\n+      /* vshort, vshort, vshort, 4-bit literal.  */\n       else if (mode0 == V8HImode && mode1 == mode0 && mode2 == mode0\n \t       && mode3 == QImode)\n \ttype = v8hi_ftype_v8hi_v8hi_int;\n \n-      /* vint, vint, vint, 4 bit literal.  */\n+      /* vint, vint, vint, 4-bit literal.  */\n       else if (mode0 == V4SImode && mode1 == mode0 && mode2 == mode0\n \t       && mode3 == QImode)\n \ttype = v4si_ftype_v4si_v4si_int;\n \n-      /* vfloat, vfloat, vfloat, 4 bit literal.  */\n+      /* vfloat, vfloat, vfloat, 4-bit literal.  */\n       else if (mode0 == V4SFmode && mode1 == mode0 && mode2 == mode0\n \t       && mode3 == QImode)\n \ttype = v4sf_ftype_v4sf_v4sf_int;\n@@ -9390,23 +9390,23 @@ rs6000_common_init_builtins (void)\n       else if (mode0 == V4SImode && mode1 == V8HImode && mode2 == V4SImode)\n \ttype = v4si_ftype_v8hi_v4si;\n \n-      /* vint, vint, 5 bit literal.  */\n+      /* vint, vint, 5-bit literal.  */\n       else if (mode0 == V4SImode && mode1 == V4SImode && mode2 == QImode)\n \ttype = v4si_ftype_v4si_int;\n \n-      /* vshort, vshort, 5 bit literal.  */\n+      /* vshort, vshort, 5-bit literal.  */\n       else if (mode0 == V8HImode && mode1 == V8HImode && mode2 == QImode)\n \ttype = v8hi_ftype_v8hi_int;\n \n-      /* vchar, vchar, 5 bit literal.  */\n+      /* vchar, vchar, 5-bit literal.  */\n       else if (mode0 == V16QImode && mode1 == V16QImode && mode2 == QImode)\n \ttype = v16qi_ftype_v16qi_int;\n \n-      /* vfloat, vint, 5 bit literal.  */\n+      /* vfloat, vint, 5-bit literal.  */\n       else if (mode0 == V4SFmode && mode1 == V4SImode && mode2 == QImode)\n \ttype = v4sf_ftype_v4si_int;\n \n-      /* vint, vfloat, 5 bit literal.  */\n+      /* vint, vfloat, 5-bit literal.  */\n       else if (mode0 == V4SImode && mode1 == V4SFmode && mode2 == QImode)\n \ttype = v4si_ftype_v4sf_int;\n "}, {"sha": "fcc2657cf03ca5196dad532f5f0abaf2395c402a", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -119,7 +119,7 @@ information necessary for CCT1 and CCT2 modes.):\n \n CCSR, CCUR\n \n-There are several instructions comparing 32 bit with 64 bit unsigned/signed\n+There are several instructions comparing 32 bit with 64-bit unsigned/signed\n values. Such instructions can be considered to have a builtin zero/sign_extend.\n The problem is that in the RTL (to be canonical) the zero/sign extended operand \n has to be the first one but the machine instructions like it the other way "}, {"sha": "553005223109d6a95334e18daf75e8cf666b64d5", "filename": "gcc/config/sparc/netbsd-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fsparc%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fsparc%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fnetbsd-elf.h?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -85,7 +85,7 @@ Boston, MA 02110-1301, USA.  */\n #define TARGET_VERSION fprintf (stderr, \" (%s)\", TARGET_NAME);\n \n /* Below here exists the merged NetBSD/sparc & NetBSD/sparc64 compiler\n-   description, allowing one to build 32 bit or 64 bit applications\n+   description, allowing one to build 32-bit or 64-bit applications\n    on either.  We define the sparc & sparc64 versions of things,\n    occasionally a neutral version (should be the same as \"netbsd-elf.h\")\n    and then based on SPARC_BI_ARCH, DEFAULT_ARCH32_P, and TARGET_CPU_DEFAULT,"}, {"sha": "764beb946ea4aed69a153d6dae2b4be246cce894", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -3493,7 +3493,7 @@ mem_min_alignment (rtx mem, int desired)\n    hard register number, and one indexed by mode.  */\n \n /* The purpose of sparc_mode_class is to shrink the range of modes so that\n-   they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is\n+   they all fit (as bit numbers) in a 32-bit word (again).  Each real mode is\n    mapped into one sparc_mode_class mode.  */\n \n enum sparc_mode_class {"}, {"sha": "db0e34e516d18d6b49411cb9158ebc5ce841ded5", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -500,7 +500,7 @@ extern enum cmodel sparc_cmodel;\n /* TARGET_HARD_MUL: Use hardware multiply instructions but not %y.\n    TARGET_HARD_MUL32: Use hardware multiply instructions with rd %y\n    to get high 32 bits.  False in V8+ or V9 because multiply stores\n-   a 64 bit result in a register.  */\n+   a 64-bit result in a register.  */\n \n #define TARGET_HARD_MUL32\t\t\t\t\\\n   ((TARGET_V8 || TARGET_SPARCLITE\t\t\t\\\n@@ -708,7 +708,7 @@ if (TARGET_ARCH64\t\t\t\t\\\n    even those that are not normally considered general registers.\n \n    SPARC has 32 integer registers and 32 floating point registers.\n-   64 bit SPARC has 32 additional fp regs, but the odd numbered ones are not\n+   64-bit SPARC has 32 additional fp regs, but the odd numbered ones are not\n    accessible.  We still account for them to simplify register computations\n    (e.g.: in CLASS_MAX_NREGS).  There are also 4 fp condition code registers, so\n    32+32+32+4 == 100."}, {"sha": "387b3405db5d5b1358ccfff779e8738b33695070", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -1237,7 +1237,7 @@\n   \"TARGET_V9\n    && REGNO (operands[1]) == SPARC_ICC_REG\n    && (GET_MODE (operands[1]) == CCXmode\n-       /* 32 bit LTU/GEU are better implemented using addx/subx.  */\n+       /* 32-bit LTU/GEU are better implemented using addx/subx.  */\n        || (GET_CODE (operands[2]) != LTU && GET_CODE (operands[2]) != GEU))\"\n   [(set (match_dup 0) (const_int 0))\n    (set (match_dup 0)\n@@ -4592,7 +4592,7 @@\n \n ;; Integer multiply/divide instructions.\n \n-;; The 32 bit multiply/divide instructions are deprecated on v9, but at\n+;; The 32-bit multiply/divide instructions are deprecated on v9, but at\n ;; least in UltraSPARC I, II and IIi it is a win tick-wise.\n \n (define_insn \"mulsi3\"\n@@ -4699,8 +4699,8 @@\n     }\n })\n \n-;; V9 puts the 64 bit product in a 64 bit register.  Only out or global\n-;; registers can hold 64 bit values in the V8plus environment.\n+;; V9 puts the 64-bit product in a 64-bit register.  Only out or global\n+;; registers can hold 64-bit values in the V8plus environment.\n ;; XXX\n (define_insn \"mulsidi3_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=h,r\")"}, {"sha": "abc319b4ff5434defb864cf4f68db324135928df", "filename": "gcc/config/spu/constraints.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fspu%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fspu%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fconstraints.md?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -25,23 +25,23 @@\n ;; another treats it as 64 bit, and the third sign extends it to 128 bit.\n \n (define_constraint \"A\"\n-  \"An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 32 bit value.\"\n+  \"An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 32-bit value.\"\n   (ior (and (match_code \"const_int,const_double,const_vector\")\n \t    (match_test \"immediate_load_p (op, SImode)\"))\n        (match_code \"symbol_ref,label_ref,high,const\")))\n \n (define_constraint \"B\"\n-  \"An immediate for arithmetic instructions (e.g., ai, ceqi).  const_int is treated as a 32 bit value.\"\n+  \"An immediate for arithmetic instructions (e.g., ai, ceqi).  const_int is treated as a 32-bit value.\"\n   (and (match_code \"const_int,const_double,const_vector\")\n        (match_test \"arith_immediate_p (op, SImode, -0x200, 0x1ff)\")))\n \n (define_constraint \"C\"\n-  \"An immediate for and/xor/or instructions.  const_int is treated as a 32 bit value.\"\n+  \"An immediate for and/xor/or instructions.  const_int is treated as a 32-bit value.\"\n   (and (match_code \"const_int,const_double,const_vector\")\n        (match_test \"logical_immediate_p (op, SImode)\")))\n \n (define_constraint \"D\"\n-  \"An immediate for iohl instruction.  const_int is treated as a 32 bit value.\"\n+  \"An immediate for iohl instruction.  const_int is treated as a 32-bit value.\"\n   (and (match_code \"const_int,const_double,const_vector\")\n        (match_test \"iohl_immediate_p (op, SImode)\")))\n \n@@ -51,7 +51,7 @@\n        (match_test \"immediate_load_p (op, TImode)\")))\n \n (define_constraint \"W\"\n-  \"An immediate for shift and rotate instructions.  const_int is treated as a 32 bit value.\"\n+  \"An immediate for shift and rotate instructions.  const_int is treated as a 32-bit value.\"\n   (and (match_code \"const_int,const_double,const_vector\")\n        (match_test \"arith_immediate_p (op, SImode, -0x40, 0x3f)\")))\n \n@@ -66,17 +66,17 @@\n        (match_test \"iohl_immediate_p (op, TImode)\")))\n \n (define_constraint \"a\"\n-  \"An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 64 bit value.\"\n+  \"An immediate which can be loaded with the il/ila/ilh/ilhu instructions.  const_int is treated as a 64-bit value.\"\n   (and (match_code \"const_int\")\n        (match_test \"immediate_load_p (op, DImode)\")))\n \n (define_constraint \"c\"\n-  \"An immediate for and/xor/or instructions.  const_int is treated as a 64 bit value.\"\n+  \"An immediate for and/xor/or instructions.  const_int is treated as a 64-bit value.\"\n   (and (match_code \"const_int\")\n        (match_test \"logical_immediate_p (op, DImode)\")))\n \n (define_constraint \"d\"\n-  \"An immediate for iohl instruction.  const_int is treated as a 64 bit value.\"\n+  \"An immediate for iohl instruction.  const_int is treated as a 64-bit value.\"\n   (and (match_code \"const_int\")\n        (match_test \"iohl_immediate_p (op, DImode)\")))\n \n@@ -86,12 +86,12 @@\n        (match_test \"fsmbi_const_p (op)\")))\n \n (define_constraint \"j\"\n-  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.  const_int is treated as a 32 bit value.\"\n+  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.  const_int is treated as a 32-bit value.\"\n   (and (match_code \"const_int,const_double,const_vector\")\n        (match_test \"cpat_const_p (op, SImode)\")))\n \n (define_constraint \"k\"\n-  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.  const_int is treated as a 64 bit value.\"\n+  \"An immediate which can be loaded with one of the cbd/chd/cwd/cdd instructions.  const_int is treated as a 64-bit value.\"\n   (and (match_code \"const_int,const_double,const_vector\")\n        (match_test \"cpat_const_p (op, DImode)\")))\n \n@@ -119,7 +119,7 @@\n        (match_test \"ival >= -0x200 && ival <= 0x1ff\")))\n  \n (define_constraint \"M\"\n-  \"A signed 16 bit immediate for @code{stop}.\"\n+  \"A signed 16-bit immediate for @code{stop}.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival >= -0x8000ll && ival <= 0x7fffll\")))\n "}, {"sha": "9adeacf20882202949a36f80cebd8949e01c3fc8", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -1969,7 +1969,7 @@ insert_branch_hints (void)\n        because they are only at the end of a block and are\n        considered when we are deciding whether to propagate\n        - we're getting too far away from the branch.  The hbr insns\n-       only have a signed 10 bit offset\n+       only have a signed 10-bit offset\n        We go back as far as possible so the branch will be considered\n        for propagation when we get to the beginning of the block.  */\n     next = 0;\n@@ -2280,7 +2280,7 @@ legitimate_const (rtx x, int aligned)\n {\n   /* We can never know if the resulting address fits in 18 bits and can be\n      loaded with ila.  Instead we should use the HI and LO relocations to\n-     load a 32 bit address. */\n+     load a 32-bit address.  */\n   rtx sym, cst;\n \n   gcc_assert (GET_CODE (x) == CONST);\n@@ -2588,11 +2588,11 @@ arith_immediate_p (rtx op, enum machine_mode mode,\n }\n \n /* We accept:\n-   - any 32 bit constant (SImode, SFmode)\n+   - any 32-bit constant (SImode, SFmode)\n    - any constant that can be generated with fsmbi (any mode)\n-   - a 64 bit constant where the high and low bits are identical\n+   - a 64-bit constant where the high and low bits are identical\n      (DImode, DFmode)\n-   - a 128 bit constant where the four 32 bit words match. */\n+   - a 128-bit constant where the four 32-bit words match.  */\n int\n spu_legitimate_constant_p (rtx x)\n {"}, {"sha": "3a85345f1d74f0f6b16ce9ed8be588304b773814", "filename": "gcc/config/stormy16/stormy16.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b376eeb6b470b23a739038f57f0f2846fde1fb/gcc%2Fconfig%2Fstormy16%2Fstormy16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.md?ref=a7b376eeb6b470b23a739038f57f0f2846fde1fb", "patch": "@@ -300,7 +300,7 @@\n \f\n ;; ::::::::::::::::::::\n ;; ::\n-;; :: 16 bit Integer arithmetic\n+;; :: 16-bit Integer arithmetic\n ;; ::\n ;; ::::::::::::::::::::\n \n@@ -449,7 +449,7 @@\n   \"mul\"\n   [(set_attr \"psw_operand\" \"nop\")])\n \n-;; Unsigned multiplication producing 64 bit results from 32 bit inputs\n+;; Unsigned multiplication producing 64-bit results from 32-bit inputs\n ; The constraint on operand 0 is 't' because it is actually two regs\n ; long, and both regs must match the constraint.\n (define_insn \"umulhisi3\"\n@@ -522,7 +522,7 @@\n \f\n ;; ::::::::::::::::::::\n ;; ::\n-;; :: 16 bit Integer Shifts and Rotates\n+;; :: 16-bit Integer Shifts and Rotates\n ;; ::\n ;; ::::::::::::::::::::\n \n@@ -556,11 +556,11 @@\n \f\n ;; ::::::::::::::::::::\n ;; ::\n-;; :: 16 Bit Integer Logical operations\n+;; :: 16-Bit Integer Logical operations\n ;; ::\n ;; ::::::::::::::::::::\n \n-;; Logical AND, 16 bit integers\n+;; Logical AND, 16-bit integers\n (define_insn \"andhi3\"\n   [(set (match_operand:HI 0 \"xstormy16_splittable_below100_or_register\" \"=T,r,r,r,W\")\n \t(and:HI (match_operand:HI 1 \"xstormy16_below100_or_register\" \"%0,0,0,0,0\")\n@@ -590,7 +590,7 @@\n    }\n \")\n \n-;; Inclusive OR, 16 bit integers\n+;; Inclusive OR, 16-bit integers\n (define_insn \"iorhi3\"\n   [(set (match_operand:HI 0 \"xstormy16_splittable_below100_or_register\" \"=T,r,r,r,W\")\n \t(ior:HI (match_operand:HI 1 \"xstormy16_below100_or_register\" \"%0,0,0,0,0\")\n@@ -620,7 +620,7 @@\n    }\n \")\n \n-;; Exclusive OR, 16 bit integers\n+;; Exclusive OR, 16-bit integers\n (define_insn \"xorhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=T,r,r\")\n \t(xor:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0\")\n@@ -632,7 +632,7 @@\n    xor %0,%2\"\n   [(set_attr \"length\" \"2,2,4\")])\n \n-;; One's complement, 16 bit integers\n+;; One's complement, 16-bit integers\n (define_insn \"one_cmplhi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(not:HI (match_operand:HI 1 \"register_operand\" \"0\")))]\n@@ -642,7 +642,7 @@\n \f\n ;; ::::::::::::::::::::\n ;; ::\n-;; :: 32 bit Integer arithmetic\n+;; :: 32-bit Integer arithmetic\n ;; ::\n ;; ::::::::::::::::::::\n \n@@ -695,7 +695,7 @@\n \n ;; ::::::::::::::::::::\n ;; ::\n-;; :: 32 bit Integer Shifts and Rotates\n+;; :: 32-bit Integer Shifts and Rotates\n ;; ::\n ;; ::::::::::::::::::::\n "}]}