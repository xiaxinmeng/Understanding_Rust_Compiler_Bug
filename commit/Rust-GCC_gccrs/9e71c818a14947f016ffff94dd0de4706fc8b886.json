{"sha": "9e71c818a14947f016ffff94dd0de4706fc8b886", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU3MWM4MThhMTQ5NDdmMDE2ZmZmZjk0ZGQwZGU0NzA2ZmM4Yjg4Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-05-18T13:43:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-05-18T13:43:27Z"}, "message": "gcse.c (try_replace_reg): First try global replace, later try to simplify the expression.\n\n\t* gcse.c (try_replace_reg): First try global replace, later try to\n\tsimplify the expression.\n\n\t* gcse.c (find_used_regs): Change calling convention; work via\n\tnote_uses.\n\t(cprop_insn): Update call of find_used_regs; work for CALL_INSNs too.\n\nFrom-SVN: r42264", "tree": {"sha": "fd5846a3b1ca6d826a86075e01324dfbf0e3b6ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd5846a3b1ca6d826a86075e01324dfbf0e3b6ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e71c818a14947f016ffff94dd0de4706fc8b886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e71c818a14947f016ffff94dd0de4706fc8b886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e71c818a14947f016ffff94dd0de4706fc8b886", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e71c818a14947f016ffff94dd0de4706fc8b886/comments", "author": null, "committer": null, "parents": [{"sha": "24cdff345943891ddb12d2e302ba47a3258a7692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24cdff345943891ddb12d2e302ba47a3258a7692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24cdff345943891ddb12d2e302ba47a3258a7692"}], "stats": {"total": 86, "additions": 28, "deletions": 58}, "files": [{"sha": "3facb8822d2f52b55d0694d397a0f6f139400e8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e71c818a14947f016ffff94dd0de4706fc8b886/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e71c818a14947f016ffff94dd0de4706fc8b886/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e71c818a14947f016ffff94dd0de4706fc8b886", "patch": "@@ -1,3 +1,12 @@\n+Fri May 18 15:39:16 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcse.c (try_replace_reg): First try global replace, later try to\n+\tsimplify the expression.\n+\n+\t* gcse.c (find_used_regs): Change calling convention; work via\n+\tnote_uses.\n+\t(cprop_insn): Update call of find_used_regs; work for CALL_INSNs too.\n+\n 2001-05-18  Bernd Schmidt  <bernds@redhat.com>\n \n \tRevert"}, {"sha": "2b1bdee68b3eead9f950619e92c4b4b1d57672d7", "filename": "gcc/gcse.c", "status": "modified", "additions": 19, "deletions": 58, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e71c818a14947f016ffff94dd0de4706fc8b886/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e71c818a14947f016ffff94dd0de4706fc8b886/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=9e71c818a14947f016ffff94dd0de4706fc8b886", "patch": "@@ -616,7 +616,7 @@ static void compute_transpout\tPARAMS ((void));\n static void compute_local_properties PARAMS ((sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t\t      int));\n static void compute_cprop_data\tPARAMS ((void));\n-static void find_used_regs\tPARAMS ((rtx));\n+static void find_used_regs\tPARAMS ((rtx *, void *));\n static int try_replace_reg\tPARAMS ((rtx, rtx, rtx));\n static struct expr *find_avail_set PARAMS ((int, rtx));\n static int cprop_jump\t\tPARAMS ((rtx, rtx, rtx));\n@@ -3937,56 +3937,29 @@ static int reg_use_count;\n    This doesn't hurt anything but it will slow things down.  */\n \n static void\n-find_used_regs (x)\n-     rtx x;\n+find_used_regs (xptr, data)\n+     rtx *xptr;\n+     void *data ATTRIBUTE_UNUSED;\n {\n   int i, j;\n   enum rtx_code code;\n   const char *fmt;\n+  rtx x = *xptr;\n \n   /* repeat is used to turn tail-recursion into iteration since GCC\n      can't do it when there's no return value.  */\n  repeat:\n-\n   if (x == 0)\n     return;\n \n   code = GET_CODE (x);\n-  switch (code)\n+  if (REG_P (x))\n     {\n-    case REG:\n       if (reg_use_count == MAX_USES)\n \treturn;\n \n       reg_use_table[reg_use_count].reg_rtx = x;\n       reg_use_count++;\n-      return;\n-\n-    case MEM:\n-      x = XEXP (x, 0);\n-      goto repeat;\n-\n-    case PC:\n-    case CC0:\n-    case CONST:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CLOBBER:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-    case ASM_INPUT: /*FIXME*/\n-      return;\n-\n-    case SET:\n-      if (GET_CODE (SET_DEST (x)) == MEM)\n-\tfind_used_regs (SET_DEST (x));\n-      x = SET_SRC (x);\n-      goto repeat;\n-\n-    default:\n-      break;\n     }\n \n   /* Recursively scan the operands of this expression.  */\n@@ -4004,11 +3977,11 @@ find_used_regs (x)\n \t      goto repeat;\n \t    }\n \n-\t  find_used_regs (XEXP (x, i));\n+\t  find_used_regs (&XEXP (x, i), data);\n \t}\n       else if (fmt[i] == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  find_used_regs (XVECEXP (x, i, j));\n+\t  find_used_regs (&XVECEXP (x, i, j), data);\n     }\n }\n \n@@ -4024,30 +3997,20 @@ try_replace_reg (from, to, insn)\n   int success = 0;\n   rtx set = single_set (insn);\n \n-  /* If this is a single set, try to simplify the source of the set given\n-     our substitution.  We could perhaps try this for multiple SETs, but\n-     it probably won't buy us anything.  */\n-  if (set != 0)\n+  success = validate_replace_src (from, to, insn);\n+\n+  /* If above failed and this is a single set, try to simplify the source of\n+     the set given our substitution.  We could perhaps try this for multiple\n+     SETs, but it probably won't buy us anything.  */\n+  if (!success && set != 0)\n     {\n       src = simplify_replace_rtx (SET_SRC (set), from, to);\n \n-      /* Try this two ways: first just replace SET_SRC.  If that doesn't\n-\t work and this is a PARALLEL, try to replace the whole pattern\n-\t with a new SET.  */\n-      if (validate_change (insn, &SET_SRC (set), src, 0))\n-\tsuccess = 1;\n-      else if (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t       && validate_change (insn, &PATTERN (insn),\n-\t\t\t\t   gen_rtx_SET (VOIDmode, SET_DEST (set),\n-\t\t\t\t\t\tsrc),\n-\t\t\t\t   0))\n+      if (!rtx_equal_p (src, SET_SRC (set))\n+\t  && validate_change (insn, &SET_SRC (set), src, 0))\n \tsuccess = 1;\n     }\n \n-  /* Otherwise, try to do a global replacement within the insn.  */\n-  if (!success)\n-    success = validate_replace_src (from, to, insn);\n-\n   /* If we've failed to do replacement, have a single SET, and don't already\n      have a note, add a REG_EQUAL note to not lose information.  */\n   if (!success && note == 0 && set != 0)\n@@ -4237,19 +4200,17 @@ cprop_insn (insn, alter_jumps)\n   int changed = 0;\n   rtx note;\n \n-  /* Only propagate into SETs.  Note that a conditional jump is a\n-     SET with pc_rtx as the destination.  */\n-  if (GET_CODE (insn) != INSN && GET_CODE (insn) != JUMP_INSN)\n+  if (!INSN_P (insn))\n     return 0;\n \n   reg_use_count = 0;\n-  find_used_regs (PATTERN (insn));\n+  note_uses (&PATTERN (insn), find_used_regs, NULL);\n   \n   note = find_reg_equal_equiv_note (insn);\n \n   /* We may win even when propagating constants into notes. */\n   if (note)\n-    find_used_regs (XEXP (note, 0));\n+    find_used_regs (&XEXP (note, 0), NULL);\n \n   for (reg_used = &reg_use_table[0]; reg_use_count > 0;\n        reg_used++, reg_use_count--)"}]}