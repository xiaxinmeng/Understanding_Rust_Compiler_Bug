{"sha": "d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI4ODhmMWRkZTVmNmI4NGEwZDAyYzlmZTRjZjUyYjFjYjg4Y2Y4Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-02-14T12:45:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-02-14T12:45:52Z"}, "message": "* config/mips/mips.h (MASK_DEBUG_[ABEFI], TARGET_DEBUG_[ABEFI]_MODE)\n\t(TARGET_MIPS4100, TARGET_MIPS4300, TARGET_MIPS4KC, TARGET_MIPS5KC)\n\t(TARGET_SB1, TUNE_SB1, TUNE_SR71K, BIGGEST_MAX_ARGS_IN_REGISTERS)\n\t(GO_PRINTF, GO_PRINTF2, GO_DEBUG_RTX, DFMODE_NAN, SFMODE_NAN): Delete.\n\t(TARGET_SWITCHES): Remove MASK_DEBUG_[ABEFI].\n\t* config/mips/mips.c: Fix some overly-long lines.\n\t(SINGLE_WORD_MODE_P, PIC_OFFSET_TABLE_MASK): Delete.\n\t(init_cumulative_args): Remove TARGET_DEBUG_E_MODE handling.\n\nFrom-SVN: r77800", "tree": {"sha": "b8b143fba960139c35b309e2c09b43d117a2d295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8b143fba960139c35b309e2c09b43d117a2d295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f/comments", "author": null, "committer": null, "parents": [{"sha": "28ba38e39f1fd80713c0c4bb2d5d9cd8b0d4ad0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ba38e39f1fd80713c0c4bb2d5d9cd8b0d4ad0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ba38e39f1fd80713c0c4bb2d5d9cd8b0d4ad0d"}], "stats": {"total": 115, "additions": 26, "deletions": 89}, "files": [{"sha": "3e28e258ce66d05e1b30bea1656ca4c2bdcfd98d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f", "patch": "@@ -1,3 +1,14 @@\n+2004-02-14  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.h (MASK_DEBUG_[ABEFI], TARGET_DEBUG_[ABEFI]_MODE)\n+\t(TARGET_MIPS4100, TARGET_MIPS4300, TARGET_MIPS4KC, TARGET_MIPS5KC)\n+\t(TARGET_SB1, TUNE_SB1, TUNE_SR71K, BIGGEST_MAX_ARGS_IN_REGISTERS)\n+\t(GO_PRINTF, GO_PRINTF2, GO_DEBUG_RTX, DFMODE_NAN, SFMODE_NAN): Delete.\n+\t(TARGET_SWITCHES): Remove MASK_DEBUG_[ABEFI].\n+\t* config/mips/mips.c: Fix some overly-long lines.\n+\t(SINGLE_WORD_MODE_P, PIC_OFFSET_TABLE_MASK): Delete.\n+\t(init_cumulative_args): Remove TARGET_DEBUG_E_MODE handling.\n+\n 2004-02-13  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* configure.ac: Search for as, ld below libexec/gcc."}, {"sha": "0a69022d222a103dd940e7b7396adbcc128bc64b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f", "patch": "@@ -73,11 +73,6 @@ enum internal_test {\n   ITEST_MAX\n };\n \n-/* Return true if it is likely that the given mode will be accessed\n-   using only a single instruction.  */\n-#define SINGLE_WORD_MODE_P(MODE) \\\n-  ((MODE) != BLKmode && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD)\n-\n /* True if X is an unspec wrapper around a SYMBOL_REF or LABEL_REF.  */\n #define UNSPEC_ADDRESS_P(X)\t\t\t\t\t\\\n   (GET_CODE (X) == UNSPEC\t\t\t\t\t\\\n@@ -2999,7 +2994,8 @@ gen_int_relational (enum rtx_code test_code, rtx result, rtx cmp0,\n   else\n     {\n       reg = (invert || eqne_p) ? gen_reg_rtx (mode) : result;\n-      convert_move (reg, gen_rtx_fmt_ee (p_info->test_code, mode, cmp0, cmp1), 0);\n+      convert_move (reg, gen_rtx_fmt_ee (p_info->test_code,\n+\t\t\t\t\t mode, cmp0, cmp1), 0);\n     }\n \n   if (test == ITEST_NE)\n@@ -3131,7 +3127,8 @@ gen_conditional_branch (rtx *operands, enum rtx_code test_code)\n       break;\n \n     default:\n-      fatal_insn (\"bad test\", gen_rtx_fmt_ee (test_code, VOIDmode, cmp0, cmp1));\n+      fatal_insn (\"bad test\",\n+\t\t  gen_rtx_fmt_ee (test_code, VOIDmode, cmp0, cmp1));\n     }\n \n   /* Generate the branch.  */\n@@ -3145,12 +3142,12 @@ gen_conditional_branch (rtx *operands, enum rtx_code test_code)\n       label1 = pc_rtx;\n     }\n \n-  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n-\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode,\n-\t\t\t\t\t\t     gen_rtx_fmt_ee (test_code,\n-\t\t\t\t\t\t\t\t     mode,\n-\t\t\t\t\t\t\t\t     cmp0, cmp1),\n-\t\t\t\t\t\t     label1, label2)));\n+  emit_jump_insn\n+    (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t  gen_rtx_IF_THEN_ELSE (VOIDmode,\n+\t\t\t\t\tgen_rtx_fmt_ee (test_code, mode,\n+\t\t\t\t\t\t\tcmp0, cmp1),\n+\t\t\t\t\tlabel1, label2)));\n }\n \n /* Emit the common code for conditional moves.  OPERANDS is the array\n@@ -3233,9 +3230,10 @@ gen_conditional_move (rtx *operands)\n \n   emit_insn (gen_rtx_SET (op_mode, operands[0],\n \t\t\t  gen_rtx_IF_THEN_ELSE (op_mode,\n-\t\t\t\t\t\tgen_rtx_fmt_ee (move_code, VOIDmode,\n+\t\t\t\t\t\tgen_rtx_fmt_ee (move_code,\n+\t\t\t\t\t\t\t\tVOIDmode,\n \t\t\t\t\t\t\t\tcmp_reg,\n-\t\t\t\t\t\t\t\tCONST0_RTX (SImode)),\n+\t\t\t\t\t\t\t\tconst0_rtx),\n \t\t\t\t\t\toperands[2], operands[3])));\n }\n \n@@ -3608,23 +3606,6 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n   static CUMULATIVE_ARGS zero_cum;\n   tree param, next_param;\n \n-  if (TARGET_DEBUG_E_MODE)\n-    {\n-      fprintf (stderr,\n-\t       \"\\ninit_cumulative_args, fntype = 0x%.8lx\", (long)fntype);\n-\n-      if (!fntype)\n-\tfputc ('\\n', stderr);\n-\n-      else\n-\t{\n-\t  tree ret_type = TREE_TYPE (fntype);\n-\t  fprintf (stderr, \", fntype code = %s, ret code = %s\\n\",\n-\t\t   tree_code_name[(int)TREE_CODE (fntype)],\n-\t\t   tree_code_name[(int)TREE_CODE (ret_type)]);\n-\t}\n-    }\n-\n   *cum = zero_cum;\n   cum->prototype = (fntype && TYPE_ARG_TYPES (fntype));\n \n@@ -6917,7 +6898,6 @@ mips_expand_prologue (void)\n    and regs.  */\n \n #define RA_MASK BITMASK_HIGH\t/* 1 << 31 */\n-#define PIC_OFFSET_TABLE_MASK (1 << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \n static void\n mips_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n@@ -7099,10 +7079,10 @@ mips_expand_epilogue (int sibcall_p)\n       /* The mips16 loads the return address into $7, not $31.  */\n       if (TARGET_MIPS16 && (cfun->machine->frame.mask & RA_MASK) != 0)\n \temit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode,\n-\t\t\t\t\t\t      GP_REG_FIRST + 7)));\n+\t\t\t\t\t\t\t  GP_REG_FIRST + 7)));\n       else\n \temit_jump_insn (gen_return_internal (gen_rtx_REG (Pmode,\n-\t\t\t\t\t\t      GP_REG_FIRST + 31)));\n+\t\t\t\t\t\t\t  GP_REG_FIRST + 31)));\n     }\n }\n \f"}, {"sha": "e404d3dc1a37b8e09c76e9735f687047336469d0", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=d2888f1dde5f6b84a0d02c9fe4cf52b1cb88cf8f", "patch": "@@ -173,14 +173,9 @@ extern const struct mips_cpu_info *mips_tune_info;\n \n \t\t\t\t\t/* Debug switches, not documented */\n #define MASK_DEBUG\t0\t\t/* unused */\n-#define MASK_DEBUG_A\t0\t\t/* don't allow <label>($reg) addrs */\n-#define MASK_DEBUG_B\t0\t\t/* GO_IF_LEGITIMATE_ADDRESS debug */\n #define MASK_DEBUG_C\t0\t\t/* don't expand seq, etc.  */\n #define MASK_DEBUG_D\t0\t\t/* don't do define_split's */\n-#define MASK_DEBUG_E\t0\t\t/* function_arg debug */\n-#define MASK_DEBUG_F\t0\t\t/* ??? */\n #define MASK_DEBUG_G\t0\t\t/* don't support 64 bit arithmetic */\n-#define MASK_DEBUG_I\t0\t\t/* unused */\n \n \t\t\t\t\t/* Dummy switches used only in specs */\n #define MASK_MIPS_TFILE\t0\t\t/* flag for mips-tfile usage */\n@@ -200,14 +195,9 @@ extern const struct mips_cpu_info *mips_tune_info;\n \n \t\t\t\t\t/* Debug Modes */\n #define TARGET_DEBUG_MODE\t(target_flags & MASK_DEBUG)\n-#define TARGET_DEBUG_A_MODE\t(target_flags & MASK_DEBUG_A)\n-#define TARGET_DEBUG_B_MODE\t(target_flags & MASK_DEBUG_B)\n #define TARGET_DEBUG_C_MODE\t(target_flags & MASK_DEBUG_C)\n #define TARGET_DEBUG_D_MODE\t(target_flags & MASK_DEBUG_D)\n-#define TARGET_DEBUG_E_MODE\t(target_flags & MASK_DEBUG_E)\n-#define TARGET_DEBUG_F_MODE\t(target_flags & MASK_DEBUG_F)\n #define TARGET_DEBUG_G_MODE\t(target_flags & MASK_DEBUG_G)\n-#define TARGET_DEBUG_I_MODE\t(target_flags & MASK_DEBUG_I)\n \n \t\t\t\t\t/* Reg. Naming in .s ($21 vs. $a0) */\n #define TARGET_NAME_REGS\t(target_flags & MASK_NAME_REGS)\n@@ -322,16 +312,11 @@ extern const struct mips_cpu_info *mips_tune_info;\n /* Architecture target defines.  */\n #define TARGET_MIPS3900             (mips_arch == PROCESSOR_R3900)\n #define TARGET_MIPS4000             (mips_arch == PROCESSOR_R4000)\n-#define TARGET_MIPS4100             (mips_arch == PROCESSOR_R4100)\n #define TARGET_MIPS4120             (mips_arch == PROCESSOR_R4120)\n-#define TARGET_MIPS4300             (mips_arch == PROCESSOR_R4300)\n-#define TARGET_MIPS4KC              (mips_arch == PROCESSOR_4KC)\n-#define TARGET_MIPS5KC              (mips_arch == PROCESSOR_5KC)\n #define TARGET_MIPS5400             (mips_arch == PROCESSOR_R5400)\n #define TARGET_MIPS5500             (mips_arch == PROCESSOR_R5500)\n #define TARGET_MIPS7000             (mips_arch == PROCESSOR_R7000)\n #define TARGET_MIPS9000             (mips_arch == PROCESSOR_R9000)\n-#define TARGET_SB1                  (mips_arch == PROCESSOR_SB1)\n #define TARGET_SR71K                (mips_arch == PROCESSOR_SR71000)\n \n /* Scheduling target defines.  */\n@@ -344,8 +329,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n #define TUNE_MIPS6000               (mips_tune == PROCESSOR_R6000)\n #define TUNE_MIPS7000               (mips_tune == PROCESSOR_R7000)\n #define TUNE_MIPS9000               (mips_tune == PROCESSOR_R9000)\n-#define TUNE_SB1                    (mips_tune == PROCESSOR_SB1)\n-#define TUNE_SR71K                  (mips_tune == PROCESSOR_SR71000)\n \n #define TARGET_OLDABI\t\t    (mips_abi == ABI_32 || mips_abi == ABI_O64)\n #define TARGET_NEWABI\t\t    (mips_abi == ABI_N32 || mips_abi == ABI_64)\n@@ -627,22 +610,12 @@ extern const struct mips_cpu_info *mips_tune_info;\n      N_(\"Do not lift restrictions on GOT size\") },\t\t\t\\\n   {\"debug\",\t\t  MASK_DEBUG,\t\t\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n-  {\"debuga\",\t\t  MASK_DEBUG_A,\t\t\t\t\t\\\n-     NULL},\t\t\t\t\t\t\t\t\\\n-  {\"debugb\",\t\t  MASK_DEBUG_B,\t\t\t\t\t\\\n-     NULL},\t\t\t\t\t\t\t\t\\\n   {\"debugc\",\t\t  MASK_DEBUG_C,\t\t\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n   {\"debugd\",\t\t  MASK_DEBUG_D,\t\t\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n-  {\"debuge\",\t\t  MASK_DEBUG_E,\t\t\t\t\t\\\n-     NULL},\t\t\t\t\t\t\t\t\\\n-  {\"debugf\",\t\t  MASK_DEBUG_F,\t\t\t\t\t\\\n-     NULL},\t\t\t\t\t\t\t\t\\\n   {\"debugg\",\t\t  MASK_DEBUG_G,\t\t\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n-  {\"debugi\",\t\t  MASK_DEBUG_I,\t\t\t\t\t\\\n-     NULL},\t\t\t\t\t\t\t\t\\\n   {\"\",\t\t\t  (TARGET_DEFAULT\t\t\t\t\\\n \t\t\t   | TARGET_CPU_DEFAULT\t\t\t\t\\\n \t\t\t   | TARGET_ENDIAN_DEFAULT),\t\t\t\\\n@@ -2185,10 +2158,6 @@ extern enum reg_class mips_char_to_class[256];\n \n #define MAX_ARGS_IN_REGISTERS (TARGET_OLDABI ? 4 : 8)\n \n-/* Largest possible value of MAX_ARGS_IN_REGISTERS.  */\n-\n-#define BIGGEST_MAX_ARGS_IN_REGISTERS 8\n-\n /* Symbolic macros for the first/last argument registers.  */\n \n #define GP_ARG_FIRST (GP_REG_FIRST + 4)\n@@ -2525,21 +2494,6 @@ typedef struct mips_args {\n \n #define MAX_REGS_PER_ADDRESS 1\n \n-/* A C compound statement with a conditional `goto LABEL;' executed\n-   if X (an RTX) is a legitimate memory address on the target\n-   machine for a memory operand of mode MODE.  */\n-\n-#if 1\n-#define GO_PRINTF(x)\tfprintf(stderr, (x))\n-#define GO_PRINTF2(x,y)\tfprintf(stderr, (x), (y))\n-#define GO_DEBUG_RTX(x) debug_rtx(x)\n-\n-#else\n-#define GO_PRINTF(x)\n-#define GO_PRINTF2(x,y)\n-#define GO_DEBUG_RTX(x)\n-#endif\n-\n #ifdef REG_OK_STRICT\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n {\t\t\t\t\t\t\\\n@@ -3361,14 +3315,6 @@ while (0)\n \n #define DONT_ACCESS_GBLS_AFTER_EPILOGUE (TARGET_ABICALLS && !TARGET_OLDABI)\n \f\n-\n-#define DFMODE_NAN \\\n-\tunsigned short DFbignan[4] = {0x7ff7, 0xffff, 0xffff, 0xffff}; \\\n-\tunsigned short DFlittlenan[4] = {0xffff, 0xffff, 0xffff, 0xfff7}\n-#define SFMODE_NAN \\\n-\tunsigned short SFbignan[2] = {0x7fbf, 0xffff}; \\\n-\tunsigned short SFlittlenan[2] = {0xffff, 0xffbf}\n-\n /* Generate calls to memcpy, etc., not bcopy, etc.  */\n #define TARGET_MEM_FUNCTIONS\n "}]}