{"sha": "548a63222ed9b9e8de3503388d64366121ba621d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ4YTYzMjIyZWQ5YjllOGRlMzUwMzM4OGQ2NDM2NjEyMWJhNjIxZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-11-10T23:21:45Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-11-10T23:21:45Z"}, "message": "re PR rtl-optimization/37948 (IRA generates slower code)\n\n2008-11-07  Vladimir Makarov  <vmakarov@redhat.com>\n\t    \n\tPR rtl-optimizations/37948\n\t* ira-int.h (struct ira_allocno_copy): New member constraint_p.\n\t(ira_create_copy, ira_add_allocno_copy): New parameter.\n\n\t* ira-conflicts.c (process_regs_for_copy): New parameter.  Pass it\n\tto ira_add_allocno_copy.\n\t(process_reg_shuffles, add_insn_allocno_copies): Pass a new\n\tparameter to process_regs_for_copy.\n\t(propagate_copies): Pass a new parameter to ira_add_allocno_copy.\n\tFix typo in passing second allocno to ira_add_allocno_copy.\n\n\t* ira-color.c (update_conflict_hard_regno_costs): Use head of\n\tcoalesced allocnos list.\n\t(assign_hard_reg): Ditto.  Check that assigned allocnos are not in\n\tthe graph.\n\t(add_ira_allocno_to_bucket): Rename to add_allocno_to_bucket.\n\t(add_ira_allocno_to_ordered_bucket): Rename to\n\tadd_allocno_to_ordered_bucket.\n\t(push_ira_allocno_to_stack): Rename to push_allocno_to_stack.  Use\n\thead of coalesced allocnos list.\n\t(push_allocnos_to_stack): Remove calculation of ALLOCNO_TEMP.\n\tCheck that it is aready calculated.\n\t(push_ira_allocno_to_spill): Rename to push_ira_allocno_to_spill.\n\t(setup_allocno_left_conflicts_num): Use head of coalesced allocnos\n\tlist.\n\t(coalesce_allocnos): Do extended coalescing too.\n\n\t* ira-emit.c (add_range_and_copies_from_move_list): Pass a new\n\tparameter to ira_add_allocno_copy.\n\n\t* ira-build.c (ira_create_copy, ira_add_allocno_copy): Add a new\n\tparameter.\n\t(print_copy): Print copy origination too.\n\n\t* ira-costs.c (scan_one_insn): Use alloc_pref for load from\n\tequivalent memory.\n\nFrom-SVN: r141753", "tree": {"sha": "7fd0254faf506029de880777901eccc09123341f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fd0254faf506029de880777901eccc09123341f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/548a63222ed9b9e8de3503388d64366121ba621d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548a63222ed9b9e8de3503388d64366121ba621d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/548a63222ed9b9e8de3503388d64366121ba621d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/548a63222ed9b9e8de3503388d64366121ba621d/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "befc25099bbedd2d49f23f929b6c441894c8cb5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/befc25099bbedd2d49f23f929b6c441894c8cb5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/befc25099bbedd2d49f23f929b6c441894c8cb5c"}], "stats": {"total": 322, "additions": 185, "deletions": 137}, "files": [{"sha": "49df4e79ac0484ecec55c0ee9141aab63c424b3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=548a63222ed9b9e8de3503388d64366121ba621d", "patch": "@@ -1,3 +1,42 @@\n+2008-11-07  Vladimir Makarov  <vmakarov@redhat.com>\n+\t    \n+\tPR rtl-optimizations/37948\n+\t* ira-int.h (struct ira_allocno_copy): New member constraint_p.\n+\t(ira_create_copy, ira_add_allocno_copy): New parameter.\n+\n+\t* ira-conflicts.c (process_regs_for_copy): New parameter.  Pass it\n+\tto ira_add_allocno_copy.\n+\t(process_reg_shuffles, add_insn_allocno_copies): Pass a new\n+\tparameter to process_regs_for_copy.\n+\t(propagate_copies): Pass a new parameter to ira_add_allocno_copy.\n+\tFix typo in passing second allocno to ira_add_allocno_copy.\n+\n+\t* ira-color.c (update_conflict_hard_regno_costs): Use head of\n+\tcoalesced allocnos list.\n+\t(assign_hard_reg): Ditto.  Check that assigned allocnos are not in\n+\tthe graph.\n+\t(add_ira_allocno_to_bucket): Rename to add_allocno_to_bucket.\n+\t(add_ira_allocno_to_ordered_bucket): Rename to\n+\tadd_allocno_to_ordered_bucket.\n+\t(push_ira_allocno_to_stack): Rename to push_allocno_to_stack.  Use\n+\thead of coalesced allocnos list.\n+\t(push_allocnos_to_stack): Remove calculation of ALLOCNO_TEMP.\n+\tCheck that it is aready calculated.\n+\t(push_ira_allocno_to_spill): Rename to push_ira_allocno_to_spill.\n+\t(setup_allocno_left_conflicts_num): Use head of coalesced allocnos\n+\tlist.\n+\t(coalesce_allocnos): Do extended coalescing too.\n+\n+\t* ira-emit.c (add_range_and_copies_from_move_list): Pass a new\n+\tparameter to ira_add_allocno_copy.\n+\n+\t* ira-build.c (ira_create_copy, ira_add_allocno_copy): Add a new\n+\tparameter.\n+\t(print_copy): Print copy origination too.\n+\n+\t* ira-costs.c (scan_one_insn): Use alloc_pref for load from\n+\tequivalent memory.\n+\t\n 2008-11-10  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR rtl-optimization/37514"}, {"sha": "295825ce5f0aed475b8ff42dd9c6a1240d3fa906", "filename": "gcc/ira-build.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=548a63222ed9b9e8de3503388d64366121ba621d", "patch": "@@ -961,9 +961,10 @@ find_allocno_copy (ira_allocno_t a1, ira_allocno_t a2, rtx insn,\n }\n \n /* Create and return copy with given attributes LOOP_TREE_NODE, FIRST,\n-   SECOND, FREQ, and INSN.  */\n+   SECOND, FREQ, CONSTRAINT_P, and INSN.  */\n ira_copy_t\n-ira_create_copy (ira_allocno_t first, ira_allocno_t second, int freq, rtx insn,\n+ira_create_copy (ira_allocno_t first, ira_allocno_t second, int freq,\n+\t\t bool constraint_p, rtx insn,\n \t\t ira_loop_tree_node_t loop_tree_node)\n {\n   ira_copy_t cp;\n@@ -973,6 +974,7 @@ ira_create_copy (ira_allocno_t first, ira_allocno_t second, int freq, rtx insn,\n   cp->first = first;\n   cp->second = second;\n   cp->freq = freq;\n+  cp->constraint_p = constraint_p;\n   cp->insn = insn;\n   cp->loop_tree_node = loop_tree_node;\n   VEC_safe_push (ira_copy_t, heap, copy_vec, cp);\n@@ -1081,7 +1083,8 @@ ira_swap_allocno_copy_ends_if_necessary (ira_copy_t cp)\n    LOOP_TREE_NODE.  */\n ira_copy_t\n ira_add_allocno_copy (ira_allocno_t first, ira_allocno_t second, int freq,\n-\t\t      rtx insn, ira_loop_tree_node_t loop_tree_node)\n+\t\t      bool constraint_p, rtx insn,\n+\t\t      ira_loop_tree_node_t loop_tree_node)\n {\n   ira_copy_t cp;\n \n@@ -1090,7 +1093,8 @@ ira_add_allocno_copy (ira_allocno_t first, ira_allocno_t second, int freq,\n       cp->freq += freq;\n       return cp;\n     }\n-  cp = ira_create_copy (first, second, freq, insn, loop_tree_node);\n+  cp = ira_create_copy (first, second, freq, constraint_p, insn,\n+\t\t\tloop_tree_node);\n   ira_assert (first != NULL && second != NULL);\n   ira_add_allocno_copy_to_list (cp);\n   ira_swap_allocno_copy_ends_if_necessary (cp);\n@@ -1101,9 +1105,11 @@ ira_add_allocno_copy (ira_allocno_t first, ira_allocno_t second, int freq,\n static void\n print_copy (FILE *f, ira_copy_t cp)\n {\n-  fprintf (f, \"  cp%d:a%d(r%d)<->a%d(r%d)@%d\\n\", cp->num,\n+  fprintf (f, \"  cp%d:a%d(r%d)<->a%d(r%d)@%d:%s\\n\", cp->num,\n \t   ALLOCNO_NUM (cp->first), ALLOCNO_REGNO (cp->first),\n-\t   ALLOCNO_NUM (cp->second), ALLOCNO_REGNO (cp->second), cp->freq);\n+\t   ALLOCNO_NUM (cp->second), ALLOCNO_REGNO (cp->second), cp->freq,\n+\t   cp->insn != NULL\n+\t   ? \"move\" : cp->constraint_p ? \"constraint\" : \"shuffle\");\n }\n \n /* Print info about copy CP into stderr.  */"}, {"sha": "59589c9a49ec6bc0ac261f430193a77a32fbd1c2", "filename": "gcc/ira-color.c", "status": "modified", "additions": 111, "deletions": 115, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=548a63222ed9b9e8de3503388d64366121ba621d", "patch": "@@ -300,7 +300,8 @@ update_conflict_hard_regno_costs (int *costs, bool decr_p)\n \tcover_class = ALLOCNO_COVER_CLASS (allocno);\n \tif (cover_class != ALLOCNO_COVER_CLASS (another_allocno)\n \t    || ALLOCNO_ASSIGNED_P (another_allocno)\n-\t    || ALLOCNO_MAY_BE_SPILLED_P (another_allocno))\n+\t    || ALLOCNO_MAY_BE_SPILLED_P (ALLOCNO_FIRST_COALESCED_ALLOCNO\n+\t\t\t\t\t (another_allocno)))\n \t  continue;\n \tclass_size = ira_class_hard_regs_num[cover_class];\n \tira_allocate_and_copy_costs\n@@ -469,7 +470,8 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n \t\t  }\n \t\tcontinue;\n \t      }\n-\t    else if (! ALLOCNO_MAY_BE_SPILLED_P (conflict_allocno))\n+\t    else if (! ALLOCNO_MAY_BE_SPILLED_P (ALLOCNO_FIRST_COALESCED_ALLOCNO\n+\t\t\t\t\t\t (conflict_allocno)))\n \t      {\n \t\tira_allocate_and_copy_costs\n \t\t  (&ALLOCNO_UPDATED_CONFLICT_HARD_REG_COSTS (conflict_allocno),\n@@ -555,6 +557,7 @@ assign_hard_reg (ira_allocno_t allocno, bool retry_p)\n       for (j = 0, a = ALLOCNO_NEXT_COALESCED_ALLOCNO (allocno);;\n \t   a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n \t{\n+\t  ira_assert (! ALLOCNO_IN_GRAPH_P (a));\n \t  sorted_allocnos[j++] = a;\n \t  if (a == allocno)\n \t    break;\n@@ -612,7 +615,7 @@ static int uncolorable_allocnos_num[N_REG_CLASSES];\n /* Add ALLOCNO to bucket *BUCKET_PTR.  ALLOCNO should be not in a bucket\n    before the call.  */\n static void\n-add_ira_allocno_to_bucket (ira_allocno_t allocno, ira_allocno_t *bucket_ptr)\n+add_allocno_to_bucket (ira_allocno_t allocno, ira_allocno_t *bucket_ptr)\n {\n   ira_allocno_t first_allocno;\n   enum reg_class cover_class;\n@@ -706,8 +709,8 @@ sort_bucket (ira_allocno_t *bucket_ptr)\n    their priority.  ALLOCNO should be not in a bucket before the\n    call.  */\n static void\n-add_ira_allocno_to_ordered_bucket (ira_allocno_t allocno,\n-\t\t\t\t   ira_allocno_t *bucket_ptr)\n+add_allocno_to_ordered_bucket (ira_allocno_t allocno,\n+\t\t\t       ira_allocno_t *bucket_ptr)\n {\n   ira_allocno_t before, after;\n   enum reg_class cover_class;\n@@ -780,7 +783,7 @@ static splay_tree uncolorable_allocnos_splay_tree[N_REG_CLASSES];\n    conflicting allocnos from the uncolorable bucket to the colorable\n    one.  */\n static void\n-push_ira_allocno_to_stack (ira_allocno_t allocno)\n+push_allocno_to_stack (ira_allocno_t allocno)\n {\n   int conflicts_num, conflict_size, size;\n   ira_allocno_t a, conflict_allocno;\n@@ -799,62 +802,66 @@ push_ira_allocno_to_stack (ira_allocno_t allocno)\n        a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n     {\n       FOR_EACH_ALLOCNO_CONFLICT (a, conflict_allocno, aci)\n-\tif (bitmap_bit_p (coloring_allocno_bitmap,\n-\t\t\t  ALLOCNO_NUM (conflict_allocno)))\n-\t  {\n-\t    ira_assert (cover_class == ALLOCNO_COVER_CLASS (conflict_allocno));\n-\t    if (allocno_coalesced_p)\n-\t      {\n-\t\tif (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n-\t\t\t\t  ALLOCNO_NUM (conflict_allocno)))\n-\t\t  continue;\n-\t\tbitmap_set_bit (processed_coalesced_allocno_bitmap,\n-\t\t\t\tALLOCNO_NUM (conflict_allocno));\n-\t      }\n-\t    if (ALLOCNO_IN_GRAPH_P (conflict_allocno)\n-\t\t&& ! ALLOCNO_ASSIGNED_P (conflict_allocno))\n-\t      {\n-\t\tconflicts_num = ALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno);\n-\t\tconflict_size\n-\t\t  = (ira_reg_class_nregs\n-\t\t     [cover_class][ALLOCNO_MODE (conflict_allocno)]);\n-\t\tira_assert\n-\t\t  (ALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno) >= size);\n-\t\tif (conflicts_num + conflict_size\n-\t\t    <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n-\t\t  {\n-\t\t    ALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno) -= size;\n+\t{\n+\t  conflict_allocno = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n+\t  if (bitmap_bit_p (coloring_allocno_bitmap,\n+\t\t\t    ALLOCNO_NUM (conflict_allocno)))\n+\t    {\n+\t      ira_assert (cover_class\n+\t\t\t  == ALLOCNO_COVER_CLASS (conflict_allocno));\n+\t      if (allocno_coalesced_p)\n+\t\t{\n+\t\t  if (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n+\t\t\t\t    ALLOCNO_NUM (conflict_allocno)))\n \t\t    continue;\n-\t\t  }\n-\t\tconflicts_num\n-\t\t  = ALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno) - size;\n-\t\tif (uncolorable_allocnos_splay_tree[cover_class] != NULL\n-\t\t    && !ALLOCNO_SPLAY_REMOVED_P (conflict_allocno)\n-\t\t    && USE_SPLAY_P (cover_class))\n-\t\t  {\n-\t\t    ira_assert\n+\t\t  bitmap_set_bit (processed_coalesced_allocno_bitmap,\n+\t\t\t\t  ALLOCNO_NUM (conflict_allocno));\n+\t\t}\n+\t      if (ALLOCNO_IN_GRAPH_P (conflict_allocno)\n+\t\t  && ! ALLOCNO_ASSIGNED_P (conflict_allocno))\n+\t\t{\n+\t\t  conflicts_num = ALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno);\n+\t\t  conflict_size\n+\t\t    = (ira_reg_class_nregs\n+\t\t       [cover_class][ALLOCNO_MODE (conflict_allocno)]);\n+\t\t  ira_assert\n+\t\t    (ALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno) >= size);\n+\t\t  if (conflicts_num + conflict_size\n+\t\t      <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n+\t\t    {\n+\t\t      ALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno) -= size;\n+\t\t      continue;\n+\t\t    }\n+\t\t  conflicts_num\n+\t\t    = ALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno) - size;\n+\t\t  if (uncolorable_allocnos_splay_tree[cover_class] != NULL\n+\t\t      && !ALLOCNO_SPLAY_REMOVED_P (conflict_allocno)\n+\t\t      && USE_SPLAY_P (cover_class))\n+\t\t    {\n+\t\t      ira_assert\n \t\t      (splay_tree_lookup\n \t\t       (uncolorable_allocnos_splay_tree[cover_class],\n \t\t\t(splay_tree_key) conflict_allocno) != NULL);\n-\t\t    splay_tree_remove\n-\t\t      (uncolorable_allocnos_splay_tree[cover_class],\n-\t\t       (splay_tree_key) conflict_allocno);\n-\t\t    ALLOCNO_SPLAY_REMOVED_P (conflict_allocno) = true;\n-\t\t    VEC_safe_push (ira_allocno_t, heap,\n-\t\t\t\t   removed_splay_allocno_vec,\n-\t\t\t\t   conflict_allocno);\n-\t\t  }\n-\t\tALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno) = conflicts_num;\n-\t\tif (conflicts_num + conflict_size\n-\t\t    <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n-\t\t  {\n-\t\t    delete_allocno_from_bucket (conflict_allocno,\n-\t\t\t\t\t\t&uncolorable_allocno_bucket);\n-\t\t    add_ira_allocno_to_ordered_bucket (conflict_allocno,\n-\t\t\t\t\t\t   &colorable_allocno_bucket);\n-\t\t  }\n-\t      }\n-\t  }\n+\t\t      splay_tree_remove\n+\t\t\t(uncolorable_allocnos_splay_tree[cover_class],\n+\t\t\t (splay_tree_key) conflict_allocno);\n+\t\t      ALLOCNO_SPLAY_REMOVED_P (conflict_allocno) = true;\n+\t\t      VEC_safe_push (ira_allocno_t, heap,\n+\t\t\t\t     removed_splay_allocno_vec,\n+\t\t\t\t     conflict_allocno);\n+\t\t    }\n+\t\t  ALLOCNO_LEFT_CONFLICTS_NUM (conflict_allocno) = conflicts_num;\n+\t\t  if (conflicts_num + conflict_size\n+\t\t      <= ALLOCNO_AVAILABLE_REGS_NUM (conflict_allocno))\n+\t\t    {\n+\t\t      delete_allocno_from_bucket\n+\t\t\t(conflict_allocno, &uncolorable_allocno_bucket);\n+\t\t      add_allocno_to_ordered_bucket\n+\t\t\t(conflict_allocno, &colorable_allocno_bucket);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n       if (a == allocno)\n \tbreak;\n     }\n@@ -889,7 +896,7 @@ remove_allocno_from_bucket_and_push (ira_allocno_t allocno, bool colorable_p)\n \t\t      > ALLOCNO_AVAILABLE_REGS_NUM (allocno))));\n   if (! colorable_p)\n     ALLOCNO_MAY_BE_SPILLED_P (allocno) = true;\n-  push_ira_allocno_to_stack (allocno);\n+  push_allocno_to_stack (allocno);\n }\n \n /* Put all allocnos from colorable bucket onto the coloring stack.  */\n@@ -904,14 +911,14 @@ push_only_colorable (void)\n /* Puts ALLOCNO chosen for potential spilling onto the coloring\n    stack.  */\n static void\n-push_ira_allocno_to_spill (ira_allocno_t allocno)\n+push_allocno_to_spill (ira_allocno_t allocno)\n {\n   delete_allocno_from_bucket (allocno, &uncolorable_allocno_bucket);\n   ALLOCNO_MAY_BE_SPILLED_P (allocno) = true;\n   if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"      Pushing p%d(%d) (potential spill)\\n\",\n \t     ALLOCNO_NUM (allocno), ALLOCNO_REGNO (allocno));\n-  push_ira_allocno_to_stack (allocno);\n+  push_allocno_to_stack (allocno);\n }\n \n /* Return the frequency of exit edges (if EXIT_P) or entry from/to the\n@@ -1124,7 +1131,7 @@ push_allocnos_to_stack (void)\n       cover_class = ALLOCNO_COVER_CLASS (allocno);\n       if (cover_class == NO_REGS)\n \t{\n-\t  push_ira_allocno_to_spill (allocno);\n+\t  push_allocno_to_spill (allocno);\n \t  continue;\n \t}\n       /* Potential spilling.  */\n@@ -1172,22 +1179,7 @@ push_allocnos_to_stack (void)\n \t      if (ALLOCNO_IN_GRAPH_P (i_allocno))\n \t\t{\n \t\t  i++;\n-\t\t  if (ALLOCNO_TEMP (i_allocno) == INT_MAX)\n-\t\t    {\n-\t\t      ira_allocno_t a;\n-\t\t      int cost = 0;\n-\t\t      \n-\t\t      for (a = ALLOCNO_NEXT_COALESCED_ALLOCNO (i_allocno);;\n-\t\t\t   a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n-\t\t\t{\n-\t\t\t  cost += calculate_allocno_spill_cost (i_allocno);\n-\t\t\t  if (a == i_allocno)\n-\t\t\t    break;\n-\t\t\t}\n-\t\t      /* ??? Remove cost of copies between the coalesced\n-\t\t\t allocnos.  */\n-\t\t      ALLOCNO_TEMP (i_allocno) = cost;\n-\t\t    }\n+\t\t  ira_assert (ALLOCNO_TEMP (i_allocno) != INT_MAX);\n \t\t  i_allocno_cost = ALLOCNO_TEMP (i_allocno);\n \t\t  i_allocno_pri\n \t\t    = (i_allocno_cost\n@@ -1351,41 +1343,45 @@ setup_allocno_left_conflicts_num (ira_allocno_t allocno)\n \t a = ALLOCNO_NEXT_COALESCED_ALLOCNO (a))\n       {\n \tFOR_EACH_ALLOCNO_CONFLICT (a, conflict_allocno, aci)\n-\t  if (bitmap_bit_p (consideration_allocno_bitmap,\n-\t\t\t    ALLOCNO_NUM (conflict_allocno)))\n-\t    {\n-\t      ira_assert (cover_class\n-\t\t\t  == ALLOCNO_COVER_CLASS (conflict_allocno));\n-\t      if (allocno_coalesced_p)\n-\t\t{\n-\t\t  if (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n-\t\t\t\t    ALLOCNO_NUM (conflict_allocno)))\n-\t\t    continue;\n-\t\t  bitmap_set_bit (processed_coalesced_allocno_bitmap,\n-\t\t\t\t  ALLOCNO_NUM (conflict_allocno));\n-\t\t}\n-\t      if (! ALLOCNO_ASSIGNED_P (conflict_allocno))\n-\t\tconflict_allocnos_size\n-\t\t  += (ira_reg_class_nregs\n-\t\t      [cover_class][ALLOCNO_MODE (conflict_allocno)]);\n-\t      else if ((hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno))\n-\t\t       >= 0)\n-\t\t{\n-\t\t  int last = (hard_regno\n-\t\t\t      + hard_regno_nregs\n+\t  {\n+\t    conflict_allocno\n+\t      = ALLOCNO_FIRST_COALESCED_ALLOCNO (conflict_allocno);\n+\t    if (bitmap_bit_p (consideration_allocno_bitmap,\n+\t\t\t      ALLOCNO_NUM (conflict_allocno)))\n+\t      {\n+\t\tira_assert (cover_class\n+\t\t\t    == ALLOCNO_COVER_CLASS (conflict_allocno));\n+\t\tif (allocno_coalesced_p)\n+\t\t  {\n+\t\t    if (bitmap_bit_p (processed_coalesced_allocno_bitmap,\n+\t\t\t\t      ALLOCNO_NUM (conflict_allocno)))\n+\t\t      continue;\n+\t\t    bitmap_set_bit (processed_coalesced_allocno_bitmap,\n+\t\t\t\t    ALLOCNO_NUM (conflict_allocno));\n+\t\t  }\n+\t\tif (! ALLOCNO_ASSIGNED_P (conflict_allocno))\n+\t\t  conflict_allocnos_size\n+\t\t    += (ira_reg_class_nregs\n+\t\t\t[cover_class][ALLOCNO_MODE (conflict_allocno)]);\n+\t\telse if ((hard_regno = ALLOCNO_HARD_REGNO (conflict_allocno))\n+\t\t\t >= 0)\n+\t\t  {\n+\t\t    int last = (hard_regno\n+\t\t\t\t+ hard_regno_nregs\n \t\t\t        [hard_regno][ALLOCNO_MODE (conflict_allocno)]);\n-\t\t  \n-\t\t  while (hard_regno < last)\n-\t\t    {\n-\t\t      if (! TEST_HARD_REG_BIT (temp_set, hard_regno))\n-\t\t\t{\n-\t\t\t  conflict_allocnos_size++;\n-\t\t\t  SET_HARD_REG_BIT (temp_set, hard_regno);\n-\t\t\t}\n-\t\t      hard_regno++;\n-\t\t    }\n-\t\t}\n-\t    }\n+\t\t    \n+\t\t    while (hard_regno < last)\n+\t\t      {\n+\t\t\tif (! TEST_HARD_REG_BIT (temp_set, hard_regno))\n+\t\t\t  {\n+\t\t\t    conflict_allocnos_size++;\n+\t\t\t    SET_HARD_REG_BIT (temp_set, hard_regno);\n+\t\t\t  }\n+\t\t\thard_regno++;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n         if (a == allocno)\n \t  break;\n       }\n@@ -1410,9 +1406,9 @@ put_allocno_into_bucket (ira_allocno_t allocno)\n   if (ALLOCNO_LEFT_CONFLICTS_NUM (allocno)\n       + ira_reg_class_nregs[cover_class][ALLOCNO_MODE (allocno)]\n       <= ALLOCNO_AVAILABLE_REGS_NUM (allocno))\n-    add_ira_allocno_to_bucket (allocno, &colorable_allocno_bucket);\n+    add_allocno_to_bucket (allocno, &colorable_allocno_bucket);\n   else\n-    add_ira_allocno_to_bucket (allocno, &uncolorable_allocno_bucket);\n+    add_allocno_to_bucket (allocno, &uncolorable_allocno_bucket);\n }\n \n /* The function is used to sort allocnos according to their execution\n@@ -1552,7 +1548,7 @@ coalesce_allocnos (bool reload_p)\n \t      if ((reload_p\n \t\t   || (ALLOCNO_COVER_CLASS (cp->second) == cover_class\n \t\t       && ALLOCNO_MODE (cp->second) == mode))\n-\t\t  && cp->insn != NULL\n+\t\t  && (cp->insn != NULL || cp->constraint_p)\n \t\t  && ((! reload_p && ! ALLOCNO_ASSIGNED_P (cp->second))\n \t\t      || (reload_p\n \t\t\t  && ALLOCNO_ASSIGNED_P (cp->second)"}, {"sha": "66376b63a5c19638d4c31b7617b756674556e483", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=548a63222ed9b9e8de3503388d64366121ba621d", "patch": "@@ -329,7 +329,8 @@ go_through_subreg (rtx x, int *offset)\n    registers.  When nothing is changed, the function returns\n    FALSE.  */\n static bool\n-process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n+process_regs_for_copy (rtx reg1, rtx reg2, bool constraint_p,\n+\t\t       rtx insn, int freq)\n {\n   int allocno_preferenced_hard_regno, cost, index, offset1, offset2;\n   bool only_regs_p;\n@@ -363,7 +364,8 @@ process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n     {\n       cp = ira_add_allocno_copy (ira_curr_regno_allocno_map[REGNO (reg1)],\n \t\t\t\t ira_curr_regno_allocno_map[REGNO (reg2)],\n-\t\t\t\t freq, insn, ira_curr_loop_tree_node);\n+\t\t\t\t freq, constraint_p, insn,\n+\t\t\t\t ira_curr_loop_tree_node);\n       bitmap_set_bit (ira_curr_loop_tree_node->local_copies, cp->num); \n       return true;\n     }\n@@ -426,7 +428,7 @@ process_reg_shuffles (rtx reg, int op_num, int freq)\n \t  || recog_data.operand_type[i] != OP_OUT)\n \tcontinue;\n       \n-      process_regs_for_copy (reg, another_reg, NULL_RTX, freq);\n+      process_regs_for_copy (reg, another_reg, false, NULL_RTX, freq);\n     }\n }\n \n@@ -451,7 +453,7 @@ add_insn_allocno_copies (rtx insn)\n \t\t\tREG_P (SET_SRC (set))\n \t\t\t? SET_SRC (set)\n \t\t\t: SUBREG_REG (SET_SRC (set))) != NULL_RTX)\n-    process_regs_for_copy (SET_DEST (set), SET_SRC (set), insn, freq);\n+    process_regs_for_copy (SET_DEST (set), SET_SRC (set), false, insn, freq);\n   else\n     {\n       extract_insn (insn);\n@@ -470,7 +472,8 @@ add_insn_allocno_copies (rtx insn)\n \t      for (j = 0, commut_p = false; j < 2; j++, commut_p = true)\n \t\tif ((dup = get_dup (i, commut_p)) != NULL_RTX\n \t\t    && REG_SUBREG_P (dup)\n-\t\t    && process_regs_for_copy (operand, dup, NULL_RTX, freq))\n+\t\t    && process_regs_for_copy (operand, dup, true,\n+\t\t\t\t\t      NULL_RTX, freq))\n \t\t  bound_p = true;\n \t      if (bound_p)\n \t\tcontinue;\n@@ -524,8 +527,8 @@ propagate_copies (void)\n \tparent_a2 = parent->regno_allocno_map[ALLOCNO_REGNO (a2)];\n       ira_assert (parent_a1 != NULL && parent_a2 != NULL);\n       if (! CONFLICT_ALLOCNO_P (parent_a1, parent_a2))\n-\tira_add_allocno_copy (parent_a1, parent_a1, cp->freq,\n-\t\t\t      cp->insn, cp->loop_tree_node);\n+\tira_add_allocno_copy (parent_a1, parent_a2, cp->freq,\n+\t\t\t      cp->constraint_p, cp->insn, cp->loop_tree_node);\n     }\n }\n "}, {"sha": "14d473ed285ab6e7997df60fa3ef0f68a475932c", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=548a63222ed9b9e8de3503388d64366121ba621d", "patch": "@@ -989,11 +989,14 @@ scan_one_insn (rtx insn)\n       && (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != NULL_RTX\n       && MEM_P (XEXP (note, 0)))\n     {\n-      COSTS_OF_ALLOCNO (allocno_costs,\n-\t\t\tALLOCNO_NUM (ira_curr_regno_allocno_map\n-\t\t\t\t     [REGNO (SET_DEST (set))]))->mem_cost\n-\t-= (ira_memory_move_cost[GET_MODE (SET_DEST (set))][GENERAL_REGS][1]\n-\t    * frequency);\n+      enum reg_class cl = GENERAL_REGS;\n+      rtx reg = SET_DEST (set);\n+      int num = ALLOCNO_NUM (ira_curr_regno_allocno_map[REGNO (reg)]);\n+\n+      if (allocno_pref)\n+\tcl = allocno_pref[num];\n+      COSTS_OF_ALLOCNO (allocno_costs, num)->mem_cost\n+\t-= ira_memory_move_cost[GET_MODE (reg)][cl][1] * frequency;\n       record_address_regs (GET_MODE (SET_SRC (set)), XEXP (SET_SRC (set), 0),\n \t\t\t   0, MEM, SCRATCH, frequency * 2);\n     }"}, {"sha": "63c866b641a423ba139fb98c81ef1c2fcbbc4b39", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=548a63222ed9b9e8de3503388d64366121ba621d", "patch": "@@ -863,7 +863,7 @@ add_range_and_copies_from_move_list (move_t list, ira_loop_tree_node_t node,\n       IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (to), hard_regs_live);\n       update_costs (from, true, freq);\n       update_costs (to, false, freq);\n-      cp = ira_add_allocno_copy (from, to, freq, move->insn, NULL);\n+      cp = ira_add_allocno_copy (from, to, freq, false, move->insn, NULL);\n       if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \tfprintf (ira_dump_file, \"    Adding cp%d:a%dr%d-a%dr%d\\n\",\n \t\t cp->num, ALLOCNO_NUM (cp->first),"}, {"sha": "c5e4bec63460f88188ab38268f32d84b63a397eb", "filename": "gcc/ira-int.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/548a63222ed9b9e8de3503388d64366121ba621d/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=548a63222ed9b9e8de3503388d64366121ba621d", "patch": "@@ -496,6 +496,7 @@ struct ira_allocno_copy\n   ira_allocno_t first, second;\n   /* Execution frequency of the copy.  */\n   int freq;\n+  bool constraint_p;\n   /* It is a move insn which is an origin of the copy.  The member\n      value for the copy representing two operand insn constraints or\n      for the copy created to remove register shuffle is NULL.  In last\n@@ -859,12 +860,12 @@ extern allocno_live_range_t ira_create_allocno_live_range\n extern void ira_finish_allocno_live_range (allocno_live_range_t);\n extern void ira_free_allocno_updated_costs (ira_allocno_t);\n extern ira_copy_t ira_create_copy (ira_allocno_t, ira_allocno_t,\n-\t\t\t\t   int, rtx, ira_loop_tree_node_t);\n+\t\t\t\t   int, bool, rtx, ira_loop_tree_node_t);\n extern void ira_add_allocno_copy_to_list (ira_copy_t);\n extern void ira_swap_allocno_copy_ends_if_necessary (ira_copy_t);\n extern void ira_remove_allocno_copy_from_list (ira_copy_t);\n-extern ira_copy_t ira_add_allocno_copy (ira_allocno_t, ira_allocno_t, int, rtx,\n-\t\t\t\t\tira_loop_tree_node_t);\n+extern ira_copy_t ira_add_allocno_copy (ira_allocno_t, ira_allocno_t, int,\n+\t\t\t\t\tbool, rtx, ira_loop_tree_node_t);\n \n extern int *ira_allocate_cost_vector (enum reg_class);\n extern void ira_free_cost_vector (int *, enum reg_class);"}]}