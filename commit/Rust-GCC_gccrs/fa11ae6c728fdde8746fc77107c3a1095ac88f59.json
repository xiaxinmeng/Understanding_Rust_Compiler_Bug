{"sha": "fa11ae6c728fdde8746fc77107c3a1095ac88f59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmExMWFlNmM3MjhmZGRlODc0NmZjNzcxMDdjM2ExMDk1YWM4OGY1OQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-09-11T20:48:26Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-09-11T20:48:26Z"}, "message": "re PR fortran/50327 (Front-end optimization generates wrong code for BLAS's srotmg)\n\n2011-09-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/50327\n\t* frontend-passes.c (dummy_expr_callback):  New function.\n\t(convert_do_while):  New function.\n\t(optimize_namespace):  Call code walker to convert do while loops.\n\n2011-09-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/50327\n\t* gfortran.dg/do_while_1.f90:  New test.\n\nFrom-SVN: r178768", "tree": {"sha": "55b9e43bee6cb3e1a4e07aaaeb414edca2c7b0aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55b9e43bee6cb3e1a4e07aaaeb414edca2c7b0aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa11ae6c728fdde8746fc77107c3a1095ac88f59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa11ae6c728fdde8746fc77107c3a1095ac88f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa11ae6c728fdde8746fc77107c3a1095ac88f59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa11ae6c728fdde8746fc77107c3a1095ac88f59/comments", "author": null, "committer": null, "parents": [{"sha": "9795c59419d1802b7332bdd766750da46741a440", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9795c59419d1802b7332bdd766750da46741a440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9795c59419d1802b7332bdd766750da46741a440"}], "stats": {"total": 102, "additions": 102, "deletions": 0}, "files": [{"sha": "836967d7a4bdc0a15df84858a9d48c3d60463418", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa11ae6c728fdde8746fc77107c3a1095ac88f59/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa11ae6c728fdde8746fc77107c3a1095ac88f59/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fa11ae6c728fdde8746fc77107c3a1095ac88f59", "patch": "@@ -1,3 +1,10 @@\n+2011-09-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/50327\n+\t* frontend-passes.c (dummy_expr_callback):  New function.\n+\t(convert_do_while):  New function.\n+\t(optimize_namespace):  Call code walker to convert do while loops.\n+\n 2011-09-11  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/35831"}, {"sha": "16053e0742aef3658383884a01e7eb367cbb099f", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa11ae6c728fdde8746fc77107c3a1095ac88f59/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa11ae6c728fdde8746fc77107c3a1095ac88f59/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=fa11ae6c728fdde8746fc77107c3a1095ac88f59", "patch": "@@ -407,6 +407,85 @@ cfe_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n+/* Dummy function for expression call back, for use when we\n+   really don't want to do any walking.  */\n+\n+static int\n+dummy_expr_callback (gfc_expr **e ATTRIBUTE_UNUSED, int *walk_subtrees,\n+\t\t     void *data ATTRIBUTE_UNUSED)\n+{\n+  *walk_subtrees = 0;\n+  return 0;\n+}\n+\n+/* Code callback function for converting\n+   do while(a)\n+   end do\n+   into the equivalent\n+   do\n+     if (.not. a) exit\n+   end do\n+   This is because common function elimination would otherwise place the\n+   temporary variables outside the loop.  */\n+\n+static int\n+convert_do_while (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t  void *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_code *co = *c;\n+  gfc_code *c_if1, *c_if2, *c_exit;\n+  gfc_code *loopblock;\n+  gfc_expr *e_not, *e_cond;\n+\n+  if (co->op != EXEC_DO_WHILE)\n+    return 0;\n+\n+  if (co->expr1 == NULL || co->expr1->expr_type == EXPR_CONSTANT)\n+    return 0;\n+\n+  e_cond = co->expr1;\n+\n+  /* Generate the condition of the if statement, which is .not. the original\n+     statement.  */\n+  e_not = gfc_get_expr ();\n+  e_not->ts = e_cond->ts;\n+  e_not->where = e_cond->where;\n+  e_not->expr_type = EXPR_OP;\n+  e_not->value.op.op = INTRINSIC_NOT;\n+  e_not->value.op.op1 = e_cond;\n+\n+  /* Generate the EXIT statement.  */\n+  c_exit = XCNEW (gfc_code);\n+  c_exit->op = EXEC_EXIT;\n+  c_exit->ext.which_construct = co;\n+  c_exit->loc = co->loc;\n+\n+  /* Generate the IF statement.  */\n+  c_if2 = XCNEW (gfc_code);\n+  c_if2->op = EXEC_IF;\n+  c_if2->expr1 = e_not;\n+  c_if2->next = c_exit;\n+  c_if2->loc = co->loc;\n+\n+  /* ... plus the one to chain it to.  */\n+  c_if1 = XCNEW (gfc_code);\n+  c_if1->op = EXEC_IF;\n+  c_if1->block = c_if2;\n+  c_if1->loc = co->loc;\n+\n+  /* Make the DO WHILE loop into a DO block by replacing the condition\n+     with a true constant.  */\n+  co->expr1 = gfc_get_logical_expr (gfc_default_integer_kind, &co->loc, true);\n+\n+  /* Hang the generated if statement into the loop body.  */\n+\n+  loopblock = co->block->next;\n+  co->block->next = c_if1;\n+  c_if1->next = loopblock;\n+\n+  return 0;\n+}\n+\n /* Optimize a namespace, including all contained namespaces.  */\n \n static void\n@@ -415,6 +494,7 @@ optimize_namespace (gfc_namespace *ns)\n \n   current_ns = ns;\n \n+  gfc_code_walker (&ns->code, convert_do_while, dummy_expr_callback, NULL);\n   gfc_code_walker (&ns->code, cfe_code, cfe_expr_0, NULL);\n   gfc_code_walker (&ns->code, optimize_code, optimize_expr, NULL);\n "}, {"sha": "f3cb48705ac4a9ce7157d44692b66b9ad8540706", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa11ae6c728fdde8746fc77107c3a1095ac88f59/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa11ae6c728fdde8746fc77107c3a1095ac88f59/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fa11ae6c728fdde8746fc77107c3a1095ac88f59", "patch": "@@ -1,3 +1,8 @@\n+2011-09-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/50327\n+\t* gfortran.dg/do_while_1.f90:  New test.\n+\n 2011-09-11  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/35831"}, {"sha": "0a22ff37cf0ed8fcc94376145423bf5da3073f25", "filename": "gcc/testsuite/gfortran.dg/do_while_1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa11ae6c728fdde8746fc77107c3a1095ac88f59/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_while_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa11ae6c728fdde8746fc77107c3a1095ac88f59/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_while_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_while_1.f90?ref=fa11ae6c728fdde8746fc77107c3a1095ac88f59", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do run }\n+! PR 50327 - this used to cause an endless loop because\n+! of wrong fron-end optimization.\n+program main\n+  real :: tmp\n+  tmp = 0.\n+  do while (abs(tmp) < 10. .and. abs(tmp) < 20.)\n+     tmp = tmp + 1.\n+  end do\n+end program main"}]}