{"sha": "9cbbba287d1ca590c503682d72df99fa2800b985", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNiYmJhMjg3ZDFjYTU5MGM1MDM2ODJkNzJkZjk5ZmEyODAwYjk4NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-05-14T08:46:33Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-05-14T08:46:33Z"}, "message": "stor-layout.c (bit_from_pos): Distribute conversion to bitsizetype into a PLUS_EXPR byte offset.\n\n\t* stor-layout.c (bit_from_pos): Distribute conversion to bitsizetype\n\tinto a PLUS_EXPR byte offset.\n\n\t* tree-ssa-pre.c (can_value_number_call): Delete.\n\t(compute_avail): Skip all statements with side effects.\n\t<GIMPLE_CALL>: Skip calls to internal functions.\n\nFrom-SVN: r187450", "tree": {"sha": "24a9b1d109a3426404acbce3f2ac87147420a614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24a9b1d109a3426404acbce3f2ac87147420a614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cbbba287d1ca590c503682d72df99fa2800b985", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cbbba287d1ca590c503682d72df99fa2800b985", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cbbba287d1ca590c503682d72df99fa2800b985", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cbbba287d1ca590c503682d72df99fa2800b985/comments", "author": null, "committer": null, "parents": [{"sha": "5341ab80950eb02944ac1a9e25814833d51cf649", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5341ab80950eb02944ac1a9e25814833d51cf649", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5341ab80950eb02944ac1a9e25814833d51cf649"}], "stats": {"total": 57, "additions": 28, "deletions": 29}, "files": [{"sha": "752edb86ed1e5323bc31eee9d09271b132627e52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cbbba287d1ca590c503682d72df99fa2800b985/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cbbba287d1ca590c503682d72df99fa2800b985/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cbbba287d1ca590c503682d72df99fa2800b985", "patch": "@@ -1,3 +1,12 @@\n+2012-05-14  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* stor-layout.c (bit_from_pos): Distribute conversion to bitsizetype\n+\tinto a PLUS_EXPR byte offset.\n+\n+\t* tree-ssa-pre.c (can_value_number_call): Delete.\n+\t(compute_avail): Skip all statements with side effects.\n+\t<GIMPLE_CALL>: Skip calls to internal functions.\n+\n 2012-05-13  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* config/pa/pa.md: Use define_c_enum for \"unspec\" and \"unspecv\"."}, {"sha": "a592bda5c23512ab1afd299269704a9a49b52bd1", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cbbba287d1ca590c503682d72df99fa2800b985/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cbbba287d1ca590c503682d72df99fa2800b985/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=9cbbba287d1ca590c503682d72df99fa2800b985", "patch": "@@ -786,25 +786,29 @@ start_record_layout (tree t)\n }\n \n /* Return the combined bit position for the byte offset OFFSET and the\n-   bit position BITPOS.  */\n+   bit position BITPOS.\n+\n+   These functions operate on byte and bit positions present in FIELD_DECLs\n+   and assume that these expressions result in no (intermediate) overflow.\n+   This assumption is necessary to fold the expressions as much as possible,\n+   so as to avoid creating artificially variable-sized types in languages\n+   supporting variable-sized types like Ada.  */\n \n tree\n bit_from_pos (tree offset, tree bitpos)\n {\n+  if (TREE_CODE (offset) == PLUS_EXPR)\n+    offset = size_binop (PLUS_EXPR,\n+\t\t\t fold_convert (bitsizetype, TREE_OPERAND (offset, 0)),\n+\t\t\t fold_convert (bitsizetype, TREE_OPERAND (offset, 1)));\n+  else\n+    offset = fold_convert (bitsizetype, offset);\n   return size_binop (PLUS_EXPR, bitpos,\n-\t\t     size_binop (MULT_EXPR,\n-\t\t\t\t fold_convert (bitsizetype, offset),\n-\t\t\t\t bitsize_unit_node));\n+\t\t     size_binop (MULT_EXPR, offset, bitsize_unit_node));\n }\n \n /* Return the combined truncated byte position for the byte offset OFFSET and\n-   the bit position BITPOS.\n-\n-   These functions operate on byte and bit positions as present in FIELD_DECLs\n-   and assume that these expressions result in no (intermediate) overflow.\n-   This assumption is necessary to fold the expressions as much as possible,\n-   so as to avoid creating artificially variable-sized types in languages\n-   supporting variable-sized types like Ada.  */\n+   the bit position BITPOS.  */\n \n tree\n byte_from_pos (tree offset, tree bitpos)"}, {"sha": "0550879faa852e9282ab80908183058e39aa0a64", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cbbba287d1ca590c503682d72df99fa2800b985/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cbbba287d1ca590c503682d72df99fa2800b985/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=9cbbba287d1ca590c503682d72df99fa2800b985", "patch": "@@ -2586,19 +2586,6 @@ compute_antic (void)\n   sbitmap_free (changed_blocks);\n }\n \n-/* Return true if we can value number the call in STMT.  This is true\n-   if we have a pure or constant call to a real function.  */\n-\n-static bool\n-can_value_number_call (gimple stmt)\n-{\n-  if (gimple_call_internal_p (stmt))\n-    return false;\n-  if (gimple_call_flags (stmt) & (ECF_PURE | ECF_CONST))\n-    return true;\n-  return false;\n-}\n-\n /* Return true if OP is a tree which we can perform PRE on.\n    This may not match the operations we can value number, but in\n    a perfect world would.  */\n@@ -3975,8 +3962,7 @@ compute_avail (void)\n \t     or control flow.\n \t     If this isn't a call or it is the last stmt in the\n \t     basic-block then the CFG represents things correctly.  */\n-\t  if (is_gimple_call (stmt)\n-\t      && !stmt_ends_bb_p (stmt))\n+\t  if (is_gimple_call (stmt) && !stmt_ends_bb_p (stmt))\n \t    {\n \t      /* Non-looping const functions always return normally.\n \t\t Otherwise the call might not return or have side-effects\n@@ -3998,8 +3984,7 @@ compute_avail (void)\n \t      bitmap_value_insert_into_set (AVAIL_OUT (block), e);\n \t    }\n \n-\t  if (gimple_has_volatile_ops (stmt)\n-\t      || stmt_could_throw_p (stmt))\n+\t  if (gimple_has_side_effects (stmt) || stmt_could_throw_p (stmt))\n \t    continue;\n \n \t  switch (gimple_code (stmt))\n@@ -4017,7 +4002,8 @@ compute_avail (void)\n \t\tpre_expr result = NULL;\n \t\tVEC(vn_reference_op_s, heap) *ops = NULL;\n \n-\t\tif (!can_value_number_call (stmt))\n+\t\t/* We can value number only calls to real functions.  */\n+\t\tif (gimple_call_internal_p (stmt))\n \t\t  continue;\n \n \t\tcopy_reference_ops_from_call (stmt, &ops);"}]}