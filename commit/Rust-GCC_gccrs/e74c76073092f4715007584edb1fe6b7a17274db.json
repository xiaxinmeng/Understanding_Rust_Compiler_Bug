{"sha": "e74c76073092f4715007584edb1fe6b7a17274db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTc0Yzc2MDczMDkyZjQ3MTUwMDc1ODRlZGIxZmU2YjdhMTcyNzRkYg==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-26T09:48:35Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-26T11:40:16Z"}, "message": "coroutines: Handle non-method promise expressions [PR95519]\n\nThe PR  points out that the standard does not restrict promise\nexpressions to methods, but the current implementation does.\n\nThe patch factors out the building of a general promise expression,\nand then uses it in a fairly mechanical replacement of each case\nthat we need such an expressions.\n\nThis extends the handling for p.xxxxxx() expressions to cover the\ncases where the promise member is some form callable.\n\nTests are added for each of the promise expressions.\n\nIt's somewhat tortuous to find good uses for this for the\nget-return-object and get-return-object-on-allocation-failure\ncases, but they are included anyway.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95519\n\t* coroutines.cc (struct coroutine_info):Add a field\n\tto hold computed p.return_void expressions.\n\t(coro_build_promise_expression): New.\n\t(get_coroutine_return_void_expr): New.\n\t(finish_co_yield_expr): Build the promise expression\n\tusing coro_build_promise_expression.\n\t(finish_co_return_stmt): Likewise.\n\t(build_init_or_final_await): Likewise.\n\t(morph_fn_to_coro): Likewise, for several cases.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95519\n\t* g++.dg/coroutines/torture/pr95519-00-return_void.C: New test.\n\t* g++.dg/coroutines/torture/pr95519-01-initial-suspend.C: New test.\n\t* g++.dg/coroutines/torture/pr95519-02-final_suspend.C: New test.\n\t* g++.dg/coroutines/torture/pr95519-03-return-value.C: New test.\n\t* g++.dg/coroutines/torture/pr95519-04-yield-value.C: New test.\n\t* g++.dg/coroutines/torture/pr95519-05-gro.C: New test.\n\t* g++.dg/coroutines/torture/pr95519-06-grooaf.C: New test.\n\t* g++.dg/coroutines/torture/pr95519-07-unhandled-exception.C: New test.", "tree": {"sha": "4adba9f1ad297f614e5ed6055bc71f7e0045a067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4adba9f1ad297f614e5ed6055bc71f7e0045a067"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e74c76073092f4715007584edb1fe6b7a17274db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74c76073092f4715007584edb1fe6b7a17274db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e74c76073092f4715007584edb1fe6b7a17274db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e74c76073092f4715007584edb1fe6b7a17274db/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e195c8045a1f3604f0f6b339e9ff731ebd9dcb0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e195c8045a1f3604f0f6b339e9ff731ebd9dcb0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e195c8045a1f3604f0f6b339e9ff731ebd9dcb0e"}], "stats": {"total": 742, "additions": 656, "deletions": 86}, "files": [{"sha": "6e723c402db80e80e548f49969796e9ca95019ad", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 109, "deletions": 86, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=e74c76073092f4715007584edb1fe6b7a17274db", "patch": "@@ -88,6 +88,7 @@ struct GTY((for_user)) coroutine_info\n \t\t\tone that will eventually be allocated in the coroutine\n \t\t\tframe.  */\n   tree promise_proxy; /* Likewise, a proxy promise instance.  */\n+  tree return_void;   /* The expression for p.return_void() if it exists.  */\n   location_t first_coro_keyword; /* The location of the keyword that made this\n \t\t\t\t    function into a coroutine.  */\n   /* Flags to avoid repeated errors for per-function issues.  */\n@@ -554,6 +555,67 @@ lookup_promise_method (tree fndecl, tree member_id, location_t loc,\n   return pm_memb;\n }\n \n+/* Build an expression of the form p.method (args) where the p is a promise\n+   object for the current coroutine.\n+   OBJECT is the promise object instance to use, it may be NULL, in which case\n+   we will use the promise_proxy instance for this coroutine.\n+   ARGS may be NULL, for empty parm lists.  */\n+\n+static tree\n+coro_build_promise_expression (tree fn, tree promise_obj, tree member_id,\n+\t\t\t       location_t loc, vec<tree, va_gc> **args,\n+\t\t\t       bool musthave)\n+{\n+  tree meth = lookup_promise_method (fn, member_id, loc, musthave);\n+  if (meth == error_mark_node)\n+    return error_mark_node;\n+\n+  /* If we don't find it, and it isn't needed, an empty return is OK.  */\n+  if (!meth)\n+    return NULL_TREE;\n+\n+  tree promise\n+    = promise_obj ? promise_obj\n+\t\t  : get_coroutine_promise_proxy (current_function_decl);\n+  tree expr;\n+  if (BASELINK_P (meth))\n+    expr = build_new_method_call (promise, meth, args, NULL_TREE,\n+\t\t\t\t  LOOKUP_NORMAL, NULL, tf_warning_or_error);\n+  else\n+    {\n+      expr = build_class_member_access_expr (promise, meth, NULL_TREE,\n+\t\t\t\t\t     true, tf_warning_or_error);\n+      vec<tree, va_gc> *real_args;\n+      if (!args)\n+\treal_args = make_tree_vector ();\n+      else\n+\treal_args = *args;\n+      expr = build_op_call (expr, &real_args, tf_warning_or_error);\n+    }\n+  return expr;\n+}\n+\n+/* Caching get for the expression p.return_void ().  */\n+\n+static tree\n+get_coroutine_return_void_expr (tree decl, location_t loc, bool musthave)\n+{\n+  if (coroutine_info *info = get_coroutine_info (decl))\n+    {\n+      /* If we don't have it try to build it.  */\n+      if (!info->return_void)\n+\tinfo->return_void\n+\t  = coro_build_promise_expression (current_function_decl, NULL,\n+\t\t\t\t\t   coro_return_void_identifier,\n+\t\t\t\t\t   loc, NULL, musthave);\n+      /* Don't return an error if it's an optional call.  */\n+      if (!musthave && info->return_void == error_mark_node)\n+\treturn NULL_TREE;\n+      return info->return_void;\n+    }\n+  return musthave ? error_mark_node : NULL_TREE;\n+}\n+\n /* Lookup an Awaitable member, which should be await_ready, await_suspend\n    or await_resume.  */\n \n@@ -943,23 +1005,17 @@ finish_co_yield_expr (location_t kw, tree expr)\n        the promise type, and obtain its return type.  */\n     return error_mark_node;\n \n-  /* The incoming expr is \"e\" per [expr.yield] para 1, lookup and build a\n-     call for p.yield_value(e).  */\n-  tree y_meth = lookup_promise_method (current_function_decl,\n-\t\t\t\t       coro_yield_value_identifier, kw,\n-\t\t\t\t       /*musthave=*/true);\n-  if (!y_meth || y_meth == error_mark_node)\n-    return error_mark_node;\n-\n   /* [expr.yield] / 1\n      Let e be the operand of the yield-expression and p be an lvalue naming\n      the promise object of the enclosing coroutine, then the yield-expression\n      is equivalent to the expression co_await p.yield_value(e).\n      build p.yield_value(e):  */\n   vec<tree, va_gc> *args = make_tree_vector_single (expr);\n-  tree yield_call = build_new_method_call\n-    (get_coroutine_promise_proxy (current_function_decl), y_meth, &args,\n-     NULL_TREE, LOOKUP_NORMAL, NULL, tf_warning_or_error);\n+  tree yield_call\n+    = coro_build_promise_expression (current_function_decl, NULL,\n+\t\t\t\t     coro_yield_value_identifier, kw,\n+\t\t\t\t     &args, /*musthave=*/true);\n+  release_tree_vector (args);\n \n   /* Now build co_await p.yield_value (e).\n      Noting that for co_yield, there is no evaluation of any potential\n@@ -1063,27 +1119,10 @@ finish_co_return_stmt (location_t kw, tree expr)\n      there's a mis-match between the co_return <expr> and this.  */\n   tree co_ret_call = error_mark_node;\n   if (expr == NULL_TREE || VOID_TYPE_P (TREE_TYPE (expr)))\n-    {\n-      tree crv_meth\n-\t= lookup_promise_method (current_function_decl,\n-\t\t\t\t coro_return_void_identifier, kw,\n-\t\t\t\t /*musthave=*/true);\n-      if (crv_meth == error_mark_node)\n-\treturn error_mark_node;\n-\n-      co_ret_call = build_new_method_call (\n-\tget_coroutine_promise_proxy (current_function_decl), crv_meth, NULL,\n-\tNULL_TREE, LOOKUP_NORMAL, NULL, tf_warning_or_error);\n-    }\n+    co_ret_call\n+      = get_coroutine_return_void_expr (current_function_decl, kw, true);\n   else\n     {\n-      tree crv_meth\n-\t= lookup_promise_method (current_function_decl,\n-\t\t\t\t coro_return_value_identifier, kw,\n-\t\t\t\t /*musthave=*/true);\n-      if (crv_meth == error_mark_node)\n-\treturn error_mark_node;\n-\n       /* [class.copy.elision] / 3.\n \t An implicitly movable entity is a variable of automatic storage\n \t duration that is either a non-volatile object or an rvalue reference\n@@ -1096,21 +1135,24 @@ finish_co_return_stmt (location_t kw, tree expr)\n \t  && CLASS_TYPE_P (TREE_TYPE (expr))\n \t  && !TYPE_VOLATILE (TREE_TYPE (expr)))\n \t{\n-\t  vec<tree, va_gc> *args = make_tree_vector_single (move (expr));\n \t  /* It's OK if this fails... */\n-\t  co_ret_call = build_new_method_call\n-\t    (get_coroutine_promise_proxy (current_function_decl), crv_meth,\n-\t     &args, NULL_TREE, LOOKUP_NORMAL|LOOKUP_PREFER_RVALUE,\n-\t     NULL, tf_none);\n+\t  vec<tree, va_gc> *args = make_tree_vector_single (move (expr));\n+\t  co_ret_call\n+\t    = coro_build_promise_expression (current_function_decl, NULL,\n+\t\t\t\t\t     coro_return_value_identifier, kw,\n+\t\t\t\t\t     &args, /*musthave=*/false);\n+\t  release_tree_vector (args);\n \t}\n \n-      if (co_ret_call == error_mark_node)\n+      if (!co_ret_call || co_ret_call == error_mark_node)\n \t{\n-\t  vec<tree, va_gc> *args = make_tree_vector_single (expr);\n \t  /* ... but this must succeed if we didn't get the move variant.  */\n-\t  co_ret_call = build_new_method_call\n-\t    (get_coroutine_promise_proxy (current_function_decl), crv_meth,\n-\t     &args, NULL_TREE, LOOKUP_NORMAL, NULL, tf_warning_or_error);\n+\t  vec<tree, va_gc> *args = make_tree_vector_single (expr);\n+\t  co_ret_call\n+\t    = coro_build_promise_expression (current_function_decl, NULL,\n+\t\t\t\t\t     coro_return_value_identifier, kw,\n+\t\t\t\t\t     &args, /*musthave=*/true);\n+\t  release_tree_vector (args);\n \t}\n     }\n \n@@ -2585,23 +2627,18 @@ get_fn_local_identifier (tree orig, const char *append)\n   return get_identifier (an);\n }\n \n+/* Build an initial or final await initialized from the promise\n+   initial_suspend or final_suspend expression.  */\n+\n static tree\n build_init_or_final_await (location_t loc, bool is_final)\n {\n   tree suspend_alt = is_final ? coro_final_suspend_identifier\n \t\t\t      : coro_initial_suspend_identifier;\n-  tree setup_meth = lookup_promise_method (current_function_decl, suspend_alt,\n-\t\t\t\t\t   loc, /*musthave=*/true);\n-  if (!setup_meth || setup_meth == error_mark_node)\n-    return error_mark_node;\n \n-  tree s_fn = NULL_TREE;\n-  tree setup_call = build_new_method_call (\n-    get_coroutine_promise_proxy (current_function_decl), setup_meth, NULL,\n-    NULL_TREE, LOOKUP_NORMAL, &s_fn, tf_warning_or_error);\n-\n-  if (!s_fn || setup_call == error_mark_node)\n-    return error_mark_node;\n+  tree setup_call\n+    = coro_build_promise_expression (current_function_decl, NULL, suspend_alt,\n+\t\t\t\t     loc, NULL, /*musthave=*/true);\n \n   /* So build the co_await for this */\n   /* For initial/final suspends the call is \"a\" per [expr.await] 3.2.  */\n@@ -3918,22 +3955,17 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n     The unqualified-id get_return_object_on_allocation_failure is looked up\n     in the scope of the promise type by class member access lookup.  */\n \n-  tree grooaf_meth\n-    = lookup_promise_method (orig, coro_gro_on_allocation_fail_identifier,\n-\t\t\t     fn_start, /*musthave=*/false);\n-\n-  tree grooaf = NULL_TREE;\n-  tree dummy_promise = build_dummy_object (get_coroutine_promise_type (orig));\n-\n-  /* We don't require this, so lookup_promise_method can return NULL,\n+  /* We don't require this, so coro_build_promise_expression can return NULL,\n      but, if the lookup succeeds, then the function must be usable.  */\n-  if (grooaf_meth && BASELINK_P (grooaf_meth))\n-    grooaf = build_new_method_call (dummy_promise, grooaf_meth, NULL,\n-\t\t\t\t    NULL_TREE, LOOKUP_NORMAL, NULL,\n-\t\t\t\t    tf_warning_or_error);\n-\n-  /* ... but if that fails, returning an error, the later stages can't handle\n-     the erroneous expression, so we reset the call as if it was absent.  */\n+  tree dummy_promise = build_dummy_object (get_coroutine_promise_type (orig));\n+  tree grooaf\n+    = coro_build_promise_expression (orig, dummy_promise,\n+\t\t\t\t     coro_gro_on_allocation_fail_identifier,\n+\t\t\t\t     fn_start, NULL, /*musthave=*/false);\n+\n+  /* however, should that fail, returning an error, the later stages can't\n+     handle the erroneous expression, so we reset the call as if it was\n+     absent.  */\n   if (grooaf == error_mark_node)\n     grooaf = NULL_TREE;\n \n@@ -3948,7 +3980,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   if (TYPE_HAS_NEW_OPERATOR (promise_type))\n     {\n       tree fns = lookup_promise_method (orig, nwname, fn_start,\n-\t\t\t\t    /*musthave=*/true);\n+\t\t\t\t\t/*musthave=*/true);\n       /* [dcl.fct.def.coroutine] / 9 (part 2)\n \tIf the lookup finds an allocation function in the scope of the promise\n \ttype, overload resolution is performed on a function call created by\n@@ -4274,12 +4306,10 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   BIND_EXPR_BLOCK (gro_context_bind) = gro_block;\n   add_stmt (gro_context_bind);\n \n-  tree gro_meth = lookup_promise_method (orig,\n-\t\t\t\t\t coro_get_return_object_identifier,\n-\t\t\t\t\t fn_start, /*musthave=*/true );\n   tree get_ro\n-    = build_new_method_call (p, gro_meth, NULL, NULL_TREE, LOOKUP_NORMAL, NULL,\n-\t\t\t     tf_warning_or_error);\n+    = coro_build_promise_expression (orig, p,\n+\t\t\t\t     coro_get_return_object_identifier,\n+\t\t\t\t     fn_start, NULL, /*musthave=*/true);\n   /* Without a return object we haven't got much clue what's going on.  */\n   if (get_ro == error_mark_node)\n     {\n@@ -4491,14 +4521,10 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      Calls to return_value () will have to be checked and created as\n      required.  */\n \n-  tree return_void = NULL_TREE;\n-  tree rvm\n-    = lookup_promise_method (orig, coro_return_void_identifier, fn_start,\n-\t\t\t     /*musthave=*/false);\n-  if (rvm && rvm != error_mark_node)\n-    return_void\n-      = build_new_method_call (ap, rvm, NULL, NULL_TREE, LOOKUP_NORMAL, NULL,\n-\t\t\t       tf_warning_or_error);\n+  tree return_void\n+    = coro_build_promise_expression (current_function_decl, ap,\n+\t\t\t\t     coro_return_void_identifier,\n+\t\t\t\t     fn_start, NULL, /*musthave=*/false);\n \n   /* [stmt.return.coroutine] (2.2 : 3) if p.return_void() is a valid\n      expression, flowing off the end of a coroutine is equivalent to\n@@ -4516,13 +4542,10 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n \n   if (flag_exceptions)\n     {\n-      tree ueh_meth\n-\t= lookup_promise_method (orig, coro_unhandled_exception_identifier,\n-\t\t\t\t fn_start, /*musthave=*/true);\n-      /* Build promise.unhandled_exception();  */\n       tree ueh\n-\t= build_new_method_call (ap, ueh_meth, NULL, NULL_TREE, LOOKUP_NORMAL,\n-\t\t\t\t NULL, tf_warning_or_error);\n+\t= coro_build_promise_expression (current_function_decl, ap,\n+\t\t\t\t\t coro_unhandled_exception_identifier,\n+\t\t\t\t\t fn_start, NULL, /*musthave=*/true);\n \n       /* The try block is just the original function, there's no real\n \t need to call any function to do this.  */"}, {"sha": "2952d0116749fd8268018ad57f50f7d16e7d877c", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95519-00-return_void.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-00-return_void.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-00-return_void.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-00-return_void.C?ref=e74c76073092f4715007584edb1fe6b7a17274db", "patch": "@@ -0,0 +1,63 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+struct pt_b\n+{\n+    std::suspend_never initial_suspend() const noexcept { return {}; }\n+    std::suspend_never final_suspend() const noexcept { return {}; }\n+    void unhandled_exception() const noexcept {}\n+};\n+\n+int called_rv_op = 0;\n+struct rv\n+{\n+    void operator ()(){\n+        PRINT(\"call to operator \");\n+        called_rv_op++;\n+    }\n+};\n+\n+struct pt_c : pt_b\n+{\n+    using handle_t = std::coroutine_handle<pt_c>;\n+    auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+    rv return_void;\n+};\n+\n+int called_lambda = 0;\n+\n+struct pt_d : pt_b\n+{\n+    using handle_t = std::coroutine_handle<pt_d>;\n+    auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+    static constexpr auto return_void\n+      = []{ PRINT(\"call to lambda \"); called_lambda++; };\n+};\n+\n+template <> struct std::coroutine_traits<pt_c::handle_t>\n+    { using promise_type = pt_c; };\n+\n+static pt_c::handle_t foo ()\n+{\n+    co_return;\n+}\n+\n+template <> struct std::coroutine_traits<pt_d::handle_t>\n+    { using promise_type = pt_d; };\n+\n+static pt_d::handle_t bar ()\n+{\n+    co_return;\n+}\n+\n+int main ()\n+{\n+    foo ();\n+    bar ();\n+    if (called_rv_op != 1 || called_lambda != 1)\n+      {\n+        PRINT (\"Failed to call one of the return_void cases\");\n+        abort ();\n+      }\n+}"}, {"sha": "346c20dbd8ff454a5e7950110a7785310b5d8d87", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95519-01-initial-suspend.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-01-initial-suspend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-01-initial-suspend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-01-initial-suspend.C?ref=e74c76073092f4715007584edb1fe6b7a17274db", "patch": "@@ -0,0 +1,69 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+struct pt_b\n+{\n+    std::suspend_never final_suspend() const noexcept { return {}; }\n+    constexpr void return_void () noexcept {};\n+    void unhandled_exception() const noexcept {}\n+};\n+\n+int called_is_op = 0;\n+struct is\n+{\n+    std::suspend_never operator ()() noexcept {\n+        PRINT(\"call to operator IS\");\n+        called_is_op++;\n+        return {};\n+    }\n+};\n+\n+struct pt_c : pt_b\n+{\n+    using handle_t = std::coroutine_handle<pt_c>;\n+    auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+    is initial_suspend;\n+};\n+\n+int called_lambda = 0;\n+struct pt_d : pt_b\n+{\n+    using handle_t = std::coroutine_handle<pt_d>;\n+    auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+    static constexpr auto initial_suspend\n+      = []() noexcept {\n+\t   PRINT(\"call to lambda IS\");\n+\t   called_lambda++;\n+\t   return std::suspend_never{};\n+\t  };\n+};\n+\n+template <>\n+struct std::coroutine_traits<pt_c::handle_t>\n+{ using promise_type = pt_c; };\n+\n+static pt_c::handle_t foo ()\n+{\n+    co_return;\n+}\n+\n+template <>\n+struct std::coroutine_traits<pt_d::handle_t>\n+{ using promise_type = pt_d; };\n+\n+static pt_d::handle_t bar ()\n+{\n+    co_return;\n+}\n+\n+int main ()\n+{\n+    foo ();\n+    bar ();\n+    if (called_is_op != 1 || called_lambda != 1)\n+      {\n+        PRINT (\"Failed to call one of the initial_suspend cases\");\n+        abort ();\n+      }\n+}"}, {"sha": "8e7ba11c72335d47073c2447f54210e8fd7f1249", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95519-02-final_suspend.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-02-final_suspend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-02-final_suspend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-02-final_suspend.C?ref=e74c76073092f4715007584edb1fe6b7a17274db", "patch": "@@ -0,0 +1,69 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+struct pt_b\n+{\n+    std::suspend_never initial_suspend() const noexcept { return {}; }\n+    constexpr void return_void () noexcept {};\n+    void unhandled_exception() const noexcept {}\n+};\n+\n+int called_fs_op = 0;\n+struct fs\n+{\n+    auto operator ()() noexcept {\n+        PRINT(\"call to operator FS\");\n+        called_fs_op++;\n+        return std::suspend_never{};\n+    }\n+};\n+\n+struct pt_c : pt_b\n+{\n+    using handle_t = std::coroutine_handle<pt_c>;\n+    auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+    fs final_suspend;\n+};\n+\n+int called_lambda = 0;\n+struct pt_d : pt_b\n+{\n+    using handle_t = std::coroutine_handle<pt_d>;\n+    auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+    constexpr static auto final_suspend\n+      = []() noexcept {\n+\t   PRINT(\"call to lambda FS\");\n+\t   called_lambda++;\n+\t   return std::suspend_never{};\n+\t  };\n+};\n+\n+template <>\n+struct std::coroutine_traits<pt_c::handle_t>\n+{ using promise_type = pt_c; };\n+\n+static pt_c::handle_t foo ()\n+{\n+    co_return;\n+}\n+\n+template <>\n+struct std::coroutine_traits<pt_d::handle_t>\n+{ using promise_type = pt_d; };\n+\n+static pt_d::handle_t bar ()\n+{\n+    co_return;\n+}\n+\n+int main ()\n+{\n+    foo ();\n+    bar ();\n+    if (called_fs_op != 1 || called_lambda != 1)\n+      {\n+        PRINT (\"Failed to call one of the initial_suspend cases\");\n+        abort ();\n+      }\n+}"}, {"sha": "7d01509001c860f063c6a91775481d5df12fa5fa", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95519-03-return-value.C", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-03-return-value.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-03-return-value.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-03-return-value.C?ref=e74c76073092f4715007584edb1fe6b7a17274db", "patch": "@@ -0,0 +1,80 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+struct pt_b\n+{\n+    std::suspend_never initial_suspend() const noexcept { return {}; }\n+    std::suspend_never final_suspend() const noexcept { return {}; }\n+    void unhandled_exception() const noexcept {}\n+};\n+\n+int called_rv_op = 0;\n+int v;\n+\n+struct pt_c : pt_b\n+{\n+  struct rv\n+    {\n+      void operator ()(int x){\n+        PRINTF(\"call to operator ret val with %d\\n\", x);\n+        called_rv_op++;\n+        v = x;\n+//      int val () { return x; }\n+    }\n+  };\n+  using handle_t = std::coroutine_handle<pt_c>;\n+  auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+  rv return_value;\n+};\n+\n+int called_lambda = 0;\n+\n+struct pt_d : pt_b\n+{\n+  using handle_t = std::coroutine_handle<pt_d>;\n+  auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+  static constexpr auto return_value\n+    = [] (int x) { PRINTF(\"call to lambda ret val %d\\n\", x); called_lambda++; v = x;};\n+};\n+\n+template <> struct std::coroutine_traits<pt_c::handle_t>\n+    { using promise_type = pt_c; };\n+\n+static pt_c::handle_t foo ()\n+{\n+    co_return 5;\n+}\n+\n+template <> struct std::coroutine_traits<pt_d::handle_t>\n+    { using promise_type = pt_d; };\n+\n+static pt_d::handle_t bar ()\n+{\n+    co_return 3;\n+}\n+\n+int main ()\n+{\n+  /* These 'coroutines' run to completion imediately, like a regular fn.  */\n+  foo ();\n+  if (v != 5)\n+     {\n+      PRINT (\"foo failed to set v\");\n+      abort ();\n+    }\n+\n+  bar ();\n+  if (v != 3)\n+     {\n+      PRINT (\"bar failed to set v\");\n+      abort ();\n+    }\n+\n+\n+  if (called_rv_op != 1 || called_lambda != 1)\n+    {\n+      PRINT (\"Failed to call one of the return_void cases\");\n+      abort ();\n+    }\n+}"}, {"sha": "d09e5ba1075a7c895bbd99430fc4a23e8ab5fb62", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95519-04-yield-value.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-04-yield-value.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-04-yield-value.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-04-yield-value.C?ref=e74c76073092f4715007584edb1fe6b7a17274db", "patch": "@@ -0,0 +1,84 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+struct pt_b\n+{\n+  std::suspend_never initial_suspend() const noexcept { return {}; }\n+  std::suspend_never final_suspend() const noexcept { return {}; }\n+  void unhandled_exception() const noexcept {}\n+  constexpr static void return_void () noexcept {}\n+};\n+\n+int called_yv_op = 0;\n+int v;\n+\n+struct pt_c : pt_b\n+{\n+  struct yv\n+    {\n+      auto operator ()(int x){\n+        PRINTF(\"call to operator yield val with %d\\n\", x);\n+        called_yv_op++;\n+        v = x;\n+        return std::suspend_never{};\n+    }\n+  };\n+  using handle_t = std::coroutine_handle<pt_c>;\n+  auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+  yv yield_value;\n+};\n+\n+int called_lambda = 0;\n+struct pt_d : pt_b\n+{\n+  using handle_t = std::coroutine_handle<pt_d>;\n+  auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+  static constexpr auto yield_value = [] (int x) -> std::suspend_never\n+     {\n+\tPRINTF(\"call to lambda yield val %d\\n\", x);\n+\tcalled_lambda++;\n+\tv = x;\n+\treturn {};\n+    };\n+};\n+\n+template <> struct std::coroutine_traits<pt_c::handle_t>\n+    { using promise_type = pt_c; };\n+\n+static pt_c::handle_t foo ()\n+{\n+    co_yield 5;\n+}\n+\n+template <> struct std::coroutine_traits<pt_d::handle_t>\n+    { using promise_type = pt_d; };\n+\n+static pt_d::handle_t bar ()\n+{\n+    co_yield 3;\n+}\n+\n+int main ()\n+{\n+  /* These 'coroutines' run to completion imediately, like a regular fn.  */\n+  foo ();\n+  if (v != 5)\n+     {\n+      PRINT (\"foo failed to yield v\");\n+      abort ();\n+    }\n+\n+  bar ();\n+  if (v != 3)\n+     {\n+      PRINT (\"bar failed to yield v\");\n+      abort ();\n+    }\n+\n+  if (called_yv_op != 1 || called_lambda != 1)\n+    {\n+      PRINT (\"Failed to call one of the return_void cases\");\n+      abort ();\n+    }\n+}"}, {"sha": "ba0a1e3dc60c91a3ca81ee1b35028755f931fa40", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95519-05-gro.C", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-05-gro.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-05-gro.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-05-gro.C?ref=e74c76073092f4715007584edb1fe6b7a17274db", "patch": "@@ -0,0 +1,64 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+struct pt_b\n+{\n+  std::suspend_always initial_suspend() const noexcept { return {}; }\n+  std::suspend_never final_suspend() const noexcept { return {}; }\n+  constexpr void return_void () noexcept {};\n+  constexpr void unhandled_exception() const noexcept {}\n+};\n+\n+int called_gro_op = 0;\n+\n+template<typename R, typename HandleRef, typename ...T>\n+struct std::coroutine_traits<R, HandleRef, T...> {\n+  struct pt_c;\n+  using promise_type = pt_c;\n+  struct pt_c : pt_b {\n+    //using handle_t = std::coroutine_handle<pt_c>;\n+    pt_c (HandleRef h, T ...args)\n+    {  h = std::coroutine_handle<pt_c>::from_promise (*this);\n+       PRINT (\"Created Promise\");\n+       //g_promise = 1;\n+    }\n+    struct gro\n+      {\n+        auto operator ()() {\n+        PRINT(\"call to operator \");\n+        called_gro_op++;\n+        }\n+      };\n+    gro get_return_object;\n+  };\n+};\n+\n+static void\n+foo (std::coroutine_handle<>& h)\n+{\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  std::coroutine_handle<> f;\n+  foo (f);\n+  if (f.done())\n+    {\n+      PRINT (\"unexptected finished f coro\");\n+      abort ();\n+   }\n+  f.resume();\n+  if (!f.done())\n+    {\n+      PRINT (\"expected f to be finished\");\n+      abort ();\n+   }\n+\n+  if (called_gro_op != 1)\n+    {\n+      PRINT (\"Failed to call gro op\");\n+      abort ();\n+   }\n+}"}, {"sha": "b6b6bd73c9aa8f6a06ca868483b8a9fb79f64bb8", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95519-06-grooaf.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-06-grooaf.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-06-grooaf.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-06-grooaf.C?ref=e74c76073092f4715007584edb1fe6b7a17274db", "patch": "@@ -0,0 +1,49 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+struct pt_b\n+{\n+  constexpr std::suspend_never initial_suspend() noexcept { return {}; }\n+  constexpr std::suspend_never final_suspend() noexcept { return {}; }\n+  constexpr void return_void () noexcept {} \n+  constexpr void unhandled_exception() noexcept {}\n+};\n+\n+int called_grooaf = 0;\n+\n+struct pt_c : pt_b\n+{\n+  using handle_t = std::coroutine_handle<pt_c>;\n+  auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+\n+  static constexpr auto get_return_object_on_allocation_failure\n+      = []{ PRINT(\"call to lambda grooaf\");\n+\t    called_grooaf++; return std::coroutine_handle<pt_c>{};\n+\t  };\n+\n+  /* Provide an operator new, that always fails.  */\n+  void *operator new (std::size_t sz) noexcept {\n+    PRINT (\"promise_type: used failing op new\");\n+    return nullptr;\n+  }\n+};\n+\n+template <> struct std::coroutine_traits<pt_c::handle_t>\n+    { using promise_type = pt_c; };\n+\n+static pt_c::handle_t\n+foo ()\n+{\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  foo ();\n+  if (called_grooaf != 1)\n+    {\n+      PRINT (\"Failed to call grooaf\");\n+      abort ();\n+    }\n+}"}, {"sha": "be2a928ea00e3fad4a926c417e2a39771db35fb0", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr95519-07-unhandled-exception.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-07-unhandled-exception.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e74c76073092f4715007584edb1fe6b7a17274db/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-07-unhandled-exception.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr95519-07-unhandled-exception.C?ref=e74c76073092f4715007584edb1fe6b7a17274db", "patch": "@@ -0,0 +1,69 @@\n+//  { dg-do run }\n+\n+#include \"../coro.h\"\n+\n+struct pt_b\n+{\n+  constexpr std::suspend_never initial_suspend() const noexcept { return {}; }\n+  constexpr std::suspend_never final_suspend() const noexcept { return {}; }\n+  constexpr void return_void () {};\n+};\n+\n+int called_ueh_op = 0;\n+struct ueh\n+{\n+  void operator ()() noexcept {\n+    PRINT(\"call to operator UEH\");\n+    called_ueh_op++;\n+  }\n+};\n+\n+struct pt_c : pt_b\n+{\n+  using handle_t = std::coroutine_handle<pt_c>;\n+  auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+  ueh unhandled_exception;\n+};\n+\n+int lambda_ueh = 0;\n+\n+struct pt_d : pt_b\n+{\n+  using handle_t = std::coroutine_handle<pt_d>;\n+  auto get_return_object() noexcept { return handle_t::from_promise(*this); }\n+  static constexpr auto unhandled_exception\n+    = [] () noexcept { PRINT(\"call to lambda UEH\"); lambda_ueh++; };\n+};\n+\n+template <>\n+struct std::coroutine_traits<pt_c::handle_t>\n+    { using promise_type = pt_c; };\n+\n+static pt_c::handle_t\n+foo ()\n+{\n+  throw (\"foo\");\n+  co_return;\n+}\n+\n+template <> \n+struct std::coroutine_traits<pt_d::handle_t>\n+    { using promise_type = pt_d; };\n+\n+static pt_d::handle_t\n+bar ()\n+{\n+  throw (\"bar\");\n+  co_return;\n+}\n+\n+int main ()\n+{\n+  foo ();\n+  bar ();\n+  if (called_ueh_op != 1 || lambda_ueh != 1)\n+    {\n+      PRINT (\"Failed to call one of the UEH cases\");\n+      abort ();\n+    }\n+}"}]}