{"sha": "23b432076ef742fa5bb4f62c8035e079e7fb5552", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNiNDMyMDc2ZWY3NDJmYTViYjRmNjJjODAzNWUwNzllN2ZiNTU1Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-07-27T20:27:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-07-27T20:27:17Z"}, "message": "attribs.c: Include hashtab.h\n\n\t* attribs.c: Include hashtab.h\n\t(attribute_hash): New.\n\t(substring): New structure.\n\t(extract_attribute_substring, substring_hash, hash_attr, eq_attr):\n\tNew function.\n\t(init_attributes): Initialize attribute hash.\n\t(decl_attributes): Use attribute hash.\n\t* Makefile.in (attribs.c): Depend on hashtab.h.\n\nFrom-SVN: r126996", "tree": {"sha": "072bc26bf7eb930ab1d9f1e434333f8bb45c5db2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/072bc26bf7eb930ab1d9f1e434333f8bb45c5db2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23b432076ef742fa5bb4f62c8035e079e7fb5552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b432076ef742fa5bb4f62c8035e079e7fb5552", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23b432076ef742fa5bb4f62c8035e079e7fb5552", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b432076ef742fa5bb4f62c8035e079e7fb5552/comments", "author": null, "committer": null, "parents": [{"sha": "e3d693e9a31a27a23a3d90e1cb599ee0dc6bec23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d693e9a31a27a23a3d90e1cb599ee0dc6bec23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3d693e9a31a27a23a3d90e1cb599ee0dc6bec23"}], "stats": {"total": 107, "additions": 91, "deletions": 16}, "files": [{"sha": "62ba07d4c051c7428da589fa7682d360cca071f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b432076ef742fa5bb4f62c8035e079e7fb5552/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b432076ef742fa5bb4f62c8035e079e7fb5552/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23b432076ef742fa5bb4f62c8035e079e7fb5552", "patch": "@@ -1,3 +1,14 @@\n+2007-07-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* attribs.c: Include hashtab.h\n+\t(attribute_hash): New.\n+\t(substring): New structure.\n+\t(extract_attribute_substring, substring_hash, hash_attr, eq_attr):\n+\tNew function.\n+\t(init_attributes): Initialize attribute hash.\n+\t(decl_attributes): Use attribute hash.\n+\t* Makefile.in (attribs.c): Depend on hashtab.h.\n+\n 2007-07-27  Steve Ellcey  <sje@cup.hp.com>\n \n \t* config/ia64/vect.md (vec_initv2si): Remove bad BIG_ENDIAN test."}, {"sha": "5ac72f77f8e84af028f49ab3788f65aded097981", "filename": "gcc/attribs.c", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b432076ef742fa5bb4f62c8035e079e7fb5552/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b432076ef742fa5bb4f62c8035e079e7fb5552/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=23b432076ef742fa5bb4f62c8035e079e7fb5552", "patch": "@@ -32,28 +32,86 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cpplib.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n+#include \"hashtab.h\"\n \n static void init_attributes (void);\n \n /* Table of the tables of attributes (common, language, format, machine)\n    searched.  */\n static const struct attribute_spec *attribute_tables[4];\n \n+/* Hashtable mapping names (represented as substrings) to attribute specs. */\n+static htab_t attribute_hash;\n+\n+/* Substring representation.  */\n+\n+struct substring\n+{\n+  const char *str;\n+  int length;\n+};\n+\n static bool attributes_initialized = false;\n \n /* Default empty table of attributes.  */\n+\n static const struct attribute_spec empty_attribute_table[] =\n {\n   { NULL, 0, 0, false, false, false, NULL }\n };\n \n+/* Return base name of the attribute.  Ie '__attr__' is turned into 'attr'.\n+   To avoid need for copying, we simply return length of the string.  */\n+\n+static void\n+extract_attribute_substring (struct substring *str)\n+{\n+  if (str->length > 4 && str->str[0] == '_' && str->str[1] == '_'\n+      && str->str[str->length - 1] == '_' && str->str[str->length - 2] == '_')\n+    {\n+      str->length -= 4;\n+      str->str += 2;\n+    }\n+}\n+\n+/* Simple hash function to avoid need to scan whole string.  */\n+\n+static inline hashval_t\n+substring_hash (const char *str, int l)\n+{\n+  return str[0] + str[l - 1] * 256 + l * 65536;\n+}\n+\n+/* Used for attribute_hash.  */\n+\n+static hashval_t\n+hash_attr (const void *p)\n+{\n+  struct attribute_spec *spec = (struct attribute_spec *) p;\n+  int l = strlen (spec->name);\n+\n+  return substring_hash (spec->name, l);\n+}\n+\n+/* Used for attribute_hash.  */\n+\n+static int\n+eq_attr (const void *p, const void *q)\n+{\n+  const struct attribute_spec *spec = (struct attribute_spec *) p;\n+  const struct substring *str = (struct substring *) q;\n+\n+  return (!strncmp (spec->name, str->str, str->length) && !spec->name[str->length]);\n+}\n+\n /* Initialize attribute tables, and make some sanity checks\n    if --enable-checking.  */\n \n static void\n init_attributes (void)\n {\n   size_t i;\n+  int k;\n \n   attribute_tables[0] = lang_hooks.common_attribute_table;\n   attribute_tables[1] = lang_hooks.attribute_table;\n@@ -120,6 +178,21 @@ init_attributes (void)\n     }\n #endif\n \n+  attribute_hash = htab_create (200, hash_attr, eq_attr, NULL);\n+  for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n+    for (k = 0; attribute_tables[i][k].name != NULL; k++)\n+      {\n+\tstruct substring str;\n+\tvoid **slot;\n+\n+\tstr.str = attribute_tables[i][k].name;\n+\tstr.length = strlen (attribute_tables[i][k].name);\n+\tslot = htab_find_slot_with_hash (attribute_hash, &str,\n+\t\t\t\t\t substring_hash (str.str, str.length),\n+\t\t\t\t\t INSERT);\n+\tgcc_assert (!*slot);\n+\t*slot = (void *)&attribute_tables[i][k];\n+      }\n   attributes_initialized = true;\n }\n \f\n@@ -151,23 +224,13 @@ decl_attributes (tree *node, tree attributes, int flags)\n       const struct attribute_spec *spec = NULL;\n       bool no_add_attrs = 0;\n       tree fn_ptr_tmp = NULL_TREE;\n-      size_t i;\n-\n-      for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n-\t{\n-\t  int j;\n+      struct substring attr;\n \n-\t  for (j = 0; attribute_tables[i][j].name != NULL; j++)\n-\t    {\n-\t      if (is_attribute_p (attribute_tables[i][j].name, name))\n-\t\t{\n-\t\t  spec = &attribute_tables[i][j];\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (spec != NULL)\n-\t    break;\n-\t}\n+      attr.str = IDENTIFIER_POINTER (name);\n+      attr.length = IDENTIFIER_LENGTH (name);\n+      extract_attribute_substring (&attr);\n+      spec = htab_find_with_hash (attribute_hash, &attr,\n+\t\t\t\t  substring_hash (attr.str, attr.length));\n \n       if (spec == NULL)\n \t{\n@@ -183,6 +246,7 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t\t IDENTIFIER_POINTER (name));\n \t  continue;\n \t}\n+      gcc_assert (is_attribute_p (spec->name, name));\n \n       if (spec->decl_required && !DECL_P (*anode))\n \t{"}]}