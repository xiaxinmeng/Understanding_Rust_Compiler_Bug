{"sha": "781d83d96d15ee03d845d6f2894d1d76ee24e79a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgxZDgzZDk2ZDE1ZWUwM2Q4NDVkNmYyODk0ZDFkNzZlZTI0ZTc5YQ==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-02-03T10:39:09Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-02-03T10:39:09Z"}, "message": "re PR fortran/67451 ([F08] ICE with sourced allocation from coarray.)\n\ngcc/testsuite/ChangeLog:\n\n2016-02-03  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/67451\n\tPR fortran/69418\n\t* gfortran.dg/coarray_allocate_2.f08: New test.\n\t* gfortran.dg/coarray_allocate_3.f08: New test.\n\t* gfortran.dg/coarray_allocate_4.f08: New test.\n\n\ngcc/fortran/ChangeLog:\n\n2016-02-03  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\tPR fortran/67451\n\tPR fortran/69418\n\t* trans-expr.c (gfc_copy_class_to_class): For coarrays just the\n\tpointer is passed.  Take it as is without trying to deref the\n\t_data component.\n\t* trans-stmt.c (gfc_trans_allocate): Take care of coarrays as\n\targument to source=-expression.\n\nFrom-SVN: r233101", "tree": {"sha": "7c15a44a869671762c2f0e4969d988f28b52fb6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c15a44a869671762c2f0e4969d988f28b52fb6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/781d83d96d15ee03d845d6f2894d1d76ee24e79a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/781d83d96d15ee03d845d6f2894d1d76ee24e79a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/781d83d96d15ee03d845d6f2894d1d76ee24e79a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/781d83d96d15ee03d845d6f2894d1d76ee24e79a/comments", "author": null, "committer": null, "parents": [{"sha": "d8208e6d4c172278488f7fbc0b4f58fd3c490bd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8208e6d4c172278488f7fbc0b4f58fd3c490bd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8208e6d4c172278488f7fbc0b4f58fd3c490bd9"}], "stats": {"total": 142, "additions": 133, "deletions": 9}, "files": [{"sha": "dc0b8f2efd641d2558ecab16af75af8929ac844f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=781d83d96d15ee03d845d6f2894d1d76ee24e79a", "patch": "@@ -1,3 +1,13 @@\n+2016-02-03  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/67451\n+\tPR fortran/69418\n+\t* trans-expr.c (gfc_copy_class_to_class): For coarrays just the\n+\tpointer is passed.  Take it as is without trying to deref the\n+\t_data component.\n+\t* trans-stmt.c (gfc_trans_allocate): Take care of coarrays as\n+\targument to source=-expression.\n+\n 2016-02-02  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* lang.opt (fopenacc-dim=): New option."}, {"sha": "87af7acb8f24996b2d2b6c6609a18f7562200453", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=781d83d96d15ee03d845d6f2894d1d76ee24e79a", "patch": "@@ -1103,7 +1103,14 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \t}\n       else\n \t{\n-\t  from_data = gfc_class_data_get (from);\n+\t  /* Check that from is a class.  When the class is part of a coarray,\n+\t     then from is a common pointer and is to be used as is.  */\n+\t  tmp = POINTER_TYPE_P (TREE_TYPE (from))\n+\t      ? build_fold_indirect_ref (from) : from;\n+\t  from_data =\n+\t      (GFC_CLASS_TYPE_P (TREE_TYPE (tmp))\n+\t       || (DECL_P (tmp) && GFC_DECL_CLASS (tmp)))\n+\t      ? gfc_class_data_get (from) : from;\n \t  is_from_desc = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (from_data));\n \t}\n      }"}, {"sha": "5143c3109b852f89a8fb8682764ca8f1e47eb90a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=781d83d96d15ee03d845d6f2894d1d76ee24e79a", "patch": "@@ -5358,7 +5358,8 @@ gfc_trans_allocate (gfc_code * code)\n      expression.  */\n   if (code->expr3)\n     {\n-      bool vtab_needed = false, temp_var_needed = false;\n+      bool vtab_needed = false, temp_var_needed = false,\n+\t  is_coarray = gfc_is_coarray (code->expr3);\n \n       /* Figure whether we need the vtab from expr3.  */\n       for (al = code->ext.alloc.list; !vtab_needed && al != NULL;\n@@ -5392,9 +5393,9 @@ gfc_trans_allocate (gfc_code * code)\n \t\t     with the POINTER_PLUS_EXPR in this case.  */\n \t\t  if (code->expr3->ts.type == BT_CLASS\n \t\t      && TREE_CODE (se.expr) == NOP_EXPR\n-\t\t      && TREE_CODE (TREE_OPERAND (se.expr, 0))\n-\t\t\t\t\t\t\t   == POINTER_PLUS_EXPR)\n-\t\t      //&& ! GFC_CLASS_TYPE_P (TREE_TYPE (se.expr)))\n+\t\t      && (TREE_CODE (TREE_OPERAND (se.expr, 0))\n+\t\t\t\t\t\t\t    == POINTER_PLUS_EXPR\n+\t\t\t  || is_coarray))\n \t\t    se.expr = TREE_OPERAND (se.expr, 0);\n \t\t}\n \t      /* Create a temp variable only for component refs to prevent\n@@ -5435,7 +5436,7 @@ gfc_trans_allocate (gfc_code * code)\n       if (se.expr != NULL_TREE && temp_var_needed)\n \t{\n \t  tree var, desc;\n-\t  tmp = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)) ?\n+\t  tmp = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)) || is_coarray ?\n \t\tse.expr\n \t      : build_fold_indirect_ref_loc (input_location, se.expr);\n \n@@ -5448,7 +5449,7 @@ gfc_trans_allocate (gfc_code * code)\n \t    {\n \t      /* When an array_ref was in expr3, then the descriptor is the\n \t\t first operand.  */\n-\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)) || is_coarray)\n \t\t{\n \t\t  desc = TREE_OPERAND (tmp, 0);\n \t\t}\n@@ -5460,11 +5461,12 @@ gfc_trans_allocate (gfc_code * code)\n \t      e3_is = E3_DESC;\n \t    }\n \t  else\n-\t    desc = se.expr;\n+\t    desc = !is_coarray ? se.expr\n+\t\t\t       : TREE_OPERAND (TREE_OPERAND (se.expr, 0), 0);\n \t  /* We need a regular (non-UID) symbol here, therefore give a\n \t     prefix.  */\n \t  var = gfc_create_var (TREE_TYPE (tmp), \"source\");\n-\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)))\n+\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (tmp)) || is_coarray)\n \t    {\n \t      gfc_allocate_lang_decl (var);\n \t      GFC_DECL_SAVED_DESCRIPTOR (var) = desc;"}, {"sha": "03376d58166ebfd9ff5c944d20167db674e49f77", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=781d83d96d15ee03d845d6f2894d1d76ee24e79a", "patch": "@@ -1,3 +1,11 @@\n+2016-02-03  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\tPR fortran/67451\n+\tPR fortran/69418\n+\t* gfortran.dg/coarray_allocate_2.f08: New test.\n+\t* gfortran.dg/coarray_allocate_3.f08: New test.\n+\t* gfortran.dg/coarray_allocate_4.f08: New test.\n+\n 2016-02-03  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* gcc.dg/vect/vect-outer-1-big-array.c: Drop vect_multiple_sizes;"}, {"sha": "7a712a94203a59511cfadb86724ba6252087c47f", "filename": "gcc/testsuite/gfortran.dg/coarray_allocate_2.f08", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_2.f08?ref=781d83d96d15ee03d845d6f2894d1d76ee24e79a", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Contributed by Ian Harvey  <ian_harvey@bigpond.com>\n+! Extended by Andre Vehreschild  <vehre@gcc.gnu.org>\n+! to test that coarray references in allocate work now\n+! PR fortran/67451\n+\n+  program main\n+    implicit none\n+    type foo\n+      integer :: bar = 99\n+    end type\n+    class(foo), allocatable :: foobar[:]\n+    class(foo), allocatable :: some_local_object\n+    allocate(foobar[*])\n+\n+    allocate(some_local_object, source=foobar)\n+\n+    if (.not. allocated(foobar)) call abort()\n+    if (.not. allocated(some_local_object)) call abort()\n+\n+    deallocate(some_local_object)\n+    deallocate(foobar)\n+  end program\n+"}, {"sha": "46f34c08d697d40b1a586773bc07e3d142384b69", "filename": "gcc/testsuite/gfortran.dg/coarray_allocate_3.f08", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_3.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_3.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_3.f08?ref=781d83d96d15ee03d845d6f2894d1d76ee24e79a", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Contributed by Ian Harvey  <ian_harvey@bigpond.com>\n+! Extended by Andre Vehreschild  <vehre@gcc.gnu.org>\n+! to test that coarray references in allocate work now\n+! PR fortran/67451\n+\n+  program main\n+    implicit none\n+    type foo\n+      integer :: bar = 99\n+    end type\n+    class(foo), dimension(:), allocatable :: foobar[:]\n+    class(foo), dimension(:), allocatable :: some_local_object\n+    allocate(foobar(10)[*])\n+\n+    allocate(some_local_object, source=foobar)\n+\n+    if (.not. allocated(foobar)) call abort()\n+    if (lbound(foobar, 1) /= 1 .OR. ubound(foobar, 1) /= 10) call abort()\n+    if (.not. allocated(some_local_object)) call abort()\n+    if (any(some_local_object(:)%bar /= [99, 99,  99, 99, 99, 99, 99, 99, 99, 99])) call abort()\n+\n+    deallocate(some_local_object)\n+    deallocate(foobar)\n+  end program\n+"}, {"sha": "a36d7968b420e45e705cdc5ab7489171f5db65bb", "filename": "gcc/testsuite/gfortran.dg/coarray_allocate_4.f08", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_4.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/781d83d96d15ee03d845d6f2894d1d76ee24e79a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_4.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_4.f08?ref=781d83d96d15ee03d845d6f2894d1d76ee24e79a", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Contributed by Gerhard Steinmetz  <gerhard.steinmetz.fortran@t-online.de>\n+!               Andre Vehreschild <vehre@gcc.gnu.org>\n+! Check that PR fortran/69451 is fixed.\n+\n+program main\n+\n+implicit none\n+\n+type foo\n+end type\n+\n+class(foo), allocatable :: p[:]\n+class(foo), pointer :: r\n+class(*), allocatable, target :: z\n+\n+allocate(p[*])\n+\n+call s(p, z)\n+select type (z)\n+  class is (foo) \n+        r => z\n+  class default\n+     call abort()\n+end select\n+\n+if (.not. associated(r)) call abort()\n+\n+deallocate(r)\n+deallocate(p)\n+\n+contains\n+\n+subroutine s(x, z) \n+   class(*) :: x[*]\n+   class(*), allocatable:: z\n+   allocate (z, source=x)\n+end\n+\n+end\n+"}]}