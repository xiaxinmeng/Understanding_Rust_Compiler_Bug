{"sha": "3b917a5593e7264c7ff809eddf15a5905885ba92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I5MTdhNTU5M2U3MjY0YzdmZjgwOWVkZGYxNWE1OTA1ODg1YmE5Mg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-06T19:02:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-06T19:02:42Z"}, "message": "Revert changes which crept in by accident.\n\nFrom-SVN: r24526", "tree": {"sha": "924bfd81a56a68b836f018e7c912d2c219c008b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/924bfd81a56a68b836f018e7c912d2c219c008b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b917a5593e7264c7ff809eddf15a5905885ba92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b917a5593e7264c7ff809eddf15a5905885ba92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b917a5593e7264c7ff809eddf15a5905885ba92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b917a5593e7264c7ff809eddf15a5905885ba92/comments", "author": null, "committer": null, "parents": [{"sha": "44d22bef0af1c9df8d65748a7e5905ff22843f00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d22bef0af1c9df8d65748a7e5905ff22843f00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44d22bef0af1c9df8d65748a7e5905ff22843f00"}], "stats": {"total": 99, "additions": 1, "deletions": 98}, "files": [{"sha": "ed90392865e05adda1d4dbe3ddcd1ff4e1fc5336", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 98, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b917a5593e7264c7ff809eddf15a5905885ba92/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b917a5593e7264c7ff809eddf15a5905885ba92/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=3b917a5593e7264c7ff809eddf15a5905885ba92", "patch": "@@ -33,10 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n #endif\n \n-extern int frame_offset;\n-extern rtx tail_recursion_label;\n-extern rtx tail_recursion_reentry;\n-\n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first.\n \n@@ -66,8 +62,6 @@ struct arg_data\n   rtx value;\n   /* Initially-compute RTL value for argument; only for const functions.  */\n   rtx initial_value;\n-  /*  */\n-  rtx sibcall_value;\n   /* Register to pass this argument in, 0 if passed on stack, or an\n      PARALLEL if the arg is to be copied into multiple non-contiguous\n      registers.  */\n@@ -840,7 +834,6 @@ expand_call (exp, target, ignore)\n   tree actparms = TREE_OPERAND (exp, 1);\n   /* RTX for the function to be called.  */\n   rtx funexp;\n-  rtx tail_recursion_insns = NULL_RTX;\n   /* Data type of the function.  */\n   tree funtype;\n   /* Declaration of the function being called,\n@@ -1923,7 +1916,6 @@ expand_call (exp, target, ignore)\n      once we have started filling any specific hard regs.  */\n   precompute_register_parameters (num_actuals, args, &reg_parm_seen);\n \n-\n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n \n   /* Save the fixed argument area if it's part of the caller's frame and\n@@ -2071,92 +2063,6 @@ expand_call (exp, target, ignore)\n \t}\n     }\n \n-  /* See if this is a potential tail recursive call.  We can not know for\n-     sure until we have expanded the entire function into RTL and can examine\n-     the cfg and other data.  But we have to mark it and save some information\n-     now so that we can optimize it later.  */\n-  if (optimize\n-      && TREE_CODE (exp) == CALL_EXPR\n-      && TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-      && TREE_OPERAND (TREE_OPERAND (exp, 0), 0) == current_function_decl)\n-    {\n-      tree actuals, formals, a, f;\n-      int i;\n-\n-      actuals = TREE_OPERAND (exp, 1);\n-      formals = DECL_ARGUMENTS (current_function_decl);\n-      /* The caller and callee must have the same number of arguments and\n-\t they must be of compatible types and modes.  */\n-      for (a = actuals, f = formals, i = 0;\n-\t   a != NULL_TREE && f != NULL_TREE;\n-\t   a = TREE_CHAIN (a) , f = TREE_CHAIN (f), i++)\n-\t{\n-\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (a)))\n-\t      != TYPE_MAIN_VARIANT (TREE_TYPE (f)))\n-\t    break;\n-\t  if (GET_CODE (DECL_RTL (f)) != REG || DECL_MODE (f) == BLKmode)\n-\t    break;\n-\t  if (!args[i].sibcall_value)\n-\t    args[i].sibcall_value = args[i].value;\n-\t}\n-\n-      \n-      if (a == NULL_TREE && f == NULL_TREE)\n-\t{\n-\t  /* Create the tail recursion label if it has not been created\n-\t     already.  */\n-\t  if (tail_recursion_label == 0)\n-\t    {\n-\t      tail_recursion_label = gen_label_rtx ();\n-\t      emit_label_after (tail_recursion_label, tail_recursion_reentry);\n-\t    }\n-\n-\t  /* We have a potential tail recursion site.\n-\n-\t     Start a new sequence for any RTL generated which might be used\n-\t     to implement tail recursion optimizations later.  */\n-\t  push_to_sequence (0);\n-\n-\t  /* Find which actual values refer to current values of previous\n-\t     formals.  Copy each of them now, before any formal is changed.  */\n-\t  for (a = actuals, i = 0; a != NULL_TREE; a = TREE_CHAIN (a), i++)\n-\t    {\n-\t      int copy = 0, j;\n-\n-\t      for (f = formals, j = 0; j < i; f = TREE_CHAIN (f), j++)\n-\t\tif (reg_mentioned_p (DECL_RTL (f), args[i].value))\n-\t\t  {\n-\t\t    copy = 1;\n-\t\t    break;\n-\t\t  }\n-\t      if (copy)\n-\t\targs[i].sibcall_value = copy_to_reg (args[i].value);\n-\t    }\n-\n-\t  /* Store the values of the actuals into the formals.  */\n-\t  for (f = formals, a = actuals, i = 0; f != NULL_TREE;\n-\t       f = TREE_CHAIN (f), a = TREE_CHAIN (a), i++)\n-\t    {\n-\t      if (GET_MODE (DECL_RTL (f)) == GET_MODE (args[i].sibcall_value))\n-\t\temit_move_insn (DECL_RTL (f), args[i].sibcall_value);\n-\t      else\n-\t\tconvert_move (DECL_RTL (f), args[i].sibcall_value,\n-\t\t\t      TREE_UNSIGNED (TREE_TYPE (TREE_VALUE (a))));\n-\t    }\n-\n-\t  /* Emit any queued operations.  */\n-\t  emit_queue ();\n-\n-\t  /* Goto the tail recursion label.  */\n-\t  expand_goto_internal (NULL_TREE, tail_recursion_label, get_last_insn);\n-\n-\t  tail_recursion_insns = get_insns ();\n-\t  end_sequence ();\n-\t  emit_insns (tail_recursion_insns);  \n-\t  return;\n-\t}\n-    }\n-      \n   /* Perform postincrements before actually calling the function.  */\n   emit_queue ();\n \n@@ -3784,10 +3690,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size,\n      arg->stack_slot and it matters when they are not the same.\n      It isn't totally clear that this is correct in all cases.  */\n   if (partial == 0)\n-    {\n-      arg->sibcall_value = arg->value;\n-      arg->value = arg->stack_slot;\n-    }\n+    arg->value = arg->stack_slot;\n \n   /* Once we have pushed something, pops can't safely\n      be deferred during the rest of the arguments.  */"}]}