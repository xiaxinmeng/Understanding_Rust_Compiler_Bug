{"sha": "1b170b55624f9a4543692f1681bacb1d9da0ea88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIxNzBiNTU2MjRmOWE0NTQzNjkyZjE2ODFiYWNiMWQ5ZGEwZWE4OA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-06-22T18:37:10Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2003-06-22T18:37:10Z"}, "message": "Nathan C.\n\n2003-06-22  Paolo Carlini  <pcarlini@unitus.it>\n\t    Nathan C. Myers  <ncm-nospam@cantrip.org>\n\n\t* include/std/std_streambuf.h (_M_move_out_cur): _M_out_lim\n\tis now used only for filebuf, when _M_buf_unified is true.\n\tepgtr() plays the role of _M_out_lim but it's only updated\n\tupon overflow, underflow, uflow, seekoff/pos.\n\t* include/bits/sstream.tcc (_M_underflow): New, implements\n\tstringbuf::underflow and uflow.\n\t(seekoff, seekpos): Tweak, use  _M_update_egptr.\n\t* include/std/std_sstream.h (str): Rewrote, deal correctly\n\twith the new logic, in particular, when pptr() > egptr().\n\t(_M_sync): When __testout && !__testin set all the get area\n\tpointers to the current string end.\n\t(_M_update_egptr): New, internal function updating egptr()\n\tto the actual string end.\n\t(_M_underflow): New, declare.\n\t(underflow): Dispatch to _M_underflow(false).\n\t(uflow): Dispatch to _M_underflow(true).\n\n\t* include/bits/sstream.tcc (pbackfail, overflow, seekoff,\n\tseekpos): Use only the documented derivation interface to\n\tbasic_streambuf (gptr(), setg(), etc.) to work right with\n\tuser specializations.\n\t* include/std/std_sstream.h (str, _M_sync): Likewise.\n\nFrom-SVN: r68347", "tree": {"sha": "e585e329bcb33dad41e26d0e446b7fb7944596ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e585e329bcb33dad41e26d0e446b7fb7944596ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b170b55624f9a4543692f1681bacb1d9da0ea88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b170b55624f9a4543692f1681bacb1d9da0ea88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b170b55624f9a4543692f1681bacb1d9da0ea88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b170b55624f9a4543692f1681bacb1d9da0ea88/comments", "author": null, "committer": null, "parents": [{"sha": "b0a3130068590ac2dac183c970abd0e6493212a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0a3130068590ac2dac183c970abd0e6493212a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0a3130068590ac2dac183c970abd0e6493212a8"}], "stats": {"total": 228, "additions": 146, "deletions": 82}, "files": [{"sha": "d2993e4af268004a7eac12062a44044e2b682c8a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b170b55624f9a4543692f1681bacb1d9da0ea88/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b170b55624f9a4543692f1681bacb1d9da0ea88/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1b170b55624f9a4543692f1681bacb1d9da0ea88", "patch": "@@ -1,21 +1,47 @@\n+2003-06-22  Paolo Carlini  <pcarlini@unitus.it>\n+\t    Nathan C. Myers  <ncm-nospam@cantrip.org>\n+\n+\t* include/std/std_streambuf.h (_M_move_out_cur): _M_out_lim\n+\tis now used only for filebuf, when _M_buf_unified is true.\n+\tepgtr() plays the role of _M_out_lim but it's only updated\n+\tupon overflow, underflow, uflow, seekoff/pos.\n+\t* include/bits/sstream.tcc (_M_underflow): New, implements\n+\tstringbuf::underflow and uflow.\n+\t(seekoff, seekpos): Tweak, use  _M_update_egptr.\n+\t* include/std/std_sstream.h (str): Rewrote, deal correctly\n+\twith the new logic, in particular, when pptr() > egptr().\n+\t(_M_sync): When __testout && !__testin set all the get area\n+\tpointers to the current string end.\n+\t(_M_update_egptr): New, internal function updating egptr()\n+\tto the actual string end.\n+\t(_M_underflow): New, declare.\n+\t(underflow): Dispatch to _M_underflow(false).\n+\t(uflow): Dispatch to _M_underflow(true).\n+\n+\t* include/bits/sstream.tcc (pbackfail, overflow, seekoff,\n+\tseekpos): Use only the documented derivation interface to\n+\tbasic_streambuf (gptr(), setg(), etc.) to work right with\n+\tuser specializations.\n+\t* include/std/std_sstream.h (str, _M_sync): Likewise.\n+\n 2003-06-20  Doug Gregor <dgregor@apple.com>\n \n-        * testsuite/20_util/auto_ptr.cc: don't dereference NULL auto_ptr\n-        * testsuite/21_strings/basic_string/replace/char/4.cc: don't \n-            dereference end iterator.\n-        * testsuite/21_strings/basic_string/replace/wchar_t/4.cc: same.\n-        * testsuite/22_locale/ctype/narrow/char/1.cc: don't subscript with\n-            index equal to the length of a string.\n-        * testsuite/22_locale/ctype/narrow/char/2.cc: same.\n-        * testsuite/22_locale/ctype/narrow/wchar_t/1.cc: same.\n-        * testsuite/22_locale/ctype/narrow/wchar_t/2.cc: same.\n-        * testsuite/22_locale/ctype/widen/char/1.cc: same.\n-        * testsuite/22_locale/ctype/widen/wchar_t/1.cc: same.\n-        * testsuite/23_containers/list_modifiers.cc: don't dereference \n-            singular reverse iterator.\n-        * testsuite/23_containers/vector_bool.cc: don't increment singular\n-            iterator.\n-        * testsuite/24_iterators/rel_ops.cc: don't compare singular iterator.\n+\t* testsuite/20_util/auto_ptr.cc: Don't dereference NULL auto_ptr\n+\t* testsuite/21_strings/basic_string/replace/char/4.cc: Don't\n+\tdereference end iterator.\n+\t* testsuite/21_strings/basic_string/replace/wchar_t/4.cc: Same.\n+\t* testsuite/22_locale/ctype/narrow/char/1.cc: Don't subscript with\n+\tindex equal to the length of a string.\n+\t* testsuite/22_locale/ctype/narrow/char/2.cc: Same.\n+\t* testsuite/22_locale/ctype/narrow/wchar_t/1.cc: Same.\n+\t* testsuite/22_locale/ctype/narrow/wchar_t/2.cc: Same.\n+\t* testsuite/22_locale/ctype/widen/char/1.cc: Same.\n+\t* testsuite/22_locale/ctype/widen/wchar_t/1.cc: Same.\n+\t* testsuite/23_containers/list_modifiers.cc: Don't dereference\n+\tsingular reverse iterator.\n+\t* testsuite/23_containers/vector_bool.cc: Don't increment singular\n+\titerator.\n+\t* testsuite/24_iterators/rel_ops.cc: Don't compare singular iterator.\n \n 2003-06-20  Doug Gregor <dgregor@apple.com>\n "}, {"sha": "f5b4c578071d5e5382775731930091ee416314a0", "filename": "libstdc++-v3/include/bits/sstream.tcc", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b170b55624f9a4543692f1681bacb1d9da0ea88/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b170b55624f9a4543692f1681bacb1d9da0ea88/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc?ref=1b170b55624f9a4543692f1681bacb1d9da0ea88", "patch": "@@ -49,11 +49,11 @@ namespace std\n       int_type __ret = traits_type::eof();\n       const bool __testeof = traits_type::eq_int_type(__c, __ret);\n       \n-      if (this->_M_in_beg < this->_M_in_cur)\n+      if (this->eback() < this->gptr())\n \t{\n \t  const bool __testeq = traits_type::eq(traits_type::to_char_type(__c),\n-\t\t\t\t\t\tthis->_M_in_cur[-1]);\n-\t  --this->_M_in_cur;\n+\t\t\t\t\t\tthis->gptr()[-1]);\n+\t  this->gbump(-1);\n \n \t  // Try to put back __c into input sequence in one of three ways.\n \t  // Order these tests done in is unspecified by the standard.\n@@ -63,7 +63,7 @@ namespace std\n \t    __ret = traits_type::not_eof(__c);\n \t  else\n \t    {\n-\t      *this->_M_in_cur = traits_type::to_char_type(__c);\n+\t      *this->gptr() = traits_type::to_char_type(__c);\n \t      __ret = __c;\n \t    }\n \t}\n@@ -88,9 +88,9 @@ namespace std\n       // experimental value (pronounced \"arbitrary\" in some of the\n       // hipper english-speaking countries), and can be changed to\n       // suit particular needs.\n-      __size_type __len = std::max(__size_type(_M_string.capacity() + 1),\n-\t\t\t\t   __size_type(512));\n-      const bool __testput = this->_M_out_cur < this->_M_out_end;\n+      const __size_type __len = std::max(__size_type(_M_string.capacity() + 1),\n+\t\t\t\t\t __size_type(512));\n+      const bool __testput = this->pptr() < this->epptr();\n       if (__builtin_expect(!__testput && __len > _M_string.max_size(), false))\n \treturn traits_type::eof();\n \n@@ -103,18 +103,37 @@ namespace std\n \t  // growth policy builtin into basic_string.\n \t  __string_type __tmp;\n \t  __tmp.reserve(__len);\n-\t  __tmp.assign(_M_string.data(),\n-\t\t       this->_M_out_end - this->_M_out_beg);\n+\t  __tmp.assign(_M_string.data(), this->epptr() - this->pbase());\n \t  _M_string.swap(__tmp);\n-\t  // Just to be sure...\n-\t  _M_string.reserve(__len);\n \t  _M_sync(const_cast<char_type*>(_M_string.data()),\n-\t\t  this->_M_in_cur - this->_M_in_beg, \n-\t\t  this->_M_out_cur - this->_M_out_beg);\n+\t\t  this->gptr() - this->eback(), \n+\t\t  this->pptr() - this->pbase());\n \t}\n       return this->sputc(traits_type::to_char_type(__c));\n     }\n \n+  template <class _CharT, class _Traits, class _Alloc>\n+    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type \n+    basic_stringbuf<_CharT, _Traits, _Alloc>::\n+    _M_underflow(bool __bump)\n+    {\n+      int_type __ret = traits_type::eof();\n+      const bool __testin = this->_M_mode & ios_base::in;\n+      if (__testin)\n+\t{\n+\t  // Update egptr() to match the actual string end.\n+\t  _M_update_egptr();\n+\n+\t  if (this->gptr() < this->egptr())\n+\t    {\n+\t      __ret = traits_type::to_int_type(*this->gptr());\n+\t      if (__bump)\n+\t\tthis->gbump(1);\n+\t    }\n+\t}\n+      return __ret;\n+    }\n+\n   template <class _CharT, class _Traits, class _Alloc>\n     typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type\n     basic_stringbuf<_CharT, _Traits, _Alloc>::\n@@ -129,35 +148,32 @@ namespace std\n \n       if (_M_string.capacity() && (__testin || __testout || __testboth))\n \t{\n-\t  char_type* __beg = __testin ? this->_M_in_beg : this->_M_out_beg;\n+\t  char_type* __beg = __testin ? this->eback() : this->pbase();\n+\n+\t  _M_update_egptr();\n \n \t  off_type __newoffi = 0;\n \t  off_type __newoffo = 0;\n \t  if (__way == ios_base::cur)\n \t    {\n-\t      __newoffi = this->_M_in_cur - __beg;\n-\t      __newoffo = this->_M_out_cur - __beg;\n+\t      __newoffi = this->gptr() - __beg;\n+\t      __newoffo = this->pptr() - __beg;\n \t    }\n \t  else if (__way == ios_base::end)\n-\t    {\n-\t      __newoffi = this->_M_in_end - __beg;\n-\t      // Due to the resolution of DR169, ios_base::end\n-\t      // is this->_M_out_lim, not _M_out_end.\n-\t      __newoffo = this->_M_out_lim - __beg;\n-\t    }\n+\t    __newoffo = __newoffi = this->egptr() - __beg;\n \n \t  if ((__testin || __testboth)\n \t      && __newoffi + __off >= 0 \n-\t      && this->_M_in_end - __beg >= __newoffi + __off)\n+\t      && this->egptr() - __beg >= __newoffi + __off)\n \t    {\n-\t      this->_M_in_cur = __beg + __newoffi + __off;\n+\t      this->gbump((__beg + __newoffi + __off) - this->gptr());\n \t      __ret = pos_type(__newoffi);\n \t    }\n \t  if ((__testout || __testboth)\n \t      && __newoffo + __off >= 0 \n-\t      && this->_M_out_lim - __beg >= __newoffo + __off)\n+\t      && this->egptr() - __beg >= __newoffo + __off)\n \t    {\n-\t      this->_M_out_cur = __beg + __newoffo + __off;\n+\t      this->pbump((__beg + __newoffo + __off) - this->pptr());\n \t      __ret = pos_type(__newoffo);\n \t    }\n \t}\n@@ -176,23 +192,18 @@ namespace std\n \t  off_type __pos = __sp; // Use streamoff operator to do conversion.\n \t  const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;\n \t  const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;\n-\t  char_type* __beg = __testin ? this->_M_in_beg : this->_M_out_beg;\n+\t  char_type* __beg = __testin ? this->eback() : this->pbase();\n \t  \n-\t  // NB: Ordered.\n-\t  bool __testposi = false;\n-\t  bool __testposo = false;\n-\t  if (__testin && 0 <= __pos\n-\t      && __pos <=  this->_M_in_end - __beg)\n-\t    __testposi = true;\n-\t  if (__testout && 0 <= __pos\n-\t      && __pos <=  this->_M_out_lim - __beg)\n-\t    __testposo = true;\n-\t  if (__testposi || __testposo)\n+\t  _M_update_egptr();\n+\n+\t  const bool __testpos = 0 <= __pos\n+\t                         && __pos <=  this->egptr() - __beg;\n+\t  if ((__testin || __testout) && __testpos)\n \t    {\n-\t      if (__testposi)\n-\t\tthis->_M_in_cur = __beg + __pos;\n-\t      if (__testposo)\n-\t        this->_M_out_cur = __beg + __pos;\n+\t      if (__testin)\n+\t\tthis->gbump((__beg + __pos) - this->gptr());\n+\t      if (__testout)\n+                this->pbump((__beg + __pos) - this->pptr());\n \t      __ret = pos_type(off_type(__pos));\n \t    }\n \t}"}, {"sha": "687e26ad07e0ae92f7419456c97569a1c0749fc5", "filename": "libstdc++-v3/include/std/std_sstream.h", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b170b55624f9a4543692f1681bacb1d9da0ea88/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b170b55624f9a4543692f1681bacb1d9da0ea88/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h?ref=1b170b55624f9a4543692f1681bacb1d9da0ea88", "patch": "@@ -133,11 +133,17 @@ namespace std\n       __string_type\n       str() const\n       {\n-\t__string_type __ret = _M_string;\n \tconst bool __testout = this->_M_mode & ios_base::out;\n-\tif (__testout && this->_M_out_beg < this->_M_out_lim)\n-\t  __ret = __string_type(this->_M_out_beg, this->_M_out_lim);\n-\treturn __ret;\n+\tif (__testout)\n+\t  {\n+\t    // The current egptr() may not be the actual string end.\n+\t    if (this->pptr() > this->egptr())\n+\t      return __string_type(this->pbase(), this->pptr());\n+\t    else\n+ \t      return __string_type(this->pbase(), this->egptr());\n+\t  }\n+\telse\n+\t  return _M_string;\n       }\n \n       /**\n@@ -173,18 +179,18 @@ namespace std\n \t_M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);\n       }\n \n-      // Overridden virtual functions:\n+      int_type\n+      _M_underflow(bool __bump);\n+\n       // [documentation is inherited]\n       virtual int_type\n       underflow()\n-      {\n-\tint_type __ret;\n-\tif (this->_M_in_cur < this->_M_in_end)\n-\t  __ret = traits_type::to_int_type(*this->_M_in_cur);\n-\telse\n-\t  __ret = traits_type::eof();\n-\treturn __ret;\n-      }\n+      { return _M_underflow(false); }\n+\n+      // [documentation is inherited]\n+      virtual int_type\n+      uflow()\n+      { return _M_underflow(true); }\n \n       // [documentation is inherited]\n       virtual int_type\n@@ -250,18 +256,37 @@ namespace std\n       {\n \tconst bool __testin = this->_M_mode & ios_base::in;\n \tconst bool __testout = this->_M_mode & ios_base::out;\n-\t__size_type __len = _M_string.size();\n+\tconst __size_type __len = _M_string.size();\n \n \tif (__testin)\n \t  this->setg(__base, __base + __i, __base + __len);\n \tif (__testout)\n \t  {\n \t    this->setp(__base, __base + _M_string.capacity());\n-\t    // _M_out_lim points to the string end.\n-\t    this->_M_out_lim += __len;\n-\t    this->_M_out_cur += __o;\n+\t    this->pbump(__o);\n+\t    // We need a pointer to the string end anyway, even when\n+\t    // !__testin: in that case, however, for the correct\n+\t    // functioning of the streambuf inlines all the get area\n+\t    // pointers must be identical.\n+\t    if (!__testin)\n+\t      this->setg(__base + __len, __base + __len, __base + __len);\n \t  }\n       }\n+\n+      // Internal function for correctly updating egptr() to the actual\n+      // string end.\n+      void\n+      _M_update_egptr()\n+      {\n+\tconst bool __testin = this->_M_mode & ios_base::in;\n+\tconst bool __testout = this->_M_mode & ios_base::out;\n+\n+\tif (__testout && this->pptr() > this->egptr())\n+\t  if (__testin)\n+\t    this->setg(this->eback(), this->gptr(), this->pptr());\n+\t  else\n+\t    this->setg(this->pptr(), this->pptr(), this->pptr());\n+      }\n     };\n \n "}, {"sha": "fa85bf4641e87623085d3882caf1e6dfacbd2f0d", "filename": "libstdc++-v3/include/std/std_streambuf.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b170b55624f9a4543692f1681bacb1d9da0ea88/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b170b55624f9a4543692f1681bacb1d9da0ea88/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h?ref=1b170b55624f9a4543692f1681bacb1d9da0ea88", "patch": "@@ -238,17 +238,19 @@ namespace std\n       void \n       _M_move_out_cur(off_type __n) // argument needs to be +-\n       {\n-\tconst bool __testin = _M_in_cur;\n-\n \t_M_out_cur += __n;\n-\tif (__testin && _M_buf_unified)\n-\t  _M_in_cur += __n;\n-\tif (_M_out_cur > _M_out_lim)\n+\tif (__builtin_expect(_M_buf_unified, false))\n \t  {\n-\t    _M_out_lim = _M_out_cur;\n-\t    // NB: in | out buffers drag the _M_in_end pointer along...\n+\t    const bool __testin = _M_in_cur;\n \t    if (__testin)\n-\t      _M_in_end += __n;\n+\t      _M_in_cur += __n;\n+\t    if (_M_out_cur > _M_out_lim)\n+\t      {\n+\t\t_M_out_lim = _M_out_cur;\n+\t\t// NB: in | out buffers drag the _M_in_end pointer along...\n+\t\tif (__testin)\n+\t\t  _M_in_end += __n;\n+\t      }\n \t  }\n       }\n "}]}