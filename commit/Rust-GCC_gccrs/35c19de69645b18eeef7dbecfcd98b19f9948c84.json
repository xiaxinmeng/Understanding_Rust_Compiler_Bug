{"sha": "35c19de69645b18eeef7dbecfcd98b19f9948c84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVjMTlkZTY5NjQ1YjE4ZWVlZjdkYmVjZmNkOThiMTlmOTk0OGM4NA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-10T21:08:42Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-10T21:08:42Z"}, "message": "compiler: make heap expression's write barrier conditional\n    \n    Heap_expression::do_get_backend emits an unconditional write\n    barrier if the type has pointers and it is not a stack allocation.\n    This CL changes it to use a write barrier for the assignment only\n    when write barriers are enabled. While here, also change it to\n    call gcWriteBarrier instead of typedmemmove for pointer-shaped\n    types.\n    \n    For this to work, Function::build needs to be adjusted so that\n    Heap_expression::do_get_backend is called when there is a parent\n    block.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/181540\n\nFrom-SVN: r272132", "tree": {"sha": "344882ca7aca8afcf2c908ba8ab684d36c5f7413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/344882ca7aca8afcf2c908ba8ab684d36c5f7413"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35c19de69645b18eeef7dbecfcd98b19f9948c84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c19de69645b18eeef7dbecfcd98b19f9948c84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35c19de69645b18eeef7dbecfcd98b19f9948c84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c19de69645b18eeef7dbecfcd98b19f9948c84/comments", "author": null, "committer": null, "parents": [{"sha": "fc917b42658000f0c4dc87f6602336eef899fadf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc917b42658000f0c4dc87f6602336eef899fadf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc917b42658000f0c4dc87f6602336eef899fadf"}], "stats": {"total": 74, "additions": 53, "deletions": 21}, "files": [{"sha": "84c00ae570eb51f4b7f1f9ea2d6fdd41ac26ec0e", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35c19de69645b18eeef7dbecfcd98b19f9948c84/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35c19de69645b18eeef7dbecfcd98b19f9948c84/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=35c19de69645b18eeef7dbecfcd98b19f9948c84", "patch": "@@ -1,4 +1,4 @@\n-11d96c36198b75b0485d16524d521e558cf03312\n+764fe6702f2bb8650622d4102de31058e484ecb5\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d82eebd521e1a5eab62ea4b9c8125bfbf7921d41", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35c19de69645b18eeef7dbecfcd98b19f9948c84/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35c19de69645b18eeef7dbecfcd98b19f9948c84/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=35c19de69645b18eeef7dbecfcd98b19f9948c84", "patch": "@@ -16387,17 +16387,43 @@ Heap_expression::do_get_backend(Translate_context* context)\n \t\t\t\t\t    &edecl);\n       Bexpression* btempref = gogo->backend()->var_expression(btemp,\n \t\t\t\t\t\t\t      loc);\n-      Bexpression* addr = gogo->backend()->address_expression(btempref, loc);\n-\n-      Expression* td = Expression::make_type_descriptor(etype, loc);\n-      Type* etype_ptr = Type::make_pointer_type(etype);\n       space = gogo->backend()->var_expression(space_temp, loc);\n+      Type* etype_ptr = Type::make_pointer_type(etype);\n       Expression* elhs = Expression::make_backend(space, etype_ptr, loc);\n-      Expression* erhs = Expression::make_backend(addr, etype_ptr, loc);\n-      Expression* call = Runtime::make_call(Runtime::TYPEDMEMMOVE, loc, 3,\n-\t\t\t\t\t    td, elhs, erhs);\n-      Bexpression* bcall = call->get_backend(context);\n-      Bstatement* s = gogo->backend()->expression_statement(fndecl, bcall);\n+      Expression* erhs;\n+      Expression* call;\n+      if (etype->is_direct_iface_type())\n+        {\n+          // Single pointer.\n+          Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+          erhs = Expression::make_backend(btempref, etype, loc);\n+          erhs = Expression::unpack_direct_iface(erhs, loc);\n+          erhs = Expression::make_unsafe_cast(uintptr_type, erhs, loc);\n+          call = Runtime::make_call(Runtime::GCWRITEBARRIER, loc, 2,\n+                                    elhs, erhs);\n+        }\n+      else\n+        {\n+          Expression* td = Expression::make_type_descriptor(etype, loc);\n+          Bexpression* addr =\n+            gogo->backend()->address_expression(btempref, loc);\n+          erhs = Expression::make_backend(addr, etype_ptr, loc);\n+          call = Runtime::make_call(Runtime::TYPEDMEMMOVE, loc, 3,\n+                                    td, elhs, erhs);\n+        }\n+      Statement* cs = Statement::make_statement(call, false);\n+\n+      space = gogo->backend()->var_expression(space_temp, loc);\n+      Bexpression* ref =\n+        gogo->backend()->indirect_expression(expr_btype, space, true, loc);\n+      Expression* eref = Expression::make_backend(ref, etype, loc);\n+      btempref = gogo->backend()->var_expression(btemp, loc);\n+      erhs = Expression::make_backend(btempref, etype, loc);\n+      Statement* as = Statement::make_assignment(eref, erhs, loc);\n+\n+      as = gogo->check_write_barrier(context->block(), as, cs);\n+      Bstatement* s = as->get_backend(context);\n+\n       assn = gogo->backend()->compound_statement(edecl, s);\n     }\n   decl = gogo->backend()->compound_statement(decl, assn);"}, {"sha": "62d687056711f13fe2da012d0e3e90999e1d640e", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35c19de69645b18eeef7dbecfcd98b19f9948c84/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35c19de69645b18eeef7dbecfcd98b19f9948c84/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=35c19de69645b18eeef7dbecfcd98b19f9948c84", "patch": "@@ -6323,7 +6323,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n   // Variables that need to be declared for this function and their\n   // initial values.\n   std::vector<Bvariable*> vars;\n-  std::vector<Bexpression*> var_inits;\n+  std::vector<Expression*> var_inits;\n   std::vector<Statement*> var_decls_stmts;\n   for (Bindings::const_definitions_iterator p =\n \t this->block_->bindings()->begin_definitions();\n@@ -6366,7 +6366,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n                                                  loc);\n               if ((*p)->var_value()->is_in_heap())\n                 parm_ref = Expression::make_heap_expression(parm_ref, loc);\n-              var_inits.push_back(parm_ref->get_backend(&context));\n+              var_inits.push_back(parm_ref);\n \t    }\n \t  else if ((*p)->var_value()->is_in_heap())\n \t    {\n@@ -6383,7 +6383,7 @@ Function::build(Gogo* gogo, Named_object* named_function)\n \t      Expression* var_ref =\n \t\t  Expression::make_var_reference(parm_no, loc);\n \t      var_ref = Expression::make_heap_expression(var_ref, loc);\n-              var_inits.push_back(var_ref->get_backend(&context));\n+              var_inits.push_back(var_ref);\n \t    }\n           param_vars.push_back(parm_bvar);\n \t}\n@@ -6392,15 +6392,15 @@ Function::build(Gogo* gogo, Named_object* named_function)\n \t  Bvariable* bvar = (*p)->get_backend_variable(gogo, named_function);\n \n \t  Type* type = (*p)->result_var_value()->type();\n-\t  Bexpression* init;\n+\t  Expression* init;\n \t  if (!(*p)->result_var_value()->is_in_heap())\n \t    {\n \t      Btype* btype = type->get_backend(gogo);\n-\t      init = gogo->backend()->zero_expression(btype);\n+\t      Bexpression* binit = gogo->backend()->zero_expression(btype);\n+              init = Expression::make_backend(binit, type, loc);\n \t    }\n \t  else\n-\t    init = Expression::make_allocation(type,\n-\t\t\t\t\t       loc)->get_backend(&context);\n+\t    init = Expression::make_allocation(type, loc);\n \n           vars.push_back(bvar);\n           var_inits.push_back(init);\n@@ -6473,13 +6473,16 @@ Function::build(Gogo* gogo, Named_object* named_function)\n       Bblock* code_block = this->block_->get_backend(&context);\n \n       // Initialize variables if necessary.\n+      Translate_context icontext(gogo, named_function, this->block_,\n+                                 var_decls);\n       std::vector<Bstatement*> init;\n       go_assert(vars.size() == var_inits.size());\n       for (size_t i = 0; i < vars.size(); ++i)\n \t{\n+          Bexpression* binit = var_inits[i]->get_backend(&icontext);\n           Bstatement* init_stmt =\n               gogo->backend()->init_statement(this->fndecl_, vars[i],\n-                                              var_inits[i]);\n+                                              binit);\n           init.push_back(init_stmt);\n \t}\n       Bstatement* var_init = gogo->backend()->statement_list(init);"}, {"sha": "e50314b62090de1f38ef3b8546067c7ccaf40af5", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35c19de69645b18eeef7dbecfcd98b19f9948c84/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35c19de69645b18eeef7dbecfcd98b19f9948c84/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=35c19de69645b18eeef7dbecfcd98b19f9948c84", "patch": "@@ -765,6 +765,12 @@ class Gogo\n   assign_with_write_barrier(Function*, Block*, Statement_inserter*,\n \t\t\t    Expression* lhs, Expression* rhs, Location);\n \n+  // Return a statement that tests whether write barriers are enabled\n+  // and executes either the efficient code (WITHOUT) or the write\n+  // barrier function call (WITH), depending.\n+  Statement*\n+  check_write_barrier(Block*, Statement* without, Statement* with);\n+\n   // Flatten parse tree.\n   void\n   flatten();\n@@ -999,9 +1005,6 @@ class Gogo\n   Named_object*\n   write_barrier_variable();\n \n-  Statement*\n-  check_write_barrier(Block*, Statement*, Statement*);\n-\n   // Type used to map import names to packages.\n   typedef std::map<std::string, Package*> Imports;\n "}]}