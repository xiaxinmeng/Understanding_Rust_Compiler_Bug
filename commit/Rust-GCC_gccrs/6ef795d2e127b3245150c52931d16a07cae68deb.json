{"sha": "6ef795d2e127b3245150c52931d16a07cae68deb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVmNzk1ZDJlMTI3YjMyNDUxNTBjNTI5MzFkMTZhMDdjYWU2OGRlYg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2007-01-13T04:21:51Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2007-01-13T04:21:51Z"}, "message": "jcf-dump.c (main): Updated call to find_class.\n\n\t* jcf-dump.c (main): Updated call to find_class.\n\t* lang.c (java_init): Removed dead code.\n\t* jcf-parse.c (read_class): Don't use java_source field.  Removed\n\tdead code.\n\t(parse_zip_file_entries): Don't use java_source field.\n\t(process_zip_dir): Likewise.\n\t(jcf_parse): Removed dead code.\n\t(java_parse_file): Likewise.\n\t(read_class): Updated call to find_class.\n\t* jcf-io.c (find_class): Don't use java_source field.  Removed\n\t'source_ok' argument, .java logic.\n\t* jcf.h (JCF) <java_source>: Removed field.\n\t(JCF_ZERO): Updated.\t(find_class): Updated.\n\t* decl.c: Removed dead code.\n\t* class.c: Removed dead code.\n\nFrom-SVN: r120745", "tree": {"sha": "d08ac509ff5c9b7c584fc0bdcd676a230d922653", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d08ac509ff5c9b7c584fc0bdcd676a230d922653"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ef795d2e127b3245150c52931d16a07cae68deb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ef795d2e127b3245150c52931d16a07cae68deb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ef795d2e127b3245150c52931d16a07cae68deb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ef795d2e127b3245150c52931d16a07cae68deb/comments", "author": null, "committer": null, "parents": [{"sha": "86b5186f2fa3d33c7758e6894c13b28588fff89c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86b5186f2fa3d33c7758e6894c13b28588fff89c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86b5186f2fa3d33c7758e6894c13b28588fff89c"}], "stats": {"total": 406, "additions": 48, "deletions": 358}, "files": [{"sha": "19fd506f809ac37a35f22b05753eb43f2e03e9cb", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6ef795d2e127b3245150c52931d16a07cae68deb", "patch": "@@ -1,3 +1,21 @@\n+2007-01-12  Tom Tromey  <tromey@redhat.com>\n+\n+\t* jcf-dump.c (main): Updated call to find_class.\n+\t* lang.c (java_init): Removed dead code.\n+\t* jcf-parse.c (read_class): Don't use java_source field.  Removed\n+\tdead code.\n+\t(parse_zip_file_entries): Don't use java_source field.\n+\t(process_zip_dir): Likewise.\n+\t(jcf_parse): Removed dead code.\n+\t(java_parse_file): Likewise.\n+\t(read_class): Updated call to find_class.\n+\t* jcf-io.c (find_class): Don't use java_source field.  Removed\n+\t'source_ok' argument, .java logic.\n+\t* jcf.h (JCF) <java_source>: Removed field.\n+\t(JCF_ZERO): Updated.\t(find_class): Updated.\n+\t* decl.c: Removed dead code.\n+\t* class.c: Removed dead code.\n+\n 2007-01-11  Tom Tromey  <tromey@redhat.com>\n \n \t* typeck.c (convert): Don't use flag_emit_class_files."}, {"sha": "a2a70a7ab168178b9b0023f13abfdf467da089e6", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=6ef795d2e127b3245150c52931d16a07cae68deb", "patch": "@@ -669,19 +669,6 @@ add_interface (tree this_class, tree interface_class)\n   BINFO_BASE_APPEND (TYPE_BINFO (this_class), interface_binfo);\n }\n \n-#if 0\n-/* Return the address of a pointer to the first FUNCTION_DECL\n-   in the list (*LIST) whose DECL_NAME is NAME. */\n-\n-static tree *\n-find_named_method (tree *list, tree name)\n-{\n-  while (*list && DECL_NAME (*list) != name)\n-    list = &TREE_CHAIN (*list);\n-  return list;\n-}\n-#endif\n-\n static tree\n build_java_method_type (tree fntype, tree this_class, int access_flags)\n {\n@@ -842,24 +829,6 @@ set_constant_value (tree field, tree constant)\n     }\n }\n \n-/* Count the number of Unicode chars encoded in a given Ut8 string. */\n-\n-#if 0\n-int\n-strLengthUtf8 (char *str, int len)\n-{\n-  register unsigned char* ptr = (unsigned char*) str;\n-  register unsigned char *limit = ptr + len;\n-  int str_length = 0;\n-  for (; ptr < limit; str_length++) {\n-    if (UTF8_GET (ptr, limit) < 0)\n-      return -1;\n-  }\n-  return str_length;\n-}\n-#endif\n-\n-\n /* Calculate a hash value for a string encoded in Utf8 format.\n  * This returns the same hash value as specified for java.lang.String.hashCode.\n  */\n@@ -2297,36 +2266,7 @@ maybe_layout_super_class (tree super_class, tree this_class ATTRIBUTE_UNUSED)\n       if (TREE_TYPE (super_class) != NULL_TREE)\n \tsuper_class = TREE_TYPE (super_class);\n       else\n-\t{\n-#if 0\n-\t  /* do_resolve_class expects an EXPR_WITH_FILE_LOCATION, so\n-\t     we give it one.  */\n-\t  tree this_wrap = NULL_TREE;\n-\n-\t  /* Set the correct context for class resolution.  */\n-\t  current_class = this_class;\n-\n-\t  if (this_class)\n-\t    {\n-\t      tree this_decl = TYPE_NAME (this_class);\n-#ifdef USE_MAPPED_LOCATION\n-\t      this_wrap = build_expr_wfl (this_class,\n-\t\t\t\t\t  DECL_SOURCE_LOCATION (this_decl));\n-#else\n-\t      this_wrap = build_expr_wfl (this_class,\n-\t\t\t\t\t  DECL_SOURCE_FILE (this_decl),\n-\t\t\t\t\t  DECL_SOURCE_LINE (this_decl), 0);\n-#endif\n-\t    }\n-\t  super_class\n-\t    = do_resolve_class (DECL_CONTEXT (TYPE_NAME (this_class)),\n-\t\t\t\tthis_class, super_class, NULL_TREE, this_wrap);\n-\t  if (!super_class)\n-\t    return NULL_TREE;\t/* FIXME, NULL_TREE not checked by caller. */\n-\t  super_class = TREE_TYPE (super_class);\n-#endif\n-\t  gcc_unreachable ();\n-\t}\n+\tgcc_unreachable ();\n     }\n   if (!TYPE_SIZE (super_class))\n     safe_layout_class (super_class);"}, {"sha": "fcf63539092712afaeff5872077e8cfefc5797fe", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 126, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=6ef795d2e127b3245150c52931d16a07cae68deb", "patch": "@@ -1,6 +1,6 @@\n /* Process declarations and variables for the GNU compiler for the\n    Java(TM) language.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007,\n    2005, 2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -427,18 +427,6 @@ static const struct binding_level clear_binding_level\n     0, /* binding_depth */\n   };\n \n-#if 0\n-/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function\n-   that have names.  Here so we can clear out their names' definitions\n-   at the end of the function.  */\n-\n-static tree named_labels;\n-\n-/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */\n-\n-static tree shadowed_labels;\n-#endif\n-\n tree java_global_trees[JTI_MAX];\n   \n /* Build (and pushdecl) a \"promoted type\" for all standard\n@@ -625,14 +613,6 @@ java_init_decl_processing (void)\n \n   null_pointer_node = build_int_cst (ptr_type_node, 0);\n \n-#if 0\n-  /* Make a type to be the domain of a few array types\n-     whose domains don't really matter.\n-     200 is small enough that it always fits in size_t\n-     and large enough that it can hold most function names for the\n-     initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */\n-  short_array_type_node = build_prim_array_type (short_type_node, 200);\n-#endif\n   char_type_node = make_node (INTEGER_TYPE);\n   TYPE_STRING_FLAG (char_type_node) = 1;\n   TYPE_PRECISION (char_type_node) = 16;\n@@ -859,9 +839,6 @@ java_init_decl_processing (void)\n   field_info_union_node = make_node (UNION_TYPE);\n   PUSH_FIELD (field_info_union_node, field, \"boffset\", int_type_node);\n   PUSH_FIELD (field_info_union_node, field, \"addr\", ptr_type_node);\n-#if 0\n-  PUSH_FIELD (field_info_union_node, field, \"idx\", unsigned_short_type_node);\n-#endif\n   layout_type (field_info_union_node);\n \n   PUSH_FIELD (field_type_node, field, \"name\", utf8const_ptr_type);\n@@ -1106,9 +1083,6 @@ java_init_decl_processing (void)\n \n   initialize_builtins ();\n   soft_fmod_node = built_in_decls[BUILT_IN_FMOD];\n-#if 0\n-  soft_fmodf_node = built_in_decls[BUILT_IN_FMODF];\n-#endif\n \n   parse_version ();\n }\n@@ -1240,55 +1214,6 @@ pushdecl (tree x)\n \t  tree oldlocal = IDENTIFIER_LOCAL_VALUE (name);\n \t  IDENTIFIER_LOCAL_VALUE (name) = x;\n \n-#if 0\n-\t  /* Warn if shadowing an argument at the top level of the body.  */\n-\t  if (oldlocal != 0 && !DECL_EXTERNAL (x)\n-\t      /* This warning doesn't apply to the parms of a nested fcn.  */\n-\t      && ! current_binding_level->parm_flag\n-\t      /* Check that this is one level down from the parms.  */\n-\t      && current_binding_level->level_chain->parm_flag\n-\t      /* Check that the decl being shadowed\n-\t\t comes from the parm level, one level up.  */\n-\t      && chain_member (oldlocal, current_binding_level->level_chain->names))\n-\t    {\n-\t      if (TREE_CODE (oldlocal) == PARM_DECL)\n-\t\tpedwarn (\"declaration of %qs shadows a parameter\",\n-\t\t\t IDENTIFIER_POINTER (name));\n-\t      else\n-\t\tpedwarn (\"declaration of %qs shadows a symbol from the parameter list\",\n-\t\t\t IDENTIFIER_POINTER (name));\n-\t    }\n-\n-\t  /* Maybe warn if shadowing something else.  */\n-\t  else if (warn_shadow && !DECL_EXTERNAL (x)\n-\t\t   /* No shadow warnings for internally generated vars.  */\n-\t\t   && DECL_SOURCE_LINE (x) != 0\n-\t\t   /* No shadow warnings for vars made for inlining.  */\n-\t\t   && ! DECL_FROM_INLINE (x))\n-\t    {\n-\t      const char *warnstring = 0;\n-\n-\t      if (TREE_CODE (x) == PARM_DECL\n-\t\t  && current_binding_level->level_chain->parm_flag)\n-\t\t/* Don't warn about the parm names in function declarator\n-\t\t   within a function declarator.\n-\t\t   It would be nice to avoid warning in any function\n-\t\t   declarator in a declaration, as opposed to a definition,\n-\t\t   but there is no way to tell it's not a definition.  */\n-\t\t;\n-\t      else if (oldlocal != 0 && TREE_CODE (oldlocal) == PARM_DECL)\n-\t\twarnstring = \"declaration of %qs shadows a parameter\";\n-\t      else if (oldlocal != 0)\n-\t\twarnstring = \"declaration of %qs shadows previous local\";\n-\t      else if (IDENTIFIER_GLOBAL_VALUE (name) != 0\n-\t\t       && IDENTIFIER_GLOBAL_VALUE (name) != error_mark_node)\n-\t\twarnstring = \"declaration of %qs shadows global declaration\";\n-\n-\t      if (warnstring)\n-\t\twarning (0, warnstring, IDENTIFIER_POINTER (name));\n-\t    }\n-#endif\n-\n \t  /* If storing a local value, there may already be one (inherited).\n \t     If so, record it for restoration when this binding level ends.  */\n \t  if (oldlocal != 0)\n@@ -1371,14 +1296,6 @@ pushlevel (int unused ATTRIBUTE_UNUSED)\n {\n   struct binding_level *newlevel = NULL_BINDING_LEVEL;\n \n-#if 0\n-  /* If this is the top level of a function,\n-     just make sure that NAMED_LABELS is 0.  */\n-\n-  if (current_binding_level == global_binding_level)\n-    named_labels = 0;\n-#endif\n-\n   /* Reuse or create a struct for this binding level.  */\n \n   if (free_binding_level)\n@@ -1444,14 +1361,6 @@ poplevel (int keep, int reverse, int functionbody)\n   else\n     fprintf (stderr, \"pop  %s level %p pc %d\\n\",\n \t     (is_class_level) ? \"class\" : \"block\", current_binding_level, current_pc);\n-#if 0\n-  if (is_class_level != (current_binding_level == class_binding_level))\n-    {\n-      indent ();\n-      fprintf (stderr, \"XXX is_class_level != (current_binding_level == class_binding_level)\\n\");\n-    }\n-  is_class_level = 0;\n-#endif\n #endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n \n   /* Get the decls in the order they were written.\n@@ -1571,32 +1480,6 @@ poplevel (int keep, int reverse, int functionbody)\n \t found in the FUNCTION_DECL instead.  */\n \n       BLOCK_VARS (block) = 0;\n-\n-      /* Clear out the definitions of all label names,\n-\t since their scopes end here,\n-\t and add them to BLOCK_VARS.  */\n-\n-#if 0\n-      for (link = named_labels; link; link = TREE_CHAIN (link))\n-\t{\n-\t  tree label = TREE_VALUE (link);\n-\n-\t  if (DECL_INITIAL (label) == 0)\n-\t    {\n-\t      error (\"label %q+D used but not defined\", label);\n-\t      /* Avoid crashing later.  */\n-\t      define_label (input_location, DECL_NAME (label));\n-\t    }\n-\t  else if (warn_unused[UNUSED_LABEL] && !TREE_USED (label))\n-\t    warning (0, \"label %q+D defined but not used\", label);\n-\t  IDENTIFIER_LABEL_VALUE (DECL_NAME (label)) = 0;\n-\n-\t  /* Put the labels into the \"variables\" of the\n-\t     top-level block, so debugger can see them.  */\n-\t  TREE_CHAIN (label) = BLOCK_VARS (block);\n-\t  BLOCK_VARS (block) = label;\n-\t}\n-#endif\n     }\n \n   /* Pop the current level, and free the structure for reuse.  */\n@@ -1811,14 +1694,6 @@ give_name_to_locals (JCF *jcf)\n \t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n \t  DECL_LOCAL_SLOT_NUMBER (decl) = slot;\n \t  DECL_LOCAL_START_PC (decl) = start_pc;\n-#if 0\n-\t  /* FIXME: The range used internally for exceptions and local\n-\t     variable ranges, is a half-open interval: \n-\t     start_pc <= pc < end_pc.  However, the range used in the\n-\t     Java VM spec is inclusive at both ends: \n-\t     start_pc <= pc <= end_pc. */\n-\t  end_pc++;\n-#endif\n \t  DECL_LOCAL_END_PC (decl) = end_pc;\n \n \t  /* Now insert the new decl in the proper place in"}, {"sha": "85d732c9484561931dc425ff62972613b1f07d4e", "filename": "gcc/java/expr.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=6ef795d2e127b3245150c52931d16a07cae68deb", "patch": "@@ -74,10 +74,6 @@ static void expand_cond (enum tree_code, tree, int);\n static void expand_java_goto (int);\n static tree expand_java_switch (tree, int);\n static void expand_java_add_case (tree, int, int);\n-#if 0\n-static void expand_java_call (int, int);\n-static void expand_java_ret (tree); \n-#endif\n static tree pop_arguments (tree); \n static void expand_invoke (int, int, int); \n static void expand_java_field_op (int, int, int); "}, {"sha": "0dfa4c20792d5a8e33ae26499431f4d58d132740", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=6ef795d2e127b3245150c52931d16a07cae68deb", "patch": "@@ -2,7 +2,7 @@\n    Functionally similar to Sun's javap.\n \n    Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-   2006 Free Software Foundation, Inc.\n+   2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1290,7 +1290,7 @@ main (int argc, char** argv)\n       for (argi = optind; argi < argc; argi++)\n \t{\n \t  char *arg = argv[argi];\n-\t  const char *class_filename = find_class (arg, strlen (arg), jcf, 0);\n+\t  const char *class_filename = find_class (arg, strlen (arg), jcf);\n \t  if (class_filename == NULL)\n \t    class_filename = find_classfile (arg, jcf, NULL);\n \t  if (class_filename == NULL)"}, {"sha": "27b910395d2e580820b734ea2574b58d1473043d", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 7, "deletions": 69, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=6ef795d2e127b3245150c52931d16a07cae68deb", "patch": "@@ -1,6 +1,6 @@\n /* Utility routines for finding and reading Java(TM) .class files.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005,\n+   2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -437,22 +437,17 @@ static htab_t memoized_class_lookups;\n    file. */\n \n const char *\n-find_class (const char *classname, int classname_length, JCF *jcf,\n-\t    int source_ok)\n+find_class (const char *classname, int classname_length, JCF *jcf)\n {\n   int fd;\n-  int i, k, java = -1, class = -1;\n-  struct stat java_buf, class_buf;\n+  int i, k, class = -1;\n+  struct stat class_buf;\n   char *dep_file;\n   void *entry;\n-  char *java_buffer;\n   int buflen;\n   char *buffer;\n   hashval_t hash;\n \n-  /* FIXME: ecj hack.  */\n-  source_ok = 0;\n-\n   /* Create the hash table, if it does not already exist.  */\n   if (!memoized_class_lookups)\n     memoized_class_lookups = htab_create (37, \n@@ -472,10 +467,6 @@ find_class (const char *classname, int classname_length, JCF *jcf,\n   buffer = ALLOC (buflen);\n   memset (buffer, 0, buflen);\n \n-  java_buffer = alloca (buflen);\n-\n-  jcf->java_source = 0;\n-\n   for (entry = jcf_path_start (); entry != NULL; entry = jcf_path_next (entry))\n     {\n       const char *path_name = jcf_path_name (entry);\n@@ -524,39 +515,9 @@ find_class (const char *classname, int classname_length, JCF *jcf,\n \t    }\n \t  class = caching_stat(buffer, &class_buf);\n \t}\n-\n-      if (source_ok)\n-\t{\n-\t  /* Compute name of .java file.  */\n-\t  int l, m;\n-\t  strcpy (java_buffer, path_name);\n-\t  l = strlen (java_buffer);\n-\t  for (m = 0; m < classname_length; ++m)\n-\t    java_buffer[m + l] = (classname[m] == '.'\n-\t\t\t\t  ? DIR_SEPARATOR : classname[m]);\n-\t  strcpy (java_buffer + m + l, \".java\");\n-\t  java = caching_stat (java_buffer, &java_buf);\n-\t  if (java == 0)\n-\t    break;\n-\t}\n     }\n \n-  /* We preferably pick a class file if we have a chance. If the source\n-     file is newer than the class file, we issue a warning and parse the\n-     source file instead.\n-     There should be a flag to allow people have the class file picked\n-     up no matter what. FIXME. */\n-  if (! java && ! class && java_buf.st_mtime > class_buf.st_mtime)\n-    {\n-      if (flag_newer)\n-\twarning (0, \"source file for class %qs is newer than its matching class file.  Source file %qs used instead\", classname, java_buffer);\n-      class = -1;\n-    }\n-\n-  if (! java)\n-    dep_file = java_buffer;\n-  else\n-    dep_file = buffer;\n+  dep_file = buffer;\n   if (!class)\n     {\n       SOURCE_FRONTEND_DEBUG ((stderr, \"[Class selected: %s]\\n\",\n@@ -567,21 +528,6 @@ find_class (const char *classname, int classname_length, JCF *jcf,\n       if (fd >= 0)\n \tgoto found;\n     }\n-  /* Give .java a try, if necessary */\n-  if (!java)\n-    {\n-      strcpy (buffer, java_buffer);\n-      SOURCE_FRONTEND_DEBUG ((stderr, \"[Source selected: %s]\\n\",\n-\t\t\t      classname+classname_length-\n-\t\t\t      (classname_length <= 30 ? \n-\t\t\t       classname_length : 30)));\n-      fd = JCF_OPEN_EXACT_CASE (buffer, O_RDONLY);\n-      if (fd >= 0)\n-\t{\n-\t  jcf->java_source = 1;\n-\t  goto found;\n-\t}\n-    }\n \n   free (buffer);\n \n@@ -592,15 +538,7 @@ find_class (const char *classname, int classname_length, JCF *jcf,\n \n   return NULL;\n  found:\n-  if (jcf->java_source)\n-    {\n-      JCF_ZERO (jcf);\t\t/* JCF_FINISH relies on this */\n-      jcf->java_source = 1;\n-      jcf->filename = xstrdup (buffer);\n-      close (fd);\t\t/* We use STDIO for source file */\n-    }\n-  else\n-    buffer = (char *) open_class (buffer, jcf, fd, dep_file);\n+  buffer = (char *) open_class (buffer, jcf, fd, dep_file);\n   jcf->classname = xstrdup (classname);\n   return buffer;\n }"}, {"sha": "10e13aea792cd54ddf1835cdbc4b65d4d32f7c14", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 15, "deletions": 86, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=6ef795d2e127b3245150c52931d16a07cae68deb", "patch": "@@ -1295,7 +1295,7 @@ read_class (tree name)\n       \n       path_name = find_class (IDENTIFIER_POINTER (name),\n \t\t\t      IDENTIFIER_LENGTH (name),\n-\t\t\t      &this_jcf, 1);\n+\t\t\t      &this_jcf);\n       if (path_name == 0)\n \treturn 0;\n       else\n@@ -1304,72 +1304,21 @@ read_class (tree name)\n \n   current_jcf = jcf;\n \n-  if (current_jcf->java_source)\n+  if (class == NULL_TREE || ! CLASS_PARSED_P (class))\n     {\n-      gcc_unreachable ();\n-#if 0\n-      const char *filename = current_jcf->filename;\n-      char *real_path;\n-      tree given_file, real_file;\n-      FILE *finput;\n-      int generate;\n-\n-      java_parser_context_save_global ();\n-      java_push_parser_context ();\n-\n-      given_file = get_identifier (filename);\n-      filename = IDENTIFIER_POINTER (given_file);\n-      real_path = lrealpath (filename);\n-      real_file = get_identifier (real_path);\n-      free (real_path);\n-\n-      generate = IS_A_COMMAND_LINE_FILENAME_P (given_file);\n-      output_class = current_class = NULL_TREE;\n-      current_function_decl = NULL_TREE;\n-\n-      if (! HAS_BEEN_ALREADY_PARSED_P (real_file))\n-\t{\n-\t  if (! (finput = fopen (filename, \"r\")))\n-\t    fatal_error (\"can't reopen %s: %m\", filename);\n-\n-\t  parse_source_file_1 (real_file, filename, finput);\n-\t  parse_source_file_2 ();\n-\t  parse_source_file_3 ();\n-\n-\t  if (fclose (finput))\n-\t    fatal_error (\"can't close %s: %m\", input_filename);\n-#ifdef USE_MAPPED_LOCATION\n-\t  linemap_add (&line_table, LC_LEAVE, false, NULL, 0);\n-#endif\n-\t}\n-      JCF_FINISH (current_jcf);\n-      java_pop_parser_context (generate);\n-      java_parser_context_restore_global ();\n-#endif\n-    }\n-  else\n-    {\n-      if (class == NULL_TREE || ! CLASS_PARSED_P (class))\n-\t{\n-/* \t  java_parser_context_save_global (); */\n-/* \t  java_push_parser_context (); */\n-\t  output_class = current_class = class;\n-/* \t  ctxp->save_location = input_location; */\n-\t  if (JCF_SEEN_IN_ZIP (current_jcf))\n-\t    read_zip_member(current_jcf,\n-\t\t\t    current_jcf->zipd, current_jcf->zipd->zipf);\n-\t  jcf_parse (current_jcf);\n-\t  /* Parsing might change the class, in which case we have to\n-\t     put it back where we found it.  */\n-\t  if (current_class != class && icv != NULL_TREE)\n-\t    TREE_TYPE (icv) = current_class;\n-\t  class = current_class;\n-/* \t  java_pop_parser_context (0); */\n-/* \t  java_parser_context_restore_global (); */\n-\t}\n-      layout_class (class);\n-      load_inner_classes (class);\n+      output_class = current_class = class;\n+      if (JCF_SEEN_IN_ZIP (current_jcf))\n+\tread_zip_member(current_jcf,\n+\t\t\tcurrent_jcf->zipd, current_jcf->zipd->zipf);\n+      jcf_parse (current_jcf);\n+      /* Parsing might change the class, in which case we have to\n+\t put it back where we found it.  */\n+      if (current_class != class && icv != NULL_TREE)\n+\tTREE_TYPE (icv) = current_class;\n+      class = current_class;\n     }\n+  layout_class (class);\n+  load_inner_classes (class);\n \n   output_class = save_output_class;\n   current_class = save_current_class;\n@@ -1557,18 +1506,7 @@ jcf_parse (JCF* jcf)\n     TYPE_FIELDS (current_class) = nreverse (TYPE_FIELDS (current_class));\n \n   if (current_class == object_type_node)\n-    {\n-      layout_class_methods (object_type_node);\n-      /* If we don't have the right archive, emit a verbose warning.\n-\t If we're generating bytecode, emit the warning only if\n-\t -fforce-classes-archive-check was specified. */\n-#if 0\n-      /* ECJ HACK: ignore this.  */\n-      if (!jcf->right_zip\n-\t  && (!flag_emit_class_files || flag_force_classes_archive_check))\n-\tfatal_error (\"the %<java.lang.Object%> that was found in %qs didn't have the special zero-length %<gnu.gcj.gcj-compiled%> attribute.  This generally means that your classpath is incorrectly set.  Use %<info gcj \\\"Input Options\\\"%> to see the info page describing how to set the classpath\", jcf->filename);\n-#endif\n-    }\n+    layout_class_methods (object_type_node);\n   else\n     all_class_list = tree_cons (NULL_TREE,\n \t\t\t\tTYPE_NAME (current_class), all_class_list );\n@@ -2048,13 +1986,6 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \n   bitmap_obstack_release (&bit_obstack);\n \n-/*   java_expand_classes (); */\n-/*   if (java_report_errors () || flag_syntax_only) */\n-/*     return; */\n-    \n-  /* Expand all classes compiled from source.  */\n-/*   java_finish_classes (); */\n-\n  finish:\n   /* Arrange for any necessary initialization to happen.  */\n   java_emit_static_constructor ();\n@@ -2196,7 +2127,6 @@ parse_zip_file_entries (void)\n \t    JCF_ZERO (jcf);\n \t    jcf->read_state  = finput;\n \t    jcf->filbuf      = jcf_filbuf_from_stdio;\n-\t    jcf->java_source = 0;\n \t    jcf->classname   = NULL;\n \t    jcf->filename    = file_name;\n \t    jcf->zipd        = zdir;\n@@ -2270,7 +2200,6 @@ process_zip_dir (FILE *finput)\n \n       jcf->read_state  = finput;\n       jcf->filbuf      = jcf_filbuf_from_stdio;\n-      jcf->java_source = 0;\n       jcf->classname   = class_name;\n       jcf->filename    = file_name;\n       jcf->zipd        = zdir;"}, {"sha": "5a19b2f7b6377816629624fcfeef068d0ffd0482", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=6ef795d2e127b3245150c52931d16a07cae68deb", "patch": "@@ -1,6 +1,6 @@\n /* Utility macros to read Java(TM) .class files and byte codes.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+   2006, 2007 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -106,7 +106,6 @@ typedef struct JCF GTY(()) {\n   unsigned char * GTY ((skip)) buffer_end;\n   unsigned char * GTY ((skip)) read_ptr;\n   unsigned char * GTY ((skip)) read_end;\n-  unsigned int java_source : 1;\n   unsigned int right_zip : 1;\n   unsigned int finished : 1;\n   jcf_filbuf_t filbuf;\n@@ -178,7 +177,7 @@ typedef struct JCF GTY(()) {\n #define JCF_ZERO(JCF)  \\\n   ((JCF)->buffer = (JCF)->buffer_end = (JCF)->read_ptr = (JCF)->read_end = 0,\\\n    (JCF)->read_state = 0, (JCF)->filename = (JCF)->classname = 0, \\\n-   CPOOL_INIT(&(JCF)->cpool), (JCF)->java_source = 0, (JCF)->zipd = 0, \\\n+   CPOOL_INIT(&(JCF)->cpool), (JCF)->zipd = 0, \\\n    (JCF)->finished = 0)\n \n /* Given that PTR points to a 2-byte unsigned integer in network\n@@ -260,7 +259,7 @@ enum cpool_tag\n \n #define DEFAULT_CLASS_PATH \".\"\n \n-extern const char *find_class (const char *, int, JCF*, int);\n+extern const char *find_class (const char *, int, JCF *);\n extern const char *find_classfile (char *, JCF*, const char *);\n extern int jcf_filbuf_from_stdio (JCF *jcf, int count);\n extern int jcf_unexpected_eof (JCF*, int) ATTRIBUTE_NORETURN;"}, {"sha": "e5d2543450a4935de684b4765f8284a610c39270", "filename": "gcc/java/lang.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef795d2e127b3245150c52931d16a07cae68deb/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=6ef795d2e127b3245150c52931d16a07cae68deb", "patch": "@@ -353,11 +353,6 @@ FILE *finput;\n static bool\n java_init (void)\n {\n-#if 0\n-  extern int flag_minimal_debug;\n-  flag_minimal_debug = 0;\n-#endif\n-\n   /* FIXME: Indirect dispatch isn't yet compatible with static class\n      init optimization.  */\n   if (flag_indirect_dispatch)"}]}