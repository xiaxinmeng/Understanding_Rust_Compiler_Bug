{"sha": "55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTViMzRiNWZkMWVhM2U0YTFjN2VlMzBlM2E5OGQwNTg4OTJmNTY0Mg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-07-14T09:59:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-07-14T09:59:18Z"}, "message": "tree-ssa-alias.h (refs_may_alias_p_1): Declare.\n\n2009-07-14  Richard Guenther  <rguenther@suse.de>\n\tAndrey Belevantsev <abel@ispras.ru>\n\n\t* tree-ssa-alias.h (refs_may_alias_p_1): Declare.\n\t(pt_solution_set): Likewise.\n\t* tree-ssa-alias.c (refs_may_alias_p_1): Export.\n\t* tree-ssa-structalias.c (pt_solution_set): New function.\n\t* final.c (rest_of_clean_state): Free SSA data structures.\n\t* print-rtl.c (print_decl_name): Remove.\n\t(print_mem_expr): Implement in terms of print_generic_expr.\n\t* alias.c (ao_ref_from_mem): New function.\n\t(rtx_refs_may_alias_p): Likewise.\n\t(true_dependence): Query alias-export info.\n\t(canon_true_dependence): Likewise.\n\t(write_dependence_p): Likewise.\n\t* tree-dfa.c (get_ref_base_and_extent): For void types leave\n\tsize unknown.\n\t* emit-rtl.c (component_ref_for_mem_expr): Remove.\n\t(mem_expr_equal_p): Use operand_equal_p.\n\t(set_mem_attributes_minus_bitpos): Do not use\n\tcomponent_ref_for_mem_expr.\n\t* cfgexpand.c (add_partitioned_vars_to_ptset): New function.\n\t(update_alias_info_with_stack_vars): Likewise.\n\t(partition_stack_vars): Call update_alias_info_with_stack_vars.\n\t* tree-ssa.c (delete_tree_ssa): Do not release SSA names\n\texplicitly nor clear stmt operands.\n\tFree the decl-to-pointer map.\n\t* tree-optimize.c (execute_free_datastructures): Do not free\n\tSSA data structures here.\n\t* tree-flow.h (struct gimple_df): Add decls_to_pointers member.\n\t* Makefile.in (emit-rtl.o): Add pointer-set.h dependency.\n\t(alias.o): Add tree-ssa-alias.h, pointer-set.h and $(TREE_FLOW_H)\n\tdependencies.\n\t(print-rtl.o): Add $(DIAGNOSTIC_H) dependency.\n\nCo-Authored-By: Andrey Belevantsev <abel@ispras.ru>\n\nFrom-SVN: r149624", "tree": {"sha": "9a0cf325e4020743f8ce27cb07e9a9ab48e57513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a0cf325e4020743f8ce27cb07e9a9ab48e57513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1700c2e7c94fa142927b940cd3ec1ba9af3add05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1700c2e7c94fa142927b940cd3ec1ba9af3add05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1700c2e7c94fa142927b940cd3ec1ba9af3add05"}], "stats": {"total": 482, "additions": 319, "deletions": 163}, "files": [{"sha": "519c7cf7cfe171c59d407f92ab54e79875b34a20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -1,3 +1,38 @@\n+2009-07-14  Richard Guenther  <rguenther@suse.de>\n+\tAndrey Belevantsev <abel@ispras.ru>\n+\n+\t* tree-ssa-alias.h (refs_may_alias_p_1): Declare.\n+\t(pt_solution_set): Likewise.\n+\t* tree-ssa-alias.c (refs_may_alias_p_1): Export.\n+\t* tree-ssa-structalias.c (pt_solution_set): New function.\n+\t* final.c (rest_of_clean_state): Free SSA data structures.\n+\t* print-rtl.c (print_decl_name): Remove.\n+\t(print_mem_expr): Implement in terms of print_generic_expr.\n+\t* alias.c (ao_ref_from_mem): New function.\n+\t(rtx_refs_may_alias_p): Likewise.\n+\t(true_dependence): Query alias-export info.\n+\t(canon_true_dependence): Likewise.\n+\t(write_dependence_p): Likewise.\n+\t* tree-dfa.c (get_ref_base_and_extent): For void types leave\n+\tsize unknown.\n+\t* emit-rtl.c (component_ref_for_mem_expr): Remove.\n+\t(mem_expr_equal_p): Use operand_equal_p.\n+\t(set_mem_attributes_minus_bitpos): Do not use\n+\tcomponent_ref_for_mem_expr.\n+\t* cfgexpand.c (add_partitioned_vars_to_ptset): New function.\n+\t(update_alias_info_with_stack_vars): Likewise.\n+\t(partition_stack_vars): Call update_alias_info_with_stack_vars.\n+\t* tree-ssa.c (delete_tree_ssa): Do not release SSA names\n+\texplicitly nor clear stmt operands.\n+\tFree the decl-to-pointer map.\n+\t* tree-optimize.c (execute_free_datastructures): Do not free\n+\tSSA data structures here.\n+\t* tree-flow.h (struct gimple_df): Add decls_to_pointers member.\n+\t* Makefile.in (emit-rtl.o): Add pointer-set.h dependency.\n+\t(alias.o): Add tree-ssa-alias.h, pointer-set.h and $(TREE_FLOW_H)\n+\tdependencies.\n+\t(print-rtl.o): Add $(DIAGNOSTIC_H) dependency.\n+\n 2009-07-13  DJ Delorie  <dj@redhat.com>\n \n \t* config/mep/mep.h (CC1_SPEC): Tweak parameters to trigger"}, {"sha": "9567dfed7f7eadd6739f37059e1bb9fd498b1216", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -2565,7 +2565,7 @@ rtl.o : rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n \n print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) $(FLAGS_H) \\\n-    $(BCONFIG_H) $(REAL_H)\n+    $(BCONFIG_H) $(REAL_H) $(DIAGNOSTIC_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TOPLEV_H) \\\n    $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) $(REAL_H) \\\n    $(FLAGS_H) $(REGS_H) output.h $(TARGET_H) $(FUNCTION_H) $(TREE_H) \\\n@@ -2653,7 +2653,7 @@ emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \\\n    $(GGC_H) $(EXPR_H) hard-reg-set.h $(BITMAP_H) $(TOPLEV_H) $(BASIC_BLOCK_H) \\\n    $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h $(TREE_PASS_H) gt-emit-rtl.h \\\n-   $(REAL_H) $(DF_H)\n+   $(REAL_H) $(DF_H) pointer-set.h\n real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TOPLEV_H) $(TM_P_H) $(REAL_H) dfp.h\n dfp.o : dfp.c dfp.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t$(TREE_H) \\\n@@ -2978,7 +2978,8 @@ alias.o : alias.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) $(REGS_H) $(TOPLEV_H) output.h \\\n    $(ALIAS_H) $(EMIT_RTL_H) $(GGC_H) $(FUNCTION_H) cselib.h $(TREE_H) $(TM_P_H) \\\n    langhooks.h $(TARGET_H) gt-alias.h $(TIMEVAR_H) $(CGRAPH_H) \\\n-   $(SPLAY_TREE_H) $(VARRAY_H) $(IPA_TYPE_ESCAPE_H) $(DF_H) $(TREE_PASS_H)\n+   $(SPLAY_TREE_H) $(VARRAY_H) $(IPA_TYPE_ESCAPE_H) $(DF_H) $(TREE_PASS_H) \\\n+   tree-ssa-alias.h pointer-set.h $(TREE_FLOW_H)\n stack-ptr-mod.o : stack-ptr-mod.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(RTL_H) $(REGS_H) $(EXPR_H) $(TREE_PASS_H) \\\n    $(BASIC_BLOCK_H) $(FLAGS_H) output.h $(DF_H)"}, {"sha": "e9cc2d85f96e788a413a9933c340dcee7f2c7cdb", "filename": "gcc/alias.c", "status": "modified", "additions": 108, "deletions": 6, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -46,6 +46,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"ipa-type-escape.h\"\n #include \"df.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"pointer-set.h\"\n+#include \"tree-flow.h\"\n \n /* The aliasing API provided here solves related but different problems:\n \n@@ -249,6 +252,98 @@ DEF_VEC_ALLOC_P(alias_set_entry,gc);\n /* The splay-tree used to store the various alias set entries.  */\n static GTY (()) VEC(alias_set_entry,gc) *alias_sets;\n \f\n+/* Build a decomposed reference object for querying the alias-oracle\n+   from the MEM rtx and store it in *REF.\n+   Returns false if MEM is not suitable for the alias-oracle.  */\n+\n+static bool\n+ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n+{\n+  tree expr = MEM_EXPR (mem);\n+  tree base;\n+\n+  if (!expr)\n+    return false;\n+\n+  ao_ref_init (ref, expr);\n+\n+  /* Get the base of the reference and see if we have to reject or\n+     adjust it.  */\n+  base = ao_ref_base (ref);\n+  if (base == NULL_TREE)\n+    return false;\n+\n+  /* If this is a pointer dereference of a non-SSA_NAME punt.\n+     ???  We could replace it with a pointer to anything.  */\n+  if (INDIRECT_REF_P (base)\n+      && TREE_CODE (TREE_OPERAND (base, 0)) != SSA_NAME)\n+    return false;\n+\n+  /* If this is a reference based on a partitioned decl replace the\n+     base with an INDIRECT_REF of the pointer representative we\n+     created during stack slot partitioning.  */\n+  if (TREE_CODE (base) == VAR_DECL\n+      && ! TREE_STATIC (base)\n+      && cfun->gimple_df->decls_to_pointers != NULL)\n+    {\n+      void *namep;\n+      namep = pointer_map_contains (cfun->gimple_df->decls_to_pointers, base);\n+      if (namep)\n+\t{\n+\t  ref->base_alias_set = get_alias_set (base);\n+\t  ref->base = build1 (INDIRECT_REF, TREE_TYPE (base), *(tree *)namep);\n+\t}\n+    }\n+\n+  ref->ref_alias_set = MEM_ALIAS_SET (mem);\n+\n+  /* For NULL MEM_OFFSET the MEM_EXPR may have been stripped arbitrarily\n+     without recording offset or extent adjustments properly.  */\n+  if (MEM_OFFSET (mem) == NULL_RTX)\n+    {\n+      ref->offset = 0;\n+      ref->max_size = -1;\n+    }\n+  else\n+    {\n+      ref->offset += INTVAL (MEM_OFFSET (mem)) * BITS_PER_UNIT;\n+    }\n+\n+  /* NULL MEM_SIZE should not really happen with a non-NULL MEM_EXPR,\n+     but just play safe here.  The size may have been adjusted together\n+     with the offset, so we need to take it if it is set and not rely\n+     on MEM_EXPR here (which has the size determining parts potentially\n+     stripped anyway).  We lose precision for max_size which is only\n+     available from the remaining MEM_EXPR.  */\n+  if (MEM_SIZE (mem) == NULL_RTX)\n+    {\n+      ref->size = -1;\n+      ref->max_size = -1;\n+    }\n+  else\n+    {\n+      ref->size = INTVAL (MEM_SIZE (mem)) * BITS_PER_UNIT;\n+    }\n+\n+  return true;\n+}\n+\n+/* Query the alias-oracle on whether the two memory rtx X and MEM may\n+   alias.  If TBAA_P is set also apply TBAA.  Returns true if the\n+   two rtxen may alias, false otherwise.  */\n+\n+static bool\n+rtx_refs_may_alias_p (const_rtx x, const_rtx mem, bool tbaa_p)\n+{\n+  ao_ref ref1, ref2;\n+\n+  if (!ao_ref_from_mem (&ref1, x)\n+      || !ao_ref_from_mem (&ref2, mem))\n+    return true;\n+\n+  return refs_may_alias_p_1 (&ref1, &ref2, tbaa_p);\n+}\n+\n /* Returns a pointer to the alias set entry for ALIAS_SET, if there is\n    such an entry, or NULL otherwise.  */\n \n@@ -2191,8 +2286,10 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n   if (mem_mode == BLKmode || GET_MODE (x) == BLKmode)\n     return 1;\n \n-  return ! fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr,\n-\t\t\t\t\t      varies);\n+  if (fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr, varies))\n+    return 0;\n+\n+  return rtx_refs_may_alias_p (x, mem, true);\n }\n \n /* Canonical true dependence: X is read after store in MEM takes place.\n@@ -2255,8 +2352,10 @@ canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n   if (mem_mode == BLKmode || GET_MODE (x) == BLKmode)\n     return 1;\n \n-  return ! fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr,\n-\t\t\t\t\t      varies);\n+  if (fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr, varies))\n+    return 0;\n+\n+  return rtx_refs_may_alias_p (x, mem, true);\n }\n \n /* Returns nonzero if a write to X might alias a previous read from\n@@ -2316,8 +2415,11 @@ write_dependence_p (const_rtx mem, const_rtx x, int writep)\n     = fixed_scalar_and_varying_struct_p (mem, x, mem_addr, x_addr,\n \t\t\t\t\t rtx_addr_varies_p);\n \n-  return (!(fixed_scalar == mem && !aliases_everything_p (x))\n-\t  && !(fixed_scalar == x && !aliases_everything_p (mem)));\n+  if ((fixed_scalar == mem && !aliases_everything_p (x))\n+      || (fixed_scalar == x && !aliases_everything_p (mem)))\n+    return 0;\n+\n+  return rtx_refs_may_alias_p (x, mem, false);\n }\n \n /* Anti dependence: X is written after read in MEM takes place.  */"}, {"sha": "89a73634cb2965269ad33726083f7ed156bee283", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -784,6 +784,133 @@ stack_var_size_cmp (const void *a, const void *b)\n   return 0;\n }\n \n+\n+/* If the points-to solution *PI points to variables that are in a partition\n+   together with other variables add all partition members to the pointed-to\n+   variables bitmap.  */\n+\n+static void\n+add_partitioned_vars_to_ptset (struct pt_solution *pt,\n+\t\t\t       struct pointer_map_t *decls_to_partitions,\n+\t\t\t       struct pointer_set_t *visited, bitmap temp)\n+{\n+  bitmap_iterator bi;\n+  unsigned i;\n+  bitmap *part;\n+\n+  if (pt->anything\n+      || pt->vars == NULL\n+      /* The pointed-to vars bitmap is shared, it is enough to\n+\t visit it once.  */\n+      || pointer_set_insert(visited, pt->vars))\n+    return;\n+\n+  bitmap_clear (temp);\n+\n+  /* By using a temporary bitmap to store all members of the partitions\n+     we have to add we make sure to visit each of the partitions only\n+     once.  */\n+  EXECUTE_IF_SET_IN_BITMAP (pt->vars, 0, i, bi)\n+    if ((!temp\n+\t || !bitmap_bit_p (temp, i))\n+\t&& (part = (bitmap *) pointer_map_contains (decls_to_partitions,\n+\t\t\t\t\t\t    (void *)(size_t) i)))\n+      bitmap_ior_into (temp, *part);\n+  if (!bitmap_empty_p (temp))\n+    bitmap_ior_into (pt->vars, temp);\n+}\n+\n+/* Update points-to sets based on partition info, so we can use them on RTL.\n+   The bitmaps representing stack partitions will be saved until expand,\n+   where partitioned decls used as bases in memory expressions will be\n+   rewritten.  */\n+\n+static void\n+update_alias_info_with_stack_vars (void)\n+{\n+  struct pointer_map_t *decls_to_partitions = NULL;\n+  size_t i, j;\n+  tree var = NULL_TREE;\n+\n+  for (i = 0; i < stack_vars_num; i++)\n+    {\n+      bitmap part = NULL;\n+      tree name;\n+      struct ptr_info_def *pi;\n+\n+      /* Not interested in partitions with single variable.  */\n+      if (stack_vars[i].representative != i\n+          || stack_vars[i].next == EOC)\n+        continue;\n+\n+      if (!decls_to_partitions)\n+\t{\n+\t  decls_to_partitions = pointer_map_create ();\n+\t  cfun->gimple_df->decls_to_pointers = pointer_map_create ();\n+\t}\n+\n+      /* Create an SSA_NAME that points to the partition for use\n+         as base during alias-oracle queries on RTL for bases that\n+\t have been partitioned.  */\n+      if (var == NULL_TREE)\n+\tvar = create_tmp_var (ptr_type_node, NULL);\n+      name = make_ssa_name (var, NULL);\n+\n+      /* Create bitmaps representing partitions.  They will be used for\n+         points-to sets later, so use GGC alloc.  */\n+      part = BITMAP_GGC_ALLOC ();\n+      for (j = i; j != EOC; j = stack_vars[j].next)\n+\t{\n+\t  tree decl = stack_vars[j].decl;\n+\t  unsigned int uid = DECL_UID (decl);\n+\t  /* We should never end up partitioning SSA names (though they\n+\t     may end up on the stack).  Neither should we allocate stack\n+\t     space to something that is unused and thus unreferenced.  */\n+\t  gcc_assert (DECL_P (decl)\n+\t\t      && referenced_var_lookup (uid));\n+\t  bitmap_set_bit (part, uid);\n+\t  *((bitmap *) pointer_map_insert (decls_to_partitions,\n+\t\t\t\t\t   (void *)(size_t) uid)) = part;\n+\t  *((tree *) pointer_map_insert (cfun->gimple_df->decls_to_pointers,\n+\t\t\t\t\t decl)) = name;\n+\t}\n+\n+      /* Make the SSA name point to all partition members.  */\n+      pi = get_ptr_info (name);\n+      pt_solution_set (&pi->pt, part);\n+    }\n+\n+  /* Make all points-to sets that contain one member of a partition\n+     contain all members of the partition.  */\n+  if (decls_to_partitions)\n+    {\n+      unsigned i;\n+      struct pointer_set_t *visited = pointer_set_create ();\n+      bitmap temp = BITMAP_ALLOC (NULL);\n+\n+      for (i = 1; i < num_ssa_names; i++)\n+\t{\n+\t  tree name = ssa_name (i);\n+\t  struct ptr_info_def *pi;\n+\n+\t  if (name\n+\t      && POINTER_TYPE_P (TREE_TYPE (name))\n+\t      && ((pi = SSA_NAME_PTR_INFO (name)) != NULL))\n+\t    add_partitioned_vars_to_ptset (&pi->pt, decls_to_partitions,\n+\t\t\t\t\t   visited, temp);\n+\t}\n+\n+      add_partitioned_vars_to_ptset (&cfun->gimple_df->escaped,\n+\t\t\t\t     decls_to_partitions, visited, temp);\n+      add_partitioned_vars_to_ptset (&cfun->gimple_df->callused,\n+\t\t\t\t     decls_to_partitions, visited, temp);\n+\n+      pointer_set_destroy (visited);\n+      pointer_map_destroy (decls_to_partitions);\n+      BITMAP_FREE (temp);\n+    }\n+}\n+\n /* A subroutine of partition_stack_vars.  The UNION portion of a UNION/FIND\n    partitioning algorithm.  Partitions A and B are known to be non-conflicting.\n    Merge them into a single partition A.\n@@ -903,6 +1030,8 @@ partition_stack_vars (void)\n \t    break;\n \t}\n     }\n+\n+  update_alias_info_with_stack_vars ();\n }\n \n /* A debugging aid for expand_used_vars.  Dump the generated partitions.  */"}, {"sha": "5b42f4a87786e3c0f405760c7212cbb5f4236865", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -197,7 +197,6 @@ static mem_attrs *get_mem_attrs (alias_set_type, tree, rtx, rtx, unsigned int,\n static hashval_t reg_attrs_htab_hash (const void *);\n static int reg_attrs_htab_eq (const void *, const void *);\n static reg_attrs *get_reg_attrs (tree, int);\n-static tree component_ref_for_mem_expr (tree);\n static rtx gen_const_vector (enum machine_mode, int);\n static void copy_rtx_if_shared_1 (rtx *orig);\n \n@@ -1429,40 +1428,6 @@ operand_subword_force (rtx op, unsigned int offset, enum machine_mode mode)\n   return result;\n }\n \f\n-/* Within a MEM_EXPR, we care about either (1) a component ref of a decl,\n-   or (2) a component ref of something variable.  Represent the later with\n-   a NULL expression.  */\n-\n-static tree\n-component_ref_for_mem_expr (tree ref)\n-{\n-  tree inner = TREE_OPERAND (ref, 0);\n-\n-  if (TREE_CODE (inner) == COMPONENT_REF)\n-    inner = component_ref_for_mem_expr (inner);\n-  else\n-    {\n-      /* Now remove any conversions: they don't change what the underlying\n-\t object is.  Likewise for SAVE_EXPR.  */\n-      while (CONVERT_EXPR_P (inner)\n-\t     || TREE_CODE (inner) == VIEW_CONVERT_EXPR\n-\t     || TREE_CODE (inner) == SAVE_EXPR)\n-\tinner = TREE_OPERAND (inner, 0);\n-\n-      if (! DECL_P (inner))\n-\tinner = NULL_TREE;\n-    }\n-\n-  if (inner == TREE_OPERAND (ref, 0)\n-      /* Don't leak SSA-names in the third operand.  */\n-      && (!TREE_OPERAND (ref, 2)\n-\t  || TREE_CODE (TREE_OPERAND (ref, 2)) != SSA_NAME))\n-    return ref;\n-  else\n-    return build3 (COMPONENT_REF, TREE_TYPE (ref), inner,\n-\t\t   TREE_OPERAND (ref, 1), NULL_TREE);\n-}\n-\n /* Returns 1 if both MEM_EXPR can be considered equal\n    and 0 otherwise.  */\n \n@@ -1478,23 +1443,7 @@ mem_expr_equal_p (const_tree expr1, const_tree expr2)\n   if (TREE_CODE (expr1) != TREE_CODE (expr2))\n     return 0;\n \n-  if (TREE_CODE (expr1) == COMPONENT_REF)\n-    return \n-      mem_expr_equal_p (TREE_OPERAND (expr1, 0),\n-\t\t\tTREE_OPERAND (expr2, 0))\n-      && mem_expr_equal_p (TREE_OPERAND (expr1, 1), /* field decl */\n-\t\t\t   TREE_OPERAND (expr2, 1));\n-  \n-  if (INDIRECT_REF_P (expr1))\n-    return mem_expr_equal_p (TREE_OPERAND (expr1, 0),\n-\t\t\t     TREE_OPERAND (expr2, 0));\n-\n-  /* ARRAY_REFs, ARRAY_RANGE_REFs and BIT_FIELD_REFs should already\n-\t      have been resolved here.  */\n-  gcc_assert (DECL_P (expr1));\n-  \n-  /* Decls with different pointers can't be equal.  */\n-  return 0;\n+  return operand_equal_p (expr1, expr2, 0);\n }\n \n /* Return OFFSET if XEXP (MEM, 0) - OFFSET is known to be ALIGN\n@@ -1732,7 +1681,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n       else if (TREE_CODE (t) == COMPONENT_REF\n \t       && ! DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n \t{\n-\t  expr = component_ref_for_mem_expr (t);\n+\t  expr = t;\n \t  offset = const0_rtx;\n \t  apply_bitpos = bitpos;\n \t  /* ??? Any reason the field size would be different than\n@@ -1789,7 +1738,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t    }\n \t  else if (TREE_CODE (t2) == COMPONENT_REF)\n \t    {\n-\t      expr = component_ref_for_mem_expr (t2);\n+\t      expr = t2;\n+\t      offset = NULL;\n \t      if (host_integerp (off_tree, 1))\n \t\t{\n \t\t  offset = GEN_INT (tree_low_cst (off_tree, 1));"}, {"sha": "e84c2cabdb3c1b75dfb25d091d1203b135c1c3f6", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -72,6 +72,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"cfglayout.h\"\n #include \"tree-pass.h\"\n+#include \"tree-flow.h\"\n #include \"timevar.h\"\n #include \"cgraph.h\"\n #include \"coverage.h\"\n@@ -4422,6 +4423,8 @@ rest_of_clean_state (void)\n \n   free_bb_for_insn ();\n \n+  delete_tree_ssa ();\n+\n   if (targetm.binds_local_p (current_function_decl))\n     {\n       unsigned int pref = crtl->preferred_stack_boundary;"}, {"sha": "fa02699707e28cff490e88cb51fae24e1bb8a6fb", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n+#include \"diagnostic.h\"\n #endif\n \n static FILE *outfile;\n@@ -72,60 +73,11 @@ int flag_simple = 0;\n int dump_for_graph;\n \n #ifndef GENERATOR_FILE\n-static void\n-print_decl_name (FILE *outfile, const_tree node)\n-{\n-  if (DECL_NAME (node))\n-    fputs (IDENTIFIER_POINTER (DECL_NAME (node)), outfile);\n-  else\n-    {\n-      if (TREE_CODE (node) == LABEL_DECL && LABEL_DECL_UID (node) != -1)\n-\tfprintf (outfile, \"L.%d\", (int) LABEL_DECL_UID (node));\n-      else\n-        {\n-          char c = TREE_CODE (node) == CONST_DECL ? 'C' : 'D';\n-\t  fprintf (outfile, \"%c.%u\", c, DECL_UID (node));\n-        }\n-    }\n-}\n-\n void\n print_mem_expr (FILE *outfile, const_tree expr)\n {\n-  if (TREE_CODE (expr) == COMPONENT_REF)\n-    {\n-      if (TREE_OPERAND (expr, 0))\n-\tprint_mem_expr (outfile, TREE_OPERAND (expr, 0));\n-      else\n-\tfputs (\" <variable>\", outfile);\n-      fputc ('.', outfile);\n-      print_decl_name (outfile, TREE_OPERAND (expr, 1));\n-    }\n-  else if (TREE_CODE (expr) == INDIRECT_REF)\n-    {\n-      fputs (\" (*\", outfile);\n-      print_mem_expr (outfile, TREE_OPERAND (expr, 0));\n-      fputs (\")\", outfile);\n-    }\n-  else if (TREE_CODE (expr) == ALIGN_INDIRECT_REF)\n-    {\n-      fputs (\" (A*\", outfile);\n-      print_mem_expr (outfile, TREE_OPERAND (expr, 0));\n-      fputs (\")\", outfile);\n-    }\n-  else if (TREE_CODE (expr) == MISALIGNED_INDIRECT_REF)\n-    {\n-      fputs (\" (M*\", outfile);\n-      print_mem_expr (outfile, TREE_OPERAND (expr, 0));\n-      fputs (\")\", outfile);\n-    }\n-  else if (TREE_CODE (expr) == RESULT_DECL)\n-    fputs (\" <result>\", outfile);\n-  else\n-    {\n-      fputc (' ', outfile);\n-      print_decl_name (outfile, expr);\n-    }\n+  fputc (' ', outfile);\n+  print_generic_expr (outfile, CONST_CAST_TREE (expr), 0);\n }\n #endif\n "}, {"sha": "1067a439b440dc2d17ca1d46dc546300b3d9043d", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -729,7 +729,7 @@ get_ref_base_and_extent (tree exp, HOST_WIDE_INT *poffset,\n     size_tree = DECL_SIZE (TREE_OPERAND (exp, 1));\n   else if (TREE_CODE (exp) == BIT_FIELD_REF)\n     size_tree = TREE_OPERAND (exp, 1);\n-  else\n+  else if (!VOID_TYPE_P (TREE_TYPE (exp)))\n     {\n       enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n       if (mode == BLKmode)"}, {"sha": "cec5ed7a13a0d7f32289b69176478ee61297f04e", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -63,6 +63,10 @@ struct GTY(()) gimple_df {\n   /* The PTA solution for the CALLUSED artificial variable.  */\n   struct pt_solution callused;\n \n+  /* A map of decls to artificial ssa-names that point to the partition\n+     of the decl.  */\n+  struct pointer_map_t * GTY((skip(\"\"))) decls_to_pointers;\n+\n   /* Free list of SSA_NAMEs.  */\n   tree free_ssanames;\n "}, {"sha": "7a9d2bd7c46902ee6101e50789dad3d7fbeca601", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -226,10 +226,6 @@ execute_free_datastructures (void)\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n \n-  /* Remove the ssa structures.  */\n-  if (cfun->gimple_df)\n-    delete_tree_ssa ();\n-\n   /* And get rid of annotations we no longer need.  */\n   delete_tree_cfg_annotations ();\n "}, {"sha": "92297fc6cf299ea9d0dd6704aef78d8a041f8941", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -724,7 +724,7 @@ indirect_refs_may_alias_p (tree ref1, tree ptr1,\n \n /* Return true, if the two memory references REF1 and REF2 may alias.  */\n \n-static bool\n+bool\n refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n {\n   tree base1, base2;"}, {"sha": "3a08750519958d5fcaaf22e6f57f3a8653fe9958", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -92,6 +92,7 @@ extern tree ao_ref_base (ao_ref *);\n extern alias_set_type ao_ref_alias_set (ao_ref *);\n extern bool ptr_deref_may_alias_global_p (tree);\n extern bool refs_may_alias_p (tree, tree);\n+extern bool refs_may_alias_p_1 (ao_ref *, ao_ref *, bool);\n extern bool refs_anti_dependent_p (tree, tree);\n extern bool refs_output_dependent_p (tree, tree);\n extern bool ref_maybe_used_by_stmt_p (gimple, tree);\n@@ -121,6 +122,7 @@ extern bool pt_solutions_intersect (struct pt_solution *, struct pt_solution *);\n extern bool pt_solutions_same_restrict_base (struct pt_solution *,\n \t\t\t\t\t     struct pt_solution *);\n extern void pt_solution_reset (struct pt_solution *);\n+extern void pt_solution_set (struct pt_solution *, bitmap);\n extern void dump_pta_stats (FILE *);\n \n "}, {"sha": "7e7e8e424c00ae9327250b1d6057fa402e4f0b6b", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -4886,6 +4886,28 @@ pt_solution_reset (struct pt_solution *pt)\n   pt->anything = true;\n }\n \n+/* Set the points-to solution *PT to point only to the variables\n+   in VARS.  */\n+\n+void\n+pt_solution_set (struct pt_solution *pt, bitmap vars)\n+{\n+  bitmap_iterator bi;\n+  unsigned i;\n+\n+  memset (pt, 0, sizeof (struct pt_solution));\n+  pt->vars = vars;\n+  EXECUTE_IF_SET_IN_BITMAP (vars, 0, i, bi)\n+    {\n+      tree var = referenced_var_lookup (i);\n+      if (is_global_var (var))\n+\t{\n+\t  pt->vars_contains_global = true;\n+\t  break;\n+\t}\n+    }\n+}\n+\n /* Return true if the points-to solution *PT is empty.  */\n \n static bool"}, {"sha": "7ec04f70fadb97b931aa0816460b5c29c2278541", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 3, "deletions": 43, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=55b34b5fd1ea3e4a1c7ee30e3a98d058892f5642", "patch": "@@ -802,52 +802,9 @@ init_tree_ssa (struct function *fn)\n void\n delete_tree_ssa (void)\n {\n-  size_t i;\n-  basic_block bb;\n-  gimple_stmt_iterator gsi;\n   referenced_var_iterator rvi;\n   tree var;\n \n-  /* Release any ssa_names still in use.  */\n-  for (i = 0; i < num_ssa_names; i++)\n-    {\n-      tree var = ssa_name (i);\n-      if (var && TREE_CODE (var) == SSA_NAME)\n-        {\n-\t  SSA_NAME_IMM_USE_NODE (var).prev = &(SSA_NAME_IMM_USE_NODE (var));\n-\t  SSA_NAME_IMM_USE_NODE (var).next = &(SSA_NAME_IMM_USE_NODE (var));\n-\t}\n-      release_ssa_name (var);\n-    }\n-\n-  /* FIXME.  This may not be necessary.  We will release all this\n-     memory en masse in free_ssa_operands.  This clearing used to be\n-     necessary to avoid problems with the inliner, but it may not be\n-     needed anymore.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\n-\t  if (gimple_has_ops (stmt))\n-\t    {\n-\t      gimple_set_def_ops (stmt, NULL);\n-\t      gimple_set_use_ops (stmt, NULL);\n-\t    }\n-\n-\t  if (gimple_has_mem_ops (stmt))\n-\t    {\n-\t      gimple_set_vdef (stmt, NULL_TREE);\n-\t      gimple_set_vuse (stmt, NULL_TREE);\n-\t    }\n-\n-\t  gimple_set_modified (stmt, true);\n-\t}\n-      if (!(bb->flags & BB_RTL))\n-\tset_phi_nodes (bb, NULL);\n-    }\n-\n   /* Remove annotations from every referenced local variable.  */\n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n@@ -873,6 +830,9 @@ delete_tree_ssa (void)\n   cfun->gimple_df->default_defs = NULL;\n   pt_solution_reset (&cfun->gimple_df->escaped);\n   pt_solution_reset (&cfun->gimple_df->callused);\n+  if (cfun->gimple_df->decls_to_pointers != NULL)\n+    pointer_map_destroy (cfun->gimple_df->decls_to_pointers);\n+  cfun->gimple_df->decls_to_pointers = NULL;\n   cfun->gimple_df->modified_noreturn_calls = NULL;\n   cfun->gimple_df = NULL;\n "}]}