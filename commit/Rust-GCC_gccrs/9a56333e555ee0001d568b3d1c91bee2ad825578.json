{"sha": "9a56333e555ee0001d568b3d1c91bee2ad825578", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE1NjMzM2U1NTVlZTAwMDFkNTY4YjNkMWM5MWJlZTJhZDgyNTU3OA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-07-25T00:04:37Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-07-25T00:04:37Z"}, "message": "re PR libstdc++/7230 (<strstream> header file is missing (trunk))\n\n\n2002-07-24  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/7230\n\t* config/linker-map.gnu: Revert strstream patch from 2002-07-01.\n\t* include/Makefile.am (backward_headers): Use strstream, not\n\tstrstream.h.\n\t* include/Makefile.in: Regenerate.\n\t* include/backward/strstream: Revert.\n\t* include/backward/strstream.h: Remove.\n\t* src/strstream.cc: Revert.\n\t* testsuite/backward/strstream_members.cc: Change include.\n\nFrom-SVN: r55730", "tree": {"sha": "e552ad160f5bd3db5682adcb4388991fc56dd854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e552ad160f5bd3db5682adcb4388991fc56dd854"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a56333e555ee0001d568b3d1c91bee2ad825578", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a56333e555ee0001d568b3d1c91bee2ad825578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a56333e555ee0001d568b3d1c91bee2ad825578", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a56333e555ee0001d568b3d1c91bee2ad825578/comments", "author": null, "committer": null, "parents": [{"sha": "8d1b7ba13bbe16749456b30cd8d8cf297cf9e41e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1b7ba13bbe16749456b30cd8d8cf297cf9e41e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d1b7ba13bbe16749456b30cd8d8cf297cf9e41e"}], "stats": {"total": 3836, "additions": 2072, "deletions": 1764}, "files": [{"sha": "ce97baad59a24d43a448db290de4e4cf3866c05d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9a56333e555ee0001d568b3d1c91bee2ad825578", "patch": "@@ -1,10 +1,22 @@\n+2002-07-24  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/7230\n+\t* config/linker-map.gnu: Revert strstream patch from 2002-07-01.\n+\t* include/Makefile.am (backward_headers): Use strstream, not\n+\tstrstream.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/backward/strstream: Revert.\n+\t* include/backward/strstream.h: Remove.\n+\t* src/strstream.cc: Revert.\n+\t* testsuite/backward/strstream_members.cc: Change include.\t\n+\n 2002-07-24  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/7219\n-\t* testsuite/27_io/ios_base_type.cc: New.\n \t* include/bits/ios_base.h (ios_base::streampos): Add.\n \t(ios_base::streamoff): Add.\n-\n+\t* testsuite/27_io/ios_base_type.cc: New.\n+\t\n 2002-07-24  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/7286"}, {"sha": "35b13a2855b215f223aac3e2104fdb6b375c29dc", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=9a56333e555ee0001d568b3d1c91bee2ad825578", "patch": "@@ -1,6 +1,6 @@\n-dnl aclocal.m4 generated automatically by aclocal 1.4\n+dnl aclocal.m4 generated automatically by aclocal 1.4-p5\n \n-dnl Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+dnl Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n dnl This file is free software; the Free Software Foundation\n dnl gives unlimited permission to copy and/or distribute it,\n dnl with or without modifications, as long as this notice is preserved.\n@@ -2201,12 +2201,37 @@ AC_MSG_RESULT($enable_symvers)\n ])\n \n \n+# isc-posix.m4 serial 1 (gettext-0.10.40)\n+dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.\n+dnl This file is free software, distributed under the terms of the GNU\n+dnl General Public License.  As a special exception to the GNU General\n+dnl Public License, this file may be distributed as part of a program\n+dnl that contains a configuration script generated by Autoconf, under\n+dnl the same distribution terms as the rest of that program.\n+\n+# This test replaces the one in autoconf.\n+# Currently this macro should have the same name as the autoconf macro\n+# because gettext's gettext.m4 (distributed in the automake package)\n+# still uses it.  Otherwise, the use in gettext.m4 makes autoheader\n+# give these diagnostics:\n+#   configure.in:556: AC_TRY_COMPILE was called before AC_ISC_POSIX\n+#   configure.in:556: AC_TRY_RUN was called before AC_ISC_POSIX\n+\n+undefine([AC_ISC_POSIX])\n+\n+AC_DEFUN([AC_ISC_POSIX],\n+  [\n+    dnl This test replaces the obsolescent AC_ISC_POSIX kludge.\n+    AC_CHECK_LIB(cposix, strerror, [LIBS=\"$LIBS -lcposix\"])\n+  ]\n+)\n+\n # Add --enable-maintainer-mode option to configure.\n # From Jim Meyering\n \n # serial 1\n \n-AC_DEFUN(AM_MAINTAINER_MODE,\n+AC_DEFUN([AM_MAINTAINER_MODE],\n [AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n   dnl maintainer-mode is disabled by default\n   AC_ARG_ENABLE(maintainer-mode,\n@@ -2223,7 +2248,7 @@ AC_DEFUN(AM_MAINTAINER_MODE,\n \n # Define a conditional.\n \n-AC_DEFUN(AM_CONDITIONAL,\n+AC_DEFUN([AM_CONDITIONAL],\n [AC_SUBST($1_TRUE)\n AC_SUBST($1_FALSE)\n if $2; then\n@@ -2243,7 +2268,7 @@ fi])\n dnl Usage:\n dnl AM_INIT_AUTOMAKE(package,version, [no-define])\n \n-AC_DEFUN(AM_INIT_AUTOMAKE,\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n [AC_REQUIRE([AC_PROG_INSTALL])\n PACKAGE=[$1]\n AC_SUBST(PACKAGE)\n@@ -2271,7 +2296,7 @@ AC_REQUIRE([AC_PROG_MAKE_SET])])\n # Check to make sure that the build environment is sane.\n #\n \n-AC_DEFUN(AM_SANITY_CHECK,\n+AC_DEFUN([AM_SANITY_CHECK],\n [AC_MSG_CHECKING([whether build environment is sane])\n # Just in case\n sleep 1\n@@ -2312,7 +2337,7 @@ AC_MSG_RESULT(yes)])\n \n dnl AM_MISSING_PROG(NAME, PROGRAM, DIRECTORY)\n dnl The program must properly implement --version.\n-AC_DEFUN(AM_MISSING_PROG,\n+AC_DEFUN([AM_MISSING_PROG],\n [AC_MSG_CHECKING(for working $2)\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n@@ -2328,7 +2353,7 @@ AC_SUBST($1)])\n \n # Like AC_CONFIG_HEADER, but automatically create stamp file.\n \n-AC_DEFUN(AM_CONFIG_HEADER,\n+AC_DEFUN([AM_CONFIG_HEADER],\n [AC_PREREQ([2.12])\n AC_CONFIG_HEADER([$1])\n dnl When config.status generates a header, we must update the stamp-h file."}, {"sha": "2a55bb2e46339ba84c29b73a95c2305a82303e10", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=9a56333e555ee0001d568b3d1c91bee2ad825578", "patch": "@@ -38,11 +38,7 @@ GLIBCPP_3.1 {\n       std::_S_bit_count;\n       std::_S_first_one;\n       std::__default_alloc_template*;\n-      std::__malloc_alloc_template*;\n-      strstreambuf::*;\n-      istrstream::*;\n-      ostrstream::*;\n-      strstream::*\n+      std::__malloc_alloc_template*\n     };\n \n     # Names not in an 'extern' block are mangled names."}, {"sha": "146e471f8b8d555a4ac3133ea74d3604a835eef5", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 1243, "deletions": 1219, "changes": 2462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=9a56333e555ee0001d568b3d1c91bee2ad825578"}, {"sha": "0563d2fb989c305052a34e947c85459eb934b711", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=9a56333e555ee0001d568b3d1c91bee2ad825578", "patch": "@@ -137,7 +137,7 @@ backward_headers = \\\n \t${backward_srcdir}/tree.h \\\n \t${backward_srcdir}/vector.h \\\n \t${backward_srcdir}/fstream.h \\\n-\t${backward_srcdir}/strstream.h \\\n+\t${backward_srcdir}/strstream \\\n \t${backward_srcdir}/backward_warning.h\n \n ext_srcdir = ${glibcpp_srcdir}/include/ext"}, {"sha": "488018466974172d4140954e469d8a5b59388bb0", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 265, "deletions": 17, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=9a56333e555ee0001d568b3d1c91bee2ad825578", "patch": "@@ -139,59 +139,307 @@ glibcpp_builddir = @glibcpp_builddir@\n \n bits_srcdir = ${glibcpp_srcdir}/include/bits\n bits_builddir = ./bits\n-bits_headers =  \t${bits_srcdir}/basic_ios.h \t${bits_srcdir}/basic_ios.tcc \t${bits_srcdir}/basic_string.h \t${bits_srcdir}/basic_string.tcc \t${bits_srcdir}/boost_concept_check.h \t${bits_srcdir}/char_traits.h \t${bits_srcdir}/codecvt.h \t${bits_srcdir}/concept_check.h \t${bits_srcdir}/cpp_type_traits.h \t${bits_srcdir}/deque.tcc \t${bits_srcdir}/fpos.h \t${bits_srcdir}/fstream.tcc \t${bits_srcdir}/functexcept.h \t${bits_srcdir}/generic_shadow.h \t${bits_srcdir}/gslice.h \t${bits_srcdir}/gslice_array.h \t${bits_srcdir}/indirect_array.h \t${bits_srcdir}/ios_base.h \t${bits_srcdir}/istream.tcc \t${bits_srcdir}/list.tcc \t${bits_srcdir}/locale_facets.h \t${bits_srcdir}/locale_facets.tcc \t${bits_srcdir}/localefwd.h \t${bits_srcdir}/mask_array.h \t${bits_srcdir}/ostream.tcc \t${bits_srcdir}/pthread_allocimpl.h \t${bits_srcdir}/stream_iterator.h \t${bits_srcdir}/streambuf_iterator.h \t${bits_srcdir}/slice_array.h \t${bits_srcdir}/sstream.tcc \t${bits_srcdir}/stl_algo.h \t${bits_srcdir}/stl_algobase.h \t${bits_srcdir}/stl_alloc.h \t${bits_srcdir}/stl_bvector.h \t${bits_srcdir}/stl_construct.h \t${bits_srcdir}/stl_deque.h \t${bits_srcdir}/stl_function.h \t${bits_srcdir}/stl_heap.h \t${bits_srcdir}/stl_iterator.h \t${bits_srcdir}/stl_iterator_base_funcs.h \t${bits_srcdir}/stl_iterator_base_types.h \t${bits_srcdir}/stl_list.h \t${bits_srcdir}/stl_map.h \t${bits_srcdir}/stl_multimap.h \t${bits_srcdir}/stl_multiset.h \t${bits_srcdir}/stl_numeric.h \t${bits_srcdir}/stl_pair.h \t${bits_srcdir}/stl_pthread_alloc.h \t${bits_srcdir}/stl_queue.h \t${bits_srcdir}/stl_raw_storage_iter.h \t${bits_srcdir}/stl_relops.h \t${bits_srcdir}/stl_set.h \t${bits_srcdir}/stl_stack.h \t${bits_srcdir}/stl_tempbuf.h \t${bits_srcdir}/stl_threads.h \t${bits_srcdir}/stl_tree.h \t${bits_srcdir}/stl_uninitialized.h \t${bits_srcdir}/stl_vector.h \t${bits_srcdir}/streambuf.tcc \t${bits_srcdir}/stringfwd.h \t${bits_srcdir}/type_traits.h \t${bits_srcdir}/valarray_array.h \t${bits_srcdir}/valarray_array.tcc \t${bits_srcdir}/valarray_meta.h \t${bits_srcdir}/vector.tcc\n+bits_headers = \\\n+\t${bits_srcdir}/basic_ios.h \\\n+\t${bits_srcdir}/basic_ios.tcc \\\n+\t${bits_srcdir}/basic_string.h \\\n+\t${bits_srcdir}/basic_string.tcc \\\n+\t${bits_srcdir}/boost_concept_check.h \\\n+\t${bits_srcdir}/char_traits.h \\\n+\t${bits_srcdir}/codecvt.h \\\n+\t${bits_srcdir}/concept_check.h \\\n+\t${bits_srcdir}/cpp_type_traits.h \\\n+\t${bits_srcdir}/deque.tcc \\\n+\t${bits_srcdir}/fpos.h \\\n+\t${bits_srcdir}/fstream.tcc \\\n+\t${bits_srcdir}/functexcept.h \\\n+\t${bits_srcdir}/generic_shadow.h \\\n+\t${bits_srcdir}/gslice.h \\\n+\t${bits_srcdir}/gslice_array.h \\\n+\t${bits_srcdir}/indirect_array.h \\\n+\t${bits_srcdir}/ios_base.h \\\n+\t${bits_srcdir}/istream.tcc \\\n+\t${bits_srcdir}/list.tcc \\\n+\t${bits_srcdir}/locale_facets.h \\\n+\t${bits_srcdir}/locale_facets.tcc \\\n+\t${bits_srcdir}/localefwd.h \\\n+\t${bits_srcdir}/mask_array.h \\\n+\t${bits_srcdir}/ostream.tcc \\\n+\t${bits_srcdir}/pthread_allocimpl.h \\\n+\t${bits_srcdir}/stream_iterator.h \\\n+\t${bits_srcdir}/streambuf_iterator.h \\\n+\t${bits_srcdir}/slice_array.h \\\n+\t${bits_srcdir}/sstream.tcc \\\n+\t${bits_srcdir}/stl_algo.h \\\n+\t${bits_srcdir}/stl_algobase.h \\\n+\t${bits_srcdir}/stl_alloc.h \\\n+\t${bits_srcdir}/stl_bvector.h \\\n+\t${bits_srcdir}/stl_construct.h \\\n+\t${bits_srcdir}/stl_deque.h \\\n+\t${bits_srcdir}/stl_function.h \\\n+\t${bits_srcdir}/stl_heap.h \\\n+\t${bits_srcdir}/stl_iterator.h \\\n+\t${bits_srcdir}/stl_iterator_base_funcs.h \\\n+\t${bits_srcdir}/stl_iterator_base_types.h \\\n+\t${bits_srcdir}/stl_list.h \\\n+\t${bits_srcdir}/stl_map.h \\\n+\t${bits_srcdir}/stl_multimap.h \\\n+\t${bits_srcdir}/stl_multiset.h \\\n+\t${bits_srcdir}/stl_numeric.h \\\n+\t${bits_srcdir}/stl_pair.h \\\n+\t${bits_srcdir}/stl_pthread_alloc.h \\\n+\t${bits_srcdir}/stl_queue.h \\\n+\t${bits_srcdir}/stl_raw_storage_iter.h \\\n+\t${bits_srcdir}/stl_relops.h \\\n+\t${bits_srcdir}/stl_set.h \\\n+\t${bits_srcdir}/stl_stack.h \\\n+\t${bits_srcdir}/stl_tempbuf.h \\\n+\t${bits_srcdir}/stl_threads.h \\\n+\t${bits_srcdir}/stl_tree.h \\\n+\t${bits_srcdir}/stl_uninitialized.h \\\n+\t${bits_srcdir}/stl_vector.h \\\n+\t${bits_srcdir}/streambuf.tcc \\\n+\t${bits_srcdir}/stringfwd.h \\\n+\t${bits_srcdir}/type_traits.h \\\n+\t${bits_srcdir}/valarray_array.h \\\n+\t${bits_srcdir}/valarray_array.tcc \\\n+\t${bits_srcdir}/valarray_meta.h \\\n+\t${bits_srcdir}/vector.tcc\n \n \n backward_srcdir = ${glibcpp_srcdir}/include/backward\n backward_builddir = ./backward\n-backward_headers =  \t${backward_srcdir}/complex.h \t${backward_srcdir}/iomanip.h \t${backward_srcdir}/istream.h \t${backward_srcdir}/ostream.h \t${backward_srcdir}/stream.h \t${backward_srcdir}/streambuf.h \t${backward_srcdir}/algo.h \t${backward_srcdir}/algobase.h \t${backward_srcdir}/alloc.h \t${backward_srcdir}/bvector.h \t${backward_srcdir}/defalloc.h \t${backward_srcdir}/deque.h \t${backward_srcdir}/function.h \t${backward_srcdir}/hash_map.h \t${backward_srcdir}/hash_set.h \t${backward_srcdir}/hashtable.h \t${backward_srcdir}/heap.h \t${backward_srcdir}/iostream.h \t${backward_srcdir}/iterator.h \t${backward_srcdir}/list.h \t${backward_srcdir}/map.h \t${backward_srcdir}/multimap.h \t${backward_srcdir}/new.h \t${backward_srcdir}/multiset.h \t${backward_srcdir}/pair.h \t${backward_srcdir}/queue.h \t${backward_srcdir}/rope.h \t${backward_srcdir}/set.h \t${backward_srcdir}/slist.h \t${backward_srcdir}/stack.h \t${backward_srcdir}/tempbuf.h \t${backward_srcdir}/tree.h \t${backward_srcdir}/vector.h \t${backward_srcdir}/fstream.h \t${backward_srcdir}/strstream.h \t${backward_srcdir}/backward_warning.h\n+backward_headers = \\\n+\t${backward_srcdir}/complex.h \\\n+\t${backward_srcdir}/iomanip.h \\\n+\t${backward_srcdir}/istream.h \\\n+\t${backward_srcdir}/ostream.h \\\n+\t${backward_srcdir}/stream.h \\\n+\t${backward_srcdir}/streambuf.h \\\n+\t${backward_srcdir}/algo.h \\\n+\t${backward_srcdir}/algobase.h \\\n+\t${backward_srcdir}/alloc.h \\\n+\t${backward_srcdir}/bvector.h \\\n+\t${backward_srcdir}/defalloc.h \\\n+\t${backward_srcdir}/deque.h \\\n+\t${backward_srcdir}/function.h \\\n+\t${backward_srcdir}/hash_map.h \\\n+\t${backward_srcdir}/hash_set.h \\\n+\t${backward_srcdir}/hashtable.h \\\n+\t${backward_srcdir}/heap.h \\\n+\t${backward_srcdir}/iostream.h \\\n+\t${backward_srcdir}/iterator.h \\\n+\t${backward_srcdir}/list.h \\\n+\t${backward_srcdir}/map.h \\\n+\t${backward_srcdir}/multimap.h \\\n+\t${backward_srcdir}/new.h \\\n+\t${backward_srcdir}/multiset.h \\\n+\t${backward_srcdir}/pair.h \\\n+\t${backward_srcdir}/queue.h \\\n+\t${backward_srcdir}/rope.h \\\n+\t${backward_srcdir}/set.h \\\n+\t${backward_srcdir}/slist.h \\\n+\t${backward_srcdir}/stack.h \\\n+\t${backward_srcdir}/tempbuf.h \\\n+\t${backward_srcdir}/tree.h \\\n+\t${backward_srcdir}/vector.h \\\n+\t${backward_srcdir}/fstream.h \\\n+\t${backward_srcdir}/strstream \\\n+\t${backward_srcdir}/backward_warning.h\n \n \n ext_srcdir = ${glibcpp_srcdir}/include/ext\n ext_builddir = ./ext\n-ext_headers =  \t${ext_srcdir}/algorithm \t${ext_srcdir}/enc_filebuf.h \t${ext_srcdir}/stdio_filebuf.h \t${ext_srcdir}/functional \t${ext_srcdir}/hash_map \t${ext_srcdir}/hash_set \t${ext_srcdir}/iterator \t${ext_srcdir}/memory \t${ext_srcdir}/numeric \t${ext_srcdir}/rb_tree \t${ext_srcdir}/rope \t${ext_srcdir}/ropeimpl.h \t${ext_srcdir}/slist \t${ext_srcdir}/stl_hash_fun.h \t${ext_srcdir}/stl_hashtable.h \t${ext_srcdir}/stl_rope.h\n+ext_headers = \\\n+\t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/enc_filebuf.h \\\n+\t${ext_srcdir}/stdio_filebuf.h \\\n+\t${ext_srcdir}/functional \\\n+\t${ext_srcdir}/hash_map \\\n+\t${ext_srcdir}/hash_set \\\n+\t${ext_srcdir}/iterator \\\n+\t${ext_srcdir}/memory \\\n+\t${ext_srcdir}/numeric \\\n+\t${ext_srcdir}/rb_tree \\\n+\t${ext_srcdir}/rope \\\n+\t${ext_srcdir}/ropeimpl.h \\\n+\t${ext_srcdir}/slist \\\n+\t${ext_srcdir}/stl_hash_fun.h \\\n+\t${ext_srcdir}/stl_hashtable.h \\\n+\t${ext_srcdir}/stl_rope.h\n \n \n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = @C_INCLUDE_DIR@\n c_base_builddir = .\n-c_base_headers =  \t${c_base_srcdir}/std_cassert.h \t${c_base_srcdir}/std_cctype.h \t${c_base_srcdir}/std_cerrno.h \t${c_base_srcdir}/std_cfloat.h \t${c_base_srcdir}/std_ciso646.h \t${c_base_srcdir}/std_climits.h \t${c_base_srcdir}/std_clocale.h \t${c_base_srcdir}/std_cmath.h \t${c_base_srcdir}/std_csetjmp.h \t${c_base_srcdir}/std_csignal.h \t${c_base_srcdir}/std_cstdarg.h \t${c_base_srcdir}/std_cstddef.h \t${c_base_srcdir}/std_cstdio.h \t${c_base_srcdir}/std_cstdlib.h \t${c_base_srcdir}/std_cstring.h \t${c_base_srcdir}/std_ctime.h \t${c_base_srcdir}/std_cwchar.h \t${c_base_srcdir}/std_cwctype.h \n-\n-c_base_headers_rename =  \tcassert \tcctype \tcerrno \tcfloat \tciso646 \tclimits \tclocale \tcmath \tcsetjmp \tcsignal \tcstdarg \tcstddef \tcstdio \tcstdlib \tcstring \tctime \tcwchar \tcwctype \n+c_base_headers = \\\n+\t${c_base_srcdir}/std_cassert.h \\\n+\t${c_base_srcdir}/std_cctype.h \\\n+\t${c_base_srcdir}/std_cerrno.h \\\n+\t${c_base_srcdir}/std_cfloat.h \\\n+\t${c_base_srcdir}/std_ciso646.h \\\n+\t${c_base_srcdir}/std_climits.h \\\n+\t${c_base_srcdir}/std_clocale.h \\\n+\t${c_base_srcdir}/std_cmath.h \\\n+\t${c_base_srcdir}/std_csetjmp.h \\\n+\t${c_base_srcdir}/std_csignal.h \\\n+\t${c_base_srcdir}/std_cstdarg.h \\\n+\t${c_base_srcdir}/std_cstddef.h \\\n+\t${c_base_srcdir}/std_cstdio.h \\\n+\t${c_base_srcdir}/std_cstdlib.h \\\n+\t${c_base_srcdir}/std_cstring.h \\\n+\t${c_base_srcdir}/std_ctime.h \\\n+\t${c_base_srcdir}/std_cwchar.h \\\n+\t${c_base_srcdir}/std_cwctype.h \n+\n+c_base_headers_rename = \\\n+\tcassert \\\n+\tcctype \\\n+\tcerrno \\\n+\tcfloat \\\n+\tciso646 \\\n+\tclimits \\\n+\tclocale \\\n+\tcmath \\\n+\tcsetjmp \\\n+\tcsignal \\\n+\tcstdarg \\\n+\tcstddef \\\n+\tcstdio \\\n+\tcstdlib \\\n+\tcstring \\\n+\tctime \\\n+\tcwchar \\\n+\tcwctype \n \n \n # \"C\" compatibility headers.\n c_compatibility_srcdir = ${glibcpp_srcdir}/include/c_compatibility\n c_compatibility_builddir = .\n-c_compatibility_headers =  \t${c_compatibility_srcdir}/assert.h \t${c_compatibility_srcdir}/ctype.h \t${c_compatibility_srcdir}/errno.h \t${c_compatibility_srcdir}/float.h \t${c_compatibility_srcdir}/iso646.h \t${c_compatibility_srcdir}/limits.h \t${c_compatibility_srcdir}/locale.h \t${c_compatibility_srcdir}/math.h \t${c_compatibility_srcdir}/setjmp.h \t${c_compatibility_srcdir}/signal.h \t${c_compatibility_srcdir}/stdarg.h \t${c_compatibility_srcdir}/stddef.h \t${c_compatibility_srcdir}/stdio.h \t${c_compatibility_srcdir}/stdlib.h \t${c_compatibility_srcdir}/string.h \t${c_compatibility_srcdir}/time.h \t${c_compatibility_srcdir}/wchar.h \t${c_compatibility_srcdir}/wctype.h \n-\n-@GLIBCPP_C_HEADERS_C_STD_TRUE@c_base_headers_extra = ${c_base_srcdir}/cmath.tcc \n+c_compatibility_headers = \\\n+\t${c_compatibility_srcdir}/assert.h \\\n+\t${c_compatibility_srcdir}/ctype.h \\\n+\t${c_compatibility_srcdir}/errno.h \\\n+\t${c_compatibility_srcdir}/float.h \\\n+\t${c_compatibility_srcdir}/iso646.h \\\n+\t${c_compatibility_srcdir}/limits.h \\\n+\t${c_compatibility_srcdir}/locale.h \\\n+\t${c_compatibility_srcdir}/math.h \\\n+\t${c_compatibility_srcdir}/setjmp.h \\\n+\t${c_compatibility_srcdir}/signal.h \\\n+\t${c_compatibility_srcdir}/stdarg.h \\\n+\t${c_compatibility_srcdir}/stddef.h \\\n+\t${c_compatibility_srcdir}/stdio.h \\\n+\t${c_compatibility_srcdir}/stdlib.h \\\n+\t${c_compatibility_srcdir}/string.h \\\n+\t${c_compatibility_srcdir}/time.h \\\n+\t${c_compatibility_srcdir}/wchar.h \\\n+\t${c_compatibility_srcdir}/wctype.h \n+\n+@GLIBCPP_C_HEADERS_C_STD_TRUE@c_base_headers_extra = @GLIBCPP_C_HEADERS_C_STD_TRUE@${c_base_srcdir}/cmath.tcc \n @GLIBCPP_C_HEADERS_C_STD_FALSE@c_base_headers_extra = \n-@GLIBCPP_C_HEADERS_COMPATIBILITY_TRUE@c_compatibility_headers_extra = ${c_compatibility_headers}\n+@GLIBCPP_C_HEADERS_COMPATIBILITY_TRUE@c_compatibility_headers_extra = @GLIBCPP_C_HEADERS_COMPATIBILITY_TRUE@${c_compatibility_headers}\n @GLIBCPP_C_HEADERS_COMPATIBILITY_FALSE@c_compatibility_headers_extra = \n \n std_srcdir = ${glibcpp_srcdir}/include/std\n std_builddir = .\n-std_headers =  \t${std_srcdir}/std_algorithm.h \t${std_srcdir}/std_bitset.h \t${std_srcdir}/std_complex.h \t${std_srcdir}/std_deque.h \t${std_srcdir}/std_fstream.h \t${std_srcdir}/std_functional.h \t${std_srcdir}/std_iomanip.h \t${std_srcdir}/std_ios.h \t${std_srcdir}/std_iosfwd.h \t${std_srcdir}/std_iostream.h \t${std_srcdir}/std_istream.h \t${std_srcdir}/std_iterator.h \t${std_srcdir}/std_limits.h \t${std_srcdir}/std_list.h \t${std_srcdir}/std_locale.h \t${std_srcdir}/std_map.h \t${std_srcdir}/std_memory.h \t${std_srcdir}/std_numeric.h \t${std_srcdir}/std_ostream.h \t${std_srcdir}/std_queue.h \t${std_srcdir}/std_set.h \t${std_srcdir}/std_sstream.h \t${std_srcdir}/std_stack.h \t${std_srcdir}/std_stdexcept.h \t${std_srcdir}/std_streambuf.h \t${std_srcdir}/std_string.h \t${std_srcdir}/std_utility.h \t${std_srcdir}/std_valarray.h \t${std_srcdir}/std_vector.h\n+std_headers = \\\n+\t${std_srcdir}/std_algorithm.h \\\n+\t${std_srcdir}/std_bitset.h \\\n+\t${std_srcdir}/std_complex.h \\\n+\t${std_srcdir}/std_deque.h \\\n+\t${std_srcdir}/std_fstream.h \\\n+\t${std_srcdir}/std_functional.h \\\n+\t${std_srcdir}/std_iomanip.h \\\n+\t${std_srcdir}/std_ios.h \\\n+\t${std_srcdir}/std_iosfwd.h \\\n+\t${std_srcdir}/std_iostream.h \\\n+\t${std_srcdir}/std_istream.h \\\n+\t${std_srcdir}/std_iterator.h \\\n+\t${std_srcdir}/std_limits.h \\\n+\t${std_srcdir}/std_list.h \\\n+\t${std_srcdir}/std_locale.h \\\n+\t${std_srcdir}/std_map.h \\\n+\t${std_srcdir}/std_memory.h \\\n+\t${std_srcdir}/std_numeric.h \\\n+\t${std_srcdir}/std_ostream.h \\\n+\t${std_srcdir}/std_queue.h \\\n+\t${std_srcdir}/std_set.h \\\n+\t${std_srcdir}/std_sstream.h \\\n+\t${std_srcdir}/std_stack.h \\\n+\t${std_srcdir}/std_stdexcept.h \\\n+\t${std_srcdir}/std_streambuf.h \\\n+\t${std_srcdir}/std_string.h \\\n+\t${std_srcdir}/std_utility.h \\\n+\t${std_srcdir}/std_valarray.h \\\n+\t${std_srcdir}/std_vector.h\n \n # Renamed at build time. \n-std_headers_rename =  \talgorithm \tbitset \tcomplex \tdeque \tfstream \tfunctional \tiomanip \tios \tiosfwd \tiostream \tistream \titerator \tlimits \tlist \tlocale \tmap \tmemory \tnumeric \tostream \tqueue \tset \tsstream \tstack \tstdexcept \tstreambuf \tstring \tutility \tvalarray \tvector\n+std_headers_rename = \\\n+\talgorithm \\\n+\tbitset \\\n+\tcomplex \\\n+\tdeque \\\n+\tfstream \\\n+\tfunctional \\\n+\tiomanip \\\n+\tios \\\n+\tiosfwd \\\n+\tiostream \\\n+\tistream \\\n+\titerator \\\n+\tlimits \\\n+\tlist \\\n+\tlocale \\\n+\tmap \\\n+\tmemory \\\n+\tnumeric \\\n+\tostream \\\n+\tqueue \\\n+\tset \\\n+\tsstream \\\n+\tstack \\\n+\tstdexcept \\\n+\tstreambuf \\\n+\tstring \\\n+\tutility \\\n+\tvalarray \\\n+\tvector\n \n \n target_srcdir = ${glibcpp_srcdir}/@OS_INC_SRCDIR@\n target_builddir = ./${target_alias}/bits\n-target_headers =  \t${target_srcdir}/ctype_base.h \t${target_srcdir}/ctype_inline.h \t${target_srcdir}/ctype_noninline.h \t${target_srcdir}/os_defines.h \t${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h \t${glibcpp_srcdir}/@CPU_LIMITS_INC_SRCDIR@/cpu_limits.h \n+target_headers = \\\n+\t${target_srcdir}/ctype_base.h \\\n+\t${target_srcdir}/ctype_inline.h \\\n+\t${target_srcdir}/ctype_noninline.h \\\n+\t${target_srcdir}/os_defines.h \\\n+\t${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h \\\n+\t${glibcpp_srcdir}/@CPU_LIMITS_INC_SRCDIR@/cpu_limits.h \n \n # These target_headers_extra files are all built with ad hoc naming rules.\n-target_headers_extra =  \t${target_builddir}/basic_file.h \t${target_builddir}/c++config.h \t${target_builddir}/c++io.h \t${target_builddir}/c++locale.h \t${target_builddir}/messages_members.h \t${target_builddir}/codecvt_specializations.h\n+target_headers_extra = \\\n+\t${target_builddir}/basic_file.h \\\n+\t${target_builddir}/c++config.h \\\n+\t${target_builddir}/c++io.h \\\n+\t${target_builddir}/c++locale.h \\\n+\t${target_builddir}/messages_members.h \\\n+\t${target_builddir}/codecvt_specializations.h\n \n \n-thread_target_headers =  \t${target_builddir}/gthr.h \t${target_builddir}/gthr-single.h \t${target_builddir}/gthr-posix.h \t${target_builddir}/gthr-default.h\n+thread_target_headers = \\\n+\t${target_builddir}/gthr.h \\\n+\t${target_builddir}/gthr-single.h \\\n+\t${target_builddir}/gthr-posix.h \\\n+\t${target_builddir}/gthr-default.h\n \n \n # List of all timestamp files.  By keeping only one copy of this list, both\n # CLEANFILES and all-local are kept up-to-date.\n-allstamps =  \tstamp-std stamp-bits stamp-c_base stamp-c_compatibility \tstamp-backward stamp-ext \t${target_builddir}/stamp-target\n+allstamps = \\\n+\tstamp-std stamp-bits stamp-c_base stamp-c_compatibility \\\n+\tstamp-backward stamp-ext \\\n+\t${target_builddir}/stamp-target\n \n \n # Target includes for threads\n@@ -214,7 +462,7 @@ DIST_COMMON =  Makefile.am Makefile.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:"}, {"sha": "165c6e70dd4a1316f3b55dc578c8cca7ebd73735", "filename": "libstdc++-v3/include/backward/strstream", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream?ref=9a56333e555ee0001d568b3d1c91bee2ad825578", "patch": "@@ -0,0 +1,174 @@\n+// Backward-compat support -*- C++ -*-\n+\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ * Copyright (c) 1998\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+// WARNING: The classes defined in this header are DEPRECATED.  This\n+// header is defined in section D.7.1 of the C++ standard, and it\n+// MAY BE REMOVED in a future standard revision.  You should use the\n+// header <sstream> instead.\n+\n+#ifndef __SGI_STL_STRSTREAM\n+#define __SGI_STL_STRSTREAM\n+\n+#include \"backward_warning.h\"\n+#include <iosfwd>\n+#include <ios>\n+#include <istream>\n+#include <ostream>\n+#include <string>\n+\n+namespace std\n+{\n+  // Class strstreambuf, a streambuf class that manages an array of char.\n+  // Note that this class is not a template.\n+  class strstreambuf : public basic_streambuf<char, char_traits<char> >\n+  {\n+  public:                         \n+    // Types.\n+    typedef char_traits<char>              _Traits;\n+    typedef basic_streambuf<char, _Traits> _Base;\n+\n+  public:  \n+    // Constructor, destructor\n+    explicit strstreambuf(streamsize __initial_capacity = 0);\n+    strstreambuf(void* (*__alloc)(size_t), void (*__free)(void*));\n+\n+    strstreambuf(char* __get, streamsize __n, char* __put = 0);\n+    strstreambuf(signed char* __get, streamsize __n, signed char* __put = 0);\n+    strstreambuf(unsigned char* __get, streamsize __n, unsigned char* __put=0);\n+\n+    strstreambuf(const char* __get, streamsize __n);\n+    strstreambuf(const signed char* __get, streamsize __n);\n+    strstreambuf(const unsigned char* __get, streamsize __n);\n+\n+    virtual ~strstreambuf();\n+\n+  public:\n+    void freeze(bool = true);\n+    char* str();\n+    int pcount() const;\n+\n+  protected:\n+    virtual int_type overflow(int_type __c  = _Traits::eof());\n+    virtual int_type pbackfail(int_type __c = _Traits::eof());\n+    virtual int_type underflow();\n+    virtual _Base* setbuf(char* __buf, streamsize __n);\n+    virtual pos_type seekoff(off_type __off, ios_base::seekdir __dir,\n+\t\t\t     ios_base::openmode __mode\n+\t\t\t     = ios_base::in | ios_base::out);\n+    virtual pos_type seekpos(pos_type __pos, ios_base::openmode __mode\n+\t\t\t     = ios_base::in | ios_base::out);\n+\n+  private:  \n+    // Dynamic allocation, possibly using _M_alloc_fun and _M_free_fun.\n+    char* _M_alloc(size_t);\n+    void  _M_free(char*);\n+\n+    // Helper function used in constructors.\n+    void _M_setup(char* __get, char* __put, streamsize __n);\n+\n+  private:  \n+    // Data members.\n+    void* (*_M_alloc_fun)(size_t);\n+    void  (*_M_free_fun)(void*);\n+\n+    bool _M_dynamic  : 1;\n+    bool _M_frozen   : 1;\n+    bool _M_constant : 1;\n+  };\n+\n+  // Class istrstream, an istream that manages a strstreambuf.\n+  class istrstream : public basic_istream<char>\n+  {\n+  public:\n+    explicit istrstream(char*);\n+    explicit istrstream(const char*);\n+    istrstream(char* , streamsize);\n+    istrstream(const char*, streamsize);\n+    virtual ~istrstream();\n+\n+    strstreambuf* rdbuf() const;\n+    char* str();\n+\n+  private:\n+    strstreambuf _M_buf;\n+  };\n+\n+  // Class ostrstream\n+  class ostrstream : public basic_ostream<char>\n+  {\n+  public:\n+    ostrstream();\n+    ostrstream(char*, int, ios_base::openmode = ios_base::out);\n+    virtual ~ostrstream();\n+\n+    strstreambuf* rdbuf() const;\n+    void freeze(bool = true);\n+    char* str();\n+    int pcount() const;\n+\n+  private:\n+    strstreambuf _M_buf;\n+  };\n+\n+  // Class strstream\n+  class strstream : public basic_iostream<char>\n+  {\n+  public:\n+    typedef char                        char_type;\n+    typedef char_traits<char>::int_type int_type;\n+    typedef char_traits<char>::pos_type pos_type;\n+    typedef char_traits<char>::off_type off_type;\n+\n+    strstream();\n+    strstream(char*, int, ios_base::openmode = ios_base::in | ios_base::out);\n+    virtual ~strstream();\n+\n+    strstreambuf* rdbuf() const;\n+    void freeze(bool = true);\n+    int pcount() const;\n+    char* str();\n+\n+  private:\n+    strstreambuf _M_buf;\n+  };\n+} // namespace std\n+#endif "}, {"sha": "c20812e3d5410e221e103f0c00294a7319832917", "filename": "libstdc++-v3/include/backward/strstream.h", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1b7ba13bbe16749456b30cd8d8cf297cf9e41e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1b7ba13bbe16749456b30cd8d8cf297cf9e41e/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fstrstream.h?ref=8d1b7ba13bbe16749456b30cd8d8cf297cf9e41e", "patch": "@@ -1,174 +0,0 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/*\n- * Copyright (c) 1998\n- * Silicon Graphics Computer Systems, Inc.\n- *\n- * Permission to use, copy, modify, distribute and sell this software\n- * and its documentation for any purpose is hereby granted without fee,\n- * provided that the above copyright notice appear in all copies and\n- * that both that copyright notice and this permission notice appear\n- * in supporting documentation.  Silicon Graphics makes no\n- * representations about the suitability of this software for any\n- * purpose.  It is provided \"as is\" without express or implied warranty.\n- */\n-\n-// WARNING: The classes defined in this header are DEPRECATED.  This\n-// header is defined in section D.7.1 of the C++ standard, and it\n-// MAY BE REMOVED in a future standard revision.  You should use the\n-// header <sstream> instead.\n-\n-#ifndef _CPP_BACKWARD_STRSTREAM_H\n-#define _CPP_BACKWARD_STRSTREAM_H 1\n-\n-#include \"backward_warning.h\"\n-#include <iosfwd>\n-#include <ios>\n-#include <istream>\n-#include <ostream>\n-#include <string>\n-\n-// Class strstreambuf, a streambuf class that manages an array of char.\n-// Note that this class is not a template.\n-class strstreambuf : public std::basic_streambuf<char>\n-{\n-public:                         \n-  // Types.\n-  typedef std::char_traits<char>              _Traits;\n-  typedef std::basic_streambuf<char, _Traits> _Base;\n-\n-public:  \n-  // Constructor, destructor\n-  explicit strstreambuf(std::streamsize __initial_capacity = 0);\n-  strstreambuf(void* (*__alloc)(size_t), void (*__free)(void*));\n-\n-  strstreambuf(char* __get, std::streamsize __n, char* __put = 0);\n-  strstreambuf(signed char* __get, std::streamsize __n, \n-\t       signed char* __put = 0);\n-  strstreambuf(unsigned char* __get, std::streamsize __n, \n-\t       unsigned char* __put=0);\n-  \n-  strstreambuf(const char* __get, std::streamsize __n);\n-  strstreambuf(const signed char* __get, std::streamsize __n);\n-  strstreambuf(const unsigned char* __get, std::streamsize __n);\n-  \n-  virtual ~strstreambuf();\n-\n-public:\n-  void freeze(bool = true);\n-  char* str();\n-  int pcount() const;\n-\n-protected:\n-  virtual int_type overflow(int_type __c  = _Traits::eof());\n-  virtual int_type pbackfail(int_type __c = _Traits::eof());\n-  virtual int_type underflow();\n-  virtual _Base* setbuf(char* __buf, std::streamsize __n);\n-  virtual pos_type seekoff(off_type __off, std::ios_base::seekdir __dir,\n-\t\t\t   std::ios_base::openmode __mode\n-\t\t\t   = std::ios_base::in | std::ios_base::out);\n-  virtual pos_type seekpos(pos_type __pos, std::ios_base::openmode __mode\n-\t\t\t   = std::ios_base::in | std::ios_base::out);\n-  \n-private:  \n-  // Dynamic allocation, possibly using _M_alloc_fun and _M_free_fun.\n-  char* _M_alloc(size_t);\n-  void  _M_free(char*);\n-  \n-  // Helper function used in constructors.\n-  void _M_setup(char* __get, char* __put, std::streamsize __n);\n-  \n-private:  \n-  // Data members.\n-  void* (*_M_alloc_fun)(size_t);\n-  void  (*_M_free_fun)(void*);\n-  \n-  bool _M_dynamic  : 1;\n-  bool _M_frozen   : 1;\n-  bool _M_constant : 1;\n-};\n-\n-// Class istrstream, an istream that manages a strstreambuf.\n-class istrstream : public std::basic_istream<char>\n-{\n-public:\n-  explicit istrstream(char*);\n-  explicit istrstream(const char*);\n-  istrstream(char* , std::streamsize);\n-  istrstream(const char*, std::streamsize);\n-  virtual ~istrstream();\n-  \n-  strstreambuf* rdbuf() const;\n-  char* str();\n-  \n-private:\n-  strstreambuf _M_buf;\n-};\n-\n-// Class ostrstream\n-class ostrstream : public std::basic_ostream<char>\n-{\n-public:\n-  ostrstream();\n-  ostrstream(char*, int, std::ios_base::openmode = std::ios_base::out);\n-  virtual ~ostrstream();\n-  \n-  strstreambuf* rdbuf() const;\n-  void freeze(bool = true);\n-  char* str();\n-  int pcount() const;\n-  \n-private:\n-  strstreambuf _M_buf;\n-};\n-\n-// Class strstream\n-class strstream : public std::basic_iostream<char>\n-{\n-public:\n-  typedef char                        char_type;\n-  typedef std::char_traits<char>::int_type int_type;\n-  typedef std::char_traits<char>::pos_type pos_type;\n-  typedef std::char_traits<char>::off_type off_type;\n-  \n-  strstream();\n-  strstream(char*, int, \n-\t    std::ios_base::openmode = std::ios_base::in | std::ios_base::out);\n-  virtual ~strstream();\n-  \n-  strstreambuf* rdbuf() const;\n-  void freeze(bool = true);\n-  int pcount() const;\n-  char* str();\n-  \n-private:\n-  strstreambuf _M_buf;\n-};\n-#endif "}, {"sha": "7252afde32375fe1efc5ecf44b02edb5557c093d", "filename": "libstdc++-v3/src/strstream.cc", "status": "modified", "additions": 339, "deletions": 336, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstrstream.cc?ref=9a56333e555ee0001d568b3d1c91bee2ad825578", "patch": "@@ -47,156 +47,156 @@\n // MAY BE REMOVED in a future standard revision.  You should use the\n // header <sstream> instead.\n \n-#include <strstream.h>\n+#include <strstream>\n #include <algorithm>\n #include <new>\n #include <stdlib.h>\n #include <string.h>\n #include <limits.h>\n \n-using namespace std;\n-\n-strstreambuf::strstreambuf(streamsize initial_capacity)\n-: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(true), \n-  _M_frozen(false), _M_constant(false)\n+namespace std\n {\n-  _M_buf_size = _M_buf_size_opt = max(initial_capacity, streamsize(16));\n-  _M_buf = _M_alloc(_M_buf_size);\n-  if (_M_buf) \n-    {\n-      setp(_M_buf, _M_buf + _M_buf_size);\n-      setg(_M_buf, _M_buf, _M_buf);\n-    }\n-}\n-\n-strstreambuf::strstreambuf(void* (*alloc_f)(size_t), void (*free_f)(void*))\n-: _Base(), _M_alloc_fun(alloc_f), _M_free_fun(free_f), _M_dynamic(true), \n+  strstreambuf::strstreambuf(streamsize initial_capacity)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(true), \n+    _M_frozen(false), _M_constant(false)\n+  {\n+    _M_buf_size = _M_buf_size_opt = max(initial_capacity, streamsize(16));\n+    _M_buf = _M_alloc(_M_buf_size);\n+    if (_M_buf) \n+      {\n+\tsetp(_M_buf, _M_buf + _M_buf_size);\n+\tsetg(_M_buf, _M_buf, _M_buf);\n+      }\n+  }\n+\n+  strstreambuf::strstreambuf(void* (*alloc_f)(size_t), void (*free_f)(void*))\n+  : _Base(), _M_alloc_fun(alloc_f), _M_free_fun(free_f), _M_dynamic(true), \n+    _M_frozen(false), _M_constant(false)\n+  {\n+    _M_buf_size = _M_buf_size_opt = 16;\n+    _M_buf = _M_alloc(_M_buf_size);\n+    if (_M_buf) \n+      {\n+\tsetp(_M_buf, _M_buf + _M_buf_size);\n+\tsetg(_M_buf, _M_buf, _M_buf);\n+      }\n+  }\n+\n+  strstreambuf::strstreambuf(char* get, streamsize n, char* put)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(false)\n+  { _M_setup(get, put, n); }\n+\n+  strstreambuf::strstreambuf(signed char* get, streamsize n, signed char* put)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n   _M_frozen(false), _M_constant(false)\n-{\n-  _M_buf_size = _M_buf_size_opt = 16;\n-  _M_buf = _M_alloc(_M_buf_size);\n-  if (_M_buf) \n-    {\n-      setp(_M_buf, _M_buf + _M_buf_size);\n-      setg(_M_buf, _M_buf, _M_buf);\n-    }\n-}\n-\n-strstreambuf::strstreambuf(char* get, streamsize n, char* put)\n-: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-  _M_frozen(false), _M_constant(false)\n-{ _M_setup(get, put, n); }\n-\n-strstreambuf::strstreambuf(signed char* get, streamsize n, signed char* put)\n-: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-  _M_frozen(false), _M_constant(false)\n-{ _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n-\n-strstreambuf::strstreambuf(unsigned char* get, streamsize n, \n-\t\t\t   unsigned char* put)\n-: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-  _M_frozen(false), _M_constant(false)\n-{ _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n-\n-strstreambuf::strstreambuf(const char* get, streamsize n)\n-: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-  _M_frozen(false), _M_constant(true)\n-{ _M_setup(const_cast<char*>(get), 0, n); }\n-\n-strstreambuf::strstreambuf(const signed char* get, streamsize n)\n-: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-  _M_frozen(false), _M_constant(true)\n-{ _M_setup(reinterpret_cast<char*>(const_cast<signed char*>(get)), 0, n); }\n-\n-strstreambuf::strstreambuf(const unsigned char* get, streamsize n)\n-: _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n-  _M_frozen(false), _M_constant(true)\n-{ _M_setup(reinterpret_cast<char*>(const_cast<unsigned char*>(get)), 0, n); }\n-\n-strstreambuf::~strstreambuf()\n-{\n-  if (_M_dynamic && !_M_frozen)\n-    {\n-      char* p = this->eback();\n-      _M_free(p);\n-      if (p == _M_buf)\n-\t_M_buf = 0;\n-    }\n-  if (_M_buf)\n-    _M_free(_M_buf);\n-}\n-\n-void \n-strstreambuf::freeze(bool frozenflag)\n-{\n-  if (_M_dynamic)\n-    _M_frozen = frozenflag;\n-}\n-\n-char* \n-strstreambuf::str()\n-{\n-  freeze(true);\n-  return eback();\n-}\n-\n-int \n-strstreambuf::pcount() const\n-{ return pptr() ? pptr() - pbase() : 0; }\n-\n-strstreambuf::int_type \n-strstreambuf::overflow(int_type c) \n-{\n-  if (c == traits_type::eof())\n-    return traits_type::not_eof(c);\n+  { _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n+\n+  strstreambuf::strstreambuf(unsigned char* get, streamsize n, \n+\t\t\t     unsigned char* put)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(false)\n+  { _M_setup(reinterpret_cast<char*>(get), reinterpret_cast<char*>(put), n); }\n+\n+  strstreambuf::strstreambuf(const char* get, streamsize n)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(true)\n+  { _M_setup(const_cast<char*>(get), 0, n); }\n+\n+  strstreambuf::strstreambuf(const signed char* get, streamsize n)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(true)\n+  { _M_setup(reinterpret_cast<char*>(const_cast<signed char*>(get)), 0, n); }\n+\n+  strstreambuf::strstreambuf(const unsigned char* get, streamsize n)\n+  : _Base(), _M_alloc_fun(0), _M_free_fun(0), _M_dynamic(false), \n+    _M_frozen(false), _M_constant(true)\n+  { _M_setup(reinterpret_cast<char*>(const_cast<unsigned char*>(get)), 0, n); }\n+\n+  strstreambuf::~strstreambuf()\n+  {\n+    if (_M_dynamic && !_M_frozen)\n+      {\n+\tchar* p = this->eback();\n+\t_M_free(p);\n+\tif (p == _M_buf)\n+\t  _M_buf = 0;\n+      }\n+    if (_M_buf)\n+      _M_free(_M_buf);\n+  }\n+\n+  void \n+  strstreambuf::freeze(bool frozenflag)\n+  {\n+    if (_M_dynamic)\n+      _M_frozen = frozenflag;\n+  }\n+\n+  char* \n+  strstreambuf::str()\n+  {\n+    freeze(true);\n+    return eback();\n+  }\n+\n+  int \n+  strstreambuf::pcount() const\n+  { return pptr() ? pptr() - pbase() : 0; }\n+\n+  strstreambuf::int_type \n+  strstreambuf::overflow(int_type c) \n+  {\n+    if (c == traits_type::eof())\n+      return traits_type::not_eof(c);\n     \n-  // Try to expand the buffer.\n-  if (pptr() == epptr() && _M_dynamic && !_M_frozen && !_M_constant) \n-    {\n-      ptrdiff_t old_size = epptr() - pbase();\n-      ptrdiff_t new_size = max(2 * old_size, ptrdiff_t(1));\n+    // Try to expand the buffer.\n+    if (pptr() == epptr() && _M_dynamic && !_M_frozen && !_M_constant) \n+      {\n+\tptrdiff_t old_size = epptr() - pbase();\n+\tptrdiff_t new_size = max(2 * old_size, ptrdiff_t(1));\n \t\n-      char* buf = _M_alloc(new_size);\n-      if (buf) \n-\t{\n-\t  memcpy(buf, pbase(), old_size);\n-\t  char* old_buffer = pbase();\n-\t  bool reposition_get = false;\n-\t  ptrdiff_t old_get_offset;\n-\t  if (gptr() != 0) \n-\t    {\n-\t      reposition_get = true;\n-\t      old_get_offset = gptr() - eback();\n-\t    }\n+\tchar* buf = _M_alloc(new_size);\n+\tif (buf) \n+\t  {\n+\t    memcpy(buf, pbase(), old_size);\n+\t    char* old_buffer = pbase();\n+\t    bool reposition_get = false;\n+\t    ptrdiff_t old_get_offset;\n+\t    if (gptr() != 0) \n+\t      {\n+\t\treposition_get = true;\n+\t\told_get_offset = gptr() - eback();\n+\t      }\n \t    \n-\t  _M_buf = buf;\n-\t  _M_buf_size = _M_buf_size_opt = new_size;\n-\t  setp(buf, buf + new_size);\n-\t  pbump(old_size);\n-\n-\t  if (reposition_get)\n-\t    setg(buf, buf + old_get_offset, buf + \n-\t\t max(old_get_offset, old_size));\n-\n-\t  _M_free(old_buffer);\n-\t}\n-    }\n+\t    _M_buf = buf;\n+\t    _M_buf_size = _M_buf_size_opt = new_size;\n+\t    setp(buf, buf + new_size);\n+\t    pbump(old_size);\n+\n+\t    if (reposition_get)\n+\t      setg(buf, buf + old_get_offset, buf + \n+\t\t   max(old_get_offset, old_size));\n+\n+\t    _M_free(old_buffer);\n+\t  }\n+      }\n     \n-  if (pptr() != epptr()) \n-    {\n-      *pptr() = c;\n-      pbump(1);\n-      return c;\n-    }\n-  else\n-    return traits_type::eof();\n-}\n-\n-strstreambuf::int_type \n-strstreambuf::pbackfail(int_type c)\n-{\n-  if (gptr() != eback()) \n-    {\n+    if (pptr() != epptr()) \n+      {\n+\t*pptr() = c;\n+\tpbump(1);\n+\treturn c;\n+      }\n+    else\n+      return traits_type::eof();\n+  }\n+\n+  strstreambuf::int_type \n+  strstreambuf::pbackfail(int_type c)\n+  {\n+    if (gptr() != eback()) \n+      {\n       if (c == _Traits::eof()) \n \t{\n \t  gbump(-1);\n@@ -214,208 +214,211 @@ strstreambuf::pbackfail(int_type c)\n \t  return c;\n \t}\n     }\n-  return _Traits::eof();\n-}\n-\n-strstreambuf::int_type \n-strstreambuf::underflow()\n-{\n-  if (gptr() == egptr() && pptr() && pptr() > egptr())\n-    setg(eback(), gptr(), pptr());\n-    \n-  if (gptr() != egptr())\n-    return (unsigned char) *gptr();\n-  else\n     return _Traits::eof();\n-}\n-\n-basic_streambuf<char, char_traits<char> >*\n-strstreambuf::setbuf(char*, streamsize)\n-{ return this; }\n+  }\n \n-strstreambuf::pos_type\n-strstreambuf::seekoff(off_type off, ios_base::seekdir dir, \n-\t\t      ios_base::openmode mode)\n-{\n-  bool do_get = false;\n-  bool do_put = false;\n-\n-  if ((mode & (ios_base::in | ios_base::out)) \n-      == (ios_base::in | ios_base::out) &&\n-      (dir == ios_base::beg || dir == ios_base::end))\n-    do_get = do_put = true;\n-  else if (mode & ios_base::in)\n-    do_get = true;\n-  else if (mode & ios_base::out)\n-    do_put = true;\n-\n-  // !gptr() is here because, according to D.7.1 paragraph 4, the seekable\n-  // area is undefined if there is no get area.\n-  if ((!do_get && !do_put) || (do_put && !pptr()) || !gptr())\n-    return pos_type(off_type(-1));\n-\n-  char* seeklow  = eback();\n-  char* seekhigh = epptr() ? epptr() : egptr();\n-\n-  off_type newoff;\n-  switch (dir) \n-    {\n-    case ios_base::beg:\n-      newoff = 0;\n-      break;\n-    case ios_base::end:\n-      newoff = seekhigh - seeklow;\n-      break;\n-    case ios_base::cur:\n-      newoff = do_put ? pptr() - seeklow : gptr() - seeklow;\n-      break;\n-    default:\n-      return pos_type(off_type(-1));\n-    }\n+  strstreambuf::int_type \n+  strstreambuf::underflow()\n+  {\n+    if (gptr() == egptr() && pptr() && pptr() > egptr())\n+      setg(eback(), gptr(), pptr());\n     \n-  off += newoff;\n-  if (off < 0 || off > seekhigh - seeklow)\n-    return pos_type(off_type(-1));\n-\n-  if (do_put) \n-    {\n-      if (seeklow + off < pbase()) \n-\t{\n-\t  setp(seeklow, epptr());\n-\t  pbump(off);\n-\t}\n-      else \n-\t{\n-\t  setp(pbase(), epptr());\n-\t  pbump(off - (pbase() - seeklow));\n-\t}\n-    }\n-  if (do_get) \n-    {\n-      if (off <= egptr() - seeklow)\n-\tsetg(seeklow, seeklow + off, egptr());\n-      else if (off <= pptr() - seeklow)\n-\tsetg(seeklow, seeklow + off, pptr());\n-      else\n-\tsetg(seeklow, seeklow + off, epptr());\n-    }\n-  return pos_type(newoff);\n-}\n+    if (gptr() != egptr())\n+      return (unsigned char) *gptr();\n+    else\n+      return _Traits::eof();\n+  }\n+\n+  basic_streambuf<char, char_traits<char> >*\n+  strstreambuf::setbuf(char*, streamsize)\n+  { return this; }\n+\n+  strstreambuf::pos_type\n+  strstreambuf::seekoff(off_type off, ios_base::seekdir dir, \n+\t\t\tios_base::openmode mode)\n+  {\n+    bool do_get = false;\n+    bool do_put = false;\n+\n+    if ((mode & (ios_base::in | ios_base::out)) \n+\t== (ios_base::in | ios_base::out) &&\n+\t(dir == ios_base::beg || dir == ios_base::end))\n+      do_get = do_put = true;\n+    else if (mode & ios_base::in)\n+      do_get = true;\n+    else if (mode & ios_base::out)\n+      do_put = true;\n+\n+    // !gptr() is here because, according to D.7.1 paragraph 4, the seekable\n+    // area is undefined if there is no get area.\n+    if ((!do_get && !do_put) || (do_put && !pptr()) || !gptr())\n+      return pos_type(off_type(-1));\n \n-strstreambuf::pos_type\n-strstreambuf::seekpos(pos_type pos, ios_base::openmode mode)\n-{ return seekoff(pos - pos_type(off_type(0)), ios_base::beg, mode); }\n+    char* seeklow  = eback();\n+    char* seekhigh = epptr() ? epptr() : egptr();\n+\n+    off_type newoff;\n+    switch (dir) \n+      {\n+      case ios_base::beg:\n+\tnewoff = 0;\n+\tbreak;\n+      case ios_base::end:\n+\tnewoff = seekhigh - seeklow;\n+\tbreak;\n+      case ios_base::cur:\n+\tnewoff = do_put ? pptr() - seeklow : gptr() - seeklow;\n+\tbreak;\n+      default:\n+\treturn pos_type(off_type(-1));\n+      }\n+    \n+    off += newoff;\n+    if (off < 0 || off > seekhigh - seeklow)\n+      return pos_type(off_type(-1));\n \n-char* \n-strstreambuf::_M_alloc(size_t n)\n-{\n-  if (_M_alloc_fun)\n-    return static_cast<char*>(_M_alloc_fun(n));\n-  else\n-    return new char[n];\n-}\n-\n-void \n-strstreambuf::_M_free(char* p)\n-{\n-  if (p)\n-    if (_M_free_fun)\n-      _M_free_fun(p);\n+    if (do_put) \n+      {\n+\tif (seeklow + off < pbase()) \n+\t  {\n+\t    setp(seeklow, epptr());\n+\t    pbump(off);\n+\t  }\n+\telse \n+\t  {\n+\t    setp(pbase(), epptr());\n+\t    pbump(off - (pbase() - seeklow));\n+\t  }\n+      }\n+    if (do_get) \n+      {\n+\tif (off <= egptr() - seeklow)\n+\t  setg(seeklow, seeklow + off, egptr());\n+\telse if (off <= pptr() - seeklow)\n+\t  setg(seeklow, seeklow + off, pptr());\n+\telse\n+\t  setg(seeklow, seeklow + off, epptr());\n+      }\n+    return pos_type(newoff);\n+  }\n+\n+  strstreambuf::pos_type\n+  strstreambuf::seekpos(pos_type pos, ios_base::openmode mode)\n+  { return seekoff(pos - pos_type(off_type(0)), ios_base::beg, mode); }\n+\n+  char* \n+  strstreambuf::_M_alloc(size_t n)\n+  {\n+    if (_M_alloc_fun)\n+      return static_cast<char*>(_M_alloc_fun(n));\n     else\n-      delete[] p;\n-}\n-\n-void \n-strstreambuf::_M_setup(char* get, char* put, streamsize n)\n-{\n-  if (get) \n-    {\n-      size_t N = n > 0 ? size_t(n) : n == 0 ? strlen(get) : size_t(INT_MAX);\n+      return new char[n];\n+  }\n+\n+  void \n+  strstreambuf::_M_free(char* p)\n+  {\n+    if (p)\n+      if (_M_free_fun)\n+\t_M_free_fun(p);\n+      else\n+\tdelete[] p;\n+  }\n+\n+  void \n+  strstreambuf::_M_setup(char* get, char* put, streamsize n)\n+  {\n+    if (get) \n+      {\n+\tsize_t N = n > 0 ? size_t(n) : n == 0 ? strlen(get) : size_t(INT_MAX);\n \t\n-      if (put) \n-\t{\n-\t  setg(get, get, put);\n-\t  setp(put, put + N);\n-\t}\n-      else \n-\tsetg(get, get, get + N);\n-    }\n-}\n-\n-istrstream::istrstream(char* s)\n-: basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n-{ basic_ios<char>::init(&_M_buf); }\n-\n-istrstream::istrstream(const char* s)\n-: basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n-{ basic_ios<char>::init(&_M_buf); }\n-\n-istrstream::istrstream(char* s, streamsize n)\n-: basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n-{ basic_ios<char>::init(&_M_buf); }\n-\n-istrstream::istrstream(const char* s, streamsize n)\n-: basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n-{ basic_ios<char>::init(&_M_buf); }\n-\n-istrstream::~istrstream() { }\n-\n-strstreambuf* \n-istrstream::rdbuf() const \n-{ return const_cast<strstreambuf*>(&_M_buf); }\n-\n-char* \n-istrstream::str() \n-{ return _M_buf.str(); }\n-\n-ostrstream::ostrstream() : basic_ios<char>(), basic_ostream<char>(0), _M_buf()\n-{ basic_ios<char>::init(&_M_buf); }\n-\n-ostrstream::ostrstream(char* s, int n, ios_base::openmode mode)\n-: basic_ios<char>(), basic_ostream<char>(0), \n-  _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n-{ basic_ios<char>::init(&_M_buf); }\n-\n-ostrstream::~ostrstream() {}\n-\n-strstreambuf* \n-ostrstream::rdbuf() const\n-{ return const_cast<strstreambuf*>(&_M_buf); }\n-\n-void \n-ostrstream::freeze(bool freezeflag)\n-{ _M_buf.freeze(freezeflag); }\n-\n-char* \n-ostrstream::str()\n-{ return _M_buf.str(); }\n-\n-int \n-ostrstream::pcount() const\n-{ return _M_buf.pcount(); }\n-\n-strstream::strstream() : basic_ios<char>(), basic_iostream<char>(0), _M_buf()\n-{ basic_ios<char>::init(&_M_buf); }\n-\n-strstream::strstream(char* s, int n, ios_base::openmode mode)\n-: basic_ios<char>(), basic_iostream<char>(0), \n-  _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n-{ basic_ios<char>::init(&_M_buf); }\n-\n-strstream::~strstream() { }\n-\n-strstreambuf* \n-strstream::rdbuf() const\n-{ return const_cast<strstreambuf*>(&_M_buf); }\n-\n-void \n-strstream::freeze(bool freezeflag)\n-{ _M_buf.freeze(freezeflag); }\n-\n-int \n-strstream::pcount() const\n-{ return _M_buf.pcount(); }\n-\n-char* \n-strstream::str()\n-{ return _M_buf.str(); }\n+\tif (put) \n+\t  {\n+\t    setg(get, get, put);\n+\t    setp(put, put + N);\n+\t  }\n+\telse \n+\t  setg(get, get, get + N);\n+      }\n+  }\n+\n+  istrstream::istrstream(char* s)\n+  : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n+  { basic_ios<char>::init(&_M_buf); }\n+\n+  istrstream::istrstream(const char* s)\n+  : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, 0)\n+  { basic_ios<char>::init(&_M_buf); }\n+\n+  istrstream::istrstream(char* s, streamsize n)\n+  : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n+  { basic_ios<char>::init(&_M_buf); }\n+\n+  istrstream::istrstream(const char* s, streamsize n)\n+  : basic_ios<char>(), basic_istream<char>(0), _M_buf(s, n)\n+  { basic_ios<char>::init(&_M_buf); }\n+\n+  istrstream::~istrstream() { }\n+\n+  strstreambuf* \n+  istrstream::rdbuf() const \n+  { return const_cast<strstreambuf*>(&_M_buf); }\n+\n+  char* \n+  istrstream::str() \n+  { return _M_buf.str(); }\n+\n+  ostrstream::ostrstream()\n+  : basic_ios<char>(), basic_ostream<char>(0), _M_buf()\n+  { basic_ios<char>::init(&_M_buf); }\n+\n+  ostrstream::ostrstream(char* s, int n, ios_base::openmode mode)\n+  : basic_ios<char>(), basic_ostream<char>(0), \n+    _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n+  { basic_ios<char>::init(&_M_buf); }\n+\n+  ostrstream::~ostrstream() {}\n+\n+  strstreambuf* \n+  ostrstream::rdbuf() const\n+  { return const_cast<strstreambuf*>(&_M_buf); }\n+\n+  void \n+  ostrstream::freeze(bool freezeflag)\n+  { _M_buf.freeze(freezeflag); }\n+\n+  char* \n+  ostrstream::str()\n+  { return _M_buf.str(); }\n+\n+  int \n+  ostrstream::pcount() const\n+  { return _M_buf.pcount(); }\n+\n+  strstream::strstream()\n+  : basic_ios<char>(), basic_iostream<char>(0), _M_buf()\n+  { basic_ios<char>::init(&_M_buf); }\n+\n+  strstream::strstream(char* s, int n, ios_base::openmode mode)\n+  : basic_ios<char>(), basic_iostream<char>(0), \n+    _M_buf(s, n, mode & ios_base::app ? s + strlen(s) : s)\n+  { basic_ios<char>::init(&_M_buf); }\n+\n+  strstream::~strstream() { }\n+\n+  strstreambuf* \n+  strstream::rdbuf() const\n+  { return const_cast<strstreambuf*>(&_M_buf); }\n+\n+  void \n+  strstream::freeze(bool freezeflag)\n+  { _M_buf.freeze(freezeflag); }\n+\n+  int \n+  strstream::pcount() const\n+  { return _M_buf.pcount(); }\n+\n+  char* \n+  strstream::str()\n+  { return _M_buf.str(); }\n+} // namespace std"}, {"sha": "f8ae7d37fa79b97246262300fbf67256e98177dd", "filename": "libstdc++-v3/testsuite/backward/strstream_members.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fstrstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a56333e555ee0001d568b3d1c91bee2ad825578/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fstrstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fbackward%2Fstrstream_members.cc?ref=9a56333e555ee0001d568b3d1c91bee2ad825578", "patch": "@@ -18,14 +18,14 @@\n \n // backward strstream members\n \n-#include <strstream.h>\n+#include <strstream>\n #include <testsuite_hooks.h>\n \n // { dg-options \"-Wno-deprecated\" }\n \n int test01()\n {\n-   strstream s;\n+   std::strstream s;\n    for (unsigned i=0 ; i!= 1000 ; ++i)\n       s << i << std::endl;\n    s << std::ends;"}]}