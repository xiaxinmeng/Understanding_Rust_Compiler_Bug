{"sha": "3aee198212070736d6a42f3a53f943f61ddc9d4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FlZTE5ODIxMjA3MDczNmQ2YTQyZjNhNTNmOTQzZjYxZGRjOWQ0YQ==", "commit": {"author": {"name": "Ian Bolton", "email": "ian.bolton@arm.com", "date": "2012-06-18T17:24:25Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2012-06-18T17:24:25Z"}, "message": "This patch adds new define_insn patterns for epilogue with integer\nregisters.\n\nThe patterns can handle pop multiple with writeback and return (loading into\nPC directly).\nTo handle return, the patterns use a new special predicate\npop_multiple_return, that uses ldm_stm_operation_p function from a previous\npatch. To output assembly, the patterns use a new function\narm_output_multireg_pop.\n\nThis patch also adds a new function arm_emit_multi_reg_pop\nthat emits RTL that matches the new pop patterns for integer registers.\nThis is a helper function for epilogue expansion. It is used by a later\npatch.\n\n2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n            Sameera Deshpande  <sameera.deshpande@arm.com>\n            Greta Yorsh  <greta.yorsh@arm.com>\n\n        * config/arm/arm.md (load_multiple_with_writeback) New define_insn.\n        (load_multiple, pop_multiple_with_writeback_and_return) Likewise.\n        (pop_multiple_with_return, ldr_with_return) Likewise.\n        * config/arm/predicates.md (pop_multiple_return) New special predicate.\n        * config/arm/arm-protos.h (arm_output_multireg_pop) New declaration.\n        * config/arm/arm.c (arm_output_multireg_pop) New function.\n        (arm_emit_multi_reg_pop): New function.\n\n\nCo-Authored-By: Greta Yorsh <greta.yorsh@arm.com>\nCo-Authored-By: Sameera Deshpande <sameera.deshpande@arm.com>\n\nFrom-SVN: r188739", "tree": {"sha": "54f6acbbd5d6ba5320cdcd59bc25cd4deceb85cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54f6acbbd5d6ba5320cdcd59bc25cd4deceb85cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aee198212070736d6a42f3a53f943f61ddc9d4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aee198212070736d6a42f3a53f943f61ddc9d4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aee198212070736d6a42f3a53f943f61ddc9d4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aee198212070736d6a42f3a53f943f61ddc9d4a/comments", "author": null, "committer": null, "parents": [{"sha": "474038cda92c3ee8c77be7368d9c954bca922579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/474038cda92c3ee8c77be7368d9c954bca922579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/474038cda92c3ee8c77be7368d9c954bca922579"}], "stats": {"total": 283, "additions": 283, "deletions": 0}, "files": [{"sha": "b3d50d3aba5a95c05655b5ae87044f6d26544195", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3aee198212070736d6a42f3a53f943f61ddc9d4a", "patch": "@@ -1,3 +1,15 @@\n+2012-06-18  Ian Bolton  <ian.bolton@arm.com>\n+            Sameera Deshpande  <sameera.deshpande@arm.com>\n+            Greta Yorsh  <greta.yorsh@arm.com>\n+\n+        * config/arm/arm.md (load_multiple_with_writeback) New define_insn.\n+        (load_multiple, pop_multiple_with_writeback_and_return) Likewise.\n+        (pop_multiple_with_return, ldr_with_return) Likewise.\n+        * config/arm/predicates.md (pop_multiple_return) New special predicate.\n+        * config/arm/arm-protos.h (arm_output_multireg_pop) New declaration.\n+        * config/arm/arm.c (arm_output_multireg_pop) New function.\n+        (arm_emit_multi_reg_pop): New function.\n+\n 2012-06-18  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* config/arm/arm.c (ldm_stm_operation_p): Require SP"}, {"sha": "c3d9773c5473b3c6140033cef3064cf68bf2c83e", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=3aee198212070736d6a42f3a53f943f61ddc9d4a", "patch": "@@ -156,6 +156,7 @@ extern int    arm_emit_vector_const (FILE *, rtx);\n extern void arm_emit_fp16_const (rtx c);\n extern const char * arm_output_load_gr (rtx *);\n extern const char *vfp_output_fstmd (rtx *);\n+extern void arm_output_multireg_pop (rtx *, bool, rtx, bool, bool);\n extern void arm_set_return_address (rtx, rtx);\n extern int arm_eliminable_register (rtx);\n extern const char *arm_output_shift(rtx *, int);"}, {"sha": "5b3e6f5add3f84acd0de9d5f61ec2c2885acf3f3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=3aee198212070736d6a42f3a53f943f61ddc9d4a", "patch": "@@ -13739,6 +13739,83 @@ vfp_output_fldmd (FILE * stream, unsigned int base, int reg, int count)\n }\n \n \n+/* OPERANDS[0] is the entire list of insns that constitute pop,\n+   OPERANDS[1] is the base register, RETURN_PC is true iff return insn\n+   is in the list, UPDATE is true iff the list contains explicit\n+   update of base register.  */\n+void\n+arm_output_multireg_pop (rtx *operands, bool return_pc, rtx cond, bool reverse,\n+                         bool update)\n+{\n+  int i;\n+  char pattern[100];\n+  int offset;\n+  const char *conditional;\n+  int num_saves = XVECLEN (operands[0], 0);\n+  unsigned int regno;\n+  unsigned int regno_base = REGNO (operands[1]);\n+\n+  offset = 0;\n+  offset += update ? 1 : 0;\n+  offset += return_pc ? 1 : 0;\n+\n+  /* Is the base register in the list?  */\n+  for (i = offset; i < num_saves; i++)\n+    {\n+      regno = REGNO (XEXP (XVECEXP (operands[0], 0, i), 0));\n+      /* If SP is in the list, then the base register must be SP.  */\n+      gcc_assert ((regno != SP_REGNUM) || (regno_base == SP_REGNUM));\n+      /* If base register is in the list, there must be no explicit update.  */\n+      if (regno == regno_base)\n+        gcc_assert (!update);\n+    }\n+\n+  conditional = reverse ? \"%?%D0\" : \"%?%d0\";\n+  if ((regno_base == SP_REGNUM) && TARGET_UNIFIED_ASM)\n+    {\n+      /* Output pop (not stmfd) because it has a shorter encoding.  */\n+      gcc_assert (update);\n+      sprintf (pattern, \"pop%s\\t{\", conditional);\n+    }\n+  else\n+    {\n+      /* Output ldmfd when the base register is SP, otherwise output ldmia.\n+         It's just a convention, their semantics are identical.  */\n+      if (regno_base == SP_REGNUM)\n+        sprintf (pattern, \"ldm%sfd\\t\", conditional);\n+      else if (TARGET_UNIFIED_ASM)\n+        sprintf (pattern, \"ldmia%s\\t\", conditional);\n+      else\n+        sprintf (pattern, \"ldm%sia\\t\", conditional);\n+\n+      strcat (pattern, reg_names[regno_base]);\n+      if (update)\n+        strcat (pattern, \"!, {\");\n+      else\n+        strcat (pattern, \", {\");\n+    }\n+\n+  /* Output the first destination register.  */\n+  strcat (pattern,\n+          reg_names[REGNO (XEXP (XVECEXP (operands[0], 0, offset), 0))]);\n+\n+  /* Output the rest of the destination registers.  */\n+  for (i = offset + 1; i < num_saves; i++)\n+    {\n+      strcat (pattern, \", \");\n+      strcat (pattern,\n+              reg_names[REGNO (XEXP (XVECEXP (operands[0], 0, i), 0))]);\n+    }\n+\n+  strcat (pattern, \"}\");\n+\n+  if (IS_INTERRUPT (arm_current_func_type ()) && return_pc)\n+    strcat (pattern, \"^\");\n+\n+  output_asm_insn (pattern, &cond);\n+}\n+\n+\n /* Output the assembly for a store multiple.  */\n \n const char *\n@@ -16386,6 +16463,87 @@ emit_multi_reg_push (unsigned long mask)\n   return par;\n }\n \n+/* Generate and emit an insn pattern that we will recognize as a pop_multi.\n+   SAVED_REGS_MASK shows which registers need to be restored.\n+\n+   Unfortunately, since this insn does not reflect very well the actual\n+   semantics of the operation, we need to annotate the insn for the benefit\n+   of DWARF2 frame unwind information.  */\n+static void\n+arm_emit_multi_reg_pop (unsigned long saved_regs_mask)\n+{\n+  int num_regs = 0;\n+  int i, j;\n+  rtx par;\n+  rtx dwarf = NULL_RTX;\n+  rtx tmp, reg;\n+  bool return_in_pc;\n+  int offset_adj;\n+  int emit_update;\n+\n+  return_in_pc = (saved_regs_mask & (1 << PC_REGNUM)) ? true : false;\n+  offset_adj = return_in_pc ? 1 : 0;\n+  for (i = 0; i <= LAST_ARM_REGNUM; i++)\n+    if (saved_regs_mask & (1 << i))\n+      num_regs++;\n+\n+  gcc_assert (num_regs && num_regs <= 16);\n+\n+  /* If SP is in reglist, then we don't emit SP update insn.  */\n+  emit_update = (saved_regs_mask & (1 << SP_REGNUM)) ? 0 : 1;\n+\n+  /* The parallel needs to hold num_regs SETs\n+     and one SET for the stack update.  */\n+  par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num_regs + emit_update + offset_adj));\n+\n+  if (return_in_pc)\n+    {\n+      tmp = ret_rtx;\n+      XVECEXP (par, 0, 0) = tmp;\n+    }\n+\n+  if (emit_update)\n+    {\n+      /* Increment the stack pointer, based on there being\n+         num_regs 4-byte registers to restore.  */\n+      tmp = gen_rtx_SET (VOIDmode,\n+                         stack_pointer_rtx,\n+                         plus_constant (Pmode,\n+                                        stack_pointer_rtx,\n+                                        4 * num_regs));\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      XVECEXP (par, 0, offset_adj) = tmp;\n+    }\n+\n+  /* Now restore every reg, which may include PC.  */\n+  for (j = 0, i = 0; j < num_regs; i++)\n+    if (saved_regs_mask & (1 << i))\n+      {\n+        reg = gen_rtx_REG (SImode, i);\n+        tmp = gen_rtx_SET (VOIDmode,\n+                           reg,\n+                           gen_frame_mem\n+                           (SImode,\n+                            plus_constant (Pmode, stack_pointer_rtx, 4 * j)));\n+        RTX_FRAME_RELATED_P (tmp) = 1;\n+        XVECEXP (par, 0, j + emit_update + offset_adj) = tmp;\n+\n+        /* We need to maintain a sequence for DWARF info too.  As dwarf info\n+           should not have PC, skip PC.  */\n+        if (i != PC_REGNUM)\n+          dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+\n+        j++;\n+      }\n+\n+  if (return_in_pc)\n+    par = emit_jump_insn (par);\n+  else\n+    par = emit_insn (par);\n+\n+  REG_NOTES (par) = dwarf;\n+}\n+\n /* Calculate the size of the return value that is passed in registers.  */\n static unsigned\n arm_size_return_regs (void)"}, {"sha": "3fa207bab834bd78885476a40ba19c5ee16079f3", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=3aee198212070736d6a42f3a53f943f61ddc9d4a", "patch": "@@ -10863,6 +10863,89 @@\n   [(set_attr \"length\" \"0\")]\n )\n \n+;; Pop (as used in epilogue RTL)\n+;;\n+(define_insn \"*load_multiple_with_writeback\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 1 \"s_register_operand\" \"+rk\")\n+          (plus:SI (match_dup 1)\n+                   (match_operand:SI 2 \"const_int_operand\" \"I\")))\n+     (set (match_operand:SI 3 \"s_register_operand\" \"=rk\")\n+          (mem:SI (match_dup 1)))\n+        ])]\n+  \"TARGET_32BIT && (reload_in_progress || reload_completed)\"\n+  \"*\n+  {\n+    arm_output_multireg_pop (operands, /*return_pc=*/false,\n+                                       /*cond=*/const_true_rtx,\n+                                       /*reverse=*/false,\n+                                       /*update=*/true);\n+    return \\\"\\\";\n+  }\n+  \"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n+\n+;; Pop with return (as used in epilogue RTL)\n+;;\n+;; This instruction is generated when the registers are popped at the end of\n+;; epilogue.  Here, instead of popping the value into LR and then generating\n+;; jump to LR, value is popped into PC directly.  Hence, the pattern is combined\n+;;  with (return).\n+(define_insn \"*pop_multiple_with_writeback_and_return\"\n+  [(match_parallel 0 \"pop_multiple_return\"\n+    [(return)\n+     (set (match_operand:SI 1 \"s_register_operand\" \"+rk\")\n+          (plus:SI (match_dup 1)\n+                   (match_operand:SI 2 \"const_int_operand\" \"I\")))\n+     (set (match_operand:SI 3 \"s_register_operand\" \"=rk\")\n+          (mem:SI (match_dup 1)))\n+        ])]\n+  \"TARGET_32BIT && (reload_in_progress || reload_completed)\"\n+  \"*\n+  {\n+    arm_output_multireg_pop (operands, /*return_pc=*/true,\n+                                       /*cond=*/const_true_rtx,\n+                                       /*reverse=*/false,\n+                                       /*update=*/true);\n+    return \\\"\\\";\n+  }\n+  \"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n+\n+(define_insn \"*pop_multiple_with_return\"\n+  [(match_parallel 0 \"pop_multiple_return\"\n+    [(return)\n+     (set (match_operand:SI 2 \"s_register_operand\" \"=rk\")\n+          (mem:SI (match_operand:SI 1 \"s_register_operand\" \"rk\")))\n+        ])]\n+  \"TARGET_32BIT && (reload_in_progress || reload_completed)\"\n+  \"*\n+  {\n+    arm_output_multireg_pop (operands, /*return_pc=*/true,\n+                                       /*cond=*/const_true_rtx,\n+                                       /*reverse=*/false,\n+                                       /*update=*/false);\n+    return \\\"\\\";\n+  }\n+  \"\n+  [(set_attr \"type\" \"load4\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n+\n+;; Load into PC and return\n+(define_insn \"*ldr_with_return\"\n+  [(return)\n+   (set (reg:SI PC_REGNUM)\n+        (mem:SI (post_inc:SI (match_operand:SI 0 \"s_register_operand\" \"+rk\"))))]\n+  \"TARGET_32BIT && (reload_in_progress || reload_completed)\"\n+  \"ldr%?\\t%|pc, [%0], #4\"\n+  [(set_attr \"type\" \"load1\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n ;; Special patterns for dealing with the constant pool\n \n (define_insn \"align_4\"\n@@ -11294,6 +11377,27 @@\n \n ;; Load the load/store multiple patterns\n (include \"ldmstm.md\")\n+\n+;; Patterns in ldmstm.md don't cover more than 4 registers. This pattern covers\n+;; large lists without explicit writeback generated for APCS_FRAME epilogue.\n+(define_insn \"*load_multiple\"\n+  [(match_parallel 0 \"load_multiple_operation\"\n+    [(set (match_operand:SI 2 \"s_register_operand\" \"=rk\")\n+          (mem:SI (match_operand:SI 1 \"s_register_operand\" \"rk\")))\n+        ])]\n+  \"TARGET_32BIT\"\n+  \"*\n+  {\n+    arm_output_multireg_pop (operands, /*return_pc=*/false,\n+                                       /*cond=*/const_true_rtx,\n+                                       /*reverse=*/false,\n+                                       /*update=*/false);\n+    return \\\"\\\";\n+  }\n+  \"\n+  [(set_attr \"predicable\" \"yes\")]\n+)\n+\n ;; Vector bits common to IWMMXT and Neon\n (include \"vec-common.md\")\n ;; Load the Intel Wireless Multimedia Extension patterns"}, {"sha": "6eaab3d49e9923ba8f79003ea1181bb1ea32afb7", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aee198212070736d6a42f3a53f943f61ddc9d4a/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=3aee198212070736d6a42f3a53f943f61ddc9d4a", "patch": "@@ -368,6 +368,14 @@\n                                  /*return_pc=*/false);\n })\n \n+(define_special_predicate \"pop_multiple_return\"\n+  (match_code \"parallel\")\n+{\n+ return ldm_stm_operation_p (op, /*load=*/true, SImode,\n+                                 /*consecutive=*/false,\n+                                 /*return_pc=*/true);\n+})\n+\n (define_special_predicate \"multi_register_push\"\n   (match_code \"parallel\")\n {"}]}