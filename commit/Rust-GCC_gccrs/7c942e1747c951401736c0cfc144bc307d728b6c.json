{"sha": "7c942e1747c951401736c0cfc144bc307d728b6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M5NDJlMTc0N2M5NTE0MDE3MzZjMGNmYzE0NGJjMzA3ZDcyOGI2Yw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-05-15T21:47:36Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-05-15T21:47:36Z"}, "message": "config.gcc: Purge all targets obsoleted in GCC 3.3.\n\n\t* config.gcc: Purge all targets obsoleted in GCC 3.3.  Also\n\tremove hppa*-*-mpeix* which could not be built, and prune\n\tfiles from tmake_file= or tm_file= lists that don't exist.\n\n\t* config/alpha/alpha-interix.h, config/alpha/alpha32.h\n\t* config/alpha/t-interix, config/arm/conix-elf.h\n\t* config/arm/t-arm-aout, config/arm/t-strongarm-coff\n\t* config/arm/unknown-elf-oabi.h, config/i386/win32.h\n\t* config/m68k/3b1.h, config/m68k/3b1g.h, config/m68k/amix.h\n\t* config/m68k/atari.h, config/m68k/ccur-GAS.h, config/m68k/crds.h\n\t* config/m68k/hp2bsd.h, config/m68k/hp3bsd.h\n\t* config/m68k/hp3bsd44.h, config/m68k/linux-aout.h\n\t* config/m68k/m68k-psos.h, config/m68k/mot3300.h\n\t* config/m68k/pbb.h, config/m68k/plexus.h, config/m68k/sun2.h\n\t* config/m68k/sun2o4.h, config/m68k/sun3.h, config/m68k/sun3mach.h\n\t* config/m68k/sun3n.h, config/m68k/sun3n3.h, config/m68k/sun3o3.h\n\t* config/m68k/t-mot3300, config/m68k/t-mot3300-gald\n\t* config/m68k/t-mot3300-gas, config/m68k/t-mot3300-gld\n\t* config/m68k/tower-as.h, config/m68k/tower.h\n\t* config/m88k/aout-dbx.h, config/m88k/m88k-aout.h\n\t* config/m88k/m88k-modes.def, config/m88k/m88k-move.sh\n\t* config/m88k/m88k-protos.h, config/m88k/m88k.c\n\t* config/m88k/m88k.h, config/m88k/m88k.md, config/m88k/openbsd.h\n\t* config/m88k/sysv4.h, config/m88k/t-luna, config/m88k/t-luna-gas\n\t* config/m88k/t-m88k, config/m88k/t-sysv4, config/mcore/gfloat.h\n\t* config/mips/rtems64.h, config/mips/sni-gas.h\n\t* config/mips/sni-svr4.h, config/mips/t-ecoff\n\t* config/mn10200/lib1funcs.asm, config/mn10200/mn10200-protos.h\n\t* config/mn10200/mn10200.c, config/mn10200/mn10200.h\n\t* config/mn10200/mn10200.md, config/mn10200/t-mn10200\n\t* config/pa/pa-hiux.h, config/pa/pa-hpux7.h, config/pa/pa-hpux9.h\n\t* config/pa/pa-oldas.h, config/pa/t-mpeix, config/psos.h\n\t* config/romp/romp-protos.h, config/romp/romp.c\n\t* config/romp/romp.h, config/romp/romp.md, config/rs6000/aix31.h\n\t* config/rs6000/aix3newas.h, config/rs6000/mach.h\n\t* config/sparc/bsd.h, config/sparc/hal.h\n\t* config/sparc/linux-aout.h, config/sparc/lynx-ng.h\n\t* config/sparc/lynx.h, config/sparc/netbsd.h\n\t* config/sparc/sp86x-aout.h, config/sparc/splet.h\n\t* config/sparc/sun4gas.h, config/sparc/sun4o3.h\n\t* config/sparc/sunos4.h, config/sparc/t-chorus-elf\n\t* config/sparc/t-halos, config/sparc/t-sparcbare\n\t* config/sparc/t-splet, config/sparc/t-sunos41\n\t* config/v850/rtems.h: Delete file.\n\nFrom-SVN: r66842", "tree": {"sha": "18faca5e7ea2246a002a630eb97ac60e50068c5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18faca5e7ea2246a002a630eb97ac60e50068c5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c942e1747c951401736c0cfc144bc307d728b6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c942e1747c951401736c0cfc144bc307d728b6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c942e1747c951401736c0cfc144bc307d728b6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c942e1747c951401736c0cfc144bc307d728b6c/comments", "author": null, "committer": null, "parents": [{"sha": "a6ebc39a661502ac9ae1c14f11a41b05cb780896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ebc39a661502ac9ae1c14f11a41b05cb780896", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ebc39a661502ac9ae1c14f11a41b05cb780896"}], "stats": {"total": 28535, "additions": 84, "deletions": 28451}, "files": [{"sha": "1aa0a321312194e2fb9165fa10c53aa2213ba400", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c942e1747c951401736c0cfc144bc307d728b6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c942e1747c951401736c0cfc144bc307d728b6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c942e1747c951401736c0cfc144bc307d728b6c", "patch": "@@ -1,10 +1,57 @@\n+2003-05-15  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* config.gcc: Purge all targets obsoleted in GCC 3.3.  Also\n+\tremove hppa*-*-mpeix* which could not be built, and prune\n+\tfiles from tmake_file= or tm_file= lists that don't exist.\n+\n+\t* config/alpha/alpha-interix.h, config/alpha/alpha32.h\n+\t* config/alpha/t-interix, config/arm/conix-elf.h\n+\t* config/arm/t-arm-aout, config/arm/t-strongarm-coff\n+\t* config/arm/unknown-elf-oabi.h, config/i386/win32.h\n+\t* config/m68k/3b1.h, config/m68k/3b1g.h, config/m68k/amix.h\n+\t* config/m68k/atari.h, config/m68k/ccur-GAS.h, config/m68k/crds.h\n+\t* config/m68k/hp2bsd.h, config/m68k/hp3bsd.h\n+\t* config/m68k/hp3bsd44.h, config/m68k/linux-aout.h\n+\t* config/m68k/m68k-psos.h, config/m68k/mot3300.h\n+\t* config/m68k/pbb.h, config/m68k/plexus.h, config/m68k/sun2.h\n+\t* config/m68k/sun2o4.h, config/m68k/sun3.h, config/m68k/sun3mach.h\n+\t* config/m68k/sun3n.h, config/m68k/sun3n3.h, config/m68k/sun3o3.h\n+\t* config/m68k/t-mot3300, config/m68k/t-mot3300-gald\n+\t* config/m68k/t-mot3300-gas, config/m68k/t-mot3300-gld\n+\t* config/m68k/tower-as.h, config/m68k/tower.h\n+\t* config/m88k/aout-dbx.h, config/m88k/m88k-aout.h\n+\t* config/m88k/m88k-modes.def, config/m88k/m88k-move.sh\n+\t* config/m88k/m88k-protos.h, config/m88k/m88k.c\n+\t* config/m88k/m88k.h, config/m88k/m88k.md, config/m88k/openbsd.h\n+\t* config/m88k/sysv4.h, config/m88k/t-luna, config/m88k/t-luna-gas\n+\t* config/m88k/t-m88k, config/m88k/t-sysv4, config/mcore/gfloat.h\n+\t* config/mips/rtems64.h, config/mips/sni-gas.h\n+\t* config/mips/sni-svr4.h, config/mips/t-ecoff\n+\t* config/mn10200/lib1funcs.asm, config/mn10200/mn10200-protos.h\n+\t* config/mn10200/mn10200.c, config/mn10200/mn10200.h\n+\t* config/mn10200/mn10200.md, config/mn10200/t-mn10200\n+\t* config/pa/pa-hiux.h, config/pa/pa-hpux7.h, config/pa/pa-hpux9.h\n+\t* config/pa/pa-oldas.h, config/pa/t-mpeix, config/psos.h\n+\t* config/romp/romp-protos.h, config/romp/romp.c\n+\t* config/romp/romp.h, config/romp/romp.md, config/rs6000/aix31.h\n+\t* config/rs6000/aix3newas.h, config/rs6000/mach.h\n+\t* config/sparc/bsd.h, config/sparc/hal.h\n+\t* config/sparc/linux-aout.h, config/sparc/lynx-ng.h\n+\t* config/sparc/lynx.h, config/sparc/netbsd.h\n+\t* config/sparc/sp86x-aout.h, config/sparc/splet.h\n+\t* config/sparc/sun4gas.h, config/sparc/sun4o3.h\n+\t* config/sparc/sunos4.h, config/sparc/t-chorus-elf\n+\t* config/sparc/t-halos, config/sparc/t-sparcbare\n+\t* config/sparc/t-splet, config/sparc/t-sunos41\n+\t* config/v850/rtems.h: Delete file.\n+\n 2003-05-15  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/rs6000-protos.h (function_value): Protoize.\n+\t* config/rs6000/rs6000-protos.h (function_value): Protoize.\n \n-        * config/rs6000/rs6000.h (FUNCTION_VALUE): Call function.\n+\t* config/rs6000/rs6000.h (FUNCTION_VALUE): Call function.\n \n-        * config/rs6000/rs6000.c (rs6000_function_value): New.\n+\t* config/rs6000/rs6000.c (rs6000_function_value): New.\n \n 2003-05-15  Philip Blundell  <philb@gnu.org>\n "}, {"sha": "b1c55edcb11b1aa36d5645796c0e695d9fede485", "filename": "gcc/config.gcc", "status": "modified", "additions": 34, "deletions": 577, "changes": 611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c942e1747c951401736c0cfc144bc307d728b6c/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c942e1747c951401736c0cfc144bc307d728b6c/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=7c942e1747c951401736c0cfc144bc307d728b6c", "patch": "@@ -226,62 +226,7 @@ need_64bit_hwint=\n \n # Obsolete configurations.\n case $machine in\n-   m88k-*-*\t\t\t\\\n- | mn10200-*-*\t\t\t\\\n- | romp-*-*\t\t\t\\\n- | alpha*-*-interix*\t\t\\\n- | alpha*-*-linux*libc1*\t\\\n- | alpha*-*-linux*ecoff*\t\\\n- | arm*-*-aout*\t\t\t\\\n- | arm*-*-conix*\t\t\\\n- | arm*-*-oabi\t\t\t\\\n- | strongarm-*-coff*\t\t\\\n- | hppa1.0-*-osf*\t\t\\\n- | hppa1.0-*-bsd*\t\t\\\n- | hppa1.[01]-*-hpux[789]*\t\\\n- | hppa*-*-hiux*\t\t\\\n- | hppa*-*-lites*\t\t\\\n- | i?86-*-win32\t\t\t\\\n- | m68000-hp-bsd*\t\t\\\n- | m68000-sun-sunos*\t\t\\\n- | m68000-att-sysv*\t\t\\\n- | m68k-atari-sysv*\t\t\\\n- | m68k-motorola-sysv*\t\t\\\n- | m68k-ncr-sysv*\t\t\\\n- | m68k-plexus-sysv*\t\t\\\n- | m68k-tti-*\t\t\t\\\n- | m68k-crds-unos*\t\t\\\n- | m68k-cbm-sysv*\t\t\\\n- | m68k-ccur-rtu*\t\t\\\n- | m68k-hp-bsd*\t\t\t\\\n- | m68k-sun-mach*\t\t\\\n- | m68k-sun-sunos*\t\t\\\n- | m68k-*-linux*aout*\t\t\\\n- | m68k-*-linux*libc1*\t\t\\\n- | m68k-*-psos*\t\t\t\\\n- | mips*-*-ecoff*\t\t\\\n- | mips-sni-sysv4\t\t\\\n- | mips64orion-*-rtems*\t\t\\\n- | ns32k-*-openbsd*\t\t\\\n- | powerpc*-*-sysv*\t\t\\\n- | powerpc*-*-linux*libc1*\t\\\n- | rs6000-ibm-aix[123]*\t\t\\\n- | rs6000-bull-bosx\t\t\\\n- | rs6000-*-mach*\t\t\\\n- | sparc-*-aout*\t\t\\\n- | sparc-*-netbsd*aout*\t\t\\\n- | sparc-*-bsd*\t\t\t\\\n- | sparc-*-chorusos*\t\t\\\n- | sparc-*-linux*aout*\t\t\\\n- | sparc-*-linux*libc1*\t\t\\\n- | sparc-*-lynxos*\t\t\\\n- | sparc-hal-solaris2*\t\t\\\n- | sparc-*-sunos[34]*\t\t\\\n- | sparclet-*-aout*\t\t\\\n- | sparclite-*-aout*\t\t\\\n- | sparc86x-*-aout*\t\t\\\n- | v850-*-rtems*\t\t\\\n- )\n+ dummy)\n     if test \"x$enable_obsolete\" != xyes; then\n       echo \"*** Configuration $machine is obsolete.\" >&2\n       echo \"*** Specify --enable-obsolete to build it anyway.\" >&2\n@@ -291,6 +236,32 @@ case $machine in\n     fi;;\n esac\n \n+# Unsupported targets list.  Do not put an entry in this list unless\n+# it would otherwise be caught by a more permissive pattern.  The list\n+# should be in alphabetical order.\n+case $machine in\n+   alpha*-*-linux*libc1*\t\t\\\n+ | i[34567]86-sequent-sysv*\t\t\\\n+ | i[34567]86-go32-*\t\t\t\\\n+ | i[34567]86-*-go32*\t\t\t\\\n+ | m68k-*-linux*aout*\t\t\t\\\n+ | m68k-*-linux*libc1*\t\t\t\\\n+ | mips64orion*-*-rtems*\t\t\\\n+ | powerpc-*-linux*libc1*\t\t\\\n+ | sparc-*-linux*aout*\t\t\t\\\n+ | sparc-*-linux*libc1*\t\t\t\\\n+ | sparc-hal-solaris2*\t\t\t\\\n+ | thumb-*-*\t\t\t\t\\\n+ | *-*-linux*coff*\t\t\t\\\n+ | *-*-linux*oldld*\t\t\t\\\n+ | *-*-rtemsaout*\t\t\t\\\n+ | *-*-rtemscoff*\t\t\t\\\n+ )\n+\techo \"*** Configuration $machine not supported\" 1>&2\n+\texit 1\n+\t;;\n+esac\n+\n # Set default cpu_type, tm_file, tm_p_file and xm_file so it can be\n # updated in each machine entry.  Also set default extra_headers for some\n # machines.\n@@ -396,7 +367,7 @@ esac\n case $machine in\n *-*-linux*)\n \tcase $machine in\n-\t*-*-linux*ecoff* | *-*-linux*libc1* | *-*-linux*oldld* | *-*-linux*aout*)\n+\t *-*-linux*libc1* | *-*-linux*aout*)\n \t\t;;\n \t*)\n \t\textra_parts=\"crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o\"\n@@ -566,39 +537,6 @@ alpha*-*-unicosmk*)\n \t# tmake_file=\"alpha/t-ieee\"\n \ttmake_file=\"alpha/t-unicosmk\"\n \t;;\n-alpha-*-interix)\n-\ttm_file=\"${tm_file} alpha/alpha32.h interix.h alpha/alpha-interix.h\"\n-\n-\t# GAS + IEEE_CONFORMANT+IEEE (no inexact);\n-\t#target_cpu_default=\"MASK_GAS|MASK_IEEE_CONFORMANT|MASK_IEEE\"\n-\n-\t# GAS + IEEE_CONFORMANT\n-\ttarget_cpu_default=\"MASK_GAS|MASK_IEEE_CONFORMANT\"\n-\n-\ttmake_file=\"alpha/t-alpha t-interix alpha/t-interix alpha/t-ieee\"\n-\tif test x$enable_threads = xyes ; then\n-\t\tthread_file='posix'\n-\tfi\n-\tif test x$stabs = xyes ; then\n-\t\ttm_file=\"${tm_file} dbxcoff.h\"\n-\tfi\n-\t#prefix='$$INTERIX_ROOT'/usr/contrib\n-\t#local_prefix='$$INTERIX_ROOT'/usr/contrib\n-\t;;\n-alpha*-*-linux*ecoff*)\n-\techo \"Configuration $machine no longer supported\" 1>&2\n-\texit 1\n-\t;;\n-alpha*-*-linux*libc1*)\n-\ttm_file=\"${tm_file} alpha/elf.h alpha/linux.h alpha/linux-elf.h\"\n-\ttarget_cpu_default=\"MASK_GAS\"\n-\ttmake_file=\"t-slibgcc-elf-ver t-linux t-linux-gnulibc1 alpha/t-alpha alpha/t-crtfm alpha/t-ieee\"\n-\textra_parts=\"crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o\"\n-\tgas=yes gnu_ld=yes\n-\tif test x$enable_threads = xyes; then\n-\t\tthread_file='posix'\n-\tfi\n-\t;;\n alpha*-*-linux*)\n \ttm_file=\"${tm_file} alpha/elf.h alpha/linux.h alpha/linux-elf.h\"\n \ttarget_cpu_default=\"MASK_GAS\"\n@@ -699,10 +637,6 @@ arm-*-coff* | armel-*-coff*)\n \ttm_file=\"arm/semi.h arm/aout.h arm/arm.h arm/coff.h\"\n \ttmake_file=arm/t-arm-coff\n \t;;\n-arm-semi-aout | armel-semi-aout)\n-\ttm_file=\"arm/semi.h arm/aout.h arm/arm.h\"\n-\ttmake_file=arm/t-semi\n-\t;;\n arm-semi-aof | armel-semi-aof)\n \ttm_file=\"arm/semiaof.h arm/aof.h arm/arm.h\"\n \ttmake_file=arm/t-semi\n@@ -736,10 +670,6 @@ arm*-*-uclinux*)\t\t# ARM ucLinux\n \ttm_file=\"dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/linux-gas.h arm/linux-elf.h arm/uclinux-elf.h\"\n \ttmake_file=arm/t-arm-elf\n \t;;\n-arm*-*-aout)\n-\ttm_file=\"arm/aout.h arm/arm.h\"\n-\ttmake_file=arm/t-arm-aout\n-\t;;\n arm*-*-ecos-elf)\n \ttm_file=\"dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h arm/ecos-elf.h\"\n \ttmake_file=arm/t-arm-elf\n@@ -755,14 +685,6 @@ arm*-*-elf | ep9312-*-elf)\n \ttm_file=\"dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h\"\n \ttmake_file=arm/t-arm-elf\n \t;;\n-arm*-*-conix*)\n-\ttm_file=\"dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/conix-elf.h arm/aout.h arm/arm.h\"\n-\ttmake_file=arm/t-arm-elf\n-\t;;\n-arm*-*-oabi)\n-\ttm_file=\"arm/unknown-elf-oabi.h dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h\"\n-\ttmake_file=arm/t-arm-elf\n-\t;;\n arm-*-pe*)\n \ttm_file=\"arm/semi.h arm/aout.h arm/arm.h arm/coff.h arm/pe.h\"\n \ttmake_file=arm/t-pe\n@@ -865,65 +787,13 @@ hppa1.1-*-rtems*)\n \t  thread_file='rtems'\n \tfi\n \t;;\n-hppa1.0-*-osf*)\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-osf.h\"\n-\ttmake_file=\"pa/t-bsd pa/t-pa\"\n-\txmake_file=\"pa/x-ada\"\n-\tuse_collect2=yes\n-\t;;\n hppa1.1-*-bsd*)\n \ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h\"\n \ttarget_cpu_default=\"MASK_PA_11\"\n \ttmake_file=\"pa/t-bsd pa/t-pa\"\n \txmake_file=\"pa/x-ada\"\n \tuse_collect2=yes\n \t;;\n-hppa1.0-*-bsd*)\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h\"\n-\ttmake_file=\"pa/t-bsd pa/t-pa\"\n-\txmake_file=\"pa/x-ada\"\n-\tuse_collect2=yes\n-\t;;\n-hppa1.0-*-hpux7*)\n-\ttm_file=\"pa/pa-oldas.h ${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux7.h\"\n-\ttmake_file=pa/t-pa-hpux\n-\tinstall_headers_dir=install-headers-cpio\n-\tuse_collect2=yes\n-\t;;\n-hppa1.0-*-hpux8.0[0-2]*)\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n-\ttmake_file=pa/t-pa-hpux\n-\tif test x$gas != xyes\n-\tthen\n-\t\ttm_file=\"pa/pa-oldas.h ${tm_file}\"\n-\tfi\n-\tinstall_headers_dir=install-headers-cpio\n-\tuse_collect2=yes\n-\t;;\n-hppa1.1-*-hpux8.0[0-2]*)\n-\ttarget_cpu_default=\"MASK_PA_11\"\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n-\ttmake_file=pa/t-pa-hpux\n-\tif test x$gas != xyes\n-\tthen\n-\t\ttm_file=\"pa/pa-oldas.h ${tm_file}\"\n-\tfi\n-\tinstall_headers_dir=install-headers-cpio\n-\tuse_collect2=yes\n-\t;;\n-hppa1.1-*-hpux8*)\n-\ttarget_cpu_default=\"MASK_PA_11\"\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n-\ttmake_file=pa/t-pa-hpux\n-\tinstall_headers_dir=install-headers-cpio\n-\tuse_collect2=yes\n-\t;;\n-hppa1.0-*-hpux8*)\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h\"\n-\ttmake_file=pa/t-pa-hpux\n-\tinstall_headers_dir=install-headers-cpio\n-\tuse_collect2=yes\n-\t;;\n hppa1.1-*-hpux10* | hppa2*-*-hpux10*)\n \ttarget_cpu_default=\"MASK_PA_11\"\n \ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-hpux.h pa/pa-hpux10.h\"\n@@ -1013,47 +883,6 @@ hppa1.0-*-hpux11*)\n \tinstall_headers_dir=install-headers-cpio\n \tuse_collect2=yes\n \t;;\n-hppa1.1-*-hpux* | hppa2*-*-hpux*)\n-\ttarget_cpu_default=\"MASK_PA_11\"\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n-\ttmake_file=pa/t-pa-hpux\n-\tinstall_headers_dir=install-headers-cpio\n-\tuse_collect2=yes\n-\t;;\n-hppa1.0-*-hpux*)\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hpux9.h\"\n-\ttmake_file=pa/t-pa-hpux\n-\tinstall_headers_dir=install-headers-cpio\n-\tuse_collect2=yes\n-\t;;\n-hppa1.1-*-hiux* | hppa2*-*-hiux*)\n-\ttarget_cpu_default=\"MASK_PA_11\"\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n-\ttmake_file=pa/t-pa-hpux\n-\tinstall_headers_dir=install-headers-cpio\n-\tuse_collect2=yes\n-\t;;\n-hppa1.0-*-hiux*)\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/som.h pa/pa-hpux.h pa/pa-hiux.h\"\n-\ttmake_file=pa/t-pa-hpux\n-\tinstall_headers_dir=install-headers-cpio\n-\tuse_collect2=yes\n-\t;;\n-hppa*-*-lites*)\n-\ttm_file=\"${tm_file} pa/pa32-regs.h dbxelf.h elfos.h pa/elf.h\"\n-\ttarget_cpu_default=\"MASK_PA_11\"\n-\ttmake_file=\"pa/t-bsd pa/t-pa\"\n-\txmake_file=\"pa/x-ada\"\n-\tuse_collect2=yes\n-\t;;\n-hppa*-*-mpeix*)\n-\ttm_file=\"${tm_file} pa/pa32-regs.h pa/long_double.h pa/som.h pa/pa-mpeix.h\"\n-\ttmake_file=pa/t-mpeix\n-\techo \"You must use gas. Assuming it is already installed.\"\n-\tgas=yes\n-\tinstall_headers_dir=install-headers-tar\n-\tuse_collect2=yes\n-\t;;\n i370-*-opened*)\t\t\t # IBM 360/370/390 Architecture\n \txm_defines='FATAL_EXIT_CODE=12'\n \ttm_file=i370/oe.h\n@@ -1083,12 +912,7 @@ i[34567]86-*-elf*)\n \t;;\n i[34567]86-ncr-sysv4*)\t\t# NCR 3000 - ix86 running system V.4\n \txm_defines=\"SMALL_ARG_MAX\"\n-\tif test x$stabs = xyes -a x$gas = xyes\n-\tthen\n-\t\ttm_file=i386/sysv4gdb.h\n-\telse\n-\t\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/sysv4-cpp.h\"\n-\tfi\n+\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/sysv4-cpp.h\"\n \textra_parts=\"crtbegin.o crtend.o\"\n \ttmake_file=i386/t-crtpic\n \t;;\n@@ -1107,10 +931,6 @@ i[34567]86-sequent-ptx4* | i[34567]86-sequent-sysv4*)\n \textra_parts=\"crtbegin.o crtend.o\"\n \tinstall_headers_dir=install-headers-cpio\n \t;;\n-i[34567]86-sequent-sysv*)\t# would otherwise be caught by i?86-*-sysv*\n-\techo \"*** Configuration $machine not supported\" 1>&2\n-\texit 1\n-\t;;\n i[34567]86-*-aout*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/i386-aout.h\"\n \t;;\n@@ -1151,10 +971,6 @@ i[34567]86-*-openbsd*)\n i[34567]86-*-coff*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h\"\n \t;;\n-i[34567]86-*-linux*oldld*)\t# would otherwise be caught by i?86-*-linux*\n-\techo \"*** Configuration $machine not supported\" 1>&2\n-\texit 1\n-\t;;\n i[34567]86-*-linux*aout*)\t# Intel 80386's running GNU/Linux\n \t\t\t\t# with a.out format\n \ttmake_file=\"t-linux-aout i386/t-crtstuff\"\n@@ -1185,10 +1001,6 @@ x86_64-*-linux*)\n \t;;\n i[34567]86-*-gnu*)\n \t;;\n-i[34567]86-go32-msdos | i[34567]86-*-go32*)\n-\techo \"GO32/DJGPP V1.X is no longer supported. Use *-pc-msdosdjgpp for DJGPP V2.X instead.\"\n-\texit 1\n-\t;;\n i[34567]86-pc-msdosdjgpp*)\n \txm_file=i386/xm-djgpp.h\n \ttm_file=\"dbxcoff.h ${tm_file} i386/djgpp.h\"\n@@ -1220,11 +1032,6 @@ i[34567]86-*-mach*)\n #\ttmake_file=t-libc-ok\n \tuse_collect2=yes\n \t;;\n-i[34567]86-go32-rtems* | i[34567]86-*-rtemscoff*)\n-\t# would otherwise be caught by i?86-*-rtems*\n-\techo \"*** Configuration $machine not supported\" 1>&2\n-\texit 1\n-\t;;\n i[34567]86-*-rtems*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h i386/rtemself.h rtems.h\"\n \textra_parts=\"crtbegin.o crtend.o crti.o crtn.o\"\n@@ -1319,16 +1126,6 @@ i386-*-vsta)\t\t\t# Intel 80386's running VSTa kernel\n \txm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/xm-vsta.h\"\n \ttm_file=\"${tm_file} i386/vsta.h\"\n \t;;\n-i[34567]86-*-win32)\n-\txm_file=i386/xm-cygwin.h\n-\ttmake_file=i386/t-cygwin\n-\ttm_file=\"${tm_file} i386/win32.h\"\n-\textra_objs=winnt.o\n-\tif test x$enable_threads = xyes; then\n-\t\tthread_file='win32'\n-\tfi\n-\texeext=.exe\n-\t;;\n i[34567]86-*-pe | i[34567]86-*-cygwin*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/cygwin.h\"\n \txm_file=i386/xm-cygwin.h\n@@ -1472,10 +1269,6 @@ m68hc12-*-*|m6812-*-*)\n \tout_file=\"m68hc11/m68hc11.c\"\n \ttmake_file=\"m68hc11/t-m68hc11-gas\"\n         ;;\n-m68000-hp-bsd*)\t\t\t# HP 9000/200 running BSD\n-\ttm_file=m68k/hp2bsd.h\n-\tuse_collect2=yes\n-\t;;\n m68000-hp-hpux*)\t\t# HP 9000 series 300\n \tif test x$gas = xyes\n \tthen\n@@ -1487,95 +1280,11 @@ m68000-hp-hpux*)\t\t# HP 9000 series 300\n \tinstall_headers_dir=install-headers-cpio\n \tuse_collect2=yes\n \t;;\n-m68000-sun-sunos3*)\n-\ttm_file=m68k/sun2.h\n-\tuse_collect2=yes\n-\t;;\n-m68000-sun-sunos4*)\n-\ttm_file=m68k/sun2o4.h\n-\tuse_collect2=yes\n-\t;;\n-m68000-att-sysv*)\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_file=m68k/3b1g.h\n-\telse\n-\t\ttm_file=m68k/3b1.h\n-\tfi\n-\tuse_collect2=yes\n-\t;;\n-m68k-atari-sysv4*)              # Atari variant of V.4.\n-\ttm_file=m68k/atari.h\n-\ttmake_file=t-svr4\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\t;;\n-m68k-apollo-sysv* | m68k-bull-sysv*)\n-\t# can otherwise be caught by m68k-*-sysv4*\n-\techo \"*** Configuration $machine not supported\" 1>&2\n-\texit 1\n-\t;;\n-m68k-motorola-sysv*)\n-\ttm_file=m68k/mot3300.h\n-\tif test x$gas = xyes\n-\tthen\n-\t\tif test x$gnu_ld = xyes\n-\t\tthen\n-\t\t\ttmake_file=m68k/t-mot3300-gald\n-\t\telse\n-\t\t\ttmake_file=m68k/t-mot3300-gas\n-\t\t\tuse_collect2=yes\n-\t\tfi\n-\telse\n-\t\tif test x$gnu_ld = xyes\n-\t\tthen\n-\t\t\ttmake_file=m68k/t-mot3300-gld\n-\t\telse\n-\t\t\ttmake_file=m68k/t-mot3300\n-\t\t\tuse_collect2=yes\n-\t\tfi\n-\tfi\n-\tgdb_needs_out_file_path=yes\n-\textra_parts=\"crt0.o mcrt0.o\"\n-\t;;\n-m68k-ncr-sysv*)\t\t\t# NCR Tower 32 SVR3\n-\ttm_file=m68k/tower-as.h\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\t;;\n-m68k-plexus-sysv*)\n-\ttm_file=m68k/plexus.h\n-\tuse_collect2=yes\n-\t;;\n-m68k-tti-*)\n-\ttm_file=m68k/pbb.h\n-\t;;\n-m68k-crds-unos*)\n-\ttm_file=m68k/crds.h\n-\tuse_collect2=yes\n-\t;;\n-m68k-cbm-sysv4*)\t\t# Commodore variant of V.4.\n-\ttm_file=m68k/amix.h\n-\ttmake_file=t-svr4\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\t;;\n-m68k-ccur-rtu)\n-\ttm_file=m68k/ccur-GAS.h\n-\tuse_collect2=yes\n-\t;;\n-m68k-hp-bsd4.4*)\t\t# HP 9000/3xx running 4.4bsd\n-\ttm_file=m68k/hp3bsd44.h\n-\tuse_collect2=yes\n-\t;;\n-m68k-hp-bsd*)\t\t\t# HP 9000/3xx running Berkeley Unix\n-\ttm_file=m68k/hp3bsd.h\n-\tuse_collect2=yes\n-\t;;\n m68k-hp-hpux7*)\t# HP 9000 series 300 running HPUX version 7.\n \tif test x$gas = xyes\n \tthen\n-\t\txmake_file=m68k/x-hp320g\n \t\ttm_file=m68k/hp320g.h\n \telse\n-\t\txmake_file=m68k/x-hp320\n \t\ttm_file=m68k/hpux7.h\n \tfi\n \tinstall_headers_dir=install-headers-cpio\n@@ -1584,37 +1293,13 @@ m68k-hp-hpux7*)\t# HP 9000 series 300 running HPUX version 7.\n m68k-hp-hpux*)\t# HP 9000 series 300\n \tif test x$gas = xyes\n \tthen\n-\t\txmake_file=m68k/x-hp320g\n \t\ttm_file=m68k/hp320g.h\n \telse\n-\t\txmake_file=m68k/x-hp320\n \t\ttm_file=m68k/hp320.h\n \tfi\n \tinstall_headers_dir=install-headers-cpio\n \tuse_collect2=yes\n \t;;\n-m68k-sun-mach*)\n-\ttm_file=m68k/sun3mach.h\n-\tuse_collect2=yes\n-\t;;\n-m68k-sun-sunos3*)\n-\tif test x$with_fp = xno\n-\tthen\n-\t\ttm_file=m68k/sun3n3.h\n-\telse\n-\t\ttm_file=m68k/sun3o3.h\n-\tfi\n-\tuse_collect2=yes\n-\t;;\n-m68k-sun-sunos*)\t\t\t# For SunOS 4 (the default).\n-\tif test x$with_fp = xno\n-\tthen\n-\t\ttm_file=m68k/sun3n.h\n-\telse\n-\t\ttm_file=m68k/sun3.h\n-\tfi\n-\tuse_collect2=yes\n-\t;;\n m68k-*-aout*)\n \ttmake_file=m68k/t-m68kbare\n \ttm_file=\"m68k/m68k-aout.h libgloss.h\"\n@@ -1656,34 +1341,12 @@ m68k-*-sysv4*)\t\t\t# Motorola m68k's running system V.4\n \ttmake_file=t-svr4\n \textra_parts=\"crtbegin.o crtend.o\"\n \t;;\n-m68k-*-linux*aout*)\t\t# Motorola m68k's running GNU/Linux\n-\t\t\t\t# with a.out format\n-\ttm_file=m68k/linux-aout.h\n-\ttmake_file=\"t-linux-aout\"\n-\tgnu_ld=yes\n-\t;;\n-m68k-*-linux*libc1)\t\t# Motorola m68k's running GNU/Linux\n-\t\t\t\t# with ELF format using the\n-\t\t\t\t# GNU/Linux C library 5\n-\ttm_file=m68k/linux.h\n-\ttmake_file=\"t-slibgcc-elf-ver t-linux t-linux-gnulibc1\"\n-\textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n-\tgnu_ld=yes\n-\t;;\n m68k-*-linux*)\t\t# Motorola m68k's running GNU/Linux\n \t\t\t\t# with ELF format using glibc 2\n \t\t\t\t# aka the GNU/Linux C library 6.\n \ttm_file=m68k/linux.h\n \ttmake_file=\"t-slibgcc-elf-ver t-linux\"\n \t;;\n-m68k-*-psos*)\n-\ttmake_file=m68k/t-m68kbare\n-\ttm_file=m68k/m68k-psos.h\n-\t;;\n-m68k-*-rtemscoff*)\t# would otherwise be caught by m68k-*-rtems*\n-\techo \"*** Configuration $machine not supported\" 1>&2\n-\texit 1\n-\t;;\n m68k-*-rtems*)\n \ttmake_file=\"m68k/t-m68kbare t-rtems m68k/t-crtstuff\"\n \ttm_file=\"m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/m68kemb.h m68k/m68020-elf.h m68k/rtemself.h rtems.h\"\n@@ -1692,18 +1355,6 @@ m68k-*-rtems*)\n \t  thread_file='rtems'\n \tfi\n \t;;\n-m88k-*-aout*)\n-\ttm_file=m88k/m88k-aout.h\n-\t;;\n-m88k-*-openbsd*)\n-\ttmake_file=\"${tmake_file} m88k/t-luna-gas\"\n-\ttm_file=\"m88k/aout-dbx.h aoutos.h m88k/m88k.h openbsd.h ${tm_file}\"\n-\t;;\n-m88k-*-sysv4*)\n-\ttm_file=\"dbxelf.h elfos.h svr4.h m88k/sysv4.h\"\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\ttmake_file=m88k/t-sysv4\n-\t;;\n mcore-*-elf)\n \ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file} mcore/mcore-elf.h\"\n \ttmake_file=mcore/t-mcore\n@@ -1757,23 +1408,6 @@ mips-sgi-irix5cross64)\t\t# Irix5 host, Irix 6 target, cross64\n #\t\tthread_file='irix'\n #\tfi\n \t;;\n-mips-sni-sysv4)\n-\tif test x$gas = xyes\n-\tthen\n-\t\tif test x$stabs = xyes\n-\t\tthen\n-\t\t\ttm_file=mips/iris5gdb.h\n-\t\telse\n-\t\t\ttm_file=\"mips/sni-svr4.h mips/sni-gas.h\"\n-\t\tfi\n-\telse\n-\t\ttm_file=mips/sni-svr4.h\n-\tfi\n-        if test x$gnu_ld != xyes\n-        then\n-                use_collect2=yes\n-        fi\n-        ;;\n mips-sgi-irix5*)\t\t# SGI System V.4., IRIX 5\n \tif test x$gas = xyes\n \tthen\n@@ -1796,18 +1430,14 @@ mips-sgi-irix5*)\t\t# SGI System V.4., IRIX 5\n #\t\tthread_file='irix'\n #\tfi\n \t;;\n-mips-sgi-*)\t# would otherwise be caught by mips-*-elf*\n-\techo \"*** Configuration $machine not supported\" 1>&2\n-\texit 1\n-\t;;\n mips*-*-netbsd*)\t\t\t# NetBSD/mips, either endian.\n \ttarget_cpu_default=\"MASK_GAS|MASK_ABICALLS\"\n \ttm_file=\"elfos.h ${tm_file} mips/netbsd.h\"\n \ttmake_file=\"${tmake_file}\"\n \t;;\n mips64*-*-linux*)\n \ttm_file=\"dbxelf.h elfos.h svr4.h linux.h ${tm_file} mips/linux.h mips/linux64.h\"\n-\ttmake_file=\"t-slibgcc-elf-ver t-linux mips/t-linux mips/t-linux64\"\n+\ttmake_file=\"t-slibgcc-elf-ver t-linux mips/t-linux64\"\n \n \t# This default ABI is a partial lie: t-linux64 overrides the\n \t# DRIVER_SELF_SPEC that sets the default abi, in the spec file\n@@ -1840,12 +1470,6 @@ mips*-*-openbsd*)\t\t# mips big endian\n \ttarget_cpu_default=\"MASK_GAS|MASK_ABICALLS\"\n \ttm_file=\"mips/openbsd-be.h ${tm_file}\"\n \t;;\n-mips-*-ecoff* | mipsel-*-ecoff*)\n-\tif test x$stabs = xyes; then\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\ttmake_file=mips/t-ecoff\n-\t;;\n mipsisa32-*-elf* | mipsisa32el-*-elf*)\n \ttm_file=\"${tm_file} mips/elf.h\"\n \ttmake_file=mips/t-isa3264\n@@ -1896,16 +1520,6 @@ mips64orion-*-elf* | mips64orionel-*-elf*)\n \ttarget_cpu_default=\"MASK_64BIT|MASK_FLOAT64|MASK_GAS\"\n \ttm_defines=\"MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_O64\"\n \t;;\n-mips64orion-*-rtems*)\n-\ttm_file=\"${tm_file} mips/elforion.h mips/elf64.h mips/rtems64.h rtems.h\"\n-\ttmake_file=\"mips/t-elf t-rtems\"\n-\ttmake_file=mips/t-elf\n-\ttarget_cpu_default=\"MASK_64BIT|MASK_FLOAT64|MASK_GAS\"\n-\ttm_defines=\"MIPS_ISA_DEFAULT=3 MIPS_ABI_DEFAULT=ABI_O64\"\n-\tif test x$enable_threads = xyes; then\n-\t  thread_file='rtems'\n-\tfi\n-\t;;\n mips*-*-rtems*)\n \ttm_file=\"${tm_file} mips/elf.h mips/rtems.h rtems.h\"\n \ttmake_file=\"mips/t-elf t-rtems\"\n@@ -1920,14 +1534,6 @@ mipstx39-*-elf* | mipstx39el-*-elf*)\n mmix-knuth-mmixware)\n \tneed_64bit_hwint=yes\n \t;;\n-mn10200-*-*)\n-\ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n-\tif test x$stabs = xyes\n-\tthen\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tuse_collect2=no\n-\t;;\n mn10300-*-*)\n \ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n \tif test x$stabs = xyes\n@@ -1953,14 +1559,8 @@ pdp11-*-*)\n \t;;\n avr-*-*)\n \t;;\n-ns32k-*-openbsd*)\n-\t# Nothing special\n-\t;;\n-romp-*-openbsd*)\n-\t# Nothing special\n-\t;;\n powerpc-*-openbsd*)\n-\ttmake_file=\"${tmake_file} rs6000/t-fprules rs6000/t-openbsd\"\n+\ttmake_file=\"${tmake_file} rs6000/t-fprules \"\n \textra_headers=\n \t;;\n powerpc64-*-linux*)\n@@ -1990,10 +1590,6 @@ powerpc*-*-freebsd*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h ${fbsd_tm_file} rs6000/sysv4.h rs6000/freebsd.h\"\n \ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos ${tmake_file} rs6000/t-ppccomm\"\n \t;;\n-powerpc-*-sysv*)\n-\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos rs6000/t-ppccomm\"\n-\t;;\n powerpc-*-netbsd*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h netbsd.h netbsd-elf.h freebsd-spec.h rs6000/sysv4.h rs6000/netbsd.h\"\n \ttmake_file=\"${tmake_file} rs6000/t-netbsd\"\n@@ -2033,23 +1629,16 @@ powerpc-*-eabi*)\n \t;;\n powerpc-*-rtems*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/eabi.h rs6000/rtems.h rtems.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-rtems t-rtems rs6000/t-ppccomm\"\n+\ttmake_file=\"rs6000/t-fprules t-rtems rs6000/t-ppccomm\"\n \tif test x$enable_threads = xyes; then\n \t  thread_file='rtems'\n \tfi\n \t;;\n-powerpc-*-linux*libc1)\n-\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-linux t-linux-gnulibc1 rs6000/t-ppccomm\"\n-\tif test x$enable_threads = xyes; then\n-\t\tthread_file='posix'\n-\tfi\n-\t;;\n-powerpc-*-linux-gnualtivec*)\n+powerpc-*-linux*altivec*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h\"\n \ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-linux rs6000/t-ppccomm\"\n \t;;\n-powerpc-*-linux-gnuspe*)\n+powerpc-*-linux*spe*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxspe.h\"\n \ttmake_file=\"rs6000/t-fprules rs6000/t-ppcos t-slibgcc-elf-ver t-linux rs6000/t-ppccomm\"\n \t;;\n@@ -2100,16 +1689,6 @@ powerpcle-*-eabi*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h freebsd-spec.h rs6000/sysv4.h rs6000/sysv4le.h rs6000/eabi.h\"\n \ttmake_file=\"rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm\"\n \t;;\n-rs6000-ibm-aix3.[01]*)\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix31.h rs6000/xcoff.h\"\n-\tuse_collect2=yes\n-\t;;\n-rs6000-ibm-aix3.2.[456789]* | powerpc-ibm-aix3.2.[456789]*)\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix3newas.h rs6000/xcoff.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-newas\"\n-\tuse_collect2=yes\n-\textra_headers=\n-\t;;\n rs6000-ibm-aix4.[12]* | powerpc-ibm-aix4.[12]*)\n \ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix41.h rs6000/xcoff.h\"\n \ttmake_file=\"rs6000/t-fprules rs6000/t-newas\"\n@@ -2137,18 +1716,6 @@ rs6000-ibm-aix[56789].* | powerpc-ibm-aix[56789].*)\n \tthread_file='aix'\n \textra_headers=\n \t;;\n-rs6000-ibm-aix*)\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/xcoff.h\"\n-\tuse_collect2=yes\n-\t;;\n-rs6000-bull-bosx)\n-\ttm_file=\"${tm_file} rs6000/aix.h rs6000/xcoff.h\"\n-\tuse_collect2=yes\n-\t;;\n-rs6000-*-mach*)\n-\ttm_file=\"${tm_file} rs6000/mach.h\"\n-\tuse_collect2=yes\n-\t;;\n rs6000-*-lynxos*)\n \ttm_file=\"lynx.h rs6000/lynx.h\"\n \ttmake_file=rs6000/t-fprules\n@@ -2274,19 +1841,9 @@ sh-*-*)\n sparc-tti-*)\n \ttm_file=\"${tm_file} sparc/pbd.h\"\n \t;;\n-sparc-*-aout*)\n-\ttmake_file=sparc/t-sparcbare\n-\ttm_file=\"sparc/sparc.h aoutos.h sparc/aout.h libgloss.h\"\n-\t;;\n sparc-*-netbsdelf*)\n \ttm_file=\"${tm_file} elfos.h svr4.h sparc/sysv4.h netbsd.h netbsd-elf.h sparc/netbsd-elf.h\"\n \t;;\n-sparc-*-netbsd*)\n-\ttm_file=\"${tm_file} sparc/aout.h netbsd.h netbsd-aout.h sparc/netbsd.h\"\n-\ttmake_file=t-netbsd\n-\textra_parts=\"\"\n-\tuse_collect2=yes\n-\t;;\n sparc-*-openbsd*)\n \ttm_file=\"sparc/sparc.h ${tm_file}\"\n \t# needed to unconfuse gdb\n@@ -2299,51 +1856,15 @@ sparc64-*-openbsd*)\n \tgas=yes gnu_ld=yes\n \twith_cpu=ultrasparc\n \t;;\n-sparc-*-bsd*)\n-\ttm_file=\"${tm_file} sparc/bsd.h\"\n-\t;;\n-sparc-*-chorusos*)\n-\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/elf.h chorus.h\"\n-\ttmake_file=\"sparc/t-chorus-elf sparc/t-crtfm\"\n-\textra_parts=\"crti.o crtn.o crtbegin.o crtend.o\"\n-\tcase x${enable_threads} in\n-\t  xyes | xpthreads | xposix)\n-\t\tthread_file='posix'\n-\t\t;;\n-\tesac\n-\t;;\n sparc-*-elf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/elf.h\"\n \ttmake_file=\"sparc/t-elf sparc/t-crtfm\"\n \textra_parts=\"crti.o crtn.o crtbegin.o crtend.o\"\n \t;;\n-sparc-*-linux*aout*)\t\t# SPARC's running GNU/Linux, a.out\n-\ttm_file=\"aoutos.h sparc/sparc.h sparc/aout.h sparc/linux-aout.h\"\n-\tgnu_ld=yes\n-\t;;\n-sparc-*-linux*libc1*)\t# SPARC's running GNU/Linux, libc5\n-\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/linux.h\"\n-\ttmake_file=\"t-slibgcc-elf-ver t-linux t-linux-gnulibc1 sparc/t-crtfm\"\n-\textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n-\tgnu_ld=yes\n-\t;;\n sparc-*-linux*)\t\t# SPARC's running GNU/Linux, libc6\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/linux.h\"\n \ttmake_file=\"t-slibgcc-elf-ver t-linux sparc/t-crtfm\"\n \t;;\n-sparc-*-lynxos*)\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_file=\"${tm_file} lynx.h sparc/aout.h sparc/lynx.h\"\n-\telse\n-\t\ttm_file=\"${tm_file} lynx-ng.h sparc/aout.h sparc/lynx-ng.h\"\n-\tfi\n-\ttmake_file=sparc/t-sunos41\n-\t;;\n-sparc-*-rtemsaout*)\t# would otherwise be caught by sparc-*-rtems*\n-\techo \"*** Configuration $machine not supported\" 1>&2\n-\texit 1\n-\t;;\n sparc-*-rtems*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/elf.h sparc/rtemself.h rtems.h\"\n \ttmake_file=\"sparc/t-elf sparc/t-crtfm t-rtems\"\n@@ -2382,18 +1903,6 @@ sparc64-*-solaris2* | sparcv9-*-solaris2*)\n \tfi\n \tneed_64bit_hwint=yes\n \t;;\n-sparc-hal-solaris2*)\n-        tm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/hal.h\"\n-        tmake_file=\"sparc/t-halos sparc/t-sol2 sparc/t-crtfm\"\n-\tif test x$gnu_ld = xyes; then\n-\t\ttm_file=\"${tm_file} sparc/sol2-gld.h\"\n-\t\ttmake_file=\"$tmake_file t-slibgcc-elf-ver\"\n-\telse\n-\t\ttmake_file=\"$tmake_file t-slibgcc-sld\"\n-\tfi\n-        extra_parts=\"crt1.o crti.o crtn.o gmon.o crtbegin.o crtend.o\"\n-\tthread_file='solaris'\n-        ;;\n sparc-*-solaris2*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h\"\n \tif test x$gnu_ld = xyes; then\n@@ -2438,48 +1947,20 @@ sparc-*-solaris2*)\n \t    fi\n \tfi\n \t;;\n-sparc-*-sunos4.0*)\n-\ttm_file=\"${tm_file} sparc/aout.h sparc/sunos4.h\"\n-\tuse_collect2=yes\n-\t;;\n-sparc-*-sunos4*)\n-\ttm_file=\"${tm_file} sparc/aout.h sparc/sunos4.h\"\n-\ttmake_file=sparc/t-sunos41\n-\tuse_collect2=yes\n-\tif test x$gas = xyes; then\n-\t\ttm_file=\"${tm_file} sparc/sun4gas.h\"\n-\tfi\n-\t;;\n-sparc-*-sunos3*)\n-\ttm_file=\"${tm_file} sparc/aout.h sparc/sun4o3.h\"\n-\tuse_collect2=yes\n-\t;;\n sparc-*-sysv4*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h\"\n \ttmake_file=t-svr4\n \textra_parts=\"crtbegin.o crtend.o\"\n \t;;\n-sparclet-*-aout*)\n-\ttm_file=\"${tm_file} aoutos.h sparc/aout.h sparc/splet.h libgloss.h\"\n-\ttmake_file=sparc/t-splet\n-\t;;\n sparclite-*-coff*)\n \ttm_file=\"${tm_file} gofast.h sparc/lite.h svr3.h sparc/litecoff.h dbxcoff.h libgloss.h\"\n \ttmake_file=sparc/t-sparclite\n \t;;\n-sparclite-*-aout*)\n-\ttm_file=\"${tm_file} gofast.h sparc/aout.h sparc/lite.h aoutos.h libgloss.h\"\n-\ttmake_file=sparc/t-sparclite\n-\t;;\n sparclite-*-elf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/elf.h gofast.h sparc/liteelf.h\"\n \ttmake_file=\"sparc/t-sparclite sparc/t-crtfm\"\n         extra_parts=\"crtbegin.o crtend.o\"\n \t;;\n-sparc86x-*-aout*)\n-\ttm_file=\"${tm_file} gofast.h sparc/aout.h sparc/sp86x-aout.h aoutos.h libgloss.h\"\n-\ttmake_file=sparc/t-sp86x\n-\t;;\n sparc86x-*-elf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sol2.h sparc/sol2.h sparc/elf.h gofast.h sparc/sp86x-elf.h\"\n \ttmake_file=\"sparc/t-sp86x sparc/t-crtfm\"\n@@ -2520,13 +2001,6 @@ strongarm-*-elf*)\n \tmd_file=arm/arm.md\n \textra_modes=arm/arm-modes.def\n \t;;\n-strongarm-*-coff*)\n-\ttm_file=\"arm/semi.h arm/aout.h arm/coff.h arm/strongarm-coff.h arm/arm.h\"\n-\ttmake_file=arm/t-strongarm-coff\n-\tout_file=arm/arm.c\n-\tmd_file=arm/arm.md\n-\textra_modes=arm/arm-modes.def\n-\t;;\n strongarm-*-pe)\n \ttm_file=\"arm/semi.h arm/aout.h arm/coff.h arm/strongarm-coff.h arm/arm.h arm/pe.h arm/strongarm-pe.h\"\n \ttmake_file=arm/t-strongarm-pe\n@@ -2535,23 +2009,6 @@ strongarm-*-pe)\n \textra_modes=arm/arm-modes.def\n \textra_objs=pe.o\n \t;;\n-thumb*-*-*)\n-\t{ echo \"config.gcc: error:\n-*** The Thumb targets have been deprecated.  The equivalent\n-*** ARM based toolchain can now generate Thumb instructions\n-*** when the -mthumb switch is given to the compiler.\" 1>&2; exit 1; }\n-\t;;\n-v850-*-rtems*)\n-\ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file} v850/v850.h v850/rtems.h rtems.h\"\n-\ttmake_file=\"v850/t-v850 t-rtems\"\n-\tif test x$stabs = xyes\n-\tthen\n-\t\ttm_file=\"${tm_file} dbx.h\"\n-\tfi\n-\tuse_collect2=no\n-\tc_target_objs=\"v850-c.o\"\n-\tcxx_target_objs=\"v850-c.o\"\n-\t;;\n v850e-*-*)\n \ttarget_cpu_default=\"TARGET_CPU_v850e\"\n \ttm_file=\"dbxelf.h elfos.h svr4.h v850/v850.h\""}, {"sha": "3f1580d05c65205e4da900a9b471504e9efa3e02", "filename": "gcc/config/alpha/alpha-interix.h", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Falpha%2Falpha-interix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Falpha%2Falpha-interix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-interix.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,150 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for DEC Alpha\n-   running Windows/NT.\n-   Copyright (C) 1995, 1996, 1999, 2000, 2002 Free Software Foundation, Inc.\n-\n-   Donn Terry, Softway Systems, Inc.\n-   From code\n-       Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* cpp handles __STDC__ */\n-/* The three \"Alpha\" defines on the first such line are from the CLAXP spec */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\t\t\\\n-    do {\t\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__INTERIX\");\t\t\t\t\\\n-\tbuiltin_define (\"__OPENNT\");\t\t\t\t\\\n-\tbuiltin_define (\"__Alpha_AXP\");\t\t\t\t\\\n-\tbuiltin_define (\"_M_ALPHA\");\t\t\t\t\\\n-\tbuiltin_define (\"_ALPHA_\");\t\t\t\t\\\n-\tbuiltin_define (\"__stdcall=\");\t\t\t\t\\\n-\tbuiltin_define (\"__cdecl=\");\t\t\t\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\t\t\\\n-\tbuiltin_assert (\"system=interix\");\t\t\t\\\n-    } while (0)\n-\n-#undef CPP_SUBTARGET_SPEC\n-#define CPP_SUBTARGET_SPEC \"\\\n--remap \\\n-%{posix:-D_POSIX_SOURCE} \\\n--isystem %$INTERIX_ROOT/usr/include\"\n-\n-#undef TARGET_VERSION\n-#define TARGET_VERSION fprintf (stderr, \" (alpha Interix)\");\n-\n-/* alpha.h sets this, but it doesn't apply to us */\n-#undef OBJECT_FORMAT_ECOFF\n-#undef OBJECT_FORMAT_COFF\n-\n-/* LINK_SPEC */\n-\n-/* MD_STARTFILE_PREFIX */\n-\n-/* ASM_OUTPUT_LOOP_ALIGN; ASM_OUTPUT_ALIGN_CODE */\n-\n-/* Codegen macro overrides for NT internal conventions */\n-\n-/* the below are ecoff specific... we don't need them, so\n-   undef them (they'll get a default later) */\n-\n-#undef PUT_SDB_BLOCK_START\n-#undef PUT_SDB_BLOCK_END\n-\n-/* The following are needed for C++, but also needed for profiling */\n-\n-/* Support const sections and the ctors and dtors sections for g++.  */\n-\n-#define READONLY_DATA_SECTION_ASM_OP\t\"\\t.rdata\"\n-\n-/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n-\n-   Note that we want to give these sections the SHF_WRITE attribute\n-   because these sections will actually contain data (i.e. tables of\n-   addresses of functions in the current root executable or shared library\n-   file) and, in the case of a shared library, the relocatable addresses\n-   will have to be properly resolved/relocated (and then written into) by\n-   the dynamic linker when it actually attaches the given shared library\n-   to the executing process.  (Note that on SVR4, you may wish to use the\n-   `-z text' option to the ELF linker, when building a shared library, as\n-   an additional check that you are doing everything right.  But if you do\n-   use the `-z text' option when building a shared library, you will get\n-   errors unless the .ctors and .dtors sections are marked as writable\n-   via the SHF_WRITE attribute.)  */\n-\n-#define CTORS_SECTION_ASM_OP\t\"\\t.ctors\"\n-#define DTORS_SECTION_ASM_OP\t\"\\t.dtors\"\n-\n-/* The linker will take care of this, and having them causes problems with\n-   ld -r (specifically -rU).  */\n-#define CTOR_LISTS_DEFINED_EXTERNALLY 1\n-\n-#define SET_ASM_OP\t\"\\t.set\\t\"\n-/* Output a definition (implements alias) */\n-#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-    fprintf ((FILE), \"\\t\");\t\t\t\t\t\t\\\n-    assemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-    fprintf (FILE, \"=\");\t\t\t\t\t\t\\\n-    assemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* We use the defaults, so undef the null definitions */\n-#undef PUT_SDB_FUNCTION_START\n-#undef PUT_SDB_FUNCTION_END\n-#undef PUT_SDB_EPILOGUE_END\n-\n-#define HOST_PTR_PRINTF \"%p\"\n-#define HOST_PTR_AS_INT unsigned long\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-#define PCC_BITFIELD_TYPE_TEST TYPE_NATIVE(rec)\n-#define GROUP_BITFIELDS_BY_ALIGN TYPE_NATIVE(rec)\n-\n-/* DWARF2 Unwinding doesn't work with exception handling yet.  */\n-#undef DWARF2_UNWIND_INFO\n-#define DWARF2_UNWIND_INFO 0\n-\n-/* Don't assume anything about the header files.  */\n-#define NO_IMPLICIT_EXTERN_C\n-\n-/* The definition of this macro implies that there are cases where\n-   a scalar value cannot be returned in registers.\n-\n-   On NT (according to the spec) anything except strings/array that fits\n-   in 64 bits is returned in the registers (this appears to differ from\n-   the rest of the Alpha family).  */\n-\n-#undef RETURN_IN_MEMORY\n-#define RETURN_IN_MEMORY(TYPE) \\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE || int_size_in_bytes(TYPE) > 8)\n-\n-#define ASM_LOAD_ADDR(loc, reg)   \"     lda \" #reg \",\" #loc \"\\n\" \n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  alpha_write_verstamp (FILE);\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.set noreorder\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\t.set volatile\\n\");                          \\\n-  fprintf (FILE, \"\\t.set noat\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\t.globl\\t__fltused\\n\");\t\t\t\\\n-  ASM_OUTPUT_SOURCE_FILENAME (FILE, main_input_filename);\t\\\n-}"}, {"sha": "8d9df0b8ebf9e4eff59a0babf326e18007051d06", "filename": "gcc/config/alpha/alpha32.h", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Falpha%2Falpha32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Falpha%2Falpha32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha32.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,85 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for DEC Alpha\n-   running Windows/NT.\n-   Copyright (C) 1995, 1996, 1998, 1999 Free Software Foundation, Inc.\n-\n-   Derived from code\n-      Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n-\n-   Donn Terry, Softway Systems, Inc.\n-\n-   This file contains the code-generation stuff common to the 32-bit\n-   versions of the DEC/Compaq Alpha architecture.  It is shared by\n-   Interix and NT/Win32 ports.   It should not contain compile-time\n-   or run-time dependent environment values (such as compiler options\n-   or anything containing a file or pathname.)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#undef TARGET_ABI_WINDOWS_NT\n-#define TARGET_ABI_WINDOWS_NT 1\n-\n-/* WinNT (and thus Interix) use unsigned int */\n-#define SIZE_TYPE \"unsigned int\"\n-\n-/* Pointer is 32 bits but the hardware has 64-bit addresses, sign extended.  */\n-#undef POINTER_SIZE\n-#define POINTER_SIZE 32\n-#define POINTERS_EXTEND_UNSIGNED 0\n-\n-/* We don't change Pmode to the \"obvious\" SI mode... the above appears\n-   to affect the in-memory size; we want the registers to stay DImode\n-   to match the md file */\n-\n-/* \"long\" is 32 bits.  */\n-#undef LONG_TYPE_SIZE\n-#define LONG_TYPE_SIZE 32\n-\n-\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.\n-\n-   The trampoline should set the static chain pointer to value placed\n-   into the trampoline and should branch to the specified routine.  */\n-\n-#undef TRAMPOLINE_TEMPLATE\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tbr $27,$LTRAMPP\\n\");\t\t\\\n-  fprintf (FILE, \"$LTRAMPP:\\n\\tldl $1,12($27)\\n\");\t\\\n-  fprintf (FILE, \"\\tldl $27,16($27)\\n\");\t\t\\\n-  fprintf (FILE, \"\\tjmp $31,($27),0\\n\");\t\t\\\n-  fprintf (FILE, \"\\t.long 0,0\\n\");\t\t\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#undef TRAMPOLINE_SIZE\n-#define TRAMPOLINE_SIZE    24\n-\n-/* The alignment of a trampoline, in bits.  */\n-\n-#undef TRAMPOLINE_ALIGNMENT\n-#define TRAMPOLINE_ALIGNMENT  32\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#undef INITIALIZE_TRAMPOLINE\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n-  alpha_initialize_trampoline (TRAMP, FNADDR, CXT, 20, 16, 12)"}, {"sha": "3d570c65ba0cbe16dd296abcc6bf7ae837cf7f33", "filename": "gcc/config/alpha/t-interix", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Falpha%2Ft-interix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Falpha%2Ft-interix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Ft-interix?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,7 +0,0 @@\n-# t-interix\n-\n-# System headers will track gcc's needs.\n-USER_H=\n-\n-LIB1ASMSRC = alpha/lib1funcs.asm\n-LIB1ASMFUNCS = _divqu _divq _divlu _divl _remqu _remq _remlu _reml"}, {"sha": "f7e2f070397d2337f08891c3df3ece366aa25e25", "filename": "gcc/config/arm/conix-elf.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Farm%2Fconix-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Farm%2Fconix-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconix-elf.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,46 +0,0 @@\n-/* Definitions of target machine for GNU compiler,\n-   for ARM with ConiX OS.\n-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n-   Contributed by Philip Blundell <pb@futuretv.com>\n-   \n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 2, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330,\n-   `Boston, MA 02111-1307, USA.  */\n-\n-/* elfos.h should have already been included.  Now just override\n-   any conflicting definitions and add any extras.  */\n-\n-/* Run-time Target Specification.  */\n-#undef  TARGET_VERSION\n-#define TARGET_VERSION\tfputs (\" (ARM/ELF ConiX)\", stderr);\n-\n-/* Default to using APCS-32 and software floating point.  */\n-#undef  TARGET_DEFAULT\n-#define TARGET_DEFAULT\t(ARM_FLAG_SOFT_FLOAT | ARM_FLAG_APCS_32)\n-\n-#ifndef CPP_APCS_PC_DEFAULT_SPEC\n-#define CPP_APCS_PC_DEFAULT_SPEC\t\"-D__APCS_32__\"\n-#endif\n-     \n-#ifndef SUBTARGET_CPU_DEFAULT\n-#define SUBTARGET_CPU_DEFAULT \t\tTARGET_CPU_arm7tdmi\n-#endif\n-     \n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tbuiltin_define (\"__CONIX__\");\t\t\\\n-\tbuiltin_define (\"__ELF__\");\t\t\\\n-    } while (0)"}, {"sha": "2ce20e4fb74472306d869f094300bfd380fa10e4", "filename": "gcc/config/arm/t-arm-aout", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Farm%2Ft-arm-aout", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Farm%2Ft-arm-aout", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm-aout?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,29 +0,0 @@\n-LIB1ASMSRC = arm/lib1funcs.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX  _interwork_call_via_rX\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#ifndef __ARMEB__' >> fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n-\techo '#endif' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#ifndef __ARMEB__' > dp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#endif' >> dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-# MULTILIB_OPTIONS  = mhard-float/msoft-float mapcs-32/mapcs-26 mno-thumb-interwork/mthumb-interwork arm/thumb\n-# MULTILIB_DIRNAMES = le be fpu soft 32bit 26bit normal interwork arm thumb\n-# MULTILIB_MATCHES  = \n-# MULTILIB_EXCEPTIONS = *mapcs-26/*mthumb-interwork* *mpacs-26/*mthumb*\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib"}, {"sha": "0a66360cb277d0c0489629a1c62800f5ee653e8c", "filename": "gcc/config/arm/t-strongarm-coff", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Farm%2Ft-strongarm-coff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Farm%2Ft-strongarm-coff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-strongarm-coff?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,34 +0,0 @@\n-LIB1ASMSRC = arm/lib1funcs.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#ifndef __ARMEB__' >> fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n-\techo '#endif' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#ifndef __ARMEB__' > dp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#endif' >> dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-MULTILIB_OPTIONS  = mlittle-endian/mbig-endian mhard-float/msoft-float\n-MULTILIB_DIRNAMES = le be fpu soft\n-MULTILIB_MATCHES  = \n-EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-# Currently there is a bug somwehere in GCC's alias analysis\n-# or scheduling code that is breaking _fpmul_parts in fp-bit.c.\n-# Disabling function inlining is a workaround for this problem.\n-TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline"}, {"sha": "112cc69916fee7baebf810fc9ecc73c4b6122a28", "filename": "gcc/config/arm/unknown-elf-oabi.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Farm%2Funknown-elf-oabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Farm%2Funknown-elf-oabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funknown-elf-oabi.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,29 +0,0 @@\n-/* Definitions for non-Linux based ARM systems using ELF old abi\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n-   Contributed by Catherine Moore <clm@cygnus.com>\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 2, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n-\n-/* Run-time Target Specification.  */\n-#undef  TARGET_VERSION\n-#define TARGET_VERSION\tfputs (\" (ARM/ELF non-Linux old abi)\", stderr);\n-\n-#undef  ASM_SPEC\n-#define ASM_SPEC \"-moabi %{mbig-endian:-EB} %{mcpu=*:-mcpu=%*} %{march=*:-march=%*} \\\n- %{mapcs-*:-mapcs-%*} %{mthumb-interwork:-mthumb-interwork}\"\n-"}, {"sha": "93f58c93f12cdba74214f11bf44acbfcf1537c97", "filename": "gcc/config/i386/win32.h", "status": "removed", "additions": 0, "deletions": 173, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fi386%2Fwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fi386%2Fwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwin32.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,173 +0,0 @@\n-/* Operating system specific defines to be used when targeting GCC for\n-   hosting on Windows NT 3.x, using a Unix style C library and tools,\n-   as distinct from winnt.h, which is used to build GCC for use with a\n-   windows style library and tool set and uses the Microsoft tools.\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */\n-#define HANDLE_PRAGMA_PACK_PUSH_POP 1\n-\n-#define DBX_DEBUGGING_INFO 1\n-#define SDB_DEBUGGING_INFO 1\n-#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n-\n-#include \"i386/unix.h\"\n-#include \"i386/bsd.h\"\n-#include \"i386/gas.h\"\n-#include \"dbxcoff.h\"\n-\n-/* Augment TARGET_SWITCHES with the cygwin/win32 options.  */\n-#define MASK_WIN32 0x40000000 /* Use -lming32 interface */\n-#define MASK_CYGWIN  0x20000000 /* Use -lcygwin interface */\n-#define MASK_WINDOWS 0x10000000 /* Use windows interface */\n-#define MASK_DLL     0x08000000 /* Use dll interface    */\n-#define MASK_NOP_FUN_DLLIMPORT 0x20000 /* Ignore dllimport for functions */\n-\n-#define TARGET_WIN32             (target_flags & MASK_WIN32)\n-#define TARGET_CYGWIN            (target_flags & MASK_CYGWIN)\n-#define TARGET_WINDOWS           (target_flags & MASK_WINDOWS)\n-#define TARGET_DLL               (target_flags & MASK_DLL)\n-#define TARGET_NOP_FUN_DLLIMPORT (target_flags & MASK_NOP_FUN_DLLIMPORT)\n-\n-#undef  SUBTARGET_SWITCHES\n-#define SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n-    { \"win32\",\t\t\tMASK_WIN32,\t\t\t\t\\\n-      N_(\"Use Mingw32 interface\") },\t\t\t\t\t\\\n-    { \"cygwin\",\t\t\tMASK_CYGWIN,\t\t\t\t\\\n-      N_(\"Use Cygwin interface\")  },\t\t\t\t\t\\\n-    { \"windows\",\t\tMASK_WINDOWS,\t\t\t\t\\\n-      N_(\"Use bare Windows interface\") },\t\t\t\t\\\n-    { \"dll\",\t\t\tMASK_DLL,\t\t\t\t\\\n-      N_(\"Generate code for a DLL\") },\t\t\t\t\t\\\n-    { \"nop-fun-dllimport\",\tMASK_NOP_FUN_DLLIMPORT,\t\t\t\\\n-      N_(\"Ignore dllimport for functions\") }, \t\t\t\t\\\n-    { \"no-nop-fun-dllimport\",\tMASK_NOP_FUN_DLLIMPORT, \"\" },\n-\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-\tbuiltin_define (\"_WIN32\");\t\t\t\t\t\\\n-\tbuiltin_define_std (\"WINNT\");\t\t\t\t\t\\\n-\tbuiltin_define (\"_X86_\");\t\t\t\t\t\\\n-\tbuiltin_define (\"__stdcall=__attribute__((__stdcall__))\");\t\\\n-\tbuiltin_define (\"__cdecl=__attribute__((__cdecl__))\");\t\t\\\n-\tbuiltin_assert (\"system=winnt\");\t\t\t\t\\\n-\tif (TARGET_CYGWIN)\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    builtin_define (\"__CYGWIN32__\");\t\t\t\t\\\n-\t    builtin_define (\"__CYGWIN__\");\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  builtin_define (\"__MINGW32__\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#undef STARTFILE_SPEC\n-\n-#define STARTFILE_SPEC \"%{mdll:dllcrt0%O%s} %{!mdll: %{!mcygwin:mcrt0%O%s} \\\n-                        %{mcygwin:crt0%O%s} %{pg:gcrt0%O%s}}\"\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"%{posix:-D_POSIX_SOURCE} \\\n-  %{!mcygwin:-iwithprefixbefore include/mingw32}\"\n-\n-/* We have to dynamic link to get to the system DLLs.  All of libc, libm and\n-   the Unix stuff is in cygwin.dll.  The import library is called\n-   'libcygwin.a'.  For Windows applications, include more libraries, but\n-   always include kernel32.  We'd like to specific subsystem windows to\n-   ld, but that doesn't work just yet.  */\n-\n-#undef LIB_SPEC\n-#define LIB_SPEC \"%{pg:-lgmon}\t\t\t\t\t\t\\\n-\t\t  %{!mcygwin:-lmingw32 -lmoldname -lmsvcrt -lcrtdll}\t\\\n-                  %{mcygwin:-lcygwin} %{mwindows:-luser32 -lgdi32 -lcomdlg32} \\\n-                  -lkernel32 -ladvapi32 -lshell32\"\n-\n-#define LINK_SPEC \"%{mwindows:--subsystem windows} \\\n-  %{mdll:--dll -e _DllMainCRTStartup@12}\"\n-\n-#define SIZE_TYPE \"unsigned int\"\n-#define PTRDIFF_TYPE \"int\"\n-#define WCHAR_TYPE_SIZE 16\n-#define WCHAR_TYPE \"short unsigned int\"\n-/* Currently we do not have the atexit() function,\n-   so take that from libgcc2.c */\n-\n-#define NEED_ATEXIT 1\n-\n-#undef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO  i386_pe_encode_section_info\n-#undef  TARGET_STRIP_NAME_ENCODING\n-#define TARGET_STRIP_NAME_ENCODING  i386_pe_strip_name_encoding_full\n-\n-/* Emit code to check the stack when allocating more that 4000\n-   bytes in one go.  */\n-\n-#define CHECK_STACK_LIMIT 4000\n-\n-/* By default, target has a 80387, uses IEEE compatible arithmetic,\n-   and returns float values in the 387 and needs stack probes */\n-#undef TARGET_SUBTARGET_DEFAULT\n-\n-#define TARGET_SUBTARGET_DEFAULT \\\n-   (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_STACK_PROBE) \n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#undef ASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-    if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n-\n-/* Define this macro if in some cases global symbols from one translation\n-   unit may not be bound to undefined symbols in another translation unit\n-   without user intervention.  For instance, under Microsoft Windows\n-   symbols must be explicitly imported from shared libraries (DLLs).  */\n-#define MULTIPLE_SYMBOL_SPACES\n-\n-extern void i386_pe_unique_section PARAMS ((tree, int));\n-#define TARGET_ASM_UNIQUE_SECTION i386_pe_unique_section\n-\n-#define SUPPORTS_ONE_ONLY 1\n-\n-/* Switch into a generic section.  */\n-#define TARGET_ASM_NAMED_SECTION  i386_pe_asm_named_section\n-\n-/* Select attributes for named sections.  */\n-#define TARGET_SECTION_TYPE_FLAGS  i386_pe_section_type_flags\n-\n-#undef ASM_COMMENT_START\n-#define ASM_COMMENT_START \" #\"\n-\n-/* Don't assume anything about the header files.  */\n-#define NO_IMPLICIT_EXTERN_C\n-\n-#define SUBTARGET_PROLOGUE\t\t\t\t\t\t\\\n-  if (current_function_profile\t\t\t\t\t\t\\\n-      && MAIN_NAME_P (DECL_NAME (current_function_decl))\t\t\\\n-     {\t\t\t\t\t\t\t\t\t\\\n-      rtx xops[1];\t\t\t\t\t\t\t\\\n-      xops[0] = gen_rtx_MEM (FUNCTION_MODE,\t\t\t\t\\\n-\t\t\t gen_rtx (SYMBOL_REF, Pmode, \"_monstartup\"));\t\\\n-      emit_call_insn (gen_rtx (CALL, VOIDmode, xops[0], const0_rtx));\t\\\n-     }"}, {"sha": "5b3fe4e02b342a1ed4d033a86ec30d098bddf61e", "filename": "gcc/config/m68k/3b1.h", "status": "removed", "additions": 0, "deletions": 470, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2F3b1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2F3b1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2F3b1.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,470 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   AT&T UNIX PC version (pc7300, 3b1)\n-   Copyright (C) 1987, 1993, 1996, 1999, 2000 Free Software Foundation, Inc.\n-   Contributed by Alex Crain (alex@umbc3.umd.edu).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define SGS_SWITCH_TABLES\t/* Different switch table handling */\n-\n-#include \"m68k/hp320.h\"\n-\n-/* See m68k.h.  0 means 680[01]0 with no 68881.  */\n-\n-#undef TARGET_DEFAULT\n-#define\tTARGET_DEFAULT 0\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-/* -m68020 requires special flags to the assembler.  */\n-\n-#undef ASM_SPEC\n-#define ASM_SPEC \"%{m68020:-68020}%{!m68020:-68010} %{m68881:-68881}\"\n-\n-/* we use /lib/libp/lib*  when profiling */\n-\n-#undef LIB_SPEC\n-#define LIB_SPEC \"%{!shlib:%{p:-L/lib/libp} %{pg:-L/lib/libp} -lc}\"\n-\n-/* shared libraries need to use crt0s.o  */\n-\n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC \\\n-  \"%{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n-   %{shlib:crt0s.o%s shlib.ifile%s} \"\n-\n-/* Make output for SDB.  */\n-\n-#define SDB_DEBUGGING_INFO 1\n-\n-/* The .file command should always begin the output.  */\n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE) \\\n-output_file_directive ((FILE), main_input_filename)\n-\n-/* Define __HAVE_68881__ in preprocessor if -m68881 is specified.\n-   This will control the use of inline 68881 insns in certain macros.  */\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"%{m68881:-D__HAVE_68881__}\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-/* ihnp4!lmayk!lgm@eddie.mit.edu says mc68000 and m68k should not be here.  */\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dmc68k -Dunix -Dunixpc -D__motorola__ -Asystem=unix  -Asystem=svr3 -Acpu=m68k -Amachine=m68k\"\n-\n-#undef REGISTER_NAMES\n-#define REGISTER_NAMES \\\n-{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n- \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%fp\", \"%sp\",\t\\\n- \"%f0\", \"%f1\", \"%f2\", \"%f3\", \"%f4\", \"%f5\", \"%f6\", \"%f7\"}\n-\n-/* Specify how to pad function arguments.\n-   Value should be `upward', `downward' or `none'.\n-   Same as the default, except no padding for large or variable-size args.  */\n-\n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n-  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n-    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n-       && int_size_in_bytes (TYPE) < PARM_BOUNDARY / BITS_PER_UNIT)\t\\\n-    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n-   ? downward : none)\n-\n-/* The 3b1 does not have `atexit'.  */\n-\n-#define NEED_ATEXIT\n-\n-/* Override parts of m68k.h to fit the SGS-3b1 assembler.  */\n-\n-#undef TARGET_VERSION\n-#undef ASM_OUTPUT_ALIGN\n-#undef ASM_OUTPUT_SOURCE_FILENAME\n-#undef ASM_OUTPUT_SOURCE_LINE\n-#undef PRINT_OPERAND_ADDRESS\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#undef FUNCTION_PROFILER\n-#undef ASM_OUTPUT_ADDR_VEC_ELT\n-#undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#undef ASM_OUTPUT_OPCODE\n-#undef ASM_OUTPUT_LOCAL\n-#undef USER_LABEL_PREFIX\n-#undef ASM_OUTPUT_ASCII\n-\n-#define TARGET_VERSION fprintf (stderr, \" (68k, SGS/AT&T unixpc syntax)\");\n-\n-#define ASM_PN_FORMAT \"%s_%%%lu\"\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-do {\t\t\t\t\t\\\n-  if ((LOG) == 1)\t\t\t\\\n-    fprintf (FILE, \"\\teven\\n\");\t\\\n-  else if ((LOG) != 0)\t\t\t\\\n-    abort ();\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter by SIZE bytes.  */\n-\n-#undef ASM_OUTPUT_SKIP\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\tspace %d\\n\", (int)(SIZE))\n-\n-/* Can't use ASM_OUTPUT_SKIP in text section; it doesn't leave 0s.  */\n-\n-#define ASM_NO_SKIP_IN_TEXT 1\n-\n-/* The beginnings of sdb support...  */\n-\n-#define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME) \\\n-  do {\tfprintf (FILE, \"\\tfile\\t\");\t\t\\\n-\toutput_quoted_string (FILE, FILENAME);\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\\\n-  } while (0)\n-\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\t\\\n-  fprintf (FILE, \"\\tln\\t%d\\n\",\t\t\t\\\n-\t   (sdb_begin_function_line\t\t\\\n-\t    ? (LINENO) - sdb_begin_function_line : 1))\n-\n-/* Yet another null terminated string format.  */\n-\n-#define ASM_OUTPUT_ASCII(FILE,PTR,LEN) \\\n-  do { register size_t sp = 0, lp = 0, limit = (LEN); \\\n-    fprintf ((FILE), \"\\tbyte\\t\"); \\\n-  loop: \\\n-    if ((PTR)[sp] > ' ' && ! ((PTR)[sp] & 0x80) && (PTR)[sp] != '\\\\') \\\n-      { lp += 3; \\\n-\tfprintf ((FILE), \"'%c\", (PTR)[sp]); } \\\n-    else \\\n-      { lp += 5; \\\n-\tfprintf ((FILE), \"0x%x\", (PTR)[sp]); } \\\n-    if (++sp < limit) \\\n-      {\tif (lp > 60) \\\n-\t  { lp = 0; \\\n-\t    fprintf ((FILE), \"\\n%s\", ASCII_DATA_ASM_OP); }\t\\\n-\telse \\\n-\t  putc (',', (FILE)); \\\n-\tgoto loop; } \\\n-    putc ('\\n', (FILE)); } while (0)\n-\n-/* Note that in the case of the movhi which fetches an element of\n-   an ADDR_DIFF_VEC the offset output is too large by 2.\n-   This is because the 3b1 assembler refuses to subtract 2.\n-   ASM_OUTPUT_CASE_LABEL, below, compensates for this.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n-  register rtx addr = ADDR;\t\t\t\t\t\t\\\n-  rtx offset;\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case REG:\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PRE_DEC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case POST_INC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PLUS:\t\t\t\t\t\t\t\t\\\n-      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n-      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n-      offset = 0;\t\t\t\t\t\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n-\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n-\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n-/*  for OLD_INDEXING\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (addr) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      reg2 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t      addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      reg2 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t      addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-  */\t\t\t\t\t\t\t\t\t\\\n-      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n-      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n-\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n-\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n-\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n-      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n-\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n-      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n-        { int scale = 1;\t\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n-\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n-\t    fprintf (FILE, \"LD%%%d(%%pc,%s.w\",\t\t\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"LD%%%d(%%pc,%s.l\",\t\t\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n-\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n-\t  fprintf (FILE, \")\");\t\t\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n-        { fprintf (FILE, \"LD%%%d(%%pc,%s.l\",\t\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   reg_names[REGNO (breg)]);\t\t\t\t\\\n-\t  putc (')', FILE);\t\t\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n-\t{ int scale = 1;\t\t\t\t\t\t\\\n-\t  if (breg == 0)\t\t\t\t\t\t\\\n-\t    abort ();\t\t\t\t\t\t\t\\\n-\t  if (addr != 0)\t\t\t\t\t\t\\\n-\t    output_addr_const (FILE, addr);\t\t\t\t\\\n-\t  fprintf (FILE, \"(%s\", reg_names[REGNO (breg)]);\t\t\\\n-\t  if (ireg != 0)\t\t\t\t\t        \\\n-\t    putc (',', FILE);\t\t\t\t\t\t\\\n-\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n-\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n-\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n-\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n-\t  else if (ireg != 0)\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n-\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n-\t  putc (')', FILE);\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n-\t{ fprintf (FILE, \"LD%%%d(%%pc,%s.w)\",\t\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n-\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n-\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n-\tfprintf (FILE, \"%d\", INTVAL (addr));\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        output_addr_const (FILE, addr);\t\t\t\t\t\\\n-    }}\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n-  sprintf ((LABEL), \"%s%%%ld\", (PREFIX), (long)(NUM))\n-\n-/* Must put address in  %a0 , not  %d0 . -- LGM, 7/15/88 */\n-#define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n-    fprintf (FILE, \"\\tmov.l &LP%%%d,%%a0\\n\\tjsr mcount\\n\", (LABEL_NO))\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\\\n-    fprintf (FILE, \"\\tlong L%%%d\\n\", (VALUE))\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n-    fprintf (FILE, \"\\tshort L%%%d-L%%%d\\n\", (VALUE), (REL))\n-\n-/* ihnp4!lmayk!lgm says that `short 0' triggers assembler bug;\n-   `short L%nn-L%nn' supposedly works.  */\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\t\\\n-  if (! RTX_INTEGRATED_P (TABLE))\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tswbeg &%d\\n%s%%%d:\\n\",\t\t\t\t\\\n-\t     XVECLEN (PATTERN (TABLE), 1), (PREFIX), (NUM));\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tswbeg &%d\\n%s%%%d:\\n\\tshort %s%%%d-%s%%%d\\n\",\t\\\n-\t     XVECLEN (PATTERN (TABLE), 1) + 1, (PREFIX), (NUM),\t\t\\\n-\t     (PREFIX), (NUM), (PREFIX), (NUM))\n-\n-/* At end of a switch table, define LDnnn iff the symbol LInnn was defined.\n-   Some SGS assemblers have a bug such that \"Lnnn-LInnn-2.b(pc,d0.l*2)\"\n-   fails to assemble.  Luckily \"LDnnn(pc,d0.l*2)\" produces the results\n-   we want.  This difference can be accommodated by making the assembler\n-   define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n-   string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n-   macro.  */\n-\n-#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\t\t\\\n-{ if (switch_table_difference_label_flag)\t\t\t\t\\\n-    fprintf (FILE, \"\\tset LD%%%d,L%%%d-LI%%%d\\n\", (NUM), (NUM), (NUM));\t\\\n-  switch_table_difference_label_flag = 0; }\n-\n-int switch_table_difference_label_flag;\n-\n-#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n-{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n-    { ++(PTR);\t\t\t\t\t\t\\\n-      while (*(PTR) != ' ')\t\t\t\t\\\n-\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n-      fprintf ((FILE), \".w\"); }\t\t\t\t\\\n-  else if ((PTR)[0] == 's')\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (!strncmp ((PTR), \"swap\", 4))\t\t\t\\\n-\t{ fprintf ((FILE), \"swap.w\"); (PTR) += 4; }\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if ((PTR)[0] == 'f')\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (!strncmp ((PTR), \"fmove\", 5))\t\t\t\\\n-\t{ fprintf ((FILE), \"fmov\"); (PTR) += 5; }\t\\\n-      else if (!strncmp ((PTR), \"fbne\", 4))\t\t\\\n-\t{ fprintf ((FILE), \"fbneq\"); (PTR) += 4; }\t\\\n-    }\t\t\t\t\t\t\t\\\n-/* MOVE, MOVEA, MOVEQ, MOVEC ==> MOV\t*/\t\t\\\n-  else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n-\t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n-    { fprintf ((FILE), \"mov\"); (PTR) += 4;\t\t\\\n-       if ((PTR)[0] == 'q' || (PTR)[0] == 'a'\t\t\\\n-\t   || (PTR)[0] == 'c') (PTR)++; }\t\t\\\n-/* SUB, SUBQ, SUBA, SUBI ==> SUB */\t\t\t\\\n-  else if ((PTR)[0] == 's' && (PTR)[1] == 'u' \t\t\\\n-\t   && (PTR)[2] == 'b')\t\t\t\t\\\n-    { fprintf ((FILE), \"sub\"); (PTR) += 3;\t\t\\\n-       if ((PTR)[0] == 'q' || (PTR)[0] == 'i'\t \t\\\n-\t   || (PTR)[0] == 'a') (PTR)++; }\t\t\\\n-/* CMP, CMPA, CMPI, CMPM ==> CMP\t*/\t\t\\\n-  else if ((PTR)[0] == 'c' && (PTR)[1] == 'm'\t\t\\\n-\t   && (PTR)[2] == 'p')\t\t\t\t\\\n-    { fprintf ((FILE), \"cmp\"); (PTR) += 3;\t\t\\\n-       if ((PTR)[0] == 'a' || (PTR)[0] == 'i'\t \t\\\n-\t   || (PTR)[0] == 'm') (PTR)++; }\t\t\\\n-}\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\tlcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (int)(ROUNDED)))\n-\n-#define USER_LABEL_PREFIX \"\"\n-\f\n-/* Override usual definitions of SDB output macros.\n-   These definitions differ only in the absence of the period\n-   at the beginning of the name of the directive\n-   and in the use of `~' as the symbol for the current location.  */\n-\n-#define PUT_SDB_SCL(a) fprintf(asm_out_file, \"\\tscl\\t%d;\", (a))\n-#define PUT_SDB_INT_VAL(a) fprintf (asm_out_file, \"\\tval\\t%d;\", (a))\n-#define PUT_SDB_VAL(a)\t\t\t\t\\\n-( fputs (\"\\tval\\t\", asm_out_file),\t\t\\\n-  output_addr_const (asm_out_file, (a)),\t\\\n-  fputc (';', asm_out_file))\n-\n-#define PUT_SDB_DEF(a)\t\t\t\t\\\n-do { fprintf (asm_out_file, \"\\tdef\\t\");\t\\\n-     ASM_OUTPUT_LABELREF (asm_out_file, a); \t\\\n-     fprintf (asm_out_file, \";\"); } while (0)\n-\n-#define PUT_SDB_PLAIN_DEF(a) fprintf(asm_out_file,\"\\tdef\\t~%s;\",a)\n-#define PUT_SDB_ENDEF fputs(\"\\tendef\\n\", asm_out_file)\n-#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\ttype\\t0%o;\", a)\n-#define PUT_SDB_SIZE(a) fprintf(asm_out_file, \"\\tsize\\t%d;\", a)\n-#define PUT_SDB_START_DIM fprintf(asm_out_file, \"\\tdim\\t\")\n-\n-#define PUT_SDB_TAG(a)\t\t\t\t\\\n-do { fprintf (asm_out_file, \"\\ttag\\t\");\t\\\n-     ASM_OUTPUT_LABELREF (asm_out_file, a);\t\\\n-     fprintf (asm_out_file, \";\"); } while (0)\n-\n-#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~bb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~eb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~bf;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~ef;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_EPILOGUE_END(NAME)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t%s;\\tval\\t~;\\tscl\\t-1;\\tendef\\n\",\t\\\n-\t   (NAME))\n-\n-#define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n-  sprintf ((BUFFER), \"~%dfake\", (NUMBER));\n-\n-/* Define subroutines to call to handle multiply, divide, and remainder.\n-   Use the subroutines that the 3b1's library provides.\n-   The `*' prevents an underscore from being prepended by the compiler.  */\n-\n-#define DIVSI3_LIBCALL \"*ldiv\"\n-#define UDIVSI3_LIBCALL \"*uldiv\"\n-#define MODSI3_LIBCALL \"*lrem\"\n-#define UMODSI3_LIBCALL \"*ulrem\"\n-#define MULSI3_LIBCALL \"*lmul\"\n-#define UMULSI3_LIBCALL \"*ulmul\"\n-\n-/* Definitions for collect2.  */\n-\n-#define OBJECT_FORMAT_COFF\n-#define MY_ISCOFF(magic) \\\n- ((magic) == MC68KWRMAGIC || (magic) == MC68KROMAGIC || (magic) == MC68KPGMAGIC)"}, {"sha": "5850a8a0d22cb39baabe835c0e1bce2e950137a5", "filename": "gcc/config/m68k/3b1g.h", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2F3b1g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2F3b1g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2F3b1g.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,61 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for a 3b1 using GAS.\n-   Copyright (C) 1987, 1988 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"m68k/m68k.h\"\n-\n-/* See m68k.h.  0 means 68000 with no 68881.  */\n-#define TARGET_DEFAULT 0\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-/* Define __HAVE_68881 in preprocessor only if -m68881 is specified.\n-   This will control the use of inline 68881 insns in certain macros.\n-   Also inform the program which CPU this is for.  */\n-#define CPP_SPEC \"%{m68881:-D__HAVE_68881__} \\\n-%{!ansi:%{m68020:-Dmc68020}%{mc68020:-Dmc68020}%{!mc68020:%{!m68020:-Dmc68010}}}\"\n-\n-/* -m68020 requires special flags to the assembler.  */\n-#define ASM_SPEC \\\n- \"%{m68020:-mc68020}%{mc68020:-mc68020}%{!mc68020:%{!m68020:-mc68010}}\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-#define CPP_PREDEFINES \"-Dmc68000 -Dmc68k -Dunix -Dunixpc -Asystem=unix  -Asystem=svr3 -Acpu=m68k -Amachine=m68k\"\n-\n-/* This is (not really) BSD, so (but) it wants DBX format.  */\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Specify how to pad function arguments.\n-   Value should be `upward', `downward' or `none'.\n-   Same as the default, except no padding for large or variable-size args.  */\n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n-  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n-    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE))\t== INTEGER_CST\t\t\\\n-       && int_size_in_bytes (TYPE) < PARM_BOUNDARY / BITS_PER_UNIT)\t\\\n-    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n-   ? downward : none)\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* Generate calls to memcpy, memcmp and memset.  */\n-#define TARGET_MEM_FUNCTIONS\n-"}, {"sha": "540cd1d6ec8f65db45ca01af788421eac39d745c", "filename": "gcc/config/m68k/amix.h", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Famix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Famix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Famix.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,144 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Commodore Amiga A3000UX version.\n-\n-   Copyright (C) 1991, 1993, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"m68k/m68kv4.h\"\n-\n-/* rhealey@aggregate.com says dots are no good either.  */\n-#define NO_DOT_IN_LABEL\n-\n-/* Alter assembler syntax for fsgldiv and fsglmul.\n-   It is highly likely that this is a generic SGS m68k assembler dependency.\n-   If so, it should eventually be handled in the m68k/sgs.h ASM_OUTPUT_OPCODE\n-   macro, like the other SGS assembler quirks.  -fnf */\n-\n-#define FSGLDIV_USE_S\t\t/* Use fsgldiv.s, not fsgldiv.x */\n-#define FSGLMUL_USE_S\t\t/* Use fsglmul.s, not fsglmul.x */\n-\n-/* Names to predefine in the preprocessor for this target machine.  For the\n-   Amiga, these definitions match those of the native AT&T compiler.  Note\n-   that we override the definition in m68kv4.h, where SVR4 is defined and\n-   AMIX isn't.  */\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \\\n-  \"-Dm68k -Dunix -DAMIX -D__svr4__ -D__motorola__ \\\n- -Amachine=m68k -Acpu=m68k -Asystem=unix -Alint=off\"\n-\n-/* At end of a switch table, define LDnnn iff the symbol LInnn was defined.\n-   Some SGS assemblers have a bug such that \"Lnnn-LInnn-2.b(pc,d0.l*2)\"\n-   fails to assemble.  Luckily \"Lnnn(pc,d0.l*2)\" produces the results\n-   we want.  This difference can be accommodated by making the assembler\n-   define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n-   string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n-   macro. (the Amiga assembler has this bug) */\n-\n-#undef ASM_OUTPUT_CASE_END\n-#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (switch_table_difference_label_flag)\t\t\t\t\\\n-    asm_fprintf ((FILE), \"%s%LLD%d,%LL%d\\n\", SET_ASM_OP, (NUM), (NUM));\\\n-  switch_table_difference_label_flag = 0;\t\t\t\t\\\n-} while (0)\n-\n-int switch_table_difference_label_flag;\n-\n-/* This says how to output assembler code to declare an\n-   uninitialized external linkage data object.  Under SVR4,\n-   the linker seems to want the alignment of data objects\n-   to depend on their types.  We do exactly that here.\n-   [This macro overrides the one in svr4.h because the amix assembler\n-    has a minimum default alignment of 4, and will not accept any\n-    explicit alignment smaller than this.  -fnf] */\n-\n-#undef ASM_OUTPUT_ALIGNED_COMMON\n-#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\t.comm\\t\", (FILE));\t\t\t\t\t\t\\\n-  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n-  fprintf ((FILE), \",%u,%u\\n\", (SIZE), MAX ((ALIGN) / BITS_PER_UNIT, 4)); \\\n-} while (0)\n-\n-/* This says how to output assembler code to declare an\n-   uninitialized internal linkage data object.  Under SVR4,\n-   the linker seems to want the alignment of data objects\n-   to depend on their types.  We do exactly that here.\n-   [This macro overrides the one in svr4.h because the amix assembler\n-    has a minimum default alignment of 4, and will not accept any\n-    explicit alignment smaller than this.  -fnf] */\n-\n-#undef ASM_OUTPUT_ALIGNED_LOCAL\n-#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"%s%s,%u,%u\\n\",\t\t\t\t\t\\\n-\t   BSS_ASM_OP, (NAME), (int)(SIZE), MAX ((ALIGN) / BITS_PER_UNIT, 4)); \\\n-} while (0)\n-\n-/* This definition of ASM_OUTPUT_ASCII is the same as the one in m68k/sgs.h,\n-   which has been overridden by the one in svr4.h.  However, we can't use\n-   the one in svr4.h because the amix assembler croaks on some of the\n-   strings that it emits (such as .string \"\\\"%s\\\"\\n\").  */\n-\n-#undef ASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  register size_t sp = 0, limit = (LEN);\t\t\t\\\n-  fputs (integer_asm_op (1, TRUE), (FILE));\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    int ch = (PTR)[sp];\t\t\t\t\t\t\\\n-    if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"'%c\", ch);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"0x%x\", ch);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    if (++sp < limit)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tif ((sp % 10) == 0)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf ((FILE), \"\\n%s\", integer_asm_op (1, TRUE));\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    putc (',', (FILE));\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  } while (sp < limit);\t\t\t\t\t\t\\\n-  putc ('\\n', (FILE));\t\t\t\t\t\t\\\n-} while (0)\n-\f\n-/* The following should be unnecessary as a result of PIC_CASE_VECTOR_ADDRESS.\n-   But rhealey@aggregate.com says they are still needed.  */\n-\n-/* Override these for the sake of an assembler bug: the Amix\n-   assembler can't handle .LC0@GOT syntax.  This pollutes the final\n-   table for shared librarys but what's a poor soul to do; sigh... RFH */\n-\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-do {\t\t\t\t\t\t\t\\\n-  if (flag_pic && !strcmp(PREFIX,\"LC\"))\t\t\t\\\n-    sprintf (LABEL, \"*%s%%%ld\", PREFIX, (long)(NUM));\t\\\n-  else\t\t\t\t\t\t\t\\\n-    sprintf (LABEL, \"*%s%s%ld\", LOCAL_LABEL_PREFIX, PREFIX, (long)(NUM)); \\\n-} while (0)"}, {"sha": "67528c3a7dffe07ad9b176b7adf1db6dbf53b8e8", "filename": "gcc/config/m68k/atari.h", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fatari.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fatari.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fatari.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,101 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Atari TT ASV version.\n-   Copyright (C) 1994, 1995, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"m68k/m68kv4.h\"\n-\n-/* Dollars and dots in labels are not allowed.  */\n-\n-#define NO_DOLLAR_IN_LABEL\n-#define NO_DOT_IN_LABEL\n-\n-/* Alter assembler syntax for fsgldiv and fsglmul.\n-   It is highly likely that this is a generic SGS m68k assembler dependency.\n-   If so, it should eventually be handled in the m68k/sgs.h ASM_OUTPUT_OPCODE\n-   macro, like the other SGS assembler quirks.  -fnf */\n-\n-#define FSGLDIV_USE_S\t\t/* Use fsgldiv.s, not fsgldiv.x */\n-#define FSGLMUL_USE_S\t\t/* Use fsglmul.s, not fsglmul.x */\n-\n-/* At end of a switch table, define LDnnn iff the symbol LInnn was defined.\n-   Some SGS assemblers have a bug such that \"Lnnn-LInnn-2.b(pc,d0.l*2)\"\n-   fails to assemble.  Luckily \"Lnnn(pc,d0.l*2)\" produces the results\n-   we want.  This difference can be accommodated by making the assembler\n-   define such \"LDnnn\" to be either \"Lnnn-LInnn-2.b\", \"Lnnn\", or any other\n-   string, as necessary.  This is accomplished via the ASM_OUTPUT_CASE_END\n-   macro. (the Amiga assembler has this bug) */\n-\n-#undef ASM_OUTPUT_CASE_END\n-#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (switch_table_difference_label_flag)\t\t\t\t\\\n-    asm_fprintf ((FILE), \"%s%LLD%d,%LL%d\\n\", SET_ASM_OP, (NUM), (NUM));\\\n-  switch_table_difference_label_flag = 0;\t\t\t\t\\\n-} while (0)\n-\n-int switch_table_difference_label_flag;\n-\n-/* This definition of ASM_OUTPUT_ASCII is the same as the one in m68k/sgs.h,\n-   which has been overridden by the one in svr4.h.  However, we can't use\n-   the one in svr4.h because the ASV assembler croaks on some of the\n-   strings that it emits (such as .string \"\\\"%s\\\"\\n\").  */\n-\n-#undef ASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(FILE,PTR,LEN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  register size_t sp = 0, limit = (LEN);\t\t\t\\\n-  fputs (integer_asm_op (1, TRUE), (FILE));\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    int ch = (PTR)[sp];\t\t\t\t\t\t\\\n-    if (ch > ' ' && ! (ch & 0x80) && ch != '\\\\')\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"'%c\", ch);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"0x%x\", ch);\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-    if (++sp < limit)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tif ((sp % 10) == 0)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    fprintf ((FILE), \"\\n%s\", integer_asm_op (1, TRUE));\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    putc (',', (FILE));\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  } while (sp < limit);\t\t\t\t\t\t\\\n-  putc ('\\n', (FILE));\t\t\t\t\t\t\\\n-}\n-\n-/* Override these for the sake of an assembler bug: the ASV\n-   assembler can't handle .LC0@GOT syntax.  This pollutes the final\n-   table for shared librarys but what's a poor soul to do; sigh... RFH */\n-\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-do {\t\t\t\t\t\t\t\\\n-  if (flag_pic && !strcmp(PREFIX,\"LC\"))\t\t\t\\\n-    sprintf (LABEL, \"*%s%%%ld\", PREFIX, (long)(NUM));\t\\\n-  else\t\t\t\t\t\t\t\\\n-    sprintf (LABEL, \"*%s%s%ld\", LOCAL_LABEL_PREFIX, PREFIX, (long)(NUM)); \\\n-} while (0)"}, {"sha": "4df5ec4bcd0313441e28dc9c20dd1150138f5cd5", "filename": "gcc/config/m68k/ccur-GAS.h", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fccur-GAS.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fccur-GAS.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fccur-GAS.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,129 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Concurrent 68k version.\n-   Copyright (C) 1987, 1988, 1995, 1996, 1997 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef MASSCOMP\n-#define MASSCOMP\n-#endif\n-\n-#ifndef CONCURRENT\n-#define CONCURRENT\n-#endif\n-\n-#ifndef __mc68000__\n-#define __mc68000__\n-#endif\n-\n-#ifndef __mc68020__\n-#define __mc68020__\n-#endif\n-\n-#define USE_GAS\n-#define MOVE_RATIO 100\n-\n-#define SPACE_AFTER_L_OPTION\n-#define SWITCHES_NEED_SPACES \"oL\"\n-\n-/* See m68k.h.  7 means 68020 with 68881.  */\n-#define TARGET_DEFAULT (MASK_68040|MASK_BITFIELD|MASK_68881|MASK_68020)\n-\n-#include \"m68k/m68k.h\"\n-\n-#define SIZE_TYPE \"int\"\n-\n-/* for 68k machines this only needs to be TRUE for the 68000 */\n-\n-#undef STRICT_ALIGNMENT     \n-#define STRICT_ALIGNMENT 0\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-#define CPP_PREDEFINES \\\n-    \"-Dmc68000 -Dmasscomp -DMASSCOMP -Dunix -DLANGUAGE_C -Dconcurrent -DCONCURRENT\"\n-\n-#undef TARGET_VERSION\n-#define TARGET_VERSION fprintf (stderr, \" (68k, GNU GAS syntax)\");\n-\n-/* Discard internal local symbols beginning with 'L'.  */\n-#define LINK_SPEC \"-X\"\n-\n-/* Every structure or union's size must be a multiple of 4 bytes.  */\n-#define STRUCTURE_SIZE_BOUNDARY 16 \n-\n-/* No data type wants to be aligned rounder than this.  */\n-#undef BIGGEST_ALIGNMENT\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-#undef POINTER_BOUNDARY\n-#define POINTER_BOUNDARY 32\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#undef EMPTY_FIELD_BOUNDARY\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Allocation boundary in bits for the code of a function */\n-#undef  FUNCTION_BOUNDARY\n-#define FUNCTION_BOUNDARY 32\n-\n-/* Make strings long-word aligned so dhrystones will run faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN) \\\n-   (TREE_CODE (EXP) == STRING_CST \\\n-    && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* This is BSD, so it wants DBX format.  */\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Override parts of m68k.h */\n-\n-#undef CALL_USED_REGISTERS\n-#define CALL_USED_REGISTERS \\\n- {1, 1, 0, 0, 0, 0, 0, 0, \\\n-  1, 1, 0, 0, 0, 0, 0, 1, \\\n-  1, 1, 0, 0, 0, 0, 1, 1 }\n-\n-#undef REG_ALLOC_ORDER\n-#define REG_ALLOC_ORDER \\\n-{  0,  1,  2,  3,  4,  5,  6,  7,\\\n-   8,  9, 10, 11, 12, 13, 14, 15, \\\n-  16, 17, 22, 23, 18, 19, 20, 21 }\n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE)\t\\\n-  fprintf (FILE, \"#NO_APP\\n.globl fltused\\n\");\n-\n-#undef ASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-{ int _LOG = LOG;                       \\\n-  if (_LOG == 1)\t\t\t\\\n-    fprintf (FILE, \"\\t.even\\n\");\t\\\n-  else if (_LOG == 2)                   \\\n-    fprintf (FILE, \"\\t.align 4\\n\");     \\\n-  else if (_LOG != 0)\t\t\t\\\n-    fprintf (FILE, \"\\t.align %d\\n\", _LOG);\\\n-}\n-\n-/* crt0.c should use the vax-bsd style of entry, with a dummy arg.  */\n-\n-#define CRT0_DUMMIES bogus_fp,"}, {"sha": "94172fa405ecee247d3423d74ddd6985064312ae", "filename": "gcc/config/m68k/crds.h", "status": "removed", "additions": 0, "deletions": 453, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fcrds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fcrds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcrds.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,453 +0,0 @@\n-/* Definitions of target machine for GNU compiler;\n-   Charles River Data Systems UNiverse/32.\n-   Copyright (C) 1987, 1993, 1994, 1996, 1997, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Contributed by Gary E. Miller (Gary_Edmunds_Miller@cup.portal.com)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n-#define SGS\t\t\t/* Uses SGS assembler */\n-#define SGS_SWITCH_TABLES\t/* Different switch table handling */\n-#define SGS_NO_LI\t\t/* Suppress jump table label usage */\n-#define CRDS\t\t\t/* Charles River Data Systems assembler */\n-\n-#include \"m68k/m68k.h\"\n-\n-/* Without STRUCTURE_SIZE_BOUNDARY, we can't ensure that structures are\n-   aligned such that we can correctly extract bitfields from them.\n-   Someone should check whether the usual compiler on the crds machine\n-   provides the equivalent behavior of STRUCTURE_SIZE_BOUNDARY.  */\n-/* Set to 16 because all other m68k targets have it so */\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* See m68k.h.  0 means 680[01]0 with no 68881.  */\n-\n-#undef TARGET_DEFAULT\n-#define\tTARGET_DEFAULT 0\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-/* special flags to the unos assembler.  */\n-\n-#undef ASM_SPEC\n-#define ASM_SPEC \"-g\"\n-\n-#undef LIB_SPEC\n-#define LIB_SPEC \"%{!p:%{!pg:-lunos}}%{p:-lc_p}%{pg:-lc_p}\"\n-\n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC  \\\n-  \"%{pg:gcrt0.o%s}%{!pg:%{p:mc68rt0.o%s}%{!p:c68rt0.o%s}}\"\n-\n-/* CC1 spec */\n-#if 0\n-/* c.sac only used in _s_call_r() in libunos.a and malloc() in libmalloc.a */\n-/* so we do not need to bother ! */\n-#define CC1_SPEC \"-fpcc-struct-return\"\n-#endif\n-\n-/* -O2 for MAX optimization */\n-#undef CC1_SPEC\n-#define CC1_SPEC \"%{O2:-fstrength-reduce}\"\n-\n-/* Make output for SDB.  */\n-\n-/* #define SDB_DEBUGGING_INFO UNOS casm has no debugging :-( */\n-\n-/* UNOS need stack probe :-( */\n-\n-#if 0\n-#define HAVE_probe 1\n-#define gen_probe()  gen_rtx_ASM_INPUT (VOIDmode, \"tstb -2048(sp)\\t;probe\\n\")\n-#else\n-#undef NEED_PROBE\n-#define NEED_PROBE (-2048)\n-#endif\n-\n-/* use memcpy, memset instead of bcopy, etc.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n-/* Define __HAVE_68881__ in preprocessor if -m68881 is specified.\n-   This will control the use of inline 68881 insns in certain macros.  */\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"%{m68881:-D__HAVE_68881__}\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dmc68k -DM68000 -Dmc68000 -Dunos -Dunix -D__motorola__ -Asystem=unix  -Acpu=m68k -Amachine=m68k\"\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-/* unos uses \".comm c.sac\" returns &c.sac in d0 */\n-/* make pointer to c.sac ?\n-#undef STRUCT_VALUE_REGNUM\n-#define STRUCT_VALUE gen_rtx_MEM (Pmode, gen_rtx( , , ) )\n-*/\n-\n-#define BSS_SECTION_ASM_OP \"\\t.bss\"\n-\n-/* Specify how to pad function arguments.\n-   Value should be `upward', `downward' or `none'.\n-   Same as the default, except no padding for large or variable-size args.  */\n-\n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n-  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n-    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE))\t== INTEGER_CST\t\t\\\n-       && int_size_in_bytes (TYPE) < PARM_BOUNDARY / BITS_PER_UNIT)\t\\\n-    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n-   ? downward : none)\n-\n-/* Override parts of m68k.h to fit the CRuDS assembler.  */\n-\n-#undef TARGET_VERSION \n-#define TARGET_VERSION fprintf (stderr, \" (68k, CRDS/UNOS)\");\n-\n-/* Specify extra dir to search for include files.  */\n-#define SYSTEM_INCLUDE_DIR \"/include\"\n-\n-/* Control the assembler format that we output.  */\n-\n-/* Output at beginning of assembler file.  */\n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE)\t\\\n-  fprintf (FILE, \";#NO_APP\\n\");\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#undef ASM_APP_ON\n-#define ASM_APP_ON \";#APP\\n\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#undef ASM_APP_OFF \n-#define ASM_APP_OFF \";#NO_APP\\n\"\n-\n-/* The prefix for immediate operands.  */\n-\n-#undef IMMEDIATE_PREFIX\n-#define IMMEDIATE_PREFIX \"$\"\n-\n-/*unos has no .skip :-( */\n-#undef ASM_OUTPUT_SKIP\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)\t \t\\\n-    fprintf (FILE, \"\\t. = . + %u\\n\", (int)(SIZE));\t\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-/* should use bss_section instead of data_section but this makes casm die ? */\n-\n-#undef ASM_OUTPUT_LOCAL\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-{ data_section ();\t\t\t\t\\\n-  if ((SIZE) > 1) fprintf (FILE, \"\\t.even\\n\");\t\\\n-  assemble_name ((FILE), (NAME));\t\t\\\n-  fprintf ((FILE), \":\\t. = . + %u\\n\", (int)(ROUNDED));}\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#undef ASM_OUTPUT_REG_PUSH\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmovel %s,-(sp)\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#undef ASM_OUTPUT_REG_POP\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmovel (sp)+,%s\\n\", reg_names[REGNO])\n-\n-#undef  ASM_OUTPUT_ASCII\n-#define  ASM_OUTPUT_ASCII(FILE, P , SIZE)\t\t\t\t\\\n-do {  size_t i, limit = (SIZE);\t\t\t\t\t\t\\\n-\t  fprintf ((FILE), \"\\t.ascii \\\"\");\t\t\t\t\\\n-\t  for (i = 0; i < limit; i++)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      register int c = (P)[i];\t\t\t\t\t\\\n-\t      if (i != 0 && (i / 200) * 200 == i)\t\t\t\\\n-\t\tfprintf ((FILE), \"\\\"\\n\\t.ascii \\\"\");\t\t\t\\\n-\t      if (c >= ' ' && c < 0177) {\t\t\t\t\\\n-\t        if (c != '\\\"' && c != '\\\\') {\t\t\t\t\\\n-\t\t  putc (c, (FILE));\t\t\t\t\t\\\n-\t\t  continue;\t\t\t\t\t\t\\\n-\t        }\t\t\t\t\t\t\t\\\n-\t       }\t\t\t\t\t\t\t\\\n-\t       /* brain dead asm doesn't understand char escapes */\t\\\n-\t       fprintf ((FILE), \"\\\"\\n\\t.byte\\t%d\\n\\t.ascii \\\"\", c);\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n- } while (0)\n-\n-\n-/* Change all JBxx to Bxx.  Also change all DBRA to DBF.\n-   Also change divs.l, etc., to divs, etc.  But don't change divsl.l.  */\n-\n-#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n-{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n-    { ++(PTR); }\t\t\t\t\t\\\n-  else if ((PTR)[0] == 'd')\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (!strncmp ((PTR), \"dbra\", 4))\t\t\t\\\n-\t{ fprintf ((FILE), \"dbf\"); (PTR) += 4; }\t\\\n-      else if (!strncmp ((PTR), \"div\", 3) && (PTR)[5] == ' ')  \\\n-\t{ fprintf ((FILE), \"div%c\", (PTR)[3]); (PTR) += 6; }   \\\n-    }\t\t\t\t\t\t\t\\\n-}\n-\n-\n-#if 0\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-\n-   On the 68000, we use several CODE characters:\n-   '.' for dot needed in Motorola-style opcode names.\n-   '-' for an operand pushing on the stack:\n-       sp@-, -(sp) or -(%sp) depending on the style of syntax.\n-   '+' for an operand pushing on the stack:\n-       sp@+, (sp)+ or (%sp)+ depending on the style of syntax.\n-   '@' for a reference to the top word on the stack:\n-       sp@, (sp) or (%sp) depending on the style of syntax.\n-   '#' for an immediate operand prefix (# in MIT and Motorola syntax\n-       but & in SGS syntax, $ in unos syntax).\n-   '!' for the fpcr register (used in some float-to-fixed conversions).\n-\n-   'b' for byte insn (no effect, on the Sun; this is for the ISI).\n-   'd' to force memory addressing to be absolute, not relative.\n-   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n-   'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n-       than directly).  Second part of 'y' below.\n-   'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n-       or print pair of registers as rx:ry.\n-   'y' for a FPA insn (print pair of registers as rx:ry).  This also outputs\n-       CONST_DOUBLE's as SunFPA constant RAM registers if\n-       possible, so it should not be used except for the SunFPA.  */\n-\n-#undef PRINT_OPERAND_PUNCT_VALID_P\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n-  ((CODE) == '.' || (CODE) == '#' || (CODE) == '-'\t\t\t\\\n-   || (CODE) == '+' || (CODE) == '@' || (CODE) == '!')\n-\n-#undef PRINT_OPERAND\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ int i;\t\t\t\t\t\t\t\t\\\n-  if (CODE == '.') ;\t\t\t\t\t\t\t\\\n-  else if (CODE == '#') fprintf (FILE, \"$\");\t\t\t\t\\\n-  else if (CODE == '-') fprintf (FILE, \"-(sp)\");\t\t\t\\\n-  else if (CODE == '+') fprintf (FILE, \"(sp)+\");\t\t\t\\\n-  else if (CODE == '@') fprintf (FILE, \"(sp)\");\t\t\t\t\\\n-  else if (CODE == '!') fprintf (FILE, \"fpcr\");\t\t\t\t\\\n-  else if (CODE == '/')\t\t\t\t\t\t\t\\\n-    ;\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    { if (REGNO (X) < 16 && (CODE == 'y' || CODE == 'x') && GET_MODE (X) == DFmode)\t\\\n-        fprintf (FILE, \"%s:%s\", reg_names[REGNO (X)], reg_names[REGNO (X)+1]); \\\n-      else\t\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      output_address (XEXP (X, 0));\t\t\t\t\t\\\n-      if (CODE == 'd' && ! TARGET_68020\t\t\t\t\t\\\n-\t  && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\t\t\\\n-\t/* fprintf (FILE, \".l\") */;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((CODE == 'y' || CODE == 'w')\t\t\t\t\t\\\n-\t   && GET_CODE(X) == CONST_DOUBLE\t\t\t\t\\\n-\t   && (i = standard_sun_fpa_constant_p (X)))\t\t\t\\\n-    fprintf (FILE, \"%%%d\", i & 0x1ff);\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n-    { REAL_VALUE_TYPE r; long l;\t\t\t\t\t\\\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n-      if (CODE == 'f')\t\t\t\t\t\t\t\\\n-\tASM_OUTPUT_FLOAT_OPERAND (CODE, FILE, r);\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        { REAL_VALUE_TO_TARGET_SINGLE (r, l);\t\t\t\t\\\n-          fprintf (FILE, \"$0x%lx\", l); } }\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n-    { REAL_VALUE_TYPE r;\t\t\t\t\t\t\\\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n-      ASM_OUTPUT_DOUBLE_OPERAND (FILE, r); }\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == XFmode)\t\\\n-    { REAL_VALUE_TYPE r;\t\t\t\t\t\t\\\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n-      ASM_OUTPUT_LONG_DOUBLE_OPERAND (FILE, r); }\t\t\t\\\n-  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n-#endif\n-\f\n-/* Note that this contains a kludge that knows that the only reason\n-   we have an address (plus (label_ref...) (reg...))\n-   is in the insn before a tablejump, and we know that m68k.md\n-   generates a label LInnn: on such an insn.  */\n-#undef PRINT_OPERAND_ADDRESS\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n-  register rtx addr = ADDR;\t\t\t\t\t\t\\\n-  rtx offset;\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case REG:\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PRE_DEC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case POST_INC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PLUS:\t\t\t\t\t\t\t\t\\\n-      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n-      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n-      offset = 0;\t\t\t\t\t\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n-\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n-\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n-      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n-      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n-\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n-\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n-\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n-      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n-\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n-      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n-        { int scale = 1;\t\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n-\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n-\t    fprintf (FILE, \"L%d-LI%d-2(pc,%s.w\",\t\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"L%d-LI%d-2(pc,%s.l\",\t\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n-\t  if (scale != 1) fprintf (FILE, \":%d\", scale);\t\t\t\\\n-\t  putc (')', FILE);\t\t\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n-        { fprintf (FILE, \"L%d-LI%d-2(pc,%s.l\",\t\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   reg_names[REGNO (breg)]);\t\t\t\t\\\n-\t  putc (')', FILE);\t\t\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n-\t{ int scale = 1;\t\t\t\t\t\t\\\n-\t  if (breg == 0)\t\t\t\t\t\t\\\n-\t    abort ();\t\t\t\t\t\t\t\\\n-\t  if (addr && GET_CODE (addr) == LABEL_REF) abort ();\t\t\\\n-\t  if (addr != 0)\t\t\t\t\t\t\\\n-\t    output_addr_const (FILE, addr);\t\t\t\t\\\n-\t  fprintf (FILE, \"(%s\", reg_names[REGNO (breg)]);\t\t\\\n-\t  if (breg != 0 && ireg != 0)\t\t\t\t\t\\\n-\t    putc (',', FILE);\t\t\t\t\t\t\\\n-\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n-\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n-\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n-\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n-\t  else if (ireg != 0)\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n-\t  if (scale != 1) fprintf (FILE, \":%d\", scale);\t\t\t\\\n-\t  putc (')', FILE);\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n-\t{ fprintf (FILE, \"L%d-LI%d-2(pc,%s.l)\",\t\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n-\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n-\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n-\tfprintf (FILE, \"%d\", INTVAL (addr));\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        output_addr_const (FILE, addr);\t\t\t\t\t\\\n-    }}\n-\f\n-#define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME) \\\n-  do {\tfprintf (FILE, \"\\t; file\\t\");\t\t\t\\\n-\toutput_quoted_string (FILE, FILENAME);\t\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\t\\\n-  } while (0)\n-\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\t\\\n-  fprintf (FILE, \"\\t; ln\\t%d\\n\",\t\t\t\\\n-\t   (sdb_begin_function_line\t\t\\\n-\t    ? (LINENO) - sdb_begin_function_line : 1))\n-\n-/* Must put address in  %a0 , not  %d0 . -- LGM, 7/15/88 */\n-/* UNOS ?? */\n-#undef FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n-    fprintf (FILE, \"\\tmovl &LP%%%d,%%a0\\n\\tjsr mcount\\n\", (LABEL_NO))"}, {"sha": "5e4501b83c4f37cd6924e4fe1ac400fe3fbb5329", "filename": "gcc/config/m68k/hp2bsd.h", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fhp2bsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fhp2bsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp2bsd.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,78 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  HP 9000/200 68000 version.\n-   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"m68k/m68k.h\"\n-\n-/* See m68k.h.  0 means 68000 with no 68881.  */\n-\n-#define TARGET_DEFAULT 0\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-/* Define __HAVE_68881 in preprocessor only if -m68881 is specified.\n-   This will control the use of inline 68881 insns in certain macros.\n-   Also inform the program which CPU this is for.  */\n-\n-#define CPP_SPEC \"%{m68881:-D__HAVE_68881__} \\\n-%{!ansi:%{m68020:-Dmc68020}%{mc68020:-Dmc68020}%{!mc68020:%{!m68020:-Dmc68010}}}\"\n-\n-/* -m68020 requires special flags to the assembler.  */\n-\n-#define ASM_SPEC \\\n- \"%{m68020:-mc68020}%{mc68020:-mc68020}%{!mc68020:%{!m68020:-mc68010}}\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dmc68000 -Dmc68010 -Dhp200 -Dunix -Asystem=unix -Asystem=bsd -Acpu=m68k -Amachine=m68k\"\n-\n-/* Link with libg.a when debugging, for dbx's sake.  */\n-\n-#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \"\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-\n-#undef EMPTY_FIELD_BOUNDARY\n-#define EMPTY_FIELD_BOUNDARY 16\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* This is BSD, so it wants DBX format.  */\n-\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Define subroutines to call to handle multiply, divide, and remainder.\n-   These routines are built into the c-library on the hp200.\n-   XXX What other routines from the c-library could we use?\n-   The `*' prevents an underscore from being prepended by the compiler.  */\n-\n-#define DIVSI3_LIBCALL \"*ldiv\"\n-#define UDIVSI3_LIBCALL \"*uldiv\"\n-#define MODSI3_LIBCALL \"*lrem\"\n-#define UMODSI3_LIBCALL \"*ulrem\"\n-#define MULSI3_LIBCALL \"*lmul\"\n-#define UMULSI3_LIBCALL \"*ulmul\"\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n-   we want to retain compatibility with older gcc versions.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0"}, {"sha": "23cc9c71b203dbf63733a4959d24e4720ebce867", "filename": "gcc/config/m68k/hp3bsd.h", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fhp3bsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fhp3bsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp3bsd.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,44 +0,0 @@\n-#include \"m68k/m68k.h\"\n-\n-/* See m68k.h.  7 means 68020 with 68881.  */\n-\n-#define TARGET_DEFAULT (MASK_BITFIELD|MASK_68881|MASK_68020)\n-\n-/* Define __HAVE_68881__ in preprocessor, unless -msoft-float is specified.\n-   This will control the use of inline 68881 insns in certain macros.  */\n-\n-#define CPP_SPEC \"%{!msoft-float:-D__HAVE_68881__ -D__HAVE_FPU__}\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dmc68000 -Dmc68020 -Dhp300 -Dhp9000 -Dunix -Asystem=unix  -Asystem=bsd -Acpu=m68k -Amachine=m68k\"\n-\n-/* Link with libg.a when debugging, for dbx's sake.  */\n-\n-#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \"\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* This is BSD, so it wants DBX format.  */\n-\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Do not break .stabs pseudos into continuations.  */\n-\n-#define DBX_CONTIN_LENGTH 0\n-\n-/* This is the char to use for continuation (in case we need to turn\n-   continuation back on).  */\n-\n-#define DBX_CONTIN_CHAR '?'\n-\n-/* Don't use the `xsfoo;' construct in DBX output; this system\n-   doesn't support it.  */\n-\n-#define DBX_NO_XREFS\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n-   we want to retain compatibility with older gcc versions.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0"}, {"sha": "780a639efa5b5d6dd60058bb4e4ea9712a4e32a1", "filename": "gcc/config/m68k/hp3bsd44.h", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fhp3bsd44.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fhp3bsd44.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp3bsd44.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,53 +0,0 @@\n-#include \"m68k/m68k.h\"\n-\n-/* See m68k.h.  7 means 68020 with 68881.  */\n-\n-#define TARGET_DEFAULT (MASK_BITFIELD|MASK_68881|MASK_68020)\n-\n-/* Define __HAVE_68881__ in preprocessor, unless -msoft-float is specified.\n-   This will control the use of inline 68881 insns in certain macros.  */\n-\n-#define CPP_SPEC \"%{!msoft-float:-D__HAVE_68881__ -D__HAVE_FPU__}\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dmc68000 -Dmc68020 -Dhp300 -Dhp9000 -Dunix -D__BSD_4_4__ -Asystem=unix  -Asystem=bsd -Acpu=m68k -Amachine=m68k\"\n-\n-/* No more libg.a */\n-\n-#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}\"\n-\n-/* Make gcc agree with <machine/ansi.h> */\n-\n-#define SIZE_TYPE \"unsigned int\"\n-#define PTRDIFF_TYPE \"int\"\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"short unsigned int\"\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 16\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* This is BSD, so it wants DBX format.  */\n-\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Do not break .stabs pseudos into continuations.  */\n-\n-#define DBX_CONTIN_LENGTH 0\n-\n-/* This is the char to use for continuation (in case we need to turn\n-   continuation back on).  */\n-\n-#define DBX_CONTIN_CHAR '?'\n-\n-/* Don't use the `xsfoo;' construct in DBX output; this system\n-   doesn't support it.  */\n-\n-#define DBX_NO_XREFS\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n-   we want to retain compatibility with older gcc versions.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0"}, {"sha": "2be6da806a2d8cdb65d5424e616d3bd147ff99c7", "filename": "gcc/config/m68k/linux-aout.h", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Flinux-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Flinux-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux-aout.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,75 +0,0 @@\n-/* Definitions for Motorola m68k running Linux-based GNU systems.\n-   Copyright (C) 1995, 1996, 1997, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include <m68k/m68k.h>\n-#include <linux-aout.h>\n-\n-/* 68020 with 68881 */\n-#define TARGET_DEFAULT (MASK_BITFIELD|MASK_68881|MASK_68020)\n-\n-#define DBX_DEBUGGING_INFO 1\n-\n-#define ASM_COMMENT_START \"|\"\n-\n-#define CPP_PREDEFINES \\\n-  \"-Dunix -Dmc68000 -Dmc68020 -D__gnu_linux__ -Dlinux -Asystem=unix -Asystem=posix -Acpu=m68k -Amachine=m68k\"\n-\n-#undef CPP_SPEC\n-#if TARGET_DEFAULT & MASK_68881\n-#define CPP_SPEC \\\n-  \"%{!msoft-float:-D__HAVE_68881__} %{posix:-D_POSIX_SOURCE}\"\n-#else\n-#define CPP_SPEC \\\n-  \"%{m68881:-D__HAVE_68881__} %{posix:-D_POSIX_SOURCE}\"\n-#endif\n-\n-#undef SUBTARGET_SWITCHES\n-#define SUBTARGET_SWITCHES\t{\"ieee-fp\", 0, \\\n-  N_(\"Use IEEE math for fp comparisons\") },\n-\n-#undef ASM_SPEC\n-#define ASM_SPEC \\\n-  \"%{m68030} %{m68040} %{fpic:-k} %{fPIC:-k}\"\n-\n-#undef LIB_SPEC\n-#if 1\n-/* We no longer link with libc_p.a or libg.a by default.  If you want\n-   to profile or debug the GNU/Linux C library, please add -lc_p or -ggdb\n-   to LDFLAGS at the link time, respectively.  */\n-#define LIB_SPEC \\\n-  \"%{mieee-fp:-lieee} %{p:-lgmon} %{pg:-lgmon} %{!ggdb:-lc} %{ggdb:-lg}\"\n-#else\n-#define LIB_SPEC \\\n-  \"%{mieee-fp:-lieee} %{p:-lgmon -lc_p} %{pg:-lgmon -lc_p} %{!p:%{!pg:%{!g*:-lc} %{g*:-lg}}}\"\n-#endif\n-\n-/* We want to pass -v to linker */\n-#undef LINK_SPEC\n-#define LINK_SPEC\t\"-m m68klinux %{v:-dll-verbose}\"\n-\n-#define SIZE_TYPE \"unsigned int\"\n-#define PTRDIFF_TYPE \"int\"\n-\n-/* Generate calls to memcpy, memcmp and memset.  */\n-#define TARGET_MEM_FUNCTIONS\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler.  */\n-#undef PCC_STATIC_STRUCT_RETURN\n-#define DEFAULT_PCC_STRUCT_RETURN 0"}, {"sha": "14f7f68c33f18fea19491a5054fd2567400440cc", "filename": "gcc/config/m68k/m68k-psos.h", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fm68k-psos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fm68k-psos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-psos.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,67 +0,0 @@\n-/* Definitions of a target machine for the GNU compiler:\n-   68040 running pSOS, ELF object files, DBX debugging.\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* Use MOTOROLA assembler syntax, as gas is configured that way and\n-   glibc also seems to use it. Must come BEFORE m68k.h! */\n-\n-#define MOTOROLA\n-\n-/* Get generic m68k definitions.  */\n-\n-#include \"m68k/m68k.h\"\n-#include \"m68k/m68kemb.h\"\n-\n-/* Default processor type is a (pure) 68040 with 68881 emulation using\n-   the floating-point support package.  */\n-\n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_68040_ONLY|MASK_BITFIELD|MASK_68881|MASK_68020)\n-\n-/* Options passed to CPP, GAS, CC1 and CC1PLUS. We override\n-   m68k-none.h for consistency with TARGET_DEFAULT.  */\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \\\n-\"%{!mc68000:%{!m68000:%{!m68332:%{!msoft-float:-D__HAVE_68881__ }}}}\\\n-%{!ansi:-Dmc68000 %{m68010:-Dmc68010 }%{m68020:-Dmc68020 }%{mc68020:-Dmc68020 }%{m68030:-Dmc68030 }%{m68040:-Dmc68040 }%{m68020-40:-Dmc68020 -Dmc68030 -Dmc68040 }%{m68302:-Dmc68302 }%{m68332:-Dmc68332 }%{!mc68000:%{!m68000:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68302:%{!m68332:-Dmc68040 }}}}}}}}}}}\\\n--D__mc68000__ -D__mc68000 %{m68010:-D__mc68010__ -D__mc68010 }%{m68020:-D__mc68020__ -D__mc68020 }%{mc68020:-D__mc68020__ -D__mc68020 }%{m68030:-D__mc68030__ -D__mc68030 }%{m68040:-D__mc68040__ -D__mc68040 }%{m68020-40:-D__mc68020__ -D__mc68030__ -D__mc68040__ -D__mc68020 -D__mc68030 -D__mc68040 }%{m68302:-D__mc68302__ -D__mc68302 }%{m68332:-D__mc68332__ -D__mc68332 }%{!mc68000:%{!m68000:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68302:%{!m68332:-D__mc68040__ -D__mc68040 }}}}}}}}}}\"\n-\n-#undef ASM_SPEC\n-#define ASM_SPEC \\\n-\"%{m68851}%{mno-68851}%{m68881}%{mno-68881}%{msoft-float:-mno-68881 }\\\n-%{m68000}%{mc68000}%{m68010}%{m68020}%{mc68020}%{m68030}%{m68040}%{m68020-40:-mc68040}%{m68302}%{m68332}%{!m68000:%{!mc68000:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68302:%{!m68332:-mc68040}}}}}}}}}}\"\n-\n-#undef CC1_SPEC\n-#define CC1_SPEC \\\n- \"%{m68000:%{!m68881:-msoft-float }}%{m68302:-m68000}%{m68332:-m68020 -mnobitfield %{!m68881:-msoft-float}}%{!m68000:%{!mc68000:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68302:%{!m68332:-m68040}}}}}}}}}}\"\n-\n-#undef CC1PLUS_SPEC\n-#define CC1PLUS_SPEC \\\n- \"%{m68000:%{!m68881:-msoft-float }}%{m68302:-m68000}%{m68332:-m68020 -mnobitfield %{!m68881:-msoft-float}}%{!m68000:%{!mc68000:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68302:%{!m68332:-m68040}}}}}}}}}}\"\n-\n-\n-/* Get processor-independent pSOS definitions.  */\n-\n-#include \"psos.h\"\n-\n-\n-/* end of m68k-psos.h */"}, {"sha": "c599cc514dd0a4af6e6eb6662bc7644f4ab87941", "filename": "gcc/config/m68k/mot3300.h", "status": "removed", "additions": 0, "deletions": 680, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fmot3300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmot3300.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,680 +0,0 @@\n-/* Definitions of target machine for GNU compiler,\n-   SysV68 Motorola 3300 Delta Series.\n-   Copyright (C) 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Abramo and Roberto Bagnara (bagnara@dipisa.di.unipi.it)\n-   based on Alex Crain's 3B1 definitions.\n-   Maintained by Philippe De Muyter (phdm@info.ucl.ac.be).\n-   Support for GAS added by merging mot3300g.h into this file by\n-   Manfred Hollstein (manfred@lts.sel.alcatel.de).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef USE_GAS\n-#define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n-#define MOTOROLA_BSR\t\t/* Use Span-dependent optimized bsr */\n-#define SGS\t\t\t/* Uses SGS assembler */\n-#define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n-#define SGS_SWAP_W\t\t/* Use swap.w rather than just plain swap */\n-#endif /* USE_GAS */\n-\n-#define NO_DOLLAR_IN_LABEL\n-#define NO_DOT_IN_LABEL\n-\n-#include \"m68k/m68k.h\"\n-\n-/* GDB expects a slightly different marker on this target.  */\n-#define STABS_GCC_MARKER \"gcc2_compiled%\"\n-\n-/* See m68k.h.  0407 means 68020-68040.  */\n-\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_68040|MASK_BITFIELD|MASK_68881|MASK_68020)\n-#endif\n-\n-/* -m[c]6800 requires special flag to the assembler.  */\n-\n-#undef ASM_SPEC\n-#ifndef USE_GAS\n-#define ASM_SPEC \"%{m68000:-p 000}%{mc68000:-p 000}\"\n-#else /* USE_GAS */\n-#define ASM_SPEC \\\n-  \"%{v:-v} %{m68000:-mc68000}%{mc68000:-mc68000}%{!mc68000:%{!m68000:-mc68020}}\"\n-#endif /* USE_GAS */\n-\n-/* NYI: FP= is equivalent to -msoft-float  */\n-\n-/* We use /lib/libp/lib* when profiling.  */\n-\n-/* NYI: if FP=M68881U library is -lc881u  */\n-/* NYI: if FP= library is -lc.  */\n-/* Default for us: FP=M68881 library is -lc881  */\n-#undef LIB_SPEC\n-#define LIB_SPEC \"%{!shlib:%{!msoft-float:-lc881}%{msoft-float:-lc}}\"\n-#ifdef CROSS_COMPILE\n-#ifndef USE_GLD\n-#define DEFAULT_A_OUT_NAME \"m68ka.out\"\n-#endif\n-#endif\n-\n-#ifdef USE_GLD\n-#undef LINK_SPEC\n-#define LINK_SPEC \"%{v:-v}\"\n-#endif /* defined (USE_GLD) */\n-\n-#define CPP_SPEC \"%{!msoft-float:-D__HAVE_68881__}\\\n-%{!mc68000:%{!m68000: -D__mc68020__}}\"\n-\n-/* Shared libraries need to use crt0s.o  */\n-\n-#undef STARTFILE_SPEC\n-#ifdef CROSS_COMPILE\n-#define STARTFILE_SPEC \\\n-  \"%{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n-   %{shlib:crt0s.o%s shlib.ifile%s} %{p:-L\"TOOLDIR_BASE_PREFIX DEFAULT_TARGET_MACHINE\"/lib/libp} %{pg:-L\"TOOLDIR_BASE_PREFIX DEFAULT_TARGET_MACHINE\"/lib/libp} \"\n-#else /* CROSS_COMPILE */\n-#define STARTFILE_SPEC \\\n-  \"%{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n-   %{shlib:crt0s.o%s shlib.ifile%s} %{p:-L/usr/lib/libp} %{pg:-L/usr/lib/libp} \"\n-#endif /* CROSS_COMPILE */\n-\n-/* Generate calls to memcpy, memcmp and memset.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n-/* size_t is unsigned int.  */\n-\n-#define SIZE_TYPE \"unsigned int\"\n-\n-/* We need POSIX/XOPEN symbols; otherwise building libio will fail.  */\n-#define ADD_MISSING_POSIX 1\n-#define ADD_MISSING_XOPEN 1\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* Follow sysV68 cc regarding alignment imposed by char:0; */\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-  \n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-/* Be compatible with native compiler.  */\n-#undef PARM_BOUNDARY\n-#define PARM_BOUNDARY 16\n-\n-/* Make output for SDB.  */\n-\n-#define SDB_DEBUGGING_INFO 1\n-\n-#undef REGISTER_PREFIX\n-#define REGISTER_PREFIX \"%\"\n-\n-#undef LOCAL_LABEL_PREFIX\n-#ifdef USE_GAS\n-#define LOCAL_LABEL_PREFIX \".L\"\n-#else\n-#define LOCAL_LABEL_PREFIX \"L%\"\n-#endif\n-\n-#undef USER_LABEL_PREFIX\n-\n-#undef IMMEDIATE_PREFIX\n-#define IMMEDIATE_PREFIX \"&\"\n-\n-#undef REGISTER_NAMES\n-#define REGISTER_NAMES \\\n-{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n- \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%fp\", \"%sp\",\t\\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\"}\n-\n-#undef FUNCTION_EXTRA_EPILOGUE\n-#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-{ if (current_function_returns_pointer\t\t\t\t\t\\\n-      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n-    asm_fprintf (FILE, \"\\tmov.l %Ra0,%Rd0\\n\"); }\n-\n-#undef FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n-    asm_fprintf (FILE, \"\\tmov.l %I%LLP%d,%Ra0\\n\\tjsr mcount%%\\n\", (LABEL_NO))\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#undef ASM_OUTPUT_REG_PUSH\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmov.l %s,-(%%sp)\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#undef ASM_OUTPUT_REG_POP\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\", reg_names[REGNO])\n-\n-#ifndef USE_GAS\n-\n-#undef ASM_APP_ON\n-#define ASM_APP_ON \"\"\n-\n-#undef ASM_APP_OFF\n-#define ASM_APP_OFF \"\"\n-\n-#undef TEXT_SECTION_ASM_OP\n-#define TEXT_SECTION_ASM_OP \"\\ttext\"\n-#undef DATA_SECTION_ASM_OP\n-#define DATA_SECTION_ASM_OP \"\\tdata\"\n-#undef ASCII_DATA_ASM_OP\n-#define\tASCII_DATA_ASM_OP \"\\tbyte\\t\"\n-\n-#undef SET_ASM_OP\n-#define SET_ASM_OP \"\\tset\\t\"\n-\n-#endif /* USE_GAS */\n-\n-#ifdef USE_GLD\n-/* Support the ctors and dtors sections for g++.  */\n-\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"x\\\"\"\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"x\\\"\"\n-#endif /* defined (USE_GLD) */\n-\n-/* The file command should always begin the output.  */\n-\n-#undef ASM_FILE_START\n-#ifndef USE_GAS\n-#define ASM_FILE_START(FILE) \\\n-  output_file_directive ((FILE), main_input_filename)\n-#else /* USE_GAS */\n-#define ASM_FILE_START(FILE) \\\n-    { \\\n-       fprintf (FILE, \"%s\", ASM_APP_OFF); \\\n-       output_file_directive ((FILE), main_input_filename); \\\n-    }\n-#endif /* USE_GAS */\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-/* ihnp4!lmayk!lgm@eddie.mit.edu says mc68000 and m68k should not be here,\n-   on the other hand I don't care what he says.  */\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dm68k -Dunix -DsysV68 -D__motorola__ -Asystem=unix -Asystem=svr3 -Acpu=m68k -Amachine=m68k\"\n-\n-#undef TARGET_VERSION\n-#ifndef USE_GAS\n-#define TARGET_VERSION fprintf (stderr, \" (68k, SGS/AT&T sysV68 syntax)\");\n-#endif /* USE_GAS */\n-\n-/* This will return small structs in d0.  */\n-#define RETURN_IN_MEMORY(type) \\\n-  ((TYPE_MODE (type) == BLKmode) \\\n-   || (AGGREGATE_TYPE_P (type) \\\n-       && GET_MODE_SIZE (TYPE_MODE (type)) > UNITS_PER_WORD))\n-\n-/* Don't default to pcc-struct-return, because we have already specified\n-   exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* If TARGET_68881, return SF and DF values in fp0 instead of d0.  */\n-/* NYI: If FP=M68881U return SF and DF values in d0.  */\n-/* NYI: If -mold return pointer in a0 and d0 */\n-\n-#undef FUNCTION_VALUE\n-/* sysV68 (brain damaged) cc convention support.  */\n-#define FUNCTION_VALUE(VALTYPE,FUNC) \\\n-  (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881 \t\\\n-   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16)\t\t\\\n-   : (POINTER_TYPE_P (VALTYPE)\t\t\t\t\\\n-      ? gen_rtx_REG (TYPE_MODE (VALTYPE), 8)\t\t\\\n-      : gen_rtx_REG (TYPE_MODE (VALTYPE), 0)))\n-\n-/* If TARGET_68881, SF and DF values are returned in fp0 instead of d0.  */\n-\n-/* Is LIBCALL_VALUE never called with a pointer ? */\n-#undef LIBCALL_VALUE\n-#define LIBCALL_VALUE(MODE)\t\t\t\t\t\\\n- gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n-\t      ((TARGET_68881\t\t\t\t\t\\\n-\t\t&& ((MODE) == SFmode || (MODE) == DFmode\t\\\n-\t\t    || (MODE) == XFmode))\t\t\t\\\n-\t       ? 16 : 0))\n-\n-/* 1 if N is a possible register number for a function value.\n-   d0 may be used, and fp0 as well if -msoft-float is not specified.  */\n-\n-#undef FUNCTION_VALUE_REGNO_P\n-/* sysV68 (brain damaged) cc convention support.  */\n-#define FUNCTION_VALUE_REGNO_P(N) \\\n- ((N) == 0 || (N) == 8 || (TARGET_68881 && (N) == 16))\n-\n-/* Define this to be true when FUNCTION_VALUE_REGNO_P is true for\n-   more than one register.  */\n-\n-#undef NEEDS_UNTYPED_CALL\n-#define NEEDS_UNTYPED_CALL 1\n- \n-#ifndef USE_GAS\n-/* This is the command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#undef GLOBAL_ASM_OP\n-#define GLOBAL_ASM_OP \"\\tglobal\\t\"\n-#endif /* USE_GAS */\n-\n-#define ASM_PN_FORMAT \"%s_%%%lu\"\n-\n-#undef INT_OP_GROUP\n-#ifdef USE_GAS\n-#define INT_OP_GROUP INT_OP_STANDARD\n-#else\n-#define INT_OP_GROUP INT_OP_NO_DOT\n-#endif\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#ifndef USE_GAS\n-#define ALIGN_ASM_OP\t\"\\teven\"\n-#else /* USE_GAS */\n-#define ALIGN_ASM_OP\t\"\\t.even\"\n-#endif /* USE_GAS */\n-\n-#undef ASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) >= 1)\t\t\t\\\n-    fprintf (FILE, \"%s\\n\", ALIGN_ASM_OP);\n-\n-#ifndef USE_GAS\n-#define SKIP_ASM_OP\t\"\\tspace\\t\"\n-#else /* USE_GAS */\n-#define SKIP_ASM_OP\t\"\\t.skip\\t\"\n-#endif /* USE_GAS */\n-\n-#undef ASM_OUTPUT_SKIP\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"%s%u\\n\", SKIP_ASM_OP, (int)(SIZE))\n-\n-/* Can't use ASM_OUTPUT_SKIP in text section.  */\n-\n-#define ASM_NO_SKIP_IN_TEXT 1\n-\n-/* The beginnings of sdb support...  */\n-\n-/* Undefining these will allow `output_file_directive' (in toplev.c)\n-   to default to the right thing.  */\n-#undef ASM_OUTPUT_MAIN_SOURCE_FILENAME\n-#ifndef USE_GAS\n-#define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME) \\\n-  do {\tfprintf (FILE, \"\\tfile\\t\");\t\t\\\n-\toutput_quoted_string (FILE, FILENAME);\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\\\n-  } while (0)\n-\n-#undef ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\t\\\n-  fprintf (FILE, \"\\tln\\t%d\\n\",\t\t\t\\\n-\t   (sdb_begin_function_line\t\t\\\n-\t    ? (LINENO) - sdb_begin_function_line : 1))\n-\n-/* Yet another null terminated string format.  */\n-\n-#undef ASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(FILE,PTR,LEN) \\\n-  do { register size_t sp = 0, lp = 0, limit = (LEN);\t\t\\\n-    fputs (integer_asm_op (1, TRUE), (FILE));\t\t\t\\\n-  loop:\t\t\t\t\t\t\t\t\\\n-    if ((PTR)[sp] > ' ' && ! ((PTR)[sp] & 0x80) && (PTR)[sp] != '\\\\')\t\\\n-      { lp += 3;\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"'%c\", (PTR)[sp]); }\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      { lp += 5;\t\t\t\t\t\t\\\n-\tfprintf ((FILE), \"0x%x\", (PTR)[sp]); }\t\t\t\\\n-    if (++sp < limit)\t\t\t\t\t\t\\\n-      {\tif (lp > 60)\t\t\t\t\t\t\\\n-\t  { lp = 0;\t\t\t\t\t\t\\\n-\t    fprintf ((FILE), \"\\n%s\", ASCII_DATA_ASM_OP); }\t\\\n-\telse\t\t\t\t\t\t\t\\\n-\t  putc (',', (FILE));\t\t\t\t\t\\\n-\tgoto loop; }\t\t\t\t\t\t\\\n-    putc ('\\n', (FILE)); } while (0)\n-#endif /* USE_GAS */\n-\n-#ifndef USE_GAS\n-/* Output a float value (represented as a C double) as an immediate operand.\n-   This macro is a 68k-specific macro.  */\n-\n-#undef ASM_OUTPUT_FLOAT_OPERAND\n-#define ASM_OUTPUT_FLOAT_OPERAND(CODE,FILE,VALUE)\t\t\t\\\n- do { long l;\t\t\t\t\t\t\t\t\\\n-      REAL_VALUE_TO_TARGET_SINGLE (r, l);\t\t\t\t\\\n-      /* Use hex representation even if CODE is f.  as needs it.  */\t\\\n-      fprintf ((FILE), \"&0x%lx\", l);\t\t\t\t\t\\\n-    } while (0)\n-\n-/* Output a double value (represented as a C double) as an immediate operand.\n-   This macro is a 68k-specific macro.  */\n-#undef ASM_OUTPUT_DOUBLE_OPERAND\n-#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n- do { long l[2];\t\t\t\t\t\t\t\\\n-      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n-      fprintf ((FILE), \"&0x%lx%08lx\", l[0], l[1]);\t\t\t\\\n-    } while (0)\n-#endif /* USE_GAS */\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n-  sprintf ((LABEL), \"%s%s%ld\", LOCAL_LABEL_PREFIX, (PREFIX), (long)(NUM))\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"\"\n-\n-/* This is how to output an element of a case-vector that is absolute.\n-   (The 68000 does not use such vectors,\n-   but we must define this macro anyway.)  */\n-/* The L after the local prefix is the \"L\" prefix for the normal labels\n-   generated by gcc; why are ASM_OUTPUT_ADDR_VEC_ELT and\n-   ASM_OUTPUT_ADDR_DIFF_ELT not called with a PREFIX parameter, like\n-   (*targetm.asm_out.internal_label) ? */\n-\n-#undef ASM_OUTPUT_ADDR_VEC_ELT\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\\\n-    asm_fprintf (FILE, \"%s%LL%d\\n\", integer_asm_op (4, TRUE), (VALUE))\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n-    asm_fprintf (FILE, \"\\t%s %LL%d-%LL%d\\n\",\t\t\t\\\n-\t\t integer_asm_op (2, TRUE), (VALUE), (REL))\n-\n-#ifndef USE_GAS\n-\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\t\\\n-    asm_fprintf (FILE, \"\\tswbeg &%d\\n%L%s%d:\\n\",\t\t\t\\\n-\t     XVECLEN (PATTERN (TABLE), 1), (PREFIX), (NUM))\n-\n-/* sysV68 as cannot handle LD%n(%pc,%reg) */ \n-#define SGS_NO_LI\n-\n-/* labelno is not used here */\n-#define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n-\tasm_fprintf (file, \"12(%Rpc,%s.\", regname)\n-\n-#define ASM_RETURN_CASE_JUMP\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    if (TARGET_5200)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tif (ADDRESS_REG_P (operands[0]))\t\t\\\n-\t  return \"jmp 8(%%pc,%0.l)\";\t\t\t\\\n-\telse\t\t\t\t\t\t\\\n-\t  return \"ext%.l %0\\n\\tjmp 8(%%pc,%0.l)\";\t\\\n-      }\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\\\n-      return \"jmp 8(%%pc,%0.w)\";\t\t\t\\\n-  } while (0)\n-\t     \n-#else /* USE_GAS */\n-\n-/* labelno is not used here */\n-#define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n-\tasm_fprintf (file, \"%Rpc@(6,%s:\", regname)\n-\n-#define ASM_RETURN_CASE_JUMP return \"jmp %%pc@(2,%0:w)\"\n-\n-#endif /* USE_GAS */\n-\n-#ifndef USE_GAS\n-\n-/* Translate some opcodes to fit the sysV68 assembler syntax.  */\n-/* The opcodes fdmov and fsmov are guesses.  */\n-\n-/* cliffm@netcom.com says no need for .w suffix on jumps.  */\n-#undef ASM_OUTPUT_OPCODE\n-#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n-{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n-    { ++(PTR);\t\t\t\t\t\t\\\n-      while (*(PTR) != ' ')\t\t\t\t\\\n-\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if ((PTR)[0] == 's')\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (!strncmp ((PTR), \"swap\", 4))\t\t\t\\\n-\t{ fprintf ((FILE), \"swap.w\"); (PTR) += 4; }\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if ((PTR)[0] == 'f')\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (!strncmp ((PTR), \"fmove\", 5))\t\t\t\\\n-\t{ fprintf ((FILE), \"fmov\"); (PTR) += 5; }\t\\\n-      else if (!strncmp ((PTR), \"f%$move\", 7))\t\t\\\n-\t{ if (TARGET_68040_ONLY)\t\t\t\\\n-\t    { fprintf ((FILE), \"fsmov\"); (PTR) += 7; }\t\\\n-\t  else\t\t\t\t\t\t\\\n-\t    { fprintf ((FILE), \"fmov\"); (PTR) += 7; } }\t\\\n-      else if (!strncmp ((PTR), \"f%&move\", 7))\t\t\\\n-\t{ if (TARGET_68040_ONLY)\t\t\t\\\n-\t    { fprintf ((FILE), \"fdmov\"); (PTR) += 7; }\t\\\n-\t  else\t\t\t\t\t\t\\\n-\t    { fprintf ((FILE), \"fmov\"); (PTR) += 7; } }\t\\\n-      else if (!strncmp ((PTR), \"ftst\", 4))\t\t\\\n-\t{ fprintf ((FILE), \"ftest\"); (PTR) += 4; }\t\\\n-      else if (!strncmp ((PTR), \"fbne\", 4))\t\t\\\n-\t{ fprintf ((FILE), \"fbneq\"); (PTR) += 4; }\t\\\n-      else if (!strncmp ((PTR), \"fsne\", 4))\t\t\\\n-\t{ fprintf ((FILE), \"fsneq\"); (PTR) += 4; }\t\\\n-    }\t\t\t\t\t\t\t\\\n-/* MOVE, MOVEA, MOVEQ, MOVEC ==> MOV\t*/\t\t\\\n-  else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n-\t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n-    { fprintf ((FILE), \"mov\"); (PTR) += 4;\t\t\\\n-       if ((PTR)[0] == 'q' || (PTR)[0] == 'a'\t\t\\\n-\t   || (PTR)[0] == 'c') (PTR)++; }\t\t\\\n-/* SUB, SUBQ, SUBA, SUBI ==> SUB */\t\t\t\\\n-  else if ((PTR)[0] == 's' && (PTR)[1] == 'u' \t\t\\\n-\t   && (PTR)[2] == 'b')\t\t\t\t\\\n-    { fprintf ((FILE), \"sub\"); (PTR) += 3;\t\t\\\n-       if ((PTR)[0] == 'q' || (PTR)[0] == 'i'\t \t\\\n-\t   || (PTR)[0] == 'a') (PTR)++; }\t\t\\\n-/* CMP, CMPA, CMPI, CMPM ==> CMP\t*/\t\t\\\n-  else if ((PTR)[0] == 'c' && (PTR)[1] == 'm'\t\t\\\n-\t   && (PTR)[2] == 'p')\t\t\t\t\\\n-    { fprintf ((FILE), \"cmp\"); (PTR) += 3;\t\t\\\n-       if ((PTR)[0] == 'a' || (PTR)[0] == 'i'\t \t\\\n-\t   || (PTR)[0] == 'm') (PTR)++; }\t\t\\\n-}\n-#endif /* USE_GAS */\n-\n-/* phdm@info.ucl.ac.be says to pass SIZE, not ROUNDED.  */\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#undef ASM_OUTPUT_COMMON\n-#ifndef USE_GAS\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\tcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (SIZE)))\n-#else /* USE_GAS */\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (SIZE)))\n-#endif /* USE_GAS */\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#undef ASM_OUTPUT_LOCAL\n-#ifndef USE_GAS\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\tlcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (int)(SIZE)))\n-#else /* USE_GAS */\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (int)(SIZE)))\n-#endif /* USE_GAS */\n-\n-#ifndef USE_GAS\n-/* Override usual definitions of SDB output macros.\n-   These definitions differ only in the absence of the period\n-   at the beginning of the name of the directive\n-   and in the use of `~' as the symbol for the current location.  */\n-\n-#define PUT_SDB_SCL(a) fprintf(asm_out_file, \"\\tscl\\t%d;\", (a))\n-#define PUT_SDB_INT_VAL(a) fprintf (asm_out_file, \"\\tval\\t%d;\", (a))\n-#define PUT_SDB_VAL(a)\t\t\t\t\\\n-( fputs (\"\\tval\\t\", asm_out_file),\t\t\\\n-  output_addr_const (asm_out_file, (a)),\t\\\n-  fputc (';', asm_out_file))\n-\n-#define PUT_SDB_DEF(a)\t\t\t\t\\\n-do { fprintf (asm_out_file, \"\\tdef\\t\");\t\\\n-     ASM_OUTPUT_LABELREF (asm_out_file, a); \t\\\n-     fprintf (asm_out_file, \";\"); } while (0)\n-\n-#define PUT_SDB_PLAIN_DEF(a) fprintf(asm_out_file,\"\\tdef\\t~%s;\",a)\n-#define PUT_SDB_ENDEF fputs(\"\\tendef\\n\", asm_out_file)\n-#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\ttype\\t0%o;\", a)\n-#define PUT_SDB_SIZE(a) fprintf(asm_out_file, \"\\tsize\\t%d;\", a)\n-#define PUT_SDB_START_DIM fprintf(asm_out_file, \"\\tdim\\t\")\n-#define PUT_SDB_NEXT_DIM(a) fprintf(asm_out_file, \"%d,\", a)\n-#define PUT_SDB_LAST_DIM(a) fprintf(asm_out_file, \"%d;\", a)\n-\n-#define PUT_SDB_TAG(a)\t\t\t\t\\\n-do { fprintf (asm_out_file, \"\\ttag\\t\");\t\\\n-     ASM_OUTPUT_LABELREF (asm_out_file, a);\t\\\n-     fprintf (asm_out_file, \";\"); } while (0)\n-\n-#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~bb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~eb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~bf;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~ef;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_EPILOGUE_END(NAME)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t%s;\\tval\\t~;\\tscl\\t-1;\\tendef\\n\",\t\\\n-\t   (NAME))\n-\n-#define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n-  sprintf ((BUFFER), \"~%dfake\", (NUMBER));\n-\n-#endif /* USE_GAS */\n-\n-/* Define subroutines to call to handle multiply, divide, and remainder.\n-   Use the subroutines that the sysV68's library provides.\n-   The `*' prevents an underscore from being prepended by the compiler.  */\n-/* The '*' is also used by INIT_CUMULATIVE_ARGS */\n-\n-#define DIVSI3_LIBCALL \"*ldiv%%\"\n-#define UDIVSI3_LIBCALL \"*uldiv%%\"\n-#define MODSI3_LIBCALL \"*lrem%%\"\n-#define UMODSI3_LIBCALL \"*ulrem%%\"\n-#define MULSI3_LIBCALL \"*lmul%%\"\n-\n-struct sysV68_cumulative_args\n-\t{\n-\tint\toffset;\n-\tint\tlibcall;\n-\t};\n-\n-#undef CUMULATIVE_ARGS\n-#define CUMULATIVE_ARGS struct sysV68_cumulative_args\n-\n-#undef INIT_CUMULATIVE_ARGS\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n-do {(CUM).offset = 0;\\\n-(CUM).libcall = (LIBNAME) && (*XSTR((LIBNAME), 0) == '*');} while(0)\n-\n-#undef FUNCTION_ARG_ADVANCE\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM).offset += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n-\n-#undef FUNCTION_ARG\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-(((CUM).libcall && (CUM).offset == 0) ? gen_rtx_REG ((MODE), 0)\\\n-: (TARGET_REGPARM && (CUM).offset < 8) ? gen_rtx_REG ((MODE), (CUM).offset / 4) : 0)\n-\n-#undef FUNCTION_ARG_PARTIAL_NREGS\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM).offset < 8\t\t\t\t\\\n-  && 8 < ((CUM).offset + ((MODE) == BLKmode\t\t\t\\\n-\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n-\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n- ? 2 - (CUM).offset / 4 : 0)\n-\n-#undef FUNCTION_ARG_REGNO_P\n-#define FUNCTION_ARG_REGNO_P(N) (TARGET_68020 ? 0 : (N) == 0)\n-\n-/* manfred@lts.sel.alcatel.de: I believe that most delta machines are configured to have\n-   a 6888[12] FPU for which we need to link -lm881 instead of -lm; define ALT_LIBM to\n-   tell g++.c about that.  */\n-#define ALT_LIBM\t\"-lm881\"\n-\n-#if (TARGET_DEFAULT & MASK_68881)      /* The default configuration has a 6888[12] FPU.  */\n-#define MATH_LIBRARY\t\"-lm881\"\n-#endif\n-\n-/* Currently we do not have the atexit() function,\n-   so take that from libgcc2.c */\n-\n-#define NEED_ATEXIT 1\n-\n-#define EXIT_BODY\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    { \t\t\t\t\t\t\t\t\\\n-      __stop_monitor ();\t\t\t\t\t\\\n-      _cleanup ();\t\t\t\t\t\t\\\n-    } while (0)\n-\n-/* FINALIZE_TRAMPOLINE clears the instruction cache.  */\n-\n-#undef FINALIZE_TRAMPOLINE\n-#define FINALIZE_TRAMPOLINE(TRAMP)\t\\\n-  if (!TARGET_68040)\t\t\t\\\n-    ;\t\t\t\t\t\\\n-  else\t\t\t\t\t\\\n-    emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__clear_insn_cache\"), \\\n-\t\t       0, VOIDmode, 0)"}, {"sha": "68c8d09ead591ea36880f745840fe693c45cefc9", "filename": "gcc/config/m68k/pbb.h", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fpbb.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fpbb.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpbb.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,163 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Citicorp/TTI Unicom PBB version (using GAS with a %-register prefix)\n-   Copyright (C) 1987, 1988, 1990, 1996, 1997, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Note:   This config uses a version of gas with a postprocessing stage that\n-   converts the output of gas to coff containing stab debug symbols.\n-   (See vasta@apollo.com or mb@soldev.tti.com) */\n-\n-#include \"m68k/m68k.h\"\n-\n-/* See m68k.h.  5 means 68020 without 68881.  */\n-\n-#define TARGET_DEFAULT (MASK_BITFIELD|MASK_68020)\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* Define __HAVE_68881__ in preprocessor if -m68881 is specified.\n-   This will control the use of inline 68881 insns in certain macros.  */\n-\n-#define CPP_SPEC \"%{m68881:-D__HAVE_68881__}\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dm68k -Dunix -DUnicomPBB -Dmc68k -Dmc68020 -Dmc68k32 -Asystem=unix  -Acpu=m68k -Amachine=m68k\"\n-\n-/* We want DBX format for use with gdb under COFF.  */\n-\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Generate calls to memcpy, memcmp and memset.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n-/* -m68000 requires special flags to the assembler.  */\n-\n-#define ASM_SPEC \\\n- \" %{m68000:-mc68010}%{mc68000:-mc68010}\"\n-\n-/* we use /lib/libp/lib*  when profiling */\n-\n-#define LIB_SPEC \"%{p:-L/usr/lib/libp} %{pg:-L/usr/lib/libp} -lc\"\n-\n-\n-/* Use crt1.o as a startup file and crtn.o as a closing file.  */\n-/*\n- * The loader directive file gcc.ifile defines how to merge the constructor \n- * sections into the data section.  Also, since gas only puts out those \n- * sections in response to N_SETT stabs, and does not (yet) have a \n- * \".sections\" directive, gcc.ifile also defines the list symbols \n- * __DTOR_LIST__ and __CTOR_LIST__.\n- * \n- * Finally, we must explicitly specify the file from libgcc.a that defines\n- * exit(), otherwise if the user specifies (for example) \"-lc_s\" on the \n- * command line, the wrong exit() will be used and global destructors will \n- * not get called .\n- */\n-\n-#define STARTFILE_SPEC \\\n-\"%{!r: gcc.ifile%s} %{pg:gcrt1.o%s}%{!pg:%{p:mcrt1.o%s}%{!p:crt1.o%s}} \\\n-%{!r:_exit.o%s}\"\n-\n-#define ENDFILE_SPEC \"crtn.o%s\"\n-\n-/* GAS register prefix assembly syntax: */\n-\n-/* User labels have no prefix */\n-#undef  USER_LABEL_PREFIX \n-#define USER_LABEL_PREFIX \"\"\n-\n-/* local labels are prefixed with \".L\" */\n-#undef  LOCAL_LABEL_PREFIX\n-#define LOCAL_LABEL_PREFIX \".\"\n-\n-/* registers are prefixed with \"%\" */\n-#undef  REGISTER_PREFIX\n-#define REGISTER_PREFIX \"%\"\n-\n-#undef REGISTER_NAMES\n-#define REGISTER_NAMES \\\n-{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n- \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\",\t\\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\"}\n-\n-#undef FUNCTION_EXTRA_EPILOGUE\n-#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-{ if (current_function_returns_pointer\t\t\t\t\t\\\n-      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n-      asm_fprintf (FILE, \"\\tmovl %Rd0,%Ra0\\n\"); } \n-\n-#define ASM_RETURN_CASE_JUMP\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    if (TARGET_5200)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tif (ADDRESS_REG_P (operands[0]))\t\t\\\n-\t  return \"jmp %%pc@(2,%0:l)\";\t\t\t\\\n-\telse\t\t\t\t\t\t\\\n-\t  return \"ext%.l %0\\n\\tjmp %%pc@(2,%0:l)\";\t\\\n-      }\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\\\n-      return \"jmp %%pc@(2,%0:w)\";\t\t\t\\\n-  } while (0)\n-\n-/* Although the gas we use can create .ctor and .dtor sections from N_SETT\n-   stabs, it does not support section directives, so we need to have the loader\n-   define the lists.\n- */\n-#define CTOR_LISTS_DEFINED_EXTERNALLY\n-\n-/* similar to default, but allows for the table defined by ld with gcc.ifile. \n-   nptrs is always 0.  So we need to instead check that __DTOR_LIST__[1] != 0.\n-   The old check is left in so that the same macro can be used if and when  \n-   a future version of gas does support section directives.  */\n-\n-#define DO_GLOBAL_DTORS_BODY {int nptrs = *(int *)__DTOR_LIST__; int i; \\\n-  if (nptrs == -1 || (__DTOR_LIST__[0] == 0 && __DTOR_LIST__[1] != 0))  \\\n-    for (nptrs = 0; __DTOR_LIST__[nptrs + 1] != 0; nptrs++); \t\t\\\n-  for (i = nptrs; i >= 1; i--)\t\t\t\t\t\t\\\n-    __DTOR_LIST__[i] (); }\n-\n-/* \n- * Here is an example gcc.ifile.  I've tested it on PBB 68k and on sco 386\n- * systems. The NEXT(0x200000) works on just about all 386 and m68k systems, \n- * but can be reduced to any power of 2 that is >= NBPS (0x10000 on a pbb).\n-\n-   SECTIONS {\n-       .text BIND(0x200200) BLOCK (0x200) : \n-\t\t{ *(.init) *(.text) vfork = fork; *(.fini) }\n-\n-      \tGROUP BIND( NEXT(0x200000) + ADDR(.text) + SIZEOF(.text)):\n-\t{      .data : { __CTOR_LIST__ = . ; . += 4; *(.ctor) . += 4 ;\n-\t\t       \t __DTOR_LIST__ = . ; . += 4; *(.dtor) . += 4 ; }\n-\t       .bss : { }\n-       }\n-  }\n- */\n-\n-/*\n-Local variables:\n-version-control: t\n-End:\n-*/"}, {"sha": "0fac3e29dc78673406c76b6541c4db71b2834ebd", "filename": "gcc/config/m68k/plexus.h", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fplexus.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fplexus.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fplexus.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,106 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for 680X0 based Plexus\n-   Computers running SYSVR2\n-   Copyright (C) 1990, 1994, 1996 Free Software Foundation, Inc.\n-   Contributed by Randy Welch (rwelch@netcom.com).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* The Plexus port of gcc requires you to use gas ( either 1.3X with COFF \n-   patches or 2.X ),  If you use gas 2.X you have to use binutils-2.X.\n-      \n-   With using gas-2.X the Plexus gcc port is now capable of generating\n-   output suitable for use by gdb-4.X ( send mail to above address for\n-   info on getting gdb patches or other GNU items for the Plexus )\n-\n-   This is configured for label output default by gas as LXXX instead of\n-   plexus cc/as combination requires .LXXX  */\n-\n-#include \"m68k/m68k.h\"\n-\n-/* Define __HAVE_68881 in preprocessor only if -m68881 is specified.\n-   This will control the use of inline 68881 insns in certain macros.  */\n-\n-#define TARGET_DEFAULT (MASK_BITFIELD|MASK_68020)\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-#define CPP_SPEC \"%{m68881:-D__HAVE_68881__}\"\n-#define CPP_PREDEFINES \"-Dm68 -Dunix -Dplexus -Asystem=unix  -Acpu=m68k -Amachine=m68k\"\n-\n-#if TARGET_DEFAULT & MASK_68020\n-#define ASM_SPEC \\\n-\"%{m68000:-mc68000}%{mc68000:-mc68000}%{!mc68000:%{!m68000:-mc68020}}\"\n-#undef STRICT_ALIGNMENT\n-#define STRICT_ALIGNMENT 0\n-#else\n-#define ASM_SPEC\\\n-\"%{m68020:-mc68020}%{mc68020:-mc68020}%{!mc68020:%{!mc68020:-mc68000}}\"\n-#endif\n-\n-/***************************************************************************/\n-/*  Un comment the following if you want adb to be able to follow a core   */\n-/*  file if you compile a program with -O                                  */\n-/***************************************************************************/\n-/* #define FRAME_POINTER_REQUIRED */\n-\n-/* Let's be compatible with the Plexus C compiler by default.  Why not?  */\n-#define PLEXUS_CC_COMPAT\n-\n-#ifdef PLEXUS_CC_COMPAT\n-#define STRUCTURE_SIZE_BOUNDARY 16\t/* for compatibility with cc */\n-#undef STACK_BOUNDARY\n-#define STACK_BOUNDARY 32\t\t/* ditto */\n-#endif\n-\n-#undef NEED_PROBE\n-#define NEED_PROBE -132\t\t\t/* plexus needs a stack probe */\n-\n-/***********************************************************************/\n-/* if you have binutils-2.X and gas-2.X running you can generate code  */\n-/* that gdb can understand ( gdb support available for 4.11 )          */\n-/*                                                                     */\n-/* If you use gas-1.3X don't define this as the version of the coff    */\n-/* patches for gas-1.3x ( stabs in coff ) does not generate coff debug */\n-/* syms                                                                */\n-/***********************************************************************/\n-#define HAVE_GAS_2_X\n-\n-#ifdef HAVE_GAS_2_X\n-#undef DBX_DEBUGGING_INFO\n-#define SDB_DEBUGGING_INFO 1\n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE) \\\n-  output_file_directive((FILE), main_input_filename)\n-\n-#else\n-#undef DBX_DEBUGGING_INFO\t\t/* no real debugger */\n-#undef SDB_DEBUGGING_INFO\n-#endif\n-#define TARGET_MEM_FUNCTIONS\n-\n-/***********************************************************************/\n-/*                          items for collect2                         */\n-/***********************************************************************/\n-\n-#define NM_FLAGS \"\"\n-\n-#define SIZE_TYPE \"int\""}, {"sha": "0f3dde3aeee5185bac6e3c335301bbda4aa2c4c3", "filename": "gcc/config/m68k/sun2.h", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun2.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,77 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Sun 68010 version.\n-   Copyright (C) 1987, 1988, 1995 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"m68k/m68k.h\"\n-\n-/* See m68k.h.  0 means 68000 with no 68881.  */\n-\n-#define TARGET_DEFAULT 0\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-/* Define __HAVE_68881 in preprocessor only if -m68881 is specified.\n-   This will control the use of inline 68881 insns in certain macros.\n-   Also inform the program which CPU this is for.  */\n-\n-#define CPP_SPEC \"%{m68881:-D__HAVE_68881__} \\\n-%{!ansi:%{m68020:-Dmc68020}%{mc68020:-Dmc68020}%{!mc68020:%{!m68020:-Dmc68010}}}\"\n-\n-/* -m68020 requires special flags to the assembler.  */\n-\n-#define ASM_SPEC \\\n- \"%{m68020:-mc68020}%{mc68020:-mc68020}%{!mc68020:%{!m68020:-mc68010}} \\\n-  %{fpic:-k} %{fPIC:-k} %{R} %{j} %{J} %{h} %{d2} %{keep-local-as-symbols:-L}\"\n-  \n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dmc68000 -Dsun -Dunix -Asystem=unix  -Asystem=bsd -Acpu=m68k -Amachine=m68k\"\n-\n-/* Prevent error on `-sun2' and `-target sun2' options.  */\n-\n-#define CC1_SPEC \"%{sun2:} %{target:}\"\n-\n-/* These compiler options take an argument.  We ignore -target for now.  */\n-\n-#define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\t\\\n- (DEFAULT_WORD_SWITCH_TAKES_ARG (STR)\t\t\t\t\\\n-  || !strcmp (STR, \"target\") || !strcmp (STR, \"assert\"))\n-\n-/* Specify what to link with.  */\n-\n-/* Link with libg.a when debugging, for dbx's sake.  */\n-/* Include the support for -a when appropriate.  */\n-#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n-%{a:/usr/lib/bb_link.o -lc} \"\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-\n-#undef EMPTY_FIELD_BOUNDARY\n-#define EMPTY_FIELD_BOUNDARY 16\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* This is BSD, so it wants DBX format.  */\n-\n-#define DBX_DEBUGGING_INFO 1"}, {"sha": "0601bd07f84c949a4c9a3d9a959da6ecbe5b6520", "filename": "gcc/config/m68k/sun2o4.h", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun2o4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun2o4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun2o4.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,147 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Sun 2 running SunOS 4.\n-   Copyright (C) 1987, 1988, 1993, 1996, 1997 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"m68k/sun2.h\"\n-\n-\n-/* Define __HAVE_SKY__ in preprocessor, according to the -m flags.\n-   Also inform the program which CPU this is for.  */\n-\n-#undef CPP_SPEC\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"int\"\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"short unsigned int\"\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 16\n-\n-#if TARGET_DEFAULT & MASK_SKY\n-\n-/* -msky is the default */\n-#define CPP_SPEC \\\n-\"%{!msoft-float:-D__HAVE_SKY__}\\\n-%{!ansi:%{m68020:-Dmc68020}%{mc68020:-Dmc68020}%{!mc68020:%{!m68020:-Dmc68010}}}\"\n-\n-#else\n-\n-/* -msoft-float is the default */\n-#define CPP_SPEC \\\n-\"%{msky:-D__HAVE_SKY__ }\\\n-%{!ansi:%{m68020:-Dmc68020}%{mc68020:-Dmc68020}%{!mc68020:%{!m68020:-Dmc68010}}}\"\n-\n-#endif\n-\n-/* STARTFILE_SPEC to include sun floating point initialization\n-   This is necessary (tr: Sun does it) for the sky routines.\n-   I'm not sure what would happen below if people gave contradictory\n-   arguments (eg. -msoft-float -mfpa) */\n-\n-#undef STARTFILE_SPEC\n-\n-#if TARGET_DEFAULT & MASK_SKY\n-/* -msky is the default */\n-#define STARTFILE_SPEC\t\t\t\t\t\\\n-  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n-   %{msoft-float:Fcrt1.o%s}\t\t\t\t\\\n-   %{!msoft-float:Scrt1.o%s}\"\n-#else\n-/* -msoft-float is the default */\n-#define STARTFILE_SPEC\t\t\t\t\t\\\n-  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n-   %{msky:Scrt1.o%s}\t\t\t\t\t\\\n-   %{!msky:Fcrt1.o%s}\"\n-#endif\n-\n-/* Specify library to handle `-a' basic block profiling.\n-   Control choice of libm.a (if user says -lm)\n-   based on fp arith default and options.  */\n-\n-#undef LIB_SPEC\n-\n-#if TARGET_DEFAULT & MASK_SKY\n-/* -msky is the default */\n-#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n-%{a:/usr/lib/bb_link.o -lc} %{g:-lg} \\\n-%{msoft-float:-L/usr/lib/fsoft} \\\n-%{!msoft_float:-L/usr/lib/fsky}\"\n-#else\n-/* -msoft-float is the default */\n-#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n-%{a:/usr/lib/bb_link.o -lc} %{g:-lg} \\\n-%{!msky:-L/usr/lib/fsoft} \\\n-%{msky:-L/usr/lib/ffpa}\"\n-#endif\n-\n-#undef LINK_SPEC\n-#define LINK_SPEC \\\n-  \"%{!nostdlib:%{!r*:%{!e*:-e start}}} -dc -dp %{static:-Bstatic}\"\n-\n-#undef ASM_OUTPUT_FLOAT_OPERAND\n-#define ASM_OUTPUT_FLOAT_OPERAND(CODE,FILE,VALUE)\t\t\\\n- do { \t\t\t\t\t\t\t\t\\\n-      if (CODE != 'f')\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          long l;\t\t\t\t\t\t\\\n-          REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n-          if (sizeof (int) == sizeof (long))\t\t\t\\\n-            asm_fprintf ((FILE), \"%I0x%x\", (int) l);\t\t\\\n-          else\t\t\t\t\t\t\t\\\n-            asm_fprintf ((FILE), \"%I0x%lx\", l);\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      else if (REAL_VALUE_ISINF (VALUE))\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          if (REAL_VALUE_NEGATIVE (VALUE))\t\t\t\\\n-            fprintf (FILE, \"#0r-99e999\");\t\t\t\\\n-          else\t\t\t\t\t\t\t\\\n-            fprintf (FILE, \"#0r99e999\");\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      else if (REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          fprintf (FILE, \"#0r-0.0\");\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-        { char dstr[30];\t\t\t\t\t\\\n-\t  real_to_decimal (dstr, &(VALUE), sizeof (dstr), 9, 0); \\\n-          fprintf (FILE, \"#0r%s\", dstr);\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-    } while (0)\n-\n-#undef ASM_OUTPUT_DOUBLE_OPERAND\n-#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n- do { if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          if (REAL_VALUE_NEGATIVE (VALUE))\t\t\t\t\\\n-            fprintf (FILE, \"#0r-99e999\");\t\t\t\t\\\n-          else\t\t\t\t\t\t\t\t\\\n-            fprintf (FILE, \"#0r99e999\");\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      else if (REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          fprintf (FILE, \"#0r-0.0\");\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        { char dstr[30];\t\t\t\t\t\t\\\n-\t  real_to_decimal (dstr, &(VALUE), sizeof (dstr), 0, 1);\t\\\n-          fprintf (FILE, \"#0r%s\", dstr);\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-    } while (0)"}, {"sha": "1d64599f332c5839c2448738e30a78451c12539e", "filename": "gcc/config/m68k/sun3.h", "status": "removed", "additions": 0, "deletions": 234, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,234 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Sun 68000/68020 version.\n-   Copyright (C) 1987, 1988, 1993, 1995, 1996, 1998, 1999\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This comment is here to see if it will keep Sun's cpp from dying.  */\n-\n-/* If you do not need to generate floating point code for the optional\n-   Sun FPA board, you can safely comment out the SUPPORT_SUN_FPA define\n-   to gain a little speed and code size.  */\n-\n-#define SUPPORT_SUN_FPA\n-\n-#include \"m68k/m68k.h\"\n-\n-/* See m68k.h.  7 means 68020 with 68881.  */\n-\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_BITFIELD|MASK_68881|MASK_68020)\n-#endif\n-\n-/* Define __HAVE_FPA__ or __HAVE_68881__ in preprocessor,\n-   according to the -m flags.\n-   This will control the use of inline 68881 insns in certain macros.\n-   Also inform the program which CPU this is for.  */\n-\n-#if TARGET_DEFAULT & MASK_68881\n-\n-/* -m68881 is the default */\n-#define CPP_SPEC \\\n-\"%{!msoft-float:%{mfpa:-D__HAVE_FPA__ }%{!mfpa:-D__HAVE_68881__ }}\\\n-%{m68000:-D__mc68010__}%{mc68000:-D__mc68010__}%{!mc68000:%{!m68000:-D__mc68020__}} \\\n-%{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n-\n-#else\n-\n-/* -msoft-float is the default */\n-#define CPP_SPEC \\\n-\"%{m68881:-D__HAVE_68881__ }%{mfpa:-D__HAVE_FPA__ }\\\n-%{m68000:-D__mc68010__}%{mc68000:-D__mc68010__}%{!mc68000:%{!m68000:-D__mc68020__}} \\\n-%{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n-\n-#endif\n-\n-/* Prevent error on `-sun3' and `-target sun3' options.  */\n-\n-#define CC1_SPEC \"%{sun3:} %{target:}\"\n-\n-#define PTRDIFF_TYPE \"int\"\n-\n-/* We must override m68k.h.  */\n-#undef WCHAR_TYPE\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE \"short unsigned int\"\n-#define WCHAR_TYPE_SIZE 16\n-\n-/* These compiler options take an argument.  We ignore -target for now.  */\n-\n-#define WORD_SWITCH_TAKES_ARG(STR)\t\t\t\t\\\n- (DEFAULT_WORD_SWITCH_TAKES_ARG (STR)\t\t\t\t\\\n-  || !strcmp (STR, \"target\") || !strcmp (STR, \"assert\"))\n-\n-/* -m68000 requires special flags to the assembler.  */\n-\n-#define ASM_SPEC \\\n- \"%{m68000:-mc68010}%{mc68000:-mc68010}%{!mc68000:%{!m68000:-mc68020}} \\\n-  %{fpic:-k} %{fPIC:-k} %{R} %{j} %{J} %{h} %{d2} %{keep-local-as-symbols:-L}\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-/* For a while,  -D_CROSS_TARGET_ARCH=SUN3 was included here,\n-   but it doesn't work, partly because SUN3 etc. aren't defined\n-   (and shouldn't be).  It seems that on a native compiler _CROSS_TARGET_ARCH\n-   should not be defined.  For cross compilers, let's do things as we\n-   normally do in GCC.  -- rms.  */\n-\n-#define CPP_PREDEFINES \"-Dmc68000 -Dsun -Dunix -Asystem=unix  -Asystem=bsd -Acpu=m68k -Amachine=m68k\"\n-\n-/* STARTFILE_SPEC to include sun floating point initialization\n-   This is necessary (tr: Sun does it) for both the m68881 and the fpa\n-   routines.\n-   Note that includes knowledge of the default specs for gcc, ie. no\n-   args translates to the same effect as -m68881\n-   I'm not sure what would happen below if people gave contradictory\n-   arguments (eg. -msoft-float -mfpa) */\n-\n-#if TARGET_DEFAULT & MASK_FPA\n-/* -mfpa is the default */\n-#define STARTFILE_SPEC\t\t\t\t\t\\\n-  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n-   %{m68881:Mcrt1.o%s}\t\t\t\t\t\\\n-   %{msoft-float:Fcrt1.o%s}\t\t\t\t\\\n-   %{!m68881:%{!msoft-float:Wcrt1.o%s}}\"\n-#else\n-#if TARGET_DEFAULT & MASK_68881\n-/* -m68881 is the default */\n-#define STARTFILE_SPEC\t\t\t\t\t\\\n-  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n-   %{mfpa:Wcrt1.o%s}\t\t\t\t\t\\\n-   %{msoft-float:Fcrt1.o%s}\t\t\t\t\\\n-   %{!mfpa:%{!msoft-float:Mcrt1.o%s}}\"\n-#else\n-/* -msoft-float is the default */\n-#define STARTFILE_SPEC\t\t\t\t\t\\\n-  \"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}\t\\\n-   %{m68881:Mcrt1.o%s}\t\t\t\t\t\\\n-   %{mfpa:Wcrt1.o%s}\t\t\t\t\t\\\n-   %{!m68881:%{!mfpa:Fcrt1.o%s}}\"\n-#endif\n-#endif\n-\n-/* Specify library to handle `-a' basic block profiling.\n-   Control choice of libm.a (if user says -lm)\n-   based on fp arith default and options.  */\n-\n-#if TARGET_DEFAULT & MASK_FPA\n-/* -mfpa is the default */\n-#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n-%{g:-lg} \\\n-%{msoft-float:-L/usr/lib/fsoft}%{m68881:-L/usr/lib/f68881}\\\n-%{!msoft_float:%{!m68881:-L/usr/lib/ffpa}}\"\n-#else\n-#if TARGET_DEFAULT & MASK_68881\n-/* -m68881 is the default */\n-#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n-%{g:-lg} \\\n-%{msoft-float:-L/usr/lib/fsoft}%{!msoft-float:%{!mfpa:-L/usr/lib/f68881}}\\\n-%{mfpa:-L/usr/lib/ffpa}\"\n-#else\n-/* -msoft-float is the default */\n-#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \\\n-%{g:-lg} \\\n-%{!m68881:%{!mfpa:-L/usr/lib/fsoft}}%{m68881:-L/usr/lib/f68881}\\\n-%{mfpa:-L/usr/lib/ffpa}\"\n-#endif\n-#endif\n-\n-/* Provide required defaults for linker -e and -d switches.  */\n-\n-#define LINK_SPEC \\\n- \"%{!nostdlib:%{!r*:%{!e*:-e start}}} -dc -dp %{static:-Bstatic} %{assert*}\"\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* This is BSD, so it wants DBX format.  */\n-\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Generate calls to memcpy, memcmp and memset.  */\n-#define TARGET_MEM_FUNCTIONS\n-\n-/* This is not a good idea.  It prevents interoperation between\n-   files compiled with -m68881 and those compiled with -msoft-float.  */\n-#if 0\n-#define FUNCTION_VALUEX(MODE)\t\t\t\t\t\\\n-  gen_rtx_REG ((MODE),\t\t\t\t\t\t\\\n-\t       ((TARGET_68881\t\t\t\t\t\\\n-\t\t && ((MODE) == SFmode || (MODE) == DFmode\t\\\n-\t\t     || (MODE) == XFmode))\t\t\t\\\n-\t\t? 16 : 0))\n-\n-#undef FUNCTION_VALUE\n-#define FUNCTION_VALUE(VALTYPE,FUNC) FUNCTION_VALUEX (TYPE_MODE (VALTYPE))\n-#endif /* 0 */\n-\n-/* This is how to output an assembler lines defining floating operands.\n-   There's no way to output a NaN's fraction, so we lose it.  */\n-  \n-#undef ASM_OUTPUT_FLOAT_OPERAND\n-#define ASM_OUTPUT_FLOAT_OPERAND(CODE,FILE,VALUE)\t\t\\\n- do { \t\t\t\t\t\t\t\t\\\n-      if (CODE != 'f')\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          long l;\t\t\t\t\t\t\\\n-          REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n-          if (sizeof (int) == sizeof (long))\t\t\t\\\n-            asm_fprintf ((FILE), \"%I0x%x\", (int) l);\t\t\\\n-          else\t\t\t\t\t\t\t\\\n-            asm_fprintf ((FILE), \"%I0x%lx\", l);\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      else if (REAL_VALUE_ISINF (VALUE))\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          if (REAL_VALUE_NEGATIVE (VALUE))\t\t\t\\\n-            asm_fprintf (FILE, \"%I0r-99e999\");\t\t\t\\\n-          else\t\t\t\t\t\t\t\\\n-            asm_fprintf (FILE, \"%I0r99e999\");\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      else if (REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          asm_fprintf (FILE, \"%I0r-0.0\");\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-        { char dstr[30];\t\t\t\t\t\\\n-\t  real_to_decimal (dstr, &(VALUE), sizeof (dstr), 9, 0); \\\n-          asm_fprintf (FILE, \"%I0r%s\", dstr);\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-    } while (0)\n-\n-#undef ASM_OUTPUT_DOUBLE_OPERAND\n-#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n- do { if (REAL_VALUE_ISINF (VALUE))\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          if (REAL_VALUE_NEGATIVE (VALUE))\t\t\t\t\\\n-            asm_fprintf (FILE, \"%I0r-99e999\");\t\t\t\t\\\n-          else\t\t\t\t\t\t\t\t\\\n-            asm_fprintf (FILE, \"%I0r99e999\");\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      else if (REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          asm_fprintf (FILE, \"%I0r-0.0\");\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        { char dstr[30];\t\t\t\t\t\t\\\n-\t  real_to_decimal (dstr, &(VALUE), sizeof (dstr), 0, 1);\t\\\n-          asm_fprintf (FILE, \"%I0r%s\", dstr);\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-    } while (0)"}, {"sha": "6769cfa096d1044188e7c06e784c33675b82fe56", "filename": "gcc/config/m68k/sun3mach.h", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3mach.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3mach.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3mach.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,15 +0,0 @@\n-#include \"m68k/sun3.h\"\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dmc68000 -Dsun -Dsun3 -Dunix -DMACH -DCMU -DMTXINU -DBIT_MSF -DBYTE_MSF -Asystem=unix  -Asystem=mach -Acpu=m68k -Amachine=m68k\"\n-\n-/* Specify extra dir to search for include files.  */\n-#define SYSTEM_INCLUDE_DIR \"/usr/mach/include\"\n-\n-/* LINK_SPEC is needed only for SunOS 4.  */\n-\n-#undef LINK_SPEC\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n-   we want to retain compatibility with older gcc versions.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0"}, {"sha": "32f5f657dc0ecd6a4898d504a054296b36f5631c", "filename": "gcc/config/m68k/sun3n.h", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3n.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3n.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3n.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,9 +0,0 @@\n-/* Define target machine as a Sun 3 with no 68881.  */\n-\n-#define TARGET_DEFAULT (MASK_BITFIELD|MASK_68020)\n-\n-#include \"m68k/sun3.h\"\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64"}, {"sha": "38680d805e2fcb237433e409f3dabb6f429bbd73", "filename": "gcc/config/m68k/sun3n3.h", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3n3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3n3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3n3.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,5 +0,0 @@\n-#include \"m68k/sun3n.h\"\n-\n-/* LINK_SPEC is needed only for SunOS 4.  */\n-\n-#undef LINK_SPEC"}, {"sha": "95f1ff65d03f42ce5dd48593ff346e8d2da39d0a", "filename": "gcc/config/m68k/sun3o3.h", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3o3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Fsun3o3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3o3.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,5 +0,0 @@\n-#include \"m68k/sun3.h\"\n-\n-/* LINK_SPEC is needed only for SunOS 4.  */\n-\n-#undef LINK_SPEC"}, {"sha": "2fc11858d58296f9832e3f5b5057f5c469eaa6cd", "filename": "gcc/config/m68k/t-mot3300", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ft-mot3300", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ft-mot3300", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-mot3300?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,10 +0,0 @@\n-MULTILIB_OPTIONS=m68000/m68020 msoft-float\n-MULTILIB_DIRNAMES=\n-MULTILIB_MATCHES=m68000=mc68000 m68000=m68302 m68000=m68332 m68020=mc68020 m68020=m68040\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-CRT0_S = $(srcdir)/config/m68k/mot3300-crt0.S\n-MCRT0_S = $(srcdir)/config/m68k/mot3300Mcrt0.S\n-CRT0STUFF_T_CFLAGS = -DMOTOROLA -DSGS_CMP_ORDER"}, {"sha": "1d6cd3d8dd7f22276071fbd8d72f994f1cec2446", "filename": "gcc/config/m68k/t-mot3300-gald", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ft-mot3300-gald", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ft-mot3300-gald", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-mot3300-gald?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,27 +0,0 @@\n-T_CPPFLAGS = -DUSE_GAS -DUSE_GLD\n-TARGET_LIBGCC2_CFLAGS = -DUSE_GAS\n-\n-LIB1ASMSRC = m68k/lb1sf68.asm\n-LIB1ASMFUNCS = _mulsi3 _udivsi3 _divsi3 _umodsi3 _modsi3 \\\n-   _double _float _floatex \\\n-   _eqdf2 _nedf2 _gtdf2 _gedf2 _ltdf2 _ledf2 \\\n-   _eqsf2 _nesf2 _gtsf2 _gesf2 _ltsf2 _lesf2\n-\n-LIB2FUNCS_EXTRA = fpgnulib.c xfgnulib.c\n-\n-fpgnulib.c: $(srcdir)/config/m68k/fpgnulib.c\n-\tcp $(srcdir)/config/m68k/fpgnulib.c fpgnulib.c\n-xfgnulib.c: $(srcdir)/config/m68k/fpgnulib.c\n-\techo '#define EXTFLOAT' > xfgnulib.c\n-\tcat $(srcdir)/config/m68k/fpgnulib.c >> xfgnulib.c\n-\n-MULTILIB_OPTIONS=m68000/m68020 msoft-float\n-MULTILIB_DIRNAMES=\n-MULTILIB_MATCHES=m68000=mc68000 m68000=m68302 m68000=m68332 m68020=mc68020 m68020=m68040\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-CRT0_S = $(srcdir)/config/m68k/mot3300-crt0.S\n-MCRT0_S = $(srcdir)/config/m68k/mot3300Mcrt0.S\n-CRT0STUFF_T_CFLAGS ="}, {"sha": "ba222499084f57c49b433e74aec16820780079eb", "filename": "gcc/config/m68k/t-mot3300-gas", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ft-mot3300-gas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ft-mot3300-gas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-mot3300-gas?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,27 +0,0 @@\n-T_CPPFLAGS = -DUSE_GAS\n-TARGET_LIBGCC2_CFLAGS = -DUSE_GAS\n-\n-LIB1ASMSRC = m68k/lb1sf68.asm\n-LIB1ASMFUNCS = _mulsi3 _udivsi3 _divsi3 _umodsi3 _modsi3 \\\n-   _double _float _floatex \\\n-   _eqdf2 _nedf2 _gtdf2 _gedf2 _ltdf2 _ledf2 \\\n-   _eqsf2 _nesf2 _gtsf2 _gesf2 _ltsf2 _lesf2\n-\n-LIB2FUNCS_EXTRA = fpgnulib.c xfgnulib.c\n-\n-fpgnulib.c: $(srcdir)/config/m68k/fpgnulib.c\n-\tcp $(srcdir)/config/m68k/fpgnulib.c fpgnulib.c\n-xfgnulib.c: $(srcdir)/config/m68k/fpgnulib.c\n-\techo '#define EXTFLOAT' > xfgnulib.c\n-\tcat $(srcdir)/config/m68k/fpgnulib.c >> xfgnulib.c\n-\n-MULTILIB_OPTIONS=m68000/m68020 msoft-float\n-MULTILIB_DIRNAMES=\n-MULTILIB_MATCHES=m68000=mc68000 m68000=m68302 m68000=m68332 m68020=mc68020 m68020=m68040\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-CRT0_S = $(srcdir)/config/m68k/mot3300-crt0.S\n-MCRT0_S = $(srcdir)/config/m68k/mot3300Mcrt0.S\n-CRT0STUFF_T_CFLAGS ="}, {"sha": "8cc3ed6f2507dfc942106b19d98c958d98a98006", "filename": "gcc/config/m68k/t-mot3300-gld", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ft-mot3300-gld", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ft-mot3300-gld", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-mot3300-gld?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,12 +0,0 @@\n-T_CPPFLAGS = -DUSE_GLD\n-\n-MULTILIB_OPTIONS=m68000/m68020 msoft-float\n-MULTILIB_DIRNAMES=\n-MULTILIB_MATCHES=m68000=mc68000 m68000=m68302 m68000=m68332 m68020=mc68020 m68020=m68040\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-CRT0_S = $(srcdir)/config/m68k/mot3300-crt0.S\n-MCRT0_S = $(srcdir)/config/m68k/mot3300Mcrt0.S\n-CRT0STUFF_T_CFLAGS = -DMOTOROLA -DSGS_CMP_ORDER"}, {"sha": "9675a4dc20d8a3168a473aad3bbb68f5f1c588a0", "filename": "gcc/config/m68k/tower-as.h", "status": "removed", "additions": 0, "deletions": 525, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ftower-as.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ftower-as.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,525 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   For NCR Tower 32/4x0 and 32/6x0 running System V Release 3.\n-   Copyright (C) 1990, 1993, 1994, 1996, 1997, 2000, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Robert Andersson (ra@intsys.no), International Systems,\n-   Oslo, Norway.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* This file outputs assembler source suitable for the native Tower as\n-   and with sdb debugging symbols.  See tower.h for more comments.\n-\n-   This file was based on m68k.h, hp320.h and 3b1.h as of the\n-   1.37.1 version.  */\n-\n-#include \"m68k/tower.h\"\n-\n-/* Use default settings for system V.3.  */\n-\n-#include \"svr3.h\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dunix -Dtower32 -Dtower32_600 -D__motorola__ -Asystem=unix -Asystem=svr3 -Acpu=m68k -Amachine=m68k\"\n-\n-/* Define __HAVE_68881 in preprocessor only if -m68881 is specified.\n-   This will control the use of inline 68881 insns in certain macros.\n-   Also, define special define used to identify the Tower assembler.  */\n-\n-#define CPP_SPEC \"-D__TOWER_ASM__ %{m68881:-D__HAVE_68881__}\"\n-\n-/* We don't want local labels to start with period.\n-   See (*targetm.asm_out.internal_label).  */\n-#undef LOCAL_LABEL_PREFIX\n-#define LOCAL_LABEL_PREFIX \"\"\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-/* We do not want leading underscores.  */\n-\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"\"\n-\n-/* These four macros control how m68k.md is expanded.  */\n-\n-#define MOTOROLA\t\t/* Use Motorola syntax rather than \"MIT\" */\n-#define SGS\t\t\t/* Uses SGS assembler */\n-#define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n-#define SGS_NO_LI\t\t/* Suppress jump table label usage */\n-\n-#undef INT_OP_GROUP\n-#define INT_OP_GROUP INT_OP_NO_DOT\n-\n-/* Turn on SDB debugging info.  */\n-\n-#define SDB_DEBUGGING_INFO 1\n-\n-/* All the ASM_OUTPUT macros need to conform to the Tower as syntax.  */\n-\n-#define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME) \\\n-  do {\t\t\t\t\t\t   \\\n-    fprintf (FILE, \"\\tfile\\t\");\t\t\t   \\\n-    output_quoted_string (FILE, FILENAME);\t   \\\n-    fprintf (FILE, \"\\n\");\t\t\t   \\\n-    fprintf (FILE, \"section ~init,\\\"x\\\"\\n\");\t   \\\n-    fprintf (FILE, \"section ~fini,\\\"x\\\"\\n\");\t   \\\n-    fprintf (FILE, \"section ~rodata,\\\"x\\\"\\n\");   \\\n-    fprintf (FILE, \"text\\n\");\t\t\t   \\\n-  } while (0)\n-\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\t\\\n-  fprintf (FILE, \"\\tln\\t%d\\n\",\t\t\t\\\n-\t   (sdb_begin_function_line > -1\t\\\n-\t    ? (LINENO) - sdb_begin_function_line : 1))\n-\n-#undef ASM_OUTPUT_IDENT\n-#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n-  fprintf (FILE, \"\\tident\\t\\\"%s\\\" \\n\", NAME)\n-\n-#define ASM_OUTPUT_ASCII(FILE,PTR,LEN) \\\n-  do { register size_t sp = 0, lp = 0, limit = (LEN); \\\n-    fprintf ((FILE), \"\\tbyte\\t\"); \\\n-  loop: \\\n-    if ((PTR)[sp] > ' ' && ! ((PTR)[sp] & 0x80) && (PTR)[sp] != '\\\\') \\\n-      { lp += 3; \\\n-\tfprintf ((FILE), \"'%c\", (PTR)[sp]); } \\\n-    else \\\n-      { lp += 5; \\\n-\tfprintf ((FILE), \"0x%x\", (PTR)[sp]); } \\\n-    if (++sp < limit) \\\n-      {\tif (lp > 60) \\\n-\t  { lp = 0; \\\n-\t    fprintf ((FILE), \"\\n\\tbyte\\t\"); }\t\\\n-\telse \\\n-\t  putc (',', (FILE)); \\\n-\tgoto loop; } \\\n-    putc ('\\n', (FILE)); } while (0)\n-\n-/* Translate Motorola opcodes such as `jbeq'\n-   into SGS/Tower opcodes such as `beq.w'.\n-   Change `move' to `mov'.\n-   Change `cmpm' to `cmp'.\n-   Change `divsl' to `tdivs'.\n-   Change `divul' to `tdivu'.\n-   Change `ftst' to `ftest'.\n-   Change `fmove' to `fmov'.  */\n-\n-#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\t\t\\\n-{ if ((PTR)[0] == 'j' && (PTR)[1] == 'b')\t\t\\\n-    { ++(PTR);\t\t\t\t\t\t\\\n-      while (*(PTR) != ' ')\t\t\t\t\\\n-\t{ putc (*(PTR), (FILE)); ++(PTR); }\t\t\\\n-      fprintf ((FILE), \".w\"); }\t\t\t\t\\\n-  else if ((PTR)[0] == 'm' && (PTR)[1] == 'o'\t\t\\\n-\t   && (PTR)[2] == 'v' && (PTR)[3] == 'e')\t\\\n-    { fprintf ((FILE), \"mov\"); (PTR) += 4; }\t\t\\\n-  else if ((PTR)[0] == 'c' && (PTR)[1] == 'm'\t\t\\\n-\t   && (PTR)[2] == 'p' && (PTR)[3] == 'm')\t\\\n-    { fprintf ((FILE), \"cmp\"); (PTR) += 4; }\t\t\\\n-  else if ((PTR)[0] == 'd' && (PTR)[1] == 'i'\t\t\\\n-\t   && (PTR)[2] == 'v' && (PTR)[3] == 's'\t\\\n-\t   && (PTR)[4] == 'l')\t\t\t\t\\\n-    { fprintf ((FILE), \"tdivs\"); (PTR) += 5; }\t\t\\\n-  else if ((PTR)[0] == 'd' && (PTR)[1] == 'i'\t\t\\\n-\t   && (PTR)[2] == 'v' && (PTR)[3] == 'u'\t\\\n-\t   && (PTR)[4] == 'l')\t\t\t\t\\\n-    { fprintf ((FILE), \"tdivu\"); (PTR) += 5; }\t\t\\\n-  else if ((PTR)[0] == 'f' && (PTR)[1] == 't'\t\t\\\n-\t   && (PTR)[2] == 's' && (PTR)[3] == 't')\t\\\n-    { fprintf ((FILE), \"ftest\"); (PTR) += 4; }\t\t\\\n-  else if ((PTR)[0] == 'f' && (PTR)[1] == 'm'\t\t\\\n-\t   && (PTR)[2] == 'o' && (PTR)[3] == 'v' \t\\\n-\t   && (PTR)[4] == 'e')\t\t\t\t\\\n-    { fprintf ((FILE), \"fmov\"); (PTR) += 5; }\t\t\\\n-}\n-\n-\n-\f\n-/* Override parts of m68k.h to fit the Tower assembler.\n-   This section needs to track changes done to m68k.h in the future.  */\n-\n-#undef TARGET_VERSION\n-#define TARGET_VERSION fprintf (stderr, \" (68k, Motorola/SGS/Tower32 syntax)\");\n-\n-#undef FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(FILE, LABEL_NO)\t\\\n-    fprintf (FILE, \"\\tmov.l &LP%%%d,%%a0\\n\\tjsr mcount%%\\n\", (LABEL_NO))\n-\n-#undef FUNCTION_EXTRA_EPILOGUE\n-#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-{ if (current_function_returns_pointer\t\t\t\t\t\\\n-      && ! find_equiv_reg (0, get_last_insn (), 0, 0, 0, 8, Pmode))\t\\\n-    asm_fprintf (FILE, \"\\tmov.l %Rd0,%Ra0\\n\"); } \n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#undef ASM_OUTPUT_REG_PUSH\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmov.l %s,-(%%sp)\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#undef ASM_OUTPUT_REG_POP\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmov.l (%%sp)+,%s\\n\", reg_names[REGNO])\n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE) \\\n-( fprintf (FILE, \"#NO_APP\\n\"), \\\n-  output_file_directive ((FILE), main_input_filename))\n-\n-#undef TEXT_SECTION_ASM_OP\n-#define TEXT_SECTION_ASM_OP \"\\ttext\"\n-\n-#undef DATA_SECTION_ASM_OP\n-#define DATA_SECTION_ASM_OP \"\\tdata\"\n-\n-/* This says how to output an assembler line to define a global common symbol.\n-   We use SIZE rather than ROUNDED, as this is what the native cc does.  */\n-\n-#undef ASM_OUTPUT_COMMON\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\tcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%d\\n\", ((SIZE) == 0) ? (int)(ROUNDED) : (int)(SIZE)))\n-\n-/* This says how to output an assembler line to define a local common symbol.\n-   We use SIZE rather than ROUNDED, as this is what the native cc does.  */\n-\n-#undef ASM_OUTPUT_LOCAL\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\tlcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%d\\n\", ((SIZE) == 0) ? (int)(ROUNDED) : (int)(SIZE)))\n-\n-#define ASM_PN_FORMAT \"%s%%%%%lu\"\n- \n-/* This is the command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#undef GLOBAL_ASM_OP\n-#define GLOBAL_ASM_OP \"\\tglobal\\t\"\n-\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n-  sprintf ((LABEL), \"%s%%%ld\", (PREFIX), (long)(NUM))\n-\n-#undef ASM_OUTPUT_CASE_LABEL\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLE)\t\t\t\\\n-  fprintf (FILE, \"\\tswbeg &%d\\n%s%%%d:\\n\",\t\t\t\t\\\n-           XVECLEN (PATTERN (TABLE), 1), (PREFIX), (NUM));\t\t\\\n-\n-#undef ASM_OUTPUT_ADDR_VEC_ELT\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\tlong L%%%d\\n\", (VALUE))\n-\n-#undef ASM_OUTPUT_ADDR_DIFF_ELT\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\tshort L%%%d-L%%%d\\n\", (VALUE), (REL))\n-\n-#undef ASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-do {\t\t\t\t\t\\\n-  if ((LOG) == 1)\t\t\t\\\n-    fprintf (FILE, \"\\teven\\n\");\t        \\\n-  else if ((LOG) != 0)\t\t\t\\\n-    abort ();\t\t\t\t\\\n-} while (0)\n-\n-#undef ASM_OUTPUT_SKIP\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\tspace %d\\n\", (int)(SIZE))\n-\n-/* Output a float value (represented as a C double) as an immediate operand.\n-   This macro is a 68k-specific macro.  */\n-\n-#undef ASM_OUTPUT_FLOAT_OPERAND\n-#define ASM_OUTPUT_FLOAT_OPERAND(CODE,FILE,VALUE)\t\t\t\\\n- do { long l;\t\t\t\t\t\t\t\t\\\n-      REAL_VALUE_TO_TARGET_SINGLE (r, l);\t\t\t\t\\\n-      /* Use hex representation even if CODE is f.  as needs it.  */\t\\\n-      fprintf ((FILE), \"&0x%lx\", l);\t\t\t\t\t\\\n-    } while (0)\n-\n-/* Output a double value (represented as a C double) as an immediate operand.\n-   This macro is a 68k-specific macro.  */\n-#undef ASM_OUTPUT_DOUBLE_OPERAND\n-#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\t\t\t\\\n- do { long l[2];\t\t\t\t\t\t\t\\\n-      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n-      fprintf ((FILE), \"&0x%lx%08lx\", l[0], l[1]);\t\t\t\\\n-    } while (0)\n-\n-#if 0\n-#undef PRINT_OPERAND\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (CODE == '.') fprintf (FILE, \".\");\t\t\t\t\t\\\n-  else if (CODE == '#') fprintf (FILE, \"&\");\t\t\t\t\\\n-  else if (CODE == '-') fprintf (FILE, \"-(%%sp)\");\t\t\t\\\n-  else if (CODE == '+') fprintf (FILE, \"(%%sp)+\");\t\t\t\\\n-  else if (CODE == '@') fprintf (FILE, \"(%%sp)\");\t\t\t\\\n-  else if (CODE == '!') fprintf (FILE, \"%%fpcr\");\t\t\t\\\n-  else if (CODE == '/')\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%%\");\t\t\t\t\t\t\\\n-  else if (CODE == '$') { if (TARGET_68040_ONLY) fprintf (FILE, \"s\"); }\t\\\n-  else if (CODE == '&') { if (TARGET_68040_ONLY) fprintf (FILE, \"d\"); }\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n-    { REAL_VALUE_TYPE r; long l;\t\t\t\t\t\\\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n-      REAL_VALUE_TO_TARGET_SINGLE (r, l);\t\t\t\t\\\n-      fprintf (FILE, \"&0x%lx\", l); }\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n-    { REAL_VALUE_TYPE r; int i[2];\t\t\t\t\t\\\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n-      REAL_VALUE_TO_TARGET_DOUBLE (r, i);\t\t\t\t\\\n-      fprintf (FILE, \"&0x%x%08x\", i[0], i[1]); }\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == XFmode)\t\\\n-    { REAL_VALUE_TYPE r;\t\t\t\t\t\t\\\n-      REAL_VALUE_FROM_CONST_DOUBLE (r, X);\t\t\t\t\\\n-      ASM_OUTPUT_LONG_DOUBLE_OPERAND (FILE, r); }\t\t\t\\\n-  else { putc ('&', FILE); output_addr_const (FILE, X); }}\n-#endif\n-\n-/* Note that this contains a kludge that knows that the only reason\n-   we have an address (plus (label_ref...) (reg...))\n-   is in the insn before a tablejump, and we know that the table is\n-   exactly 10 bytes away.  */\n-\n-#undef PRINT_OPERAND_ADDRESS\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n-  register rtx addr = ADDR;\t\t\t\t\t\t\\\n-  rtx offset;\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case REG:\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"(%s)\", reg_names[REGNO (addr)]);\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PRE_DEC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"-(%s)\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case POST_INC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"(%s)+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PLUS:\t\t\t\t\t\t\t\t\\\n-      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n-      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n-      offset = 0;\t\t\t\t\t\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n-\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n-\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n-/*  for OLD_INDEXING\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (addr) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      reg2 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t      addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      reg2 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t      addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-  */\t\t\t\t\t\t\t\t\t\\\n-      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n-      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n-\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n-\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n-\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n-      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n-\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n-      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n-        { int scale = 1;\t\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n-\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n-\t    fprintf (FILE, \"10(%%pc,%s.w\",\t\t\t\t\\\n-\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"10(%%pc,%s.l\",\t\t\t\t\\\n-\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n-\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n-\t  putc (')', FILE);\t\t\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n-\t{ int scale = 1;\t\t\t\t\t\t\\\n-\t  if (breg == 0)\t\t\t\t\t\t\\\n-\t    abort ();\t\t\t\t\t\t\t\\\n-\t  if (addr != 0)\t\t\t\t\t\t\\\n-\t    output_addr_const (FILE, addr);\t\t\t\t\\\n-\t  fprintf (FILE, \"(%s\", reg_names[REGNO (breg)]);\t\t\\\n-\t  if (ireg != 0)\t\t\t\t\t\t\\\n-\t    putc (',', FILE);\t\t\t\t\t\t\\\n-\t  if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n-\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n-\t  if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n-\t    fprintf (FILE, \"%s.w\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n-\t  else if (ireg != 0)\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"%s.l\", reg_names[REGNO (ireg)]);\t\t\\\n-\t  if (scale != 1) fprintf (FILE, \"*%d\", scale);\t\t\t\\\n-\t  putc (')', FILE);\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n-\t{ fprintf (FILE, \"10(%%pc,%s.w)\",\t\t\t\t\\\n-\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-        output_addr_const (FILE, addr);\t\t\t\t\t\\\n-    }}\n-\n-\n-\f\n-/* Override usual definitions of SDB output macros.\n-   These definitions differ only in the absence of the period\n-   at the beginning of the name of the directive\n-   and in the use of `~' as the symbol for the current location.  */\n-\n-#define PUT_SDB_SCL(a) fprintf(asm_out_file, \"\\tscl\\t%d;\", (a))\n-#define PUT_SDB_INT_VAL(a) fprintf (asm_out_file, \"\\tval\\t%d;\", (a))\n-#define PUT_SDB_VAL(a)\t\t\t\t\\\n-( fputs (\"\\tval\\t\", asm_out_file),\t\t\\\n-  output_addr_const (asm_out_file, (a)),\t\\\n-  fputc (';', asm_out_file))\n-\n-#define PUT_SDB_DEF(a)\t\t\t\t\\\n-do { fprintf (asm_out_file, \"\\tdef\\t\");\t\\\n-     ASM_OUTPUT_LABELREF (asm_out_file, a); \t\\\n-     fprintf (asm_out_file, \";\"); } while (0)\n-\n-#define PUT_SDB_PLAIN_DEF(a) fprintf(asm_out_file,\"\\tdef\\t~%s;\",a)\n-#define PUT_SDB_ENDEF fputs(\"\\tendef\\n\", asm_out_file)\n-#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\ttype\\t0%o;\", a)\n-#define PUT_SDB_SIZE(a) fprintf(asm_out_file, \"\\tsize\\t%d;\", a)\n-#define PUT_SDB_START_DIM fprintf(asm_out_file, \"\\tdim\\t\")\n-#define PUT_SDB_NEXT_DIM(a) fprintf(asm_out_file, \"%d,\", a)\n-#define PUT_SDB_LAST_DIM(a) fprintf(asm_out_file, \"%d;\", a)\n-\n-#define PUT_SDB_TAG(a)\t\t\t\t\\\n-do { fprintf (asm_out_file, \"\\ttag\\t\");\t\\\n-     ASM_OUTPUT_LABELREF (asm_out_file, a);\t\\\n-     fprintf (asm_out_file, \";\"); } while (0)\n-\n-#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~bb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~eb;\\tval\\t~;\\tscl\\t100;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~bf;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t~ef;\\tval\\t~;\\tscl\\t101;\\tline\\t%d;\\tendef\\n\",\t\\\n-\t   (LINE))\n-\n-#define PUT_SDB_EPILOGUE_END(NAME)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\tdef\\t%s;\\tval\\t~;\\tscl\\t-1;\\tendef\\n\",\t\\\n-\t   (NAME))\n-\n-#define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n-  sprintf ((BUFFER), \"~%dfake\", (NUMBER));\n-\n-#define NO_DOLLAR_IN_LABEL\n-#define NO_DOT_IN_LABEL\n-\n-/* The usual definitions don't work because neither $ nor . is allowed.  */\n-#define CONSTRUCTOR_NAME_FORMAT \"_GLOBAL_%%I\\%%%s\"\n-\n-/* Define a few machine-specific details\n-   of the implementation of constructors.\n-\n-   The __CTORS_LIST__ goes in the .init section.  Define CTOR_LIST_BEGIN\n-   and CTOR_LIST_END to contribute to the .init section an instruction to\n-   push a word containing 0 (or some equivalent of that).  */\n-\n-#undef INIT_SECTION_ASM_OP\n-#define INIT_SECTION_ASM_OP\t\"\\tsection\\t~init\"\n-#undef FINI_SECTION_ASM_OP\n-#define FINI_SECTION_ASM_OP\t\"\\tsection\\t~fini\"\n-#undef READONLY_DATA_SECTION_ASM_OP\n-#define READONLY_DATA_SECTION_ASM_OP\t\"\\tsection\\t~rodata\"\n-\n-#define CTOR_LIST_BEGIN\t\t\t\t\\\n-  asm (INIT_SECTION_ASM_OP);\t\t\t\\\n-  asm (\"clr.l -(%sp)\")\n-#define CTOR_LIST_END CTOR_LIST_BEGIN\n-\n-#define BSS_SECTION_ASM_OP\t\"\\tsection\\t~bss\"\n-\n-#define TARGET_ASM_CONSTRUCTOR  m68k_svr3_asm_out_constructor"}, {"sha": "7ae1a9ec28208f238bf590b3ab5df27c17537629", "filename": "gcc/config/m68k/tower.h", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ftower.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm68k%2Ftower.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ftower.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,104 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Copyright (C) 1990, 1994, 1996 Free Software Foundation, Inc.\n-   Contributed by Robert Andersson, International Systems, Oslo, ra@intsys.no.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* For NCR Tower 32/4x0 and 32/6x0 running System V Release 3.  I don't have\n-   access to 200/700/800/850 machines, so I don't know if it works on those\n-   as well.  It shouldn't be far from it however.  The hardware floating point\n-   support is completely untested, as I do not have access to a machine with\n-   a 6888x FPU in it.  It does not work on the System V Release 2 based OS\n-   releases.  Making it work will not be easy, due to the silly way in which\n-   stack expansion is implemented in the OS.\n-\n-   This file is included in tower-as.h.\n-   Do *NOT* include this file directly.  */\n-\n-\n-#include \"m68k/m68k.h\"\n-\n-#define TARGET_DEFAULT (MASK_BITFIELD|MASK_68020)\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dunix -Dtower32 -Dtower32_200 -Asystem=unix -Asystem=svr3 -Acpu=m68k -Amachine=m68k\"\n-\n-#if 0  /* It is incorrect to test these symbols.\n-\t  They describe the host, not the target.\n-\t  It should not matter which model is specified.  */\n-#ifdef tower32_600\n-#define CPP_PREDEFINES \"-Dunix -Dtower32 -Dtower32_600 -Asystem=unix -Asystem=svr3 -Acpu=m68k -Amachine=m68k\"\n-#endif\n-#ifdef tower32_700\n-#define CPP_PREDEFINES \"-Dunix -Dtower32 -Dtower32_700 -Asystem=unix -Asystem=svr3 -Acpu=m68k -Amachine=m68k\"\n-#endif\n-#ifdef tower32_800\n-#define CPP_PREDEFINES \"-Dunix -Dtower32 -Dtower32_800 -Asystem=unix -Asystem=svr3 -Acpu=m68k -Amachine=m68k\"\n-#endif\n-#ifdef tower32_850\n-#define CPP_PREDEFINES \"-Dunix -Dtower32 -Dtower32_850 -Asystem=unix -Asystem=svr3 -Acpu=m68k -Amachine=m68k\"\n-#endif\n-#endif\n-\n-/* The startfiles and libraries depend on the -p and -m68881 options.\n-   The Tower does not support the -pg option.  */\n-\n-#define LINK_SPEC                                              \\\n-\"%{p:%{m68881:-L/usr/lib/fp/libp} -L/usr/lib/libp}             \\\n- %{m68881:-L/usr/lib/fp}\"\n-\n-#define LIB_SPEC \\\n-\"%{shlib:-lc_s} -lc crtend.o%s crtn.o%s\"\n-\n-#define STARTFILE_SPEC \\\n-\"%{p:mcrt1.o%s} %{!p:crt1.o%s} crtbegin.o%s\"\n-\n-/* Use mem* functions, recognize #ident lines.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-#define IDENT_DIRECTIVE\n-\n-/* Every structure and union's size must be a multiple of two bytes.  */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* All register names should have a leading % character.  */\n-\n-#undef REGISTER_NAMES\n-#define REGISTER_NAMES \\\n-{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",                      \\\n- \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\",                      \\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\"}\n-\n-#undef REGISTER_PREFIX\n-#define REGISTER_PREFIX \"%\"\n-\n-#undef IMMEDIATE_PREFIX\n-#define IMMEDIATE_PREFIX \"&\"\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-/* We do not want leading underscores.  */\n-\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"\""}, {"sha": "4eef7d685baa6a4c5e74618056c78f2ab91d6540", "filename": "gcc/config/m88k/aout-dbx.h", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Faout-dbx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Faout-dbx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Faout-dbx.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,25 +0,0 @@\n-/* Configuration fragment for an m88k OpenBSD target.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* a.out with DBX. */\n-#define DBX_DEBUGGING_INFO 1\n-#define DEFAULT_GDB_EXTENSIONS 0\n-"}, {"sha": "50ea8dd3da7e4e8db274a5ba2ae7e86b4c17ee26", "filename": "gcc/config/m88k/m88k-aout.h", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k-aout.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,32 +0,0 @@\n-/* Definitions for \"naked\" Motorola 88k using a.out object format files\n-   and stabs debugging info.\n-\n-   Copyright (C) 1994 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#undef SDB_DEBUGGING_INFO\n-#define DBX_DEBUGGING_INFO 1\n-\n-#include \"m88k/m88k.h\"\n-#include \"aoutos.h\"\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dm88000 -Dm88k -Acpu=m88k -Amachine=m88k\"\n-\n-/* end of m88k-aout.h */"}, {"sha": "b5edc6cb82e3a70adbb93a6568e61053d986ca86", "filename": "gcc/config/m88k/m88k-modes.def", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k-modes.def?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,27 +0,0 @@\n-/* Definitions of target machine for GNU compiler for Motorola m88100.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com).\n-   Currently maintained by (gcc@dg-rtp.dg.com)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Extra machine modes to represent the condition code.  */\n-\n-CC (CCEVEN)\n-\n-"}, {"sha": "874bc364ae5cda65325d6b2545d14dd30dbe8513", "filename": "gcc/config/m88k/m88k-move.sh", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k-move.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k-move.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k-move.sh?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,306 +0,0 @@\n-#!/bin/sh\n-#\n-#\tIf your shell doesn't support functions (true for some BSD users),\n-#\tyou might try using GNU's bash.\n-#\n-#ident \"@(#) m88k-move.sh 1-Sep-92\"\n-#\n-#\tThis file provided by Data General, February 1990.\n-#\n-#\tThis script generates the necessary movstr library functions\n-#\tfor the m88100.  These functions are called from the expansion\n-#\tof movstrsi.  There are eight modules created by this script,\n-#\teach with multiple entry points.  One module, moveSI64n\n-#\timplements a word aligned loop; the other modules, moveXINx\n-#\timplement a straight line copy of N bytes in mode XI.\n-#\n-#\tBy analysis of the best memcpy function, it can be determined\n-#\twhat appear to be certain magic numbers.  For example, a\n-#\tmemcpy of 13 bytes, where the pointers are determined at run\n-#\ttime to be word aligned takes 28 cycles.  A call to\n-#\t__movstrQI13x13 also takes 28 cycles.  The break even point\n-#\tfor a HImode copy is 38 bytes.  Just to be on the safe side,\n-#\tthese are bumped to 16 and 48 respectively.\n-#\n-#\tThe smaller, odd-remainder modules are provided to help\n-#\tmitigate the overhead of copying the last bytes.\n-#\n-#\tChanges to these functions should not be taken lightly if you\n-#\twant to be able to link programs built with older movstr\n-#\tparameters.\n-#\n-#.Revision History\n-#\n-#\t 1-Sep-92   Stan Cox   Added moveDI96x, moveDI41x through moveDI47x.\n-#\t 2-Jan-92   Tom Wood   Renamed files to comply with SVR3 14 char limit.\n-#\t26-Oct-90   Tom Wood   Delete movstr.h; moved to out-m88k.c.\n-#\t17-Oct-90   Tom Wood   Files are named *.asm rather than *.s.\n-#\t11-Sep-90   Jeffrey Friedl\n-#\t\t\tOn my BSD 4.3 awk and my GNU-awk, only the\n-#\t\t\tfirst character of an argument to -F is passed\n-#\t\t\tthrough, so I can't get this to work.\n-#\t 5-Sep-90   Ray Essick/Tom Wood  \n-#\t\t\tAdded a -no-tdesc option.\n-#\t27-Aug-90   Vince Guarna/Tom Wood   \n-#\t\t\tVersion 3 assembler syntax (-abi).\n-#\t16-Aug-90   Ron Guilmette\n-#\t\t\tAvoid problems on a SPARC.  The common\n-#\t\t\tdenominator among shells seems to be '...\\'\n-#\t\t\trather than '...\\\\'.\n-#\t15-Aug-90   Ron Guilmette\n-#\t\t\tAvoid awk syntax errors on a Sun by not using\n-#\t\t\tthe `!' operator.\n-#\t22-Feb-90   Tom Wood  \tCreated.\n-#\t20-Jun-90   Tom Wood\tEmit file directives.\n-#\n-#.End]=--------------------------------------------------------------*/\n-\n-usage() {\n-    echo \"usage: $0 [ -abi ] [ -no-tdesc ]\" 1>&2\n-    exit 1\n-}\n-\n-awk_flag=\"-F:\";\n-awk_begin=\"BEGIN { \"\n-ps=\"\"; us=\"_\"; tf=\"x\"; la=\"@L\"; fb=\"8\"; nt=\"\";\n-do_file() {\n-    echo \"\tfile\t $1\";\n-}\n-\n-while [ $# -gt 0 ] ; do\n-    case $1 in\n-\t-no-tdesc) awk_begin=\"$awk_begin no_tdesc=1;\"\n-\t      nt=\";\";;\n-\t-abi) awk_begin=\"$awk_begin abi=1;\"\n-\t      ps=\"#\"; us=\"\"; tf=\"a\"; la=\".L\"; fb=\"16\";\n-\t      do_file() {\n-\t\techo '\tversion\t \"03.00\"';\n-\t\techo \"\tfile\t $1\";\n-\t      };;\n-\t*) usage;;\n-    esac\n-    shift\n-done\n-\n-rm -f move?I*[xn].s move?I*[xn].asm\n-\n-#.Implementation_continued[=-----------------------------------------------\n-#\n-#\tThis generates the word aligned loop.  The loop is entered\n-#\tfrom the callable entry points ___movstrSI64nN, where at\n-#\tleast N bytes will be copied.  r2 is the destination pointer\n-#\toffset by 4, r3 is the source pointer offset by 4, r6 is the\n-#\tloop count.  Thus, the total bytes moved is 64 * r6 + N.  The\n-#\tfirst value is preloaded into r4 or r5 (r4 if N/4 is odd;\n-#\tr5 if N/4 is even).  Upon returning, r2 and r3 have been\n-#\tupdated and may be used for the remainder bytes to move.\n-#\n-#\tThe code for this loop is generated by the awk program\n-#\tfollowing.  Edit *it*, not what it generates!\n-#\n-#.End]=------------------------------------------------------------------*/\n-\n-gen_movstrN() {\n-  awk $awk_flag \"$awk_begin\"'\n-    if (abi) {\n-      ps=\"#\"; us=\"\"; tf=\"a\"; la=\".L\"; fb=16;\n-    } else {\n-      ps=\"\"; us=\"_\"; tf=\"x\"; la=\"@L\"; fb=8;\n-    }\n-  }\n-  NR == 1 && NF == 4 {\n-    mode = $1; suffix = $2; align = $3; count = $4;\n-    ld = align; st = 0;\n-\n-    printf \"; The following was calculated using awk.\\n\";\n-    printf \"\\ttext\\n\";\n-    printf \"\\talign\\t%d\\n\", fb;\n-    printf \"%sloop%s%d:\\n\", la, mode, count * align;\n-    printf \"\\taddu\\t%sr3,%sr3,%d\\n\", ps, ps, count * align;\n-    printf \"\\taddu\\t%sr2,%sr2,%d\\n\", ps, ps, count * align;\n-    printf \"\\tsubu\\t%sr6,%sr6,1\\n\", ps, ps;\n-    for (r = count + 1; r >= 1; r--) {\n-      evenp = r % 2;\n-      name = sprintf(\"__%smovstr%s%dn%d\", us, mode, count * align, r * align);\n-      if (r > 1) {\n-        printf \"\\tglobal\\t%s\\n\", name;\n-        printf \"%s:\\n\", name;\n-      }\n-      if (r > 2) {\n-\tprintf \"\\tld%s\\t%sr%d,%sr3,%d\\n\", suffix, ps, 4 + evenp, ps, ld;\n-        printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix, ps, 5 - evenp, ps, st;\n-      } else if (r == 2) {\n-\tprintf \"\\tld%s\\t%sr%d,%sr3,%d\\n\", suffix, ps, 4 + evenp, ps, ld;\n-\tprintf \"\\tbcnd.n\\t%sgt0,%sr6,%sloop%s%d\\n\", ps, ps, la, mode, count * align;\n-        printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix, ps, 5 - evenp, ps, st;\n-        printf \"\\tjmp.n\\t%sr1\\n\", ps;\n-      } else {\n-        printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix, ps, 5 - evenp, ps, st;\n-      }\n-      ld += align; st += align;\n-    }\n-    if (!no_tdesc) {\n-      printf \"%send%s%d:\\n\", la, mode, count * align;\n-      printf \"\\tsection\\t.tdesc,\\\"%s\\\"\\n\", tf;\n-      printf \"\\tword\\t0x42,1,%sloop%s%d\", la, mode, count * align;\n-      printf \",%send%s%d\\n\", la, mode, count * align;\n-      printf \"\\tword\\t0x0100001f,0,1,0\\n\";\n-      printf \"\\ttext\\n\";\n-    }\n-    printf \"; End of awk generated code.\\n\";\n-    exit;\n-  }'\n-}\n-\n-(do_file '\"movstrSI64n.s\"';\n- echo 'SI::4:16' | gen_movstrN) > moveSI64n.asm\n-\n-#.Implementation_continued[=-----------------------------------------------\n-#\n-#\tThis generates the even-remainder, straight-line modules.\n-#\tThe code is entered from the callable entry points\n-#\t___movstrXINxM, where exactly M bytes will be copied in XI\n-#\tmode.  r2 is the destination pointer, r3 is the source\n-#\tpointer, neither being offset.  The first value is preloaded\n-#\tinto r4 or r5 (r4 if M-N/B is even; r5 if M-N/B is odd, where\n-#\tB is the mode size of XI).  Upon returning, r2 and r3 have not\n-#\tbeen changed.\n-#\n-#\tThe code for these cases is generated by the awk program\n-#\tfollowing.  Edit *it*, not what it generates!\n-#\n-#.End]=------------------------------------------------------------------*/\n-\n-gen_movstrX0() {\n-    awk $awk_flag \"$awk_begin\"'\n-      if (abi) {\n-\tps=\"#\"; us=\"\"; tf=\"a\"; la=\".L\"; fb=16;\n-      } else {\n-\tps=\"\"; us=\"_\"; tf=\"x\"; la=\"@L\"; fb=8;\n-      }\n-    }\n-    NR == 1 && NF == 4 {\n-    mode = $1; suffix = $2; align = $3; bytes = $4;\n-    ld = align; st = 0; count = bytes / align;\n-    reg[0] = 4; if (align == 8) reg[1] = 6; else reg[1] = 5;\n-    printf \"; The following was calculated using awk.\\n\";\n-    printf \"\\ttext\\n\";\n-    printf \"\\talign\\t%d\\n\", fb;\n-    for (r = count; r >= 1; r--) {\n-      evenp = r % 2;\n-      name = sprintf(\"__%smovstr%s%dx%d\", us, mode, count * align, r * align);\n-      if (r > 1) {\n-        printf \"\\tglobal\\t%s\\n\", name;\n-        printf \"%s:\\n\", name;\n-      }\n-      if (r == 1)\n-        printf \"\\tjmp.n\\t%sr1\\n\", ps;\n-      else\n-        printf \"\\tld%s\\t%sr%d,%sr3,%d\\n\", suffix, ps, reg[evenp], ps, ld;\n-      printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix, ps, reg[1-evenp], ps, st;\n-      ld += align; st += align;\n-    }\n-    if (!no_tdesc) {\n-      printf \"%send%s%dx:\\n\", la, mode, count * align;\n-      printf \"\\tsection\\t.tdesc,\\\"%s\\\"\\n\", tf;\n-      printf \"\\tword\\t0x42,1,__%smovstr%s%dx%d\", us, mode, count * align, count * align;\n-      printf \",%send%s%dx\\n\", la, mode, count * align;\n-      printf \"\\tword\\t0x0100001f,0,1,0\\n\";\n-      printf \"\\ttext\\n\";\n-    }\n-    printf \"; End of awk generated code.\\n\"\n-    exit;\n-  }'\n-}\n-\n-(do_file '\"movstrQI16x.s\"';\n- echo 'QI:.b:1:16' | gen_movstrX0) > moveQI16x.asm\n-(do_file '\"movstrHI48x.s\"';\n- echo 'HI:.h:2:48' | gen_movstrX0) > moveHI48x.asm\n-(do_file '\"movstrSI96x.s\"';\n- echo 'SI::4:96'   | gen_movstrX0) > moveSI96x.asm\n-(do_file '\"movstrDI96x.s\"';\n- echo 'DI:.d:8:96'   | gen_movstrX0) > moveDI96x.asm\n-\n-#.Implementation_continued[=-----------------------------------------------\n-#\n-#\tThis generates the odd-remainder, straight-line modules.  The\n-#\tinterface is the same as that for the even-remainder modules.\n-#\n-#.End]=------------------------------------------------------------------*/\n-\n-gen_movstrXr() {\n-    awk $awk_flag \"$awk_begin\"'\n-      if (abi) {\n-\tps=\"#\"; us=\"\"; tf=\"a\"; la=\".L\"; fb=16;\n-      } else {\n-\tps=\"\"; us=\"_\"; tf=\"x\"; la=\"@L\"; fb=8;\n-      }\n-    }\n-    NR == 1 && NF == 4 {\n-    mode = $1; rem = $2; most = $3; count = $4;\n-    suffix[1] = \".b\"; suffix[2] = \".h\"; suffix[4] = \"\"; suffix[8] = \".d\";\n-\n-    prev = align = most;\n-    ld = align; st = 0; total = count - rem - most;\n-    evenp = int(total/align) % 2;\n-    reg[0] = 4; if (align == 8) reg[1] = 6; else reg[1] = 5;\n-    printf \"; The following was calculated using awk.\\n\";\n-    printf \"\\ttext\\n\";\n-    printf \"\\talign\\t%d\\n\", fb;\n-    for (bytes = total; bytes >= 0; bytes -= align) {\n-      if (bytes < align) {\n-\tif (bytes >= 4) align = 4;\n-\telse if (bytes >= 2) align = 2;\n-\telse align = 1;\n-      }\n-      name = sprintf(\"__%smovstr%s%dx%d\", us, mode, total + most, bytes + most);\n-      if (bytes > most) {\n-        printf \"\\tglobal\\t%s\\n\", name;\n-        printf \"%s:\\n\", name;\n-      }\n-      if (bytes == 0)\n-\tprintf \"\\tjmp.n\\t%sr1\\n\", ps;\n-      else\n-\tprintf \"\\tld%s\\t%sr%d,%sr3,%d\\n\", suffix[align], ps, reg[evenp], ps, ld;\n-      printf \"\\tst%s\\t%sr%d,%sr2,%d\\n\", suffix[prev], ps, reg[1-evenp], ps, st;\n-      ld += align; st += prev; prev = align;\n-      evenp = 1 - evenp;\n-    }\n-    if (!no_tdesc) {\n-      printf \"%send%s%dx:\\n\", la, mode, total + most;\n-      printf \"\\tsection\\t.tdesc,\\\"%s\\\"\\n\", tf;\n-      printf \"\\tword\\t0x42,1,__%smovstr%s%dx%d\", us, mode, total + most, total + most;\n-      printf \",%send%s%dx\\n\", la, mode, total + most;\n-      printf \"\\tword\\t0x0100001f,0,1,0\\n\";\n-      printf \"\\ttext\\n\";\n-    }\n-    printf \"; End of awk generated code.\\n\"\n-    exit;\n-  }'\n-}\n-\n-(do_file '\"movstrDI47x.s\"';\n- echo 'DI:1:8:48' | gen_movstrXr) > moveDI47x.asm\n-(do_file '\"movstrDI46x.s\"';\n- echo 'DI:2:8:48' | gen_movstrXr) > moveDI46x.asm\n-(do_file '\"movstrDI45x.s\"';\n- echo 'DI:3:8:48' | gen_movstrXr) > moveDI45x.asm\n-(do_file '\"movstrDI44x.s\"';\n- echo 'DI:4:8:48' | gen_movstrXr) > moveDI44x.asm\n-(do_file '\"movstrDI43x.s\"';\n- echo 'DI:5:8:48' | gen_movstrXr) > moveDI43x.asm\n-(do_file '\"movstrDI42x.s\"';\n- echo 'DI:6:8:48' | gen_movstrXr) > moveDI42x.asm\n-(do_file '\"movstrDI41x.s\"';\n- echo 'DI:7:8:48' | gen_movstrXr) > moveDI41x.asm\n-\n-(do_file '\"movstrSI47x.s\"';\n- echo 'SI:1:4:48' | gen_movstrXr) > moveSI47x.asm\n-(do_file '\"movstrSI46x.s\"';\n- echo 'SI:2:4:48' | gen_movstrXr) > moveSI46x.asm\n-(do_file '\"movstrSI45x.s\"';\n- echo 'SI:3:4:48' | gen_movstrXr) > moveSI45x.asm\n-\n-(do_file '\"movstrHI15x.s\"';\n- echo 'HI:1:2:16' | gen_movstrXr) > moveHI15x.asm"}, {"sha": "b7bba671916bba7fd6499873ed0b1c40d44592c7", "filename": "gcc/config/m88k/m88k-protos.h", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k-protos.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,102 +0,0 @@\n-/* Definitions of target machine for GNU compiler for\n-   Motorola m88100 in an 88open OCS/BCS environment.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com).\n-   Currently maintained by (gcc@dg-rtp.dg.com)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef RTX_CODE\n-extern int m88k_debugger_offset PARAMS ((rtx, int));\n-extern void emit_bcnd PARAMS ((enum rtx_code, rtx));\n-extern void expand_block_move PARAMS ((rtx, rtx, rtx *));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern const char *output_load_const_int PARAMS ((enum machine_mode, rtx *));\n-extern const char *output_load_const_float PARAMS ((rtx *));\n-extern const char *output_load_const_double PARAMS ((rtx *));\n-extern const char *output_load_const_dimode PARAMS ((rtx *));\n-extern const char *output_and PARAMS ((rtx[]));\n-extern const char *output_ior PARAMS ((rtx[]));\n-extern const char *output_xor PARAMS ((rtx[]));\n-extern const char *output_call PARAMS ((rtx[], rtx));\n-\n-extern struct rtx_def *emit_test PARAMS ((enum rtx_code, enum machine_mode));\n-extern struct rtx_def *legitimize_address PARAMS ((int, rtx, rtx, rtx));\n-extern struct rtx_def *legitimize_operand PARAMS ((rtx, enum machine_mode));\n-\n-extern int pic_address_needs_scratch PARAMS ((rtx));\n-extern int symbolic_address_p PARAMS ((rtx));\n-extern int condition_value PARAMS ((rtx));\n-extern int emit_move_sequence PARAMS ((rtx *, enum machine_mode, rtx));\n-extern int mostly_false_jump PARAMS ((rtx, rtx));\n-extern int real_power_of_2_operand PARAMS ((rtx, enum machine_mode));\n-extern int move_operand PARAMS ((rtx, enum machine_mode));\n-extern int call_address_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith5_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith32_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith64_operand PARAMS ((rtx, enum machine_mode));\n-extern int int5_operand PARAMS ((rtx, enum machine_mode));\n-extern int int32_operand PARAMS ((rtx, enum machine_mode));\n-extern int add_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_bbx_mask_operand PARAMS ((rtx, enum machine_mode));\n-extern int real_or_0_operand PARAMS ((rtx, enum machine_mode));\n-extern int partial_ccmode_register_operand PARAMS ((rtx, enum machine_mode));\n-extern int relop PARAMS ((rtx, enum machine_mode));\n-extern int even_relop PARAMS ((rtx, enum machine_mode));\n-extern int odd_relop PARAMS ((rtx, enum machine_mode));\n-extern int relop_no_unsigned PARAMS ((rtx, enum machine_mode));\n-extern int equality_op PARAMS ((rtx, enum machine_mode));\n-extern int pc_or_label_ref PARAMS ((rtx, enum machine_mode));\n-extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n-#ifdef TREE_CODE\n-extern void m88k_va_start PARAMS ((tree, rtx));\n-#endif /* TREE_CODE */\n-#endif /* RTX_CODE */\n-\n-#ifdef ANSI_PROTOTYPES\n-struct m88k_lang_independent_options;\n-#endif\n-extern void output_file_start PARAMS ((FILE *,\n-\t\t\t\t       const struct m88k_lang_independent_options *,\n-\t\t\t\t       int,\n-\t\t\t\t       const struct m88k_lang_independent_options *,\n-\t\t\t\t       int));\n-\n-extern int null_prologue PARAMS ((void));\n-extern int integer_ok_for_set PARAMS ((unsigned));\n-extern void m88k_layout_frame PARAMS ((void));\n-extern void m88k_expand_prologue PARAMS ((void));\n-extern void m88k_expand_epilogue PARAMS ((void));\n-extern void output_function_profiler PARAMS ((FILE *, int, const char *, int));\n-extern void output_ascii PARAMS ((FILE *, const char *, int,\n-\t\t\t\t  const char *, int));\n-extern void output_label PARAMS ((int));\n-extern struct rtx_def *m88k_builtin_saveregs PARAMS ((void));\n-extern enum m88k_instruction classify_integer PARAMS ((enum machine_mode, int));\n-extern int mak_mask_p PARAMS ((int));\n-\n-#ifdef TREE_CODE\n-extern struct rtx_def *m88k_function_arg PARAMS ((CUMULATIVE_ARGS,\n-\t\t\t\t\t\t  enum machine_mode, tree,\n-\t\t\t\t\t\t  int));\n-extern struct rtx_def *m88k_va_arg PARAMS ((tree, tree));\n-extern tree m88k_build_va_list PARAMS ((void));\n-#endif /* TREE_CODE */"}, {"sha": "a27d8a3acbe3e2da93318e2dacd07a882384850a", "filename": "gcc/config/m88k/m88k.c", "status": "removed", "additions": 0, "deletions": 3457, "changes": 3457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "442c62aa9e68992d16a50c8aec970e50e44fff9c", "filename": "gcc/config/m88k/m88k.h", "status": "removed", "additions": 0, "deletions": 2221, "changes": 2221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,2221 +0,0 @@\n-/* Definitions of target machine for GNU compiler for\n-   Motorola m88100 in an 88open OCS/BCS environment.\n-   Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002 Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com).\n-   Currently maintained by (gcc@dg-rtp.dg.com)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* The m88100 port of GNU CC adheres to the various standards from 88open.\n-   These documents are available by writing:\n-\n-\t88open Consortium Ltd.\n-\t100 Homeland Court, Suite 800\n-\tSan Jose, CA  95112\n-\t(408) 436-6600\n-\n-   In brief, the current standards are:\n-\n-   Binary Compatibility Standard, Release 1.1A, May 1991\n-\tThis provides for portability of application-level software at the\n-\texecutable level for AT&T System V Release 3.2.\n-\n-   Object Compatibility Standard, Release 1.1A, May 1991\n-\tThis provides for portability of application-level software at the\n-\tobject file and library level for C, Fortran, and Cobol, and again,\n-\tlargely for SVR3.\n-\n-   Under development are standards for AT&T System V Release 4, based on the\n-   [generic] System V Application Binary Interface from AT&T.  These include:\n-\n-   System V Application Binary Interface, Motorola 88000 Processor Supplement\n-\tAnother document from AT&T for SVR4 specific to the m88100.\n-\tAvailable from Prentice Hall.\n-\n-   System V Application Binary Interface, Motorola 88000 Processor Supplement,\n-   Release 1.1, Draft H, May 6, 1991\n-\tA proposed update to the AT&T document from 88open.\n-\n-   System V ABI Implementation Guide for the M88000 Processor,\n-   Release 1.0, January 1991\n-\tA companion ABI document from 88open.  */\n-\n-/* Other *.h files in config/m88k include this one and override certain items.\n-   Currently these are sysv3.h, sysv4.h, dgux.h, dolph.h, tekXD88.h, and luna.h.\n-   Additionally, sysv4.h and dgux.h include svr4.h first.  All other\n-   m88k targets except luna.h are based on svr3.h.  */\n-\n-/* Choose SVR3 as the default.  */\n-#if !defined(DBX_DEBUGGING_INFO) && !defined(DWARF_DEBUGGING_INFO)\n-#include \"svr3.h\"\n-#endif\n-\f\n-/* External types used.  */\n-\n-/* What instructions are needed to manufacture an integer constant.  */\n-enum m88k_instruction {\n-  m88k_zero,\n-  m88k_or,\n-  m88k_subu,\n-  m88k_or_lo16,\n-  m88k_or_lo8,\n-  m88k_set,\n-  m88k_oru_hi16,\n-  m88k_oru_or\n-};\n-\n-/* Which processor to schedule for.  The elements of the enumeration\n-   must match exactly the cpu attribute in the m88k.md machine description. */\n-\n-enum processor_type {\n-  PROCESSOR_M88100,\n-  PROCESSOR_M88110,\n-  PROCESSOR_M88000\n-};\n-\n-/* Recast the cpu class to be the cpu attribute.  */\n-#define m88k_cpu_attr ((enum attr_cpu)m88k_cpu)\n-\n-/* External variables/functions defined in m88k.c.  */\n-\n-extern const char *m88k_pound_sign;\n-extern const char *m88k_short_data;\n-extern const char *m88k_version;\n-extern char m88k_volatile_code;\n-\n-extern unsigned m88k_gp_threshold;\n-extern int m88k_prologue_done;\n-extern int m88k_function_number;\n-extern int m88k_fp_offset;\n-extern int m88k_stack_size;\n-extern int m88k_case_index;\n-\n-extern struct rtx_def *m88k_compare_reg;\n-extern struct rtx_def *m88k_compare_op0;\n-extern struct rtx_def *m88k_compare_op1;\n-\n-extern enum processor_type m88k_cpu;\n-\n-/* external variables defined elsewhere in the compiler */\n-\n-extern int target_flags;\t\t\t/* -m compiler switches */\n-extern int frame_pointer_needed;\t\t/* current function has a FP */\n-extern int flag_delayed_branch;\t\t\t/* -fdelayed-branch */\n-extern int flag_pic;\t\t\t\t/* -fpic */\n-\n-/* Specify the default monitors.  The meaning of these values can\n-   be obtained by doing \"grep MONITOR_GCC *m88k*\".  Generally, the\n-   values downward from 0x8000 are tests that will soon go away.\n-   values upward from 0x1 are generally useful tests that will remain.  */\n-\n-#ifndef MONITOR_GCC\n-#define MONITOR_GCC 0\n-#endif\n-\f\n-/*** Controlling the Compilation Driver, `gcc' ***/\n-/* Show we can debug even without a frame pointer.  */\n-#define CAN_DEBUG_WITHOUT_FP\n-\n-/* If -m88100 is in effect, add -D__m88100__; similarly for -m88110.\n-   Here, the CPU_DEFAULT is assumed to be -m88100.  */\n-#undef\tCPP_SPEC\n-#define\tCPP_SPEC \"%{!m88000:%{!m88100:%{m88110:-D__m88110__}}} \\\n-\t\t  %{!m88000:%{!m88110:-D__m88100__}}\"\n-\n-/* LIB_SPEC, LINK_SPEC, and STARTFILE_SPEC defined in svr3.h.\n-   ASM_SPEC, ASM_FINAL_SPEC, LIB_SPEC, LINK_SPEC, and STARTFILE_SPEC redefined\n-   in svr4.h.\n-   CPP_SPEC, ASM_SPEC, ASM_FINAL_SPEC, LIB_SPEC, LINK_SPEC, and\n-   STARTFILE_SPEC redefined in dgux.h.  */\n-\f\n-/*** Run-time Target Specification ***/\n-\n-/* Names to predefine in the preprocessor for this target machine.\n-   Redefined in sysv3.h, sysv4.h, dgux.h, and luna.h.  */\n-#define CPP_PREDEFINES \"-Dm88000 -Dm88k -Dunix -D__CLASSIFY_TYPE__=2\"\n-\n-#define TARGET_VERSION fprintf (stderr, \" (%s)\", VERSION_INFO1)\n-\n-#ifndef VERSION_INFO1\n-#define VERSION_INFO1\t\"m88k\"\n-#endif\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define MASK_88100\t\t0x00000001 /* Target m88100 */\n-#define MASK_88110\t\t0x00000002 /* Target m88110 */\n-#define MASK_88000 \t\t(MASK_88100 | MASK_88110)\n-\n-#define MASK_OCS_DEBUG_INFO\t0x00000004 /* Emit .tdesc info */\n-#define MASK_OCS_FRAME_POSITION\t0x00000008 /* Debug frame = CFA, not r30 */\n-#define MASK_SVR4\t\t0x00000010 /* Target is AT&T System V.4 */\n-#define MASK_SVR3\t\t0x00000020 /* Target is AT&T System V.3 */\n-#define MASK_NO_UNDERSCORES\t0x00000040 /* Don't emit a leading `_' */\n-#define MASK_BIG_PIC\t\t0x00000080 /* PIC with large got-rel's -fPIC */\n-#define MASK_TRAP_LARGE_SHIFT\t0x00000100 /* Trap if shift not <= 31 */\n-#define MASK_HANDLE_LARGE_SHIFT\t0x00000200 /* Handle shift count >= 32 */\n-#define MASK_CHECK_ZERO_DIV\t0x00000400 /* Check for int div. by 0 */\n-#define MASK_USE_DIV\t\t0x00000800 /* No signed div. checks */\n-#define MASK_IDENTIFY_REVISION\t0x00001000 /* Emit ident, with GCC rev */\n-#define MASK_WARN_PASS_STRUCT\t0x00002000 /* Warn about passed structs */\n-#define MASK_OPTIMIZE_ARG_AREA\t0x00004000 /* Save stack space */\n-#define MASK_NO_SERIALIZE_VOLATILE 0x00008000 /* Serialize volatile refs */\n-#define MASK_EITHER_LARGE_SHIFT\t(MASK_TRAP_LARGE_SHIFT | \\\n-\t\t\t\t MASK_HANDLE_LARGE_SHIFT)\n-#define MASK_OMIT_LEAF_FRAME_POINTER 0x00020000 /* omit leaf frame pointers */\n-\n-\n-#define TARGET_88100   \t\t ((target_flags & MASK_88000) == MASK_88100)\n-#define TARGET_88110\t\t ((target_flags & MASK_88000) == MASK_88110)\n-#define TARGET_88000\t\t ((target_flags & MASK_88000) == MASK_88000)\n-\n-#define TARGET_OCS_DEBUG_INFO\t  (target_flags & MASK_OCS_DEBUG_INFO)\n-#define TARGET_OCS_FRAME_POSITION (target_flags & MASK_OCS_FRAME_POSITION)\n-#define TARGET_SVR4\t\t  (target_flags & MASK_SVR4)\n-#define TARGET_SVR3\t\t  (target_flags & MASK_SVR3)\n-#define TARGET_NO_UNDERSCORES\t  (target_flags & MASK_NO_UNDERSCORES)\n-#define TARGET_BIG_PIC\t\t  (target_flags & MASK_BIG_PIC)\n-#define TARGET_TRAP_LARGE_SHIFT   (target_flags & MASK_TRAP_LARGE_SHIFT)\n-#define TARGET_HANDLE_LARGE_SHIFT (target_flags & MASK_HANDLE_LARGE_SHIFT)\n-#define TARGET_CHECK_ZERO_DIV\t  (target_flags & MASK_CHECK_ZERO_DIV)\n-#define\tTARGET_USE_DIV\t\t  (target_flags & MASK_USE_DIV)\n-#define TARGET_IDENTIFY_REVISION  (target_flags & MASK_IDENTIFY_REVISION)\n-#define TARGET_WARN_PASS_STRUCT   (target_flags & MASK_WARN_PASS_STRUCT)\n-#define TARGET_OPTIMIZE_ARG_AREA  (target_flags & MASK_OPTIMIZE_ARG_AREA)\n-#define TARGET_SERIALIZE_VOLATILE (!(target_flags & MASK_NO_SERIALIZE_VOLATILE))\n-\n-#define TARGET_EITHER_LARGE_SHIFT (target_flags & MASK_EITHER_LARGE_SHIFT)\n-#define TARGET_OMIT_LEAF_FRAME_POINTER (target_flags & MASK_OMIT_LEAF_FRAME_POINTER)\n-\n-/*  Redefined in sysv3.h, sysv4.h, and dgux.h.  */\n-#define TARGET_DEFAULT\t(MASK_CHECK_ZERO_DIV)\n-#define CPU_DEFAULT MASK_88100\n-\n-#define TARGET_SWITCHES \\\n-  { \\\n-    { \"88110\",\t\t\t\t MASK_88110 }, \\\n-    { \"88100\",\t\t\t\t MASK_88100 }, \\\n-    { \"88000\",\t\t\t         MASK_88000 }, \\\n-    { \"ocs-debug-info\",\t\t\t MASK_OCS_DEBUG_INFO }, \\\n-    { \"no-ocs-debug-info\",\t\t-MASK_OCS_DEBUG_INFO }, \\\n-    { \"ocs-frame-position\",\t\t MASK_OCS_FRAME_POSITION }, \\\n-    { \"no-ocs-frame-position\",\t\t-MASK_OCS_FRAME_POSITION }, \\\n-    { \"svr4\",\t\t\t         MASK_SVR4 }, \\\n-    { \"svr3\",\t\t\t        -MASK_SVR4 }, \\\n-    { \"no-underscores\",\t\t\t MASK_NO_UNDERSCORES }, \\\n-    { \"big-pic\",\t\t\t MASK_BIG_PIC }, \\\n-    { \"trap-large-shift\",\t\t MASK_TRAP_LARGE_SHIFT }, \\\n-    { \"handle-large-shift\",\t\t MASK_HANDLE_LARGE_SHIFT }, \\\n-    { \"check-zero-division\",\t\t MASK_CHECK_ZERO_DIV }, \\\n-    { \"no-check-zero-division\",\t\t-MASK_CHECK_ZERO_DIV }, \\\n-    { \"use-div-instruction\",\t\t MASK_USE_DIV }, \\\n-    { \"identify-revision\",\t\t MASK_IDENTIFY_REVISION }, \\\n-    { \"warn-passed-structs\",\t\t MASK_WARN_PASS_STRUCT }, \\\n-    { \"optimize-arg-area\",\t\t MASK_OPTIMIZE_ARG_AREA }, \\\n-    { \"no-optimize-arg-area\",\t\t-MASK_OPTIMIZE_ARG_AREA }, \\\n-    { \"no-serialize-volatile\",\t\t MASK_NO_SERIALIZE_VOLATILE }, \\\n-    { \"serialize-volatile\",\t\t-MASK_NO_SERIALIZE_VOLATILE }, \\\n-    { \"omit-leaf-frame-pointer\",\t MASK_OMIT_LEAF_FRAME_POINTER }, \\\n-    { \"no-omit-leaf-frame-pointer\",     -MASK_OMIT_LEAF_FRAME_POINTER }, \\\n-    SUBTARGET_SWITCHES \\\n-    /* Default switches */ \\\n-    { \"\",\t\t\t\t TARGET_DEFAULT }, \\\n-  }\n-\n-/* Redefined in dgux.h.  */\n-#define SUBTARGET_SWITCHES\n-\n-/* Macro to define table for command options with values.  */\n-\n-#define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data, 0}, \\\n-\t\t\t { \"version-\", &m88k_version, 0} }\n-\n-/* Do any checking or such that is needed after processing the -m switches.  */\n-\n-#define OVERRIDE_OPTIONS\t\t\t\t\t\t     \\\n-  do {\t\t\t\t\t\t\t\t\t     \\\n-    register int i;\t\t\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-    if ((target_flags & MASK_88000) == 0)\t\t\t\t     \\\n-      target_flags |= CPU_DEFAULT;\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-    if (TARGET_88110)\t\t\t\t\t\t\t     \\\n-      {\t\t\t\t\t\t\t\t\t     \\\n-        target_flags |= MASK_USE_DIV;\t\t\t\t\t     \\\n-        target_flags &= ~MASK_CHECK_ZERO_DIV;\t\t\t\t     \\\n-      }\t\t\t\t\t\t\t\t\t     \\\n-      \t\t\t\t\t\t\t\t\t     \\\n-    m88k_cpu = (TARGET_88000 ? PROCESSOR_M88000\t\t\t\t     \\\n-\t\t: (TARGET_88100 ? PROCESSOR_M88100 : PROCESSOR_M88110));\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-    if (TARGET_BIG_PIC)\t\t\t\t\t\t\t     \\\n-      flag_pic = 2;\t\t\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-    if ((target_flags & MASK_EITHER_LARGE_SHIFT) == MASK_EITHER_LARGE_SHIFT) \\\n-      error (\"-mtrap-large-shift and -mhandle-large-shift are incompatible\");\\\n-\t\t\t\t\t\t\t\t\t     \\\n-    if (TARGET_SVR4)\t\t\t\t\t\t     \t     \\\n-      {\t\t\t\t\t\t\t\t\t     \\\n-\tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\t\t     \\\n-\t  reg_names[i]--;\t\t\t\t\t\t     \\\n-\tm88k_pound_sign = \"#\";\t\t\t\t\t\t     \\\n-      }\t\t\t\t\t\t\t\t\t     \\\n-    else\t\t\t\t\t\t\t\t     \\\n-      {\t\t\t\t\t\t\t\t\t     \\\n-\ttarget_flags |= MASK_SVR3;\t\t\t\t\t     \\\n-\ttarget_flags &= ~MASK_SVR4;\t\t\t\t\t     \\\n-      }\t\t\t\t\t\t\t\t\t     \\\n-\t\t\t\t\t\t\t\t\t     \\\n-    if (m88k_short_data)\t\t\t\t\t\t     \\\n-      {\t\t\t\t\t\t\t\t\t     \\\n-\tconst char *p = m88k_short_data;\t\t\t\t     \\\n-\twhile (*p)\t\t\t\t\t\t\t     \\\n-\t  if (ISDIGIT (*p))\t\t\t\t\t\t     \\\n-\t    p++;\t\t\t\t\t\t\t     \\\n-\t  else\t\t\t\t\t\t\t\t     \\\n-\t    {\t\t\t\t\t\t\t\t     \\\n-\t      error (\"invalid option `-mshort-data-%s'\", m88k_short_data);   \\\n-\t      break;\t\t\t\t\t\t\t     \\\n-\t    }\t\t\t\t\t\t\t\t     \\\n-\tm88k_gp_threshold = atoi (m88k_short_data);\t\t\t     \\\n-\tif (m88k_gp_threshold > 0x7fffffff)\t\t\t\t     \\\n-\t  error (\"-mshort-data-%s is too large \", m88k_short_data);          \\\n-\tif (flag_pic)\t\t\t\t\t\t\t     \\\n-\t  error (\"-mshort-data-%s and PIC are incompatible\", m88k_short_data); \\\n-      }\t\t\t\t\t\t\t\t\t     \\\n-    if (TARGET_OMIT_LEAF_FRAME_POINTER)       /* keep nonleaf frame pointers */    \\\n-      flag_omit_frame_pointer = 1;                                         \\\n-  } while (0)\n-\f\n-/*** Storage Layout ***/\n-\n-/* Sizes in bits of the various types.  */\n-#define SHORT_TYPE_SIZE\t\t16\n-#define INT_TYPE_SIZE\t\t32\n-#define LONG_TYPE_SIZE\t\t32\n-#define LONG_LONG_TYPE_SIZE\t64\n-#define FLOAT_TYPE_SIZE\t\t32\n-#define\tDOUBLE_TYPE_SIZE\t64\n-#define LONG_DOUBLE_TYPE_SIZE\t64\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-   Somewhat arbitrary.  It matches the bit field patterns.  */\n-#define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.\n-   That is true on the m88000.  */\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.\n-   For the m88000 we can decide arbitrarily since there are no machine\n-   instructions for them.  */\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Largest alignment for stack parameters (if greater than PARM_BOUNDARY).  */\n-#define MAX_PARM_BOUNDARY 64\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 128\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  On the\n-   m88100, it is desirable to align to a cache line.  However, SVR3 targets\n-   only provided 8 byte alignment.  The m88110 cache is small, so align\n-   to an 8 byte boundary.  Pack code tightly when compiling crtstuff.c.  */\n-#define FUNCTION_BOUNDARY (flag_inhibit_size_directive ? 32 : \\\n-\t\t\t   (TARGET_88100 && TARGET_SVR4 ? 128 : 64))\n-\n-/* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 64\n-\n-/* The best alignment to use in cases where we have a choice.  */\n-#define FASTEST_ALIGNMENT (TARGET_88100 ? 32 : 64)\n-\n-/* Make strings 4/8 byte aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  ((TREE_CODE (EXP) == STRING_CST\t\\\n-    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n-   ? FASTEST_ALIGNMENT : (ALIGN))\n-\n-/* Make arrays of chars 4/8 byte aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n-\n-/* Alignment of field after `int : 0' in a structure.\n-   Ignored with PCC_BITFIELD_TYPE_MATTERS.  */\n-/* #define EMPTY_FIELD_BOUNDARY 8 */\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 1\n-\n-/* A bit-field declared as `int' forces `int' alignment for the struct.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* Maximum size (in bits) to use for the largest integral type that\n-   replaces a BLKmode type. */\n-/* #define MAX_FIXED_MODE_SIZE 0 */\n-\f\n-/*** Register Usage ***/\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-   The m88100 has a General Register File (GRF) of 32 32-bit registers.\n-   The m88110 adds an Extended Register File (XRF) of 32 80-bit registers.  */\n-#define FIRST_PSEUDO_REGISTER 64\n-#define FIRST_EXTENDED_REGISTER 32\n-\n-/*  General notes on extended registers, their use and misuse.\n-\n-    Possible good uses:\n-\n-    spill area instead of memory.\n-      -waste if only used once\n-\n-    floating point calculations\n-      -probably a waste unless we have run out of general purpose registers\n-\n-    freeing up general purpose registers\n-      -e.g. may be able to have more loop invariants if floating\n-       point is moved into extended registers.\n-\n-\n-    I've noticed wasteful moves into and out of extended registers; e.g. a load\n-    into x21, then inside a loop a move into r24, then r24 used as input to\n-    an fadd.  Why not just load into r24 to begin with?  Maybe the new cse.c\n-    will address this.  This wastes a move, but the load,store and move could\n-    have been saved had extended registers been used throughout.\n-    E.g. in the code following code, if z and xz are placed in extended\n-    registers, there is no need to save preserve registers.\n-\n-\tlong c=1,d=1,e=1,f=1,g=1,h=1,i=1,j=1,k;\n-\n-\tdouble z=0,xz=4.5;\n-\n-\tfoo(a,b)\n-\tlong a,b;\n-\t{\n-\t  while (a < b)\n-\t    {\n-\t      k = b + c + d + e + f + g + h + a + i + j++;\n-\t      z += xz;\n-\t      a++;\n-\t    }\n-\t  printf(\"k= %d; z=%f;\\n\", k, z);\n-\t}\n-\n-    I've found that it is possible to change the constraints (putting * before\n-    the 'r' constraints int the fadd.ddd instruction) and get the entire\n-    addition and store to go into extended registers.  However, this also\n-    forces simple addition and return of floating point arguments to a\n-    function into extended registers.  Not the correct solution.\n-\n-    Found the following note in local-alloc.c which may explain why I can't\n-    get both registers to be in extended registers since two are allocated in\n-    local-alloc and one in global-alloc.  Doesn't explain (I don't believe)\n-    why an extended register is used instead of just using the preserve\n-    register.\n-\n-\tfrom local-alloc.c:\n-\tWe have provision to exempt registers, even when they are contained\n-\twithin the block, that can be tied to others that are not contained in it.\n-\tThis is so that global_alloc could process them both and tie them then.\n-\tBut this is currently disabled since tying in global_alloc is not\n-\tyet implemented.\n-\n-    The explanation of why the preserved register is not used is as follows,\n-    I believe.  The registers are being allocated in order.  Tying is not\n-    done so efficiently, so when it comes time to do the first allocation,\n-    there are no registers left to use without spilling except extended\n-    registers.  Then when the next pseudo register needs a hard reg, there\n-    are still no registers to be had for free, but this one must be a GRF\n-    reg instead of an extended reg, so a preserve register is spilled.  Thus\n-    the move from extended to GRF is necessitated.  I do not believe this can\n-    be 'fixed' through the files in config/m88k.\n-\n-    gcc seems to sometimes make worse use of register allocation -- not counting\n-    moves -- whenever extended registers are present.  For example in the\n-    whetstone, the simple for loop (slightly modified)\n-      for(i = 1; i <= n1; i++)\n-\t{\n-\t  x1 = (x1 + x2 + x3 - x4) * t;\n-\t  x2 = (x1 + x2 - x3 + x4) * t;\n-\t  x3 = (x1 - x2 + x3 + x4) * t;\n-\t  x4 = (x1 + x2 + x3 + x4) * t;\n-\t}\n-    in general loads the high bits of the addresses of x2-x4 and i into registers\n-    outside the loop.  Whenever extended registers are used, it loads all of\n-    these inside the loop. My conjecture is that since the 88110 has so many\n-    registers, and gcc makes no distinction at this point -- just that they are\n-    not fixed, that in loop.c it believes it can expect a number of registers\n-    to be available.  Then it allocates 'too many' in local-alloc which causes\n-    problems later.  'Too many' are allocated because a large portion of the\n-    registers are extended registers and cannot be used for certain purposes\n-    ( e.g. hold the address of a variable).  When this loop is compiled on its\n-    own, the problem does not occur.  I don't know the solution yet, though it\n-    is probably in the base sources.  Possibly a different way to calculate\n-    \"threshold\".  */\n-\n-/* 1 for registers that have pervasive standard uses and are not available\n-   for the register allocator.  Registers r14-r25 and x22-x29 are expected\n-   to be preserved across function calls.\n-\n-   On the 88000, the standard uses of the General Register File (GRF) are:\n-   Reg 0\t= Pseudo argument pointer (hardware fixed to 0).\n-   Reg 1\t= Subroutine return pointer (hardware).\n-   Reg 2-9\t= Parameter registers (OCS).\n-   Reg 10\t= OCS reserved temporary.\n-   Reg 11\t= Static link if needed [OCS reserved temporary].\n-   Reg 12\t= Address of structure return (OCS).\n-   Reg 13\t= OCS reserved temporary.\n-   Reg 14-25\t= Preserved register set.\n-   Reg 26-29\t= Reserved by OCS and ABI.\n-   Reg 30\t= Frame pointer (Common use).\n-   Reg 31\t= Stack pointer.\n-\n-   The following follows the current 88open UCS specification for the\n-   Extended Register File (XRF):\n-   Reg 32       = x0\t\tAlways equal to zero\n-   Reg 33-53\t= x1-x21\tTemporary registers (Caller Save)\n-   Reg 54-61\t= x22-x29\tPreserver registers (Callee Save)\n-   Reg 62-63\t= x30-x31\tReserved for future ABI use.\n-\n-   Note:  The current 88110 extended register mapping is subject to change.\n-\t  The bias towards caller-save registers is based on the\n-\t  presumption that memory traffic can potentially be reduced by\n-\t  allowing the \"caller\" to save only that part of the register\n-\t  which is actually being used.  (i.e. don't do a st.x if a st.d\n-\t  is sufficient).  Also, in scientific code (a.k.a. Fortran), the\n-\t  large number of variables defined in common blocks may require\n-\t  that almost all registers be saved across calls anyway.  */\n-\n-#define FIXED_REGISTERS \\\n- {1, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 0, 0, \\\n-  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 1, 1,  1, 1, 1, 1, \\\n-  1, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 0, 0, \\\n-  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 1, 1}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-\n-#define CALL_USED_REGISTERS \\\n- {1, 1, 1, 1,  1, 1, 1, 1,   1, 1, 1, 1,  1, 1, 0, 0, \\\n-  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 1, 1,  1, 1, 1, 1, \\\n-  1, 1, 1, 1,  1, 1, 1, 1,   1, 1, 1, 1,  1, 1, 1, 1, \\\n-  1, 1, 1, 1,  1, 1, 0, 0,   0, 0, 0, 0,  0, 0, 1, 1}\n-\n-/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (! TARGET_88110)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tregister int i;\t\t\t\t\t\\\n-\t  for (i = FIRST_EXTENDED_REGISTER; i < FIRST_PSEUDO_REGISTER; i++) \\\n-\t    {\t\t\t\t\t\t\\\n-\t      fixed_regs[i] = 1;\t\t\t\\\n-\t      call_used_regs[i] = 1;\t\t\t\\\n-\t    }\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    if (flag_pic)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\t/* Current hack to deal with -fpic -O2 problems.  */ \\\n-\tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n-\tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n-\tglobal_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n-      }\t\t\t\t\t\t\t\\\n-  }\n-\n-/* True if register is an extended register.  */\n-#define XRF_REGNO_P(N) ((N) < FIRST_PSEUDO_REGISTER && (N) >= FIRST_EXTENDED_REGISTER)\n- \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On the m88000, GRF registers hold 32-bits and XRF registers hold 80-bits.\n-   An XRF register can hold any mode, but two GRF registers are required\n-   for larger modes.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-  (XRF_REGNO_P (REGNO)                                                 \\\n-   ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-\n-   For double integers, we never put the value into an odd register so that\n-   the operators don't run into the situation where the high part of one of\n-   the inputs is the low part of the result register.  (It's ok if the output\n-   registers are the same as the input registers.)  The XRF registers can\n-   hold all modes, but only DF and SF modes can be manipulated in these\n-   registers.  The compiler should be allowed to use these as a fast spill\n-   area.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  (XRF_REGNO_P(REGNO)\t\t\t\t\t\t\t\\\n-    ? (TARGET_88110 && GET_MODE_CLASS (MODE) == MODE_FLOAT)             \\\n-    : (((MODE) != DImode && (MODE) != DFmode && (MODE) != DCmode)\t\\\n-       || ((REGNO) & 1) == 0))\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (((MODE1) == DFmode || (MODE1) == DCmode || (MODE1) == DImode \\\n-    || (TARGET_88110 && GET_MODE_CLASS (MODE1) == MODE_FLOAT)) \\\n-   == ((MODE2) == DFmode || (MODE2) == DCmode || (MODE2) == DImode \\\n-       || (TARGET_88110 && GET_MODE_CLASS (MODE2) == MODE_FLOAT)))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* the m88000 pc isn't overloaded on a register that the compiler knows about.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 31\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 30\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 0\n-\n-/* Register used in cases where a temporary is known to be safe to use.  */\n-#define TEMP_REGNUM 10\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 11\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM 12\n-\n-/* Register to hold the addressing base for position independent\n-   code access to data items.  */\n-#define PIC_OFFSET_TABLE_REGNUM 25\n-\n-/* Order in which registers are preferred (most to least).  Use temp\n-   registers, then param registers top down.  Preserve registers are\n-   top down to maximize use of double memory ops for register save.\n-   The 88open reserved registers (r26-r29 and x30-x31) may commonly be used\n-   in most environments with the -fcall-used- or -fcall-saved- options.  */\n-#define REG_ALLOC_ORDER\t\t  \\\n- {\t\t\t\t  \\\n-  13, 12, 11, 10, 29, 28, 27, 26, \\\n-  62, 63,  9,  8,  7,  6,  5,  4, \\\n-   3,  2,  1, 53, 52, 51, 50, 49, \\\n-  48, 47, 46, 45, 44, 43, 42, 41, \\\n-  40, 39, 38, 37, 36, 35, 34, 33, \\\n-  25, 24, 23, 22, 21, 20, 19, 18, \\\n-  17, 16, 15, 14, 61, 60, 59, 58, \\\n-  57, 56, 55, 54, 30, 31,  0, 32}\n-\n-/* Order for leaf functions.  */\n-#define REG_LEAF_ALLOC_ORDER\t  \\\n- {\t\t\t\t  \\\n-   9,  8,  7,  6, 13, 12, 11, 10, \\\n-  29, 28, 27, 26, 62, 63,  5,  4, \\\n-   3,  2,  0, 53, 52, 51, 50, 49, \\\n-  48, 47, 46, 45, 44, 43, 42, 41, \\\n-  40, 39, 38, 37, 36, 35, 34, 33, \\\n-  25, 24, 23, 22, 21, 20, 19, 18, \\\n-  17, 16, 15, 14, 61, 60, 59, 58, \\\n-  57, 56, 55, 54, 30, 31,  1, 32}\n-\n-/* Switch between the leaf and non-leaf orderings.  The purpose is to avoid\n-   write-over scoreboard delays between caller and callee.  */\n-#define ORDER_REGS_FOR_LOCAL_ALLOC\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  static const int leaf[] = REG_LEAF_ALLOC_ORDER;\t\t\\\n-  static const int nonleaf[] = REG_ALLOC_ORDER;\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  memcpy (reg_alloc_order, regs_ever_live[1] ? nonleaf : leaf,\t\\\n-\t  FIRST_PSEUDO_REGISTER * sizeof (int));\t\t\\\n-}\n-\f\n-/*** Register Classes ***/\n-\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-/* The m88000 hardware has two kinds of registers.  In addition, we denote\n-   the arg pointer as a separate class.  */\n-\n-enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n-\t\t XGRF_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.   */\n-#define REG_CLASS_NAMES {\"NO_REGS\", \"AP_REG\", \"XRF_REGS\", \"GENERAL_REGS\", \\\n-\t\t\t \"AGRF_REGS\", \"XGRF_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-#define REG_CLASS_CONTENTS {{0x00000000, 0x00000000},\t\\\n-\t\t\t    {0x00000001, 0x00000000},\t\\\n-\t\t\t    {0x00000000, 0xffffffff},\t\\\n-\t\t\t    {0xfffffffe, 0x00000000},\t\\\n-\t\t\t    {0xffffffff, 0x00000000},\t\\\n-\t\t\t    {0xfffffffe, 0xffffffff},\t\\\n-\t\t\t    {0xffffffff, 0xffffffff}}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-#define REGNO_REG_CLASS(REGNO) \\\n-  ((REGNO) ? ((REGNO < 32) ? GENERAL_REGS : XRF_REGS) : AP_REG)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-#define BASE_REG_CLASS AGRF_REGS\n-#define INDEX_REG_CLASS GENERAL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.\n-   For the 88000, the following class/letter is defined for the XRF:\n-\tx - Extended register file  */\n-#define REG_CLASS_FROM_LETTER(C) \t\\\n-   (((C) == 'x') ? XRF_REGS : NO_REGS)\n-\n-/* Macros to check register numbers against specific register classes.\n-   These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n-  ((REGNO) < FIRST_EXTENDED_REGISTER\t\t\t\t\\\n-   || (unsigned) reg_renumber[REGNO] < FIRST_EXTENDED_REGISTER)\n-#define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\\\n-  (((REGNO) && (REGNO) < FIRST_EXTENDED_REGISTER)\t\t\\\n-   || (unsigned) reg_renumber[REGNO] < FIRST_EXTENDED_REGISTER)\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-   Double constants should be in a register iff they can be made cheaply.  */\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n-   (CONSTANT_P(X) && (CLASS == XRF_REGS) ? NO_REGS : (CLASS))\n-\n-/* Return the register class of a scratch register needed to load IN\n-   into a register of class CLASS in MODE.  On the m88k, when PIC, we\n-   need a temporary when loading some addresses into a register.  */\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n-  ((flag_pic\t\t\t\t\t\t\t\\\n-    && GET_CODE (IN) == CONST\t\t\t\t\t\\\n-    && GET_CODE (XEXP (IN, 0)) == PLUS\t\t\t\t\\\n-    && GET_CODE (XEXP (XEXP (IN, 0), 0)) == CONST_INT\t\t\\\n-    && ! SMALL_INT (XEXP (XEXP (IN, 0), 1))) ? GENERAL_REGS : NO_REGS)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-  ((((CLASS) == XRF_REGS) ? 1 \\\n-    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n-\n-/* Letters in the range `I' through `P' in a register constraint string can\n-   be used to stand for particular ranges of immediate operands.  The C\n-   expression is true iff C is a known letter and VALUE is appropriate for\n-   that letter.\n-\n-   For the m88000, the following constants are used:\n-   `I' requires a non-negative 16-bit value.\n-   `J' requires a non-positive 16-bit value.\n-   `K' requires a non-negative value < 32.\n-   `L' requires a constant with only the upper 16-bits set.\n-   `M' requires constant values that can be formed with `set'.\n-   `N' requires a negative value.\n-   `O' requires zero.\n-   `P' requires a non-negative value.  */\n-\n-/* Quick tests for certain values.  */\n-#define SMALL_INT(X) (SMALL_INTVAL (INTVAL (X)))\n-#define SMALL_INTVAL(I) ((unsigned) (I) < 0x10000)\n-#define ADD_INT(X) (ADD_INTVAL (INTVAL (X)))\n-#define ADD_INTVAL(I) ((unsigned) (I) + 0xffff < 0x1ffff)\n-#define POWER_OF_2(I) ((I) && POWER_OF_2_or_0(I))\n-#define POWER_OF_2_or_0(I) (((I) & ((unsigned)(I) - 1)) == 0)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\\\n-  ((C) == 'I' ? SMALL_INTVAL (VALUE)\t\t\t\\\n-   : (C) == 'J' ? SMALL_INTVAL (-(VALUE))\t\t\\\n-   : (C) == 'K' ? (unsigned)(VALUE) < 32\t\t\\\n-   : (C) == 'L' ? ((VALUE) & 0xffff) == 0\t\t\\\n-   : (C) == 'M' ? integer_ok_for_set (VALUE)\t\t\\\n-   : (C) == 'N' ? (VALUE) < 0\t\t\t\t\\\n-   : (C) == 'O' ? (VALUE) == 0\t\t\t\t\\\n-   : (C) == 'P' ? (VALUE) >= 0\t\t\t\t\\\n-   : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  For the m88000, the\n-   constraints are:  `G' requires zero, and `H' requires one or two.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((C) == 'G' ? (CONST_DOUBLE_HIGH (VALUE) == 0\t\t\t\t\\\n-\t\t && CONST_DOUBLE_LOW (VALUE) == 0)\t\t\t\\\n-   : 0)\n-\n-/* Letters in the range `Q' through `U' in a register constraint string\n-   may be defined in a machine-dependent fashion to stand for arbitrary\n-   operand types.\n-\n-   For the m88k, `Q' handles addresses in a call context.  */\n-\n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q' ? symbolic_address_p (OP) : 0)\n-\f\n-/*** Describing Stack Layout ***/\n-\n-/* Define this if pushing a word on the stack moves the stack pointer\n-   to a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the addresses of local variable slots are at negative\n-   offsets from the frame pointer.  */\n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-/* Offset from the frame pointer to the first local variable slot to be\n-   allocated. For the m88k, the debugger wants the return address (r1)\n-   stored at location r30+4, and the previous frame pointer stored at\n-   location r30.  */\n-#define STARTING_FRAME_OFFSET 8\n-\n-/* If we generate an insn to push BYTES bytes, this says how many the\n-   stack pointer really advances by.  The m88k has no push instruction.  */\n-/*  #define PUSH_ROUNDING(BYTES) */\n-\n-/* If defined, the maximum amount of space required for outgoing arguments\n-   will be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  No space will be pushed\n-   onto the stack for each call; instead, the function prologue should\n-   increase the stack frame size by this amount.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Offset from the stack pointer register to the first location at which\n-   outgoing arguments are placed.  Use the default value zero.  */\n-/* #define STACK_POINTER_OFFSET 0 */\n-\n-/* Offset of first parameter from the argument pointer register value.\n-   Using an argument pointer, this is 0 for the m88k.  GCC knows\n-   how to eliminate the argument pointer references if necessary.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* Define this if functions should assume that stack space has been\n-   allocated for arguments even when their values are passed in\n-   registers.\n-\n-   The value of this macro is the size, in bytes, of the area reserved for\n-   arguments passed in registers.\n-\n-   This space can either be allocated by the caller or be a part of the\n-   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE'\n-   says which.  */\n-#define REG_PARM_STACK_SPACE(FNDECL) 32\n-\n-/* Define this macro if REG_PARM_STACK_SPACE is defined but stack\n-   parameters don't skip the area specified by REG_PARM_STACK_SPACE.\n-   Normally, when a parameter is not passed in registers, it is placed on\n-   the stack beyond the REG_PARM_STACK_SPACE area.  Defining this macro\n-   suppresses this behavior and causes the parameter to be passed on the\n-   stack in its natural location.  */\n-#define STACK_PARMS_IN_REG_PARM_AREA\n-\n-/* Define this if it is the responsibility of the caller to allocate the\n-   area reserved for arguments passed in registers.  If\n-   `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect of this\n-   macro is to determine whether the space is included in\n-   `current_function_outgoing_args_size'.  */\n-/* #define OUTGOING_REG_PARM_STACK_SPACE */\n-\n-/* Offset from the stack pointer register to an item dynamically allocated\n-   on the stack, e.g., by `alloca'.\n-\n-   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n-   length of the outgoing arguments.  The default is correct for most\n-   machines.  See `function.c' for details.  */\n-/* #define STACK_DYNAMIC_OFFSET(FUNDECL) ... */\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.  */\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE) == BLKmode ? SImode : TYPE_MODE (VALTYPE), \\\n-\t       2)\n-\n-/* Define this if it differs from FUNCTION_VALUE.  */\n-/* #define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC) ... */\n-\n-/* Disable the promotion of some structures and unions to registers. */\n-#define RETURN_IN_MEMORY(TYPE) \\\n-  (TYPE_MODE (TYPE) == BLKmode \\\n-   || ((TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE(TYPE) == UNION_TYPE) \\\n-       && !(TYPE_MODE (TYPE) == SImode \\\n-\t    || (TYPE_MODE (TYPE) == BLKmode \\\n-\t\t&& TYPE_ALIGN (TYPE) == BITS_PER_WORD \\\n-\t\t&& int_size_in_bytes (TYPE) == UNITS_PER_WORD))))\n-\n-/* Don't default to pcc-struct-return, because we have already specified\n-   exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 2)\n-\n-/* True if N is a possible register number for a function value\n-   as seen by the caller.  */\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 2)\n-\n-/* Determine whether a function argument is passed in a register, and\n-   which register.  See m88k.c.  */\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  m88k_function_arg (CUM, MODE, TYPE, NAMED)\n-\n-/* Define this if it differs from FUNCTION_ARG.  */\n-/* #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) ... */\n-\n-/* A C expression for the number of words, at the beginning of an\n-   argument, must be put in registers.  The value must be zero for\n-   arguments that are passed entirely in registers or that are entirely\n-   pushed on the stack.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) (0)\n-\n-/* A C expression that indicates when an argument must be passed by\n-   reference.  If nonzero for an argument, a copy of that argument is\n-   made in memory and a pointer to the argument is passed instead of the\n-   argument itself.  The pointer is passed in whatever way is appropriate\n-   for passing a pointer to that type.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) (0)\n-\n-/* A C type for declaring a variable that is used as the first argument\n-   of `FUNCTION_ARG' and other related values.  It suffices to count\n-   the number of words of argument so far.  */\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a\n-   function whose data type is FNTYPE.  For a library call, FNTYPE is 0. */\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) ((CUM) = 0)\n-\n-/* A C statement (sans semicolon) to update the summarizer variable\n-   CUM to advance past an argument in the argument list.  The values\n-   MODE, TYPE and NAMED describe that argument.  Once this is done,\n-   the variable CUM is suitable for analyzing the *following* argument\n-   with `FUNCTION_ARG', etc.  (TYPE is null for libcalls where that\n-   information may not be available.)  */\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    enum machine_mode __mode = (TYPE) ? TYPE_MODE (TYPE) : (MODE);\t\\\n-    if ((CUM & 1)\t\t\t\t\t\t\t\\\n-\t&& (__mode == DImode || __mode == DFmode\t\t\t\\\n-\t    || ((TYPE) && TYPE_ALIGN (TYPE) > BITS_PER_WORD)))\t\t\\\n-      CUM++;\t\t\t\t\t\t\t\t\\\n-    CUM += (((__mode != BLKmode)\t\t\t\t\t\\\n-\t     ? GET_MODE_SIZE (MODE) : int_size_in_bytes (TYPE))\t\t\\\n-\t    + 3) / 4;\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* True if N is a possible register number for function argument passing.\n-   On the m88000, these are registers 2 through 9.  */\n-#define FUNCTION_ARG_REGNO_P(N) ((N) <= 9 && (N) >= 2)\n-\n-/* A C expression which determines whether, and in which direction,\n-   to pad out an argument with extra space.  The value should be of\n-   type `enum direction': either `upward' to pad above the argument,\n-   `downward' to pad below, or `none' to inhibit padding.\n-\n-   This macro does not control the *amount* of padding; that is always\n-   just enough to reach the next multiple of `FUNCTION_ARG_BOUNDARY'.  */\n-#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n-  ((MODE) == BLKmode \\\n-   || ((TYPE) && (TREE_CODE (TYPE) == RECORD_TYPE \\\n-\t\t  || TREE_CODE (TYPE) == UNION_TYPE)) \\\n-   ? upward : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY ? downward : none)\n-\n-/* If defined, a C expression that gives the alignment boundary, in bits,\n-   of an argument with the specified mode and type.  If it is not defined,\n-   `PARM_BOUNDARY' is used for all arguments.  */\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n-  (((TYPE) ? TYPE_ALIGN (TYPE) : GET_MODE_BITSIZE (MODE)) <= PARM_BOUNDARY \\\n-    ? PARM_BOUNDARY : 2 * PARM_BOUNDARY)\n-\n-/* Generate necessary RTL for __builtin_saveregs().\n-   ARGLIST is the argument list; see expr.c.  */\n-#define EXPAND_BUILTIN_SAVEREGS() m88k_builtin_saveregs ()\n-\n-/* Define the `__builtin_va_list' type for the ABI.  */\n-#define BUILD_VA_LIST_TYPE(VALIST) \\\n-  (VALIST) = m88k_build_va_list ()\n-\n-/* Implement `va_start' for varargs and stdarg.  */\n-#define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n-  m88k_va_start (valist, nextarg)\n-\n-/* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  m88k_va_arg (valist, type)\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  Redefined in sysv3.h, sysv4.h and\n-   dgux.h.  */\n-#define FUNCTION_PROFILER(FILE, LABELNO) \\\n-  output_function_profiler (FILE, LABELNO, \"mcount\", 1)\n-\n-/* Maximum length in instructions of the code output by FUNCTION_PROFILER.  */\n-#define FUNCTION_PROFILER_LENGTH (5+3+1+5)\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-#define EXIT_IGNORE_STACK (1)\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED \\\n-((TARGET_OMIT_LEAF_FRAME_POINTER && !leaf_function_p ()) \t\\\n- || (write_symbols != NO_DEBUG && !TARGET_OCS_FRAME_POSITION))\n-\n-/* Definitions for register eliminations.\n-\n-   We have two registers that can be eliminated on the m88k.  First, the\n-   frame pointer register can often be eliminated in favor of the stack\n-   pointer register.  Secondly, the argument pointer register can always be\n-   eliminated; it is replaced with either the stack or frame pointer.  */\n-\n-/* This is an array of structures.  Each structure initializes one pair\n-   of eliminable registers.  The \"from\" register number is given first,\n-   followed by \"to\".  Eliminations of the same \"from\" register are listed\n-   in order of preference.  */\n-#define ELIMINABLE_REGS\t\t\t\t\\\n-{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n- { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n- { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n-\n-/* Given FROM and TO register numbers, say whether this elimination\n-   is allowed.  */\n-#define CAN_ELIMINATE(FROM, TO) \\\n-  (!((FROM) == FRAME_POINTER_REGNUM && FRAME_POINTER_REQUIRED))\n-\n-/* Define the offset between two registers, one to be eliminated, and the other\n-   its replacement, at the start of a routine.  */\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t \\\n-{ m88k_layout_frame ();\t\t\t\t\t\t\t \\\n-  if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t \\\n-      (OFFSET) = m88k_fp_offset;\t\t\t\t\t \\\n-  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM) \\\n-    (OFFSET) = m88k_stack_size - m88k_fp_offset;\t\t\t \\\n-  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n-    (OFFSET) = m88k_stack_size;\t\t\t\t\t\t \\\n-  else\t\t\t\t\t\t\t\t\t \\\n-    abort ();\t\t\t\t\t\t\t\t \\\n-}\n-\f\n-/*** Trampolines for Nested Functions ***/\n-\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.\n-\n-   This block is placed on the stack and filled in.  It is aligned\n-   0 mod 128 and those portions that are executed are constant.\n-   This should work for instruction caches that have cache lines up\n-   to the aligned amount (128 is arbitrary), provided no other code\n-   producer is attempting to play the same game.  This of course is\n-   in violation of any number of 88open standards.  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  char buf[256];\t\t\t\t\t\t\t\\\n-  static int labelno = 0;\t\t\t\t\t\t\\\n-  labelno++;\t\t\t\t\t\t\t\t\\\n-  ASM_GENERATE_INTERNAL_LABEL (buf, \"LTRMP\", labelno);\t\t\t\\\n-  /* Save the return address (r1) in the static chain reg (r11).  */\t\\\n-  fprintf (FILE, \"\\tor\\t %s,%s,0\\n\", reg_names[11], reg_names[1]);\t\\\n-  /* Locate this block; transfer to the next instruction.  */\t\t\\\n-  fprintf (FILE, \"\\tbsr\\t %s\\n\", &buf[1]);\t\t\t\t\t\\\n-  (*targetm.asm_out.internal_label) (FILE, \"LTRMP\", labelno);\t\t\t\\\n-  /* Save r10; use it as the relative pointer; restore r1.  */\t\t\\\n-  fprintf (FILE, \"\\tst\\t %s,%s,24\\n\", reg_names[10], reg_names[1]);\t\\\n-  fprintf (FILE, \"\\tor\\t %s,%s,0\\n\", reg_names[10], reg_names[1]);\t\\\n-  fprintf (FILE, \"\\tor\\t %s,%s,0\\n\", reg_names[1], reg_names[11]);\t\\\n-  /* Load the function's address and go there.  */\t\t\t\\\n-  fprintf (FILE, \"\\tld\\t %s,%s,32\\n\", reg_names[11], reg_names[10]);\t\\\n-  fprintf (FILE, \"\\tjmp.n\\t %s\\n\", reg_names[11]);\t\t\t\\\n-  /* Restore r10 and load the static chain register.  */\t\t\\\n-  fprintf (FILE, \"\\tld.d\\t %s,%s,24\\n\", reg_names[10], reg_names[10]);\t\\\n-  /* Storage: r10 save area, static chain, function address.  */\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, const0_rtx);\t\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.\n-   This is really two components.  The first 32 bytes are fixed and\n-   must be copied; the last 12 bytes are just storage that's filled\n-   in later.  So for allocation purposes, it's 32+12 bytes, but for\n-   initialization purposes, it's 32 bytes.  */\n-\n-#define TRAMPOLINE_SIZE (32+12)\n-\n-/* Alignment required for a trampoline.  128 is used to find the\n-   beginning of a line in the instruction cache and to allow for\n-   instruction cache lines of up to 128 bytes.  */\n-\n-#define TRAMPOLINE_ALIGNMENT 128\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 40)), FNADDR); \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 36)), CXT); \\\n-}\n-\n-/*** Library Subroutine Names ***/\n-\n-/* Define this macro if GNU CC should generate calls to the System V\n-   (and ANSI C) library functions `memcpy' and `memset' rather than\n-   the BSD functions `bcopy' and `bzero'.  */\n-#define TARGET_MEM_FUNCTIONS\n-\f\n-/*** Addressing Modes ***/\n-\n-#define SELECT_CC_MODE(OP,X,Y) CCmode\n-\n-/* Recognize any constant value that is a valid address.\n-   When PIC, we do not accept an address that would require a scratch reg\n-   to load into a register.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH                 \\\n-   || (GET_CODE (X) == CONST                                            \\\n-       && ! (flag_pic && pic_address_needs_scratch (X))))\n-\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* The condition for memory shift insns.  */\n-#define SCALED_ADDRESS_P(ADDR)\t\t\t\\\n-  (GET_CODE (ADDR) == PLUS\t\t\t\\\n-   && (GET_CODE (XEXP (ADDR, 0)) == MULT\t\\\n-       || GET_CODE (XEXP (ADDR, 1)) == MULT))\n-\n-/* Can the reference to X be made short?  */\n-#define SHORT_ADDRESS_P(X,TEMP) \\\n-  ((TEMP) = (GET_CODE (X) == CONST ? get_related_value (X) : X), \\\n-   ((TEMP) && GET_CODE (TEMP) == SYMBOL_REF && SYMBOL_REF_FLAG (TEMP)))\n-\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On the m88000, a legitimate address has the form REG, REG+REG,\n-   REG+SMALLINT, REG+(REG*modesize) (REG[REG]), or SMALLINT.\n-\n-   The register elimination process should deal with the argument\n-   pointer and frame pointer changing to REG+SMALLINT.  */\n-\n-#define LEGITIMATE_INDEX_P(X, MODE)\t\t\t\\\n-   ((GET_CODE (X) == CONST_INT\t\t\t\t\\\n-     && SMALL_INT (X))\t\t\t\t\t\\\n-    || (REG_P (X)\t\t\t\t\t\\\n-\t&& REG_OK_FOR_INDEX_P (X))\t\t\t\\\n-    || (GET_CODE (X) == MULT\t\t\t\t\\\n-\t&& REG_P (XEXP (X, 0))\t\t\t\t\\\n-\t&& REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\t\\\n-\t&& GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n-\t&& INTVAL (XEXP (X, 1)) == GET_MODE_SIZE (MODE)))\n-\n-#define RTX_OK_FOR_BASE_P(X)\t\t\t\t\t\t\\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-  || (GET_CODE (X) == SUBREG\t\t\t\t\t\t\\\n-      && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\t\\\n-      && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n-\n-#define RTX_OK_FOR_INDEX_P(X)\t\t\t\t\t\t\\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\t\t\\\n-  || (GET_CODE (X) == SUBREG\t\t\t\t\t\t\\\n-      && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\t\\\n-      && REG_OK_FOR_INDEX_P (SUBREG_REG (X))))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  register rtx _x;\t\t\t\t\t\\\n-  if (REG_P (X))\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (REG_OK_FOR_BASE_P (X))\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      register rtx _x0 = XEXP (X, 0);\t\t\t\\\n-      register rtx _x1 = XEXP (X, 1);\t\t\t\\\n-      if ((flag_pic\t\t\t\t\t\\\n-\t   && _x0 == pic_offset_table_rtx\t\t\\\n-\t   && (flag_pic == 2\t\t\t\t\\\n-\t       ? RTX_OK_FOR_BASE_P (_x1)\t\t\\\n-\t       : (GET_CODE (_x1) == SYMBOL_REF\t\t\\\n-\t\t  || GET_CODE (_x1) == LABEL_REF)))\t\\\n-\t  || (REG_P (_x0)\t\t\t\t\\\n-\t      && (REG_OK_FOR_BASE_P (_x0)\t\t\\\n-\t\t  && LEGITIMATE_INDEX_P (_x1, MODE)))\t\\\n-\t  || (REG_P (_x1)\t\t\t\t\\\n-\t      && (REG_OK_FOR_BASE_P (_x1)\t\t\\\n-\t\t  && LEGITIMATE_INDEX_P (_x0, MODE))))\t\\\n-\tgoto ADDR;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == LO_SUM)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      register rtx _x0 = XEXP (X, 0);\t\t\t\\\n-      register rtx _x1 = XEXP (X, 1);\t\t\t\\\n-      if (((REG_P (_x0)\t\t\t\t\t\\\n-\t    && REG_OK_FOR_BASE_P (_x0))\t\t\t\\\n-\t   || (GET_CODE (_x0) == SUBREG\t\t\t\\\n-\t       && REG_P (SUBREG_REG (_x0))\t\t\\\n-\t       && REG_OK_FOR_BASE_P (SUBREG_REG (_x0)))) \\\n-\t  && CONSTANT_P (_x1))\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_INT\t\t\t\\\n-\t   && SMALL_INT (X))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  else if (SHORT_ADDRESS_P (X, _x))\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-}\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  Not the argument pointer.  */\n-#define REG_OK_FOR_INDEX_P(X)                                         \\\n-  (!XRF_REGNO_P(REGNO (X)))\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) (REG_OK_FOR_INDEX_P (X))\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-/* On the m88000, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1))); \\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0))); \\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n-    (X) = gen_rtx_PLUS (Pmode, force_operand (XEXP (X, 0), NULL_RTX),\\\n-\t\t\tXEXP (X, 1));\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 1), NULL_RTX));\t\\\n-  if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST\t\\\n-\t   || GET_CODE (X) == LABEL_REF)\t\t\t\\\n-    (X) = legitimize_address (flag_pic, X, 0, 0);\t\t\\\n-  if (memory_address_p (MODE, X))\t\t\t\t\\\n-    goto WIN; }\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the m88000 this is never true.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-#define LEGITIMATE_CONSTANT_P(X) (1)\n-\n-/* Define this, so that when PIC, reload won't try to reload invalid\n-   addresses which require two reload registers.  */\n-\n-#define LEGITIMATE_PIC_OPERAND_P(X)  (! pic_address_needs_scratch (X))\n-\n-\f\n-/*** Condition Code Information ***/\n-\n-/* C code for a data type which is used for declaring the `mdep'\n-   component of `cc_status'.  It defaults to `int'.  */\n-/* #define CC_STATUS_MDEP int */\n-\n-/* A C expression to initialize the `mdep' field to \"empty\".  */\n-/* #define CC_STATUS_MDEP_INIT (cc_status.mdep = 0) */\n-\n-/* Macro to zap the normal portions of CC_STATUS, but leave the\n-   machine dependent parts (ie, literal synthesis) alone.  */\n-/* #define CC_STATUS_INIT_NO_MDEP \\\n-  (cc_status.flags = 0, cc_status.value1 = 0, cc_status.value2 = 0) */\n-\n-/* When using a register to hold the condition codes, the cc_status\n-   mechanism cannot be used.  */\n-#define NOTICE_UPDATE_CC(EXP, INSN) (0)\n-\f\n-/*** Miscellaneous Parameters ***/\n-\n-/* Define the codes that are matched by predicates in m88k.c.  */\n-#define PREDICATE_CODES\t  \t\t\t\t\t\t\\\n-  {\"move_operand\", {SUBREG, REG, CONST_INT, LO_SUM, MEM}},\t\t\\\n-  {\"call_address_operand\", {SUBREG, REG, SYMBOL_REF, LABEL_REF, CONST}}, \\\n-  {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"arith5_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"arith32_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"arith64_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"int5_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"int32_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"reg_or_bbx_mask_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-  {\"real_or_0_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n-  {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT}},                       \\\n-  {\"relop\", {EQ, NE, LT, LE, GE, GT, LTU, LEU, GEU, GTU}},\t\t\\\n-  {\"even_relop\", {EQ, LT, GT, LTU, GTU}},\t\t\\\n-  {\"odd_relop\", { NE, LE, GE, LEU, GEU}},\t\t\\\n-  {\"partial_ccmode_register_operand\", { SUBREG, REG}},\t\t\t\\\n-  {\"relop_no_unsigned\", {EQ, NE, LT, LE, GE, GT}},\t\t\t\\\n-  {\"equality_op\", {EQ, NE}},\t\t\t\t\t\t\\\n-  {\"pc_or_label_ref\", {PC, LABEL_REF}},\n-\n-/* A list of predicates that do special things with modes, and so\n-   should not elicit warnings for VOIDmode match_operand.  */\n-\n-#define SPECIAL_MODE_PREDICATES\t\t\\\n-  \"partial_ccmode_register_operand\",\t\\\n-  \"pc_or_label_ref\",\n-\n-/* The case table contains either words or branch instructions.  This says\n-   which.  We always claim that the vector is PC-relative.  It is position\n-   independent when -fpic is used.  */\n-#define CASE_VECTOR_INSNS (TARGET_88100 || flag_pic)\n-\n-/* An alias for a machine mode name.  This is the machine mode that\n-   elements of a jump-table should have.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses. */\n-#define CASE_VECTOR_PC_RELATIVE 1\n-\n-/* Define this if control falls through a `case' insn when the index\n-   value is out of range.  This means the specified default-label is\n-   actually ignored by the `case' insn proper.  */\n-/* #define CASE_DROPS_THROUGH */\n-\n-/* Define this to be the smallest number of different values for which it\n-   is best to use a jump-table instead of a tree of conditional branches.\n-   The default is 4 for machines with a casesi instruction and 5 otherwise.\n-   The best 88110 number is around 7, though the exact number isn't yet\n-   known.  A third alternative for the 88110 is to use a binary tree of\n-   bb1 instructions on bits 2/1/0 if the range is dense.  This may not\n-   win very much though.  */\n-#define CASE_VALUES_THRESHOLD (TARGET_88100 ? 4 : 7)\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* The 88open ABI says size_t is unsigned int.  */\n-#define SIZE_TYPE \"unsigned int\"\n-\n-/* Handle #pragma pack and sometimes #pragma weak.  */\n-#define HANDLE_SYSV_PRAGMA 1\n-\n-/* Tell when to handle #pragma weak.  This is only done for V.4.  */\n-#define SUPPORTS_WEAK TARGET_SVR4\n-#define SUPPORTS_ONE_ONLY TARGET_SVR4\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 8\n-\n-/* Define if normal loads of shorter-than-word items from memory clears\n-   the rest of the bigs in the register.  */\n-#define BYTE_LOADS_ZERO_EXTEND\n-\n-/* Zero if access to memory by bytes is faster.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Define this if addresses of constant functions\n-   shouldn't be put through pseudo regs where they can be cse'd.\n-   Desirable on machines where ordinary constants are expensive\n-   but a CALL with constant address is cheap.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Define this macro if an argument declared as `char' or\n-   `short' in a prototype should actually be passed as an\n-   `int'.  In addition to avoiding errors in certain cases of\n-   mismatch, it also makes for better code on certain machines.  */\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* We assume that the store-condition-codes instructions store 0 for false\n-   and some other value for true.  This is the value stored for true.  */\n-#define STORE_FLAG_VALUE (-1)\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction\n-   is a word address (for indexing purposes)\n-   so give the MEM rtx word mode.  */\n-#define FUNCTION_MODE SImode\n-\n-/* A barrier will be aligned so account for the possible expansion.\n-   A volatile load may be preceded by a serializing instruction.\n-   Account for profiling code output at NOTE_INSN_PROLOGUE_END.\n-   Account for block profiling code at basic block boundaries.  */\n-#define ADJUST_INSN_LENGTH(RTX, LENGTH)\t\t\t\t\t\\\n-  if (GET_CODE (RTX) == BARRIER\t\t\t\t\t\t\\\n-      || (TARGET_SERIALIZE_VOLATILE\t\t\t\t\t\\\n-\t  && GET_CODE (RTX) == INSN\t\t\t\t\t\\\n-\t  && GET_CODE (PATTERN (RTX)) == SET\t\t\t\t\\\n-\t  && ((GET_CODE (SET_SRC (PATTERN (RTX))) == MEM\t\t\\\n-\t       && MEM_VOLATILE_P (SET_SRC (PATTERN (RTX)))))))\t\t\\\n-    LENGTH += 1;\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (RTX) == NOTE\t\t\t\t\t\\\n-\t   && NOTE_LINE_NUMBER (RTX) == NOTE_INSN_PROLOGUE_END)\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (current_function_profile)\t\t\t\t\t\\\n-\tLENGTH += (FUNCTION_PROFILER_LENGTH + REG_PUSH_LENGTH\t\t\\\n-\t\t   + REG_POP_LENGTH);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\n-/* Track the state of the last volatile memory reference.  Clear the\n-   state with CC_STATUS_INIT for now.  */\n-#define CC_STATUS_INIT m88k_volatile_code = '\\0'\n-\n-/* A C expressions returning the cost of moving data of MODE from a register\n-   to or from memory.  This is more costly than between registers.  */\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN) 4\n-\n-/* Provide the cost of a branch.  Exact meaning under development.  */\n-#define BRANCH_COST (TARGET_88100 ? 1 : 2)\n-\n-/* Do not break .stabs pseudos into continuations.  */\n-#define DBX_CONTIN_LENGTH 0\n-\f\n-/*** Output of Assembler Code ***/\n-\n-/* Control the assembler format that we output.  */\n-\n-/* A C string constant describing how to begin a comment in the target\n-   assembler language.  The compiler assumes that the comment will end at\n-   the end of the line.  */\n-#define ASM_COMMENT_START \";\"\n-\n-/* Allow pseudo-ops to be overridden.  Override these in svr[34].h.  */\n-#undef\tASCII_DATA_ASM_OP\n-#undef\tREADONLY_DATA_SECTION_ASM_OP\n-#undef\tCTORS_SECTION_ASM_OP\n-#undef\tDTORS_SECTION_ASM_OP\n-#undef  TARGET_ASM_NAMED_SECTION\n-#undef\tINIT_SECTION_ASM_OP\n-#undef\tFINI_SECTION_ASM_OP\n-#undef\tTYPE_ASM_OP\n-#undef\tSIZE_ASM_OP\n-#undef\tSET_ASM_OP\n-#undef\tSKIP_ASM_OP\n-#undef\tCOMMON_ASM_OP\n-#undef\tALIGN_ASM_OP\n-#undef\tIDENT_ASM_OP\n-\n-/* These are used in varasm.c as well.  */\n-#define TEXT_SECTION_ASM_OP\t\"\\ttext\"\n-#define DATA_SECTION_ASM_OP\t\"\\tdata\"\n-\n-/* Other sections.  */\n-#define READONLY_DATA_SECTION_ASM_OP (TARGET_SVR4\t\t\\\n-\t\t\t      ? \"\\tsection\\t .rodata,\\\"a\\\"\"\t\\\n-\t\t\t      : \"\\tsection\\t .rodata,\\\"x\\\"\")\n-#define TDESC_SECTION_ASM_OP (TARGET_SVR4\t\t\t\\\n-\t\t\t      ? \"\\tsection\\t .tdesc,\\\"a\\\"\"\t\\\n-\t\t\t      : \"\\tsection\\t .tdesc,\\\"x\\\"\")\n-\n-/* These must be constant strings for crtstuff.c.  */\n-#define CTORS_SECTION_ASM_OP\t\"\\tsection\\t .ctors,\\\"d\\\"\"\n-#define DTORS_SECTION_ASM_OP\t\"\\tsection\\t .dtors,\\\"d\\\"\"\n-#define INIT_SECTION_ASM_OP\t\"\\tsection\\t .init,\\\"x\\\"\"\n-#define FINI_SECTION_ASM_OP\t\"\\tsection\\t .fini,\\\"x\\\"\"\n-\n-/* These are pretty much common to all assemblers.  */\n-#define IDENT_ASM_OP\t\t\"\\tident\\t\"\n-#define FILE_ASM_OP\t\t\"\\tfile\\t\"\n-#define SET_ASM_OP\t\t\"\\tdef\\t\"\n-#define GLOBAL_ASM_OP\t\t\"\\tglobal\\t\"\n-#define ALIGN_ASM_OP\t\t\"\\talign\\t\"\n-#define SKIP_ASM_OP\t\t\"\\tzero\\t\"\n-#define COMMON_ASM_OP\t\t\"\\tcomm\\t\"\n-#define BSS_ASM_OP\t\t\"\\tbss\\t\"\n-#define FLOAT_ASM_OP\t\t\"\\tfloat\\t\"\n-#define DOUBLE_ASM_OP\t\t\"\\tdouble\\t\"\n-#define ASCII_DATA_ASM_OP\t\"\\tstring\\t\"\n-\n-/* These are particular to the global pool optimization.  */\n-#define SBSS_ASM_OP\t\t\"\\tsbss\\t\"\n-#define SCOMM_ASM_OP\t\t\"\\tscomm\\t\"\n-#define SDATA_SECTION_ASM_OP\t\"\\tsdata\"\n-\n-/* These are specific to PIC.  */\n-#define TYPE_ASM_OP\t\t\"\\ttype\\t\"\n-#define SIZE_ASM_OP\t\t\"\\tsize\\t\"\n-#ifndef AS_BUG_POUND_TYPE /* Faulty assemblers require @ rather than #.  */\n-#undef\tTYPE_OPERAND_FMT\n-#define TYPE_OPERAND_FMT\t\"#%s\"\n-#endif\n-\n-/* This is how we tell the assembler that a symbol is weak.  */\n-\n-#undef ASM_WEAKEN_LABEL\n-#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n-  do { fputs (\"\\tweak\\t\", FILE); assemble_name (FILE, NAME); \\\n-       fputc ('\\n', FILE); } while (0)\n-\n-/* These are specific to version 03.00 assembler syntax.  */\n-#define INTERNAL_ASM_OP\t\t\"\\tlocal\\t\"\n-#define VERSION_ASM_OP\t\t\"\\tversion\\t\"\n-#define PUSHSECTION_ASM_OP\t\"\\tsection\\t\"\n-#define POPSECTION_ASM_OP\t\"\\tprevious\"\n-\n-/* These are specific to the version 04.00 assembler syntax.  */\n-#define REQUIRES_88110_ASM_OP\t\"\\trequires_88110\"\n-\n-/* Output any initial stuff to the assembly file.  Always put out\n-   a file directive, even if not debugging.\n-\n-   Immediately after putting out the file, put out a \"sem.<value>\"\n-   declaration.  This should be harmless on other systems, and\n-   is used in DG/UX by the debuggers to supplement COFF.  The\n-   fields in the integer value are as follows:\n-\n-   Bits\tValue\tMeaning\n-   ----\t-----\t-------\n-   0-1\t0\tNo information about stack locations\n-\t1\tAuto/param locations are based on r30\n-\t2\tAuto/param locations are based on CFA\n-\n-   3-2\t0\tNo information on dimension order\n-\t1\tArray dims in sym table matches source language\n-\t2\tArray dims in sym table is in reverse order\n-\n-   5-4\t0\tNo information about the case of global names\n-\t1\tGlobal names appear in the symbol table as in the source\n-\t2\tGlobal names have been converted to lower case\n-\t3\tGlobal names have been converted to upper case.  */\n-\n-#ifdef SDB_DEBUGGING_INFO\n-#define ASM_COFFSEM(FILE)\t\t\t\t\t\t\\\n-    if (write_symbols == SDB_DEBUG)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\nsem.%x:\\t\\t; %s\\n\",\t\t\t\t\\\n-\t\t (((TARGET_OCS_FRAME_POSITION) ? 2 : 1) << 0) + (1 << 2) + (1 << 4),\\\n-\t\t (TARGET_OCS_FRAME_POSITION)\t\t\t\t\\\n-\t\t\t? \"frame is CFA, normal array dims, case unchanged\" \\\n-\t\t\t: \"frame is r30, normal array dims, case unchanged\"); \\\n-      }\n-#else\n-#define ASM_COFFSEM(FILE)\n-#endif\n-\n-/* Output the first line of the assembly file.  Redefined in dgux.h.  */\n-\n-#define ASM_FIRST_LINE(FILE)\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_SVR4)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (TARGET_88110)\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%s\\\"%s\\\"\\n\", VERSION_ASM_OP, \"04.00\");\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%s\\\"%s\\\"\\n\", VERSION_ASM_OP, \"03.00\");\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* Override svr[34].h.  */\n-#undef\tASM_FILE_START\n-#define ASM_FILE_START(FILE) \\\n-  output_file_start (FILE, \\\n-\t(struct m88k_lang_independent_options *) f_options, \\\n-\tARRAY_SIZE (f_options), \\\n-\t(struct m88k_lang_independent_options *) W_options, \\\n-\tARRAY_SIZE (W_options))\n-\n-#undef\tASM_FILE_END\n-\n-#define ASM_OUTPUT_SOURCE_FILENAME(FILE, NAME) \\\n-  do {                                         \\\n-    fputs (FILE_ASM_OP, FILE);                 \\\n-    output_quoted_string (FILE, NAME);         \\\n-    putc ('\\n', FILE);                         \\\n-  } while (0)\n-\n-#ifdef SDB_DEBUGGING_INFO\n-#undef ASM_OUTPUT_SOURCE_LINE\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE)\t\t\t\\\n-  if (m88k_prologue_done)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\n\\tln\\t %d\\t\\t\\t\\t; Real source line %d\\n\",\\\n-\t     LINE - sdb_begin_function_line, LINE)\n-#endif\n-\n-/* Code to handle #ident directives.  Override svr[34].h definition.  */\n-#undef\tASM_OUTPUT_IDENT\n-#ifdef DBX_DEBUGGING_INFO\n-#define ASM_OUTPUT_IDENT(FILE, NAME)\n-#else\n-#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n-  output_ascii (FILE, IDENT_ASM_OP, 4000, NAME, strlen (NAME));\n-#endif\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-#define ASM_APP_OFF \"\"\n-\n-/* Format the assembly opcode so that the arguments are all aligned.\n-   The maximum instruction size is 8 characters (fxxx.xxx), so a tab and a\n-   space will do to align the output.  Abandon the output if a `%' is\n-   encountered.  */\n-#define ASM_OUTPUT_OPCODE(STREAM, PTR)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    int ch;\t\t\t\t\t\t\t\t\\\n-    const char *orig_ptr;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    for (orig_ptr = (PTR);\t\t\t\t\t\t\\\n-\t (ch = *(PTR)) && ch != ' ' && ch != '\\t' && ch != '\\n' && ch != '%'; \\\n-\t (PTR)++)\t\t\t\t\t\t\t\\\n-      putc (ch, STREAM);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    if (ch == ' ' && orig_ptr != (PTR) && (PTR) - orig_ptr < 8)\t\t\\\n-      putc ('\\t', STREAM);\t\t\t\t\t\t\\\n-  }\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number.\n-   Updated by OVERRIDE_OPTIONS to include the # for version 03.00 syntax.  */\n-\n-#define REGISTER_NAMES \\\n-  {\"#r0\"+1, \"#r1\"+1, \"#r2\"+1, \"#r3\"+1, \"#r4\"+1, \"#r5\"+1, \"#r6\"+1, \"#r7\"+1, \\\n-   \"#r8\"+1, \"#r9\"+1, \"#r10\"+1,\"#r11\"+1,\"#r12\"+1,\"#r13\"+1,\"#r14\"+1,\"#r15\"+1,\\\n-   \"#r16\"+1,\"#r17\"+1,\"#r18\"+1,\"#r19\"+1,\"#r20\"+1,\"#r21\"+1,\"#r22\"+1,\"#r23\"+1,\\\n-   \"#r24\"+1,\"#r25\"+1,\"#r26\"+1,\"#r27\"+1,\"#r28\"+1,\"#r29\"+1,\"#r30\"+1,\"#r31\"+1,\\\n-   \"#x0\"+1, \"#x1\"+1, \"#x2\"+1, \"#x3\"+1, \"#x4\"+1, \"#x5\"+1, \"#x6\"+1, \"#x7\"+1, \\\n-   \"#x8\"+1, \"#x9\"+1, \"#x10\"+1,\"#x11\"+1,\"#x12\"+1,\"#x13\"+1,\"#x14\"+1,\"#x15\"+1,\\\n-   \"#x16\"+1,\"#x17\"+1,\"#x18\"+1,\"#x19\"+1,\"#x20\"+1,\"#x21\"+1,\"#x22\"+1,\"#x23\"+1,\\\n-   \"#x24\"+1,\"#x25\"+1,\"#x26\"+1,\"#x27\"+1,\"#x28\"+1,\"#x29\"+1,\"#x30\"+1,\"#x31\"+1}\n-\n-/* Define additional names for use in asm clobbers and asm declarations.\n-\n-   We define the fake Condition Code register as an alias for reg 0 (which\n-   is our `condition code' register), so that condition codes can easily\n-   be clobbered by an asm.  The carry bit in the PSR is now used.  */\n-\n-#define ADDITIONAL_REGISTER_NAMES\t{{\"psr\", 0}, {\"cc\", 0}}\n-\n-/* Tell when to declare ASM names.  Override svr4.h to provide this hook.  */\n-#undef\tDECLARE_ASM_NAME\n-#define DECLARE_ASM_NAME TARGET_SVR4\n-\n-/* Write the extra assembler code needed to declare a function properly.  */\n-#undef\tASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (DECLARE_ASM_NAME)\t\t\t\t\t\t\\\n-      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"function\");\t\t\\\n-    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n-  } while (0)\n-\n-/* Write the extra assembler code needed to declare an object properly.  */\n-#undef\tASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (DECLARE_ASM_NAME)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tHOST_WIDE_INT size;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tsize_directive_output = 0;\t\t\t\t\t\\\n-\tif (!flag_inhibit_size_directive\t\t\t\t\\\n-\t    && (DECL) && DECL_SIZE (DECL))\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    size_directive_output = 1;\t\t\t\t\t\\\n-\t    size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n-\t    ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, size);\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\\\n-  } while (0);\n-\n-/* Output the size directive for a decl in rest_of_decl_compilation\n-   in the case where we did not do so before the initializer.\n-   Once we find the error_mark_node, we know that the value of\n-   size_directive_output was set\n-   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n-\n-#undef ASM_FINISH_DECLARE_OBJECT\n-#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n-do {\t\t\t\t\t\t\t\t\t \\\n-     const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t \\\n-     HOST_WIDE_INT size;\t\t\t\t\t\t \\\n-     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n-\t && DECLARE_ASM_NAME\t\t\t\t\t\t \\\n-         && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n-\t && DECL_INITIAL (DECL) == error_mark_node\t\t\t \\\n-\t && !size_directive_output)\t\t\t\t\t \\\n-       {\t\t\t\t\t\t\t\t \\\n-\t size_directive_output = 1;\t\t\t\t\t \\\n-\t size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\t \\\n-\t ASM_OUTPUT_SIZE_DIRECTIVE (FILE, name, size);\t\t\t \\\n-       }\t\t\t\t\t\t\t\t \\\n-   } while (0)\n-\n-/* This is how to declare the size of a function.  */\n-#undef\tASM_DECLARE_FUNCTION_SIZE\n-#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (DECLARE_ASM_NAME && !flag_inhibit_size_directive)\t\t\\\n-      ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);\t\t\t\t\\\n-  } while (0)\n-\n-/* The prefix to add to user-visible assembler symbols.\n-   Override svr[34].h.  */\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output a reference to a user-level label named NAME.\n-   Override svr[34].h.  */\n-#undef\tASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (!TARGET_NO_UNDERSCORES && !TARGET_SVR4) \t\\\n-      fputc ('_', FILE);\t\t\t\t\\\n-    fputs (NAME, FILE);\t\t\t\t\t\\\n-  }\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  This must agree\n-   with (*targetm.asm_out.internal_label) above, except for being prefixed\n-   with an `*'.  */\n-\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\t\t\\\n-  sprintf (LABEL, TARGET_SVR4 ? \"*.%s%ld\" : \"*@%s%ld\", PREFIX, (long)(NUM))\n-\n-/* The single-byte pseudo-op is the default.  Override svr[34].h.  */\n-#undef\tASM_OUTPUT_ASCII\n-#define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n-  output_ascii (FILE, ASCII_DATA_ASM_OP, 48, P, SIZE)\n-\n-/* Override svr4.h.  Change to the readonly data section for a table of\n-   addresses.  final_scan_insn changes back to the text section.  */\n-#undef\tASM_OUTPUT_CASE_LABEL\n-#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (! CASE_VECTOR_INSNS)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-        readonly_data_section ();\t\t\t\t\t\\\n-        ASM_OUTPUT_ALIGN (FILE, 2);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM);\t\t\t\\\n-  } while (0)\n-\n-/* Epilogue for case labels.  This jump instruction is called by casesi\n-   to transfer to the appropriate branch instruction within the table.\n-   The label `@L<n>e' is coined to mark the end of the table.  */\n-#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (CASE_VECTOR_INSNS)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tchar label[256]; \t\t\t\t\t\t\\\n-\tASM_GENERATE_INTERNAL_LABEL (label, \"L\", NUM);\t\t\t\\\n-\tfprintf (FILE, \"%se:\\n\", &label[1]);\t\t\t\t\\\n-\tif (! flag_delayed_branch)\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tlda\\t %s,%s[%s]\\n\", reg_names[1],\t\t\\\n-\t\t   reg_names[1], reg_names[m88k_case_index]);\t\t\\\n-\tfprintf (FILE, \"\\tjmp\\t %s\\n\", reg_names[1]);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    char buffer[256];\t\t\t\t\t\t\t\\\n-    ASM_GENERATE_INTERNAL_LABEL (buffer, \"L\", VALUE);\t\t\t\\\n-    fprintf (FILE, CASE_VECTOR_INSNS ? \"\\tbr\\t %s\\n\" : \"\\tword\\t %s\\n\",\t\\\n-\t     &buffer[1]);\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-  ASM_OUTPUT_ADDR_VEC_ELT (FILE, VALUE)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) != 0)\t\t\t\\\n-    fprintf (FILE, \"%s%d\\n\", ALIGN_ASM_OP, 1<<(LOG))\n-\n-/* On the m88100, align the text address to half a cache boundary when it\n-   can only be reached by jumping.  Pack code tightly when compiling\n-   crtstuff.c.  */\n-#define LABEL_ALIGN_AFTER_BARRIER(LABEL) \\\n-  (TARGET_88100 && !flag_inhibit_size_directive ? 3 : 2)\n-\n-/* Override svr[34].h.  */\n-#undef\tASM_OUTPUT_SKIP\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"%s%u\\n\", SKIP_ASM_OP, (int)(SIZE))\n-\n-/* Override svr4.h.  */\n-#undef\tASM_OUTPUT_EXTERNAL_LIBCALL\n-\n-/* This says how to output an assembler line to define a global common\n-   symbol.  Size can be zero for the unusual case of a `struct { int : 0; }'.\n-   Override svr[34].h.  */\n-#undef\tASM_OUTPUT_COMMON\n-#undef\tASM_OUTPUT_ALIGNED_COMMON\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n-( fprintf ((FILE), \"%s\",\t\t\t\t\\\n-\t   ((SIZE) ? (int)(SIZE) : 1) <= m88k_gp_threshold ? SCOMM_ASM_OP : COMMON_ASM_OP), \\\n-  assemble_name ((FILE), (NAME)),\t\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (SIZE) ? (int)(SIZE) : 1))\n-\n-/* This says how to output an assembler line to define a local common\n-   symbol.  Override svr[34].h.  */\n-#undef\tASM_OUTPUT_LOCAL\n-#undef\tASM_OUTPUT_ALIGNED_LOCAL\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n-( fprintf ((FILE), \"%s\",\t\t\t\t\\\n-\t   ((SIZE) ? (int)(SIZE) : 1) <= m88k_gp_threshold ? SBSS_ASM_OP : BSS_ASM_OP), \\\n-  assemble_name ((FILE), (NAME)),\t\t\t\\\n-  fprintf ((FILE), \",%u,%d\\n\", (SIZE) ? (int)(SIZE) : 1, (SIZE) <= 4 ? 4 : 8))\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tsubu\\t %s,%s,%d\\n\\tst\\t %s,%s,0\\n\",\t\\\n-\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n-\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n-\t   (STACK_BOUNDARY / BITS_PER_UNIT),\t\t\\\n-\t   reg_names[REGNO],\t\t\t\t\\\n-\t   reg_names[STACK_POINTER_REGNUM])\n-\n-/* Length in instructions of the code output by ASM_OUTPUT_REG_PUSH.  */\n-#define REG_PUSH_LENGTH 2\n-\n-/* This is how to output an insn to pop a register from the stack.  */\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tld\\t %s,%s,0\\n\\taddu\\t %s,%s,%d\\n\",\t\\\n-\t   reg_names[REGNO],\t\t\t\t\\\n-\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n-\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n-\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n-\t   (STACK_BOUNDARY / BITS_PER_UNIT))\n-\n-/* Length in instructions of the code output by ASM_OUTPUT_REG_POP.  */\n-#define REG_POP_LENGTH 2\n-\f\n-/* Macros to deal with OCS debug information */\n-\n-#define OCS_START_PREFIX\t\"Ltb\"\n-#define OCS_END_PREFIX\t\t\"Lte\"\n-\n-#define PUT_OCS_FUNCTION_START(FILE) \\\n-  { (*targetm.asm_out.internal_label) (FILE, OCS_START_PREFIX, m88k_function_number); }\n-\n-#define PUT_OCS_FUNCTION_END(FILE) \\\n-  { (*targetm.asm_out.internal_label) (FILE, OCS_END_PREFIX, m88k_function_number); }\n-\n-/* Macros for debug information */\n-#define DEBUGGER_AUTO_OFFSET(X) \\\n-  (m88k_debugger_offset (X, 0) \\\n-   + (TARGET_OCS_FRAME_POSITION ? 0 : m88k_stack_size - m88k_fp_offset))\n-\n-#define DEBUGGER_ARG_OFFSET(OFFSET, X) \\\n-  (m88k_debugger_offset (X, OFFSET) \\\n-   + (TARGET_OCS_FRAME_POSITION ? 0 : m88k_stack_size - m88k_fp_offset))\n-\n-/* Macros to deal with SDB debug information */\n-#ifdef SDB_DEBUGGING_INFO\n-\n-/* Output structure tag names even when it causes a forward reference. */\n-#define SDB_ALLOW_FORWARD_REFERENCES\n-\n-/* Print out extra debug information in the assembler file */\n-#define PUT_SDB_SCL(a)\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    register int s = (a);\t\t\t\t\t\\\n-    register const char *scl;\t\t\t\t\t\\\n-    switch (s)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-      case C_EFCN:\tscl = \"end of function\";\tbreak;\t\\\n-      case C_NULL:\tscl = \"NULL storage class\";\tbreak;\t\\\n-      case C_AUTO:\tscl = \"automatic\";\t\tbreak;\t\\\n-      case C_EXT:\tscl = \"external\";\t\tbreak;\t\\\n-      case C_STAT:\tscl = \"static\";\t\t\tbreak;\t\\\n-      case C_REG:\tscl = \"register\";\t\tbreak;\t\\\n-      case C_EXTDEF:\tscl = \"external definition\";\tbreak;\t\\\n-      case C_LABEL:\tscl = \"label\";\t\t\tbreak;\t\\\n-      case C_ULABEL:\tscl = \"undefined label\";\tbreak;\t\\\n-      case C_MOS:\tscl = \"structure member\";\tbreak;\t\\\n-      case C_ARG:\tscl = \"argument\";\t\tbreak;\t\\\n-      case C_STRTAG:\tscl = \"structure tag\";\t\tbreak;\t\\\n-      case C_MOU:\tscl = \"union member\";\t\tbreak;\t\\\n-      case C_UNTAG:\tscl = \"union tag\";\t\tbreak;\t\\\n-      case C_TPDEF:\tscl = \"typedef\";\t\tbreak;\t\\\n-      case C_USTATIC:\tscl = \"uninitialized static\";\tbreak;\t\\\n-      case C_ENTAG:\tscl = \"enumeration tag\";\tbreak;\t\\\n-      case C_MOE:\tscl = \"member of enumeration\";\tbreak;\t\\\n-      case C_REGPARM:\tscl = \"register parameter\";\tbreak;\t\\\n-      case C_FIELD:\tscl = \"bit field\";\t\tbreak;\t\\\n-      case C_BLOCK:\tscl = \"block start/end\";\tbreak;\t\\\n-      case C_FCN:\tscl = \"function start/end\";\tbreak;\t\\\n-      case C_EOS:\tscl = \"end of structure\";\tbreak;\t\\\n-      case C_FILE:\tscl = \"filename\";\t\tbreak;\t\\\n-      case C_LINE:\tscl = \"line\";\t\t\tbreak;\t\\\n-      case C_ALIAS:\tscl = \"duplicated tag\";\t\tbreak;\t\\\n-      case C_HIDDEN:\tscl = \"hidden\";\t\t\tbreak;\t\\\n-      default:\t\tscl = \"unknown\";\t\tbreak;\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    fprintf(asm_out_file, \"\\tscl\\t %d\\t\\t\\t\\t; %s\\n\", s, scl);\t\\\n-  } while (0)\n-\n-#define PUT_SDB_TYPE(a)\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    register int t = (a);\t\t\t\t\t\\\n-    static char buffer[100];\t\t\t\t\t\\\n-    register char *p = buffer;\t\t\t\t\t\\\n-    register const char *q;\t\t\t\t\t\\\n-    register int typ = t;\t\t\t\t\t\\\n-    register int i;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    for (i = 0; i <= 5; i++)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tswitch ((typ >> ((i*N_TSHIFT) + N_BTSHFT)) & 03)\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t  case DT_PTR:\t\t\t\t\t\t\\\n-\t    strcpy (p, \"ptr to \");\t\t\t\t\\\n-\t    p += sizeof(\"ptr to\");\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-\t  case DT_ARY:\t\t\t\t\t\t\\\n-\t    strcpy (p, \"array of \");\t\t\t\t\\\n-\t    p += sizeof(\"array of\");\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-\t  case DT_FCN:\t\t\t\t\t\t\\\n-\t    strcpy (p, \"func ret \");\t\t\t\t\\\n-\t    p += sizeof(\"func ret\");\t\t\t\t\\\n-\t    break;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  switch (typ & N_BTMASK)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-    case T_NULL:\tq = \"<no type>\";\tbreak;\t\t\\\n-    case T_CHAR:\tq = \"char\";\t\tbreak;\t\t\\\n-    case T_SHORT:\tq = \"short\";\t\tbreak;\t\t\\\n-    case T_INT:\t\tq = \"int\";\t\tbreak;\t\t\\\n-    case T_LONG:\tq = \"long\";\t\tbreak;\t\t\\\n-    case T_FLOAT:\tq = \"float\";\t\tbreak;\t\t\\\n-    case T_DOUBLE:\tq = \"double\";\t\tbreak;\t\t\\\n-    case T_STRUCT:\tq = \"struct\";\t\tbreak;\t\t\\\n-    case T_UNION:\tq = \"union\";\t\tbreak;\t\t\\\n-    case T_ENUM:\tq = \"enum\";\t\tbreak;\t\t\\\n-    case T_MOE:\t\tq = \"enum member\";\tbreak;\t\t\\\n-    case T_UCHAR:\tq = \"unsigned char\";\tbreak;\t\t\\\n-    case T_USHORT:\tq = \"unsigned short\";\tbreak;\t\t\\\n-    case T_UINT:\tq = \"unsigned int\";\tbreak;\t\t\\\n-    case T_ULONG:\tq = \"unsigned long\";\tbreak;\t\t\\\n-    default:\t\tq = \"void\";\t\tbreak;\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-    strcpy (p, q);\t\t\t\t\t\t\\\n-    fprintf(asm_out_file, \"\\ttype\\t %d\\t\\t\\t\\t; %s\\n\",\t\t\\\n-\t    t, buffer);\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define PUT_SDB_INT_VAL(a) \\\n-  fprintf (asm_out_file, \"\\tval\\t %d\\n\", (a))\n-\n-#define PUT_SDB_VAL(a)\t\t\t\t\t\\\n-( fprintf (asm_out_file, \"\\tval\\t \"),\t\t\t\\\n-  output_addr_const (asm_out_file, (a)),\t\t\\\n-  fputc ('\\n', asm_out_file))\n-\n-#define PUT_SDB_DEF(a)\t\t\t\t\t\t\\\n-  do { fprintf (asm_out_file, \"\\tsdef\\t \");\t\t\t\\\n-    ASM_OUTPUT_LABELREF (asm_out_file, a);\t\t\t\\\n-    fputc ('\\n', asm_out_file);\t\t\t\t\t\\\n-  } while (0)\n-\n-#define PUT_SDB_PLAIN_DEF(a) \\\n-  fprintf(asm_out_file,\"\\tsdef\\t .%s\\n\", a)\n-\n-/* Simply and endef now.  */\n-#define PUT_SDB_ENDEF \\\n-  fputs(\"\\tendef\\n\\n\", asm_out_file)\n-\n-#define PUT_SDB_SIZE(a) \\\n-  fprintf (asm_out_file, \"\\tsize\\t %d\\n\", (a))\n-\n-/* Max dimensions to store for debug information (limited by COFF).  */\n-#define SDB_MAX_DIM 6\n-\n-/* New method for dim operations.  */\n-#define PUT_SDB_START_DIM \\\n-  fputs(\"\\tdim\\t \", asm_out_file)\n-\n-/* How to end the DIM sequence.  */\n-#define PUT_SDB_LAST_DIM(a) \\\n-  fprintf(asm_out_file, \"%d\\n\", a)\n-\n-#define PUT_SDB_TAG(a)\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    fprintf (asm_out_file, \"\\ttag\\t \");\t\t\t\t\\\n-    ASM_OUTPUT_LABELREF (asm_out_file, a);\t\t\t\\\n-    fputc ('\\n', asm_out_file);\t\t\t\t\t\\\n-  } while( 0 )\n-\n-#define PUT_SDB_BLOCK_OR_FUNCTION(NAME, SCL, LINE)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    fprintf (asm_out_file, \"\\n\\tsdef\\t %s\\n\\tval\\t .\\n\",\t\\\n-\t     NAME);\t\t\t\t\t\t\\\n-    PUT_SDB_SCL( SCL );\t\t\t\t\t\t\\\n-    fprintf (asm_out_file, \"\\tline\\t %d\\n\\tendef\\n\\n\",\t\t\\\n-\t     (LINE));\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define PUT_SDB_BLOCK_START(LINE) \\\n-  PUT_SDB_BLOCK_OR_FUNCTION (\".bb\", C_BLOCK, (LINE))\n-\n-#define PUT_SDB_BLOCK_END(LINE) \\\n-  PUT_SDB_BLOCK_OR_FUNCTION (\".eb\", C_BLOCK, (LINE))\n-\n-#define PUT_SDB_FUNCTION_START(LINE)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    fprintf (asm_out_file, \"\\tln\\t 1\\n\");\t\t\t\\\n-    PUT_SDB_BLOCK_OR_FUNCTION (\".bf\", C_FCN, (LINE));\t\t\\\n-  } while (0)\n-\n-#define PUT_SDB_FUNCTION_END(LINE)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    PUT_SDB_BLOCK_OR_FUNCTION (\".ef\", C_FCN, (LINE));\t\t\\\n-  } while (0)\n-\n-#define PUT_SDB_EPILOGUE_END(NAME)\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    text_section ();\t\t\t\t\t\t\\\n-    fprintf (asm_out_file, \"\\n\\tsdef\\t \");\t\t\t\\\n-    ASM_OUTPUT_LABELREF(asm_out_file, (NAME));\t\t\t\\\n-    fputc('\\n', asm_out_file);\t\t\t\t\t\\\n-    PUT_SDB_SCL( C_EFCN );\t\t\t\t\t\\\n-    fprintf (asm_out_file, \"\\tendef\\n\\n\");\t\t\t\\\n-  } while (0)\n-\n-#define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n-  sprintf ((BUFFER), \".%dfake\", (NUMBER));\n-\n-#endif /* SDB_DEBUGGING_INFO */\n-\f\n-/* Support const and tdesc sections.  Generally, a const section will\n-   be distinct from the text section whenever we do V.4-like things\n-   and so follows DECLARE_ASM_NAME.  Note that strings go in text\n-   rather than const.  Override svr[34].h.  */\n-\n-#undef\tEXTRA_SECTIONS\n-\n-#if defined(USING_SVR4_H)\n-\n-#define EXTRA_SECTIONS in_tdesc, in_sdata\n-#define INIT_SECTION_FUNCTION\n-#define FINI_SECTION_FUNCTION\n-\n-#else\n-#if defined(USING_SVR3_H)\n-\n-#define EXTRA_SECTIONS in_tdesc, in_sdata, in_init, in_fini\n-\n-#else /* luna or other not based on svr[34].h.  */\n-\n-#undef READONLY_DATA_SECTION_ASM_OP\n-#undef INIT_SECTION_ASM_OP\n-#define EXTRA_SECTIONS in_tdesc, in_sdata\n-#define INIT_SECTION_FUNCTION\n-#define FINI_SECTION_FUNCTION\n-\n-#endif /* USING_SVR3_H */\n-#endif /* USING_SVR4_H */\n-\n-#undef\tEXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-tdesc_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_tdesc)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", TDESC_SECTION_ASM_OP);\t\t\\\n-      in_section = in_tdesc;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-sdata_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_sdata)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", SDATA_SECTION_ASM_OP);\t\t\\\n-      in_section = in_sdata;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  INIT_SECTION_FUNCTION\t\t\t\t\t\t\t\\\n-  FINI_SECTION_FUNCTION\n-\n-#define TARGET_ASM_SELECT_SECTION  m88k_select_section\n-\n-/* Jump tables consist of branch instructions and should be output in\n-   the text section.  When we use a table of addresses, we explicitly\n-   change to the readonly data section.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n-\f\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n-#define PRINT_OPERAND_PUNCT_VALID_P(c) \\\n-  ((c) == '#' || (c) == '.' || (c) == '!' || (c) == '*' || (c) == ';')\n-\n-#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n-\n-/* Print a memory address as an operand to reference that memory location.  */\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n-\n-/* This says not to strength reduce the addr calculations within loops\n-   (otherwise it does not take advantage of m88k scaled loads and stores */\n-\n-#define DONT_REDUCE_ADDR"}, {"sha": "edefd23db088f2b2f8f3249f2ebf63fd00099114", "filename": "gcc/config/m88k/m88k.md", "status": "removed", "additions": 0, "deletions": 4011, "changes": 4011, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "56891e8f0837bd9af5fe91fbd79afac81822e76f", "filename": "gcc/config/m88k/openbsd.h", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fopenbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fopenbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fopenbsd.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,67 +0,0 @@\n-/* Configuration file for an m88k OpenBSD target.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Identify the compiler.  */\n-#undef  VERSION_INFO1\n-#define VERSION_INFO1 \"Motorola m88k, \"\n-\n-/* Macros to be automatically defined.  */\n-#define CPP_PREDEFINES \\\n-    \"-D__m88k__ -D__unix__ -D__OpenBSD__ -D__CLASSIFY_TYPE__=2 -Asystem=unix -Asystem=OpenBSD -Acpu=m88k -Amachine=m88k\"\n-\n-/* If -m88000 is in effect, add -Dmc88000; similarly for -m88100 and -m88110.\n-   However, reproduce the effect of -Dmc88100 previously in CPP_PREDEFINES.\n-   Here, the CPU_DEFAULT is assumed to be -m88100.  */\n-#undef\tCPP_SPEC\n-#define\tCPP_SPEC \"%{m88000:-D__mc88000__} \\\n-\t\t  %{!m88000:%{m88100:%{m88110:-D__mc88000__}}} \\\n-\t\t  %{!m88000:%{!m88100:%{m88110:-D__mc88110__}}} \\\n-\t\t  %{!m88000:%{!m88110:-D__mc88100__ -D__mc88100}} \\\n-\t\t  %{posix:-D_POSIX_SOURCE} \\\n-\t\t  %{pthread:-D_POSIX_THREADS}\"\n-\n-/* Layout of source language data types. */\n-\n-/* This must agree with <machine/ansi.h> */\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"int\"\n-\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 32\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-#undef STRUCTURE_SIZE_BOUNDARY\n-#define STRUCTURE_SIZE_BOUNDARY 16 \n-\n-/* Stack & calling: aggregate returns. */\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n-   we want to retain compatibility with older gcc versions.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-#undef SET_ASM_OP\n-#define SET_ASM_OP\t\"\\t.def\\t\"\n-"}, {"sha": "64695d1b72685d1d5e80cea97c0842425420ad56", "filename": "gcc/config/m88k/sysv4.h", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fsysv4.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,85 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Motorola 88100 in an 88open ABI environment.\n-   Copyright (C) 1990, 1991, 2000, 2001 Free Software Foundation, Inc.\n-\n-   Written by Ron Guilmette (rfg@netcom.com).\n-   Contributed to FSF by Network Computing Devices.\n-\n-   Other contributions by Vince Guarna (vguarna@urbana.mcd.mot.com),\n-   Ray Essick (essick@i88.isc.com), Wilson Tien (wtien@urbana.mcd.mot.com),\n-   and Tom Wood (Tom_Wood@NeXT.com)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* DWARF_DEBUGGING_INFO defined in svr4.h.  */\n-\n-#ifndef NO_BUGS\n-#define AS_BUG_DOT_LABELS\n-#define AS_BUG_POUND_TYPE\n-#endif\n-\n-/* TODO: convert includes to ${tm_file} list in config.gcc.  */\n-#include \"m88k/m88k.h\"\n-\n-/* Identify the compiler.  */\n-#undef  VERSION_INFO1\n-#define VERSION_INFO1 \"88open ABI\"\n-\n-/* Default switches */\n-#undef\tTARGET_DEFAULT\n-#define TARGET_DEFAULT\t(MASK_CHECK_ZERO_DIV | \\\n-\t\t\t MASK_OCS_DEBUG_INFO | \\\n-\t\t\t MASK_SVR4)\n-\n-/* Cpp spec.  These pre-assertions are needed for SVR4 as they occur\n-   often in the system header files.  __svr4__ is our extension.  */\n-\n-#undef  CPP_PREDEFINES\n-#define CPP_PREDEFINES \\\n-  \"-Dm88000 -Dm88k -Dunix -D__svr4__ -Amachine=m88k -Acpu=m88k -Asystem=unix -Asystem=svr4\"\n-\n-/* For the AT&T SVR4 port, the function is _mcount.  */\n-#undef\tFUNCTION_PROFILER\n-#define FUNCTION_PROFILER(FILE, LABELNO) \\\n-  output_function_profiler (FILE, LABELNO, \"_mcount\", 1)\n-\n-/* Override svr4.h and m88k.h.  */\n-#undef\tINIT_SECTION_ASM_OP\n-#define INIT_SECTION_ASM_OP \"\\tsection\\t.init,\\\"xa\\\",#progbits\"\n-#undef\tFINI_SECTION_ASM_OP\n-#define FINI_SECTION_ASM_OP \"\\tsection\\t.fini,\\\"xa\\\",#progbits\"\n-\n-/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n- \n-   Note that we want to give these sections the SHF_WRITE attribute\n-   because these sections will actually contain data (i.e. tables of\n-   addresses of functions in the current root executable or shared library\n-   file) and, in the case of a shared library, the relocatable addresses\n-   will have to be properly resolved/relocated (and then written into) by\n-   the dynamic linker when it actually attaches the given shared library\n-   to the executing process.  (Note that on SVR4, you may wish to use the\n-   `-z text' option to the ELF linker, when building a shared library, as\n-   an additional check that you are doing everything right.  But if you do\n-   use the `-z text' option when building a shared library, you will get\n-   errors unless the .ctors and .dtors sections are marked as writable\n-   via the SHF_WRITE attribute.)  */\n- \n-#undef\tCTORS_SECTION_ASM_OP\n-#define CTORS_SECTION_ASM_OP\t\"\\tsection\\t.ctors,\\\"aw\\\"\"\n-#undef\tDTORS_SECTION_ASM_OP\n-#define DTORS_SECTION_ASM_OP\t\"\\tsection\\t.dtors,\\\"aw\\\"\""}, {"sha": "ddbfa73da1249995f818d5af3223b23e08d2718e", "filename": "gcc/config/m88k/t-luna", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Ft-luna", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Ft-luna", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-luna?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,10 +0,0 @@\n-# Specify how to create the *.asm files\n-\n-MOVE_ASM = moveHI15x.asm moveQI16x.asm moveSI46x.asm moveSI64n.asm \\\n-\t   moveHI48x.asm moveSI45x.asm moveSI47x.asm moveSI96x.asm \\\n-\t   moveDI96x.asm\n-\n-$(MOVE_ASM): $(srcdir)/config/m88k/m88k-move.sh\n-\t$(srcdir)/config/m88k/m88k-move.sh -no-tdesc\n-\n-LIB2FUNCS_EXTRA = $(MOVE_ASM)"}, {"sha": "2b2d72784bebd1fe4e9af3b9a8f1eb7fde5318a8", "filename": "gcc/config/m88k/t-luna-gas", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Ft-luna-gas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Ft-luna-gas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-luna-gas?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,11 +0,0 @@\n-# Specify how to create the *.asm files\n-\n-MOVE_ASM = moveHI15x.asm moveQI16x.asm moveSI46x.asm moveSI64n.asm \\\n-\t   moveHI48x.asm moveSI45x.asm moveSI47x.asm moveSI96x.asm \\\n-\t   moveDI96x.asm\n-\n-$(MOVE_ASM): $(srcdir)/config/m88k/m88k-move.sh\n-\t$(SHELL) $(srcdir)/config/m88k/m88k-move.sh -no-tdesc\n-\n-LIB2FUNCS_EXTRA = $(MOVE_ASM)\n-T_CPPFLAGS = -DUSE_GAS"}, {"sha": "c4406233d97d7c20a8242dc5cd36fc5f38f331cd", "filename": "gcc/config/m88k/t-m88k", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Ft-m88k", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Ft-m88k", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-m88k?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,10 +0,0 @@\n-# Specify how to create the *.asm files\n-\n-MOVE_ASM = moveHI15x.asm moveQI16x.asm moveSI46x.asm moveSI64n.asm \\\n-\t   moveHI48x.asm moveSI45x.asm moveSI47x.asm moveSI96x.asm \\\n-\t   moveDI96x.asm\n-\n-$(MOVE_ASM): $(srcdir)/config/m88k/m88k-move.sh\n-\t$(srcdir)/config/m88k/m88k-move.sh\n-\n-LIB2FUNCS_EXTRA = $(MOVE_ASM)"}, {"sha": "858fdc0476eec563285e74dadf91f49e15e190af", "filename": "gcc/config/m88k/t-sysv4", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Ft-sysv4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fm88k%2Ft-sysv4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Ft-sysv4?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,20 +0,0 @@\n-# Specify how to create the *.asm files\n-\n-MOVE_ASM = moveHI15x.asm moveQI16x.asm moveSI46x.asm moveSI64n.asm \\\n-\t   moveHI48x.asm moveSI45x.asm moveSI47x.asm moveSI96x.asm \\\n-\t   moveDI96x.asm\n-\n-# Use the -abi option for version 03.00 syntax.\n-\n-$(MOVE_ASM): $(srcdir)/config/m88k/m88k-move.sh\n-\t$(srcdir)/config/m88k/m88k-move.sh -abi\n-\n-LIB2FUNCS_EXTRA = $(MOVE_ASM)\n-\n-# We need to use -fPIC when we are using gcc to compile the routines in\n-# crtstuff.c.  This is only really needed when we are going to use gcc/g++\n-# to produce a shared library, but since we don't know ahead of time when\n-# we will be doing that, we just always use -fPIC when compiling the\n-# routines in crtstuff.c.\n-\n-CRTSTUFF_T_CFLAGS=-fPIC"}, {"sha": "b64dd75417e5bfc2009e34ffe3fc689bc6a0b538", "filename": "gcc/config/mcore/gfloat.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmcore%2Fgfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmcore%2Fgfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fgfloat.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,65 +0,0 @@\n-/* Output routines for Motorola MCore processor\n-   Copyright (C) 1993, 1999, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* float.h for the M*Core microprocessor. It uses IEEE floating point.\n- *\tfloat is 32 bit IEEE-754 format\n- *\tdouble is 64 bit IEEE-754 format\n- *\tlong double is not defined right now...\n- */\n-#ifndef\t__FLOAT_H___\n-#define\t__FLOAT_H___\n-\n-#define FLT_RADIX 2\n-#define FLT_ROUNDS 1\n-\n-#define FLT_MANT_DIG\t24\n-#define FLT_DIG       \t6\n-#define FLT_EPSILON \t((float)1.19209290e-07)\n-#define FLT_MIN_EXP \t(-125)\n-#define FLT_MIN \t((float)1.17549435e-38)\n-#define FLT_MIN_10_EXP \t(-37)\n-#define FLT_MAX_EXP \t128\n-#define FLT_MAX \t((float)3.40282347e+38)\n-#define FLT_MAX_10_EXP \t38\n-\n-#define DBL_MANT_DIG \t53\n-#define DBL_DIG \t15\n-#define DBL_EPSILON \t2.2204460492503131e-16\n-#define DBL_MIN_EXP \t(-1021)\n-#define DBL_MIN \t2.2250738585072014e-308\n-#define DBL_MIN_10_EXP \t(-307)\n-#define DBL_MAX_EXP \t1024\n-#define DBL_MAX \t1.7976931348623157e+308\n-#define DBL_MAX_10_EXP \t308\n-\n-\n-/* No definitions for LDBL at this time.  */\n-\n-#undef\tLDBL_MANT_DIG\n-#undef\tLDBL_DIG\n-#undef\tLDBL_EPSILON\n-#undef\tLDBL_MIN_EXP\n-#undef\tLDBL_MIN\n-#undef\tLDBL_MIN_10_EXP\n-#undef\tLDBL_MAX_EXP\n-#undef\tLDBL_MAX\n-#undef\tLDBL_MAX_10_EXP\n-\n-#endif /* __FLOAT_H__ */"}, {"sha": "bd9535658d1e0039153ce0c9a75c3e4df0480981", "filename": "gcc/config/mips/rtems64.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmips%2Frtems64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmips%2Frtems64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Frtems64.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,37 +0,0 @@\n-/* Definitions for rtems targeting a MIPS ORION using ecoff.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.\n-   Contributed by Joel Sherrill (joel@OARcorp.com).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Specify predefined symbols in preprocessor.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\\\n-do {\t\t\t\t\t\\\n-  builtin_define (\"__rtems__\");\t\t\\\n-  builtin_assert (\"system=rtems\");\t\\\n-} while (0)\n-\n-#undef EXTRA_SECTIONS\n-#define EXTRA_SECTIONS in_sdata\n-\n-#undef EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS                                         \\\n-  SECTION_FUNCTION_TEMPLATE(sdata_section, in_sdata, SDATA_SECTION_ASM_OP)\n-\n-#undef STARTFILE_SPEC\n-#undef ENDFILE_SPEC"}, {"sha": "5515bfd3c395e2c2e6b85f005991e25b01330064", "filename": "gcc/config/mips/sni-gas.h", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmips%2Fsni-gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmips%2Fsni-gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsni-gas.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,40 +0,0 @@\n-/* Enable debugging.  */\n-#define DBX_DEBUGGING_INFO 1\n-#define SDB_DEBUGGING_INFO 1\n-#define MIPS_DEBUGGING_INFO 1\n-#define DWARF_DEBUGGING_INFO 1\n-\n-#undef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE DWARF_DEBUG\n-\n-/* We need to use .esize and .etype instead of .size and .type to\n-   avoid conflicting with ELF directives.  These are only recognized\n-   by gas, anyhow, not the native assembler.  */\n-#undef PUT_SDB_SIZE\n-#define PUT_SDB_SIZE(a)                               \\\n-do {                                                  \\\n-  extern FILE *asm_out_text_file;                     \\\n-  fprintf (asm_out_text_file, \"\\t.esize\\t\");          \\\n-  fprintf (asm_out_text_file, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT) (a)); \\\n-  fprintf (asm_out_text_file, \";\");                   \\\n-} while (0)\n-\n-#undef PUT_SDB_TYPE\n-#define PUT_SDB_TYPE(a)                                       \\\n-do {                                                  \\\n-  extern FILE *asm_out_text_file;                     \\\n-  fprintf (asm_out_text_file, \"\\t.etype\\t0x%x;\", (a));        \\\n-} while (0)\n-\n-\n-/* This is how to equate one symbol to another symbol.  The syntax used is\n-   `SYM1=SYM2'.  Note that this is different from the way equates are done\n-   with most svr4 assemblers, where the syntax is `.set SYM1,SYM2'.  */\n-\n-#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)\t\t\t\t\\\n- do {\tfprintf ((FILE), \"\\t\");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n-\tfprintf (FILE, \" = \");\t\t\t\t\t\t\\\n-\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n-  } while (0)"}, {"sha": "f912759a16ba699f566668c2587693a54766358b", "filename": "gcc/config/mips/sni-svr4.h", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmips%2Fsni-svr4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmips%2Fsni-svr4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsni-svr4.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,88 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  SNI SINIX version.\n-   Copyright (C) 1996, 1997, 1999, 2000, 2002 Free Software Foundation, Inc.\n-   Contributed by Marco Walther (Marco.Walther@mch.sni.de).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define MIPS_SVR4\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\t\\\n-    do {\t\t\t\t\t\t\\\n-\tbuiltin_define_std (\"host_mips\");\t\t\\\n-\tbuiltin_define_std (\"SYSTYPE_SVR4\");\t\t\\\n-\tbuiltin_define_std (\"unix\");\t\t\t\\\n-\tbuiltin_define_std (\"mips\");\t\t\t\\\n-\tbuiltin_define_std (\"sinix\");\t\t\t\\\n-\tbuiltin_define_std (\"SNI\");\t\t\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\t\\\n-\tbuiltin_assert (\"system=svr4\");\t\t\t\\\n-\tbuiltin_assert (\"machine=mips\");\t\t\\\n-} while (0)\n-\n-#define LINK_SPEC \"\\\n-%{G*} \\\n-%{!mgas: \\\n-\t%{dy} %{dn}}\"\n-\n-#define LIB_SPEC \"\\\n-\t%{p:-lprof1} \\\n-\t%{!p:%{pg:-lprof1} \\\n-\t     %{!pg:-L/usr/ccs/lib/ -lc /usr/ccs/lib/crtn.o%s}}\"\n-\n-#define STARTFILE_SPEC \"\\\n-\t%{pg:gcrt0.o%s} \\\n-\t%{!pg:%{p:mcrt0.o%s} \\\n-\t       %{!p:/usr/ccs/lib/crt1.o /usr/ccs/lib/crti.o /usr/ccs/lib/values-Xt.o%s}}\"\n-\n-/* Mips System V.4 doesn't have a getpagesize() function needed by the\n-   trampoline code, so use the POSIX sysconf function to get it.\n-   This is only done when compiling the trampoline code.  */\n-\n-#ifdef  L_trampoline\n-#include <unistd.h>\n-\n-#define getpagesize()\tsysconf(_SC_PAGE_SIZE)\n-#endif /*  L_trampoline */\n-\n-#define OBJECT_FORMAT_ELF\n-\n-#define\tTARGET_DEFAULT\tMASK_ABICALLS\n-#define ABICALLS_ASM_OP \"\\t.option pic2\"\n-\n-#define MACHINE_TYPE \"SNI running SINIX 5.42\"\n-\n-#define MIPS_DEFAULT_GVALUE\t0\n-\n-#define NM_FLAGS\t\"-p\"\n-\n-#define ASM_GLOBAL\t\".rdata\\n\\t\\t.globl\\t\"\n-\n-#include \"mips/mips.h\"\n-\n-/* We do not want to run mips-tfile!  */\n-#undef ASM_FINAL_SPEC\n-\n-#undef OBJECT_FORMAT_COFF\n-\n-/* We don't support debugging info for now.  */\n-#undef DBX_DEBUGGING_INFO\n-#undef SDB_DEBUGGING_INFO\n-#undef MIPS_DEBUGGING_INFO\n-#undef PREFERRED_DEBUGGING_TYPE\n-\n-#define DWARF2_UNWIND_INFO 0"}, {"sha": "f5e3805375d651581878408121078917a2fb2ffb", "filename": "gcc/config/mips/t-ecoff", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmips%2Ft-ecoff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmips%2Ft-ecoff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-ecoff?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,59 +0,0 @@\n-LIB1ASMSRC = mips/mips16.S\n-LIB1ASMFUNCS = _m16addsf3 _m16subsf3 _m16mulsf3 _m16divsf3 \\\n-\t_m16eqsf2 _m16nesf2 _m16gtsf2 _m16gesf2 _m16lesf2 _m16ltsf2 \\\n-\t_m16fltsisf _m16fixsfsi \\\n-\t_m16adddf3 _m16subdf3 _m16muldf3 _m16divdf3 \\\n-\t_m16extsfdf2 _m16trdfsf2 \\\n-\t_m16eqdf2 _m16nedf2 _m16gtdf2 _m16gedf2 _m16ledf2 _m16ltdf2 \\\n-\t_m16fltsidf _m16fixdfsi \\\n-\t_m16retsf _m16retdf \\\n-\t_m16stub1 _m16stub2 _m16stub5 _m16stub6 _m16stub9 _m16stub10 \\\n-\t_m16stubsf0 _m16stubsf1 _m16stubsf2 _m16stubsf5 _m16stubsf6 \\\n-\t_m16stubsf9 _m16stubsf10 \\\n-\t_m16stubdf0 _m16stubdf1 _m16stubdf2 _m16stubdf5 _m16stubdf6 \\\n-\t_m16stubdf9 _m16stubdf10\n-\n-# We must build libgcc2.a with -G 0, in case the user wants to link\n-# without the $gp register.\n-TARGET_LIBGCC2_CFLAGS = -G 0\n-\n-# Build the libraries for both hard and soft floating point\n-\n-MULTILIB_OPTIONS = msoft-float/msingle-float EL/EB mips1/mips3\n-MULTILIB_DIRNAMES = soft-float single el eb mips1 mips3\n-MULTILIB_MATCHES = EL=mel EB=meb\n-MULTILIB_MATCHES = msingle-float=m4650\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-# Add additional dependencies to recompile selected modules whenever the\n-# tm.h file changes.  The files compiled are:\n-#\n-#\tgcc.c\t\t(*_SPEC changes)\n-#\ttoplev.c\t(new switches + assembly output changes)\n-#\tsdbout.c\t(debug format changes)\n-#\tdbxout.c\t(debug format changes)\n-#\tdwarfout.c\t(debug format changes)\n-#\tfinal.c\t\t(assembly output changes)\n-#\tvarasm.c\t(assembly output changes)\n-#\tcse.c\t\t(cost functions)\n-#\tinsn-output.c\t(possible ifdef changes in tm.h)\n-#\tregclass.c\t(fixed/call used register changes)\n-#\texplow.c\t(GO_IF_LEGITIMATE_ADDRESS)\n-#\trecog.c\t\t(GO_IF_LEGITIMATE_ADDRESS)\n-#\treload.c\t(GO_IF_LEGITIMATE_ADDRESS)\n-\n-gcc.o: $(CONFIG2_H)\n-toplev.o: $(CONFIG2_H)\n-sdbout.o: $(CONFIG2_H)\n-dbxout.o: $(CONFIG2_H)\n-dwarfout.o: $(CONFIG2_H)\n-final.o: $(CONFIG2_H)\n-varasm.o: $(CONFIG2_H)\n-cse.o: $(CONFIG2_H)\n-insn-output.o: $(CONFIG2_H)\n-regclass.o: $(CONFIG2_H)\n-explow.o: $(CONFIG2_H)\n-recog.o: $(CONFIG2_H)\n-reload.o: $(CONFIG2_H)"}, {"sha": "90ae1beba8094c5300e58a0e85712186b94ba773", "filename": "gcc/config/mn10200/lib1funcs.asm", "status": "removed", "additions": 0, "deletions": 604, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Flib1funcs.asm?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,604 +0,0 @@\n-/* libgcc routines for Matsushita mn10200.\n-   Copyright (C) 1997 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-This file is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef L_divhi3\n-\t/* Derive signed division/modulo from unsigned \"divu\" instruction.  */\n-\t.text\n-\t.globl ___divhi3\n-\t.type ___divhi3,@function\n-___divhi3:\n-\n-\t/* We're going to need some scratch registers, so save d2/d3\n-\t   into the stack.  */\n-\tadd -8,a3\n-\tmovx d2,(0,a3)\n-\tmovx d3,(4,a3)\n-\n-\t/* Loading zeros into registers now allows us to use them\n-\t   in the compare instructions, which saves a total of\n-\t   two bytes (egad).  */\n-\tsub d3,d3\n-\tsub d2,d2\n-\tsub a0,a0\n-\n-\t/* If first operand is negative, then make it positive.\n-\t   It will be contained in d2 just before .L1. \n-\n-\t   a0 tells us if the first operand was negated.  */\n-\tcmp d2,d0\n-\tbge .L0\n-\tsub d0,d2\n-\tmov 1,a0\n-\tbra .L1\n-.L0:\n-\tmov d0,d2\n-.L1:\n-\t/* If the second operand is negative, then make it positive.\n-\t   It will be contained in d3 just before .L3. \n-\n-\t   d0 tells us if the second operand was negated.  */\n-\tcmp d3,d1\n-\tbge .L2\n-\tsub d1,d3\n-\tmov 1,d0\n-\tbra .L3\n-.L2:\n-\tsub d0,d0\n-\tmov d1,d3\n-.L3:\n-\t/* Loading d1 with zero here allows us to save one byte\n-\t   in the comparison below.  */\n-\n-\tsub d1,d1\n-\n-\t/* Make sure to clear the mdr register, then do the unsigned\n-\t   division.  Result will be in d2/mdr.  */\n-\tmov d1,mdr\n-\tdivu d3,d2\n-\n-\t/* Negate the remainder based on the first argument negation\n-\t   flag only.  */\n-\tcmp d1,a0\n-\tbeq .L4\n-\tmov mdr,d3\n-\tsub d3,d1\n-\tbra .L5\n-.L4:\n-\tmov mdr,d1\n-\n-.L5:\n-\t/* Negate the result if either, but not both of the inputs\n-\t   were negated.  */\n-\tmov a0,d3\n-\txor d3,d0\n-\tbeq .L6\n-\tsub d0,d0\n-\tsub d2,d0\n-\tbra .L7\n-.L6:\n-\tmov d2,d0\n-.L7:\n-\t\n-\t/* Restore our scratch registers, deallocate our stack and return.  */\n-\tmovx (0,a3),d2\n-\tmovx (4,a3),d3\n-\tadd 8,a3\n-\trts\n-\t.size ___divhi3,.-___divhi3\n-#endif\n-\n-#ifdef L_modhi3\n-\t.text\n-\t.globl ___modhi3\n-\t.type ___modhi3,@function\n-___modhi3:\n-\tjsr ___divhi3\n-\tmov d1,d0\n-\trts\n-\t.size ___modhi3,.-___modhi3\n-#endif\n-\n-#ifdef L_addsi3\n-\t.text\n-\t.globl ___addsi3\n-\t.type  ___addsi3,@function\n-___addsi3:\n-\tadd -4,a3\n-\tmovx d2,(0,a3)\n-\tmov (8,a3),d2\n-\tadd d2,d0\n-\tmov (10,a3),d2\n-\taddc d2,d1\n-\tmovx (0,a3),d2\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___addsi3,.-___addsi3\n-#endif\n-\n-#ifdef L_subsi3\n-\t.text\n-\t.globl ___subsi3\n-\t.type  ___subsi3,@function\n-___subsi3:\n-\tadd -4,a3\n-\tmovx d2,(0,a3)\n-\tmov (8,a3),d2\n-\tsub d2,d0\n-\tmov (10,a3),d2\n-\tsubc d2,d1\n-\tmovx (0,a3),d2\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___subsi3,.-___subsi3\n-#endif\n-\n-#ifdef L_mulsi3\n-\t.text\n-\t.globl ___mulsi3\n-\t.type  ___mulsi3,@function\n-___mulsi3:\n-\tadd -4,a3\n-\tmov a1,(0,a3)\n-\tmov d0,a0\n-\t/* Multiply arg0 msb with arg1 lsb.\n-\t   arg0 msb is in register d1,\n-\t   arg1 lsb is in memory.  */\n-\tmov (8,a3),d0\n-\tmulu d0,d1\n-\tmov d1,a1\n-\n-\t/* Multiply arg0 lsb with arg1 msb.\n-\t   arg0 msb is in register a0,\n-\t   arg1 lsb is in memory.  */\n-\tmov a0,d0\n-\tmov (10,a3),d1\n-\tmulu d0,d1\n-\n-\t/* Add the cross products.  */\n-\tadd d1,a1\n-\n-\t/* Now multiply arg0 lsb with arg1 lsb.  */\n-\tmov (8,a3),d1\n-\tmulu d1,d0\n-\n-\t/* Add in the upper 16 bits to the cross product sum.  */\n-\tmov mdr,d1\n-\tadd a1,d1\n-\tmov (0,a3),a1\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___mulsi3,.-___mulsi3\n-#endif\n-\n-#ifdef  L_ashlsi3\n-\t.text\n-\t.globl ___ashlsi3\n-\t.type  ___ashlsi3,@function\n-___ashlsi3:\n-\tmov (4,a3),a0\n-\tcmp 0,a0\n-\tbeq .L0\n-.L1:\n-\tadd d0,d0\n-\taddc d1,d1\n-\tadd -1,a0\n-\tbne .L1\n-.L0:\n-\trts\n-\n-\t.size ___ashlsi3,.-___ashlsi3\n-#endif\n-\n-#ifdef  L_lshrsi3\n-\t.text\n-\t.globl ___lshrsi3\n-\t.type  ___lshrsi3,@function\n-___lshrsi3:\n-\tmov (4,a3),a0\n-\tcmp 0,a0\n-\tbeq .L0\n-.L1:\n-\tlsr d1\n-\tror d0\n-\tadd -1,a0\n-\tbne .L1\n-.L0:\n-\trts\n-\n-\t.size ___lshrsi3,.-___lshrsi3\n-#endif\n-\n-#ifdef  L_ashrsi3\n-\t.text\n-\t.globl ___ashrsi3\n-\t.type  ___ashrsi3,@function\n-___ashrsi3:\n-\tmov (4,a3),a0\n-\tcmp 0,a0\n-\tbeq .L0\n-.L1:\n-\tasr d1\n-\tror d0\n-\tadd -1,a0\n-\tbne .L1\n-.L0:\n-\trts\n-\n-\t.size ___ashrsi3,.-___ashrsi3\n-#endif\n-\n-/* All functions beyond this point pass their arguments in registers! */\n-#ifdef  L_negsi2_d0\n-\t.text\n-\t.globl ___negsi2_d0\n-\t.type  ___negsi2_d0,@function\n-___negsi2_d0:\n-\tadd -8,a3\n-\tmovx d3,(0,a3)\n-\tmovx d2,(4,a3)\n-\tmov d0,d2\n-\tmov d1,d3\n-\tsub d0,d0\n-\tsub d1,d1\n-\tsub d2,d0\n-\tsubc d3,d1\n-\tmovx (0,a3),d3\n-\tmovx (4,a3),d2\n-\tadd 8,a3\n-\trts\n-\n-\t.size ___negsi2_d0,.-___negsi2_d0\n-#endif\n-\n-#ifdef  L_negsi2_d2\n-\t.text\n-\t.globl ___negsi2_d2\n-\t.type  ___negsi2_d2,@function\n-___negsi2_d2:\n-\tadd -8,a3\n-\tmovx d1,(0,a3)\n-\tmovx d0,(4,a3)\n-\tmov d2,d0\n-\tmov d3,d1\n-\tsub d2,d2\n-\tsub d3,d3\n-\tsub d0,d2\n-\tsubc d1,d3\n-\tmovx (0,a3),d1\n-\tmovx (4,a3),d0\n-\tadd 8,a3\n-\trts\n-\n-\t.size ___negsi2_d2,.-___negsi2_d2\n-#endif\n-\n-#ifdef  L_zero_extendpsisi2_d0\n-\t.text\n-\t.globl ___zero_extendpsisi2_d0\n-\t.type  ___zero_extendpsisi2_d0,@function\n-___zero_extendpsisi2_d0:\n-\tadd -4,a3\n-\tmovx d0,(0,a3)\n-\tmovbu (2,a3),d1\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___zero_extendpsisi2_d0,.-___zero_extendpsisi2_d0\n-#endif\n-\n-#ifdef  L_zero_extendpsisi2_d2\n-\t.text\n-\t.globl ___zero_extendpsisi2_d2\n-\t.type  ___zero_extendpsisi2_d2,@function\n-___zero_extendpsisi2_d2:\n-\tadd -4,a3\n-\tmovx d2,(0,a3)\n-\tmovbu (2,a3),d3\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___zero_extendpsisi2_d2,.-___zero_extendpsisi2_d2\n-#endif\n-\n-#ifdef  L_sign_extendpsisi2_d0\n-\t.text\n-\t.globl ___sign_extendpsisi2_d0\n-\t.type  ___sign_extendpsisi2_d0,@function\n-___sign_extendpsisi2_d0:\n-\tadd -4,a3\n-\tmovx d0,(0,a3)\n-\tmovb (2,a3),d1\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___sign_extendpsisi2_d0,.-___sign_extendpsisi2_d0\n-#endif\n-\n-#ifdef  L_sign_extendpsisi2_d2\n-\t.text\n-\t.globl ___sign_extendpsisi2_d2\n-\t.type  ___sign_extendpsisi2_d2,@function\n-___sign_extendpsisi2_d2:\n-\tadd -4,a3\n-\tmovx d2,(0,a3)\n-\tmovb (2,a3),d3\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___sign_extendpsisi2_d2,.-___sign_extendpsisi2_d2\n-#endif\n-\n-#ifdef  L_truncsipsi2_d0_d0\n-\t.text\n-\t.globl ___truncsipsi2_d0_d0\n-\t.type  ___truncsipsi2_d0_d0,@function\n-___truncsipsi2_d0_d0:\n-\tadd -4,a3\n-\tmov d0,(a3)\n-\tmov d1,(2,a3)\n-\tmovx (0,a3),d0\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___truncsipsi2_d0_d0,.-___truncsipsi2_d0_d0\n-#endif\n-\n-#ifdef  L_truncsipsi2_d0_d1\n-\t.text\n-\t.globl ___truncsipsi2_d0_d1\n-\t.type  ___truncsipsi2_d0_d1,@function\n-___truncsipsi2_d0_d1:\n-\tadd -4,a3\n-\tmov d0,(a3)\n-\tmov d1,(2,a3)\n-\tmovx (0,a3),d1\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___truncsipsi2_d0_d1,.-___truncsipsi2_d0_d1\n-#endif\n-\n-#ifdef  L_truncsipsi2_d0_d2\n-\t.text\n-\t.globl ___truncsipsi2_d0_d2\n-\t.type  ___truncsipsi2_d0_d2,@function\n-___truncsipsi2_d0_d2:\n-\tadd -4,a3\n-\tmov d0,(a3)\n-\tmov d1,(2,a3)\n-\tmovx (0,a3),d2\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___truncsipsi2_d0_d2,.-___truncsipsi2_d0_d2\n-#endif\n-\n-#ifdef  L_truncsipsi2_d0_d3\n-\t.text\n-\t.globl ___truncsipsi2_d0_d3\n-\t.type  ___truncsipsi2_d0_d3,@function\n-___truncsipsi2_d0_d3:\n-\tadd -4,a3\n-\tmov d0,(a3)\n-\tmov d1,(2,a3)\n-\tmovx (0,a3),d3\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___truncsipsi2_d0_d3,.-___truncsipsi2_d0_d3\n-#endif\n-\n-#ifdef  L_truncsipsi2_d2_d0\n-\t.text\n-\t.globl ___truncsipsi2_d2_d0\n-\t.type  ___truncsipsi2_d2_d0,@function\n-___truncsipsi2_d2_d0:\n-\tadd -4,a3\n-\tmov d2,(a3)\n-\tmov d3,(2,a3)\n-\tmovx (0,a3),d0\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___truncsipsi2_d2_d0,.-___truncsipsi2_d2_d0\n-#endif\n-\n-#ifdef  L_truncsipsi2_d2_d1\n-\t.text\n-\t.globl ___truncsipsi2_d2_d1\n-\t.type  ___truncsipsi2_d2_d1,@function\n-___truncsipsi2_d2_d1:\n-\tadd -4,a3\n-\tmov d2,(a3)\n-\tmov d3,(2,a3)\n-\tmovx (0,a3),d1\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___truncsipsi2_d2_d1,.-___truncsipsi2_d2_d1\n-#endif\n-\n-#ifdef  L_truncsipsi2_d2_d2\n-\t.text\n-\t.globl ___truncsipsi2_d2_d2\n-\t.type  ___truncsipsi2_d2_d2,@function\n-___truncsipsi2_d2_d2:\n-\tadd -4,a3\n-\tmov d2,(a3)\n-\tmov d3,(2,a3)\n-\tmovx (0,a3),d2\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___truncsipsi2_d2_d2,.-___truncsipsi2_d2_d2\n-#endif\n-\n-#ifdef  L_truncsipsi2_d2_d3\n-\t.text\n-\t.globl ___truncsipsi2_d2_d3\n-\t.type  ___truncsipsi2_d2_d3,@function\n-___truncsipsi2_d2_d3:\n-\tadd -4,a3\n-\tmov d2,(a3)\n-\tmov d3,(2,a3)\n-\tmovx (0,a3),d3\n-\tadd 4,a3\n-\trts\n-\n-\t.size ___truncsipsi2_d2_d3,.-___truncsipsi2_d2_d3\n-#endif\n-\n-\n-#ifdef  L_cmpsi2\n-\t.text\n-\t.globl ___cmpsi2\n-\t.type  ___cmpsi2,@function\n-___cmpsi2:\n-\tadd -4,a3\n-\tmov a1,(0,a3)\n-        mov (10,a3),a1\n-        mov (8,a3),a0\n-        cmp a1,d1\n-        blt .L9\n-        bgt .L6\n-        cmp a0,d0\n-        bcc .L5\n-.L9:\n-        sub d0,d0\n-        jmp .L8\n-.L5:\n-        cmp a0,d0\n-        bhi .L6\n-        mov 1,d0\n-        jmp .L8\n-.L6:\n-        mov 2,d0\n-.L8:\n-\tmov (0,a3),a1\n-\tadd 4,a3\n-        rts\n-\t.size ___cmpsi2,.-___cmpsi2\n-#endif\n-\n-#ifdef  L_ucmpsi2\n-\t.text\n-\t.globl ___ucmpsi2\n-\t.type  ___ucmpsi2,@function\n-___ucmpsi2:\n-\tadd -4,a3\n-\tmov a1,(0,a3)\n-        mov (10,a3),a1\n-        mov (8,a3),a0\n-        cmp a1,d1\n-        bcs .L9\n-        bhi .L6\n-        cmp a0,d0\n-        bcc .L5\n-.L9:\n-        sub d0,d0\n-        jmp .L8\n-.L5:\n-        cmp a0,d0\n-        bhi .L6\n-        mov 1,d0\n-        jmp .L8\n-.L6:\n-        mov 2,d0\n-.L8:\n-\tmov (0,a3),a1\n-\tadd 4,a3\n-        rts\n-\t.size ___ucmpsi2,.-___ucmpsi2\n-#endif\n-\n-\n-#ifdef L_prologue\n-\t.text\n-\t.globl ___prologue\n-\t.type ___prologue,@function\n-___prologue:\n-\tmov (0,a3),a0\n-\tadd -16,a3\n-\tmovx d2,(4,a3)\n-\tmovx d3,(8,a3)\n-\tmov a1,(12,a3)\n-\tmov a2,(16,a3)\n-\tmov a0,(0,a3)\n-\trts\n-\t.size ___prologue,.-___prologue\n-#endif\n-\n-#ifdef L_epilogue_a0\n-\t.text\n-\t.globl ___epilogue_a0\n-\t.type ___epilogue_a0,@function\n-___epilogue_a0:\n-\tmov (0,a3),a0\n-\tmovx (4,a3),d2\n-\tmovx (8,a3),d3\n-\tmov (12,a3),a1\n-\tmov (16,a3),a2\n-\tadd 16,a3\n-\tmov a0,(0,a3)\n-\trts\n-\t.size ___epilogue_a0,.-___epilogue_a0\n-#endif\n-\n-#ifdef L_epilogue_d0\n-\t.text\n-\t.globl ___epilogue_d0\n-\t.type ___epilogue_d0,@function\n-___epilogue_d0:\n-\tmovx (0,a3),d0\n-\tmovx (4,a3),d2\n-\tmovx (8,a3),d3\n-\tmov (12,a3),a1\n-\tmov (16,a3),a2\n-\tadd 16,a3\n-\tmovx d0,(0,a3)\n-\trts\n-\t.size ___epilogue_d0,.-___epilogue_d0\n-#endif\n-\n-#ifdef L_epilogue_noreturn\n-\t.text\n-\t.globl ___epilogue_noreturn\n-\t.type ___epilogue_noreturn,@function\n-___epilogue_noreturn:\n-\tmovx (0,a3),d2\n-\tmovx (4,a3),d3\n-\tmov (8,a3),a1\n-\tmov (12,a3),a2\n-\tadd 16,a3\n-\trts\n-\t.size ___epilogue_noreturn,.-___epilogue_noreturn\n-#endif"}, {"sha": "4f82d61fd38704c46e2f77ef5d7382a34ae4868f", "filename": "gcc/config/mn10200/mn10200-protos.h", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Fmn10200-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Fmn10200-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200-protos.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,51 +0,0 @@\n-/* Definitions of target machine for GNU compiler. Matsushita MN10200 series\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Jeff Law (law@cygnus.com).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef RTX_CODE\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern void notice_update_cc PARAMS ((rtx, rtx));\n-extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n-\t\t\t\t\t\t      enum machine_mode,\n-\t\t\t\t\t\t      rtx, int));\n-extern const char *emit_a_shift PARAMS ((rtx, rtx *));\n-extern const char *output_tst PARAMS ((rtx, rtx));\n-extern int expand_a_shift PARAMS ((enum machine_mode, int, rtx[]));\n-\n-extern int call_address_operand PARAMS ((rtx, enum machine_mode));\n-extern int extendpsi_operand PARAMS ((rtx, enum machine_mode));\n-extern int psimode_truncation_operand PARAMS ((rtx, enum machine_mode));\n-extern int constant_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int nshift_operator PARAMS ((rtx, enum machine_mode));\n-#endif /* RTX_CODE */\n-\n-#ifdef TREE_CODE\n-extern struct rtx_def *function_arg PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t     enum machine_mode, tree, int));\n-extern struct rtx_def *mn10200_va_arg PARAMS ((tree, tree));\n-extern int function_arg_partial_nregs PARAMS ((CUMULATIVE_ARGS *,\n-\t\t\t\t\t       enum machine_mode, tree, int));\n-#endif /* TREE_CODE */\n-\n-extern void asm_file_start PARAMS ((FILE *));\n-extern void expand_prologue PARAMS ((void));\n-extern void expand_epilogue PARAMS ((void));\n-extern int total_frame_size PARAMS ((void));"}, {"sha": "4116c016e556345224f0de9892e4cfc3bb3ec062", "filename": "gcc/config/mn10200/mn10200.c", "status": "removed", "additions": 0, "deletions": 1662, "changes": 1662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,1662 +0,0 @@\n-/* Subroutines for insn-output.c for Matsushita MN10200 series\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Jeff Law (law@cygnus.com).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"flags.h\"\n-#include \"recog.h\"\n-#include \"expr.h\"\n-#include \"function.h\"\n-#include \"obstack.h\"\n-#include \"ggc.h\"\n-#include \"toplev.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-/* Global registers known to hold the value zero.\n-\n-   Normally we'd depend on CSE and combine to put zero into a\n-   register and re-use it.\n-\n-   However, on the mn10x00 processors we implicitly use the constant\n-   zero in tst instructions, so we might be able to do better by\n-   loading the value into a register in the prologue, then re-useing\n-   that register throughout the function.\n-\n-   We could perform similar optimizations for other constants, but with\n-   gcse due soon, it doesn't seem worth the effort.\n-\n-   These variables hold a rtx for a register known to hold the value\n-   zero throughout the entire function, or NULL if no register of\n-   the appropriate class has such a value throughout the life of the\n-   function.  */\n-rtx zero_dreg;\n-rtx zero_areg;\n-\n-static void count_tst_insns PARAMS ((int *));\n-static bool mn10200_rtx_costs PARAMS ((rtx, int, int, int *));\n-\n-/* Note whether or not we need an out of line epilogue.  */\n-static int out_of_line_epilogue;\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS mn10200_rtx_costs\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Indicate this file was compiled by gcc and what optimization\n-   level was used.  */\n-void\n-asm_file_start (file)\n-     FILE *file;\n-{\n-  fprintf (file, \"#\\tGCC For the Matsushita MN10200\\n\");\n-  if (optimize)\n-    fprintf (file, \"# -O%d\\n\", optimize);\n-  else\n-    fprintf (file, \"\\n\\n\");\n-  output_file_directive (file, main_input_filename);\n-}\n-\n-/* Print operand X using operand code CODE to assembly language output file\n-   FILE.  */\n-\n-void\n-print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n-{\n-  switch (code)\n-    {\n-      case 'b':\n-      case 'B':\n-\t/* These are normal and reversed branches.  */\n-\tswitch (code == 'b' ? GET_CODE (x) : reverse_condition (GET_CODE (x)))\n-\t  {\n-\t  case NE:\n-\t    fprintf (file, \"ne\");\n-\t    break;\n-\t  case EQ:\n-\t    fprintf (file, \"eq\");\n-\t    break;\n-\t  case GE:\n-\t    fprintf (file, \"ge\");\n-\t    break;\n-\t  case GT:\n-\t    fprintf (file, \"gt\");\n-\t    break;\n-\t  case LE:\n-\t    fprintf (file, \"le\");\n-\t    break;\n-\t  case LT:\n-\t    fprintf (file, \"lt\");\n-\t    break;\n-\t  case GEU:\n-\t    fprintf (file, \"cc\");\n-\t    break;\n-\t  case GTU:\n-\t    fprintf (file, \"hi\");\n-\t    break;\n-\t  case LEU:\n-\t    fprintf (file, \"ls\");\n-\t    break;\n-\t  case LTU:\n-\t    fprintf (file, \"cs\");\n-\t    break;\n-\t  default:\n-\t    abort ();\n-\t  }\n-\tbreak;\n-      case 'C':\n-\t/* This is used for the operand to a call instruction;\n-\t   if it's a REG, enclose it in parens, else output\n-\t   the operand normally.  */\n-\tif (GET_CODE (x) == REG)\n-\t  {\n-\t    fputc ('(', file);\n-\t    print_operand (file, x, 0);\n-\t    fputc (')', file);\n-\t  }\n-\telse\n-\t  print_operand (file, x, 0);\n-\tbreak;\n-     \n-      /* These are the least significant word in a 32bit value.\n-\t 'o' allows us to sign extend a constant if doing so\n-\t makes for more compact code.  */\n-      case 'L':\n-      case 'o':\n-\tswitch (GET_CODE (x))\n-\t  {\n-\t  case MEM:\n-\t    fputc ('(', file);\n-\t    output_address (XEXP (x, 0));\n-\t    fputc (')', file);\n-\t    break;\n-\n-\t  case REG:\n-\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t    break;\n-\n-\t  case SUBREG:\n-\t    fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n-\t    break;\n-\n-\t  case CONST_DOUBLE:\n-\t    if (code == 'L')\n-\t      {\n-\t\tlong val;\n-\t\tREAL_VALUE_TYPE rv;\n-\n-\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-\t\tREAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\t\tprint_operand_address (file, GEN_INT (val & 0xffff));\n-\t      }\n-\t    else\n-\t      {\n-\t\tlong val;\n-\t\tREAL_VALUE_TYPE rv;\n-\n-\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-\t\tREAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\n-\t\tval &= 0xffff;\n-\t\tval = (((val) & 0xffff) ^ (~0x7fff)) + 0x8000;\n-\t\tprint_operand_address (file, GEN_INT (val));\n-\t      }\n-\t    break;\n-\n-\t  case CONST_INT:\n-\t    if (code == 'L')\n-\t      print_operand_address (file, GEN_INT ((INTVAL (x) & 0xffff)));\n-\t    else\n-\t      {\n-\t        unsigned int val = INTVAL (x) & 0xffff;\n-\t\tval = (((val) & 0xffff) ^ (~0x7fff)) + 0x8000;\n-\t\tprint_operand_address (file, GEN_INT (val));\n-\t      }\n-\t    break;\n-\t  default:\n-\t    abort ();\n-\t  }\n-\tbreak;\n-\n-      /* Similarly, but for the most significant word.  */\n-      case 'H':\n-      case 'h':\n-\tswitch (GET_CODE (x))\n-\t  {\n-\t  case MEM:\n-\t    fputc ('(', file);\n-\t    x = adjust_address (x, HImode, 2);\n-\t    output_address (XEXP (x, 0));\n-\t    fputc (')', file);\n-\t    break;\n-\n-\t  case REG:\n-\t    fprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n-\t    break;\n-\n-\t  case SUBREG:\n-\t    fprintf (file, \"%s\", reg_names[subreg_regno (x) + 1]);\n-\t    break;\n-\n-\t  case CONST_DOUBLE:\n-\t    if (code == 'H')\n-\t      {\n-\t\tlong val;\n-\t\tREAL_VALUE_TYPE rv;\n-\n-\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-\t\tREAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\n-\t\tprint_operand_address (file, GEN_INT ((val >> 16) & 0xffff));\n-\t      }\n-\t    else\n-\t      {\n-\t\tlong val;\n-\t\tREAL_VALUE_TYPE rv;\n-\n-\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n-\t\tREAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\n-\t\tval = (val >> 16) & 0xffff;\n-\t\tval = (((val) & 0xffff) ^ (~0x7fff)) + 0x8000;\n-\n-\t\tprint_operand_address (file, GEN_INT (val));\n-\t      }\n-\t    break;\n-\n-\t  case CONST_INT:\n-\t    if (code == 'H')\n-\t      print_operand_address (file,\n-\t\t\t\t     GEN_INT ((INTVAL (x) >> 16) & 0xffff));\n-\t    else\n-\t      {\n-\t        unsigned int val = (INTVAL (x) >> 16) & 0xffff;\n-\t\tval = (((val) & 0xffff) ^ (~0x7fff)) + 0x8000;\n-\n-\t\tprint_operand_address (file, GEN_INT (val));\n-\t      }\n-\t    break;\n-\t  default:\n-\t    abort ();\n-\t  }\n-\tbreak;\n-\n-      /* Output ~CONST_INT.  */\n-      case 'N':\n-\tif (GET_CODE (x) != CONST_INT)\n-\t  abort ();\n-        fprintf (file, \"%d\", ~INTVAL (x));\n-        break;\n-\n-      /* An address which can not be register indirect, if it is\n-\t register indirect, then turn it into reg + disp.  */\n-      case 'A':\n-\tif (GET_CODE (x) != MEM)\n-\t  abort ();\n-\tif (GET_CODE (XEXP (x, 0)) == REG)\n-\t  x = gen_rtx_PLUS (PSImode, XEXP (x, 0), GEN_INT (0));\n-\telse\n-\t  x = XEXP (x, 0);\n-\tfputc ('(', file);\n-\toutput_address (x);\n-\tfputc (')', file);\n-\tbreak;\n-\n-      case 'Z':\n-        print_operand (file, XEXP (x, 1), 0);\n-\tbreak;\n-\n-      /* More cases where we can sign-extend a CONST_INT if it\n-\t results in more compact code.  */\n-      case 's':\n-      case 'S':\n-\tif (GET_CODE (x) == CONST_INT)\n-\t  {\n-\t    int val = INTVAL (x);\n-\n-\t    if (code == 's')\n-\t      x = GEN_INT (((val & 0xffff) ^ (~0x7fff)) + 0x8000);\n-\t    else\n-\t      x = GEN_INT (((val & 0xff) ^ (~0x7f)) + 0x80);\n-\t  }\n-        /* FALL THROUGH */\n-      default:\n-\tswitch (GET_CODE (x))\n-\t  {\n-\t  case MEM:\n-\t    fputc ('(', file);\n-\t    output_address (XEXP (x, 0));\n-\t    fputc (')', file);\n-\t    break;\n-\n-\t  case REG:\n-\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t    break;\n-\n-\t  case SUBREG:\n-\t    fprintf (file, \"%s\", reg_names[subreg_regno (x)]);\n-\t    break;\n-\n-\t  case CONST_INT:\n-\t  case CONST_DOUBLE:\n-\t  case SYMBOL_REF:\n-\t  case CONST:\n-\t  case LABEL_REF:\n-\t  case CODE_LABEL:\n-\t    print_operand_address (file, x);\n-\t    break;\n-\t  default:\n-\t    abort ();\n-\t  }\n-\tbreak;\n-   }\n-}\n-\n-/* Output assembly language output for the address ADDR to FILE.  */\n-\n-void\n-print_operand_address (file, addr)\n-     FILE *file;\n-     rtx addr;\n-{\n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-      print_operand (file, addr, 0);\n-      break;\n-    case PLUS:\n-      {\n-\trtx base, index;\n-\t/* The base and index could be in any order, so we have\n-\t   to figure out which is the base and which is the index.\n-\t   Uses the same code as GO_IF_LEGITIMATE_ADDRESS.  */\n-\tif (REG_P (XEXP (addr, 0))\n-\t    && REG_OK_FOR_BASE_P (XEXP (addr, 0)))\n-\t  base = XEXP (addr, 0), index = XEXP (addr, 1);\n-\telse if (REG_P (XEXP (addr, 1))\n-\t    && REG_OK_FOR_BASE_P (XEXP (addr, 1)))\n-\t  base = XEXP (addr, 1), index = XEXP (addr, 0);\n-      \telse\n-\t  abort ();\n-\tprint_operand (file, index, 0);\n-\tfputc (',', file);\n-\tprint_operand (file, base, 0);;\n-\tbreak;\n-      }\n-    case SYMBOL_REF:\n-      output_addr_const (file, addr);\n-      break;\n-    default:\n-      output_addr_const (file, addr);\n-      break;\n-    }\n-}\n-\n-/* Count the number of tst insns which compare an address register\n-   with zero.  */\n-static void \n-count_tst_insns (areg_countp)\n-     int *areg_countp;\n-{\n-  rtx insn;\n-\n-  /* Assume no tst insns exist.  */\n-  *areg_countp = 0;\n-\n-  /* If not optimizing, then quit now.  */\n-  if (!optimize)\n-    return;\n-\n-  /* Walk through all the insns.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      rtx pat;\n-\n-      /* Ignore anything that is not a normal INSN.  */\n-      if (GET_CODE (insn) != INSN)\n-\tcontinue;\n-\n-      /* Ignore anything that isn't a SET.  */\n-      pat = PATTERN (insn);\n-      if (GET_CODE (pat) != SET)\n-\tcontinue;\n-\n-      /* Check for a tst insn.  */\n-      if (SET_DEST (pat) == cc0_rtx\n-\t  && GET_CODE (SET_SRC (pat)) == REG\n-\t  && REGNO_REG_CLASS (REGNO (SET_SRC (pat))) == ADDRESS_REGS)\n-\t(*areg_countp)++;\n-    }\n-}\n-\n-/* Return the total size (in bytes) of the current function's frame.\n-   This is the size of the register save area + the size of locals,\n-   spills, etc.  */\n-int\n-total_frame_size ()\n-{\n-  unsigned int size = get_frame_size ();\n-  unsigned int outgoing_args_size = current_function_outgoing_args_size;\n-  int i;\n-\n-  /* First figure out if we're going to use an out of line\n-     prologue, if so we have to make space for all the\n-     registers, even if we don't use them.  */\n-  if (optimize && !current_function_needs_context && !frame_pointer_needed)\n-    {\n-      int inline_count, outline_count;\n-\n-      /* Compute how many bytes an inline prologue would take.\n-\n-         Each address register store takes two bytes, each data register\n-\t store takes three bytes.  */\n-      inline_count = 0;\n-      if (regs_ever_live[5])\n-\tinline_count += 2;\n-      if (regs_ever_live[6])\n-\tinline_count += 2;\n-      if (regs_ever_live[2])\n-\tinline_count += 3;\n-      if (regs_ever_live[3])\n-\tinline_count += 3;\n-\n-      /* If this function has any stack, then the stack adjustment\n-\t will take two (or more) bytes.  */\n-      if (size || outgoing_args_size\n-\t  || regs_ever_live[5] || regs_ever_live[6]\n-\t  || regs_ever_live[2] || regs_ever_live[3])\n-      inline_count += 2;\n-\n-      /* Multiply the current count by two and add one to account for the\n-\t epilogue insns.  */\n-      inline_count = inline_count * 2 + 1;\n-    \n-      /* Now compute how many bytes an out of line sequence would take.  */\n-      /* A relaxed jsr will be three bytes.  */\n-      outline_count = 3;\n-\n-      /* If there are outgoing arguments, then we will need a stack\n-\t pointer adjustment after the call to the prologue, two\n-\t more bytes.  */\n-      outline_count += (outgoing_args_size == 0 ? 0 : 2);\n-\n-      /* If there is some local frame to allocate, it will need to be\n-\t done before the call to the prologue, two more bytes.  */\n-      if (get_frame_size () != 0)\n-\toutline_count += 2;\n-\n-      /* Now account for the epilogue, multiply the base count by two,\n-\t then deal with optimizing away the rts instruction.  */\n-      outline_count = outline_count * 2 + 1;\n-\n-      if (get_frame_size () == 0 && outgoing_args_size == 0)\n-\toutline_count -= 1;\n-\n-      /* If an out of line prologue is smaller, use it.  */\n-      if (inline_count > outline_count)\n-\treturn size + outgoing_args_size + 16;\n-    }\n-\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if ((regs_ever_live[i] && !call_used_regs[i] && ! fixed_regs[i])\n-\t  || (i == FRAME_POINTER_REGNUM && frame_pointer_needed))\n-\tsize += 4;\n-    }\n-\n-  return (size + outgoing_args_size);\n-}\n-\n-/* Expand the prologue into RTL.  */\n-void\n-expand_prologue ()\n-{\n-  unsigned int size = total_frame_size ();\n-  unsigned int outgoing_args_size = current_function_outgoing_args_size;\n-  int offset, i;\n-\n-  zero_areg = NULL_RTX;\n-  zero_dreg = NULL_RTX;\n-\n-  /* If optimizing, see if we should do an out of line prologue/epilogue\n-     sequence.\n-\n-     We don't support out of line prologues if the current function\n-     needs a context or frame pointer.  */\n-  if (optimize && !current_function_needs_context && !frame_pointer_needed)\n-    {\n-      int inline_count, outline_count, areg_count;\n-\n-      /* We need to end the current sequence so that count_tst_insns can\n-\t look at all the insns in this function.  Normally this would be\n-\t unsafe, but it's OK in the prologue/epilogue expanders.  */\n-      end_sequence ();\n-\n-      /* Get a count of the number of tst insns which use address\n-\t registers (it's not profitable to try and improve tst insns\n-\t which use data registers).  */\n-      count_tst_insns (&areg_count);\n-\n-      /* Now start a new sequence.  */\n-      start_sequence ();\n-\n-      /* Compute how many bytes an inline prologue would take.\n-\n-         Each address register store takes two bytes, each data register\n-\t store takes three bytes.  */\n-      inline_count = 0;\n-      if (regs_ever_live[5])\n-\tinline_count += 2;\n-      if (regs_ever_live[6])\n-\tinline_count += 2;\n-      if (regs_ever_live[2])\n-\tinline_count += 3;\n-      if (regs_ever_live[3])\n-\tinline_count += 3;\n-\n-      /* If this function has any stack, then the stack adjustment\n-\t will take two (or more) bytes.  */\n-      if (size || outgoing_args_size\n-\t  || regs_ever_live[5] || regs_ever_live[6]\n-\t  || regs_ever_live[2] || regs_ever_live[3])\n-      inline_count += 2;\n-\n-      /* Multiply the current count by two and add one to account for the\n-\t epilogue insns.  */\n-      inline_count = inline_count * 2 + 1;\n-    \n-      /* Now compute how many bytes an out of line sequence would take.  */\n-      /* A relaxed jsr will be three bytes.  */\n-      outline_count = 3;\n-\n-      /* If there are outgoing arguments, then we will need a stack\n-\t pointer adjustment after the call to the prologue, two\n-\t more bytes.  */\n-      outline_count += (outgoing_args_size == 0 ? 0 : 2);\n-\n-      /* If there is some local frame to allocate, it will need to be\n-\t done before the call to the prologue, two more bytes.  */\n-      if (get_frame_size () != 0)\n-\toutline_count += 2;\n-\n-      /* Now account for the epilogue, multiply the base count by two,\n-\t then deal with optimizing away the rts instruction.  */\n-      outline_count = outline_count * 2 + 1;\n-\n-      if (get_frame_size () == 0 && outgoing_args_size == 0)\n-\toutline_count -= 1;\n-     \n-      /* If an out of line prologue is smaller, use it.  */\n-      if (inline_count > outline_count)\n-\t{\n-\t  if (get_frame_size () != 0)\n-\t    emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t    GEN_INT (-size + outgoing_args_size + 16)));\n-\t  emit_insn (gen_outline_prologue_call ());\n-\n-\t  if (outgoing_args_size)\n-\t    emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t    GEN_INT (-outgoing_args_size)));\n-\t\n-\t  out_of_line_epilogue = 1;\n-\n-\t  /* Determine if it is profitable to put the value zero into a register\n-\t     for the entire function.  If so, set ZERO_DREG and ZERO_AREG.  */\n-\n-\t  /* First see if we could load the value into a data register\n-\t     since that's the most efficient way.  */\n-\t  if (areg_count > 1\n-\t      && (!regs_ever_live[2] || !regs_ever_live[3]))\n-\t    {\n-\t      if (!regs_ever_live[2])\n-\t\t{\n-\t\t  regs_ever_live[2] = 1;\n-\t\t  zero_dreg = gen_rtx_REG (HImode, 2);\n-\t\t}\n-\t      if (!regs_ever_live[3])\n-\t\t{\n-\t\t  regs_ever_live[3] = 1;\n-\t\t  zero_dreg = gen_rtx_REG (HImode, 3);\n-\t\t}\n-\t    }\n-\n-\t  /* Now see if we could load the value into an address register.  */\n-\t  if (zero_dreg == NULL_RTX\n-\t      && areg_count > 2\n-\t      && (!regs_ever_live[5] || !regs_ever_live[6]))\n-\t    {\n-\t      if (!regs_ever_live[5])\n-\t\t{\n-\t\t  regs_ever_live[5] = 1;\n-\t\t  zero_areg = gen_rtx_REG (HImode, 5);\n-\t\t}\n-\t      if (!regs_ever_live[6])\n-\t\t{\n-\t\t  regs_ever_live[6] = 1;\n-\t\t  zero_areg = gen_rtx_REG (HImode, 6);\n-\t\t}\n-\t    }\n-\n-\t  if (zero_dreg)\n-\t    emit_move_insn (zero_dreg, const0_rtx);\n-\n-\t  if (zero_areg)\n-\t    emit_move_insn (zero_areg, const0_rtx);\n-\n-\t  return;\n-\t}\n-    }\n-\n-  out_of_line_epilogue = 0;\n-\n-  /* Temporarily stuff the static chain onto the stack so we can\n-     use a0 as a scratch register during the prologue.  */\n-  if (current_function_needs_context)\n-    {\n-      emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t      GEN_INT (-4)));\n-      emit_move_insn (gen_rtx_MEM (PSImode, stack_pointer_rtx),\n-\t\t      gen_rtx_REG (PSImode, STATIC_CHAIN_REGNUM));\n-    }\n-\n-  if (frame_pointer_needed)\n-    {\n-      /* Store a2 into a0 temporarily.  */\n-      emit_move_insn (gen_rtx_REG (PSImode, 4), frame_pointer_rtx);\n-\n-      /* Set up the frame pointer.  */\n-      emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n-    }\n-\n-  /* Make any necessary space for the saved registers and local frame.  */\n-  if (size)\n-    emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t    GEN_INT (-size)));\n-\n-  /* Save the callee saved registers.  They're saved into the top\n-     of the frame, using the stack pointer.  */\n-  for (i = 0, offset = outgoing_args_size;\n-       i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if ((regs_ever_live[i] && !call_used_regs[i] && ! fixed_regs[i])\n-\t  || (i == FRAME_POINTER_REGNUM && frame_pointer_needed))\n-\t{\n-\t  int regno;\n-\n-\t  /* If we're saving the frame pointer, then it will be found in\n-\t     register 4 (a0).  */\n-\t  regno = (i == FRAME_POINTER_REGNUM && frame_pointer_needed) ? 4 : i;\n-\t\n-\t  emit_move_insn (gen_rtx_MEM (PSImode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      offset)),\n-\t\t\t  gen_rtx_REG (PSImode, regno));\n-\t  offset += 4;\n-\t}\n-    }\n-\n-  /* Now put the static chain back where the rest of the function\n-     expects to find it. \n-\n-     Note that we may eliminate all references to this later, so we\n-     mark the static chain as maybe dead.  */\n-  if (current_function_needs_context)\n-    {\n-      rtx insn;\n-\n-      insn = emit_move_insn (gen_rtx_REG (PSImode, STATIC_CHAIN_REGNUM),\n-\t\t\t     gen_rtx (MEM, PSImode,\n-\t\t\t\t      gen_rtx_PLUS (PSImode,\n-\t\t\t\t\t\t    stack_pointer_rtx,\n-\t\t\t\t\t\t    GEN_INT (size))));\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD,\n-                                            const0_rtx,\n-                                            REG_NOTES (insn));\n-  \n-    }\n-}\n-\n-/* Expand the epilogue into RTL.  */\n-void\n-expand_epilogue ()\n-{\n-  unsigned int size;\n-  unsigned int outgoing_args_size = current_function_outgoing_args_size;\n-  int offset, i, temp_regno;\n-  rtx basereg;\n-\n-  size = total_frame_size ();\n-\n-  if (DECL_RESULT (current_function_decl)\n-      && POINTER_TYPE_P (TREE_TYPE (DECL_RESULT (current_function_decl))))\n-    temp_regno = 0;\n-  else\n-    temp_regno = 4;\n-\n-  /* Emit an out of line epilogue sequence if it's profitable to do so.  */\n-  if (out_of_line_epilogue)\n-    {\n-      /* If there were no outgoing arguments and no local frame, then\n-\t we will be able to omit the rts at the end of this function,\n-\t so just jump to the epilogue_noreturn routine.  */\n-      if (get_frame_size () == 0 && outgoing_args_size == 0)\n-\t{\n-\t  emit_jump_insn (gen_outline_epilogue_jump ());\n-\t  return;\n-\t}\n-\n-      if (outgoing_args_size)\n-\temit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\tGEN_INT (outgoing_args_size)));\n-\n-      if (temp_regno == 0)\n-\temit_insn (gen_outline_epilogue_call_d0 ());\n-      else if (temp_regno == 4)\n-\temit_insn (gen_outline_epilogue_call_a0 ());\n-\n-      if (get_frame_size () != 0)\n-\temit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\tGEN_INT (size - outgoing_args_size - 16)));\n-      emit_jump_insn (gen_return_internal ());\n-      return;\n-    }\n-\n-  /* Registers are restored from the frame pointer if we have one,\n-     else they're restored from the stack pointer.  Figure out\n-     the appropriate offset to the register save area for both cases.  */\n-  if (frame_pointer_needed)\n-    {\n-      basereg = frame_pointer_rtx;\n-      offset = -(size - outgoing_args_size);\n-    }\n-  else\n-    {\n-      basereg = stack_pointer_rtx;\n-      offset = outgoing_args_size;\n-    }\n-\n-  /* Restore each register.  */\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if ((regs_ever_live[i] && !call_used_regs[i] && ! fixed_regs[i])\n-\t  || (i == FRAME_POINTER_REGNUM && frame_pointer_needed))\n-\t{\n-\t  int regno;\n-\n-\t  /* Restore the frame pointer (if it exists) into a temporary\n-\t     register.  */\n-\t  regno = ((i == FRAME_POINTER_REGNUM && frame_pointer_needed)\n-\t\t   ? temp_regno : i);\n-\t\n-\t  emit_move_insn (gen_rtx_REG (PSImode, regno),\n-\t\t\t  gen_rtx_MEM (PSImode,\n-\t\t\t\t       plus_constant (basereg, offset)));\n-\t  offset += 4;\n-\t}\n-    }\n-\n-  if (frame_pointer_needed)\n-    {\n-      /* Deallocate this frame's stack.  */\n-      emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-      /* Restore the old frame pointer.  */\n-      emit_move_insn (frame_pointer_rtx, gen_rtx_REG (PSImode, temp_regno));\n-    }\n-  else if (size)\n-    {\n-      /* Deallocate this function's stack.  */\n-      emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t      GEN_INT (size)));\n-    }\n-\n-  /* If we had to allocate a slot to save the context pointer,\n-     then it must be deallocated here.  */\n-  if (current_function_needs_context)\n-    emit_insn (gen_addpsi3 (stack_pointer_rtx, stack_pointer_rtx, GEN_INT (4)));\n-\n-  /* Emit the return insn, if this function had no stack, then we\n-     can use the standard return (which allows more optimizations),\n-     else we have to use the special one which inhibits optimizations.  */\n-  if (size == 0 && !current_function_needs_context)\n-    emit_jump_insn (gen_return ());\n-  else\n-    emit_jump_insn (gen_return_internal ());\n-}\n-\n-/* Update the condition code from the insn.  */\n-\n-void\n-notice_update_cc (body, insn)\n-     rtx body;\n-     rtx insn;\n-{\n-  switch (get_attr_cc (insn))\n-    {\n-    case CC_NONE:\n-      /* Insn does not affect CC at all.  */\n-      break;\n-\n-    case CC_NONE_0HIT:\n-      /* Insn does not change CC, but the 0'th operand has been changed.  */\n-      if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n-\tcc_status.value1 = 0;\n-      break;\n-\n-    case CC_SET_ZN:\n-      /* Insn sets the Z,N flags of CC to recog_data.operand[0].\n-\t V,C is in an unusable state.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;\n-      cc_status.value1 = recog_data.operand[0];\n-      break;\n-\n-    case CC_SET_ZNV:\n-      /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].\n-\t C is in an unusable state.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_NO_CARRY;\n-      cc_status.value1 = recog_data.operand[0];\n-      break;\n-\n-    case CC_COMPARE:\n-      /* The insn is a compare instruction.  */\n-      CC_STATUS_INIT;\n-      cc_status.value1 = SET_SRC (body);\n-      break;\n-\n-    case CC_CLOBBER:\n-      /* Insn doesn't leave CC in a usable state.  */\n-      CC_STATUS_INIT;\n-      break;\n-\n-    default:\n-      CC_STATUS_INIT;\n-      break;\n-    }\n-}\n-\n-/* Return true if OP is a valid call operand.  Valid call operands\n-   are SYMBOL_REFs and REGs.  */\n-int\n-call_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n-}\n-\n-/* Return true if OP is a memory operand with a constant address.\n-   A special PSImode move pattern uses this predicate.  */\n-int\n-constant_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return GET_CODE (op) == MEM && CONSTANT_ADDRESS_P (XEXP (op, 0));\n-}\n-\n-/* Return true if OP is valid for a psi mode truncation operand.\n-   It must either be a memory operand which is valid for a PSImode\n-   address, or if it is not a memory operand at all.  */\n-int\n-psimode_truncation_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (general_operand (op, mode)\n-\t  && (GET_CODE (op) != MEM\n-\t      || memory_address_p (PSImode, XEXP (op, 0))));\n-}\n-\n-/* What (if any) secondary registers are needed to move IN with mode\n-   MODE into a register from in register class CLASS. \n-\n-   We might be able to simplify this.  */\n-enum reg_class\n-secondary_reload_class (class, mode, in, input)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx in;\n-     int input;\n-{\n-  /* Memory loads less than a full word wide can't have an\n-     address or stack pointer destination.  They must use\n-     a data register as an intermediate register.  */\n-  if (input\n-      && GET_CODE (in) == MEM\n-      && (mode == QImode)\n-      && class == ADDRESS_REGS)\n-    return DATA_REGS;\n-\n-  /* Address register stores which are not PSImode need a scratch register.  */\n-  if (! input\n-      && GET_CODE (in) == MEM\n-      && (mode != PSImode)\n-      && class == ADDRESS_REGS)\n-    return DATA_REGS;\n-\n-  /* Otherwise assume no secondary reloads are needed.  */\n-  return NO_REGS;\n-}\n-\n-\f\n-/* Shifts.\n-\n-   We devote a fair bit of code to getting efficient shifts since we can only\n-   shift one bit at a time, and each single bit shift may take multiple\n-   instructions.\n-\n-   The basic shift methods:\n-\n-     * loop shifts -- emit a loop using one (or two on H8S) bit shifts;\n-     this is the default.  SHIFT_LOOP\n-\n-     * inlined shifts -- emit straight line code for the shift; this is\n-     used when a straight line shift is about the same size or smaller\n-     than a loop.  We allow the inline version to be slightly longer in\n-     some cases as it saves a register.  SHIFT_INLINE\n-\n-     * There other oddballs.  Not worth explaining.  SHIFT_SPECIAL\n-\n-\n-   HImode shifts:\n-\n-     1-4    do them inline\n-\n-     5-7    If ashift, then multiply, else loop.\n-\t\n-     8-14 - If ashift, then multiply, if lshiftrt, then divide, else loop.\n-     15   - rotate the bit we want into the carry, clear the destination,\n-\t    (use mov 0,dst, not sub as sub will clobber the carry), then\n-\t    move bit into place.\n-\n-   Don't Panic, it's not nearly as bad as the H8 shifting code!!!  */\n-\n-int\n-nshift_operator (x, mode)\n-     rtx x;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  switch (GET_CODE (x))\n-    {\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-    case ASHIFT:\n-      return 1;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Called from the .md file to emit code to do shifts.\n-   Returns a boolean indicating success\n-   (currently this is always TRUE).  */\n-\n-int\n-expand_a_shift (mode, code, operands)\n-     enum machine_mode mode;\n-     int code;\n-     rtx operands[];\n-{\n-  emit_move_insn (operands[0], operands[1]);\n-\n-  /* need a loop to get all the bits we want  - we generate the\n-     code at emit time, but need to allocate a scratch reg now  */\n-\n-  emit_insn (gen_rtx_PARALLEL\n-\t     (VOIDmode,\n-\t      gen_rtvec (2,\n-\t\t\t gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t      gen_rtx (code, mode,\n-\t\t\t\t\t       operands[0], operands[2])),\n-\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t  gen_rtx_SCRATCH (HImode)))));\n-\n-  return 1;\n-}\n-\n-/* Shift algorithm determination.\n-\n-   There are various ways of doing a shift:\n-   SHIFT_INLINE: If the amount is small enough, just generate as many one-bit\n-                 shifts as we need.\n-   SHIFT_SPECIAL: Hand crafted assembler.\n-   SHIFT_LOOP:    If the above methods fail, just loop.  */\n-\n-enum shift_alg\n-{\n-  SHIFT_INLINE,\n-  SHIFT_SPECIAL,\n-  SHIFT_LOOP,\n-  SHIFT_MAX\n-};\n-\n-/* Symbols of the various shifts which can be used as indices.  */\n-\n-enum shift_type\n-  {\n-    SHIFT_ASHIFT, SHIFT_LSHIFTRT, SHIFT_ASHIFTRT\n-  };\n-\n-/* Symbols of the various modes which can be used as indices.  */\n-\n-enum shift_mode\n-  {\n-    HIshift\n-  };\n-\n-/* For single bit shift insns, record assembler and what bits of the\n-   condition code are valid afterwards (represented as various CC_FOO\n-   bits, 0 means CC isn't left in a usable state).  */\n-\n-struct shift_insn\n-{\n-  const char *assembler;\n-  int cc_valid;\n-};\n-\n-/* Assembler instruction shift table.\n-\n-   These tables are used to look up the basic shifts.\n-   They are indexed by cpu, shift_type, and mode.\n-*/\n-\n-static const struct shift_insn shift_one[3][3] =\n-{\n-  {\n-/* SHIFT_ASHIFT */\n-      { \"add\\t%0,%0\", CC_OVERFLOW_UNUSABLE | CC_NO_CARRY },\n-  },\n-/* SHIFT_LSHIFTRT */\n-  {\n-      { \"lsr\\t%0\", CC_NO_CARRY },\n-  },\n-/* SHIFT_ASHIFTRT */\n-  {\n-      { \"asr\\t%0\", CC_NO_CARRY },\n-  },\n-};\n-\n-static enum shift_alg get_shift_alg PARAMS ((enum shift_type,\n-\t\t\t\t\t     enum machine_mode, int,\n-\t\t\t\t\t     const char **, int *));\n-\n-/* Given CPU, MODE, SHIFT_TYPE, and shift count COUNT, determine the best\n-   algorithm for doing the shift.  The assembler code is stored in ASSEMBLER.\n-   We don't achieve maximum efficiency in all cases, but the hooks are here\n-   to do so.\n-\n-   For now we just use lots of switch statements.  Since we don't even come\n-   close to supporting all the cases, this is simplest.  If this function ever\n-   gets too big, perhaps resort to a more table based lookup.  Of course,\n-   at this point you may just wish to do it all in rtl.  */\n-\n-static enum shift_alg\n-get_shift_alg (shift_type, mode, count, assembler_p, cc_valid_p)\n-     enum shift_type shift_type;\n-     enum machine_mode mode;\n-     int count;\n-     const char **assembler_p;\n-     int *cc_valid_p;\n-{\n-  /* The default is to loop.  */\n-  enum shift_alg alg = SHIFT_LOOP;\n-  enum shift_mode shift_mode;\n-\n-  /* We don't handle negative shifts or shifts greater than the word size,\n-     they should have been handled already.  */\n-\n-  if (count < 0 || count > GET_MODE_BITSIZE (mode))\n-    abort ();\n-\n-  switch (mode)\n-    {\n-    case HImode:\n-      shift_mode = HIshift;\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n-  /* Assume either SHIFT_LOOP or SHIFT_INLINE.\n-     It is up to the caller to know that looping clobbers cc.  */\n-  *assembler_p = shift_one[shift_type][shift_mode].assembler;\n-  *cc_valid_p = shift_one[shift_type][shift_mode].cc_valid;\n-\n-  /* Now look for cases we want to optimize.  */\n-\n-  switch (shift_mode)\n-    {\n-    case HIshift:\n-      if (count <= 4)\n-\treturn SHIFT_INLINE;\n-      else if (count < 15 && shift_type != SHIFT_ASHIFTRT)\n-\t{\n-\t  switch (count)\n-\t    {\n-\t    case 5:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 32,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 32,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    case 6:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 64,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 64,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    case 7:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 128,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 128,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    case 8:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 256,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 256,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    case 9:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 512,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 512,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    case 10:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 1024,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 1024,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    case 11:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 2048,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 2048,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    case 12:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 4096,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 4096,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    case 13:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 8192,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 8192,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    case 14:\n-\t      if (shift_type == SHIFT_ASHIFT)\n-\t\t*assembler_p = \"mov 16384,%4\\n\\tmul %4,%0\";\n-\t      else if (shift_type == SHIFT_LSHIFTRT)\n-\t\t*assembler_p\n-\t\t  = \"sub %4,%4\\n\\tmov %4,mdr\\n\\tmov 16384,%4\\n\\tdivu %4,%0\";\n-\t      *cc_valid_p = CC_NO_CARRY;\n-\t      return SHIFT_SPECIAL;\n-\t    }\n-\t}\n-      else if (count == 15)\n-\t{\n-          if (shift_type == SHIFT_ASHIFTRT)\n-            {\n-              *assembler_p = \"add\\t%0,%0\\n\\tsubc\\t%0,%0\\n\";\n-              *cc_valid_p = CC_NO_CARRY;\n-              return SHIFT_SPECIAL;\n-\t    }\n-          if (shift_type == SHIFT_LSHIFTRT)\n-            {\n-              *assembler_p = \"add\\t%0,%0\\n\\tmov 0,%0\\n\\trol %0\\n\";\n-              *cc_valid_p = CC_NO_CARRY;\n-              return SHIFT_SPECIAL;\n-\t    }\n-          if (shift_type == SHIFT_ASHIFT)\n-            {\n-              *assembler_p = \"ror\\t%0\\n\\tmov 0,%0\\n\\tror %0\\n\";\n-              *cc_valid_p = CC_NO_CARRY;\n-              return SHIFT_SPECIAL;\n-\t    }\n-\t}\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  return alg;\n-}\n-\n-/* Emit the assembler code for doing shifts.  */\n-\n-const char *\n-emit_a_shift (insn, operands)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx *operands;\n-{\n-  static int loopend_lab;\n-  const char *assembler;\n-  int cc_valid;\n-  rtx shift = operands[3];\n-  enum machine_mode mode = GET_MODE (shift);\n-  enum rtx_code code = GET_CODE (shift);\n-  enum shift_type shift_type;\n-  enum shift_mode shift_mode;\n-\n-  loopend_lab++;\n-\n-  switch (mode)\n-    {\n-    case HImode:\n-      shift_mode = HIshift;\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n-  switch (code)\n-    {\n-    case ASHIFTRT:\n-      shift_type = SHIFT_ASHIFTRT;\n-      break;\n-    case LSHIFTRT:\n-      shift_type = SHIFT_LSHIFTRT;\n-      break;\n-    case ASHIFT:\n-      shift_type = SHIFT_ASHIFT;\n-      break;\n-    default:\n-      abort ();\n-    }\n-\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      /* Indexing by reg, so have to loop and test at top */\n-      output_asm_insn (\"mov\t%2,%4\", operands);\n-      output_asm_insn (\"cmp\t0,%4\", operands);\n-      fprintf (asm_out_file, \"\\tble\t.Lle%d\\n\", loopend_lab);\n-\n-      /* Get the assembler code to do one shift.  */\n-      get_shift_alg (shift_type, mode, 1, &assembler, &cc_valid);\n-    }\n-  else\n-    {\n-      int n = INTVAL (operands[2]);\n-      enum shift_alg alg;\n-\n-      /* If the count is negative, make it 0.  */\n-      if (n < 0)\n-\tn = 0;\n-      /* If the count is too big, truncate it.\n-         ANSI says shifts of GET_MODE_BITSIZE are undefined - we choose to\n-\t do the intuitive thing.  */\n-      else if (n > GET_MODE_BITSIZE (mode))\n-\tn = GET_MODE_BITSIZE (mode);\n-\n-      alg = get_shift_alg (shift_type, mode, n, &assembler, &cc_valid);\n-\n-\n-      switch (alg)\n-\t{\n-\tcase SHIFT_INLINE:\n-\t  /* Emit one bit shifts.  */\n-\t  while (n > 0)\n-\t    {\n-\t      output_asm_insn (assembler, operands);\n-\t      n -= 1;\n-\t    }\n-\n-\t  /* Keep track of CC.  */\n-\t  if (cc_valid)\n-\t    {\n-\t      cc_status.value1 = operands[0];\n-\t      cc_status.flags |= cc_valid;\n-\t    }\n-\t  return \"\";\n-\n-\tcase SHIFT_SPECIAL:\n-\t  output_asm_insn (assembler, operands);\n-\n-\t  /* Keep track of CC.  */\n-\t  if (cc_valid)\n-\t    {\n-\t      cc_status.value1 = operands[0];\n-\t      cc_status.flags |= cc_valid;\n-\t    }\n-\t  return \"\";\n-\t}\n-\n-\t{\n-\t  fprintf (asm_out_file, \"\\tmov\t%d,%s\\n\", n,\n-\t\t   reg_names[REGNO (operands[4])]);\n-\t  fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n-\t  output_asm_insn (assembler, operands);\n-\t  output_asm_insn (\"add\t-1,%4\", operands);\n-\t  fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n-\t  return \"\";\n-\t}\n-    }\n-\n-  fprintf (asm_out_file, \".Llt%d:\\n\", loopend_lab);\n-  output_asm_insn (assembler, operands);\n-  output_asm_insn (\"add\t-1,%4\", operands);\n-  fprintf (asm_out_file, \"\\tbne\t.Llt%d\\n\", loopend_lab);\n-  fprintf (asm_out_file, \".Lle%d:\\n\", loopend_lab);\n-\n-  return \"\";\n-}\n-\n-/* Return an RTX to represent where a value with mode MODE will be returned\n-   from a function.  If the result is 0, the argument is pushed.  */\n-\n-rtx\n-function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n-{\n-  rtx result = 0;\n-  int size, align;\n-\n-  /* We only support using 2 data registers as argument registers.  */\n-  int nregs = 2;\n-\n-  /* Only pass named arguments in registers.  */\n-  if (!named)\n-    return NULL_RTX;\n-\n-  /* Figure out the size of the object to be passed.  We lie and claim\n-     PSImode values are only two bytes since they fit in a single\n-     register.  */\n-  if (mode == BLKmode)\n-    size = int_size_in_bytes (type);\n-  else if (mode == PSImode)\n-    size = 2;\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n-  /* Figure out the alignment of the object to be passed.  */\n-    align = size;\n-\n-  cum->nbytes = (cum->nbytes + 1) & ~1;\n-\n-  /* Don't pass this arg via a register if all the argument registers\n-     are used up.  */\n-  if (cum->nbytes + size > nregs * UNITS_PER_WORD)\n-    return 0;\n-\n-  switch (cum->nbytes / UNITS_PER_WORD)\n-    {\n-    case 0:\n-      result = gen_rtx_REG (mode, 0);\n-      break;\n-    case 1:\n-      result = gen_rtx_REG (mode, 1);\n-      break;\n-    default:\n-      result = 0;\n-    }\n-\n-  return result;\n-}\n-\n-/* Return the number of registers to use for an argument passed partially\n-   in registers and partially in memory.  */\n-\n-int\n-function_arg_partial_nregs (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n-{\n-  int size, align;\n-\n-  /* We only support using 2 data registers as argument registers.  */\n-  int nregs = 2;\n-\n-  return 0;\n-  /* Only pass named arguments in registers.  */\n-  if (!named)\n-    return 0;\n-\n-  /* Figure out the size of the object to be passed.  */\n-  if (mode == BLKmode)\n-    size = int_size_in_bytes (type);\n-  else if (mode == PSImode)\n-    size = 2;\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n-  /* Figure out the alignment of the object to be passed.  */\n-  align = size;\n-\n-  cum->nbytes = (cum->nbytes + 1) & ~1;\n-\n-  /* Don't pass this arg via a register if all the argument registers\n-     are used up.  */\n-  if (cum->nbytes > nregs * UNITS_PER_WORD)\n-    return 0;\n-\n-  if (cum->nbytes + size <= nregs * UNITS_PER_WORD)\n-    return 0;\n-\n-  /* Don't pass this arg via a register if it would be split between\n-     registers and memory.  */\n-  if (type == NULL_TREE\n-      && cum->nbytes + size > nregs * UNITS_PER_WORD)\n-    return 0;\n-\n-  return (nregs * UNITS_PER_WORD - cum->nbytes) / UNITS_PER_WORD;\n-}\n-\n-rtx\n-mn10200_va_arg (valist, type)\n-     tree valist, type;\n-{\n-  HOST_WIDE_INT align, rsize;\n-  tree t, ptr, pptr;\n-\n-  /* Compute the rounded size of the type.  */\n-  align = PARM_BOUNDARY / BITS_PER_UNIT;\n-  rsize = (((int_size_in_bytes (type) + align - 1) / align) * align);\n-\n-  t = build (POSTINCREMENT_EXPR, TREE_TYPE (valist), valist, \n-\t     build_int_2 ((rsize > 8 ? 4 : rsize), 0));\n-  TREE_SIDE_EFFECTS (t) = 1;\n-\n-  ptr = build_pointer_type (type);\n-\n-  /* \"Large\" types are passed by reference.  */\n-  if (rsize > 8)\n-    {\n-      pptr = build_pointer_type (ptr);\n-      t = build1 (NOP_EXPR, pptr, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-\n-      t = build1 (INDIRECT_REF, ptr, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-    }\n-  else\n-    {\n-      t = build1 (NOP_EXPR, ptr, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-    }\n-\n-  /* Calculate!  */\n-  return force_reg (Pmode, expand_expr (t, NULL_RTX, Pmode, EXPAND_NORMAL));\n-}\n-\n-const char *\n-output_tst (operand, insn)\n-     rtx operand, insn;\n-{\n-  \n-  rtx temp;\n-  int past_call = 0;\n-\n-  /* Only tst insns using address registers can be optimized.  */\n-  if (REGNO_REG_CLASS (REGNO (operand)) != ADDRESS_REGS)\n-    return \"cmp 0,%0\";\n-\n-  /* If testing an address register against zero, we can do better if\n-     we know there's a register already holding the value zero.  First\n-     see if a global register has been set to zero, else we do a search\n-     for a register holding zero, if both of those fail, then we use a\n-     compare against zero.  */\n-  if (zero_dreg || zero_areg)\n-    {\n-      rtx xoperands[2];\n-      xoperands[0] = operand;\n-      xoperands[1] = zero_dreg ? zero_dreg : zero_areg;\n-\n-      output_asm_insn (\"cmp %1,%0\", xoperands);\n-      return \"\";\n-    }\n-\n-  /* We can save a byte if we can find a register which has the value\n-     zero in it.  */\n-  temp = PREV_INSN (insn);\n-  while (temp)\n-    {\n-      rtx set;\n-\n-      /* We allow the search to go through call insns.  We record\n-\t the fact that we've past a CALL_INSN and reject matches which\n-\t use call clobbered registers.  */\n-      if (GET_CODE (temp) == CODE_LABEL\n-\t  || GET_CODE (temp) == JUMP_INSN\n-\t  || GET_CODE (temp) == BARRIER)\n-\tbreak;\n-\n-      if (GET_CODE (temp) == CALL_INSN)\n-\tpast_call = 1;\n-\n-      if (GET_CODE (temp) == NOTE)\n-\t{\n-\t  temp = PREV_INSN (temp);\n-\t  continue;\n-\t}\n-\n-      /* It must be an insn, see if it is a simple set. */\n-      set = single_set (temp);\n-      if (!set)\n-\t{\n-\t  temp = PREV_INSN (temp);\n-\t  continue;\n-\t}\n-\n-      /* Are we setting a register to zero?\n-\n-\t If it's a call clobbered register, have we past a call?  */\n-      if (REG_P (SET_DEST (set))\n-\t  && SET_SRC (set) == CONST0_RTX (GET_MODE (SET_DEST (set)))\n-\t  && !reg_set_between_p (SET_DEST (set), temp, insn)\n-\t  && (!past_call \n-\t      || !call_used_regs[REGNO (SET_DEST (set))]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[0] = operand;\n-\t  xoperands[1] = SET_DEST (set);\n-\n-\t  output_asm_insn (\"cmp %1,%0\", xoperands);\n-\t  return \"\";\n-\t}\n-      temp = PREV_INSN (temp);\n-    }\n-  return \"cmp 0,%0\";\n-}\n-\n-/* Return nonzero if OP is a valid operand for a {zero,sign}_extendpsisi\n-   instruction.\n-\n-   It accepts anything that is a general operand or the sum of the\n-   stack pointer and a general operand.  */\n-int\n-extendpsi_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (general_operand (op, mode)\n-\t  || (GET_CODE (op) == PLUS\n-\t      && XEXP (op, 0) == stack_pointer_rtx\n-\t      && general_operand (XEXP (op, 1), VOIDmode)));\n-}\n-\f\n-static bool\n-mn10200_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code ATTRIBUTE_UNUSED;\n-     int *total;\n-{\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      /* Zeros are extremely cheap.  */\n-      if (INTVAL (x) == 0)\n-\t*total = 0;\n-      /* If it fits in 8 bits, then it's still relatively cheap.  */\n-      else if (INT_8_BITS (INTVAL (x)))\n-\t*total = 1;\n-      /* This is the \"base\" cost, includes constants where either the\n-\t upper or lower 16bits are all zeros.  */\n-      else if (INT_16_BITS (INTVAL (x))\n-\t       || (INTVAL (x) & 0xffff) == 0\n-\t       || (INTVAL (x) & 0xffff0000) == 0)\n-\t*total = 2;\n-      else\n-\t*total = 4;\n-      return true;\n-\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      /* These are more costly than a CONST_INT, but we can relax them,\n-\t so they're less costly than a CONST_DOUBLE.  */\n-      *total = 6;\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      /* We don't optimize CONST_DOUBLEs well nor do we relax them well,\n-\t so their cost is very high.  */\n-      *total = 8;\n-      return true;\n-\n-   /* ??? This probably needs more work.  The definitions below were first\n-      taken from the H8 port, then tweaked slightly to improve code density\n-      on various sample codes.  */\n-    case MOD:\n-    case DIV:\n-      *total = 8;\n-      return true;\n-\n-    case MULT:\n-      *total = (GET_MODE (x) == SImode ? 20 : 8);\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}"}, {"sha": "7ea4bb3f39810a0cb9e879ad5e2eb1da64071fe1", "filename": "gcc/config/mn10200/mn10200.h", "status": "removed", "additions": 0, "deletions": 933, "changes": 933, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,933 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Matsushita MN10200 series\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Jeff Law (law@cygnus.com).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* Get rid of svr4.h stuff we don't want/need.  */\n-#undef ASM_SPEC\n-#undef ASM_FINAL_SPEC\n-#undef LIB_SPEC\n-#undef ENDFILE_SPEC\n-#undef LINK_SPEC\n-#undef STARTFILE_SPEC\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define (\"__mn10200__\");\t\t\\\n-      builtin_define (\"__MN10200__\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-/* We don't have any switched on the mn10200.  Though there are some things\n-   that might be worth a switch:\n-\n-   -mspace to optimize even more for space.\n-\n-   -mrelax to enable the relaxing linker.  */\n-\n-extern int target_flags;\n-\n-/* Macros used in the machine description to test the flags.  */\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define TARGET_SWITCHES  \\\n-  {{ \"\", TARGET_DEFAULT, 0}}\n-\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT 0\n-#endif\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-\n-#define TARGET_VERSION fprintf (stderr, \" (MN10200)\");\n-\n-\f\n-/* Target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-   This is not true on the Matsushita MN10300.  */\n-#define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-/* This is not true on the Matsushita MN10200.  */\n-#define BYTES_BIG_ENDIAN 0\n-\n-/* Define this if most significant word of a multiword number is lowest\n-   numbered.\n-   This is not true on the Matsushita MN10200.  */\n-#define WORDS_BIG_ENDIAN 0\n-\n-/* This is a white lie.  Registers are really 24bits, but most operations\n-   only operate on 16 bits.   GCC chokes badly if we set this to a value\n-   that is not a power of two.  */\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD\t\t2\n-\n-/* Width in bits of a pointer.\n-   See also the macro `Pmode' defined below.\n-\n-   This differs from Pmode because we need to allocate 32bits of space\n-   to hold the 24bit pointers on this machine.  */\n-#define POINTER_SIZE \t\t32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY\t\t16\n-\n-/* The stack goes in 16 bit lumps.  */\n-#define STACK_BOUNDARY \t\t16\n-\n-/* Allocation boundary (in *bits*) for the code of a function.\n-   8 is the minimum boundary; it's unclear if bigger alignments\n-   would improve performance.  */\n-#define FUNCTION_BOUNDARY 8\n-\n-/* No data type wants to be aligned rounder than this.   */\n-#define BIGGEST_ALIGNMENT\t16\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 16\n-\n-/* Seems to be how the Matsushita compiler does things, and there's\n-   no real reason to be different.  */\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-#undef PCC_BITFIELD_TYPE_MATTERS\n-\n-/* Define this if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 1\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 0\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-   XXX Long term we should probably expose the MDR register, we use\n-   it for division, multiplication, and some extension operations.  */\n-\n-#define FIRST_PSEUDO_REGISTER 8\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.  */\n-\n-#define FIXED_REGISTERS \\\n-  { 0, 0, 0, 0, 0, 0, 0, 1}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you\n-   like.  */\n-\n-#define CALL_USED_REGISTERS \\\n-  { 1, 1, 0, 0, 1, 0, 0, 1}\n-\n-#define REG_ALLOC_ORDER \\\n-  { 0, 1, 4, 2, 3, 5, 6, 7}\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((MODE) == PSImode ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) \\\n-\t\t\t    / UNITS_PER_WORD))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode\n-   MODE.\n-\n-   We allow any register to hold a PSImode value.  We allow any register\n-   to hold values <= 16 bits.  For values > 16 bits we require aligned\n-   register pairs.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n- ((MODE) == PSImode ? 1 : ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) <= 2)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (MODE1 == MODE2 || (GET_MODE_SIZE (MODE1) <= 2 && GET_MODE_SIZE (MODE2) <= 2))\n-\n-/* 4 data, and effectively 2 address registers is small as far as I'm\n-   concerned.  Especially since we use 2 data registers for argument\n-   passing and return values.\n-\n-   We used to define CLASS_LIKELY_SPILLED_P as true for DATA_REGS too,\n-   but we've made improvements to the port which greatly reduce register\n-   pressure.  As a result we no longer need to define CLASS_LIKELY_SPILLED_P\n-   for DATA_REGS (and by not defining it we get significantly better code).  */\n-#define SMALL_REGISTER_CLASSES 1\n-#define CLASS_LIKELY_SPILLED_P(CLASS) (CLASS == ADDRESS_REGS)\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-   \n-enum reg_class {\n-  NO_REGS, DATA_REGS, ADDRESS_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n-};\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\", \\\n-  \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS  \t\t\t\\\n-{     {0},\t\t/* No regs      */\t\\\n-   {0x0f},\t\t/* DATA_REGS */\t\t\\\n-   {0xf0},\t\t/* ADDRESS_REGS */\t\\\n-   {0xff},\t\t/* GENERAL_REGS */    \t\\\n-   {0xff},\t\t/* ALL_REGS \t*/\t\\\n-}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) \\\n-  ((REGNO) < 4 ? DATA_REGS : ADDRESS_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS DATA_REGS\n-#define BASE_REG_CLASS  ADDRESS_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'd' ? DATA_REGS : \\\n-   (C) == 'a' ? ADDRESS_REGS : NO_REGS)\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n- \n-#define REGNO_OK_FOR_BASE_P(regno) \\\n-  (((regno) > 3 && regno < FIRST_PSEUDO_REGISTER)\t\\\n-   || (reg_renumber[regno] > 3 && reg_renumber[regno] < FIRST_PSEUDO_REGISTER))\n-\n-#define REGNO_OK_FOR_INDEX_P(regno) \\\n-  (IN_RANGE ((regno), 0, 3) \\\n-   || (reg_renumber[regno] >= 0 && reg_renumber[regno] < 4))\n-\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n-  ((GET_MODE (X) != PSImode && GET_MODE (X) != VOIDmode) ? DATA_REGS : CLASS)\n-\n-/* We want to use DATA_REGS for anything that is not PSImode.  */\n-#define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n-  ((MODE != PSImode && MODE != VOIDmode) ? DATA_REGS : CLASS)\n-\n-/* We have/need secondary reloads on the mn10200.  Mostly to deal\n-   with problems using address registers.  */\n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  secondary_reload_class(CLASS,MODE,IN, 1)\n-\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  secondary_reload_class(CLASS,MODE,IN, 0)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((MODE) == PSImode ? 1 : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* The letters I, J, K, L, M, N, O, P in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n-\n-#define INT_8_BITS(VALUE) ((unsigned) (VALUE) + 0x80 < 0x100)\n-#define INT_16_BITS(VALUE) ((unsigned) (VALUE) + 0x8000 < 0x10000)\n-\n-#define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n-#define CONST_OK_FOR_J(VALUE) ((VALUE) >= 1 && (VALUE) <= 3)\n-#define CONST_OK_FOR_K(VALUE) ((VALUE) >= 1 && (VALUE) <= 4)\n-#define CONST_OK_FOR_L(VALUE) ((VALUE) == 15)\n-#define CONST_OK_FOR_M(VALUE) ((VALUE) == 255)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n-  ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n-   (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n-   (C) == 'K' ? CONST_OK_FOR_K (VALUE) : \\\n-   (C) == 'L' ? CONST_OK_FOR_L (VALUE) : \\\n-   (C) == 'M' ? CONST_OK_FOR_M (VALUE) : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself. \n-     \n-  `G' is a floating-point zero.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT\t\\\n-\t\t && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\\\n-   : 0)\n-\n-\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-\n-#define STARTING_FRAME_OFFSET 0\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-/* Is equal to the size of the saved fp + pc, even if an fp isn't\n-   saved since the value is used before we know.  */\n-\n-#define FIRST_PARM_OFFSET(FNDECL) (current_function_needs_context ? 8 : 4)\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 7\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 6\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 6\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 4\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.\n-\n-   We allow frame pointers to be eliminated when not having one will\n-   not interfere with debugging.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-#define FRAME_POINTER_REQUIRED 0\n-#define CAN_DEBUG_WITHOUT_FP\n-\n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved.  */\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = total_frame_size()\n-\n-/* Various type size information.\n-\n-   The mn10200 has a limited number of small registers.  Sizes of basic\n-   data types are adjusted accordingly.  */\n-#define SHORT_TYPE_SIZE         16\n-#define INT_TYPE_SIZE           16\n-#define LONG_TYPE_SIZE          32\n-#define LONG_LONG_TYPE_SIZE     32\n-#define FLOAT_TYPE_SIZE         32\n-#define DOUBLE_TYPE_SIZE        32\n-#define LONG_DOUBLE_TYPE_SIZE   DOUBLE_TYPE_SIZE\n-\n-/* Any size less than 64bits will work; but a smarter definition\n-   can make G++ code smaller and faster.  Most operations on the\n-   mn10200 occur on 16bit hunks, so the best size for a boolean\n-   is 16bits.  */\n-#define BOOL_TYPE_SIZE\t\t16\n-\n-/* The difference of two pointers must be at least 24bits since pointers\n-   are 24bits; however, no basic data type is 24bits, so we have to round\n-   up to a 32bits for the difference of pointers.  */\n-#undef SIZE_TYPE\n-#undef PTRDIFF_TYPE\n-#define SIZE_TYPE \"long unsigned int\"\n-#define PTRDIFF_TYPE \"long int\"\n-\n-/* Note sizeof (WCHAR_TYPE) must be equal to the value of WCHAR_TYPE_SIZE!  */\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"int\"\n-\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE BITS_PER_WORD\n-\n-#define MAX_FIXED_MODE_SIZE     32\n-\n-/* A guess for the MN10200.  */\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* 1 if N is a possible register number for function argument passing.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) ((N) <= 1)\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.  */\n-\n-#define CUMULATIVE_ARGS struct cum_arg\n-struct cum_arg { int nbytes; };\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On the MN10200, the offset starts at 0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n- ((CUM).nbytes = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM).nbytes += ((MODE) != BLKmode\t\t\t\\\n-\t? (MODE) == PSImode ? 2 :\t\t\t\\\n-\t    (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD \\\n-\t: (int_size_in_bytes (TYPE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD))\n-\n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  function_arg (&CUM, MODE, TYPE, NAMED)\n-\n-/* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  mn10200_va_arg (valist, type)\n-\f\n-/* For \"large\" items, we pass them by invisible reference, and the\n-   callee is responsible for copying the data item if it might be\n-   modified.  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n-  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n- \n-#define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED) \\\n-  ((TYPE) && int_size_in_bytes (TYPE) > 8)\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.   */\n-   \n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), TYPE_MODE (VALTYPE) == PSImode ? 4 : 0)\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, (MODE) == PSImode ? 4 : 0)\n-\n-/* 1 if N is a possible register number for a function value.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N) == 4)\n-\n-/* Return values > 8 bytes in length in memory.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-#define RETURN_IN_MEMORY(TYPE)  \\\n-  (int_size_in_bytes (TYPE) > 8 || TYPE_MODE (TYPE) == BLKmode)\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  On the MN10200 it's passed as\n-   the first parameter.  */\n-\n-#define STRUCT_VALUE 0\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK 1\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.\n-\n-   ?!? Profiling is not currently supported.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO) ;\n-\n-/* Yes, we actually support trampolines on this machine, even though\n-   nobody is likely to ever use them.  */\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.byte 0xfd\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\t.byte 0x00\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\t.byte 0x00\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\tmov (a3),a0\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\tadd -4,a3\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\tmov a0,(0,a3)\\n\");\t\t\\\n-    fprintf (FILE, \"\\tmov (21,a0),a0\\n\");\t\t\\\n-    fprintf (FILE, \"\\tmov a0,(4,a3)\\n\");\t\t\\\n-    fprintf (FILE, \"\\tmov (0,a3),a0\\n\");\t\t\\\n-    fprintf (FILE, \"\\tmov (17,a0),a0\\n\");\t\t\\\n-    fprintf (FILE, \"\\tadd 4,a3\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\trts\\n\");\t\t\t\t\\\n-    fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n-    fprintf (FILE, \"\\t.long 0\\n\");\t\t\t\\\n-  } while (0)\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 0x1c\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (PSImode, plus_constant ((TRAMP), 20)),\t\\\n-\t\t  (CXT));\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (PSImode, plus_constant ((TRAMP), 24)),\t\\\n-\t\t  (FNADDR));\t\t\t\t\t\t\\\n-}\n-\n-/* A C expression whose value is RTL representing the value of the return\n-   address for the frame COUNT steps up from the current frame.  */\n-\n-#define RETURN_ADDR_RTX(COUNT, FRAME)   \\\n-  ((COUNT == 0)                         \\\n-   ? gen_rtx_MEM (Pmode, frame_pointer_rtx) \\\n-   : (rtx) 0)\n-\n-\n-/* Addressing modes, and classification of registers for them.  */\n-\n-\f\n-/* 1 if X is an rtx for a constant that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   CONSTANT_P (X)\n-\n-/* Extra constraints.  */\n-#define OK_FOR_R(OP) \\\n-   (GET_CODE (OP) == MEM\t\t\t\t\t\\\n-    && GET_MODE (OP) == QImode\t\t\t\t\t\\\n-    && REG_P (XEXP (OP, 0)))\n- \n-/* Q is used for sp + <something> in the {zero,sign}_extendpsisi2 patterns.  */\n-#define EXTRA_CONSTRAINT(OP, C) \\\n- ((C) == 'R' ? OK_FOR_R (OP) : \\\n-  (C) == 'S' ? GET_CODE (OP) == SYMBOL_REF : \\\n-  (C) == 'Q' ? GET_CODE (OP) == PLUS : 0)\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X)  \\\n-  (IN_RANGE (REGNO (X), 0, 3) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-  (((REGNO (X) >= 4 && REGNO(X) <= 8) || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n-#else\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) \\\n-  REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-  REGNO_OK_FOR_BASE_P (REGNO (X))\n-#endif\n-\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   We used to allow reg+reg addresses for QImode and HImode; however,\n-   they tended to cause the register allocator to run out of registers.\n-   Basically, an indexed load/store always keeps 2 data and one address\n-   register live, which is just too many for this machine.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n-\n-/* Accept either REG or SUBREG where a register is valid.  */\n-  \n-#define RTX_OK_FOR_BASE_P(X)\t\t\t\t\t\\\n-  ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n-   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))\t\t\\\n-       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)    \t\\\n-{\t\t\t\t\t\t\t\\\n-  if ((MODE != PSImode) && CONSTANT_ADDRESS_P (X))\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      rtx base = 0, index = 0;\t\t\t\t\\\n-      if (RTX_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\\\n-\tbase = XEXP (X, 0), index = XEXP (X, 1);\t\\\n-      if (RTX_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\\\n-\tbase = XEXP (X, 1), index = XEXP (X, 0);\t\\\n-      if (base != 0 && index != 0)\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  if (GET_CODE (index) == CONST_INT)\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\n-\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.   */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  {}\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the VAX.  */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define CC_OVERFLOW_UNUSABLE 0x200\n-#define CC_NO_CARRY CC_NO_OVERFLOW\n-#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n-\n-/* The mn10200 has a limited number of registers, so CSE of function\n-   addresses generally makes code worse due to register pressure.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Make moves between different classes more expensive than moves\n-   within the same class.  */\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)  (CLASS1 != CLASS2 ? 4 : 2)\n-\n-/* Nonzero if access to memory by bytes or half words is no faster\n-   than accessing full words.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* According expr.c, a value of around 6 should minimize code size, and\n-   for the MN10200 series, code size our primary concern.  */\n-#define MOVE_RATIO 6\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.section .text\"\n-#define DATA_SECTION_ASM_OP \"\\t.section .data\"\n-#define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n-\n-/* Output at beginning/end of assembler file.  */\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE) asm_file_start(FILE)\n-\n-#define ASM_COMMENT_START \"#\"\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-/* This says how to output the assembler to define a global\n-   uninitialized but not common symbol.\n-   Try to use asm_output_bss to implement this macro.  */\n-\n-#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n-  asm_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \"\\t.global \"\n-\n-/* This is how to output a reference to a user-level label named NAME.\n-   `assemble_name' uses this.  */\n-\n-#undef ASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n-  fprintf (FILE, \"_%s\", (*targetm.strip_name_encoding) (NAME))\n-\n-#define ASM_PN_FORMAT \"%s___%lu\"\n-\n-/* This is how we tell the assembler that two symbols have the same value.  */\n-\n-#define ASM_OUTPUT_DEF(FILE,NAME1,NAME2) \\\n-  do { assemble_name(FILE, NAME1); \t \\\n-       fputs(\" = \", FILE);\t\t \\\n-       assemble_name(FILE, NAME2);\t \\\n-       fputc('\\n', FILE); } while (0)\n-\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{ \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\"}\n-\n-/* Print an instruction operand X on file FILE.\n-   look in mn10200.c for details */\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE,X,CODE)\n-\n-/* Print a memory operand whose address is X, on file FILE.\n-   This uses a function in output-vax.c.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n-  fprintf (FILE, \"\\t%s .L%d\\n\", \".long\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-  fprintf (FILE, \"\\t%s .L%d-.L%d\\n\", \".long\", VALUE, REL)\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) != 0)\t\t\t\\\n-    fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n-\n-/* We don't have to worry about dbx compatibility for the mn10200.  */\n-#define DEFAULT_GDB_EXTENSIONS 1\n-\n-/* Use stabs debugging info by default.  */\n-#undef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n-\n-/* GDB always assumes the current function's frame begins at the value\n-   of the stack pointer upon entry to the current function.  Accessing\n-   local variables and parameters passed on the stack is done using the\n-   base of the frame + an offset provided by GCC.\n-\n-   For functions which have frame pointers this method works fine;\n-   the (frame pointer) == (stack pointer at function entry) and GCC provides\n-   an offset relative to the frame pointer.\n-\n-   This loses for functions without a frame pointer; GCC provides an offset\n-   which is relative to the stack pointer after adjusting for the function's\n-   frame size.  GDB would prefer the offset to be relative to the value of\n-   the stack pointer at the function's entry.  Yuk!  */\n-#define DEBUGGER_AUTO_OFFSET(X) \\\n-  ((GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0) \\\n-    + (frame_pointer_needed ? 0 : -total_frame_size ()))\n-\n-#define DEBUGGER_ARG_OFFSET(OFFSET, X) \\\n-  ((GET_CODE (X) == PLUS ? OFFSET : 0) \\\n-    + (frame_pointer_needed ? 0 : -total_frame_size ()))\n-\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE Pmode\n-\n-/* Dispatch tables on the mn10200 are extremely expensive in terms of code\n-   and readonly data size.  So we crank up the case threshold value to\n-   encourage a series of if/else comparisons to implement many small switch\n-   statements.  In theory, this value could be increased much more if we\n-   were solely optimizing for space, but we keep it \"reasonable\" to avoid\n-   serious code efficiency lossage.  */\n-#define CASE_VALUES_THRESHOLD 8\n-\n-/* Define if operations between registers always perform the operation\n-   on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n-\n-/* We could define this either way.  Using ZERO_EXTEND for QImode makes slightly\n-   fast and more compact code.  */\n-#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n-\n-/* This flag, if defined, says the same insns that convert to a signed fixnum\n-   also convert validly to an unsigned one.  */\n-#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX\t2\n-\n-/* Define if shifts truncate the shift count\n-   which implies one can omit a sign-extension or zero-extension\n-   of a shift count.  */\n-#define SHIFT_COUNT_TRUNCATED 1\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) (OUTPREC != 32)\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode PSImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE QImode\n-\n-/* Perform target dependent optabs initialization.  */\n-#define MODHI3_LIBCALL \"__modhi3\"\n-#define DIVHI3_LIBCALL \"__divhi3\"\n-\n-#define INIT_TARGET_OPTABS \\\n-  do { \\\n-    sdiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = init_one_libfunc (DIVHI3_LIBCALL);\t\t\\\n-    smod_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = init_one_libfunc (MODHI3_LIBCALL);\t\t\\\n-  } while (0)\n-\n-/* The assembler op to get a word.  */\n-\n-#define FILE_ASM_OP \"\\t.file\\n\"\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"call_address_operand\",\t{ SYMBOL_REF, REG }},\t\t\t\\\n-  {\"constant_memory_operand\",\t{ MEM }},\t\t\t\t\\\n-  {\"psimode_truncation_operand\",{ PLUS, CONST_INT, CONST_DOUBLE, CONST,\t\\\n-\t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG, REG, MEM }},\\\n-  {\"extendpsi_operand\",\t\t{ PLUS, CONST_INT, CONST_DOUBLE, CONST,\t\\\n-\t\t\t\t  SYMBOL_REF, LABEL_REF, SUBREG, REG, MEM }}, \\\n-  {\"nshift_operator\",\t\t{ ASHIFTRT, LSHIFTRT, ASHIFT }},\n-\n-extern GTY(()) rtx zero_dreg;\n-extern GTY(()) rtx zero_areg;"}, {"sha": "ea658fdb31c8f1d3c73d5928c3c1a71fbaa5ffd9", "filename": "gcc/config/mn10200/mn10200.md", "status": "removed", "additions": 0, "deletions": 2050, "changes": 2050, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.md?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,2050 +0,0 @@\n-;; GCC machine description for Matsushita MN10200\n-;; Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n-;; Contributed by Jeff Law (law@cygnus.com).\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-;; The original PO technology requires these to be ordered by speed,\n-;; so that assigner will pick the fastest.\n-\n-;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-;; Condition code settings.\n-;; none - insn does not affect cc\n-;; none_0hit - insn does not affect cc but it does modify operand 0\n-;;\tThis attribute is used to keep track of when operand 0 changes.\n-;; \tSee the description of NOTICE_UPDATE_CC for more info.\n-;; set_znv - sets z,n,v to usable values; c is unknown.\n-;; set_zn  - sets z,n to usable values; v,c is unknown.\n-;; compare - compare instruction\n-;; clobber - value of cc is unknown\n-(define_attr \"cc\" \"none,none_0hit,set_znv,set_zn,compare,clobber\"\n-  (const_string \"clobber\"))\n-\f\n-;; ----------------------------------------------------------------------\n-;; MOVE INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-;;\n-;; Some general notes on move instructions.\n-;;\n-;; The hardware can't encode nop moves involving data registers, so\n-;; we catch them and emit a nop instead.\n-;;\n-;; Loads/stores to/from address registers must be 16bit aligned,\n-;; thus we avoid them for QImode.\n-;;\n-;; Stores from address registers always store 24bits, so avoid\n-;; stores from address registers in HImode, SImode, and SFmode.\n-;;\n-;; As a result of the various problems using address registers in\n-;; QImode, HImode, SImode, and SFmode, we discourage their use via\n-;; '*' in their constraints.  They're still allowed, but they're never\n-;; the preferred class for insns with those modes.\n-\n-;; movqi\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register */\n-  if (!register_operand (operand0, QImode)\n-      && !register_operand (operand1, QImode))\n-    operands[1] = copy_to_mode_reg (QImode, operand1);\n-}\")\n-\n-;; We avoid memory operations involving address registers because we\n-;; can't be sure they'll be suitably aligned.\n-;;\n-;; We also discourage holding QImode values in address registers.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,d,*a,d,d,m,d,*a,*a\")\n-\t(match_operand:QI 1 \"general_operand\" \"0,I,I,di,m,d,*a,d,i*a\"))]\n-  \"register_operand (operands[0], QImode)\n-   || register_operand (operands[1], QImode)\"\n-  \"@\n-  nop\n-  sub %0,%0\n-  sub %0,%0\n-  mov %S1,%0\n-  movbu %1,%0\n-  movb %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\"\n-  [(set_attr \"cc\" \"none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n-\n-;; movhi\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register */\n-  if (!register_operand (operand1, HImode)\n-      && !register_operand (operand0, HImode))\n-    operands[1] = copy_to_mode_reg (HImode, operand1);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,*a,d,d,m,d,*a,*a,*a\")\n-\t(match_operand:HI 1 \"general_operand\" \"0,I,I,di,m,d,*a,d,i*a,m\"))]\n-  \"register_operand (operands[0], HImode)\n-   || register_operand (operands[1], HImode)\"\n-  \"@\n-  nop\n-  sub %0,%0\n-  sub %0,%0\n-  mov %s1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %1,%0\n-  mov %A1,%0\"\n-  [(set_attr \"cc\" \"none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n-\n-;; movpsi and helpers\n-\n-(define_expand \"movpsi\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n-\t(match_operand:PSI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register */\n-  if (!register_operand (operand1, PSImode)\n-      && !register_operand (operand0, PSImode))\n-    operands[1] = copy_to_mode_reg (PSImode, operand1);\n-}\")\n-\n-\n-;; Constant and indexed addresses are not valid addresses for PSImode,\n-;; therefore they won't be matched by the general movpsi pattern below.\n-;; ??? We had patterns to handle indexed addresses, but they kept making\n-;; us run out of regs, so they were eliminated.\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"register_operand\" \"=a\")\n-\t(match_operand:PSI 1 \"constant_memory_operand\" \"\"))]\n-  \"\"\n-  \"mov %A1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"constant_memory_operand\" \"=X\")\n-\t(match_operand:PSI 1 \"register_operand\" \"a\"))]\n-  \"\"\n-  \"mov %1,%A0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-;; We want to prefer address registers here because 24bit moves to/from\n-;; memory are shorter and faster when done via address registers.\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,a?d,?da,a,m,?d,m\")\n-\t(match_operand:PSI 1 \"general_operand\" \"0,I,?dai,m,a,m,?d\"))]\n-  \"register_operand (operands[0], PSImode)\n-   || register_operand (operands[1], PSImode)\"\n-  \"@\n-  nop\n-  sub %0,%0\n-  mov %1,%0\n-  mov %A1,%0\n-  mov %1,%A0\n-  movx %A1,%0\n-  movx %1,%A0\"\n-  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register */\n-  if (!register_operand (operand1, SImode)\n-      && !register_operand (operand0, SImode))\n-    operands[1] = copy_to_mode_reg (SImode, operand1);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,*a,dm,d,d,*a,*a,*a\")\n-\t(match_operand:SI 1 \"general_operand\" \"0,I,I,d,dim,*a,d,*a,i\"))]\n-  \"register_operand (operands[0], SImode)\n-   || register_operand (operands[1], SImode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \\\"nop\\\";\n-    case 1:\n-    case 2:\n-      return \\\"sub %H0,%H0\\;sub %L0,%L0\\\";\n-    case 3:\n-    case 5:\n-    case 6:\n-    case 7:\n-      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n-\n-    /* The next two cases try to optimize cases where one half\n-       of the constant is all zeros, or when the two halves are\n-       the same.  */\n-    case 4:\n-    case 8:\n-      if (REG_P (operands[0])\n-\t  && GET_CODE (operands[1]) == CONST_INT\n-\t  && (INTVAL (operands[1]) & 0xffff0000) == 0)\n-\toutput_asm_insn (\\\"sub %H0,%H0\\\", operands);\n-      else\n-\toutput_asm_insn (\\\"mov %h1,%H0\\\", operands);\n-\n-      if (GET_CODE (operands[1]) == CONST_INT\n-\t  && ((INTVAL (operands[1]) & 0xffff)\n-\t      == ((INTVAL (operands[1]) >> 16) & 0xffff)))\n-\toutput_asm_insn (\\\"mov %H0,%L0\\\", operands);\n-      else if (GET_CODE (operands[1]) == CONST_INT\n-\t       && (INTVAL (operands[1]) & 0xffff) == 0)\n-\toutput_asm_insn (\\\"sub %L0,%L0\\\", operands);\n-      else\n-\toutput_asm_insn (\\\"mov %o1,%L0\\\", operands);\n-      return \\\"\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"cc\" \"none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register */\n-  if (!register_operand (operand1, SFmode)\n-      && !register_operand (operand0, SFmode))\n-    operands[1] = copy_to_mode_reg (SFmode, operand1);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=d,d,*a,dm,d,d,*a,*a,*a\")\n-\t(match_operand:SF 1 \"general_operand\" \"0,G,G,d,dim,*a,d,*a,i\"))]\n-  \"register_operand (operands[0], SFmode)\n-   || register_operand (operands[1], SFmode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \\\"nop\\\";\n-\n-    case 1:\n-    case 2:\n-      return \\\"sub %H0,%H0\\;sub %L0,%L0\\\";\n-\n-    default:\n-      {\n-        long val = 0;\n-        REAL_VALUE_TYPE rv;\n-\n-\tif (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t  {\n-\t    REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n-\t    REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-\t  }\n-\n-\tif (GET_CODE (operands[1]) == CONST_INT)\n-\t  val = INTVAL (operands[1]);\n-\n-        if ((GET_CODE (operands[1]) == CONST_INT\n-\t     || GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t    && (val & 0xffff0000) == 0)\n-\t  output_asm_insn (\\\"sub %H0,%H0\\\", operands);\n-\telse\n-\t  output_asm_insn (\\\"mov %h1,%H0\\\", operands);\n-\t\n-\tif (GET_CODE (operands[1]) == CONST_INT\n-\t    && ((INTVAL (operands[1]) & 0xffff)\n-\t\t == ((INTVAL (operands[1]) >> 16) & 0xffff)))\n-\t  output_asm_insn (\\\"mov %H0,%L0\\\", operands);\n-        else if ((GET_CODE (operands[1]) == CONST_INT\n-\t\t  || GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t\t && (val & 0x0000ffff) == 0)\n-\t  output_asm_insn (\\\"sub %L0,%L0\\\", operands);\n-\telse\n-\t  output_asm_insn (\\\"mov %o1,%L0\\\", operands);\n-\treturn \\\"\\\";\n-      }\n-    }\n-}\"\n-  [(set_attr \"cc\" \"none,clobber,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n-\n-\f\n-;; ----------------------------------------------------------------------\n-;; TEST INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-;; Go ahead and define tsthi and tstpsi so we can eliminate redundant tst insns\n-;; when we start trying to optimize this port.\n-(define_insn \"tsthi\"\n-  [(set (cc0) (match_operand:HI 0 \"nonimmediate_operand\" \"da\"))]\n-  \"\"\n-  \"* return output_tst (operands[0], insn);\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-(define_insn \"tstpsi\"\n-  [(set (cc0) (match_operand:PSI 0 \"nonimmediate_operand\" \"da\"))]\n-  \"\"\n-  \"* return output_tst (operands[0], insn);\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extend:HI (match_operand:QI 0 \"memory_operand\" \"d\")))]\n-  \"\"\n-  \"* return output_tst (operands[0], insn);\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extend:PSI (match_operand:QI 0 \"memory_operand\" \"d\")))]\n-  \"\"\n-  \"* return output_tst (operands[0], insn);\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-(define_insn \"cmphi\"\n-  [(set (cc0)\n-\t(compare:HI (match_operand:HI 0 \"nonimmediate_operand\" \"da\")\n-\t\t    (match_operand:HI 1 \"general_operand\" \"dai\")))]\n-  \"\"\n-  \"cmp %1,%0\"\n-  [(set_attr \"cc\" \"compare\")])\n-\n-(define_insn \"cmppsi\"\n-  [(set (cc0)\n-\t(compare:PSI (match_operand:PSI 0 \"nonimmediate_operand\" \"da\")\n-\t\t     (match_operand:PSI 1 \"general_operand\" \"dai\")))]\n-  \"\"\n-  \"cmp %1,%0\"\n-  [(set_attr \"cc\" \"compare\")])\n-\f\n-;; ----------------------------------------------------------------------\n-;; ADD INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-(define_insn \"addhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"dai\")))]\n-  \"\"\n-  \"add %2,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-(define_insn \"addpsi3\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=da\")\n-\t(plus:PSI (match_operand:PSI 1 \"general_operand\" \"%0\")\n-\t\t  (match_operand:PSI 2 \"general_operand\" \"dai\")))]\n-  \"\"\n-  \"add %2,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-;; We want to avoid using explicit registers; reload won't tell us\n-;; if it has to spill them and may generate incorrect code in such\n-;; cases.\n-;;\n-;; So we call out to a library routine to perform 32bit add or\n-;; subtract operations.\n-;;\n-;; operand2 must be nonmemory_operand so that we will accept CONST_INTs\n-;; during initial code generation.\n-(define_expand \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* If adding a CONST_INT, we are better off generating code ourselves.\n-\n-     During RTL generation we call out to library routines.\n-\n-     After RTL generation we can not call the library routines as\n-     they need to push arguments via virtual_outgoing_args_rtx which\n-     has already been instantiated.  So, after RTL generation we just\n-     FAIL and open code the operation.  */\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      if (!rtx_equal_p (operands[0], operands[1]))\n-\temit_move_insn (operands[0], operands[1]);\n-      emit_insn (gen_addsi3_const (operands[0], operands[0], operands[2]));\n-      DONE;\n-    }\n-  else if (rtx_equal_function_value_matters)\n-    {\n-      rtx ret, insns;\n-\n-      start_sequence ();\n-      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__addsi3\\\"),\n-\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n-\t\t\t\t     SImode, operands[2], SImode);\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx_PLUS (SImode, operands[1], operands[2]));\n-      DONE;\n-    }\n-  else\n-    FAIL;\n-}\")\n-\n-(define_insn \"addsi3_const\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")))\n-   (clobber (match_scratch:SI 3 \"=&d\"))]\n-  \"\"\n-  \"*\n-{\n-  unsigned long value = INTVAL (operands[2]);\n-\n-  /* If only the high bits are set in the constant, then we only\n-     need a single add operation.  It might be better to catch this\n-     at RTL expansion time.  */\n-  if ((value & 0xffff) == 0)\n-    return \\\"add %h2,%H0\\\";\n-\n-  value >>= 16;\n-  value &= 0xffff;\n-\n-  if (value == 0)\n-    return \\\"sub %3,%3\\;add %o2,%L0\\;addc %3,%H0\\\";\n-  else\n-    return \\\"mov %h2,%3\\;add %o2,%L0\\;addc %3,%H0\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; ----------------------------------------------------------------------\n-;; SUBTRACT INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-(define_insn \"subhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:HI 2 \"general_operand\" \"dai\")))]\n-  \"\"\n-  \"sub %2,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-(define_insn \"subpsi3\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=da\")\n-\t(minus:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:PSI 2 \"general_operand\" \"dai\")))]\n-  \"\"\n-  \"sub %2,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-(define_expand \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* During RTL generation we call out to library routines.\n-\n-     After RTL generation we can not call the library routines as\n-     they need to push arguments via virtual_outgoing_args_rtx which\n-     has already been instantiated.  So, after RTL generation we just\n-     FAIL and open code the operation.  */\n-  if (rtx_equal_function_value_matters)\n-    {\n-      rtx ret, insns;\n-\n-      start_sequence ();\n-      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__subsi3\\\"),\n-\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n-\t\t\t\t     SImode, operands[2], SImode);\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx_MINUS (SImode, operands[1], operands[2]));\n-      DONE;\n-    }\n-  else\n-    FAIL;\n-}\")\n-\n-;; There isn't a negate instruction, so we fake it.\n-;;\n-;; We used to expand this into patterns, but a single pattern\n-;; actually generates better overall code.\n-;; \n-;; We could do HImode negations with a \"not;add\" sequence, but\n-;; generally it's generated slightly worse code.\n-;;\n-;; The second alternative is not strictly necesasry, but helps\n-;; when the register allocators start running short of registers.\n-(define_insn \"neghi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=&d,d\")\n-        (neg:HI (match_operand:HI 1 \"general_operand\" \"d,0\")))]\n-  \"\"\n-  \"@\n-  sub %0,%0\\;sub %1,%0\n-  not %0\\;add 1,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-;; The not/and sequence won't work here.  It's not clear if we'll\n-;; ever need to provide an alternate sequence since this should\n-;; be used much less frequently than neghi2.\n-(define_insn \"negpsi2\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=&d\")\n-        (neg:PSI (match_operand:PSI 1 \"general_operand\" \"d\")))]\n-  \"\"\n-  \"sub %0,%0\\;sub %1,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-;; Using a magic libcall that accepts its arguments in any\n-;; data register pair has proven to be the most efficient\n-;; and most compact way to represent negsi2.\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(neg:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"jsr ___negsi2_%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n- \n-;; ----------------------------------------------------------------------\n-;; MULTIPLY INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-;;\n-;; The mn10200 has HIxHI->SI widening multiply, but we get _severe_\n-;; code density regressions if we enable such a pattern.\n-\n-(define_insn \"mulhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"d\")))]\n-  \"\"\n-  \"mul %2,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-(define_insn \"udivmodhi4\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"d\")))\n-   (set (match_operand:HI 3 \"general_operand\" \"=&d\")\n-\t(umod:HI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"*\n-{\n-  if (zero_dreg)\n-    output_asm_insn (\\\"mov %0,mdr\\\", &zero_dreg);\n-  else\n-    output_asm_insn (\\\"sub %3,%3\\;mov %3,mdr\\\", operands);\n-    \n-  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n-    return \\\"divu %2,%0\\\";\n-  else\n-    return \\\"divu %2,%0\\;mov mdr,%3\\\";\n-}\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-\f\n-;; ----------------------------------------------------------------------\n-;; AND INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-(define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,d\")\n-\t(and:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"M,di\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xff)\n-    return \\\"extxbu %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x7fff)\n-    return \\\"add %0,%0\\;lsr %0\\\";\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffe)\n-    return \\\"lsr %0\\;add %0,%0\\\";\n-  return \\\"and %2,%0\\\";\n-}\"\n-  [(set_attr \"cc\" \"none_0hit,set_znv\")])\n-\n-;; This expander + pattern exist only to allow trampolines to be aligned\n-;; in the stack.\n-(define_expand \"andpsi3\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n-\t(and:PSI (match_operand:PSI 1 \"general_operand\" \"\")\n-\t\t(match_operand:PSI 2 \"const_int_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || (INTVAL (operands[2]) & 0xff0000) != 0xff0000)\n-    FAIL;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d\")\n-\t(and:PSI (match_operand:PSI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:PSI 2 \"const_int_operand\" \"i\")))]\n-  \"GET_CODE (operands[2]) == CONST_INT\n-   && (INTVAL (operands[2]) & 0xff0000) == 0xff0000\"\n-  \"and %2,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; ----------------------------------------------------------------------\n-;; OR INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-(define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"di\")))]\n-  \"\"\n-  \"or %2,%0\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-;; ----------------------------------------------------------------------\n-;; XOR INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-(define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"di\")))]\n-  \"\"\n-  \"xor %2,%0\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-;; ----------------------------------------------------------------------\n-;; NOT INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-(define_insn \"one_cmplhi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"not %0\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-\f\n-;; -----------------------------------------------------------------\n-;; BIT INSTRUCTIONS\n-;; -----------------------------------------------------------------\n-\n-;; These clears a constant set of bits in memory or in a register.\n-;; We must support register destinations to make reload happy.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"+R,d\")\n-\t(subreg:QI\n-\t  (and:HI (subreg:HI (match_dup 0) 0)\n-\t\t  (match_operand 1 \"const_int_operand\" \"\")) 0))\n-   (clobber (match_scratch:HI 2 \"=&d,X\"))]\n-  \"\"\n-  \"@\n-  mov %N1,%2\\;bclr %2,%0\n-  and %1,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; This clears a variable set of bits in memory or in a register.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"+R,d\")\n-\t(subreg:QI\n-\t  (and:HI (subreg:HI (match_dup 0) 0)\n-\t\t  (not:HI (match_operand:HI 1 \"general_operand\" \"d,d\"))) 0))\n-   (clobber (match_scratch:HI 2 \"=X,&d\"))]\n-  \"\"\n-  \"@\n-  bclr %1,%0\n-  mov %1,%2\\;not %2\\;and %2,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"+R,d\")\n-\t(subreg:QI\n-\t  (and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"d,d\"))\n-\t\t  (subreg:HI (match_dup 0) 0)) 0))\n-   (clobber (match_scratch:HI 2 \"=X,&d\"))]\n-  \"\"\n-  \"@\n-  bclr %1,%0\n-  mov %1,%2\\;not %2\\;and %2,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; These set bits in memory.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"+R,d\")\n-\t(subreg:QI\n-\t  (ior:HI (subreg:HI (match_dup 0) 0)\n-\t\t  (match_operand:HI 1 \"general_operand\" \"d,d\")) 0))]\n-  \"\"\n-  \"@\n-  bset %1,%0\n-  or %1,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"+R,d\")\n-\t(subreg:QI\n-\t  (ior:HI (match_operand:HI 1 \"general_operand\" \"d,d\")\n-\t\t  (subreg:HI (match_dup 0) 0)) 0))]\n-  \"\"\n-  \"@\n-  bset %1,%0\n-  or %1,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; Not any shorter/faster than using cmp, but it might save a\n-;; register if the result of the AND isn't ever used.\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-     (zero_extract:HI (match_operand:HI 0 \"general_operand\" \"d\")\n-\t\t      (match_operand 1 \"const_int_operand\" \"\")\n-\t\t      (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"\"\n-  \"*\n-{\n-  int len = INTVAL (operands[1]);\n-  int bit = INTVAL (operands[2]);\n-  int mask = 0;\n-  rtx xoperands[2];\n-\n-  while (len > 0)\n-    {\n-      mask |= (1 << bit);\n-      bit++;\n-      len--;\n-    }\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = GEN_INT (mask);\n-  output_asm_insn (\\\"btst %1,%0\\\", xoperands);\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"\"\n-  [(set (cc0) (and:HI (match_operand:HI 0 \"general_operand\" \"d\")\n-\t\t      (match_operand:HI 1 \"const_int_operand\" \"i\")))]\n-  \"\"\n-  \"btst %1,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-\f\n-;; ----------------------------------------------------------------------\n-;; JUMP INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-;; Conditional jump instructions\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n-      && (GET_CODE (operands[1]) == GT\n-          || GET_CODE (operands[1]) == GE\n-          || GET_CODE (operands[1]) == LE\n-          || GET_CODE (operands[1]) == LT))\n-    return 0;\n-\n-  if (GET_MODE (SET_SRC (PATTERN (PREV_INSN (insn)))) == PSImode)\n-    return \\\"b%b1x %0\\\";\n-  else\n-    return \\\"b%b1 %0\\\";\n-}\"\n- [(set_attr \"cc\" \"none\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(cc0) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n-      && (GET_CODE (operands[1]) == GT\n-          || GET_CODE (operands[1]) == GE\n-          || GET_CODE (operands[1]) == LE\n-          || GET_CODE (operands[1]) == LT))\n-    return 0;\n-\n-  if (GET_MODE (SET_SRC (PATTERN (PREV_INSN (insn)))) == PSImode)\n-    return \\\"b%B1x %0\\\";\n-  else\n-    return \\\"b%B1 %0\\\";\n-}\"\n- [(set_attr \"cc\" \"none\")])\n-\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"jmp %l0\"\n- [(set_attr \"cc\" \"none\")])\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:PSI 0 \"register_operand\" \"a\"))]\n-  \"\"\n-  \"jmp (%0)\"\n-  [(set_attr \"cc\" \"none\")])\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:PSI 0 \"register_operand\" \"a\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"jmp  (%0)\"\n-  [(set_attr \"cc\" \"none\")])\n-\n-;; Call subroutine with no return value.\n-\n-(define_expand \"call\"\n-  [(call (match_operand:QI 0 \"general_operand\" \"\")\n-\t (match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (! call_address_operand (XEXP (operands[0], 0), VOIDmode))\n-    XEXP (operands[0], 0) = force_reg (PSImode, XEXP (operands[0], 0));\n-  emit_call_insn (gen_call_internal (XEXP (operands[0], 0), operands[1]));\n-  DONE;\n-}\")\n-\n-(define_insn \"call_internal\"\n-  [(call (mem:QI (match_operand:PSI 0 \"call_address_operand\" \"aS\"))\n-\t (match_operand:HI 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"jsr %C0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; Call subroutine, returning value in operand 0\n-;; (which must be a hard register).\n-\n-(define_expand \"call_value\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (match_operand:QI 1 \"general_operand\" \"\")\n-\t      (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (! call_address_operand (XEXP (operands[1], 0), VOIDmode))\n-    XEXP (operands[1], 0) = force_reg (PSImode, XEXP (operands[1], 0));\n-  emit_call_insn (gen_call_value_internal (operands[0],\n-\t\t\t\t\t   XEXP (operands[1], 0),\n-\t\t\t\t\t   operands[2]));\n-  DONE;\n-}\")\n-\n-(define_insn \"call_value_internal\"\n-  [(set (match_operand 0 \"\" \"=da\")\n-\t(call (mem:QI (match_operand:PSI 1 \"call_address_operand\" \"aS\"))\n-\t      (match_operand:HI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"jsr %C1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_expand \"untyped_call\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n-                    (const_int 0))\n-              (match_operand 1 \"\" \"\")\n-              (match_operand 2 \"\" \"\")])]\n-  \"\"\n-  \"\n-{\n-  int i;\n-\n-  emit_call_insn (gen_call (operands[0], const0_rtx));\n-\n-  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n-    {\n-      rtx set = XVECEXP (operands[2], 0, i);\n-      emit_move_insn (SET_DEST (set), SET_SRC (set));\n-    }\n-  DONE;\n-}\")\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"nop\"\n-  [(set_attr \"cc\" \"none\")])\n-\f\n-;; ----------------------------------------------------------------------\n-;; EXTEND INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-\n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d\")\n-\t(zero_extend:HI\n-\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n-  \"\"\n-  \"@\n-  extxbu %0\n-  mov %1,%0\\;extxbu %0\n-  movbu %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"zero_extendqipsi2\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(zero_extend:PSI\n-\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n-  \"\"\n-  \"@\n-  extxbu %0\n-  mov %1,%0\\;extxbu %0\n-  movbu %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n-\t(zero_extend:SI\n-\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n-  \"\"\n-  \"@\n-  extxbu %L0\\;sub %H0,%H0\n-  mov %1,%L0\\;extxbu %L0\\;sub %H0,%H0\n-  movbu %1,%L0\\;sub %H0,%H0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"zero_extendhipsi2\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(zero_extend:PSI\n-\t (match_operand:HI 1 \"general_operand\" \"0,di,m\")))]\n-  \"\"\n-  \"@\n-  extxu %0\n-  mov %1,%0\\;extxu %0\n-  mov %1,%0\\;extxu %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d\")\n-\t(zero_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"0,dim\")))]\n-  \"\"\n-  \"@\n-  sub %H0,%H0\n-  mov %1,%L0\\;sub %H0,%H0\"\n-  [(set_attr \"cc\" \"clobber,clobber\")])\n-\n-;; The last alternative is necessary because the second operand might\n-;; have been the frame pointer.  The frame pointer would get replaced\n-;; by (plus (stack_pointer) (const_int)).\n-;;\n-;; Reload would think that it only needed a PSImode register in\n-;; push_reload and at the start of allocate_reload_regs.  However,\n-;; at the end of allocate_reload_reg it would realize that the\n-;; reload register must also be valid for SImode, and if it was\n-;; not valid reload would abort.\n-(define_insn \"zero_extendpsisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,?d,?*d,?*d\")\n-\t(zero_extend:SI (match_operand:PSI 1 \"extendpsi_operand\"\n-\t\t\t\t\t\t\"m,?0,?*dai,Q\")))]\n-  \"\"\n-  \"@\n-  mov %L1,%L0\\;movbu %H1,%H0\n-  jsr ___zero_extendpsisi2_%0\n-  mov %1,%L0\\;jsr ___zero_extendpsisi2_%0\n-  mov a3,%L0\\;add %Z1,%L0\\;jsr ___zero_extendpsisi2_%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;;- sign extension instructions\n-\n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d\")\n-\t(sign_extend:HI\n-\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return \\\"extxb %0\\\";\n-  else if (which_alternative == 1)\n-    return \\\"mov %1,%0\\;extxb %0\\\";\n-  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n-    return \\\"movbu %1,%0\\;extxb %0\\\";\n-  else\n-    return \\\"movb %1,%0\\\";\n-}\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"extendqipsi2\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(sign_extend:PSI\n-\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return \\\"extxb %0\\\";\n-  else if (which_alternative == 1)\n-    return \\\"mov %1,%0\\;extxb %0\\\";\n-  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n-    return \\\"movbu %1,%0\\;extxb %0\\\";\n-  else\n-    return \\\"movb %1,%0\\\";\n-}\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n-\t(sign_extend:SI\n-\t (match_operand:QI 1 \"general_operand\" \"0,di,m\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return \\\"extxb %L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\\\";\n-  else if (which_alternative == 1)\n-    return \\\"mov %1,%L0\\;extxb %L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\\\";\n-  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n-    return \\\"movbu %1,%L0\\;extxb %L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\\\";\n-  else\n-    return \\\"movb %1,%L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"extendhipsi2\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(sign_extend:PSI\n-\t (match_operand:HI 1 \"general_operand\" \"0,di,m\")))]\n-  \"\"\n-  \"@\n-  extx %0\n-  mov %1,%0\\;extx %0\n-  mov %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n-\t(sign_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"0,di,m\")))]\n-  \"\"\n-  \"@\n-  mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\n-  mov %1,%L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\n-  mov %1,%L0\\;mov %L0,%H0\\;add %H0,%H0\\;subc %H0,%H0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; The last alternative is necessary because the second operand might\n-;; have been the frame pointer.  The frame pointer would get replaced\n-;; by (plus (stack_pointer) (const_int)).\n-;;\n-;; Reload would think that it only needed a PSImode register in\n-;; push_reload and at the start of allocate_reload_regs.  However,\n-;; at the end of allocate_reload_reg it would realize that the\n-;; reload register must also be valid for SImode, and if it was\n-;; not valid reload would abort.\n-(define_insn \"extendpsisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,?d,?*d,?*d\")\n-\t(sign_extend:SI (match_operand:PSI 1 \"extendpsi_operand\"\n-\t\t\t\t\t\t\"m,?0,?*dai,Q\")))]\n-  \"\"\n-  \"@\n-  mov %L1,%L0\\;movb %H1,%H0\n-  jsr ___sign_extendpsisi2_%0\n-  mov %1,%L0\\;jsr ___sign_extendpsisi2_%0\n-  mov a3,%L0\\;add %Z1,%L0\\;jsr ___sign_extendpsisi2_%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"truncsipsi2\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=a,?d,?*d,da\")\n-\t(truncate:PSI (match_operand:SI 1 \"psimode_truncation_operand\" \"m,?m,?*d,i\")))]\n-   \"\"\n-   \"@\n-   mov %1,%0\n-   movx %A1,%0\n-   jsr ___truncsipsi2_%1_%0\n-   mov %1,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-\f\n-;; Combine should be simplifying this stuff, but isn't.\n-;;\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n-\t(sign_extend:SI\n-\t  (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,di,m\"))))]\n-  \"\"\n-  \"@\n-  extxbu %L0\\;sub %H0,%H0\n-  mov %1,%L0\\;extxbu %L0\\;sub %H0,%H0\n-  movbu %1,%L0\\;sub %H0,%H0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-        (truncate:PSI\n-\t  (sign_extend:SI (match_operand:QI 1 \"general_operand\" \"0,di,m\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return \\\"extxb %0\\\";\n-  else if (which_alternative == 1)\n-    return \\\"mov %1,%0\\;extxb %0\\\";\n-  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n-    return \\\"movbu %1,%0\\;extxb %0\\\";\n-  else\n-    return \\\"movb %1,%0\\\";\n-}\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(truncate:PSI\n-\t  (sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0,di,m\"))))]\n-  \"\"\n-  \"@\n-  extx %0\n-  mov %1,%0\\;extx %0\n-  mov %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(truncate:PSI\n-\t  (sign_extend:SI\n-\t    (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,di,m\")))))]\n-  \"\"\n-  \"@\n-  extxbu %0\n-  mov %1,%0\\;extxbu %0\n-  movbu %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(truncate:PSI\n-\t  (zero_extend:SI (match_operand:HI 1 \"general_operand\" \"0,di,m\"))))]\n-  \"\"\n-  \"@\n-  extxu %0\n-  mov %1,%0\\;extxu %0\n-  mov %1,%0\\;extxu %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-        (truncate:PSI\n-\t  (zero_extend:SI (match_operand:QI 1 \"general_operand\" \"0,di,m\"))))]\n-  \"\"\n-  \"@\n-  extxbu %0\n-  mov %1,%0\\;extxbu %0\n-  movbu %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n-;; ----------------------------------------------------------------------\n-;; SHIFTS\n-;; ----------------------------------------------------------------------\n-\n-;; If the shift count is small, we expand it into several single bit\n-;; shift insns.  Otherwise we expand into a generic shift insn which\n-;; handles larger shift counts, shift by variable amounts, etc.\n-(define_expand \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* This is an experiment to see if exposing more of the underlying\n-     operations results in better code.  */\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) <= 4)\n-    {\n-      int count = INTVAL (operands[2]);\n-      emit_move_insn (operands[0], operands[1]);\n-      while (count > 0)\n-\t{\n-\t  emit_insn (gen_rtx_SET (HImode, operands[0],\n-\t\t\t\t  gen_rtx_ASHIFT (HImode,\n-\t\t\t\t\t\t  operands[0], GEN_INT (1))));\n-\t  count--;\n-\t}\n-      DONE;\n-    }\n-  else\n-    {\n-      expand_a_shift (HImode, ASHIFT, operands);\n-      DONE;\n-    }\n-}\")\n-\n-;; ASHIFT one bit.\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (const_int 1)))]\n-  \"\"\n-  \"add %0,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-(define_expand \"lshrhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* This is an experiment to see if exposing more of the underlying\n-     operations results in better code.  */\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) <= 4)\n-    {\n-      int count = INTVAL (operands[2]);\n-      emit_move_insn (operands[0], operands[1]);\n-      while (count > 0)\n-\t{\n-\t  emit_insn (gen_rtx_SET (HImode, operands[0],\n-\t\t\t\t   gen_rtx_LSHIFTRT (HImode,\n-\t\t\t\t\t\t     operands[0],\n-\t\t\t\t\t\t     GEN_INT (1))));\n-\t  count--;\n-\t}\n-      DONE;\n-    }\n-  else\n-    {\n-      expand_a_shift (HImode, LSHIFTRT, operands);\n-      DONE;\n-    }\n-}\")\n-\n-;; LSHIFTRT one bit.\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"lsr %0\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-(define_expand \"ashrhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* This is an experiment to see if exposing more of the underlying\n-     operations results in better code.  */\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) <= 4)\n-    {\n-      int count = INTVAL (operands[2]);\n-      emit_move_insn (operands[0], operands[1]);\n-      while (count > 0)\n-\t{\n-\t  emit_insn (gen_rtx_SET (HImode, operands[0],\n-\t\t\t\t  gen_rtx_ASHIFTRT (HImode, operands[0],\n-\t\t\t\t\t\t    GEN_INT (1))));\n-\t  count--;\n-\t}\n-      DONE;\n-    }\n-  else\n-    {\n-      expand_a_shift (HImode, ASHIFTRT, operands);\n-      DONE;\n-    }\n-}\")\n-\n-;; ASHIFTRT one bit.\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"asr %0\"\n-  [(set_attr \"cc\" \"set_znv\")])\n-\n-;; And the general HImode shift pattern.  Handles both shift by constants\n-;; and shift by variable counts.\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,d\")\n-\t(match_operator:HI 3 \"nshift_operator\" \n-\t\t\t[ (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t\t  (match_operand:HI 2 \"general_operand\" \"KL,dan\")]))\n-   (clobber (match_scratch:HI 4 \"=X,&d\"))]\n-  \"\"\n-  \"* return emit_a_shift (insn, operands);\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; We expect only ASHIFT with constant shift counts to be common for\n-;; PSImode, so we optimize just that case.  For all other cases we\n-;; extend the value to SImode and perform the shift in SImode.\n-(define_expand \"ashlpsi3\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n-\t(ashift:PSI (match_operand:PSI 1 \"general_operand\" \"\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* This is an experiment to see if exposing more of the underlying\n-     operations results in better code.  */\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) <= 7)\n-    {\n-      int count = INTVAL (operands[2]);\n-      emit_move_insn (operands[0], operands[1]);\n-      while (count > 0)\n-\t{\n-\t  emit_insn (gen_rtx_SET (PSImode, operands[0],\n-\t\t\t\t  gen_rtx_ASHIFT (PSImode,\n-\t\t\t\t\t\t  operands[0], GEN_INT (1))));\n-\t  count--;\n-\t}\n-      DONE;\n-    }\n-  else\n-    {\n-      expand_a_shift (PSImode, ASHIFT, operands);\n-      DONE;\n-    }\n-}\")\n-\n-;; ASHIFT one bit.\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d\")\n-\t(ashift:PSI (match_operand:PSI 1 \"general_operand\" \"0\")\n-\t\t    (const_int 1)))]\n-  \"\"\n-  \"add %0,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-(define_expand \"lshrpsi3\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n-\t(lshiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  rtx reg = gen_reg_rtx (SImode);\n-\n-  emit_insn (gen_zero_extendpsisi2 (reg, operands[1]));\n-  reg = expand_binop (SImode, lshr_optab, reg,\n-\t\t      operands[2], reg, 1, OPTAB_WIDEN);\n-  emit_insn (gen_truncsipsi2 (operands[0], reg));\n-  DONE;\n-}\")\n-\n-(define_expand \"ashrpsi3\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"\")\n-\t(ashiftrt:PSI (match_operand:PSI 1 \"general_operand\" \"\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  rtx reg = gen_reg_rtx (SImode);\n-\n-  emit_insn (gen_extendpsisi2 (reg, operands[1]));\n-  reg = expand_binop (SImode, ashr_optab, reg,\n-\t\t      operands[2], reg, 0, OPTAB_WIDEN);\n-  emit_insn (gen_truncsipsi2 (operands[0], reg));\n-  DONE;\n-}\")\n-\n-(define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashift:SI (match_operand:SI 1 \"nonmemory_operand\" \"\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* For small shifts, just emit a series of single bit shifts inline.\n-\n-     For other constant shift counts smaller than a word or non-constant\n-     shift counts we call out to a library call during RTL generation time;\n-     after RTL generation time we allow optabs.c to open code the operation.\n-     See comments in addsi3/subsi3 expanders.\n-\n-     Otherwise we allow optabs.c to open code the operation.  */\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) <= 3))\n-    {\n-      int count = INTVAL (operands[2]);\n-      emit_move_insn (operands[0], operands[1]);\n-      while (count > 0)\n-\t{\n-\t  emit_insn (gen_rtx_SET (SImode, operands[0],\n-\t\t\t\t  gen_rtx_ASHIFT (SImode,\n-\t\t\t\t\t\t  operands[0], GEN_INT (1))));\n-\t  count--;\n-\t}\n-      DONE;\n-    }\n-  else if (rtx_equal_function_value_matters\n-\t   && (GET_CODE (operands[2]) != CONST_INT\n-\t       || INTVAL (operands[2]) <= 15))\n-    {\n-      rtx ret, insns;\n-\n-      start_sequence ();\n-      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__ashlsi3\\\"),\n-\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n-\t\t\t\t     SImode, operands[2], HImode);\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx_ASHIFT (SImode, operands[1], operands[2]));\n-      DONE;\n-    }\n-  else\n-    FAIL;\n-}\")\n-\n-;; ASHIFT one bit.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"add %L0,%L0\\;addc %H0,%H0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* For small shifts, just emit a series of single bit shifts inline.\n-\n-     For other constant shift counts smaller than a word or non-constant\n-     shift counts we call out to a library call during RTL generation time;\n-     after RTL generation time we allow optabs.c to open code the operation.\n-     See comments in addsi3/subsi3 expanders.\n-\n-     Otherwise we allow optabs.c to open code the operation.  */\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) <= 2))\n-    {\n-      int count = INTVAL (operands[2]);\n-      emit_move_insn (operands[0], operands[1]);\n-      while (count > 0)\n-\t{\n-\t  emit_insn (gen_rtx_SET (SImode, operands[0],\n-\t\t\t\t  gen_rtx_LSHIFTRT (SImode, operands[0],\n-\t\t\t\t\t\t    GEN_INT (1))));\n-\t  count--;\n-\t}\n-      DONE;\n-    }\n-  else if (rtx_equal_function_value_matters\n-\t   && (GET_CODE (operands[2]) != CONST_INT\n-\t       || INTVAL (operands[2]) <= 15))\n-    {\n-      rtx ret, insns;\n-\n-      start_sequence ();\n-      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__lshrsi3\\\"),\n-\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n-\t\t\t\t     SImode, operands[2], HImode);\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx_LSHIFTRT (SImode, operands[1], operands[2]));\n-      DONE;\n-    }\n-  else\n-    FAIL;\n-}\")\n-\n-;; LSHIFTRT one bit.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"lsr %H0\\;ror %L0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  /* For small shifts, just emit a series of single bit shifts inline.\n-\n-     For other constant shift counts smaller than a word or non-constant\n-     shift counts we call out to a library call during RTL generation time;\n-     after RTL generation time we allow optabs.c to open code the operation.\n-     See comments in addsi3/subsi3 expanders.\n-\n-     Otherwise we allow optabs.c to open code the operation.  */\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) <= 2))\n-    {\n-      int count = INTVAL (operands[2]);\n-      emit_move_insn (operands[0], operands[1]);\n-      while (count > 0)\n-\t{\n-\t  emit_insn (gen_rtx_SET (SImode, operands[0],\n-\t\t\t\t  gen_rtx_ASHIFTRT (SImode, operands[0],\n-\t\t\t\t\t\t    GEN_INT (1))));\n-\t  count--;\n-\t}\n-      DONE;\n-    }\n-  else if (rtx_equal_function_value_matters\n-\t   && (GET_CODE (operands[2]) != CONST_INT\n-\t       || INTVAL (operands[2]) <= 15))\n-    {\n-      rtx ret, insns;\n-\n-      start_sequence ();\n-      ret = emit_library_call_value (gen_rtx_SYMBOL_REF (Pmode, \\\"__ashrsi3\\\"),\n-\t\t\t\t     NULL_RTX, 1, SImode, 2, operands[1],\n-\t\t\t\t     SImode, operands[2], HImode);\n-      insns = get_insns ();\n-      end_sequence ();\n-      emit_libcall_block (insns, operands[0], ret,\n-\t\t\t  gen_rtx_ASHIFTRT (SImode, operands[1], operands[2]));\n-      DONE;\n-    }\n-  else\n-    FAIL;\n-}\")\n-\n-;; ASHIFTRT one bit.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (const_int 1)))]\n-  \"\"\n-  \"asr %H0\\;ror %L0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; ----------------------------------------------------------------------\n-;; FP INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n-;;\n-;; The mn102 series does not have floating point instructions, but since\n-;; FP values are held in integer regs, we can clear the high bit easily\n-;; which gives us an efficient inline floating point absolute value.\n-;;\n-;; Similarly for negation of a FP value.\n-;;\n-\n-(define_expand \"abssf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-        (abs:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  rtx target, result, insns;\n-\n-  start_sequence ();\n-  target = operand_subword (operands[0], 1, 1, SFmode);\n-  result = expand_binop (HImode, and_optab,\n-\t\t\t operand_subword_force (operands[1], 1, SFmode),\n-\t\t\t GEN_INT(0x7fff), target, 0, OPTAB_WIDEN);\n-\n-  if (result == 0)\n-    abort ();\n-\n-  if (result != target)\n-    emit_move_insn (result, target);\n-\n-  emit_move_insn (operand_subword (operands[0], 0, 1, SFmode),\n-\t\t  operand_subword_force (operands[1], 0, SFmode));\n-\n-  insns = get_insns ();\n-  end_sequence ();\n-\n-  emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n-  DONE;\n-}\")\n-\n-(define_expand \"negsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-        (neg:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  rtx target, result, insns;\n-\n-  start_sequence ();\n-  target = operand_subword (operands[0], 1, 1, SFmode);\n-  result = expand_binop (HImode, xor_optab,\n-\t\t\t operand_subword_force (operands[1], 1, SFmode),\n-\t\t\t GEN_INT(-0x8000), target, 0, OPTAB_WIDEN);\n-\n-  if (result == 0)\n-    abort ();\n-\n-  if (result != target)\n-    emit_move_insn (result, target);\n-\n-  emit_move_insn (operand_subword (operands[0], 0, 1, SFmode),\n-\t\t  operand_subword_force (operands[1], 0, SFmode));\n-\n-  insns = get_insns ();\n-  end_sequence ();\n-\n-  emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n-  DONE;\n-}\")\n-\n-;; ----------------------------------------------------------------------\n-;; PROLOGUE/EPILOGUE\n-;; ----------------------------------------------------------------------\n-(define_expand \"prologue\"\n-  [(const_int 0)]\n-  \"\"\n-  \"expand_prologue (); DONE;\")\n-\n-(define_insn \"outline_prologue_call\"\n-  [(const_int 1)]\n-  \"\"\n-  \"jsr ___prologue\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_expand \"epilogue\"\n-  [(return)]\n-  \"\"\n-  \"\n-{\n-  expand_epilogue ();\n-  DONE;\n-}\")\n-\n-(define_insn \"outline_epilogue_call_a0\"\n-  [(const_int 2)]\n-  \"\"\n-  \"jsr ___epilogue_a0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"outline_epilogue_call_d0\"\n-  [(const_int 3)]\n-  \"\"\n-  \"jsr ___epilogue_d0\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"outline_epilogue_jump\"\n-  [(const_int 4)\n-   (return)]\n-  \"\"\n-  \"jmp ___epilogue_noreturn\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"return\"\n-  [(return)]\n-  \"reload_completed && total_frame_size () == 0\n-   && !current_function_needs_context\"\n-  \"*\n-{\n-  rtx next = next_active_insn (insn);\n-\n-  if (next\n-      && GET_CODE (next) == JUMP_INSN\n-      && GET_CODE (PATTERN (next)) == RETURN)\n-    return \\\"\\\";\n-  return \\\"rts\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"return_internal\"\n-  [(const_int 0)\n-   (return)]\n-  \"\"\n-  \"rts\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; These are special combiner patterns to improve array/pointer accesses.\n-;;\n-;; A typical sequence involves extending an integer/char, shifting it left\n-;; a few times, then truncating the value to PSImode.\n-;;\n-;; This first pattern combines the shifting & truncation operations, by\n-;; itself it is a win because the shifts end up occurring in PSImode instead\n-;; of SImode.  However, it has the secondary effect of giving us the\n-;; opportunity to match patterns which allow us to remove the initial\n-;; extension completely, which is a big win.\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,a,da\")\n-\t(truncate:PSI\n-\t  (ashift:SI (match_operand:SI 1 \"psimode_truncation_operand\" \"d,m,m,i\")\n-\t\t     (match_operand:HI 2 \"const_int_operand\" \"i,i,i,i\"))))]\n-  \"\"\n-  \"*\n-{\n-  int count = INTVAL (operands[2]);\n-  if (which_alternative == 0)\n-    output_asm_insn (\\\"jsr ___truncsipsi2_%1_%0\\\", operands);\n-  else if (which_alternative == 1)\n-    output_asm_insn (\\\"movx %A1,%0\\\", operands);\n-  else\n-    output_asm_insn (\\\" mov %1,%0\\\", operands);\n-\n-  while (count)\n-    {\n-      output_asm_insn (\\\"add %0,%0\\\", operands);\n-      count--;\n-    }\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; Similarly, except that we also have zero/sign extension of the\n-;; original operand.  */\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d\")\n-\t(truncate:PSI\n-\t  (ashift:SI\n-\t    (zero_extend:SI (match_operand:HI 1 \"general_operand\" \"0,dim\"))\n-\t    (match_operand:HI 2 \"const_int_operand\" \"i,i\"))))]\n-  \"\"\n-  \"*\n-{\n-  int count = INTVAL (operands[2]);\n-\n-  /* First extend operand 1 to PSImode.  */\n-  if (which_alternative == 0)\n-    output_asm_insn (\\\"extxu %0\\\", operands);\n-  else\n-    output_asm_insn (\\\"mov %1,%0\\;extxu %0\\\", operands);\n-\n-  /* Now do the shifting.  */\n-  while (count)\n-    {\n-      output_asm_insn (\\\"add %0,%0\\\", operands);\n-      count--;\n-    }\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(truncate:PSI\n-\t  (ashift:SI\n-\t    (sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0,di,m\"))\n-\t    (match_operand:HI 2 \"const_int_operand\" \"i,i,i\"))))]\n-  \"\"\n-  \"*\n-{\n-  int count = INTVAL (operands[2]);\n-\n-  /* First extend operand 1 to PSImode.  */\n-  if (which_alternative == 0)\n-    output_asm_insn (\\\"extx %0\\\", operands);\n-  else if (which_alternative == 1)\n-    output_asm_insn (\\\"mov %1,%0\\;extx %0\\\", operands);\n-  else\n-    output_asm_insn (\\\"mov %1,%0\\\", operands);\n-\n-  /* Now do the shifting.  */\n-  while (count)\n-    {\n-      output_asm_insn (\\\"add %0,%0\\\", operands);\n-      count--;\n-    }\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(truncate:PSI\n-\t  (ashift:SI\n-\t    (sign_extend:SI\n-\t      (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,di,m\")))\n-\t    (match_operand:HI 2 \"const_int_operand\" \"i,i,i\"))))]\n-  \"\"\n-  \"*\n-{\n-  int count = INTVAL (operands[2]);\n-\n-  /* First extend operand 1 to PSImode.  */\n-  if (which_alternative == 0)\n-    output_asm_insn (\\\"extxbu %0\\\", operands);\n-  else if (which_alternative == 1)\n-    output_asm_insn (\\\"mov %1,%0\\;extxbu %0\\\", operands);\n-  else\n-    output_asm_insn (\\\"movbu %1,%0\\\", operands);\n-\n-  /* Now do the shifting.  */\n-  while (count)\n-    {\n-      output_asm_insn (\\\"add %0,%0\\\", operands);\n-      count--;\n-    }\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:PSI 0 \"general_operand\" \"=d,d,d\")\n-\t(truncate:PSI\n-\t  (ashift:SI\n-\t    (sign_extend:SI\n-\t      (match_operand:QI 1 \"general_operand\" \"0,di,m\"))\n-\t    (match_operand:HI 2 \"const_int_operand\" \"i,i,i\"))))]\n-  \"\"\n-  \"*\n-{\n-  int count = INTVAL (operands[2]);\n-\n-  /* First extend operand 1 to PSImode.  */\n-  if (which_alternative == 0)\n-    output_asm_insn (\\\"extxb %0\\\", operands);\n-  else if (which_alternative == 1)\n-    output_asm_insn (\\\"mov %1,%0\\;extxb %0\\\", operands);\n-  else if (GET_CODE (XEXP (operands[1], 0)) == REG)\n-    output_asm_insn (\\\"movbu %1,%0\\;extxb %0\\\", operands);\n-  else\n-    output_asm_insn (\\\"movb %1,%0\\\", operands);\n-\n-  /* Now do the shifting.  */\n-  while (count)\n-    {\n-      output_asm_insn (\\\"add %0,%0\\\", operands);\n-      count--;\n-    }\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; Try to combine consecutive updates of the stack pointer (or any\n-;; other register for that matter).\n-(define_peephole\n-  [(set (match_operand:PSI 0 \"register_operand\" \"=da\")\n-\t(plus:PSI (match_dup 0)\n-\t\t  (match_operand 1 \"const_int_operand\" \"\")))\n-   (set (match_dup 0)\n-\t(plus:PSI (match_dup 0)\n-\t\t  (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[1] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[1]));\n-  return \\\"add %1,%0\\\";\n-}\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;;\n-;; We had patterns to check eq/ne, but the they don't work because\n-;; 0x80000000 + 0x80000000 = 0x0 with a carry out.\n-;;\n-;; The Z flag and C flag would be set, and we have no way to\n-;; check for the Z flag set and C flag clear.\n-;;\n-;; This will work on the mn10200 because we can check the ZX flag\n-;; if the comparison is in HImode.\n-(define_peephole\n-  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"d\"))\n-   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n-\t\t\t   (match_operand 1 \"\" \"\")\n-\t\t\t   (pc)))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcc %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"d\"))\n-   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n-\t\t\t   (match_operand 1 \"\" \"\")\n-\t\t\t   (pc)))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcs %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"d\"))\n-   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (match_operand 1 \"\" \"\")))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcs %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:HI 0 \"register_operand\" \"d\"))\n-   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (match_operand 1 \"\" \"\")))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcc %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:PSI 0 \"register_operand\" \"d\"))\n-   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n-\t\t\t   (match_operand 1 \"\" \"\")\n-\t\t\t   (pc)))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bccx %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:PSI 0 \"register_operand\" \"d\"))\n-   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n-\t\t\t   (match_operand 1 \"\" \"\")\n-\t\t\t   (pc)))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcsx %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:PSI 0 \"register_operand\" \"d\"))\n-   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (match_operand 1 \"\" \"\")))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcsx %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (match_operand:PSI 0 \"register_operand\" \"d\"))\n-   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (match_operand 1 \"\" \"\")))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bccx %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;; We call out to library routines to perform 32bit addition and subtraction\n-;; operations (see addsi3/subsi3 expanders for why).  These peepholes catch\n-;; the trivial case where the operation could be done with an add;addc or\n-;; sub;subc sequence.\n-(define_peephole\n-  [(set (mem:SI (reg:PSI 7)) (reg:SI 2))\n-   (set (reg:SI 0) (call (match_operand:QI 1 \"general_operand\" \"\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n-   && strcmp (XSTR (XEXP (operands[1], 0), 0), \\\"__addsi3\\\") == 0\"\n-  \"add d2,d0\\;addc d3,d1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (mem:SI (reg:PSI 7)) (reg:SI 2))\n-   (set (reg:SI 0) (call (match_operand:QI 1 \"general_operand\" \"\")\n-\t\t\t (match_operand:HI 2 \"general_operand\" \"\")))]\n-  \"GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF\n-   && strcmp (XSTR (XEXP (operands[1], 0), 0), \\\"__subsi3\\\") == 0\"\n-  \"sub d2,d0\\;subc d3,d1\"\n-  [(set_attr \"cc\" \"clobber\")])"}, {"sha": "7bdc5abdd07a49358da5f2a47ba223fde24502c9", "filename": "gcc/config/mn10200/t-mn10200", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Ft-mn10200", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fmn10200%2Ft-mn10200", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Ft-mn10200?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,52 +0,0 @@\n-LIB1ASMSRC = mn10200/lib1funcs.asm\n-LIB1ASMFUNCS    = _divhi3 \\\n-\t\t  _modhi3 \\\n-\t\t  _addsi3 \\\n-\t\t  _subsi3 \\\n-\t\t  _mulsi3 \\\n-\t\t  _ashlsi3 \\\n-\t\t  _lshrsi3 \\\n-\t\t  _ashrsi3 \\\n-\t\t  _negsi2_d0 \\\n-\t\t  _negsi2_d2 \\\n-\t\t  _zero_extendpsisi2_d0 \\\n-\t\t  _zero_extendpsisi2_d2 \\\n-\t\t  _sign_extendpsisi2_d0 \\\n-\t\t  _sign_extendpsisi2_d2 \\\n-\t\t  _truncsipsi2_d0_d0 \\\n-\t\t  _truncsipsi2_d0_d1 \\\n-\t\t  _truncsipsi2_d0_d2 \\\n-\t\t  _truncsipsi2_d0_d3 \\\n-\t\t  _truncsipsi2_d2_d0 \\\n-\t\t  _truncsipsi2_d2_d1 \\\n-\t\t  _truncsipsi2_d2_d2 \\\n-\t\t  _truncsipsi2_d2_d3 \\\n-\t\t  _cmpsi2 \\\n-\t\t  _ucmpsi2 \\\n-\t\t  _prologue \\\n-\t\t  _epilogue_a0 \\\n-\t\t  _epilogue_d0 \\\n-\t\t  _epilogue_noreturn \\\n-\t\t  _floatdisf \\\n-\t\t  _fixsfdi\n-\n-\n-# We do not have DF or DI types, so fake out the libgcc2 compilation.\n-TARGET_LIBGCC2_CFLAGS=-DDF=SF -DDI=SI\n-LIB2FUNCS_EXTRA = $(srcdir)/config/udivmodsi4.c \\\n-\t$(srcdir)/config/divmod.c $(srcdir)/config/udivmod.c\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.  The mn10200 only has single\n-# precision floating point.\n-FPBIT = fp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#define FLOAT_ONLY' >> fp-bit.c\n-\techo '#define SMALL_MACHINE' >> fp-bit.c\n-\techo '#define CMPtype HItype' >> fp-bit.c\n-\techo '#ifdef __LITTLE_ENDIAN__' >> fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>fp-bit.c\n-\techo '#endif' \t\t>> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c"}, {"sha": "c1d945c6daa63dcf4207e1c092df1f9094b9bd68", "filename": "gcc/config/pa/pa-hiux.h", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Fpa-hiux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Fpa-hiux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hiux.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,76 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for HI-UX.\n-   Copyright (C) 1993, 1995, 1996, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* HIUX is just a HPUX variant.  We can simply use the HPUX configuration\n-   for just about everything.  */\n-\n-/* OS cpp builtins are the one noteworthy difference between HPUX and HIUX.\n-   The following defines are similar to those for hpux10 with the addition\n-   of __H3050R and __H3050RX.  */\n-#undef TARGET_OS_CPP_BUILTINS\n-#define TARGET_OS_CPP_BUILTINS()\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-\tbuiltin_assert (\"system=hiux\");\t\t\t\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\t\t\\\n-\tbuiltin_define (\"__hp9000s800\");\t\t\t\\\n-\tbuiltin_define (\"__hp9000s800__\");\t\t\t\\\n-\tbuiltin_define (\"__hiux\");\t\t\t\t\\\n-\tbuiltin_define (\"__hiux__\");\t\t\t\t\\\n-\tbuiltin_define (\"__unix\");\t\t\t\t\\\n-\tbuiltin_define (\"__unix__\");\t\t\t\t\\\n-\tbuiltin_define (\"__H3050R\");\t\t\t\t\\\n-\tbuiltin_define (\"__H3050RX\");\t\t\t\t\\\n-\tif (c_language == clk_cplusplus)\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    builtin_define (\"_HIUX_SOURCE\");\t\t\t\\\n-\t    builtin_define (\"_INCLUDE_LONGLONG\");\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\telse if (!flag_iso)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    builtin_define (\"_HIUX_SOURCE\");\t\t\t\\\n-\t    if (preprocessing_trad_p ())\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\\\n-\t\tbuiltin_define (\"hp9000s800\");\t\t\t\\\n-\t\tbuiltin_define (\"hppa\");\t\t\t\\\n-\t\tbuiltin_define (\"hiux\");\t\t\t\\\n-\t\tbuiltin_define (\"unix\");\t\t\t\\\n-\t\tbuiltin_define (\"__CLASSIC_C__\");\t\t\\\n-\t\tbuiltin_define (\"_PWB\");\t\t\t\\\n-\t\tbuiltin_define (\"PWB\");\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\\\n-\t      builtin_define (\"__STDC_EXT__\");\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\tif (TARGET_SIO)\t\t\t\t\t\t\\\n-\t  builtin_define (\"_SIO\");\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    builtin_define (\"__hp9000s700\");\t\t\t\\\n-\t    builtin_define (\"__hp9000s700__\");\t\t\t\\\n-\t    builtin_define (\"_WSIO\");\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#undef SUBTARGET_SWITCHES\n-#define SUBTARGET_SWITCHES \\\n-  { \"sio\",\t MASK_SIO,\tN_(\"Generate cpp defines for server IO\") }, \\\n-  { \"wsio\",\t-MASK_SIO,\tN_(\"Generate cpp defines for workstation IO\") },"}, {"sha": "0239e038cf8c87d3c5e85f0bce7e2df600aaa7fb", "filename": "gcc/config/pa/pa-hpux7.h", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Fpa-hpux7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Fpa-hpux7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux7.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,86 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for HP-UX.\n-   Copyright (C) 1991, 1995, 1996, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT 0\n-#endif\n-\n-/* Make GCC agree with types.h.  */\n-#undef SIZE_TYPE\n-#undef PTRDIFF_TYPE\n-\n-#define SIZE_TYPE \"unsigned int\"\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef TARGET_OS_CPP_BUILTINS\n-#define TARGET_OS_CPP_BUILTINS()\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-\tbuiltin_assert (\"system=hpux\");\t\t\t\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\t\t\\\n-\tbuiltin_define (\"__hp9000s800\");\t\t\t\\\n-\tbuiltin_define (\"__hp9000s800__\");\t\t\t\\\n-\tbuiltin_define (\"__hp9k8\");\t\t\t\t\\\n-\tbuiltin_define (\"__hp9k8__\");\t\t\t\t\\\n-\tbuiltin_define (\"__hpux\");\t\t\t\t\\\n-\tbuiltin_define (\"__hpux__\");\t\t\t\t\\\n-\tbuiltin_define (\"__unix\");\t\t\t\t\\\n-\tbuiltin_define (\"__unix__\");\t\t\t\t\\\n-\tif (c_language == clk_cplusplus)\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    builtin_define (\"_HPUX_SOURCE\");\t\t\t\\\n-\t    builtin_define (\"_INCLUDE_LONGLONG\");\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\telse if (!flag_iso)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    builtin_define (\"_HPUX_SOURCE\");\t\t\t\\\n-\t    if (preprocessing_trad_p ())\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\\\n-\t\tbuiltin_define (\"hp9000s800\");\t\t\t\\\n-\t\tbuiltin_define (\"hp9k8\");\t\t\t\\\n-\t\tbuiltin_define (\"hppa\");\t\t\t\\\n-\t\tbuiltin_define (\"hpux\");\t\t\t\\\n-\t\tbuiltin_define (\"unix\");\t\t\t\\\n-\t\tbuiltin_define (\"__CLASSIC_C__\");\t\t\\\n-\t\tbuiltin_define (\"_PWB\");\t\t\t\\\n-\t\tbuiltin_define (\"PWB\");\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\\\n-\t      builtin_define (\"__STDC_EXT__\");\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-\tif (TARGET_SIO)\t\t\t\t\t\t\\\n-\t  builtin_define (\"_SIO\");\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-\t    builtin_define (\"__hp9000s700\");\t\t\t\\\n-\t    builtin_define (\"__hp9000s700__\");\t\t\t\\\n-\t    builtin_define (\"_WSIO\");\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#undef SUBTARGET_SWITCHES\n-#define SUBTARGET_SWITCHES \\\n-  { \"sio\",\t MASK_SIO,\tN_(\"Generate cpp defines for server IO\") }, \\\n-  { \"wsio\",\t-MASK_SIO,\tN_(\"Generate cpp defines for workstation IO\") },\n-\n-/* Like the default, except no -lg.  */\n-#undef LIB_SPEC\n-#define LIB_SPEC \"%{!p:%{!pg:-lc}}%{p: -L/lib/libp/ -lc}%{pg: -L/lib/libp/ -lc}\""}, {"sha": "89dbbc9ef46896f802425b48abb52dff4eaff849", "filename": "gcc/config/pa/pa-hpux9.h", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Fpa-hpux9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Fpa-hpux9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux9.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,31 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for HP PA-RISC 1.1\n-   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.\n-   Contributed by Tim Moore (moore@defmacro.cs.utah.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* We can debug dynamically linked executables on hpux9; we also want\n-   dereferencing of a NULL pointer to cause a SEGV.  */\n-#undef LINK_SPEC\n-#if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_PA_11)\n-#define LINK_SPEC \\\n-  \"%{!mpa-risc-1-0:%{!shared:-L/lib/pa1.1 -L/usr/lib/pa1.1 }} -z %{mlinker-opt:-O} %{!shared:-u main} %{static:-a archive} %{shared:-b}\"\n-#else\n-#define LINK_SPEC \\\n-  \"-z %{mlinker-opt:-O} %{!shared:-u main} %{static:-a archive} %{shared:-b}\"\n-#endif"}, {"sha": "8ff741f14357484547a79dd65f16e6cc309bc882", "filename": "gcc/config/pa/pa-oldas.h", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Fpa-oldas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Fpa-oldas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-oldas.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,22 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for HP PA-RISC 1.1\n-   Copyright (C) 1991, 1996 Free Software Foundation, Inc.\n-   Contributed by Tim Moore (moore@defmacro.cs.utah.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define HP_FP_ARG_DESCRIPTOR_REVERSED"}, {"sha": "4e6cd7a2d8e5414d8661fdabbd55b7477ce95a30", "filename": "gcc/config/pa/t-mpeix", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Ft-mpeix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpa%2Ft-mpeix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Ft-mpeix?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,5 +0,0 @@\n-LIB2FUNCS_EXTRA= quadlib.c\n-\n-quadlib.c: $(srcdir)/config/pa/quadlib.c\n-\trm -f quadlib.c\n-\tcp $(srcdir)/config/pa/quadlib.c ."}, {"sha": "72825d458df645671ca033e3581e307c707f1693", "filename": "gcc/config/psos.h", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpsos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fpsos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpsos.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,88 +0,0 @@\n-/* Operating system specific defines to be used when targeting GCC for some\n-   embedded system running pSOS. We assume GNU tools with ELF, but\n-   try to maintain compatibility with the MRI tools. Based on svr4.h.\n-   Copyright (C) 1996, 1999, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.\n-\n-   To use this file, make up a file with a name like:\n-\n-\t?????-psos.h\n-\n-   where ????? is replaced by the name of the basic hardware that you\n-   are targeting for.  Then, in the file ?????-psos.h, put something\n-   like:\n-\n-\t#include \"?????.h\"\n-\t#include \"psos.h\"\n-\n-   followed by any really system-specific defines (or overrides of\n-   defines) which you find that you need.\n-*/\n-\n-\n-/* Define a symbol indicating that we are using psos.h.  */\n-\n-#define USING_PSOS_H\n-\n-\n-/* All pSOS targets currently use the ELF object file format.  */\n-\n-#define OBJECT_FORMAT_ELF\n-\n-\n-/* Provide a NULL STARTFILE_SPEC. The startfile cannot be specified\n-   here because it depends on the architecture (e.g. 68K), the\n-   board-support package (e.g. M162) and the run-time configuration\n-   (e.g. application vs. ram-image vs. rom-image). Specify the\n-   startfile in a linker-script created from the generic\n-   architecture-specific linker-scripts.  */\n-\n-#undef\tSTARTFILE_SPEC\n-#define STARTFILE_SPEC \"\"\n-\n-\n-/* Predefined macros (independent of processor type).  */\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dpsos\"\n-\n-\n-/* Implicit library calls should use ANSI memcpy rather than BSD\n-   bcopy, etc.  */\n-\n-#define TARGET_MEM_FUNCTIONS\n-\n-/* This is how we tell the assembler that a symbol is weak.  */\n-\n-#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n-  do { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n-       fputc ('\\n', FILE); } while (0)\n-\n-/* Switch into a generic section.  */\n-#define TARGET_ASM_NAMED_SECTION  default_elf_asm_named_section\n-\n-/* Use DBX debugging info by default.  */\n-\n-#ifndef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n-#endif\n-\n-/* For pSOS we use DBX debugging info.  */\n-\n-#define DBX_DEBUGGING_INFO 1"}, {"sha": "8ec306f3802358b085d9715e2258e7c791d2df9a", "filename": "gcc/config/romp/romp-protos.h", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fromp%2Fromp-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fromp%2Fromp-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp-protos.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,62 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for ROMP chip.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Richard Kenner (kenner@nyu.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef RTX_CODE\n-extern int next_insn_tests_no_unsigned PARAMS ((rtx));\n-extern void update_cc PARAMS ((rtx, rtx));\n-extern int restore_compare_p PARAMS ((rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern rtx get_symref PARAMS ((const char *));\n-extern int check_precision PARAMS ((enum machine_mode, rtx, rtx));\n-extern const char *output_fpop PARAMS ((enum rtx_code, rtx, rtx, rtx, rtx));\n-extern int constant_pool_address_operand PARAMS ((rtx, enum machine_mode));\n-extern int romp_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int zero_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int short_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int symbolic_memory_operand PARAMS ((rtx, enum machine_mode));\n-extern int current_function_operand PARAMS ((rtx, enum machine_mode));\n-extern int constant_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_any_cint_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_D_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_add_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_and_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_mem_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_or_nonsymb_mem_operand PARAMS ((rtx, enum machine_mode));\n-extern int romp_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_0_operand PARAMS ((rtx, enum machine_mode));\n-extern int reg_15_operand PARAMS ((rtx, enum machine_mode));\n-extern int float_binary PARAMS ((rtx, enum machine_mode));\n-extern int float_unary PARAMS ((rtx, enum machine_mode));\n-extern int float_conversion PARAMS ((rtx, enum machine_mode));\n-extern void romp_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n-#endif /* RTX_CODE */\n-\n-extern int first_reg_to_save PARAMS ((void));\n-extern int romp_pushes_stack PARAMS ((void));\n-extern int romp_using_r14 PARAMS ((void));\n-extern int null_epilogue PARAMS ((void));\n-extern int romp_sa_size PARAMS ((void));\n-extern int romp_makes_calls PARAMS ((void));\n-extern void output_encoded_offset PARAMS ((FILE *, unsigned));\n-extern int romp_debugger_auto_correction PARAMS ((int));\n-extern int romp_debugger_arg_correction PARAMS ((int));\n-extern const char *output_in_line_mul PARAMS ((void));"}, {"sha": "ab4430279b33ce1aba352a20600230a65f8c39e4", "filename": "gcc/config/romp/romp.c", "status": "removed", "additions": 0, "deletions": 2191, "changes": 2191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,2191 +0,0 @@\n-/* Subroutines used for code generation on ROMP.\n-   Copyright (C) 1990, 1991, 1992, 1993, 1997, 1998, 1999, 2000, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Richard Kenner (kenner@nyu.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"flags.h\"\n-#include \"recog.h\"\n-#include \"obstack.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"ggc.h\"\n-#include \"toplev.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-#define min(A,B)\t((A) < (B) ? (A) : (B))\n-#define max(A,B)\t((A) > (B) ? (A) : (B))\n-\n-static int unsigned_comparisons_p PARAMS ((rtx));\n-static void output_loadsave_fpregs PARAMS ((FILE *, enum rtx_code, rtx));\n-static void output_fpops PARAMS ((FILE *));\n-static void init_fpops PARAMS ((void));\n-static int memory_offset_in_range_p PARAMS ((rtx, enum machine_mode, int, int));\n-static unsigned int hash_rtx PARAMS ((rtx));\n-static void romp_output_function_prologue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void romp_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void romp_select_rtx_section PARAMS ((enum machine_mode, rtx,\n-\t\t\t\t\t     unsigned HOST_WIDE_INT));\n-static void romp_encode_section_info PARAMS ((tree, rtx, int));\n-static bool romp_rtx_costs PARAMS ((rtx, int, int, int *));\n-static int romp_address_cost PARAMS ((rtx));\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE romp_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE romp_output_function_epilogue\n-#undef TARGET_ASM_SELECT_RTX_SECTION\n-#define TARGET_ASM_SELECT_RTX_SECTION romp_select_rtx_section\n-#undef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO romp_encode_section_info\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS romp_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST romp_address_cost\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Return 1 if the insn using CC0 set by INSN does not contain\n-   any unsigned tests applied to the condition codes.\n-\n-   Based on `next_insn_tests_no_inequality' in recog.c.  */\n-\n-int\n-next_insn_tests_no_unsigned (insn)\n-     rtx insn;\n-{\n-  register rtx next = next_cc0_user (insn);\n-\n-  if (next == 0)\n-    {\n-      if (find_reg_note (insn, REG_UNUSED, cc0_rtx))\n-\treturn 1;\n-      else\n-\tabort ();\n-    }\n-\n-  return ((GET_CODE (next) == JUMP_INSN\n-\t   || GET_CODE (next) == INSN\n-\t   || GET_CODE (next) == CALL_INSN)\n-\t  && ! unsigned_comparisons_p (PATTERN (next)));\n-}\n-\n-static int\n-unsigned_comparisons_p (x)\n-     rtx x;\n-{\n-  register const char *fmt;\n-  register int len, i;\n-  register enum rtx_code code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case REG:\n-    case PC:\n-    case CC0:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      return 0;\n-\n-    case LTU:\n-    case GTU:\n-    case LEU:\n-    case GEU:\n-      return (XEXP (x, 0) == cc0_rtx || XEXP (x, 1) == cc0_rtx);\n-    default:\n-      break;\n-    }\n-\n-  len = GET_RTX_LENGTH (code);\n-  fmt = GET_RTX_FORMAT (code);\n-\n-  for (i = 0; i < len; i++)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (unsigned_comparisons_p (XEXP (x, i)))\n-\t    return 1;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (unsigned_comparisons_p (XVECEXP (x, i, j)))\n-\t      return 1;\n-\t}\n-    }\n-\t    \n-  return 0;\n-}\n-\f\n-/* Update the condition code from the insn.  Look mostly at the first\n-   byte of the machine-specific insn description information.\n-\n-   cc_state.value[12] refer to two possible values that might correspond\n-   to the CC.  We only store register values.  */\n-\n-void\n-update_cc (body, insn)\n-    rtx body ATTRIBUTE_UNUSED;\n-    rtx insn;\n-{\n-  switch (get_attr_cc (insn))\n-    {\n-    case CC_NONE:\n-      /* Insn does not affect the CC at all.  */\n-      break;\n-\n-    case CC_CHANGE0:\n-      /* Insn doesn't affect the CC but does modify operand[0], known to be\n-\t a register.  */\n-      if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n-\tcc_status.value1 = 0;\n-\n-      if (cc_status.value2 != 0\n-\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value2))\n-\tcc_status.value2 = 0;\n-\n-      break;\n-\n-    case CC_COPY1TO0:\n-      /* Insn copies operand[1] to operand[0], both registers, but doesn't\n-         affect the CC.  */\n-      if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n-\tcc_status.value1 = 0;\n-\n-      if (cc_status.value2 != 0\n-\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value2))\n-\tcc_status.value2 = 0;\n-\n-      if (cc_status.value1 != 0\n-\t  && rtx_equal_p (cc_status.value1, recog_data.operand[1]))\n-\tcc_status.value2 = recog_data.operand[0];\n-\n-      if (cc_status.value2 != 0\n-\t  && rtx_equal_p (cc_status.value2, recog_data.operand[1]))\n-\tcc_status.value1 = recog_data.operand[0];\n-\n-      break;\n-\n-    case CC_CLOBBER:\n-      /* Insn clobbers CC.  */\n-      CC_STATUS_INIT;\n-      break;\n-\n-    case CC_SETS:\n-      /* Insn sets CC to recog_data.operand[0], but overflow is impossible.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_NO_OVERFLOW;\n-      cc_status.value1 = recog_data.operand[0];\n-      break;\n-\n-   case CC_COMPARE:\n-      /* Insn is a compare which sets the CC fully.  Update CC_STATUS for this\n-\t compare and mark whether the test will be signed or unsigned.  */\n-      {\n-\tregister rtx p = PATTERN (insn);\n-\n-\tCC_STATUS_INIT;\n-\n-\tif (GET_CODE (p) == PARALLEL)\n-\t  p = XVECEXP (p, 0, 0);\n-\tcc_status.value1 = SET_SRC (p);\n-\n-\tif (GET_CODE (SET_SRC (p)) == REG)\n-\t  cc_status.flags |= CC_NO_OVERFLOW;\n-\tif (! next_insn_tests_no_unsigned (insn))\n-\t  cc_status.flags |= CC_UNSIGNED;\n-      }\n-      break;\n-\n-    case CC_TBIT:\n-      /* Insn sets T bit if result is nonzero.  Next insn must be branch.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags = CC_IN_TB | CC_NOT_NEGATIVE;\n-      break;\n-\n-    default:\n-      abort ();\n-   }\n-}\n-\n-/* Return 1 if a previous compare needs to be re-issued.  This will happen\n-   if two compares tested the same objects, but one was signed and the\n-   other unsigned.  OP is the comparison operation being performed.  */\n-\n-int\n-restore_compare_p (op)\n-     rtx op;\n-{\n-  enum rtx_code code = GET_CODE (op);\n-\n-  return (((code == GEU || code == LEU || code == GTU || code == LTU)\n-\t   && ! (cc_status.flags & CC_UNSIGNED))\n-\t  || ((code == GE || code == LE || code == GT || code == LT)\n-\t      && (cc_status.flags & CC_UNSIGNED)));\n-}\n-\f\n-/*  Generate the (long) string corresponding to an inline multiply insn.\n-    Note that `r10' does not refer to the register r10, but rather to the\n-    SCR used as the MQ.  */\n-const char *\n-output_in_line_mul ()\n-{\n-  static char insns[200];\n-  int i;\n-\n-  strcpy (insns, \"s %0,%0\\n\");\n-  strcat (insns, \"\\tmts r10,%1\\n\");\n-  for (i = 0; i < 16; i++)\n-    strcat (insns, \"\\tm %0,%2\\n\");\n-  strcat (insns, \"\\tmfs r10,%0\");\n-\n-  return insns;\n-}\n-\f\n-/* Returns 1 if OP is a memory reference with an offset from a register within\n-   the range specified.  The offset must also be a multiple of the size of the\n-   mode.  */\n-\n-static int\n-memory_offset_in_range_p (op, mode, low, high)\n-     register rtx op;\n-     enum machine_mode mode;\n-     int low, high;\n-{\n-  int offset = 0;\n-\n-  if (! memory_operand (op, mode))\n-    return 0;\n-\n-  while (GET_CODE (op) == SUBREG)\n-    {\n-      offset += SUBREG_BYTE (op);\n-      op = SUBREG_REG (op);\n-    }\n-\n-  /* We must now have either (mem (reg (x)), (mem (plus (reg (x)) (c))),\n-     or a constant pool address.  */\n-  if (GET_CODE (op) != MEM)\n-    abort ();\n-\n-  /* Now use the actual mode and get the address.  */\n-  mode = GET_MODE (op);\n-  op = XEXP (op, 0);\n-  if (GET_CODE (op) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (op))\n-    offset = get_pool_offset (op) + 12;\n-  else if (GET_CODE (op) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n-\t  || ! register_operand (XEXP (op, 0), Pmode))\n-\treturn 0;\n-\n-      offset += INTVAL (XEXP (op, 1));\n-    }\n-\n-  else if (! register_operand (op, Pmode))\n-    return 0;\n-\n-  return (offset >= low && offset <= high\n-\t  && (offset % GET_MODE_SIZE (mode) == 0));\n-}\n-\n-/* Return 1 if OP is a valid operand for a memory reference insn that can\n-   only reference indirect through a register.   */\n-\n-int\n-zero_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return memory_offset_in_range_p (op, mode, 0, 0);\n-}\n-\n-/* Return 1 if OP is a valid operand for a `short' memory reference insn.  */\n-\n-int\n-short_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  return memory_offset_in_range_p (op, mode, 0,\n-\t\t\t\t   15 * min (UNITS_PER_WORD,\n-\t\t\t\t\t     GET_MODE_SIZE (mode)));\n-}\n-\n-/* Returns 1 if OP is a memory reference involving a symbolic constant\n-   that is not in the constant pool.  */\n-\n-int\n-symbolic_memory_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  if (! memory_operand (op, mode))\n-    return 0;\n-\n-  while (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) != MEM)\n-    abort ();\n-\n-  op = XEXP (op, 0);\n-  if (constant_pool_address_operand (op, VOIDmode))\n-    return 0;\n-  else\n-    return romp_symbolic_operand (op, Pmode)\n-      || (GET_CODE (op) == PLUS && register_operand (XEXP (op, 0), Pmode)\n-\t  && romp_symbolic_operand (XEXP (op, 1), Pmode));\n-}\n-\n-\n-/* Returns 1 if OP is a constant pool reference to the current function.  */\n-\n-int\n-current_function_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if (GET_CODE (op) != MEM || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n-      ||  ! CONSTANT_POOL_ADDRESS_P (XEXP (op, 0)))\n-    return 0;\n-\n-  op = get_pool_constant (XEXP (op, 0));\n-  return (GET_CODE (op) == SYMBOL_REF\n-\t  && ! strcmp (current_function_name, XSTR (op, 0)));\n-}\n-\n-/* Return nonzero if this function is known to have a null epilogue.  */\n-\n-int\n-null_epilogue ()\n-{\n-  return (reload_completed\n-\t  && first_reg_to_save () == 16\n-\t  && ! romp_pushes_stack ());\n-}\n-\f\n-/* Returns 1 if OP is the address of a location in the constant pool.  */\n-\n-int\n-constant_pool_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return ((GET_CODE (op) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (op))\n-\t  || (GET_CODE (op) == CONST && GET_CODE (XEXP (op, 0)) == PLUS\n-\t      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-\t      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-\t      && CONSTANT_POOL_ADDRESS_P (XEXP (XEXP (op, 0), 0))));\n-}\n-\n-/* Returns 1 if OP is either a symbol reference or a sum of a symbol\n-   reference and a constant.  */\n-\n-int\n-romp_symbolic_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return ! op->integrated;\n-\n-    case CONST:\n-      op = XEXP (op, 0);\n-      return (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t      || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-\t     && GET_CODE (XEXP (op, 1)) == CONST_INT;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Returns 1 if OP is a valid constant for the ROMP.  */\n-\n-int\n-constant_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case PLUS:\n-    case CONST:\n-      return romp_symbolic_operand (op,mode);\n-\n-    case CONST_INT:\n-      return (unsigned int) (INTVAL (op) + 0x8000) < 0x10000\n-\t     || (INTVAL (op) & 0xffff) == 0 || (INTVAL (op) & 0xffff0000) == 0;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Returns 1 if OP is either a constant integer valid for the ROMP or a\n-   register.  If a register, it must be in the proper mode unless MODE is\n-   VOIDmode.  */\n-\n-int\n-reg_or_cint_operand (op, mode)\n-      register rtx op;\n-      enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return constant_operand (op, mode);\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return 1 is the operand is either a register or ANY constant integer.  */\n-\n-int\n-reg_or_any_cint_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-     return GET_CODE (op) == CONST_INT || register_operand (op, mode);\n-}\n-\n-/* Return 1 if the operand is either a register or a valid D-type operand.  */\n-\n-int\n-reg_or_D_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return (unsigned) (INTVAL (op) + 0x8000) < 0x10000;\n-\n-  return register_operand (op, mode);\n-}\n-\n-/* Return 1 if the operand is either a register or an item that can be\n-   used as the operand of an SI add insn.  */\n-\n-int\n-reg_or_add_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  return reg_or_D_operand (op, mode) || romp_symbolic_operand (op, mode)\n-\t || (GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff) == 0);\n-}\n-\n-/* Return 1 if the operand is either a register or an item that can be\n-   used as the operand of a ROMP logical AND insn.  */\n-\n-int\n-reg_or_and_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  if (reg_or_cint_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  return (INTVAL (op) & 0xffff) == 0xffff\n-\t || (INTVAL (op) & 0xffff0000) == 0xffff0000;\n-}\n-\n-/* Return 1 if the operand is a register or memory operand.  */\n-\n-int\n-reg_or_mem_operand (op, mode)\n-     register rtx op;\n-     register enum machine_mode mode;\n-{\n-  return register_operand (op, mode) || memory_operand (op, mode);\n-}\n-\n-/* Return 1 if the operand is either a register or a memory operand that is\n-   not symbolic.  */\n-\n-int\n-reg_or_nonsymb_mem_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (memory_operand (op, mode) && ! symbolic_memory_operand (op, mode))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return 1 if this operand is valid for the ROMP.  This is any operand except\n-   certain constant integers.  */\n-\n-int\n-romp_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return constant_operand (op, mode);\n-\n-  return general_operand (op, mode);\n-}\n-\n-/* Return 1 if the operand is (reg:mode 0).  */\n-\n-int\n-reg_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && GET_CODE (op) == REG && REGNO (op) == 0);\n-}\n-\n-/* Return 1 if the operand is (reg:mode 15).  */\n-\n-int\n-reg_15_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return ((mode == VOIDmode || mode == GET_MODE (op))\n-\t  && GET_CODE (op) == REG && REGNO (op) == 15);\n-}\n-\f\n-/* Return 1 if this is a binary floating-point operation.  */\n-\n-int\n-float_binary (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_MODE (op) != SFmode && GET_MODE (op) != DFmode)\n-    return 0;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case PLUS:\n-    case MINUS:\n-    case MULT:\n-    case DIV:\n-      return GET_MODE (XEXP (op, 0)) == GET_MODE (op)\n-\t     && GET_MODE (XEXP (op, 1)) == GET_MODE (op);\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Return 1 if this is a unary floating-point operation.  */\n-\n-int\n-float_unary (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  if (GET_MODE (op) != SFmode && GET_MODE (op) != DFmode)\n-    return 0;\n-\n-  return (GET_CODE (op) == NEG || GET_CODE (op) == ABS)\n-\t && GET_MODE (XEXP (op, 0)) == GET_MODE (op);\n-}\n-\n-/* Return 1 if this is a valid floating-point conversion that can be done\n-   as part of an operation by the RT floating-point routines.  */\n-\n-int\n-float_conversion (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  switch (GET_CODE (op))\n-    {\n-    case FLOAT_TRUNCATE:\n-      return GET_MODE (op) == SFmode && GET_MODE (XEXP (op, 0)) == DFmode;\n-\n-    case FLOAT_EXTEND:\n-      return GET_MODE (op) == DFmode && GET_MODE (XEXP (op, 0)) == SFmode;\n-\n-    case FLOAT:\n-      return ((GET_MODE (XEXP (op, 0)) == SImode\n-\t       || GET_CODE (XEXP (op, 0)) == CONST_INT)\n-\t      && (GET_MODE (op) == SFmode || GET_MODE (op) == DFmode));\n-\n-    case FIX:\n-      return ((GET_MODE (op) == SImode\n-\t       || GET_CODE (XEXP (op, 0)) == CONST_INT)\n-\t      && (GET_MODE (XEXP (op, 0)) == SFmode\n-\t\t  || GET_MODE (XEXP (op, 0)) == DFmode));\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\f\n-/* Print an operand.  Recognize special options, documented below.  */\n-\n-void\n-print_operand (file, x, code)\n-    FILE *file;\n-    rtx x;\n-    int code;\n-{\n-  int i;\n-\n-  switch (code)\n-    {\n-    case 'B':\n-      /* Byte number (const/8) */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%B value\");\n-\n-      fprintf (file, \"%d\", INTVAL (x) / 8);\n-      break;\n-\n-    case 'L':\n-      /* Low order 16 bits of constant.  */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%L value\");\n-\n-      fprintf (file, \"%d\", INTVAL (x) & 0xffff);\n-      break;\n-\n-    case 's':\n-      /* Null or \"16\" depending on whether the constant is greater than 16.  */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%s value\");\n-\n-      if (INTVAL (x) >= 16)\n-\tfprintf (file, \"16\");\n-\n-      break;\n-\n-    case 'S':\n-      /* For shifts: 's' will have given the half.  Just give the amount\n-\t within 16.  */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%S value\");\n-\n-      fprintf (file, \"%d\", INTVAL (x) & 15);\n-      break;\n-\n-    case 'b':\n-      /* The number of a single bit set or cleared, mod 16.  Note that the ROMP\n-\t numbers bits with the high-order bit 31.  */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%b value\");\n-\n-      if ((i = exact_log2 (INTVAL (x))) >= 0)\n-\tfprintf (file, \"%d\", (31 - i) % 16);\n-      else if ((i = exact_log2 (~ INTVAL (x))) >= 0)\n-\tfprintf (file, \"%d\", (31 - i) % 16);\n-      else\n-\toutput_operand_lossage (\"invalid %%b value\");\n-\n-      break;\n-\n-    case 'h':\n-      /* \"l\" or \"u\" depending on which half of the constant is zero.  */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%h value\");\n-\n-      if ((INTVAL (x) & 0xffff0000) == 0)\n-\tfprintf (file, \"l\");\n-      else if ((INTVAL (x) & 0xffff) == 0)\n-\tfprintf (file, \"u\");\n-      else\n-\toutput_operand_lossage (\"invalid %%h value\");\n-\n-      break;\n-\n-    case 'H':\n-      /* Upper or lower half, depending on which half is zero.  */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%H value\");\n-\n-      if ((INTVAL (x) & 0xffff0000) == 0)\n-\tfprintf (file, \"%d\", INTVAL (x) & 0xffff);\n-      else if ((INTVAL (x) & 0xffff) == 0)\n-\tfprintf (file, \"%d\", (INTVAL (x) >> 16) & 0xffff);\n-      else\n-\toutput_operand_lossage (\"invalid %%H value\");\n-\n-      break;\n-\n-    case 'z':\n-      /* Write two characters:\n-\t\t'lo'\tif the high order part is all ones\n-\t\t'lz'\tif the high order part is all zeros\n-\t\t'uo'\tif the low order part is all ones\n-\t\t'uz'\tif the low order part is all zeros \n-       */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%z value\");\n-\n-      if ((INTVAL (x) & 0xffff0000) == 0)\n-\tfprintf (file, \"lz\");\n-      else if ((INTVAL (x) & 0xffff0000) == 0xffff0000)\n-\tfprintf (file, \"lo\");\n-      else if ((INTVAL (x) & 0xffff) == 0)\n-\tfprintf (file, \"uz\");\n-      else if ((INTVAL (x) & 0xffff) == 0xffff)\n-\tfprintf (file, \"uo\");\n-      else\n-\toutput_operand_lossage (\"invalid %%z value\");\n-\n-      break;\n-\n-    case 'Z':\n-      /* Upper or lower half, depending on which is nonzero or not\n-\t all ones.  Must be consistent with 'z' above.  */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%Z value\");\n-\n-      if ((INTVAL (x) & 0xffff0000) == 0\n-\t  || (INTVAL (x) & 0xffff0000) == 0xffff0000)\n-\tfprintf (file, \"%d\", INTVAL (x) & 0xffff);\n-      else if ((INTVAL (x) & 0xffff) == 0 || (INTVAL (x) & 0xffff) == 0xffff)\n-\tfprintf (file, \"%d\", (INTVAL (x) >> 16) & 0xffff);\n-      else\n-\toutput_operand_lossage (\"invalid %%Z value\");\n-\n-      break;\n-\n-    case 'k':\n-      /* Same as 'z', except the trailing 'o' or 'z' is not written.  */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%k value\");\n-\n-      if ((INTVAL (x) & 0xffff0000) == 0\n-\t  || (INTVAL (x) & 0xffff0000) == 0xffff0000)\n-\tfprintf (file, \"l\");\n-      else if ((INTVAL (x) & 0xffff) == 0\n-\t       || (INTVAL (x) & 0xffff) == 0xffff)\n-\tfprintf (file, \"u\");\n-      else\n-\toutput_operand_lossage (\"invalid %%k value\");\n-\n-      break;\n-\n-    case 't':\n-      /* Similar to 's', except that we write 'h' or 'u'.  */\n-      if (GET_CODE (x) != CONST_INT)\n-\toutput_operand_lossage (\"invalid %%k value\");\n-\n-      if (INTVAL (x) < 16)\n-\tfprintf (file, \"u\");\n-      else\n-\tfprintf (file, \"l\");\n-      break;\n-\n-    case 'M':\n-      /* For memory operations, write 's' if the operand is a short\n-\t memory operand.  */\n-      if (short_memory_operand (x, VOIDmode))\n-\tfprintf (file, \"s\");\n-      break;\n-\n-    case 'N':\n-      /* Like 'M', but check for zero memory offset.  */\n-      if (zero_memory_operand (x, VOIDmode))\n-\tfprintf (file, \"s\");\n-      break;\n-\n-    case 'O':\n-      /* Write low-order part of DImode or DFmode.  Supported for MEM\n-\t and REG only.  */\n-      if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n-      else if (GET_CODE (x) == MEM)\n-\tprint_operand (file, gen_rtx_MEM (GET_MODE (x),\n-\t\t\t\t\t  plus_constant (XEXP (x, 0), 4)), 0);\n-      else\n-\tabort ();\n-      break;\n-\n-    case 'C':\n-      /* Offset in constant pool for constant pool address.  */\n-      if (! constant_pool_address_operand (x, VOIDmode))\n-\tabort ();\n-      if (GET_CODE (x) == SYMBOL_REF)\n-\tfprintf (file, \"%d\", get_pool_offset (x) + 12);\n-      else \n-\t/* Must be (const (plus (symbol_ref) (const_int))) */\n-\tfprintf (file, \"%d\",\n-\t\t (get_pool_offset (XEXP (XEXP (x, 0), 0)) + 12\n-\t\t  + INTVAL (XEXP (XEXP (x, 0), 1))));\n-      break;\n-\n-    case 'j':\n-      /* Branch opcode.  Check for condition in test bit for eq/ne.  */\n-      switch (GET_CODE (x))\n-\t{\n-\tcase EQ:\n-\t  if (cc_status.flags & CC_IN_TB)\n-\t    fprintf (file, \"ntb\");\n-\t  else\n-\t    fprintf (file, \"eq\");\n-\t  break;\n-\n-\tcase NE:\n-\t  if (cc_status.flags & CC_IN_TB)\n-\t    fprintf (file, \"tb\");\n-\t  else\n-\t    fprintf (file, \"ne\");\n-\t  break;\n-\n-\tcase GT:\n-\tcase GTU:\n-\t  fprintf (file, \"h\");\n-\t  break;\n-\n-\tcase LT:\n-\tcase LTU:\n-\t  fprintf (file, \"l\");\n-\t  break;\n-\n-\tcase GE:\n-\tcase GEU:\n-\t  fprintf (file, \"he\");\n-\t  break;\n-\n-\tcase LE:\n-\tcase LEU:\n-\t  fprintf (file, \"le\");\n-\t  break;\n-\n-\tdefault:\n-\t  output_operand_lossage (\"invalid %%j value\");\n-\t}\n-      break;\n-\n-    case 'J':\n-      /* Reversed branch opcode.  */\n-      switch (GET_CODE (x))\n-\t{\n-\tcase EQ:\n-\t  if (cc_status.flags & CC_IN_TB)\n-\t    fprintf (file, \"tb\");\n-\t  else\n-\t    fprintf (file, \"ne\");\n-\t  break;\n-\n-\tcase NE:\n-\t  if (cc_status.flags & CC_IN_TB)\n-\t    fprintf (file, \"ntb\");\n-\t  else\n-\t    fprintf (file, \"eq\");\n-\t  break;\n-\n-\tcase GT:\n-\tcase GTU:\n-\t  fprintf (file, \"le\");\n-\t  break;\n-\n-\tcase LT:\n-\tcase LTU:\n-\t  fprintf (file, \"he\");\n-\t  break;\n-\n-\tcase GE:\n-\tcase GEU:\n-\t  fprintf (file, \"l\");\n-\t  break;\n-\n-\tcase LE:\n-\tcase LEU:\n-\t  fprintf (file, \"h\");\n-\t  break;\n-\n-\tdefault:\n-\t  output_operand_lossage (\"invalid %%j value\");\n-\t}\n-      break;\n-\n-    case '.':\n-      /* Output nothing.  Used as delimiter in, e.g., \"mc%B1%.3 \" */\n-      break;\n-\n-    case '#':\n-      /* Output 'x' if this insn has a delay slot, else nothing.  */\n-      if (dbr_sequence_length ())\n-\tfprintf (file, \"x\");\n-      break;\n-\n-    case 0:\n-      if (GET_CODE (x) == REG)\n-\tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n-      else if (GET_CODE (x) == MEM)\n-\t{\n-\t  if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n-\t      && current_function_operand (x, Pmode))\n-\t    fprintf (file, \"r14\");\n-\t  else\n-\t    output_address (XEXP (x, 0));\n-\t}\n-      else\n-\toutput_addr_const (file, x);\n-      break;\n-\n-    default:\n-      output_operand_lossage (\"invalid %%xn code\");\n-    }\n-}\n-\f\n-/* This page contains routines that are used to determine what the function\n-   prologue and epilogue code will do and write them out.  */\n-\n-/*  Return the first register that is required to be saved. 16 if none.  */\n-\n-int\n-first_reg_to_save()\n-{\n-  int first_reg;\n-\n-  /* Find lowest numbered live register.  */\n-  for (first_reg = 6; first_reg <= 15; first_reg++)\n-    if (regs_ever_live[first_reg])\n-      break;\n-\n-  /* If we think that we do not have to save r14, see if it will be used\n-     to be sure.  */\n-  if (first_reg > 14 && romp_using_r14 ())\n-    first_reg = 14;\n-\n-  return first_reg;\n-}\n-\n-/* Compute the size of the save area in the stack, including the space for\n-   the first four incoming arguments.  */\n-\n-int\n-romp_sa_size ()\n-{\n-  int size;\n-  int i;\n-\n-  /* We have the 4 words corresponding to the arguments passed in registers,\n-     4 reserved words, space for static chain, general register save area,\n-     and floating-point save area.  */\n-  size = 4 + 4 + 1 + (16 - first_reg_to_save ());\n-\n-  /* The documentation says we have to leave 18 words in the save area if\n-     any floating-point registers at all are saved, not the three words\n-     per register you might otherwise expect.  */\n-  for (i = 2 + (TARGET_FP_REGS != 0); i <= 7; i++)\n-    if (regs_ever_live[i + 17])\n-      {\n-\tsize += 18;\n-\tbreak;\n-      }\n-\n-  return size * 4;\n-}\n-\n-/* Return nonzero if this function makes calls or has fp operations\n-   (which are really calls).  */\n-\n-int\n-romp_makes_calls ()\n-{\n-  rtx insn;\n-\n-  for (insn = get_insns (); insn; insn = next_insn (insn))\n-    {\n-      if (GET_CODE (insn) == CALL_INSN)\n-\treturn 1;\n-      else if (GET_CODE (insn) == INSN)\n-\t{\n-\t  rtx body = PATTERN (insn);\n-\n-\t  if (GET_CODE (body) != USE && GET_CODE (body) != CLOBBER\n-\t      && GET_CODE (body) != ADDR_VEC\n-\t      && GET_CODE (body) != ADDR_DIFF_VEC\n-\t      && get_attr_type (insn) == TYPE_FP)\n-\t    return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return nonzero if this function will use r14 as a pointer to its\n-   constant pool.  */\n-\n-int\n-romp_using_r14 ()\n-{\n-  /* If we are debugging, profiling, have a non-empty constant pool, or\n-     call a function, we need r14.  */\n-  return (write_symbols != NO_DEBUG || current_function_profile\n-\t  || get_pool_size () != 0 || romp_makes_calls ());\n-}\n-\n-/* Return nonzero if this function needs to push space on the stack.  */\n-\n-int\n-romp_pushes_stack ()\n-{\n-  /* We need to push the stack if a frame pointer is needed (because the\n-     stack might be dynamically adjusted), if we are debugging, if the\n-     total required size is more than 100 bytes, or if we make calls.  */\n-\n-  return (frame_pointer_needed || write_symbols != NO_DEBUG\n-\t  || (romp_sa_size () + get_frame_size ()) > 100\n-\t  || romp_makes_calls ());\n-}\n-\n-/* Write function prologue.\n-\n-   We compute the size of the fixed area required as follows:\n-\n-   We always allocate 4 words for incoming arguments, 4 word reserved, 1\n-   word for static link, as many words as required for general register\n-   save area, plus 2 words for each FP reg 2-7 that must be saved.  */\n-\n-static void\n-romp_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  int first_reg;\n-  int reg_save_offset;\n-  HOST_WIDE_INT fp_save = size + current_function_outgoing_args_size;\n-\n-  init_fpops ();\n-\n-  /* Add in fixed size plus output argument area.  */\n-  size += romp_sa_size () + current_function_outgoing_args_size;\n-\n-  /* Compute first register to save and perform the save operation if anything\n-     needs to be saved.  */\n-  first_reg = first_reg_to_save();\n-  reg_save_offset = - (4 + 4 + 1 + (16 - first_reg)) * 4;\n-  if (first_reg == 15)\n-    fprintf (file, \"\\tst r15,%d(r1)\\n\", reg_save_offset);\n-  else if (first_reg < 16)\n-    fprintf (file, \"\\tstm r%d,%d(r1)\\n\", first_reg, reg_save_offset);\n-\n-  /* Set up pointer to data area if it is needed.  */\n-  if (romp_using_r14 ())\n-    fprintf (file, \"\\tcas r14,r0,r0\\n\");\n-\n-  /* Set up frame pointer if needed.  */\n-  if (frame_pointer_needed)\n-    fprintf (file, \"\\tcal r13,-%d(r1)\\n\", romp_sa_size () + 64);\n-\n-  /* Push stack if neeeded.  There are a couple of ways of doing this.  */\n-  if (romp_pushes_stack ())\n-    {\n-      if (size >= 32768)\n-\t{\n-\t  if (size >= 65536)\n-\t    {\n-\t      fprintf (file, \"\\tcau r0,%d(r0)\\n\", size >> 16);\n-\t      fprintf (file, \"\\toil r0,r0,%d\\n\", size & 0xffff);\n-\t    }\n-\t  else\n-\t    fprintf (file, \"\\tcal16 r0,%d(r0)\\n\", size);\n-\t  fprintf (file, \"\\ts r1,r0\\n\");\n-\t}\n-      else\n-\tfprintf (file, \"\\tcal r1,-%d(r1)\\n\", size);\n-    }\n-\n-  /* Save floating-point registers.  */\n-  output_loadsave_fpregs (file, USE,\n-\t\t\t  plus_constant (stack_pointer_rtx, fp_save));\n-}\n-\f\n-/* Output the offset information used by debuggers.\n-   This is the exactly the total_size value of output_function_epilogue()\n-   which is added to the frame pointer. However the value in the debug\n-   table is encoded in a space-saving way as follows:\n-\n-   The first byte contains two fields: a 2-bit size field and the first\n-   6 bits of an offset value. The 2-bit size field is in the high-order\n-   position and specifies how many subsequent bytes follow after\n-   this one. An offset value is at most 4-bytes long.\n-\n-   The last 6 bits of the first byte initialize the offset value. In many\n-   cases where procedures have small local storage, this is enough and, in\n-   this case, the high-order size field is zero so the byte can (almost) be\n-   used as is (see below). Thus, the byte value of 0x0d is encodes an offset\n-   size of 13 words, or 52 bytes.\n-\n-   For procedures with a local space larger than 60 bytes, the 6 bits\n-   are the high-order 6 bits.  The remaining bytes follow as necessary,\n-   in Big Endian order.  Thus, the short value of 16907 (= 16384+523)\n-   encodes an offset of 2092 bytes (523 words).\n-\n-   The total offset value is in words (not bytes), so the final value has to\n-   be multiplied by 4 before it can be used in address computations by a\n-   debugger.   */\n-\n-void\n-output_encoded_offset (file, reg_offset)\n-     FILE *file;\n-     unsigned reg_offset;\n-{\n-  /* Convert the offset value to 4-byte words rather than bytes.  */\n-  reg_offset = (reg_offset + 3) / 4;\n-\n-  /* Now output 1-4 bytes in encoded form.  */\n-  if (reg_offset < (1 << 6))\n-    /* Fits into one byte */\n-    fprintf (file, \"\\t.byte %d\\n\", reg_offset);\n-  else if (reg_offset < (1 << (6 + 8)))\n-    /* Fits into two bytes */\n-    fprintf (file, \"\\t.short %d\\n\", (1 << (6 + 8)) + reg_offset);\n-  else if (reg_offset < (1 << (6 + 8 + 8)))\n-    {\n-      /* Fits in three bytes */\n-      fprintf (file, \"\\t.byte %d\\n\", (2 << 6) + (reg_offset >> ( 6+ 8)));\n-      fprintf (file, \"\\t.short %d\\n\", reg_offset % (1 << (6 + 8)));\n-    }\n-  else\n-    {\n-      /* Use 4 bytes.  */\n-      fprintf (file, \"\\t.short %d\", (3 << (6 + 8)) + (reg_offset >> (6 + 8)));\n-      fprintf (file, \"\\t.short %d\\n\", reg_offset % (1 << (6 + 8)));\n-    }\n-}\n-\f\n-/* Write function epilogue.  */\n-\n-static void\n-romp_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  int first_reg = first_reg_to_save();\n-  int pushes_stack = romp_pushes_stack ();\n-  int reg_save_offset = - ((16 - first_reg) + 1 + 4 + 4) * 4;\n-  HOST_WIDE_INT total_size = (size + romp_sa_size ()\n-\t\t\t      + current_function_outgoing_args_size);\n-  HOST_WIDE_INT fp_save = size + current_function_outgoing_args_size;\n-  int long_frame = total_size >= 32768;\n-  rtx insn = get_last_insn ();\n-  int write_code = 1;\n-\n-  int nargs = 0;\t\t/* words of arguments */\n-  tree argptr;\n-\n-  /* Compute the number of words of arguments.  Since this is just for\n-     the traceback table, we ignore arguments that don't have a size or\n-     don't have a fixed size.  */\n-\n-  for (argptr = DECL_ARGUMENTS (current_function_decl);\n-       argptr; argptr = TREE_CHAIN (argptr))\n-    {\n-      int this_size = int_size_in_bytes (TREE_TYPE (argptr));\n-\n-      if (this_size > 0)\n-\tnargs += (this_size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-    }\n-  \n-  /* If the last insn was a BARRIER, we don't have to write anything except\n-     the trace table.  */\n-  if (GET_CODE (insn) == NOTE)\n-    insn = prev_nonnote_insn (insn);\n-  if (insn && GET_CODE (insn) == BARRIER)\n-    write_code = 0;\n-\n-  /* Restore floating-point registers.  */\n-  if (write_code)\n-    output_loadsave_fpregs (file, CLOBBER,\n-\t\t\t    plus_constant (gen_rtx_REG (Pmode, 1), fp_save));\n-\n-  /* If we push the stack and do not have size > 32K, adjust the register\n-     save location to the current position of sp.  Otherwise, if long frame,\n-     restore sp from fp.  */\n-  if (pushes_stack && ! long_frame)\n-    reg_save_offset += total_size;\n-  else if (long_frame && write_code)\n-    fprintf (file, \"\\tcal r1,%d(r13)\\n\", romp_sa_size () + 64);\n-\n-  /* Restore registers.  */\n-  if (first_reg == 15 && write_code)\n-    fprintf (file, \"\\tl r15,%d(r1)\\n\", reg_save_offset);\n-  else if (first_reg < 16 && write_code)\n-    fprintf (file, \"\\tlm r%d,%d(r1)\\n\", first_reg, reg_save_offset);\n-  if (first_reg == 16) first_reg = 0;\n-\n-  /* Handle popping stack, if needed and write debug table entry.  */\n-  if (pushes_stack)\n-    {\n-      if (write_code)\n-\t{\n-\t  if (long_frame)\n-\t    fprintf (file, \"\\tbr r15\\n\");\n-\t  else\n-\t    fprintf (file, \"\\tbrx r15\\n\\tcal r1,%d(r1)\\n\", total_size);\n-\t}\n-\n-      /* Table header (0xdf), usual-type stack frame (0x07),\n-\t table header (0xdf), and first register saved.\n-\n-\t The final 0x08 means that there is a byte following this one\n-\t describing the number of parameter words and the register used as\n-\t stack pointer.\n-\n-\t If GCC passed floating-point parameters in floating-point registers,\n-\t it would be necessary to change the final byte from 0x08 to 0x0c.\n-\t Also an additional entry byte would be need to be emitted to specify\n-\t the first floating-point register.\n-\n-\t (See also Section 11 (Trace Tables) in ``IBM/4.3 Linkage Convention,''\n-\t pages IBM/4.3-PSD:5-7 of Volume III of the IBM Academic Operating\n-\t System Manual dated July 1987.)  */\n-\n-      fprintf (file, \"\\t.long 0x%x\\n\", 0xdf07df08 + first_reg * 0x10);\n-\n-      if (nargs > 15) nargs = 15;\n-\n-      /* The number of parameter words and the register used as the stack\n-\t pointer (encoded here as r1).\n-\n-\t Note: The MetWare Hich C Compiler R2.1y actually gets this wrong;\n-\t it erroneously lists r13 but uses r1 as the stack too. But a bug in\n-\t dbx 1.5 nullifies this mistake---most of the time.\n-         (Dbx retrieves the value of r13 saved on the stack which is often\n-\t the value of r1 before the call.)  */\n-\n-      fprintf (file, \"\\t.byte 0x%x1\\n\", nargs);\n-      output_encoded_offset (file, total_size);\n-    }\n-  else\n-    {\n-      if (write_code)\n-\tfprintf (file, \"\\tbr r15\\n\");\n-\n-      /* Table header (0xdf), no stack frame (0x02),\n-\t table header (0xdf) and no parameters saved (0x00).\n-\n-\t If GCC passed floating-point parameters in floating-point registers,\n-\t it might be necessary to change the final byte from 0x00 to 0x04.\n-\t Also a byte would be needed to specify the first floating-point\n-\t register.  */\n-      fprintf (file, \"\\t.long 0xdf02df00\\n\");\n-    }\n-\n-  /* Output any pending floating-point operations.  */\n-  output_fpops (file);\n-}\n-\f\n-/* For the ROMP we need to make new SYMBOL_REFs for the actual name of a\n-   called routine.  To keep them unique we maintain a hash table of all\n-   that have been created so far.  */\n-\n-struct symref_hashent {\n-  rtx symref;\t\t\t/* Created SYMBOL_REF rtx.  */\n-  struct symref_hashent *next;\t/* Next with same hash code.  */\n-};\n-\n-#define SYMHASHSIZE 151\n-#define HASHBITS 65535\n-\n-/* Define the hash table itself.  */\n-\n-static struct symref_hashent *symref_hash_table[SYMHASHSIZE];\n-\n-/* Given a name (allocable in temporary storage), return a SYMBOL_REF\n-   for the name.  The rtx is allocated from the current rtl_obstack, while\n-   the name string is allocated from the permanent obstack.  */\n-rtx\n-get_symref (name)\n-     register const char *name;\n-{\n-  register const char *sp = name;\n-  unsigned int hash = 0;\n-  struct symref_hashent *p, **last_p;\n-\n-  /* Compute the hash code for the string.  */\n-  while (*sp)\n-    hash = (hash << 4) + *sp++;\n-\n-  /* Search for a matching entry in the hash table, keeping track of the\n-     insertion location as we do so.  */\n-  hash = (hash & HASHBITS) % SYMHASHSIZE;\n-  for (last_p = &symref_hash_table[hash], p = *last_p;\n-       p; last_p = &p->next, p = *last_p)\n-    if (strcmp (name, XSTR (p->symref, 0)) == 0)\n-      break;\n-\n-  /* If couldn't find matching SYMBOL_REF, make a new one.  */\n-  if (p == 0)\n-    {\n-      /* Ensure SYMBOL_REF will stay around.  */\n-      p = *last_p = (struct symref_hashent *)\n-\t\t\txmalloc (sizeof (struct symref_hashent));\n-      p->symref = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n-      p->next = 0;\n-    }\n-\n-  return p->symref;\n-}\n-\f\n-/* Validate the precision of a floating-point operation.\n-\n-   We merge conversions from integers and between floating-point modes into\n-   the insn.  However, this must not effect the desired precision of the\n-   insn.  The RT floating-point system uses the widest of the operand modes.\n-   If this should be a double-precision insn, ensure that one operand\n-   passed to the floating-point processor has double mode.\n-\n-   Note that since we don't check anything if the mode is single precision,\n-   it, strictly speaking, isn't necessary to call this for those insns.\n-   However, we do so in case something else needs to be checked in the\n-   future.\n-\n-   This routine returns 1 if the operation is OK.  */\n-\n-int\n-check_precision (opmode, op1, op2)\n-     enum machine_mode opmode;\n-     rtx op1, op2;\n-{\n-  if (opmode == SFmode)\n-    return 1;\n-\n-  /* If operand is not a conversion from an integer mode or an extension from\n-     single-precision, it must be a double-precision value.  */\n-  if (GET_CODE (op1) != FLOAT && GET_CODE (op1) != FLOAT_EXTEND)\n-    return 1;\n-\n-  if (op2 && GET_CODE (op2) != FLOAT && GET_CODE (op2) != FLOAT_EXTEND)\n-    return 1;\n-\n-  return 0;\n-}\n-\f\n-/* Floating-point on the RT is done by creating an operation block in the data\n-   area that describes the operation.  If two floating-point operations are the\n-   same in a single function, they can use the same block.\n-\n-   These routines are responsible for managing these blocks.  */\n-\n-/* Structure to describe a floating-point operation.  */\n-\n-struct fp_op {\n-  struct fp_op *next_same_hash;\t\t/* Next op with same hash code.  */\n-  struct fp_op *next_in_mem;\t\t/* Next op in memory.  */\n-  int mem_offset;\t\t\t/* Offset from data area.  */\n-  short size;\t\t\t\t/* Size of block in bytes.  */\n-  short noperands;\t\t\t/* Number of operands in block.  */\n-  rtx ops[3];\t\t\t\t/* RTL for operands.  */\n-  enum rtx_code opcode;\t\t\t/* Operation being performed.  */\n-};\n-\n-/* Size of hash table.  */\n-#define FP_HASH_SIZE 101\n-\n-/* Hash table of floating-point operation blocks.  */\n-static struct fp_op *fp_hash_table[FP_HASH_SIZE];\n-\n-/* First floating-point block in data area.  */\n-static struct fp_op *first_fpop;\n-\n-/* Last block in data area so far.  */\n-static struct fp_op *last_fpop_in_mem;\n-\n-/* Subroutine number in file, to get unique \"LF\" labels.  */\n-static int subr_number = 0;\n-\n-/* Current word offset in data area (includes header and any constant pool).  */\n-int data_offset;\n-\n-/* Compute hash code for an RTX used in floating-point.  */\n-\n-static unsigned int\n-hash_rtx (x)\n-     register rtx x;\n-{\n-  register unsigned int hash = (((int) GET_CODE (x) << 10)\n-\t\t\t\t+ ((int) GET_MODE (x) << 20));\n-  register int i;\n-  register const char *fmt = GET_RTX_FORMAT (GET_CODE (x));\n-\n-  for (i = 0; i < GET_RTX_LENGTH (GET_CODE (x)); i++)\n-    if (fmt[i] == 'e')\n-      hash += hash_rtx (XEXP (x, i));\n-    else if (fmt[i] == 'u')\n-      hash += (unsigned HOST_WIDE_INT) XEXP (x, i);\n-    else if (fmt[i] == 'i')\n-      hash += XINT (x, i);\n-    else if (fmt[i] == 's')\n-      hash += (unsigned HOST_WIDE_INT) XSTR (x, i);\n-\n-  return hash;\n-}\n-\f\n-/* Given an operation code and up to three operands, return a character string\n-   corresponding to the code to emit to branch to a floating-point operation\n-   block.  INSN is provided to see if the delay slot has been filled or not.\n-\n-   A new floating-point operation block is created if this operation has not\n-   been seen before.  */\n-\n-const char *\n-output_fpop (code, op0, op1, op2, insn)\n-     enum rtx_code code;\n-     rtx op0, op1, op2;\n-     rtx insn ATTRIBUTE_UNUSED;\n-{\n-  static char outbuf[40];\n-  unsigned int hash, hash0, hash1, hash2;\n-  int size, i;\n-  register struct fp_op *fpop, *last_fpop;\n-  int dyadic = (op2 != 0);\n-  enum machine_mode opmode;\n-  int noperands;\n-  rtx tem;\n-  unsigned int tem_hash;\n-  int fr0_avail = 0;\n-\n-  /* Compute hash code for each operand.  If the operation is commutative,\n-     put the one with the smaller hash code first.  This will make us see\n-     more operations as identical.  */\n-  hash0 = op0 ? hash_rtx (op0) : 0;\n-  hash1 = op1 ? hash_rtx (op1) : 0;\n-  hash2 = op2 ? hash_rtx (op2) : 0;\n-\n-  if (hash0 > hash1 && code == EQ)\n-    {\n-      tem = op0; op0 = op1; op1 = tem;\n-      tem_hash = hash0; hash0 = hash1; hash1 = tem_hash;\n-    }\n-  else if (hash1 > hash2 && (code == PLUS || code == MULT))\n-    {\n-      tem = op1; op1 = op2; op2 = tem;\n-      tem_hash = hash1; hash1 = hash2; hash2 = tem_hash;\n-    }\n-\n-  /* If operation is commutative and the first and third operands are equal,\n-     swap the second and third operands.  Note that we must consider two\n-     operands equal if they are the same register even if different modes.  */\n-  if (op2 && (code == PLUS || code == MULT)\n-      && (rtx_equal_p (op0, op2)\n-\t  || (GET_CODE (op0) == REG && GET_CODE (op2) == REG\n-\t      && REGNO (op0) == REGNO (op2))))\n-    {\n-      tem = op1; op1 = op2; op2 = tem;\n-      tem_hash = hash1; hash1 = hash2; hash2 = tem_hash;\n-    }\n-\n-  /* If the first and second operands are the same, merge them.  Don't do this\n-     for SFmode or SImode in general registers because this triggers a bug in\n-     the RT fp code.  */\n-  if (op1 && rtx_equal_p (op0, op1)\n-      && code != EQ && code != GE && code != SET\n-      && ((GET_MODE (op1) != SFmode && GET_MODE (op1) != SImode)\n-\t  || GET_CODE (op0) != REG || FP_REGNO_P (REGNO (op0))))\n-    {\n-      op1 = op2;\n-      op2 = 0;\n-    }\n-\n-  noperands = 1 + (op1 != 0) + (op2 != 0);\n-\n-  /* Compute hash code for entire expression and see if operation block\n-     already exists.  */\n-  hash = ((int) code << 13) + (hash0 << 2) + (hash1 << 1) + hash2;\n-\n-  hash %= FP_HASH_SIZE;\n-  for (fpop = fp_hash_table[hash], last_fpop = 0;\n-       fpop;\n-       last_fpop = fpop, fpop = fpop->next_same_hash)\n-    if (fpop->opcode == code && noperands == fpop->noperands\n-\t&& (op0 == 0 || rtx_equal_p (op0, fpop->ops[0]))\n-\t&& (op1 == 0 || rtx_equal_p (op1, fpop->ops[1]))\n-\t&& (op2 == 0 || rtx_equal_p (op2, fpop->ops[2])))\n-      goto win;\n-\n-  /* We have never seen this operation before.  */\n-  fpop = (struct fp_op *) xmalloc (sizeof (struct fp_op));\n-  fpop->mem_offset = data_offset;\n-  fpop->opcode = code;\n-  fpop->noperands = noperands;\n-  fpop->ops[0] = op0;\n-  fpop->ops[1] = op1;\n-  fpop->ops[2] = op2;\n-\n-  /* Compute the size using the rules in Appendix A of the RT Linkage\n-     Convention (4.3/RT-PSD:5) manual.  These rules are a bit ambiguous,\n-     but if we guess wrong, it will effect only efficiency, not correctness.  */\n-\n-  /* Size = 24 + 32 for each non-fp (or fr7) */\n-  size = 24;\n-  if (op0 && (GET_CODE (op0) != REG\n-\t      || ! FP_REGNO_P (REGNO (op0)) || REGNO (op0) == 23))\n-    size += 32;\n-\n-  if (op1 && (GET_CODE (op1) != REG\n-\t      || ! FP_REGNO_P (REGNO (op1)) || REGNO (op1) == 23))\n-    size += 32;\n-\n-  if (op2 && (GET_CODE (op2) != REG\n-\t      || ! FP_REGNO_P (REGNO (op2)) || REGNO (op2) == 23))\n-    size += 32;\n-\n-  /* Size + 12 for each conversion.  First get operation mode.  */\n-  if ((op0 && GET_MODE (op0) == DFmode)\n-      || (op1 && GET_MODE (op1) == DFmode)\n-      || (op2 && GET_MODE (op2) == DFmode))\n-    opmode = DFmode;\n-  else\n-    opmode = SFmode;\n-\n-  if (op0 && GET_MODE (op0) != opmode)\n-    size += 12;\n-  if (op1 && GET_MODE (op1) != opmode)\n-    size += 12;\n-  if (op2 && GET_MODE (op2) != opmode)\n-    size += 12;\n-\n-  /* 12 more if first and third operand types not the same.  */\n-  if (op2 && GET_MODE (op0) != GET_MODE (op2))\n-    size += 12;\n-\n-  /* CMP and CMPT need additional.  Also, compute size of save/restore here.  */\n-  if (code == EQ)\n-    size += 32;\n-  else if (code == GE)\n-    size += 64;\n-  else if (code == USE || code == CLOBBER)\n-    {\n-      /* 34 + 24 for each additional register plus 8 if fr7 saved.  (We\n-         call it 36 because we need to keep the block length a multiple\n-\t of four.  */\n-      size = 36 - 24;\n-      for (i = 0; i <= 7; i++)\n-\tif (INTVAL (op0) & (1 << (7-i)))\n-\t  size += 24 + 8 * (i == 7);\n-    }\n-\n-  /* We provide no general-purpose scratch registers.  */\n-  size +=16;\n-\n-  /* No floating-point scratch registers are provided.  Compute extra\n-     length due to this.  This logic is that shown in the referenced\n-     appendix.  */\n-\n-  i = 0;\n-  if (op0 && GET_CODE (op0) == REG && FP_REGNO_P (REGNO (op0)))\n-    i++;\n-  if (op1 && GET_CODE (op1) == REG && FP_REGNO_P (REGNO (op1)))\n-    i++;\n-  if (op2 && GET_CODE (op2) == REG && FP_REGNO_P (REGNO (op2)))\n-    i++;\n-\n-  if ((op0 == 0 || GET_CODE (op0) != REG || REGNO(op0) != 17)\n-      && (op1 == 0 || GET_CODE (op1) != REG || REGNO(op1) != 17)\n-      && (op2 == 0 || GET_CODE (op2) != REG || REGNO(op2) != 17))\n-    fr0_avail = 1;\n-\n-  if (dyadic)\n-    {\n-      if (i == 0)\n-\tsize += fr0_avail ? 64 : 112;\n-      else if (fpop->noperands == 2 && i == 1)\n-\tsize += fr0_avail ? 0 : 64;\n-      else if (fpop->noperands == 3)\n-\t{\n-\t  if (GET_CODE (op0) == REG && FP_REGNO_P (REGNO (op0))\n-\t      && GET_CODE (op2) == REG && FP_REGNO_P (REGNO (op2)))\n-\t    {\n-\t      if (REGNO (op0) == REGNO (op2))\n-#if 1\n-\t\t/* This triggers a bug on the RT.  */\n-\t\tabort ();\n-#else\n-\t\tsize += fr0_avail ? 0 : 64;\n-#endif\n-\t    }\n-\t  else\n-\t    {\n-\t      i = 0;\n-\t      if (GET_CODE (op0) == REG && FP_REGNO_P (REGNO (op0)))\n-\t\ti++;\n-\t      if (GET_CODE (op2) == REG && FP_REGNO_P (REGNO (op2)))\n-\t\ti++;\n-\t      if (i == 0)\n-\t\tsize += fr0_avail ? 64 : 112;\n-\t      else if (i == 1)\n-\t\tsize += fr0_avail ? 0 : 64;\n-\t    }\n-\t}\n-    }\n-  else if (code != USE && code != CLOBBER\n-\t   && (GET_CODE (op0) != REG || ! FP_REGNO_P (REGNO (op0))))\n-    size += 64;\n-    \n-  if (! TARGET_FULL_FP_BLOCKS)\n-    {\n-      /* If we are not to pad the blocks, just compute its actual length.  */\n-      size = 12;\t/* Header + opcode */\n-      if (code == USE || code == CLOBBER)\n-        size += 2;\n-      else\n-        {\n-\t  if (op0) size += 2;\n-\t  if (op1) size += 2;\n-\t  if (op2) size += 2;\n-\t}\n-\n-      /* If in the middle of a word, round.  */\n-      if (size % UNITS_PER_WORD)\n-\tsize += 2;\n-\t\n-      /* Handle any immediates.  */\n-      if (code != USE && code != CLOBBER && op0 && GET_CODE (op0) != REG)\n-        size += 4;\n-      if (op1 && GET_CODE (op1) != REG)\n-        size += 4;\n-      if (op2 && GET_CODE (op2) != REG)\n-        size += 4;\n-\n-      if (code != USE && code != CLOBBER && \n-\t  op0 && GET_CODE (op0) == CONST_DOUBLE && GET_MODE (op0) == DFmode)\n-        size += 4;\n-      if (op1 && GET_CODE (op1) == CONST_DOUBLE && GET_MODE (op1) == DFmode)\n-        size += 4;\n-      if (op2 && GET_CODE (op2) == CONST_DOUBLE && GET_MODE (op2) == DFmode)\n-        size += 4;\n-    }\n-\n-  /* Done with size computation!  Chain this in.  */\n-  fpop->size = size;\n-  data_offset += size / UNITS_PER_WORD;\n-  fpop->next_in_mem = 0;\n-  fpop->next_same_hash = 0;\n-\n-  if (last_fpop_in_mem)\n-    last_fpop_in_mem->next_in_mem = fpop;\n-  else\n-    first_fpop = fpop;\n-  last_fpop_in_mem = fpop;\n-\n-  if (last_fpop)\n-    last_fpop->next_same_hash = fpop;\n-  else\n-    fp_hash_table[hash] = fpop;\n-\n-win:\n-  /* FPOP describes the operation to be performed.  Return a string to branch\n-     to it.  */\n-  if (fpop->mem_offset < 32768 / UNITS_PER_WORD)\n-    sprintf (outbuf, \"cal r15,%d(r14)\\n\\tbalr%s r15,r15\",\n-\t     fpop->mem_offset * UNITS_PER_WORD,\n-\t     dbr_sequence_length () ? \"x\" : \"\");\n-  else\n-    sprintf (outbuf, \"get r15,$L%dF%d\\n\\tbalr%s r15,r15\",\n-\t     subr_number, fpop->mem_offset * UNITS_PER_WORD,\n-\t     dbr_sequence_length () ? \"x\" : \"\");\n-  return outbuf;\n-}\n-\f\n-/* If necessary, output a floating-point operation to save or restore all\n-   floating-point registers.\n-\n-   file is the file to write the operation to, CODE is USE for save, CLOBBER\n-   for restore, and ADDR is the address of the same area, as RTL.  */\n-\n-static void\n-output_loadsave_fpregs (file, code, addr)\n-     FILE *file;\n-     enum rtx_code code;\n-     rtx addr;\n-{\n-  register int i;\n-  register int mask = 0;\n-\n-  for (i = 2 + (TARGET_FP_REGS != 0); i <= 7; i++)\n-    if (regs_ever_live[i + 17])\n-      mask |= 1 << (7 - i);\n-\n-  if (mask)\n-    fprintf (file, \"\\t%s\\n\",\n-\t     output_fpop (code, GEN_INT (mask), gen_rtx_MEM (Pmode, addr),\n-\t\t\t\t0, const0_rtx));\n-\n-}\n-\f\n-/* Output any floating-point operations at the end of the routine.  */\n-\n-static void\n-output_fpops (file)\n-     FILE *file;\n-{\n-  register struct fp_op *fpop;\n-  register int size_so_far;\n-  register int i;\n-  rtx immed[3];\n-\n-  if (first_fpop == 0)\n-    return;\n-\n-  data_section ();\n-\n-  ASM_OUTPUT_ALIGN (file, 2);\n-\n-  for (fpop = first_fpop; fpop; fpop = fpop->next_in_mem)\n-    {\n-      if (fpop->mem_offset < 32768 / UNITS_PER_WORD)\n-\tfprintf (file, \"# data area offset = %d\\n\",\n-\t\t fpop->mem_offset * UNITS_PER_WORD);\n-      else\n-\tfprintf (file, \"L%dF%d:\\n\",\n-\t\t subr_number, fpop->mem_offset * UNITS_PER_WORD);\n-\n-      fprintf (file, \"\\tcas r0,r15,r0\\n\");\n-      fprintf (file, \"\\t.long FPGLUE\\n\");\n-      switch (fpop->opcode)\n-\t{\n-\tcase USE:\n-\t  fprintf (file, \"\\t.byte 0x1d\\t# STOREM\\n\");\n-\t  break;\n-\tcase CLOBBER:\n-\t  fprintf (file, \"\\t.byte 0x0f\\t# LOADM\\n\");\n-\t  break;\n-\tcase ABS:\n-\t  fprintf (file, \"\\t.byte 0x00\\t# ABS\\n\");\n-\t  break;\n-\tcase PLUS:\n-\t  fprintf (file, \"\\t.byte 0x02\\t# ADD\\n\");\n-\t  break;\n-\tcase EQ:\n-\t  fprintf (file, \"\\t.byte 0x07\\t# CMP\\n\");\n-\t  break;\n-\tcase GE:\n-\t  fprintf (file, \"\\t.byte 0x08\\t# CMPT\\n\");\n-\t  break;\n-\tcase DIV:\n-\t  fprintf (file, \"\\t.byte 0x0c\\t# DIV\\n\");\n-\t  break;\n-\tcase SET:\n-\t  fprintf (file, \"\\t.byte 0x14\\t# MOVE\\n\");\n-\t  break;\n-\tcase MULT:\n-\t  fprintf (file, \"\\t.byte 0x15\\t# MUL\\n\");\n-\t  break;\n-\tcase NEG:\n-\t  fprintf (file, \"\\t.byte 0x16\\t# NEG\\n\");\n-\t  break;\n-\tcase SQRT:\n-\t  fprintf (file, \"\\t.byte 0x1c\\t# SQRT\\n\");\n-\t  break;\n-\tcase MINUS:\n-\t  fprintf (file, \"\\t.byte 0x1e\\t# SUB\\n\");\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-      fprintf (file, \"\\t.byte %d\\n\", fpop->noperands);\n-      fprintf (file, \"\\t.short 0x8001\\n\");\n-      \n-      if ((fpop->ops[0] == 0\n-\t   || GET_CODE (fpop->ops[0]) != REG || REGNO(fpop->ops[0]) != 17)\n-\t  && (fpop->ops[1] == 0 || GET_CODE (fpop->ops[1]) != REG\n-\t      || REGNO(fpop->ops[1]) != 17)\n-\t  && (fpop->ops[2] == 0 || GET_CODE (fpop->ops[2]) != REG\n-\t      || REGNO(fpop->ops[2]) != 17))\n-\tfprintf (file, \"\\t.byte %d, 0x80\\n\", fpop->size);\n-      else\n-\tfprintf (file, \"\\t.byte %d, 0\\n\", fpop->size);\n-      size_so_far = 12;\n-      for (i = 0; i < fpop->noperands; i++)\n-\t{\n-\t  register int type;\n-\t  register int opbyte;\n-\t  register const char *desc0;\n-\t  char desc1[50];\n-\n-\t  immed[i] = 0;\n-\t  switch (GET_MODE (fpop->ops[i]))\n-\t    {\n-\t    case SImode:\n-\t    case VOIDmode:\n-\t      desc0 = \"int\";\n-\t      type = 0;\n-\t      break;\n-\t    case SFmode:\n-\t      desc0 = \"float\";\n-\t      type = 2;\n-\t      break;\n-\t    case DFmode:\n-\t      desc0 = \"double\";\n-\t      type = 3;\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n-\n-\t  switch (GET_CODE (fpop->ops[i]))\n-\t    {\n-\t    case REG:\n-\t      strcpy(desc1, reg_names[REGNO (fpop->ops[i])]);\n-\t      if (FP_REGNO_P (REGNO (fpop->ops[i])))\n-\t\t{\n-\t\t  type += 0x10;\n-\t\t  opbyte = REGNO (fpop->ops[i]) - 17;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  type += 0x00;\n-\t\t  opbyte = REGNO (fpop->ops[i]);\n-\t\t  if (type == 3)\n-\t\t    opbyte = (opbyte << 4) + opbyte + 1;\n-\t\t}\n-\t      break;\n-\n-\t    case MEM:\n-\t      type += 0x30;\n-\t      if (GET_CODE (XEXP (fpop->ops[i], 0)) == PLUS)\n-\t\t{\n-\t\t  immed[i] = XEXP (XEXP (fpop->ops[i], 0), 1);\n-\t\t  opbyte = REGNO (XEXP (XEXP (fpop->ops[i], 0), 0));\n-\t\t  if (GET_CODE (immed[i]) == CONST_INT)\n-\t\t    sprintf (desc1, \"%d(%s)\", INTVAL (immed[i]),\n-\t\t\t     reg_names[opbyte]);\n-\t\t  else\n-\t\t    sprintf (desc1, \"<memory> (%s)\", reg_names[opbyte]);\n-\t\t}\n-\t      else if (GET_CODE (XEXP (fpop->ops[i], 0)) == REG)\n-\t\t{\n-\t\t  opbyte = REGNO (XEXP (fpop->ops[i], 0));\n-\t\t  immed[i] = const0_rtx;\n- \t\t  sprintf (desc1, \"(%s)\", reg_names[opbyte]);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  immed[i] = XEXP (fpop->ops[i], 0);\n-\t\t  opbyte = 0;\n-\t\t  sprintf(desc1, \"<memory>\");\n-\t\t}\n-\t      break;\n-\n-\t    case CONST_INT:\n-\t    case CONST_DOUBLE:\n-\t    case CONST:\n-\t    case SYMBOL_REF:\n-\t    case LABEL_REF:\n-\t      type += 0x20;\n-\t      opbyte = 0;\n-\t      immed[i] = fpop->ops[i];\n-\t      desc1[0] = '$';\n-\t      desc1[1] = '\\0';\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n-\t    }\n-\n-\t  /* Save/restore is special.  */\n-\t  if (i == 0 && (fpop->opcode == USE || fpop->opcode == CLOBBER))\n-\t    type = 0xff, opbyte = INTVAL (fpop->ops[0]), immed[i] = 0;\n-\n-\t  fprintf (file, \"\\t.byte 0x%x,0x%x # (%s) %s\\n\",\n-\t\t   type, opbyte, desc0, desc1);\n-\n-\t  size_so_far += 2;\n-\t}\n-\n-      /* If in the middle of a word, round.  */\n-      if (size_so_far % UNITS_PER_WORD)\n-\t{\n-\t  fprintf (file, \"\\t.space 2\\n\");\n-\t  size_so_far += 2;\n-\t}\n-\n-      for (i = 0; i < fpop->noperands; i++)\n-\tif (immed[i])\n-\t  switch (GET_MODE (immed[i]))\n-\t    {\n-\t    case SImode:\n-\t    case VOIDmode:\n-\t      size_so_far += 4;\n-\t      fprintf (file, \"\\t.long \");\n-\t      output_addr_const (file, immed[i]);\n-\t      fprintf (file, \"\\n\");\n-\t      break;\n-\n-\t    case DFmode:\n-\t      size_so_far += 4;\n-\t    case SFmode:\n-\t      size_so_far += 4;\n-\t      if (GET_CODE (immed[i]) == CONST_DOUBLE)\n-\t\t{\n-\t\t  REAL_VALUE_TYPE r;\n-\t\t  REAL_VALUE_FROM_CONST_DOUBLE (r, immed[i]);\n-\t\t  assemble_real (r, GET_MODE (immed[i]),\n-\t\t\t\t GET_MODE_ALIGNMENT (GET_MODE (immed[i])));\n-\t\t}\n-\t      else\n-\t\tabort ();\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t\n-      if (size_so_far != fpop->size)\n-        {\n-          if (TARGET_FULL_FP_BLOCKS)\n-\t    fprintf (file, \"\\t.space %d\\n\", fpop->size - size_so_far);\n-\t  else\n-\t    abort ();\n-\t}\n-    }\n-\n-  /* Update for next subroutine.  */\n-  subr_number++;\n-  text_section ();\n-}\n-\n- /* Initialize floating-point operation table.  */\n-\n-static void\n-init_fpops()\n-{\n-  register int i;\n-\n-  first_fpop = last_fpop_in_mem = 0;\n-  for (i = 0; i < FP_HASH_SIZE; i++)\n-    fp_hash_table[i] = 0;\n-}\n-\f\n-/* Return the offset value of an automatic variable (N_LSYM) having\n-   the given offset. Basically, we correct by going from a frame pointer to\n-   stack pointer value.\n-*/\n-\n-int\n-romp_debugger_auto_correction(offset)\n-     int offset;\n-{\n-  int fp_to_sp;\n-\n-  /* We really want to go from STACK_POINTER_REGNUM to\n-     FRAME_POINTER_REGNUM, but this isn't defined. So go the other\n-     direction and negate.  */\n-  INITIAL_ELIMINATION_OFFSET (FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM,\n-\t\t\t      fp_to_sp);\n-\n-  /* The offset value points somewhere between the frame pointer and\n-     the stack pointer. What is up from the frame pointer is down from the\n-     stack pointer. Therefore the negation in the offset value too.  */\n-\n-  return -(offset+fp_to_sp+4);\n-}\n-\n-/* Return the offset value of an argument having\n-   the given offset. Basically, we correct by going from an arg pointer to\n-   stack pointer value.  */\n-\n-int\n-romp_debugger_arg_correction (offset)\n-     int offset;\n-{\n-  int fp_to_argp;\n-\n-  INITIAL_ELIMINATION_OFFSET (ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM,\n-\t\t\t      fp_to_argp);\n-\n-  /* Actually, something different happens if offset is from a floating-point\n-     register argument, but we don't handle it here.  */\n-\n-  return (offset - fp_to_argp);\n-}\n-\n-void\n-romp_initialize_trampoline (tramp, fnaddr, cxt)\n-     rtx tramp, fnaddr, cxt;\n-{\n-  rtx addr, temp, val;\n-\n-  temp = expand_simple_binop (SImode, PLUS, tramp, GEN_INT (4),\n-\t\t\t       0, 1, OPTAB_LIB_WIDEN);\n-  emit_move_insn (gen_rtx_MEM (SImode, memory_address (SImode, tramp)), temp);\n-\n-  val = force_reg (SImode, cxt);\n-  addr = memory_address (HImode, plus_constant (tramp, 10));\n-  emit_move_insn (gen_rtx_MEM (HImode, addr), gen_lowpart (HImode, val));\n-  temp = expand_shift (RSHIFT_EXPR, SImode, val, build_int_2 (16, 0), 0, 1);\n-  addr = memory_address (HImode, plus_constant (tramp, 6));\n-  emit_move_insn (gen_rtx_MEM (HImode, addr), gen_lowpart (HImode, temp));\n-\n-  val = force_reg (SImode, fnaddr);\n-  addr = memory_address (HImode, plus_constant (tramp, 24));\n-  emit_move_insn (gen_rtx_MEM (HImode, addr), gen_lowpart (HImode, val));\n-  temp = expand_shift (RSHIFT_EXPR, SImode, val, build_int_2 (16, 0), 0, 1);\n-  addr = memory_address (HImode, plus_constant (tramp, 20));\n-  emit_move_insn (gen_rtx_MEM (HImode, addr), gen_lowpart (HImode, temp));\n-}\n-\n-/* On ROMP, all constants are in the data area.  */\n-\n-static void\n-romp_select_rtx_section (mode, x, align)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x ATTRIBUTE_UNUSED;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n-{\n-  data section ();\n-}\n-\n-/* For no good reason, we do the same as the other RT compilers and load\n-   the addresses of data areas for a function from our data area.  That means\n-   that we need to mark such SYMBOL_REFs.  We do so here.  */\n-\n-static void\n-romp_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first ATTRIBUTE_UNUSED;\n-{\n-  if (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)\n-    SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;\n-}\n-\n-static bool\n-romp_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n-{\n-  switch (x)\n-    {\n-    case CONST_INT:\n-      if ((outer_code == IOR && exact_log2 (INTVAL (x)) >= 0)\n-\t  || (outer_code == AND && exact_log2 (~INTVAL (x)) >= 0)\n-\t  || ((outer_code == PLUS || outer_code == MINUS)\n-\t      && (unsigned HOST_WIDE_INT) (INTVAL (x) + 15) < 31)\n-\t  || (outer_code == SET && (unsigned HOST_WIDE_INT) INTVAL (x) < 16))\n-\t*total = 0;\n-      else if ((unsigned HOST_WIDE_INT) (INTVAL (x) + 0x8000) < 0x10000\n-\t       || (INTVAL (x) & 0xffff0000) == 0)\n-\t*total = 0;\n-      else\n-\t*total = COSTS_N_INSNS (2);\n-      return true;\n-\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      if (current_function_operand (x, Pmode))\n-\t*total = 0;\n-      else\n-        *total = COSTS_N_INSNS (2);\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      if (x == CONST0_RTX (GET_MODE (x)))\n-\t*total = 2;\n-      else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-\t*total = COSTS_N_INSNS (5)\n-      else\n-\t*total = COSTS_N_INSNS (4);\n-      return true;\n-\n-    case MEM:\n-      *total = current_function_operand (x, Pmode) ? 0 : COSTS_N_INSNS (2);\n-      return true;\n-\n-    case MULT:\n-      if (TARGET_IN_LINE_MUL && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT)\n-\t*total = COSTS_N_INSNS (19);\n-      else\n-\t*total = COSTS_N_INSNS (25);\n-      return true;\n-\n-    case DIV:\n-    case UDIV:\n-    case MOD:\n-    case UMOD:\n-      *total = COSTS_N_INSNS (45);\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* For the ROMP, everything is cost 0 except for addresses involving\n-   symbolic constants, which are cost 1.  */\n-\n-static int\n-romp_address_cost (x)\n-     rtx x;\n-{\n-  return \n-  ((GET_CODE (x) == SYMBOL_REF\n-    && ! CONSTANT_POOL_ADDRESS_P (x))\n-   || GET_CODE (x) == LABEL_REF\n-   || (GET_CODE (x) == CONST\n-       && ! constant_pool_address_operand (x, Pmode))\n-   || (GET_CODE (x) == PLUS\n-       && ((GET_CODE (XEXP (x, 1)) == SYMBOL_REF\n-\t    && ! CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n-\t   || GET_CODE (XEXP (x, 1)) == LABEL_REF\n-\t   || GET_CODE (XEXP (x, 1)) == CONST)));\n-}"}, {"sha": "cb7c9ad374b6a5839c8ab66d94c8f534454c7379", "filename": "gcc/config/romp/romp.h", "status": "removed", "additions": 0, "deletions": 1385, "changes": 1385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fromp%2Fromp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fromp%2Fromp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896", "patch": "@@ -1,1385 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for ROMP chip.\n-   Copyright (C) 1989, 1991, 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2002,\n-   2003 Free Software Foundation, Inc.\n-   Contributed by Richard Kenner (kenner@nyu.edu)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dibm032 -Dunix -Asystem=unix -Asystem=bsd  -Acpu=ibm032 -Amachine=ibm032\"\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-#define TARGET_VERSION ;\n-\n-/* Add -lfp_p when running with -p or -pg.  */\n-#define LIB_SPEC \"%{pg:-lfp_p}%{p:-lfp_p} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}\"\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-/* Flag to generate all multiplies as an in-line sequence of multiply-step\n-   insns instead of calling a library routine.  */\n-#define TARGET_IN_LINE_MUL (target_flags & 1)\n-\n-/* Flag to generate padded floating-point data blocks.  Otherwise, we generate\n-   them the minimum size.  This trades off execution speed against size.  */\n-#define TARGET_FULL_FP_BLOCKS (target_flags & 2)\n-\n-/* Flag to pass and return floating point values in floating point registers.\n-   Since this violates the linkage convention, we feel free to destroy fr2\n-   and fr3 on function calls.\n-   fr1-fr3 are used to pass the arguments.  */\n-#define TARGET_FP_REGS (target_flags & 4)\n-\n-/* Flag to return structures of more than one word in memory.  This is for\n-   compatibility with the MetaWare HighC (hc) compiler.  */\n-#define TARGET_HC_STRUCT_RETURN (target_flags & 010)\n-\n-extern int target_flags;\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define TARGET_SWITCHES\t\t\\\n-  { {\"in-line-mul\", 1},\t\t\\\n-    {\"call-lib-mul\", -1},\t\\\n-    {\"full-fp-blocks\", 2},\t\\\n-    {\"minimum-fp-blocks\", -2},\t\\\n-    {\"fp-arg-in-fpregs\", 4},\t\\\n-    {\"fp-arg-in-gregs\", -4},\t\\\n-    {\"hc-struct-return\", 010},  \\\n-    {\"nohc-struct-return\", - 010}, \\\n-    { \"\", TARGET_DEFAULT}}\n-\n-#define TARGET_DEFAULT 3\n-\f\n-/* target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.  */\n-/* That is true on ROMP.  */\n-#define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-/* That is true on ROMP.  */\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if most significant word of a multiword number is lowest\n-   numbered. \n-\n-   For ROMP we can decide arbitrarily since there are no machine instructions\n-   for them.  Might as well be consistent with bits and bytes.  */\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 16\n-\n-/* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* A bit-field declared as `int' forces `int' alignment for the struct.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* Make strings word-aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  (TREE_CODE (EXP) == STRING_CST\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 1\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-   ROMP has 16 fullword registers and 8 floating point registers.\n-\n-   In addition, the difference between the frame and argument pointers is\n-   a function of the number of registers saved, so we need to have a register\n-   to use for AP that will later be eliminated in favor of sp or fp.  This is\n-   a normal register, but it is fixed.  */\n-\n-#define FIRST_PSEUDO_REGISTER 25\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-\n-   On ROMP, r1 is used for the stack and r14 is used for a\n-   data area pointer.\n-\n-   HACK WARNING:  On the RT, there is a bug in code generation for\n-   the MC68881 when the first and third operands are the same floating-point\n-   register.  See the definition of the FINAL_PRESCAN_INSN macro for details.\n-   Here we need to reserve fr0 for this purpose.  */\n-#define FIXED_REGISTERS  \\\n- {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  1,\t\t\t\t\t\t\t\\\n-  1, 0, 0, 0, 0, 0, 0, 0}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS\t\t\t\t\\\n- {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  1,\t\t\t\t\t\t\t\\\n-  1, 1, 0, 0, 0, 0, 0, 0}\n-\n-/* List the order in which to allocate registers.  Each register must be\n-   listed once, even those in FIXED_REGISTERS.\n-\n-   We allocate in the following order:\n-\tfr0, fr1\t(not saved)\n-\tfr2 ... fr6\n-\tfr7\t\t(more expensive for some FPA's)\n-\tr0\t\t(not saved and won't conflict with parameter register)\n-\tr4, r3, r2\t(not saved, highest used first to make less conflict)\n-\tr5\t\t(not saved, but forces r6 to be saved if DI/DFmode)\n-\tr15, r14, r13, r12, r11, r10, r9, r8, r7, r6 (less to save)\n-\tr1, ap \t\t\t*/\n-\n-#define REG_ALLOC_ORDER\t\t\\\n-  {17, 18,\t\t\t\\\n-   19, 20, 21, 22, 23,\t\t\\\n-   24,\t\t\t\t\\\n-   0,\t\t\t\t\\\n-   4, 3, 2,\t\t\t\\\n-   5,\t\t\t\t\\\n-   15, 14, 13, 12, 11, 10,\t\\\n-   9, 8, 7, 6, \t\t\t\\\n-   1, 16}\n-\n-/* True if register is floating-point.  */\n-#define FP_REGNO_P(N) ((N) >= 17)\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On ROMP, ordinary registers hold 32 bits worth;\n-   a single floating point register is always enough for\n-   anything that can be stored in them at all.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  (FP_REGNO_P (REGNO) ? GET_MODE_NUNITS (MODE)\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On ROMP, the cpu registers can hold any mode but the float registers\n-   can hold only floating point.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  (! FP_REGNO_P (REGNO) || GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n-   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\\\n-    || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n-   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\\\n-       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n-\n-/* A C expression returning the cost of moving data from a register of class\n-   CLASS1 to one of CLASS2.\n-\n-   On the ROMP, access to floating-point registers is expensive (even between\n-   two FP regs.)  */\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)\t\\\n-  (2 + 10 * ((CLASS1) == FP_REGS) + 10 * (CLASS2 == FP_REGS))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* ROMP pc isn't overloaded on a register that the compiler knows about.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 1\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 13\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED 0\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 16\n-\n-/* Place to put static chain when calling a function that requires it.  */\n-#define STATIC_CHAIN\t\t\t\t\t\t\t\\\n-  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, -36))\n-\n-/* Place where static chain is found upon entry to routine.  */\n-#define STATIC_CHAIN_INCOMING\t\t\t\t\t\t\\\n-  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -20))\n-\n-/* Place that structure value return address is placed.\n-\n-   On the ROMP, it is passed as an extra parameter.  */\n-#define STRUCT_VALUE\t0\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-   \n-/* The ROMP has two types of registers, general and floating-point.\n-\n-   However, r0 is special in that it cannot be used as a base register.\n-   So make a class for registers valid as base registers.\n-\n-   For floating-point support, add classes that just consist of r0 and\n-   r15, respectively.  */\n-\n-enum reg_class { NO_REGS, R0_REGS, R15_REGS, BASE_REGS, GENERAL_REGS,\n-\t\t FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"R0_REGS\", \"R15_REGS\", \"BASE_REGS\", \"GENERAL_REGS\", \\\n-  \"FP_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS {{0}, {0x00001}, {0x08000}, {0x1fffe}, {0x1ffff},  \\\n-\t\t\t    {0x1fe0000}, {0x1ffffff} }\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) \\\n- ((REGNO) == 0 ? GENERAL_REGS : FP_REGNO_P (REGNO) ? FP_REGS : BASE_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS BASE_REGS\n-#define BASE_REG_CLASS BASE_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS\t\t\\\n-   : (C) == 'b' ? BASE_REGS\t\\\n-   : (C) == 'z' ? R0_REGS\t\\\n-   : (C) == 't' ? R15_REGS\t\\\n-   : NO_REGS)\n-\n-/* The letters I, J, K, L, M, N, and P in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   `I' is constants less than 16\n-   `J' is negative constants greater than -16\n-   `K' is the range for a normal D insn.\n-   `L' is a constant with only the low-order 16 bits set\n-   `M' is a constant with only the high-order 16 bits set\n-   `N' is a single-bit constant\n-   `O' is a constant with either the high-order or low-order 16 bits all ones\n-   `P' is the complement of a single-bit constant\n-  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \t\t   \\\n-   ( (C) == 'I' ? (unsigned) (VALUE) < 0x10\t\t   \\\n-   : (C) == 'J' ? (VALUE) < 0 && (VALUE) > -16\t\t   \\\n-   : (C) == 'K' ? (unsigned) ((VALUE) + 0x8000) < 0x10000  \\\n-   : (C) == 'L' ? ((VALUE) & 0xffff0000) == 0\t\t   \\\n-   : (C) == 'M' ? ((VALUE) & 0xffff) == 0\t\t   \\\n-   : (C) == 'N' ? exact_log2 (VALUE) >= 0\t\t   \\\n-   : (C) == 'O' ? ((VALUE) & 0xffff) == 0xffff\t\t   \\\n-\t\t  || ((VALUE) & 0xffff0000) == 0xffff0000  \\\n-   : (C) == 'P' ? exact_log2 (~ (VALUE)) >= 0\t\t   \\\n-   : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.\n-   No floating-point constants on ROMP.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0\n-\n-/* Optional extra constraints for this machine.\n-\n-   For the ROMP, `Q' means that this is a memory operand but not a symbolic\n-   memory operand.  Note that an unassigned pseudo register is such a\n-   memory operand.  If register allocation has not been done, we reject\n-   pseudos, since we assume (hope) that they will get hard registers.\n-\n-   `R' means that this is a constant pool reference to the current function.\n-   This is just r14 and so can be treated as a register.  We bother with this\n-   just in move insns as that is the only place it is likely to occur.\n-\n-   `S' means that this is the address of a constant pool location.  This is\n-   equal to r14 plus a constant.  We also only check for this in move insns.  */\n-\n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q' ?\t\t\t\t\t\t\\\n-   ((GET_CODE (OP) == REG\t\t\t\t\\\n-     && REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n-     && reg_renumber != 0\t\t\t\t\\\n-     && reg_renumber[REGNO (OP)] < 0)\t\t\t\\\n-    || (GET_CODE (OP) == MEM\t\t\t\t\\\n-        && ! symbolic_memory_operand (OP, VOIDmode)))\t\\\n-   : (C) == 'R' ? current_function_operand (OP, VOIDmode) \\\n-   : (C) == 'S' ? constant_pool_address_operand (OP, VOIDmode) \\\n-   : 0)\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-\n-   For the ROMP, if X is a memory reference that involves a symbol,\n-   we must use a BASE_REGS register instead of GENERAL_REGS\n-   to do the reload. The argument of MEM be either REG, PLUS, or SYMBOL_REF\n-   to be valid, so we assume that this is the case.\n-\n-   Also, if X is an integer class, ensure that floating-point registers\n-   aren't used.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\t\t\\\n-  ((CLASS) == FP_REGS && GET_MODE_CLASS (GET_MODE (X)) == MODE_INT\t\\\n-   ? GENERAL_REGS :\t\t\t\t\t\t\t\\\n-   (CLASS) != GENERAL_REGS ? (CLASS) :\t\t\t\t\t\\\n-   GET_CODE (X) != MEM ? GENERAL_REGS :\t\t\t\t\t\\\n-   GET_CODE (XEXP (X, 0)) == SYMBOL_REF ? BASE_REGS :\t\t\t\\\n-   GET_CODE (XEXP (X, 0)) == LABEL_REF ? BASE_REGS :\t\t\t\\\n-   GET_CODE (XEXP (X, 0)) == CONST ? BASE_REGS :\t\t\t\\\n-   GET_CODE (XEXP (X, 0)) == REG ? GENERAL_REGS :\t\t\t\\\n-   GET_CODE (XEXP (X, 0)) != PLUS ? GENERAL_REGS :\t\t\t\\\n-   GET_CODE (XEXP (XEXP (X, 0), 1)) == SYMBOL_REF ? BASE_REGS :\t\t\\\n-   GET_CODE (XEXP (XEXP (X, 0), 1)) == LABEL_REF ? BASE_REGS :\t\t\\\n-   GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST ? BASE_REGS : GENERAL_REGS)\n-\n-/* Return the register class of a scratch register needed to store into\n-   OUT from a register of class CLASS in MODE.  \n-\n-   On the ROMP, we cannot store into a symbolic memory address from an\n-   integer register; we need a BASE_REGS register as a scratch to do it.  */\n-\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, OUT) \\\n-  (GET_MODE_CLASS (MODE) == MODE_INT && symbolic_memory_operand (OUT, MODE) \\\n-   ? BASE_REGS : NO_REGS)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.\n-\n-   On ROMP, this is the size of MODE in words,\n-   except in the FP regs, where a single reg is always enough.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((CLASS) == FP_REGS ? 1\t\t\t\\\n-  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.\n-   On the ROMP, if we set the frame pointer to 15 words below the highest\n-   address of the highest local variable, the first 16 words will be\n-   addressable via D-short insns.  */\n-#define STARTING_FRAME_OFFSET 64\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On ROMP, don't define this because there are no push insns.  */\n-/*  #define PUSH_ROUNDING(BYTES) */\n-\n-/* Offset of first parameter from the argument pointer register value.\n-   On the ROMP, we define the argument pointer to the start of the argument\n-   area.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* Define this if stack space is still allocated for a parameter passed\n-   in a register.  The value is the number of bytes.  */\n-#define REG_PARM_STACK_SPACE(FNDECL) 16\n-\n-/* This is the difference between the logical top of stack and the actual sp.\n-\n-   For the ROMP, sp points past the words allocated for the first four outgoing\n-   arguments (they are part of the callee's frame).  */\n-#define STACK_POINTER_OFFSET -16\n-\n-/* Define this if the maximum size of all the outgoing args is to be\n-   accumulated and pushed during the prologue.  The amount can be\n-   found in the variable current_function_outgoing_args_size.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.\n-\n-   On ROMP the value is found in r2, unless the machine specific option\n-   fp-arg-in-fpregs is selected, in which case FP return values are in fr1 */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE),\t\t\t\t\t\\\n-\t       (TARGET_FP_REGS\t\t\t\t\t\t\\\n-\t\t&& GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_FLOAT)\t\\\n-\t       ? 18 : 2)\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 2)\n-\n-/* The definition of this macro implies that there are cases where\n-   a scalar value cannot be returned in registers.\n-\n-   For the ROMP, if compatibility with HC is required, anything of\n-   type DImode is returned in memory.  */\n-\n-#define RETURN_IN_MEMORY(type) \\\n-  (TYPE_MODE (type) == BLKmode \\\n-   || (TARGET_HC_STRUCT_RETURN && TYPE_MODE (type) == DImode))\n-\n-/* 1 if N is a possible register number for a function value\n-   as seen by the caller.\n-\n-   On ROMP, r2 is the only register thus used unless fp values are to be\n-   returned in fp regs, in which case fr1 is also used.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N)  ((N) == 2 || ((N) == 18 && TARGET_FP_REGS))\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On ROMP, these are r2-r5 (and fr1-fr4 if fp regs are used).  */\n-\n-#define FUNCTION_ARG_REGNO_P(N)\t\\\n-  (((N) <= 5 && (N) >= 2) || (TARGET_FP_REGS && (N) > 17 && (N) < 21))\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On the ROMP, this is a structure.  The first word is the number of\n-   words of (integer only if -mfp-arg-in-fpregs is specified) arguments\n-   scanned so far (including the invisible argument, if any, which holds\n-   the structure-value-address).  The second word hold the corresponding\n-   value for floating-point arguments, except that both single and double\n-   count as one register.  */\n-\n-struct rt_cargs {int gregs, fregs; };\n-#define CUMULATIVE_ARGS struct rt_cargs \n-\n-#define USE_FP_REG(MODE,CUM)\t\t\t\t\t\\\n-  (TARGET_FP_REGS && GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n-   && (CUM).fregs < 3)\n-\n-/* Define intermediate macro to compute the size (in registers) of an argument\n-   for the ROMP.  */\n-\n-#define ROMP_ARG_SIZE(MODE, TYPE, NAMED)\t\t\t\t\\\n-(! (NAMED) ? 0\t\t\t\t\t\t\t\t\\\n- : (MODE) != BLKmode\t\t\t\t\t\t\t\\\n- ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD \t\\\n- : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On ROMP, the offset normally starts at 0, but starts at 4 bytes\n-   when the function gets a structure-value-address as an\n-   invisible first argument.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n-  (CUM).gregs = 0,\t\t\t\t\\\n-  (CUM).fregs = 0\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-{ if (NAMED)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      if (USE_FP_REG(MODE, CUM))\t\t\t\\\n-\t(CUM).fregs++;\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\\\n-\t(CUM).gregs += ROMP_ARG_SIZE (MODE, TYPE, NAMED); \\\n-    }\t\t\t\t\t\t\t\\\n-}\n-\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).\n-\n-   On ROMP the first four words of args are normally in registers\n-   and the rest are pushed.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n-  (! (NAMED) ? 0\t\t\t\t\t\t\t\\\n-   : ((TYPE) != 0 && TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST) ? 0\t\\\n-   : USE_FP_REG(MODE,CUM) ? gen_rtx_REG ((MODE), (CUM).fregs + 17)\t\\\n-   : (CUM).gregs < 4 ? gen_rtx_REG ((MODE), 2 + (CUM).gregs) : 0)\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n-  (! (NAMED) ? 0\t\t\t\t\t\t\t\\\n-   : USE_FP_REG(MODE,CUM) ? 0\t\t\t\t\t\t\\\n-   : (((CUM).gregs < 4\t\t\t\t\t\t\t\\\n-       && 4 < ((CUM).gregs + ROMP_ARG_SIZE (MODE, TYPE, NAMED)))\t\\\n-      ? 4 - (CUM).gregs : 0))\n-\n-/* Perform any needed actions needed for a function that is receiving a\n-   variable number of arguments. \n-\n-   CUM is as above.\n-\n-   MODE and TYPE are the mode and type of the current parameter.\n-\n-   PRETEND_SIZE is a variable that should be set to the amount of stack\n-   that must be pushed by the prolog to pretend that our caller pushed\n-   it.\n-\n-   Normally, this macro will push all remaining incoming registers on the\n-   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n-\n-#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n-{ if (TARGET_FP_REGS)\t\t\t\t\t\t\t\\\n-    error (\"can't have varargs with -mfp-arg-in-fp-regs\");\t\t\\\n-  else if ((CUM).gregs < 4)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int first_reg_offset = (CUM).gregs;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\\\n-\tfirst_reg_offset += ROMP_ARG_SIZE (TYPE_MODE (TYPE), TYPE, 1);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (first_reg_offset > 4)\t\t\t\t\t\t\\\n-\tfirst_reg_offset = 4;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if (! NO_RTL && first_reg_offset != 4)\t\t\t\t\\\n-\tmove_block_from_reg\t\t\t\t\t\t\\\n-\t  (2 + first_reg_offset,\t\t\t\t\t\\\n-\t   gen_rtx_MEM (BLKmode,\t\t\t\t\t\\\n-\t\t\tplus_constant (virtual_incoming_args_rtx,\t\\\n-\t\t\t\t       first_reg_offset * 4)), \t\t\\\n-\t   4 - first_reg_offset);\t\t\t\t\t\\\n-      PRETEND_SIZE = (4 - first_reg_offset) * UNITS_PER_WORD;\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* This macro produces the initial definition of a function name.\n-   On the ROMP, we need to place an extra '.' in the function name.  */\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n-{ if (TREE_PUBLIC(DECL))\t\t\t\t\\\n-    fprintf (FILE, \"\\t.globl _.%s\\n\", NAME);\t\t\\\n-  fprintf (FILE, \"_.%s:\\n\", NAME);\t\t\t\\\n-}\n-\n-/* This macro is used to output the start of the data area.\n-\n-   On the ROMP, the _name is a pointer to the data area.  At that\n-   location is the address of _.name, which is really the name of\n-   the function.  We need to set all this up here.\n-\n-   The global declaration of the data area, if needed, is done in \n-   `assemble_function', where it thinks it is globalizing the function\n-   itself.  */\n-\n-#define ASM_OUTPUT_POOL_PROLOGUE(FILE, NAME, DECL, SIZE)\t\\\n-{ extern int data_offset;\t\t\t\t\t\\\n-  data_section ();\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.align 2\\n\");\t\t\t\t\\\n-  ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n-  fprintf (FILE, \"\\t.long _.%s, 0, \", NAME);\t\t\t\\\n-  if (current_function_calls_alloca)\t\t\t\t\\\n-    fprintf (FILE, \"0x%x\\n\",\t\t\t\t\t\\\n-\t     0xf6900000 + current_function_outgoing_args_size); \\\n-  else\t\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"0\\n\");\t\t\t\t\t\\\n-  data_offset = ((SIZE) + 12 + 3) / 4;\t\t\t\t\\\n-}\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n-  fprintf(FILE, \"\\tcas r0,r15,r0\\n\\tbali r15,mcount\\n\");\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-/* #define EXIT_IGNORE_STACK\t1\t*/\n-\f\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.\n-\n-   The trampoline should set the static chain pointer to value placed\n-   into the trampoline and should branch to the specified routine.\n-\n-   On the ROMP, we have a problem.  There are no free registers to use\n-   to construct the static chain and function addresses.  Hence we use\n-   the following kludge:  r15 (the return address) is first saved in mq.\n-   Then we use r15 to form the function address.  We then branch to the\n-   function and restore r15 in the delay slot.  This makes it appear that\n-   the function was called directly from the caller.\n-\n-   (Note that the function address built is actually that of the data block.\n-   This is passed in r0 and the actual routine address is loaded into r15.)\n-\n-   In addition, note that the address of the \"called function\", in this case\n-   the trampoline, is actually the address of the data area.  So we need to\n-   make a fake data area that will contain the address of the trampoline.\n-   Note that this must be defined as two half-words, since the trampoline\n-   template (as opposed to the trampoline on the stack) is only half-word\n-   aligned.  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\\\n-{\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.short 0,0\\n\");\t\\\n-  fprintf (FILE, \"\\tcau r0,0(r0)\\n\");\t\\\n-  fprintf (FILE, \"\\toil r0,r0,0\\n\");\t\\\n-  fprintf (FILE, \"\\tmts r10,r15\\n\");\t\\\n-  fprintf (FILE, \"\\tst r0,-36(r1)\\n\");\t\\\n-  fprintf (FILE, \"\\tcau r15,0(r0)\\n\");\t\\\n-  fprintf (FILE, \"\\toil r15,r15,0\\n\");\t\\\n-  fprintf (FILE, \"\\tcas r0,r15,r0\\n\");\t\\\n-  fprintf (FILE, \"\\tls r15,0(r15)\\n\");\t\\\n-  fprintf (FILE, \"\\tbrx r15\\n\");\t\\\n-  fprintf (FILE, \"\\tmfs r10,r15\\n\");\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE    36\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.\n-\n-   On the RT, the static chain and function addresses are written in\n-   two 16-bit sections.\n-\n-   We also need to write the address of the first instruction in\n-   the trampoline into the first word of the trampoline to simulate a\n-   data area.  */\n-\n-#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, CXT)\t\t\\\n-\tromp_initialize_trampoline (ADDR, FNADDR, CXT)\n-\f\n-/* Definitions for register eliminations.\n-\n-   We have two registers that can be eliminated on the ROMP.  First, the\n-   frame pointer register can often be eliminated in favor of the stack\n-   pointer register.  Secondly, the argument pointer register can always be\n-   eliminated; it is replaced with either the stack or frame pointer.\n-\n-   In addition, we use the elimination mechanism to see if r14 is needed.\n-   Initially we assume that it isn't.  If it is, we spill it.  This is done\n-   by making it an eliminable register.  It doesn't matter what we replace\n-   it with, since it will never occur in the rtl at this point.  */\n-\n-/* This is an array of structures.  Each structure initializes one pair\n-   of eliminable registers.  The \"from\" register number is given first,\n-   followed by \"to\".  Eliminations of the same \"from\" register are listed\n-   in order of preference.  */\n-#define ELIMINABLE_REGS\t\t\t\t\\\n-{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n- { ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n- { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n- { 14, 0}}\n-\n-/* Given FROM and TO register numbers, say whether this elimination is allowed.\n-   Frame pointer elimination is automatically handled.\n-\n-   For the ROMP, if frame pointer elimination is being done, we would like to\n-   convert ap into fp, not sp.\n-\n-   We need r14 if various conditions (tested in romp_using_r14) are true.\n-\n-   All other eliminations are valid.  */\n-#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n- ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n-  ? ! frame_pointer_needed\t\t\t\t\t\\\n-  : (FROM) == 14 ? ! romp_using_r14 ()\t\t\t\t\\\n-  : 1)\n-\n-/* Define the offset between two registers, one to be eliminated, and the other\n-   its replacement, at the start of a routine.  */\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-{ if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (romp_pushes_stack ())\t\t\t\t\t\t\\\n-\t(OFFSET) = ((get_frame_size () - 64)\t\t\t\t\\\n-\t\t    + current_function_outgoing_args_size);\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t(OFFSET) = - (romp_sa_size () + 64);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM) \\\n-    (OFFSET) = romp_sa_size () - 16 + 64;\t\t\t\t\\\n-  else if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (romp_pushes_stack ())\t\t\t\t\t\t\\\n-\t(OFFSET) = (get_frame_size () + (romp_sa_size () - 16)\t\t\\\n-\t\t    + current_function_outgoing_args_size);\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t(OFFSET) = -16;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if ((FROM) == 14)\t\t\t\t\t\t\\\n-    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-}\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) 0\n-#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n-((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\t\\\n- ? (REGNO) < 16 && (REGNO) != 0 && (REGNO) != 16\t\t\\\n- : (reg_renumber[REGNO] < 16 && reg_renumber[REGNO] >= 0\t\\\n-    && reg_renumber[REGNO] != 16))\n-\f\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-/* Recognize any constant value that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n-\n-   On the ROMP, there is a bit of a hack here.  Basically, we wish to\n-   only issue instructions that are not `as' macros.  However, in the\n-   case of `get', `load', and `store', if the operand is a relocatable\n-   symbol (possibly +/- an integer), there is no way to express the\n-   resulting split-relocation except with the macro.  Therefore, allow\n-   either a constant valid in a normal (sign-extended) D-format insn or\n-   a relocatable expression.\n-\n-   Also, for DFmode and DImode, we must ensure that both words are\n-   addressable.\n-\n-   We define two macros: The first is given an offset (0 or 4) and indicates\n-   that the operand is a CONST_INT that is valid for that offset.  The second\n-   indicates a valid non-CONST_INT constant.  */\n-\n-#define LEGITIMATE_ADDRESS_INTEGER_P(X,OFFSET)\t\t\t\t\\\n-  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n-   && (unsigned) (INTVAL (X) + (OFFSET) + 0x8000) < 0x10000)\n-\n-#define LEGITIMATE_ADDRESS_CONSTANT_P(X)\t\t\t\t\\\n- (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n-  || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n-  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-      && (GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n-          || GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF)\t\t\\\n-      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT))\n-\n-/* Include all constant integers and constant double, but exclude \n-   SYMBOL_REFs that are to be obtained from the data area (see below).  */\n-#define LEGITIMATE_CONSTANT_P(X)\t\t\\\n-  ((LEGITIMATE_ADDRESS_CONSTANT_P (X)\t\t\\\n-    || GET_CODE (X) == CONST_INT\t\t\\\n-    || GET_CODE (X) == CONST_DOUBLE)\t\t\\\n-   && ! (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X)))\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) 0\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)\t\t\\\n-  (REGNO (X) != 0 && (REGNO (X) < 17 || REGNO (X) >= FIRST_PSEUDO_REGISTER))\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On the ROMP, a legitimate address is either a legitimate constant,\n-   a register plus a legitimate constant, or a register.  See the\n-   discussion at the LEGITIMATE_ADDRESS_CONSTANT_P macro.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{ if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) != CONST_INT && LEGITIMATE_ADDRESS_CONSTANT_P (X))\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-      && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-      && LEGITIMATE_ADDRESS_CONSTANT_P (XEXP (X, 1)))\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-      && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-      && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 0)\t\t\t\\\n-      && (((MODE) != DFmode && (MODE) != DImode)\t\t\t\\\n-\t  || (LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 4))))\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-}\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   On ROMP, check for the sum of a register with a constant\n-   integer that is out of range.  If so, generate code to add the\n-   constant with the low-order 16 bits masked to the register and force\n-   this result into another register (this can be done with `cau').\n-   Then generate an address of REG+(CONST&0xffff), allowing for the \n-   possibility of bit 16 being a one.\n-\n-   If the register is not OK for a base register, abort.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-{ if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == REG\t\\\n-    && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\\\n-    && (unsigned) (INTVAL (XEXP (X, 1)) + 0x8000) >= 0x10000)\t\\\n-    { int high_int, low_int;\t\t\t\t\t\\\n-      if (! REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n-\tabort ();\t\t\t\t\t\t\\\n-      high_int = INTVAL (XEXP (X, 1)) >> 16;\t\t\t\\\n-      low_int = INTVAL (XEXP (X, 1)) & 0xffff;\t\t\t\\\n-      if (low_int & 0x8000)\t\t\t\t\t\\\n-\thigh_int += 1, low_int |= 0xffff0000;\t\t\t\\\n-      (X) = gen_rtx_PLUS (SImode,\t\t\t\t\\\n-\t\t\t  force_operand (plus_constant (XEXP (X, 0),  \\\n-\t\t\t\t\t\t\thigh_int << 16), 0), \\\n-\t\t\t  GEN_INT (low_int));\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-\n-   On the ROMP this is true only if the address is valid with a zero offset\n-   but not with an offset of four (this means it cannot be used as an\n-   address for DImode or DFmode).  Since we know it is valid, we just check\n-   for an address that is not valid with an offset of four.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\t\\\n-{ if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n-      && ! LEGITIMATE_ADDRESS_CONSTANT_P (XEXP (ADDR, 1))\t\\\n-      && ! LEGITIMATE_ADDRESS_INTEGER_P (XEXP (ADDR, 1), 4))\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\\\n-}\n-\f\n-/* Define this if some processing needs to be done immediately before\n-   emitting code for an insn.\n-\n-   This is used on the ROMP, to compensate for a bug in the floating-point\n-   code.  When a floating-point operation is done with the first and third\n-   operands both the same floating-point register, it will generate bad code\n-   for the MC68881.  So we must detect this.  If it occurs, we patch the \n-   first operand to be fr0 and insert a move insn to move it to the desired\n-   destination.  */\n-#define FINAL_PRESCAN_INSN(INSN,OPERANDS,NOPERANDS)\t\t\t\\\n-  { rtx op0, op1, op2, operation, tem;\t\t\t\t\t\\\n-    if (NOPERANDS >= 3\t&& get_attr_type (INSN) == TYPE_FP)\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\top0 = OPERANDS[0];\t\t\t\t\t\t\\\n-\toperation = OPERANDS[1];\t\t\t\t\t\\\n-\tif (float_conversion (operation, VOIDmode))\t\t\t\\\n-\t  operation = XEXP (operation, 0);\t\t\t\t\\\n-        if (float_binary (operation, VOIDmode))\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    op1 = XEXP (operation, 0), op2 = XEXP (operation, 1);\t\\\n-\t    if (float_conversion (op1, VOIDmode))\t\t\t\\\n-\t      op1 = XEXP (op1, 0);\t\t\t\t\t\\\n-\t    if (float_conversion (op2, VOIDmode))\t\t\t\\\n-\t      op2 = XEXP (op2, 0);\t\t\t\t\t\\\n-\t    if (rtx_equal_p (op0, op2)\t\t\t\t\t\\\n-\t\t&& (GET_CODE (operation) == PLUS\t\t\t\\\n-\t\t    || GET_CODE (operation) == MULT))\t\t\t\\\n-\t      tem = op1, op1 = op2, op2 = tem;\t\t\t\t\\\n-\t    if (GET_CODE (op0) == REG && FP_REGNO_P (REGNO (op0))\t\\\n-\t\t&& GET_CODE (op2) == REG && FP_REGNO_P (REGNO (op2))\t\\\n-\t\t&& REGNO (op0) == REGNO (op2))\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\ttem = gen_rtx_REG (GET_MODE (op0), 17);\t\t\\\n-\t\temit_insn_after (gen_move_insn (op0, tem), INSN);\t\\\n-\t\tSET_DEST (XVECEXP (PATTERN (INSN), 0, 0)) = tem; \t\\\n-\t\tOPERANDS[0] = tem;\t\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-/* This flag, if defined, says the same insns that convert to a signed fixnum\n-   also convert validly to an unsigned one.\n-\n-   We actually lie a bit here as overflow conditions are different.  But\n-   they aren't being checked anyway.  */\n-\n-#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n-\n-/* Nonzero if access to memory by bytes is no faster than for words.\n-   Also nonzero if doing byte operations (specifically shifts) in registers\n-   is undesirable.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define if operations between registers always perform the operation\n-   on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n-\n-/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n-   will either zero-extend or sign-extend.  The value of this macro should\n-   be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n-#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n-\n-/* This is BSD, so it wants DBX format.  */\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Define the letter code used in a stabs entry for parameters passed\n-   with the register attribute.\n-\n-   GCC's default value, 'P', is used by dbx to refers to an external\n-   procedure. The section 5 manual page for dbx implies that 'R' would be the\n-   right letter, but dbx 1.5 has a bug in it that precludes its use.\n-   Probably that is why neither hc or pcc use this. pcc puts in two\n-   stabs entries: one for the parameter location and one for the register\n-   location. The letter `r' (register)\n-   would be okay, but it loses parameter attribute of the stabs entry.  */\n-#define DBX_REGPARM_STABS_LETTER 'R'\n-\n-/* A C expression for the integer offset value of an automatic variable\n-   (N_LSYM) having address X (an RTX). This gets used in .stabs entries\n-   for the local variables. Compare with the default definition.  */\n-#define DEBUGGER_AUTO_OFFSET(X)                        \\\n-  (GET_CODE (X) == PLUS                                \\\n-   ? romp_debugger_auto_correction (INTVAL (XEXP (X, 1)) ) \\\n-   : 0 )\n-\n-/* A C expression for the integer offset value of an argument (N_PSYM)\n-   having address X (an RTX).  The nominal offset is OFFSET.  */\n-#define DEBUGGER_ARG_OFFSET(OFFSET, X)             \\\n-  romp_debugger_arg_correction (OFFSET);\n-\n-/* We don't have GAS for the RT yet, so don't write out special\n-   .stabs in cc1plus.  */\n-   \n-#define FASCIST_ASSEMBLER\n-\n-/* Do not break .stabs pseudos into continuations.  */\n-#define DBX_CONTIN_LENGTH 0\n-\n-/* Don't try to use the `x' type-cross-reference character in DBX data.\n-   Also has the consequence of putting each struct, union or enum\n-   into a separate .stabs, containing only cross-refs to the others.  */\n-#define DBX_NO_XREFS\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* Mode of a function address in a call instruction (for indexing purposes).\n-\n-   Doesn't matter on ROMP.  */\n-#define FUNCTION_MODE SImode\n-\n-/* Define this if addresses of constant functions\n-   shouldn't be put through pseudo regs where they can be cse'd.\n-   Desirable on machines where ordinary constants are expensive\n-   but a CALL with constant address is cheap.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Define this if shift instructions ignore all but the low-order\n-   few bits.\n-\n-   This is not true on the RT since it uses the low-order 6, not 5, bits.\n-   At some point, this should be extended to see how to express that.  */\n-\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Adjust the length of an INSN.  LENGTH is the currently-computed length and\n-   should be adjusted to reflect any required changes.  This macro is used when\n-   there is some systematic length adjustment required that would be difficult\n-   to express in the length attribute.\n-\n-   On the ROMP, there are two adjustments:  First, a 2-byte insn in the delay\n-   slot of a CALL (including floating-point operations) actually takes four\n-   bytes.  Second, we have to make the worst-case alignment assumption for\n-   address vectors.  */\n-\n-#define ADJUST_INSN_LENGTH(X,LENGTH)\t\t\t\t\t\\\n-  if (GET_CODE (X) == INSN && GET_CODE (PATTERN (X)) == SEQUENCE\t\\\n-      && GET_CODE (XVECEXP (PATTERN (X), 0, 0)) != JUMP_INSN\t\t\\\n-      && get_attr_length (XVECEXP (PATTERN (X), 0, 1)) == 2)\t\t\\\n-    (LENGTH) += 2;\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == JUMP_INSN && GET_CODE (PATTERN (X)) == ADDR_VEC) \\\n-    (LENGTH) += 2;\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* Set if condition code (really not-Z) is stored in `test bit'.  */\n-#define CC_IN_TB\t 01000\n-\n-/* Set if condition code is set by an unsigned compare.  */\n-#define\tCC_UNSIGNED        02000\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(BODY,INSN) \\\n-  update_cc (BODY, INSN)\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Output at beginning of assembler file.  */\n-\n-#define ASM_FILE_START(FILE)\t\t\t\t\\\n-{ const char *p;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.globl .oVncs\\n\\t.set .oVncs,0\\n\") ; \\\n-  fprintf (FILE, \"\\t.globl .oVgcc\");\t\t\t\\\n-  for (p = version_string; *p != ' ' && *p != 0; p++)\t\\\n-    fprintf (FILE, \"%c\", *p);\t\t\t\t\\\n-  fprintf (FILE, \"\\n\\t.set .oVgcc\");\t\t\t\\\n-  for (p = version_string; *p != ' ' && *p != 0; p++)\t\\\n-    fprintf (FILE, \"%c\", *p);\t\t\t\t\\\n-  fprintf (FILE, \",0\\n\");\t\t\t\t\\\n-}\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"\"\n-\n-/* Output before instructions and read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\",\t\\\n- \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"ap\",\t\t\\\n- \"fr0\", \"fr1\", \"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\" }\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \"\\t.globl \"\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output a label for a jump table.  Arguments are the same as\n-   for (*targetm.asm_out.internal_label), except the insn for the jump table is\n-   passed.  */\n-\n-#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n-{ ASM_OUTPUT_ALIGN (FILE, 2); (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM); }\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n-\n-/* This is how to output code to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tsis r1,4\\n\\tsts %s,0(r1)\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tls r1,0(r1)\\n\\tais r1,4\\n\", reg_names[REGNO])\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.long L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.\n-   Don't define this if it is not supported.  */\n-\n-/* #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) */\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) != 0)\t\t\t\\\n-    fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.space %d\\n\", (int)(SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%d\\n\", (int)(SIZE)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)\t\\\n-( fputs (\".lcomm \", (FILE)),\t\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\t\\\n-  fprintf ((FILE), \",%d\\n\", (int)(SIZE)))\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  print_operand (FILE, X, CODE)\n-\n-/* Define which CODE values are valid.  */\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n-  ((CODE) == '.' || (CODE) == '#')\n-\f\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\\\n-{ register rtx addr = ADDR;\t\t\t\t\t\\\n-  register rtx base = 0, offset = addr;\t\t\t\t\\\n-  if (GET_CODE (addr) == REG)\t\t\t\t\t\\\n-    base = addr, offset = const0_rtx;\t\t\t\t\\\n-  else if (GET_CODE (addr) == PLUS\t\t\t\t\\\n-\t   && GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n-    base = XEXP (addr, 0), offset = XEXP (addr, 1);\t\t\\\n-  else if (GET_CODE (addr) == SYMBOL_REF\t\t\t\\\n-\t   && CONSTANT_POOL_ADDRESS_P (addr))\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      offset = GEN_INT (get_pool_offset (addr) + 12);  \t\t\\\n-      base = gen_rtx_REG (SImode, 14);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (addr) == CONST\t\t\t\t\\\n-\t   && GET_CODE (XEXP (addr, 0)) == PLUS\t\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST_INT\t\\\n-\t   && GET_CODE (XEXP (XEXP (addr, 0), 0)) == SYMBOL_REF\t\\\n-\t   && CONSTANT_POOL_ADDRESS_P (XEXP (XEXP (addr, 0), 0))) \\\n-    {\t\t\t\t\t\t\t\t\\\n-      offset = plus_constant (XEXP (XEXP (addr, 0), 1),\t\t\\\n-\t\t\t      (get_pool_offset (XEXP (XEXP (addr, 0), 0)) \\\n-\t\t\t       + 12));\t\t\t\t\\\n-      base = gen_rtx_REG (SImode, 14);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  output_addr_const (FILE, offset);\t\t\t\t\\\n-  if (base)\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"(%s)\", reg_names [REGNO (base)]);\t\t\\\n-}\n-\n-/* Define the codes that are matched by predicates in aux-output.c.  */\n-\n-#define PREDICATE_CODES \\\n-  {\"zero_memory_operand\", {SUBREG, MEM}},\t\t\t\\\n-  {\"short_memory_operand\", {SUBREG, MEM}},\t\t\t\\\n-  {\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\\\n-  {\"current_function_operand\", {MEM}},\t\t\t\t\\\n-  {\"constant_pool_address_operand\", {SUBREG, CONST}},\t\t\\\n-  {\"romp_symbolic_operand\", {LABEL_REF, SYMBOL_REF, CONST}},\t\\\n-  {\"constant_operand\", {LABEL_REF, SYMBOL_REF, PLUS, CONST, CONST_INT}}, \\\n-  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-  {\"reg_or_any_cint_operand\", {SUBREG, REG, CONST_INT}},\t\\\n-  {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"reg_or_D_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-  {\"reg_or_add_operand\", {SUBREG, REG, LABEL_REF, SYMBOL_REF,\t\\\n-\t\t\t  PLUS, CONST, CONST_INT}}, \t\t\\\n-  {\"reg_or_and_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-  {\"reg_or_mem_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-  {\"reg_or_nonsymb_mem_operand\", {SUBREG, REG, MEM}},\t\t\\\n-  {\"romp_operand\", {SUBREG, MEM, REG, CONST_INT, CONST, LABEL_REF, \\\n-\t\t    SYMBOL_REF, CONST_DOUBLE}},\t\t\t\\\n-  {\"reg_0_operand\", {REG}},\t\t\t\t\t\\\n-  {\"reg_15_operand\", {REG}},\t\t\t\t\t\\\n-  {\"float_binary\", {PLUS, MINUS, MULT, DIV}},\t\t\t\\\n-  {\"float_unary\", {NEG, ABS}},\t\t\t\t\t\\\n-  {\"float_conversion\", {FLOAT_TRUNCATE, FLOAT_EXTEND, FLOAT, FIX}},\n-"}, {"sha": "07da5f0748ec138fbe455a20c41b8b5f68d12113", "filename": "gcc/config/romp/romp.md", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fromp%2Fromp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fromp%2Fromp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.md?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "211fcd3212401eaab4b7117a07d163cdcbb83fc6", "filename": "gcc/config/rs6000/aix31.h", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Frs6000%2Faix31.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Frs6000%2Faix31.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix31.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "549e088fb8d0b9965c60e969b6b5ef06a9d7d2cd", "filename": "gcc/config/rs6000/aix3newas.h", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Frs6000%2Faix3newas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Frs6000%2Faix3newas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix3newas.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "6cd0305014431aa187b29b2e3dfa838591806f24", "filename": "gcc/config/rs6000/mach.h", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Frs6000%2Fmach.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Frs6000%2Fmach.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fmach.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "41f83081399a00d89c1cfa366c48f0cd2bf58099", "filename": "gcc/config/sparc/bsd.h", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fbsd.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "0222b819e0eb1e7ce57c387caa534f0e40b09b3f", "filename": "gcc/config/sparc/hal.h", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fhal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fhal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fhal.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "70b2c794b7d920cdbfbf47e0c25cd45ef717f7d4", "filename": "gcc/config/sparc/linux-aout.h", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Flinux-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Flinux-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux-aout.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "b1a6ef5f8f3530c733346f68c1cd4ae84807eadd", "filename": "gcc/config/sparc/lynx-ng.h", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Flynx-ng.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Flynx-ng.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flynx-ng.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "805f65f34e3d280f747bf666d104af47519ef306", "filename": "gcc/config/sparc/lynx.h", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Flynx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Flynx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flynx.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "284e288d5e41935e9e1fffd0782068e2d77525f6", "filename": "gcc/config/sparc/netbsd.h", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fnetbsd.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "74607d351654ce92968fd3b9d4190ff0e4a3be2f", "filename": "gcc/config/sparc/sp86x-aout.h", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsp86x-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsp86x-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp86x-aout.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "0d3f0546abe22480fff49e38c536988b2defcbad", "filename": "gcc/config/sparc/splet.h", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsplet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsplet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsplet.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "7f4f7dbbc803edfffc56eee157670047072160e7", "filename": "gcc/config/sparc/sun4gas.h", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsun4gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsun4gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsun4gas.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "e79a4c8d32901bb24735ca972bca7c443fd224a7", "filename": "gcc/config/sparc/sun4o3.h", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsun4o3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsun4o3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsun4o3.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "513251ce83684ff2bedfbc7f18fe90d7542ef233", "filename": "gcc/config/sparc/sunos4.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsunos4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Fsunos4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsunos4.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "5fc405bf62793a1683766682a264bad75430257a", "filename": "gcc/config/sparc/t-chorus-elf", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-chorus-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-chorus-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-chorus-elf?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "0bd5496ac238cee992ec83a7880ba2799855b77e", "filename": "gcc/config/sparc/t-halos", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-halos", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-halos", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-halos?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "bac38de9b794b5438326a01005bcdc45e600a351", "filename": "gcc/config/sparc/t-sparcbare", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-sparcbare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-sparcbare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-sparcbare?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "3334200dd64c63dfe951c22018c6dc0c5b4d699e", "filename": "gcc/config/sparc/t-splet", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-splet", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-splet", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-splet?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "1056d931f8a6430f4f2f46c9c2f7a29fb4542d3a", "filename": "gcc/config/sparc/t-sunos41", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-sunos41", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fsparc%2Ft-sunos41", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-sunos41?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}, {"sha": "c495214e0f71dd3fa982c0b16c4aa9e78a1808e7", "filename": "gcc/config/v850/rtems.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fv850%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ebc39a661502ac9ae1c14f11a41b05cb780896/gcc%2Fconfig%2Fv850%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Frtems.h?ref=a6ebc39a661502ac9ae1c14f11a41b05cb780896"}]}