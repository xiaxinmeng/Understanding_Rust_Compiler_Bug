{"sha": "2f4aa534294046582e026d67f9e74d01124b66cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY0YWE1MzQyOTQwNDY1ODJlMDI2ZDY3ZjllNzRkMDExMjRiNjZjYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-31T20:34:00Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-31T20:34:00Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1132", "tree": {"sha": "194f6145d51c6a5705565bb53e838692c8abe190", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/194f6145d51c6a5705565bb53e838692c8abe190"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f4aa534294046582e026d67f9e74d01124b66cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4aa534294046582e026d67f9e74d01124b66cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f4aa534294046582e026d67f9e74d01124b66cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4aa534294046582e026d67f9e74d01124b66cb/comments", "author": null, "committer": null, "parents": [{"sha": "8ac9cb56c48ae583e15311c4a7307eae42f87edc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ac9cb56c48ae583e15311c4a7307eae42f87edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ac9cb56c48ae583e15311c4a7307eae42f87edc"}], "stats": {"total": 106, "additions": 100, "deletions": 6}, "files": [{"sha": "20686f11c8ca23c49e15dd0d4e3ca8d3a98f9ba7", "filename": "gcc/calls.c", "status": "modified", "additions": 100, "deletions": 6, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f4aa534294046582e026d67f9e74d01124b66cb/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f4aa534294046582e026d67f9e74d01124b66cb/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2f4aa534294046582e026d67f9e74d01124b66cb", "patch": "@@ -87,6 +87,13 @@ static char *stack_usage_map;\n \n /* Size of STACK_USAGE_MAP.  */\n static int highest_outgoing_arg_in_use;\n+\n+/* stack_arg_under_construction is nonzero when an argument may be\n+   initialized with a constructor call (including a C function that\n+   returns a BLKmode struct) and expand_call must take special action\n+   to make sure the object being constructed does not overlap the\n+   argument list for the constructor call.  */\n+int stack_arg_under_construction;\n #endif\n \n static void store_one_arg ();\n@@ -468,6 +475,7 @@ expand_call (exp, target, ignore)\n \n   rtx old_stack_level = 0;\n   int old_pending_adj;\n+  int old_stack_arg_under_construction;\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n   tree old_cleanups = cleanups_this_call;\n \n@@ -576,6 +584,7 @@ expand_call (exp, target, ignore)\n   if (is_integrable)\n     {\n       rtx temp;\n+      rtx before_call = get_last_insn ();\n \n       temp = expand_inline_function (fndecl, actparms, target,\n \t\t\t\t     ignore, TREE_TYPE (exp),\n@@ -584,6 +593,39 @@ expand_call (exp, target, ignore)\n       /* If inlining succeeded, return.  */\n       if ((int) temp != -1)\n \t{\n+\t  int i;\n+\n+\t  /* If the outgoing argument list must be preserved, push\n+\t     the stack before executing the inlined function if it\n+\t     makes any calls.  */\n+\n+\t  for (i = reg_parm_stack_space - 1; i >= 0; i--)\n+\t    if (i < highest_outgoing_arg_in_use && stack_usage_map[i] != 0)\n+\t      break;\n+\n+\t  if (stack_arg_under_construction || i >= 0)\n+\t    {\n+\t      rtx insn, seq;\n+\n+\t      for (insn = NEXT_INSN (before_call); insn;\n+\t\t   insn = NEXT_INSN (insn))\n+\t\tif (GET_CODE (insn) == CALL_INSN)\n+\t\t  break;\n+\n+\t      if (insn)\n+\t\t{\n+\t\t  start_sequence ();\n+\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n+\t\t  allocate_dynamic_stack_space (gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t\t\t\t highest_outgoing_arg_in_use),\n+\t\t\t\t\t\t0, BITS_PER_UNIT);\n+\t\t  seq = get_insns ();\n+\t\t  end_sequence ();\n+\t\t  emit_insns_before (seq, NEXT_INSN (before_call));\n+\t\t  emit_stack_restore (SAVE_BLOCK, old_stack_level, 0);\n+\t\t}\n+\t    }\n+\n \t  /* Perform all cleanups needed for the arguments of this call\n \t     (i.e. destructors in C++).  It is ok if these destructors\n \t     clobber RETURN_VALUE_REG, because the only time we care about\n@@ -701,10 +743,15 @@ expand_call (exp, target, ignore)\n      as if it were an extra parameter.  */\n   if (structure_value_addr && struct_value_rtx == 0)\n     {\n+      /* If the stack will be adjusted, make sure the structure address\n+\t does not refer to virtual_outgoing_args_rtx.  */\n+      rtx temp = (stack_arg_under_construction\n+\t\t  ? copy_addr_to_reg (structure_value_addr)\n+\t\t  : force_reg (Pmode, structure_value_addr));\n       actparms\n \t= tree_cons (error_mark_node,\n \t\t     make_tree (build_pointer_type (TREE_TYPE (funtype)),\n-\t\t\t\tforce_reg (Pmode, structure_value_addr)),\n+\t\t\t\ttemp),\n \t\t     actparms);\n       structure_value_addr_parm = 1;\n     }\n@@ -1064,6 +1111,11 @@ expand_call (exp, target, ignore)\n \t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n \t  old_pending_adj = pending_stack_adjust;\n \t  pending_stack_adjust = 0;\n+\t  /* stack_arg_under_construction says whether a stack arg is\n+\t     being constructed at the old stack level.  Pushing the stack\n+\t     gets a clean outgoing argument block.  */\n+\t  old_stack_arg_under_construction = stack_arg_under_construction;\n+\t  stack_arg_under_construction = 0;\n \t}\n       argblock = push_block (ARGS_SIZE_RTX (args_size), 0, 0);\n     }\n@@ -1118,10 +1170,24 @@ expand_call (exp, target, ignore)\n \tbzero (&stack_usage_map[initial_highest_arg_in_use],\n \t       highest_outgoing_arg_in_use - initial_highest_arg_in_use);\n       needed = 0;\n-      /* No need to copy this virtual register; the space we're\n-\t using gets preallocated at the start of the function\n-\t so the stack pointer won't change here.  */\n+\n+      /* The only way the stack pointer can change here is if some arguments\n+\t which are passed in memory are constructed in place in the outgoing\n+\t argument area.  All objects which are constructed in place have\n+\t pass_on_stack == 1 (see store_one_arg ()).\n+\n+\t The test for arguments being constructed on the stack is just an\n+\t optimization: it would be correct but suboptimal to call\n+\t copy_addr_to_reg () unconditionally.  */\n+\n       argblock = virtual_outgoing_args_rtx;\n+      for (i = 0; i < num_actuals; i++)\n+\tif (args[i].pass_on_stack)\n+\t  {\n+\t    argblock = copy_addr_to_reg (argblock);\n+\t    break;\n+\t  }\n+\n #else /* not ACCUMULATE_OUTGOING_ARGS */\n       if (inhibit_defer_pop == 0)\n \t{\n@@ -1207,6 +1273,31 @@ expand_call (exp, target, ignore)\n #endif\n #endif\n \n+  /* The save/restore code in store_one_arg handles all cases except one:\n+     a constructor call (including a C function returning a BLKmode struct)\n+     to initialize an argument.  */\n+  if (stack_arg_under_construction)\n+    {\n+      rtx push_size = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t       highest_outgoing_arg_in_use);\n+      if (old_stack_level == 0)\n+\t{\n+\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, 0);\n+\t  old_pending_adj = pending_stack_adjust;\n+\t  pending_stack_adjust = 0;\n+\t  /* stack_arg_under_construction says whether a stack arg is\n+\t     being constructed at the old stack level.  Pushing the stack\n+\t     gets a clean outgoing argument block.  */\n+\t  old_stack_arg_under_construction = stack_arg_under_construction;\n+\t  stack_arg_under_construction = 0;\n+\t  /* Make a new map for the new argument list.  */\n+\t  stack_usage_map = (char *)alloca (highest_outgoing_arg_in_use);\n+\t  bzero (stack_usage_map, highest_outgoing_arg_in_use);\n+\t  highest_outgoing_arg_in_use = 0;\n+\t}\n+      allocate_dynamic_stack_space (push_size, 0, BITS_PER_UNIT);\n+    }\n+\n   /* Don't try to defer pops if preallocating, not even from the first arg,\n      since ARGBLOCK probably refers to the SP.  */\n   if (argblock)\n@@ -1537,14 +1628,17 @@ expand_call (exp, target, ignore)\n      (i.e. destructors in C++).  */\n   expand_cleanups_to (old_cleanups);\n \n-  /* If size of args is variable, restore saved stack-pointer value.  */\n+  /* If size of args is variable or this was a constructor call for a stack\n+     argument, restore saved stack-pointer value.  */\n \n   if (old_stack_level)\n     {\n       emit_stack_restore (SAVE_BLOCK, old_stack_level, 0);\n       pending_stack_adjust = old_pending_adj;\n+      stack_arg_under_construction = old_stack_arg_under_construction;\n+      highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n+      stack_usage_map = initial_stack_usage_map;\n     }\n-\n #ifdef ACCUMULATE_OUTGOING_ARGS\n   else\n     {"}]}