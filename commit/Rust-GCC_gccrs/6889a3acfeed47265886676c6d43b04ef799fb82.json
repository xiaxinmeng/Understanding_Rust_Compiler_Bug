{"sha": "6889a3acfeed47265886676c6d43b04ef799fb82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg4OWEzYWNmZWVkNDcyNjU4ODY2NzZjNmQ0M2IwNGVmNzk5ZmI4Mg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-09-19T22:15:34Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-09-19T22:15:34Z"}, "message": "PR middle-end/91631 - buffer overflow into an array member of a declared object not detected\n\ngcc/ChangeLog:\n\n\tPR middle-end/91631\n\t* builtins.c (component_size): Correct trailing array computation,\n\trename to component_ref_size and move...\n\t(compute_objsize): Adjust.\n\t* gimple-ssa-warn-restrict.c (builtin_memref::refsize): New member.\n\t(builtin_access::strict): Do not consider mememmove.\n\t(builtin_access::write_off): New function.\n\t(builtin_memref::builtin_memref): Initialize refsize.\n\t(builtin_memref::set_base_and_offset): Adjust refoff and compute\n\trefsize.\n\t(builtin_memref::offset_out_of_bounds): Use ooboff input values.\n\tHandle refsize.\n\t(builtin_access::builtin_access): Intialize dstoff to destination\n\trefeence offset here instead of in maybe_diag_overlap.  Adjust\n\treferencess even to unrelated objects.\tAdjust sizrange of bounded\n\tstring functions to reflect bound.  For strcat, adjust destination\n\tsizrange by that of source.\n\t(builtin_access::strcat_overlap):  Adjust offsets and sizes\n\tto reflect the increase in destination sizrange above.\n\t(builtin_access::overlap): Do not set dstoff here but instead\n\tin builtin_access::builtin_access.\n\t(check_bounds_or_overlap): Use builtin_access::write_off.\n\t(maybe_diag_access_bounds): Add argument.  Add informational notes.\n\t(dump_builtin_memref, dump_builtin_access): New functions.\n\t* tree.c (component_ref_size): ...to here.\n\t* tree.h (component_ref_size): Declare.\n\t* tree-ssa-strlen (handle_builtin_strcat): Include the terminating\n\tnul in the size of the source string.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/91631\n\t* /c-c++-common/Warray-bounds-3.c: Correct expected offsets.\n\t* /c-c++-common/Warray-bounds-4.c: Same.\n\t* gcc.dg/Warray-bounds-39.c: Remove xfails.\n\t* gcc.dg/Warray-bounds-45.c: New test.\n\t* gcc.dg/Warray-bounds-46.c: New test.\n\nFrom-SVN: r275981", "tree": {"sha": "8101bfd6fc153a6707fc453e76507f09e0916c46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8101bfd6fc153a6707fc453e76507f09e0916c46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6889a3acfeed47265886676c6d43b04ef799fb82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6889a3acfeed47265886676c6d43b04ef799fb82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6889a3acfeed47265886676c6d43b04ef799fb82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6889a3acfeed47265886676c6d43b04ef799fb82/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d112d6670a0e0e662f8a7e64c33686e475832c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d112d6670a0e0e662f8a7e64c33686e475832c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d112d6670a0e0e662f8a7e64c33686e475832c8"}], "stats": {"total": 1139, "additions": 983, "deletions": 156}, "files": [{"sha": "9dfb64643c1faf83d0d828746282891d666c64df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -1,3 +1,34 @@\n+2019-09-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91631\n+\t* builtins.c (component_size): Correct trailing array computation,\n+\trename to component_ref_size and move...\n+\t(compute_objsize): Adjust.\n+\t* gimple-ssa-warn-restrict.c (builtin_memref::refsize): New member.\n+\t(builtin_access::strict): Do not consider memmove.\n+\t(builtin_access::write_off): New function.\n+\t(builtin_memref::builtin_memref): Initialize refsize.\n+\t(builtin_memref::set_base_and_offset): Adjust refoff and compute\n+\trefsize.\n+\t(builtin_memref::offset_out_of_bounds): Use ooboff input values.\n+\tHandle refsize.\n+\t(builtin_access::builtin_access): Initialize dstoff to destination\n+\trefeence offset here instead of in maybe_diag_overlap.  Adjust\n+\treferencess even to unrelated objects.\tAdjust sizrange of bounded\n+\tstring functions to reflect bound.  For strcat, adjust destination\n+\tsizrange by that of source.\n+\t(builtin_access::strcat_overlap):  Adjust offsets and sizes\n+\tto reflect the increase in destination sizrange above.\n+\t(builtin_access::overlap): Do not set dstoff here but instead\n+\tin builtin_access::builtin_access.\n+\t(check_bounds_or_overlap): Use builtin_access::write_off.\n+\t(maybe_diag_access_bounds): Add argument.  Add informational notes.\n+\t(dump_builtin_memref, dump_builtin_access): New functions.\n+\t* tree.c (component_ref_size): ...to here.\n+\t* tree.h (component_ref_size): Declare.\n+\t* tree-ssa-strlen (handle_builtin_strcat): Include the terminating\n+\tnul in the size of the source string.\n+\n 2019-09-19  Lewis Hyatt  <lhyatt@gmail.com>\n \n \tPR c/67224"}, {"sha": "1fd4b88bcacd511a3bccdcacb041ff67469a6f53", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -3562,54 +3562,6 @@ check_access (tree exp, tree, tree, tree dstwrite,\n   return true;\n }\n \n-/* Determines the size of the member referenced by the COMPONENT_REF\n-   REF, using its initializer expression if necessary in order to\n-   determine the size of an initialized flexible array member.\n-   Returns the size (which might be zero for an object with\n-   an uninitialized flexible array member) or null if the size\n-   cannot be determined.  */\n-\n-static tree\n-component_size (tree ref)\n-{\n-  gcc_assert (TREE_CODE (ref) == COMPONENT_REF);\n-\n-  tree member = TREE_OPERAND (ref, 1);\n-\n-  /* If the member is not last or has a size greater than one, return\n-     it.  Otherwise it's either a flexible array member or a zero-length\n-     array member, or an array of length one treated as such.  */\n-  tree size = DECL_SIZE_UNIT (member);\n-  if (size\n-      && (!array_at_struct_end_p (ref)\n-\t  || (!integer_zerop (size)\n-\t      && !integer_onep (size))))\n-    return size;\n-\n-  /* If the reference is to a declared object and the member a true\n-     flexible array, try to determine its size from its initializer.  */\n-  poly_int64 off = 0;\n-  tree base = get_addr_base_and_unit_offset (ref, &off);\n-  if (!base || !VAR_P (base))\n-    return NULL_TREE;\n-\n-  /* The size of any member of a declared object other than a flexible\n-     array member is that obtained above.  */\n-  if (size)\n-    return size;\n-\n-  if (tree init = DECL_INITIAL (base))\n-    if (TREE_CODE (init) == CONSTRUCTOR)\n-      {\n-\toff <<= LOG2_BITS_PER_UNIT;\n-\tinit = fold_ctor_reference (NULL_TREE, init, off, 0, base);\n-\tif (init)\n-\t  return TYPE_SIZE_UNIT (TREE_TYPE (init));\n-      }\n-\n-  return DECL_EXTERNAL (base) ? NULL_TREE : integer_zero_node;\n-}\n-\n /* Helper to compute the size of the object referenced by the DEST\n    expression which must have pointer type, using Object Size type\n    OSTYPE (only the least significant 2 bits are used).  Return\n@@ -3744,7 +3696,7 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */)\n   if (TREE_CODE (dest) == COMPONENT_REF)\n     {\n       *pdecl = TREE_OPERAND (dest, 1);\n-      return component_size (dest);\n+      return component_ref_size (dest);\n     }\n \n   if (TREE_CODE (dest) != ADDR_EXPR)"}, {"sha": "4f6e535ff277ad00181bb67c2212e4f022adeacf", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 263, "deletions": 85, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -137,6 +137,8 @@ class builtin_memref\n   /* The size of the BASE object, PTRDIFF_MAX if indeterminate,\n      and negative until (possibly lazily) initialized.  */\n   offset_int basesize;\n+  /* Same for the subobject.  */\n+  offset_int refsize;\n \n   /* The non-negative offset of the referenced subobject.  Used to avoid\n      warnings for (apparently) possibly but not definitively overlapping\n@@ -160,7 +162,7 @@ class builtin_memref\n \n   builtin_memref (tree, tree);\n \n-  tree offset_out_of_bounds (int, offset_int[2]) const;\n+  tree offset_out_of_bounds (int, offset_int[3]) const;\n \n private:\n \n@@ -192,14 +194,19 @@ class builtin_access\n      and false for raw memory functions.  */\n   bool strict () const\n   {\n-    return detect_overlap != &builtin_access::generic_overlap;\n+    return (detect_overlap != &builtin_access::generic_overlap\n+\t    && detect_overlap != &builtin_access::no_overlap);\n   }\n \n   builtin_access (gimple *, builtin_memref &, builtin_memref &);\n \n   /* Entry point to determine overlap.  */\n   bool overlap ();\n \n+  offset_int write_off (tree) const;\n+\n+  void dump (FILE *) const;\n+\n  private:\n   /* Implementation functions used to determine overlap.  */\n   bool generic_overlap ();\n@@ -234,6 +241,7 @@ builtin_memref::builtin_memref (tree expr, tree size)\n   ref (),\n   base (),\n   basesize (-1),\n+  refsize (-1),\n   refoff (HOST_WIDE_INT_MIN),\n   offrange (),\n   sizrange (),\n@@ -298,6 +306,19 @@ builtin_memref::builtin_memref (tree expr, tree size)\n     }\n }\n \n+/* Based on the initial length of the destination STARTLEN, returns\n+   the offset of the first write access from the beginning of\n+   the destination.  Nonzero only for strcat-type of calls.  */\n+\n+offset_int builtin_access::write_off (tree startlen) const\n+{\n+  if (detect_overlap != &builtin_access::strcat_overlap\n+      || !startlen || TREE_CODE (startlen) != INTEGER_CST)\n+    return 0;\n+\n+  return wi::to_offset (startlen);\n+}\n+\n /* Ctor helper to set or extend OFFRANGE based on the OFFSET argument.\n    Pointer offsets are represented as unsigned sizetype but must be\n    treated as signed.  */\n@@ -483,33 +504,69 @@ builtin_memref::set_base_and_offset (tree expr)\n \n   if (TREE_CODE (base) == MEM_REF)\n     {\n-      tree memrefoff = TREE_OPERAND (base, 1);\n+      tree memrefoff = fold_convert (ptrdiff_type_node, TREE_OPERAND (base, 1));\n       extend_offset_range (memrefoff);\n       base = TREE_OPERAND (base, 0);\n+\n+      if (refoff != HOST_WIDE_INT_MIN\n+      \t  && TREE_CODE (expr) == COMPONENT_REF)\n+      \t{\n+\t  /* Bump up the offset of the referenced subobject to reflect\n+\t     the offset to the enclosing object.  For example, so that\n+\t     in\n+\t       struct S { char a, b[3]; } s[2];\n+\t       strcpy (s[1].b, \"1234\");\n+\t     REFOFF is set to s[1].b - (char*)s.  */\n+      \t  tree basetype = TREE_TYPE (TREE_TYPE (base));\n+\t  if (tree basesize = TYPE_SIZE_UNIT (basetype))\n+\t    if (TREE_CODE (basesize) == INTEGER_CST)\n+\t      {\n+\t\toffset_int size = wi::to_offset (basesize);\n+\t\toffset_int off = tree_to_shwi (memrefoff);\n+\t\trefoff += size * (off / size);\n+\t      }\n+      \t}\n+\n+      if (!integer_zerop (memrefoff))\n+\t/* A non-zero offset into an array of struct with flexible array\n+\t   members implies that the array is empty because there is no\n+\t   way to initialize such a member when it belongs to an array.\n+\t   This must be some sort of a bug.  */\n+\trefsize = 0;\n     }\n \n+  if (TREE_CODE (ref) == COMPONENT_REF)\n+    if (tree size = component_ref_size (ref))\n+      if (TREE_CODE (size) == INTEGER_CST)\n+\trefsize = wi::to_offset (size);\n+\n   if (TREE_CODE (base) == SSA_NAME)\n     set_base_and_offset (base);\n }\n \n /* Return error_mark_node if the signed offset exceeds the bounds\n-   of the address space (PTRDIFF_MAX).  Otherwise, return either\n-   BASE or REF when the offset exceeds the bounds of the BASE or\n-   REF object, and set OOBOFF to the past-the-end offset formed\n-   by the reference, including its size.  When STRICT is non-zero\n-   use REF size, when available, otherwise use BASE size.  When\n-   STRICT is greater than 1, use the size of the last array member\n-   as the bound, otherwise treat such a member as a flexible array\n-   member.  Return NULL when the offset is in bounds.  */\n+   of the address space (PTRDIFF_MAX).  Otherwise, return either BASE\n+   or REF when the offset exceeds the bounds of the BASE or REF object,\n+   and set OOBOFF to the past-the-end offset formed by the reference,\n+   including its size.  OOBOFF is initially setto the range of offsets,\n+   and OOBOFF[2] to the offset of the first write access (nonzero for\n+   the strcat family).  When STRICT is nonzero use REF size, when\n+   available, otherwise use BASE size.  When STRICT is greater than 1,\n+   use the size of the last array member as the bound, otherwise treat\n+   such a member as a flexible array member.  Return NULL when the offset\n+   is in bounds.  */\n \n tree\n-builtin_memref::offset_out_of_bounds (int strict, offset_int ooboff[2]) const\n+builtin_memref::offset_out_of_bounds (int strict, offset_int ooboff[3]) const\n {\n   if (!ptr)\n     return NULL_TREE;\n \n+  /* The offset of the first write access or zero.  */\n+  offset_int wroff = ooboff[2];\n+\n   /* A temporary, possibly adjusted, copy of the offset range.  */\n-  offset_int offrng[2] = { offrange[0], offrange[1] };\n+  offset_int offrng[2] = { ooboff[0], ooboff[1] };\n \n   if (DECL_P (base) && TREE_CODE (TREE_TYPE (base)) == ARRAY_TYPE)\n     {\n@@ -527,9 +584,19 @@ builtin_memref::offset_out_of_bounds (int strict, offset_int ooboff[2]) const\n   bool hib = wi::les_p (offrng[0], offrng[1]);\n   bool lob = !hib;\n \n+  /* Set to the size remaining in the object object after subtracting\n+     REFOFF.  It may become negative as a result of negative indices\n+     into the enclosing object, such as in:\n+       extern struct S { char a[4], b[3], c[1]; } *p;\n+       strcpy (p[-3].b, \"123\");  */\n+  offset_int size = basesize;\n+  tree obj = base;\n+\n+  const bool decl_p = DECL_P (obj);\n+\n   if (basesize < 0)\n     {\n-      endoff = offrng[lob] + sizrange[0];\n+      endoff = offrng[lob] + (sizrange[0] - wroff);\n \n       /* For a reference through a pointer to an object of unknown size\n \t all initial offsets are considered valid, positive as well as\n@@ -539,54 +606,58 @@ builtin_memref::offset_out_of_bounds (int strict, offset_int ooboff[2]) const\n       if (endoff > maxobjsize)\n \treturn error_mark_node;\n \n-      return NULL_TREE;\n+      /* When the referenced subobject is known, the end offset must be\n+\t within its bounds.  Otherwise there is nothing to do.  */\n+      if (strict\n+\t  && !decl_p\n+\t  && ref\n+\t  && refsize >= 0\n+\t  && TREE_CODE (ref) == COMPONENT_REF)\n+\t{\n+\t  /* If REFOFF is negative, SIZE will become negative here.  */\n+\t  size = refoff + refsize;\n+\t  obj = ref;\n+\t}\n+      else\n+\treturn NULL_TREE;\n     }\n \n   /* A reference to an object of known size must be within the bounds\n-     of the base object.  */\n-  if (offrng[hib] < 0 || offrng[lob] > basesize)\n-    return base;\n+     of either the base object or the subobject (see above for when\n+     a subobject can be used).  */\n+  if ((decl_p && offrng[hib] < 0) || offrng[lob] > size)\n+    return obj;\n \n   /* The extent of the reference must also be within the bounds of\n-     the base object (if known) or the maximum object size otherwise.  */\n-  endoff = wi::smax (offrng[lob], 0) + sizrange[0];\n+     the base object (if known) or the subobject or the maximum object\n+     size otherwise.  */\n+  endoff = offrng[lob] + sizrange[0];\n   if (endoff > maxobjsize)\n     return error_mark_node;\n \n-  offset_int size = basesize;\n-  tree obj = base;\n-\n   if (strict\n-      && DECL_P (obj)\n+      && decl_p\n       && ref\n-      && refoff >= 0\n-      && TREE_CODE (ref) == COMPONENT_REF\n-      && (strict > 1\n-\t  || !array_at_struct_end_p (ref)))\n+      && refsize >= 0\n+      && TREE_CODE (ref) == COMPONENT_REF)\n     {\n-      /* If the reference is to a member subobject, the offset must\n-\t be within the bounds of the subobject.  */\n-      tree field = TREE_OPERAND (ref, 1);\n-      tree type = TREE_TYPE (field);\n-      if (tree sz = TYPE_SIZE_UNIT (type))\n-\tif (TREE_CODE (sz) == INTEGER_CST)\n-\t  {\n-\t    size = refoff + wi::to_offset (sz);\n-\t    obj = ref;\n-\t  }\n+      /* If the reference is to a member subobject of a declared object,\n+\t the offset must be within the bounds of the subobject.  */\n+      size = refoff + refsize;\n+      obj = ref;\n     }\n \n   if (endoff <= size)\n     return NULL_TREE;\n \n   /* Set the out-of-bounds offset range to be one greater than\n      that delimited by the reference including its size.  */\n-  ooboff[lob] = size + 1;\n+  ooboff[lob] = size;\n \n   if (endoff > ooboff[lob])\n-    ooboff[hib] = endoff;\n+    ooboff[hib] = endoff - 1;\n   else\n-    ooboff[hib] = wi::smax (offrng[lob], 0) + sizrange[1];\n+    ooboff[hib] = offrng[lob] + sizrange[1];\n \n   return obj;\n }\n@@ -599,8 +670,10 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n : dstref (&dst), srcref (&src), sizrange (), ovloff (), ovlsiz (),\n   dstoff (), srcoff (), dstsiz (), srcsiz ()\n {\n+  dstoff[0] = dst.offrange[0];\n+  dstoff[1] = dst.offrange[1];\n+\n   /* Zero out since the offset_int ctors invoked above are no-op.  */\n-  dstoff[0] = dstoff[1] = 0;\n   srcoff[0] = srcoff[1] = 0;\n   dstsiz[0] = dstsiz[1] = 0;\n   srcsiz[0] = srcsiz[1] = 0;\n@@ -716,15 +789,9 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n \tsrc.basesize = maxobjsize;\n     }\n \n-  /* If there is no dependency between the references or the base\n-     objects of the two references aren't the same there's nothing\n-     else to do.  */\n-  if (depends_p && dstref->base != srcref->base)\n-    return;\n-\n-  /* ...otherwise, make adjustments for references to the same object\n-     by string built-in functions to reflect the constraints imposed\n-     by the function.  */\n+  /* Make adjustments for references to the same object by string\n+     built-in functions to reflect the constraints imposed by\n+     the function.  */\n \n   /* For bounded string functions determine the range of the bound\n      on the access.  For others, the range stays unbounded.  */\n@@ -755,6 +822,7 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n \t}\n     }\n \n+  bool dstsize_set = false;\n   /* The size range of one reference involving the same base object\n      can be determined from the size range of the other reference.\n      This makes it possible to compute accurate offsets for warnings\n@@ -766,6 +834,7 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n \t the source.  */\n       dstref->sizrange[0] = srcref->sizrange[0];\n       dstref->sizrange[1] = srcref->sizrange[1];\n+      dstsize_set = true;\n     }\n   else if (srcref->sizrange[0] == 0 && srcref->sizrange[1] == maxobjsize)\n     {\n@@ -778,11 +847,15 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n \t{\n \t  if (dstref->strbounded_p)\n \t    {\n-\t      /* Read access by strncpy is bounded.  */\n-\t      if (bounds[0] < srcref->sizrange[0])\n-\t\tsrcref->sizrange[0] = bounds[0];\n-\t      if (bounds[1] < srcref->sizrange[1])\n-\t\tsrcref->sizrange[1] = bounds[1];\n+\t      /* Read access by strncpy is constrained by the third\n+\t\t argument but except for a zero bound is at least one.  */\n+\t      offset_int size = wi::umax (srcref->basesize, 1);\n+\t      offset_int bound = wi::umin (size, bounds[0]);\n+\t      if (bound < srcref->sizrange[0])\n+\t\tsrcref->sizrange[0] = bound;\n+\t      bound = wi::umin (srcref->basesize, bounds[1]);\n+\t      if (bound < srcref->sizrange[1])\n+\t\tsrcref->sizrange[1] = bound;\n \t    }\n \n \t  /* For string functions, adjust the size range of the source\n@@ -834,6 +907,11 @@ builtin_access::builtin_access (gimple *call, builtin_memref &dst,\n \t    }\n \t}\n     }\n+  else if (!dstsize_set && detect_overlap == &builtin_access::strcat_overlap)\n+    {\n+      dstref->sizrange[0] += srcref->sizrange[0] - 1;\n+      dstref->sizrange[1] += srcref->sizrange[1] - 1;\n+    }\n \n   if (dstref->strbounded_p)\n     {\n@@ -1108,10 +1186,11 @@ builtin_access::strcat_overlap ()\n   /* Adjust for strcat-like accesses.  */\n \n   /* As a special case for strcat, set the DSTREF offsets to the length\n-     of the source string since the function starts writing at the first\n-     nul, and set the size to 1 for the length of the nul.  */\n-  acs.dstoff[0] += acs.dstsiz[0];\n-  acs.dstoff[1] += acs.dstsiz[1];\n+     of the destination string since the function starts writing over\n+     its terminating nul, and set the destination size to 1 for the length\n+     of the nul.  */\n+  acs.dstoff[0] += dstsiz[0] - srcref->sizrange[0];\n+  acs.dstoff[1] += dstsiz[1] - srcref->sizrange[1];\n \n   bool strfunc_unknown_args = acs.dstsiz[0] == 0 && acs.dstsiz[1] != 0;\n \n@@ -1189,7 +1268,8 @@ builtin_access::strcat_overlap ()\n   acs.ovlsiz[0] = dstref->sizrange[0] == dstref->sizrange[1] ? 1 : 0;\n   acs.ovlsiz[1] = 1;\n \n-  offset_int endoff = dstref->offrange[0] + dstref->sizrange[0];\n+  offset_int endoff\n+    = dstref->offrange[0] + (dstref->sizrange[0] - srcref->sizrange[0]);\n   if (endoff <= srcref->offrange[0])\n     acs.ovloff[0] = wi::smin (maxobjsize, srcref->offrange[0]).to_shwi ();\n   else\n@@ -1261,10 +1341,6 @@ builtin_access::overlap ()\n   if (!dstref->base || !srcref->base)\n     return false;\n \n-  /* Set the access offsets.  */\n-  acs.dstoff[0] = dstref->offrange[0];\n-  acs.dstoff[1] = dstref->offrange[1];\n-\n   /* If the base object is an array adjust the bounds of the offset\n      to be non-negative and within the bounds of the array if possible.  */\n   if (dstref->base\n@@ -1626,7 +1702,8 @@ maybe_diag_overlap (location_t loc, gimple *call, builtin_access &acs)\n \n static bool\n maybe_diag_access_bounds (location_t loc, gimple *call, tree func, int strict,\n-\t\t\t  const builtin_memref &ref, bool do_warn)\n+\t\t\t  const builtin_memref &ref, offset_int wroff,\n+\t\t\t  bool do_warn)\n {\n   const offset_int maxobjsize = ref.maxobjsize;\n \n@@ -1665,8 +1742,12 @@ maybe_diag_access_bounds (location_t loc, gimple *call, tree func, int strict,\n     }\n \n   /* Check for out-bounds pointers regardless of warning options since\n-     the result is used to make codegen decisions.  */\n-  offset_int ooboff[] = { ref.offrange[0], ref.offrange[1] };\n+     the result is used to make codegen decisions.  An excessive WROFF\n+     can only come up as a result of an invalid strncat bound and is\n+     diagnosed separately using a more meaningful warning.  */\n+  if (maxobjsize < wroff)\n+    wroff = 0;\n+  offset_int ooboff[] = { ref.offrange[0], ref.offrange[1], wroff };\n   tree oobref = ref.offset_out_of_bounds (strict, ooboff);\n   if (!oobref)\n     return false;\n@@ -1787,27 +1868,45 @@ maybe_diag_access_bounds (location_t loc, gimple *call, tree func, int strict,\n     }\n   else if (TREE_CODE (ref.ref) == MEM_REF)\n     {\n-      tree type = TREE_TYPE (TREE_OPERAND (ref.ref, 0));\n+      tree refop = TREE_OPERAND (ref.ref, 0);\n+      tree type = TREE_TYPE (refop);\n       if (POINTER_TYPE_P (type))\n \ttype = TREE_TYPE (type);\n       type = TYPE_MAIN_VARIANT (type);\n \n-      warned = warning_at (loc, OPT_Warray_bounds,\n-\t\t\t   \"%G%qD offset %s from the object at %qE is out \"\n-\t\t\t   \"of the bounds of %qT\",\n-\t\t\t   call, func, rangestr[0], ref.base, type);\n+      if (warning_at (loc, OPT_Warray_bounds,\n+\t\t      \"%G%qD offset %s from the object at %qE is out \"\n+\t\t      \"of the bounds of %qT\",\n+\t\t      call, func, rangestr[0], ref.base, type))\n+\t{\n+\t  if (TREE_CODE (ref.ref) == COMPONENT_REF)\n+\t    refop = TREE_OPERAND (ref.ref, 1);\n+\t  if (DECL_P (refop))\n+\t    inform (DECL_SOURCE_LOCATION (refop),\n+\t\t    \"subobject %qD declared here\", refop);\n+\t  warned = true;\n+\t}\n     }\n   else\n     {\n+      tree refop = TREE_OPERAND (ref.ref, 0);\n       tree type = TYPE_MAIN_VARIANT (TREE_TYPE (ref.ref));\n \n-      warned = warning_at (loc, OPT_Warray_bounds,\n-\t\t\t   \"%G%qD offset %s from the object at %qE is out \"\n-\t\t\t   \"of the bounds of referenced subobject %qD with \"\n-\t\t\t   \"type %qT at offset %wu\",\n-\t\t\t   call, func, rangestr[0], ref.base,\n-\t\t\t   TREE_OPERAND (ref.ref, 1), type,\n-\t\t\t   ref.refoff.to_uhwi ());\n+      if (warning_at (loc, OPT_Warray_bounds,\n+\t\t      \"%G%qD offset %s from the object at %qE is out \"\n+\t\t      \"of the bounds of referenced subobject %qD with \"\n+\t\t      \"type %qT at offset %wi\",\n+\t\t      call, func, rangestr[0], ref.base,\n+\t\t      TREE_OPERAND (ref.ref, 1), type,\n+\t\t      ref.refoff.to_shwi ()))\n+\t{\n+\t  if (TREE_CODE (ref.ref) == COMPONENT_REF)\n+\t    refop = TREE_OPERAND (ref.ref, 1);\n+\t  if (DECL_P (refop))\n+\t    inform (DECL_SOURCE_LOCATION (refop),\n+\t\t    \"subobject %qD declared here\", refop);\n+\t  warned = true;\n+\t}\n     }\n \n   return warned;\n@@ -1936,17 +2035,23 @@ check_bounds_or_overlap (gimple *call, tree dst, tree src, tree dstsize,\n   builtin_memref dstref (dst, dstsize);\n   builtin_memref srcref (src, srcsize);\n \n+  /* Create a descriptor of the access.  This may adjust both DSTREF\n+     and SRCREF based on one another and the kind of the access.  */\n   builtin_access acs (call, dstref, srcref);\n \n   /* Set STRICT to the value of the -Warray-bounds=N argument for\n      string functions or when N > 1.  */\n   int strict = (acs.strict () || warn_array_bounds > 1 ? warn_array_bounds : 0);\n \n-  /* Validate offsets first to make sure they are within the bounds\n-     of the destination object if its size is known, or PTRDIFF_MAX\n-     otherwise.  */\n-  if (maybe_diag_access_bounds (loc, call, func, strict, dstref, do_warn)\n-      || maybe_diag_access_bounds (loc, call, func, strict, srcref, do_warn))\n+  /* The starting offset of the destination write access.  Nonzero only\n+     for the strcat family of functions.  */\n+  offset_int wroff = acs.write_off (dstsize);\n+\n+  /* Validate offsets to each reference before the access first to make\n+     sure they are within the bounds of the destination object if its\n+     size is known, or PTRDIFF_MAX otherwise.  */\n+  if (maybe_diag_access_bounds (loc, call, func, strict, dstref, wroff, do_warn)\n+      || maybe_diag_access_bounds (loc, call, func, strict, srcref, 0, do_warn))\n     {\n       if (do_warn)\n \tgimple_set_no_warning (call, true);\n@@ -2003,3 +2108,76 @@ make_pass_warn_restrict (gcc::context *ctxt)\n {\n   return new pass_wrestrict (ctxt);\n }\n+\n+DEBUG_FUNCTION void\n+dump_builtin_memref (FILE *fp, const builtin_memref &ref)\n+{\n+  fprintf (fp, \"\\n    ptr = \");\n+  print_generic_expr (fp, ref.ptr, TDF_LINENO);\n+  fprintf (fp, \"\\n    ref = \");\n+  if (ref.ref)\n+    print_generic_expr (fp, ref.ref, TDF_LINENO);\n+  else\n+    fputs (\"null\", fp);\n+  fprintf (fp, \"\\n    base = \");\n+  print_generic_expr (fp, ref.base, TDF_LINENO);\n+  fprintf (fp,\n+\t   \"\\n    basesize = %lli\"\n+\t   \"\\n    refsize = %lli\"\n+\t   \"\\n    refoff = %lli\"\n+\t   \"\\n    offrange = [%lli, %lli]\"\n+\t   \"\\n    sizrange = [%lli, %lli]\"\n+\t   \"\\n    strbounded_p = %s\\n\",\n+\t   (long long)ref.basesize.to_shwi (),\n+\t   (long long)ref.refsize.to_shwi (),\n+\t   (long long)ref.refoff.to_shwi (),\n+\t   (long long)ref.offrange[0].to_shwi (),\n+\t   (long long)ref.offrange[1].to_shwi (),\n+\t   (long long)ref.sizrange[0].to_shwi (),\n+\t   (long long)ref.sizrange[1].to_shwi (),\n+\t   ref.strbounded_p ? \"true\" : \"false\");\n+}\n+\n+void\n+builtin_access::dump (FILE *fp) const\n+{\n+  fprintf (fp, \"  dstref:\");\n+  dump_builtin_memref (fp, *dstref);\n+  fprintf (fp, \"\\n  srcref:\");\n+  dump_builtin_memref (fp, *srcref);\n+\n+  fprintf (fp,\n+\t   \"  sizrange = [%lli, %lli]\\n\"\n+\t   \"  ovloff = [%lli, %lli]\\n\"\n+\t   \"  ovlsiz = [%lli, %lli]\\n\"\n+\t   \"  dstoff = [%lli, %lli]\\n\"\n+\t   \"  dstsiz = [%lli, %lli]\\n\"\n+\t   \"  srcoff = [%lli, %lli]\\n\"\n+\t   \"  srcsiz = [%lli, %lli]\\n\",\n+\t   (long long)sizrange[0], (long long)sizrange[1],\n+\t   (long long)ovloff[0], (long long)ovloff[1],\n+\t   (long long)ovlsiz[0], (long long)ovlsiz[1],\n+\t   (long long)dstoff[0].to_shwi (), (long long)dstoff[1].to_shwi (),\n+\t   (long long)dstsiz[0].to_shwi (), (long long)dstsiz[1].to_shwi (),\n+\t   (long long)srcoff[0].to_shwi (), (long long)srcoff[1].to_shwi (),\n+\t   (long long)srcsiz[0].to_shwi (), (long long)srcsiz[1].to_shwi ());\n+}\n+\n+DEBUG_FUNCTION void\n+dump_builtin_access (FILE *fp, gimple *stmt, const builtin_access &acs)\n+{\n+  if (stmt)\n+    {\n+      fprintf (fp, \"\\nDumping builtin_access for \");\n+      print_gimple_expr (fp, stmt, TDF_LINENO);\n+      fputs (\":\\n\", fp);\n+    }\n+\n+  acs.dump (fp);\n+}\n+\n+DEBUG_FUNCTION void\n+debug (gimple *stmt, const builtin_access &acs)\n+{\n+  dump_builtin_access (stdout, stmt, acs);\n+}"}, {"sha": "c230b2a545e660e962fdee92f54260898bfb6e57", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -1,3 +1,12 @@\n+2019-09-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/91631\n+\t* /c-c++-common/Warray-bounds-3.c: Correct expected offsets.\n+\t* /c-c++-common/Warray-bounds-4.c: Same.\n+\t* gcc.dg/Warray-bounds-39.c: Remove xfails.\n+\t* gcc.dg/Warray-bounds-45.c: New test.\n+\t* gcc.dg/Warray-bounds-46.c: New test.\n+\n 2019-09-19  Lewis Hyatt  <lhyatt@gmail.com>\n \n \tPR c/67224"}, {"sha": "ab84c60262516a840740991f082e9bf97795b237", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-3.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -115,7 +115,7 @@ void test_memcpy_bounds_anti_range (char *d, const char *s, size_t n)\n      offset, i.e., 7 + 3.  Including the whole final range because would be\n      confusing (the upper bound would either be negative or a very large\n      positive number) so only the lower bound is included.  */\n-  T (char, 9, a, a + SAR ( 0,  6), 3);   /* { dg-warning \"forming offset 10 is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a, a + SAR ( 0,  6), 3);   /* { dg-warning \"forming offset 9 is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n \n   /* This fails because the offset isn't represented as an SSA_NAME\n      but rather as a GIMPLE_PHI (offset, 0).  With some effort it is\n@@ -129,18 +129,18 @@ void test_memcpy_bounds_anti_range (char *d, const char *s, size_t n)\n   T (char, 9, a, a + SAR ( 2,  6), 3);\n   T (char, 9, a, a + SAR ( 3,  6), 3);\n \n-  T (char, 9, a, a + SAR (-1,  7), 3);   /* { dg-warning \"forming offset \\\\\\[10, 11] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n-  T (char, 9, a, a + SAR (-2,  8), 3);   /* { dg-warning \"forming offset \\\\\\[10, 12] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n-  T (char, 9, a, a + SAR (-3,  7), 5);   /* { dg-warning \"forming offset \\\\\\[10, 13] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a, a + SAR (-1,  7), 3);   /* { dg-warning \"forming offset \\\\\\[9, 10] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a, a + SAR (-2,  8), 3);   /* { dg-warning \"offset \\\\\\[9, 11] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a, a + SAR (-3,  7), 5);   /* { dg-warning \"forming offset \\\\\\[9, 12] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n \n   T (char, 9, a + SAR (-2, -1), a, 3);\n   T (char, 9, a + SAR (-1,  1), a, 3);\n   T (char, 9, a + SAR ( 0,  1), a, 3);\n   T (char, 9, a + SAR ( 0,  2), a, 3);\n   T (char, 9, a + SAR ( 0,  3), a, 3);\n-  T (char, 9, a + SAR ( 0,  6), a, 3);   /* { dg-warning \"forming offset 10 is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n-  T (char, 9, a + SAR (-1,  7), a, 3);   /* { dg-warning \"forming offset \\\\\\[10, 11] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n-  T (char, 9, a + SAR (-2,  8), a, 3);   /* { dg-warning \"forming offset \\\\\\[10, 12] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a + SAR ( 0,  6), a, 3);   /* { dg-warning \"forming offset 9 is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a + SAR (-1,  7), a, 3);   /* { dg-warning \"forming offset \\\\\\[9, 10] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n+  T (char, 9, a + SAR (-2,  8), a, 3);   /* { dg-warning \"offset \\\\\\[9, 11] is out of the bounds \\\\\\[0, 9] of object \" \"memcpy\" } */\n \n   ptrdiff_t i = SAR (DIFF_MIN + 1, DIFF_MAX - 4);\n   T (char, 1, d, d + SAR (DIFF_MIN + 3, DIFF_MAX - 1), 3);\n@@ -312,13 +312,13 @@ void test_strcpy_bounds (char *d, const char *s)\n      it out of bounds (it isn't) but because the final source offset\n      after the access has completed, is.  It would be clearer if\n      the warning mentioned the final offset.  */\n-  TI (char, 2, \"\", a + SR (2, DIFF_MAX - 1), s);   /* { dg-warning \"forming offset 3 is out of the bounds \\\\\\[0, 2] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[2\\\\\\].\"  \"strcpy\" } */\n+  TI (char, 2, \"\", a + SR (2, DIFF_MAX - 1), s);   /* { dg-warning \"offset 2 is out of the bounds \\\\\\[0, 2] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[2\\\\\\].\"  \"strcpy\" } */\n   TI (char, 2, \"\", a + SR (3, DIFF_MAX - 1), s);   /* { dg-warning \"offset \\\\\\[3, \\[0-9\\]+] is out of the bounds \\\\\\[0, 2] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[2\\\\\\].\"  \"strcpy\" } */\n \n   TI (char, 3, \"\", a + SR (0, DIFF_MAX - 1), s);\n   TI (char, 3, \"\", a + SR (1, DIFF_MAX - 1), s);\n   TI (char, 3, \"\", a + SR (2, DIFF_MAX - 1), s);\n-  TI (char, 3, \"\", a + SR (3, DIFF_MAX - 1), s);   /* { dg-warning \"forming offset 4 is out of the bounds \\\\\\[0, 3] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[3\\\\\\].\"  \"strcpy\" } */\n+  TI (char, 3, \"\", a + SR (3, DIFF_MAX - 1), s);   /* { dg-warning \"offset 3 is out of the bounds \\\\\\[0, 3] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[3\\\\\\].\"  \"strcpy\" } */\n   TI (char, 3, \"\", a + SR (4, DIFF_MAX - 1), s);   /* { dg-warning \"offset \\\\\\[4, \\[0-9\\]+] is out of the bounds \\\\\\[0, 3] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[3\\\\\\].\"  \"strcpy\" } */\n \n   TI (char, 4, \"\", a + SR (DIFF_MAX - 2, DIFF_MAX - 1), s);   /* { dg-warning \"offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] is out of the bounds \\\\\\[0, 4] of object \\[^\\n\\r\\]+ with type .char ?\\\\\\[4\\\\\\].\"  \"strcpy\" } */\n@@ -364,15 +364,15 @@ void test_strcpy_bounds_memarray_range (void)\n   TM (a5, \"0\",    ma.a5 + i, ma.a5);\n   TM (a5, \"01\",   ma.a5 + i, ma.a5);\n   TM (a5, \"012\",  ma.a5 + i, ma.a5);\n-  TM (a5, \"0123\", ma.a5 + i, ma.a5);     /* { dg-warning \"offset 10 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 4\" \"strcpy\" } */\n+  TM (a5, \"0123\", ma.a5 + i, ma.a5);     /* { dg-warning \"offset 9 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 4\" \"strcpy\" } */\n \n   TM (a11, \"0\",       ma.a5, ma.a11);\n   TM (a11, \"01\",      ma.a5, ma.a11);\n   TM (a11, \"012\",     ma.a5, ma.a11);\n   TM (a11, \"0123\",    ma.a5, ma.a11);\n-  TM (a11, \"01234\",   ma.a5, ma.a11);    /* { dg-warning \"offset 10 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]' at offset 4\" } */\n-  TM (a11, \"012345\",  ma.a5, ma.a11);    /* { dg-warning \"offset \\\\\\[10, 11] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]' at offset 4\" } */\n-  TM (a11, \"0123456\", ma.a5, ma.a11);    /* { dg-warning \"offset \\\\\\[10, 12] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]' at offset 4\" } */\n+  TM (a11, \"01234\",   ma.a5, ma.a11);    /* { dg-warning \"offset 9 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]' at offset 4\" } */\n+  TM (a11, \"012345\",  ma.a5, ma.a11);    /* { dg-warning \"offset \\\\\\[9, 10] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]' at offset 4\" } */\n+  TM (a11, \"0123456\", ma.a5, ma.a11);    /* { dg-warning \"offset \\\\\\[9, 11] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]' at offset 4\" } */\n \n   TM (a11, \"0123456\", ma.a11 + i, \"789abcd\");\n }"}, {"sha": "961107a3472814748ceacc4f92474b13654bcbb1", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-4.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -44,8 +44,8 @@ void test_memcpy_bounds_memarray_range (void)\n   TM (ma.a5, ma.a5 + j, ma.a5, 1);\n   TM (ma.a5, ma.a5 + j, ma.a5, 3);\n   TM (ma.a5, ma.a5 + j, ma.a5, 5);\n-  TM (ma.a5, ma.a5 + j, ma.a5, 7);        /* { dg-warning \"offset \\\\\\[6, 8] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 0\" } */\n-  TM (ma.a5, ma.a5 + j, ma.a5, 9);        /* { dg-warning \"offset \\\\\\[6, 10] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 0\" } */\n+  TM (ma.a5, ma.a5 + j, ma.a5, 7);        /* { dg-warning \"offset \\\\\\[5, 7] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 0\" } */\n+  TM (ma.a5, ma.a5 + j, ma.a5, 9);        /* { dg-warning \"offset \\\\\\[5, 9] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 0\" } */\n }\n \n void test_strcpy_bounds_memarray_range (void)\n@@ -67,7 +67,7 @@ void test_strcpy_bounds_memarray_range (void)\n \n #if __i386__ || __x86_64__\n   /* Disabled for non-x86 targets due to bug 83462.  */\n-  TM (\"\", \"012345\", ma.a7 + i, ma.a7);    /* { dg-warning \"offset 13 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a7. with type .char ?\\\\\\[7]. at offset 5\" \"strcpy\" { xfail { ! { i?86-*-* x86_64-*-* } } } } */\n+  TM (\"\", \"012345\", ma.a7 + i, ma.a7);    /* { dg-warning \"offset 12 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a7. with type .char ?\\\\\\[7]. at offset 5\" \"strcpy\" { xfail { ! { i?86-*-* x86_64-*-* } } } } */\n #endif\n \n }"}, {"sha": "f10ffaca5cb18b1185033d870ed03e888991871b", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-39.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-39.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -123,7 +123,7 @@ char* test_strcpy_s0 (char *d)\n \n char* test_strcpy_s0_0 (char *d)\n {\n-  return strcpy (d, s0_0[0]);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr88991\" { xfail *-*-* } } */\n+  return strcpy (d, s0_0[0]);     /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n \n@@ -139,10 +139,10 @@ char* test_strncpy_s0_2 (char *d)\n \n char* test_strncpy_s0_0_1 (char *d)\n {\n-  return strncpy (d, s0_0[0], 1); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr88991\" { xfail *-*-* } } */\n+  return strncpy (d, s0_0[0], 1); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }\n \n char* test_strncpy_s0_0_2 (char *d)\n {\n-  return strncpy (d, s0_0[0], 2); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" \"pr88991\" { xfail *-*-* } } */\n+  return strncpy (d, s0_0[0], 2); /* { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" } */\n }"}, {"sha": "e21452fdf24d27e5abf9aa59ac854232b2751242", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-45.c", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-45.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -0,0 +1,330 @@\n+/* PR middle-end/91631 - buffer overflow into an array member of a declared\n+   object not detected\n+   Test to verify that past-the-end accesses by string functions to member\n+   arrays by-reference objects are diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-unused-local-typedefs -ftrack-macro-expansion=0\" }  */\n+\n+extern char* strcpy (char*, const char*);\n+extern char* strcat (char*, const char*);\n+\n+void sink (void*, ...);\n+\n+#define S36 \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+\n+#define S(N)   (S36 + sizeof (S36) - N - 1)\n+\n+/* In the test macro, prevent the strcpy to memcpy transformation\n+   by using a local array initialized with the string literal.  Without\n+   it, GCC transforms the strcpy call with memcpy which (unfortunately)\n+   permits accesses that cross subobject boundaries.  */\n+#define T(dst, ncpy, ncat)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    const char a[] = S36;\t\t\t\\\n+    strcpy (dst, a + sizeof a - ncpy - 1);\t\\\n+    const char b[] = S36;\t\t\t\\\n+    strcat (dst, b + sizeof b - ncat - 1);\t\\\n+    sink (dst);\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+struct MemArrays\n+{\n+  char a7[7];             // { dg-message \"'a7' declared here\" }\n+  char a4[4];             // { dg-message \"'a4' declared here\" }\n+  char a3[3];             // { dg-message \"'a3' declared here\" }\n+};\n+\n+struct MemArrays gma;\n+\n+void strcat_value (void)\n+{\n+  T (gma.a7, 1, 1);\n+  T (gma.a7, 1, 5);\n+  T (gma.a7, 1, 6);       // { dg-warning \"'strcat' offset 7 from the object at 'gma' is out of the bounds of referenced subobject 'a7' with type 'char\\\\\\[7]' at offset 0\" }\n+  T (gma.a7, 1, 7);       // { dg-warning \"'strcat' offset \\\\\\[7, 8] from the object at 'gma' is out of the bounds of referenced subobject 'a7' with type 'char\\\\\\[7]' at offset 0\" }\n+\n+  T (gma.a7, 2, 1);\n+  T (gma.a7, 2, 4);\n+  T (gma.a7, 2, 5);       // { dg-warning \"'strcat' offset 7 from the object at 'gma' is out of the bounds of referenced subobject 'a7' with type 'char\\\\\\[7]' at offset 0\" }\n+  T (gma.a7, 2, 6);       // { dg-warning \"'strcat' offset \\\\\\[7, 8] from the object at 'gma' is out of the bounds of referenced subobject 'a7' with type 'char\\\\\\[7]' at offset 0\" }\n+\n+  T (gma.a7, 5, 1);\n+  T (gma.a7, 5, 2);       // { dg-warning \"'strcat' offset 7 from the object at 'gma' is out of the bounds of referenced subobject 'a7' with type 'char\\\\\\[7]' at offset 0\" }\n+\n+  T (gma.a4, 1, 1);\n+  T (gma.a4, 1, 2);\n+  T (gma.a4, 1, 3);       // { dg-warning \"'strcat' offset 11 from the object at 'gma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 7\" }\n+   T (gma.a4, 1, 4);       // { dg-warning \"'strcat' offset \\\\\\[11, 12] from the object at 'gma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 7\" }\n+\n+  T (gma.a4, 2, 3);       // { dg-warning \"'strcat' offset \\\\\\[11, 12] from the object at 'gma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 7\" }\n+\n+  T (gma.a3, 1, 1);\n+  T (gma.a3, 1, 2);       // { dg-warning \"'strcat' offset 14 from the object at 'gma' is out of the bounds of referenced subobject 'a3' with type 'char\\\\\\[3]' at offset 11\" }\n+}\n+\n+\n+void strcat_ref (struct MemArrays *pma)\n+{\n+  T (pma->a7, 1, 1);\n+  T (pma->a7, 1, 5);\n+  T (pma->a7, 1, 6);      // { dg-warning \"'strcat' offset 7 from the object at 'pma' is out of the bounds of referenced subobject 'a7' with type 'char\\\\\\[7]' at offset 0\" }\n+  T (pma->a7, 1, 7);      // { dg-warning \"'strcat' offset \\\\\\[7, 8] from the object at 'pma' is out of the bounds of referenced subobject 'a7' with type 'char\\\\\\[7]' at offset 0\" }\n+\n+  T (pma->a7, 2, 1);\n+  T (pma->a7, 2, 4);\n+  T (pma->a7, 2, 5);      // { dg-warning \"'strcat' offset 7 from the object at 'pma' is out of the bounds of referenced subobject 'a7' with type 'char\\\\\\[7]' at offset 0\" }\n+  T (pma->a7, 2, 6);      // { dg-warning \"'strcat' offset \\\\\\[7, 8] from the object at 'pma' is out of the bounds of referenced subobject 'a7' with type 'char\\\\\\[7]' at offset 0\" }\n+\n+  T (pma->a4, 1, 1);\n+  T (pma->a4, 1, 2);\n+  T (pma->a4, 1, 3);      // { dg-warning \"'strcat' offset 11 from the object at 'pma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 7\" }\n+   T (pma->a4, 1, 4);      // { dg-warning \"'strcat' offset \\\\\\[11, 12] from the object at 'pma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 7\" }\n+\n+  T (pma->a4, 2, 3);      // { dg-warning \"'strcat' offset \\\\\\[11, 12] from the object at 'pma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 7\" }\n+\n+  T (pma->a3, 1, 1);\n+  T (pma->a3, 1, 2);      // { dg-warning \"'strcat' offset 14 from the object at 'pma' is out of the bounds of referenced subobject 'a3' with type 'char\\\\\\[3]' at offset 11\" }\n+}\n+\n+\n+#define T2(dst1, dst2, ncpy, ncat)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    const char a[] = S36;\t\t\t\\\n+    strcpy (dst1, a + sizeof a - ncpy - 1);\t\\\n+    const char b[] = S36;\t\t\t\\\n+    strcat (dst2, b + sizeof b - ncat - 1);\t\\\n+    sink (dst1, dst2);\t\t\t\t\\\n+  } while (0)\n+\n+struct ArraysOfMemArrays\n+{\n+  struct MemArrays ma3[3];\n+} a3[3];\n+\n+void strcat_arrays_of_arrays_value (void)\n+{\n+  T2 (a3[0].ma3[0].a7, a3[0].ma3[0].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (a3[0].ma3[0].a7, a3[0].ma3[1].a7, 6, 6);\n+  T2 (a3[0].ma3[0].a7, a3[0].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[0].ma3[1].a7, a3[0].ma3[0].a7, 6, 6);\n+  T2 (a3[0].ma3[1].a7, a3[0].ma3[1].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (a3[0].ma3[1].a7, a3[0].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[0].ma3[2].a7, a3[0].ma3[0].a7, 6, 6);\n+  T2 (a3[0].ma3[2].a7, a3[0].ma3[1].a7, 6, 6);\n+  T2 (a3[0].ma3[2].a7, a3[0].ma3[2].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T2 (a3[0].ma3[0].a7, a3[1].ma3[0].a7, 6, 6);\n+  T2 (a3[0].ma3[0].a7, a3[1].ma3[1].a7, 6, 6);\n+  T2 (a3[0].ma3[0].a7, a3[1].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[0].ma3[1].a7, a3[1].ma3[0].a7, 6, 6);\n+  T2 (a3[0].ma3[1].a7, a3[1].ma3[1].a7, 6, 6);\n+  T2 (a3[0].ma3[1].a7, a3[1].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[0].ma3[2].a7, a3[1].ma3[0].a7, 6, 6);\n+  T2 (a3[0].ma3[2].a7, a3[1].ma3[1].a7, 6, 6);\n+  T2 (a3[0].ma3[2].a7, a3[1].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[0].ma3[0].a7, a3[2].ma3[0].a7, 6, 6);\n+  T2 (a3[0].ma3[0].a7, a3[2].ma3[1].a7, 6, 6);\n+  T2 (a3[0].ma3[0].a7, a3[2].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[0].ma3[1].a7, a3[2].ma3[0].a7, 6, 6);\n+  T2 (a3[0].ma3[1].a7, a3[2].ma3[1].a7, 6, 6);\n+  T2 (a3[0].ma3[1].a7, a3[2].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[0].ma3[2].a7, a3[2].ma3[0].a7, 6, 6);\n+  T2 (a3[0].ma3[2].a7, a3[2].ma3[1].a7, 6, 6);\n+  T2 (a3[0].ma3[2].a7, a3[2].ma3[2].a7, 6, 6);\n+\n+\n+  T2 (a3[1].ma3[0].a7, a3[0].ma3[0].a7, 6, 6);\n+  T2 (a3[1].ma3[0].a7, a3[0].ma3[1].a7, 6, 6);\n+  T2 (a3[1].ma3[0].a7, a3[0].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[1].ma3[1].a7, a3[0].ma3[0].a7, 6, 6);\n+  T2 (a3[1].ma3[1].a7, a3[0].ma3[1].a7, 6, 6);\n+  T2 (a3[1].ma3[1].a7, a3[0].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[1].ma3[2].a7, a3[0].ma3[0].a7, 6, 6);\n+  T2 (a3[1].ma3[2].a7, a3[0].ma3[1].a7, 6, 6);\n+  T2 (a3[1].ma3[2].a7, a3[0].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[1].ma3[0].a7, a3[1].ma3[0].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (a3[1].ma3[0].a7, a3[1].ma3[1].a7, 6, 6);\n+  T2 (a3[1].ma3[0].a7, a3[1].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[1].ma3[1].a7, a3[1].ma3[0].a7, 6, 6);\n+  T2 (a3[1].ma3[1].a7, a3[1].ma3[1].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (a3[1].ma3[1].a7, a3[1].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[1].ma3[2].a7, a3[1].ma3[0].a7, 6, 6);\n+  T2 (a3[1].ma3[2].a7, a3[1].ma3[1].a7, 6, 6);\n+  T2 (a3[1].ma3[2].a7, a3[1].ma3[2].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T2 (a3[1].ma3[0].a7, a3[2].ma3[0].a7, 6, 6);\n+  T2 (a3[1].ma3[0].a7, a3[2].ma3[1].a7, 6, 6);\n+  T2 (a3[1].ma3[0].a7, a3[2].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[1].ma3[1].a7, a3[2].ma3[0].a7, 6, 6);\n+  T2 (a3[1].ma3[1].a7, a3[2].ma3[1].a7, 6, 6);\n+  T2 (a3[1].ma3[1].a7, a3[2].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[1].ma3[2].a7, a3[2].ma3[0].a7, 6, 6);\n+  T2 (a3[1].ma3[2].a7, a3[2].ma3[1].a7, 6, 6);\n+  T2 (a3[1].ma3[2].a7, a3[2].ma3[2].a7, 6, 6);\n+\n+\n+  T2 (a3[2].ma3[0].a7, a3[0].ma3[0].a7, 6, 6);\n+  T2 (a3[2].ma3[0].a7, a3[0].ma3[1].a7, 6, 6);\n+  T2 (a3[2].ma3[0].a7, a3[0].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[2].ma3[1].a7, a3[0].ma3[0].a7, 6, 6);\n+  T2 (a3[2].ma3[1].a7, a3[0].ma3[1].a7, 6, 6);\n+  T2 (a3[2].ma3[1].a7, a3[0].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[2].ma3[2].a7, a3[0].ma3[0].a7, 6, 6);\n+  T2 (a3[2].ma3[2].a7, a3[0].ma3[1].a7, 6, 6);\n+  T2 (a3[2].ma3[2].a7, a3[0].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[2].ma3[0].a7, a3[1].ma3[0].a7, 6, 6);\n+  T2 (a3[2].ma3[0].a7, a3[1].ma3[1].a7, 6, 6);\n+  T2 (a3[2].ma3[0].a7, a3[1].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[2].ma3[1].a7, a3[1].ma3[0].a7, 6, 6);\n+  T2 (a3[2].ma3[1].a7, a3[1].ma3[1].a7, 6, 6);\n+  T2 (a3[2].ma3[1].a7, a3[1].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[2].ma3[2].a7, a3[1].ma3[0].a7, 6, 6);\n+  T2 (a3[2].ma3[2].a7, a3[1].ma3[1].a7, 6, 6);\n+  T2 (a3[2].ma3[2].a7, a3[1].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[2].ma3[0].a7, a3[2].ma3[0].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (a3[2].ma3[0].a7, a3[2].ma3[1].a7, 6, 6);\n+  T2 (a3[2].ma3[0].a7, a3[2].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[2].ma3[1].a7, a3[2].ma3[0].a7, 6, 6);\n+  T2 (a3[2].ma3[1].a7, a3[2].ma3[1].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (a3[2].ma3[1].a7, a3[2].ma3[2].a7, 6, 6);\n+\n+  T2 (a3[2].ma3[2].a7, a3[2].ma3[0].a7, 6, 6);\n+  T2 (a3[2].ma3[2].a7, a3[2].ma3[1].a7, 6, 6);\n+  T2 (a3[2].ma3[2].a7, a3[2].ma3[2].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+void strcat_arrays_of_arrays_ref (struct ArraysOfMemArrays *p)\n+{\n+  T2 (p[0].ma3[0].a7, p[0].ma3[0].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (p[0].ma3[0].a7, p[0].ma3[1].a7, 6, 6);\n+  T2 (p[0].ma3[0].a7, p[0].ma3[2].a7, 6, 6);\n+\n+  T2 (p[0].ma3[1].a7, p[0].ma3[0].a7, 6, 6);\n+  T2 (p[0].ma3[1].a7, p[0].ma3[1].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (p[0].ma3[1].a7, p[0].ma3[2].a7, 6, 6);\n+\n+  T2 (p[0].ma3[2].a7, p[0].ma3[0].a7, 6, 6);\n+  T2 (p[0].ma3[2].a7, p[0].ma3[1].a7, 6, 6);\n+  T2 (p[0].ma3[2].a7, p[0].ma3[2].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T2 (p[0].ma3[0].a7, p[1].ma3[0].a7, 6, 6);\n+  T2 (p[0].ma3[0].a7, p[1].ma3[1].a7, 6, 6);\n+  T2 (p[0].ma3[0].a7, p[1].ma3[2].a7, 6, 6);\n+\n+  T2 (p[0].ma3[1].a7, p[1].ma3[0].a7, 6, 6);\n+  T2 (p[0].ma3[1].a7, p[1].ma3[1].a7, 6, 6);\n+  T2 (p[0].ma3[1].a7, p[1].ma3[2].a7, 6, 6);\n+\n+  T2 (p[0].ma3[2].a7, p[1].ma3[0].a7, 6, 6);\n+  T2 (p[0].ma3[2].a7, p[1].ma3[1].a7, 6, 6);\n+  T2 (p[0].ma3[2].a7, p[1].ma3[2].a7, 6, 6);\n+\n+  T2 (p[0].ma3[0].a7, p[2].ma3[0].a7, 6, 6);\n+  T2 (p[0].ma3[0].a7, p[2].ma3[1].a7, 6, 6);\n+  T2 (p[0].ma3[0].a7, p[2].ma3[2].a7, 6, 6);\n+\n+  T2 (p[0].ma3[1].a7, p[2].ma3[0].a7, 6, 6);\n+  T2 (p[0].ma3[1].a7, p[2].ma3[1].a7, 6, 6);\n+  T2 (p[0].ma3[1].a7, p[2].ma3[2].a7, 6, 6);\n+\n+  T2 (p[0].ma3[2].a7, p[2].ma3[0].a7, 6, 6);\n+  T2 (p[0].ma3[2].a7, p[2].ma3[1].a7, 6, 6);\n+  T2 (p[0].ma3[2].a7, p[2].ma3[2].a7, 6, 6);\n+\n+\n+  T2 (p[1].ma3[0].a7, p[0].ma3[0].a7, 6, 6);\n+  T2 (p[1].ma3[0].a7, p[0].ma3[1].a7, 6, 6);\n+  T2 (p[1].ma3[0].a7, p[0].ma3[2].a7, 6, 6);\n+\n+  T2 (p[1].ma3[1].a7, p[0].ma3[0].a7, 6, 6);\n+  T2 (p[1].ma3[1].a7, p[0].ma3[1].a7, 6, 6);\n+  T2 (p[1].ma3[1].a7, p[0].ma3[2].a7, 6, 6);\n+\n+  T2 (p[1].ma3[2].a7, p[0].ma3[0].a7, 6, 6);\n+  T2 (p[1].ma3[2].a7, p[0].ma3[1].a7, 6, 6);\n+  T2 (p[1].ma3[2].a7, p[0].ma3[2].a7, 6, 6);\n+\n+  T2 (p[1].ma3[0].a7, p[1].ma3[0].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (p[1].ma3[0].a7, p[1].ma3[1].a7, 6, 6);\n+  T2 (p[1].ma3[0].a7, p[1].ma3[2].a7, 6, 6);\n+\n+  T2 (p[1].ma3[1].a7, p[1].ma3[0].a7, 6, 6);\n+  T2 (p[1].ma3[1].a7, p[1].ma3[1].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (p[1].ma3[1].a7, p[1].ma3[2].a7, 6, 6);\n+\n+  T2 (p[1].ma3[2].a7, p[1].ma3[0].a7, 6, 6);\n+  T2 (p[1].ma3[2].a7, p[1].ma3[1].a7, 6, 6);\n+  T2 (p[1].ma3[2].a7, p[1].ma3[2].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  T2 (p[1].ma3[0].a7, p[2].ma3[0].a7, 6, 6);\n+  T2 (p[1].ma3[0].a7, p[2].ma3[1].a7, 6, 6);\n+  T2 (p[1].ma3[0].a7, p[2].ma3[2].a7, 6, 6);\n+\n+  T2 (p[1].ma3[1].a7, p[2].ma3[0].a7, 6, 6);\n+  T2 (p[1].ma3[1].a7, p[2].ma3[1].a7, 6, 6);\n+  T2 (p[1].ma3[1].a7, p[2].ma3[2].a7, 6, 6);\n+\n+  T2 (p[1].ma3[2].a7, p[2].ma3[0].a7, 6, 6);\n+  T2 (p[1].ma3[2].a7, p[2].ma3[1].a7, 6, 6);\n+  T2 (p[1].ma3[2].a7, p[2].ma3[2].a7, 6, 6);\n+\n+\n+  T2 (p[2].ma3[0].a7, p[0].ma3[0].a7, 6, 6);\n+  T2 (p[2].ma3[0].a7, p[0].ma3[1].a7, 6, 6);\n+  T2 (p[2].ma3[0].a7, p[0].ma3[2].a7, 6, 6);\n+\n+  T2 (p[2].ma3[1].a7, p[0].ma3[0].a7, 6, 6);\n+  T2 (p[2].ma3[1].a7, p[0].ma3[1].a7, 6, 6);\n+  T2 (p[2].ma3[1].a7, p[0].ma3[2].a7, 6, 6);\n+\n+  T2 (p[2].ma3[2].a7, p[0].ma3[0].a7, 6, 6);\n+  T2 (p[2].ma3[2].a7, p[0].ma3[1].a7, 6, 6);\n+  T2 (p[2].ma3[2].a7, p[0].ma3[2].a7, 6, 6);\n+\n+  T2 (p[2].ma3[0].a7, p[1].ma3[0].a7, 6, 6);\n+  T2 (p[2].ma3[0].a7, p[1].ma3[1].a7, 6, 6);\n+  T2 (p[2].ma3[0].a7, p[1].ma3[2].a7, 6, 6);\n+\n+  T2 (p[2].ma3[1].a7, p[1].ma3[0].a7, 6, 6);\n+  T2 (p[2].ma3[1].a7, p[1].ma3[1].a7, 6, 6);\n+  T2 (p[2].ma3[1].a7, p[1].ma3[2].a7, 6, 6);\n+\n+  T2 (p[2].ma3[2].a7, p[1].ma3[0].a7, 6, 6);\n+  T2 (p[2].ma3[2].a7, p[1].ma3[1].a7, 6, 6);\n+  T2 (p[2].ma3[2].a7, p[1].ma3[2].a7, 6, 6);\n+\n+  T2 (p[2].ma3[0].a7, p[2].ma3[0].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (p[2].ma3[0].a7, p[2].ma3[1].a7, 6, 6);\n+  T2 (p[2].ma3[0].a7, p[2].ma3[2].a7, 6, 6);\n+\n+  T2 (p[2].ma3[1].a7, p[2].ma3[0].a7, 6, 6);\n+  T2 (p[2].ma3[1].a7, p[2].ma3[1].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T2 (p[2].ma3[1].a7, p[2].ma3[2].a7, 6, 6);\n+\n+  T2 (p[2].ma3[2].a7, p[2].ma3[0].a7, 6, 6);\n+  T2 (p[2].ma3[2].a7, p[2].ma3[1].a7, 6, 6);\n+  T2 (p[2].ma3[2].a7, p[2].ma3[2].a7, 6, 6);   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}"}, {"sha": "09b577e63637cc3afd4900c8e17750ea5ad8f003", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-46.c", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -0,0 +1,249 @@\n+/* PR middle-end/91631 - buffer overflow into an array member of a declared\n+   object not detected\n+   Test to verify that past-the-end accesses by string functions to member\n+   arrays by-reference objects are diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-unused-local-typedefs -ftrack-macro-expansion=0\" }  */\n+\n+#define SA(expr) typedef int StaticAssert [2 * !!(expr) - 1]\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern char* strcpy (char*, const char*);\n+extern char* strncpy (char*, const char*, size_t);\n+\n+void sink (void*);\n+\n+struct MA17\n+{\n+  char pad[4];\n+  char a1[1], a2[2], a3[3], a4[4], a5[5], a6[6], a7[7], a8[8], a9[9], a10[10];\n+  char a11[11], a12[12], a13[13], a14[14], a15[15], a16[16], a17[17], ax[];\n+};\n+\n+extern struct MA17 gma;\n+extern struct MA17 gma2[2];\n+\n+struct MA17 igma_3 = { .ax = { 1, 2, 3 } };\n+struct MA17 igma2_[2];\n+\n+#define S36 \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+\n+#define S(N)   (S36 + sizeof (S36) - N - 1)\n+\n+/* In the test macro, prevent the strcpy to memcpy transformation\n+   by using a local array initialized with the string literal.  Without\n+   it, GCC transforms the strcpy call with memcpy which (unfortunately)\n+   permits accesses that cross subobject boundaries.  */\n+#define T(dst, n)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    const char a[] = S36;\t\t\t\\\n+    strcpy (dst, a + sizeof a - n - 1);\t\t\\\n+    sink (dst);\t\t\t\t\t\\\n+  } while (0)\n+\n+void strcpy_global (void)\n+{\n+  T (gma.a1, 0);\n+  T (gma.a1, 1);          // { dg-warning \"'strcpy' offset 5 from the object at 'gma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 4\" }\n+  T (gma.a1, 4);          // { dg-warning \"'strcpy' offset \\\\\\[5, 8] from the object at 'gma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 4\" }\n+\n+  T (gma.a2, 1);\n+  T (gma.a2, 2);          // { dg-warning \"'strcpy' offset 7 from the object at 'gma' is out of the bounds of referenced subobject 'a2' with type 'char\\\\\\[2]' at offset 5\" }\n+\n+  T (gma.a3, 2);\n+  T (gma.a3, 3);          // { dg-warning \"'strcpy' offset 10 from the object at 'gma' is out of the bounds of referenced subobject 'a3' with type 'char\\\\\\[3]' at offset 7\" }\n+\n+  T (gma.a4, 3);\n+  T (gma.a4, 4);          // { dg-warning \"'strcpy' offset 14 from the object at 'gma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 10\" }\n+\n+  T (gma.a5, 4);\n+  T (gma.a5, 5);          // { dg-warning \"'strcpy' offset 19 from the object at 'gma' is out of the bounds of referenced subobject 'a5' with type 'char\\\\\\[5]' at offset 14\" }\n+\n+  SA (__builtin_offsetof (struct MA17, a17) == 140);\n+\n+  T (gma.a17, 16);\n+  T (gma.a17, 17);        // { dg-warning \"'strcpy' offset 157 from the object at 'gma' is out of the bounds of referenced subobject 'a17' with type 'char\\\\\\[17]' at offset 140\" }\n+\n+  SA (__builtin_offsetof (struct MA17, ax) == 157);\n+\n+  T (gma.ax, 0);          // { dg-warning \"'strcpy' offset 157 is out of the bounds \\\\\\[0, 157] of object 'gma' with type 'struct MA17'\" }\n+}\n+\n+\n+void strcpy_global_array (void)\n+{\n+  T (gma2[0].a1, 0);\n+  T (gma2[0].a1, 1);      // { dg-warning \"'strcpy' offset 5 from the object at 'gma2' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 4\" }\n+  T (gma2[0].a1, 4);      // { dg-warning \"'strcpy' offset \\\\\\[5, 8] from the object at 'gma2' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 4\" }\n+\n+  T (gma2[0].a2, 1);\n+  T (gma2[0].a2, 2);      // { dg-warning \"'strcpy' offset 7 from the object at 'gma2' is out of the bounds of referenced subobject 'a2' with type 'char\\\\\\[2]' at offset 5\" }\n+\n+  T (gma2[0].a3, 2);\n+  T (gma2[0].a3, 3);      // { dg-warning \"'strcpy' offset 10 from the object at 'gma2' is out of the bounds of referenced subobject 'a3' with type 'char\\\\\\[3]' at offset 7\" }\n+\n+  T (gma2[0].a4, 3);\n+  T (gma2[0].a4, 4);      // { dg-warning \"'strcpy' offset 14 from the object at 'gma2' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 10\" }\n+\n+  T (gma2[0].a5, 4);\n+  T (gma2[0].a5, 5);      // { dg-warning \"'strcpy' offset 19 from the object at 'gma2' is out of the bounds of referenced subobject 'a5' with type 'char\\\\\\[5]' at offset 14\" }\n+\n+  T (gma2[0].a17, 16);\n+  T (gma2[0].a17, 17);    // { dg-warning \"'strcpy' offset 157 from the object at 'gma2' is out of the bounds of referenced subobject 'a17' with type 'char\\\\\\[17]' at offset 140\" }\n+\n+  /* GMA2 is external buts because it's an array its definition in another\n+     translation unit may not provide an initializer for the flexible array\n+     member.  Verify that a warning is issued for access to it.  */\n+  T (gma2[0].ax, 1);      // { dg-warning \"'strcpy' offset \\\\\\[157, 158] from the object at 'gma2' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 157\" }\n+  T (gma2[0].ax, 7);      // { dg-warning \"'strcpy' offset \\\\\\[157, 164] from the object at 'gma2' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 157\" }\n+\n+  /* IGMA_ is internal and provides on definition for the flexible array\n+     member.  Verify that a warnin is issued for out-of-bounds accesses\n+     to it.  */\n+  T (igma2_[0].ax, 1);    // { dg-warning \"'strcpy' offset \\\\\\[157, 158] from the object at 'igma2_' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 157\" }\n+\n+  T (igma_3.ax, 0);\n+  T (igma_3.ax, 1);\n+  T (igma_3.ax, 1);\n+  T (igma_3.ax, 3);       // { dg-warning \" offset 160 \" }\n+  T (igma_3.ax, 9);       // { dg-warning \" offset \\\\\\[160, 166] \" }\n+}\n+\n+\n+void strcpy_local (void)\n+{\n+  struct MA17 lma;\n+\n+  T (lma.a1, 0);\n+  T (lma.a1, 1);          // { dg-warning \"'strcpy' offset 5 from the object at 'lma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 4\" }\n+  T (lma.a1, 4);          // { dg-warning \"'strcpy' offset \\\\\\[5, 8] from the object at 'lma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 4\" }\n+\n+  T (lma.a2, 1);\n+  T (lma.a2, 2);          // { dg-warning \"'strcpy' offset 7 from the object at 'lma' is out of the bounds of referenced subobject 'a2' with type 'char\\\\\\[2]' at offset 5\" }\n+\n+  T (lma.a3, 2);\n+  T (lma.a3, 3);          // { dg-warning \"'strcpy' offset 10 from the object at 'lma' is out of the bounds of referenced subobject 'a3' with type 'char\\\\\\[3]' at offset 7\" }\n+\n+  T (lma.a4, 3);\n+  T (lma.a4, 4);          // { dg-warning \"'strcpy' offset 14 from the object at 'lma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 10\" }\n+\n+  T (lma.a5, 4);\n+  T (lma.a5, 5);          // { dg-warning \"'strcpy' offset 19 from the object at 'lma' is out of the bounds of referenced subobject 'a5' with type 'char\\\\\\[5]' at offset 14\" }\n+\n+  T (lma.a17, 16);\n+  T (lma.a17, 17);        // { dg-warning \"'strcpy' offset 157 from the object at 'lma' is out of the bounds of referenced subobject 'a17' with type 'char\\\\\\[17]' at offset 140\" }\n+\n+  T (lma.ax, 0);          // { dg-warning \"'strcpy' offset 157 from the object at 'lma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 157\" }\n+}\n+\n+\n+void strcpy_ref (struct MA17 *pma)\n+{\n+  T (pma->a1, 0);\n+  T (pma->a1, 1);         // { dg-warning \"'strcpy' offset 5 from the object at 'pma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 4\" }\n+  T (pma->a1, 4);         // { dg-warning \"'strcpy' offset \\\\\\[5, 8] from the object at 'pma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 4\" }\n+\n+  T (pma->a2, 1);\n+  T (pma->a2, 2);         // { dg-warning \"'strcpy' offset 7 from the object at 'pma' is out of the bounds of referenced subobject 'a2' with type 'char\\\\\\[2]' at offset 5\" }\n+\n+  T (pma->a3, 2);\n+  T (pma->a3, 3);         // { dg-warning \"'strcpy' offset 10 from the object at 'pma' is out of the bounds of referenced subobject 'a3' with type 'char\\\\\\[3]' at offset 7\" }\n+\n+  T (pma->a4, 3);\n+  T (pma->a4, 4);         // { dg-warning \"'strcpy' offset 14 from the object at 'pma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 10\" }\n+\n+  T (pma->a5, 4);\n+  T (pma->a5, 5);         // { dg-warning \"'strcpy' offset 19 from the object at 'pma' is out of the bounds of referenced subobject 'a5' with type 'char\\\\\\[5]' at offset 14\" }\n+\n+  T (pma->a17, 16);\n+  T (pma->a17, 17);       // { dg-warning \"'strcpy' offset 157 from the object at 'pma' is out of the bounds of referenced subobject 'a17' with type 'char\\\\\\[17]' at offset 140\" }\n+\n+  T (pma->ax, 0);\n+  T ((*pma).ax, 8);\n+  T (pma[0].ax, 9);\n+\n+  SA (__builtin_offsetof (struct MA17, a1) == 4\n+      && sizeof (struct MA17) == 157);\n+\n+  T (pma[1].a1, 0);\n+  T (pma[1].a1, 1);       // { dg-warning \"'strcpy' offset 162 from the object at 'pma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 161\" }\n+  T (pma[1].a1, 4);       // { dg-warning \"'strcpy' offset \\\\\\[162, 165] from the object at 'pma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset 161\" }\n+\n+  T (pma[1].a2, 1);\n+  T (pma[1].a2, 2);       // { dg-warning \"'strcpy' offset 164 from the object at 'pma' is out of the bounds of referenced subobject 'a2' with type 'char\\\\\\[2]' at offset 162\" }\n+\n+  T (pma[1].a3, 2);\n+  T (pma[1].a3, 3);       // { dg-warning \"'strcpy' offset 167 from the object at 'pma' is out of the bounds of referenced subobject 'a3' with type 'char\\\\\\[3]' at offset 164\" }\n+\n+  T (pma[1].a4, 3);\n+  T (pma[1].a4, 4);       // { dg-warning \"'strcpy' offset 171 from the object at 'pma' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset 167\" }\n+\n+  T (pma[1].a5, 4);\n+  T (pma[1].a5, 5);       // { dg-warning \"'strcpy' offset 176 from the object at 'pma' is out of the bounds of referenced subobject 'a5' with type 'char\\\\\\[5]' at offset 171\" }\n+\n+  T (pma[1].a17, 16);\n+  T (pma[1].a17, 17);     // { dg-warning \"'strcpy' offset 314 from the object at 'pma' is out of the bounds of referenced subobject 'a17' with type 'char\\\\\\[17]' at offset 297\" }\n+\n+  /* Since PMA points to an array of structs, accessing the flexible\n+     member of any of the elements of the array except for the last one\n+     would necessarily access a part of the next element of the enclosing\n+     array.  The warning assumes that PMA doesn't point to the last element\n+     of the array which could in theory have nonzero elements without\n+     overlapping other objects.  */\n+  T (pma[1].ax, 0);       // { dg-warning \"'strcpy' offset 314 from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 314\" }\n+  T ((pma + 1)->ax, 1);   // { dg-warning \"'strcpy' offset \\\\\\[314, 315] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 314\" }\n+  T ((pma + 1)[1].ax, 2); // { dg-warning \"'strcpy' offset \\\\\\[471, 473] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 471\" }\n+  T ((*(pma + 2)).ax, 2); // { dg-warning \"'strcpy' offset \\\\\\[471, 473] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 471\" }\n+  T (pma[3].ax, 9);       // { dg-warning \"'strcpy' offset \\\\\\[628, 637] from the object at 'pma' is out of the bounds of referenced subobject 'ax' with type 'char\\\\\\[]' at offset 628\" }\n+\n+  T (pma[-1].a1, 0);\n+  T (pma[-1].a1, 1);      // { dg-warning \"'strcpy' offset -152 from the object at 'pma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset -153\" }\n+  T (pma[-1].a1, 4);      // { dg-warning \"'strcpy' offset \\\\\\[-152, -149] from the object at 'pma' is out of the bounds of referenced subobject 'a1' with type 'char\\\\\\[1]' at offset -153\" }\n+}\n+\n+struct MA3\n+{\n+  char a4[4];             // { dg-message \"'a4' declared here\" }\n+  char a3[3];             // { dg-message \"'a3' declared here\" }\n+  char c;\n+};\n+\n+void strcpy_ref_note (struct MA17 *pma, struct MA3 *pma3)\n+{\n+  T (pma3[-1].a4, 0);\n+  T (pma3[-1].a4, 1);\n+  T (pma3[-1].a4, 2);\n+  T (pma3[-1].a4, 3);\n+  T (pma3[-1].a4, 4);     // { dg-warning \"'strcpy' offset -4 from the object at 'pma3' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset -8\" }\n+  T (pma3[-1].a4, 5);     // { dg-warning \"'strcpy' offset \\\\\\[-4, -3] from the object at 'pma3' is out of the bounds of referenced subobject 'a4' with type 'char\\\\\\[4]' at offset -8\" }\n+\n+  T (pma3[-1].a3, 0);\n+  T (pma3[-1].a3, 1);\n+  T (pma3[-1].a3, 2);\n+  T (pma3[-1].a3, 3);     // { dg-warning \"'strcpy' offset -1 from the object at 'pma3' is out of the bounds of referenced subobject 'a3' with type 'char\\\\\\[3]' at offset -4\" }\n+  T (pma3[-1].a3, 4);     // { dg-warning \"'strcpy' offset \\\\\\[-1, 0] from the object at 'pma3' is out of the bounds of referenced subobject 'a3' with type 'char\\\\\\[3]' at offset -4\" }\n+}\n+\n+\n+void strncpy_vla_member (unsigned n)\n+{\n+  struct VarLenStruct {\n+    char a4[4], an[n], bn[n];\n+  } x;\n+\n+  sink (&x);\n+\n+  strncpy (x.bn, x.a4, sizeof x.bn);\n+  sink (&x);\n+\n+  strncpy (x.a4, x.bn, sizeof x.a4);\n+  x.a4[sizeof x.a4 - 1] = '\\0';\n+  sink (&x);\n+\n+  strncpy (x.a4, x.bn, n);\n+  sink (&x);\n+\n+  strncpy (x.an, x.bn, sizeof x.bn);    /* { dg-bogus \"\\\\\\[-Warray-bounds\" } */\n+  sink (&x);\n+}"}, {"sha": "5e1054be48e2a792cad6dcc0876dbd145f9b3af6", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -3057,11 +3057,12 @@ handle_builtin_strcat (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \n       /* Compute the size of the source sequence, including the nul.  */\n       tree srcsize = srclen ? srclen : size_zero_node;\n-      srcsize = fold_build2 (PLUS_EXPR, type, srcsize, build_int_cst (type, 1));\n-\n+      tree one = build_int_cst (type, 1);\n+      srcsize = fold_build2 (PLUS_EXPR, type, srcsize, one);\n+      tree dstsize = fold_build2 (PLUS_EXPR, type, dstlen, one);\n       tree sptr = si && si->ptr ? si->ptr : src;\n \n-      if (check_bounds_or_overlap (stmt, dst, sptr, dstlen, srcsize))\n+      if (check_bounds_or_overlap (stmt, dst, sptr, dstsize, srcsize))\n \t{\n \t  gimple_set_no_warning (stmt, true);\n \t  set_no_warning = true;"}, {"sha": "59ea6b934540e6f359dad9755003213a7a12ac93", "filename": "gcc/tree.c", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -67,6 +67,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"tree-vector-builder.h\"\n+#include \"gimple-fold.h\"\n \n /* Tree code classes.  */\n \n@@ -13850,6 +13851,75 @@ component_ref_field_offset (tree exp)\n     return SUBSTITUTE_PLACEHOLDER_IN_EXPR (DECL_FIELD_OFFSET (field), exp);\n }\n \n+/* Determines the size of the member referenced by the COMPONENT_REF\n+   REF, using its initializer expression if necessary in order to\n+   determine the size of an initialized flexible array member.\n+   Returns the size (which might be zero for an object with\n+   an uninitialized flexible array member) or null if the size\n+   cannot be determined.  */\n+\n+tree\n+component_ref_size (tree ref)\n+{\n+  gcc_assert (TREE_CODE (ref) == COMPONENT_REF);\n+\n+  tree member = TREE_OPERAND (ref, 1);\n+\n+  /* If the member is not an array, or is not last, or is an array with\n+     more than one element, return its size.  Otherwise it's either\n+     a bona fide flexible array member, or a zero-length array member,\n+     or an array of length one treated as such.  */\n+  tree size = DECL_SIZE_UNIT (member);\n+  if (size)\n+    {\n+      tree memtype = TREE_TYPE (member);\n+      if (TREE_CODE (memtype) != ARRAY_TYPE\n+\t  || !array_at_struct_end_p (ref))\n+\treturn size;\n+\n+      if (!integer_zerop (size))\n+\tif (tree dom = TYPE_DOMAIN (memtype))\n+\t  if (tree min = TYPE_MIN_VALUE (dom))\n+\t    if (tree max = TYPE_MAX_VALUE (dom))\n+\t      if (TREE_CODE (min) == INTEGER_CST\n+\t\t  && TREE_CODE (max) == INTEGER_CST)\n+\t\t{\n+\t\t  offset_int minidx = wi::to_offset (min);\n+\t\t  offset_int maxidx = wi::to_offset (max);\n+\t\t  if (maxidx - minidx > 1)\n+\t\t    return size;\n+\t\t}\n+    }\n+\n+  /* If the reference is to a declared object and the member a true\n+     flexible array, try to determine its size from its initializer.  */\n+  poly_int64 off = 0;\n+  tree base = get_addr_base_and_unit_offset (ref, &off);\n+  if (!base || !VAR_P (base))\n+    return NULL_TREE;\n+\n+  /* The size of any member of a declared object other than a flexible\n+     array member is that obtained above.  */\n+  if (size)\n+    return size;\n+\n+  if (tree init = DECL_INITIAL (base))\n+    if (TREE_CODE (init) == CONSTRUCTOR)\n+      {\n+\toff <<= LOG2_BITS_PER_UNIT;\n+\tinit = fold_ctor_reference (NULL_TREE, init, off, 0, base);\n+\tif (init)\n+\t  return TYPE_SIZE_UNIT (TREE_TYPE (init));\n+      }\n+\n+  /* Return \"don't know\" for an external non-array object since its\n+     flexible array member can be initialized to have any number of\n+     elements.  Otherwise, return zero because the flexible array\n+     member has no elements.  */\n+  return (DECL_EXTERNAL (base) && TREE_CODE (TREE_TYPE (base)) != ARRAY_TYPE\n+\t  ? NULL_TREE : integer_zero_node);\n+}\n+\n /* Return the machine mode of T.  For vectors, returns the mode of the\n    inner type.  The main use case is to feed the result to HONOR_NANS,\n    avoiding the BLKmode that a direct TYPE_MODE (T) might return.  */"}, {"sha": "c825109b5f7e5a5be3421fc6ee6f62be67f8f2ab", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6889a3acfeed47265886676c6d43b04ef799fb82/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6889a3acfeed47265886676c6d43b04ef799fb82", "patch": "@@ -5263,6 +5263,13 @@ extern bool array_at_struct_end_p (tree);\n    by EXP.  This does not include any offset in DECL_FIELD_BIT_OFFSET.  */\n extern tree component_ref_field_offset (tree);\n \n+/* Return the size of the member referenced by the COMPONENT_REF, using\n+   its initializer expression if necessary in order to determine the size\n+   of an initialized flexible array member.  The size might be zero for\n+   an object with an uninitialized flexible array member or null if it\n+   cannot be determined.  */\n+extern tree component_ref_size (tree);\n+\n extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);\n extern int tree_map_base_marked_p (const void *);"}]}