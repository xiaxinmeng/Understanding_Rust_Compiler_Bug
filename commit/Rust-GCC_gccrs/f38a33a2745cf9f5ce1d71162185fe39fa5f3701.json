{"sha": "f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM4YTMzYTI3NDVjZjlmNWNlMWQ3MTE2MjE4NWZlMzlmYTVmMzcwMQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-06-16T17:26:32Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-11-23T22:52:29Z"}, "message": "ipa: special pass-through op for Fortran strides\n\nwhen Fortran functions pass array descriptors they receive as a\nparameter to another function, they actually rebuild it.  Thanks to\nwork done mainly by Feng, IPA-CP can already handle the cases when\nthey pass directly the values loaded from the original descriptor.\nUnfortunately, perhaps the most important one, stride, is first\nchecked against zero and is replaced with one in that case:\n\n  _12 = *a_11(D).dim[0].stride;\n  if (_12 != 0)\n    goto <bb 4>; [50.00%]\n  else\n    goto <bb 3>; [50.00%]\n\n  <bb 3>\n    // empty BB\n  <bb 4>\n  # iftmp.22_9 = PHI <_12(2), 1(3)>\n   ...\n   parm.6.dim[0].stride = iftmp.22_9;\n   ...\n   __x_MOD_foo (&parm.6, b_31(D));\n\nin the most important and hopefully common cases, the incoming value\nis already 1 and we fail to propagate it.\n\nI would therefore like to propose the following way of encoding this\nsituation in pass-through jump functions using using ASSERTT_EXPR\noperation code meaning that if the incoming value is the same as the\n\"operand\" in the jump function, it is passed on, otherwise the result\nis unknown.  This of course captures only the single (but most\nimportant) case but is an improvement and does not need enlarging the\njump function structure and is simple to pattern match.  Encoding that\nzero needs to be changed to one would need another field and matching\nit would be slightly more complicated too.\n\ngcc/\n2020-06-12  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (ipa_pass_through_data): Expand comment describing\n\toperation.\n\t* ipa-prop.c (analyze_agg_content_value): Detect new special case and\n\tencode it as ASSERT_EXPR.\n\t* ipa-cp.c (values_equal_for_ipcp_p): Move before\n\tipa_get_jf_arith_result.\n\t(ipa_get_jf_arith_result): Special case ASSERT_EXPR.\n\ngcc/testsuite/\n2020-06-12  Martin Jambor  <mjambor@suse.cz>\n\t* gfortran.dg/ipcp-array-2.f90: New test.", "tree": {"sha": "84e69f026994401e2129fd826576f87a980b585d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84e69f026994401e2129fd826576f87a980b585d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38a33a2745cf9f5ce1d71162185fe39fa5f3701/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f80565da33598c4dbc70ea9c83272ed6bfff7a0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f80565da33598c4dbc70ea9c83272ed6bfff7a0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f80565da33598c4dbc70ea9c83272ed6bfff7a0d"}], "stats": {"total": 252, "additions": 179, "deletions": 73}, "files": [{"sha": "a06b4d151dd7d0bcaa7caa7be10ef3d4c252251f", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38a33a2745cf9f5ce1d71162185fe39fa5f3701/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38a33a2745cf9f5ce1d71162185fe39fa5f3701/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "patch": "@@ -1304,6 +1304,26 @@ initialize_node_lattices (struct cgraph_node *node)\n       }\n }\n \n+/* Return true iff X and Y should be considered equal values by IPA-CP.  */\n+\n+static bool\n+values_equal_for_ipcp_p (tree x, tree y)\n+{\n+  gcc_checking_assert (x != NULL_TREE && y != NULL_TREE);\n+\n+  if (x == y)\n+    return true;\n+\n+  if (TREE_CODE (x) == ADDR_EXPR\n+      && TREE_CODE (y) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (x, 0)) == CONST_DECL\n+      && TREE_CODE (TREE_OPERAND (y, 0)) == CONST_DECL)\n+    return operand_equal_p (DECL_INITIAL (TREE_OPERAND (x, 0)),\n+\t\t\t    DECL_INITIAL (TREE_OPERAND (y, 0)), 0);\n+  else\n+    return operand_equal_p (x, y, 0);\n+}\n+\n /* Return the result of a (possibly arithmetic) operation on the constant\n    value INPUT.  OPERAND is 2nd operand for binary operation.  RES_TYPE is\n    the type of the parameter to which the result is passed.  Return\n@@ -1321,6 +1341,14 @@ ipa_get_jf_arith_result (enum tree_code opcode, tree input, tree operand,\n   if (!is_gimple_ip_invariant (input))\n     return NULL_TREE;\n \n+  if (opcode == ASSERT_EXPR)\n+    {\n+      if (values_equal_for_ipcp_p (input, operand))\n+\treturn input;\n+      else\n+\treturn NULL_TREE;\n+    }\n+\n   if (!res_type)\n     {\n       if (TREE_CODE_CLASS (opcode) == tcc_comparison)\n@@ -1753,26 +1781,6 @@ ipcp_verify_propagated_values (void)\n     }\n }\n \n-/* Return true iff X and Y should be considered equal values by IPA-CP.  */\n-\n-static bool\n-values_equal_for_ipcp_p (tree x, tree y)\n-{\n-  gcc_checking_assert (x != NULL_TREE && y != NULL_TREE);\n-\n-  if (x == y)\n-    return true;\n-\n-  if (TREE_CODE (x) ==  ADDR_EXPR\n-      && TREE_CODE (y) ==  ADDR_EXPR\n-      && TREE_CODE (TREE_OPERAND (x, 0)) == CONST_DECL\n-      && TREE_CODE (TREE_OPERAND (y, 0)) == CONST_DECL)\n-    return operand_equal_p (DECL_INITIAL (TREE_OPERAND (x, 0)),\n-\t\t\t    DECL_INITIAL (TREE_OPERAND (y, 0)), 0);\n-  else\n-    return operand_equal_p (x, y, 0);\n-}\n-\n /* Return true iff X and Y should be considered equal contexts by IPA-CP.  */\n \n static bool"}, {"sha": "130b2f84b78bf7a352dacef84618652430ff66d2", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 98, "deletions": 50, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38a33a2745cf9f5ce1d71162185fe39fa5f3701/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38a33a2745cf9f5ce1d71162185fe39fa5f3701/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "patch": "@@ -1775,75 +1775,123 @@ analyze_agg_content_value (struct ipa_func_body_info *fbi,\n \n       stmt = SSA_NAME_DEF_STMT (rhs1);\n       if (!is_gimple_assign (stmt))\n-\treturn;\n+\tbreak;\n \n       rhs1 = gimple_assign_rhs1 (stmt);\n     }\n \n-  code = gimple_assign_rhs_code (stmt);\n-  switch (gimple_assign_rhs_class (stmt))\n+  if (gphi *phi = dyn_cast<gphi *> (stmt))\n     {\n-    case GIMPLE_SINGLE_RHS:\n-      if (is_gimple_ip_invariant (rhs1))\n-\t{\n-\t  agg_value->pass_through.operand = rhs1;\n-\t  return;\n-\t}\n-      code = NOP_EXPR;\n-      break;\n+      /* Also special case like the following (a is a formal parameter):\n+\n+\t   _12 = *a_11(D).dim[0].stride;\n+\t   ...\n+\t   # iftmp.22_9 = PHI <_12(2), 1(3)>\n+\t   ...\n+\t   parm.6.dim[0].stride = iftmp.22_9;\n+\t   ...\n+\t   __x_MOD_foo (&parm.6, b_31(D));\n \n-    case GIMPLE_UNARY_RHS:\n-      /* NOTE: A GIMPLE_UNARY_RHS operation might not be tcc_unary\n-\t (truth_not_expr is example), GIMPLE_BINARY_RHS does not imply\n-\t tcc_binary, this subtleness is somewhat misleading.\n+\t The aggregate function describing parm.6.dim[0].stride is encoded as a\n+\t PASS-THROUGH jump function with ASSERT_EXPR operation whith operand 1\n+\t (the constant from the PHI node).  */\n \n-\t Since tcc_unary is widely used in IPA-CP code to check an operation\n-\t with one operand, here we only allow tc_unary operation to avoid\n-\t possible problem.  Then we can use (opclass == tc_unary) or not to\n-\t distinguish unary and binary.  */\n-      if (TREE_CODE_CLASS (code) != tcc_unary || CONVERT_EXPR_CODE_P (code))\n+      if (gimple_phi_num_args (phi) != 2)\n+\treturn;\n+      tree arg0 = gimple_phi_arg_def (phi, 0);\n+      tree arg1 = gimple_phi_arg_def (phi, 1);\n+      tree operand;\n+\n+      if (is_gimple_ip_invariant (arg1))\n+\t{\n+\t  operand = arg1;\n+\t  rhs1 = arg0;\n+\t}\n+      else if (is_gimple_ip_invariant (arg0))\n+\t{\n+\t  operand = arg0;\n+\t  rhs1 = arg1;\n+\t}\n+      else\n \treturn;\n \n       rhs1 = get_ssa_def_if_simple_copy (rhs1, &stmt);\n-      break;\n+      if (!is_gimple_assign (stmt))\n+\treturn;\n \n-    case GIMPLE_BINARY_RHS:\n-      {\n-\tgimple *rhs1_stmt = stmt;\n-\tgimple *rhs2_stmt = stmt;\n-\ttree rhs2 = gimple_assign_rhs2 (stmt);\n+      code = ASSERT_EXPR;\n+      agg_value->pass_through.operand = operand;\n+    }\n+  else if (is_gimple_assign (stmt))\n+    {\n+      code = gimple_assign_rhs_code (stmt);\n+      switch (gimple_assign_rhs_class (stmt))\n+\t{\n+\tcase GIMPLE_SINGLE_RHS:\n+\t  if (is_gimple_ip_invariant (rhs1))\n+\t    {\n+\t      agg_value->pass_through.operand = rhs1;\n+\t      return;\n+\t    }\n+\t  code = NOP_EXPR;\n+\t  break;\n \n-\trhs1 = get_ssa_def_if_simple_copy (rhs1, &rhs1_stmt);\n-\trhs2 = get_ssa_def_if_simple_copy (rhs2, &rhs2_stmt);\n+\tcase GIMPLE_UNARY_RHS:\n+\t  /* NOTE: A GIMPLE_UNARY_RHS operation might not be tcc_unary\n+\t     (truth_not_expr is example), GIMPLE_BINARY_RHS does not imply\n+\t     tcc_binary, this subtleness is somewhat misleading.\n+\n+\t     Since tcc_unary is widely used in IPA-CP code to check an operation\n+\t     with one operand, here we only allow tc_unary operation to avoid\n+\t     possible problem.  Then we can use (opclass == tc_unary) or not to\n+\t     distinguish unary and binary.  */\n+\t  if (TREE_CODE_CLASS (code) != tcc_unary || CONVERT_EXPR_CODE_P (code))\n+\t    return;\n \n-\tif (is_gimple_ip_invariant (rhs2))\n-\t  {\n-\t    agg_value->pass_through.operand = rhs2;\n-\t    stmt = rhs1_stmt;\n-\t  }\n-\telse if (is_gimple_ip_invariant (rhs1))\n+\t  rhs1 = get_ssa_def_if_simple_copy (rhs1, &stmt);\n+\t  break;\n+\n+\tcase GIMPLE_BINARY_RHS:\n \t  {\n-\t    if (TREE_CODE_CLASS (code) == tcc_comparison)\n-\t      code = swap_tree_comparison (code);\n-\t    else if (!commutative_tree_code (code))\n+\t    gimple *rhs1_stmt = stmt;\n+\t    gimple *rhs2_stmt = stmt;\n+\t    tree rhs2 = gimple_assign_rhs2 (stmt);\n+\n+\t    rhs1 = get_ssa_def_if_simple_copy (rhs1, &rhs1_stmt);\n+\t    rhs2 = get_ssa_def_if_simple_copy (rhs2, &rhs2_stmt);\n+\n+\t    if (is_gimple_ip_invariant (rhs2))\n+\t      {\n+\t\tagg_value->pass_through.operand = rhs2;\n+\t\tstmt = rhs1_stmt;\n+\t      }\n+\t    else if (is_gimple_ip_invariant (rhs1))\n+\t      {\n+\t\tif (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t\t  code = swap_tree_comparison (code);\n+\t\telse if (!commutative_tree_code (code))\n+\t\t  return;\n+\n+\t\tagg_value->pass_through.operand = rhs1;\n+\t\tstmt = rhs2_stmt;\n+\t\trhs1 = rhs2;\n+\t      }\n+\t    else\n \t      return;\n \n-\t    agg_value->pass_through.operand = rhs1;\n-\t    stmt = rhs2_stmt;\n-\t    rhs1 = rhs2;\n+\t    if (TREE_CODE_CLASS (code) != tcc_comparison\n+\t\t&& !useless_type_conversion_p (TREE_TYPE (lhs),\n+\t\t\t\t\t       TREE_TYPE (rhs1)))\n+\t      return;\n \t  }\n-\telse\n-\t  return;\n+\t  break;\n \n-\tif (TREE_CODE_CLASS (code) != tcc_comparison\n-\t    && !useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs1)))\n+\tdefault:\n \t  return;\n-      }\n-      break;\n-\n-    default:\n-      return;\n-  }\n+\t}\n+    }\n+  else\n+    return;\n \n   if (TREE_CODE (rhs1) != SSA_NAME)\n     index = load_from_unmodified_param_or_agg (fbi, fbi->info, stmt,"}, {"sha": "112a1ba580bf59520322c45ba2ddc6a59b05dd7f", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38a33a2745cf9f5ce1d71162185fe39fa5f3701/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38a33a2745cf9f5ce1d71162185fe39fa5f3701/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "patch": "@@ -94,9 +94,14 @@ struct GTY(()) ipa_pass_through_data\n   /* Number of the caller's formal parameter being passed.  */\n   int formal_id;\n   /* Operation that is performed on the argument before it is passed on.\n-     NOP_EXPR means no operation.  Otherwise oper must be a simple binary\n-     arithmetic operation where the caller's parameter is the first operand and\n-     operand field from this structure is the second one.  */\n+     Special values which have other meaning than in normal contexts:\n+       - NOP_EXPR means no operation, not even type conversion.\n+       - ASSERT_EXPR means that only the value in operand is allowed to pass\n+         through (without any change), for all other values the result is\n+         unknown.\n+     Otherwise operation must be a simple binary or unary arithmetic operation\n+     where the caller's parameter is the first operand and (for binary\n+     operations) the operand field from this structure is the second one.  */\n   enum tree_code operation;\n   /* When the passed value is a pointer, it is set to true only when we are\n      certain that no write to the object it points to has occurred since the"}, {"sha": "9af8fffa7ea887689e5d3f997c7fc324728b3932", "filename": "gcc/testsuite/gfortran.dg/ipcp-array-2.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38a33a2745cf9f5ce1d71162185fe39fa5f3701/gcc%2Ftestsuite%2Fgfortran.dg%2Fipcp-array-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38a33a2745cf9f5ce1d71162185fe39fa5f3701/gcc%2Ftestsuite%2Fgfortran.dg%2Fipcp-array-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fipcp-array-2.f90?ref=f38a33a2745cf9f5ce1d71162185fe39fa5f3701", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -fno-inline -fwhole-program -fdump-ipa-cp-details -fdump-tree-lversion-details\" }\n+\n+module x\n+  implicit none\n+contains\n+  subroutine foo(a, b)\n+    real :: a(:,:)\n+    real :: b\n+    integer :: i,j\n+    b = 0.\n+    do j=1,size(a,2)\n+       do i=1,size(a,1)\n+          b = b + a(i,j) * i * j\n+       end do\n+    end do\n+  end subroutine foo\n+\n+  subroutine bar(a, b)\n+    real :: a(:,:)\n+    real :: b\n+    call foo (a,b)\n+  end subroutine bar\n+\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer :: n, m\n+  real, dimension(4,3) :: a\n+  real, dimension(3,4) :: c     \n+  real :: b\n+  call random_number(a)\n+  call bar(a,b)\n+  print *,b\n+  \n+  call random_number(c)\n+  call bar(c,b)\n+  print *,b\n+  \n+end program main\n+\n+! { dg-final { scan-ipa-dump \"op assert_expr 1\" \"cp\" } }\n+! { dg-final { scan-tree-dump-not \"versioned this loop for when certain strides are 1\" \"lversion\" } }"}]}