{"sha": "b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdkOTNiNDY4YTA4ZDQ2ZDViZDdkMGVkOWUwODY5NWVlZjg5Y2UyNA==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2013-10-11T22:17:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-10-11T22:17:47Z"}, "message": "compiler: Use backend interface for function code expressions.\n\n\t* go-gcc.cc (Gcc_backend::function_code_expression): New\n\tfunction.\n\nFrom-SVN: r203467", "tree": {"sha": "99f0ea46175de93ca5f449a6f4e1c690d5ff89c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99f0ea46175de93ca5f449a6f4e1c690d5ff89c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/comments", "author": null, "committer": null, "parents": [{"sha": "ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3cfba23d0f9c518cc71ff053994e77e80f1d1a"}], "stats": {"total": 245, "additions": 135, "deletions": 110}, "files": [{"sha": "4d0dd11f662412b94f4129a7e06b51a85e2528b2", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "patch": "@@ -1,26 +1,31 @@\n+2013-10-11  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::function_code_expression): New\n+\tfunction.\n+\n 2013-10-10  Chris Manghane  <cmang@google.com>\n \n-\t* go-gcc.cc (Backend::error_function): New function.\n-\t(Backend::function): New function.\n-\t(Backend::make_function): New function.\n+\t* go-gcc.cc (Gcc_backend::error_function): New function.\n+\t(Gcc_backend::function): New function.\n+\t(Gcc_backend::make_function): New function.\n \t(function_to_tree): New function.\n \n 2013-10-04  Chris Manghane  <cmang@google.com>\n \n-\t* go-gcc.cc (Backend::convert_expression): New function.\n+\t* go-gcc.cc (Gcc_backend::convert_expression): New function.\n \n 2013-10-02  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc: Include \"real.h\" and \"realmpfr.h\".\n-\t(Backend::integer_constant_expression): New function.\n-\t(Backend::float_constant_expression): New function.\n-\t(Backend::complex_constant_expression): New function.\n+\t(Gcc_backend::integer_constant_expression): New function.\n+\t(Gcc_backend::float_constant_expression): New function.\n+\t(Gcc_backend::complex_constant_expression): New function.\n \n 2013-09-30  Chris Manghane  <cmang@google.com>\n \n-\t* go-gcc.cc (Backend::error_expression): New function.\n-\t(Backend::var_expression): New function.\n-\t(Backend::indirect_expression): New function.\n+\t* go-gcc.cc (Gcc_backend::error_expression): New function.\n+\t(Gcc_backend::var_expression): New function.\n+\t(Gcc_backend::indirect_expression): New function.\n \n 2013-09-25  Tom Tromey  <tromey@redhat.com>\n \n@@ -515,7 +520,7 @@\n \n 2011-04-14  Ian Lance Taylor  <iant@google.com>\n \n-\t* go-gcc.cc (Backend::error_statement): New function.\n+\t* go-gcc.cc (Gcc_backend::error_statement): New function.\n \n 2011-04-13  Ian Lance Taylor  <iant@google.com>\n "}, {"sha": "81e9ad18610a7878b2ff34366d7799e6d700573e", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "patch": "@@ -232,6 +232,9 @@ class Gcc_backend : public Backend\n   Bexpression*\n   convert_expression(Btype* type, Bexpression* expr, Location);\n \n+  Bexpression*\n+  function_code_expression(Bfunction*, Location);\n+\n   // Statements.\n \n   Bstatement*\n@@ -981,6 +984,19 @@ Gcc_backend::convert_expression(Btype* type, Bexpression* expr, Location)\n   return tree_to_expr(ret);\n }\n \n+// Get the address of a function.\n+\n+Bexpression*\n+Gcc_backend::function_code_expression(Bfunction* bfunc, Location location)\n+{\n+  tree func = bfunc->get_tree();\n+  if (func == error_mark_node)\n+    return this->error_expression();\n+\n+  tree ret = build_fold_addr_expr_loc(location.gcc_location(), func);\n+  return this->make_expression(ret);\n+}\n+\n // An expression as a statement.\n \n Bstatement*"}, {"sha": "ca997f08adeb721aa249f4da336ce7311810ce75", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "patch": "@@ -266,6 +266,11 @@ class Backend\n   virtual Bexpression*\n   convert_expression(Btype* type, Bexpression* expr, Location) = 0;\n \n+  // Create an expression for the address of a function.  This is used to\n+  // get the address of the code for a function.\n+  virtual Bexpression*\n+  function_code_expression(Bfunction*, Location) = 0;\n+\n   // Statements.\n \n   // Create an error statement.  This is used for cases which should"}, {"sha": "6ba351e2f42ceb0f033628ca95ee114dc4612060", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "patch": "@@ -1219,7 +1219,7 @@ Func_expression::do_type()\n \n // Get the tree for the code of a function expression.\n \n-tree\n+Bexpression*\n Func_expression::get_code_pointer(Gogo* gogo, Named_object* no, Location loc)\n {\n   Function_type* fntype;\n@@ -1237,21 +1237,18 @@ Func_expression::get_code_pointer(Gogo* gogo, Named_object* no, Location loc)\n       error_at(loc,\n \t       \"invalid use of special builtin function %qs; must be called\",\n \t       no->message_name().c_str());\n-      return error_mark_node;\n+      return gogo->backend()->error_expression();\n     }\n \n-  tree fndecl;\n+  Bfunction* fndecl;\n   if (no->is_function())\n     fndecl = no->func_value()->get_or_make_decl(gogo, no);\n   else if (no->is_function_declaration())\n     fndecl = no->func_declaration_value()->get_or_make_decl(gogo, no);\n   else\n     go_unreachable();\n \n-  if (fndecl == error_mark_node)\n-    return error_mark_node;\n-\n-  return build_fold_addr_expr_loc(loc.gcc_location(), fndecl);\n+  return gogo->backend()->function_code_expression(fndecl, loc);\n }\n \n // Get the tree for a function expression.  This is used when we take\n@@ -1488,8 +1485,10 @@ class Func_code_reference_expression : public Expression\n tree\n Func_code_reference_expression::do_get_tree(Translate_context* context)\n {\n-  return Func_expression::get_code_pointer(context->gogo(), this->function_,\n-\t\t\t\t\t   this->location());\n+  Bexpression* ret =\n+      Func_expression::get_code_pointer(context->gogo(), this->function_,\n+                                        this->location());\n+  return expr_to_tree(ret);\n }\n \n // Make a reference to the code of a function.\n@@ -9846,7 +9845,7 @@ Call_expression::do_get_tree(Translate_context* context)\n   if (func != NULL)\n     {\n       Named_object* no = func->named_object();\n-      fn = Func_expression::get_code_pointer(gogo, no, location);\n+      fn = expr_to_tree(Func_expression::get_code_pointer(gogo, no, location));\n       if (!has_closure)\n \tclosure_tree = NULL_TREE;\n       else"}, {"sha": "35bfcfe8e4f248e436426ee31d63c03816332244", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "patch": "@@ -1514,8 +1514,8 @@ class Func_expression : public Expression\n   closure()\n   { return this->closure_; }\n \n-  // Return a tree for the code for a function.\n-  static tree\n+  // Return a backend expression for the code of a function.\n+  static Bexpression*\n   get_code_pointer(Gogo*, Named_object* function, Location loc);\n \n  protected:"}, {"sha": "fbc46526ef0d684dd951e76da5101f9c560b0cf3", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 9, "deletions": 83, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "patch": "@@ -1089,7 +1089,7 @@ Named_object::get_tree(Gogo* gogo, Named_object* function)\n     case NAMED_OBJECT_FUNC:\n       {\n \tFunction* func = this->u_.func_value;\n-\tdecl = func->get_or_make_decl(gogo, this);\n+\tdecl = function_to_tree(func->get_or_make_decl(gogo, this));\n \tif (decl != error_mark_node)\n \t  {\n \t    if (func->block() != NULL)\n@@ -1214,83 +1214,9 @@ Variable::get_init_block(Gogo* gogo, Named_object* function, tree var_decl)\n   return block_tree;\n }\n \n-// Get a tree for a function decl.\n+// Get the backend representation.\n \n-tree\n-Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n-{\n-  if (this->fndecl_ == NULL)\n-    {\n-      std::string asm_name;\n-      bool is_visible = false;\n-      if (no->package() != NULL)\n-        ;\n-      else if (this->enclosing_ != NULL || Gogo::is_thunk(no))\n-        ;\n-      else if (Gogo::unpack_hidden_name(no->name()) == \"init\"\n-               && !this->type_->is_method())\n-        ;\n-      else if (Gogo::unpack_hidden_name(no->name()) == \"main\"\n-               && gogo->is_main_package())\n-        is_visible = true;\n-      // Methods have to be public even if they are hidden because\n-      // they can be pulled into type descriptors when using\n-      // anonymous fields.\n-      else if (!Gogo::is_hidden_name(no->name())\n-               || this->type_->is_method())\n-        {\n-          is_visible = true;\n-          std::string pkgpath = gogo->pkgpath_symbol();\n-          if (this->type_->is_method()\n-              && Gogo::is_hidden_name(no->name())\n-              && Gogo::hidden_name_pkgpath(no->name()) != gogo->pkgpath())\n-            {\n-              // This is a method we created for an unexported\n-              // method of an imported embedded type.  We need to\n-              // use the pkgpath of the imported package to avoid\n-              // a possible name collision.  See bug478 for a test\n-              // case.\n-              pkgpath = Gogo::hidden_name_pkgpath(no->name());\n-              pkgpath = Gogo::pkgpath_for_symbol(pkgpath);\n-            }\n-\n-          asm_name = pkgpath;\n-          asm_name.append(1, '.');\n-          asm_name.append(Gogo::unpack_hidden_name(no->name()));\n-          if (this->type_->is_method())\n-            {\n-              asm_name.append(1, '.');\n-              Type* rtype = this->type_->receiver()->type();\n-              asm_name.append(rtype->mangled_name(gogo));\n-            }\n-        }\n-\n-      // If a function calls the predeclared recover function, we\n-      // can't inline it, because recover behaves differently in a\n-      // function passed directly to defer.  If this is a recover\n-      // thunk that we built to test whether a function can be\n-      // recovered, we can't inline it, because that will mess up\n-      // our return address comparison.\n-      bool is_inlinable = !(this->calls_recover_ || this->is_recover_thunk_);\n-\n-      // If this is a thunk created to call a function which calls\n-      // the predeclared recover function, we need to disable\n-      // stack splitting for the thunk.\n-      bool disable_split_stack = this->is_recover_thunk_;\n-\n-      Btype* functype = this->type_->get_backend_fntype(gogo);\n-      this->fndecl_ =\n-          gogo->backend()->function(functype, no->get_id(gogo), asm_name,\n-                                    is_visible, false, is_inlinable,\n-                                    disable_split_stack,\n-                                    this->in_unique_section_, this->location());\n-    }\n-  return function_to_tree(this->fndecl_);\n-}\n-\n-// Get a tree for a function declaration.\n-\n-tree\n+Bfunction*\n Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n {\n   if (this->fndecl_ == NULL)\n@@ -1304,7 +1230,7 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n \t  if (p != builtin_functions.end())\n \t    {\n \t      this->fndecl_ = tree_to_function(p->second);\n-\t      return p->second;\n+\t      return this->fndecl_;\n \t    }\n \t}\n \n@@ -1331,7 +1257,7 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n                                     this->location());\n     }\n \n-  return function_to_tree(this->fndecl_);\n+  return this->fndecl_;\n }\n \n // Return the function's decl after it has been built.\n@@ -2202,14 +2128,14 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n       go_assert(m != NULL);\n \n       Named_object* no = m->named_object();\n-      tree fndecl;\n+      Bfunction* bf;\n       if (no->is_function())\n-\tfndecl = no->func_value()->get_or_make_decl(this, no);\n+\tbf = no->func_value()->get_or_make_decl(this, no);\n       else if (no->is_function_declaration())\n-\tfndecl = no->func_declaration_value()->get_or_make_decl(this, no);\n+\tbf = no->func_declaration_value()->get_or_make_decl(this, no);\n       else\n \tgo_unreachable();\n-      fndecl = build_fold_addr_expr(fndecl);\n+      tree fndecl = build_fold_addr_expr(function_to_tree(bf));\n \n       elt = pointers->quick_push(empty);\n       elt->index = size_int(i);"}, {"sha": "0796caaa94ca8e3b032ab85ebf4ae75018758159", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "patch": "@@ -3819,6 +3819,80 @@ Function::import_func(Import* imp, std::string* pname,\n   *presults = results;\n }\n \n+// Get the backend representation.\n+\n+Bfunction*\n+Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n+{\n+  if (this->fndecl_ == NULL)\n+    {\n+      std::string asm_name;\n+      bool is_visible = false;\n+      if (no->package() != NULL)\n+        ;\n+      else if (this->enclosing_ != NULL || Gogo::is_thunk(no))\n+        ;\n+      else if (Gogo::unpack_hidden_name(no->name()) == \"init\"\n+               && !this->type_->is_method())\n+        ;\n+      else if (Gogo::unpack_hidden_name(no->name()) == \"main\"\n+               && gogo->is_main_package())\n+        is_visible = true;\n+      // Methods have to be public even if they are hidden because\n+      // they can be pulled into type descriptors when using\n+      // anonymous fields.\n+      else if (!Gogo::is_hidden_name(no->name())\n+               || this->type_->is_method())\n+        {\n+          is_visible = true;\n+          std::string pkgpath = gogo->pkgpath_symbol();\n+          if (this->type_->is_method()\n+              && Gogo::is_hidden_name(no->name())\n+              && Gogo::hidden_name_pkgpath(no->name()) != gogo->pkgpath())\n+            {\n+              // This is a method we created for an unexported\n+              // method of an imported embedded type.  We need to\n+              // use the pkgpath of the imported package to avoid\n+              // a possible name collision.  See bug478 for a test\n+              // case.\n+              pkgpath = Gogo::hidden_name_pkgpath(no->name());\n+              pkgpath = Gogo::pkgpath_for_symbol(pkgpath);\n+            }\n+\n+          asm_name = pkgpath;\n+          asm_name.append(1, '.');\n+          asm_name.append(Gogo::unpack_hidden_name(no->name()));\n+          if (this->type_->is_method())\n+            {\n+              asm_name.append(1, '.');\n+              Type* rtype = this->type_->receiver()->type();\n+              asm_name.append(rtype->mangled_name(gogo));\n+            }\n+        }\n+\n+      // If a function calls the predeclared recover function, we\n+      // can't inline it, because recover behaves differently in a\n+      // function passed directly to defer.  If this is a recover\n+      // thunk that we built to test whether a function can be\n+      // recovered, we can't inline it, because that will mess up\n+      // our return address comparison.\n+      bool is_inlinable = !(this->calls_recover_ || this->is_recover_thunk_);\n+\n+      // If this is a thunk created to call a function which calls\n+      // the predeclared recover function, we need to disable\n+      // stack splitting for the thunk.\n+      bool disable_split_stack = this->is_recover_thunk_;\n+\n+      Btype* functype = this->type_->get_backend_fntype(gogo);\n+      this->fndecl_ =\n+          gogo->backend()->function(functype, no->get_id(gogo), asm_name,\n+                                    is_visible, false, is_inlinable,\n+                                    disable_split_stack,\n+                                    this->in_unique_section_, this->location());\n+    }\n+  return this->fndecl_;\n+}\n+\n // Class Block.\n \n Block::Block(Block* enclosing, Location location)"}, {"sha": "8c4ccf981797aaf00395a23f6786dfe3be36a5b6", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7d93b468a08d46d5bd7d0ed9e08695eef89ce24/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=b7d93b468a08d46d5bd7d0ed9e08695eef89ce24", "patch": "@@ -1090,8 +1090,8 @@ class Function\n     this->descriptor_ = descriptor;\n   }\n \n-  // Return the function's decl given an identifier.\n-  tree\n+  // Return the backend representation.\n+  Bfunction*\n   get_or_make_decl(Gogo*, Named_object*);\n \n   // Return the function's decl after it has been built.\n@@ -1262,8 +1262,8 @@ class Function_declaration\n   has_descriptor() const\n   { return this->descriptor_ != NULL; }\n \n-  // Return a decl for the function given an identifier.\n-  tree\n+  // Return a backend representation.\n+  Bfunction*\n   get_or_make_decl(Gogo*, Named_object*);\n \n   // If there is a descriptor, build it into the backend"}]}