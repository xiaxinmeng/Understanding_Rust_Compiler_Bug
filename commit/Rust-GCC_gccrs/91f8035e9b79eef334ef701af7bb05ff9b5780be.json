{"sha": "91f8035e9b79eef334ef701af7bb05ff9b5780be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFmODAzNWU5Yjc5ZWVmMzM0ZWY3MDFhZjdiYjA1ZmY5YjU3ODBiZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-08-01T20:26:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-08-01T20:26:58Z"}, "message": "Allow MODE_PARTIAL_INT in expmed costs\n\nFrom-SVN: r190050", "tree": {"sha": "fe0865e7d97255b0742bf37f86bc1c0daf402632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe0865e7d97255b0742bf37f86bc1c0daf402632"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91f8035e9b79eef334ef701af7bb05ff9b5780be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f8035e9b79eef334ef701af7bb05ff9b5780be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f8035e9b79eef334ef701af7bb05ff9b5780be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f8035e9b79eef334ef701af7bb05ff9b5780be/comments", "author": null, "committer": null, "parents": [{"sha": "92e014ca10fdba3f12a05f18fcbf7355a9201a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92e014ca10fdba3f12a05f18fcbf7355a9201a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92e014ca10fdba3f12a05f18fcbf7355a9201a94"}], "stats": {"total": 192, "additions": 106, "deletions": 86}, "files": [{"sha": "9b2019fc4c1961a5559139cad9f75cd730dcd393", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f8035e9b79eef334ef701af7bb05ff9b5780be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f8035e9b79eef334ef701af7bb05ff9b5780be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91f8035e9b79eef334ef701af7bb05ff9b5780be", "patch": "@@ -1,3 +1,19 @@\n+2012-08-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* expmed.h (NUM_MODE_PARTIAL_INT): New.\n+\t(NUM_MODE_VECTOR_INT, NUM_MODE_IP_INT, NUM_MODE_IPV_INT): New.\n+\t(struct expmed_op_cheap): Size one array on NUM_MODE_IPV_INT.\n+\t(struct expmed_op_costs): Likewise.\n+\t(struct target_expmed): Size x_convert_cost on NUM_MODE_IP_INT.\n+\t(expmed_mode_index): New.\n+\t(expmed_op_cheap_ptr, expmed_op_cost_ptr): Use expmed_mode_index.\n+\t(convert_cost_ptr): Likewise.\n+\t* expmed.c (struct init_expmed_rtl): Rename convert to trunc.\n+\t(init_expmed_one_conv): Split out from ...\n+\t(init_expmed_one_mode): ... here.  Iterate conversions over\n+\tpartial integer modes too.\n+\t(init_expmed): Iterate over partial integer modes too.\n+\n 2012-08-01  Richard Henderson  <rth@redhat.com>\n \n \t* config/m32c/m32c.c (TARGET_INIT_LIBFUNCS): Remove."}, {"sha": "d91d8f159e6bd08bd9f85d247ad3d7a660ff6cb4", "filename": "gcc/expmed.c", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f8035e9b79eef334ef701af7bb05ff9b5780be/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f8035e9b79eef334ef701af7bb05ff9b5780be/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=91f8035e9b79eef334ef701af7bb05ff9b5780be", "patch": "@@ -101,7 +101,6 @@ struct init_expmed_rtl\n   struct rtx_def mult;\trtunion mult_fld1;\n   struct rtx_def sdiv;\trtunion sdiv_fld1;\n   struct rtx_def udiv;\trtunion udiv_fld1;\n-  struct rtx_def zext;\n   struct rtx_def sdiv_32;\trtunion sdiv_32_fld1;\n   struct rtx_def smod_32;\trtunion smod_32_fld1;\n   struct rtx_def wide_mult;\trtunion wide_mult_fld1;\n@@ -112,12 +111,35 @@ struct init_expmed_rtl\n   struct rtx_def shift_add;\trtunion shift_add_fld1;\n   struct rtx_def shift_sub0;\trtunion shift_sub0_fld1;\n   struct rtx_def shift_sub1;\trtunion shift_sub1_fld1;\n-  struct rtx_def convert;\n+  struct rtx_def zext;\n+  struct rtx_def trunc;\n \n   rtx pow2[MAX_BITS_PER_WORD];\n   rtx cint[MAX_BITS_PER_WORD];\n };\n \n+static void\n+init_expmed_one_conv (struct init_expmed_rtl *all, enum machine_mode to_mode,\n+\t\t      enum machine_mode from_mode, bool speed)\n+{\n+  int to_size, from_size;\n+  rtx which;\n+\n+  /* We're given no information about the true size of a partial integer,\n+     only the size of the \"full\" integer it requires for storage.  For\n+     comparison purposes here, reduce the bit size by one in that case.  */\n+  to_size = (GET_MODE_BITSIZE (to_mode)\n+\t     - (GET_MODE_CLASS (to_mode) == MODE_PARTIAL_INT));\n+  from_size = (GET_MODE_BITSIZE (from_mode)\n+\t       - (GET_MODE_CLASS (from_mode) == MODE_PARTIAL_INT));\n+  \n+  /* Assume cost of zero-extend and sign-extend is the same.  */\n+  which = (to_size < from_size ? &all->trunc : &all->zext);\n+\n+  PUT_MODE (&all->reg, from_mode);\n+  set_convert_cost (to_mode, from_mode, speed, set_src_cost (which, speed));\n+}\n+\n static void\n init_expmed_one_mode (struct init_expmed_rtl *all,\n \t\t      enum machine_mode mode, int speed)\n@@ -141,7 +163,8 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n   PUT_MODE (&all->shift_add, mode);\n   PUT_MODE (&all->shift_sub0, mode);\n   PUT_MODE (&all->shift_sub1, mode);\n-  PUT_MODE (&all->convert, mode);\n+  PUT_MODE (&all->zext, mode);\n+  PUT_MODE (&all->trunc, mode);\n \n   set_add_cost (speed, mode, set_src_cost (&all->plus, speed));\n   set_neg_cost (speed, mode, set_src_cost (&all->neg, speed));\n@@ -176,42 +199,25 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n \n   if (SCALAR_INT_MODE_P (mode))\n     {\n-      enum machine_mode wider_mode = GET_MODE_WIDER_MODE (mode);\n-\n+      for (mode_from = MIN_MODE_INT; mode_from <= MAX_MODE_INT;\n+\t   mode_from = (enum machine_mode)(mode_from + 1))\n+\tinit_expmed_one_conv (all, mode, mode_from, speed);\n+    }\n+  if (GET_MODE_CLASS (mode) == MODE_INT)\n+    {\n+      enum machine_mode  wider_mode = GET_MODE_WIDER_MODE (mode);\n       if (wider_mode != VOIDmode)\n \t{\n \t  PUT_MODE (&all->zext, wider_mode);\n \t  PUT_MODE (&all->wide_mult, wider_mode);\n \t  PUT_MODE (&all->wide_lshr, wider_mode);\n \t  XEXP (&all->wide_lshr, 1) = GEN_INT (mode_bitsize);\n \n-\t  set_mul_widen_cost (speed, wider_mode, set_src_cost (&all->wide_mult, speed));\n-\t  set_mul_highpart_cost (speed, mode, set_src_cost (&all->wide_trunc, speed));\n+\t  set_mul_widen_cost (speed, wider_mode,\n+\t\t\t      set_src_cost (&all->wide_mult, speed));\n+\t  set_mul_highpart_cost (speed, mode,\n+\t\t\t\t set_src_cost (&all->wide_trunc, speed));\n \t}\n-\n-      for (mode_from = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   mode_from != VOIDmode;\n-\t   mode_from = GET_MODE_WIDER_MODE (mode_from))\n-\tif (mode != mode_from)\n-\t  {\n-\t    unsigned short size_to = GET_MODE_SIZE (mode);\n-\t    unsigned short size_from = GET_MODE_SIZE (mode_from);\n-\t    if (size_to < size_from)\n-\t      {\n-\t\tPUT_CODE (&all->convert, TRUNCATE);\n-\t\tPUT_MODE (&all->reg, mode_from);\n-\t\tset_convert_cost (mode, mode_from, speed,\n-\t\t\t\t  set_src_cost (&all->convert, speed));\n-\t      }\n-\t    else if (size_from < size_to)\n-\t      {\n-\t\t/* Assume cost of zero-extend and sign-extend is the same.  */\n-\t\tPUT_CODE (&all->convert, ZERO_EXTEND);\n-\t\tPUT_MODE (&all->reg, mode_from);\n-\t\tset_convert_cost (mode, mode_from, speed,\n-\t\t\t\t  set_src_cost (&all->convert, speed));\n-\t      }\n-\t  }\n     }\n }\n \n@@ -291,23 +297,27 @@ init_expmed (void)\n   XEXP (&all.shift_sub1, 0) = &all.reg;\n   XEXP (&all.shift_sub1, 1) = &all.shift_mult;\n \n-  PUT_CODE (&all.convert, TRUNCATE);\n-  XEXP (&all.convert, 0) = &all.reg;\n+  PUT_CODE (&all.trunc, TRUNCATE);\n+  XEXP (&all.trunc, 0) = &all.reg;\n \n   for (speed = 0; speed < 2; speed++)\n     {\n       crtl->maybe_hot_insn_p = speed;\n       set_zero_cost (speed, set_src_cost (const0_rtx, speed));\n \n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n+      for (mode = MIN_MODE_INT; mode <= MAX_MODE_INT;\n+\t   mode = (enum machine_mode)(mode + 1))\n \tinit_expmed_one_mode (&all, mode, speed);\n \n-      for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);\n-\t   mode != VOIDmode;\n-\t   mode = GET_MODE_WIDER_MODE (mode))\n-\tinit_expmed_one_mode (&all, mode, speed);\n+      if (MIN_MODE_PARTIAL_INT != VOIDmode)\n+\tfor (mode = MIN_MODE_PARTIAL_INT; mode <= MAX_MODE_PARTIAL_INT;\n+\t     mode = (enum machine_mode)(mode + 1))\n+\t  init_expmed_one_mode (&all, mode, speed);\n+\n+      if (MIN_MODE_VECTOR_INT != VOIDmode)\n+\tfor (mode = MIN_MODE_VECTOR_INT; mode <= MAX_MODE_VECTOR_INT;\n+\t     mode = (enum machine_mode)(mode + 1))\n+\t  init_expmed_one_mode (&all, mode, speed);\n     }\n \n   if (alg_hash_used_p ())"}, {"sha": "05d0c15bf5ef17e70845804c2a9586189e3e212e", "filename": "gcc/expmed.h", "status": "modified", "additions": 40, "deletions": 46, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f8035e9b79eef334ef701af7bb05ff9b5780be/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f8035e9b79eef334ef701af7bb05ff9b5780be/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=91f8035e9b79eef334ef701af7bb05ff9b5780be", "patch": "@@ -124,23 +124,24 @@ struct alg_hash_entry {\n #define NUM_ALG_HASH_ENTRIES 307\n #endif\n \n-#define NUM_MODE_INT (MAX_MODE_INT - MIN_MODE_INT + 1)\n-#define NUM_MODE_VECTOR_INT (MAX_MODE_VECTOR_INT - MIN_MODE_VECTOR_INT + 1)\n+#define NUM_MODE_INT \\\n+  (MAX_MODE_INT - MIN_MODE_INT + 1)\n+#define NUM_MODE_PARTIAL_INT \\\n+  (MIN_MODE_PARTIAL_INT == VOIDmode ? 0 \\\n+   : MAX_MODE_PARTIAL_INT - MIN_MODE_PARTIAL_INT + 1)\n+#define NUM_MODE_VECTOR_INT \\\n+  (MIN_MODE_VECTOR_INT == VOIDmode ? 0 \\\n+   : MAX_MODE_VECTOR_INT - MIN_MODE_VECTOR_INT + 1)\n+\n+#define NUM_MODE_IP_INT (NUM_MODE_INT + NUM_MODE_PARTIAL_INT)\n+#define NUM_MODE_IPV_INT (NUM_MODE_IP_INT + NUM_MODE_VECTOR_INT)\n \n struct expmed_op_cheap {\n-  /* Whether an operation is cheap in a given integer mode.  */\n-  bool cheap_int[2][NUM_MODE_INT];\n-\n-  /* Whether an operation is cheap in a given vector integer mode.  */\n-  bool cheap_vector_int[2][NUM_MODE_VECTOR_INT];\n+  bool cheap[2][NUM_MODE_IPV_INT];\n };\n \n struct expmed_op_costs {\n-  /* The cost of an operation in a given integer mode.  */\n-  int int_cost[2][NUM_MODE_INT];\n-\n-  /* The cost of an operation in a given vector integer mode.  */\n-  int vector_int_cost[2][NUM_MODE_VECTOR_INT];\n+  int cost[2][NUM_MODE_IPV_INT];\n };\n \n /* Target-dependent globals.  */\n@@ -178,7 +179,7 @@ struct target_expmed {\n   /* Conversion costs are only defined between two scalar integer modes\n      of different sizes.  The first machine mode is the destination mode,\n      and the second is the source mode.  */\n-  int x_convert_cost[2][NUM_MODE_INT][NUM_MODE_INT];\n+  int x_convert_cost[2][NUM_MODE_IP_INT][NUM_MODE_IP_INT];\n };\n \n extern struct target_expmed default_target_expmed;\n@@ -212,6 +213,24 @@ set_alg_hash_used_p (bool usedp)\n   this_target_expmed->x_alg_hash_used_p = usedp;\n }\n \n+/* Compute an index into the cost arrays by mode class.  */\n+\n+static inline int\n+expmed_mode_index (enum machine_mode mode)\n+{\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_INT:\n+      return mode - MIN_MODE_INT;\n+    case MODE_PARTIAL_INT:\n+      return mode - MIN_MODE_PARTIAL_INT + NUM_MODE_INT;\n+    case MODE_VECTOR_INT:\n+      return mode - MIN_MODE_VECTOR_INT + NUM_MODE_IP_INT;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Return a pointer to a boolean contained in EOC indicating whether\n    a particular operation performed in MODE is cheap when optimizing\n    for SPEED.  */\n@@ -220,19 +239,8 @@ static inline bool *\n expmed_op_cheap_ptr (struct expmed_op_cheap *eoc, bool speed,\n \t\t     enum machine_mode mode)\n {\n-  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT\n-\t      || GET_MODE_CLASS (mode) == MODE_VECTOR_INT);\n-\n-  if (GET_MODE_CLASS (mode) == MODE_INT)\n-    {\n-      int idx = mode - MIN_MODE_INT;\n-      return &eoc->cheap_int[speed][idx];\n-    }\n-  else\n-    {\n-      int idx = mode - MIN_MODE_VECTOR_INT;\n-      return &eoc->cheap_vector_int[speed][idx];\n-    }\n+  int idx = expmed_mode_index (mode);\n+  return &eoc->cheap[speed][idx];\n }\n \n /* Return a pointer to a cost contained in COSTS when a particular\n@@ -242,19 +250,8 @@ static inline int *\n expmed_op_cost_ptr (struct expmed_op_costs *costs, bool speed,\n \t\t    enum machine_mode mode)\n {\n-  gcc_assert (GET_MODE_CLASS (mode) == MODE_INT\n-\t      || GET_MODE_CLASS (mode) == MODE_VECTOR_INT);\n-\n-  if (GET_MODE_CLASS (mode) == MODE_INT)\n-    {\n-      int idx = mode - MIN_MODE_INT;\n-      return &costs->int_cost[speed][idx];\n-    }\n-  else\n-    {\n-      int idx = mode - MIN_MODE_VECTOR_INT;\n-      return &costs->vector_int_cost[speed][idx];\n-    }\n+  int idx = expmed_mode_index (mode);\n+  return &costs->cost[speed][idx];\n }\n \n /* Subroutine of {set_,}sdiv_pow2_cheap.  Not to be used otherwise.  */\n@@ -631,15 +628,12 @@ static inline int *\n convert_cost_ptr (enum machine_mode to_mode, enum machine_mode from_mode,\n \t\t  bool speed)\n {\n-  int to_idx, from_idx;\n+  int to_idx = expmed_mode_index (to_mode);\n+  int from_idx = expmed_mode_index (from_mode);\n \n-  gcc_assert (to_mode >= MIN_MODE_INT\n-\t      && to_mode <= MAX_MODE_INT\n-\t      && from_mode >= MIN_MODE_INT\n-\t      && from_mode <= MAX_MODE_INT);\n+  gcc_assert (IN_RANGE (to_idx, 0, NUM_MODE_IP_INT - 1));\n+  gcc_assert (IN_RANGE (from_idx, 0, NUM_MODE_IP_INT - 1));\n \n-  to_idx = to_mode - MIN_MODE_INT;\n-  from_idx = from_mode - MIN_MODE_INT;\n   return &this_target_expmed->x_convert_cost[speed][to_idx][from_idx];\n }\n "}]}