{"sha": "9b06b9d23799ecad5db710e80f214fac0ae175f3", "node_id": "C_kwDOANBUbNoAKDliMDZiOWQyMzc5OWVjYWQ1ZGI3MTBlODBmMjE0ZmFjMGFlMTc1ZjM", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-12T12:37:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-12T12:40:39Z"}, "message": "Remove create_lcssa_for_virtual_phi and uses\n\nThe following expands the comment in vect_do_peeling as to why we\ndo not need create_lcssa_for_virtual_phi and removes that function.\n\nThat's the last bit I have queued for the vectorizer virtual LCSSA\ncleanup.\n\n\t* tree-vect-loop-manip.cc (create_lcssa_for_virtual_phi):\n\tRemove.\n\t(vect_do_peeling): Do not call it, adjust comment.", "tree": {"sha": "65b4ff24f729246075b99fd51bd56a0744f7d46d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65b4ff24f729246075b99fd51bd56a0744f7d46d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b06b9d23799ecad5db710e80f214fac0ae175f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b06b9d23799ecad5db710e80f214fac0ae175f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b06b9d23799ecad5db710e80f214fac0ae175f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b06b9d23799ecad5db710e80f214fac0ae175f3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7005b5e57eb4ce03f6166d62f7aa60b01677df1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7005b5e57eb4ce03f6166d62f7aa60b01677df1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7005b5e57eb4ce03f6166d62f7aa60b01677df1f"}], "stats": {"total": 95, "additions": 7, "deletions": 88}, "files": [{"sha": "86d2264054ae120d59694a2a2c5a96d5b9eea8c0", "filename": "gcc/tree-vect-loop-manip.cc", "status": "modified", "additions": 7, "deletions": 88, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b06b9d23799ecad5db710e80f214fac0ae175f3/gcc%2Ftree-vect-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b06b9d23799ecad5db710e80f214fac0ae175f3/gcc%2Ftree-vect-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.cc?ref=9b06b9d23799ecad5db710e80f214fac0ae175f3", "patch": "@@ -1332,56 +1332,6 @@ slpeel_can_duplicate_loop_p (const class loop *loop, const_edge e)\n   return true;\n }\n \n-/* If the loop has a virtual PHI, but exit bb doesn't, create a virtual PHI\n-   in the exit bb and rename all the uses after the loop.  This simplifies\n-   the *guard[12] routines, which assume loop closed SSA form for all PHIs\n-   (but normally loop closed SSA form doesn't require virtual PHIs to be\n-   in the same form).  Doing this early simplifies the checking what\n-   uses should be renamed.\n-\n-   If we create a new phi after the loop, return the definition that\n-   applies on entry to the loop, otherwise return null.  */\n-\n-static tree\n-create_lcssa_for_virtual_phi (class loop *loop)\n-{\n-  gphi_iterator gsi;\n-  edge exit_e = single_exit (loop);\n-\n-  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (virtual_operand_p (gimple_phi_result (gsi_stmt (gsi))))\n-      {\n-\tgphi *phi = gsi.phi ();\n-\tfor (gsi = gsi_start_phis (exit_e->dest);\n-\t     !gsi_end_p (gsi); gsi_next (&gsi))\n-\t  if (virtual_operand_p (gimple_phi_result (gsi_stmt (gsi))))\n-\t    break;\n-\tif (gsi_end_p (gsi))\n-\t  {\n-\t    tree new_vop = copy_ssa_name (PHI_RESULT (phi));\n-\t    gphi *new_phi = create_phi_node (new_vop, exit_e->dest);\n-\t    tree vop = PHI_ARG_DEF_FROM_EDGE (phi, EDGE_SUCC (loop->latch, 0));\n-\t    imm_use_iterator imm_iter;\n-\t    gimple *stmt;\n-\t    use_operand_p use_p;\n-\n-\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_vop)\n-\t      = SSA_NAME_OCCURS_IN_ABNORMAL_PHI (vop);\n-\t    add_phi_arg (new_phi, vop, exit_e, UNKNOWN_LOCATION);\n-\t    gimple_phi_set_result (new_phi, new_vop);\n-\t    FOR_EACH_IMM_USE_STMT (stmt, imm_iter, vop)\n-\t      if (stmt != new_phi\n-\t\t  && !flow_bb_inside_loop_p (loop, gimple_bb (stmt)))\n-\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\t\t  SET_USE (use_p, new_vop);\n-\n-\t    return PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n-\t  }\n-\tbreak;\n-      }\n-  return NULL_TREE;\n-}\n-\n /* Function vect_get_loop_location.\n \n    Extract the location of the loop in the source code.\n@@ -2702,31 +2652,20 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n      pending update needs.  */\n   gcc_assert (!need_ssa_update_p (cfun));\n \n-  create_lcssa_for_virtual_phi (loop);\n-\n-  /* If we're vectorizing an epilogue loop, the update_ssa above will\n-     have ensured that the virtual operand is in SSA form throughout the\n-     vectorized main loop.  Normally it is possible to trace the updated\n+  /* If we're vectorizing an epilogue loop, we have ensured that the\n+     virtual operand is in SSA form throughout the vectorized main loop.\n+     Normally it is possible to trace the updated\n      vector-stmt vdefs back to scalar-stmt vdefs and vector-stmt vuses\n      back to scalar-stmt vuses, meaning that the effect of the SSA update\n      remains local to the main loop.  However, there are rare cases in\n-     which the vectorized loop has vdefs even when the original scalar\n+     which the vectorized loop should have vdefs even when the original scalar\n      loop didn't.  For example, vectorizing a load with IFN_LOAD_LANES\n      introduces clobbers of the temporary vector array, which in turn\n      needs new vdefs.  If the scalar loop doesn't write to memory, these\n      new vdefs will be the only ones in the vector loop.\n-\n-     In that case, update_ssa will have added a new virtual phi to the\n-     main loop, which previously didn't need one.  Ensure that we (locally)\n-     maintain LCSSA form for the virtual operand, just as we would have\n-     done if the virtual phi had existed from the outset.  This makes it\n-     easier to duplicate the scalar epilogue loop below.  */\n-  tree vop_to_rename = NULL_TREE;\n-  if (loop_vec_info orig_loop_vinfo = LOOP_VINFO_ORIG_LOOP_INFO (loop_vinfo))\n-    {\n-      class loop *orig_loop = LOOP_VINFO_LOOP (orig_loop_vinfo);\n-      vop_to_rename = create_lcssa_for_virtual_phi (orig_loop);\n-    }\n+     We are currently defering updating virtual SSA form and creating\n+     of a virtual PHI for this case so we do not have to make sure the\n+     newly introduced virtual def is in LCSSA form.  */\n \n   if (MAY_HAVE_DEBUG_BIND_STMTS)\n     {\n@@ -2947,26 +2886,6 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n \t as the transformations mentioned above make less or no sense when not\n \t vectorizing.  */\n       epilog = vect_epilogues ? get_loop_copy (loop) : scalar_loop;\n-      if (vop_to_rename)\n-\t{\n-\t  /* Vectorizing the main loop can sometimes introduce a vdef to\n-\t     a loop that previously didn't have one; see the comment above\n-\t     the definition of VOP_TO_RENAME for details.  The definition\n-\t     D that holds on E will then be different from the definition\n-\t     VOP_TO_RENAME that holds during SCALAR_LOOP, so we need to\n-\t     rename VOP_TO_RENAME to D when copying the loop.\n-\n-\t     The virtual operand is in LCSSA form for the main loop,\n-\t     and no stmt between the main loop and E needs a vdef,\n-\t     so we know that D is provided by a phi rather than by a\n-\t     vdef on a normal gimple stmt.  */\n-\t  basic_block vdef_bb = e->src;\n-\t  gphi *vphi;\n-\t  while (!(vphi = get_virtual_phi (vdef_bb)))\n-\t    vdef_bb = get_immediate_dominator (CDI_DOMINATORS, vdef_bb);\n-\t  gcc_assert (vop_to_rename != gimple_phi_result (vphi));\n-\t  set_current_def (vop_to_rename, gimple_phi_result (vphi));\n-\t}\n       epilog = slpeel_tree_duplicate_loop_to_edge_cfg (loop, epilog, e);\n       if (!epilog)\n \t{"}]}