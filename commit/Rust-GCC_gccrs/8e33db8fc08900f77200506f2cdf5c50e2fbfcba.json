{"sha": "8e33db8fc08900f77200506f2cdf5c50e2fbfcba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUzM2RiOGZjMDg5MDBmNzcyMDA1MDZmMmNkZjVjNTBlMmZiZmNiYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-09-19T02:56:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-09-19T02:56:15Z"}, "message": "[PATCH] avail_expr_stack is no longer file scoped\n\n       PR tree-optimization/47679\n        * tree-ssa-dom.c (avail_exprs_stack): No longer file scoped.  Move\n        it here ...\n        (dom_opt_dom_walker): New private member holding the avail_exprs_stack\n        object.  Update constructor.\n        (pass_dominator::execute):  Corresponding chagnes to declaration\n        and initialization of avail_exprs_stack.  Update constructor call\n        for dom_opt_dom_walker object.\n        (lookup_avail_expr, record_cond): Accept additional argument.  Pass\n        it down to children as needed.\n        (record_equivalences_from_incoming_edge): Likewise.\n        (eliminate_redundant_computations): Likewise.\n        (record_equivalences_from_stmt): Likewise.\n        (simplify_stmt_for_jump_threading): Likewise.\n        (record_temporary_equivalences): Likewise.\n        (optimize_stmt): Likewise.\n        (dom_opt_dom_walker::thread_across_edge): Update access to\n        avail_exprs_stack object and pass it to children as needed.\n        (dom_opt_dom_walker::before_dom_children): Similarly.\n        (dom_opt_dom_walker::after_dom_children): Similarly.\n        * tree-ssa-threadedge.c (pfn_simplify): New typedef.\n        (record_temporary_equivalences_from_stmts_at_dest): Use new typedef.\n        Add avail_expr_stack argument.  Pass it to children as needed.\n        (dummy_simplify): Likewise.\n        (simplify_control_stmt_condition): Likewise.\n        (thread_around_empty_blocks): Likewise.\n        (thread_through_normal_block): Likewise.\n        (thread_across_edge): Likewise.\n        * tree-ssa-threadedge.h (thread_across_edge): Update prototype.\n        * tree-vrp.c (simplify_stmt_for_jump_threading): Update.\n\nFrom-SVN: r227931", "tree": {"sha": "62af4cc89d09878673cfb0755453089addf8f45e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62af4cc89d09878673cfb0755453089addf8f45e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e33db8fc08900f77200506f2cdf5c50e2fbfcba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e33db8fc08900f77200506f2cdf5c50e2fbfcba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e33db8fc08900f77200506f2cdf5c50e2fbfcba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/comments", "author": null, "committer": null, "parents": [{"sha": "8788ec94173a9551076ee7d9f52b7f6c7afc9c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8788ec94173a9551076ee7d9f52b7f6c7afc9c68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8788ec94173a9551076ee7d9f52b7f6c7afc9c68"}], "stats": {"total": 228, "additions": 153, "deletions": 75}, "files": [{"sha": "4d0b1f5b4d4f2da314dbf39aaf5117906c422de1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e33db8fc08900f77200506f2cdf5c50e2fbfcba", "patch": "@@ -1,5 +1,36 @@\n 2015-09-18  Jeff Law  <law@redhat.com>\n \n+\tPR tree-optimization/47679\n+\t* tree-ssa-dom.c (avail_exprs_stack): No longer file scoped.  Move\n+\tit here ...\n+\t(dom_opt_dom_walker): New private member holding the avail_exprs_stack\n+\tobject.  Update constructor.\n+\t(pass_dominator::execute):  Corresponding chagnes to declaration\n+\tand initialization of avail_exprs_stack.  Update constructor call\n+\tfor dom_opt_dom_walker object.\n+\t(lookup_avail_expr, record_cond): Accept additional argument.  Pass\n+\tit down to children as needed.\n+\t(record_equivalences_from_incoming_edge): Likewise.\n+\t(eliminate_redundant_computations): Likewise.\n+\t(record_equivalences_from_stmt): Likewise.\n+\t(simplify_stmt_for_jump_threading): Likewise.\n+\t(record_temporary_equivalences): Likewise.\n+\t(optimize_stmt): Likewise.\n+\t(dom_opt_dom_walker::thread_across_edge): Update access to\n+\tavail_exprs_stack object and pass it to children as needed.\n+\t(dom_opt_dom_walker::before_dom_children): Similarly.\n+\t(dom_opt_dom_walker::after_dom_children): Similarly.\n+\t* tree-ssa-threadedge.c (pfn_simplify): New typedef.\n+\t(record_temporary_equivalences_from_stmts_at_dest): Use new typedef.\n+\tAdd avail_expr_stack argument.  Pass it to children as needed.\n+\t(dummy_simplify): Likewise.\n+\t(simplify_control_stmt_condition): Likewise.\n+\t(thread_around_empty_blocks): Likewise.\n+\t(thread_through_normal_block): Likewise.\n+\t(thread_across_edge): Likewise.\n+\t* tree-ssa-threadedge.h (thread_across_edge): Update prototype.\n+\t* tree-vrp.c (simplify_stmt_for_jump_threading): Update.\n+\n \tPR tree-optimization/47679\n \t* tree-ssa-dom.c (const_and_copies): No longer file scoped.  Move\n \tit here ..."}, {"sha": "936af9919bc6bceff2c0c5aa30dad09ebc870c1e", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 72, "deletions": 51, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=8e33db8fc08900f77200506f2cdf5c50e2fbfcba", "patch": "@@ -78,9 +78,6 @@ struct edge_info\n   vec<cond_equivalence> cond_equivalences;\n };\n \n-/* Unwindable equivalences, both const/copy and expression varieties.  */\n-static avail_exprs_stack *avail_exprs_stack;\n-\n /* Track whether or not we have changed the control flow graph.  */\n static bool cfg_altered;\n \n@@ -103,16 +100,20 @@ static struct opt_stats_d opt_stats;\n \n /* Local functions.  */\n static void optimize_stmt (basic_block, gimple_stmt_iterator,\n-\t\t\t   class const_and_copies *);\n-static tree lookup_avail_expr (gimple, bool);\n-static void record_cond (cond_equivalence *);\n+\t\t\t   class const_and_copies *,\n+\t\t\t   class avail_exprs_stack *);\n+static tree lookup_avail_expr (gimple, bool, class avail_exprs_stack *);\n+static void record_cond (cond_equivalence *, class avail_exprs_stack *);\n static void record_equality (tree, tree, class const_and_copies *);\n static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block,\n-\t\t\t\t\t\t    class const_and_copies *);\n+\t\t\t\t\t\t    class const_and_copies *,\n+\t\t\t\t\t\t    class avail_exprs_stack *);\n static void eliminate_redundant_computations (gimple_stmt_iterator *,\n-\t\t\t\t\t      class const_and_copies *);\n-static void record_equivalences_from_stmt (gimple, int);\n+\t\t\t\t\t      class const_and_copies *,\n+\t\t\t\t\t      class avail_exprs_stack *);\n+static void record_equivalences_from_stmt (gimple, int,\n+\t\t\t\t\t   class avail_exprs_stack *);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n static void dump_dominator_optimization_stats (FILE *file,\n \t\t\t\t\t       hash_table<expr_elt_hasher> *);\n@@ -490,9 +491,11 @@ class dom_opt_dom_walker : public dom_walker\n {\n public:\n   dom_opt_dom_walker (cdi_direction direction,\n-\t\t      class const_and_copies *const_and_copies)\n+\t\t      class const_and_copies *const_and_copies,\n+\t\t      class avail_exprs_stack *avail_exprs_stack)\n     : dom_walker (direction),\n       m_const_and_copies (const_and_copies),\n+      m_avail_exprs_stack (avail_exprs_stack),\n       m_dummy_cond (NULL) {}\n \n   virtual void before_dom_children (basic_block);\n@@ -503,6 +506,7 @@ class dom_opt_dom_walker : public dom_walker\n \n   /* Unwindable equivalences, both const/copy and expression varieties.  */\n   class const_and_copies *m_const_and_copies;\n+  class avail_exprs_stack *m_avail_exprs_stack;\n \n   gcond *m_dummy_cond;\n };\n@@ -550,7 +554,8 @@ pass_dominator::execute (function *fun)\n   /* Create our hash tables.  */\n   hash_table<expr_elt_hasher> *avail_exprs\n     = new hash_table<expr_elt_hasher> (1024);\n-  avail_exprs_stack = new class avail_exprs_stack (avail_exprs);\n+  class avail_exprs_stack *avail_exprs_stack\n+    = new class avail_exprs_stack (avail_exprs);\n   class const_and_copies *const_and_copies = new class const_and_copies ();\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n   need_noreturn_fixup.create (0);\n@@ -589,7 +594,9 @@ pass_dominator::execute (function *fun)\n     record_edge_info (bb);\n \n   /* Recursively walk the dominator tree optimizing statements.  */\n-  dom_opt_dom_walker walker (CDI_DOMINATORS, const_and_copies);\n+  dom_opt_dom_walker walker (CDI_DOMINATORS,\n+\t\t\t     const_and_copies,\n+\t\t\t     avail_exprs_stack);\n   walker.walk (fun->cfg->x_entry_block_ptr);\n \n   {\n@@ -749,9 +756,10 @@ canonicalize_comparison (gcond *condstmt)\n    threading code with a simple API for simplifying statements.  */\n static tree\n simplify_stmt_for_jump_threading (gimple stmt,\n-\t\t\t\t  gimple within_stmt ATTRIBUTE_UNUSED)\n+\t\t\t\t  gimple within_stmt ATTRIBUTE_UNUSED,\n+\t\t\t\t  class avail_exprs_stack *avail_exprs_stack)\n {\n-  return lookup_avail_expr (stmt, false);\n+  return lookup_avail_expr (stmt, false, avail_exprs_stack);\n }\n \n /* Valueize hook for gimple_fold_stmt_to_constant_1.  */\n@@ -768,13 +776,14 @@ dom_valueize (tree t)\n   return t;\n }\n \n-/* Record into the equivalence tables any equivalences implied by\n-   traversing edge E (which are cached in E->aux).\n+/* Record into CONST_AND_COPIES and AVAIL_EXPRS_STACK any equivalences implied\n+   by traversing edge E (which are cached in E->aux).\n \n    Callers are responsible for managing the unwinding markers.  */\n static void\n record_temporary_equivalences (edge e,\n-\t\t\t       class const_and_copies *const_and_copies)\n+\t\t\t       class const_and_copies *const_and_copies,\n+\t\t\t       class avail_exprs_stack *avail_exprs_stack)\n {\n   int i;\n   struct edge_info *edge_info = (struct edge_info *) e->aux;\n@@ -861,7 +870,7 @@ record_temporary_equivalences (edge e,\n       /* If we have 0 = COND or 1 = COND equivalences, record them\n \t into our expression hash tables.  */\n       for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n-\trecord_cond (eq);\n+\trecord_cond (eq, avail_exprs_stack);\n     }\n }\n \n@@ -880,16 +889,16 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n \n   /* Push a marker on both stacks so we can unwind the tables back to their\n      current state.  */\n-  avail_exprs_stack->push_marker ();\n+  m_avail_exprs_stack->push_marker ();\n   m_const_and_copies->push_marker ();\n \n   /* Traversing E may result in equivalences we can utilize.  */\n-  record_temporary_equivalences (e, m_const_and_copies);\n+  record_temporary_equivalences (e, m_const_and_copies, m_avail_exprs_stack);\n \n   /* With all the edge equivalences in the tables, go ahead and attempt\n      to thread through E->dest.  */\n   ::thread_across_edge (m_dummy_cond, e, false,\n-\t\t        m_const_and_copies, avail_exprs_stack,\n+\t\t        m_const_and_copies, m_avail_exprs_stack,\n \t\t        simplify_stmt_for_jump_threading);\n \n   /* And restore the various tables to their state before\n@@ -898,7 +907,7 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n      XXX The code in tree-ssa-threadedge.c will restore the state of\n      the const_and_copies table.  We we just have to restore the expression\n      table.  */\n-  avail_exprs_stack->pop_to_marker ();\n+  m_avail_exprs_stack->pop_to_marker ();\n }\n \n /* PHI nodes can create equivalences too.\n@@ -989,12 +998,14 @@ single_incoming_edge_ignoring_loop_edges (basic_block bb)\n   return retval;\n }\n \n-/* Record any equivalences created by the incoming edge to BB.  If BB\n-   has more than one incoming edge, then no equivalence is created.  */\n+/* Record any equivalences created by the incoming edge to BB into\n+   CONST_AND_COPIES and AVAIL_EXPRS_STACK.  If BB has more than one\n+   incoming edge, then no equivalence is created.  */\n \n static void\n record_equivalences_from_incoming_edge (basic_block bb,\n-    class const_and_copies *const_and_copies)\n+    class const_and_copies *const_and_copies,\n+    class avail_exprs_stack *avail_exprs_stack)\n {\n   edge e;\n   basic_block parent;\n@@ -1009,7 +1020,7 @@ record_equivalences_from_incoming_edge (basic_block bb,\n   /* If we had a single incoming edge from our parent block, then enter\n      any data associated with the edge into our tables.  */\n   if (e && e->src == parent)\n-    record_temporary_equivalences (e, const_and_copies);\n+    record_temporary_equivalences (e, const_and_copies, avail_exprs_stack);\n }\n \n /* Dump statistics for the hash table HTAB.  */\n@@ -1041,12 +1052,14 @@ dump_dominator_optimization_stats (FILE *file,\n }\n \n \n-/* Enter condition equivalence into the expression hash table.\n+/* Enter condition equivalence P into AVAIL_EXPRS_HASH.\n+\n    This indicates that a conditional expression has a known\n    boolean value.  */\n \n static void\n-record_cond (cond_equivalence *p)\n+record_cond (cond_equivalence *p,\n+\t     class avail_exprs_stack *avail_exprs_stack)\n {\n   class expr_hash_elt *element = new expr_hash_elt (&p->cond, p->value);\n   expr_hash_elt **slot;\n@@ -1056,7 +1069,6 @@ record_cond (cond_equivalence *p)\n   if (*slot == NULL)\n     {\n       *slot = element;\n-\n       avail_exprs_stack->record_expr (element, NULL, '1');\n     }\n   else\n@@ -1280,24 +1292,26 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n \n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n-  avail_exprs_stack->push_marker ();\n+  m_avail_exprs_stack->push_marker ();\n   m_const_and_copies->push_marker ();\n \n-  record_equivalences_from_incoming_edge (bb, m_const_and_copies);\n+  record_equivalences_from_incoming_edge (bb, m_const_and_copies,\n+\t\t\t\t\t  m_avail_exprs_stack);\n \n   /* PHI nodes can create equivalences too.  */\n   record_equivalences_from_phis (bb);\n \n   /* Create equivalences from redundant PHIs.  PHIs are only truly\n      redundant when they exist in the same block, so push another\n      marker and unwind right afterwards.  */\n-  avail_exprs_stack->push_marker ();\n+  m_avail_exprs_stack->push_marker ();\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    eliminate_redundant_computations (&gsi, m_const_and_copies);\n-  avail_exprs_stack->pop_to_marker ();\n+    eliminate_redundant_computations (&gsi, m_const_and_copies,\n+\t\t\t\t      m_avail_exprs_stack);\n+  m_avail_exprs_stack->pop_to_marker ();\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    optimize_stmt (bb, gsi, m_const_and_copies);\n+    optimize_stmt (bb, gsi, m_const_and_copies, m_avail_exprs_stack);\n \n   /* Now prepare to process dominated blocks.  */\n   record_edge_info (bb);\n@@ -1345,19 +1359,20 @@ dom_opt_dom_walker::after_dom_children (basic_block bb)\n     }\n \n   /* These remove expressions local to BB from the tables.  */\n-  avail_exprs_stack->pop_to_marker ();\n+  m_avail_exprs_stack->pop_to_marker ();\n   m_const_and_copies->pop_to_marker ();\n }\n \n /* Search for redundant computations in STMT.  If any are found, then\n    replace them with the variable holding the result of the computation.\n \n-   If safe, record this expression into the available expression hash\n-   table.  */\n+   If safe, record this expression into AVAIL_EXPRS_STACK and\n+   CONST_AND_COPIES.  */\n \n static void\n eliminate_redundant_computations (gimple_stmt_iterator* gsi,\n-\t\t\t\t  class const_and_copies *const_and_copies)\n+\t\t\t\t  class const_and_copies *const_and_copies,\n+\t\t\t\t  class avail_exprs_stack *avail_exprs_stack)\n {\n   tree expr_type;\n   tree cached_lhs;\n@@ -1384,7 +1399,7 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi,\n     insert = false;\n \n   /* Check if the expression has been computed before.  */\n-  cached_lhs = lookup_avail_expr (stmt, insert);\n+  cached_lhs = lookup_avail_expr (stmt, insert, avail_exprs_stack);\n \n   opt_stats.num_exprs_considered++;\n \n@@ -1459,12 +1474,14 @@ eliminate_redundant_computations (gimple_stmt_iterator* gsi,\n \n /* STMT, a GIMPLE_ASSIGN, may create certain equivalences, in either\n    the available expressions table or the const_and_copies table.\n-   Detect and record those equivalences.  */\n-/* We handle only very simple copy equivalences here.  The heavy\n+   Detect and record those equivalences into AVAIL_EXPRS_STACK. \n+\n+   We handle only very simple copy equivalences here.  The heavy\n    lifing is done by eliminate_redundant_computations.  */\n \n static void\n-record_equivalences_from_stmt (gimple stmt, int may_optimize_p)\n+record_equivalences_from_stmt (gimple stmt, int may_optimize_p,\n+\t\t\t       class avail_exprs_stack *avail_exprs_stack)\n {\n   tree lhs;\n   enum tree_code lhs_code;\n@@ -1567,7 +1584,7 @@ record_equivalences_from_stmt (gimple stmt, int may_optimize_p)\n \n       /* Finally enter the statement into the available expression\n \t table.  */\n-      lookup_avail_expr (new_stmt, true);\n+      lookup_avail_expr (new_stmt, true, avail_exprs_stack);\n     }\n }\n \n@@ -1649,7 +1666,8 @@ cprop_into_stmt (gimple stmt)\n     cprop_operand (stmt, op_p);\n }\n \n-/* Optimize the statement pointed to by iterator SI.\n+/* Optimize the statement in block BB pointed to by iterator SI\n+   using equivalences from CONST_AND_COPIES and AVAIL_EXPRS_STACK.\n \n    We try to perform some simplistic global redundancy elimination and\n    constant propagation:\n@@ -1666,7 +1684,8 @@ cprop_into_stmt (gimple stmt)\n \n static void\n optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n-\t       class const_and_copies *const_and_copies)\n+\t       class const_and_copies *const_and_copies,\n+\t       class avail_exprs_stack *avail_exprs_stack)\n {\n   gimple stmt, old_stmt;\n   bool may_optimize_p;\n@@ -1756,7 +1775,8 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t}\n \n       update_stmt_if_modified (stmt);\n-      eliminate_redundant_computations (&si, const_and_copies);\n+      eliminate_redundant_computations (&si, const_and_copies,\n+\t\t\t\t\tavail_exprs_stack);\n       stmt = gsi_stmt (si);\n \n       /* Perform simple redundant store elimination.  */\n@@ -1778,7 +1798,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \t  else\n \t    new_stmt = gimple_build_assign (rhs, lhs);\n \t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n-\t  cached_lhs = lookup_avail_expr (new_stmt, false);\n+\t  cached_lhs = lookup_avail_expr (new_stmt, false, avail_exprs_stack);\n \t  if (cached_lhs\n \t      && rhs == cached_lhs)\n \t    {\n@@ -1798,7 +1818,7 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si,\n \n   /* Record any additional equivalences created by this statement.  */\n   if (is_gimple_assign (stmt))\n-    record_equivalences_from_stmt (stmt, may_optimize_p);\n+    record_equivalences_from_stmt (stmt, may_optimize_p, avail_exprs_stack);\n \n   /* If STMT is a COND_EXPR and it was modified, then we may know\n      where it goes.  If that is the case, then mark the CFG as altered.\n@@ -1876,7 +1896,7 @@ vuse_eq (ao_ref *, tree vuse1, unsigned int cnt, void *data)\n   return NULL;\n }\n \n-/* Search for an existing instance of STMT in the AVAIL_EXPRS table.\n+/* Search for an existing instance of STMT in the AVAIL_EXPRS_STACK table.\n    If found, return its LHS. Otherwise insert STMT in the table and\n    return NULL_TREE.\n \n@@ -1885,7 +1905,8 @@ vuse_eq (ao_ref *, tree vuse1, unsigned int cnt, void *data)\n    we finish processing this block and its children.  */\n \n static tree\n-lookup_avail_expr (gimple stmt, bool insert)\n+lookup_avail_expr (gimple stmt, bool insert,\n+\t\t   class avail_exprs_stack *avail_exprs_stack)\n {\n   expr_hash_elt **slot;\n   tree lhs;"}, {"sha": "ba25e0776796977f720b59cdc8baf51241ff8c2d", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 47, "deletions": 22, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=8e33db8fc08900f77200506f2cdf5c50e2fbfcba", "patch": "@@ -56,6 +56,8 @@ static int stmt_count;\n /* Array to record value-handles per SSA_NAME.  */\n vec<tree> ssa_name_values;\n \n+typedef tree (pfn_simplify) (gimple, gimple, class avail_exprs_stack *);\n+\n /* Set the value for the SSA name NAME to VALUE.  */\n \n void\n@@ -256,10 +258,10 @@ fold_assignment_stmt (gimple stmt)\n \n static gimple\n record_temporary_equivalences_from_stmts_at_dest (edge e,\n-\t\t\t\t\t\t  const_and_copies *const_and_copies,\n-\t\t\t\t\t\t  tree (*simplify) (gimple,\n-\t\t\t\t\t\t\t\t    gimple),\n-\t\t\t\t\t\t  bool backedge_seen)\n+    const_and_copies *const_and_copies,\n+    avail_exprs_stack *avail_exprs_stack,\n+    pfn_simplify simplify,\n+    bool backedge_seen)\n {\n   gimple stmt = NULL;\n   gimple_stmt_iterator gsi;\n@@ -412,7 +414,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n           if (!cached_lhs\n               || (TREE_CODE (cached_lhs) != SSA_NAME\n                   && !is_gimple_min_invariant (cached_lhs)))\n-            cached_lhs = (*simplify) (stmt, stmt);\n+            cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack);\n \n \t  /* Restore the statement's original uses/defs.  */\n \t  i = 0;\n@@ -445,7 +447,8 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n    necessarily valid.  We use this callback rather than the ones provided by\n    DOM/VRP to achieve that effect.  */\n static tree\n-dummy_simplify (gimple stmt1 ATTRIBUTE_UNUSED, gimple stmt2 ATTRIBUTE_UNUSED)\n+dummy_simplify (gimple stmt1 ATTRIBUTE_UNUSED, gimple stmt2 ATTRIBUTE_UNUSED,\n+\t\tclass avail_exprs_stack *avail_exprs_stack ATTRIBUTE_UNUSED)\n {\n   return NULL_TREE;\n }\n@@ -459,13 +462,16 @@ dummy_simplify (gimple stmt1 ATTRIBUTE_UNUSED, gimple stmt2 ATTRIBUTE_UNUSED)\n    a condition using pass specific information.\n \n    Return the simplified condition or NULL if simplification could\n-   not be performed.  */\n+   not be performed. \n+\n+   The available expression table is referenced via AVAIL_EXPRS_STACK.  */\n \n static tree\n simplify_control_stmt_condition (edge e,\n \t\t\t\t gimple stmt,\n+\t\t\t\t class avail_exprs_stack *avail_exprs_stack,\n \t\t\t\t gcond *dummy_cond,\n-\t\t\t\t tree (*simplify) (gimple, gimple),\n+\t\t\t\t pfn_simplify simplify,\n \t\t\t\t bool handle_dominating_asserts)\n {\n   tree cond, cached_lhs;\n@@ -552,7 +558,7 @@ simplify_control_stmt_condition (edge e,\n \t then use the pass specific callback to simplify the condition.  */\n       if (!cached_lhs\n           || !is_gimple_min_invariant (cached_lhs))\n-        cached_lhs = (*simplify) (dummy_cond, stmt);\n+        cached_lhs = (*simplify) (dummy_cond, stmt, avail_exprs_stack);\n \n       /* If we were just testing that an integral type was != 0, and that\n \t failed, just return the first operand.  This gives the FSM code a\n@@ -614,7 +620,7 @@ simplify_control_stmt_condition (edge e,\n       /* If we haven't simplified to an invariant yet, then use the\n \t pass specific callback to try and simplify it further.  */\n       if (cached_lhs && ! is_gimple_min_invariant (cached_lhs))\n-        cached_lhs = (*simplify) (stmt, stmt);\n+        cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack);\n \n       /* We couldn't find an invariant.  But, callers of this\n \t function may be able to do something useful with the\n@@ -764,12 +770,16 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)\n    return false.\n \n    DUMMY_COND, HANDLE_DOMINATING_ASSERTS and SIMPLIFY are used to\n-   try and simplify the condition at the end of TAKEN_EDGE->dest.  */\n+   try and simplify the condition at the end of TAKEN_EDGE->dest. \n+\n+   The available expression table is referenced via AVAIL_EXPRS_STACK.  */\n+\n static bool\n thread_around_empty_blocks (edge taken_edge,\n \t\t\t    gcond *dummy_cond,\n+\t\t\t    class avail_exprs_stack *avail_exprs_stack,\n \t\t\t    bool handle_dominating_asserts,\n-\t\t\t    tree (*simplify) (gimple, gimple),\n+\t\t\t    pfn_simplify simplify,\n \t\t\t    bitmap visited,\n \t\t\t    vec<jump_thread_edge *> *path,\n \t\t\t    bool *backedge_seen_p)\n@@ -818,6 +828,7 @@ thread_around_empty_blocks (edge taken_edge,\n \t\tsimplify = dummy_simplify;\n \t      return thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t\t dummy_cond,\n+\t\t\t\t\t\t avail_exprs_stack,\n \t\t\t\t\t\t handle_dominating_asserts,\n \t\t\t\t\t\t simplify,\n \t\t\t\t\t\t visited,\n@@ -846,7 +857,8 @@ thread_around_empty_blocks (edge taken_edge,\n     simplify = dummy_simplify;\n \n   /* Extract and simplify the condition.  */\n-  cond = simplify_control_stmt_condition (taken_edge, stmt, dummy_cond,\n+  cond = simplify_control_stmt_condition (taken_edge, stmt,\n+\t\t\t\t\t  avail_exprs_stack, dummy_cond,\n \t\t\t\t\t  simplify, handle_dominating_asserts);\n \n   /* If the condition can be statically computed and we have not already\n@@ -869,6 +881,7 @@ thread_around_empty_blocks (edge taken_edge,\n \n       thread_around_empty_blocks (taken_edge,\n \t\t\t\t  dummy_cond,\n+\t\t\t\t  avail_exprs_stack,\n \t\t\t\t  handle_dominating_asserts,\n \t\t\t\t  simplify,\n \t\t\t\t  visited,\n@@ -1187,7 +1200,8 @@ thread_through_normal_block (edge e,\n \t\t\t     gcond *dummy_cond,\n \t\t\t     bool handle_dominating_asserts,\n \t\t\t     const_and_copies *const_and_copies,\n-\t\t\t     tree (*simplify) (gimple, gimple),\n+\t\t\t     avail_exprs_stack *avail_exprs_stack,\n+\t\t\t     pfn_simplify simplify,\n \t\t\t     vec<jump_thread_edge *> *path,\n \t\t\t     bitmap visited,\n \t\t\t     bool *backedge_seen_p)\n@@ -1210,6 +1224,7 @@ thread_through_normal_block (edge e,\n      temporary equivalences we can detect.  */\n   gimple stmt\n     = record_temporary_equivalences_from_stmts_at_dest (e, const_and_copies,\n+\t\t\t\t\t\t\tavail_exprs_stack,\n \t\t\t\t\t\t\tsimplify,\n \t\t\t\t\t\t\t*backedge_seen_p);\n \n@@ -1248,7 +1263,8 @@ thread_through_normal_block (edge e,\n       tree cond;\n \n       /* Extract and simplify the condition.  */\n-      cond = simplify_control_stmt_condition (e, stmt, dummy_cond, simplify,\n+      cond = simplify_control_stmt_condition (e, stmt, avail_exprs_stack,\n+\t\t\t\t\t      dummy_cond, simplify,\n \t\t\t\t\t      handle_dominating_asserts);\n \n       if (!cond)\n@@ -1293,6 +1309,7 @@ thread_through_normal_block (edge e,\n \t  bitmap_set_bit (visited, e->dest->index);\n \t  thread_around_empty_blocks (taken_edge,\n \t\t\t\t      dummy_cond,\n+\t\t\t\t      avail_exprs_stack,\n \t\t\t\t      handle_dominating_asserts,\n \t\t\t\t      simplify,\n \t\t\t\t      visited,\n@@ -1348,18 +1365,21 @@ thread_through_normal_block (edge e,\n    the simplified condition with left-hand sides of ASSERT_EXPRs they are\n    used in.\n \n-   STACK is used to undo temporary equivalences created during the walk of\n-   E->dest.\n+   CONST_AND_COPIES is used to undo temporary equivalences created during the\n+   walk of E->dest.\n+\n+   The available expression table is referenced vai AVAIL_EXPRS_STACK.\n \n    SIMPLIFY is a pass-specific function used to simplify statements.  */\n \n void\n thread_across_edge (gcond *dummy_cond,\n \t\t    edge e,\n \t\t    bool handle_dominating_asserts,\n-\t\t    const_and_copies *const_and_copies,\n-\t\t    avail_exprs_stack *avail_exprs_stack,\n-\t\t    tree (*simplify) (gimple, gimple))\n+\t\t    class const_and_copies *const_and_copies,\n+\t\t    class avail_exprs_stack *avail_exprs_stack,\n+\t\t    tree (*simplify) (gimple, gimple,\n+\t\t\t\t      class avail_exprs_stack *))\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n   bool backedge_seen;\n@@ -1376,7 +1396,9 @@ thread_across_edge (gcond *dummy_cond,\n \n   int threaded = thread_through_normal_block (e, dummy_cond,\n \t\t\t\t\t      handle_dominating_asserts,\n-\t\t\t\t\t      const_and_copies, simplify, path,\n+\t\t\t\t\t      const_and_copies,\n+\t\t\t\t\t      avail_exprs_stack,\n+\t\t\t\t\t      simplify, path,\n \t\t\t\t\t      visited, &backedge_seen);\n   if (threaded > 0)\n     {\n@@ -1467,6 +1489,7 @@ thread_across_edge (gcond *dummy_cond,\n \t  simplify = dummy_simplify;\n \tfound = thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t    dummy_cond,\n+\t\t\t\t\t    avail_exprs_stack,\n \t\t\t\t\t    handle_dominating_asserts,\n \t\t\t\t\t    simplify,\n \t\t\t\t\t    visited,\n@@ -1479,7 +1502,9 @@ thread_across_edge (gcond *dummy_cond,\n \tif (!found)\n \t  found = thread_through_normal_block (path->last ()->e, dummy_cond,\n \t\t\t\t\t       handle_dominating_asserts,\n-\t\t\t\t\t       const_and_copies, simplify, path,\n+\t\t\t\t\t       const_and_copies,\n+\t\t\t\t\t       avail_exprs_stack,\n+\t\t\t\t\t       simplify, path,\n \t\t\t\t\t       visited, &backedge_seen) > 0;\n \n \t/* If we were able to thread through a successor of E->dest, then"}, {"sha": "023b0f791d9537be594809382fd4d01b9b725a7b", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=8e33db8fc08900f77200506f2cdf5c50e2fbfcba", "patch": "@@ -33,6 +33,6 @@ extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n extern void thread_across_edge (gcond *, edge, bool,\n \t\t\t\tconst_and_copies *,\n \t\t\t\tavail_exprs_stack *,\n-\t\t\t\ttree (*) (gimple, gimple));\n+\t\t\t\ttree (*) (gimple, gimple, avail_exprs_stack *));\n \n #endif /* GCC_TREE_SSA_THREADEDGE_H */"}, {"sha": "cfb832916e4538df141c178fe6108ea28fa3c37c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e33db8fc08900f77200506f2cdf5c50e2fbfcba/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8e33db8fc08900f77200506f2cdf5c50e2fbfcba", "patch": "@@ -10066,7 +10066,8 @@ const_and_copies *equiv_stack;\n    for any overflow warnings.  */\n \n static tree\n-simplify_stmt_for_jump_threading (gimple stmt, gimple within_stmt)\n+simplify_stmt_for_jump_threading (gimple stmt, gimple within_stmt,\n+    class avail_exprs_stack *avail_exprs_stack ATTRIBUTE_UNUSED)\n {\n   if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))\n     return vrp_evaluate_conditional (gimple_cond_code (cond_stmt),"}]}