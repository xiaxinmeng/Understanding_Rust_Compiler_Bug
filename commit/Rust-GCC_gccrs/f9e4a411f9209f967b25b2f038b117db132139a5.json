{"sha": "f9e4a411f9209f967b25b2f038b117db132139a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjllNGE0MTFmOTIwOWY5NjdiMjViMmYwMzhiMTE3ZGIxMzIxMzlhNQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-09-05T14:40:04Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-09-05T14:40:04Z"}, "message": "Add mips16/nomips16 function attributes and -mflip-mips16 option for testing mixed-mode compilation.\n\n2007-09-05  Sandra Loosemore  <sandra@codesourcery.com>\n\t    David Ung  <davidu@mips.com>\n            Nigel Stephens <nigel@mips.com>\n\n\tAdd mips16/nomips16 function attributes and -mflip-mips16 option\n\tfor testing mixed-mode compilation.\n\n\tgcc/\n\n\t* config/mips/mips.opt (mflip-mips16): New.\n\n\t* config/mips/mips.h (SYMBOL_FLAG_MIPS16_FUNC): Define.\n\t(SYMBOL_FLAG_MIPS16_FUNC_P): Define.\n\n\t* config/mips/mips.c (mips_base_target_flags): New.\n\t(mips_base_mips16): New.\n\t(mips_base_schedule_insns): New.\n\t(mips_base_reorder_blocks_and_partition): New.\n\t(mips_base_align_loops): New.\n\t(mips_base_align_jumps): New.\n\t(mips_base_align_functions): New.\n\t(mips16_flipper): New.\n\t(mips_attribute_table): Add \"mips16\" and \"nomips16\" entries.\n\t(TARGET_SET_CURRENT_FUNCTION): Define.\n\t(mips_mips16_type_p, mips_nomips16_type_p): New.\n\t(mips_comp_type_attributes): Check mips16/nomips16 attributes.\n\t(mips_function_ok_for_sibcall): Make it deal with functions with\n\tmips16 attributes.\n\t(mips_init_split_addresses): New, split out from override_options.\n\t(mips_init_relocs): New, split out from override_options.\n\t(was_mips16_p): New.\n\t(mips_set_mips16_mode): New, split out from override_options.\n\t(mips_set_current_function): New.\n\t(override_options):  Add sorry for unsupported mips16/pic\n\tcombination.  Remove error for mips16/dsp combination.\tSave\n\tbase option settings.  \n\t(mips_file_start): Move mips16 mode setting output from here....\n\t(mips_output_function_prologue): ....to here.\n\t(mips_output_mi_thunk): Check for mips16 function.\n\t(build_mips16_function_stub): Don't set .mips16 here.\n\t(build_mips16_call_stub): Likewise.\n\t(mips_expand_builtin): Error in mips16 mode.\n\t(mips_use_mips16_mode_p): New.\n\t(mips_encode_section_info): Check for mips16 function, and set\n\tSYMBOL_REF_FLAGS accordingly.\n\n\t* doc/extend.texi (Function Attributes): Document new\n\tmips16/nomips16 attributes.\n\t* doc/invoke.texi (Option Summary): Add -mflip-mips16.\n\t(MIPS Options): Document -mflip-mips16.\n\n\tgcc/testsuite/\n\t* gcc.target/mips/mips16-attributes.c: New.\n\nCo-Authored-By: David Ung <davidu@mips.com>\nCo-Authored-By: Nigel Stephens <nigel@mips.com>\n\nFrom-SVN: r128134", "tree": {"sha": "29d08101d22259feff99a98e337e4f1321941d35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29d08101d22259feff99a98e337e4f1321941d35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9e4a411f9209f967b25b2f038b117db132139a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e4a411f9209f967b25b2f038b117db132139a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9e4a411f9209f967b25b2f038b117db132139a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e4a411f9209f967b25b2f038b117db132139a5/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "edede0242fe72bf7814fa25da0ddb6a4dd516738", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edede0242fe72bf7814fa25da0ddb6a4dd516738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edede0242fe72bf7814fa25da0ddb6a4dd516738"}], "stats": {"total": 709, "additions": 536, "deletions": 173}, "files": [{"sha": "2051ef1a05c513fed192154706861a2ccd9f72ae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9e4a411f9209f967b25b2f038b117db132139a5", "patch": "@@ -1,6 +1,54 @@\n+2007-09-05  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    David Ung  <davidu@mips.com>\n+            Nigel Stephens <nigel@mips.com>\n+\n+\tAdd mips16/nomips16 function attributes and -mflip-mips16 option\n+\tfor testing mixed-mode compilation.\n+\n+\t* config/mips/mips.opt (mflip-mips16): New.\n+\n+\t* config/mips/mips.h (SYMBOL_FLAG_MIPS16_FUNC): Define.\n+\t(SYMBOL_FLAG_MIPS16_FUNC_P): Define.\n+\n+\t* config/mips/mips.c (mips_base_target_flags): New.\n+\t(mips_base_mips16): New.\n+\t(mips_base_schedule_insns): New.\n+\t(mips_base_reorder_blocks_and_partition): New.\n+\t(mips_base_align_loops): New.\n+\t(mips_base_align_jumps): New.\n+\t(mips_base_align_functions): New.\n+\t(mips16_flipper): New.\n+\t(mips_attribute_table): Add \"mips16\" and \"nomips16\" entries.\n+\t(TARGET_SET_CURRENT_FUNCTION): Define.\n+\t(mips_mips16_type_p, mips_nomips16_type_p): New.\n+\t(mips_comp_type_attributes): Check mips16/nomips16 attributes.\n+\t(mips_function_ok_for_sibcall): Make it deal with functions with\n+\tmips16 attributes.\n+\t(mips_init_split_addresses): New, split out from override_options.\n+\t(mips_init_relocs): New, split out from override_options.\n+\t(was_mips16_p): New.\n+\t(mips_set_mips16_mode): New, split out from override_options.\n+\t(mips_set_current_function): New.\n+\t(override_options):  Add sorry for unsupported mips16/pic\n+\tcombination.  Remove error for mips16/dsp combination.\tSave\n+\tbase option settings.  \n+\t(mips_file_start): Move mips16 mode setting output from here....\n+\t(mips_output_function_prologue): ....to here.\n+\t(mips_output_mi_thunk): Check for mips16 function.\n+\t(build_mips16_function_stub): Don't set .mips16 here.\n+\t(build_mips16_call_stub): Likewise.\n+\t(mips_expand_builtin): Error in mips16 mode.\n+\t(mips_use_mips16_mode_p): New.\n+\t(mips_encode_section_info): Check for mips16 function, and set\n+\tSYMBOL_REF_FLAGS accordingly.\n+\n+\t* doc/extend.texi (Function Attributes): Document new\n+\tmips16/nomips16 attributes.\n+\t* doc/invoke.texi (Option Summary): Add -mflip-mips16.\n+\t(MIPS Options): Document -mflip-mips16.\n+\n 2007-09-05  Sandra Loosemore  <sandra@codesourcery.com>\n \n-\tgcc/\n \t* config/mips/mips.c (mips_legitimize_tls_address): Call sorry\n \tif we encounter TLS address in MIPS16 mode.\n \t(mips_legitimize_const_move):  Check cannot_force_const_mem for"}, {"sha": "ae412dea64131d436a4c8d3b8dcb183c889c5635", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 360, "deletions": 171, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f9e4a411f9209f967b25b2f038b117db132139a5", "patch": "@@ -424,6 +424,8 @@ static rtx mips_expand_builtin_bposge (enum mips_builtin_type, rtx);\n static void mips_encode_section_info (tree, rtx, int);\n static void mips_extra_live_on_entry (bitmap);\n static int mips_comp_type_attributes (const_tree, const_tree);\n+static void mips_set_mips16_mode (int);\n+static void mips_set_current_function (tree);\n static int mips_mode_rep_extended (enum machine_mode, enum machine_mode);\n static bool mips_offset_within_alignment_p (rtx, HOST_WIDE_INT);\n static void mips_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n@@ -617,6 +619,18 @@ int mips_abi = MIPS_ABI_DEFAULT;\n /* Cost information to use.  */\n const struct mips_rtx_cost_data *mips_cost;\n \n+/* Remember the ambient target flags, excluding mips16.  */\n+static int mips_base_target_flags;\n+/* The mips16 command-line target flags only.  */\n+static bool mips_base_mips16;\n+/* Similar copies of option settings.  */\n+static int mips_base_schedule_insns; /* flag_schedule_insns */\n+static int mips_base_reorder_blocks_and_partition; /* flag_reorder... */\n+static int mips_base_align_loops; /* align_loops */\n+static int mips_base_align_jumps; /* align_jumps */\n+static int mips_base_align_functions; /* align_functions */\n+static GTY(()) int mips16_flipper;\n+\n /* The -mtext-loads setting.  */\n enum mips_code_readable_setting mips_code_readable = CODE_READABLE_YES;\n \n@@ -715,6 +729,9 @@ const struct attribute_spec mips_attribute_table[] =\n   { \"long_call\",   0, 0, false, true,  true,  NULL },\n   { \"far\",     \t   0, 0, false, true,  true,  NULL },\n   { \"near\",        0, 0, false, true,  true,  NULL },\n+  /* Switch MIPS16 ASE on and off per-function.  */\n+  { \"mips16\", \t   0, 0, false, true,  true,  NULL },\n+  { \"nomips16\",    0, 0, false, true,  true,  NULL },\n   { NULL,\t   0, 0, false, false, false, NULL }\n };\n \f\n@@ -1251,6 +1268,9 @@ static const unsigned char mips16e_save_restore_regs[] = {\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL mips_function_ok_for_sibcall\n \n+#undef TARGET_SET_CURRENT_FUNCTION\n+#define TARGET_SET_CURRENT_FUNCTION mips_set_current_function\n+\n #undef TARGET_VALID_POINTER_MODE\n #define TARGET_VALID_POINTER_MODE mips_valid_pointer_mode\n #undef TARGET_RTX_COSTS\n@@ -1369,6 +1389,19 @@ mips_far_type_p (const_tree type)\n \t  || lookup_attribute (\"far\", TYPE_ATTRIBUTES (type)) != NULL);\n }\n \n+/* Similar predicates for \"mips16\"/\"nomips16\" attributes.  */\n+\n+static bool\n+mips_mips16_type_p (const_tree type)\n+{\n+  return lookup_attribute (\"mips16\", TYPE_ATTRIBUTES (type)) != NULL;\n+}\n+\n+static bool\n+mips_nomips16_type_p (const_tree type)\n+{\n+  return lookup_attribute (\"nomips16\", TYPE_ATTRIBUTES (type)) != NULL;\n+}\n \n /* Return 0 if the attributes for two types are incompatible, 1 if they\n    are compatible, and 2 if they are nearly compatible (which causes a\n@@ -1387,6 +1420,11 @@ mips_comp_type_attributes (const_tree type1, const_tree type2)\n   if (mips_near_type_p (type1) && mips_far_type_p (type2))\n     return 0;\n \n+  /* Mips16/nomips16 attributes must match exactly.  */\n+  if (mips_nomips16_type_p (type1) != mips_nomips16_type_p (type2)\n+      || mips_mips16_type_p (type1) != mips_mips16_type_p (type2))\n+    return 0;\n+\n   return 1;\n }\n \f\n@@ -3789,13 +3827,22 @@ mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, int sibcall_p)\n }\n \n \n-/* We can handle any sibcall when TARGET_SIBCALLS is true.  */\n+/* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n \n static bool\n-mips_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n-\t\t\t      tree exp ATTRIBUTE_UNUSED)\n+mips_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n-  return TARGET_SIBCALLS;\n+  if (!TARGET_SIBCALLS)\n+    return false;\n+\n+  /* We can't do a sibcall if the called function is a MIPS16 function\n+     because there is no direct \"jx\" instruction equivalent to \"jalx\" to\n+     switch the ISA mode.  */\n+  if (decl && SYMBOL_REF_MIPS16_FUNC_P (XEXP (DECL_RTL (decl), 0)))\n+    return false;\n+\n+  /* Otherwise OK.  */\n+  return true;\n }\n \f\n /* Emit code to move general operand SRC into condition-code\n@@ -5038,6 +5085,231 @@ mips_set_tune (const struct mips_cpu_info *info)\n     }\n }\n \n+/* Initialize mips_split_addresses from the associated command-line\n+   settings.\n+\n+   mips_split_addresses is a half-way house between explicit\n+   relocations and the traditional assembler macros.  It can\n+   split absolute 32-bit symbolic constants into a high/lo_sum\n+   pair but uses macros for other sorts of access.\n+   \n+   Like explicit relocation support for REL targets, it relies\n+   on GNU extensions in the assembler and the linker.\n+\n+   Although this code should work for -O0, it has traditionally\n+   been treated as an optimization.  */\n+\n+static void\n+mips_init_split_addresses (void)\n+{\n+  if (!TARGET_MIPS16 && TARGET_SPLIT_ADDRESSES\n+      && optimize && !flag_pic\n+      && !ABI_HAS_64BIT_SYMBOLS)\n+    mips_split_addresses = 1;\n+  else\n+    mips_split_addresses = 0;\n+}\n+\n+/* (Re-)Initialize information about relocs.  */\n+\n+static void\n+mips_init_relocs (void)\n+{\n+  memset (mips_split_p, '\\0', sizeof (mips_split_p));\n+  memset (mips_hi_relocs, '\\0', sizeof (mips_hi_relocs));\n+  memset (mips_lo_relocs, '\\0', sizeof (mips_lo_relocs));\n+\n+  if (ABI_HAS_64BIT_SYMBOLS)\n+    {\n+      if (TARGET_EXPLICIT_RELOCS)\n+\t{\n+\t  mips_split_p[SYMBOL_64_HIGH] = true;\n+\t  mips_hi_relocs[SYMBOL_64_HIGH] = \"%highest(\";\n+\t  mips_lo_relocs[SYMBOL_64_HIGH] = \"%higher(\";\n+\n+\t  mips_split_p[SYMBOL_64_MID] = true;\n+\t  mips_hi_relocs[SYMBOL_64_MID] = \"%higher(\";\n+\t  mips_lo_relocs[SYMBOL_64_MID] = \"%hi(\";\n+\n+\t  mips_split_p[SYMBOL_64_LOW] = true;\n+\t  mips_hi_relocs[SYMBOL_64_LOW] = \"%hi(\";\n+\t  mips_lo_relocs[SYMBOL_64_LOW] = \"%lo(\";\n+\n+\t  mips_split_p[SYMBOL_ABSOLUTE] = true;\n+\t  mips_lo_relocs[SYMBOL_ABSOLUTE] = \"%lo(\";\n+\t}\n+    }\n+  else\n+    {\n+      if (TARGET_EXPLICIT_RELOCS || mips_split_addresses || TARGET_MIPS16)\n+\t{\n+\t  mips_split_p[SYMBOL_ABSOLUTE] = true;\n+\t  mips_hi_relocs[SYMBOL_ABSOLUTE] = \"%hi(\";\n+\t  mips_lo_relocs[SYMBOL_ABSOLUTE] = \"%lo(\";\n+\n+\t  mips_lo_relocs[SYMBOL_32_HIGH] = \"%hi(\";\n+\t}\n+    }\n+\n+  if (TARGET_MIPS16)\n+    {\n+      /* The high part is provided by a pseudo copy of $gp.  */\n+      mips_split_p[SYMBOL_GP_RELATIVE] = true;\n+      mips_lo_relocs[SYMBOL_GP_RELATIVE] = \"%gprel(\";\n+    }\n+\n+  if (TARGET_EXPLICIT_RELOCS)\n+    {\n+      /* Small data constants are kept whole until after reload,\n+\t then lowered by mips_rewrite_small_data.  */\n+      mips_lo_relocs[SYMBOL_GP_RELATIVE] = \"%gp_rel(\";\n+\n+      mips_split_p[SYMBOL_GOT_PAGE_OFST] = true;\n+      if (TARGET_NEWABI)\n+\t{\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_PAGE] = \"%got_page(\";\n+\t  mips_lo_relocs[SYMBOL_GOT_PAGE_OFST] = \"%got_ofst(\";\n+\t}\n+      else\n+\t{\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_PAGE] = \"%got(\";\n+\t  mips_lo_relocs[SYMBOL_GOT_PAGE_OFST] = \"%lo(\";\n+\t}\n+\n+      if (TARGET_XGOT)\n+\t{\n+\t  /* The HIGH and LO_SUM are matched by special .md patterns.  */\n+\t  mips_split_p[SYMBOL_GOT_DISP] = true;\n+\n+\t  mips_split_p[SYMBOL_GOTOFF_DISP] = true;\n+\t  mips_hi_relocs[SYMBOL_GOTOFF_DISP] = \"%got_hi(\";\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_DISP] = \"%got_lo(\";\n+\n+\t  mips_split_p[SYMBOL_GOTOFF_CALL] = true;\n+\t  mips_hi_relocs[SYMBOL_GOTOFF_CALL] = \"%call_hi(\";\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_CALL] = \"%call_lo(\";\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_NEWABI)\n+\t    mips_lo_relocs[SYMBOL_GOTOFF_DISP] = \"%got_disp(\";\n+\t  else\n+\t    mips_lo_relocs[SYMBOL_GOTOFF_DISP] = \"%got(\";\n+\t  mips_lo_relocs[SYMBOL_GOTOFF_CALL] = \"%call16(\";\n+\t}\n+    }\n+\n+  if (TARGET_NEWABI)\n+    {\n+      mips_split_p[SYMBOL_GOTOFF_LOADGP] = true;\n+      mips_hi_relocs[SYMBOL_GOTOFF_LOADGP] = \"%hi(%neg(%gp_rel(\";\n+      mips_lo_relocs[SYMBOL_GOTOFF_LOADGP] = \"%lo(%neg(%gp_rel(\";\n+    }\n+\n+  /* Thread-local relocation operators.  */\n+  mips_lo_relocs[SYMBOL_TLSGD] = \"%tlsgd(\";\n+  mips_lo_relocs[SYMBOL_TLSLDM] = \"%tlsldm(\";\n+  mips_split_p[SYMBOL_DTPREL] = 1;\n+  mips_hi_relocs[SYMBOL_DTPREL] = \"%dtprel_hi(\";\n+  mips_lo_relocs[SYMBOL_DTPREL] = \"%dtprel_lo(\";\n+  mips_lo_relocs[SYMBOL_GOTTPREL] = \"%gottprel(\";\n+  mips_split_p[SYMBOL_TPREL] = 1;\n+  mips_hi_relocs[SYMBOL_TPREL] = \"%tprel_hi(\";\n+  mips_lo_relocs[SYMBOL_TPREL] = \"%tprel_lo(\";\n+\n+  mips_lo_relocs[SYMBOL_HALF] = \"%half(\";\n+}\n+\n+static GTY(()) int was_mips16_p = -1;\n+\n+/* Set up the target-dependent global state so that it matches the\n+   current function's ISA mode.  */\n+\n+static void\n+mips_set_mips16_mode (int mips16_p)\n+{\n+  if (mips16_p == was_mips16_p)\n+    return;\n+\n+  /* Restore base settings of various flags.  */\n+  target_flags = mips_base_target_flags;\n+  align_loops = mips_base_align_loops;\n+  align_jumps = mips_base_align_jumps;\n+  align_functions = mips_base_align_functions;\n+  flag_schedule_insns = mips_base_schedule_insns;\n+  flag_reorder_blocks_and_partition = mips_base_reorder_blocks_and_partition;\n+  flag_delayed_branch = mips_flag_delayed_branch;\n+  \n+  if (mips16_p) \n+    {\n+      /* Select mips16 instruction set.  */\n+      target_flags |= MASK_MIPS16;\n+\n+      /* Don't run the scheduler before reload, since it tends to\n+         increase register pressure.  */\n+      flag_schedule_insns = 0;\n+\n+      /* Don't do hot/cold partitioning.  The constant layout code expects\n+       the whole function to be in a single section.  */\n+      flag_reorder_blocks_and_partition = 0;\n+\n+      /* Silently disable -mexplicit-relocs since it doesn't apply\n+\t to mips16 code.  Even so, it would overly pedantic to warn\n+\t about \"-mips16 -mexplicit-relocs\", especially given that\n+\t we use a %gprel() operator.  */\n+      target_flags &= ~MASK_EXPLICIT_RELOCS;\n+\n+      /* Silently disable DSP extensions.  */\n+      target_flags &= ~MASK_DSP;\n+      target_flags &= ~MASK_DSPR2;\n+    }\n+  else \n+    {\n+      /* Reset to select base non-mips16 ISA.  */\n+      target_flags &= ~MASK_MIPS16;\n+\n+      /* When using explicit relocs, we call dbr_schedule from within\n+\t mips_reorg.  */\n+      if (TARGET_EXPLICIT_RELOCS)\n+\tflag_delayed_branch = 0;\n+\n+      /* Provide default values for align_* for 64-bit targets.  */\n+      if (TARGET_64BIT)\n+\t{\n+\t  if (align_loops == 0)\n+\t    align_loops = 8;\n+\t  if (align_jumps == 0)\n+\t    align_jumps = 8;\n+\t  if (align_functions == 0)\n+\t    align_functions = 8;\n+\t}\n+    }\n+\n+  /* (Re)initialize mips target internals for new ISA.  */\n+  mips_init_split_addresses ();\n+  mips_init_relocs ();\n+\n+  if (was_mips16_p >= 0)\n+    /* Reinitialize target-dependent state.  */\n+    target_reinit ();\n+\n+  was_mips16_p = TARGET_MIPS16;\n+}\n+\n+/* Implement TARGET_SET_CURRENT_FUNCTION.  Decide whether the current \n+   function should use the MIPS16 ISA and switch modes accordingly.  */\n+\n+static void\n+mips_set_current_function (tree fndecl)\n+{\n+  int mips16p;\n+  if (fndecl)\n+    mips16p = SYMBOL_REF_MIPS16_FUNC_P (XEXP (DECL_RTL (fndecl), 0));\n+  else\n+    mips16p = mips_base_mips16;\n+  mips_set_mips16_mode (mips16p);\n+}\n+\n /* Implement TARGET_HANDLE_OPTION.  */\n \n static bool\n@@ -5265,6 +5537,14 @@ override_options (void)\n       target_flags &= ~MASK_ABICALLS;\n     }\n \n+  /* MIPS16 cannot generate PIC yet.  */\n+  if (TARGET_MIPS16 && (flag_pic || TARGET_ABICALLS))\n+    {\n+      sorry (\"MIPS16 PIC\");\n+      target_flags &= ~MASK_ABICALLS;\n+      flag_pic = flag_pie = flag_shlib = 0;\n+    }\n+\n   if (TARGET_ABICALLS)\n     {\n       /* We need to set flag_pic for executables as well as DSOs\n@@ -5282,54 +5562,12 @@ override_options (void)\n   if (TARGET_VXWORKS_RTP && mips_section_threshold > 0)\n     warning (0, \"-G and -mrtp are incompatible\");\n \n-  /* mips_split_addresses is a half-way house between explicit\n-     relocations and the traditional assembler macros.  It can\n-     split absolute 32-bit symbolic constants into a high/lo_sum\n-     pair but uses macros for other sorts of access.\n-\n-     Like explicit relocation support for REL targets, it relies\n-     on GNU extensions in the assembler and the linker.\n-\n-     Although this code should work for -O0, it has traditionally\n-     been treated as an optimization.  */\n-  if (!TARGET_MIPS16 && TARGET_SPLIT_ADDRESSES\n-      && optimize && !flag_pic\n-      && !ABI_HAS_64BIT_SYMBOLS)\n-    mips_split_addresses = 1;\n-  else\n-    mips_split_addresses = 0;\n-\n   /* -mvr4130-align is a \"speed over size\" optimization: it usually produces\n      faster code, but at the expense of more nops.  Enable it at -O3 and\n      above.  */\n   if (optimize > 2 && (target_flags_explicit & MASK_VR4130_ALIGN) == 0)\n     target_flags |= MASK_VR4130_ALIGN;\n \n-  if (TARGET_MIPS16)\n-    {\n-      /* Don't run the scheduler before reload, since it tends to\n-         increase register pressure.  */\n-      flag_schedule_insns = 0;\n-\n-      /* Don't do hot/cold partitioning.  The constant layout code expects\n-\t the whole function to be in a single section.  */\n-      flag_reorder_blocks_and_partition = 0;\n-\n-      /* Silently disable -mexplicit-relocs since it doesn't apply\n-\t to mips16 code.  Even so, it would overly pedantic to warn\n-\t about \"-mips16 -mexplicit-relocs\", especially given that\n-\t we use a %gprel() operator.  */\n-      target_flags &= ~MASK_EXPLICIT_RELOCS;\n-    }\n-\n-  /* When using explicit relocs, we call dbr_schedule from within\n-     mips_reorg.  */\n-  if (TARGET_EXPLICIT_RELOCS)\n-    {\n-      mips_flag_delayed_branch = flag_delayed_branch;\n-      flag_delayed_branch = 0;\n-    }\n-\n   /* Prefer a call to memcpy over inline code when optimizing for size,\n      though see MOVE_RATIO in mips.h.  */\n   if (optimize_size && (target_flags_explicit & MASK_MEMCPY) == 0)\n@@ -5363,9 +5601,6 @@ override_options (void)\n   if (TARGET_DSPR2)\n     target_flags |= MASK_DSP;\n \n-  if (TARGET_MIPS16 && TARGET_DSP)\n-    error (\"-mips16 and -mdsp cannot be used together\");\n-\n   mips_print_operand_punct['?'] = 1;\n   mips_print_operand_punct['#'] = 1;\n   mips_print_operand_punct['/'] = 1;\n@@ -5493,120 +5728,9 @@ override_options (void)\n      initialized yet, so we can't use that here.  */\n   gpr_mode = TARGET_64BIT ? DImode : SImode;\n \n-  /* Provide default values for align_* for 64-bit targets.  */\n-  if (TARGET_64BIT && !TARGET_MIPS16)\n-    {\n-      if (align_loops == 0)\n-\talign_loops = 8;\n-      if (align_jumps == 0)\n-\talign_jumps = 8;\n-      if (align_functions == 0)\n-\talign_functions = 8;\n-    }\n-\n   /* Function to allocate machine-dependent function status.  */\n   init_machine_status = &mips_init_machine_status;\n \n-  if (ABI_HAS_64BIT_SYMBOLS)\n-    {\n-      if (TARGET_EXPLICIT_RELOCS)\n-\t{\n-\t  mips_split_p[SYMBOL_64_HIGH] = true;\n-\t  mips_hi_relocs[SYMBOL_64_HIGH] = \"%highest(\";\n-\t  mips_lo_relocs[SYMBOL_64_HIGH] = \"%higher(\";\n-\n-\t  mips_split_p[SYMBOL_64_MID] = true;\n-\t  mips_hi_relocs[SYMBOL_64_MID] = \"%higher(\";\n-\t  mips_lo_relocs[SYMBOL_64_MID] = \"%hi(\";\n-\n-\t  mips_split_p[SYMBOL_64_LOW] = true;\n-\t  mips_hi_relocs[SYMBOL_64_LOW] = \"%hi(\";\n-\t  mips_lo_relocs[SYMBOL_64_LOW] = \"%lo(\";\n-\n-\t  mips_split_p[SYMBOL_ABSOLUTE] = true;\n-\t  mips_lo_relocs[SYMBOL_ABSOLUTE] = \"%lo(\";\n-\t}\n-    }\n-  else\n-    {\n-      if (TARGET_EXPLICIT_RELOCS || mips_split_addresses || TARGET_MIPS16)\n-\t{\n-\t  mips_split_p[SYMBOL_ABSOLUTE] = true;\n-\t  mips_hi_relocs[SYMBOL_ABSOLUTE] = \"%hi(\";\n-\t  mips_lo_relocs[SYMBOL_ABSOLUTE] = \"%lo(\";\n-\n-\t  mips_lo_relocs[SYMBOL_32_HIGH] = \"%hi(\";\n-\t}\n-    }\n-\n-  if (TARGET_MIPS16)\n-    {\n-      /* The high part is provided by a pseudo copy of $gp.  */\n-      mips_split_p[SYMBOL_GP_RELATIVE] = true;\n-      mips_lo_relocs[SYMBOL_GP_RELATIVE] = \"%gprel(\";\n-    }\n-\n-  if (TARGET_EXPLICIT_RELOCS)\n-    {\n-      /* Small data constants are kept whole until after reload,\n-\t then lowered by mips_rewrite_small_data.  */\n-      mips_lo_relocs[SYMBOL_GP_RELATIVE] = \"%gp_rel(\";\n-\n-      mips_split_p[SYMBOL_GOT_PAGE_OFST] = true;\n-      if (TARGET_NEWABI)\n-\t{\n-\t  mips_lo_relocs[SYMBOL_GOTOFF_PAGE] = \"%got_page(\";\n-\t  mips_lo_relocs[SYMBOL_GOT_PAGE_OFST] = \"%got_ofst(\";\n-\t}\n-      else\n-\t{\n-\t  mips_lo_relocs[SYMBOL_GOTOFF_PAGE] = \"%got(\";\n-\t  mips_lo_relocs[SYMBOL_GOT_PAGE_OFST] = \"%lo(\";\n-\t}\n-\n-      if (TARGET_XGOT)\n-\t{\n-\t  /* The HIGH and LO_SUM are matched by special .md patterns.  */\n-\t  mips_split_p[SYMBOL_GOT_DISP] = true;\n-\n-\t  mips_split_p[SYMBOL_GOTOFF_DISP] = true;\n-\t  mips_hi_relocs[SYMBOL_GOTOFF_DISP] = \"%got_hi(\";\n-\t  mips_lo_relocs[SYMBOL_GOTOFF_DISP] = \"%got_lo(\";\n-\n-\t  mips_split_p[SYMBOL_GOTOFF_CALL] = true;\n-\t  mips_hi_relocs[SYMBOL_GOTOFF_CALL] = \"%call_hi(\";\n-\t  mips_lo_relocs[SYMBOL_GOTOFF_CALL] = \"%call_lo(\";\n-\t}\n-      else\n-\t{\n-\t  if (TARGET_NEWABI)\n-\t    mips_lo_relocs[SYMBOL_GOTOFF_DISP] = \"%got_disp(\";\n-\t  else\n-\t    mips_lo_relocs[SYMBOL_GOTOFF_DISP] = \"%got(\";\n-\t  mips_lo_relocs[SYMBOL_GOTOFF_CALL] = \"%call16(\";\n-\t}\n-    }\n-\n-  if (TARGET_NEWABI)\n-    {\n-      mips_split_p[SYMBOL_GOTOFF_LOADGP] = true;\n-      mips_hi_relocs[SYMBOL_GOTOFF_LOADGP] = \"%hi(%neg(%gp_rel(\";\n-      mips_lo_relocs[SYMBOL_GOTOFF_LOADGP] = \"%lo(%neg(%gp_rel(\";\n-    }\n-\n-  /* Thread-local relocation operators.  */\n-  mips_lo_relocs[SYMBOL_TLSGD] = \"%tlsgd(\";\n-  mips_lo_relocs[SYMBOL_TLSLDM] = \"%tlsldm(\";\n-  mips_split_p[SYMBOL_DTPREL] = 1;\n-  mips_hi_relocs[SYMBOL_DTPREL] = \"%dtprel_hi(\";\n-  mips_lo_relocs[SYMBOL_DTPREL] = \"%dtprel_lo(\";\n-  mips_lo_relocs[SYMBOL_GOTTPREL] = \"%gottprel(\";\n-  mips_split_p[SYMBOL_TPREL] = 1;\n-  mips_hi_relocs[SYMBOL_TPREL] = \"%tprel_hi(\";\n-  mips_lo_relocs[SYMBOL_TPREL] = \"%tprel_lo(\";\n-\n-  mips_lo_relocs[SYMBOL_HALF] = \"%half(\";\n-\n   /* Default to working around R4000 errata only if the processor\n      was selected explicitly.  */\n   if ((target_flags_explicit & MASK_FIX_R4000) == 0\n@@ -5618,6 +5742,19 @@ override_options (void)\n   if ((target_flags_explicit & MASK_FIX_R4400) == 0\n       && mips_matching_cpu_name_p (mips_arch_info->name, \"r4400\"))\n     target_flags |= MASK_FIX_R4400;\n+\n+  /* Save base state of options.  */\n+  mips_base_mips16 = TARGET_MIPS16;\n+  mips_base_target_flags = target_flags;\n+  mips_base_schedule_insns = flag_schedule_insns;\n+  mips_base_reorder_blocks_and_partition = flag_reorder_blocks_and_partition;\n+  mips_base_align_loops = align_loops;\n+  mips_base_align_jumps = align_jumps;\n+  mips_base_align_functions = align_functions;\n+  mips_flag_delayed_branch = flag_delayed_branch;\n+\n+  /* Now select the mips16 or 32-bit instruction set, as requested.  */\n+  mips_set_mips16_mode (mips_base_mips16);\n }\n \n /* Swap the register information for registers I and I + 1, which\n@@ -6373,9 +6510,6 @@ mips_file_start (void)\n   if (TARGET_ABICALLS)\n     fprintf (asm_out_file, \"\\t.abicalls\\n\");\n \n-  if (TARGET_MIPS16)\n-    fprintf (asm_out_file, \"\\t.set\\tmips16\\n\");\n-\n   if (flag_verbose_asm)\n     fprintf (asm_out_file, \"\\n%s -G value = %d, Arch = %s, ISA = %d\\n\",\n \t     ASM_COMMENT_START,\n@@ -7230,6 +7364,12 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       && current_function_args_info.fp_code != 0)\n     build_mips16_function_stub (file);\n \n+  /* Select the mips16 mode for this function.  */\n+  if (TARGET_MIPS16)\n+    fprintf (file, \"\\t.set\\tmips16\\n\");\n+  else \n+    fprintf (file, \"\\t.set\\tnomips16\\n\");\n+\n   if (!FUNCTION_NAME_ALREADY_DECLARED)\n     {\n       /* Get the function name the same way that toplev.c does before calling\n@@ -8186,7 +8326,6 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \tTARGET_CALL_SAVED_GP ? 15 : GLOBAL_POINTER_REGNUM;\n \n       SET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);\n-\n     }\n \n   /* Set up the global pointer for n32 or n64 abicalls.  If\n@@ -8237,7 +8376,8 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Jump to the target function.  Use a sibcall if direct jumps are\n      allowed, otherwise load the address into a register first.  */\n   fnaddr = XEXP (DECL_RTL (function), 0);\n-  if (TARGET_MIPS16 || TARGET_USE_GOT || SYMBOL_REF_LONG_CALL_P (fnaddr))\n+  if (TARGET_MIPS16 || TARGET_USE_GOT || SYMBOL_REF_LONG_CALL_P (fnaddr)\n+      || SYMBOL_REF_MIPS16_FUNC_P (fnaddr))\n     {\n       /* This is messy.  gas treats \"la $25,foo\" as part of a call\n \t sequence and may allow a global \"foo\" to be lazily bound.\n@@ -9073,8 +9213,6 @@ build_mips16_function_stub (FILE *file)\n       fputs (\"\\n\", file);\n     }\n \n-  fprintf (file, \"\\t.set\\tmips16\\n\");\n-\n   switch_to_section (function_section (current_function_decl));\n }\n \n@@ -9406,8 +9544,6 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \t  fputs (\"\\n\", asm_out_file);\n \t}\n \n-      fprintf (asm_out_file, \"\\t.set\\tmips16\\n\");\n-\n       /* Record this stub.  */\n       l = (struct mips16_stub *) xmalloc (sizeof *l);\n       l->name = xstrdup (fnname);\n@@ -11648,6 +11784,13 @@ mips_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   fcode = DECL_FUNCTION_CODE (fndecl);\n \n+  if (TARGET_MIPS16)\n+    {\n+      error (\"built-in function %qs not supported for MIPS16\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+      return const0_rtx;\n+    }\n+\n   bdesc = NULL;\n   for (m = bdesc_arrays; m < &bdesc_arrays[ARRAY_SIZE (bdesc_arrays)]; m++)\n     {\n@@ -12154,6 +12297,43 @@ mips_expand_builtin_bposge (enum mips_builtin_type builtin_type, rtx target)\n \t\t\t\t       const1_rtx, const0_rtx);\n }\n \f\n+/* Return true if we should force MIPS16 mode for the function named by\n+   the SYMBOL_REF SYMBOL, which belongs to DECL and has type TYPE.\n+   FIRST is true if this is the first time handling this decl.  */\n+\n+static bool\n+mips_use_mips16_mode_p (rtx symbol, tree decl, int first, tree type)\n+{\n+  tree parent;\n+\n+  /* Explicit function attributes take precedence.  */\n+  if (mips_mips16_type_p (type))\n+    return true;\n+  if (mips_nomips16_type_p (type))\n+    return false;\n+\n+  /* A nested function should inherit the MIPS16 setting from its parent.  */\n+  parent = decl_function_context (decl);\n+  if (parent)\n+    return SYMBOL_REF_MIPS16_FUNC_P (XEXP (DECL_RTL (parent), 0));\n+\n+  /* Handle -mflip-mips16.  */\n+  if (TARGET_FLIP_MIPS16\n+      && !DECL_BUILT_IN (decl)\n+      && !DECL_ARTIFICIAL (decl))\n+    {\n+      if (!first)\n+\t/* Use the setting we picked first time around.  */\n+\treturn SYMBOL_REF_MIPS16_FUNC_P (symbol);\n+\n+      mips16_flipper = !mips16_flipper;\n+      if (mips16_flipper)\n+\treturn !mips_base_mips16;\n+    }\n+\n+  return mips_base_mips16;\n+}\n+\n /* Set SYMBOL_REF_FLAGS for the SYMBOL_REF inside RTL, which belongs to DECL.\n    FIRST is true if this is the first time handling this decl.  */\n \n@@ -12165,10 +12345,19 @@ mips_encode_section_info (tree decl, rtx rtl, int first)\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       rtx symbol = XEXP (rtl, 0);\n+      tree type = TREE_TYPE (decl);\n \n-      if ((TARGET_LONG_CALLS && !mips_near_type_p (TREE_TYPE (decl)))\n-\t  || mips_far_type_p (TREE_TYPE (decl)))\n+      if ((TARGET_LONG_CALLS && !mips_near_type_p (type))\n+\t  || mips_far_type_p (type))\n \tSYMBOL_REF_FLAGS (symbol) |= SYMBOL_FLAG_LONG_CALL;\n+\n+      if (mips_use_mips16_mode_p (symbol, decl, first, type))\n+\t{\n+\t  if (flag_pic || TARGET_ABICALLS)\n+\t    sorry (\"MIPS16 PIC\");\n+\t  else\n+\t    SYMBOL_REF_FLAGS (symbol) |= SYMBOL_FLAG_MIPS16_FUNC;\n+\t}\n     }\n }\n "}, {"sha": "cc6b50011be78583ccb6f2de03214ce6bbc6de28", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=f9e4a411f9209f967b25b2f038b117db132139a5", "patch": "@@ -2301,6 +2301,11 @@ typedef struct mips_args {\n #define SYMBOL_REF_LONG_CALL_P(X)\t\t\t\t\t\\\n   ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_LONG_CALL) != 0)\n \n+/* Flag to mark a function decl symbol a \"mips16\" function.  */\n+#define SYMBOL_FLAG_MIPS16_FUNC\t(SYMBOL_FLAG_MACH_DEP << 1)\n+#define SYMBOL_REF_MIPS16_FUNC_P(RTX) \\\n+  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_MIPS16_FUNC) != 0)\n+\n /* True if we're generating a form of MIPS16 code in which jump tables\n    are stored in the text section and encoded as 16-bit PC-relative\n    offsets.  This is only possible when general text loads are allowed,"}, {"sha": "7f60bebc7b823a4357b61da1be06349a42660cfd", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=f9e4a411f9209f967b25b2f038b117db132139a5", "patch": "@@ -42,6 +42,10 @@ mbranch-likely\n Target Report Mask(BRANCHLIKELY)\n Use Branch Likely instructions, overriding the architecture default\n \n+mflip-mips16\n+Target Report Var(TARGET_FLIP_MIPS16)\n+Switch on/off MIPS16 ASE on alternating functions for compiler testing\n+\n mcheck-zero-division\n Target Report Mask(CHECK_ZERO_DIV)\n Trap on integer divide by zero"}, {"sha": "0012740476b924b22404f75118112352f88742cd", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=f9e4a411f9209f967b25b2f038b117db132139a5", "patch": "@@ -2202,6 +2202,24 @@ long as the old pointer is never referred to (including comparing it\n to the new pointer) after the function returns a non-@code{NULL}\n value.\n \n+@item mips16/nomips16\n+@cindex @code{mips16} attribute\n+@cindex @code{nomips16} attribute\n+\n+On MIPS targets, you can use the @code{mips16} and @code{nomips16}\n+function attributes to locally select or turn off MIPS16 code generation.\n+A function with the @code{mips16} attribute is emitted as MIPS16 code, \n+while MIPS16 code generation is disabled for functions with the \n+@code{nomips16} attribute.  These attributes override the \n+@option{-mips16} and @option{-mno-mips16} options on the command line\n+(@pxref{MIPS Options}).  \n+\n+When compiling files containing mixed MIPS16 and non-MIPS16 code, the\n+preprocessor symbol @code{__mips16} reflects the setting on the command line,\n+not that within individual functions.  Mixed MIPS16 and non-MIPS16 code\n+may interact badly with some GCC extensions such as @code{__builtin_apply}\n+(@pxref{Constructing Calls}).\n+\n @item model (@var{model-name})\n @cindex function addressability on the M32R/D\n @cindex variable addressability on the IA-64"}, {"sha": "734c8edfb45e58b099bea350da0d77182dacc668", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f9e4a411f9209f967b25b2f038b117db132139a5", "patch": "@@ -620,7 +620,8 @@ Objective-C and Objective-C++ Dialects}.\n @emph{MIPS Options}\n @gccoptlist{-EL  -EB  -march=@var{arch}  -mtune=@var{arch} @gol\n -mips1  -mips2  -mips3  -mips4  -mips32  -mips32r2  -mips64 @gol\n--mips16  -mno-mips16  -mabi=@var{abi}  -mabicalls  -mno-abicalls @gol\n+-mips16  -mno-mips16  -mflip-mips16 @gol\n+-mabi=@var{abi}  -mabicalls  -mno-abicalls @gol\n -mshared  -mno-shared  -mxgot  -mno-xgot  -mgp32  -mgp64 @gol\n -mfp32  -mfp64  -mhard-float  -msoft-float @gol\n -msingle-float  -mdouble-float  -mdsp  -mno-dsp  -mdspr2  -mno-dspr2 @gol\n@@ -11626,6 +11627,16 @@ Equivalent to @samp{-march=mips64}.\n Generate (do not generate) MIPS16 code.  If GCC is targetting a\n MIPS32 or MIPS64 architecture, it will make use of the MIPS16e ASE@.\n \n+MIPS16 code generation can also be controlled on a per-function basis\n+by means of @code{mips16} and @code{nomips16} attributes.  \n+@xref{Function Attributes}, for more information.\n+\n+@item -mflip-mips16\n+@opindex mflip-mips16\n+Generate MIPS16 code on alternating functions.  This option is provided\n+for regression testing of mixed MIPS16/non-MIPS16 code generation, and is\n+not intended for ordinary use in compiling user code.\n+\n @item -mabi=32\n @itemx -mabi=o64\n @itemx -mabi=n32"}, {"sha": "e00d89c5ff2625c9c24d380182bba967ae566763", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f9e4a411f9209f967b25b2f038b117db132139a5", "patch": "@@ -1,3 +1,9 @@\n+2007-09-05  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    David Ung  <davidu@mips.com>\n+            Nigel Stephens <nigel@mips.com>\n+\n+\t* gcc.target/mips/mips16-attributes.c: New.\n+\n 2007-09-05  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/31564"}, {"sha": "dca75e5d02f3a6785a70504212a9b58ce697cca4", "filename": "gcc/testsuite/gcc.target/mips/mips16-attributes.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips16-attributes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e4a411f9209f967b25b2f038b117db132139a5/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips16-attributes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips16-attributes.c?ref=f9e4a411f9209f967b25b2f038b117db132139a5", "patch": "@@ -0,0 +1,82 @@\n+/* Verify that mips16 and nomips16 attributes work, checking all combinations\n+   of calling a nomips16/mips16/default function from a nomips16/mips16/default\n+   function.  */\n+/* { dg-do run { target mipsisa*-*-elf* } } */\n+\n+#include <stdlib.h>\n+\n+#define ATTR1 __attribute__ ((nomips16))\n+#define ATTR2 __attribute__ ((mips16))\n+#define ATTR3\n+\n+double ATTR1\n+f1 (int i, float f, double d)\n+{\n+  return i + f + d;\n+}\n+\n+double ATTR2\n+f2 (int i, float f, double d)\n+{\n+  return i + f + d;\n+}\n+\n+double ATTR3\n+f3 (int i, float f, double d)\n+{\n+  return i + f + d;\n+}\n+\n+void ATTR1\n+g1 (int i, float f, double d)\n+{\n+  double r = i + f + d;\n+\n+  if (f1 (i, f, d) != r)\n+    abort ();\n+  if (f2 (i+1, f+1, d+1) != r + 3)\n+    abort ();\n+  if (f3 (i+2, f+2, d+2) != r + 6)\n+    abort ();\n+}\n+\n+void ATTR2\n+g2 (int i, float f, double d)\n+{\n+  double r = i + f + d;\n+\n+  if (f1 (i, f, d) != r)\n+    abort ();\n+  if (f2 (i+1, f+1, d+1) != r + 3)\n+    abort ();\n+  if (f3 (i+2, f+2, d+2) != r + 6)\n+    abort ();\n+}\n+\n+void ATTR3\n+g3 (int i, float f, double d)\n+{\n+  double r = i + f + d;\n+\n+  if (f1 (i, f, d) != r)\n+    abort ();\n+  if (f2 (i+1, f+1, d+1) != r + 3)\n+    abort ();\n+  if (f3 (i+2, f+2, d+2) != r + 6)\n+    abort ();\n+}\n+\n+int ATTR3\n+main (void)\n+{\n+  int i = 1;\n+  float f = -2.0;\n+  double d = 3.0;\n+\n+  g1 (i, f, d);\n+  g2 (i, f, d);\n+  g3 (i, f, d);\n+\n+  exit (0);\n+}\n+"}]}