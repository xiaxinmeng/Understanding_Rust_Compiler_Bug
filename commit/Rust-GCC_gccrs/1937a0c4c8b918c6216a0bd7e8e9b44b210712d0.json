{"sha": "1937a0c4c8b918c6216a0bd7e8e9b44b210712d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkzN2EwYzRjOGI5MThjNjIxNmEwYmQ3ZThlOWI0NGIyMTA3MTJkMA==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2007-12-13T10:24:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:24:08Z"}, "message": "eval_fat.adb (Decompose_Int): Handle argument of zero.\n\n2007-12-06  Geert Bosch  <bosch@adacore.com>\n\n\t* eval_fat.adb (Decompose_Int): Handle argument of zero.\n\t(Compose): Remove special casing of zero.\n\t(Exponent): Likewise.\n\t(Fraction): Likewise.\n\t(Machine): Likewise.\n\t(Decompose): Update comment.\n\nFrom-SVN: r130827", "tree": {"sha": "d31666d1f5ae2a4eb30efba490dfc245e697e3bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d31666d1f5ae2a4eb30efba490dfc245e697e3bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1937a0c4c8b918c6216a0bd7e8e9b44b210712d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1937a0c4c8b918c6216a0bd7e8e9b44b210712d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1937a0c4c8b918c6216a0bd7e8e9b44b210712d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1937a0c4c8b918c6216a0bd7e8e9b44b210712d0/comments", "author": null, "committer": null, "parents": [{"sha": "987c5cecd034d57ef50e2e93266acd15e693f3e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/987c5cecd034d57ef50e2e93266acd15e693f3e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/987c5cecd034d57ef50e2e93266acd15e693f3e7"}], "stats": {"total": 275, "additions": 128, "deletions": 147}, "files": [{"sha": "78dcea60165dd3f35dee5e391e1b85f57bc05082", "filename": "gcc/ada/eval_fat.adb", "status": "modified", "additions": 128, "deletions": 147, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1937a0c4c8b918c6216a0bd7e8e9b44b210712d0/gcc%2Fada%2Feval_fat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1937a0c4c8b918c6216a0bd7e8e9b44b210712d0/gcc%2Fada%2Feval_fat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feval_fat.adb?ref=1937a0c4c8b918c6216a0bd7e8e9b44b210712d0", "patch": "@@ -32,13 +32,13 @@ with Targparm; use Targparm;\n package body Eval_Fat is\n \n    Radix : constant Int := 2;\n-   --  This code is currently only correct for the radix 2 case. We use\n-   --  the symbolic value Radix where possible to help in the unlikely\n-   --  case of anyone ever having to adjust this code for another value,\n-   --  and for documentation purposes.\n+   --  This code is currently only correct for the radix 2 case. We use the\n+   --  symbolic value Radix where possible to help in the unlikely case of\n+   --  anyone ever having to adjust this code for another value, and for\n+   --  documentation purposes.\n \n-   --  Another assumption is that the range of the floating-point type\n-   --  is symmetric around zero.\n+   --  Another assumption is that the range of the floating-point type is\n+   --  symmetric around zero.\n \n    type Radix_Power_Table is array (Int range 1 .. 4) of Int;\n \n@@ -55,10 +55,9 @@ package body Eval_Fat is\n       Fraction : out T;\n       Exponent : out UI;\n       Mode     : Rounding_Mode := Round);\n-   --  Decomposes a non-zero floating-point number into fraction and\n-   --  exponent parts. The fraction is in the interval 1.0 / Radix ..\n-   --  T'Pred (1.0) and uses Rbase = Radix.\n-   --  The result is rounded to a nearest machine number.\n+   --  Decomposes a non-zero floating-point number into fraction and exponent\n+   --  parts. The fraction is in the interval 1.0 / Radix .. T'Pred (1.0) and\n+   --  uses Rbase = Radix. The result is rounded to a nearest machine number.\n \n    procedure Decompose_Int\n      (RT       : R;\n@@ -116,12 +115,8 @@ package body Eval_Fat is\n       Arg_Exp  : UI;\n       pragma Warnings (Off, Arg_Exp);\n    begin\n-      if UR_Is_Zero (Fraction) then\n-         return Fraction;\n-      else\n-         Decompose (RT, Fraction, Arg_Frac, Arg_Exp);\n-         return Scaling (RT, Arg_Frac, Exponent);\n-      end if;\n+      Decompose (RT, Fraction, Arg_Frac, Arg_Exp);\n+      return Scaling (RT, Arg_Frac, Exponent);\n    end Compose;\n \n    ---------------\n@@ -175,10 +170,10 @@ package body Eval_Fat is\n    -- Decompose_Int --\n    -------------------\n \n-   --  This procedure should be modified with care, as there are many\n-   --  non-obvious details that may cause problems that are hard to\n-   --  detect. The cases of positive and negative zeroes are also\n-   --  special and should be verified separately.\n+   --  This procedure should be modified with care, as there are many non-\n+   --  obvious details that may cause problems that are hard to detect. For\n+   --  zero arguments, Fraction and Exponent are set to zero. Note that sign\n+   --  of zero cannot be preserved.\n \n    procedure Decompose_Int\n      (RT       : R;\n@@ -204,13 +199,19 @@ package body Eval_Fat is\n       --  intermediate values (this routine generates lots of junk!)\n \n    begin\n+      if N = Uint_0 then\n+         Fraction := Uint_0;\n+         Exponent := Uint_0;\n+         return;\n+      end if;\n+\n       Calculate_D_And_Exponent_1 : begin\n          Uintp_Mark := Mark;\n          Exponent := Uint_0;\n \n-         --  In cases where Base > 1, the actual denominator is\n-         --  Base**D. For cases where Base is a power of Radix, use\n-         --  the value 1 for the Denominator and adjust the exponent.\n+         --  In cases where Base > 1, the actual denominator is Base**D. For\n+         --  cases where Base is a power of Radix, use the value 1 for the\n+         --  Denominator and adjust the exponent.\n \n          --  Note: Exponent has different sign from D, because D is a divisor\n \n@@ -230,13 +231,13 @@ package body Eval_Fat is\n          Calculate_Exponent : begin\n             Uintp_Mark := Mark;\n \n-            --  For bases that are a multiple of the Radix, divide\n-            --  the base by Radix and adjust the Exponent. This will\n-            --  help because D will be much smaller and faster to process.\n+            --  For bases that are a multiple of the Radix, divide the base by\n+            --  Radix and adjust the Exponent. This will help because D will be\n+            --  much smaller and faster to process.\n \n-            --  This occurs for decimal bases on a machine with binary\n-            --  floating-point for example. When calculating 1E40,\n-            --  with Radix = 2, N will be 93 bits instead of 133.\n+            --  This occurs for decimal bases on machines with binary floating-\n+            --  point for example. When calculating 1E40, with Radix = 2, N\n+            --  will be 93 bits instead of 133.\n \n             --        N            E\n             --      ------  * Radix\n@@ -264,11 +265,10 @@ package body Eval_Fat is\n             Release_And_Save (Uintp_Mark, Exponent);\n          end Calculate_Exponent;\n \n-         --  For remaining bases we must actually compute\n-         --  the exponentiation.\n+         --  For remaining bases we must actually compute the exponentiation\n \n-         --  Because the exponentiation can be negative, and D must\n-         --  be integer, the numerator is corrected instead.\n+         --  Because the exponentiation can be negative, and D must be integer,\n+         --  the numerator is corrected instead.\n \n          Calculate_N_And_D : begin\n             Uintp_Mark := Mark;\n@@ -286,29 +286,25 @@ package body Eval_Fat is\n          Base := 0;\n       end if;\n \n-      --  Now scale N and D so that N / D is a value in the\n-      --  interval [1.0 / Radix, 1.0) and adjust Exponent accordingly,\n-      --  so the value N / D * Radix ** Exponent remains unchanged.\n+      --  Now scale N and D so that N / D is a value in the interval [1.0 /\n+      --  Radix, 1.0) and adjust Exponent accordingly, so the value N / D *\n+      --  Radix ** Exponent remains unchanged.\n \n       --  Step 1 - Adjust N so N / D >= 1 / Radix, or N = 0\n \n       --  N and D are positive, so N / D >= 1 / Radix implies N * Radix >= D.\n-      --  This scaling is not possible for N is Uint_0 as there\n-      --  is no way to scale Uint_0 so the first digit is non-zero.\n+      --  As this scaling is not possible for N is Uint_0, zero is handled\n+      --  explicitly at the start of this subprogram.\n \n       Calculate_N_And_Exponent : begin\n          Uintp_Mark := Mark;\n \n          N_Times_Radix := N * Radix;\n-\n-         if N /= Uint_0 then\n-            while not (N_Times_Radix >= D) loop\n-               N := N_Times_Radix;\n-               Exponent := Exponent - 1;\n-\n-               N_Times_Radix := N * Radix;\n-            end loop;\n-         end if;\n+         while not (N_Times_Radix >= D) loop\n+            N := N_Times_Radix;\n+            Exponent := Exponent - 1;\n+            N_Times_Radix := N * Radix;\n+         end loop;\n \n          Release_And_Save (Uintp_Mark, N, Exponent);\n       end Calculate_N_And_Exponent;\n@@ -322,8 +318,8 @@ package body Eval_Fat is\n \n          while not (N < D) loop\n \n-            --  As N / D >= 1, N / (D * Radix) will be at least 1 / Radix,\n-            --  so the result of Step 1 stays valid\n+            --  As N / D >= 1, N / (D * Radix) will be at least 1 / Radix, so\n+            --  the result of Step 1 stays valid\n \n             D := D * Radix;\n             Exponent := Exponent + 1;\n@@ -334,14 +330,14 @@ package body Eval_Fat is\n \n       --  Here the value N / D is in the range [1.0 / Radix .. 1.0)\n \n-      --  Now find the fraction by doing a very simple-minded\n-      --  division until enough digits have been computed.\n+      --  Now find the fraction by doing a very simple-minded division until\n+      --  enough digits have been computed.\n \n-      --  This division works for all radices, but is only efficient for\n-      --  a binary radix. It is just like a manual division algorithm,\n-      --  but instead of moving the denominator one digit right, we move\n-      --  the numerator one digit left so the numerator and denominator\n-      --  remain integral.\n+      --  This division works for all radices, but is only efficient for a\n+      --  binary radix. It is just like a manual division algorithm, but\n+      --  instead of moving the denominator one digit right, we move the\n+      --  numerator one digit left so the numerator and denominator remain\n+      --  integral.\n \n       Fraction := Uint_0;\n       Even := True;\n@@ -380,8 +376,8 @@ package body Eval_Fat is\n             when Round_Even =>\n \n                --  This rounding mode should not be used for static\n-               --  expressions, but only for compile-time evaluation\n-               --  of non-static expressions.\n+               --  expressions, but only for compile-time evaluation of\n+               --  non-static expressions.\n \n                if (Even and then N * 2 > D)\n                      or else\n@@ -392,9 +388,9 @@ package body Eval_Fat is\n \n             when Round   =>\n \n-               --  Do not round to even as is done with IEEE arithmetic,\n-               --  but instead round away from zero when the result is\n-               --  exactly between two machine numbers. See RM 4.9(38).\n+               --  Do not round to even as is done with IEEE arithmetic, but\n+               --  instead round away from zero when the result is exactly\n+               --  between two machine numbers. See RM 4.9(38).\n \n                if N * 2 >= D then\n                   Fraction := Fraction + 1;\n@@ -411,8 +407,8 @@ package body Eval_Fat is\n                end if;\n          end case;\n \n-         --  The result must be normalized to [1.0/Radix, 1.0),\n-         --  so adjust if the result is 1.0 because of rounding.\n+         --  The result must be normalized to [1.0/Radix, 1.0), so adjust if\n+         --  the result is 1.0 because of rounding.\n \n          if Fraction = Most_Significant_Digit * Radix then\n             Fraction := Most_Significant_Digit;\n@@ -438,12 +434,8 @@ package body Eval_Fat is\n       X_Exp  : UI;\n       pragma Warnings (Off, X_Frac);\n    begin\n-      if UR_Is_Zero (X) then\n-         return Uint_0;\n-      else\n-         Decompose_Int (RT, X, X_Frac, X_Exp, Round_Even);\n-         return X_Exp;\n-      end if;\n+      Decompose_Int (RT, X, X_Frac, X_Exp, Round_Even);\n+      return X_Exp;\n    end Exponent;\n \n    -----------\n@@ -474,12 +466,8 @@ package body Eval_Fat is\n       X_Exp  : UI;\n       pragma Warnings (Off, X_Exp);\n    begin\n-      if UR_Is_Zero (X) then\n-         return X;\n-      else\n-         Decompose (RT, X, X_Frac, X_Exp);\n-         return X_Frac;\n-      end if;\n+      Decompose (RT, X, X_Frac, X_Exp);\n+      return X_Frac;\n    end Fraction;\n \n    ------------------\n@@ -511,81 +499,74 @@ package body Eval_Fat is\n       Emin   : constant UI := UI_From_Int (Machine_Emin (RT));\n \n    begin\n-      if UR_Is_Zero (X) then\n-         return X;\n+      Decompose (RT, X, X_Frac, X_Exp, Mode);\n+\n+      --  Case of denormalized number or (gradual) underflow\n+\n+      --  A denormalized number is one with the minimum exponent Emin, but that\n+      --  breaks the assumption that the first digit of the mantissa is a one.\n+      --  This allows the first non-zero digit to be in any of the remaining\n+      --  Mant - 1 spots. The gap between subsequent denormalized numbers is\n+      --  the same as for the smallest normalized numbers. However, the number\n+      --  of significant digits left decreases as a result of the mantissa now\n+      --  having leading seros.\n+\n+      if X_Exp < Emin then\n+         declare\n+            Emin_Den : constant UI :=\n+                         UI_From_Int\n+                           (Machine_Emin (RT) - Machine_Mantissa (RT) + 1);\n+         begin\n+            if X_Exp < Emin_Den or not Denorm_On_Target then\n+               if UR_Is_Negative (X) then\n+                  Error_Msg_N\n+                    (\"floating-point value underflows to -0.0?\", Enode);\n+                  return Ureal_M_0;\n+\n+               else\n+                  Error_Msg_N\n+                    (\"floating-point value underflows to 0.0?\", Enode);\n+                  return Ureal_0;\n+               end if;\n \n-      else\n-         Decompose (RT, X, X_Frac, X_Exp, Mode);\n-\n-         --  Case of denormalized number or (gradual) underflow\n-\n-         --  A denormalized number is one with the minimum exponent Emin, but\n-         --  that breaks the assumption that the first digit of the mantissa\n-         --  is a one. This allows the first non-zero digit to be in any\n-         --  of the remaining Mant - 1 spots. The gap between subsequent\n-         --  denormalized numbers is the same as for the smallest normalized\n-         --  numbers. However, the number of significant digits left decreases\n-         --  as a result of the mantissa now having leading seros.\n-\n-         if X_Exp < Emin then\n-            declare\n-               Emin_Den : constant UI :=\n-                            UI_From_Int\n-                              (Machine_Emin (RT) - Machine_Mantissa (RT) + 1);\n-            begin\n-               if X_Exp < Emin_Den or not Denorm_On_Target then\n-                  if UR_Is_Negative (X) then\n-                     Error_Msg_N\n-                       (\"floating-point value underflows to -0.0?\", Enode);\n-                     return Ureal_M_0;\n+            elsif Denorm_On_Target then\n \n-                  else\n-                     Error_Msg_N\n-                       (\"floating-point value underflows to 0.0?\", Enode);\n-                     return Ureal_0;\n-                  end if;\n+               --  Emin - Mant <= X_Exp < Emin, so result is denormal. Handle\n+               --  gradual underflow by first computing the number of\n+               --  significant bits still available for the mantissa and\n+               --  then truncating the fraction to this number of bits.\n \n-               elsif Denorm_On_Target then\n-\n-                  --  Emin - Mant <= X_Exp < Emin, so result is denormal.\n-                  --  Handle gradual underflow by first computing the\n-                  --  number of significant bits still available for the\n-                  --  mantissa and then truncating the fraction to this\n-                  --  number of bits.\n-\n-                  --  If this value is different from the original\n-                  --  fraction, precision is lost due to gradual underflow.\n-\n-                  --  We probably should round here and prevent double\n-                  --  rounding as a result of first rounding to a model\n-                  --  number and then to a machine number. However, this\n-                  --  is an extremely rare case that is not worth the extra\n-                  --  complexity. In any case, a warning is issued in cases\n-                  --  where gradual underflow occurs.\n-\n-                  declare\n-                     Denorm_Sig_Bits : constant UI := X_Exp - Emin_Den + 1;\n-\n-                     X_Frac_Denorm   : constant T := UR_From_Components\n-                       (UR_Trunc (Scaling (RT, abs X_Frac, Denorm_Sig_Bits)),\n-                        Denorm_Sig_Bits,\n-                        Radix,\n-                        UR_Is_Negative (X));\n-\n-                  begin\n-                     if X_Frac_Denorm /= X_Frac then\n-                        Error_Msg_N\n-                          (\"gradual underflow causes loss of precision?\",\n-                           Enode);\n-                        X_Frac := X_Frac_Denorm;\n-                     end if;\n-                  end;\n-               end if;\n-            end;\n-         end if;\n+               --  If this value is different from the original fraction,\n+               --  precision is lost due to gradual underflow.\n+\n+               --  We probably should round here and prevent double rounding as\n+               --  a result of first rounding to a model number and then to a\n+               --  machine number. However, this is an extremely rare case that\n+               --  is not worth the extra complexity. In any case, a warning is\n+               --  issued in cases where gradual underflow occurs.\n+\n+               declare\n+                  Denorm_Sig_Bits : constant UI := X_Exp - Emin_Den + 1;\n+\n+                  X_Frac_Denorm   : constant T := UR_From_Components\n+                    (UR_Trunc (Scaling (RT, abs X_Frac, Denorm_Sig_Bits)),\n+                     Denorm_Sig_Bits,\n+                     Radix,\n+                     UR_Is_Negative (X));\n \n-         return Scaling (RT, X_Frac, X_Exp);\n+               begin\n+                  if X_Frac_Denorm /= X_Frac then\n+                     Error_Msg_N\n+                       (\"gradual underflow causes loss of precision?\",\n+                        Enode);\n+                     X_Frac := X_Frac_Denorm;\n+                  end if;\n+               end;\n+            end if;\n+         end;\n       end if;\n+\n+      return Scaling (RT, X_Frac, X_Exp);\n    end Machine;\n \n    ------------------\n@@ -848,8 +829,8 @@ package body Eval_Fat is\n          Exp := Emin;\n       end if;\n \n-      --  Set exponent such that the radix point will be directly\n-      --  following the mantissa after scaling\n+      --  Set exponent such that the radix point will be directly following the\n+      --  mantissa after scaling.\n \n       if Denorm_On_Target or Exp /= Emin then\n          Exp := Exp - Mantissa;"}]}