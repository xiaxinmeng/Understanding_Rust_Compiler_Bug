{"sha": "22a982409323feb203401d345488a5a9c18e6733", "node_id": "C_kwDOANBUbNoAKDIyYTk4MjQwOTMyM2ZlYjIwMzQwMWQzNDU0ODhhNWE5YzE4ZTY3MzM", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-11-13T12:39:09Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-12-02T19:44:44Z"}, "message": "Darwin: Rewrite host PCH support [PR 55610].\n\nWe need to revise the PCH memory allocation scheme to enable\nsupport for PIE on aarch64.  The rewrite uses a similar scheme\nto the one used on Linux.\n\nWe attempt to identify VM segments for each arch/OS version that\nare always available to the compiler (note this is not general,\nit only needs to work for the cc1* exes).\n\nIf we cannot find the preferred segment we fall back to allowing\nthe kernel to supply one - this is more likely to fail when the\nPCH read-in occurs (but that is trapped).\n\nIn doing this we obviate the need to unmap any part of the\ncompiler __DATA segment - thus fixing PR 55610.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\ngcc/ChangeLog:\n\n\tPR target/55610\n\t* config/host-darwin.c (TRY_EMPTY_VM_SPACE,\n\tSAFE_ALLOC_SIZE): New.\n\t(darwin_gt_pch_get_address): Rewrite to use nominated\n\tmemory segments rather than part of the compiler __DATA\n\tsegment.\n\t(darwin_gt_pch_use_address): Likewise.", "tree": {"sha": "d1b59ebd2620f197c94fa2a5d00817dc007700f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1b59ebd2620f197c94fa2a5d00817dc007700f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22a982409323feb203401d345488a5a9c18e6733", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a982409323feb203401d345488a5a9c18e6733", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22a982409323feb203401d345488a5a9c18e6733", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22a982409323feb203401d345488a5a9c18e6733/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2835977f8460ea59e7d3c877453fa358b31f9a7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2835977f8460ea59e7d3c877453fa358b31f9a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2835977f8460ea59e7d3c877453fa358b31f9a7f"}], "stats": {"total": 191, "additions": 153, "deletions": 38}, "files": [{"sha": "559b919f2ee0dca81da0c1a05aea91a0120be161", "filename": "gcc/config/host-darwin.c", "status": "modified", "additions": 153, "deletions": 38, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22a982409323feb203401d345488a5a9c18e6733/gcc%2Fconfig%2Fhost-darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22a982409323feb203401d345488a5a9c18e6733/gcc%2Fconfig%2Fhost-darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-darwin.c?ref=22a982409323feb203401d345488a5a9c18e6733", "patch": "@@ -20,62 +20,177 @@\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"options.h\"\n #include \"diagnostic-core.h\"\n #include \"config/host-darwin.h\"\n-\n-/* Yes, this is really supposed to work.  */\n-/* This allows for a pagesize of 16384, which we have on Darwin20, but should\n-   continue to work OK for pagesize 4096 which we have on earlier versions.\n-   The size is 1 (binary) Gb.  */\n-static char pch_address_space[65536*16384] __attribute__((aligned (16384)));\n-\n-/* Return the address of the PCH address space, if the PCH will fit in it.  */\n+#include <errno.h>\n+\n+/* For Darwin (macOS only) platforms, without ASLR (PIE) enabled on the\n+   binaries, the following VM addresses are expected to be available.\n+   NOTE, that for aarch64, ASLR is always enabled - but the VM address\n+   mentioned below is available (at least on Darwin20).\n+\n+   The spaces should all have 512Mb available c.f. PCH files for large\n+   C++ or Objective-C in the range of 150Mb for 64b hosts.\n+\n+   We also try to steer clear of places already used for sanitizers.  */\n+\n+#define PAGE_SZ 4096\n+#if defined(__x86_64) && defined(__LP64__)\n+# define TRY_EMPTY_VM_SPACE\t0x180000000000ULL\n+# define SAFE_ALLOC_SIZE\t0x20000000\n+#elif defined(__x86_64)\n+# define TRY_EMPTY_VM_SPACE\t0x00006fe00000ULL\n+# define SAFE_ALLOC_SIZE\t0x20000000\n+#elif defined(__i386)\n+# define TRY_EMPTY_VM_SPACE\t0x00006fe00000ULL\n+# define SAFE_ALLOC_SIZE\t0x20000000\n+#elif defined(__POWERPC__) && defined(__LP64__)\n+# define TRY_EMPTY_VM_SPACE\t0x180000000000ULL\n+# define SAFE_ALLOC_SIZE\t0x20000000\n+#elif defined(__POWERPC__)\n+# define TRY_EMPTY_VM_SPACE\t0x00006fe00000ULL\n+# define SAFE_ALLOC_SIZE\t0x20000000\n+#elif defined(__aarch64__)\n+# undef PAGE_SZ\n+# define PAGE_SZ 16384\n+# define TRY_EMPTY_VM_SPACE\t0x180000000000ULL\n+# define SAFE_ALLOC_SIZE\t0x20000000\n+#else\n+# error \"unknown Darwin target\"\n+#endif\n+\n+/* Try to map a known position in the VM.  The current PCH implementation\n+   can adjust values at write-time, but not at read-time thus we need to\n+   pick up the same position when reading as we got at write-time.  */\n \n void *\n-darwin_gt_pch_get_address (size_t sz, int fd ATTRIBUTE_UNUSED)\n+darwin_gt_pch_get_address (size_t sz, int fd)\n {\n-  if (sz <= sizeof (pch_address_space))\n-    return pch_address_space;\n-  else\n-    return NULL;\n+  if (sz > SAFE_ALLOC_SIZE)\n+    {\n+      error (\"PCH memory request exceeds the available space\");\n+      return NULL;\n+    }\n+\n+  /* Now try with the constraint that we really want this address...  */\n+  void *addr = mmap ((void *)TRY_EMPTY_VM_SPACE, sz, PROT_READ | PROT_WRITE,\n+\t\t     MAP_PRIVATE | MAP_FIXED, fd, 0);\n+\n+  if (addr != (void *) MAP_FAILED)\n+    munmap (addr, sz);\n+\n+  /* This ought to be the only alternative to failure, but there are comments\n+     that suggest some versions of mmap can be buggy and return a different\n+     value.  */\n+  if (addr == (void *) TRY_EMPTY_VM_SPACE)\n+    return addr;\n+\n+  warning (OPT_Winvalid_pch, \"PCH memory [fixed at %p] is not available %m\",\n+\t   (void *) TRY_EMPTY_VM_SPACE);\n+\n+  /* OK try to find a space without the constraint.  */\n+  addr = mmap ((void *) TRY_EMPTY_VM_SPACE, sz, PROT_READ | PROT_WRITE,\n+\t       MAP_PRIVATE, fd, 0);\n+\n+  /* If we failed this time, that means there is *no* large enough free\n+     space.  */\n+  if (addr == (void *) MAP_FAILED)\n+    {\n+      error (\"no memory is available for PCH : %m\");\n+      return NULL;\n+    }\n+\n+  /* Unmap the area before returning.  */\n+  munmap (addr, sz);\n+\n+  /* If we got the exact area we requested, then that's great.  */\n+  if (TRY_EMPTY_VM_SPACE && addr == (void *) TRY_EMPTY_VM_SPACE)\n+    return addr;\n+\n+  warning (OPT_Winvalid_pch, \"PCH memory at %p is not available\",\n+\t  (void *) TRY_EMPTY_VM_SPACE);\n+\n+  /* Otherwise, we need to try again but put some buffer space first.  */\n+  size_t buffer_size = 32 * 1024 * 1024;\n+  void *buffer = mmap (0, buffer_size, PROT_NONE,\n+\t\t       MAP_PRIVATE | MAP_ANON, -1, 0);\n+  addr = mmap ((void *)TRY_EMPTY_VM_SPACE, sz, PROT_READ | PROT_WRITE,\n+\t\tMAP_PRIVATE, fd, 0);\n+  if (buffer != (void *) MAP_FAILED)\n+    munmap (buffer, buffer_size);\n+\n+  if (addr == (void *) MAP_FAILED)\n+    {\n+      error (\"PCH memory not available %m\");\n+      return NULL;\n+    }\n+\n+  warning (OPT_Winvalid_pch, \"PCH memory at %p used instead\", addr);\n+  munmap (addr, sz);\n+  return addr;\n }\n \n-/* Check ADDR and SZ for validity, and deallocate (using munmap) that part of\n-   pch_address_space beyond SZ.  */\n+/* Try to mmap the PCH file at ADDR for SZ bytes at OFF offset in the file.\n+   If we succeed return 1, if we cannot mmap the desired address, then we\n+   fail with -1.  */\n \n int\n darwin_gt_pch_use_address (void *addr, size_t sz, int fd, size_t off)\n {\n-  const size_t pagesize = getpagesize();\n-  void *mmap_result;\n-  int ret;\n+  void *mapped_addr;\n+\n+  /* We're called with size == 0 if we're not planning to load a PCH\n+     file at all.  This allows the hook to free any static space that\n+     we might have allocated at link time.  */\n+  if (sz == 0)\n+    return -1;\n \n-  gcc_assert ((size_t)pch_address_space % pagesize == 0\n-\t      && sizeof (pch_address_space) % pagesize == 0);\n-  \n-  ret = (addr == pch_address_space && sz <= sizeof (pch_address_space));\n-  if (! ret)\n-    sz = 0;\n+  gcc_checking_assert (!(off % PAGE_SZ));\n+  if (addr != (void *) TRY_EMPTY_VM_SPACE)\n+    warning (OPT_Winvalid_pch, \"PCH at %p does not use the default position\",\n+\t     addr);\n \n-  /* Round the size to a whole page size.  Normally this is a no-op.  */\n-  sz = (sz + pagesize - 1) / pagesize * pagesize;\n+  /* Try to map the file with MAP_PRIVATE and FIXED.  */\n+  mapped_addr = mmap (addr, sz, PROT_READ | PROT_WRITE,\n+\t\t      MAP_PRIVATE | MAP_FIXED, fd, (off_t) off);\n \n-  if (munmap (pch_address_space + sz, sizeof (pch_address_space) - sz) != 0)\n-    fatal_error (input_location,\n-\t\t \"could not unmap %<pch_address_space%>: %m\");\n+  /* Hopefully, we succeed.  */\n+  if (mapped_addr == addr)\n+    return 1;\n \n-  if (ret)\n+  warning (OPT_Winvalid_pch, \"PCH private mmap of written position (%p)\"\n+\t   \" failed [errno %d] %m\", addr, errno);\n+\n+  if (mapped_addr != (void *) MAP_FAILED)\n+    munmap (mapped_addr, sz);\n+\n+  /* Try to make an anonymous private mmap at the desired location.  */\n+  mapped_addr = mmap (addr, sz, PROT_READ | PROT_WRITE,\n+\t\t      MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, (off_t)0);\n+\n+  if (mapped_addr != addr)\n     {\n-      mmap_result = mmap (addr, sz,\n-\t\t\t  PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED,\n-\t\t\t  fd, off);\n+      warning (OPT_Winvalid_pch, \"PCH anon mmap at written position (%p)\"\n+\t       \" failed [errno %d] %m\", addr, errno);\n+      if (mapped_addr != (void *) MAP_FAILED)\n+\t    munmap (mapped_addr, sz);\n+      return -1;\n+    }\n+\n+  if (lseek (fd, off, SEEK_SET) == (off_t) -1)\n+    return -1;\n \n-      /* The file might not be mmap-able.  */\n-      ret = mmap_result != (void *) MAP_FAILED;\n+  while (sz)\n+    {\n+      ssize_t nbytes;\n \n-      /* Sanity check for broken MAP_FIXED.  */\n-      gcc_assert (!ret || mmap_result == addr);\n+      nbytes = read (fd, addr, MIN (sz, (size_t) -1 >> 1));\n+      if (nbytes <= 0)\n+\treturn -1;\n+      addr = (char *) addr + nbytes;\n+      sz -= nbytes;\n     }\n \n-  return ret;\n+  return 1;\n }"}]}