{"sha": "a19f98d5defb7a173725e89b1fed532c66561f61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE5Zjk4ZDVkZWZiN2ExNzM3MjVlODliMWZlZDUzMmM2NjU2MWY2MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-08-01T15:46:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-08-01T15:46:12Z"}, "message": "Fold pointer range checks with equal spans\n\nWhen checking whether vectorised accesses at A and B are independent,\nthe vectoriser falls back to tests of the form:\n\n    A + size <= B || B + size <= A\n\nBut in the common case that \"size\" is just the constant size of a vector\n(or a small multiple), it would be more efficient to do:\n\n   (size_t) (A + (size - 1) - B) > (size - 1) * 2\n\nThis patch adds folds to do that.  E.g. before the patch, the alias\nchecks for:\n\n  for (int j = 0; j < n; ++j)\n    {\n      for (int i = 0; i < 16; ++i)\n\ta[i] = (b[i] + c[i]) >> 1;\n      a += step;\n      b += step;\n      c += step;\n    }\n\nwere:\n\n\tadd     x7, x1, 15\n\tadd     x5, x0, 15\n\tcmp     x0, x7\n\tadd     x7, x2, 15\n\tccmp    x1, x5, 2, ls\n\tcset    w8, hi\n\tcmp     x0, x7\n\tccmp    x2, x5, 2, ls\n\tcset    w4, hi\n\ttst     w8, w4\n\nwhile after the patch they're:\n\n\tadd     x0, x0, 15\n\tsub     x6, x0, x1\n\tsub     x5, x0, x2\n\tcmp     x6, 30\n\tccmp    x5, 30, 0, hi\n\nThe old scheme needs:\n\n[A] one addition per vector pointer\n[B] two comparisons and one IOR per range check\n\nThe new one needs:\n\n[C] less than one addition per vector pointer\n[C] one subtraction and one comparison per range check\n\nThe range checks are then ANDed together, with the same number of\nANDs either way.\n\nWith conditional comparisons (such as on AArch64), we're able to remove\nthe IOR between comparisons in the old scheme, but then need an explicit\nAND or branch when combining the range checks, as the example above shows.\nWith the new scheme we can instead use conditional comparisons for\nthe AND chain.\n\nSo even with conditional comparisons, the new scheme should in practice\nbe a win in almost all cases.  Without conditional comparisons, the new\nscheme removes at least one operation from [A] and one operation per\nrange check from [B], so should always give fewer operations overall.\n\n2018-07-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* match.pd: Optimise pointer range checks.\n\ngcc/testsuite/\n\t* gcc.dg/pointer-range-check-1.c: New test.\n\t* gcc.dg/pointer-range-check-2.c: Likewise.\n\nFrom-SVN: r263226", "tree": {"sha": "552180999f2a5f51634c87b6aef66ee849c8a661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/552180999f2a5f51634c87b6aef66ee849c8a661"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a19f98d5defb7a173725e89b1fed532c66561f61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a19f98d5defb7a173725e89b1fed532c66561f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a19f98d5defb7a173725e89b1fed532c66561f61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a19f98d5defb7a173725e89b1fed532c66561f61/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e68aa3cc52956ea99bb726c3c29ce0581b9f7e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e68aa3cc52956ea99bb726c3c29ce0581b9f7e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e68aa3cc52956ea99bb726c3c29ce0581b9f7e7"}], "stats": {"total": 137, "additions": 137, "deletions": 0}, "files": [{"sha": "2e4ed90d447fa18768b571575bba78966acd07ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a19f98d5defb7a173725e89b1fed532c66561f61", "patch": "@@ -1,3 +1,7 @@\n+2018-08-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* match.pd: Optimise pointer range checks.\n+\n 2018-08-01  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/86758"}, {"sha": "cb3c93e3e162b262e218dee1d09858095efba371", "filename": "gcc/match.pd", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=a19f98d5defb7a173725e89b1fed532c66561f61", "patch": "@@ -4937,3 +4937,63 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (if (inverse_conditions_p (@0, @2)\n         && element_precision (type) == element_precision (op_type))\n     (view_convert (cond_op @2 @3 @4 @5 (view_convert:op_type @1)))))))\n+\n+/* For pointers @0 and @2 and nonnegative constant offset @1, look for\n+   expressions like:\n+\n+   A: (@0 + @1 < @2) | (@2 + @1 < @0)\n+   B: (@0 + @1 <= @2) | (@2 + @1 <= @0)\n+\n+   If pointers are known not to wrap, B checks whether @1 bytes starting\n+   at @0 and @2 do not overlap, while A tests the same thing for @1 + 1\n+   bytes.  A is more efficiently tested as:\n+\n+   A: (sizetype) (@0 + @1 - @2) > @1 * 2\n+\n+   The equivalent expression for B is given by replacing @1 with @1 - 1:\n+\n+   B: (sizetype) (@0 + (@1 - 1) - @2) > (@1 - 1) * 2\n+\n+   @0 and @2 can be swapped in both expressions without changing the result.\n+\n+   The folds rely on sizetype's being unsigned (which is always true)\n+   and on its being the same width as the pointer (which we have to check).\n+\n+   The fold replaces two pointer_plus expressions, two comparisons and\n+   an IOR with a pointer_plus, a pointer_diff, and a comparison, so in\n+   the best case it's a saving of two operations.  The A fold retains one\n+   of the original pointer_pluses, so is a win even if both pointer_pluses\n+   are used elsewhere.  The B fold is a wash if both pointer_pluses are\n+   used elsewhere, since all we end up doing is replacing a comparison with\n+   a pointer_plus.  We do still apply the fold under those circumstances\n+   though, in case applying it to other conditions eventually makes one of the\n+   pointer_pluses dead.  */\n+(for ior (truth_orif truth_or bit_ior)\n+ (for cmp (le lt)\n+  (simplify\n+   (ior (cmp:cs (pointer_plus@3 @0 INTEGER_CST@1) @2)\n+\t(cmp:cs (pointer_plus@4 @2 @1) @0))\n+   (if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (@0))\n+\t&& TYPE_OVERFLOW_WRAPS (sizetype)\n+\t&& TYPE_PRECISION (TREE_TYPE (@0)) == TYPE_PRECISION (sizetype))\n+    /* Calculate the rhs constant.  */\n+    (with { offset_int off = wi::to_offset (@1) - (cmp == LE_EXPR ? 1 : 0);\n+\t    offset_int rhs = off * 2; }\n+     /* Always fails for negative values.  */\n+     (if (wi::min_precision (rhs, UNSIGNED) <= TYPE_PRECISION (sizetype))\n+      /* Since the order of @0 and @2 doesn't matter, let tree_swap_operands_p\n+\t pick a canonical order.  This increases the chances of using the\n+\t same pointer_plus in multiple checks.  */\n+      (with { bool swap_p = tree_swap_operands_p (@0, @2);\n+\t      tree rhs_tree = wide_int_to_tree (sizetype, rhs); }\n+       (if (cmp == LT_EXPR)\n+\t(gt (convert:sizetype\n+\t     (pointer_diff:ssizetype { swap_p ? @4 : @3; }\n+\t\t\t\t     { swap_p ? @0 : @2; }))\n+\t    { rhs_tree; })\n+\t(gt (convert:sizetype\n+\t     (pointer_diff:ssizetype\n+\t      (pointer_plus { swap_p ? @2 : @0; }\n+\t\t\t    { wide_int_to_tree (sizetype, off); })\n+\t      { swap_p ? @0 : @2; }))\n+\t    { rhs_tree; })))))))))"}, {"sha": "96565bb2d448ee78d3cfc3029b337e42f97d8302", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a19f98d5defb7a173725e89b1fed532c66561f61", "patch": "@@ -1,3 +1,8 @@\n+2018-08-01  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/pointer-range-check-1.c: New test.\n+\t* gcc.dg/pointer-range-check-2.c: Likewise.\n+\n 2018-08-01  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR tree-optimization/86749"}, {"sha": "986865888846af96e0b1362ac16bd8d5bc53b16c", "filename": "gcc/testsuite/gcc.dg/pointer-range-check-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-range-check-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-range-check-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-range-check-1.c?ref=a19f98d5defb7a173725e89b1fed532c66561f61", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target { ilp32 || lp64 } } } */\n+/* { dg-options \"-O2 -fno-ipa-icf -fdump-tree-optimized\" } */\n+\n+/* All four functions should be folded to:\n+\n+   (sizetype) (a + 15 - b) < 30.  */\n+\n+_Bool\n+f1 (char *a, char *b)\n+{\n+  return (a + 16 <= b) || (b + 16 <= a);\n+}\n+\n+_Bool\n+f2 (char *a, char *b)\n+{\n+  return (a + 15 < b) || (b + 15 < a);\n+}\n+\n+_Bool\n+f3 (char *a, char *b)\n+{\n+  return (a + 16 <= b) | (b + 16 <= a);\n+}\n+\n+_Bool\n+f4 (char *a, char *b)\n+{\n+  return (a + 15 < b) | (b + 15 < a);\n+}\n+\n+/* { dg-final { scan-tree-dump-times { = [^\\n]* - [^\\n]*;} 4 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times { = [^\\n]* \\+ [^\\n]*;} 4 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times { = [^\\n]*\\ > [^\\n]*;} 4 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not {=[^\\n]*\\ < [^\\n]*;} \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times { \\+ 15} 4 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times { > 30} 4 \"optimized\" } } */"}, {"sha": "4ccc413f23a2b5b81fa84884dae0f5714782bb9a", "filename": "gcc/testsuite/gcc.dg/pointer-range-check-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-range-check-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a19f98d5defb7a173725e89b1fed532c66561f61/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-range-check-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-range-check-2.c?ref=a19f98d5defb7a173725e89b1fed532c66561f61", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-ipa-icf -fwrapv-pointer -fdump-tree-optimized\" } */\n+\n+_Bool\n+f1 (char *a, char *b)\n+{\n+  return (a + 16 <= b) || (b + 16 <= a);\n+}\n+\n+_Bool\n+f2 (char *a, char *b)\n+{\n+  return (a + 15 < b) || (b + 15 < a);\n+}\n+\n+_Bool\n+f3 (char *a, char *b)\n+{\n+  return (a + 16 <= b) | (b + 16 <= a);\n+}\n+\n+_Bool\n+f4 (char *a, char *b)\n+{\n+  return (a + 15 < b) | (b + 15 < a);\n+}\n+\n+/* { dg-final { scan-tree-dump-not { = [^\\n]* - [^\\n]*;} \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times { = [^\\n]* \\+ [^\\n]*;} 8 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times { \\+ 15} 4 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times { \\+ 16} 4 \"optimized\" } } */"}]}