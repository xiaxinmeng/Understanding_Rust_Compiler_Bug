{"sha": "ddb555ed5129279c1bbe74574507ad67fff22e5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRiNTU1ZWQ1MTI5Mjc5YzFiYmU3NDU3NDUwN2FkNjdmZmYyMmU1ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-06-22T10:41:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-06-22T10:41:58Z"}, "message": "re PR debug/47858 (IPA-SRA decreases quality of debug info)\n\n\tPR debug/47858\n\t* gimple.h (enum gimple_debug_subcode): Add GIMPLE_DEBUG_SOURCE_BIND.\n\t(gimple_build_debug_source_bind_stat): New prototype.\n\t(gimple_build_debug_source_bind): Define.\n\t(gimple_debug_source_bind_p, gimple_debug_source_bind_get_var,\n\tgimple_debug_source_bind_get_value,\n\tgimple_debug_source_bind_get_value_ptr,\n\tgimple_debug_source_bind_set_var,\n\tgimple_debug_source_bind_set_value): New inlines.\n\t* gimple.c (gimple_build_debug_source_bind_stat): New function.\n\t* gimple-pretty-print.c (dump_gimple_debug): Handle\n\tGIMPLE_DEBUG_SOURCE_BIND.\n\t* sese.c (rename_uses): Handle gimple_debug_source_bind_p.\n\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n\t* tree-parloops.c (eliminate_local_variables,\n\tseparate_decls_in_region): Likewise.\n\t(separate_decls_in_region_debug): Renamed from\n\tseparate_decls_in_region_debug_bind.  Handle\n\tgimple_debug_source_bind_p.\n\t* tree.h (decl_debug_args_lookup, decl_debug_args_insert): New\n\tprototypes.\n\t(DECL_HAS_DEBUG_ARGS_P): Define.\n\t(struct tree_function_decl): Add has_debug_args_flag field.\n\t* tree.c (debug_args_for_decl): New variable.\n\t(decl_debug_args_lookup, decl_debug_args_insert): New functions.\n\t* tree-into-ssa.c (mark_def_sites): Handle uses in debug stmts.\n\t(rewrite_debug_stmt_uses): New function.\n\t(rewrite_stmt): Use it to rewrite debug stmt uses.\n\t* rtl.def (DEBUG_PARAMETER_REF): New.\n\t* rtl.h (DEBUG_PARAMETER_REF_DECL): Define.\n\t* cselib.c (rtx_equal_for_cselib_1, cselib_hash_rtx): Handle\n\tDEBUG_PARAMETER_REF.\n\t* rtl.c (rtx_equal_p_cb, rtx_equal_p, iterative_hash_rtx): Likewise.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* tree-sra.c (sra_ipa_reset_debug_stmts): Prefer replacing of\n\tSSA_NAMEs with DEBUG_EXPR_DECLs initialized in source bind\n\tdebug stmts in the first bb.\n\t* tree-inline.c (remap_ssa_name): If remapping default def\n\tof a PARM_DECL fails, map to a DEBUG_EXPR_DECL set in\n\ta source bind debug stmt.\n\t(remap_gimple_stmt): Handle gimple_debug_source_bind_p.\n\t(maybe_move_debug_stmts_to_successors): Likewise.\n\t(copy_debug_stmt): Likewise.  Avoid shadowing a variable.\n\t(tree_function_versioning): If DECL_HAS_DEBUG_ARGS_P, copy\n\tdebug args vector from old_decl to new_decl.\n\t* ipa-prop.c (ipa_modify_call_arguments): For optimized away\n\tor modified parameters, add debug bind stmts before call\n\tsetting DEBUG_EXPR_DECL which is remembered in debug args\n\tvector.\n\t* cfgexpand.c (expand_call_stmt): Call expand_debug_expr\n\ton DECL_DEBUG_EXPRs from debug args vector.\n\t(expand_debug_source_expr): New function.\n\t(expand_debug_locations): Use it for source bind insns.\n\t(expand_gimple_basic_block): Handle gimple_debug_source_bind_p.\n\t* var-tracking.c (prepare_call_arguments): Add debug args\n\tto call_arguments if any.\n\t* dwarf2out.c (dwarf_stack_op_name, size_of_loc_descr,\n\toutput_loc_operands, output_loc_operands_raw,\n\tresolve_addr_in_expr, compare_loc_operands): Handle\n\tDW_OP_GNU_parameter_ref.\n\t(get_ref_die_offset, parameter_ref_descriptor): New functions.\n\t(mem_loc_descriptor): Handle DEBUG_PARAMETER_REF.\n\t(gen_subprogram_die): Handle parameters identified by\n\tDEBUG_PARAMETER_REF.\n\n\t* dwarf2.h (enum dwarf_location_atom): Add DW_OP_GNU_parameter_ref.\n\nFrom-SVN: r175288", "tree": {"sha": "084c46b58471b676de4f37c5db720c691779a0e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/084c46b58471b676de4f37c5db720c691779a0e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddb555ed5129279c1bbe74574507ad67fff22e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb555ed5129279c1bbe74574507ad67fff22e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddb555ed5129279c1bbe74574507ad67fff22e5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb555ed5129279c1bbe74574507ad67fff22e5e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ccdc216414a902642b358b80f9aaa14bb7ce192b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccdc216414a902642b358b80f9aaa14bb7ce192b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccdc216414a902642b358b80f9aaa14bb7ce192b"}], "stats": {"total": 937, "additions": 868, "deletions": 69}, "files": [{"sha": "00391cbcb2a8c9dbf4437574f09f99ba2f2d5690", "filename": "gcc/ChangeLog", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,3 +1,70 @@\n+2011-06-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/47858\n+\t* gimple.h (enum gimple_debug_subcode): Add GIMPLE_DEBUG_SOURCE_BIND.\n+\t(gimple_build_debug_source_bind_stat): New prototype.\n+\t(gimple_build_debug_source_bind): Define.\n+\t(gimple_debug_source_bind_p, gimple_debug_source_bind_get_var,\n+\tgimple_debug_source_bind_get_value,\n+\tgimple_debug_source_bind_get_value_ptr,\n+\tgimple_debug_source_bind_set_var,\n+\tgimple_debug_source_bind_set_value): New inlines.\n+\t* gimple.c (gimple_build_debug_source_bind_stat): New function.\n+\t* gimple-pretty-print.c (dump_gimple_debug): Handle\n+\tGIMPLE_DEBUG_SOURCE_BIND.\n+\t* sese.c (rename_uses): Handle gimple_debug_source_bind_p.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Likewise.\n+\t* tree-parloops.c (eliminate_local_variables,\n+\tseparate_decls_in_region): Likewise.\n+\t(separate_decls_in_region_debug): Renamed from\n+\tseparate_decls_in_region_debug_bind.  Handle\n+\tgimple_debug_source_bind_p.\n+\t* tree.h (decl_debug_args_lookup, decl_debug_args_insert): New\n+\tprototypes.\n+\t(DECL_HAS_DEBUG_ARGS_P): Define.\n+\t(struct tree_function_decl): Add has_debug_args_flag field.\n+\t* tree.c (debug_args_for_decl): New variable.\n+\t(decl_debug_args_lookup, decl_debug_args_insert): New functions.\n+\t* tree-into-ssa.c (mark_def_sites): Handle uses in debug stmts.\n+\t(rewrite_debug_stmt_uses): New function.\n+\t(rewrite_stmt): Use it to rewrite debug stmt uses.\n+\t* rtl.def (DEBUG_PARAMETER_REF): New.\n+\t* rtl.h (DEBUG_PARAMETER_REF_DECL): Define.\n+\t* cselib.c (rtx_equal_for_cselib_1, cselib_hash_rtx): Handle\n+\tDEBUG_PARAMETER_REF.\n+\t* rtl.c (rtx_equal_p_cb, rtx_equal_p, iterative_hash_rtx): Likewise.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* tree-sra.c (sra_ipa_reset_debug_stmts): Prefer replacing of\n+\tSSA_NAMEs with DEBUG_EXPR_DECLs initialized in source bind\n+\tdebug stmts in the first bb.\n+\t* tree-inline.c (remap_ssa_name): If remapping default def\n+\tof a PARM_DECL fails, map to a DEBUG_EXPR_DECL set in\n+\ta source bind debug stmt.\n+\t(remap_gimple_stmt): Handle gimple_debug_source_bind_p.\n+\t(maybe_move_debug_stmts_to_successors): Likewise.\n+\t(copy_debug_stmt): Likewise.  Avoid shadowing a variable.\n+\t(tree_function_versioning): If DECL_HAS_DEBUG_ARGS_P, copy\n+\tdebug args vector from old_decl to new_decl.\n+\t* ipa-prop.c (ipa_modify_call_arguments): For optimized away\n+\tor modified parameters, add debug bind stmts before call\n+\tsetting DEBUG_EXPR_DECL which is remembered in debug args\n+\tvector.\n+\t* cfgexpand.c (expand_call_stmt): Call expand_debug_expr\n+\ton DECL_DEBUG_EXPRs from debug args vector.\n+\t(expand_debug_source_expr): New function.\n+\t(expand_debug_locations): Use it for source bind insns.\n+\t(expand_gimple_basic_block): Handle gimple_debug_source_bind_p.\n+\t* var-tracking.c (prepare_call_arguments): Add debug args\n+\tto call_arguments if any.\n+\t* dwarf2out.c (dwarf_stack_op_name, size_of_loc_descr,\n+\toutput_loc_operands, output_loc_operands_raw,\n+\tresolve_addr_in_expr, compare_loc_operands): Handle\n+\tDW_OP_GNU_parameter_ref.\n+\t(get_ref_die_offset, parameter_ref_descriptor): New functions.\n+\t(mem_loc_descriptor): Handle DEBUG_PARAMETER_REF.\n+\t(gen_subprogram_die): Handle parameters identified by\n+\tDEBUG_PARAMETER_REF.\n+\n 2011-06-22  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* doc/invoke.texi (ARM Options): Document -mtls-dialect option."}, {"sha": "000a790a683694f4301c302df5314c6519cc14db", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 169, "deletions": 1, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -57,6 +57,8 @@ struct ssaexpand SA;\n    of comminucating the profile info to the builtin expanders.  */\n gimple currently_expanding_gimple_stmt;\n \n+static rtx expand_debug_expr (tree);\n+\n /* Return an expression tree corresponding to the RHS of GIMPLE\n    statement STMT.  */\n \n@@ -1863,6 +1865,21 @@ expand_call_stmt (gimple stmt)\n   SET_EXPR_LOCATION (exp, gimple_location (stmt));\n   TREE_BLOCK (exp) = gimple_block (stmt);\n \n+  /* Ensure RTL is created for debug args.  */\n+  if (decl && DECL_HAS_DEBUG_ARGS_P (decl))\n+    {\n+      VEC(tree, gc) **debug_args = decl_debug_args_lookup (decl);\n+      unsigned int ix;\n+      tree dtemp;\n+\n+      if (debug_args)\n+\tfor (ix = 1; VEC_iterate (tree, *debug_args, ix, dtemp); ix += 2)\n+\t  {\n+\t    gcc_assert (TREE_CODE (dtemp) == DEBUG_EXPR_DECL);\n+\t    expand_debug_expr (dtemp);\n+\t  }\n+    }\n+\n   lhs = gimple_call_lhs (stmt);\n   if (lhs)\n     expand_assignment (lhs, exp, false);\n@@ -3297,6 +3314,120 @@ expand_debug_expr (tree exp)\n     }\n }\n \n+/* Return an RTX equivalent to the source bind value of the tree expression\n+   EXP.  */\n+\n+static rtx\n+expand_debug_source_expr (tree exp)\n+{\n+  rtx op0 = NULL_RTX;\n+  enum machine_mode mode = VOIDmode, inner_mode;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case PARM_DECL:\n+      {\n+\trtx incoming = DECL_INCOMING_RTL (exp);\n+\tmode = DECL_MODE (exp);\n+\tif (incoming\n+\t    && GET_MODE (incoming) != BLKmode\n+\t    && ((REG_P (incoming) && HARD_REGISTER_P (incoming))\n+\t\t|| (MEM_P (incoming)\n+\t\t    && REG_P (XEXP (incoming, 0))\n+\t\t    && HARD_REGISTER_P (XEXP (incoming, 0)))))\n+\t  {\n+\t    op0 = gen_rtx_ENTRY_VALUE (GET_MODE (incoming));\n+\t    ENTRY_VALUE_EXP (op0) = incoming;\n+\t    break;\n+\t  }\n+\tif (incoming\n+\t    && MEM_P (incoming)\n+\t    && !TREE_ADDRESSABLE (exp)\n+\t    && GET_MODE (incoming) != BLKmode\n+\t    && (XEXP (incoming, 0) == virtual_incoming_args_rtx\n+\t\t|| (GET_CODE (XEXP (incoming, 0)) == PLUS\n+\t\t    && XEXP (XEXP (incoming, 0), 0)\n+\t\t       == virtual_incoming_args_rtx\n+\t\t    && CONST_INT_P (XEXP (XEXP (incoming, 0), 1)))))\n+\t  {\n+\t    op0 = incoming;\n+\t    break;\n+\t  }\n+\t/* See if this isn't an argument that has been completely\n+\t   optimized out.  */\n+\tif (!DECL_RTL_SET_P (exp)\n+\t    && incoming == NULL_RTX\n+\t    && DECL_ABSTRACT_ORIGIN (current_function_decl))\n+\t  {\n+\t    tree aexp = exp;\n+\t    if (DECL_ABSTRACT_ORIGIN (exp))\n+\t      aexp = DECL_ABSTRACT_ORIGIN (exp);\n+\t    if (DECL_CONTEXT (aexp)\n+\t\t== DECL_ABSTRACT_ORIGIN (current_function_decl))\n+\t      {\n+\t\tVEC(tree, gc) **debug_args;\n+\t\tunsigned int ix;\n+\t\ttree ddecl;\n+#ifdef ENABLE_CHECKING\n+\t\ttree parm;\n+\t\tfor (parm = DECL_ARGUMENTS (current_function_decl);\n+\t\t     parm; parm = DECL_CHAIN (parm))\n+\t\t  gcc_assert (parm != exp\n+\t\t\t      && DECL_ABSTRACT_ORIGIN (parm) != aexp);\n+#endif\n+\t\tdebug_args = decl_debug_args_lookup (current_function_decl);\n+\t\tif (debug_args != NULL)\n+\t\t  {\n+\t\t    for (ix = 0; VEC_iterate (tree, *debug_args, ix, ddecl);\n+\t\t\t ix += 2)\n+\t\t      if (ddecl == aexp)\n+\t\t\treturn gen_rtx_DEBUG_PARAMETER_REF (mode, aexp);\n+\t\t  }\n+\t      }\n+\t  }\n+\tbreak;\n+      }\n+    default:\n+      break;\n+    }\n+\n+  if (op0 == NULL_RTX)\n+    return NULL_RTX;\n+\n+  inner_mode = GET_MODE (op0);\n+  if (mode == inner_mode)\n+    return op0;\n+\n+  if (FLOAT_MODE_P (mode) && FLOAT_MODE_P (inner_mode))\n+    {\n+      if (GET_MODE_BITSIZE (mode) == GET_MODE_BITSIZE (inner_mode))\n+\top0 = simplify_gen_subreg (mode, op0, inner_mode, 0);\n+      else if (GET_MODE_BITSIZE (mode) < GET_MODE_BITSIZE (inner_mode))\n+\top0 = simplify_gen_unary (FLOAT_TRUNCATE, mode, op0, inner_mode);\n+      else\n+\top0 = simplify_gen_unary (FLOAT_EXTEND, mode, op0, inner_mode);\n+    }\n+  else if (FLOAT_MODE_P (mode))\n+    gcc_unreachable ();\n+  else if (FLOAT_MODE_P (inner_mode))\n+    {\n+      if (TYPE_UNSIGNED (TREE_TYPE (exp)))\n+\top0 = simplify_gen_unary (UNSIGNED_FIX, mode, op0, inner_mode);\n+      else\n+\top0 = simplify_gen_unary (FIX, mode, op0, inner_mode);\n+    }\n+  else if (CONSTANT_P (op0)\n+\t   || GET_MODE_BITSIZE (mode) <= GET_MODE_BITSIZE (inner_mode))\n+    op0 = simplify_gen_subreg (mode, op0, inner_mode,\n+\t\t\t       subreg_lowpart_offset (mode, inner_mode));\n+  else if (TYPE_UNSIGNED (TREE_TYPE (exp)))\n+    op0 = simplify_gen_unary (ZERO_EXTEND, mode, op0, inner_mode);\n+  else\n+    op0 = simplify_gen_unary (SIGN_EXTEND, mode, op0, inner_mode);\n+\n+  return op0;\n+}\n+\n /* Expand the _LOCs in debug insns.  We run this after expanding all\n    regular insns, so that any variables referenced in the function\n    will have their DECL_RTLs set.  */\n@@ -3324,7 +3455,11 @@ expand_debug_locations (void)\n \t  val = NULL_RTX;\n \telse\n \t  {\n-\t    val = expand_debug_expr (value);\n+\t    if (INSN_VAR_LOCATION_STATUS (insn)\n+\t\t== VAR_INIT_STATUS_UNINITIALIZED)\n+\t      val = expand_debug_source_expr (value);\n+\t    else\n+\t      val = expand_debug_expr (value);\n \t    gcc_assert (last == get_last_insn ());\n \t  }\n \n@@ -3603,6 +3738,39 @@ expand_gimple_basic_block (basic_block bb)\n \t\tbreak;\n \t    }\n \n+\t  set_curr_insn_source_location (sloc);\n+\t  set_curr_insn_block (sblock);\n+\t}\n+      else if (gimple_debug_source_bind_p (stmt))\n+\t{\n+\t  location_t sloc = get_curr_insn_source_location ();\n+\t  tree sblock = get_curr_insn_block ();\n+\t  tree var = gimple_debug_source_bind_get_var (stmt);\n+\t  tree value = gimple_debug_source_bind_get_value (stmt);\n+\t  rtx val;\n+\t  enum machine_mode mode;\n+\n+\t  last = get_last_insn ();\n+\n+\t  set_curr_insn_source_location (gimple_location (stmt));\n+\t  set_curr_insn_block (gimple_block (stmt));\n+\n+\t  mode = DECL_MODE (var);\n+\n+\t  val = gen_rtx_VAR_LOCATION (mode, var, (rtx)value,\n+\t\t\t\t      VAR_INIT_STATUS_UNINITIALIZED);\n+\n+\t  emit_debug_insn (val);\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      /* We can't dump the insn with a TREE where an RTX\n+\t\t is expected.  */\n+\t      PAT_VAR_LOCATION_LOC (val) = const0_rtx;\n+\t      maybe_dump_rtl_for_gimple_stmt (stmt, last);\n+\t      PAT_VAR_LOCATION_LOC (val) = (rtx)value;\n+\t    }\n+\n \t  set_curr_insn_source_location (sloc);\n \t  set_curr_insn_block (sblock);\n \t}"}, {"sha": "e575aff72fd8320dceffd96a098e9f082d117a3b", "filename": "gcc/cselib.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -812,6 +812,10 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, enum machine_mode memmode)\n       return DEBUG_IMPLICIT_PTR_DECL (x)\n \t     == DEBUG_IMPLICIT_PTR_DECL (y);\n \n+    case DEBUG_PARAMETER_REF:\n+      return DEBUG_PARAMETER_REF_DECL (x)\n+\t     == DEBUG_PARAMETER_REF_DECL (y);\n+\n     case ENTRY_VALUE:\n       /* ENTRY_VALUEs are function invariant, it is thus undesirable to\n \t use rtx_equal_for_cselib_1 to compare the operands.  */\n@@ -963,6 +967,11 @@ cselib_hash_rtx (rtx x, int create, enum machine_mode memmode)\n \t      + DECL_UID (DEBUG_IMPLICIT_PTR_DECL (x));\n       return hash ? hash : (unsigned int) DEBUG_IMPLICIT_PTR;\n \n+    case DEBUG_PARAMETER_REF:\n+      hash += ((unsigned) DEBUG_PARAMETER_REF << 7)\n+\t      + DECL_UID (DEBUG_PARAMETER_REF_DECL (x));\n+      return hash ? hash : (unsigned int) DEBUG_PARAMETER_REF;\n+\n     case ENTRY_VALUE:\n       /* ENTRY_VALUEs are function invariant, thus try to avoid\n \t recursing on argument if ENTRY_VALUE is one of the"}, {"sha": "6d536205dea36c68e50ef318eccd80a0955292bc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 83, "deletions": 5, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -4811,6 +4811,8 @@ dwarf_stack_op_name (unsigned int op)\n       return \"DW_OP_GNU_convert\";\n     case DW_OP_GNU_reinterpret:\n       return \"DW_OP_GNU_reinterpret\";\n+    case DW_OP_GNU_parameter_ref:\n+      return \"DW_OP_GNU_parameter_ref\";\n \n     default:\n       return \"OP_<unknown>\";\n@@ -5085,6 +5087,10 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n \t  = get_base_type_offset (loc->dw_loc_oprnd1.v.val_die_ref.die);\n \tsize += size_of_uleb128 (o);\n       }\n+      break;\n+    case DW_OP_GNU_parameter_ref:\n+      size += 4;\n+      break;\n     default:\n       break;\n     }\n@@ -5122,6 +5128,7 @@ size_of_locs (dw_loc_descr_ref loc)\n \n static HOST_WIDE_INT extract_int (const unsigned char *, unsigned);\n static void get_ref_die_offset_label (char *, dw_die_ref);\n+static unsigned long int get_ref_die_offset (dw_die_ref);\n static void output_loc_sequence (dw_loc_descr_ref, int);\n \n /* Output location description stack opcode's operands (if any).\n@@ -5467,6 +5474,15 @@ output_loc_operands (dw_loc_descr_ref loc, int for_eh_or_skip)\n       }\n       break;\n \n+    case DW_OP_GNU_parameter_ref:\n+      {\n+\tunsigned long o;\n+\tgcc_assert (val1->val_class == dw_val_class_die_ref);\n+\to = get_ref_die_offset (val1->v.val_die_ref.die);\n+\tdw2_asm_output_data (4, o, NULL);\n+      }\n+      break;\n+\n     default:\n       /* Other codes have no operands.  */\n       break;\n@@ -5649,6 +5665,7 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n     case DW_OP_GNU_deref_type:\n     case DW_OP_GNU_convert:\n     case DW_OP_GNU_reinterpret:\n+    case DW_OP_GNU_parameter_ref:\n       gcc_unreachable ();\n       break;\n \n@@ -6965,6 +6982,15 @@ get_base_type_offset (dw_die_ref ref)\n   return ref->die_offset;\n }\n \n+/* Return die_offset of a DIE reference other than base type.  */\n+\n+static unsigned long int\n+get_ref_die_offset (dw_die_ref ref)\n+{\n+  gcc_assert (ref->die_offset);\n+  return ref->die_offset;\n+}\n+\n /* Convert a DIE tag into its string name.  */\n \n static const char *\n@@ -14507,6 +14533,34 @@ rotate_loc_descriptor (rtx rtl, enum machine_mode mode,\n   return ret;\n }\n \n+/* Helper function for mem_loc_descriptor.  Return DW_OP_GNU_parameter_ref\n+   for DEBUG_PARAMETER_REF RTL.  */\n+\n+static dw_loc_descr_ref\n+parameter_ref_descriptor (rtx rtl)\n+{\n+  dw_loc_descr_ref ret;\n+  dw_die_ref ref;\n+\n+  if (dwarf_strict)\n+    return NULL;\n+  gcc_assert (TREE_CODE (DEBUG_PARAMETER_REF_DECL (rtl)) == PARM_DECL);\n+  ref = lookup_decl_die (DEBUG_PARAMETER_REF_DECL (rtl));\n+  ret = new_loc_descr (DW_OP_GNU_parameter_ref, 0, 0);\n+  if (ref)\n+    {\n+      ret->dw_loc_oprnd1.val_class = dw_val_class_die_ref;\n+      ret->dw_loc_oprnd1.v.val_die_ref.die = ref;\n+      ret->dw_loc_oprnd1.v.val_die_ref.external = 0;\n+    }\n+  else\n+    {\n+      ret->dw_loc_oprnd1.val_class = dw_val_class_decl_ref;\n+      ret->dw_loc_oprnd1.v.val_decl_ref = DEBUG_PARAMETER_REF_DECL (rtl);\n+    }\n+  return ret;\n+}\n+\n /* The following routine converts the RTL for a variable or parameter\n    (resident in memory) into an equivalent Dwarf representation of a\n    mechanism for getting the address of that same variable onto the top of a\n@@ -14853,7 +14907,11 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       mem_loc_result = new_loc_descr (DW_OP_GNU_entry_value, 0, 0);\n       mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_loc;\n       mem_loc_result->dw_loc_oprnd1.v.val_loc = op0;\n-      return mem_loc_result;\n+      break;\n+\n+    case DEBUG_PARAMETER_REF:\n+      mem_loc_result = parameter_ref_descriptor (rtl);\n+      break;\n \n     case PRE_MODIFY:\n       /* Extract the PLUS expression nested inside and fall into\n@@ -20571,7 +20629,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t{\n \t\t  dw_loc_descr_ref reg, val;\n \t\t  enum machine_mode mode = GET_MODE (XEXP (XEXP (arg, 0), 1));\n-\t\t  dw_die_ref cdie;\n+\t\t  dw_die_ref cdie, tdie = NULL;\n \n \t\t  next_arg = XEXP (arg, 1);\n \t\t  if (REG_P (XEXP (XEXP (arg, 0), 0))\n@@ -20602,6 +20660,7 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t      tlocc = XEXP (XEXP (arg, 0), 1);\n \t\t      continue;\n \t\t    }\n+\t\t  reg = NULL;\n \t\t  if (REG_P (XEXP (XEXP (arg, 0), 0)))\n \t\t    reg = reg_loc_descriptor (XEXP (XEXP (arg, 0), 0),\n \t\t\t\t\t      VAR_INIT_STATUS_INITIALIZED);\n@@ -20613,9 +20672,20 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t\t\t\t\tGET_MODE (mem),\n \t\t\t\t\t\tVAR_INIT_STATUS_INITIALIZED);\n \t\t    }\n+\t\t  else if (GET_CODE (XEXP (XEXP (arg, 0), 0))\n+\t\t\t   == DEBUG_PARAMETER_REF)\n+\t\t    {\n+\t\t      tree tdecl\n+\t\t\t= DEBUG_PARAMETER_REF_DECL (XEXP (XEXP (arg, 0), 0));\n+\t\t      tdie = lookup_decl_die (tdecl);\n+\t\t      if (tdie == NULL)\n+\t\t\tcontinue;\n+\t\t    }\n \t\t  else\n \t\t    continue;\n-\t\t  if (reg == NULL)\n+\t\t  if (reg == NULL\n+\t\t      && GET_CODE (XEXP (XEXP (arg, 0), 0))\n+\t\t\t != DEBUG_PARAMETER_REF)\n \t\t    continue;\n \t\t  val = mem_loc_descriptor (XEXP (XEXP (arg, 0), 1), mode,\n \t\t\t\t\t    VOIDmode,\n@@ -20625,8 +20695,11 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t\t  if (die == NULL)\n \t\t    die = gen_call_site_die (decl, subr_die, ca_loc);\n \t\t  cdie = new_die (DW_TAG_GNU_call_site_parameter, die,\n-\t\t\t\t  NULL_TREE);\t\t\n-\t\t  add_AT_loc (cdie, DW_AT_location, reg);\n+\t\t\t\t  NULL_TREE);\n+\t\t  if (reg != NULL)\n+\t\t    add_AT_loc (cdie, DW_AT_location, reg);\n+\t\t  else if (tdie != NULL)\n+\t\t    add_AT_die_ref (cdie, DW_AT_abstract_origin, tdie);\n \t\t  add_AT_loc (cdie, DW_AT_GNU_call_site_value, val);\n \t\t  if (next_arg != XEXP (arg, 1))\n \t\t    {\n@@ -24208,6 +24281,7 @@ resolve_addr_in_expr (dw_loc_descr_ref loc)\n \t  return false;\n \tbreak;\n       case DW_OP_GNU_implicit_pointer:\n+      case DW_OP_GNU_parameter_ref:\n \tif (loc->dw_loc_oprnd1.val_class == dw_val_class_decl_ref)\n \t  {\n \t    dw_die_ref ref\n@@ -24748,6 +24822,10 @@ compare_loc_operands (dw_loc_descr_ref x, dw_loc_descr_ref y)\n     case DW_OP_GNU_convert:\n     case DW_OP_GNU_reinterpret:\n       return valx1->v.val_die_ref.die == valy1->v.val_die_ref.die;\n+    case DW_OP_GNU_parameter_ref:\n+      return valx1->val_class == dw_val_class_die_ref\n+\t     && valx1->val_class == valy1->val_class\n+\t     && valx1->v.val_die_ref.die == valy1->v.val_die_ref.die;\n     default:\n       /* Other codes have no operands.  */\n       return true;"}, {"sha": "eaf3e5fa995fcd045c77025a6adefaa63ad18710", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,6 +1,6 @@\n /* Pretty formatting of GIMPLE statements and expressions.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011  Free Software Foundation, Inc.\n    Contributed by Aldy Hernandez <aldyh@redhat.com> and\n    Diego Novillo <dnovillo@google.com>\n \n@@ -966,6 +966,17 @@ dump_gimple_debug (pretty_printer *buffer, gimple gs, int spc, int flags)\n \t\t\t gimple_debug_bind_get_value (gs));\n       break;\n \n+    case GIMPLE_DEBUG_SOURCE_BIND:\n+      if (flags & TDF_RAW)\n+\tdump_gimple_fmt (buffer, spc, flags, \"%G SRCBIND <%T, %T>\", gs,\n+\t\t\t gimple_debug_source_bind_get_var (gs),\n+\t\t\t gimple_debug_source_bind_get_value (gs));\n+      else\n+\tdump_gimple_fmt (buffer, spc, flags, \"# DEBUG %T s=> %T\",\n+\t\t\t gimple_debug_source_bind_get_var (gs),\n+\t\t\t gimple_debug_source_bind_get_value (gs));\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "e3095d7e261916cc8c00a30ae068878634bb6b17", "filename": "gcc/gimple.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,6 +1,6 @@\n /* Gimple IR support functions.\n \n-   Copyright 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Aldy Hernandez <aldyh@redhat.com>\n \n This file is part of GCC.\n@@ -866,6 +866,30 @@ gimple_build_debug_bind_stat (tree var, tree value, gimple stmt MEM_STAT_DECL)\n }\n \n \n+/* Build a new GIMPLE_DEBUG_SOURCE_BIND statement.\n+\n+   VAR is bound to VALUE; block and location are taken from STMT.  */\n+\n+gimple\n+gimple_build_debug_source_bind_stat (tree var, tree value,\n+\t\t\t\t     gimple stmt MEM_STAT_DECL)\n+{\n+  gimple p = gimple_build_with_ops_stat (GIMPLE_DEBUG,\n+\t\t\t\t\t (unsigned)GIMPLE_DEBUG_SOURCE_BIND, 2\n+\t\t\t\t\t PASS_MEM_STAT);\n+\n+  gimple_debug_source_bind_set_var (p, var);\n+  gimple_debug_source_bind_set_value (p, value);\n+  if (stmt)\n+    {\n+      gimple_set_block (p, gimple_block (stmt));\n+      gimple_set_location (p, gimple_location (stmt));\n+    }\n+\n+  return p;\n+}\n+\n+\n /* Build a GIMPLE_OMP_CRITICAL statement.\n \n    BODY is the sequence of statements for which only one thread can execute."}, {"sha": "184c9733ee5900798ed23d568b7ac17db3147bee", "filename": "gcc/gimple.h", "status": "modified", "additions": 71, "deletions": 3, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,6 +1,6 @@\n /* Gimple IR definitions.\n \n-   Copyright 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Aldy Hernandez <aldyh@redhat.com>\n \n This file is part of GCC.\n@@ -117,12 +117,13 @@ enum gf_mask {\n     GF_PREDICT_TAKEN\t\t= 1 << 15\n };\n \n-/* Currently, there's only one type of gimple debug stmt.  Others are\n+/* Currently, there are only two types of gimple debug stmt.  Others are\n    envisioned, for example, to enable the generation of is_stmt notes\n    in line number information, to mark sequence points, etc.  This\n    subcode is to be used to tell them apart.  */\n enum gimple_debug_subcode {\n-  GIMPLE_DEBUG_BIND = 0\n+  GIMPLE_DEBUG_BIND = 0,\n+  GIMPLE_DEBUG_SOURCE_BIND = 1\n };\n \n /* Masks for selecting a pass local flag (PLF) to work on.  These\n@@ -823,6 +824,9 @@ gimple gimple_build_assign_with_ops_stat (enum tree_code, tree, tree,\n gimple gimple_build_debug_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n #define gimple_build_debug_bind(var,val,stmt)\t\t\t\\\n   gimple_build_debug_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n+gimple gimple_build_debug_source_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n+#define gimple_build_debug_source_bind(var,val,stmt)\t\t\t\\\n+  gimple_build_debug_source_bind_stat ((var), (val), (stmt) MEM_STAT_INFO)\n \n gimple gimple_build_call_vec (tree, VEC(tree, heap) *);\n gimple gimple_build_call (tree, unsigned, ...);\n@@ -3583,6 +3587,70 @@ gimple_debug_bind_has_value_p (gimple dbg)\n \n #undef GIMPLE_DEBUG_BIND_NOVALUE\n \n+/* Return true if S is a GIMPLE_DEBUG SOURCE BIND statement.  */\n+\n+static inline bool\n+gimple_debug_source_bind_p (const_gimple s)\n+{\n+  if (is_gimple_debug (s))\n+    return s->gsbase.subcode == GIMPLE_DEBUG_SOURCE_BIND;\n+\n+  return false;\n+}\n+\n+/* Return the variable bound in a GIMPLE_DEBUG source bind statement.  */\n+\n+static inline tree\n+gimple_debug_source_bind_get_var (gimple dbg)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n+  return gimple_op (dbg, 0);\n+}\n+\n+/* Return the value bound to the variable in a GIMPLE_DEBUG source bind\n+   statement.  */\n+\n+static inline tree\n+gimple_debug_source_bind_get_value (gimple dbg)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n+  return gimple_op (dbg, 1);\n+}\n+\n+/* Return a pointer to the value bound to the variable in a\n+   GIMPLE_DEBUG source bind statement.  */\n+\n+static inline tree *\n+gimple_debug_source_bind_get_value_ptr (gimple dbg)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n+  return gimple_op_ptr (dbg, 1);\n+}\n+\n+/* Set the variable bound in a GIMPLE_DEBUG source bind statement.  */\n+\n+static inline void\n+gimple_debug_source_bind_set_var (gimple dbg, tree var)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n+  gimple_set_op (dbg, 0, var);\n+}\n+\n+/* Set the value bound to the variable in a GIMPLE_DEBUG source bind\n+   statement.  */\n+\n+static inline void\n+gimple_debug_source_bind_set_value (gimple dbg, tree value)\n+{\n+  GIMPLE_CHECK (dbg, GIMPLE_DEBUG);\n+  gcc_gimple_checking_assert (gimple_debug_source_bind_p (dbg));\n+  gimple_set_op (dbg, 1, value);\n+}\n+\n /* Return the body for the OMP statement GS.  */\n \n static inline gimple_seq"}, {"sha": "aec1920c62ebe3c9fda375a038a6271c85ad121c", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 39, "deletions": 2, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,5 +1,5 @@\n /* Interprocedural analyses.\n-   Copyright (C) 2005, 2007, 2008, 2009, 2010\n+   Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -2393,13 +2393,15 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \t\t\t   ipa_parm_adjustment_vec adjustments)\n {\n   VEC(tree, heap) *vargs;\n+  VEC(tree, gc) **debug_args = NULL;\n   gimple new_stmt;\n   gimple_stmt_iterator gsi;\n   tree callee_decl;\n   int i, len;\n \n   len = VEC_length (ipa_parm_adjustment_t, adjustments);\n   vargs = VEC_alloc (tree, heap, len);\n+  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->decl;\n \n   gsi = gsi_for_stmt (stmt);\n   for (i = 0; i < len; i++)\n@@ -2490,6 +2492,42 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \t\t\t\t\t   NULL, true, GSI_SAME_STMT);\n \t  VEC_quick_push (tree, vargs, expr);\n \t}\n+      if (!adj->copy_param && MAY_HAVE_DEBUG_STMTS)\n+\t{\n+\t  unsigned int ix;\n+\t  tree ddecl = NULL_TREE, origin = DECL_ORIGIN (adj->base), arg;\n+\t  gimple def_temp;\n+\n+\t  arg = gimple_call_arg (stmt, adj->base_index);\n+\t  if (!useless_type_conversion_p (TREE_TYPE (origin), TREE_TYPE (arg)))\n+\t    {\n+\t      if (!fold_convertible_p (TREE_TYPE (origin), arg))\n+\t\tcontinue;\n+\t      arg = fold_convert_loc (gimple_location (stmt),\n+\t\t\t\t      TREE_TYPE (origin), arg);\n+\t    }\n+\t  if (debug_args == NULL)\n+\t    debug_args = decl_debug_args_insert (callee_decl);\n+\t  for (ix = 0; VEC_iterate (tree, *debug_args, ix, ddecl); ix += 2)\n+\t    if (ddecl == origin)\n+\t      {\n+\t\tddecl = VEC_index (tree, *debug_args, ix + 1);\n+\t\tbreak;\n+\t      }\n+\t  if (ddecl == NULL)\n+\t    {\n+\t      ddecl = make_node (DEBUG_EXPR_DECL);\n+\t      DECL_ARTIFICIAL (ddecl) = 1;\n+\t      TREE_TYPE (ddecl) = TREE_TYPE (origin);\n+\t      DECL_MODE (ddecl) = DECL_MODE (origin);\n+\n+\t      VEC_safe_push (tree, gc, *debug_args, origin);\n+\t      VEC_safe_push (tree, gc, *debug_args, ddecl);\n+\t    }\n+\t  def_temp = gimple_build_debug_bind (ddecl, unshare_expr (arg),\n+\t\t\t\t\t      stmt);\n+\t  gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n+\t}\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2498,7 +2536,6 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n       print_gimple_stmt (dump_file, gsi_stmt (gsi), 0, 0);\n     }\n \n-  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->decl;\n   new_stmt = gimple_build_call_vec (callee_decl, vargs);\n   VEC_free (tree, heap, vargs);\n   if (gimple_call_lhs (stmt))"}, {"sha": "c20ff6c0c5f133e2643042db371eeec6c85a606a", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -552,6 +552,8 @@ print_rtx (const_rtx in_rtx)\n #ifndef GENERATOR_FILE\n \tif (i == 0 && GET_CODE (in_rtx) == DEBUG_IMPLICIT_PTR)\n \t  print_mem_expr (outfile, DEBUG_IMPLICIT_PTR_DECL (in_rtx));\n+\telse if (i == 0 && GET_CODE (in_rtx) == DEBUG_PARAMETER_REF)\n+\t  print_mem_expr (outfile, DEBUG_PARAMETER_REF_DECL (in_rtx));\n \telse\n \t  dump_addr (outfile, \" \", XTREE (in_rtx, i));\n #endif"}, {"sha": "52e9e9ce3a89b258d85b4625819bbd328c273cca", "filename": "gcc/rtl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -413,6 +413,10 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n       return DEBUG_IMPLICIT_PTR_DECL (x)\n \t     == DEBUG_IMPLICIT_PTR_DECL (y);\n \n+    case DEBUG_PARAMETER_REF:\n+      return DEBUG_PARAMETER_REF_DECL (x)\n+\t     == DEBUG_PARAMETER_REF_DECL (x);\n+\n     case ENTRY_VALUE:\n       return rtx_equal_p_cb (ENTRY_VALUE_EXP (x), ENTRY_VALUE_EXP (y), cb);\n \n@@ -548,6 +552,10 @@ rtx_equal_p (const_rtx x, const_rtx y)\n       return DEBUG_IMPLICIT_PTR_DECL (x)\n \t     == DEBUG_IMPLICIT_PTR_DECL (y);\n \n+    case DEBUG_PARAMETER_REF:\n+      return DEBUG_PARAMETER_REF_DECL (x)\n+\t     == DEBUG_PARAMETER_REF_DECL (y);\n+\n     case ENTRY_VALUE:\n       return rtx_equal_p (ENTRY_VALUE_EXP (x), ENTRY_VALUE_EXP (y));\n \n@@ -660,6 +668,7 @@ iterative_hash_rtx (const_rtx x, hashval_t hash)\n     case CONST_DOUBLE:\n     case CONST_FIXED:\n     case DEBUG_IMPLICIT_PTR:\n+    case DEBUG_PARAMETER_REF:\n       return hash;\n     default:\n       break;"}, {"sha": "a7de8f7b4aadb3892058736b4140944e3fe92da4", "filename": "gcc/rtl.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -727,6 +727,10 @@ DEF_RTL_EXPR(DEBUG_IMPLICIT_PTR, \"debug_implicit_ptr\", \"t\", RTX_OBJ)\n    parameter.  */\n DEF_RTL_EXPR(ENTRY_VALUE, \"entry_value\", \"0\", RTX_OBJ)\n \n+/* Used in VAR_LOCATION for a reference to a parameter that has\n+   been optimized away completely.  */\n+DEF_RTL_EXPR(DEBUG_PARAMETER_REF, \"debug_parameter_ref\", \"t\", RTX_OBJ)\n+\n /* All expressions from this point forward appear only in machine\n    descriptions.  */\n #ifdef GENERATOR_FILE"}, {"sha": "da18788a292fb3bca6c9964cdd557d66d983a72f", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -941,6 +941,9 @@ extern const char * const reg_note_name[];\n /* VAR_DECL/PARM_DECL DEBUG_IMPLICIT_PTR takes address of.  */\n #define DEBUG_IMPLICIT_PTR_DECL(RTX) XCTREE (RTX, 0, DEBUG_IMPLICIT_PTR)\n \n+/* PARM_DECL DEBUG_PARAMETER_REF references.  */\n+#define DEBUG_PARAMETER_REF_DECL(RTX) XCTREE (RTX, 0, DEBUG_PARAMETER_REF)\n+\n /* Possible initialization status of a variable.   When requested\n    by the user, this information is tracked and recorded in the DWARF\n    debug information, along with the variable's location.  */"}, {"sha": "a03cbc9a0bdab3737a7eb0af1f6dec2082876938", "filename": "gcc/sese.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,5 +1,5 @@\n /* Single entry single exit control flow regions.\n-   Copyright (C) 2008, 2009, 2010\n+   Copyright (C) 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Jan Sjodin <jan.sjodin@amd.com> and\n    Sebastian Pop <sebastian.pop@amd.com>.\n@@ -472,6 +472,8 @@ rename_uses (gimple copy, htab_t rename_map, gimple_stmt_iterator *gsi_tgt,\n     {\n       if (gimple_debug_bind_p (copy))\n \tgimple_debug_bind_reset_value (copy);\n+      else if (gimple_debug_source_bind_p (copy))\n+\treturn false;\n       else\n \tgcc_unreachable ();\n "}, {"sha": "6a8eae8694507cac0be500d98a857054326fea11", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 89, "deletions": 18, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,5 +1,5 @@\n /* Tree inlining.\n-   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Alexandre Oliva <aoliva@redhat.com>\n \n@@ -188,6 +188,33 @@ remap_ssa_name (tree name, copy_body_data *id)\n \n   if (processing_debug_stmt)\n     {\n+      if (TREE_CODE (SSA_NAME_VAR (name)) == PARM_DECL\n+\t  && SSA_NAME_IS_DEFAULT_DEF (name)\n+\t  && id->entry_bb == NULL\n+\t  && single_succ_p (ENTRY_BLOCK_PTR))\n+\t{\n+\t  tree vexpr = make_node (DEBUG_EXPR_DECL);\n+\t  gimple def_temp;\n+\t  gimple_stmt_iterator gsi;\n+\t  tree val = SSA_NAME_VAR (name);\n+\n+\t  n = (tree *) pointer_map_contains (id->decl_map, val);\n+\t  if (n != NULL)\n+\t    val = *n;\n+\t  if (TREE_CODE (val) != PARM_DECL)\n+\t    {\n+\t      processing_debug_stmt = -1;\n+\t      return name;\n+\t    }\n+\t  def_temp = gimple_build_debug_source_bind (vexpr, val, NULL);\n+\t  DECL_ARTIFICIAL (vexpr) = 1;\n+\t  TREE_TYPE (vexpr) = TREE_TYPE (name);\n+\t  DECL_MODE (vexpr) = DECL_MODE (SSA_NAME_VAR (name));\n+\t  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+\t  gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n+\t  return vexpr;\n+\t}\n+\n       processing_debug_stmt = -1;\n       return name;\n     }\n@@ -1403,6 +1430,14 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t  VEC_safe_push (gimple, heap, id->debug_stmts, copy);\n \t  return copy;\n \t}\n+      if (gimple_debug_source_bind_p (stmt))\n+\t{\n+\t  copy = gimple_build_debug_source_bind\n+\t\t   (gimple_debug_source_bind_get_var (stmt),\n+\t\t    gimple_debug_source_bind_get_value (stmt), stmt);\n+\t  VEC_safe_push (gimple, heap, id->debug_stmts, copy);\n+\t  return copy;\n+\t}\n \n       /* Create a new deep copy of the statement.  */\n       copy = gimple_copy (stmt);\n@@ -1478,7 +1513,7 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \n   gimple_set_block (copy, new_block);\n \n-  if (gimple_debug_bind_p (copy))\n+  if (gimple_debug_bind_p (copy) || gimple_debug_source_bind_p (copy))\n     return copy;\n \n   /* Remap all the operands in COPY.  */\n@@ -2151,22 +2186,33 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n \t    {\n \t      si = ssi;\n \t      gsi_prev (&ssi);\n-\t      if (!single_pred_p (e->dest))\n+\t      if (!single_pred_p (e->dest) && gimple_debug_bind_p (stmt))\n \t\tgimple_debug_bind_reset_value (stmt);\n \t      gsi_remove (&si, false);\n \t      gsi_insert_before (&dsi, stmt, GSI_SAME_STMT);\n \t      continue;\n \t    }\n \n-\t  var = gimple_debug_bind_get_var (stmt);\n-\t  if (single_pred_p (e->dest))\n+\t  if (gimple_debug_bind_p (stmt))\n \t    {\n-\t      value = gimple_debug_bind_get_value (stmt);\n-\t      value = unshare_expr (value);\n+\t      var = gimple_debug_bind_get_var (stmt);\n+\t      if (single_pred_p (e->dest))\n+\t\t{\n+\t\t  value = gimple_debug_bind_get_value (stmt);\n+\t\t  value = unshare_expr (value);\n+\t\t}\n+\t      else\n+\t\tvalue = NULL_TREE;\n+\t      new_stmt = gimple_build_debug_bind (var, value, stmt);\n+\t    }\n+\t  else if (gimple_debug_source_bind_p (stmt))\n+\t    {\n+\t      var = gimple_debug_source_bind_get_var (stmt);\n+\t      value = gimple_debug_source_bind_get_value (stmt);\n+\t      new_stmt = gimple_build_debug_source_bind (var, value, stmt);\n \t    }\n \t  else\n-\t    value = NULL_TREE;\n-\t  new_stmt = gimple_build_debug_bind (var, value, stmt);\n+\t    gcc_unreachable ();\n \t  gsi_insert_before (&dsi, new_stmt, GSI_SAME_STMT);\n \t  VEC_safe_push (gimple, heap, id->debug_stmts, new_stmt);\n \t  gsi_prev (&ssi);\n@@ -2317,7 +2363,6 @@ copy_debug_stmt (gimple stmt, copy_body_data *id)\n   t = id->block;\n   if (gimple_block (stmt))\n     {\n-      tree *n;\n       n = (tree *) pointer_map_contains (id->decl_map, gimple_block (stmt));\n       if (n)\n \tt = *n;\n@@ -2330,7 +2375,10 @@ copy_debug_stmt (gimple stmt, copy_body_data *id)\n \n   processing_debug_stmt = 1;\n \n-  t = gimple_debug_bind_get_var (stmt);\n+  if (gimple_debug_source_bind_p (stmt))\n+    t = gimple_debug_source_bind_get_var (stmt);\n+  else\n+    t = gimple_debug_bind_get_var (stmt);\n \n   if (TREE_CODE (t) == PARM_DECL && id->debug_map\n       && (n = (tree *) pointer_map_contains (id->debug_map, t)))\n@@ -2347,15 +2395,24 @@ copy_debug_stmt (gimple stmt, copy_body_data *id)\n   else\n     walk_tree (&t, remap_gimple_op_r, &wi, NULL);\n \n-  gimple_debug_bind_set_var (stmt, t);\n+  if (gimple_debug_bind_p (stmt))\n+    {\n+      gimple_debug_bind_set_var (stmt, t);\n \n-  if (gimple_debug_bind_has_value_p (stmt))\n-    walk_tree (gimple_debug_bind_get_value_ptr (stmt),\n-\t       remap_gimple_op_r, &wi, NULL);\n+      if (gimple_debug_bind_has_value_p (stmt))\n+\twalk_tree (gimple_debug_bind_get_value_ptr (stmt),\n+\t\t   remap_gimple_op_r, &wi, NULL);\n \n-  /* Punt if any decl couldn't be remapped.  */\n-  if (processing_debug_stmt < 0)\n-    gimple_debug_bind_reset_value (stmt);\n+      /* Punt if any decl couldn't be remapped.  */\n+      if (processing_debug_stmt < 0)\n+\tgimple_debug_bind_reset_value (stmt);\n+    }\n+  else if (gimple_debug_source_bind_p (stmt))\n+    {\n+      gimple_debug_source_bind_set_var (stmt, t);\n+      walk_tree (gimple_debug_source_bind_get_value_ptr (stmt),\n+\t\t remap_gimple_op_r, &wi, NULL);\n+    }\n \n   processing_debug_stmt = 0;\n \n@@ -5001,6 +5058,20 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   new_version_node = cgraph_get_node (new_decl);\n   gcc_checking_assert (new_version_node);\n \n+  /* Copy over debug args.  */\n+  if (DECL_HAS_DEBUG_ARGS_P (old_decl))\n+    {\n+      VEC(tree, gc) **new_debug_args, **old_debug_args;\n+      gcc_checking_assert (decl_debug_args_lookup (new_decl) == NULL);\n+      DECL_HAS_DEBUG_ARGS_P (new_decl) = 0;\n+      old_debug_args = decl_debug_args_lookup (old_decl);\n+      if (old_debug_args)\n+\t{\n+\t  new_debug_args = decl_debug_args_insert (new_decl);\n+\t  *new_debug_args = VEC_copy (tree, gc, *old_debug_args);\n+\t}\n+    }\n+\n   /* Output the inlining info for this abstract function, since it has been\n      inlined.  If we don't do this now, we can lose the information about the\n      variables in the function when the blocks get blown away as soon as we"}, {"sha": "0db9085f0530b66eba8c4d13d916e1920653aa84", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 90, "deletions": 8, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,5 +1,5 @@\n /* Rewrite a program in Normal form into SSA.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n@@ -745,7 +745,17 @@ mark_def_sites (basic_block bb, gimple stmt, bitmap kills)\n   set_rewrite_uses (stmt, false);\n \n   if (is_gimple_debug (stmt))\n-    return;\n+    {\n+      FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  tree sym = USE_FROM_PTR (use_p);\n+\t  gcc_assert (DECL_P (sym));\n+\t  set_rewrite_uses (stmt, true);\n+\t}\n+      if (rewrite_uses_p (stmt))\n+\tSET_BIT (interesting_blocks, bb->index);\n+      return;\n+    }\n \n   /* If a variable is used before being set, then the variable is live\n      across a block boundary, so mark it live-on-entry to BB.  */\n@@ -1279,6 +1289,73 @@ get_reaching_def (tree var)\n }\n \n \n+/* Helper function for rewrite_stmt.  Rewrite uses in a debug stmt.  */\n+\n+static void\n+rewrite_debug_stmt_uses (gimple stmt)\n+{\n+  use_operand_p use_p;\n+  ssa_op_iter iter;\n+  bool update = false;\n+\n+  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+    {\n+      tree var = USE_FROM_PTR (use_p), def = NULL_TREE;\n+      gcc_assert (DECL_P (var));\n+      if (var_ann (var) == NULL)\n+\t{\n+\t  if (TREE_CODE (var) == PARM_DECL && single_succ_p (ENTRY_BLOCK_PTR))\n+\t    {\n+\t      gimple_stmt_iterator gsi\n+\t\t= gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+\t      int lim;\n+\t      /* Search a few source bind stmts at the start of first bb to\n+\t\t see if a DEBUG_EXPR_DECL can't be reused.  */\n+\t      for (lim = 32;\n+\t\t   !gsi_end_p (gsi) && lim > 0;\n+\t\t   gsi_next (&gsi), lim--)\n+\t\t{\n+\t\t  gimple gstmt = gsi_stmt (gsi);\n+\t\t  if (!gimple_debug_source_bind_p (gstmt))\n+\t\t    break;\n+\t\t  if (gimple_debug_source_bind_get_value (gstmt) == var)\n+\t\t    {\n+\t\t      def = gimple_debug_source_bind_get_var (gstmt);\n+\t\t      if (TREE_CODE (def) == DEBUG_EXPR_DECL)\n+\t\t\tbreak;\n+\t\t      else\n+\t\t\tdef = NULL_TREE;\n+\t\t    }\n+\t\t}\n+\t      /* If not, add a new source bind stmt.  */\n+\t      if (def == NULL_TREE)\n+\t\t{\n+\t\t  gimple def_temp;\n+\t\t  def = make_node (DEBUG_EXPR_DECL);\n+\t\t  def_temp = gimple_build_debug_source_bind (def, var, NULL);\n+\t\t  DECL_ARTIFICIAL (def) = 1;\n+\t\t  TREE_TYPE (def) = TREE_TYPE (var);\n+\t\t  DECL_MODE (def) = DECL_MODE (var);\n+\t\t  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+\t\t  gsi_insert_before (&gsi, def_temp, GSI_SAME_STMT);\n+\t\t}\n+\t      update = true;\n+\t    }\n+\t}\n+      else\n+\tdef = get_current_def (var);\n+      if (def == NULL)\n+\t{\n+\t  gimple_debug_bind_reset_value (stmt);\n+\t  update_stmt (stmt);\n+\t  return;\n+\t}\n+      SET_USE (use_p, def);\n+    }\n+  if (update)\n+    update_stmt (stmt);\n+}\n+\n /* SSA Rewriting Step 2.  Rewrite every variable used in each statement in\n    the block with its immediate reaching definitions.  Update the current\n    definition of a variable when a new real or virtual definition is found.  */\n@@ -1306,12 +1383,17 @@ rewrite_stmt (gimple_stmt_iterator si)\n \n   /* Step 1.  Rewrite USES in the statement.  */\n   if (rewrite_uses_p (stmt))\n-    FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n-      {\n-\ttree var = USE_FROM_PTR (use_p);\n-\tgcc_assert (DECL_P (var));\n-\tSET_USE (use_p, get_reaching_def (var));\n-      }\n+    {\n+      if (is_gimple_debug (stmt))\n+\trewrite_debug_stmt_uses (stmt);\n+      else\n+\tFOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n+\t  {\n+\t    tree var = USE_FROM_PTR (use_p);\n+\t    gcc_assert (DECL_P (var));\n+\t    SET_USE (use_p, get_reaching_def (var));\n+\t  }\n+    }\n \n   /* Step 2.  Register the statement's DEF operands.  */\n   if (register_defs_p (stmt))"}, {"sha": "921821d5fbde3072e0a14af691a5208f64496d04", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,5 +1,5 @@\n /* Loop autoparallelization.\n-   Copyright (C) 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <pop@cri.ensmp.fr> and\n    Zdenek Dvorak <dvorakz@suse.cz>.\n@@ -716,8 +716,11 @@ eliminate_local_variables (edge entry, edge exit)\n   FOR_EACH_VEC_ELT (basic_block, body, i, bb)\n     if (bb != entry_bb && bb != exit_bb)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\tif (gimple_debug_bind_p (gsi_stmt (gsi)))\n-\t  has_debug_stmt = true;\n+\tif (is_gimple_debug (gsi_stmt (gsi)))\n+\t  {\n+\t    if (gimple_debug_bind_p (gsi_stmt (gsi)))\n+\t      has_debug_stmt = true;\n+\t  }\n \telse\n \t  eliminate_local_variables_stmt (entry, &gsi, decl_address);\n \n@@ -883,8 +886,8 @@ separate_decls_in_region_stmt (edge entry, edge exit, gimple stmt,\n    replacement decls are stored in DECL_COPIES.  */\n \n static bool\n-separate_decls_in_region_debug_bind (gimple stmt,\n-\t\t\t\t     htab_t name_copies, htab_t decl_copies)\n+separate_decls_in_region_debug (gimple stmt, htab_t name_copies,\n+\t\t\t\thtab_t decl_copies)\n {\n   use_operand_p use;\n   ssa_op_iter oi;\n@@ -893,15 +896,23 @@ separate_decls_in_region_debug_bind (gimple stmt,\n   struct name_to_copy_elt elt;\n   void **slot, **dslot;\n \n-  var = gimple_debug_bind_get_var (stmt);\n+  if (gimple_debug_bind_p (stmt))\n+    var = gimple_debug_bind_get_var (stmt);\n+  else if (gimple_debug_source_bind_p (stmt))\n+    var = gimple_debug_source_bind_get_var (stmt);\n+  else\n+    return true;\n   if (TREE_CODE (var) == DEBUG_EXPR_DECL)\n     return true;\n   gcc_assert (DECL_P (var) && SSA_VAR_P (var));\n   ielt.uid = DECL_UID (var);\n   dslot = htab_find_slot_with_hash (decl_copies, &ielt, ielt.uid, NO_INSERT);\n   if (!dslot)\n     return true;\n-  gimple_debug_bind_set_var (stmt, ((struct int_tree_map *) *dslot)->to);\n+  if (gimple_debug_bind_p (stmt))\n+    gimple_debug_bind_set_var (stmt, ((struct int_tree_map *) *dslot)->to);\n+  else if (gimple_debug_source_bind_p (stmt))\n+    gimple_debug_source_bind_set_var (stmt, ((struct int_tree_map *) *dslot)->to);\n \n   FOR_EACH_PHI_OR_STMT_USE (use, stmt, oi, SSA_OP_USE)\n   {\n@@ -1295,11 +1306,10 @@ separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n \t    {\n \t      gimple stmt = gsi_stmt (gsi);\n \n-\t      if (gimple_debug_bind_p (stmt))\n+\t      if (is_gimple_debug (stmt))\n \t\t{\n-\t\t  if (separate_decls_in_region_debug_bind (stmt,\n-\t\t\t\t\t\t\t   name_copies,\n-\t\t\t\t\t\t\t   decl_copies))\n+\t\t  if (separate_decls_in_region_debug (stmt, name_copies,\n+\t\t\t\t\t\t      decl_copies))\n \t\t    {\n \t\t      gsi_remove (&gsi, true);\n \t\t      continue;"}, {"sha": "b9bb23d62e3c5ab25b069ab29e29f5a59b5f2693", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 70, "deletions": 11, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,7 +1,7 @@\n /* Scalar Replacement of Aggregates (SRA) converts some structure\n    references into scalar references, exposing them to the scalar\n    optimizers.\n-   Copyright (C) 2008, 2009, 2010 Free Software Foundation, Inc.\n+   Copyright (C) 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n    Contributed by Martin Jambor <mjambor@suse.cz>\n \n This file is part of GCC.\n@@ -4282,28 +4282,87 @@ static void\n sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n {\n   int i, len;\n+  gimple_stmt_iterator *gsip = NULL, gsi;\n \n+  if (MAY_HAVE_DEBUG_STMTS && single_succ_p (ENTRY_BLOCK_PTR))\n+    {\n+      gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n+      gsip = &gsi;\n+    }\n   len = VEC_length (ipa_parm_adjustment_t, adjustments);\n   for (i = 0; i < len; i++)\n     {\n       struct ipa_parm_adjustment *adj;\n       imm_use_iterator ui;\n-      gimple stmt;\n-      tree name;\n+      gimple stmt, def_temp;\n+      tree name, vexpr, copy = NULL_TREE;\n+      use_operand_p use_p;\n \n       adj = VEC_index (ipa_parm_adjustment_t, adjustments, i);\n       if (adj->copy_param || !is_gimple_reg (adj->base))\n \tcontinue;\n       name = gimple_default_def (cfun, adj->base);\n-      if (!name)\n-\tcontinue;\n-      FOR_EACH_IMM_USE_STMT (stmt, ui, name)\n+      vexpr = NULL;\n+      if (name)\n+\tFOR_EACH_IMM_USE_STMT (stmt, ui, name)\n+\t  {\n+\t    /* All other users must have been removed by\n+\t       ipa_sra_modify_function_body.  */\n+\t    gcc_assert (is_gimple_debug (stmt));\n+\t    if (vexpr == NULL && gsip != NULL)\n+\t      {\n+\t\tgcc_assert (TREE_CODE (adj->base) == PARM_DECL);\n+\t\tvexpr = make_node (DEBUG_EXPR_DECL);\n+\t\tdef_temp = gimple_build_debug_source_bind (vexpr, adj->base,\n+\t\t\t\t\t\t\t   NULL);\n+\t\tDECL_ARTIFICIAL (vexpr) = 1;\n+\t\tTREE_TYPE (vexpr) = TREE_TYPE (name);\n+\t\tDECL_MODE (vexpr) = DECL_MODE (adj->base);\n+\t\tgsi_insert_before (gsip, def_temp, GSI_SAME_STMT);\n+\t      }\n+\t    if (vexpr)\n+\t      {\n+\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, ui)\n+\t\t  SET_USE (use_p, vexpr);\n+\t      }\n+\t    else\n+\t      gimple_debug_bind_reset_value (stmt);\n+\t    update_stmt (stmt);\n+\t  }\n+      /* Create a VAR_DECL for debug info purposes.  */\n+      if (!DECL_IGNORED_P (adj->base))\n \t{\n-\t  /* All other users must have been removed by\n-\t     ipa_sra_modify_function_body.  */\n-\t  gcc_assert (is_gimple_debug (stmt));\n-\t  gimple_debug_bind_reset_value (stmt);\n-\t  update_stmt (stmt);\n+\t  copy = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t     VAR_DECL, DECL_NAME (adj->base),\n+\t\t\t     TREE_TYPE (adj->base));\n+\t  if (DECL_PT_UID_SET_P (adj->base))\n+\t    SET_DECL_PT_UID (copy, DECL_PT_UID (adj->base));\n+\t  TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (adj->base);\n+\t  TREE_READONLY (copy) = TREE_READONLY (adj->base);\n+\t  TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (adj->base);\n+\t  DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (adj->base);\n+\t  DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (adj->base);\n+\t  DECL_IGNORED_P (copy) = DECL_IGNORED_P (adj->base);\n+\t  DECL_ABSTRACT_ORIGIN (copy) = DECL_ORIGIN (adj->base);\n+\t  DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;\n+\t  SET_DECL_RTL (copy, 0);\n+\t  TREE_USED (copy) = 1;\n+\t  DECL_CONTEXT (copy) = current_function_decl;\n+\t  add_referenced_var (copy);\n+\t  add_local_decl (cfun, copy);\n+\t  DECL_CHAIN (copy) =\n+\t    BLOCK_VARS (DECL_INITIAL (current_function_decl));\n+\t  BLOCK_VARS (DECL_INITIAL (current_function_decl)) = copy;\n+\t}\n+      if (gsip != NULL && copy && target_for_debug_bind (adj->base))\n+\t{\n+\t  gcc_assert (TREE_CODE (adj->base) == PARM_DECL);\n+\t  if (vexpr)\n+\t    def_temp = gimple_build_debug_bind (copy, vexpr, NULL);\n+\t  else\n+\t    def_temp = gimple_build_debug_source_bind (copy, adj->base,\n+\t\t\t\t\t\t       NULL);\n+\t  gsi_insert_before (gsip, def_temp, GSI_SAME_STMT);\n \t}\n     }\n }"}, {"sha": "6900ee77e869570aba49b40299a8a82fcf614e31", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,5 +1,5 @@\n /* Dead code elimination pass for the GNU compiler.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Ben Elliston <bje@redhat.com>\n    and Andrew MacLeod <amacleod@redhat.com>\n@@ -316,7 +316,8 @@ mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n \t easily locate the debug temp bind stmt for a use thereof,\n \t would could refrain from marking all debug temps here, and\n \t mark them only if they're used.  */\n-      if (gimple_debug_bind_has_value_p (stmt)\n+      if (!gimple_debug_bind_p (stmt)\n+\t  || gimple_debug_bind_has_value_p (stmt)\n \t  || TREE_CODE (gimple_debug_bind_get_var (stmt)) != DEBUG_EXPR_DECL)\n \tmark_stmt_necessary (stmt, false);\n       return;"}, {"sha": "28720340bab9223482b941a79dc5bb8ecb4a5c63", "filename": "gcc/tree.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -203,6 +203,9 @@ static GTY ((if_marked (\"tree_decl_map_marked_p\"), param_is (struct tree_decl_ma\n static GTY ((if_marked (\"tree_decl_map_marked_p\"), param_is (struct tree_decl_map)))\n      htab_t value_expr_for_decl;\n \n+static GTY ((if_marked (\"tree_vec_map_marked_p\"), param_is (struct tree_vec_map)))\n+     htab_t debug_args_for_decl;\n+\n static GTY ((if_marked (\"tree_priority_map_marked_p\"),\n \t     param_is (struct tree_priority_map)))\n   htab_t init_priority_for_decl;\n@@ -6016,6 +6019,49 @@ decl_value_expr_insert (tree from, tree to)\n   *(struct tree_decl_map **) loc = h;\n }\n \n+/* Lookup a vector of debug arguments for FROM, and return it if we\n+   find one.  */\n+\n+VEC(tree, gc) **\n+decl_debug_args_lookup (tree from)\n+{\n+  struct tree_vec_map *h, in;\n+\n+  if (!DECL_HAS_DEBUG_ARGS_P (from))\n+    return NULL;\n+  gcc_checking_assert (debug_args_for_decl != NULL);\n+  in.base.from = from;\n+  h = (struct tree_vec_map *)\n+      htab_find_with_hash (debug_args_for_decl, &in, DECL_UID (from));\n+  if (h)\n+    return &h->to;\n+  return NULL;\n+}\n+\n+/* Insert a mapping FROM->empty vector of debug arguments in the value\n+   expression hashtable.  */\n+\n+VEC(tree, gc) **\n+decl_debug_args_insert (tree from)\n+{\n+  struct tree_vec_map *h;\n+  void **loc;\n+\n+  if (DECL_HAS_DEBUG_ARGS_P (from))\n+    return decl_debug_args_lookup (from);\n+  if (debug_args_for_decl == NULL)\n+    debug_args_for_decl = htab_create_ggc (64, tree_vec_map_hash,\n+\t\t\t\t\t   tree_vec_map_eq, 0);\n+  h = ggc_alloc_tree_vec_map ();\n+  h->base.from = from;\n+  h->to = NULL;\n+  loc = htab_find_slot_with_hash (debug_args_for_decl, h, DECL_UID (from),\n+\t\t\t\t  INSERT);\n+  *(struct tree_vec_map **) loc = h;\n+  DECL_HAS_DEBUG_ARGS_P (from) = 1;\n+  return &h->to;\n+}\n+\n /* Hashing of types so that we don't make duplicates.\n    The entry point is `type_hash_canon'.  */\n "}, {"sha": "1d1bb31f579507c64422577fcfe1c248e5f9b8a0", "filename": "gcc/tree.h", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,6 +1,6 @@\n /* Front-end tree definitions for GNU compiler.\n    Copyright (C) 1989, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -3431,6 +3431,13 @@ struct GTY(())\n #define DECL_DISREGARD_INLINE_LIMITS(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->function_decl.disregard_inline_limits)\n \n+extern VEC(tree, gc) **decl_debug_args_lookup (tree);\n+extern VEC(tree, gc) **decl_debug_args_insert (tree);\n+\n+/* Nonzero if a FUNCTION_DECL has DEBUG arguments attached to it.  */\n+#define DECL_HAS_DEBUG_ARGS_P(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->function_decl.has_debug_args_flag)\n+\n /* For FUNCTION_DECL, this holds a pointer to a structure (\"struct function\")\n    that describes the status of this function.  */\n #define DECL_STRUCT_FUNCTION(NODE) \\\n@@ -3496,16 +3503,16 @@ struct GTY(()) tree_function_decl {\n   unsigned operator_new_flag : 1;\n   unsigned declared_inline_flag : 1;\n   unsigned regdecl_flag : 1;\n-\n   unsigned no_inline_warning_flag : 1;\n+\n   unsigned no_instrument_function_entry_exit : 1;\n   unsigned no_limit_stack : 1;\n   unsigned disregard_inline_limits : 1;\n   unsigned pure_flag : 1;\n   unsigned looping_const_or_pure_flag : 1;\n+  unsigned has_debug_args_flag : 1;\n \n-\n-  /* 3 bits left */\n+  /* 2 bits left */\n };\n \n /* The source language of the translation-unit.  */\n@@ -5742,6 +5749,17 @@ struct GTY(()) tree_priority_map {\n #define tree_priority_map_hash tree_map_base_hash\n #define tree_priority_map_marked_p tree_map_base_marked_p\n \n+/* Map from a decl tree to a tree vector.  */\n+\n+struct GTY(()) tree_vec_map {\n+  struct tree_map_base base;\n+  VEC(tree,gc) *to;\n+};\n+\n+#define tree_vec_map_eq tree_map_base_eq\n+#define tree_vec_map_hash tree_decl_map_hash\n+#define tree_vec_map_marked_p tree_map_base_marked_p\n+\n /* In tree-ssa.c */\n \n tree target_for_debug_bind (tree);"}, {"sha": "b3f84a17044e95635a286f815fca90c8121ae101", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -5812,6 +5812,29 @@ prepare_call_arguments (basic_block bb, rtx insn)\n \t  }\n       }\n \n+  /* Add debug arguments.  */\n+  if (fndecl\n+      && TREE_CODE (fndecl) == FUNCTION_DECL\n+      && DECL_HAS_DEBUG_ARGS_P (fndecl))\n+    {\n+      VEC(tree, gc) **debug_args = decl_debug_args_lookup (fndecl);\n+      if (debug_args)\n+\t{\n+\t  unsigned int ix;\n+\t  tree param;\n+\t  for (ix = 0; VEC_iterate (tree, *debug_args, ix, param); ix += 2)\n+\t    {\n+\t      rtx item;\n+\t      tree dtemp = VEC_index (tree, *debug_args, ix + 1);\n+\t      enum machine_mode mode = DECL_MODE (dtemp);\n+\t      item = gen_rtx_DEBUG_PARAMETER_REF (mode, param);\n+\t      item = gen_rtx_CONCAT (mode, item, DECL_RTL (dtemp));\n+\t      call_arguments = gen_rtx_EXPR_LIST (VOIDmode, item,\n+\t\t\t\t\t\t  call_arguments);\n+\t    }\n+\t}\n+    }\n+\n   /* Reverse call_arguments chain.  */\n   prev = NULL_RTX;\n   for (cur = call_arguments; cur; cur = next)"}, {"sha": "e4a6bcae4f9af05c07417241c8bca2de65af27f2", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -1,3 +1,8 @@\n+2011-06-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/47858\n+\t* dwarf2.h (enum dwarf_location_atom): Add DW_OP_GNU_parameter_ref.\n+\n 2011-06-13  Jan Kratochvil  <jan.kratochvil@redhat.com>\n \n \t* demangle.h (DMGL_RET_POSTFIX): Extend the comment."}, {"sha": "b2806ef78c9083abfe3762e86d7a3a5fedaa8b76", "filename": "include/dwarf2.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb555ed5129279c1bbe74574507ad67fff22e5e/include%2Fdwarf2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb555ed5129279c1bbe74574507ad67fff22e5e/include%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdwarf2.h?ref=ddb555ed5129279c1bbe74574507ad67fff22e5e", "patch": "@@ -563,6 +563,8 @@ enum dwarf_location_atom\n     DW_OP_GNU_deref_type = 0xf6,\n     DW_OP_GNU_convert = 0xf7,\n     DW_OP_GNU_reinterpret = 0xf9,\n+    /* The GNU parameter ref extension.  */\n+    DW_OP_GNU_parameter_ref = 0xfa,\n     /* HP extensions.  */\n     DW_OP_HP_unknown     = 0xe0, /* Ouch, the same as GNU_push_tls_address.  */\n     DW_OP_HP_is_value    = 0xe1,"}]}