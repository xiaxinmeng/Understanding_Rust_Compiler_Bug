{"sha": "818c0c94935c342158a0106db55eba9317cc913f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE4YzBjOTQ5MzVjMzQyMTU4YTAxMDZkYjU1ZWJhOTMxN2NjOTEzZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-07T05:44:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-05-07T05:44:26Z"}, "message": "re PR c++/6212 (g++ testsuite EH regressions for irix6 -mabi=64)\n\n        PR c++/6212\n        * expr.c (highest_pow2_factor_for_type): New.\n        (expand_assignment): Use it.\n\nFrom-SVN: r53249", "tree": {"sha": "af5dd9b0c303db6988e7f7897689bf5a11fa2377", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af5dd9b0c303db6988e7f7897689bf5a11fa2377"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/818c0c94935c342158a0106db55eba9317cc913f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818c0c94935c342158a0106db55eba9317cc913f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/818c0c94935c342158a0106db55eba9317cc913f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818c0c94935c342158a0106db55eba9317cc913f/comments", "author": null, "committer": null, "parents": [{"sha": "486e8c0cd34a187feb4adf908c183274a93cb654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/486e8c0cd34a187feb4adf908c183274a93cb654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/486e8c0cd34a187feb4adf908c183274a93cb654"}], "stats": {"total": 35, "additions": 29, "deletions": 6}, "files": [{"sha": "0c54cdeb82f8a12b53ec78f0bc2886a71723457d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818c0c94935c342158a0106db55eba9317cc913f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818c0c94935c342158a0106db55eba9317cc913f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=818c0c94935c342158a0106db55eba9317cc913f", "patch": "@@ -1,8 +1,14 @@\n+2002-05-06  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c++/6212\n+\t* expr.c (highest_pow2_factor_for_type): New.\n+\t(expand_assignment): Use it.\n+\n 2002-05-06  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/rs6000.md (\"altivec_mtvscr\"): Change to\n-        unspec_volatile.\n-        (\"altivec_mfvscr\"): Same.\n+\t* config/rs6000/rs6000.md (\"altivec_mtvscr\"): Change to\n+\tunspec_volatile.\n+\t(\"altivec_mfvscr\"): Same.\n \n 2002-05-06  Janis Johnson  <janis187@us.ibm.com>\n \n@@ -26,7 +32,7 @@\n \tPR opt/3995\n \t* fold-const.c (sign_bit_p): New function.\n \t(fold) [EQ_EXPR]: Use this to convert (A & C) == 0 into A >= 0 and\n-        (A & C) != 0 into A < 0, when constant C is the sign bit of A's type.\n+\t(A & C) != 0 into A < 0, when constant C is the sign bit of A's type.\n \tReapply fold when converting (A & C) == C into (A & C) != 0.\n \t(fold_binary_op_with_conditional_arg): Fix typo in comment.\n \n@@ -85,7 +91,7 @@ doc:\n 2002-05-06  Catherine Moore  <clm@redhat.com>\n \n \t* config/v850/v850.c (compute_register_save_size): Make sure\n-        to count all of the registers that will be saved.\n+\tto count all of the registers that will be saved.\n \n Mon May  6 18:03:11 CEST 2002  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "84443e014e6e115afcaab3b54d36656d6b077128", "filename": "gcc/expr.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818c0c94935c342158a0106db55eba9317cc913f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818c0c94935c342158a0106db55eba9317cc913f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=818c0c94935c342158a0106db55eba9317cc913f", "patch": "@@ -147,6 +147,7 @@ static rtx store_field\t\tPARAMS ((rtx, HOST_WIDE_INT,\n \t\t\t\t\t int));\n static rtx var_rtx\t\tPARAMS ((tree));\n static HOST_WIDE_INT highest_pow2_factor PARAMS ((tree));\n+static HOST_WIDE_INT highest_pow2_factor_for_type PARAMS ((tree, tree));\n static int is_aligning_offset\tPARAMS ((tree, tree));\n static rtx expand_increment\tPARAMS ((tree, int, int));\n static void do_jump_by_parts_greater PARAMS ((tree, int, rtx, rtx));\n@@ -3707,7 +3708,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t    }\n \n \t  to_rtx = offset_address (to_rtx, offset_rtx,\n-\t\t\t\t   highest_pow2_factor (offset));\n+\t\t\t\t   highest_pow2_factor_for_type (TREE_TYPE (to),\n+\t\t\t\t\t\t\t\t offset));\n \t}\n \n       if (GET_CODE (to_rtx) == MEM)\n@@ -5934,6 +5936,21 @@ highest_pow2_factor (exp)\n \n   return 1;\n }\n+\n+/* Similar, except that it is known that the expression must be a multiple\n+   of the alignment of TYPE.  */\n+\n+static HOST_WIDE_INT\n+highest_pow2_factor_for_type (type, exp)\n+     tree type;\n+     tree exp;\n+{\n+  HOST_WIDE_INT type_align, factor;\n+\n+  factor = highest_pow2_factor (exp);\n+  type_align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n+  return MAX (factor, type_align);\n+}\n \f\n /* Return an object on the placeholder list that matches EXP, a\n    PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the"}]}