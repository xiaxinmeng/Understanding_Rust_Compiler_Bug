{"sha": "93d455621810ca1fcb759fcb6cc4c237ba02a584", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNkNDU1NjIxODEwY2ExZmNiNzU5ZmNiNmNjNGMyMzdiYTAyYTU4NA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-11-25T00:36:51Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-11-25T00:36:51Z"}, "message": "prims.cc (_Jv_NewObjectArray): Use _Jv_GetArrayElementFromElementType.\n\n\t* prims.cc (_Jv_NewObjectArray): Use\n\t_Jv_GetArrayElementFromElementType.\n\t(_Jv_NewPrimArray): Likewise.\n\t* java/lang/natObject.cc (clone): Use\n\t_Jv_GetArrayElementFromElementType instead of sizeof.\n\t* java/lang/natSystem.cc (arraycopy): Use\n\t_Jv_GetArrayElementFromElementType.\n\t* include/jvm.h (_Jv_GetArrayElementFromElementType): New\n\tfunction.\n\nFrom-SVN: r30655", "tree": {"sha": "35bb29ca80faf5479ebdd7ea3a0fbd2086f9fc89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35bb29ca80faf5479ebdd7ea3a0fbd2086f9fc89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93d455621810ca1fcb759fcb6cc4c237ba02a584", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93d455621810ca1fcb759fcb6cc4c237ba02a584", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93d455621810ca1fcb759fcb6cc4c237ba02a584", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93d455621810ca1fcb759fcb6cc4c237ba02a584/comments", "author": null, "committer": null, "parents": [{"sha": "fc39d3710887c5a0d560d93e29e8c222d40bf072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc39d3710887c5a0d560d93e29e8c222d40bf072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc39d3710887c5a0d560d93e29e8c222d40bf072"}], "stats": {"total": 114, "additions": 63, "deletions": 51}, "files": [{"sha": "a2830124ef7e449fd855fbb06b4c0f3651cc18b2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=93d455621810ca1fcb759fcb6cc4c237ba02a584", "patch": "@@ -1,3 +1,15 @@\n+1999-11-24  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* prims.cc (_Jv_NewObjectArray): Use\n+\t_Jv_GetArrayElementFromElementType.\n+\t(_Jv_NewPrimArray): Likewise.\n+\t* java/lang/natObject.cc (clone): Use\n+\t_Jv_GetArrayElementFromElementType instead of sizeof.\n+\t* java/lang/natSystem.cc (arraycopy): Use\n+\t_Jv_GetArrayElementFromElementType.\n+\t* include/jvm.h (_Jv_GetArrayElementFromElementType): New\n+\tfunction.\n+\n 1999-11-23  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/net/natPlainSocketImpl.cc: Fix potential buffer overruns in"}, {"sha": "33925d34d78b8d629f3493dc179d5a3fd53df73b", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=93d455621810ca1fcb759fcb6cc4c237ba02a584", "patch": "@@ -114,6 +114,36 @@ _Jv_HashCode (jobject obj)\n   return (jint) obj;\n }\n \n+// Return a raw pointer to the elements of an array given the array\n+// and its element type.  You might think we could just pick a single\n+// array type and use elements() on it, but we can't because we must\n+// account for alignment of the element type.\n+inline char *\n+_Jv_GetArrayElementFromElementType (jobject array,\n+\t\t\t\t    jclass element_type)\n+{\n+  char *elts;\n+  if (element_type == JvPrimClass (byte))\n+    elts = (char *) elements ((jbyteArray) array);\n+  else if (element_type == JvPrimClass (short))\n+    elts = (char *) elements ((jshortArray) array);\n+  else if (element_type == JvPrimClass (int))\n+    elts = (char *) elements ((jintArray) array);\n+  else if (element_type == JvPrimClass (long))\n+    elts = (char *) elements ((jlongArray) array);\n+  else if (element_type == JvPrimClass (boolean))\n+    elts = (char *) elements ((jbooleanArray) array);\n+  else if (element_type == JvPrimClass (char))\n+    elts = (char *) elements ((jcharArray) array);\n+  else if (element_type == JvPrimClass (float))\n+    elts = (char *) elements ((jfloatArray) array);\n+  else if (element_type == JvPrimClass (double))\n+    elts = (char *) elements ((jdoubleArray) array);\n+  else\n+    elts = (char *) elements ((jobjectArray) array);\n+  return elts;\n+}\n+\n extern \"C\" void _Jv_ThrowBadArrayIndex (jint bad_index);\n extern \"C\" jobject _Jv_NewArray (jint type, jint size);\n extern \"C\" jobject _Jv_NewMultiArray (jclass klass, jint dims, ...);"}, {"sha": "0ca5a58fbc3b72b98e38ed80e1251f3ebe033d4f", "filename": "libjava/java/lang/natObject.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2Fjava%2Flang%2FnatObject.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2Fjava%2Flang%2FnatObject.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatObject.cc?ref=93d455621810ca1fcb759fcb6cc4c237ba02a584", "patch": "@@ -84,7 +84,10 @@ java::lang::Object::clone (void)\n \t  r = _Jv_NewObjectArray (array->length, comp, NULL);\n \t  eltsize = sizeof (jobject);\n \t}\n-      size = sizeof (__JArray) + array->length * eltsize;\n+      // We can't use sizeof on __JArray because we must account for\n+      // alignment of the element type.\n+      size = (_Jv_GetArrayElementFromElementType (array, comp) - (char *) array\n+\t      + array->length * eltsize);\n     }\n   else\n     {"}, {"sha": "4e4316a1ef0bc76e120d0522cf9e18015689d27e", "filename": "libjava/java/lang/natSystem.cc", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2Fjava%2Flang%2FnatSystem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2Fjava%2Flang%2FnatSystem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatSystem.cc?ref=93d455621810ca1fcb759fcb6cc4c237ba02a584", "patch": "@@ -124,52 +124,10 @@ java::lang::System::arraycopy (jobject src, jint src_offset,\n       const size_t size = (prim ? src_comp->size()\n \t\t\t   : sizeof elements((jobjectArray)src)[0]);\n \n-      // In an ideal world we would do this via a virtual function in\n-      // __JArray.  However, we can't have virtual functions in\n-      // __JArray due to the need to copy an array's virtual table in\n-      // _Jv_FindArrayClass.\n-      // We can't just pick a single subtype of __JArray to use due to\n-      // alignment concerns.\n-      char *src_elts = NULL;\n-      if (! prim)\n-\tsrc_elts = (char *) elements ((jobjectArray) src);\n-      else if (src_comp == JvPrimClass (byte))\n-\tsrc_elts = (char *) elements ((jbyteArray) src);\n-      else if (src_comp == JvPrimClass (short))\n-\tsrc_elts = (char *) elements ((jshortArray) src);\n-      else if (src_comp == JvPrimClass (int))\n-\tsrc_elts = (char *) elements ((jintArray) src);\n-      else if (src_comp == JvPrimClass (long))\n-\tsrc_elts = (char *) elements ((jlongArray) src);\n-      else if (src_comp == JvPrimClass (boolean))\n-\tsrc_elts = (char *) elements ((jbooleanArray) src);\n-      else if (src_comp == JvPrimClass (char))\n-\tsrc_elts = (char *) elements ((jcharArray) src);\n-      else if (src_comp == JvPrimClass (float))\n-\tsrc_elts = (char *) elements ((jfloatArray) src);\n-      else if (src_comp == JvPrimClass (double))\n-\tsrc_elts = (char *) elements ((jdoubleArray) src);\n+      char *src_elts = _Jv_GetArrayElementFromElementType (src, src_comp);\n       src_elts += size * src_offset;\n \n-      char *dst_elts = NULL;\n-      if (! prim)\n-\tdst_elts = (char *) elements ((jobjectArray) dst);\n-      else if (dst_comp == JvPrimClass (byte))\n-\tdst_elts = (char *) elements ((jbyteArray) dst);\n-      else if (dst_comp == JvPrimClass (short))\n-\tdst_elts = (char *) elements ((jshortArray) dst);\n-      else if (dst_comp == JvPrimClass (int))\n-\tdst_elts = (char *) elements ((jintArray) dst);\n-      else if (dst_comp == JvPrimClass (long))\n-\tdst_elts = (char *) elements ((jlongArray) dst);\n-      else if (dst_comp == JvPrimClass (boolean))\n-\tdst_elts = (char *) elements ((jbooleanArray) dst);\n-      else if (dst_comp == JvPrimClass (char))\n-\tdst_elts = (char *) elements ((jcharArray) dst);\n-      else if (dst_comp == JvPrimClass (float))\n-\tdst_elts = (char *) elements ((jfloatArray) dst);\n-      else if (dst_comp == JvPrimClass (double))\n-\tdst_elts = (char *) elements ((jdoubleArray) dst);\n+      char *dst_elts = _Jv_GetArrayElementFromElementType (dst, dst_comp);\n       dst_elts += size * dst_offset;\n \n #if HAVE_MEMMOVE"}, {"sha": "7f73047aa9d19c7b00cecbcb16cdc7087b5a701b", "filename": "libjava/prims.cc", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93d455621810ca1fcb759fcb6cc4c237ba02a584/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=93d455621810ca1fcb759fcb6cc4c237ba02a584", "patch": "@@ -328,16 +328,22 @@ _Jv_NewObjectArray (jsize count, jclass elementClass, jobject init)\n   if (count < 0)\n     JvThrow (new java::lang::NegativeArraySizeException);\n \n+  JvAssert (! elementClass->isPrimitive ());\n+\n+  jobjectArray obj = NULL;\n+  size_t size = (size_t) _Jv_GetArrayElementFromElementType (obj,\n+\t\t\t\t\t\t\t     elementClass);\n+\n   // Check for overflow.\n-  if ((size_t) count > (SIZE_T_MAX - sizeof (__JArray)) / sizeof (jobject))\n+  if ((size_t) count > (SIZE_T_MAX - size) / sizeof (jobject))\n     JvThrow (no_memory);\n \n-  size_t size = count * sizeof (jobject) + sizeof (__JArray);\n+  size += count * sizeof (jobject);\n \n   // FIXME: second argument should be \"current loader\" //\n   jclass clas = _Jv_FindArrayClass (elementClass, 0);\n \n-  jobjectArray obj = (jobjectArray) _Jv_AllocArray (size);\n+  obj = (jobjectArray) _Jv_AllocArray (size);\n   if (! obj)\n     JvThrow (no_memory);\n   obj->length = count;\n@@ -365,12 +371,15 @@ _Jv_NewPrimArray (jclass eltype, jint count)\n   if (count < 0)\n     JvThrow (new java::lang::NegativeArraySizeException ());\n \n+  JvAssert (eltype->isPrimitive ());\n+  jobject dummy = NULL;\n+  size_t size = (size_t) _Jv_GetArrayElementFromElementType (dummy, eltype);\n+\n   // Check for overflow.\n-  if ((size_t) count > (SIZE_T_MAX - sizeof (__JArray)) / elsize)\n+  if ((size_t) count > (SIZE_T_MAX - size) / elsize)\n     JvThrow (no_memory);\n \n-  __JArray *arr = (__JArray*) _Jv_AllocObj (sizeof (__JArray)\n-\t\t\t\t\t    + elsize * count);\n+  __JArray *arr = (__JArray*) _Jv_AllocObj (size + elsize * count);\n   if (! arr)\n     JvThrow (no_memory);\n   arr->length = count;"}]}