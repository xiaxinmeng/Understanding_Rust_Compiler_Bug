{"sha": "b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYzZDYxZjdkMTI1NmMyNTUwMTNhZjZlYTRiMGY2NGJkZDZkNzM0MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:57:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:57:00Z"}, "message": "[multiple changes]\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-cofuse.adb, a-cfdlli.adb, a-cofuse.ads, a-cfdlli.ads, a-cofuve.adb,\n\ta-cofuve.ads, a-cofuma.adb, a-cofuma.ads, sem_eval.adb, a-cofuba.adb:\n\tMinor reformatting.\n\n2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Call): If the return type of a function\n\tis incomplete in an context in which the full view is available,\n\treplace the type of the call by the full view, to prevent spurious\n\ttype errors.\n\t* exp_disp.adb (Check_Premature_Freezing): Disable check on an\n\tabstract subprogram so that compiler does not reject a parameter\n\tof a primitive operation of a tagged type being frozen, when\n\tthe untagged type of that parameter cannot be frozen.\n\n2017-04-27  Bob Duff  <duff@adacore.com>\n\n\t* sem_attr.adb (Compute_Type_Key): Don't walk\n\trepresentation items for irrelevant types, which could be in a\n\tdifferent source file.\n\n2017-04-27  Steve Baird  <baird@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference):\n\tDon't expand Image, Wide_Image, Wide_Wide_Image attributes\n\tfor CodePeer.\n\nFrom-SVN: r247305", "tree": {"sha": "e3ecd4e087cb6d587db234fbb131aea9674974c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3ecd4e087cb6d587db234fbb131aea9674974c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/comments", "author": null, "committer": null, "parents": [{"sha": "bb9e2aa27576a5dc46bc679949309de4c1600132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9e2aa27576a5dc46bc679949309de4c1600132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb9e2aa27576a5dc46bc679949309de4c1600132"}], "stats": {"total": 2192, "additions": 1252, "deletions": 940}, "files": [{"sha": "3baef3c2e79974b06baa8aa7fc39bb6522417322", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -1,3 +1,32 @@\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-cofuse.adb, a-cfdlli.adb, a-cofuse.ads, a-cfdlli.ads, a-cofuve.adb,\n+\ta-cofuve.ads, a-cofuma.adb, a-cofuma.ads, sem_eval.adb, a-cofuba.adb:\n+\tMinor reformatting.\n+\n+2017-04-27  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Call): If the return type of a function\n+\tis incomplete in an context in which the full view is available,\n+\treplace the type of the call by the full view, to prevent spurious\n+\ttype errors.\n+\t* exp_disp.adb (Check_Premature_Freezing): Disable check on an\n+\tabstract subprogram so that compiler does not reject a parameter\n+\tof a primitive operation of a tagged type being frozen, when\n+\tthe untagged type of that parameter cannot be frozen.\n+\n+2017-04-27  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_attr.adb (Compute_Type_Key): Don't walk\n+\trepresentation items for irrelevant types, which could be in a\n+\tdifferent source file.\n+\n+2017-04-27  Steve Baird  <baird@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference):\n+\tDon't expand Image, Wide_Image, Wide_Wide_Image attributes\n+\tfor CodePeer.\n+\n 2017-04-27  Yannick Moy  <moy@adacore.com>\n \n \t* exp_unst.ads: Fix typos in comments."}, {"sha": "84596ee285028f40a8cd2c616e084d985a4322c3", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 108, "deletions": 89, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -30,7 +30,6 @@ with System; use type System.Address;\n package body Ada.Containers.Formal_Doubly_Linked_Lists with\n   SPARK_Mode => Off\n is\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -55,8 +54,9 @@ is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (Left, Right : List) return Boolean is\n-      LI, RI : Count_Type;\n+   function \"=\" (Left : List; Right : List) return Boolean is\n+      LI : Count_Type;\n+      RI : Count_Type;\n \n    begin\n       if Left'Address = Right'Address then\n@@ -230,10 +230,10 @@ is\n          N := N + 1;\n       end loop;\n \n-      P.Free := Source.Free;\n+      P.Free   := Source.Free;\n       P.Length := Source.Length;\n-      P.First := Source.First;\n-      P.Last := Source.Last;\n+      P.First  := Source.First;\n+      P.Last   := Source.Last;\n \n       if P.Free >= 0 then\n          N := Source.Capacity + 1;\n@@ -250,14 +250,12 @@ is\n    -- Delete --\n    ------------\n \n-   procedure Delete\n-     (Container : in out List;\n-      Position  : in out Cursor)\n-   is\n+   procedure Delete (Container : in out List; Position : in out Cursor) is\n    begin\n-      Delete (Container => Container,\n-              Position  => Position,\n-              Count     => 1);\n+      Delete\n+        (Container => Container,\n+         Position  => Position,\n+         Count     => 1);\n    end Delete;\n \n    procedure Delete\n@@ -272,8 +270,7 @@ is\n       if not Has_Element (Container => Container,\n                           Position  => Position)\n       then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n@@ -317,24 +314,22 @@ is\n \n          Free (Container, X);\n       end loop;\n+\n       Position := No_Element;\n    end Delete;\n \n    ------------------\n    -- Delete_First --\n    ------------------\n \n-   procedure Delete_First (Container : in out List)\n-   is\n+   procedure Delete_First (Container : in out List) is\n    begin\n-      Delete_First (Container => Container,\n-                    Count     => 1);\n+      Delete_First\n+        (Container => Container,\n+         Count     => 1);\n    end Delete_First;\n \n-   procedure Delete_First\n-     (Container : in out List;\n-      Count     : Count_Type)\n-   is\n+   procedure Delete_First (Container : in out List; Count : Count_Type) is\n       N : Node_Array renames Container.Nodes;\n       X : Count_Type;\n \n@@ -365,17 +360,14 @@ is\n    -- Delete_Last --\n    -----------------\n \n-   procedure Delete_Last (Container : in out List)\n-   is\n+   procedure Delete_Last (Container : in out List) is\n    begin\n-      Delete_Last (Container => Container,\n-                   Count     => 1);\n+      Delete_Last\n+        (Container => Container,\n+         Count     => 1);\n    end Delete_Last;\n \n-   procedure Delete_Last\n-     (Container : in out List;\n-      Count     : Count_Type)\n-   is\n+   procedure Delete_Last (Container : in out List; Count : Count_Type) is\n       N : Node_Array renames Container.Nodes;\n       X : Count_Type;\n \n@@ -412,8 +404,7 @@ is\n    is\n    begin\n       if not Has_Element (Container => Container, Position  => Position) then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       return Container.Nodes (Position.Node).Element;\n@@ -442,8 +433,7 @@ is\n       if Position.Node /= 0 and then\n         not Has_Element (Container, Position)\n       then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n+         raise Constraint_Error with \"Position cursor has no element\";\n       end if;\n \n       while From /= 0 loop\n@@ -476,6 +466,7 @@ is\n \n    function First_Element (Container : List) return Element_Type is\n       F : constant Count_Type := Container.First;\n+\n    begin\n       if F = 0 then\n          raise Constraint_Error with \"list is empty\";\n@@ -500,8 +491,12 @@ is\n       -- M_Elements_Reversed --\n       -------------------------\n \n-      function M_Elements_Reversed (Left, Right : M.Sequence) return Boolean is\n+      function M_Elements_Reversed\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean\n+      is\n          L : constant Count_Type := M.Length (Left);\n+\n       begin\n          if L /= M.Length (Right) then\n             return False;\n@@ -533,11 +528,13 @@ is\n             declare\n                Found : Boolean := False;\n                J     : Count_Type := Fst;\n+\n             begin\n                while not Found and J <= Lst loop\n                   if Element (Left, I) = Element (Right, J + Offset) then\n                      Found := True;\n                   end if;\n+\n                   J := J + 1;\n                end loop;\n \n@@ -546,6 +543,7 @@ is\n                end if;\n             end;\n          end loop;\n+\n          return True;\n       end M_Elements_Shuffle;\n \n@@ -556,7 +554,8 @@ is\n       function M_Elements_Swapped\n         (Left  : M.Sequence;\n          Right : M.Sequence;\n-         X, Y  : Positive_Count_Type) return Boolean\n+         X     : Positive_Count_Type;\n+         Y     : Positive_Count_Type) return Boolean\n       is\n       begin\n          if M.Length (Left) /= M.Length (Right)\n@@ -584,13 +583,16 @@ is\n       function Model (Container : List) return M.Sequence is\n          Position : Count_Type := Container.First;\n          R        : M.Sequence;\n+\n       begin\n-         --  Can't use First, Next or Element here, since they depend\n-         --  on models for their postconditions\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n          while Position /= 0 loop\n             R := M.Add (R, Container.Nodes (Position).Element);\n             Position := Container.Nodes (Position).Next;\n          end loop;\n+\n          return R;\n       end Model;\n \n@@ -607,10 +609,10 @@ is\n       begin\n          for C of P_Left loop\n             if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left, C) > M.Length (M_Left)\n+              or else P.Get (P_Left,  C) > M.Length (M_Left)\n               or else P.Get (P_Right, C) > M.Length (M_Right)\n-              or else M.Get (M_Left, P.Get (P_Left, C))\n-                   /= M.Get (M_Right, P.Get (P_Right, C))\n+              or else M.Get (M_Left,  P.Get (P_Left,  C)) /=\n+                      M.Get (M_Right, P.Get (P_Right, C))\n             then\n                return False;\n             end if;\n@@ -645,25 +647,30 @@ is\n          for Cu of Big loop\n             declare\n                Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n+\n             begin\n                if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu) or else Pos /= P.Get (Small, Cu)\n+                  if not P.Has_Key (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu)\n                   then\n                      return False;\n                   end if;\n+\n                elsif Pos >= Cut + Count then\n                   if not P.Has_Key (Small, Cu)\n                     or else Pos /= P.Get (Small, Cu) + Count\n                   then\n                      return False;\n                   end if;\n+\n                else\n                   if P.Has_Key (Small, Cu) then\n                      return False;\n                   end if;\n                end if;\n             end;\n          end loop;\n+\n          return True;\n       end P_Positions_Shifted;\n \n@@ -674,17 +681,20 @@ is\n       function P_Positions_Swapped\n         (Left  : P.Map;\n          Right : P.Map;\n-         X, Y  : Cursor) return Boolean\n+         X     : Cursor;\n+         Y     : Cursor) return Boolean\n       is\n       begin\n-         if not P.Has_Key (Left, X) or not P.Has_Key (Left, Y)\n-           or not P.Has_Key (Right, X) or not P.Has_Key (Right, Y)\n+         if not P.Has_Key (Left, X)\n+           or not P.Has_Key (Left, Y)\n+           or not P.Has_Key (Right, X)\n+           or not P.Has_Key (Right, Y)\n          then\n             return False;\n          end if;\n \n          if P.Get (Left, X) /= P.Get (Right, Y)\n-             or P.Get (Left, Y) /= P.Get (Right, X)\n+           or P.Get (Left, Y) /= P.Get (Right, X)\n          then\n             return False;\n          end if;\n@@ -698,7 +708,7 @@ is\n          for C of Right loop\n             if not P.Has_Key (Left, C)\n               or else (C /= X and C /= Y\n-                       and P.Get (Left, C) /= P.Get (Right, C))\n+                        and P.Get (Left, C) /= P.Get (Right, C))\n             then\n                return False;\n             end if;\n@@ -727,19 +737,24 @@ is\n          for Cu of Big loop\n             declare\n                Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n+\n             begin\n                if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu) or else Pos /= P.Get (Small, Cu)\n+                  if not P.Has_Key (Small, Cu)\n+                    or else Pos /= P.Get (Small, Cu)\n                   then\n                      return False;\n                   end if;\n+\n                elsif Pos >= Cut + Count then\n                   return False;\n+\n                elsif P.Has_Key (Small, Cu) then\n                   return False;\n                end if;\n             end;\n          end loop;\n+\n          return True;\n       end P_Positions_Truncated;\n \n@@ -748,18 +763,21 @@ is\n       ---------------\n \n       function Positions (Container : List) return P.Map is\n+         I        : Count_Type := 1;\n          Position : Count_Type := Container.First;\n          R        : P.Map;\n-         I        : Count_Type := 1;\n+\n       begin\n-         --  Can't use First, Next or Element here, since they depend\n-         --  on models for their postconditions\n+         --  Can't use First, Next or Element here, since they depend on models\n+         --  for their postconditions.\n+\n          while Position /= 0 loop\n             R := P.Add (R, (Node => Position), I);\n             pragma Assert (P.Length (R) = I);\n             Position := Container.Nodes (Position).Next;\n             I := I + 1;\n          end loop;\n+\n          return R;\n       end Positions;\n \n@@ -769,10 +787,7 @@ is\n    -- Free --\n    ----------\n \n-   procedure Free\n-     (Container : in out List;\n-      X         : Count_Type)\n-   is\n+   procedure Free (Container : in out List; X : Count_Type) is\n       pragma Assert (X > 0);\n       pragma Assert (X <= Container.Capacity);\n \n@@ -846,29 +861,30 @@ is\n \n          declare\n             E1 : Element_Type := Element (Container, 1);\n+\n          begin\n             for I in 2 .. M.Length (Container) loop\n                declare\n                   E2 : constant Element_Type := Element (Container, I);\n+\n                begin\n                   if E2 < E1 then\n                      return False;\n                   end if;\n+\n                   E1 := E2;\n                end;\n             end loop;\n          end;\n+\n          return True;\n       end M_Elements_Sorted;\n \n       -----------\n       -- Merge --\n       -----------\n \n-      procedure Merge\n-        (Target : in out List;\n-         Source : in out List)\n-      is\n+      procedure Merge (Target : in out List; Source : in out List) is\n          LN : Node_Array renames Target.Nodes;\n          RN : Node_Array renames Source.Nodes;\n          LI : Cursor;\n@@ -882,18 +898,20 @@ is\n          LI := First (Target);\n          RI := First (Source);\n          while RI.Node /= 0 loop\n-            pragma Assert (RN (RI.Node).Next = 0\n-              or else not (RN (RN (RI.Node).Next).Element <\n-                  RN (RI.Node).Element));\n+            pragma Assert\n+              (RN (RI.Node).Next = 0\n+                or else not (RN (RN (RI.Node).Next).Element <\n+                             RN (RI.Node).Element));\n \n             if LI.Node = 0 then\n                Splice (Target, No_Element, Source);\n                return;\n             end if;\n \n-            pragma Assert (LN (LI.Node).Next = 0\n-              or else not (LN (LN (LI.Node).Next).Element <\n-                  LN (LI.Node).Element));\n+            pragma Assert\n+              (LN (LI.Node).Next = 0\n+                or else not (LN (LN (LI.Node).Next).Element <\n+                             LN (LI.Node).Element));\n \n             if RN (RI.Node).Element < LN (LI.Node).Element then\n                declare\n@@ -917,14 +935,14 @@ is\n       procedure Sort (Container : in out List) is\n          N : Node_Array renames Container.Nodes;\n \n-         procedure Partition (Pivot, Back : Count_Type);\n-         procedure Sort (Front, Back : Count_Type);\n+         procedure Partition (Pivot : Count_Type; Back : Count_Type);\n+         procedure Sort (Front : Count_Type; Back : Count_Type);\n \n          ---------------\n          -- Partition --\n          ---------------\n \n-         procedure Partition (Pivot, Back : Count_Type) is\n+         procedure Partition (Pivot : Count_Type; Back : Count_Type) is\n             Node : Count_Type;\n \n          begin\n@@ -968,7 +986,7 @@ is\n          -- Sort --\n          ----------\n \n-         procedure Sort (Front, Back : Count_Type) is\n+         procedure Sort (Front : Count_Type; Back : Count_Type) is\n             Pivot : Count_Type;\n \n          begin\n@@ -1060,11 +1078,12 @@ is\n       Position  : out Cursor)\n    is\n    begin\n-      Insert (Container => Container,\n-              Before    => Before,\n-              New_Item  => New_Item,\n-              Position  => Position,\n-              Count     => 1);\n+      Insert\n+        (Container => Container,\n+         Before    => Before,\n+         New_Item  => New_Item,\n+         Position  => Position,\n+         Count     => 1);\n    end Insert;\n \n    procedure Insert\n@@ -1074,6 +1093,7 @@ is\n       Count     : Count_Type)\n    is\n       Position : Cursor;\n+\n    begin\n       Insert (Container, Before, New_Item, Position, Count);\n    end Insert;\n@@ -1084,6 +1104,7 @@ is\n       New_Item  : Element_Type)\n    is\n       Position : Cursor;\n+\n    begin\n       Insert (Container, Before, New_Item, Position, 1);\n    end Insert;\n@@ -1171,6 +1192,7 @@ is\n \n    function Last_Element (Container : List) return Element_Type is\n       L : constant Count_Type := Container.Last;\n+\n    begin\n       if L = 0 then\n          raise Constraint_Error with \"list is empty\";\n@@ -1192,10 +1214,7 @@ is\n    -- Move --\n    ----------\n \n-   procedure Move\n-     (Target : in out List;\n-      Source : in out List)\n-   is\n+   procedure Move (Target : in out List; Source : in out List) is\n       N : Node_Array renames Source.Nodes;\n       X : Count_Type;\n \n@@ -1295,10 +1314,7 @@ is\n    -- Prepend --\n    -------------\n \n-   procedure Prepend\n-     (Container : in out List;\n-      New_Item  : Element_Type)\n-   is\n+   procedure Prepend (Container : in out List; New_Item : Element_Type) is\n    begin\n       Insert (Container, First (Container), New_Item, 1);\n    end Prepend;\n@@ -1363,13 +1379,13 @@ is\n       I : Count_Type := Container.First;\n       J : Count_Type := Container.Last;\n \n-      procedure Swap (L, R : Count_Type);\n+      procedure Swap (L : Count_Type; R : Count_Type);\n \n       ----------\n       -- Swap --\n       ----------\n \n-      procedure Swap (L, R : Count_Type) is\n+      procedure Swap (L : Count_Type; R : Count_Type) is\n          LN : constant Count_Type := N (L).Next;\n          LP : constant Count_Type := N (L).Prev;\n \n@@ -1414,7 +1430,7 @@ is\n       pragma Assert (N (Container.Last).Next = 0);\n \n       Container.First := J;\n-      Container.Last := I;\n+      Container.Last  := I;\n       loop\n          Swap (L => I, R => J);\n \n@@ -1642,7 +1658,8 @@ is\n \n    procedure Swap\n      (Container : in out List;\n-      I, J      : Cursor)\n+      I         : Cursor;\n+      J         : Cursor)\n    is\n    begin\n       if I.Node = 0 then\n@@ -1679,9 +1696,11 @@ is\n \n    procedure Swap_Links\n      (Container : in out List;\n-      I, J      : Cursor)\n+      I         : Cursor;\n+      J         : Cursor)\n    is\n-      I_Next, J_Next : Cursor;\n+      I_Next : Cursor;\n+      J_Next : Cursor;\n \n    begin\n       if I.Node = 0 then"}, {"sha": "b60a6fe4b13a41fbfc6cde0a89b2423c29485bda", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 850, "deletions": 679, "changes": 1529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -34,6 +34,7 @@ with Ada.Containers.Functional_Maps;\n \n generic\n    type Element_Type is private;\n+\n package Ada.Containers.Formal_Doubly_Linked_Lists with\n   SPARK_Mode\n is\n@@ -67,17 +68,25 @@ is\n       package M is new Ada.Containers.Functional_Vectors\n         (Index_Type   => Positive_Count_Type,\n          Element_Type => Element_Type);\n-      function \"=\" (Left, Right : M.Sequence) return Boolean renames M.\"=\";\n-      function \"<\" (Left, Right : M.Sequence) return Boolean renames M.\"<\";\n-      function \"<=\" (Left, Right : M.Sequence) return Boolean renames M.\"<=\";\n+\n+      function \"=\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"=\";\n+\n+      function \"<\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"<\";\n+\n+      function \"<=\"\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean renames M.\"<=\";\n \n       function M_Elements_Shuffle\n         (Left   : M.Sequence;\n          Right  : M.Sequence;\n          Fst    : Positive_Count_Type;\n          Lst    : Count_Type;\n-         Offset : Count_Type'Base)\n-      return Boolean\n+         Offset : Count_Type'Base) return Boolean\n       --  The slice from Fst to Lst in Left contains the same elements than the\n       --  same slide shifted by Offset in Right\n       with\n@@ -87,51 +96,57 @@ is\n             and Offset in 1 - Fst .. M.Length (Right) - Lst,\n         Post   =>\n           M_Elements_Shuffle'Result =\n-          (for all J in Fst + Offset .. Lst + Offset =>\n-             (for some I in Fst .. Lst =>\n-                    Element (Left, I) = Element (Right, J)));\n+            (for all J in Fst + Offset .. Lst + Offset =>\n+              (for some I in Fst .. Lst =>\n+                Element (Left, I) = Element (Right, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Shuffle);\n \n-      function M_Elements_Reversed (Left, Right : M.Sequence) return Boolean\n+      function M_Elements_Reversed\n+        (Left  : M.Sequence;\n+         Right : M.Sequence) return Boolean\n       --  Right is Left in reverse order\n       with\n         Global => null,\n         Post   =>\n           M_Elements_Reversed'Result =\n-              (M.Length (Left) = M.Length (Right)\n-               and\n-                 (for all I in 1 .. M.Length (Left) =>\n-                      Element (Left, I)\n-                    = Element (Right, M.Length (Left) - I + 1))\n-               and\n-                 (for all I in 1 .. M.Length (Left) =>\n-                      Element (Right, I)\n-                    = Element (Left, M.Length (Left) - I + 1)));\n+            (M.Length (Left) = M.Length (Right)\n+              and (for all I in 1 .. M.Length (Left) =>\n+                     Element (Left, I) =\n+                     Element (Right, M.Length (Left) - I + 1))\n+              and (for all I in 1 .. M.Length (Left) =>\n+                     Element (Right, I) =\n+                     Element (Left, M.Length (Left) - I + 1)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n \n       function M_Elements_Swapped\n         (Left  : M.Sequence;\n          Right : M.Sequence;\n-         X, Y  : Positive_Count_Type)\n-      return Boolean\n+         X     : Positive_Count_Type;\n+         Y     : Positive_Count_Type) return Boolean\n       --  Elements stored at X and Y are reversed in Left and Right\n       with\n         Global => null,\n         Pre    => X <= M.Length (Left) and Y <= M.Length (Left),\n         Post   =>\n           M_Elements_Swapped'Result =\n             (M.Length (Left) = M.Length (Right)\n-             and Element (Left, X) = Element (Right, Y)\n-             and Element (Left, Y) = Element (Right, X)\n-             and M.Equal_Except (Left, Right, X, Y));\n+              and Element (Left, X) = Element (Right, Y)\n+              and Element (Left, Y) = Element (Right, X)\n+              and M.Equal_Except (Left, Right, X, Y));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n \n       package P is new Ada.Containers.Functional_Maps\n         (Key_Type        => Cursor,\n          Element_Type    => Positive_Count_Type,\n          Equivalent_Keys => \"=\");\n-      function \"=\" (Left, Right : P.Map) return Boolean renames P.\"=\";\n-      function \"<=\" (Left, Right : P.Map) return Boolean renames P.\"<=\";\n+\n+      function \"=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"=\";\n+\n+      function \"<=\"\n+        (Left  : P.Map;\n+         Right : P.Map) return Boolean renames P.\"<=\";\n \n       function P_Positions_Shifted\n         (Small : P.Map;\n@@ -143,39 +158,44 @@ is\n         Post   =>\n           P_Positions_Shifted'Result =\n \n-         --  Big contains all cursors of Small\n-        (P.Keys_Included (Small, Big)\n+            --  Big contains all cursors of Small\n \n-         --  Cursors located before Cut are not moved, cursors located after\n-         --  are shifted by Count.\n-         and\n-           (for all I of Small =>\n-                  (if P.Get (Small, I) < Cut\n-                   then P.Get (Big, I) = P.Get (Small, I)\n-                   else P.Get (Big, I) - Count = P.Get (Small, I)))\n+            P.Keys_Included (Small, Big)\n \n-         --  New cursors of Big (if any) are between Cut and Cut - 1 + Count\n-         and\n-           (for all I of Big =>\n-                 P.Has_Key (Small, I)\n-              or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n+              --  Cursors located before Cut are not moved, cursors located\n+              --  after are shifted by Count.\n+\n+              and (for all I of Small =>\n+                    (if P.Get (Small, I) < Cut then\n+                        P.Get (Big, I) = P.Get (Small, I)\n+                     else\n+                        P.Get (Big, I) - Count = P.Get (Small, I)))\n+\n+              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n+              --  Count.\n+\n+              and (for all I of Big =>\n+                    P.Has_Key (Small, I)\n+                      or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1);\n \n       function P_Positions_Swapped\n         (Left  : P.Map;\n          Right : P.Map;\n-         X, Y  : Cursor) return Boolean\n+         X     : Cursor;\n+         Y     : Cursor) return Boolean\n       --  Left and Right contain the same cursors, but the positions of X and Y\n       --  are reversed.\n       with\n         Ghost,\n         Global => null,\n         Post   =>\n           P_Positions_Swapped'Result =\n-              (P.Same_Keys (Left, Right)\n-               and P.Elements_Equal_Except (Left, Right, X, Y)\n-               and P.Has_Key (Left, X) and P.Has_Key (Left, Y)\n-               and P.Get (Left, X) = P.Get (Right, Y)\n-               and P.Get (Left, Y) = P.Get (Right, X));\n+            (P.Same_Keys (Left, Right)\n+              and P.Elements_Equal_Except (Left, Right, X, Y)\n+              and P.Has_Key (Left, X)\n+              and P.Has_Key (Left, Y)\n+              and P.Get (Left, X) = P.Get (Right, Y)\n+              and P.Get (Left, Y) = P.Get (Right, X));\n \n       function P_Positions_Truncated\n         (Small : P.Map;\n@@ -188,14 +208,16 @@ is\n         Post   =>\n           P_Positions_Truncated'Result =\n \n-         --  Big contains all cursors of Small at the same position\n-        (Small <= Big\n+            --  Big contains all cursors of Small at the same position\n+\n+            (Small <= Big\n \n-         --  New cursors of Big (if any) are between Cut and Cut - 1 + Count\n-         and\n-           (for all I of Big =>\n-                P.Has_Key (Small, I)\n-             or P.Get (Big, I) - Count in Cut - Count .. Cut - 1));\n+              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n+              --  Count.\n+\n+              and (for all I of Big =>\n+                    P.Has_Key (Small, I)\n+                      or P.Get (Big, I) - Count in Cut - Count .. Cut - 1));\n \n       function Mapping_Preserved\n         (M_Left  : M.Sequence;\n@@ -206,16 +228,18 @@ is\n         Ghost,\n         Global => null,\n         Post   =>\n-            (if Mapping_Preserved'Result then\n+          (if Mapping_Preserved'Result then\n \n              --  Left and Right contain the same cursors\n+\n              P.Same_Keys (P_Left, P_Right)\n \n-             --  Mappings from cursors to elements induced by M_Left, P_Left\n-             --  and M_Right, P_Right are the same.\n-             and (for all C of P_Left =>\n-                          M.Get (M_Left, P.Get (P_Left, C))\n-                        = M.Get (M_Right, P.Get (P_Right, C))));\n+               --  Mappings from cursors to elements induced by M_Left, P_Left\n+               --  and M_Right, P_Right are the same.\n+\n+               and (for all C of P_Left =>\n+                     M.Get (M_Left, P.Get (P_Left, C)) =\n+                     M.Get (M_Right, P.Get (P_Right, C))));\n \n       function Model (Container : List) return M.Sequence with\n       --  The highlevel model of a list is a sequence of elements. Cursors are\n@@ -232,19 +256,23 @@ is\n \n         Ghost,\n         Global => null,\n-        Post   => not P.Has_Key (Positions'Result, No_Element)\n-        --  Positions of cursors are smaller than the container's length.\n-        and then\n-          (for all I of Positions'Result =>\n-             P.Get (Positions'Result, I) in 1 .. Length (Container)\n-\n-               --  No two cursors have the same position. Note that we do not\n-           --  state that there is a cursor in the map for each position,\n-           --  as it is rarely needed.\n-           and then\n-             (for all J of Positions'Result =>\n+        Post   =>\n+          not P.Has_Key (Positions'Result, No_Element)\n+\n+            --  Positions of cursors are smaller than the container's length.\n+\n+            and then\n+              (for all I of Positions'Result =>\n+                P.Get (Positions'Result, I) in 1 .. Length (Container)\n+\n+            --  No two cursors have the same position. Note that we do not\n+            --  state that there is a cursor in the map for each position, as\n+            --  it is rarely needed.\n+\n+            and then\n+              (for all J of Positions'Result =>\n                 (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                     then I = J)));\n+                  then I = J)));\n \n       procedure Lift_Abstraction_Level (Container : List) with\n         --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n@@ -257,15 +285,17 @@ is\n         Ghost,\n         Global => null,\n         Post   =>\n-            (for all Elt of Model (Container) =>\n-               (for some I of Positions (Container) =>\n-                    M.Get (Model (Container), P.Get (Positions (Container), I))\n-                    = Elt));\n-\n-      function Element (S : M.Sequence; I : Count_Type) return Element_Type\n-                     renames M.Get;\n+          (for all Elt of Model (Container) =>\n+            (for some I of Positions (Container) =>\n+              M.Get (Model (Container), P.Get (Positions (Container), I)) =\n+                Elt));\n+\n+      function Element\n+        (S : M.Sequence;\n+         I : Count_Type) return Element_Type renames M.Get;\n       --  To improve readability of contracts, we rename the function used to\n       --  access an element in the model to Element.\n+\n    end Formal_Model;\n    use Formal_Model;\n \n@@ -289,10 +319,13 @@ is\n    function Copy (Source : List; Capacity : Count_Type := 0) return List with\n      Global => null,\n      Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n-     Post   => Model (Copy'Result) = Model (Source)\n-     and Positions (Copy'Result) = Positions (Source)\n-     and (if Capacity = 0 then Copy'Result.Capacity = Source.Capacity\n-          else Copy'Result.Capacity = Capacity);\n+     Post   =>\n+       Model (Copy'Result) = Model (Source)\n+         and Positions (Copy'Result) = Positions (Source)\n+         and (if Capacity = 0 then\n+                 Copy'Result.Capacity = Source.Capacity\n+              else\n+                 Copy'Result.Capacity = Capacity);\n \n    function Element\n      (Container : List;\n@@ -302,8 +335,7 @@ is\n      Pre    => Has_Element (Container, Position),\n      Post   =>\n        Element'Result =\n-         Element (Model (Container),\n-                  P.Get (Positions (Container), Position));\n+         Element (Model (Container), P.Get (Positions (Container), Position));\n    pragma Annotate (GNATprove, Inline_For_Proof, Element);\n \n    procedure Replace_Element\n@@ -313,25 +345,30 @@ is\n    with\n      Global => null,\n      Pre    => Has_Element (Container, Position),\n-     Post   => Length (Container) = Length (Container)'Old\n+     Post   =>\n+       Length (Container) = Length (Container)'Old\n+\n+         --  Cursors are preserved\n \n-     --  Cursors are preserved.\n-     and Positions (Container)'Old = Positions (Container)\n+         and Positions (Container)'Old = Positions (Container)\n \n-     --  The element at the position of Position in Container is New_Item\n-     and Element (Model (Container), P.Get (Positions (Container), Position))\n-       = New_Item\n+         --  The element at the position of Position in Container is New_Item\n \n-     --  Other elements are preserved\n-     and M.Equal_Except (Model (Container)'Old,\n-                         Model (Container),\n-                         P.Get (Positions (Container), Position));\n+         and Element\n+               (Model (Container),\n+                P.Get (Positions (Container), Position)) = New_Item\n+\n+         --  Other elements are preserved\n+\n+         and M.Equal_Except\n+               (Model (Container)'Old,\n+                Model (Container),\n+                P.Get (Positions (Container), Position));\n \n    procedure Move (Target : in out List; Source : in out List) with\n      Global => null,\n      Pre    => Target.Capacity >= Length (Source),\n-     Post   => Model (Target) = Model (Source'Old)\n-     and Length (Source) = 0;\n+     Post   => Model (Target) = Model (Source'Old) and Length (Source) = 0;\n \n    procedure Insert\n      (Container : in out List;\n@@ -340,126 +377,145 @@ is\n    with\n      Global         => null,\n      Pre            =>\n-         Length (Container) < Container.Capacity\n-       and then (Has_Element (Container, Before)\n-                 or else Before = No_Element),\n+       Length (Container) < Container.Capacity\n+         and then (Has_Element (Container, Before)\n+                    or else Before = No_Element),\n      Post           => Length (Container) = Length (Container)'Old + 1,\n      Contract_Cases =>\n        (Before = No_Element =>\n \n           --  Positions contains a new mapping from the last cursor of\n           --  Container to its length.\n+\n           P.Get (Positions (Container), Last (Container)) = Length (Container)\n \n-          --  Other cursors come from Container'Old\n-          and P.Keys_Included_Except\n-            (Left    => Positions (Container),\n-             Right   => Positions (Container)'Old,\n-             New_Key => Last (Container))\n+            --  Other cursors come from Container'Old\n+\n+            and P.Keys_Included_Except\n+                  (Left    => Positions (Container),\n+                   Right   => Positions (Container)'Old,\n+                   New_Key => Last (Container))\n \n-          --  Cursors of Container'Old keep the same position\n-          and Positions (Container)'Old <= Positions (Container)\n+            --  Cursors of Container'Old keep the same position\n \n-          --  Model contains a new element New_Item at the end\n-          and Element (Model (Container), Length (Container)) = New_Item\n+            and Positions (Container)'Old <= Positions (Container)\n \n-          --  Elements of Container'Old are preserved\n-          and Model (Container)'Old <= Model (Container),\n-        others              =>\n+            --  Model contains a new element New_Item at the end\n+\n+            and Element (Model (Container), Length (Container)) = New_Item\n+\n+            --  Elements of Container'Old are preserved\n+\n+            and Model (Container)'Old <= Model (Container),\n+\n+        others =>\n+\n+          --  The elements of Container located before Before are preserved\n \n-          --  The elements of Container located before Before are preserved.\n           M.Range_Equal\n             (Left  => Model (Container)'Old,\n              Right => Model (Container),\n              Fst   => 1,\n              Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n \n-          --  Other elements are shifted by 1.\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => P.Get (Positions (Container)'Old, Before),\n-             Lst    => Length (Container)'Old,\n-             Offset => 1)\n-\n-          --  New_Item is stored at the previous position of Before in\n-          --  Container\n-          and Element\n-            (Model (Container), P.Get (Positions (Container)'Old, Before))\n-               = New_Item\n+            --  Other elements are shifted by 1\n \n-          --  A new cursor has been inserted at position Before in Container\n-          and P_Positions_Shifted\n-            (Positions (Container)'Old,\n-             Positions (Container),\n-             Cut => P.Get (Positions (Container)'Old, Before)));\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container)'Old, Before),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => 1)\n+\n+            --  New_Item is stored at the previous position of Before in\n+            --  Container.\n+\n+            and Element\n+                  (Model (Container),\n+                   P.Get (Positions (Container)'Old, Before)) = New_Item\n+\n+            --  A new cursor has been inserted at position Before in Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut => P.Get (Positions (Container)'Old, Before)));\n \n    procedure Insert\n      (Container : in out List;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Count     : Count_Type)\n    with\n-     Global => null,\n-       Pre    =>\n-         Length (Container) <= Container.Capacity - Count\n-       and then (Has_Element (Container, Before)\n-                 or else Before = No_Element),\n+     Global         => null,\n+     Pre            =>\n+       Length (Container) <= Container.Capacity - Count\n+         and then (Has_Element (Container, Before)\n+                    or else Before = No_Element),\n      Post           => Length (Container) = Length (Container)'Old + Count,\n      Contract_Cases =>\n        (Before = No_Element =>\n \n           --  The elements of Container are preserved\n+\n           M.Range_Equal\n             (Left  => Model (Container)'Old,\n              Right => Model (Container),\n              Fst   => 1,\n              Lst   => Length (Container)'Old)\n \n-          --  Container contains Count times New_Item at the end\n-          and M.Constant_Range\n-            (Container => Model (Container),\n-             Fst       => Length (Container)'Old + 1,\n-             Lst       => Length (Container),\n-             Item      => New_Item)\n-\n-          --  A Count cursors have been inserted at the end of Container\n-          and P_Positions_Truncated\n-            (Positions (Container)'Old,\n-             Positions (Container),\n-             Cut   => Length (Container)'Old + 1,\n-             Count => Count),\n-        others              =>\n+            --  Container contains Count times New_Item at the end\n+\n+            and M.Constant_Range\n+                  (Container => Model (Container),\n+                   Fst       => Length (Container)'Old + 1,\n+                   Lst       => Length (Container),\n+                   Item      => New_Item)\n+\n+            --  A Count cursors have been inserted at the end of Container\n+\n+            and P_Positions_Truncated\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut   => Length (Container)'Old + 1,\n+                   Count => Count),\n+\n+        others =>\n \n           --  The elements of Container located before Before are preserved\n+\n           M.Range_Equal\n             (Left  => Model (Container)'Old,\n              Right => Model (Container),\n              Fst   => 1,\n              Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n \n-          --  Other elements are shifted by Count.\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => P.Get (Positions (Container)'Old, Before),\n-             Lst    => Length (Container)'Old,\n-             Offset => Count)\n-\n-          --  Container contains Count times New_Item after position Before\n-          and M.Constant_Range\n-            (Container => Model (Container),\n-             Fst       => P.Get (Positions (Container)'Old, Before),\n-             Lst       =>\n-               P.Get (Positions (Container)'Old, Before) - 1 + Count,\n-             Item      => New_Item)\n-\n-          --  Count cursors have been inserted at position Before in Container\n-          and P_Positions_Shifted\n-            (Positions (Container)'Old,\n-             Positions (Container),\n-             Cut   => P.Get (Positions (Container)'Old, Before),\n-             Count => Count));\n+            --  Other elements are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container)'Old, Before),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => Count)\n+\n+            --  Container contains Count times New_Item after position Before\n+\n+            and M.Constant_Range\n+                  (Container => Model (Container),\n+                   Fst       => P.Get (Positions (Container)'Old, Before),\n+                   Lst       =>\n+                     P.Get (Positions (Container)'Old, Before) - 1 + Count,\n+                   Item      => New_Item)\n+\n+            --  Count cursors have been inserted at position Before in\n+            --  Container.\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut   => P.Get (Positions (Container)'Old, Before),\n+                   Count => Count));\n \n    procedure Insert\n      (Container : in out List;\n@@ -469,47 +525,52 @@ is\n    with\n      Global => null,\n      Pre    =>\n-         Length (Container) < Container.Capacity\n-       and then (Has_Element (Container, Before)\n-                 or else Before = No_Element),\n+       Length (Container) < Container.Capacity\n+         and then (Has_Element (Container, Before)\n+                    or else Before = No_Element),\n      Post   =>\n        Length (Container) = Length (Container)'Old + 1\n \n           --  Positions is valid in Container and it is located either before\n           --  Before if it is valid in Container or at the end if it is\n           --  No_Element.\n+\n           and P.Has_Key (Positions (Container), Position)\n-          and (if Before = No_Element\n-               then P.Get (Positions (Container), Position)\n-                  = Length (Container)\n-               else P.Get (Positions (Container), Position)\n-                  = P.Get (Positions (Container)'Old, Before))\n+          and (if Before = No_Element then\n+                  P.Get (Positions (Container), Position) = Length (Container)\n+               else\n+                  P.Get (Positions (Container), Position) =\n+                  P.Get (Positions (Container)'Old, Before))\n+\n+          --  The elements of Container located before Position are preserved\n \n-          --  The elements of Container located before Position are preserved.\n           and M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container), Position) - 1)\n+                (Left  => Model (Container)'Old,\n+                 Right => Model (Container),\n+                 Fst   => 1,\n+                 Lst   => P.Get (Positions (Container), Position) - 1)\n+\n+          --  Other elements are shifted by 1\n \n-          --  Other elements are shifted by 1.\n           and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => P.Get (Positions (Container), Position),\n-             Lst    => Length (Container)'Old,\n-             Offset => 1)\n+                (Left   => Model (Container)'Old,\n+                 Right  => Model (Container),\n+                 Fst    => P.Get (Positions (Container), Position),\n+                 Lst    => Length (Container)'Old,\n+                 Offset => 1)\n \n           --  New_Item is stored at Position in Container\n+\n           and Element\n-            (Model (Container), P.Get (Positions (Container), Position))\n-               = New_Item\n+                (Model (Container),\n+                 P.Get (Positions (Container), Position)) = New_Item\n \n           --  A new cursor has been inserted at position Position in Container\n+\n           and P_Positions_Shifted\n-            (Positions (Container)'Old,\n-             Positions (Container),\n-             Cut => P.Get (Positions (Container), Position));\n+                (Positions (Container)'Old,\n+                 Positions (Container),\n+                 Cut => P.Get (Positions (Container), Position));\n \n    procedure Insert\n      (Container : in out List;\n@@ -520,80 +581,89 @@ is\n    with\n      Global         => null,\n      Pre            =>\n-         Length (Container) <= Container.Capacity - Count\n-       and then (Has_Element (Container, Before)\n-                 or else Before = No_Element),\n+       Length (Container) <= Container.Capacity - Count\n+         and then (Has_Element (Container, Before)\n+                    or else Before = No_Element),\n      Post           => Length (Container) = Length (Container)'Old + Count,\n      Contract_Cases =>\n-       (Count = 0 => Position = Before\n-          and Model (Container) = Model (Container)'Old\n-          and Positions (Container) = Positions (Container)'Old,\n+       (Count = 0 =>\n+          Position = Before\n+            and Model (Container) = Model (Container)'Old\n+            and Positions (Container) = Positions (Container)'Old,\n+\n+        others =>\n \n-        others    =>\n           --  Positions is valid in Container and it is located either before\n           --  Before if it is valid in Container or at the end if it is\n           --  No_Element.\n-          P.Has_Key (Positions (Container), Position)\n-          and (if Before = No_Element\n-               then P.Get (Positions (Container), Position)\n-                  = Length (Container)'Old + 1\n-               else P.Get (Positions (Container), Position)\n-                  = P.Get (Positions (Container)'Old, Before))\n-\n-          --  The elements of Container located before Position are preserved.\n-          and M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container), Position) - 1)\n-\n-          --  Other elements are shifted by Count.\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => P.Get (Positions (Container), Position),\n-             Lst    => Length (Container)'Old,\n-             Offset => Count)\n-\n-          --  Container contains Count times New_Item after position Position\n-          and M.Constant_Range\n-            (Container => Model (Container),\n-             Fst       => P.Get (Positions (Container), Position),\n-             Lst       => P.Get (Positions (Container), Position) - 1 + Count,\n-             Item      => New_Item)\n-\n-          --  Count cursor have been inserted at Position in Container\n-          and P_Positions_Shifted\n-            (Positions (Container)'Old,\n-             Positions (Container),\n-             Cut   => P.Get (Positions (Container), Position),\n-             Count => Count));\n \n-   procedure Prepend\n-     (Container : in out List;\n-      New_Item  : Element_Type)\n-   with\n+          P.Has_Key (Positions (Container), Position)\n+            and (if Before = No_Element then\n+                    P.Get (Positions (Container), Position) =\n+                    Length (Container)'Old + 1\n+                 else\n+                    P.Get (Positions (Container), Position) =\n+                    P.Get (Positions (Container)'Old, Before))\n+\n+            --  The elements of Container located before Position are preserved\n+\n+            and M.Range_Equal\n+                  (Left  => Model (Container)'Old,\n+                   Right => Model (Container),\n+                   Fst   => 1,\n+                   Lst   => P.Get (Positions (Container), Position) - 1)\n+\n+            --  Other elements are shifted by Count\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container), Position),\n+                   Lst    => Length (Container)'Old,\n+                   Offset => Count)\n+\n+            --  Container contains Count times New_Item after position Position\n+\n+            and M.Constant_Range\n+                  (Container => Model (Container),\n+                   Fst       => P.Get (Positions (Container), Position),\n+                   Lst       =>\n+                     P.Get (Positions (Container), Position) - 1 + Count,\n+                   Item      => New_Item)\n+\n+            --  Count cursor have been inserted at Position in Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container)'Old,\n+                   Positions (Container),\n+                   Cut   => P.Get (Positions (Container), Position),\n+                   Count => Count));\n+\n+   procedure Prepend (Container : in out List; New_Item : Element_Type) with\n      Global => null,\n      Pre    => Length (Container) < Container.Capacity,\n      Post   =>\n        Length (Container) = Length (Container)'Old + 1\n \n-          --  Elements are shifted by 1\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => 1,\n-             Lst    => Length (Container)'Old,\n-             Offset => 1)\n+         --  Elements are shifted by 1\n \n-          --  New_Item is the first element of Container\n-          and Element (Model (Container), 1) = New_Item\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => 1,\n+                Lst    => Length (Container)'Old,\n+                Offset => 1)\n \n-          --  A new cursor has been inserted at the beginning of Container\n-          and P_Positions_Shifted\n-            (Positions (Container)'Old,\n-             Positions (Container),\n-             Cut => 1);\n+         --  New_Item is the first element of Container\n+\n+         and Element (Model (Container), 1) = New_Item\n+\n+         --  A new cursor has been inserted at the beginning of Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Cut => 1);\n \n    procedure Prepend\n      (Container : in out List;\n@@ -605,55 +675,61 @@ is\n      Post   =>\n        Length (Container) = Length (Container)'Old + Count\n \n-          --  Elements are shifted by Count.\n-          and M.Range_Shifted\n-            (Left     => Model (Container)'Old,\n-             Right     => Model (Container),\n-             Fst    => 1,\n-             Lst    => Length (Container)'Old,\n-             Offset => Count)\n-\n-          --  Container starts with Count times New_Item\n-          and M.Constant_Range\n-            (Container => Model (Container),\n-             Fst       => 1,\n-             Lst       => Count,\n-             Item      => New_Item)\n-\n-          --  Count cursors have been inserted at the beginning of Container\n-          and P_Positions_Shifted\n-            (Positions (Container)'Old,\n-             Positions (Container),\n-             Cut   => 1,\n-             Count => Count);\n+         --  Elements are shifted by Count\n \n-   procedure Append\n-     (Container : in out List;\n-      New_Item  : Element_Type)\n-   with\n+         and M.Range_Shifted\n+               (Left     => Model (Container)'Old,\n+                Right     => Model (Container),\n+                Fst    => 1,\n+                Lst    => Length (Container)'Old,\n+                Offset => Count)\n+\n+         --  Container starts with Count times New_Item\n+\n+         and M.Constant_Range\n+               (Container => Model (Container),\n+                Fst       => 1,\n+                Lst       => Count,\n+                Item      => New_Item)\n+\n+         --  Count cursors have been inserted at the beginning of Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Cut   => 1,\n+                Count => Count);\n+\n+   procedure Append (Container : in out List; New_Item : Element_Type) with\n      Global => null,\n      Pre    => Length (Container) < Container.Capacity,\n-     Post   => Length (Container) = Length (Container)'Old + 1\n+     Post   =>\n+       Length (Container) = Length (Container)'Old + 1\n \n-          --  Positions contains a new mapping from the last cursor of\n-          --  Container to its length.\n-          and P.Get (Positions (Container), Last (Container))\n-            = Length (Container)\n+         --  Positions contains a new mapping from the last cursor of Container\n+         --  to its length.\n \n-          --  Other cursors come from Container'Old\n-          and P.Keys_Included_Except\n-            (Left    => Positions (Container),\n-             Right   => Positions (Container)'Old,\n-             New_Key => Last (Container))\n+         and P.Get (Positions (Container), Last (Container)) =\n+               Length (Container)\n \n-          --  Cursors of Container'Old keep the same position\n-          and Positions (Container)'Old <= Positions (Container)\n+         --  Other cursors come from Container'Old\n \n-          --  Model contains a new element New_Item at the end\n-          and Element (Model (Container), Length (Container)) = New_Item\n+         and P.Keys_Included_Except\n+               (Left    => Positions (Container),\n+                Right   => Positions (Container)'Old,\n+                New_Key => Last (Container))\n \n-          --  Elements of Container'Old are preserved\n-          and Model (Container)'Old <= Model (Container);\n+         --  Cursors of Container'Old keep the same position\n+\n+         and Positions (Container)'Old <= Positions (Container)\n+\n+         --  Model contains a new element New_Item at the end\n+\n+         and Element (Model (Container), Length (Container)) = New_Item\n+\n+         --  Elements of Container'Old are preserved\n+\n+         and Model (Container)'Old <= Model (Container);\n \n    procedure Append\n      (Container : in out List;\n@@ -665,55 +741,59 @@ is\n      Post   =>\n        Length (Container) = Length (Container)'Old + Count\n \n-          --  The elements of Container are preserved\n-          and Model (Container)'Old <= Model (Container)\n-\n-          --  Container contains Count times New_Item at the end\n-          and M.Constant_Range\n-            (Container => Model (Container),\n-             Fst       => Length (Container)'Old + 1,\n-             Lst       => Length (Container),\n-             Item      => New_Item)\n-\n-          --  Count cursors have been inserted at the end of Container\n-          and P_Positions_Truncated\n-            (Positions (Container)'Old,\n-             Positions (Container),\n-             Cut   => Length (Container)'Old + 1,\n-             Count => Count);\n+         --  The elements of Container are preserved\n \n-   procedure Delete\n-     (Container : in out List;\n-      Position  : in out Cursor)\n-   with\n+         and Model (Container)'Old <= Model (Container)\n+\n+         --  Container contains Count times New_Item at the end\n+\n+         and M.Constant_Range\n+               (Container => Model (Container),\n+                Fst       => Length (Container)'Old + 1,\n+                Lst       => Length (Container),\n+                Item      => New_Item)\n+\n+         --  Count cursors have been inserted at the end of Container\n+\n+         and P_Positions_Truncated\n+               (Positions (Container)'Old,\n+                Positions (Container),\n+                Cut   => Length (Container)'Old + 1,\n+                Count => Count);\n+\n+   procedure Delete (Container : in out List; Position : in out Cursor) with\n      Global => null,\n      Pre    => Has_Element (Container, Position),\n      Post   =>\n        Length (Container) = Length (Container)'Old - 1\n \n-          --  Position is set to No_Element\n-          and Position = No_Element\n+         --  Position is set to No_Element\n \n-          --  The elements of Container located before Position are preserved.\n-          and M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n+         and Position = No_Element\n \n-          --  The elements located after Position are shifted by 1\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => P.Get (Positions (Container)'Old, Position'Old) + 1,\n-             Lst    => Length (Container)'Old,\n-             Offset => -1)\n+         --  The elements of Container located before Position are preserved.\n \n-          --  Position has been removed from Container\n-          and P_Positions_Shifted\n-            (Positions (Container),\n-             Positions (Container)'Old,\n-             Cut   => P.Get (Positions (Container)'Old, Position'Old));\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n+\n+         --  The elements located after Position are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => P.Get (Positions (Container)'Old, Position'Old) + 1,\n+                Lst    => Length (Container)'Old,\n+                Offset => -1)\n+\n+         --  Position has been removed from Container\n+\n+         and P_Positions_Shifted\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Cut   => P.Get (Positions (Container)'Old, Position'Old));\n \n    procedure Delete\n      (Container : in out List;\n@@ -723,152 +803,166 @@ is\n      Global         => null,\n      Pre            => Has_Element (Container, Position),\n      Post           =>\n-          Length (Container) in Length (Container)'Old - Count\n-                                        .. Length (Container)'Old\n+       Length (Container) in\n+         Length (Container)'Old - Count .. Length (Container)'Old\n \n-          --  Position is set to No_Element\n-          and Position = No_Element\n+         --  Position is set to No_Element\n+\n+         and Position = No_Element\n+\n+         --  The elements of Container located before Position are preserved.\n+\n+         and M.Range_Equal\n+               (Left  => Model (Container)'Old,\n+                Right => Model (Container),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1),\n \n-          --  The elements of Container located before Position are preserved.\n-          and M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1),\n      Contract_Cases =>\n \n        --  All the elements after Position have been erased\n-       (Length (Container) - Count < P.Get (Positions (Container), Position)\n-        =>\n \n+       (Length (Container) - Count < P.Get (Positions (Container), Position) =>\n           Length (Container) =\n             P.Get (Positions (Container)'Old, Position'Old) - 1\n \n-          --  At most Count cursors have been removed at the end of Container\n-          and P_Positions_Truncated\n-            (Positions (Container),\n-             Positions (Container)'Old,\n-             Cut   => P.Get (Positions (Container)'Old, Position'Old),\n-             Count => Count),\n+            --  At most Count cursors have been removed at the end of Container\n+\n+            and P_Positions_Truncated\n+                 (Positions (Container),\n+                  Positions (Container)'Old,\n+                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n+                  Count => Count),\n+\n         others =>\n           Length (Container) = Length (Container)'Old - Count\n \n-          --  Other elements are shifted by Count\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    =>\n-               P.Get (Positions (Container)'Old, Position'Old) + Count,\n-             Lst    => Length (Container)'Old,\n-             Offset => -Count)\n-\n-          --  Count cursors have been removed from Container at Position\n-          and P_Positions_Shifted\n-            (Positions (Container),\n-             Positions (Container)'Old,\n-             Cut   => P.Get (Positions (Container)'Old, Position'Old),\n-             Count => Count));\n+            --  Other elements are shifted by Count\n \n-   procedure Delete_First (Container : in out List)\n-   with\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    =>\n+                     P.Get (Positions (Container)'Old, Position'Old) + Count,\n+                   Lst    => Length (Container)'Old,\n+                   Offset => -Count)\n+\n+            --  Count cursors have been removed from Container at Position\n+\n+            and P_Positions_Shifted\n+                 (Positions (Container),\n+                  Positions (Container)'Old,\n+                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n+                  Count => Count));\n+\n+   procedure Delete_First (Container : in out List) with\n      Global => null,\n      Pre    => not Is_Empty (Container),\n      Post   =>\n        Length (Container) = Length (Container)'Old - 1\n \n-          --  The elements of Container are shifted by 1\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => 2,\n-             Lst    => Length (Container)'Old,\n-             Offset => -1)\n+         --  The elements of Container are shifted by 1\n \n-          --  The first cursor of Container has been removed\n-          and P_Positions_Shifted\n-            (Positions (Container),\n-             Positions (Container)'Old,\n-             Cut   => 1);\n+         and M.Range_Shifted\n+               (Left   => Model (Container)'Old,\n+                Right  => Model (Container),\n+                Fst    => 2,\n+                Lst    => Length (Container)'Old,\n+                Offset => -1)\n \n-   procedure Delete_First\n-     (Container : in out List;\n-      Count     : Count_Type)\n-   with\n+         --  The first cursor of Container has been removed\n+\n+         and P_Positions_Shifted\n+               (Positions (Container),\n+                Positions (Container)'Old,\n+                Cut   => 1);\n+\n+   procedure Delete_First (Container : in out List; Count : Count_Type) with\n      Global         => null,\n      Contract_Cases =>\n \n        --  All the elements of Container have been erased\n-       (Length (Container) <= Count => Length (Container) = 0,\n+\n+       (Length (Container) <= Count =>\n+          Length (Container) = 0,\n+\n         others =>\n           Length (Container) = Length (Container)'Old - Count\n \n-          --  Elements of Container are shifted by Count\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => Count + 1,\n-             Lst    => Length (Container)'Old,\n-             Offset => -Count)\n+            --  Elements of Container are shifted by Count\n \n-          --  The first Count cursors have been removed from Container\n-          and P_Positions_Shifted\n-            (Positions (Container),\n-             Positions (Container)'Old,\n-             Cut   => 1,\n-             Count => Count));\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => Count + 1,\n+                   Lst    => Length (Container)'Old,\n+                   Offset => -Count)\n \n-   procedure Delete_Last (Container : in out List)\n-   with\n+            --  The first Count cursors have been removed from Container\n+\n+            and P_Positions_Shifted\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Cut   => 1,\n+                   Count => Count));\n+\n+   procedure Delete_Last (Container : in out List) with\n      Global => null,\n      Pre    => not Is_Empty (Container),\n      Post   =>\n        Length (Container) = Length (Container)'Old - 1\n \n-          --  The elements of Container are preserved.\n-          and Model (Container) <= Model (Container)'Old\n+         --  The elements of Container are preserved\n \n-          --  The last cursor of Container has been removed\n-          and not P.Has_Key (Positions (Container), Last (Container)'Old)\n+         and Model (Container) <= Model (Container)'Old\n \n-          --  Other cursors are still valid\n-          and P.Keys_Included_Except\n-            (Left    => Positions (Container)'Old,\n-             Right   => Positions (Container)'Old,\n-             New_Key => Last (Container)'Old)\n+         --  The last cursor of Container has been removed\n \n-          --  The positions of other cursors are preserved\n-          and Positions (Container) <= Positions (Container)'Old;\n+         and not P.Has_Key (Positions (Container), Last (Container)'Old)\n \n-   procedure Delete_Last\n-     (Container : in out List;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n+         --  Other cursors are still valid\n+\n+         and P.Keys_Included_Except\n+                (Left    => Positions (Container)'Old,\n+                 Right   => Positions (Container)'Old,\n+                 New_Key => Last (Container)'Old)\n+\n+         --  The positions of other cursors are preserved\n+\n+         and Positions (Container) <= Positions (Container)'Old;\n+\n+   procedure Delete_Last (Container : in out List; Count : Count_Type) with\n+     Global         => null,\n      Contract_Cases =>\n \n        --  All the elements of Container have been erased\n-       (Length (Container) <= Count => Length (Container) = 0,\n-        others =>\n \n+       (Length (Container) <= Count =>\n+          Length (Container) = 0,\n+\n+        others =>\n           Length (Container) = Length (Container)'Old - Count\n \n-          --  The elements of Container are preserved.\n-          and Model (Container) <= Model (Container)'Old\n+            --  The elements of Container are preserved\n+\n+            and Model (Container) <= Model (Container)'Old\n \n-          --  At most Count cursors have been removed at the end of Container\n-          and P_Positions_Truncated\n-            (Positions (Container),\n-             Positions (Container)'Old,\n-             Cut   => Length (Container) + 1,\n-             Count => Count));\n+            --  At most Count cursors have been removed at the end of Container\n+\n+            and P_Positions_Truncated\n+                  (Positions (Container),\n+                   Positions (Container)'Old,\n+                   Cut   => Length (Container) + 1,\n+                   Count => Count));\n \n    procedure Reverse_Elements (Container : in out List) with\n      Global => null,\n      Post   => M_Elements_Reversed (Model (Container'Old), Model (Container));\n \n    procedure Swap\n      (Container : in out List;\n-      I, J      : Cursor)\n+      I         : Cursor;\n+      J         : Cursor)\n    with\n      Global => null,\n      Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n@@ -877,11 +971,13 @@ is\n          (Model (Container)'Old, Model (Container),\n           X => P.Get (Positions (Container)'Old, I),\n           Y => P.Get (Positions (Container)'Old, J))\n-       and Positions (Container) = Positions (Container)'Old;\n+\n+         and Positions (Container) = Positions (Container)'Old;\n \n    procedure Swap_Links\n      (Container : in out List;\n-      I, J      : Cursor)\n+      I         : Cursor;\n+      J        : Cursor)\n    with\n      Global => null,\n      Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n@@ -890,8 +986,8 @@ is\n          (Model (Container'Old), Model (Container),\n           X => P.Get (Positions (Container)'Old, I),\n           Y => P.Get (Positions (Container)'Old, J))\n-       and P_Positions_Swapped\n-       (Positions (Container)'Old, Positions (Container), I, J);\n+         and P_Positions_Swapped\n+               (Positions (Container)'Old, Positions (Container), I, J);\n \n    procedure Splice\n      (Target : in out List;\n@@ -901,69 +997,77 @@ is\n    with\n      Global         => null,\n      Pre            =>\n-         Length (Source) <= Target.Capacity - Length (Target)\n+       Length (Source) <= Target.Capacity - Length (Target)\n          and then (Has_Element (Target, Before)\n-                   or else Before = No_Element),\n+                    or else Before = No_Element),\n      Post           =>\n        Length (Source) = 0\n-           and Length (Target) = Length (Target)'Old + Length (Source)'Old,\n+         and Length (Target) = Length (Target)'Old + Length (Source)'Old,\n      Contract_Cases =>\n        (Before = No_Element =>\n \n           --  The elements of Target are preserved\n+\n           M.Range_Equal\n             (Left  => Model (Target)'Old,\n              Right => Model (Target),\n              Fst   => 1,\n              Lst   => Length (Target)'Old)\n \n-          --  The elements of Source are appended to target, the order is not\n-          --  specified.\n-          and M_Elements_Shuffle\n-            (Left   => Model (Source)'Old,\n-             Right  => Model (Target),\n-             Fst    => 1,\n-             Lst    => Length (Source)'Old,\n-             Offset => Length (Target)'Old)\n-\n-          --  Cursors have been inserted at the end of Target\n-          and P_Positions_Truncated\n-            (Positions (Target)'Old,\n-             Positions (Target),\n-             Cut   => Length (Target)'Old + 1,\n-             Count => Length (Source)'Old),\n-        others              =>\n+            --  The elements of Source are appended to target, the order is not\n+            --  specified.\n+\n+            and M_Elements_Shuffle\n+                  (Left   => Model (Source)'Old,\n+                   Right  => Model (Target),\n+                   Fst    => 1,\n+                   Lst    => Length (Source)'Old,\n+                   Offset => Length (Target)'Old)\n+\n+            --  Cursors have been inserted at the end of Target\n+\n+            and P_Positions_Truncated\n+                  (Positions (Target)'Old,\n+                   Positions (Target),\n+                   Cut   => Length (Target)'Old + 1,\n+                   Count => Length (Source)'Old),\n+\n+        others =>\n \n           --  The elements of Target located before Before are preserved\n+\n           M.Range_Equal\n             (Left  => Model (Target)'Old,\n              Right => Model (Target),\n              Fst   => 1,\n              Lst   => P.Get (Positions (Target)'Old, Before) - 1)\n \n-          --  The elements of Source are inserted before Before, the order is\n-          --  not specified.\n+            --  The elements of Source are inserted before Before, the order is\n+            --  not specified.\n+\n           and M_Elements_Shuffle\n-            (Left   => Model (Source)'Old,\n-             Right  => Model (Target),\n-             Fst    => 1,\n-             Lst    => Length (Source)'Old,\n-             Offset => P.Get (Positions (Target)'Old, Before) - 1)\n+                (Left   => Model (Source)'Old,\n+                 Right  => Model (Target),\n+                 Fst    => 1,\n+                 Lst    => Length (Source)'Old,\n+                 Offset => P.Get (Positions (Target)'Old, Before) - 1)\n \n           --  Other elements are shifted by the length of Source\n+\n           and M.Range_Shifted\n-            (Left   => Model (Target)'Old,\n-             Right  => Model (Target),\n-             Fst    => P.Get (Positions (Target)'Old, Before),\n-             Lst    => Length (Target)'Old,\n-             Offset => Length (Source)'Old)\n+                (Left   => Model (Target)'Old,\n+                 Right  => Model (Target),\n+                 Fst    => P.Get (Positions (Target)'Old, Before),\n+                 Lst    => Length (Target)'Old,\n+                 Offset => Length (Source)'Old)\n \n           --  Cursors have been inserted at position Before in Target\n+\n           and P_Positions_Shifted\n-            (Positions (Target)'Old,\n-             Positions (Target),\n-             Cut   => P.Get (Positions (Target)'Old, Before),\n-             Count => Length (Source)'Old));\n+                (Positions (Target)'Old,\n+                 Positions (Target),\n+                 Cut   => P.Get (Positions (Target)'Old, Before),\n+                 Count => Length (Source)'Old));\n \n    procedure Splice\n      (Target   : in out List;\n@@ -974,70 +1078,76 @@ is\n    with\n      Global => null,\n      Pre    =>\n-         (Has_Element (Target, Before)\n-          or else Before = No_Element)\n-          and then Has_Element (Source, Position)\n-          and then Length (Target) < Target.Capacity,\n+       (Has_Element (Target, Before) or else Before = No_Element)\n+         and then Has_Element (Source, Position)\n+         and then Length (Target) < Target.Capacity,\n      Post   =>\n-          Length (Target) = Length (Target)'Old + 1\n-          and Length (Source) = Length (Source)'Old - 1\n+       Length (Target) = Length (Target)'Old + 1\n+         and Length (Source) = Length (Source)'Old - 1\n \n-          --  The elements of Source located before Position are preserved.\n-          and M.Range_Equal\n-            (Left  => Model (Source)'Old,\n-             Right => Model (Source),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Source)'Old, Position'Old) - 1)\n+         --  The elements of Source located before Position are preserved\n \n-          --  The elements located after Position are shifted by 1\n-          and M.Range_Shifted\n-            (Left   => Model (Source)'Old,\n-             Right  => Model (Source),\n-             Fst    => P.Get (Positions (Source)'Old, Position'Old) + 1,\n-             Lst    => Length (Source)'Old,\n-             Offset => -1)\n+         and M.Range_Equal\n+               (Left  => Model (Source)'Old,\n+                Right => Model (Source),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Source)'Old, Position'Old) - 1)\n \n-          --  Position has been removed from Source\n-          and P_Positions_Shifted\n-            (Positions (Source),\n-             Positions (Source)'Old,\n-             Cut   => P.Get (Positions (Source)'Old, Position'Old))\n+         --  The elements located after Position are shifted by 1\n \n-          --  Positions is valid in Target and it is located either before\n-          --  Before if it is valid in Target or at the end if it is\n-          --  No_Element.\n-          and P.Has_Key (Positions (Target), Position)\n-          and (if Before = No_Element\n-               then P.Get (Positions (Target), Position)\n-                  = Length (Target)\n-               else P.Get (Positions (Target), Position)\n-                  = P.Get (Positions (Target)'Old, Before))\n-\n-          --  The elements of Target located before Position are preserved.\n-          and M.Range_Equal\n-            (Left  => Model (Target)'Old,\n-             Right => Model (Target),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Target), Position) - 1)\n+         and M.Range_Shifted\n+               (Left   => Model (Source)'Old,\n+                Right  => Model (Source),\n+                Fst    => P.Get (Positions (Source)'Old, Position'Old) + 1,\n+                Lst    => Length (Source)'Old,\n+                Offset => -1)\n \n-          --  Other elements are shifted by 1.\n-          and M.Range_Shifted\n-            (Left   => Model (Target)'Old,\n-             Right  => Model (Target),\n-             Fst    => P.Get (Positions (Target), Position),\n-             Lst    => Length (Target)'Old,\n-             Offset => 1)\n-\n-          --  The element located at Position in Source is moved to Target\n-          and Element (Model (Target), P.Get (Positions (Target), Position))\n-            = Element (Model (Source)'Old,\n-                       P.Get (Positions (Source)'Old, Position'Old))\n-\n-          --  A new cursor has been inserted at position Position in Target\n-          and P_Positions_Shifted\n-            (Positions (Target)'Old,\n-             Positions (Target),\n-             Cut => P.Get (Positions (Target), Position));\n+         --  Position has been removed from Source\n+\n+         and P_Positions_Shifted\n+               (Positions (Source),\n+                Positions (Source)'Old,\n+                Cut   => P.Get (Positions (Source)'Old, Position'Old))\n+\n+         --  Positions is valid in Target and it is located either before\n+         --  Before if it is valid in Target or at the end if it is No_Element.\n+\n+         and P.Has_Key (Positions (Target), Position)\n+         and (if Before = No_Element then\n+                 P.Get (Positions (Target), Position) = Length (Target)\n+              else\n+                 P.Get (Positions (Target), Position) =\n+                 P.Get (Positions (Target)'Old, Before))\n+\n+         --  The elements of Target located before Position are preserved\n+\n+         and M.Range_Equal\n+               (Left  => Model (Target)'Old,\n+                Right => Model (Target),\n+                Fst   => 1,\n+                Lst   => P.Get (Positions (Target), Position) - 1)\n+\n+         --  Other elements are shifted by 1\n+\n+         and M.Range_Shifted\n+               (Left   => Model (Target)'Old,\n+                Right  => Model (Target),\n+                Fst    => P.Get (Positions (Target), Position),\n+                Lst    => Length (Target)'Old,\n+                Offset => 1)\n+\n+         --  The element located at Position in Source is moved to Target\n+\n+         and Element (Model (Target), P.Get (Positions (Target), Position)) =\n+               Element (Model (Source)'Old,\n+                        P.Get (Positions (Source)'Old, Position'Old))\n+\n+         --  A new cursor has been inserted at position Position in Target\n+\n+         and P_Positions_Shifted\n+               (Positions (Target)'Old,\n+                Positions (Target),\n+                Cut => P.Get (Positions (Target), Position));\n \n    procedure Splice\n      (Container : in out List;\n@@ -1046,101 +1156,116 @@ is\n    with\n      Global         => null,\n      Pre            =>\n-         (Has_Element (Container, Before) or else Before = No_Element)\n+       (Has_Element (Container, Before) or else Before = No_Element)\n          and then Has_Element (Container, Position),\n      Post           => Length (Container) = Length (Container)'Old,\n      Contract_Cases =>\n-       (Before = Position   =>\n+       (Before = Position =>\n           Model (Container) = Model (Container)'Old\n-        and Positions (Container) = Positions (Container)'Old,\n+            and Positions (Container) = Positions (Container)'Old,\n \n         Before = No_Element =>\n \n           --  The elements located before Position are preserved\n+\n           M.Range_Equal\n             (Left  => Model (Container)'Old,\n              Right => Model (Container),\n              Fst   => 1,\n              Lst   => P.Get (Positions (Container)'Old, Position) - 1)\n \n           --  The elements located after Position are shifted by 1\n+\n           and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n-             Lst    => Length (Container)'Old,\n-             Offset => -1)\n-\n-          --  The last element of Container is the one that was previously\n-          --  at Position.\n-          and Element (Model (Container), Length (Container))\n-            = Element (Model (Container)'Old,\n-                       P.Get (Positions (Container)'Old, Position))\n+                (Left   => Model (Container)'Old,\n+                 Right  => Model (Container),\n+                 Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n+                 Lst    => Length (Container)'Old,\n+                 Offset => -1)\n+\n+          --  The last element of Container is the one that was previously at\n+          --  Position.\n+\n+          and Element (Model (Container), Length (Container)) =\n+                Element (Model (Container)'Old,\n+                         P.Get (Positions (Container)'Old, Position))\n \n           --  Cursors from Container continue designating the same elements\n+\n           and Mapping_Preserved\n-            (M_Left  => Model (Container)'Old,\n-             M_Right => Model (Container),\n-             P_Left  => Positions (Container)'Old,\n-             P_Right => Positions (Container)),\n+                (M_Left  => Model (Container)'Old,\n+                 M_Right => Model (Container),\n+                 P_Left  => Positions (Container)'Old,\n+                 P_Right => Positions (Container)),\n \n-        others              =>\n+        others =>\n \n           --  The elements located before Position and Before are preserved\n+\n           M.Range_Equal\n             (Left  => Model (Container)'Old,\n              Right => Model (Container),\n              Fst   => 1,\n-             Lst   => Count_Type'Min\n-               (P.Get (Positions (Container)'Old, Position) - 1,\n-                P.Get (Positions (Container)'Old, Before) - 1))\n-\n-          --  The elements located after Position and Before are preserved\n-          and M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => Count_Type'Max\n-               (P.Get (Positions (Container)'Old, Position) + 1,\n-                P.Get (Positions (Container)'Old, Before) + 1),\n-             Lst   => Length (Container))\n-\n-          --  The elements located after Before and before Position are shifted\n-          --  by 1 to the right.\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => P.Get (Positions (Container)'Old, Before) + 1,\n-             Lst    => P.Get (Positions (Container)'Old, Position) - 1,\n-             Offset => 1)\n-\n-          --  The elements located after Position and before Before are shifted\n-          --  by 1 to the left.\n-          and M.Range_Shifted\n-            (Left   => Model (Container)'Old,\n-             Right  => Model (Container),\n-             Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n-             Lst    => P.Get (Positions (Container)'Old, Before) - 1,\n-             Offset => -1)\n-\n-          --  The element previously at Position is now before Before\n-          and Element (Model (Container),\n-                       P.Get (Positions (Container)'Old, Before))\n-            = Element (Model (Container)'Old,\n-                       P.Get (Positions (Container)'Old, Position))\n-\n-          --  Cursors from Container continue designating the same elements\n-          and Mapping_Preserved\n-            (M_Left  => Model (Container)'Old,\n-             M_Right => Model (Container),\n-             P_Left  => Positions (Container)'Old,\n-             P_Right => Positions (Container)));\n+             Lst   =>\n+               Count_Type'Min\n+                 (P.Get (Positions (Container)'Old, Position) - 1,\n+                  P.Get (Positions (Container)'Old, Before) - 1))\n+\n+            --  The elements located after Position and Before are preserved\n+\n+            and M.Range_Equal\n+                  (Left  => Model (Container)'Old,\n+                   Right => Model (Container),\n+                   Fst   =>\n+                     Count_Type'Max\n+                       (P.Get (Positions (Container)'Old, Position) + 1,\n+                        P.Get (Positions (Container)'Old, Before) + 1),\n+                   Lst   => Length (Container))\n+\n+            --  The elements located after Before and before Position are\n+            --  shifted by 1 to the right.\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container)'Old, Before) + 1,\n+                   Lst    => P.Get (Positions (Container)'Old, Position) - 1,\n+                   Offset => 1)\n+\n+            --  The elements located after Position and before Before are\n+            --  shifted by 1 to the left.\n+\n+            and M.Range_Shifted\n+                  (Left   => Model (Container)'Old,\n+                   Right  => Model (Container),\n+                   Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n+                   Lst    => P.Get (Positions (Container)'Old, Before) - 1,\n+                   Offset => -1)\n+\n+            --  The element previously at Position is now before Before\n+\n+            and Element (Model (Container),\n+                         P.Get (Positions (Container)'Old, Before)) =\n+                  Element (Model (Container)'Old,\n+                           P.Get (Positions (Container)'Old, Position))\n+\n+            --  Cursors from Container continue designating the same elements\n+\n+            and Mapping_Preserved\n+                  (M_Left  => Model (Container)'Old,\n+                   M_Right => Model (Container),\n+                   P_Left  => Positions (Container)'Old,\n+                   P_Right => Positions (Container)));\n \n    function First (Container : List) return Cursor with\n      Global         => null,\n      Contract_Cases =>\n-       (Length (Container) = 0 => First'Result = No_Element,\n-        others            => Has_Element (Container, First'Result)\n-        and  P.Get (Positions (Container), First'Result) = 1);\n+       (Length (Container) = 0 =>\n+          First'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, First'Result)\n+            and P.Get (Positions (Container), First'Result) = 1);\n \n    function First_Element (Container : List) return Element_Type with\n      Global => null,\n@@ -1150,65 +1275,79 @@ is\n    function Last (Container : List) return Cursor with\n      Global         => null,\n      Contract_Cases =>\n-       (Length (Container) = 0 => Last'Result = No_Element,\n-        others            => Has_Element (Container, Last'Result)\n-        and P.Get (Positions (Container), Last'Result) = Length (Container));\n+       (Length (Container) = 0 =>\n+          Last'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Last'Result)\n+            and P.Get (Positions (Container), Last'Result) =\n+                  Length (Container));\n \n    function Last_Element (Container : List) return Element_Type with\n      Global => null,\n      Pre    => not Is_Empty (Container),\n-     Post   => Last_Element'Result\n-             = M.Get (Model (Container), Length (Container));\n+     Post   =>\n+       Last_Element'Result = M.Get (Model (Container), Length (Container));\n \n    function Next (Container : List; Position : Cursor) return Cursor with\n      Global         => null,\n-     Pre            => Has_Element (Container, Position)\n-        or else Position = No_Element,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n      Contract_Cases =>\n        (Position = No_Element\n-        or else P.Get (Positions (Container), Position) = Length (Container) =>\n-              Next'Result = No_Element,\n-        others => Has_Element (Container, Next'Result)\n-        and then P.Get (Positions (Container), Next'Result) =\n-          P.Get (Positions (Container), Position) + 1);\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Next'Result = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Next'Result)\n+            and then P.Get (Positions (Container), Next'Result) =\n+                     P.Get (Positions (Container), Position) + 1);\n \n    procedure Next (Container : List; Position : in out Cursor) with\n      Global         => null,\n-     Pre            => Has_Element (Container, Position)\n-        or else Position = No_Element,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n      Contract_Cases =>\n        (Position = No_Element\n-        or else P.Get (Positions (Container), Position) = Length (Container) =>\n-              Position = No_Element,\n-        others => Has_Element (Container, Position)\n-        and then P.Get (Positions (Container), Position) =\n-          P.Get (Positions (Container), Position'Old) + 1);\n+          or else P.Get (Positions (Container), Position) = Length (Container)\n+        =>\n+          Position = No_Element,\n+\n+        others =>\n+          Has_Element (Container, Position)\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) + 1);\n \n    function Previous (Container : List; Position : Cursor) return Cursor with\n      Global         => null,\n-     Pre            => Has_Element (Container, Position)\n-        or else Position = No_Element,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n      Contract_Cases =>\n        (Position = No_Element\n-        or else P.Get (Positions (Container), Position) = 1 =>\n+          or else P.Get (Positions (Container), Position) = 1\n+        =>\n           Previous'Result = No_Element,\n+\n         others =>\n           Has_Element (Container, Previous'Result)\n-        and then P.Get (Positions (Container), Previous'Result) =\n-          P.Get (Positions (Container), Position) - 1);\n+            and then P.Get (Positions (Container), Previous'Result) =\n+                     P.Get (Positions (Container), Position) - 1);\n \n    procedure Previous (Container : List; Position : in out Cursor) with\n      Global         => null,\n-     Pre            => Has_Element (Container, Position)\n-        or else Position = No_Element,\n+     Pre            =>\n+       Has_Element (Container, Position) or else Position = No_Element,\n      Contract_Cases =>\n        (Position = No_Element\n-        or else P.Get (Positions (Container), Position) = 1 =>\n+          or else P.Get (Positions (Container), Position) = 1\n+         =>\n           Position = No_Element,\n+\n         others =>\n           Has_Element (Container, Position)\n-        and then P.Get (Positions (Container), Position) =\n-          P.Get (Positions (Container), Position'Old) - 1);\n+            and then P.Get (Positions (Container), Position) =\n+                     P.Get (Positions (Container), Position'Old) - 1);\n \n    function Find\n      (Container : List;\n@@ -1217,40 +1356,52 @@ is\n    with\n      Global         => null,\n      Pre            =>\n-         Has_Element (Container, Position) or else Position = No_Element,\n+       Has_Element (Container, Position) or else Position = No_Element,\n      Contract_Cases =>\n \n        --  If Item is not is not contained in Container after Position, Find\n        --  returns No_Element.\n+\n        (not M.Contains\n-          (Container => Model (Container),\n-           Fst       => (if Position = No_Element then 1\n-                         else P.Get (Positions (Container), Position)),\n-           Lst       => Length (Container),\n-           Item      => Item)\n+              (Container => Model (Container),\n+               Fst       =>\n+                 (if Position = No_Element then\n+                     1\n+                  else\n+                     P.Get (Positions (Container), Position)),\n+               Lst       => Length (Container),\n+               Item      => Item)\n         =>\n           Find'Result = No_Element,\n \n         --  Otherwise, Find returns a valid cusror in Container\n+\n         others =>\n           P.Has_Key (Positions (Container), Find'Result)\n \n-        --  The element designated by the result of Find is Item\n-        and Element (Model (Container),\n-                     P.Get (Positions (Container), Find'Result)) = Item\n+            --  The element designated by the result of Find is Item\n+\n+            and Element (Model (Container),\n+                         P.Get (Positions (Container), Find'Result)) = Item\n \n-        --  The result of Find is located after Position\n-        and (if Position /= No_Element\n-             then P.Get (Positions (Container), Find'Result)\n-               >= P.Get (Positions (Container), Position))\n+            --  The result of Find is located after Position\n \n-        --  It is the first occurence of Item in this slice\n-        and not M.Contains\n-          (Container => Model (Container),\n-           Fst       => (if Position = No_Element then 1\n-                         else P.Get (Positions (Container), Position)),\n-           Lst       => P.Get (Positions (Container), Find'Result) - 1,\n-           Item      => Item));\n+            and (if Position /= No_Element then\n+                    P.Get (Positions (Container), Find'Result) >=\n+                    P.Get (Positions (Container), Position))\n+\n+            --  It is the first occurence of Item in this slice\n+\n+            and not M.Contains\n+                      (Container => Model (Container),\n+                       Fst       =>\n+                         (if Position = No_Element then\n+                             1\n+                          else\n+                             P.Get (Positions (Container), Position)),\n+                       Lst       =>\n+                         P.Get (Positions (Container), Find'Result) - 1,\n+                       Item      => Item));\n \n    function Reverse_Find\n      (Container : List;\n@@ -1259,70 +1410,88 @@ is\n    with\n      Global         => null,\n      Pre            =>\n-         Has_Element (Container, Position) or else Position = No_Element,\n+       Has_Element (Container, Position) or else Position = No_Element,\n      Contract_Cases =>\n \n        --  If Item is not is not contained in Container before Position, Find\n        --  returns No_Element.\n+\n        (not M.Contains\n-          (Container => Model (Container),\n-           Fst       => 1,\n-           Lst       => (if Position = No_Element then Length (Container)\n-                         else P.Get (Positions (Container), Position)),\n-           Item      => Item)\n+              (Container => Model (Container),\n+               Fst       => 1,\n+               Lst       =>\n+                 (if Position = No_Element then\n+                     Length (Container)\n+                  else\n+                     P.Get (Positions (Container), Position)),\n+               Item      => Item)\n         =>\n           Reverse_Find'Result = No_Element,\n \n         --  Otherwise, Find returns a valid cusror in Container\n+\n         others =>\n           P.Has_Key (Positions (Container), Reverse_Find'Result)\n \n-        --  The element designated by the result of Find is Item\n-        and Element (Model (Container),\n-                     P.Get (Positions (Container), Reverse_Find'Result)) = Item\n+            --  The element designated by the result of Find is Item\n \n-        --  The result of Find is located before Position\n-        and (if Position /= No_Element\n-             then P.Get (Positions (Container), Reverse_Find'Result)\n-               <= P.Get (Positions (Container), Position))\n+            and Element (Model (Container),\n+                         P.Get (Positions (Container),\n+                                Reverse_Find'Result)) = Item\n \n-        --  It is the last occurence of Item in this slice\n-        and not M.Contains\n-          (Container => Model (Container),\n-           Fst       => P.Get (Positions (Container), Reverse_Find'Result) + 1,\n-           Lst       => (if Position = No_Element then Length (Container)\n-                         else P.Get (Positions (Container), Position)),\n-           Item      => Item));\n+            --  The result of Find is located before Position\n+\n+            and (if Position /= No_Element then\n+                    P.Get (Positions (Container), Reverse_Find'Result) <=\n+                    P.Get (Positions (Container), Position))\n+\n+            --  It is the last occurence of Item in this slice\n+\n+            and not M.Contains\n+                      (Container => Model (Container),\n+                       Fst       =>\n+                         P.Get (Positions (Container),\n+                                Reverse_Find'Result) + 1,\n+                       Lst       =>\n+                         (if Position = No_Element then\n+                             Length (Container)\n+                          else\n+                             P.Get (Positions (Container), Position)),\n+                       Item      => Item));\n \n    function Contains\n      (Container : List;\n       Item      : Element_Type) return Boolean\n    with\n      Global => null,\n      Post   =>\n-         Contains'Result = M.Contains (Container => Model (Container),\n-                                       Fst       => 1,\n-                                       Lst       => Length (Container),\n-                                       Item      => Item);\n+       Contains'Result = M.Contains (Container => Model (Container),\n+                                     Fst       => 1,\n+                                     Lst       => Length (Container),\n+                                     Item      => Item);\n \n-   function Has_Element (Container : List; Position : Cursor) return Boolean\n+   function Has_Element\n+     (Container : List;\n+      Position  : Cursor) return Boolean\n    with\n      Global => null,\n      Post   =>\n-         Has_Element'Result = P.Has_Key (Positions (Container), Position);\n+       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n    pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n+\n    package Generic_Sorting with SPARK_Mode is\n       function M_Elements_Sorted (Container : M.Sequence) return Boolean with\n         Ghost,\n         Global => null,\n-        Post   => M_Elements_Sorted'Result =\n-          (for all I in 1 .. M.Length (Container) =>\n-             (for all J in I + 1 .. M.Length (Container) =>\n-                  Element (Container, I) = Element (Container, J)\n-               or Element (Container, I) < Element (Container, J)));\n+        Post   =>\n+          M_Elements_Sorted'Result =\n+            (for all I in 1 .. M.Length (Container) =>\n+              (for all J in I + 1 .. M.Length (Container) =>\n+                 Element (Container, I) = Element (Container, J)\n+                   or Element (Container, I) < Element (Container, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       function Is_Sorted (Container : List) return Boolean with\n@@ -1331,18 +1500,20 @@ is\n \n       procedure Sort (Container : in out List) with\n         Global => null,\n-        Post   => Length (Container) = Length (Container)'Old\n-        and M_Elements_Sorted (Model (Container));\n+        Post   =>\n+          Length (Container) = Length (Container)'Old\n+            and M_Elements_Sorted (Model (Container));\n \n-      procedure Merge (Target, Source : in out List) with\n+      procedure Merge (Target : in out List; Source : in out List) with\n       --  Target and Source should not be aliased\n         Global => null,\n         Pre    => Length (Source) <= Target.Capacity - Length (Target),\n-        Post   => Length (Target) = Length (Target)'Old + Length (Source)'Old\n-        and Length (Source) = 0\n-        and (if M_Elements_Sorted (Model (Target)'Old)\n-               and M_Elements_Sorted (Model (Source)'Old)\n-             then M_Elements_Sorted (Model (Target)));\n+        Post   =>\n+          Length (Target) = Length (Target)'Old + Length (Source)'Old\n+            and Length (Source) = 0\n+            and (if M_Elements_Sorted (Model (Target)'Old)\n+                   and M_Elements_Sorted (Model (Source)'Old)\n+                 then M_Elements_Sorted (Model (Target)));\n    end Generic_Sorting;\n \n private"}, {"sha": "4e7ac38c438cce0f61cce03a33d99ee6b886ce23", "filename": "gcc/ada/a-cofuba.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuba.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuba.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuba.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -33,14 +33,14 @@ pragma Ada_2012;\n \n package body Ada.Containers.Functional_Base with SPARK_Mode => Off is\n \n-   function To_Count (Idx : Extended_Index) return Count_Type\n-   is (Count_Type\n-        (Extended_Index'Pos (Idx) -\n-         Extended_Index'Pos (Extended_Index'First)));\n-\n-   function To_Index (Position : Count_Type) return Extended_Index\n-   is (Extended_Index'Val\n-        (Position + Extended_Index'Pos (Extended_Index'First)));\n+   function To_Count (Idx : Extended_Index) return Count_Type is\n+     (Count_Type\n+       (Extended_Index'Pos (Idx) -\n+        Extended_Index'Pos (Extended_Index'First)));\n+\n+   function To_Index (Position : Count_Type) return Extended_Index is\n+     (Extended_Index'Val\n+       (Position + Extended_Index'Pos (Extended_Index'First)));\n    --  Conversion functions between Index_Type and Count_Type\n \n    function Find (C : Container; E : access Element_Type) return Count_Type;"}, {"sha": "e4ee1988a5a541fdeea5d4300debaa64492bdce1", "filename": "gcc/ada/a-cofuma.adb", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -93,8 +93,8 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n             K : constant Key_Type := Get (Left.Keys, I);\n          begin\n             if not Equivalent_Keys (K, New_Key)\n-              and then Get (Right.Elements, Find (Right.Keys, K))\n-                    /= Get (Left.Elements, I)\n+              and then Get (Right.Elements, Find (Right.Keys, K)) /=\n+                       Get (Left.Elements, I)\n             then\n                return False;\n             end if;\n@@ -106,7 +106,8 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    function Elements_Equal_Except\n      (Left  : Map;\n       Right : Map;\n-      X, Y  : Key_Type) return Boolean\n+      X     : Key_Type;\n+      Y     : Key_Type) return Boolean\n    is\n    begin\n       for I in 1 .. Length (Left.Keys) loop\n@@ -115,8 +116,8 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n          begin\n             if not Equivalent_Keys (K, X)\n               and then not Equivalent_Keys (K, Y)\n-              and then Get (Right.Elements, Find (Right.Keys, K))\n-                    /= Get (Left.Elements, I)\n+              and then Get (Right.Elements, Find (Right.Keys, K)) /=\n+                       Get (Left.Elements, I)\n             then\n                return False;\n             end if;\n@@ -167,6 +168,7 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n             end if;\n          end;\n       end loop;\n+\n       return True;\n    end Keys_Included;\n \n@@ -191,13 +193,15 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n             end if;\n          end;\n       end loop;\n+\n       return True;\n    end Keys_Included_Except;\n \n    function Keys_Included_Except\n      (Left  : Map;\n       Right : Map;\n-      X, Y  : Key_Type) return Boolean\n+      X     : Key_Type;\n+      Y     : Key_Type) return Boolean\n    is\n    begin\n       for I in 1 .. Length (Left.Keys) loop\n@@ -212,6 +216,7 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n             end if;\n          end;\n       end loop;\n+\n       return True;\n    end Keys_Included_Except;\n \n@@ -229,8 +234,8 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    ---------------\n \n    function Same_Keys (Left : Map; Right : Map) return Boolean is\n-      (Keys_Included (Left, Right)\n-            and Keys_Included (Left => Right, Right => Left));\n+     (Keys_Included (Left, Right)\n+       and Keys_Included (Left => Right, Right => Left));\n \n    ---------\n    -- Set --\n@@ -243,6 +248,6 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    is\n      (Keys     => Container.Keys,\n       Elements =>\n-         Set (Container.Elements, Find (Container.Keys, Key), New_Item));\n+        Set (Container.Elements, Find (Container.Keys, Key), New_Item));\n \n end Ada.Containers.Functional_Maps;"}, {"sha": "9d3bb9786bc03af200fc6574d700be435d159bba", "filename": "gcc/ada/a-cofuma.ads", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -36,6 +36,7 @@ generic\n    type Key_Type (<>) is private;\n    type Element_Type (<>)  is private;\n    with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n+\n package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n    type Map is private with\n@@ -90,9 +91,9 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Post   =>\n        \"=\"'Result =\n          ((for all Key of Left =>\n-                   Has_Key (Right, Key)\n-           and then Get (Right, Key) = Get (Left, Key))\n-          and (for all Key of Right => Has_Key (Left, Key)));\n+             Has_Key (Right, Key)\n+               and then Get (Right, Key) = Get (Left, Key))\n+               and (for all Key of Right => Has_Key (Left, Key)));\n \n    pragma Warnings (Off, \"unused variable \"\"Key\"\"\");\n    function Is_Empty (Container : Map) return Boolean with\n@@ -117,8 +118,8 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Global => null,\n      Post   =>\n        Same_Keys'Result =\n-           (Keys_Included (Left, Right)\n-            and Keys_Included (Left => Right, Right => Left));\n+         (Keys_Included (Left, Right)\n+           and Keys_Included (Left => Right, Right => Left));\n    pragma Annotate (GNATprove, Inline_For_Proof, Same_Keys);\n \n    function Keys_Included_Except\n@@ -130,24 +131,27 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n    with\n      Global => null,\n      Post   =>\n-         Keys_Included_Except'Result =\n-           (for all Key of Left =>\n-              (if not Equivalent_Keys (Key, New_Key)\n-               then Has_Key (Right, Key)));\n+       Keys_Included_Except'Result =\n+         (for all Key of Left =>\n+           (if not Equivalent_Keys (Key, New_Key) then\n+               Has_Key (Right, Key)));\n \n    function Keys_Included_Except\n      (Left  : Map;\n       Right : Map;\n-      X, Y  : Key_Type) return Boolean\n+      X     : Key_Type;\n+      Y     : Key_Type) return Boolean\n    --  Returns True if Left contains only keys of Right and possibly X and Y\n \n    with\n      Global => null,\n      Post   =>\n-         Keys_Included_Except'Result =\n-           (for all Key of Left =>\n-              (if not Equivalent_Keys (Key, X) and not Equivalent_Keys (Key, Y)\n-               then Has_Key (Right, Key)));\n+       Keys_Included_Except'Result =\n+         (for all Key of Left =>\n+           (if not Equivalent_Keys (Key, X)\n+              and not Equivalent_Keys (Key, Y)\n+            then\n+               Has_Key (Right, Key)));\n \n    function Elements_Equal_Except\n      (Left    : Map;\n@@ -162,13 +166,14 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Post   =>\n        Elements_Equal_Except'Result =\n          (for all Key of Left =>\n-            (if not Equivalent_Keys (Key, New_Key)\n-             then Get (Left, Key) = Get (Right, Key)));\n+           (if not Equivalent_Keys (Key, New_Key) then\n+               Get (Left, Key) = Get (Right, Key)));\n \n    function Elements_Equal_Except\n      (Left  : Map;\n       Right : Map;\n-      X, Y  : Key_Type) return Boolean\n+      X     : Key_Type;\n+      Y     : Key_Type) return Boolean\n    --  Returns True if all the keys of Left are mapped to the same elements in\n    --  Left and Right except X and Y.\n \n@@ -178,8 +183,10 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Post   =>\n        Elements_Equal_Except'Result =\n          (for all Key of Left =>\n-            (if not Equivalent_Keys (Key, X) and not Equivalent_Keys (Key, Y)\n-             then Get (Left, Key) = Get (Right, Key)));\n+           (if not Equivalent_Keys (Key, X)\n+              and not Equivalent_Keys (Key, Y)\n+            then\n+               Get (Left, Key) = Get (Right, Key)));\n \n    ----------------------------\n    -- Construction Functions --\n@@ -192,19 +199,19 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      (Container : Map;\n       New_Key   : Key_Type;\n       New_Item  : Element_Type) return Map\n-   --  Returns Container augmented with the mapping Key -> New_Item.\n+   --  Returns Container augmented with the mapping Key -> New_Item\n \n    with\n      Global => null,\n      Pre    =>\n-         not Has_Key (Container, New_Key)\n-       and Length (Container) < Count_Type'Last,\n+       not Has_Key (Container, New_Key)\n+         and Length (Container) < Count_Type'Last,\n      Post   =>\n        Length (Container) + 1 = Length (Add'Result)\n-       and Has_Key (Add'Result, New_Key)\n-       and Get (Add'Result, New_Key) = New_Item\n-       and Container <= Add'Result\n-       and Keys_Included_Except (Add'Result, Container, New_Key);\n+         and Has_Key (Add'Result, New_Key)\n+         and Get (Add'Result, New_Key) = New_Item\n+         and Container <= Add'Result\n+         and Keys_Included_Except (Add'Result, Container, New_Key);\n \n    function Set\n      (Container : Map;\n@@ -218,9 +225,9 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n      Pre    => Has_Key (Container, Key),\n      Post   =>\n        Length (Container) = Length (Set'Result)\n-       and Get (Set'Result, Key) = New_Item\n-       and Same_Keys (Container, Set'Result)\n-       and Elements_Equal_Except (Container, Set'Result, Key);\n+         and Get (Set'Result, Key) = New_Item\n+         and Same_Keys (Container, Set'Result)\n+         and Elements_Equal_Except (Container, Set'Result, Key);\n \n    ---------------------------\n    --  Iteration Primitives --\n@@ -281,11 +288,15 @@ private\n    is\n      (Count_Type (Key) in 1 .. Key_Containers.Length (Container.Keys));\n \n-   function Iter_Next (Container : Map; Key : Private_Key) return Private_Key\n+   function Iter_Next\n+     (Container : Map;\n+      Key       : Private_Key) return Private_Key\n    is\n      (if Key = Private_Key'Last then 0 else Key + 1);\n \n-   function Iter_Element (Container : Map; Key : Private_Key) return Key_Type\n+   function Iter_Element\n+     (Container : Map;\n+      Key       : Private_Key) return Key_Type\n    is\n      (Key_Containers.Get (Container.Keys, Count_Type (Key)));\n "}, {"sha": "e0ea2ff9b483b46ab1d9a64cacac6ec9c940cc95", "filename": "gcc/ada/a-cofuse.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -54,7 +54,7 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n \n    function Add (Container : Set; Item : Element_Type) return Set is\n      (Content =>\n-         Add (Container.Content, Length (Container.Content) + 1, Item));\n+       Add (Container.Content, Length (Container.Content) + 1, Item));\n \n    --------------\n    -- Contains --\n@@ -73,7 +73,7 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n       Item  : Element_Type) return Boolean\n    is\n      (for all E of Left =>\n-         Equivalent_Elements (E, Item) or Contains (Right, E));\n+       Equivalent_Elements (E, Item) or Contains (Right, E));\n \n    -----------------------\n    -- Included_In_Union --\n@@ -85,7 +85,7 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n       Right     : Set) return Boolean\n    is\n      (for all Item of Container =>\n-         Contains (Left, Item) or Contains (Right, Item));\n+       Contains (Left, Item) or Contains (Right, Item));\n \n    ---------------------------\n    -- Includes_Intersection --\n@@ -97,7 +97,7 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n       Right     : Set) return Boolean\n    is\n      (for all Item of Left =>\n-        (if Contains (Right, Item) then Contains (Container, Item)));\n+       (if Contains (Right, Item) then Contains (Container, Item)));\n \n    ------------------\n    -- Intersection --"}, {"sha": "16a4a4d05996f080843136dd783dc536f6d785cd", "filename": "gcc/ada/a-cofuse.ads", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.ads?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -34,8 +34,10 @@ private with Ada.Containers.Functional_Base;\n \n generic\n    type Element_Type (<>) is private;\n-   with\n-     function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n+   with function Equivalent_Elements\n+     (Left  : Element_Type;\n+      Right : Element_Type) return Boolean;\n+\n package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n    type Set is private with\n@@ -80,8 +82,8 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n      Global => null,\n      Post   =>\n        \"=\"'Result =\n-         ((for all Item of Left => Contains (Right, Item))\n-             and (for all Item of Right => Contains (Left, Item)));\n+         (for all Item of Left => Contains (Right, Item))\n+           and (for all Item of Right => Contains (Left, Item));\n \n    pragma Warnings (Off, \"unused variable \"\"Item\"\"\");\n    function Is_Empty (Container : Set) return Boolean with\n@@ -102,8 +104,8 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n      Global => null,\n      Post   =>\n        Included_Except'Result =\n-           (for all E of Left =>\n-              Contains (Right, E) or Equivalent_Elements (E, Item));\n+         (for all E of Left =>\n+           Contains (Right, E) or Equivalent_Elements (E, Item));\n \n    function Includes_Intersection\n      (Container : Set;\n@@ -117,7 +119,7 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n      Post   =>\n        Includes_Intersection'Result =\n          (for all Item of Left =>\n-             (if Contains (Right, Item) then Contains (Container, Item)));\n+           (if Contains (Right, Item) then Contains (Container, Item)));\n \n    function Included_In_Union\n      (Container : Set;\n@@ -130,7 +132,7 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n      Post   =>\n        Included_In_Union'Result =\n          (for all Item of Container =>\n-            Contains (Left, Item) or Contains (Right, Item));\n+           Contains (Left, Item) or Contains (Right, Item));\n \n    function Num_Overlaps (Left : Set; Right : Set) return Count_Type with\n    --  Number of elements that are both in Left and Right\n@@ -158,9 +160,9 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n        and Length (Container) < Count_Type'Last,\n      Post   =>\n        Length (Add'Result) = Length (Container) + 1\n-       and Contains (Add'Result, Item)\n-       and Container <= Add'Result\n-       and Included_Except (Add'Result, Container, Item);\n+         and Contains (Add'Result, Item)\n+         and Container <= Add'Result\n+         and Included_Except (Add'Result, Container, Item);\n \n    function Remove (Container : Set; Item : Element_Type) return Set with\n    --  Return a new set containing all the elements of Container except E\n@@ -169,9 +171,9 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n      Pre    => Contains (Container, Item),\n      Post   =>\n        Length (Remove'Result) = Length (Container) - 1\n-       and not Contains (Remove'Result, Item)\n-       and Remove'Result <= Container\n-       and Included_Except (Container, Remove'Result, Item);\n+         and not Contains (Remove'Result, Item)\n+         and Remove'Result <= Container\n+         and Included_Except (Container, Remove'Result, Item);\n \n    function Intersection (Left : Set; Right : Set) return Set with\n    --  Returns the intersection of Left and Right\n@@ -188,8 +190,8 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n      Global => null,\n      Pre    =>\n-       Length (Left) - Num_Overlaps (Left, Right)\n-         <= Count_Type'Last - Length (Right),\n+       Length (Left) - Num_Overlaps (Left, Right) <=\n+         Count_Type'Last - Length (Right),\n      Post   =>\n        Length (Union'Result) =\n          Length (Left) - Num_Overlaps (Left, Right) + Length (Right)\n@@ -212,7 +214,9 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n    with\n      Global => null;\n \n-   function Iter_Next (Container : Set; Key : Private_Key) return Private_Key\n+   function Iter_Next\n+     (Container : Set;\n+      Key       : Private_Key) return Private_Key\n    with\n      Global => null,\n      Pre    => Iter_Has_Element (Container, Key);\n@@ -249,7 +253,9 @@ private\n    is\n      (Count_Type (Key) in 1 .. Containers.Length (Container.Content));\n \n-   function Iter_Next (Container : Set; Key : Private_Key) return Private_Key\n+   function Iter_Next\n+     (Container : Set;\n+      Key       : Private_Key) return Private_Key\n    is\n      (if Key = Private_Key'Last then 0 else Key + 1);\n "}, {"sha": "2984bcc4b7200cbc2c438997584df051145d1d30", "filename": "gcc/ada/a-cofuve.adb", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -40,7 +40,7 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    function \"<\" (Left : Sequence; Right : Sequence) return Boolean is\n      (Length (Left.Content) < Length (Right.Content)\n        and then (for all I in Index_Type'First .. Last (Left) =>\n-                   Get (Left.Content, I) = Get (Right.Content, I)));\n+                  Get (Left.Content, I) = Get (Right.Content, I)));\n \n    ----------\n    -- \"<=\" --\n@@ -49,7 +49,7 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    function \"<=\" (Left : Sequence; Right : Sequence) return Boolean is\n      (Length (Left.Content) <= Length (Right.Content)\n        and then (for all I in Index_Type'First .. Last (Left) =>\n-                   Get (Left.Content, I) = Get (Right.Content, I)));\n+                  Get (Left.Content, I) = Get (Right.Content, I)));\n \n    ---------\n    -- \"=\" --\n@@ -62,13 +62,15 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    -- Add --\n    ---------\n \n-   function Add (Container : Sequence; New_Item : Element_Type) return Sequence\n+   function Add\n+     (Container : Sequence;\n+      New_Item  : Element_Type) return Sequence\n    is\n-     (Content => Add (Container.Content,\n-                      Index_Type'Val\n-                        (Index_Type'Pos (Index_Type'First) +\n-                             Length (Container.Content)),\n-                      New_Item));\n+     (Content =>\n+       Add (Container.Content,\n+            Index_Type'Val (Index_Type'Pos (Index_Type'First) +\n+                            Length (Container.Content)),\n+            New_Item));\n \n    function Add\n      (Container : Sequence;\n@@ -92,6 +94,7 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n             return False;\n          end if;\n       end loop;\n+\n       return True;\n    end Constant_Range;\n \n@@ -111,6 +114,7 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n             return True;\n          end if;\n       end loop;\n+\n       return False;\n    end Contains;\n \n@@ -142,7 +146,8 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    function Equal_Except\n      (Left  : Sequence;\n       Right : Sequence;\n-      X, Y  : Index_Type) return Boolean\n+      X     : Index_Type;\n+      Y     : Index_Type) return Boolean\n    is\n    begin\n       if Length (Left.Content) /= Length (Right.Content) then\n@@ -174,8 +179,8 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    ----------\n \n    function Last (Container : Sequence) return Extended_Index is\n-     (Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1)\n-                      + Length (Container)));\n+     (Index_Type'Val\n+       ((Index_Type'Pos (Index_Type'First) - 1) + Length (Container)));\n \n    ------------\n    -- Length --\n@@ -200,6 +205,7 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n             return False;\n          end if;\n       end loop;\n+\n       return True;\n    end Range_Equal;\n \n@@ -216,8 +222,8 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    is\n    begin\n       for I in Fst .. Lst loop\n-         if Get (Left, I)\n-           /= Get (Right, Index_Type'Val (Index_Type'Pos (I) + Offset))\n+         if Get (Left, I) /=\n+              Get (Right, Index_Type'Val (Index_Type'Pos (I) + Offset))\n          then\n             return False;\n          end if;\n@@ -229,8 +235,9 @@ package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    -- Remove --\n    ------------\n \n-   function Remove (Container : Sequence;\n-                    Position : Index_Type) return Sequence\n+   function Remove\n+     (Container : Sequence;\n+      Position : Index_Type) return Sequence\n    is\n      (Content => Remove (Container.Content, Position));\n "}, {"sha": "d02864e4329fd43f12ca053e3c6f92424b25f1f0", "filename": "gcc/ada/a-cofuve.ads", "status": "modified", "additions": 65, "deletions": 57, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fa-cofuve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.ads?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -38,6 +38,7 @@ generic\n    --  should have at least one more element at the low end than Index_Type.\n \n    type Element_Type (<>) is private;\n+\n package Ada.Containers.Functional_Vectors with SPARK_Mode is\n \n    subtype Extended_Index is Index_Type'Base range\n@@ -69,7 +70,7 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Global => null,\n      Post   =>\n        (Index_Type'Pos (Index_Type'First) - 1) + Length'Result <=\n-          Index_Type'Pos (Index_Type'Last);\n+         Index_Type'Pos (Index_Type'Last);\n \n    function Get\n      (Container : Sequence;\n@@ -86,8 +87,8 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Global => null,\n      Post =>\n        Last'Result =\n-         Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1)\n-                         + Length (Container));\n+         Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1) +\n+           Length (Container));\n    pragma Annotate (GNATprove, Inline_For_Proof, Last);\n \n    function First return Extended_Index is (Index_Type'First);\n@@ -104,8 +105,8 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Post   =>\n        \"=\"'Result =\n          (Length (Left) = Length (Right)\n-          and then (for all N in Index_Type'First .. Last (Left) =>\n-              Get (Left, N) = Get (Right, N)));\n+           and then (for all N in Index_Type'First .. Last (Left) =>\n+                      Get (Left, N) = Get (Right, N)));\n    pragma Annotate (GNATprove, Inline_For_Proof, \"=\");\n \n    function \"<\" (Left : Sequence; Right : Sequence) return Boolean with\n@@ -115,8 +116,8 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Post   =>\n        \"<\"'Result =\n          (Length (Left) < Length (Right)\n-          and then (for all N in Index_Type'First .. Last (Left) =>\n-              Get (Left, N) = Get (Right, N)));\n+           and then (for all N in Index_Type'First .. Last (Left) =>\n+                      Get (Left, N) = Get (Right, N)));\n    pragma Annotate (GNATprove, Inline_For_Proof, \"<\");\n \n    function \"<=\" (Left : Sequence; Right : Sequence) return Boolean with\n@@ -126,16 +127,15 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Post   =>\n        \"<=\"'Result =\n          (Length (Left) <= Length (Right)\n-          and then (for all N in Index_Type'First .. Last (Left) =>\n-              Get (Left, N) = Get (Right, N)));\n+           and then (for all N in Index_Type'First .. Last (Left) =>\n+                      Get (Left, N) = Get (Right, N)));\n    pragma Annotate (GNATprove, Inline_For_Proof, \"<=\");\n \n    function Contains\n      (Container : Sequence;\n       Fst       : Index_Type;\n       Lst       : Extended_Index;\n-      Item      : Element_Type)\n-         return Boolean\n+      Item      : Element_Type) return Boolean\n    --  Returns True if Item occurs in the range from Fst to Lst of Container\n \n    with\n@@ -150,8 +150,7 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      (Container : Sequence;\n       Fst       : Index_Type;\n       Lst       : Extended_Index;\n-      Item      : Element_Type)\n-         return Boolean\n+      Item      : Element_Type) return Boolean\n    --  Returns True if every element of the range from Fst to Lst of Container\n    --  is equal to Item.\n \n@@ -175,14 +174,15 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Post   =>\n        Equal_Except'Result =\n          (Length (Left) = Length (Right)\n-          and then (for all I in Index_Type'First .. Last (Left) =>\n-              (if I /= Position then Get (Left, I) = Get (Right, I))));\n+           and then (for all I in Index_Type'First .. Last (Left) =>\n+                      (if I /= Position then Get (Left, I) = Get (Right, I))));\n    pragma Annotate (GNATprove, Inline_For_Proof, Equal_Except);\n \n    function Equal_Except\n      (Left  : Sequence;\n       Right : Sequence;\n-      X, Y  : Index_Type) return Boolean\n+      X     : Index_Type;\n+      Y     : Index_Type) return Boolean\n    --  Returns True is Left and Right are the same except at positions X and Y\n \n    with\n@@ -191,8 +191,9 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Post   =>\n        Equal_Except'Result =\n          (Length (Left) = Length (Right)\n-          and then (for all I in Index_Type'First .. Last (Left) =>\n-              (if I /= X and I /= Y then Get (Left, I) = Get (Right, I))));\n+           and then (for all I in Index_Type'First .. Last (Left) =>\n+                      (if I /= X and I /= Y then\n+                          Get (Left, I) = Get (Right, I))));\n    pragma Annotate (GNATprove, Inline_For_Proof, Equal_Except);\n \n    function Range_Equal\n@@ -222,21 +223,23 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n \n    with\n      Global => null,\n-     Pre    => Lst <= Last (Left)\n-           and Offset in\n-              Index_Type'Pos (Index_Type'First) - Index_Type'Pos (Fst) ..\n-                   (Index_Type'Pos (Index_Type'First) - 1)\n-                  + Length (Right) - Index_Type'Pos (Lst),\n+     Pre    =>\n+       Lst <= Last (Left)\n+         and Offset in\n+           Index_Type'Pos (Index_Type'First) - Index_Type'Pos (Fst) ..\n+             (Index_Type'Pos (Index_Type'First) - 1) + Length (Right) -\n+              Index_Type'Pos (Lst),\n      Post   =>\n        Range_Shifted'Result =\n          ((for all I in Fst .. Lst =>\n-                   Get (Left, I)\n-           = Get (Right, Index_Type'Val (Index_Type'Pos (I) + Offset)))\n+            Get (Left, I) =\n+            Get (Right, Index_Type'Val (Index_Type'Pos (I) + Offset)))\n           and\n             (for all I in Index_Type'Val (Index_Type'Pos (Fst) + Offset) ..\n-               Index_Type'Val (Index_Type'Pos (Lst) + Offset) =>\n-                 Get (Left, Index_Type'Val (Index_Type'Pos (I) - Offset))\n-             = Get (Right, I)));\n+               Index_Type'Val (Index_Type'Pos (Lst) + Offset)\n+             =>\n+               Get (Left, Index_Type'Val (Index_Type'Pos (I) - Offset)) =\n+               Get (Right, I)));\n    pragma Annotate (GNATprove, Inline_For_Proof, Range_Shifted);\n \n    ----------------------------\n@@ -256,8 +259,9 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n    with\n      Global => null,\n      Pre    => Position in Index_Type'First .. Last (Container),\n-     Post   => Get (Set'Result, Position) = New_Item\n-     and then Equal_Except (Container, Set'Result, Position);\n+     Post   =>\n+       Get (Set'Result, Position) = New_Item\n+         and then Equal_Except (Container, Set'Result, Position);\n \n    function Add (Container : Sequence; New_Item : Element_Type) return Sequence\n    --  Returns a new sequence which contains the same elements as Container\n@@ -289,17 +293,17 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n      Post   =>\n        Length (Add'Result) = Length (Container) + 1\n          and then Get (Add'Result, Position) = New_Item\n-         and then\n-            Range_Equal (Left  => Container,\n-                         Right =>  Add'Result,\n-                         Fst   => Index_Type'First,\n-                         Lst   => Index_Type'Pred (Position))\n-         and then\n-            Range_Shifted (Left   => Container,\n-                           Right  => Add'Result,\n-                           Fst    => Position,\n-                           Lst    => Last (Container),\n-                           Offset => 1);\n+         and then Range_Equal\n+                    (Left  => Container,\n+                     Right =>  Add'Result,\n+                     Fst   => Index_Type'First,\n+                     Lst   => Index_Type'Pred (Position))\n+         and then Range_Shifted\n+                    (Left   => Container,\n+                     Right  => Add'Result,\n+                     Fst    => Position,\n+                     Lst    => Last (Container),\n+                     Offset => 1);\n \n    function Remove\n      (Container : Sequence;\n@@ -315,17 +319,17 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n          and Position in Index_Type'First .. Last (Container),\n      Post   =>\n        Length (Remove'Result) = Length (Container) - 1\n-         and then\n-            Range_Equal (Left  => Container,\n-                         Right => Remove'Result,\n-                         Fst   => Index_Type'First,\n-                         Lst   => Index_Type'Pred (Position))\n-         and then\n-            Range_Shifted (Left   => Remove'Result,\n-                           Right  => Container,\n-                           Fst    => Position,\n-                           Lst    => Last (Remove'Result),\n-                           Offset => 1);\n+         and then Range_Equal\n+                    (Left  => Container,\n+                     Right => Remove'Result,\n+                     Fst   => Index_Type'First,\n+                     Lst   => Index_Type'Pred (Position))\n+         and then Range_Shifted\n+                    (Left   => Remove'Result,\n+                     Right  => Container,\n+                     Fst    => Position,\n+                     Lst    => Last (Remove'Result),\n+                     Offset => 1);\n \n    ---------------------------\n    --  Iteration Primitives --\n@@ -339,7 +343,8 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n       Position  : Extended_Index) return Boolean\n    with\n      Global => null,\n-     Post   => Iter_Has_Element'Result =\n+     Post   =>\n+       Iter_Has_Element'Result =\n          (Position in Index_Type'First .. Last (Container));\n    pragma Annotate (GNATprove, Inline_For_Proof, Iter_Has_Element);\n \n@@ -364,19 +369,22 @@ private\n \n    function Iter_First (Container : Sequence) return Extended_Index is\n      (Index_Type'First);\n+\n    function Iter_Next\n      (Container : Sequence;\n       Position  : Extended_Index) return Extended_Index\n    is\n-     (if Position = Extended_Index'Last then Extended_Index'First\n-      else Extended_Index'Succ (Position));\n+     (if Position = Extended_Index'Last then\n+         Extended_Index'First\n+      else\n+         Extended_Index'Succ (Position));\n \n    function Iter_Has_Element\n      (Container : Sequence;\n       Position  : Extended_Index) return Boolean\n    is\n      (Position in Index_Type'First ..\n-        (Index_Type'Val\n-           ((Index_Type'Pos (Index_Type'First) - 1) + Length (Container))));\n+       (Index_Type'Val\n+         ((Index_Type'Pos (Index_Type'First) - 1) + Length (Container))));\n \n end Ada.Containers.Functional_Vectors;"}, {"sha": "56a92d3aaee82a0857ff358edeb23027aa2eb53c", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -3598,6 +3598,14 @@ package body Exp_Attr is\n       --  Image attribute is handled in separate unit Exp_Imgv\n \n       when Attribute_Image =>\n+\n+         --  Leave attribute unexpanded in CodePeer mode: the gnat2scil\n+         --  back-end knows how to handle this attribute directly.\n+\n+         if CodePeer_Mode then\n+            return;\n+         end if;\n+\n          Exp_Imgv.Expand_Image_Attribute (N);\n \n       ---------\n@@ -6995,6 +7003,14 @@ package body Exp_Attr is\n       --  Wide_Image attribute is handled in separate unit Exp_Imgv\n \n       when Attribute_Wide_Image =>\n+\n+         --  Leave attribute unexpanded in CodePeer mode: the gnat2scil\n+         --  back-end knows how to handle this attribute directly.\n+\n+         if CodePeer_Mode then\n+            return;\n+         end if;\n+\n          Exp_Imgv.Expand_Wide_Image_Attribute (N);\n \n       ---------------------\n@@ -7004,6 +7020,14 @@ package body Exp_Attr is\n       --  Wide_Wide_Image attribute is handled in separate unit Exp_Imgv\n \n       when Attribute_Wide_Wide_Image =>\n+\n+         --  Leave attribute unexpanded in CodePeer mode: the gnat2scil\n+         --  back-end knows how to handle this attribute directly.\n+\n+         if CodePeer_Mode then\n+            return;\n+         end if;\n+\n          Exp_Imgv.Expand_Wide_Wide_Image_Attribute (N);\n \n       ----------------"}, {"sha": "4bdd525d90c4e6f8668fe93e86fb6b535f04a4c2", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -4510,10 +4510,13 @@ package body Exp_Disp is\n \n       if Building_Static_DT (Typ) then\n          declare\n-            Save      : constant Boolean := Freezing_Library_Level_Tagged_Type;\n+            Saved_FLLTT : constant Boolean :=\n+                            Freezing_Library_Level_Tagged_Type;\n+\n+            Formal    : Entity_Id;\n+            Frnodes   : List_Id;\n             Prim      : Entity_Id;\n             Prim_Elmt : Elmt_Id;\n-            Frnodes   : List_Id;\n \n          begin\n             Freezing_Library_Level_Tagged_Type := True;\n@@ -4523,18 +4526,21 @@ package body Exp_Disp is\n                Prim    := Node (Prim_Elmt);\n                Frnodes := Freeze_Entity (Prim, Typ);\n \n-               declare\n-                  F : Entity_Id;\n-\n-               begin\n-                  F := First_Formal (Prim);\n-                  while Present (F) loop\n-                     Check_Premature_Freezing (Prim, Typ, Etype (F));\n-                     Next_Formal (F);\n+               --  We disable this check for abstract subprograms, given that\n+               --  they cannot be called directly and thus the state of their\n+               --  untagged formals is of no concern. The RM is unclear in any\n+               --  case concerning the need for this check, and this topic may\n+               --  go back to the ARG.\n+\n+               if not Is_Abstract_Subprogram (Prim)  then\n+                  Formal := First_Formal (Prim);\n+                  while Present (Formal) loop\n+                     Check_Premature_Freezing (Prim, Typ, Etype (Formal));\n+                     Next_Formal (Formal);\n                   end loop;\n \n                   Check_Premature_Freezing (Prim, Typ, Etype (Prim));\n-               end;\n+               end if;\n \n                if Present (Frnodes) then\n                   Append_List_To (Result, Frnodes);\n@@ -4543,7 +4549,7 @@ package body Exp_Disp is\n                Next_Elmt (Prim_Elmt);\n             end loop;\n \n-            Freezing_Library_Level_Tagged_Type := Save;\n+            Freezing_Library_Level_Tagged_Type := Saved_FLLTT;\n          end;\n       end if;\n "}, {"sha": "0184d8e97483d144566346161b408fc9a429eb8a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -6310,21 +6310,28 @@ package body Sem_Attr is\n                end;\n             end if;\n \n-            --  Fold in representation aspects for the type, which appear in\n-            --  the same source buffer.\n+            if Is_First_Subtype (T) then\n \n-            Rep := First_Rep_Item (T);\n+               --  Fold in representation aspects for the type, which appear in\n+               --  the same source buffer. If the representation aspects are in\n+               --  a different source file, then skip them; they apply to some\n+               --  other type, perhaps one we're derived from.\n \n-            while Present (Rep) loop\n-               if Comes_From_Source (Rep) then\n-                  Sloc_Range (Rep, P_Min, P_Max);\n-                  pragma Assert (SFI = Get_Source_File_Index (P_Min));\n-                  pragma Assert (SFI = Get_Source_File_Index (P_Max));\n-                  Process_One_Declaration;\n-               end if;\n+               Rep := First_Rep_Item (T);\n \n-               Rep := Next_Rep_Item (Rep);\n-            end loop;\n+               while Present (Rep) loop\n+                  if Comes_From_Source (Rep) then\n+                     Sloc_Range (Rep, P_Min, P_Max);\n+\n+                     if SFI = Get_Source_File_Index (P_Min) then\n+                        pragma Assert (SFI = Get_Source_File_Index (P_Max));\n+                        Process_One_Declaration;\n+                     end if;\n+                  end if;\n+\n+                  Rep := Next_Rep_Item (Rep);\n+               end loop;\n+            end if;\n          end Compute_Type_Key;\n \n       --  Start of processing for Type_Key"}, {"sha": "8da266ac11ed582879a5a03df4682613aafb2ec5", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -1463,6 +1463,25 @@ package body Sem_Ch4 is\n          --  actuals.\n \n          Check_Function_Writable_Actuals (N);\n+\n+         --  The return type of the function may be incomplete. This can be\n+         --  the case if the type is a generic formal, or a limited view. It\n+         --  can also happen when the function declaration appears before the\n+         --  full view of the type (which is legal in Ada 2012) and the call\n+         --  appears in a different unit, in which case the incomplete view\n+         --  must be replaced with the full view to prevent subsequent type\n+         --  errors.\n+\n+         if Is_Incomplete_Type (Etype (N))\n+           and then Present (Full_View (Etype (N)))\n+         then\n+            if Is_Entity_Name (Nam) then\n+               Set_Etype (Nam, Full_View (Etype (N)));\n+               Set_Etype (Entity (Nam), Full_View (Etype (N)));\n+            end if;\n+\n+            Set_Etype (N, Full_View (Etype (N)));\n+         end if;\n       end if;\n    end Analyze_Call;\n "}, {"sha": "24e0963c88e5fde9a64746c4ffc1535fe60b68b8", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b63d61f7d1256c255013af6ea4b0f64bdd6d7340/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=b63d61f7d1256c255013af6ea4b0f64bdd6d7340", "patch": "@@ -630,17 +630,17 @@ package body Sem_Eval is\n       --  to discrete and non-discrete types.\n \n       elsif (Nkind (Choice) = N_Subtype_Indication\n-               or else (Is_Entity_Name (Choice)\n-                         and then Is_Type (Entity (Choice))))\n+              or else (Is_Entity_Name (Choice)\n+                        and then Is_Type (Entity (Choice))))\n         and then Has_Predicates (Etype (Choice))\n         and then Has_Static_Predicate (Etype (Choice))\n       then\n          if Is_Discrete_Type (Etype (Choice)) then\n-            return Choices_Match\n-              (Expr, Static_Discrete_Predicate (Etype (Choice)));\n+            return\n+              Choices_Match\n+                (Expr, Static_Discrete_Predicate (Etype (Choice)));\n \n-         elsif\n-            Real_Or_String_Static_Predicate_Matches (Expr, Etype (Choice))\n+         elsif Real_Or_String_Static_Predicate_Matches (Expr, Etype (Choice))\n          then\n             return Match;\n "}]}