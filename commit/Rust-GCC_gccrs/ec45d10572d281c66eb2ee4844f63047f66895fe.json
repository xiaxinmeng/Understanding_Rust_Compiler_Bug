{"sha": "ec45d10572d281c66eb2ee4844f63047f66895fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM0NWQxMDU3MmQyODFjNjZlYjJlZTQ4NDRmNjMwNDdmNjY4OTVmZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2008-07-20T20:31:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-20T20:31:59Z"}, "message": "* gnathtml.pl: New file.\n\nFrom-SVN: r138013", "tree": {"sha": "bfe7d8b69b98c27b1e48c4aa71765056ba1953b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfe7d8b69b98c27b1e48c4aa71765056ba1953b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec45d10572d281c66eb2ee4844f63047f66895fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec45d10572d281c66eb2ee4844f63047f66895fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec45d10572d281c66eb2ee4844f63047f66895fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec45d10572d281c66eb2ee4844f63047f66895fe/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "34a87fd4ea315151d6103662893ba4b02010f59a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a87fd4ea315151d6103662893ba4b02010f59a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34a87fd4ea315151d6103662893ba4b02010f59a"}], "stats": {"total": 1119, "additions": 1119, "deletions": 0}, "files": [{"sha": "bb42b64460a50f479dea2802a13c44b70e929046", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec45d10572d281c66eb2ee4844f63047f66895fe/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec45d10572d281c66eb2ee4844f63047f66895fe/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ec45d10572d281c66eb2ee4844f63047f66895fe", "patch": "@@ -1,3 +1,7 @@\n+2008-07-20  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnathtml.pl: New file.\n+\n 2008-07-19  Olivier Hainque  <hainque@adacore.com>\n \t \n \t* targtyps.c (get_target_default_allocator_alignment): Use"}, {"sha": "9d893268055f42fe2fa306f8d3aea1d19c077d0a", "filename": "gcc/ada/gnathtml.pl", "status": "added", "additions": 1115, "deletions": 0, "changes": 1115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec45d10572d281c66eb2ee4844f63047f66895fe/gcc%2Fada%2Fgnathtml.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec45d10572d281c66eb2ee4844f63047f66895fe/gcc%2Fada%2Fgnathtml.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnathtml.pl?ref=ec45d10572d281c66eb2ee4844f63047f66895fe", "patch": "@@ -0,0 +1,1115 @@\n+#! /usr/bin/env perl\n+\n+#-----------------------------------------------------------------------------\n+#-                                                                          --\n+#-                         GNAT COMPILER COMPONENTS                         --\n+#-                                                                          --\n+#-                             G N A T H T M L                              --\n+#-                                                                          --\n+#-          Copyright (C) 1998-2008, Free Software Foundation, Inc.         --\n+#-                                                                          --\n+#- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+#- terms of the  GNU General Public License as published  by the Free Soft- --\n+#- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+#- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+#- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+#- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+#- for  more details.  You should have  received  a copy of the GNU General --\n+#- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+#- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+#- MA 02111-1307, USA.                                                      --\n+#-                                                                          --\n+#- GNAT was originally developed  by the GNAT team at  New York University. --\n+#- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+#-                                                                          --\n+#-----------------------------------------------------------------------------\n+\n+## This script converts an Ada file (and its dependency files) to Html.\n+## Keywords, comments and strings are color-hilighted. If the cross-referencing\n+## information provided by Gnat (when not using the -gnatx switch) is found,\n+## the html files will also have some cross-referencing features, i.e. if you\n+## click on a type, its declaration will be displayed.\n+##\n+## To find more about the switches provided by this script, please use the\n+## following command :\n+##     perl gnathtml.pl -h\n+## You may also change the first line of this script to indicates where Perl is\n+## installed on your machine, so that you can just type\n+##     gnathtml.pl -h\n+##\n+## Unless you supply another directory with the -odir switch, the html files\n+## will be saved saved in a html subdirectory\n+\n+use Cwd 'abs_path';\n+use File::Basename;\n+\n+### Print help if necessary\n+sub print_usage\n+{\n+  print \"Usage is:\\n\";\n+  print \"  $0 [switches] main_file[.adb] main_file2[.adb] ...\\n\";\n+  print \"     -83       : Use Ada83 keywords only (default is Ada95)\\n\";\n+  print \"     -cc color : Choose the color for comments\\n\";\n+  print \"     -d        : Convert also the files which main_file depends on\\n\";\n+  print \"     -D        : same as -d, also looks for files in the standard library\\n\";\n+  print \"     -f        : Include cross-references for local entities too\\n\";\n+  print \"     -absolute : Display absolute filenames in the headers\\n\";\n+  print \"     -h        : Print this help page\\n\";\n+  print \"     -lnb      : Display line numbers every nb lines\\n\";\n+  print \"     -Idir     : Specify library/object files search path\\n\";\n+  print \"     -odir     : Name of the directory where the html files will be\\n\";\n+  print \"                 saved. Default is 'html/'\\n\";\n+  print \"     -pfile    : Use file as a project file (.adp file)\\n\";\n+  print \"     -sc color : Choose the color for symbol definitions\\n\";\n+  print \"     -Tfile    : Read the name of the files from file rather than the\\n\";\n+  print \"                 command line\\n\";\n+  print \"     -ext ext  : Choose the generated file names extension (default\\n\";\n+  print \"                 is htm)\\n\";\n+  print \"This program attemps to generate an html file from an Ada file\\n\";\n+  exit;\n+}\n+\n+### Parse the command line\n+local ($ada83_mode)    = 0;\n+local ($prjfile)       = \"\";\n+local (@list_files)    = ();\n+local ($line_numbers)  = 0;\n+local ($dependencies)  = 0;\n+local ($standard_library) = 0;\n+local ($output_dir)    = \"html\";\n+local ($xref_variable) = 0;\n+local (@search_dir)    = ('.');\n+local ($tab_size)      = 8;\n+local ($comment_color) = \"green\";\n+local ($symbol_color)  = \"red\";\n+local ($absolute)      = 0;\n+local ($fileext)       = \"htm\";\n+\n+while ($_ = shift @ARGV)\n+{\n+  /^-83$/  &&   do { $ada83_mode = 1; };\n+  /^-d$/   &&   do { $dependencies = 1; };\n+  /^-D$/   &&   do { $dependencies = 1;\n+\t\t     $standard_library = 1; };\n+  /^-f$/   &&   do { $xref_variable = 1; };\n+  /^-absolute$/ && do {$absolute = 1; };\n+  /^-h$/   &&   do { &print_usage; };\n+  /^[^-]/  &&   do { $_ .= \".adb\" if (! /\\.ad[bs]$/);\n+\t\t     push (@list_files, $_); };\n+  \n+  if (/^-o\\s*(.*)$/)\n+  {\n+    $output_dir = ($1 eq \"\") ? shift @ARGV : $1;\n+    chop $output_dir if ($output_dir =~ /\\/$/);\n+    &print_usage if ($output_dir =~ /^-/ || $output_dir eq \"\");\n+  }\n+\n+  if (/^-T\\s*(.*)$/)\n+  {\n+      my ($source_file) = ($1 eq \"\") ? shift @ARGV : $1;\n+      local (*SOURCE);\n+      open (SOURCE, \"$source_file\") || die \"file not found: $source_file\";\n+      while (<SOURCE>) {\n+\t  @files = split;\n+\t  foreach (@files) {\n+\t      $_ .= \".adb\" if (! /\\.ad[bs]$/);\t      \n+\t      push (@list_files, $_);\n+\t  }\n+      }\n+  }\n+\n+  if (/^-cc\\s*(.*)$/)\n+  {\n+      $comment_color = ($1 eq \"\") ? shift @ARGV : $1;\n+      &print_usage if ($comment_color =~ /^-/ || $comment_color eq \"\");\n+  }\n+\n+  if (/^-sc\\s*(.*)$/)\n+  {\n+      $symbol_color = ($1 eq \"\") ? shift @ARGV : $1;\n+      &print_usage if ($symbol_color =~ /^-/ || $symbol_color eq \"\");\n+  }\n+\n+  if (/^-I\\s*(.*)$/)\n+  {\n+    push (@search_dir, ($1 eq \"\") ? scalar (shift @ARGV) : $1);\n+  }\n+  \n+  if (/^-p\\s*(.*)$/)\n+  {\n+    $prjfile = ($1 eq \"\") ? shift @ARGV : $1;\n+    &print_usage if ($prjfile =~ /^-/ || $prjfile eq \"\");\n+  }\n+  \n+  if (/^-l\\s*(.*)$/)\n+  {\n+    $line_numbers = ($1 eq \"\") ? shift @ARGV : $1;\n+    &print_usage if ($line_numbers =~ /^-/ || $line_numbers eq \"\");\n+  }\n+\n+  if (/^-ext\\s*(.*)$/)\n+  {\n+    $fileext = ($1 eq \"\") ? shift @ARGV : $1;\n+    &print_usage if ($fileext =~ /^-/ || $fileext eq \"\");\n+  }\n+}\n+\n+&print_usage if ($#list_files == -1);\n+local (@original_list) = @list_files;\n+\n+## This regexp should match all the files from the standard library (and only them)\n+## Note that at this stage the '.' in the file names has been replaced with __\n+$standard_file_regexp=\"^([agis]-|ada__|gnat__|system__|interface__).*\\$\";\n+\n+local (@src_dir) = ();\n+local (@obj_dir) = ();\n+\n+if ($standard_library) {\n+    open (PIPE, \"gnatls -v | \");\n+    local ($mode) = \"\";\n+    while (defined ($_ = <PIPE>)) {\n+\tchop;\n+\ts/^\\s+//;\n+\t$_ = './' if (/<Current_Directory>/);\n+\tnext if (/^$/);\n+\t\n+\tif (/Source Search Path:/) {\n+\t    $mode = 's';\n+\t}\n+\telsif (/Object Search Path:/) {\n+\t    $mode = 'o';\n+\t}\n+\telsif ($mode eq 's') {\n+\t    push (@src_dir, $_);\n+\t}\n+\telsif ($mode eq 'o') {\n+\t    push (@obj_dir, $_);\n+\t}\n+    }\n+    close (PIPE);\n+}\n+else\n+{\n+    push (@src_dir, \"./\");\n+    push (@obj_dir, \"./\");\n+}\n+\n+foreach (@list_files) {\n+  local ($dir) = $_;\n+  $dir =~ s/\\/([^\\/]+)$//;\n+  push (@src_dir, $dir. '/');\n+  push (@obj_dir, $dir. '/');\n+}\n+\n+### Defines and compiles the Ada key words :\n+local (@Ada_keywords) = ('abort', 'abs', 'accept', 'access', 'all', 'and',\n+\t\t\t 'array', 'at', 'begin', 'body', 'case', 'constant',\n+\t\t\t 'declare', 'delay', 'delta', 'digits', 'do', 'else',\n+\t\t\t 'elsif', 'end', 'entry', 'exception', 'exit', 'for',\n+\t\t\t 'function', 'generic', 'goto', 'if', 'in', 'is',\n+\t\t\t 'limited', 'loop', 'mod', 'new', 'not', 'null', 'of',\n+\t\t\t 'or', 'others', 'out', 'package', 'pragma', 'private',\n+\t\t\t 'procedure', 'raise', 'range', 'record', 'rem',\n+\t\t\t 'renames', 'return', 'reverse', 'select', 'separate',\n+\t\t\t 'subtype', 'task', 'terminate', 'then', 'type',\n+\t\t\t 'until', 'use', 'when', 'while', 'with', 'xor');\n+local (@Ada95_keywords) = ('abstract', 'aliased', 'protected', 'requeue',\n+\t\t\t'tagged');\n+\n+local (%keywords) = ();\n+grep (++ $keywords{$_}, @Ada_keywords);\n+grep (++ $keywords{$_}, @Ada95_keywords) unless ($ada83_mode);\n+\n+### Symbols declarations for the current file\n+### format is   (line_column => 1, ...)\n+local (%symbols);\n+\n+### Symbols usage for the current file\n+### format is  ($adafile#$line_$column => $htmlfile#$linedecl_$columndecl, ...)\n+local (%symbols_used);\n+\n+### the global index of all symbols\n+### format is  ($name => [[file, line, column], [file, line, column], ...])\n+local (%global_index);\n+\n+#########\n+##  This function create the header of every html file.\n+##  These header is returned as a string\n+##  Params:  - Name of the Ada file associated with this html file\n+#########\n+sub create_header\n+{\n+  local ($adafile) = shift;\n+  local ($string) = \"<HEAD><TITLE>$adafile</TITLE></HEAD>\n+<BODY>\\n\";\n+  \n+  if ($adafile ne \"\")\n+  {\n+    $string .= \"<HR><DIV ALIGN=\\\"center\\\"><H1> File : $adafile \"\n+\t. \"</H1></DIV><HR>\\n<PRE>\";\n+  }\n+  return $string;\n+}\n+\n+#########\n+##  Protect a string (or character) from the Html parser\n+##  Params: - the string to protect\n+##  Out:    - the protected string\n+#########\n+sub protect_string\n+{\n+    local ($string) = shift;\n+    $string =~ s/&/&amp;/g;\n+    $string =~ s/</&lt;/g;\n+    $string =~ s/>/&gt;/g;\n+    return $string;\n+}\n+\n+#########\n+##  This function creates the footer of the html file\n+##  The footer is returned as a string\n+##  Params :  - Name of the Ada file associated with this html file\n+#########\n+sub create_footer\n+{\n+  local ($adafile) = shift;\n+  local ($string) = \"\";\n+  $string = \"</PRE>\" if ($adafile ne \"\");\n+  return $string . \"</BODY></HTML>\\n\";\n+}\n+\n+#########\n+##  This function creates the string to use for comment output\n+##  Params :  - the comment itself\n+#########\n+sub output_comment\n+{\n+  local ($comment) = &protect_string (shift);\n+  return \"<FONT COLOR=$comment_color><EM>--$comment</EM></FONT>\";\n+}\n+\n+########\n+##  This function creates the string to use for symbols output\n+##  Params :  - the symbol to output\n+##            - the current line\n+##            - the current column\n+########\n+sub output_symbol\n+{\n+  local ($symbol) = &protect_string (shift);\n+  local ($lineno) = shift;\n+  local ($column) = shift;\n+  return \"<FONT COLOR=$symbol_color><A NAME=\\\"$lineno\\_$column\\\">$symbol</A></FONT>\";\n+}\n+\n+########\n+##  This function creates the string to use for keyword output\n+##  Params :  - the keyword to output\n+########\n+sub output_keyword\n+{\n+  local ($keyw) = shift;\n+  return \"<b>$keyw</b>\";\n+}\n+\n+########\n+##  This function outputs a line number\n+##  Params :  - the line number to generate\n+########\n+sub output_line_number\n+{\n+  local ($no) = shift;\n+  if ($no != -1)\n+  {\n+    return \"<EM><FONT SIZE=-1>\" . sprintf (\"%4d \", $no) . \"</FONT></EM>\";\n+  }\n+  else\n+  {\n+    return \"<FONT SIZE=-1>     </FONT>\";\n+  }\n+}\n+\n+########\n+##  Converts a character into the corresponding Ada type\n+##  This is based on the ali format (see lib-xref.adb) in the GNAT sources\n+##  Note: 'f' or 'K' should be returned in case a link from the body to the\n+##        spec needs to be generated.\n+##  Params : - the character to convert\n+########\n+sub to_type\n+{\n+  local ($char) = shift;\n+  $char =~ tr/a-z/A-Z/;\n+  \n+  return 'array'                              if ($char eq 'A');\n+  return 'boolean'                            if ($char eq 'B');\n+  return 'class'                              if ($char eq 'C');\n+  return 'decimal'                            if ($char eq 'D');\n+  return 'enumeration'                        if ($char eq 'E');\n+  return 'floating point'                     if ($char eq 'F');\n+  return 'signed integer'                     if ($char eq 'I');\n+  # return 'generic package'                    if ($char eq 'K');\n+  return 'block'                              if ($char eq 'L');\n+  return 'modular integer'                    if ($char eq 'M');\n+  return 'enumeration litteral'               if ($char eq 'N');\n+  return 'ordinary fixed point'               if ($char eq 'O');\n+  return 'access'                             if ($char eq 'P');\n+  return 'label'                              if ($char eq 'Q');  \n+  return 'record'                             if ($char eq 'R');\n+  return 'string'                             if ($char eq 'S');\n+  return 'task'                               if ($char eq 'T');\n+  return 'f'                                  if ($char eq 'U');\n+  return 'f'                                  if ($char eq 'V');\n+  return 'exception'                          if ($char eq 'X');\n+  return 'entry'                              if ($char eq 'Y');\n+  return \"$char\";\n+}\n+\n+########\n+##  Changes a file name to be http compatible\n+########\n+sub http_string\n+{\n+  local ($str) = shift;\n+  $str =~ s/\\//__/g;\n+  $str =~ s/\\\\/__/g;\n+  $str =~ s/:/__/g;\n+  $str =~ s/\\./__/g;\n+  return $str;\n+}\n+\n+########\n+##  Creates the complete file-name, with directory\n+##  use the variables read in the .prj file\n+##  Params : - file name\n+##  RETURNS : the relative path_name to the file\n+########\n+sub get_real_file_name\n+{\n+  local ($filename) = shift;\n+  local ($path) = $filename;\n+  \n+  foreach (@src_dir)\n+  {\n+      if ( -r \"$_$filename\")\n+      {\n+\t  $path = \"$_$filename\";\n+\t  last;\n+      }\n+  }\n+  \n+  $path =~ s/^\\.\\///;\n+  return $path if (substr ($path, 0, 1) ne '/');\n+\n+  ## We want to return relative paths only, so that the name of the HTML files\n+  ## can easily be generated\n+  local ($pwd) = `pwd`;\n+  chop ($pwd);\n+  local (@pwd) = split (/\\//, $pwd);\n+  local (@path) = split (/\\//, $path);\n+  \n+  while (@pwd)\n+  {\n+    if ($pwd [0] ne $path [0])\n+    {\n+      return '../' x ($#pwd + 1) . join (\"/\", @path);\n+    }\n+    shift @pwd;\n+    shift @path;\n+  }\n+  return join ('/', @path);\n+}\n+\n+########\n+##  Reads and parses .adp files\n+##  Params : - adp file name\n+########\n+sub parse_prj_file\n+{\n+  local ($filename) = shift;\n+  local (@src) = ();\n+  local (@obj) = ();\n+  \n+  print \"Parsing project file : $filename\\n\";\n+  \n+  open (PRJ, $filename) || do { print \" ... sorry, file not found\\n\";\n+\t\t\t\treturn;\n+\t\t\t      };\n+  while (<PRJ>)\n+  {\n+    chop;\n+    s/\\/$//;\n+    push (@src, $1 . \"/\") if (/^src_dir=(.*)/);\n+    push (@obj, $1 . \"/\") if (/^obj_dir=(.*)/);\n+  }\n+  unshift (@src_dir, @src);\n+  unshift (@obj_dir, @obj);\n+  close (PRJ);\n+}\n+\n+########\n+##  Finds a file in the search path\n+##  Params  : - the name of the file\n+##  RETURNS : - the directory/file_name\n+########\n+sub find_file\n+{\n+  local ($filename) = shift;\n+\n+  foreach (@search_dir) {\n+    if (-f \"$_/$filename\") {\n+      return \"$_/$filename\";\n+    }\n+  }\n+  return $filename;\n+}\n+\n+########\n+##  Inserts a new reference in the list of references\n+##  Params: - Ref as it appears in the .ali file ($line$type$column)\n+##          - Current file for the reference\n+##          - Current offset to be added from the line (handling of\n+##            pragma Source_Reference)\n+##          - Current entity reference\n+##  Modifies: - %symbols_used\n+########\n+sub create_new_reference\n+{\n+    local ($ref) = shift;\n+    local ($lastfile) = shift;\n+    local ($offset) = shift;\n+    local ($currentref) = shift;\n+    local ($refline, $type, $refcol);\n+\n+    ## Do not generate references to the standard library files if we\n+    ## do not generate the corresponding html files\n+    return if (! $standard_library && $lastfile =~ /$standard_file_regexp/);\n+    \n+    ($refline, $type, $extern, $refcol) = /(\\d+)(.)(<[^>]+>)?(\\d+)/;\n+    $refline += $offset;\n+\n+    ## If we have a body, then we only generate the cross-reference from\n+    ## the spec to the body if we have a subprogram (or a package)\n+    \n+    \n+    if ($type eq \"b\")\n+#\t&& ($symbols {$currentref} eq 'f' || $symbols {$currentref} eq 'K'))\n+    {\n+\tlocal ($cref_file, $cref) = ($currentref =~ /([^\\#]+).$fileext\\#(.+)/);\n+\n+\t$symbols_used {\"$cref_file#$cref\"} = \"$lastfile.$fileext#$refline\\_$refcol\";\n+\t$symbols_used {\"$lastfile#$refline\\_$refcol\"} = $currentref;\n+\t$symbols {\"$lastfile.$fileext#$refline\\_$refcol\"} = \"body\";\n+    }\n+\n+    ## Do not generate cross-references for \"e\" and \"t\", since these point to the\n+    ## semicolon that terminates the block -- irrelevant for gnathtml\n+    ## \"p\" is also removed, since it is used for primitive subprograms\n+    ## \"d\" is also removed, since it is used for discriminants\n+    ## \"i\" is removed since it is used for implicit references\n+    ## \"z\" is used for generic formals\n+    ## \"k\" is for references to parent package\n+    ## \"=\", \"<\", \">\", \"^\" is for subprogram parameters\n+\n+    elsif ($type !~ /[eztpid=<>^k]/)\n+    {\n+\t$symbols_used {\"$lastfile#$refline\\_$refcol\"} = $currentref;\n+    }\n+}\n+\n+########\n+##  Parses the ali file associated with the current Ada file\n+##  Params :  - the complete ali file name\n+########\n+sub parse_ali\n+{\n+  local ($filename) = shift;\n+  local ($currentfile);\n+  local ($currentref);\n+  local ($lastfile);\n+\n+  # A    file | line type column      reference\n+  local ($reference) = \"(?:(?:\\\\d+\\\\|)?\\\\d+.\\\\d+|\\\\w+)\";\n+\n+  # The following variable is used to represent the possible xref information\n+  # output by GNAT when -gnatdM is used. It includes renaming references, and\n+  # references to the parent type, as well as references to the generic parent\n+\n+  local ($typeref) = \"(?:=$reference|<$reference>|\\\\{$reference\\\\}|\\\\($reference\\\\)|\\\\[$reference\\\\])?\";\n+\n+  # The beginning of an entity declaration line in the ALI file\n+  local ($decl_line) = \"^(\\\\d+)(.)(\\\\d+)[ *]([\\\\w\\\\d.-]+|\\\"..?\\\")$typeref\\\\s+(\\\\S.*)?\\$\";\n+ \n+  # Contains entries of the form  [ filename source_reference_offset]\n+  # Offset needs to be added to the lines read in the cross-references, and are\n+  # used when the source comes from a gnatchop-ed file. See lib-write.ads, lines\n+  # with ^D in the ALI file.\n+  local (@reffiles) = ();\n+\n+  open (ALI, &find_file ($filename)) || do {\n+    print \"no \", &find_file ($filename), \" file...\\n\";\n+    return;\n+  };\n+  local (@ali) = <ALI>;\n+  close (ALI);\n+\n+  undef %symbols;\n+  undef %symbols_used;\n+\n+  foreach (@ali)\n+  {\n+    ## The format of D lines is\n+    ## D source-name time-stamp checksum [subunit-name] line:file-name\n+\n+    if (/^D\\s+([\\w\\d.-]+)\\s+\\S+ \\S+(\\s+\\D[^: ]+)?( (\\d+):(.*))?/)\n+    {\n+\t# The offset will be added to each cross-reference line. If it is\n+\t# greater than 1, this means that we have a pragma Source_Reference,\n+\t# and this must not be counted in the xref information.\n+\tmy ($file, $offset) = ($1, (defined $4) ? 2 - $4 : 0);\n+\n+\tif ($dependencies)\n+\t{\n+\t    push (@list_files, $1) unless (grep (/$file/, @list_files));\n+\t}\n+\tpush (@reffiles, [&http_string (&get_real_file_name ($file)), $offset]);\n+    }\n+    \n+    elsif (/^X\\s+(\\d+)/)\n+    {\n+\t$currentfile = $lastfile = $1 - 1;\n+    }\n+\n+    elsif (defined $currentfile && /$decl_line/)\n+    {\n+      my ($line) = $1 + $reffiles[$currentfile][1];\n+      next if (! $standard_library\n+\t       && $reffiles[$currentfile][0] =~ /$standard_file_regexp/);\n+      if ($xref_variable || $2 eq &uppercases ($2))\n+      {\n+\t$currentref = $reffiles[$currentfile][0] . \".$fileext#$line\\_$3\";\n+\t$symbols {$currentref} = &to_type ($2);\n+\t$lastfile = $currentfile;\n+\t\n+\tlocal ($endofline) = $5;\n+\t\n+\tforeach (split (\" \", $endofline))\n+\t{\n+\t    (s/^(\\d+)\\|//) && do { $lastfile = $1 - 1; };\n+\t    &create_new_reference\n+\t\t($_, $reffiles[$lastfile][0],\n+\t\t $reffiles[$lastfile][1], $currentref);\n+\t}\n+      }\n+      else\n+      {\n+\t$currentref = \"\";\n+      }\n+    }\n+    elsif (/^\\.\\s(.*)/ && $reffiles[$currentfile][0] ne \"\" && $currentref ne \"\")\n+    {\n+      next if (! $standard_library\n+\t       && $reffiles[$currentfile][0] =~ /$standard_file_regexp/);\n+      foreach (split (\" \", $1))\n+      {\n+\t  (s/^(\\d+)\\|//) && do { $lastfile = $1 - 1; };\n+\t  &create_new_reference\n+\t      ($_, $reffiles[$lastfile][0], $reffiles[$lastfile][1],\n+\t       $currentref);\n+      }\n+    }\n+  }\n+}\n+\n+#########\n+##  Return the name of the ALI file to use for a given source\n+##  Params:  - Name of the source file\n+##  return:  Name and location of the ALI file\n+#########\n+\n+sub ali_file_name {\n+    local ($source) = shift;\n+    local ($alifilename, $unitname);\n+    local ($in_separate) = 0;\n+\n+    $source =~ s/\\.ad[sb]$//;\n+    $alifilename = $source;\n+    $unitname = $alifilename;\n+    $unitname =~ s/-/./g;\n+\n+    ## There are two reasons why we might not find the ALI file: either the\n+    ## user did not generate them at all, or we are working on a separate unit.\n+    ## Thus, we search in the parent's ALI file.\n+\n+    while ($alifilename ne \"\") {\n+\n+      ## Search in the object path\n+      foreach (@obj_dir) {\n+\n+\t## Check if the ALI file does apply to the source file\n+\t## We check the ^D lines, which have the following format:\n+\t## D source-name time-stamp checksum [subunit-name] line:file-name\n+\n+\tif (-r \"$_$alifilename.ali\") {\n+\t  if ($in_separate) {\n+\t    open (FILE, \"$_$alifilename.ali\");\n+\n+\t    if (grep (/^D \\S+\\s+\\S+\\s+\\S+ $unitname/, <FILE>)) {\n+\t      close FILE;\n+\t      return \"$_$alifilename.ali\";\n+\n+\t    } else {\n+\t      ## If the ALI file doesn't apply to the source file, we can\n+\t      ## return now, since there won't be a parent ALI file above\n+\t      ## anyway\n+\t      close FILE;\n+\t      return \"$source.ali\";\n+\t    }\n+\t  } else {\n+\t    return \"$_$alifilename.ali\";\n+\t  }\n+\t}\n+      }\n+\n+      ## Get the parent's ALI file name\n+\n+      if (! ($alifilename =~ s/-[^-]+$//)) {\n+\t$alifilename = \"\";\n+      }\n+      $in_separate = 1;\n+    }\n+\n+    return \"$source.ali\";\n+}\n+\n+#########\n+## Convert a path to an absolute path\n+#########\n+\n+sub to_absolute\n+{\n+  local ($path) = shift;\n+  local ($name, $suffix, $separator);\n+  ($name,$path,$suffix) = fileparse ($path, ());\n+  $path = &abs_path ($path);\n+  $separator = substr ($path, 0, 1);\n+  return $path . $separator . $name;\n+}\n+\n+#########\n+##  This function outputs the html version of the file FILE\n+##  The output is send to FILE.htm.\n+##  Params :  - Name of the file to convert (ends with .ads or .adb)\n+#########\n+sub output_file\n+{\n+  local ($filename_param) = shift;\n+  local ($lineno)   = 1;\n+  local ($column);\n+  local ($found);\n+  \n+  local ($alifilename) = &ali_file_name ($filename_param);\n+  \n+  $filename = &get_real_file_name ($filename_param);\n+  $found = &find_file ($filename);\n+  \n+  ## Read the whole file\n+  open (FILE, $found) || do {\n+    print $found, \" not found ... skipping.\\n\";\n+    return 0; \n+  };\n+  local (@file) = <FILE>;\n+  close (FILE);\n+\n+  ## Parse the .ali file to find the cross-references\n+  print \"converting \", $filename, \"\\n\";\n+  &parse_ali ($alifilename);\n+\n+  ## Create and initialize the html file\n+  open (OUTPUT, \">$output_dir/\" . &http_string ($filename) . \".$fileext\")\n+      || die \"Couldn't write $output_dir/\" . &http_string ($filename)\n+\t  . \".$fileext\\n\";\n+\n+  if ($absolute) {\n+     print OUTPUT &create_header (&to_absolute ($found)), \"\\n\";\n+  } else {\n+     print OUTPUT &create_header ($filename_param), \"\\n\";\n+  }\n+\n+  ## Print the file\n+  $filename = &http_string ($filename);\n+  foreach (@file)\n+  {\n+      local ($index);\n+      local ($line) = $_;\n+      local ($comment);\n+\n+      $column = 1;\n+      chop ($line);\n+      \n+      ## Print either the line number or a space if required\n+      if ($line_numbers)\n+      {\n+\t  if ($lineno % $line_numbers == 0)\n+\t  {\n+\t      print OUTPUT &output_line_number ($lineno);\n+\t  }\n+\t  else\n+\t  {\n+\t      print OUTPUT &output_line_number (-1);\n+\t  }\n+      }\n+\n+      ## First, isolate any comment on the line\n+      undef $comment;\n+      $index = index ($line, '--');\n+      if ($index != -1) {\n+\t  $comment = substr ($line, $index + 2);\n+\t  if ($index > 1)\n+\t  {\n+\t      $line = substr ($line, 0, $index);\n+\t  }\n+\t  else\n+\t  {\n+\t      undef $line;\n+\t  }\n+      }\n+\n+      ## Then print the line\n+      if (defined $line)\n+      {\n+\t  $index = 0;\n+\t  while ($index < length ($line))\n+\t  {\n+\t      local ($substring) = substr ($line, $index);\n+\t      \n+\t      if ($substring =~ /^\\t/)\n+\t      {\n+\t\t  print OUTPUT ' ' x ($tab_size - (($column - 1) % $tab_size));\n+\t\t  $column += $tab_size - (($column - 1) % $tab_size);\n+\t\t  $index ++;\n+\t      }\n+\t      elsif ($substring =~ /^(\\w+)/\n+\t\t     || $substring =~ /^(\"[^\\\"]*\")/\n+\t\t     || $substring =~ /^(\\W)/)\n+\t      {\n+\t\t  local ($word) = $1;\n+\t\t  $index += length ($word);\n+\n+\t\t  local ($lowercase) = $word;\n+\t\t  $lowercase =~ tr/A-Z/a-z/;\n+\n+\t\t  if ($keywords{$lowercase})\n+\t\t  {\n+\t\t      print OUTPUT &output_keyword ($word);\n+\t\t  }\n+\t\t  elsif ($symbols {\"$filename.$fileext#$lineno\\_$column\"})\n+\t\t  {\n+\t\t      ##  A symbol can both have a link and be a reference for\n+\t\t      ##  another link, as is the case for bodies and\n+\t\t      ##  declarations\n+\t\t      \n+\t\t      if ($symbols_used{\"$filename#$lineno\\_$column\"})\n+\t\t      {\n+\t\t\t  print OUTPUT \"<A HREF=\\\"\",\n+\t\t\t  $symbols_used{\"$filename#$lineno\\_$column\"},\n+\t\t\t  \"\\\">\", &protect_string ($word), \"</A>\";\n+\t\t\t  print OUTPUT &output_symbol ('', $lineno, $column);\n+\t\t      }\n+\t\t      else\n+\t\t      {\n+\t\t\t  print OUTPUT &output_symbol ($word, $lineno, $column);\n+\t\t      }\n+\t\t      \n+\t\t      ## insert only functions into the global index\n+\t\t      \n+\t\t      if ($symbols {\"$filename.$fileext#$lineno\\_$column\"} eq 'f')\n+\t\t      {\n+\t\t\t  push (@{$global_index {$word}},\n+\t\t\t\t[$filename_param, $filename, $lineno, $column]);\n+\t\t      }\n+\t\t  }\n+\t\t  elsif ($symbols_used{\"$filename#$lineno\\_$column\"})\n+\t\t  {\n+\t\t      print OUTPUT \"<A HREF=\\\"\",\n+\t\t      $symbols_used{\"$filename#$lineno\\_$column\"},\n+\t\t      \"\\\">\", &protect_string ($word), \"</A>\";\n+\t\t  }\n+\t\t  else\n+\t\t  {\n+\t\t      print OUTPUT &protect_string ($word);\n+\t\t  }\n+\t\t  $column += length ($word);\n+\t      }\n+\t      else\n+\t      {\n+\t\t  $index ++;\n+\t\t  $column ++;\n+\t\t  print OUTPUT &protect_string (substr ($substring, 0, 1));\n+\t      }\n+\t  }\n+      }\n+\t  \n+      ## Then output the comment\n+      print OUTPUT &output_comment ($comment) if (defined $comment);\n+      print OUTPUT \"\\n\";\n+      \n+      $lineno ++;\n+  }\n+  \n+  print OUTPUT &create_footer ($filename);\n+  close (OUTPUT);\n+  return 1;\n+}\n+\n+#########\n+##  This function generates the global index\n+#########\n+sub create_index_file\n+{\n+  open (INDEX, \">$output_dir/index.$fileext\") || die \"couldn't write $output_dir/index.$fileext\";\n+  \n+  print INDEX <<\"EOF\";\n+<HTML>\n+<HEAD><TITLE>Source Browser</TITLE></HEAD>\n+<FRAMESET COLS='250,*'>\n+<NOFRAME>\n+EOF\n+  ;\n+  \n+  local (@files) = &create_file_index;\n+  print INDEX join (\"\\n\", @files), \"\\n\";\n+  \n+  print INDEX \"<HR>\\n\";\n+  local (@functions) = &create_function_index;\n+  print INDEX join (\"\\n\", @functions), \"\\n\";\n+  \n+  print INDEX <<\"EOF\";\n+</NOFRAME>\n+<FRAMESET ROWS='50%,50%'>\n+<FRAME NAME=files SRC=files.$fileext>\n+<FRAME NAME=funcs SRC=funcs.$fileext>\n+</FRAMESET>\n+<FRAME NAME=main SRC=main.$fileext>\n+</FRAMESET>\n+</HTML>\n+EOF\n+  ;\n+  close (INDEX);\n+  \n+  open (MAIN, \">$output_dir/main.$fileext\") || die \"couldn't write $output_dir/main.$fileext\";\n+  print MAIN &create_header (\"\"),\n+  \"<P ALIGN=right>\",\n+  \"<A HREF=main.$fileext TARGET=_top>[No frame version is here]</A>\",\n+  \"<P>\",\n+  join (\"\\n\", @files), \"\\n<HR>\",\n+  join (\"\\n\", @functions), \"\\n\";\n+\n+  if ($dependencies) {\n+      print MAIN \"<HR>\\n\";\n+      print MAIN \"You should start your browsing with one of these files:\\n\";\n+      print MAIN \"<UL>\\n\";\n+      foreach (@original_list) {\n+\t  print MAIN \"<LI><A HREF=\", &http_string (&get_real_file_name ($_)),\n+\t     \".$fileext>$_</A>\\n\";\n+      }\n+  }\n+  print MAIN &create_footer (\"\");\n+  close (MAIN);\n+}\n+\n+#######\n+##  Convert to upper cases (did not exist in Perl 4)\n+#######\n+\n+sub uppercases {\n+  local ($tmp) = shift;\n+  $tmp =~ tr/a-z/A-Z/;\n+  return $tmp;\n+}\n+\n+#######\n+##  This function generates the file_index\n+##  RETURN : - table with the html lines to be printed\n+#######\n+sub create_file_index\n+{\n+  local (@output) = (\"<H2 ALIGN=CENTER>Files</H2>\");\n+  \n+  \n+  open (FILES, \">$output_dir/files.$fileext\") || die \"couldn't write $output_dir/files.$fileext\";\n+  print FILES &create_header (\"\"), join (\"\\n\", @output), \"\\n\";\n+  \n+  \n+  if ($#list_files > 20)\n+  {\n+    local ($last_letter) = '';\n+    foreach (sort {&uppercases ($a) cmp &uppercases ($b)} @list_files)\n+    {\n+      next if ($_ eq \"\");\n+      if (&uppercases (substr ($_, 0, 1)) ne $last_letter)\n+      {\n+\tif ($last_letter ne '')\n+\t{\n+\t  print INDEX_FILE \"</UL></BODY></HTML>\\n\";\n+\t  close (INDEX_FILE);\n+\t}\n+\t$last_letter = &uppercases (substr ($_, 0, 1));\n+\topen (INDEX_FILE, \">$output_dir/files/$last_letter.$fileext\")\n+\t|| die \"couldn't write $output_dir/files/$last_letter.$fileext\";\n+\tprint INDEX_FILE <<\"EOF\";\n+<HTML><HEAD><TITLE>$last_letter</TITLE></HEAD>\n+<BODY>\n+<H2>Files - $last_letter</H2>\n+<A HREF=../files.$fileext TARGET=_self>[index]</A>\n+<UL COMPACT TYPE=DISC>\n+EOF\n+\t;\n+\tlocal ($str) = \"<A HREF=files/$last_letter.$fileext>[$last_letter]</A>\";\n+\tpush (@output, $str); \n+\tprint FILES \"$str\\n\";\n+      }\n+      print INDEX_FILE \"<LI><A HREF=../\",\n+      &http_string (&get_real_file_name ($_)),\n+      \".$fileext TARGET=main>$_</A>\\n\";   ## Problem with TARGET when in no_frame mode!\n+    }\n+    \n+    print INDEX_FILE \"</UL></BODY></HTML>\\n\";\n+    close INDEX_FILE;\n+  }\n+  else\n+  {\n+    push (@output, \"<UL COMPACT TYPE=DISC>\");\n+    print FILES \"<UL COMPACT TYPE=DISC>\";\n+    foreach (sort {&uppercases ($a) cmp &uppercases ($b)} @list_files)\n+    {\n+      next if ($_ eq \"\");\n+      local ($ref) = &http_string (&get_real_file_name ($_));\n+      push (@output, \"<LI><A HREF=$ref.$fileext>$_</A>\");\n+      print FILES \"<LI><A HREF=$ref.$fileext TARGET=main>$_</A>\\n\";\n+    }\n+  }\n+  \n+  print FILES &create_footer (\"\");\n+  close (FILES);\n+  \n+  push (@output, \"</UL>\");\n+  return @output;\n+}\n+\n+#######\n+##  This function generates the function_index\n+##  RETURN : - table with the html lines to be printed\n+#######\n+sub create_function_index\n+{\n+  local (@output) = (\"<H2 ALIGN=CENTER>Functions/Procedures</H2>\");\n+  local ($initial) = \"\";\n+  \n+  open (FUNCS, \">$output_dir/funcs.$fileext\") || die \"couldn't write $output_dir/funcs.$fileext\";\n+  print FUNCS &create_header (\"\"), join (\"\\n\", @output), \"\\n\";\n+\n+  ## If there are more than 20 entries, we just want to create some\n+  ## submenus\n+  if (scalar (keys %global_index) > 20)\n+  {\n+    local ($last_letter) = '';\n+    foreach (sort {&uppercases ($a) cmp &uppercases ($b)} keys %global_index)\n+    {\n+      if (&uppercases (substr ($_, 0, 1)) ne $last_letter)\n+      {\n+\tif ($last_letter ne '')\n+\t{\n+\t  print INDEX_FILE \"</UL></BODY></HTML>\\n\";\n+\t  close (INDEX_FILE);\n+\t}\n+\t\n+\t$last_letter = &uppercases (substr ($_, 0, 1));\n+\t$initial = $last_letter;\n+\tif ($initial eq '\"')\n+\t{\n+\t    $initial = \"operators\";\n+\t}\n+\tif ($initial ne '.')\n+\t{\n+\t    open (INDEX_FILE, \">$output_dir/funcs/$initial.$fileext\")\n+\t\t|| die \"couldn't write $output_dir/funcs/$initial.$fileext\";\n+\t    print INDEX_FILE <<\"EOF\";\n+<HTML><HEAD><TITLE>$initial</TITLE></HEAD>\n+<BODY>\n+<H2>Functions - $initial</H2>\n+<A HREF=../funcs.$fileext TARGET=_self>[index]</A>\n+<UL COMPACT TYPE=DISC>\n+EOF\n+\t\t\t\t    ;\n+\t    local ($str) = \"<A HREF=funcs/$initial.$fileext>[$initial]</A>\";\n+\t    push (@output, $str);\n+\t    print FUNCS \"$str\\n\";\n+\t}\n+      }\n+      local ($ref);\n+      local ($is_overloaded) = ($#{$global_index {$_}} > 0 ? 1 : 0);\n+      foreach $ref (@{$global_index {$_}})\n+      {\n+\t  ($file, $full_file, $lineno, $column) = @{$ref};\n+\t  local ($symbol) = ($is_overloaded ? \"$_ -  $file:$lineno\" : $_);\n+\t  print INDEX_FILE \"<LI><A HREF=../$full_file.$fileext#$lineno\\_$column TARGET=main>$symbol</A>\";\n+      }\n+    }\n+    \n+    print INDEX_FILE \"</UL></BODY></HTML>\\n\";\n+    close INDEX_FILE;\n+  }\n+  else\n+  {\n+    push (@output, \"<UL COMPACT TYPE=DISC>\");\n+    print FUNCS \"<UL COMPACT TYPE=DISC>\";\n+    foreach (sort {&uppercases ($a) cmp &uppercases ($b)} keys %global_index)\n+    {\n+      local ($ref);\n+      local ($is_overloaded) = ($#{$global_index {$_}} > 0 ? 1 : 0);\n+      foreach $ref (@{$global_index {$_}})\n+      {\n+\t  ($file, $full_file, $lineno, $column) = @{$ref};\n+\t  local ($symbol) = ($is_overloaded ? \"$_ -  $file:$lineno\" : $_);\n+\t  push (@output, \"<LI><A HREF=$full_file.$fileext#$lineno\\_$column>$symbol</A>\");\n+\t  print FUNCS \"<LI><A HREF=$full_file.$fileext#$lineno\\_$column TARGET=main>$symbol</A>\";\n+      }\n+    }\n+  }\n+  \n+  print FUNCS &create_footer (\"\");\n+  close (FUNCS);\n+  \n+  push (@output, \"</UL>\");\n+  return (@output);\n+}\n+\n+######\n+##  Main function\n+######\n+\n+local ($index_file) = 0;\n+\n+mkdir ($output_dir, 0777)          if (! -d $output_dir);\n+mkdir ($output_dir.\"/files\", 0777) if (! -d $output_dir.\"/files\");\n+mkdir ($output_dir.\"/funcs\", 0777) if (! -d $output_dir.\"/funcs\");\n+\n+&parse_prj_file ($prjfile) if ($prjfile);\n+\n+while ($index_file <= $#list_files)\n+{\n+  local ($file) = $list_files [$index_file];\n+  \n+  if (&output_file ($file) == 0)\n+    {\n+      $list_files [$index_file] = \"\";\n+    }\n+  $index_file ++;\n+}\n+&create_index_file;\n+\n+$indexfile = \"$output_dir/index.$fileext\";\n+$indexfile =~ s!//!/!g;\n+print \"You can now download the $indexfile file to see the \",\n+  \"created pages\\n\";"}]}