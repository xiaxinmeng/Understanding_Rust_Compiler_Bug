{"sha": "0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZmM2RjZDYxYTcwODg0ZWIzOWMyZWU5ZmIxMDdlOGVhMTQ4NDljOA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2018-08-08T11:35:45Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2018-08-08T11:35:45Z"}, "message": "S/390: Fix whitespace problems in the backend\n\n2018-08-08  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\t* config/s390/s390.c: Fix whitespace damage throughout the file.\n\t* config/s390/s390.h: Likewise.\n\t* config/s390/tpf.h: Likewise.\n\nFrom-SVN: r263395", "tree": {"sha": "5e1f8c3e80e057f30488c4b975fdf55c06937c19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e1f8c3e80e057f30488c4b975fdf55c06937c19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cc6307c8889b92c98d4b905bf2fdd8fb285a577", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cc6307c8889b92c98d4b905bf2fdd8fb285a577"}], "stats": {"total": 790, "additions": 398, "deletions": 392}, "files": [{"sha": "1a1d0ee1c0480ab6325cd16846f969f28198fd8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8", "patch": "@@ -1,3 +1,9 @@\n+2018-08-08  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\t* config/s390/s390.c: Fix whitespace damage throughout the file.\n+\t* config/s390/s390.h: Likewise.\n+\t* config/s390/tpf.h: Likewise.\n+\n 2018-08-08  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \t* config/s390/s390.c (s390_loadrelative_operand_p):"}, {"sha": "d533a3fcb4e156a233b314c225002c9f4946860f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 343, "deletions": 343, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8", "patch": "@@ -420,11 +420,11 @@ struct s390_address\n #define CONST_OK_FOR_K(x) \\\n \tCONST_OK_FOR_CONSTRAINT_P((x), 'K', \"K\")\n #define CONST_OK_FOR_Os(x) \\\n-        CONST_OK_FOR_CONSTRAINT_P((x), 'O', \"Os\")\n+\tCONST_OK_FOR_CONSTRAINT_P((x), 'O', \"Os\")\n #define CONST_OK_FOR_Op(x) \\\n-        CONST_OK_FOR_CONSTRAINT_P((x), 'O', \"Op\")\n+\tCONST_OK_FOR_CONSTRAINT_P((x), 'O', \"Op\")\n #define CONST_OK_FOR_On(x) \\\n-        CONST_OK_FOR_CONSTRAINT_P((x), 'O', \"On\")\n+\tCONST_OK_FOR_CONSTRAINT_P((x), 'O', \"On\")\n \n #define REGNO_PAIR_OK(REGNO, MODE)                               \\\n   (s390_hard_regno_nregs ((REGNO), (MODE)) == 1 || !((REGNO) & 1))\n@@ -919,7 +919,7 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n       /* Record the vector mode used for an element selector.  This assumes:\n \t 1. There is no builtin with two different vector modes and an element selector\n-         2. The element selector comes after the vector type it is referring to.\n+\t 2. The element selector comes after the vector type it is referring to.\n \t This currently the true for all the builtins but FIXME we\n \t should better check for that.  */\n       if (VECTOR_MODE_P (insn_op->mode))\n@@ -982,7 +982,7 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n       break;\n     case 1:\n       if (nonvoid)\n-        pat = GEN_FCN (icode) (target, op[0]);\n+\tpat = GEN_FCN (icode) (target, op[0]);\n       else\n \tpat = GEN_FCN (icode) (op[0]);\n       break;\n@@ -1332,7 +1332,7 @@ s390_cc_modes_compatible (machine_mode m1, machine_mode m2)\n     case E_CCZmode:\n       if (m2 == CCUmode || m2 == CCTmode || m2 == CCZ1mode\n \t  || m2 == CCSmode || m2 == CCSRmode || m2 == CCURmode)\n-        return m2;\n+\treturn m2;\n       return VOIDmode;\n \n     case E_CCSmode:\n@@ -1392,20 +1392,20 @@ s390_match_ccmode_set (rtx set, machine_mode req_mode)\n     case E_CCVFHmode:\n     case E_CCVFHEmode:\n       if (req_mode != set_mode)\n-        return 0;\n+\treturn 0;\n       break;\n \n     case E_CCZmode:\n       if (req_mode != CCSmode && req_mode != CCUmode && req_mode != CCTmode\n \t  && req_mode != CCSRmode && req_mode != CCURmode\n \t  && req_mode != CCZ1mode)\n-        return 0;\n+\treturn 0;\n       break;\n \n     case E_CCAPmode:\n     case E_CCANmode:\n       if (req_mode != CCAmode)\n-        return 0;\n+\treturn 0;\n       break;\n \n     default:\n@@ -1434,12 +1434,12 @@ s390_match_ccmode (rtx_insn *insn, machine_mode req_mode)\n \n   if (GET_CODE (PATTERN (insn)) == PARALLEL)\n       for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n-        {\n-          rtx set = XVECEXP (PATTERN (insn), 0, i);\n-          if (GET_CODE (set) == SET)\n-            if (!s390_match_ccmode_set (set, req_mode))\n-              return false;\n-        }\n+\t{\n+\t  rtx set = XVECEXP (PATTERN (insn), 0, i);\n+\t  if (GET_CODE (set) == SET)\n+\t    if (!s390_match_ccmode_set (set, req_mode))\n+\t      return false;\n+\t}\n \n   return true;\n }\n@@ -1479,7 +1479,7 @@ s390_tm_ccmode (rtx op1, rtx op2, bool mixed)\n       bit1 = exact_log2 (INTVAL (op2));\n       bit0 = exact_log2 (INTVAL (op1) ^ INTVAL (op2));\n       if (bit0 != -1 && bit1 != -1)\n-        return bit0 > bit1 ? CCT1mode : CCT2mode;\n+\treturn bit0 > bit1 ? CCT1mode : CCT2mode;\n     }\n \n   return VOIDmode;\n@@ -1516,7 +1516,7 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n \t      {\n \t\t/* Relax CCTmode to CCZmode to allow fall-back to AND\n \t\t   if that turns out to be beneficial.  */\n-\t        return ccmode == CCTmode ? CCZmode : ccmode;\n+\t\treturn ccmode == CCTmode ? CCZmode : ccmode;\n \t      }\n \t  }\n \n@@ -1543,11 +1543,11 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n \t    && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT)\n \t  return CCAPmode;\n \n- \t/* If constants are involved in an add instruction it is possible to use\n- \t   the resulting cc for comparisons with zero. Knowing the sign of the\n+\t/* If constants are involved in an add instruction it is possible to use\n+\t   the resulting cc for comparisons with zero. Knowing the sign of the\n \t   constant the overflow behavior gets predictable. e.g.:\n- \t     int a, b; if ((b = a + c) > 0)\n- \t   with c as a constant value: c < 0 -> CCAN and c >= 0 -> CCAP  */\n+\t     int a, b; if ((b = a + c) > 0)\n+\t   with c as a constant value: c < 0 -> CCAN and c >= 0 -> CCAP  */\n \tif (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t    && (CONST_OK_FOR_K (INTVAL (XEXP (op0, 1)))\n \t\t|| (CONST_OK_FOR_CONSTRAINT_P (INTVAL (XEXP (op0, 1)), 'O', \"Os\")\n@@ -1652,8 +1652,8 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t  && (GET_MODE_SIZE (GET_MODE (inner))\n \t      >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (inner))))\n \t  && ((INTVAL (mask)\n-               & GET_MODE_MASK (GET_MODE (inner))\n-               & ~GET_MODE_MASK (GET_MODE (SUBREG_REG (inner))))\n+\t       & GET_MODE_MASK (GET_MODE (inner))\n+\t       & ~GET_MODE_MASK (GET_MODE (SUBREG_REG (inner))))\n \t      == 0))\n \tinner = SUBREG_REG (inner);\n \n@@ -1738,8 +1738,8 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t{\n \t  /* For CCRAWmode put the required cc mask into the second\n \t     operand.  */\n-        if (GET_MODE (XVECEXP (*op0, 0, 0)) == CCRAWmode\n-            && INTVAL (*op1) >= 0 && INTVAL (*op1) <= 3)\n+\tif (GET_MODE (XVECEXP (*op0, 0, 0)) == CCRAWmode\n+\t    && INTVAL (*op1) >= 0 && INTVAL (*op1) <= 3)\n \t    *op1 = gen_rtx_CONST_INT (VOIDmode, 1 << (3 - INTVAL (*op1)));\n \t  *op0 = XVECEXP (*op0, 0, 0);\n \t  *code = new_code;\n@@ -1756,7 +1756,7 @@ s390_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n       && *op1 == const0_rtx)\n     {\n       if ((*code == EQ && GET_CODE (*op0) == NE)\n-          || (*code == NE && GET_CODE (*op0) == EQ))\n+\t  || (*code == NE && GET_CODE (*op0) == EQ))\n \t*code = EQ;\n       else\n \t*code = NE;\n@@ -1899,65 +1899,65 @@ s390_branch_condition_mask (rtx code)\n     case E_CCZmode:\n     case E_CCZ1mode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC0;\n+\t{\n+\tcase EQ:\treturn CC0;\n \tcase NE:\treturn CC1 | CC2 | CC3;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCT1mode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC1;\n+\t{\n+\tcase EQ:\treturn CC1;\n \tcase NE:\treturn CC0 | CC2 | CC3;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCT2mode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC2;\n+\t{\n+\tcase EQ:\treturn CC2;\n \tcase NE:\treturn CC0 | CC1 | CC3;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCT3mode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC3;\n+\t{\n+\tcase EQ:\treturn CC3;\n \tcase NE:\treturn CC0 | CC1 | CC2;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCLmode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC0 | CC2;\n+\t{\n+\tcase EQ:\treturn CC0 | CC2;\n \tcase NE:\treturn CC1 | CC3;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCL1mode:\n       switch (GET_CODE (code))\n-        {\n+\t{\n \tcase LTU:\treturn CC2 | CC3;  /* carry */\n \tcase GEU:\treturn CC0 | CC1;  /* no carry */\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCL2mode:\n       switch (GET_CODE (code))\n-        {\n+\t{\n \tcase GTU:\treturn CC0 | CC1;  /* borrow */\n \tcase LEU:\treturn CC2 | CC3;  /* no borrow */\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCL3mode:\n@@ -1974,96 +1974,96 @@ s390_branch_condition_mask (rtx code)\n \n     case E_CCUmode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC0;\n-        case NE:\treturn CC1 | CC2 | CC3;\n-        case LTU:\treturn CC1;\n-        case GTU:\treturn CC2;\n-        case LEU:\treturn CC0 | CC1;\n-        case GEU:\treturn CC0 | CC2;\n+\t{\n+\tcase EQ:\treturn CC0;\n+\tcase NE:\treturn CC1 | CC2 | CC3;\n+\tcase LTU:\treturn CC1;\n+\tcase GTU:\treturn CC2;\n+\tcase LEU:\treturn CC0 | CC1;\n+\tcase GEU:\treturn CC0 | CC2;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCURmode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC0;\n-        case NE:\treturn CC2 | CC1 | CC3;\n-        case LTU:\treturn CC2;\n-        case GTU:\treturn CC1;\n-        case LEU:\treturn CC0 | CC2;\n-        case GEU:\treturn CC0 | CC1;\n+\t{\n+\tcase EQ:\treturn CC0;\n+\tcase NE:\treturn CC2 | CC1 | CC3;\n+\tcase LTU:\treturn CC2;\n+\tcase GTU:\treturn CC1;\n+\tcase LEU:\treturn CC0 | CC2;\n+\tcase GEU:\treturn CC0 | CC1;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCAPmode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC0;\n-        case NE:\treturn CC1 | CC2 | CC3;\n-        case LT:\treturn CC1 | CC3;\n-        case GT:\treturn CC2;\n-        case LE:\treturn CC0 | CC1 | CC3;\n-        case GE:\treturn CC0 | CC2;\n+\t{\n+\tcase EQ:\treturn CC0;\n+\tcase NE:\treturn CC1 | CC2 | CC3;\n+\tcase LT:\treturn CC1 | CC3;\n+\tcase GT:\treturn CC2;\n+\tcase LE:\treturn CC0 | CC1 | CC3;\n+\tcase GE:\treturn CC0 | CC2;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCANmode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC0;\n-        case NE:\treturn CC1 | CC2 | CC3;\n-        case LT:\treturn CC1;\n-        case GT:\treturn CC2 | CC3;\n-        case LE:\treturn CC0 | CC1;\n-        case GE:\treturn CC0 | CC2 | CC3;\n+\t{\n+\tcase EQ:\treturn CC0;\n+\tcase NE:\treturn CC1 | CC2 | CC3;\n+\tcase LT:\treturn CC1;\n+\tcase GT:\treturn CC2 | CC3;\n+\tcase LE:\treturn CC0 | CC1;\n+\tcase GE:\treturn CC0 | CC2 | CC3;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCSmode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC0;\n-        case NE:\treturn CC1 | CC2 | CC3;\n-        case LT:\treturn CC1;\n-        case GT:\treturn CC2;\n-        case LE:\treturn CC0 | CC1;\n-        case GE:\treturn CC0 | CC2;\n+\t{\n+\tcase EQ:\treturn CC0;\n+\tcase NE:\treturn CC1 | CC2 | CC3;\n+\tcase LT:\treturn CC1;\n+\tcase GT:\treturn CC2;\n+\tcase LE:\treturn CC0 | CC1;\n+\tcase GE:\treturn CC0 | CC2;\n \tcase UNORDERED:\treturn CC3;\n \tcase ORDERED:\treturn CC0 | CC1 | CC2;\n \tcase UNEQ:\treturn CC0 | CC3;\n-        case UNLT:\treturn CC1 | CC3;\n-        case UNGT:\treturn CC2 | CC3;\n-        case UNLE:\treturn CC0 | CC1 | CC3;\n-        case UNGE:\treturn CC0 | CC2 | CC3;\n+\tcase UNLT:\treturn CC1 | CC3;\n+\tcase UNGT:\treturn CC2 | CC3;\n+\tcase UNLE:\treturn CC0 | CC1 | CC3;\n+\tcase UNGE:\treturn CC0 | CC2 | CC3;\n \tcase LTGT:\treturn CC1 | CC2;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n     case E_CCSRmode:\n       switch (GET_CODE (code))\n-        {\n-        case EQ:\treturn CC0;\n-        case NE:\treturn CC2 | CC1 | CC3;\n-        case LT:\treturn CC2;\n-        case GT:\treturn CC1;\n-        case LE:\treturn CC0 | CC2;\n-        case GE:\treturn CC0 | CC1;\n+\t{\n+\tcase EQ:\treturn CC0;\n+\tcase NE:\treturn CC2 | CC1 | CC3;\n+\tcase LT:\treturn CC2;\n+\tcase GT:\treturn CC1;\n+\tcase LE:\treturn CC0 | CC2;\n+\tcase GE:\treturn CC0 | CC1;\n \tcase UNORDERED:\treturn CC3;\n \tcase ORDERED:\treturn CC0 | CC2 | CC1;\n \tcase UNEQ:\treturn CC0 | CC3;\n-        case UNLT:\treturn CC2 | CC3;\n-        case UNGT:\treturn CC1 | CC3;\n-        case UNLE:\treturn CC0 | CC2 | CC3;\n-        case UNGE:\treturn CC0 | CC1 | CC3;\n+\tcase UNLT:\treturn CC2 | CC3;\n+\tcase UNGT:\treturn CC1 | CC3;\n+\tcase UNLE:\treturn CC0 | CC2 | CC3;\n+\tcase UNGE:\treturn CC0 | CC1 | CC3;\n \tcase LTGT:\treturn CC2 | CC1;\n \tdefault:\treturn -1;\n-        }\n+\t}\n       break;\n \n       /* Vector comparison modes.  */\n@@ -2515,7 +2515,7 @@ s390_split_ok_p (rtx dst, rtx src, machine_mode mode, int first_subword)\n     {\n       rtx subreg = operand_subword (dst, first_subword, 0, mode);\n       if (reg_overlap_mentioned_p (subreg, src))\n-        return false;\n+\treturn false;\n     }\n \n   return true;\n@@ -2615,7 +2615,7 @@ s390_expand_logical_operator (enum rtx_code code, machine_mode mode,\n       else if (REG_P (dst))\n \tdst = gen_rtx_SUBREG (wmode, dst, 0);\n       else\n-        dst = gen_reg_rtx (wmode);\n+\tdst = gen_reg_rtx (wmode);\n \n       if (GET_CODE (src1) == SUBREG\n \t  && (tem = simplify_subreg (wmode, src1, mode, 0)) != 0)\n@@ -2737,7 +2737,7 @@ s390_short_displacement (rtx disp)\n   if (GET_CODE (disp) == CONST\n       && GET_CODE (XEXP (disp, 0)) == UNSPEC\n       && (XINT (XEXP (disp, 0), 1) == UNSPEC_GOT\n-          || XINT (XEXP (disp, 0), 1) == UNSPEC_GOTNTPOFF))\n+\t  || XINT (XEXP (disp, 0), 1) == UNSPEC_GOTNTPOFF))\n     return false;\n \n   /* All other symbolic constants are literal pool references,\n@@ -2895,13 +2895,13 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t      && frame_pointer_needed\n \t      && REGNO (base) == HARD_FRAME_POINTER_REGNUM)\n \t  || REGNO (base) == ARG_POINTER_REGNUM\n-          || (flag_pic\n-              && REGNO (base) == PIC_OFFSET_TABLE_REGNUM))\n-        pointer = base_ptr = true;\n+\t  || (flag_pic\n+\t      && REGNO (base) == PIC_OFFSET_TABLE_REGNUM))\n+\tpointer = base_ptr = true;\n \n       if ((reload_completed || reload_in_progress)\n \t  && base == cfun->machine->base_reg)\n-        pointer = base_ptr = literal_pool = true;\n+\tpointer = base_ptr = literal_pool = true;\n     }\n \n   /* Validate index register.  */\n@@ -2941,13 +2941,13 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t      && frame_pointer_needed\n \t      && REGNO (indx) == HARD_FRAME_POINTER_REGNUM)\n \t  || REGNO (indx) == ARG_POINTER_REGNUM\n-          || (flag_pic\n-              && REGNO (indx) == PIC_OFFSET_TABLE_REGNUM))\n-        pointer = indx_ptr = true;\n+\t  || (flag_pic\n+\t      && REGNO (indx) == PIC_OFFSET_TABLE_REGNUM))\n+\tpointer = indx_ptr = true;\n \n       if ((reload_completed || reload_in_progress)\n \t  && indx == cfun->machine->base_reg)\n-        pointer = indx_ptr = literal_pool = true;\n+\tpointer = indx_ptr = literal_pool = true;\n     }\n \n   /* Prefer to use pointer as base, not index.  */\n@@ -2991,14 +2991,14 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n       pointer = true;\n \n       /* In the small-PIC case, the linker converts @GOT\n-         and @GOTNTPOFF offsets to possible displacements.  */\n+\t and @GOTNTPOFF offsets to possible displacements.  */\n       if (GET_CODE (disp) == UNSPEC\n-          && (XINT (disp, 1) == UNSPEC_GOT\n+\t  && (XINT (disp, 1) == UNSPEC_GOT\n \t      || XINT (disp, 1) == UNSPEC_GOTNTPOFF)\n \t  && flag_pic == 1)\n-        {\n+\t{\n \t  ;\n-        }\n+\t}\n \n       /* Accept pool label offsets.  */\n       else if (GET_CODE (disp) == UNSPEC\n@@ -3008,7 +3008,7 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n       /* Accept literal pool references.  */\n       else if (GET_CODE (disp) == UNSPEC\n \t       && XINT (disp, 1) == UNSPEC_LTREL_OFFSET)\n-        {\n+\t{\n \t  /* In case CSE pulled a non literal pool reference out of\n \t     the pool we have to reject the address.  This is\n \t     especially important when loading the GOT pointer on non\n@@ -3028,9 +3028,9 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t      if (offset >= GET_MODE_SIZE (get_pool_mode (sym)))\n \t\treturn false;\n \n-              orig_disp = plus_constant (Pmode, orig_disp, offset);\n+\t      orig_disp = plus_constant (Pmode, orig_disp, offset);\n \t    }\n-        }\n+\t}\n \n       else\n \treturn false;\n@@ -3403,7 +3403,7 @@ s390_float_const_zero_p (rtx value)\n \n static int\n s390_register_move_cost (machine_mode mode,\n-                         reg_class_t from, reg_class_t to)\n+\t\t\t reg_class_t from, reg_class_t to)\n {\n   /* On s390, copy between fprs and gprs is expensive.  */\n \n@@ -3636,14 +3636,14 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \n     case UDIV:\n     case UMOD:\n-      if (mode == TImode) \t       /* 128 bit division */\n+      if (mode == TImode)\t       /* 128 bit division */\n \t*total = s390_cost->dlgr;\n       else if (mode == DImode)\n \t{\n \t  rtx right = XEXP (x, 1);\n \t  if (GET_CODE (right) == ZERO_EXTEND) /* 64 by 32 bit division */\n \t    *total = s390_cost->dlr;\n-\t  else \t                               /* 64 by 64 bit division */\n+\t  else\t\t\t\t       /* 64 by 64 bit division */\n \t    *total = s390_cost->dlgr;\n \t}\n       else if (mode == SImode)         /* 32 bit division */\n@@ -3660,7 +3660,7 @@ s390_rtx_costs (rtx x, machine_mode mode, int outer_code,\n \t      *total = s390_cost->dsgfr;\n \t    else\n \t      *total = s390_cost->dr;\n-\t  else \t                               /* 64 by 64 bit division */\n+\t  else\t\t\t\t       /* 64 by 64 bit division */\n \t    *total = s390_cost->dsgr;\n \t}\n       else if (mode == SImode)         /* 32 bit division */\n@@ -3941,7 +3941,7 @@ s390_cannot_force_const_mem (machine_mode mode, rtx x)\n \n     case SYMBOL_REF:\n       /* 'Naked' TLS symbol references are never OK,\n-         non-TLS symbols are OK iff we are non-PIC.  */\n+\t non-TLS symbols are OK iff we are non-PIC.  */\n       if (tls_symbolic_operand (x))\n \treturn true;\n       else\n@@ -4117,7 +4117,7 @@ s390_preferred_reload_class (rtx op, reg_class_t rclass)\n       case CONST:\n \t/* Symrefs cannot be pushed into the literal pool with -fPIC\n \t   so we *MUST NOT* return NO_REGS for these cases\n-\t   (s390_cannot_force_const_mem will return true).  \n+\t   (s390_cannot_force_const_mem will return true).\n \n \t   On the other hand we MUST return NO_REGS for symrefs with\n \t   invalid addend which might have been pushed to the literal\n@@ -4138,7 +4138,7 @@ s390_preferred_reload_class (rtx op, reg_class_t rclass)\n       case LABEL_REF:\n       case SYMBOL_REF:\n \tif (!legitimate_reload_constant_p (op))\n-          return NO_REGS;\n+\t  return NO_REGS;\n \t/* fallthrough */\n       case PLUS:\n \t/* load address will be used.  */\n@@ -4179,7 +4179,7 @@ s390_check_symref_alignment (rtx addr, HOST_WIDE_INT alignment)\n   if (GET_CODE (symref) == SYMBOL_REF)\n     {\n       /* We have load-relative instructions for 2-byte, 4-byte, and\n-         8-byte alignment so allow only these.  */\n+\t 8-byte alignment so allow only these.  */\n       switch (alignment)\n \t{\n \tcase 8:\treturn !SYMBOL_FLAG_NOTALIGN8_P (symref);\n@@ -4339,10 +4339,10 @@ s390_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t  case E_##M##mode:\t\t\t\t\t\t\\\n \t    if (TARGET_64BIT)\t\t\t\t\t\t\\\n \t      sri->icode = in_p ? CODE_FOR_reload##m##di_toreg_z10 :\t\\\n-                                  CODE_FOR_reload##m##di_tomem_z10;\t\\\n+\t\t\t\t  CODE_FOR_reload##m##di_tomem_z10;\t\\\n \t    else\t\t\t\t\t\t\t\\\n-  \t      sri->icode = in_p ? CODE_FOR_reload##m##si_toreg_z10 :\t\\\n-                                  CODE_FOR_reload##m##si_tomem_z10;\t\\\n+\t      sri->icode = in_p ? CODE_FOR_reload##m##si_toreg_z10 :\t\\\n+\t\t\t\t  CODE_FOR_reload##m##si_tomem_z10;\t\\\n \t  break;\n \n \t  switch (GET_MODE (x))\n@@ -4508,7 +4508,7 @@ s390_expand_plus_operand (rtx target, rtx src,\n       || (ad.indx && !REGNO_OK_FOR_INDEX_P (REGNO (ad.indx))))\n     {\n       /* Otherwise, one of the operands cannot be an address register;\n-         we reload its value into the scratch register.  */\n+\t we reload its value into the scratch register.  */\n       if (true_regnum (sum1) < 1 || true_regnum (sum1) > 15)\n \t{\n \t  emit_move_insn (scratch, sum1);\n@@ -4521,9 +4521,9 @@ s390_expand_plus_operand (rtx target, rtx src,\n \t}\n \n       /* According to the way these invalid addresses are generated\n-         in reload.c, it should never happen (at least on s390) that\n-         *neither* of the PLUS components, after find_replacements\n-         was applied, is an address register.  */\n+\t in reload.c, it should never happen (at least on s390) that\n+\t *neither* of the PLUS components, after find_replacements\n+\t was applied, is an address register.  */\n       if (sum1 == scratch && sum2 == scratch)\n \t{\n \t  debug_rtx (src);\n@@ -4786,7 +4786,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t that case.  So no need to do it here.  */\n \n       if (reg == 0)\n-        reg = gen_reg_rtx (Pmode);\n+\treg = gen_reg_rtx (Pmode);\n \n       if (TARGET_Z10)\n \t{\n@@ -4800,19 +4800,19 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  new_rtx = reg;\n \t}\n       else if (flag_pic == 1)\n-        {\n-          /* Assume GOT offset is a valid displacement operand (< 4k\n-             or < 512k with z990).  This is handled the same way in\n-             both 31- and 64-bit code (@GOT).\n-             lg <target>, sym@GOT(r12)  */\n+\t{\n+\t  /* Assume GOT offset is a valid displacement operand (< 4k\n+\t     or < 512k with z990).  This is handled the same way in\n+\t     both 31- and 64-bit code (@GOT).\n+\t     lg <target>, sym@GOT(r12)  */\n \n \t  if (reload_in_progress || reload_completed)\n \t    df_set_regs_ever_live (PIC_OFFSET_TABLE_REGNUM, true);\n \n-          new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n-          new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n-          new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new_rtx);\n-          new_rtx = gen_const_mem (Pmode, new_rtx);\n+\t  new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOT);\n+\t  new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+\t  new_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, new_rtx);\n+\t  new_rtx = gen_const_mem (Pmode, new_rtx);\n \t  emit_move_insn (reg, new_rtx);\n \t  new_rtx = reg;\n \t}\n@@ -4821,15 +4821,15 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t  /* If the GOT offset might be >= 4k, we determine the position\n \t     of the GOT entry via a PC-relative LARL (@GOTENT).\n \t     larl temp, sym@GOTENT\n-             lg   <target>, 0(temp) */\n+\t     lg   <target>, 0(temp) */\n \n-          rtx temp = reg ? reg : gen_reg_rtx (Pmode);\n+\t  rtx temp = reg ? reg : gen_reg_rtx (Pmode);\n \n \t  gcc_assert (REGNO (temp) >= FIRST_PSEUDO_REGISTER\n \t\t      || REGNO_REG_CLASS (REGNO (temp)) == ADDR_REGS);\n \n-          new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTENT);\n-          new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n+\t  new_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTENT);\n+\t  new_rtx = gen_rtx_CONST (Pmode, new_rtx);\n \t  emit_move_insn (temp, new_rtx);\n \t  new_rtx = gen_const_mem (Pmode, temp);\n \t  emit_move_insn (reg, new_rtx);\n@@ -5051,7 +5051,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \tnew_rtx = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_NTPOFF);\n \tnew_rtx = gen_rtx_CONST (Pmode, new_rtx);\n \tnew_rtx = force_const_mem (Pmode, new_rtx);\n-        temp = gen_reg_rtx (Pmode);\n+\ttemp = gen_reg_rtx (Pmode);\n \temit_move_insn (temp, new_rtx);\n \n \tnew_rtx = gen_rtx_PLUS (Pmode, s390_get_thread_pointer (), temp);\n@@ -5149,9 +5149,9 @@ s390_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n   else if (flag_pic)\n     {\n       if (SYMBOLIC_CONST (x)\n-          || (GET_CODE (x) == PLUS\n-              && (SYMBOLIC_CONST (XEXP (x, 0))\n-                  || SYMBOLIC_CONST (XEXP (x, 1)))))\n+\t  || (GET_CODE (x) == PLUS\n+\t      && (SYMBOLIC_CONST (XEXP (x, 0))\n+\t\t  || SYMBOLIC_CONST (XEXP (x, 1)))))\n \t  x = legitimize_pic_address (x, 0);\n \n       if (s390_legitimate_address_p (mode, x, FALSE))\n@@ -5308,7 +5308,7 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)\n \n       mode = GET_MODE (len);\n       if (mode == VOIDmode)\n-        mode = Pmode;\n+\tmode = Pmode;\n \n       dst_addr = gen_reg_rtx (Pmode);\n       src_addr = gen_reg_rtx (Pmode);\n@@ -5327,12 +5327,12 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)\n       temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1,\n \t\t\t   OPTAB_DIRECT);\n       if (temp != count)\n-        emit_move_insn (count, temp);\n+\temit_move_insn (count, temp);\n \n       temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1,\n \t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n-        emit_move_insn (blocks, temp);\n+\temit_move_insn (blocks, temp);\n \n       emit_cmp_and_jump_insns (blocks, const0_rtx,\n \t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n@@ -5366,7 +5366,7 @@ s390_expand_movmem (rtx dst, rtx src, rtx len)\n       temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1,\n \t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n-        emit_move_insn (blocks, temp);\n+\temit_move_insn (blocks, temp);\n \n       emit_cmp_and_jump_insns (blocks, const0_rtx,\n \t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n@@ -5588,12 +5588,12 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n   if (GET_CODE (len) == CONST_INT && INTVAL (len) >= 0 && INTVAL (len) <= 256)\n     {\n       if (INTVAL (len) > 0)\n-        {\n-          emit_insn (gen_cmpmem_short (op0, op1, GEN_INT (INTVAL (len) - 1)));\n-          emit_insn (gen_cmpint (target, ccreg));\n-        }\n+\t{\n+\t  emit_insn (gen_cmpmem_short (op0, op1, GEN_INT (INTVAL (len) - 1)));\n+\t  emit_insn (gen_cmpint (target, ccreg));\n+\t}\n       else\n-        emit_move_insn (target, const0_rtx);\n+\temit_move_insn (target, const0_rtx);\n     }\n   else if (TARGET_MVCLE)\n     {\n@@ -5610,7 +5610,7 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n \n       mode = GET_MODE (len);\n       if (mode == VOIDmode)\n-        mode = Pmode;\n+\tmode = Pmode;\n \n       addr0 = gen_reg_rtx (Pmode);\n       addr1 = gen_reg_rtx (Pmode);\n@@ -5629,12 +5629,12 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n       temp = expand_binop (mode, add_optab, count, constm1_rtx, count, 1,\n \t\t\t   OPTAB_DIRECT);\n       if (temp != count)\n-        emit_move_insn (count, temp);\n+\temit_move_insn (count, temp);\n \n       temp = expand_binop (mode, lshr_optab, count, GEN_INT (8), blocks, 1,\n \t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n-        emit_move_insn (blocks, temp);\n+\temit_move_insn (blocks, temp);\n \n       emit_cmp_and_jump_insns (blocks, const0_rtx,\n \t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n@@ -5674,7 +5674,7 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n       temp = expand_binop (mode, add_optab, blocks, constm1_rtx, blocks, 1,\n \t\t\t   OPTAB_DIRECT);\n       if (temp != blocks)\n-        emit_move_insn (blocks, temp);\n+\temit_move_insn (blocks, temp);\n \n       emit_cmp_and_jump_insns (blocks, const0_rtx,\n \t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n@@ -5810,7 +5810,7 @@ s390_expand_vec_strlen (rtx target, rtx string, rtx alignment)\n \t\t\t    highest_index_to_load_reg, str_idx_reg));\n \n   add_reg_br_prob_note (s390_emit_jump (is_aligned_label, cond),\n-\t\t        profile_probability::very_unlikely ());\n+\t\t\tprofile_probability::very_unlikely ());\n \n   expand_binop (Pmode, add_optab, str_idx_reg,\n \t\tGEN_INT (-16), str_idx_reg, 1, OPTAB_DIRECT);\n@@ -6044,7 +6044,7 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n \n       p = rtvec_alloc (2);\n       RTVEC_ELT (p, 0) =\n-        gen_rtx_SET (dst, op_res);\n+\tgen_rtx_SET (dst, op_res);\n       RTVEC_ELT (p, 1) =\n \tgen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n@@ -6111,7 +6111,7 @@ s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,\n \t\t\t\t\t      const0_rtx));\n       p = rtvec_alloc (2);\n       RTVEC_ELT (p, 0) =\n-        gen_rtx_SET (dst, op_res);\n+\tgen_rtx_SET (dst, op_res);\n       RTVEC_ELT (p, 1) =\n \tgen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, CC_REGNUM));\n       emit_insn (gen_rtx_PARALLEL (VOIDmode, p));\n@@ -6942,8 +6942,8 @@ s390_expand_cs_tdsi (machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n \t  emit_insn (gen_rtx_SET (cc, gen_rtx_COMPARE (CCZmode, output, cmp)));\n \t}\n       s390_emit_jump (skip_cs_label, gen_rtx_NE (VOIDmode, cc, const0_rtx));\n-      add_reg_br_prob_note (get_last_insn (), \n-\t\t            profile_probability::very_unlikely ());\n+      add_reg_br_prob_note (get_last_insn (),\n+\t\t\t    profile_probability::very_unlikely ());\n       /* If the jump is not taken, OUTPUT is the expected value.  */\n       cmp = output;\n       /* Reload newval to a register manually, *after* the compare and jump\n@@ -7210,12 +7210,12 @@ s390_delegitimize_address (rtx orig_x)\n \n   /* Extract the symbol ref from:\n      (plus:SI (reg:SI 12 %r12)\n-              (const:SI (unspec:SI [(symbol_ref/f:SI (\"*.LC0\"))]\n-\t                            UNSPEC_GOTOFF/PLTOFF)))\n+\t      (const:SI (unspec:SI [(symbol_ref/f:SI (\"*.LC0\"))]\n+\t\t\t\t    UNSPEC_GOTOFF/PLTOFF)))\n      and\n      (plus:SI (reg:SI 12 %r12)\n-              (const:SI (plus:SI (unspec:SI [(symbol_ref:SI (\"L\"))]\n-                                             UNSPEC_GOTOFF/PLTOFF)\n+\t      (const:SI (plus:SI (unspec:SI [(symbol_ref:SI (\"L\"))]\n+\t\t\t\t\t     UNSPEC_GOTOFF/PLTOFF)\n \t\t\t\t (const_int 4 [0x4]))))  */\n   if (GET_CODE (x) == PLUS\n       && REG_P (XEXP (x, 0))\n@@ -7260,7 +7260,7 @@ s390_delegitimize_address (rtx orig_x)\n     {\n       /* Extract the symbol ref from:\n \t (mem:QI (const:DI (unspec:DI [(symbol_ref:DI (\"foo\"))]\n-\t                               UNSPEC_PLT/GOTENT)))  */\n+\t\t\t\t       UNSPEC_PLT/GOTENT)))  */\n \n       y = XEXP (x, 0);\n       if (GET_CODE (y) == UNSPEC\n@@ -7575,7 +7575,7 @@ print_operand_address (FILE *file, rtx addr)\n \n   if (ad.base && ad.indx)\n     fprintf (file, \"(%s,%s)\", reg_names[REGNO (ad.indx)],\n-                              reg_names[REGNO (ad.base)]);\n+\t\t\t      reg_names[REGNO (ad.base)]);\n   else if (ad.base)\n     fprintf (file, \"(%s)\", reg_names[REGNO (ad.base)]);\n }\n@@ -7609,7 +7609,7 @@ print_operand_address (FILE *file, rtx addr)\n     'o': print integer X as if it's an unsigned 32bit word.\n     's': \"start\" of contiguous bitmask X in either DImode or vector inner mode.\n     't': CONST_INT: \"start\" of contiguous bitmask X in SImode.\n-         CONST_VECTOR: Generate a bitmask for vgbm instruction.\n+\t CONST_VECTOR: Generate a bitmask for vgbm instruction.\n     'x': print integer X as if it's an unsigned halfword.\n     'v': print register number as vector register (v1 instead of f1).\n */\n@@ -7667,7 +7667,7 @@ print_operand (FILE *file, rtx x, int code)\n \n     case 'O':\n       {\n-        struct s390_address ad;\n+\tstruct s390_address ad;\n \tint ret;\n \n \tret = s390_decompose_address (MEM_P (x) ? XEXP (x, 0) : x, &ad);\n@@ -7680,16 +7680,16 @@ print_operand (FILE *file, rtx x, int code)\n \t    return;\n \t  }\n \n-        if (ad.disp)\n-          output_addr_const (file, ad.disp);\n-        else\n-          fprintf (file, \"0\");\n+\tif (ad.disp)\n+\t  output_addr_const (file, ad.disp);\n+\telse\n+\t  fprintf (file, \"0\");\n       }\n       return;\n \n     case 'R':\n       {\n-        struct s390_address ad;\n+\tstruct s390_address ad;\n \tint ret;\n \n \tret = s390_decompose_address (MEM_P (x) ? XEXP (x, 0) : x, &ad);\n@@ -7702,10 +7702,10 @@ print_operand (FILE *file, rtx x, int code)\n \t    return;\n \t  }\n \n-        if (ad.base)\n-          fprintf (file, \"%s\", reg_names[REGNO (ad.base)]);\n-        else\n-          fprintf (file, \"0\");\n+\tif (ad.base)\n+\t  fprintf (file, \"%s\", reg_names[REGNO (ad.base)]);\n+\telse\n+\t  fprintf (file, \"0\");\n       }\n       return;\n \n@@ -7851,13 +7851,13 @@ print_operand (FILE *file, rtx x, int code)\n \n     case CONST_WIDE_INT:\n       if (code == 'b')\n-        fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC,\n \t\t CONST_WIDE_INT_ELT (x, 0) & 0xff);\n       else if (code == 'x')\n-        fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC,\n \t\t CONST_WIDE_INT_ELT (x, 0) & 0xffff);\n       else if (code == 'h')\n-        fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC,\n \t\t ((CONST_WIDE_INT_ELT (x, 0) & 0xffff) ^ 0x8000) - 0x8000);\n       else\n \t{\n@@ -8060,7 +8060,7 @@ s390_adjust_priority (rtx_insn *insn, int priority)\n \tpriority = priority << 1;\n \tbreak;\n       default:\n-        break;\n+\tbreak;\n     }\n   return priority;\n }\n@@ -8191,14 +8191,14 @@ annotate_constant_pool_refs (rtx *x)\n   for (i = GET_RTX_LENGTH (GET_CODE (*x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-        {\n-          annotate_constant_pool_refs (&XEXP (*x, i));\n-        }\n+\t{\n+\t  annotate_constant_pool_refs (&XEXP (*x, i));\n+\t}\n       else if (fmt[i] == 'E')\n-        {\n-          for (j = 0; j < XVECLEN (*x, i); j++)\n-            annotate_constant_pool_refs (&XVECEXP (*x, i, j));\n-        }\n+\t{\n+\t  for (j = 0; j < XVECLEN (*x, i); j++)\n+\t    annotate_constant_pool_refs (&XVECEXP (*x, i, j));\n+\t}\n     }\n }\n \n@@ -8226,13 +8226,13 @@ find_constant_pool_ref (rtx x, rtx *ref)\n     return;\n \n   gcc_assert (GET_CODE (x) != SYMBOL_REF\n-              || !CONSTANT_POOL_ADDRESS_P (x));\n+\t      || !CONSTANT_POOL_ADDRESS_P (x));\n \n   if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_LTREF)\n     {\n       rtx sym = XVECEXP (x, 0, 0);\n       gcc_assert (GET_CODE (sym) == SYMBOL_REF\n-\t          && CONSTANT_POOL_ADDRESS_P (sym));\n+\t\t  && CONSTANT_POOL_ADDRESS_P (sym));\n \n       if (*ref == NULL_RTX)\n \t*ref = sym;\n@@ -8246,14 +8246,14 @@ find_constant_pool_ref (rtx x, rtx *ref)\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-        {\n-          find_constant_pool_ref (XEXP (x, i), ref);\n-        }\n+\t{\n+\t  find_constant_pool_ref (XEXP (x, i), ref);\n+\t}\n       else if (fmt[i] == 'E')\n-        {\n-          for (j = 0; j < XVECLEN (x, i); j++)\n-            find_constant_pool_ref (XVECEXP (x, i, j), ref);\n-        }\n+\t{\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n+\t    find_constant_pool_ref (XVECEXP (x, i, j), ref);\n+\t}\n     }\n }\n \n@@ -8291,14 +8291,14 @@ replace_constant_pool_ref (rtx *x, rtx ref, rtx offset)\n   for (i = GET_RTX_LENGTH (GET_CODE (*x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-        {\n-          replace_constant_pool_ref (&XEXP (*x, i), ref, offset);\n-        }\n+\t{\n+\t  replace_constant_pool_ref (&XEXP (*x, i), ref, offset);\n+\t}\n       else if (fmt[i] == 'E')\n-        {\n-          for (j = 0; j < XVECLEN (*x, i); j++)\n-            replace_constant_pool_ref (&XVECEXP (*x, i, j), ref, offset);\n-        }\n+\t{\n+\t  for (j = 0; j < XVECLEN (*x, i); j++)\n+\t    replace_constant_pool_ref (&XVECEXP (*x, i, j), ref, offset);\n+\t}\n     }\n }\n \n@@ -8319,20 +8319,20 @@ find_ltrel_base (rtx x)\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-        {\n-          rtx fnd = find_ltrel_base (XEXP (x, i));\n+\t{\n+\t  rtx fnd = find_ltrel_base (XEXP (x, i));\n \t  if (fnd)\n \t    return fnd;\n-        }\n+\t}\n       else if (fmt[i] == 'E')\n-        {\n-          for (j = 0; j < XVECLEN (x, i); j++)\n+\t{\n+\t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n-              rtx fnd = find_ltrel_base (XVECEXP (x, i, j));\n+\t      rtx fnd = find_ltrel_base (XVECEXP (x, i, j));\n \t      if (fnd)\n \t\treturn fnd;\n \t    }\n-        }\n+\t}\n     }\n \n   return NULL_RTX;\n@@ -8357,14 +8357,14 @@ replace_ltrel_base (rtx *x)\n   for (i = GET_RTX_LENGTH (GET_CODE (*x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-        {\n-          replace_ltrel_base (&XEXP (*x, i));\n-        }\n+\t{\n+\t  replace_ltrel_base (&XEXP (*x, i));\n+\t}\n       else if (fmt[i] == 'E')\n-        {\n-          for (j = 0; j < XVECLEN (*x, i); j++)\n-            replace_ltrel_base (&XVECEXP (*x, i, j));\n-        }\n+\t{\n+\t  for (j = 0; j < XVECLEN (*x, i); j++)\n+\t    replace_ltrel_base (&XVECEXP (*x, i, j));\n+\t}\n     }\n }\n \n@@ -8857,21 +8857,21 @@ s390_mainpool_finish (struct constant_pool *pool)\n \treplace_ltrel_base (&PATTERN (insn));\n \n       if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n-        {\n-          rtx addr, pool_ref = NULL_RTX;\n-          find_constant_pool_ref (PATTERN (insn), &pool_ref);\n-          if (pool_ref)\n-            {\n+\t{\n+\t  rtx addr, pool_ref = NULL_RTX;\n+\t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+\t  if (pool_ref)\n+\t    {\n \t      if (s390_execute_label (insn))\n \t\taddr = s390_find_execute (pool, insn);\n \t      else\n \t\taddr = s390_find_constant (pool, get_pool_constant (pool_ref),\n \t\t\t\t\t\t get_pool_mode (pool_ref));\n \n-              replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n-              INSN_CODE (insn) = -1;\n-            }\n-        }\n+\t      replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n+\t      INSN_CODE (insn) = -1;\n+\t    }\n+\t}\n     }\n \n \n@@ -9039,7 +9039,7 @@ s390_chunkify_start (void)\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     if (LABEL_P (insn)\n-        && bitmap_bit_p (far_labels, CODE_LABEL_NUMBER (insn)))\n+\t&& bitmap_bit_p (far_labels, CODE_LABEL_NUMBER (insn)))\n       {\n \tstruct constant_pool *pool = s390_find_pool (pool_list, insn);\n \tif (pool)\n@@ -9085,22 +9085,22 @@ s390_chunkify_finish (struct constant_pool *pool_list)\n \tcontinue;\n \n       if (NONJUMP_INSN_P (insn) || CALL_P (insn))\n-        {\n-          rtx addr, pool_ref = NULL_RTX;\n-          find_constant_pool_ref (PATTERN (insn), &pool_ref);\n-          if (pool_ref)\n-            {\n+\t{\n+\t  rtx addr, pool_ref = NULL_RTX;\n+\t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n+\t  if (pool_ref)\n+\t    {\n \t      if (s390_execute_label (insn))\n \t\taddr = s390_find_execute (curr_pool, insn);\n \t      else\n \t\taddr = s390_find_constant (curr_pool,\n \t\t\t\t\t   get_pool_constant (pool_ref),\n \t\t\t\t\t   get_pool_mode (pool_ref));\n \n-              replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n-              INSN_CODE (insn) = -1;\n-            }\n-        }\n+\t      replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n+\t      INSN_CODE (insn) = -1;\n+\t    }\n+\t}\n     }\n \n   /* Dump out all literal pools.  */\n@@ -10416,9 +10416,9 @@ save_gprs (rtx base, int offset, int first, int last)\n   if (first == last)\n     {\n       if (TARGET_64BIT)\n-        insn = gen_movdi (addr, gen_rtx_REG (Pmode, first));\n+\tinsn = gen_movdi (addr, gen_rtx_REG (Pmode, first));\n       else\n-        insn = gen_movsi (addr, gen_rtx_REG (Pmode, first));\n+\tinsn = gen_movsi (addr, gen_rtx_REG (Pmode, first));\n \n       if (!global_not_special_regno_p (first))\n \tRTX_FRAME_RELATED_P (insn) = 1;\n@@ -10529,9 +10529,9 @@ restore_gprs (rtx base, int offset, int first, int last)\n   if (first == last)\n     {\n       if (TARGET_64BIT)\n-        insn = gen_movdi (gen_rtx_REG (Pmode, first), addr);\n+\tinsn = gen_movdi (gen_rtx_REG (Pmode, first), addr);\n       else\n-        insn = gen_movsi (gen_rtx_REG (Pmode, first), addr);\n+\tinsn = gen_movsi (gen_rtx_REG (Pmode, first), addr);\n \n       RTX_FRAME_RELATED_P (insn) = 1;\n       return insn;\n@@ -11067,7 +11067,7 @@ s390_emit_prologue (void)\n \t\t\t\t\t     t, const0_rtx, const0_rtx));\n \t\t}\n \t    }\n-  \t}\n+\t}\n \n       if (s390_warn_framesize > 0\n \t  && cfun_frame_layout.frame_size >= s390_warn_framesize)\n@@ -11215,7 +11215,7 @@ s390_emit_epilogue (bool sibcall)\n \t algorithms located at the branch target.  */\n \n       /* Emit a blockage here so that all code\n-         lies between the profiling mechanisms.  */\n+\t lies between the profiling mechanisms.  */\n       emit_insn (gen_blockage ());\n \n       emit_insn (gen_epilogue_tpf ());\n@@ -11236,7 +11236,7 @@ s390_emit_epilogue (bool sibcall)\n       /* Nothing to restore.  */\n     }\n   else if (DISP_IN_RANGE (cfun_frame_layout.frame_size + area_bottom)\n-           && DISP_IN_RANGE (cfun_frame_layout.frame_size + area_top - 1))\n+\t   && DISP_IN_RANGE (cfun_frame_layout.frame_size + area_top - 1))\n     {\n       /* Area is in range.  */\n       offset = cfun_frame_layout.frame_size;\n@@ -11534,8 +11534,8 @@ s390_expand_split_stack_prologue (void)\n       LABEL_NUSES (call_done)++;\n \n       /* Mark the jump as very unlikely to be taken.  */\n-      add_reg_br_prob_note (insn, \n-\t\t            profile_probability::very_unlikely ());\n+      add_reg_br_prob_note (insn,\n+\t\t\t    profile_probability::very_unlikely ());\n \n       if (cfun->machine->split_stack_varargs_pointer != NULL_RTX)\n \t{\n@@ -11803,7 +11803,7 @@ s390_pass_by_reference (cumulative_args_t ca ATTRIBUTE_UNUSED,\n   if (type)\n     {\n       if (AGGREGATE_TYPE_P (type) && exact_log2 (size) < 0)\n-        return true;\n+\treturn true;\n \n       if (TREE_CODE (type) == COMPLEX_TYPE\n \t  || TREE_CODE (type) == VECTOR_TYPE)\n@@ -11976,9 +11976,9 @@ s390_return_in_memory (const_tree type, const_tree fundecl ATTRIBUTE_UNUSED)\n \n static machine_mode\n s390_promote_function_mode (const_tree type, machine_mode mode,\n-                            int *punsignedp,\n-                            const_tree fntype ATTRIBUTE_UNUSED,\n-                            int for_return ATTRIBUTE_UNUSED)\n+\t\t\t    int *punsignedp,\n+\t\t\t    const_tree fntype ATTRIBUTE_UNUSED,\n+\t\t\t    int for_return ATTRIBUTE_UNUSED)\n {\n   if (INTEGRAL_MODE_P (mode)\n       && GET_MODE_SIZE (mode) < UNITS_PER_LONG)\n@@ -12073,12 +12073,12 @@ s390_libcall_value (machine_mode mode, const_rtx fun ATTRIBUTE_UNUSED)\n    On S/390, va_list is an array type equivalent to\n \n       typedef struct __va_list_tag\n-        {\n-            long __gpr;\n-            long __fpr;\n-            void *__overflow_arg_area;\n-            void *__reg_save_area;\n-        } va_list[1];\n+\t{\n+\t    long __gpr;\n+\t    long __fpr;\n+\t    void *__overflow_arg_area;\n+\t    void *__reg_save_area;\n+\t} va_list[1];\n \n    where __gpr and __fpr hold the number of general purpose\n    or floating point arguments used up to now, respectively,\n@@ -12182,14 +12182,14 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   if (cfun->va_list_fpr_size)\n     {\n       t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t          build_int_cst (NULL_TREE, n_fpr));\n+\t\t  build_int_cst (NULL_TREE, n_fpr));\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n \n   if (flag_split_stack\n      && (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (cfun->decl))\n-         == NULL)\n+\t == NULL)\n      && cfun->machine->split_stack_varargs_pointer == NULL_RTX)\n     {\n       rtx reg;\n@@ -12217,9 +12217,9 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       || TARGET_VX_ABI)\n     {\n       if (cfun->machine->split_stack_varargs_pointer == NULL_RTX)\n-        t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n+\tt = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n       else\n-        t = make_tree (TREE_TYPE (ovf), cfun->machine->split_stack_varargs_pointer);\n+\tt = make_tree (TREE_TYPE (ovf), cfun->machine->split_stack_varargs_pointer);\n \n       off = INTVAL (crtl->args.arg_offset_rtx);\n       off = off < 0 ? 0 : off;\n@@ -12255,7 +12255,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n    if (integral value) {\n      if (size  <= 4 && args.gpr < 5 ||\n-         size  > 4 && args.gpr < 4 )\n+\t size  > 4 && args.gpr < 4 )\n        ret = args.reg_save_area[args.gpr+8]\n      else\n        ret = *args.overflow_arg_area++;\n@@ -12391,13 +12391,13 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n     {\n       /*\n \tif (reg > ((typeof (reg))max_reg))\n-          goto lab_false;\n+\t  goto lab_false;\n \n-        addr = sav + sav_ofs + reg * save_scale;\n+\taddr = sav + sav_ofs + reg * save_scale;\n \n \tgoto lab_over;\n \n-        lab_false:\n+\tlab_false:\n       */\n \n       lab_false = create_artificial_label (UNKNOWN_LOCATION);\n@@ -12471,11 +12471,11 @@ s390_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n    expanders.\n    DEST  - Register location where CC will be stored.\n    TDB   - Pointer to a 256 byte area where to store the transaction.\n-           diagnostic block. NULL if TDB is not needed.\n+\t   diagnostic block. NULL if TDB is not needed.\n    RETRY - Retry count value.  If non-NULL a retry loop for CC2\n-           is emitted\n+\t   is emitted\n    CLOBBER_FPRS_P - If true clobbers for all FPRs are emitted as part\n-                    of the tbegin instruction pattern.  */\n+\t\t    of the tbegin instruction pattern.  */\n \n void\n s390_expand_tbegin (rtx dest, rtx tdb, rtx retry, bool clobber_fprs_p)\n@@ -12619,17 +12619,17 @@ output_asm_nops (const char *user, int hw)\n \t{\n \t  output_asm_insn (\"brcl\\t0,0\", NULL);\n \t  hw -= 3;\n-        }\n+\t}\n       else if (hw >= 2)\n-        {\n-          output_asm_insn (\"bc\\t0,0\", NULL);\n-          hw -= 2;\n-        }\n+\t{\n+\t  output_asm_insn (\"bc\\t0,0\", NULL);\n+\t  hw -= 2;\n+\t}\n       else\n-        {\n-          output_asm_insn (\"bcr\\t0,0\", NULL);\n-          hw -= 1;\n-        }\n+\t{\n+\t  output_asm_insn (\"bcr\\t0,0\", NULL);\n+\t  hw -= 1;\n+\t}\n     }\n }\n \n@@ -12668,44 +12668,44 @@ s390_function_profiler (FILE *file, int labelno)\n   if (flag_fentry)\n     {\n       if (flag_nop_mcount)\n-        output_asm_nops (\"-mnop-mcount\", /* brasl */ 3);\n+\toutput_asm_nops (\"-mnop-mcount\", /* brasl */ 3);\n       else if (cfun->static_chain_decl)\n-        warning (OPT_Wcannot_profile, \"nested functions cannot be profiled \"\n-                 \"with -mfentry on s390\");\n+\twarning (OPT_Wcannot_profile, \"nested functions cannot be profiled \"\n+\t\t \"with -mfentry on s390\");\n       else\n-        output_asm_insn (\"brasl\\t0,%4\", op);\n+\toutput_asm_insn (\"brasl\\t0,%4\", op);\n     }\n   else if (TARGET_64BIT)\n     {\n       if (flag_nop_mcount)\n-        output_asm_nops (\"-mnop-mcount\", /* stg */ 3 + /* larl */ 3 +\n-                         /* brasl */ 3 + /* lg */ 3);\n+\toutput_asm_nops (\"-mnop-mcount\", /* stg */ 3 + /* larl */ 3 +\n+\t\t\t /* brasl */ 3 + /* lg */ 3);\n       else\n-        {\n-          output_asm_insn (\"stg\\t%0,%1\", op);\n-          if (flag_dwarf2_cfi_asm)\n-            output_asm_insn (\".cfi_rel_offset\\t%0,%7\", op);\n-          output_asm_insn (\"larl\\t%2,%3\", op);\n-          output_asm_insn (\"brasl\\t%0,%4\", op);\n-          output_asm_insn (\"lg\\t%0,%1\", op);\n-          if (flag_dwarf2_cfi_asm)\n-            output_asm_insn (\".cfi_restore\\t%0\", op);\n-        }\n+\t{\n+\t  output_asm_insn (\"stg\\t%0,%1\", op);\n+\t  if (flag_dwarf2_cfi_asm)\n+\t    output_asm_insn (\".cfi_rel_offset\\t%0,%7\", op);\n+\t  output_asm_insn (\"larl\\t%2,%3\", op);\n+\t  output_asm_insn (\"brasl\\t%0,%4\", op);\n+\t  output_asm_insn (\"lg\\t%0,%1\", op);\n+\t  if (flag_dwarf2_cfi_asm)\n+\t    output_asm_insn (\".cfi_restore\\t%0\", op);\n+\t}\n     }\n   else\n     {\n       if (flag_nop_mcount)\n-        output_asm_nops (\"-mnop-mcount\", /* st */ 2 + /* larl */ 3 +\n-                         /* brasl */ 3 + /* l */ 2);\n+\toutput_asm_nops (\"-mnop-mcount\", /* st */ 2 + /* larl */ 3 +\n+\t\t\t /* brasl */ 3 + /* l */ 2);\n       else\n-        {\n-          output_asm_insn (\"st\\t%0,%1\", op);\n-          if (flag_dwarf2_cfi_asm)\n-            output_asm_insn (\".cfi_rel_offset\\t%0,%7\", op);\n-          output_asm_insn (\"larl\\t%2,%3\", op);\n-          output_asm_insn (\"brasl\\t%0,%4\", op);\n-          output_asm_insn (\"l\\t%0,%1\", op);\n-          if (flag_dwarf2_cfi_asm)\n+\t{\n+\t  output_asm_insn (\"st\\t%0,%1\", op);\n+\t  if (flag_dwarf2_cfi_asm)\n+\t    output_asm_insn (\".cfi_rel_offset\\t%0,%7\", op);\n+\t  output_asm_insn (\"larl\\t%2,%3\", op);\n+\t  output_asm_insn (\"brasl\\t%0,%4\", op);\n+\t  output_asm_insn (\"l\\t%0,%1\", op);\n+\t  if (flag_dwarf2_cfi_asm)\n \t    output_asm_insn (\".cfi_restore\\t%0\", op);\n \t}\n     }\n@@ -12830,8 +12830,8 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t    output_asm_insn (\"lay\\t%1,%2(%1)\", op);\n \t  else if (CONST_OK_FOR_K (delta))\n \t    output_asm_insn (\"aghi\\t%1,%2\", op);\n- \t  else if (CONST_OK_FOR_Os (delta))\n- \t    output_asm_insn (\"agfi\\t%1,%2\", op);\n+\t  else if (CONST_OK_FOR_Os (delta))\n+\t    output_asm_insn (\"agfi\\t%1,%2\", op);\n \t  else\n \t    {\n \t      op[6] = gen_label_rtx ();\n@@ -12853,12 +12853,12 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t      output_asm_insn (\"ag\\t%4,0(%1)\", op);\n \t      output_asm_insn (\"ag\\t%1,0(%4)\", op);\n \t    }\n- \t  else if (CONST_OK_FOR_Os (vcall_offset))\n- \t    {\n- \t      output_asm_insn (\"lgfi\\t%4,%3\", op);\n- \t      output_asm_insn (\"ag\\t%4,0(%1)\", op);\n- \t      output_asm_insn (\"ag\\t%1,0(%4)\", op);\n- \t    }\n+\t  else if (CONST_OK_FOR_Os (vcall_offset))\n+\t    {\n+\t      output_asm_insn (\"lgfi\\t%4,%3\", op);\n+\t      output_asm_insn (\"ag\\t%4,0(%1)\", op);\n+\t      output_asm_insn (\"ag\\t%1,0(%4)\", op);\n+\t    }\n \t  else\n \t    {\n \t      op[7] = gen_label_rtx ();\n@@ -12896,10 +12896,10 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n       /* Setup base pointer if required.  */\n       if (!vcall_offset\n \t  || (!DISP_IN_RANGE (delta)\n-              && !CONST_OK_FOR_K (delta)\n+\t      && !CONST_OK_FOR_K (delta)\n \t      && !CONST_OK_FOR_Os (delta))\n \t  || (!DISP_IN_RANGE (delta)\n-              && !CONST_OK_FOR_K (vcall_offset)\n+\t      && !CONST_OK_FOR_K (vcall_offset)\n \t      && !CONST_OK_FOR_Os (vcall_offset)))\n \t{\n \t  op[5] = gen_label_rtx ();\n@@ -12918,7 +12918,7 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t  else if (CONST_OK_FOR_K (delta))\n \t    output_asm_insn (\"ahi\\t%1,%2\", op);\n \t  else if (CONST_OK_FOR_Os (delta))\n- \t    output_asm_insn (\"afi\\t%1,%2\", op);\n+\t    output_asm_insn (\"afi\\t%1,%2\", op);\n \t  else\n \t    {\n \t      op[6] = gen_label_rtx ();\n@@ -12928,7 +12928,7 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \n       /* Perform vcall adjustment.  */\n       if (vcall_offset)\n-        {\n+\t{\n \t  if (CONST_OK_FOR_J (vcall_offset))\n \t    {\n \t      output_asm_insn (\"l\\t%4,0(%1)\", op);\n@@ -12946,11 +12946,11 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \t      output_asm_insn (\"a\\t%1,0(%4)\", op);\n \t    }\n \t  else if (CONST_OK_FOR_Os (vcall_offset))\n- \t    {\n- \t      output_asm_insn (\"iilf\\t%4,%3\", op);\n- \t      output_asm_insn (\"a\\t%4,0(%1)\", op);\n- \t      output_asm_insn (\"a\\t%1,0(%4)\", op);\n- \t    }\n+\t    {\n+\t      output_asm_insn (\"iilf\\t%4,%3\", op);\n+\t      output_asm_insn (\"a\\t%4,0(%1)\", op);\n+\t      output_asm_insn (\"a\\t%1,0(%4)\", op);\n+\t    }\n \t  else\n \t    {\n \t      op[7] = gen_label_rtx ();\n@@ -13175,10 +13175,10 @@ s390_call_saved_register_used (tree call_expr)\n \t named.  This only has an impact on vector argument register\n \t usage none of which is call-saved.  */\n       if (pass_by_reference (&cum_v, mode, type, true))\n- \t{\n- \t  mode = Pmode;\n- \t  type = build_pointer_type (type);\n- \t}\n+\t{\n+\t  mode = Pmode;\n+\t  type = build_pointer_type (type);\n+\t}\n \n        parm_rtx = s390_function_arg (cum, mode, type, true);\n \n@@ -13188,10 +13188,10 @@ s390_call_saved_register_used (tree call_expr)\n \t continue;\n \n        if (REG_P (parm_rtx))\n-  \t {\n+\t {\n \t   for (reg = 0; reg < REG_NREGS (parm_rtx); reg++)\n \t     if (!call_used_regs[reg + REGNO (parm_rtx)])\n- \t       return true;\n+\t       return true;\n \t }\n \n        if (GET_CODE (parm_rtx) == PARALLEL)\n@@ -13263,8 +13263,8 @@ s390_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n    TLS_CALL the location of the thread-local symbol\n    RESULT_REG the register where the result of the call should be stored\n    RETADDR_REG the register where the return address should be stored\n-               If this parameter is NULL_RTX the call is considered\n-               to be a sibling call.  */\n+\t       If this parameter is NULL_RTX the call is considered\n+\t       to be a sibling call.  */\n \n rtx_insn *\n s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n@@ -13284,9 +13284,9 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n   if (GET_CODE (addr_location) == SYMBOL_REF)\n     {\n       /* When calling a global routine in PIC mode, we must\n-         replace the symbol itself with the PLT stub.  */\n+\t replace the symbol itself with the PLT stub.  */\n       if (flag_pic && !SYMBOL_REF_LOCAL_P (addr_location))\n-        {\n+\t{\n \t  if (TARGET_64BIT || retaddr_reg != NULL_RTX)\n \t    {\n \t      addr_location = gen_rtx_UNSPEC (Pmode,\n@@ -13443,7 +13443,7 @@ s390_emit_tpf_eh_return (rtx target)\n   emit_move_insn (reg, target);\n   emit_move_insn (orig_ra, get_hard_reg_initial_val (Pmode, RETURN_REGNUM));\n   insn = s390_emit_call (s390_tpf_eh_return_symbol, NULL_RTX, reg,\n-                                     gen_rtx_REG (Pmode, RETURN_REGNUM));\n+\t\t\t\t     gen_rtx_REG (Pmode, RETURN_REGNUM));\n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), reg);\n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), orig_ra);\n \n@@ -15029,8 +15029,8 @@ s390_option_override_internal (struct gcc_options *opts,\n \n   /* Use the alternative scheduling-pressure algorithm by default.  */\n   maybe_set_param_value (PARAM_SCHED_PRESSURE_ALGORITHM, 2,\n-                         opts->x_param_values,\n-                         opts_set->x_param_values);\n+\t\t\t opts->x_param_values,\n+\t\t\t opts_set->x_param_values);\n \n   maybe_set_param_value (PARAM_MIN_VECT_LOOP_BOUND, 2,\n \t\t\t opts->x_param_values,\n@@ -15126,7 +15126,7 @@ s390_option_override (void)\n     {\n       /* Don't emit DWARF3/4 unless specifically selected.  The TPF\n \t debuggers do not yet support DWARF 3/4.  */\n-      if (!global_options_set.x_dwarf_strict) \n+      if (!global_options_set.x_dwarf_strict)\n \tdwarf_strict = 1;\n       if (!global_options_set.x_dwarf_version)\n \tdwarf_version = 2;"}, {"sha": "4fb32b8786cdd607a7a24c75d7f6fef5a411ca99", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8", "patch": "@@ -1,8 +1,8 @@\n /* Definitions of target machine for GNU compiler, for IBM S/390\n    Copyright (C) 1999-2018 Free Software Foundation, Inc.\n    Contributed by Hartmut Penner (hpenner@de.ibm.com) and\n-                  Ulrich Weigand (uweigand@de.ibm.com).\n-                  Andreas Krebbel (Andreas.Krebbel@de.ibm.com)\n+\t\t  Ulrich Weigand (uweigand@de.ibm.com).\n+\t\t  Andreas Krebbel (Andreas.Krebbel@de.ibm.com)\n \n This file is part of GCC.\n \n@@ -202,13 +202,13 @@ enum processor_flags\n \n #ifdef DEFAULT_TARGET_64BIT\n #define TARGET_DEFAULT     (MASK_64BIT | MASK_ZARCH | MASK_HARD_DFP\t\\\n-                            | MASK_OPT_HTM | MASK_OPT_VX)\n+\t\t\t    | MASK_OPT_HTM | MASK_OPT_VX)\n #else\n #define TARGET_DEFAULT             0\n #endif\n \n /* Support for configure-time defaults.  */\n-#define OPTION_DEFAULT_SPECS \t\t\t\t\t\\\n+#define OPTION_DEFAULT_SPECS\t\t\t\t\t\\\n   { \"mode\", \"%{!mesa:%{!mzarch:-m%(VALUE)}}\" },\t\t\t\\\n   { \"arch\", \"%{!march=*:-march=%(VALUE)}\" },\t\t\t\\\n   { \"tune\", \"%{!mtune=*:%{!march=*:-mtune=%(VALUE)}}\" }\n@@ -261,10 +261,10 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n \n /* For signbit, the BFP-DFP-difference makes no difference. */\n #define S390_TDC_SIGNBIT_SET (S390_TDC_NEGATIVE_ZERO \\\n-                          | S390_TDC_NEGATIVE_NORMALIZED_BFP_NUMBER \\\n-                          | S390_TDC_NEGATIVE_DENORMALIZED_BFP_NUMBER\\\n-                          | S390_TDC_NEGATIVE_INFINITY \\\n-                          | S390_TDC_NEGATIVE_QUIET_NAN \\\n+\t\t\t  | S390_TDC_NEGATIVE_NORMALIZED_BFP_NUMBER \\\n+\t\t\t  | S390_TDC_NEGATIVE_DENORMALIZED_BFP_NUMBER\\\n+\t\t\t  | S390_TDC_NEGATIVE_INFINITY \\\n+\t\t\t  | S390_TDC_NEGATIVE_QUIET_NAN \\\n \t\t\t  | S390_TDC_NEGATIVE_SIGNALING_NAN )\n \n #define S390_TDC_INFINITY (S390_TDC_POSITIVE_INFINITY \\\n@@ -418,59 +418,59 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n    All non-FP vector registers are call-clobbered v16-v31.  */\n \n #define FIXED_REGISTERS\t\t\t\t\\\n-{ 0, 0, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n+{ 0, 0, 0, 0,\t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n   0, 1, 1, 1,\t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n   1, 1, 1, 1,\t\t\t\t\t\\\n   1, 1,\t\t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n   0, 0, 0, 0 }\n \n #define CALL_USED_REGISTERS\t\t\t\\\n-{ 1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n+{ 1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 0, 0,\t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n   0, 1, 1, 1,\t\t\t\t\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1, 1,\t\t\t\t\t\\\n-  1, 1,\t\t\t\t\t        \\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n   1, 1, 1, 1,\t\t\t\t\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1,\t\t\t\t\t\t\\\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 1, 1,\t\t\t\t\t\\\n   1, 1, 1, 1 }\n \n #define CALL_REALLY_USED_REGISTERS\t\t\\\n-{ 1, 1, 1, 1, \t/* r0 - r15 */\t\t\t\\\n-  1, 1, 0, 0, \t\t\t\t\t\\\n-  0, 0, 0, 0, \t\t\t\t\t\\\n+{ 1, 1, 1, 1,\t/* r0 - r15 */\t\t\t\\\n+  1, 1, 0, 0,\t\t\t\t\t\\\n+  0, 0, 0, 0,\t\t\t\t\t\\\n   0, 0, 0, 0,\t\t\t\t\t\\\n-  1, 1, 1, 1, \t/* f0 (16) - f15 (31) */\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n-  1, 1, 1, 1, \t\t\t\t\t\\\n+  1, 1, 1, 1,\t/* f0 (16) - f15 (31) */\t\\\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 1, 1,\t\t\t\t\t\\\n+  1, 1, 1, 1,\t\t\t\t\t\\\n   1, 1, 1, 1,\t/* arg, cc, fp, ret addr */\t\\\n-  0, 0,\t\t/* a0 (36), a1 (37) */\t        \\\n-  1, 1, 1, 1, \t/* v16 (38) - v23 (45) */\t\\\n+  0, 0,\t\t/* a0 (36), a1 (37) */\t\t\\\n+  1, 1, 1, 1,\t/* v16 (38) - v23 (45) */\t\\\n   1, 1, 1, 1,\t\t\t\t\t\\\n-  1, 1, 1, 1, \t/* v24 (46) - v31 (53) */\t\\\n+  1, 1, 1, 1,\t/* v24 (46) - v31 (53) */\t\\\n   1, 1, 1, 1 }\n \n /* Preferred register allocation order.  */\n #define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n   {  1, 2, 3, 4, 5, 0, 12, 11, 10, 9, 8, 7, 6, 14, 13,\t\t\t\\\n      16, 17, 18, 19, 20, 21, 22, 23,\t\t\t\t\t\\\n      24, 25, 26, 27, 28, 29, 30, 31,\t\t\t\t\t\\\n-     38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, \t\\\n+     38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\t\\\n      15, 32, 33, 34, 35, 36, 37 }\n \n \n@@ -479,7 +479,7 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n \n /* Maximum number of registers to represent a value of mode MODE\n    in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)   \t\t\t\t\t\\\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n   s390_class_max_nregs ((CLASS), (MODE))\n \n /* We can reverse a CC mode safely if we know whether it comes from a\n@@ -499,7 +499,7 @@ extern const char *s390_host_detect_local_cpu (int argc, const char **argv);\n /* We use the following register classes:\n    GENERAL_REGS     All general purpose registers\n    ADDR_REGS        All general purpose registers except %r0\n-                    (These registers can be used in address generation)\n+\t\t    (These registers can be used in address generation)\n    FP_REGS          All floating point registers\n    CC_REGS          The condition code register\n    ACCESS_REGS      The access registers\n@@ -573,8 +573,8 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n /* Check whether REGNO is a hard register of the suitable class\n    or a pseudo register currently allocated to one such.  */\n #define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\t\\\n-    (((REGNO) < FIRST_PSEUDO_REGISTER \t\t\t\t\t\\\n-      && REGNO_REG_CLASS ((REGNO)) == ADDR_REGS) \t\t\t\\\n+    (((REGNO) < FIRST_PSEUDO_REGISTER\t\t\t\t\t\\\n+      && REGNO_REG_CLASS ((REGNO)) == ADDR_REGS)\t\t\t\\\n      || ADDR_REGNO_P (reg_renumber[REGNO]))\n #define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P (REGNO)\n \n@@ -745,7 +745,7 @@ CUMULATIVE_ARGS;\n \n /* Profiling.  */\n \n-#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\\\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\\\n   s390_function_profiler ((FILE), ((LABELNO)))\n \n #define PROFILE_BEFORE_PROLOGUE 1"}, {"sha": "9e9124461479e8e5b671b9b8fea4b368185b56c6", "filename": "gcc/config/s390/tpf.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8/gcc%2Fconfig%2Fs390%2Ftpf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8/gcc%2Fconfig%2Fs390%2Ftpf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ftpf.h?ref=0ff3dcd61a70884eb39c2ee9fb107e8ea14849c8", "patch": "@@ -1,8 +1,8 @@\n /* Definitions for target OS TPF for GNU compiler, for IBM S/390 hardware\n    Copyright (C) 2003-2018 Free Software Foundation, Inc.\n    Contributed by P.J. Darcy (darcypj@us.ibm.com),\n-                  Hartmut Penner (hpenner@de.ibm.com), and\n-                  Ulrich Weigand (uweigand@de.ibm.com).\n+\t\t  Hartmut Penner (hpenner@de.ibm.com), and\n+\t\t  Ulrich Weigand (uweigand@de.ibm.com).\n \n This file is part of GCC.\n \n@@ -44,7 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* TPF OS specific stack-pointer offset.  */\n #undef STACK_POINTER_OFFSET\n-#define STACK_POINTER_OFFSET \t\t448\n+#define STACK_POINTER_OFFSET\t\t448\n \n /* When building for TPF, set a generic default target that is 64 bits. Also\n    enable TPF profiling support and the standard backchain by default.  */\n@@ -105,10 +105,10 @@ along with GCC; see the file COPYING3.  If not see\n \n #undef LIB_SPEC\n #define LIB_SPEC \"-lCTIS -lCISO -lCLBM -lCTAL -lCFVS -lCTBX -lCTXO \\\n-                  -lCJ00 -lCTDF -lCOMX -lCOMS -lCTHD -lCTAD -lTPFSTUB\"\n+\t\t  -lCJ00 -lCTDF -lCOMX -lCOMS -lCTHD -lCTAD -lTPFSTUB\"\n \n #define ENTRY_SPEC \"%{mmain:-entry=_start} \\\n-                    %{!mmain:-entry=0}\"\n+\t\t    %{!mmain:-entry=0}\"\n \n /* All linking is done shared on TPF-OS.  */\n /* FIXME: When binutils patch for new emulation is committed"}]}