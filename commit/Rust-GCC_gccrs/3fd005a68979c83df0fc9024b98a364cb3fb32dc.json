{"sha": "3fd005a68979c83df0fc9024b98a364cb3fb32dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkMDA1YTY4OTc5YzgzZGYwZmM5MDI0Yjk4YTM2NGNiM2ZiMzJkYw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2013-01-02T20:29:28Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2013-01-02T20:29:28Z"}, "message": "re PR fortran/55818 (Reading a REAL from a file which doesn't end in a new line fails)\n\n2013-01-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/55818\n\t* gfortran.dg/eof_4.f90: New test.\n\nFrom-SVN: r194819", "tree": {"sha": "d49b92eb41c27f3d0eb9485398a3d343301b1e38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d49b92eb41c27f3d0eb9485398a3d343301b1e38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fd005a68979c83df0fc9024b98a364cb3fb32dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd005a68979c83df0fc9024b98a364cb3fb32dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd005a68979c83df0fc9024b98a364cb3fb32dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd005a68979c83df0fc9024b98a364cb3fb32dc/comments", "author": null, "committer": null, "parents": [{"sha": "6a7da30fd7edbf7f22c7fad73f5b8e1ee89839b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a7da30fd7edbf7f22c7fad73f5b8e1ee89839b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a7da30fd7edbf7f22c7fad73f5b8e1ee89839b3"}], "stats": {"total": 135, "additions": 135, "deletions": 0}, "files": [{"sha": "bb2103fd1c71cd4a2270b13f90f503a8929db0c1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd005a68979c83df0fc9024b98a364cb3fb32dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd005a68979c83df0fc9024b98a364cb3fb32dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3fd005a68979c83df0fc9024b98a364cb3fb32dc", "patch": "@@ -1,3 +1,8 @@\n+2013-01-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/55818\n+\t* gfortran.dg/eof_4.f90: New test.\n+\n 2013-01-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* lib/c-compat.exp (compat-use-alt-compiler): Remove"}, {"sha": "293c0fa39f6fca322eae2be78352264a640bd6c8", "filename": "gcc/testsuite/gfortran.dg/eof_4.f90", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd005a68979c83df0fc9024b98a364cb3fb32dc/gcc%2Ftestsuite%2Fgfortran.dg%2Feof_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd005a68979c83df0fc9024b98a364cb3fb32dc/gcc%2Ftestsuite%2Fgfortran.dg%2Feof_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Feof_4.f90?ref=3fd005a68979c83df0fc9024b98a364cb3fb32dc", "patch": "@@ -0,0 +1,130 @@\n+! { dg-do run }\n+! PR55818 Reading a REAL from a file which doesn't end in a new line fails\n+! Test case from PR reporter.\n+implicit none\n+integer :: stat\n+!integer :: var ! << works\n+real    :: var ! << fails\n+character(len=10)    :: cvar ! << fails\n+complex :: cval\n+logical :: lvar\n+\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"1\", new_line(\"\")\n+write(99) \"2\", new_line(\"\")\n+write(99) \"3\"\n+close(99)\n+\n+! Test character kind\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) cvar\n+if (stat /= 0 .or. cvar /= \"1\") call abort()\n+read (99,*, iostat=stat) cvar\n+if (stat /= 0 .or. cvar /= \"2\") call abort()\n+read (99,*, iostat=stat) cvar              ! << FAILS: stat /= 0\n+if (stat /= 0 .or. cvar /= \"3\") call abort() ! << aborts here\n+\n+! Test real kind\n+rewind(99)\n+read (99,*, iostat=stat) var\n+if (stat /= 0 .or. var /= 1.0) call abort()\n+read (99,*, iostat=stat) var\n+if (stat /= 0 .or. var /= 2.0) call abort()\n+read (99,*, iostat=stat) var ! << FAILS: stat /= 0\n+if (stat /= 0 .or. var /= 3.0) call abort()\n+close(99, status=\"delete\")\n+\n+! Test real kind with exponents\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"1.0e3\", new_line(\"\")\n+write(99) \"2.0e-03\", new_line(\"\")\n+write(99) \"3.0e2\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) var\n+if (stat /= 0) call abort()\n+read (99,*, iostat=stat) var\n+if (stat /= 0) call abort()\n+read (99,*) var ! << FAILS: stat /= 0\n+if (stat /= 0) call abort()\n+close(99, status=\"delete\")\n+\n+! Test logical kind\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"Tru\", new_line(\"\")\n+write(99) \"fal\", new_line(\"\")\n+write(99) \"t\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) lvar\n+if (stat /= 0 .or. (.not.lvar)) call abort()\n+read (99,*, iostat=stat) lvar\n+if (stat /= 0 .or. lvar) call abort()\n+read (99,*) lvar ! << FAILS: stat /= 0\n+if (stat /= 0 .or. (.not.lvar)) call abort()\n+close(99, status=\"delete\")\n+\n+! Test combinations of Inf and Nan\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"infinity\", new_line(\"\")\n+write(99) \"nan\", new_line(\"\")\n+write(99) \"infinity\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) var\n+if (stat /= 0) call abort()\n+read (99,*, iostat=stat) var\n+if (stat /= 0) call abort()\n+read (99,*) var          ! << FAILS: stat /= 0\n+if (stat /= 0) call abort ! << aborts here\n+close(99, status=\"delete\")\n+\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"infinity\", new_line(\"\")\n+write(99) \"inf\", new_line(\"\")\n+write(99) \"nan\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) var\n+if (stat /= 0) call abort()\n+read (99,*, iostat=stat) var\n+if (stat /= 0) call abort()\n+read (99,*) var          ! << FAILS: stat /= 0\n+if (stat /= 0) call abort ! << aborts here\n+close(99, status=\"delete\")\n+\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"infinity\", new_line(\"\")\n+write(99) \"nan\", new_line(\"\")\n+write(99) \"inf\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) var\n+if (stat /= 0) call abort()\n+read (99,*, iostat=stat) var\n+if (stat /= 0) call abort()\n+read (99,*) var          ! << FAILS: stat /= 0\n+if (stat /= 0) call abort ! << aborts here\n+close(99, status=\"delete\")\n+\n+! Test complex kind\n+open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n+write(99) \"(1,2)\", new_line(\"\")\n+write(99) \"(2,3)\", new_line(\"\")\n+write(99) \"(4,5)\"\n+close(99)\n+\n+open(99, file=\"test.dat\")\n+read (99,*, iostat=stat) cval\n+if (stat /= 0 .or. cval /= cmplx(1,2)) call abort()\n+read (99,*, iostat=stat) cval\n+if (stat /= 0 .or. cval /= cmplx(2,3)) call abort()\n+read (99,*, iostat=stat) cval      ! << FAILS: stat /= 0, value is okay\n+if (stat /= 0 .or. cval /= cmplx(4,5)) call abort()\n+close(99, status=\"delete\")\n+end"}]}