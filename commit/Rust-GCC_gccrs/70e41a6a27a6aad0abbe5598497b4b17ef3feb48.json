{"sha": "70e41a6a27a6aad0abbe5598497b4b17ef3feb48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBlNDFhNmEyN2E2YWFkMGFiYmU1NTk4NDk3YjRiMTdlZjNmZWI0OA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2011-06-22T09:52:55Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-06-22T09:52:55Z"}, "message": "In gcc/: 2011-06-21 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2011-06-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* attribs.c (register_attribute): Added assert to check that all\n\tattribute specs are registered with a name that is not empty and\n\tdoes not start with '_'.\n\t(decl_attributes): Avoid the lookup of the \"naked\" attribute spec\n\tif the function has no attributes.\n\t* tree.c (is_attribute_with_length_p): Removed.\n\t(is_attribute_p): Removed.\n\t(private_is_attribute_p): New.  \n\t(private_lookup_attribute): New.\n\t(lookup_attribute): Removed.\n\t(lookup_ident_attribute): New.\n\t(remove_attribute): Require the first argument to be in the form\n\t'text', not '__text__'.  Updated asserts.\n\t(merge_attributes): Use lookup_ident_attributes instead of\n\tlookup_attribute.\n\t(merge_dllimport_decl_attributes): Use remove_attribute.\n\t(attribute_list_contained): Likewise.\n\t(attribute_list_equal): Immediately return 1 if the arguments are\n\tidentical pointers.\n\t* tree.h (is_attribute_p): Made inline.  Return a 'bool', not an\n\t'int'.  Require the first argument to be in the form 'text', not\n\t'__text__'.  Require the second argument to be an identifier.\n\t(lookup_attribute): Made inline.  Require the first argument to be\n\tin the form 'text', not '__text__'.\n\t(private_is_attribute_p, private_lookup_attribute): New.\n\tUpdated comments.\n\nFrom-SVN: r175286", "tree": {"sha": "eb06d313c03be1290b9c63500235d5b1ba88492d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb06d313c03be1290b9c63500235d5b1ba88492d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70e41a6a27a6aad0abbe5598497b4b17ef3feb48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e41a6a27a6aad0abbe5598497b4b17ef3feb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70e41a6a27a6aad0abbe5598497b4b17ef3feb48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70e41a6a27a6aad0abbe5598497b4b17ef3feb48/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "637c11bd1659581b3bd137b8e479301cbd6ff2b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/637c11bd1659581b3bd137b8e479301cbd6ff2b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/637c11bd1659581b3bd137b8e479301cbd6ff2b3"}], "stats": {"total": 277, "additions": 185, "deletions": 92}, "files": [{"sha": "aa89cdda46e259ae92a076d8e8c6da47267ffee0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e41a6a27a6aad0abbe5598497b4b17ef3feb48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e41a6a27a6aad0abbe5598497b4b17ef3feb48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70e41a6a27a6aad0abbe5598497b4b17ef3feb48", "patch": "@@ -1,3 +1,32 @@\n+2011-06-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* attribs.c (register_attribute): Added assert to check that all\n+\tattribute specs are registered with a name that is not empty and\n+\tdoes not start with '_'.\n+\t(decl_attributes): Avoid the lookup of the \"naked\" attribute spec\n+\tif the function has no attributes.\n+\t* tree.c (is_attribute_with_length_p): Removed.\n+\t(is_attribute_p): Removed.\n+\t(private_is_attribute_p): New.  \n+\t(private_lookup_attribute): New.\n+\t(lookup_attribute): Removed.\n+\t(lookup_ident_attribute): New.\n+\t(remove_attribute): Require the first argument to be in the form\n+\t'text', not '__text__'.  Updated asserts.\n+\t(merge_attributes): Use lookup_ident_attributes instead of\n+\tlookup_attribute.\n+\t(merge_dllimport_decl_attributes): Use remove_attribute.\n+\t(attribute_list_contained): Likewise.\n+\t(attribute_list_equal): Immediately return 1 if the arguments are\n+\tidentical pointers.\n+\t* tree.h (is_attribute_p): Made inline.  Return a 'bool', not an\n+\t'int'.  Require the first argument to be in the form 'text', not\n+\t'__text__'.  Require the second argument to be an identifier.\n+\t(lookup_attribute): Made inline.  Require the first argument to be\n+\tin the form 'text', not '__text__'.\n+\t(private_is_attribute_p, private_lookup_attribute): New.\n+\tUpdated comments.\n+\t\n 2011-06-21  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* builtins.c: Add sync_ or SYNC__ to builtin names."}, {"sha": "98a6310294bba6b08e6a7714116dd75c42a13a43", "filename": "gcc/attribs.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e41a6a27a6aad0abbe5598497b4b17ef3feb48/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e41a6a27a6aad0abbe5598497b4b17ef3feb48/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=70e41a6a27a6aad0abbe5598497b4b17ef3feb48", "patch": "@@ -198,6 +198,11 @@ register_attribute (const struct attribute_spec *attr)\n \n   str.str = attr->name;\n   str.length = strlen (str.str);\n+\n+  /* Attribute names in the table must be in the form 'text' and not\n+     in the form '__text__'.  */\n+  gcc_assert (str.length > 0 && str.str[0] != '_');\n+\n   slot = htab_find_slot_with_hash (attribute_hash, &str,\n \t\t\t\t   substring_hash (str.str, str.length),\n \t\t\t\t   INSERT);\n@@ -279,6 +284,7 @@ decl_attributes (tree *node, tree attributes, int flags)\n   /* A \"naked\" function attribute implies \"noinline\" and \"noclone\" for\n      those targets that support it.  */\n   if (TREE_CODE (*node) == FUNCTION_DECL\n+      && attributes\n       && lookup_attribute_spec (get_identifier (\"naked\"))\n       && lookup_attribute (\"naked\", attributes) != NULL)\n     {"}, {"sha": "d984ecef331abadcae0213bbb9e4456eb40877f7", "filename": "gcc/tree.c", "status": "modified", "additions": 107, "deletions": 85, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e41a6a27a6aad0abbe5598497b4b17ef3feb48/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e41a6a27a6aad0abbe5598497b4b17ef3feb48/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=70e41a6a27a6aad0abbe5598497b4b17ef3feb48", "patch": "@@ -5218,82 +5218,119 @@ struct simple_ipa_opt_pass pass_ipa_free_lang_data =\n  }\n };\n \n-/* Return nonzero if IDENT is a valid name for attribute ATTR,\n-   or zero if not.\n-\n-   We try both `text' and `__text__', ATTR may be either one.  */\n-/* ??? It might be a reasonable simplification to require ATTR to be only\n-   `text'.  One might then also require attribute lists to be stored in\n-   their canonicalized form.  */\n-\n-static int\n-is_attribute_with_length_p (const char *attr, int attr_len, const_tree ident)\n+/* The backbone of is_attribute_p().  ATTR_LEN is the string length of\n+   ATTR_NAME.  Also used internally by remove_attribute().  */\n+bool\n+private_is_attribute_p (const char *attr_name, size_t attr_len, const_tree ident)\n {\n-  int ident_len;\n-  const char *p;\n+  size_t ident_len = IDENTIFIER_LENGTH (ident);\n \n-  if (TREE_CODE (ident) != IDENTIFIER_NODE)\n-    return 0;\n-\n-  p = IDENTIFIER_POINTER (ident);\n-  ident_len = IDENTIFIER_LENGTH (ident);\n-\n-  if (ident_len == attr_len\n-      && strcmp (attr, p) == 0)\n-    return 1;\n-\n-  /* If ATTR is `__text__', IDENT must be `text'; and vice versa.  */\n-  if (attr[0] == '_')\n+  if (ident_len == attr_len)\n     {\n-      gcc_assert (attr[1] == '_');\n-      gcc_assert (attr[attr_len - 2] == '_');\n-      gcc_assert (attr[attr_len - 1] == '_');\n-      if (ident_len == attr_len - 4\n-\t  && strncmp (attr + 2, p, attr_len - 4) == 0)\n-\treturn 1;\n+      if (strcmp (attr_name, IDENTIFIER_POINTER (ident)) == 0)\n+\treturn true;\n     }\n-  else\n+  else if (ident_len == attr_len + 4)\n     {\n-      if (ident_len == attr_len + 4\n-\t  && p[0] == '_' && p[1] == '_'\n+      /* There is the possibility that ATTR is 'text' and IDENT is\n+\t '__text__'.  */\n+      const char *p = IDENTIFIER_POINTER (ident);      \n+      if (p[0] == '_' && p[1] == '_'\n \t  && p[ident_len - 2] == '_' && p[ident_len - 1] == '_'\n-\t  && strncmp (attr, p + 2, attr_len) == 0)\n-\treturn 1;\n+\t  && strncmp (attr_name, p + 2, attr_len) == 0)\n+\treturn true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n-/* Return nonzero if IDENT is a valid name for attribute ATTR,\n-   or zero if not.\n+/* The backbone of lookup_attribute().  ATTR_LEN is the string length\n+   of ATTR_NAME, and LIST is not NULL_TREE.  */\n+tree\n+private_lookup_attribute (const char *attr_name, size_t attr_len, tree list)\n+{\n+  while (list)\n+    {\n+      size_t ident_len = IDENTIFIER_LENGTH (TREE_PURPOSE (list));\n \n-   We try both `text' and `__text__', ATTR may be either one.  */\n+      if (ident_len == attr_len)\n+\t{\n+\t  if (strcmp (attr_name, IDENTIFIER_POINTER (TREE_PURPOSE (list))) == 0)\n+\t    break;\n+\t}\n+      /* TODO: If we made sure that attributes were stored in the\n+\t canonical form without '__...__' (ie, as in 'text' as opposed\n+\t to '__text__') then we could avoid the following case.  */\n+      else if (ident_len == attr_len + 4)\n+\t{\n+\t  const char *p = IDENTIFIER_POINTER (TREE_PURPOSE (list));\n+\t  if (p[0] == '_' && p[1] == '_'\n+\t      && p[ident_len - 2] == '_' && p[ident_len - 1] == '_'\n+\t      && strncmp (attr_name, p + 2, attr_len) == 0)\n+\t    break;\n+\t}\n+      list = TREE_CHAIN (list);\n+    }\n \n-int\n-is_attribute_p (const char *attr, const_tree ident)\n-{\n-  return is_attribute_with_length_p (attr, strlen (attr), ident);\n+  return list;\n }\n \n-/* Given an attribute name and a list of attributes, return a pointer to the\n-   attribute's list element if the attribute is part of the list, or NULL_TREE\n-   if not found.  If the attribute appears more than once, this only\n-   returns the first occurrence; the TREE_CHAIN of the return value should\n-   be passed back in if further occurrences are wanted.  */\n+/* A variant of lookup_attribute() that can be used with an identifier\n+   as the first argument, and where the identifier can be either\n+   'text' or '__text__'.\n \n-tree\n-lookup_attribute (const char *attr_name, tree list)\n+   Given an attribute ATTR_IDENTIFIER, and a list of attributes LIST,\n+   return a pointer to the attribute's list element if the attribute\n+   is part of the list, or NULL_TREE if not found.  If the attribute\n+   appears more than once, this only returns the first occurrence; the\n+   TREE_CHAIN of the return value should be passed back in if further\n+   occurrences are wanted.  ATTR_IDENTIFIER must be an identifier but\n+   can be in the form 'text' or '__text__'.  */\n+static tree\n+lookup_ident_attribute (tree attr_identifier, tree list)\n {\n-  tree l;\n-  size_t attr_len = strlen (attr_name);\n+  gcc_checking_assert (TREE_CODE (attr_identifier) == IDENTIFIER_NODE);\n \n-  for (l = list; l; l = TREE_CHAIN (l))\n+  while (list)\n     {\n-      gcc_assert (TREE_CODE (TREE_PURPOSE (l)) == IDENTIFIER_NODE);\n-      if (is_attribute_with_length_p (attr_name, attr_len, TREE_PURPOSE (l)))\n-\treturn l;\n+      gcc_checking_assert (TREE_CODE (TREE_PURPOSE (list)) == IDENTIFIER_NODE);\n+\n+      /* Identifiers can be compared directly for equality.  */\n+      if (attr_identifier == TREE_PURPOSE (list))\n+\tbreak;\n+\n+      /* If they are not equal, they may still be one in the form\n+\t 'text' while the other one is in the form '__text__'.  TODO:\n+\t If we were storing attributes in normalized 'text' form, then\n+\t this could all go away and we could take full advantage of\n+\t the fact that we're comparing identifiers. :-)  */\n+      {\n+\tsize_t attr_len = IDENTIFIER_LENGTH (attr_identifier);\n+\tsize_t ident_len = IDENTIFIER_LENGTH (TREE_PURPOSE (list));\n+\n+\tif (ident_len == attr_len + 4)\n+\t  {\n+\t    const char *p = IDENTIFIER_POINTER (TREE_PURPOSE (list));\n+\t    const char *q = IDENTIFIER_POINTER (attr_identifier);\n+\t    if (p[0] == '_' && p[1] == '_'\n+\t\t&& p[ident_len - 2] == '_' && p[ident_len - 1] == '_'\n+\t\t&& strncmp (q, p + 2, attr_len) == 0)\n+\t      break;\n+\t  }\n+\telse if (ident_len + 4 == attr_len)\n+\t  {\n+\t    const char *p = IDENTIFIER_POINTER (TREE_PURPOSE (list));\n+\t    const char *q = IDENTIFIER_POINTER (attr_identifier);\n+\t    if (q[0] == '_' && q[1] == '_'\n+\t\t&& q[attr_len - 2] == '_' && q[attr_len - 1] == '_'\n+\t\t&& strncmp (q + 2, p, ident_len) == 0)\n+\t      break;\n+\t  }\n+      }\n+      list = TREE_CHAIN (list);\n     }\n-  return NULL_TREE;\n+\n+  return list;\n }\n \n /* Remove any instances of attribute ATTR_NAME in LIST and return the\n@@ -5305,11 +5342,14 @@ remove_attribute (const char *attr_name, tree list)\n   tree *p;\n   size_t attr_len = strlen (attr_name);\n \n+  gcc_checking_assert (attr_name[0] != '_');\n+\n   for (p = &list; *p; )\n     {\n       tree l = *p;\n-      gcc_assert (TREE_CODE (TREE_PURPOSE (l)) == IDENTIFIER_NODE);\n-      if (is_attribute_with_length_p (attr_name, attr_len, TREE_PURPOSE (l)))\n+      /* TODO: If we were storing attributes in normalized form, here\n+\t we could use a simple strcmp().  */\n+      if (private_is_attribute_p (attr_name, attr_len, TREE_PURPOSE (l)))\n \t*p = TREE_CHAIN (l);\n       else\n \tp = &TREE_CHAIN (l);\n@@ -5346,11 +5386,9 @@ merge_attributes (tree a1, tree a2)\n \t  for (; a2 != 0; a2 = TREE_CHAIN (a2))\n \t    {\n \t      tree a;\n-\t      for (a = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n-\t\t\t\t\t attributes);\n+\t      for (a = lookup_ident_attribute (TREE_PURPOSE (a2), attributes);\n \t\t   a != NULL_TREE && !attribute_value_equal (a, a2);\n-\t\t   a = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n-\t\t\t\t\t TREE_CHAIN (a)))\n+\t\t   a = lookup_ident_attribute (TREE_PURPOSE (a2), TREE_CHAIN (a)))\n \t\t;\n \t      if (a == NULL_TREE)\n \t\t{\n@@ -5449,24 +5487,7 @@ merge_dllimport_decl_attributes (tree old, tree new_tree)\n   a = merge_attributes (DECL_ATTRIBUTES (old), DECL_ATTRIBUTES (new_tree));\n \n   if (delete_dllimport_p)\n-    {\n-      tree prev, t;\n-      const size_t attr_len = strlen (\"dllimport\");\n-\n-      /* Scan the list for dllimport and delete it.  */\n-      for (prev = NULL_TREE, t = a; t; prev = t, t = TREE_CHAIN (t))\n-\t{\n-\t  if (is_attribute_with_length_p (\"dllimport\", attr_len,\n-\t\t\t\t\t  TREE_PURPOSE (t)))\n-\t    {\n-\t      if (prev == NULL_TREE)\n-\t\ta = TREE_CHAIN (a);\n-\t      else\n-\t\tTREE_CHAIN (prev) = TREE_CHAIN (t);\n-\t      break;\n-\t    }\n-\t}\n-    }\n+    a = remove_attribute (\"dllimport\", a);\n \n   return a;\n }\n@@ -6254,6 +6275,9 @@ attribute_hash_list (const_tree list, hashval_t hashcode)\n int\n attribute_list_equal (const_tree l1, const_tree l2)\n {\n+  if (l1 == l2)\n+    return 1;\n+\n   return attribute_list_contained (l1, l2)\n \t && attribute_list_contained (l2, l1);\n }\n@@ -6292,11 +6316,9 @@ attribute_list_contained (const_tree l1, const_tree l2)\n       /* This CONST_CAST is okay because lookup_attribute does not\n \t modify its argument and the return value is assigned to a\n \t const_tree.  */\n-      for (attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n-\t\t\t\t    CONST_CAST_TREE(l1));\n+      for (attr = lookup_ident_attribute (TREE_PURPOSE (t2), CONST_CAST_TREE(l1));\n \t   attr != NULL_TREE && !attribute_value_equal (t2, attr);\n-\t   attr = lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n-\t\t\t\t    TREE_CHAIN (attr)))\n+\t   attr = lookup_ident_attribute (TREE_PURPOSE (t2), TREE_CHAIN (attr)))\n \t;\n \n       if (attr == NULL_TREE)"}, {"sha": "3840fed8c04127f310699b80c10af863952578b8", "filename": "gcc/tree.h", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70e41a6a27a6aad0abbe5598497b4b17ef3feb48/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70e41a6a27a6aad0abbe5598497b4b17ef3feb48/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=70e41a6a27a6aad0abbe5598497b4b17ef3feb48", "patch": "@@ -4498,18 +4498,54 @@ enum attribute_flags\n extern tree merge_decl_attributes (tree, tree);\n extern tree merge_type_attributes (tree, tree);\n \n-/* Given a tree node and a string, return nonzero if the tree node is\n-   a valid attribute name for the string.  */\n+/* This function is a private implementation detail of lookup_attribute()\n+   and you should never call it directly.  */\n+extern tree private_lookup_attribute (const char *, size_t, tree);\n+\n+/* Given an attribute name ATTR_NAME and a list of attributes LIST,\n+   return a pointer to the attribute's list element if the attribute\n+   is part of the list, or NULL_TREE if not found.  If the attribute\n+   appears more than once, this only returns the first occurrence; the\n+   TREE_CHAIN of the return value should be passed back in if further\n+   occurrences are wanted.  ATTR_NAME must be in the form 'text' (not\n+   '__text__').  */\n \n-extern int is_attribute_p (const char *, const_tree);\n+static inline tree\n+lookup_attribute (const char *attr_name, tree list)\n+{\n+  gcc_checking_assert (attr_name[0] != '_');  \n+  /* In most cases, list is NULL_TREE.  */\n+  if (list == NULL_TREE)\n+    return NULL_TREE;\n+  else\n+    /* Do the strlen() before calling the out-of-line implementation.\n+       In most cases attr_name is a string constant, and the compiler\n+       will optimize the strlen() away.  */\n+    return private_lookup_attribute (attr_name, strlen (attr_name), list);\n+}\n \n-/* Given an attribute name and a list of attributes, return the list element\n-   of the attribute or NULL_TREE if not found.  */\n+/* This function is a private implementation detail of\n+   is_attribute_p() and you should never call it directly.  */\n+extern bool private_is_attribute_p (const char *, size_t, const_tree);\n \n-extern tree lookup_attribute (const char *, tree);\n+/* Given an identifier node IDENT and a string ATTR_NAME, return true\n+   if the identifier node is a valid attribute name for the string.\n+   ATTR_NAME must be in the form 'text' (not '__text__').  IDENT could\n+   be the identifier for 'text' or for '__text__'.  */\n+\n+static inline bool\n+is_attribute_p (const char *attr_name, const_tree ident)\n+{\n+  gcc_checking_assert (attr_name[0] != '_');\n+  /* Do the strlen() before calling the out-of-line implementation.\n+     In most cases attr_name is a string constant, and the compiler\n+     will optimize the strlen() away.  */\n+  return private_is_attribute_p (attr_name, strlen (attr_name), ident);\n+}\n \n /* Remove any instances of attribute ATTR_NAME in LIST and return the\n-   modified list.  */\n+   modified list.  ATTR_NAME must be in the form 'text' (not\n+   '__text__').  */\n \n extern tree remove_attribute (const char *, tree);\n "}]}