{"sha": "50cbc6057f519f2d0af68c95cf37e45d396009c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBjYmM2MDU3ZjUxOWYyZDBhZjY4Yzk1Y2YzN2U0NWQzOTYwMDljMg==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2003-01-14T13:31:11Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2003-01-14T13:31:11Z"}, "message": "[multiple changes]\n\n2003-01-14  Andrew Haley  <aph@redhat.com>\n\n        * decl.c (java_init_decl_processing): _Jv_NewMultiArray is a\n        varargs function -- correct.\n\n        * parse.y (patch_assignment): Copy the rhs of an assignment into a\n        temporary if the RHS is a reference.\n\n2003-01-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n\n        * Make-lang.in (keyword.h): Pass \"-L ANSI-C\" to gperf.\n        * keyword.h: Regenerated.\n\n        * All Files: Convert to ISO C style function definitions.\n\nFrom-SVN: r61281", "tree": {"sha": "adf750741436d54577476b5594ab5c705dbfa822", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adf750741436d54577476b5594ab5c705dbfa822"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50cbc6057f519f2d0af68c95cf37e45d396009c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50cbc6057f519f2d0af68c95cf37e45d396009c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50cbc6057f519f2d0af68c95cf37e45d396009c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50cbc6057f519f2d0af68c95cf37e45d396009c2/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d77fda24b78067384db548c55e5cb7b0bce0e44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d77fda24b78067384db548c55e5cb7b0bce0e44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d77fda24b78067384db548c55e5cb7b0bce0e44"}], "stats": {"total": 50, "additions": 48, "deletions": 2}, "files": [{"sha": "a7d983bd3adae512a809e84d5abe52a14fc7aaa6", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50cbc6057f519f2d0af68c95cf37e45d396009c2/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50cbc6057f519f2d0af68c95cf37e45d396009c2/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=50cbc6057f519f2d0af68c95cf37e45d396009c2", "patch": "@@ -1,3 +1,11 @@\n+2003-01-14  Andrew Haley  <aph@redhat.com>\n+\n+\t* decl.c (java_init_decl_processing): _Jv_NewMultiArray is a\n+\tvarargs function -- correct.\n+\n+\t* parse.y (patch_assignment): Copy the rhs of an assignment into a\n+\ttemporary if the RHS is a reference.\n+\n 2003-01-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Make-lang.in (keyword.h): Pass \"-L ANSI-C\" to gperf."}, {"sha": "c388539ae99addec79feca898e117b0ca5faea47", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50cbc6057f519f2d0af68c95cf37e45d396009c2/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50cbc6057f519f2d0af68c95cf37e45d396009c2/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=50cbc6057f519f2d0af68c95cf37e45d396009c2", "patch": "@@ -810,8 +810,9 @@ java_init_decl_processing (void)\n \t\t\t  0, NOT_BUILT_IN, NULL, NULL_TREE);\n   DECL_IS_MALLOC (soft_anewarray_node) = 1;\n \n-  t = tree_cons (NULL_TREE, ptr_type_node,\n-\t\t tree_cons (NULL_TREE, int_type_node, endlink));\n+  /* There is no endlink here because _Jv_NewMultiArray is a varargs\n+     function.  */\n+  t = tree_cons (NULL_TREE, ptr_type_node, int_type_node);\n   soft_multianewarray_node\n       = builtin_function (\"_Jv_NewMultiArray\",\n \t\t\t  build_function_type (ptr_type_node, t),"}, {"sha": "b618bb273ada603696bb47c17c2cd15435728ef9", "filename": "gcc/java/parse.y", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50cbc6057f519f2d0af68c95cf37e45d396009c2/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50cbc6057f519f2d0af68c95cf37e45d396009c2/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=50cbc6057f519f2d0af68c95cf37e45d396009c2", "patch": "@@ -12627,6 +12627,43 @@ patch_assignment (tree node, tree wfl_op1)\n       DECL_INITIAL (lvalue) = new_rhs;\n     }\n \n+  /* Copy the rhs if it's a reference.  */\n+  if (! flag_check_references && optimize > 0)\n+    {\n+      switch (TREE_CODE (new_rhs))\n+\t{\n+\tcase ARRAY_REF:\n+\tcase INDIRECT_REF:\n+\tcase COMPONENT_REF:\n+\t  /* Transform a = foo.bar \n+\t     into a = { int tmp; tmp = foo.bar; tmp; ).   \t     \n+\t     We need to ensure that if a read from memory fails\n+\t     because of a NullPointerException, a destination variable\n+\t     will remain unchanged.  An explicit temporary does what\n+\t     we need.  \n+\n+\t     If flag_check_references is set, this is unnecessary\n+\t     because we'll check each reference before doing any\n+\t     reads.  If optimize is not set the result will never be\n+\t     written to a stack slot that contains the LHS.  */\n+\t  {\n+\t    tree tmp = build_decl (VAR_DECL, get_identifier (\"<tmp>\"), \n+\t\t\t\t   TREE_TYPE (new_rhs));\n+\t    tree block = build (BLOCK, TREE_TYPE (new_rhs), NULL);\n+\t    tree assignment \n+\t      = build (MODIFY_EXPR, TREE_TYPE (new_rhs), tmp, fold (new_rhs));\n+\t    BLOCK_VARS (block) = tmp;\n+\t    BLOCK_EXPR_BODY (block) \n+\t      = build (COMPOUND_EXPR, TREE_TYPE (new_rhs), assignment, tmp);\n+\t    TREE_SIDE_EFFECTS (block) = 1;\n+\t    new_rhs = block;\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n   TREE_OPERAND (node, 0) = lvalue;\n   TREE_OPERAND (node, 1) = new_rhs;\n   TREE_TYPE (node) = lhs_type;"}]}