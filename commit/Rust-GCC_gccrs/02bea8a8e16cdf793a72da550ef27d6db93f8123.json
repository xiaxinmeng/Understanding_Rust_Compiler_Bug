{"sha": "02bea8a8e16cdf793a72da550ef27d6db93f8123", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJiZWE4YThlMTZjZGY3OTNhNzJkYTU1MGVmMjdkNmRiOTNmODEyMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-08T12:46:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-08T12:46:52Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1517", "tree": {"sha": "514213a42bcff5d310025e71e9b32b14a61d8d06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/514213a42bcff5d310025e71e9b32b14a61d8d06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02bea8a8e16cdf793a72da550ef27d6db93f8123", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02bea8a8e16cdf793a72da550ef27d6db93f8123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02bea8a8e16cdf793a72da550ef27d6db93f8123", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02bea8a8e16cdf793a72da550ef27d6db93f8123/comments", "author": null, "committer": null, "parents": [{"sha": "508f8149cc9ce0c99b755aff3ca4b7409405f42a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/508f8149cc9ce0c99b755aff3ca4b7409405f42a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/508f8149cc9ce0c99b755aff3ca4b7409405f42a"}], "stats": {"total": 23, "additions": 14, "deletions": 9}, "files": [{"sha": "b8f8bebd837b5a4e5fd1a72670aa3f741f173b3b", "filename": "gcc/integrate.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02bea8a8e16cdf793a72da550ef27d6db93f8123/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02bea8a8e16cdf793a72da550ef27d6db93f8123/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=02bea8a8e16cdf793a72da550ef27d6db93f8123", "patch": "@@ -305,7 +305,7 @@ initialize_for_inline (fndecl, min_labelno, max_labelno, max_reg, copy)\n      the original argument vector,\n      and the original DECL_INITIAL.  */\n \n-  return gen_inline_header_rtx (NULL, NULL, min_labelno, max_labelno,\n+  return gen_inline_header_rtx (NULL_RTX, NULL_RTX, min_labelno, max_labelno,\n \t\t\t\tmax_parm_reg, max_reg,\n \t\t\t\tcurrent_function_args_size,\n \t\t\t\tcurrent_function_pops_args,\n@@ -1155,7 +1155,7 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \t  arg_vals[i] = XEXP (stack_slot, 0);\n \t}\n       else if (GET_CODE (loc) != MEM)\n-\targ_vals[i] = expand_expr (arg, 0, mode, EXPAND_SUM);\n+\targ_vals[i] = expand_expr (arg, NULL_RTX, mode, EXPAND_SUM);\n       else\n \targ_vals[i] = 0;\n \n@@ -1320,7 +1320,7 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n \t  /* Compute the address in the area we reserved and store the\n \t     value there.  */\n \t  temp = copy_rtx_and_substitute (loc, map);\n-\t  subst_constants (&temp, 0, map);\n+\t  subst_constants (&temp, NULL_RTX, map);\n \t  apply_change_group ();\n \t  if (! memory_address_p (GET_MODE (temp), XEXP (temp, 0)))\n \t    temp = change_address (temp, VOIDmode, XEXP (temp, 0));\n@@ -1373,7 +1373,7 @@ expand_inline_function (fndecl, parms, target, ignore, type, structure_value_add\n       else\n \t{\n \t  temp = copy_rtx_and_substitute (loc, map);\n-\t  subst_constants (&temp, 0, map);\n+\t  subst_constants (&temp, NULL_RTX, map);\n \t  apply_change_group ();\n \t  emit_move_insn (temp, structure_value_addr);\n \t}\n@@ -1660,7 +1660,7 @@ integrate_parm_decls (args, map, arg_vector)\n \t debugging information contains the actual register, instead of the\n \t virtual register.   Do this by not passing an insn to\n \t subst_constants.  */\n-      subst_constants (&new_decl_rtl, 0, map);\n+      subst_constants (&new_decl_rtl, NULL_RTX, map);\n       apply_change_group ();\n       DECL_RTL (decl) = new_decl_rtl;\n     }\n@@ -1703,7 +1703,7 @@ integrate_decl_tree (let, level, map, functionbody)\n \t     debugging information contains the actual register, instead of the\n \t     virtual register.   Do this by not passing an insn to\n \t     subst_constants.  */\n-\t  subst_constants (&DECL_RTL (d), 0, map);\n+\t  subst_constants (&DECL_RTL (d), NULL_RTX, map);\n \t  apply_change_group ();\n \t}\n       else if (DECL_RTL (t))\n@@ -1799,7 +1799,7 @@ copy_rtx_and_substitute (orig, map)\n \t      rounded = CEIL_ROUND (size, BIGGEST_ALIGNMENT / BITS_PER_UNIT);\n \t      loc = plus_constant (loc, rounded);\n #endif\n-\t      map->reg_map[regno] = temp = force_operand (loc, 0);\n+\t      map->reg_map[regno] = temp = force_operand (loc, NULL_RTX);\n \t      map->const_equiv_map[REGNO (temp)] = loc;\n \t      map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n \n@@ -1818,7 +1818,7 @@ copy_rtx_and_substitute (orig, map)\n \t      start_sequence ();\n \t      loc = assign_stack_temp (BLKmode, size, 1);\n \t      loc = XEXP (loc, 0);\n-\t      map->reg_map[regno] = temp = force_operand (loc, 0);\n+\t      map->reg_map[regno] = temp = force_operand (loc, NULL_RTX);\n \t      map->const_equiv_map[REGNO (temp)] = loc;\n \t      map->const_age_map[REGNO (temp)] = CONST_AGE_PARM;\n \n@@ -2071,6 +2071,10 @@ copy_rtx_and_substitute (orig, map)\n \t    }\n \t  break;\n \n+\tcase 'w':\n+\t  XWINT (copy, i) = XWINT (orig, i);\n+\t  break;\n+\n \tcase 'i':\n \t  XINT (copy, i) = XINT (orig, i);\n \t  break;\n@@ -2222,7 +2226,7 @@ subst_constants (loc, insn, map)\n \t   see what is inside, try to form the new SUBREG and see if that is\n \t   valid.  We handle two cases: extracting a full word in an \n \t   integral mode and extracting the low part.  */\n-\tsubst_constants (&inner, 0, map);\n+\tsubst_constants (&inner, NULL_RTX, map);\n \n \tif (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT\n \t    && GET_MODE_SIZE (GET_MODE (x)) == UNITS_PER_WORD\n@@ -2333,6 +2337,7 @@ subst_constants (loc, insn, map)\n \tcase 'u':\n \tcase 'i':\n \tcase 's':\n+\tcase 'w':\n \t  break;\n \n \tcase 'E':"}]}