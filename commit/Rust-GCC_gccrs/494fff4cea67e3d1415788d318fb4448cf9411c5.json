{"sha": "494fff4cea67e3d1415788d318fb4448cf9411c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk0ZmZmNGNlYTY3ZTNkMTQxNTc4OGQzMThmYjQ0NDhjZjk0MTFjNQ==", "commit": {"author": {"name": "Stephen M. Webb", "email": "stephen@bregmasoft.com", "date": "2001-07-02T19:47:09Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-07-02T19:47:09Z"}, "message": "stl_construct.h (construct): Remove.\n\n\n2001-07-01  Stephen M. Webb <stephen@bregmasoft.com>\n\n\t* include/bits/stl_construct.h (construct): Remove.\n      \t(destroy): Remove.\n      \t(__destroy): Replaced by use of iterator_traits.\n\t* include/bits/stl_deque.h: replaced HP iterator functions with\n\titerator_traits.\n        (construct): changed to _Construct.\n\t(destroy): changed to _Destroy.\n\t* include/bits/stl_tempbuf.h: Same.\n\t* include/bits/stl_tree.h: Same.\n\t* include/bits/stl_vector.h: Same.\n\t* include/backward/iterator.h (construct): moved definition to here.\n\t(destroy): Same.\n\nFrom-SVN: r43701", "tree": {"sha": "cfa462159ccbfa2c8b097c906bdea4bd99fe4a52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfa462159ccbfa2c8b097c906bdea4bd99fe4a52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/494fff4cea67e3d1415788d318fb4448cf9411c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494fff4cea67e3d1415788d318fb4448cf9411c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/494fff4cea67e3d1415788d318fb4448cf9411c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494fff4cea67e3d1415788d318fb4448cf9411c5/comments", "author": null, "committer": null, "parents": [{"sha": "becbcf96daeab29991bfc9deb55373923dc20abe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/becbcf96daeab29991bfc9deb55373923dc20abe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/becbcf96daeab29991bfc9deb55373923dc20abe"}], "stats": {"total": 616, "additions": 345, "deletions": 271}, "files": [{"sha": "89203b6baf865652305b740c2264fec5317d8194", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=494fff4cea67e3d1415788d318fb4448cf9411c5", "patch": "@@ -1,3 +1,18 @@\n+2001-07-01  Stephen M. Webb <stephen@bregmasoft.com>\n+\n+\t* include/bits/stl_construct.h (construct): Remove.\n+      \t(destroy): Remove.\n+      \t(__destroy): Replaced by use of iterator_traits.\n+\t* include/bits/stl_deque.h: replaced HP iterator functions with\n+\titerator_traits.\n+        (construct): changed to _Construct.\n+\t(destroy): changed to _Destroy.\n+\t* include/bits/stl_tempbuf.h: Same.\n+\t* include/bits/stl_tree.h: Same.\n+\t* include/bits/stl_vector.h: Same.\n+\t* include/backward/iterator.h (construct): moved definition to here.\n+\t(destroy): Same.\n+\n 2001-06-29  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/bits/locale_facets.tcc (locale::combine): Clone _Impl."}, {"sha": "8cb2878d15e3a948e02e3cc30134dd02c1c70613", "filename": "libstdc++-v3/include/backward/iterator.h", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h?ref=494fff4cea67e3d1415788d318fb4448cf9411c5", "patch": "@@ -1,32 +1,3 @@\n-// Backward-compat support -*- C++ -*-\n-\n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n /*\n  *\n  * Copyright (c) 1994\n@@ -104,8 +75,26 @@ using std::istream_iterator;\n using std::ostream_iterator;\n \n // Names from stl_construct.h\n-using std::construct;\n-using std::destroy;\n+template<class _T1, class _T2>\n+  inline void\n+  construct(_T1* __p, const _T2& __value)\n+  { std::_Construct(__p, __value); }\n+\n+template<class _T1>\n+  inline void\n+  construct(_T1* __p)\n+  { std::_Construct(__p); }\n+\n+template <class _Tp>\n+  inline void\n+  destroy(_Tp* __pointer)\n+  { std::_Destroy(__pointer); }\n+  \n+template <class _ForwardIterator>\n+  inline void\n+  destroy(_ForwardIterator __first, _ForwardIterator __last)\n+  { std::_Destroy(__first, __last); }\n+}\n \n // Names from stl_raw_storage_iter.h\n using std::raw_storage_iterator;"}, {"sha": "385317d51fa3dffba785005468a758e4c06727c9", "filename": "libstdc++-v3/include/bits/stl_construct.h", "status": "modified", "additions": 73, "deletions": 77, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_construct.h?ref=494fff4cea67e3d1415788d318fb4448cf9411c5", "patch": "@@ -60,89 +60,85 @@\n #ifndef _CPP_BITS_STL_CONSTRUCT_H\n #define _CPP_BITS_STL_CONSTRUCT_H 1\n \n+#include <bits/type_traits.h>\n #include <new>\n \n namespace std\n {\n-\n-// construct and destroy.  These functions are not part of the C++ standard,\n-// and are provided for backward compatibility with the HP STL. We also\n-// provide internal names _Construct and _Destroy that can be used within\n-// the library, so that standard-conforming pieces don't have to rely on\n-// non-standard extensions.\n-\n-// Internal names\n-\n-template <class _T1, class _T2>\n-inline void _Construct(_T1* __p, const _T2& __value) {\n-new ((void*) __p) _T1(__value);\n-}\n+  /**\n+   * Invoke an allocated object's constructor with an initializer.\n+   *\n+   * This function is not part of the C++ standard but is used internally\n+   * within the library.\n+   */\n+  template <class _T1, class _T2>\n+    inline void\n+    _Construct(_T1* __p, const _T2& __value)\n+    { new (static_cast<void*>(__p)) _T1(__value); }\n   \n-template <class _T1>\n-inline void _Construct(_T1* __p) {\n-  new ((void*) __p) _T1();\n-}\n-\n-template <class _Tp>\n-inline void _Destroy(_Tp* __pointer) {\n-  __pointer->~_Tp();\n-}\n+  /**\n+   * Invoke an allocated object's constructor without an initializer.\n+   *\n+   * This function is not part of the C++ standard but is used internally\n+   * within the library.\n+   */\n+  template <class _T1>\n+    inline void\n+    _Construct(_T1* __p)\n+    { new (static_cast<void*>(__p)) _T1(); }\n+\n+  /**\n+   * Destroy a range of objects with nontrivial destructors.  \n+   *\n+   * This is a helper function used only by _Destroy().\n+   */\n+  template <class _ForwardIterator>\n+    inline void\n+    __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)\n+    { for ( ; __first != __last; ++__first) _Destroy(&*__first); }\n+\n+  /**\n+   * Destroy a range of objects with trivial destructors.  Since the destructors\n+   * are trivial, there's nothing to do and hopefully this function will be\n+   * entirely optimized away.\n+   *\n+   * This is a helper function used only by _Destroy().\n+   */\n+  template <class _ForwardIterator> \n+    inline void\n+    __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type)\n+    { }\n+\n+  /**\n+   * Destroy the object pointed to by a pointer type.\n+   *\n+   * This function is not part of the C++ standard but is used internally\n+   * within the library.\n+   */\n+  template <class _Tp>\n+    inline void\n+    _Destroy(_Tp* __pointer)\n+    { __pointer->~_Tp(); }\n   \n-template <class _ForwardIterator>\n-void\n-__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)\n-{\n-  for ( ; __first != __last; ++__first)\n-    destroy(&*__first);\n-}\n-\n-template <class _ForwardIterator> \n-inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) {}\n-\n-template <class _ForwardIterator, class _Tp>\n-inline void \n-__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)\n-{\n-  typedef typename __type_traits<_Tp>::has_trivial_destructor\n-          _Trivial_destructor;\n-  __destroy_aux(__first, __last, _Trivial_destructor());\n-}\n-\n-template <class _ForwardIterator>\n-inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {\n-  __destroy(__first, __last, __value_type(__first));\n-}\n-\n-inline void _Destroy(char*, char*) {}\n-inline void _Destroy(int*, int*) {}\n-inline void _Destroy(long*, long*) {}\n-inline void _Destroy(float*, float*) {}\n-inline void _Destroy(double*, double*) {}\n-inline void _Destroy(wchar_t*, wchar_t*) {}\n-\n-// --------------------------------------------------\n-// Old names from the HP STL.\n-\n-template <class _T1, class _T2>\n-inline void construct(_T1* __p, const _T2& __value) {\n-  _Construct(__p, __value);\n-}\n-\n-template <class _T1>\n-inline void construct(_T1* __p) {\n-  _Construct(__p);\n-}\n-\n-template <class _Tp>\n-inline void destroy(_Tp* __pointer) {\n-  _Destroy(__pointer);\n-}\n-\n-template <class _ForwardIterator>\n-inline void destroy(_ForwardIterator __first, _ForwardIterator __last) {\n-  _Destroy(__first, __last);\n-}\n-\n+  /**\n+   * Destroy a range of objects.  If the value_type of the object has\n+   * a trivial destructor, the compiler should optimize all of this\n+   * away, otherwise the objects' destructors must be invoked.\n+   *\n+   * This function is not part of the C++ standard but is used internally\n+   * within the library.\n+   */\n+  template <class _ForwardIterator>\n+    inline void\n+    _Destroy(_ForwardIterator __first, _ForwardIterator __last)\n+    {\n+      typedef typename iterator_traits<_ForwardIterator>::value_type\n+                       _Value_type;\n+      typedef typename __type_traits<_Value_type>::has_trivial_destructor\n+                       _Has_trivial_destructor;\n+\n+      __destroy_aux(__first, __last, _Has_trivial_destructor());\n+    }\n } // namespace std\n \n #endif /* _CPP_BITS_STL_CONSTRUCT_H */"}, {"sha": "a361756d1fd1d746dc8c2a411cd634a250fe6e4f", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 129, "deletions": 89, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=494fff4cea67e3d1415788d318fb4448cf9411c5", "patch": "@@ -479,30 +479,40 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n   deque(size_type __n, const value_type& __value,\n         const allocator_type& __a = allocator_type()) : _Base(__a, __n)\n     { _M_fill_initialize(__value); }\n-  explicit deque(size_type __n) : _Base(allocator_type(), __n)\n-    { _M_fill_initialize(value_type()); }\n+\n+  explicit\n+  deque(size_type __n)\n+  : _Base(allocator_type(), __n)\n+  { _M_fill_initialize(value_type()); }\n \n   // Check whether it's an integral type.  If so, it's not an iterator.\n-  template <class _InputIterator>\n-  deque(_InputIterator __first, _InputIterator __last,\n-        const allocator_type& __a = allocator_type()) : _Base(__a) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_initialize_dispatch(__first, __last, _Integral());\n-  }\n+  template<class _InputIterator>\n+    deque(_InputIterator __first, _InputIterator __last,\n+          const allocator_type& __a = allocator_type())\n+    : _Base(__a)\n+    {\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_initialize_dispatch(__first, __last, _Integral());\n+    }\n \n-  template <class _Integer>\n-  void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n-    _M_initialize_map(__n);\n-    _M_fill_initialize(__x);\n-  }\n+  template<class _Integer>\n+    void\n+    _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+    {\n+      _M_initialize_map(__n);\n+      _M_fill_initialize(__x);\n+    }\n \n-  template <class _InputIter>\n-  void _M_initialize_dispatch(_InputIter __first, _InputIter __last,\n-                              __false_type) {\n-    _M_range_initialize(__first, __last, __iterator_category(__first));\n-  }\n+  template<class _InputIter>\n+    void\n+    _M_initialize_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIter>::iterator_category _IterCategory;\n+      _M_range_initialize(__first, __last, _IterCategory());\n+    }\n \n-  ~deque() { destroy(_M_start, _M_finish); }\n+  ~deque()\n+  { _Destroy(_M_start, _M_finish); }\n \n   deque& operator= (const deque& __x) {\n     const size_type __len = size();\n@@ -542,27 +552,32 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n     }\n   }\n \n-  void assign(size_type __n, const _Tp& __val) {\n-    _M_fill_assign(__n, __val);\n-  }\n+  void\n+  assign(size_type __n, const _Tp& __val)\n+  { _M_fill_assign(__n, __val); }\n \n-  template <class _InputIterator>\n-  void assign(_InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_assign_dispatch(__first, __last, _Integral());\n-  }\n+  template<class _InputIterator>\n+    void\n+    assign(_InputIterator __first, _InputIterator __last)\n+    {\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_assign_dispatch(__first, __last, _Integral());\n+    }\n \n private:                        // helper functions for assign() \n \n-  template <class _Integer>\n-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n-    { _M_fill_assign((size_type) __n, (_Tp) __val); }\n-\n-  template <class _InputIterator>\n-  void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n-                          __false_type) {\n-    _M_assign_aux(__first, __last, __iterator_category(__first));\n-  }\n+  template<class _Integer>\n+    void\n+    _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+    { _M_fill_assign(static_cast<size_type>(__n), static_cast<_Tp>(__val)); }\n+\n+  template<class _InputIterator>\n+    void\n+    _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;\n+      _M_assign_aux(__first, __last, _IterCategory());\n+    }\n \n   template <class _InputIterator>\n   void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n@@ -585,55 +600,67 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n \n public:                         // push_* and pop_*\n   \n-  void push_back(const value_type& __t) {\n+  void\n+  push_back(const value_type& __t)\n+  {\n     if (_M_finish._M_cur != _M_finish._M_last - 1) {\n-      construct(_M_finish._M_cur, __t);\n+      _Construct(_M_finish._M_cur, __t);\n       ++_M_finish._M_cur;\n     }\n     else\n       _M_push_back_aux(__t);\n   }\n \n-  void push_back() {\n+  void\n+  push_back()\n+  {\n     if (_M_finish._M_cur != _M_finish._M_last - 1) {\n-      construct(_M_finish._M_cur);\n+      _Construct(_M_finish._M_cur);\n       ++_M_finish._M_cur;\n     }\n     else\n       _M_push_back_aux();\n   }\n \n-  void push_front(const value_type& __t) {\n+  void\n+  push_front(const value_type& __t) \n+  {\n     if (_M_start._M_cur != _M_start._M_first) {\n-      construct(_M_start._M_cur - 1, __t);\n+      _Construct(_M_start._M_cur - 1, __t);\n       --_M_start._M_cur;\n     }\n     else\n       _M_push_front_aux(__t);\n   }\n \n-  void push_front() {\n+  void\n+  push_front()\n+  {\n     if (_M_start._M_cur != _M_start._M_first) {\n-      construct(_M_start._M_cur - 1);\n+      _Construct(_M_start._M_cur - 1);\n       --_M_start._M_cur;\n     }\n     else\n       _M_push_front_aux();\n   }\n \n \n-  void pop_back() {\n+  void\n+  pop_back()\n+  {\n     if (_M_finish._M_cur != _M_finish._M_first) {\n       --_M_finish._M_cur;\n-      destroy(_M_finish._M_cur);\n+      _Destroy(_M_finish._M_cur);\n     }\n     else\n       _M_pop_back_aux();\n   }\n \n-  void pop_front() {\n+  void\n+  pop_front()\n+  {\n     if (_M_start._M_cur != _M_start._M_last - 1) {\n-      destroy(_M_start._M_cur);\n+      _Destroy(_M_start._M_cur);\n       ++_M_start._M_cur;\n     }\n     else \n@@ -642,7 +669,9 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n \n public:                         // Insert\n \n-  iterator insert(iterator position, const value_type& __x) {\n+  iterator\n+  insert(iterator position, const value_type& __x)\n+  {\n     if (position._M_cur == _M_start._M_cur) {\n       push_front(__x);\n       return _M_start;\n@@ -658,33 +687,40 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n     }\n   }\n \n-  iterator insert(iterator __position)\n-    { return insert(__position, value_type()); }\n+  iterator\n+  insert(iterator __position)\n+  { return insert(__position, value_type()); }\n \n-  void insert(iterator __pos, size_type __n, const value_type& __x)\n-    { _M_fill_insert(__pos, __n, __x); }\n+  void\n+  insert(iterator __pos, size_type __n, const value_type& __x)\n+  { _M_fill_insert(__pos, __n, __x); }\n \n-  void _M_fill_insert(iterator __pos, size_type __n, const value_type& __x); \n+  void\n+  _M_fill_insert(iterator __pos, size_type __n, const value_type& __x); \n \n   // Check whether it's an integral type.  If so, it's not an iterator.\n-  template <class _InputIterator>\n-  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_insert_dispatch(__pos, __first, __last, _Integral());\n-  }\n-\n-  template <class _Integer>\n-  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n-                          __true_type) {\n-    _M_fill_insert(__pos, (size_type) __n, (value_type) __x);\n-  }\n+  template<class _InputIterator>\n+    void\n+    insert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+    {\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_insert_dispatch(__pos, __first, __last, _Integral());\n+    }\n \n-  template <class _InputIterator>\n-  void _M_insert_dispatch(iterator __pos,\n-                          _InputIterator __first, _InputIterator __last,\n-                          __false_type) {\n-    insert(__pos, __first, __last, __iterator_category(__first));\n-  }\n+  template<class _Integer>\n+    void\n+    _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x, __true_type)\n+    { _M_fill_insert(__pos, static_cast<size_type>(__n), static_cast<value_type>(__x)); }\n+\n+  template<class _InputIterator>\n+    void\n+    _M_insert_dispatch(iterator __pos,\n+                       _InputIterator __first, _InputIterator __last,\n+                       __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;\n+      insert(__pos, __first, __last, _IterCategory());\n+    }\n \n   void resize(size_type __new_size, const value_type& __x) {\n     const size_type __len = size();\n@@ -847,14 +883,14 @@ deque<_Tp,_Alloc>::erase(iterator __first, iterator __last)\n     if (static_cast<size_type>(__elems_before) < (size() - __n) / 2) {\n       copy_backward(_M_start, __first, __last);\n       iterator __new_start = _M_start + __n;\n-      destroy(_M_start, __new_start);\n+      _Destroy(_M_start, __new_start);\n       _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n       _M_start = __new_start;\n     }\n     else {\n       copy(__last, _M_finish, __first);\n       iterator __new_finish = _M_finish - __n;\n-      destroy(__new_finish, _M_finish);\n+      _Destroy(__new_finish, _M_finish);\n       _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);\n       _M_finish = __new_finish;\n     }\n@@ -868,17 +904,17 @@ void deque<_Tp,_Alloc>::clear()\n   for (_Map_pointer __node = _M_start._M_node + 1;\n        __node < _M_finish._M_node;\n        ++__node) {\n-    destroy(*__node, *__node + _S_buffer_size());\n+    _Destroy(*__node, *__node + _S_buffer_size());\n     _M_deallocate_node(*__node);\n   }\n \n   if (_M_start._M_node != _M_finish._M_node) {\n-    destroy(_M_start._M_cur, _M_start._M_last);\n-    destroy(_M_finish._M_first, _M_finish._M_cur);\n+    _Destroy(_M_start._M_cur, _M_start._M_last);\n+    _Destroy(_M_finish._M_first, _M_finish._M_cur);\n     _M_deallocate_node(_M_finish._M_first);\n   }\n   else\n-    destroy(_M_start._M_cur, _M_finish._M_cur);\n+    _Destroy(_M_start._M_cur, _M_finish._M_cur);\n \n   _M_finish = _M_start;\n }\n@@ -893,7 +929,7 @@ void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value) {\n       uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n     uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);\n   }\n-  __STL_UNWIND(destroy(_M_start, iterator(*__cur, __cur)));\n+  __STL_UNWIND(_Destroy(_M_start, iterator(*__cur, __cur)));\n }\n \n template <class _Tp, class _Alloc> template <class _InputIterator>\n@@ -930,18 +966,19 @@ void deque<_Tp,_Alloc>::_M_range_initialize(_ForwardIterator __first,\n     }\n     uninitialized_copy(__first, __last, _M_finish._M_first);\n   }\n-  __STL_UNWIND(destroy(_M_start, iterator(*__cur_node, __cur_node)));\n+  __STL_UNWIND(_Destroy(_M_start, iterator(*__cur_node, __cur_node)));\n }\n \n // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_push_back_aux(const value_type& __t)\n+void\n+deque<_Tp,_Alloc>::_M_push_back_aux(const value_type& __t)\n {\n   value_type __t_copy = __t;\n   _M_reserve_map_at_back();\n   *(_M_finish._M_node + 1) = _M_allocate_node();\n   __STL_TRY {\n-    construct(_M_finish._M_cur, __t_copy);\n+    _Construct(_M_finish._M_cur, __t_copy);\n     _M_finish._M_set_node(_M_finish._M_node + 1);\n     _M_finish._M_cur = _M_finish._M_first;\n   }\n@@ -950,12 +987,13 @@ void deque<_Tp,_Alloc>::_M_push_back_aux(const value_type& __t)\n \n // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_push_back_aux()\n+void\n+deque<_Tp,_Alloc>::_M_push_back_aux()\n {\n   _M_reserve_map_at_back();\n   *(_M_finish._M_node + 1) = _M_allocate_node();\n   __STL_TRY {\n-    construct(_M_finish._M_cur);\n+    _Construct(_M_finish._M_cur);\n     _M_finish._M_set_node(_M_finish._M_node + 1);\n     _M_finish._M_cur = _M_finish._M_first;\n   }\n@@ -964,29 +1002,31 @@ void deque<_Tp,_Alloc>::_M_push_back_aux()\n \n // Called only if _M_start._M_cur == _M_start._M_first.\n template <class _Tp, class _Alloc>\n-void  deque<_Tp,_Alloc>::_M_push_front_aux(const value_type& __t)\n+void\n+deque<_Tp,_Alloc>::_M_push_front_aux(const value_type& __t)\n {\n   value_type __t_copy = __t;\n   _M_reserve_map_at_front();\n   *(_M_start._M_node - 1) = _M_allocate_node();\n   __STL_TRY {\n     _M_start._M_set_node(_M_start._M_node - 1);\n     _M_start._M_cur = _M_start._M_last - 1;\n-    construct(_M_start._M_cur, __t_copy);\n+    _Construct(_M_start._M_cur, __t_copy);\n   }\n   __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - 1))));\n } \n \n // Called only if _M_start._M_cur == _M_start._M_first.\n template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_push_front_aux()\n+void\n+deque<_Tp,_Alloc>::_M_push_front_aux()\n {\n   _M_reserve_map_at_front();\n   *(_M_start._M_node - 1) = _M_allocate_node();\n   __STL_TRY {\n     _M_start._M_set_node(_M_start._M_node - 1);\n     _M_start._M_cur = _M_start._M_last - 1;\n-    construct(_M_start._M_cur);\n+    _Construct(_M_start._M_cur);\n   }\n   __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - 1))));\n } \n@@ -998,7 +1038,7 @@ void deque<_Tp,_Alloc>::_M_pop_back_aux()\n   _M_deallocate_node(_M_finish._M_first);\n   _M_finish._M_set_node(_M_finish._M_node - 1);\n   _M_finish._M_cur = _M_finish._M_last - 1;\n-  destroy(_M_finish._M_cur);\n+  _Destroy(_M_finish._M_cur);\n }\n \n // Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that \n@@ -1008,7 +1048,7 @@ void deque<_Tp,_Alloc>::_M_pop_back_aux()\n template <class _Tp, class _Alloc>\n void deque<_Tp,_Alloc>::_M_pop_front_aux()\n {\n-  destroy(_M_start._M_cur);\n+  _Destroy(_M_start._M_cur);\n   _M_deallocate_node(_M_start._M_first);\n   _M_start._M_set_node(_M_start._M_node + 1);\n   _M_start._M_cur = _M_start._M_first;"}, {"sha": "f6c9a529142a142ae4c31c01f5abc66adcbc9dde", "filename": "libstdc++-v3/include/bits/stl_tempbuf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tempbuf.h?ref=494fff4cea67e3d1415788d318fb4448cf9411c5", "patch": "@@ -149,7 +149,7 @@ class _Temporary_buffer {\n   }\n  \n   ~_Temporary_buffer() {  \n-    destroy(_M_buffer, _M_buffer + _M_len);\n+    _Destroy(_M_buffer, _M_buffer + _M_len);\n     free(_M_buffer);\n   }\n "}, {"sha": "756bc954ddd45f8f6285fc63549007b39ceed511", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=494fff4cea67e3d1415788d318fb4448cf9411c5", "patch": "@@ -552,11 +552,12 @@ class _Rb_tree : protected _Rb_tree_base<_Value, _Alloc> {\n \n protected:\n \n-  _Link_type _M_create_node(const value_type& __x)\n+  _Link_type\n+  _M_create_node(const value_type& __x)\n   {\n     _Link_type __tmp = _M_get_node();\n     __STL_TRY {\n-      construct(&__tmp->_M_value_field, __x);\n+      _Construct(&__tmp->_M_value_field, __x);\n     }\n     __STL_UNWIND(_M_put_node(__tmp));\n     return __tmp;\n@@ -571,9 +572,10 @@ class _Rb_tree : protected _Rb_tree_base<_Value, _Alloc> {\n     return __tmp;\n   }\n \n-  void destroy_node(_Link_type __p)\n+  void\n+  destroy_node(_Link_type __p)\n   {\n-    destroy(&__p->_M_value_field);\n+    _Destroy(&__p->_M_value_field);\n     _M_put_node(__p);\n   }\n "}, {"sha": "50102743d9186a5ba00526772ffce2fc566be7ee", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 101, "deletions": 69, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/494fff4cea67e3d1415788d318fb4448cf9411c5/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=494fff4cea67e3d1415788d318fb4448cf9411c5", "patch": "@@ -236,33 +236,39 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n \n   // Check whether it's an integral type.  If so, it's not an iterator.\n   template <class _InputIterator>\n-  vector(_InputIterator __first, _InputIterator __last,\n-         const allocator_type& __a = allocator_type()) : _Base(__a) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_initialize_aux(__first, __last, _Integral());\n-  }\n+    vector(_InputIterator __first, _InputIterator __last,\n+           const allocator_type& __a = allocator_type())\n+\t: _Base(__a)\n+\t{\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_initialize_aux(__first, __last, _Integral());\n+    }\n \n   template <class _Integer>\n-  void _M_initialize_aux(_Integer __n, _Integer __value, __true_type) {\n-    _M_start = _M_allocate(__n);\n-    _M_end_of_storage = _M_start + __n; \n-    _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n-  }\n+    void _M_initialize_aux(_Integer __n, _Integer __value, __true_type)\n+\t{\n+      _M_start = _M_allocate(__n);\n+      _M_end_of_storage = _M_start + __n; \n+      _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n+    }\n \n-  template <class _InputIterator>\n-  void _M_initialize_aux(_InputIterator __first, _InputIterator __last,\n-                         __false_type) {\n-    _M_range_initialize(__first, __last, __iterator_category(__first));\n-  }\n+  template<class _InputIterator>\n+    void\n+\t_M_initialize_aux(_InputIterator __first, _InputIterator __last, __false_type)\n+\t{\n+\t  typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategoy;\n+\t  _M_range_initialize(__first, __last, _IterCategory());\n+\t}\n \n-  ~vector() { destroy(_M_start, _M_finish); }\n+  ~vector()\n+  { _Destroy(_M_start, _M_finish); }\n \n   vector<_Tp, _Alloc>& operator=(const vector<_Tp, _Alloc>& __x);\n   void reserve(size_type __n) {\n     if (capacity() < __n) {\n       const size_type __old_size = size();\n       pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);\n-      destroy(_M_start, _M_finish);\n+      _Destroy(_M_start, _M_finish);\n       _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n       _M_start = __tmp;\n       _M_finish = __tmp + __old_size;\n@@ -278,19 +284,26 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }\n   void _M_fill_assign(size_type __n, const _Tp& __val);\n \n-  template <class _InputIterator>\n-  void assign(_InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_assign_dispatch(__first, __last, _Integral());\n-  }\n+  template<class _InputIterator>\n+    void\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_assign_dispatch(__first, __last, _Integral());\n+    }\n \n-  template <class _Integer>\n-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+  template<class _Integer>\n+    void\n+\t_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n     { _M_fill_assign((size_type) __n, (_Tp) __val); }\n \n-  template <class _InputIter>\n-  void _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n-    { _M_assign_aux(__first, __last, __iterator_category(__first)); }\n+  template<class _InputIter>\n+    void\n+\t_M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)\n+    {\n+\t  typedef typename iterator_traits<_InputIter>::iterator_category _IterCategory;\n+\t  _M_assign_aux(__first, __last, _IterCategory());\n+\t}\n \n   template <class _InputIterator>\n   void _M_assign_aux(_InputIterator __first, _InputIterator __last,\n@@ -305,66 +318,85 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n   reference back() { return *(end() - 1); }\n   const_reference back() const { return *(end() - 1); }\n \n-  void push_back(const _Tp& __x) {\n+  void\n+  push_back(const _Tp& __x)\n+  {\n     if (_M_finish != _M_end_of_storage) {\n-      construct(_M_finish, __x);\n+      _Construct(_M_finish, __x);\n       ++_M_finish;\n     }\n     else\n       _M_insert_aux(end(), __x);\n   }\n-  void push_back() {\n+\n+  void\n+  push_back()\n+  {\n     if (_M_finish != _M_end_of_storage) {\n-      construct(_M_finish);\n+      _Construct(_M_finish);\n       ++_M_finish;\n     }\n     else\n       _M_insert_aux(end());\n   }\n-  void swap(vector<_Tp, _Alloc>& __x) {\n+\n+  void\n+  swap(vector<_Tp, _Alloc>& __x)\n+  {\n     std::swap(_M_start, __x._M_start);\n     std::swap(_M_finish, __x._M_finish);\n     std::swap(_M_end_of_storage, __x._M_end_of_storage);\n   }\n \n-  iterator insert(iterator __position, const _Tp& __x) {\n+  iterator\n+  insert(iterator __position, const _Tp& __x)\n+  {\n     size_type __n = __position - begin();\n     if (_M_finish != _M_end_of_storage && __position == end()) {\n-      construct(_M_finish, __x);\n+      _Construct(_M_finish, __x);\n       ++_M_finish;\n     }\n     else\n       _M_insert_aux(iterator(__position), __x);\n     return begin() + __n;\n   }\n-  iterator insert(iterator __position) {\n+\n+  iterator\n+  insert(iterator __position)\n+  {\n     size_type __n = __position - begin();\n     if (_M_finish != _M_end_of_storage && __position == end()) {\n-      construct(_M_finish);\n+      _Construct(_M_finish);\n       ++_M_finish;\n     }\n     else\n       _M_insert_aux(iterator(__position));\n     return begin() + __n;\n   }\n+\n   // Check whether it's an integral type.  If so, it's not an iterator.\n-  template <class _InputIterator>\n-  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {\n-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-    _M_insert_dispatch(__pos, __first, __last, _Integral());\n-  }\n+  template<class _InputIterator>\n+    void\n+\tinsert(iterator __pos, _InputIterator __first, _InputIterator __last)\n+\t{\n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      _M_insert_dispatch(__pos, __first, __last, _Integral());\n+    }\n \n   template <class _Integer>\n-  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,\n-                          __true_type)\n-    { _M_fill_insert(__pos, (size_type) __n, (_Tp) __val); }\n+    void\n+\t_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val, __true_type)\n+    { _M_fill_insert(__pos, static_cast<size_type>(__n), static_cast<_Tp>(__val)); }\n \n-  template <class _InputIterator>\n-  void _M_insert_dispatch(iterator __pos,\n-                          _InputIterator __first, _InputIterator __last,\n-                          __false_type) {\n-    _M_range_insert(__pos, __first, __last, __iterator_category(__first));\n-  }\n+  template<class _InputIterator>\n+    void\n+\t_M_insert_dispatch(iterator __pos,\n+                       _InputIterator __first, _InputIterator __last,\n+                       __false_type)\n+\t{\n+\t  typedef typename iterator_traits<_InputIterator>::iterator_category _IterCategory;\n+      _M_range_insert(__pos, __first, __last, _IterCategory());\n+    }\n \n   void insert (iterator __pos, size_type __n, const _Tp& __x)\n     { _M_fill_insert(__pos, __n, __x); }\n@@ -373,18 +405,18 @@ class vector : protected _Vector_base<_Tp, _Alloc>\n \n   void pop_back() {\n     --_M_finish;\n-    destroy(_M_finish);\n+    _Destroy(_M_finish);\n   }\n   iterator erase(iterator __position) {\n     if (__position + 1 != end())\n       copy(__position + 1, end(), __position);\n     --_M_finish;\n-    destroy(_M_finish);\n+    _Destroy(_M_finish);\n     return __position;\n   }\n   iterator erase(iterator __first, iterator __last) {\n     iterator __i(copy(__last, end(), __first));\n-    destroy(__i, end());\n+    _Destroy(__i, end());\n     _M_finish = _M_finish - (__last - __first);\n     return __first;\n   }\n@@ -497,14 +529,14 @@ vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)\n     const size_type __xlen = __x.size();\n     if (__xlen > capacity()) {\n       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());\n-      destroy(_M_start, _M_finish);\n+      _Destroy(_M_start, _M_finish);\n       _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n       _M_start = __tmp;\n       _M_end_of_storage = _M_start + __xlen;\n     }\n     else if (size() >= __xlen) {\n       iterator __i(copy(__x.begin(), __x.end(), begin()));\n-      destroy(__i, end());\n+      _Destroy(__i, end());\n     }\n     else {\n       copy(__x.begin(), __x.begin() + size(), _M_start);\n@@ -551,14 +583,14 @@ vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIter __first, _ForwardIter __last,\n \n   if (__len > capacity()) {\n     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n-    destroy(_M_start, _M_finish);\n+    _Destroy(_M_start, _M_finish);\n     _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n     _M_start = __tmp;\n     _M_end_of_storage = _M_finish = _M_start + __len;\n   }\n   else if (size() >= __len) {\n     iterator __new_finish(copy(__first, __last, _M_start));\n-    destroy(__new_finish, end());\n+    _Destroy(__new_finish, end());\n     _M_finish = __new_finish.base();\n   }\n   else {\n@@ -574,7 +606,7 @@ void\n vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)\n {\n   if (_M_finish != _M_end_of_storage) {\n-    construct(_M_finish, *(_M_finish - 1));\n+    _Construct(_M_finish, *(_M_finish - 1));\n     ++_M_finish;\n     _Tp __x_copy = __x;\n     copy_backward(__position, iterator(_M_finish - 2), iterator(_M_finish- 1));\n@@ -588,14 +620,14 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)\n     __STL_TRY {\n       __new_finish = uninitialized_copy(iterator(_M_start), __position,\n                                         __new_start);\n-      construct(__new_finish.base(), __x);\n+      _Construct(__new_finish.base(), __x);\n       ++__new_finish;\n       __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n                                         __new_finish);\n     }\n-    __STL_UNWIND((destroy(__new_start,__new_finish), \n+    __STL_UNWIND((_Destroy(__new_start,__new_finish), \n                   _M_deallocate(__new_start.base(),__len)));\n-    destroy(begin(), end());\n+    _Destroy(begin(), end());\n     _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n     _M_start = __new_start.base();\n     _M_finish = __new_finish.base();\n@@ -608,7 +640,7 @@ void\n vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)\n {\n   if (_M_finish != _M_end_of_storage) {\n-    construct(_M_finish, *(_M_finish - 1));\n+    _Construct(_M_finish, *(_M_finish - 1));\n     ++_M_finish;\n     copy_backward(__position, iterator(_M_finish - 2), \n \t\t  iterator(_M_finish - 1));\n@@ -622,14 +654,14 @@ vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)\n     __STL_TRY {\n       __new_finish = uninitialized_copy(iterator(_M_start), __position, \n \t\t\t\t\t__new_start);\n-      construct(__new_finish);\n+      _Construct(__new_finish);\n       ++__new_finish;\n       __new_finish = uninitialized_copy(__position, iterator(_M_finish), \n \t\t\t\t\t__new_finish);\n     }\n-    __STL_UNWIND((destroy(__new_start,__new_finish), \n+    __STL_UNWIND((_Destroy(__new_start,__new_finish), \n                   _M_deallocate(__new_start,__len)));\n-    destroy(begin(), end());\n+    _Destroy(begin(), end());\n     _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n     _M_start = __new_start;\n     _M_finish = __new_finish;\n@@ -671,9 +703,9 @@ void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n,\n         __new_finish\n           = uninitialized_copy(__position, end(), __new_finish);\n       }\n-      __STL_UNWIND((destroy(__new_start,__new_finish), \n+      __STL_UNWIND((_Destroy(__new_start,__new_finish), \n                     _M_deallocate(__new_start.base(),__len)));\n-      destroy(_M_start, _M_finish);\n+      _Destroy(_M_start, _M_finish);\n       _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n       _M_start = __new_start.base();\n       _M_finish = __new_finish.base();\n@@ -736,9 +768,9 @@ vector<_Tp, _Alloc>::_M_range_insert(iterator __position,\n         __new_finish\n           = uninitialized_copy(__position, iterator(_M_finish), __new_finish);\n       }\n-      __STL_UNWIND((destroy(__new_start,__new_finish), \n+      __STL_UNWIND((_Destroy(__new_start,__new_finish), \n                     _M_deallocate(__new_start.base(),__len)));\n-      destroy(_M_start, _M_finish);\n+      _Destroy(_M_start, _M_finish);\n       _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n       _M_start = __new_start.base();\n       _M_finish = __new_finish.base();"}]}