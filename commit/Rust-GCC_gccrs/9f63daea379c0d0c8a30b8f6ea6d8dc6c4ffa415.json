{"sha": "9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY2M2RhZWEzNzljMGQwYzhhMzBiOGY2ZWE2ZDhkYzZjNGZmYTQxNQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-07-28T23:44:56Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2004-07-28T23:44:56Z"}, "message": "c-common.c (c_common_unsafe_for_reeval): Delete.\n\n2004-07-28  Eric Christopher  <echristo@redhat.com>\n\n\t* c-common.c (c_common_unsafe_for_reeval): Delete.\n\t* c-lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete use.\n\t* c-pretty-print.c (pp_c_expression): Delete UNSAVE_EXPR case.\n\t* calls.c (fix_unsafe_tree): Delete.\n\t(expand_call): Delete code which used above.\n\t* dojump.c (do_jump): Delete UNSAVE_EXPR case.\n\t* expr.c (expand_expr_real_1): Ditto.\n\t* fold-const.c (non_lvalue): Ditto.\n\t* langhooks-def.h (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete.\n\t(lhd_unsafe_for_reeval): Ditto.\n\t* langhooks.c (lhd_unsafe_for_reeval): Ditto.\n\t* langhooks.h (unsafe_for_reeval): Ditto.\n\t(unsave_expr_now): Adjust comment.\n\t* tree-inline.c (copy_body_r): Delete UNSAVE_EXPR bits.\n\t(estimate_num_insns_1): Ditto.\n\t* tree-pretty-print.c (dump_generic_node): Ditto.\n\t* tree.c (expr_align): Ditto.\n\t(unsave_expr): Delete.\n\t(unsafe_for_reeval): Ditto.\n\t* tree.h (unsafe_for_reeval, unsave_expr): Ditto.\n\t* tree.def (UNSAVE_EXPR): Delete.\n\t* objc/objc-lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete.\n\n2004-07-28  Eric Christopher  <echristo@redhat.com>\n\n\t* cp-lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete.\n\n2004-07-28  Eric Christopher  <echristo@redhat.com>\n\n\t* lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete.\n\t(java_unsafe_for_reeval): Ditto.\n\nFrom-SVN: r85276", "tree": {"sha": "789a4a99989bb6a0b5b9248db954752ac63506bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/789a4a99989bb6a0b5b9248db954752ac63506bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/comments", "author": null, "committer": null, "parents": [{"sha": "61b60ed0833f0b703b0b411fb75363cbd145182b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61b60ed0833f0b703b0b411fb75363cbd145182b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61b60ed0833f0b703b0b411fb75363cbd145182b"}], "stats": {"total": 832, "additions": 285, "deletions": 547}, "files": [{"sha": "4bd3a7d1acc2f7449fb3096add13a41bdec616e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -1,3 +1,28 @@\n+2004-07-28  Eric Christopher  <echristo@redhat.com>\n+\n+\t* c-common.c (c_common_unsafe_for_reeval): Delete.\n+\t* c-lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete use.\n+\t* c-pretty-print.c (pp_c_expression): Delete UNSAVE_EXPR case.\n+\t* calls.c (fix_unsafe_tree): Delete.\n+\t(expand_call): Delete code which used above.\n+\t* dojump.c (do_jump): Delete UNSAVE_EXPR case.\n+\t* expr.c (expand_expr_real_1): Ditto.\n+\t* fold-const.c (non_lvalue): Ditto.\n+\t* langhooks-def.h (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete.\n+\t(lhd_unsafe_for_reeval): Ditto.\n+\t* langhooks.c (lhd_unsafe_for_reeval): Ditto.\n+\t* langhooks.h (unsafe_for_reeval): Ditto.\n+\t(unsave_expr_now): Adjust comment.\n+\t* tree-inline.c (copy_body_r): Delete UNSAVE_EXPR bits.\n+\t(estimate_num_insns_1): Ditto.\n+\t* tree-pretty-print.c (dump_generic_node): Ditto.\n+\t* tree.c (expr_align): Ditto.\n+\t(unsave_expr): Delete.\n+\t(unsafe_for_reeval): Ditto.\n+\t* tree.h (unsafe_for_reeval, unsave_expr): Ditto.\n+\t* tree.def (UNSAVE_EXPR): Delete.\n+\t* objc/objc-lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete.\n+\n 2004-07-28  Zack Weinberg  <zack@codesourcery.com>\n \n \t* tree.h (enum tls_model): Move ..."}, {"sha": "31b8dd91daf7987a698ac09b2c1b20497a0428a8", "filename": "gcc/c-common.c", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -304,7 +304,7 @@ int flag_zero_link = 0;\n    unit.  It will inform the ObjC runtime that class definition(s) herein\n    contained are to replace one(s) previously loaded.  */\n int flag_replace_objc_classes = 0;\n-   \n+\n /* C/ObjC language option variables.  */\n \n \n@@ -1474,7 +1474,7 @@ check_case_bounds (tree type, tree orig_type,\n       warning (\"case label value is less than minimum value for type\");\n       return false;\n     }\n- \n+\n   /* Case value is greater than maximum for type.  */\n   if (tree_int_cst_compare (case_low, max_value) > 0\n       && tree_int_cst_compare (case_high, max_value) > 0)\n@@ -1491,7 +1491,7 @@ check_case_bounds (tree type, tree orig_type,\n \t       \" less than minimum value for type\");\n       case_low = min_value;\n     }\n- \n+\n   /* Saturate upper case label value to maximum.  */\n   if (tree_int_cst_compare (case_low, max_value) <= 0\n       && tree_int_cst_compare (case_high, max_value) > 0)\n@@ -1610,7 +1610,7 @@ c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n \n   if (mode == TYPE_MODE (void_type_node))\n     return void_type_node;\n-  \n+\n   if (mode == TYPE_MODE (build_pointer_type (char_type_node)))\n     return unsignedp ? make_unsigned_type (mode) : make_signed_type (mode);\n \n@@ -2475,7 +2475,7 @@ c_build_qualified_type (tree type, int type_quals)\n {\n   if (type == error_mark_node)\n     return type;\n-  \n+\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     return build_array_type (c_build_qualified_type (TREE_TYPE (type),\n \t\t\t\t\t\t     type_quals),\n@@ -2501,7 +2501,7 @@ void\n c_apply_type_quals_to_decl (int type_quals, tree decl)\n {\n   tree type = TREE_TYPE (decl);\n-  \n+\n   if (type == error_mark_node)\n     return;\n \n@@ -2681,11 +2681,11 @@ c_common_get_alias_set (tree t)\n     {\n       tree t2;\n       /* Find bottom type under any nested POINTERs.  */\n-      for (t2 = TREE_TYPE (t); \n+      for (t2 = TREE_TYPE (t);\n      TREE_CODE (t2) == POINTER_TYPE;\n      t2 = TREE_TYPE (t2))\n   ;\n-      if (TREE_CODE (t2) != RECORD_TYPE \n+      if (TREE_CODE (t2) != RECORD_TYPE\n     && TREE_CODE (t2) != ENUMERAL_TYPE\n     && TREE_CODE (t2) != QUAL_UNION_TYPE\n     && TREE_CODE (t2) != UNION_TYPE)\n@@ -2694,7 +2694,7 @@ c_common_get_alias_set (tree t)\n   return -1;\n     }\n   /* These are the only cases that need special handling.  */\n-  if (TREE_CODE (t) != RECORD_TYPE \n+  if (TREE_CODE (t) != RECORD_TYPE\n       && TREE_CODE (t) != ENUMERAL_TYPE\n       && TREE_CODE (t) != QUAL_UNION_TYPE\n       && TREE_CODE (t) != UNION_TYPE\n@@ -2704,7 +2704,7 @@ c_common_get_alias_set (tree t)\n   if (TYPE_SIZE (t) == 0)\n     return -1;\n \n-  /* Look up t in hash table.  Only one of the compatible types within each \n+  /* Look up t in hash table.  Only one of the compatible types within each\n      alias set is recorded in the table.  */\n   if (!type_hash_table)\n     type_hash_table = htab_create (1021, c_type_hash,\n@@ -2756,7 +2756,7 @@ c_sizeof_or_alignof_type (tree type, enum tree_code op, int complain)\n   else if (!COMPLETE_TYPE_P (type))\n     {\n       if (complain)\n-\terror (\"invalid application of `%s' to incomplete type `%T' \", \n+\terror (\"invalid application of `%s' to incomplete type `%T' \",\n \t       op_name, type);\n       value = size_zero_node;\n     }\n@@ -3701,7 +3701,7 @@ match_case_to_enum (splay_tree_node node, void *data)\n void\n c_do_switch_warnings (splay_tree cases, tree switch_stmt)\n {\n-  splay_tree_node default_node;  \n+  splay_tree_node default_node;\n   location_t switch_location;\n   tree type;\n \n@@ -3730,7 +3730,7 @@ c_do_switch_warnings (splay_tree cases, tree switch_stmt)\n       tree chain;\n \n       /* The time complexity here is O(N*lg(N)) worst case, but for the\n-\t common case of monotonically increasing enumerators, it is \n+\t common case of monotonically increasing enumerators, it is\n \t O(N), since the nature of the splay tree will keep the next\n \t element adjacent to the root at all times.  */\n \n@@ -3742,7 +3742,7 @@ c_do_switch_warnings (splay_tree cases, tree switch_stmt)\n \t  if (node)\n \t    {\n \t      /* Mark the CASE_LOW part of the case entry as seen, so\n-\t\t that we save time later.  Choose TREE_ADDRESSABLE \n+\t\t that we save time later.  Choose TREE_ADDRESSABLE\n \t\t randomly as a bit that won't have been set to-date.  */\n \t      tree label = (tree) node->value;\n \t      TREE_ADDRESSABLE (label) = 1;\n@@ -3762,7 +3762,7 @@ c_do_switch_warnings (splay_tree cases, tree switch_stmt)\n \n \t The time complexity here is O(N**2) worst case, since we've\n \t not sorted the enumeration values.  However, in the absence\n-\t of case ranges this is O(N), since all single cases that \n+\t of case ranges this is O(N), since all single cases that\n \t corresponded to enumerations have been marked above.  */\n \n       splay_tree_foreach (cases, match_case_to_enum, type);\n@@ -3799,12 +3799,12 @@ finish_label_address_expr (tree label)\n }\n \n /* Hook used by expand_expr to expand language-specific tree codes.  */\n-/* The only things that should go here are bits needed to expand \n+/* The only things that should go here are bits needed to expand\n    constant initializers.  Everything else should be handled by the\n    gimplification routines.  */\n \n rtx\n-c_expand_expr (tree exp, rtx target, enum machine_mode tmode, \n+c_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n \t       int modifier /* Actually enum_modifier.  */,\n \t       rtx *alt_rtl)\n {\n@@ -3824,21 +3824,6 @@ c_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n     }\n }\n \n-/* Hook used by unsafe_for_reeval to handle language-specific tree codes.  */\n-\n-int\n-c_common_unsafe_for_reeval (tree exp)\n-{\n-  /* Statement expressions may not be reevaluated, likewise compound\n-     literals.  */\n-  if (TREE_CODE (exp) == STMT_EXPR\n-      || TREE_CODE (exp) == COMPOUND_LITERAL_EXPR)\n-    return 2;\n-\n-  /* Walk all other expressions.  */\n-  return -1;\n-}\n-\n /* Hook used by staticp to handle language-specific tree codes.  */\n \n bool\n@@ -3939,17 +3924,17 @@ handle_packed_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \t{\n \t  /* If it is the main variant, then pack the other variants\n    \t     too. This happens in,\n-\t     \n+\n \t     struct Foo {\n \t       struct Foo const *ptr; // creates a variant w/o packed flag\n \t       } __ attribute__((packed)); // packs it now.\n \t  */\n \t  tree probe;\n-\t  \n+\n \t  for (probe = *node; probe; probe = TYPE_NEXT_VARIANT (probe))\n \t    TYPE_PACKED (probe) = 1;\n \t}\n-      \n+\n     }\n   else if (TREE_CODE (*node) == FIELD_DECL)\n     DECL_PACKED (*node) = 1;\n@@ -4583,7 +4568,7 @@ handle_visibility_attribute (tree *node, tree name, tree args,\n       error (\"visibility arg not a string\");\n       return NULL_TREE;\n     }\n-  \n+\n   /*  If this is a type, set the visibility on the type decl.  */\n   if (TYPE_P (decl))\n     {\n@@ -4597,7 +4582,7 @@ handle_visibility_attribute (tree *node, tree name, tree args,\n   else if (strcmp (TREE_STRING_POINTER (id), \"internal\") == 0)\n     DECL_VISIBILITY (decl) = VISIBILITY_INTERNAL;\n   else if (strcmp (TREE_STRING_POINTER (id), \"hidden\") == 0)\n-    DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;  \n+    DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;\n   else if (strcmp (TREE_STRING_POINTER (id), \"protected\") == 0)\n     DECL_VISIBILITY (decl) = VISIBILITY_PROTECTED;\n   else\n@@ -5320,8 +5305,8 @@ c_parse_error (const char *msgid, enum cpp_ttype token, tree value)\n \n /* Walk a gimplified function and warn for functions whose return value is\n    ignored and attribute((warn_unused_result)) is set.  This is done before\n-   inlining, so we don't have to worry about that.  */  \n-   \n+   inlining, so we don't have to worry about that.  */\n+\n void\n c_warn_unused_result (tree *top_p)\n {"}, {"sha": "72d21010c29292ee35430b40e0e9ba97dda9831d", "filename": "gcc/c-lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -70,8 +70,6 @@ enum c_language_kind c_language = clk_c;\n #define LANG_HOOKS_TRUTHVALUE_CONVERSION c_objc_common_truthvalue_conversion\n #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL c_finish_incomplete_decl\n-#undef LANG_HOOKS_UNSAFE_FOR_REEVAL\n-#define LANG_HOOKS_UNSAFE_FOR_REEVAL c_common_unsafe_for_reeval\n #undef LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS\n #define LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS true\n #undef LANG_HOOKS_STATICP"}, {"sha": "3ddef7a23852d0d660d8d44b1aba9526b3ecffe5", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -225,7 +225,7 @@ void\n pp_c_type_qualifier_list (c_pretty_printer *pp, tree t)\n {\n    int qualifiers;\n-   \n+\n   if (!TYPE_P (t))\n     t = TREE_TYPE (t);\n \n@@ -481,7 +481,7 @@ pp_c_direct_abstract_declarator (c_pretty_printer *pp, tree t)\n     case POINTER_TYPE:\n       pp_abstract_declarator (pp, t);\n       break;\n-      \n+\n     case FUNCTION_TYPE:\n       pp_c_parameter_type_list (pp, t);\n       pp_direct_abstract_declarator (pp, TREE_TYPE (t));\n@@ -507,7 +507,7 @@ pp_c_direct_abstract_declarator (c_pretty_printer *pp, tree t)\n     case COMPLEX_TYPE:\n     case TYPE_DECL:\n       break;\n-      \n+\n     default:\n       pp_unsupported_tree (pp, t);\n       break;\n@@ -654,7 +654,7 @@ pp_c_declarator (c_pretty_printer *pp, tree t)\n       pp_direct_declarator (pp, t);\n     break;\n \n-    \n+\n     default:\n       pp_unsupported_tree (pp, t);\n       break;\n@@ -810,7 +810,7 @@ pp_c_character_constant (c_pretty_printer *pp, tree c)\n {\n   tree type = TREE_TYPE (c);\n   if (type == wchar_type_node)\n-    pp_character (pp, 'L'); \n+    pp_character (pp, 'L');\n   pp_quote (pp);\n   if (host_integerp (c, TYPE_UNSIGNED (type)))\n     pp_c_char (pp, tree_low_cst (c, TYPE_UNSIGNED (type)));\n@@ -893,12 +893,12 @@ pp_c_floating_constant (c_pretty_printer *pp, tree r)\n }\n \n /* Pretty-print a compound literal expression.  GNU extensions include\n-   vector constants.  */ \n+   vector constants.  */\n \n static void\n pp_c_compound_literal (c_pretty_printer *pp, tree e)\n {\n-  tree type = TREE_TYPE (e);  \n+  tree type = TREE_TYPE (e);\n   pp_c_type_cast (pp, type);\n \n   switch (TREE_CODE (type))\n@@ -939,8 +939,8 @@ pp_c_constant (c_pretty_printer *pp, tree e)\n           pp_c_character_constant (pp, e);\n         else if (TREE_CODE (type) == ENUMERAL_TYPE\n                  && pp_c_enumeration_constant (pp, e))\n-          ; \n-        else \n+          ;\n+        else\n           pp_c_integer_constant (pp, e);\n       }\n       break;\n@@ -964,8 +964,8 @@ pp_c_constant (c_pretty_printer *pp, tree e)\n void\n pp_c_identifier (c_pretty_printer *pp, const char *id)\n {\n-  pp_c_maybe_whitespace (pp);            \n-  pp_identifier (pp, id);  \n+  pp_c_maybe_whitespace (pp);\n+  pp_identifier (pp, id);\n   pp_base (pp)->padding = pp_before;\n }\n \n@@ -1401,7 +1401,7 @@ pp_c_call_argument_list (c_pretty_printer *pp, tree t)\n \n   unary-operator: one of\n       * &  + - ! ~\n-      \n+\n    GNU extensions.\n    unary-expression:\n       __alignof__ unary-expression\n@@ -1538,7 +1538,7 @@ pp_c_additive_expression (c_pretty_printer *pp, tree e)\n       else\n \tpp_minus (pp);\n       pp_c_whitespace (pp);\n-      pp_multiplicative_expression (pp, TREE_OPERAND (e, 1)); \n+      pp_multiplicative_expression (pp, TREE_OPERAND (e, 1));\n       break;\n \n     default:\n@@ -1756,7 +1756,7 @@ pp_c_conditional_expression (c_pretty_printer *pp, tree e)\n \n /* assignment-expression:\n       conditional-expression\n-      unary-expression assignment-operator  assignment-expression \n+      unary-expression assignment-operator  assignment-expression\n \n    assignment-expression: one of\n       =    *=    /=    %=    +=    -=    >>=    <<=    &=    ^=    |=  */\n@@ -1903,7 +1903,7 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n     case NE_EXPR:\n       pp_c_equality_expression (pp, e);\n       break;\n-      \n+\n     case COND_EXPR:\n       pp_conditional_expression (pp, e);\n       break;\n@@ -1929,14 +1929,13 @@ pp_c_expression (c_pretty_printer *pp, tree e)\n     case NOP_EXPR:\n     case NON_LVALUE_EXPR:\n     case SAVE_EXPR:\n-    case UNSAVE_EXPR:\n       pp_expression (pp, TREE_OPERAND (e, 0));\n       break;\n \n     case TARGET_EXPR:\n       pp_postfix_expression (pp, TREE_OPERAND (e, 1));\n       break;\n-      \n+\n     default:\n       pp_unsupported_tree (pp, e);\n       break;\n@@ -1965,7 +1964,7 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n \n   if (pp_needs_newline (pp))\n     pp_newline_and_indent (pp, 0);\n-  \n+\n   code = TREE_CODE (stmt);\n   switch (code)\n     {"}, {"sha": "e4c3d9f3037c832e676bb92a6fa7c9726db72d89", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -144,7 +144,6 @@ static int check_sibcall_argument_overlap (rtx, struct arg_data *, int);\n \n static int combine_pending_stack_adjustment_and_call (int, struct args_size *,\n \t\t\t\t\t\t      unsigned int);\n-static tree fix_unsafe_tree (tree);\n static bool shift_returned_value (tree, rtx *);\n \n #ifdef REG_PARM_STACK_SPACE\n@@ -1724,35 +1723,6 @@ check_sibcall_argument_overlap (rtx insn, struct arg_data *arg, int mark_stored_\n   return insn != NULL_RTX;\n }\n \n-static tree\n-fix_unsafe_tree (tree t)\n-{\n-  switch (unsafe_for_reeval (t))\n-    {\n-    case 0: /* Safe.  */\n-      break;\n-\n-    case 1: /* Mildly unsafe.  */\n-      t = unsave_expr (t);\n-      break;\n-\n-    case 2: /* Wildly unsafe.  */\n-      {\n-\ttree var = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t       TREE_TYPE (t));\n-\tSET_DECL_RTL (var,\n-\t\t      expand_expr (t, NULL_RTX, VOIDmode, EXPAND_NORMAL));\n-\tt = var;\n-      }\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-  return t;\n-}\n-\n-\n /* If function value *VALUE was returned at the most significant end of a\n    register, shift it towards the least significant end and convert it to\n    TYPE's mode.  Return true and update *VALUE if some action was needed.\n@@ -2270,48 +2240,6 @@ expand_call (tree exp, rtx target, int ignore)\n       || !lang_hooks.decls.ok_for_sibcall (fndecl))\n     try_tail_call = 0;\n \n-  if (try_tail_call)\n-    {\n-      int end, inc;\n-      actparms = NULL_TREE;\n-      /* Ok, we're going to give the tail call the old college try.\n-\t This means we're going to evaluate the function arguments\n-\t up to three times.  There are two degrees of badness we can\n-\t encounter, those that can be unsaved and those that can't.\n-\t (See unsafe_for_reeval commentary for details.)\n-\n-\t Generate a new argument list.  Pass safe arguments through\n-\t unchanged.  For the easy badness wrap them in UNSAVE_EXPRs.\n-\t For hard badness, evaluate them now and put their resulting\n-\t rtx in a temporary VAR_DECL.\n-\n-\t initialize_argument_information has ordered the array for the\n-\t order to be pushed, and we must remember this when reconstructing\n-\t the original argument order.  */\n-\n-      if (PUSH_ARGS_REVERSED)\n-\t{\n-\t  inc = 1;\n-\t  i = 0;\n-\t  end = num_actuals;\n-\t}\n-      else\n-\t{\n-\t  inc = -1;\n-\t  i = num_actuals - 1;\n-\t  end = -1;\n-\t}\n-\n-      for (; i != end; i += inc)\n-\t{\n-          args[i].tree_value = fix_unsafe_tree (args[i].tree_value);\n-\t}\n-      /* Do the same for the function address if it is an expression.  */\n-      if (!fndecl)\n-        addr = fix_unsafe_tree (addr);\n-    }\n-\n-\n   /* Ensure current function's preferred stack boundary is at least\n      what we need.  We don't have to increase alignment for recursive\n      functions.  */"}, {"sha": "da4dad7448b0e6010542b2b289bc5ad71e45f8ea", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -1,3 +1,7 @@\n+2004-07-28  Eric Christopher  <echristo@redhat.com>\n+\n+\t* cp-lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete.\n+\n 2004-07-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (struct tree_pair_s): New."}, {"sha": "00ba81cf8a54a5c3f0d78c5833a865179853109d", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -78,8 +78,6 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL cxx_dup_lang_specific_decl\n #undef LANG_HOOKS_TRUTHVALUE_CONVERSION\n #define LANG_HOOKS_TRUTHVALUE_CONVERSION c_common_truthvalue_conversion\n-#undef LANG_HOOKS_UNSAFE_FOR_REEVAL\n-#define LANG_HOOKS_UNSAFE_FOR_REEVAL c_common_unsafe_for_reeval\n #undef LANG_HOOKS_SET_DECL_ASSEMBLER_NAME\n #define LANG_HOOKS_SET_DECL_ASSEMBLER_NAME mangle_decl\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n@@ -225,7 +223,7 @@ cxx_get_alias_set (tree t)\n     /* The base variant of a type must be in the same alias set as the\n        complete type.  */\n     return get_alias_set (TYPE_CONTEXT (t));\n-  \n+\n   /* Punt on PMFs until we canonicalize functions properly.  */\n   if (TYPE_PTRMEMFUNC_P (t))\n     return 0;\n@@ -270,7 +268,7 @@ cp_expr_size (tree exp)\n       /* This would be wrong for a type with virtual bases, but they are\n \t caught by the abort above.  */\n       return (is_empty_class (TREE_TYPE (exp))\n-\t      ? size_zero_node \n+\t      ? size_zero_node\n \t      : CLASSTYPE_SIZE_UNIT (TREE_TYPE (exp)));\n     }\n   else"}, {"sha": "79070f0629afaf8badec9853164b49af9f3b84d0", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 113, "deletions": 114, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -59,7 +59,7 @@ static tree handle_init_priority_attribute (tree *, tree, tree, int, bool *);\n    nonzero, rvalues of class type are considered lvalues.  */\n \n static cp_lvalue_kind\n-lvalue_p_1 (tree ref, \n+lvalue_p_1 (tree ref,\n             int treat_class_rvalues_as_lvalues)\n {\n   cp_lvalue_kind op1_lvalue_kind = clk_none;\n@@ -78,7 +78,6 @@ lvalue_p_1 (tree ref,\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case SAVE_EXPR:\n-    case UNSAVE_EXPR:\n     case TRY_CATCH_EXPR:\n     case WITH_CLEANUP_EXPR:\n     case REALPART_EXPR:\n@@ -93,8 +92,8 @@ lvalue_p_1 (tree ref,\n \t expression does not depend on \"X\".  */\n       op1_lvalue_kind &= ~clk_packed;\n       /* Look at the member designator.  */\n-      if (!op1_lvalue_kind \n-\t  /* The \"field\" can be a FUNCTION_DECL or an OVERLOAD in some\t\n+      if (!op1_lvalue_kind\n+\t  /* The \"field\" can be a FUNCTION_DECL or an OVERLOAD in some\n   \t     situations.  */\n  \t  || TREE_CODE (TREE_OPERAND (ref, 1)) != FIELD_DECL)\n  \t;\n@@ -108,7 +107,7 @@ lvalue_p_1 (tree ref,\n \t}\n       else if (DECL_PACKED (TREE_OPERAND (ref, 1)))\n \top1_lvalue_kind |= clk_packed;\n-      \n+\n       return op1_lvalue_kind;\n \n     case STRING_CST:\n@@ -163,7 +162,7 @@ lvalue_p_1 (tree ref,\n     case FUNCTION_DECL:\n       /* All functions (except non-static-member functions) are\n \t lvalues.  */\n-      return (DECL_NONSTATIC_MEMBER_FUNCTION_P (ref) \n+      return (DECL_NONSTATIC_MEMBER_FUNCTION_P (ref)\n \t      ? clk_none : clk_ordinary);\n \n     case NON_DEPENDENT_EXPR:\n@@ -200,7 +199,7 @@ lvalue_p_1 (tree ref,\n cp_lvalue_kind\n real_lvalue_p (tree ref)\n {\n-  return lvalue_p_1 (ref, \n+  return lvalue_p_1 (ref,\n \t\t     /*treat_class_rvalues_as_lvalues=*/0);\n }\n \n@@ -210,7 +209,7 @@ real_lvalue_p (tree ref)\n int\n lvalue_p (tree ref)\n {\n-  return \n+  return\n     (lvalue_p_1 (ref, /*class rvalue ok*/ 1) != clk_none);\n }\n \n@@ -235,7 +234,7 @@ build_target_expr (tree decl, tree value)\n {\n   tree t;\n \n-  t = build (TARGET_EXPR, TREE_TYPE (decl), decl, value, \n+  t = build (TARGET_EXPR, TREE_TYPE (decl), decl, value,\n \t     cxx_maybe_build_cleanup (decl), NULL_TREE);\n   /* We always set TREE_SIDE_EFFECTS so that expand_expr does not\n      ignore the TARGET_EXPR.  If there really turn out to be no\n@@ -386,9 +385,9 @@ build_cplus_array_type_1 (tree elt_type, tree index_type)\n \n   /* Push these needs up so that initialization takes place\n      more easily.  */\n-  TYPE_NEEDS_CONSTRUCTING (t) \n+  TYPE_NEEDS_CONSTRUCTING (t)\n     = TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (elt_type));\n-  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) \n+  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n     = TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (elt_type));\n   return t;\n }\n@@ -413,7 +412,7 @@ build_cplus_array_type (tree elt_type, tree index_type)\n /* Make a variant of TYPE, qualified with the TYPE_QUALS.  Handles\n    arrays correctly.  In particular, if TYPE is an array of T's, and\n    TYPE_QUALS is non-empty, returns an array of qualified T's.\n-  \n+\n    FLAGS determines how to deal with illformed qualifications. If\n    tf_ignore_bad_quals is set, then bad qualifications are dropped\n    (this is permitted if TYPE was introduced via a typedef or template\n@@ -429,10 +428,10 @@ build_cplus_array_type (tree elt_type, tree index_type)\n    DR 295 queries this and the proposed resolution brings it into line\n    with qualifying a reference.  We implement the DR.  We also behave\n    in a similar manner for restricting non-pointer types.  */\n- \n+\n tree\n-cp_build_qualified_type_real (tree type, \n-                              int type_quals, \n+cp_build_qualified_type_real (tree type,\n+                              int type_quals,\n                               tsubst_flags_t complain)\n {\n   tree result;\n@@ -449,8 +448,8 @@ cp_build_qualified_type_real (tree type,\n       /* In C++, the qualification really applies to the array element\n \t type.  Obtain the appropriately qualified element type.  */\n       tree t;\n-      tree element_type \n-\t= cp_build_qualified_type_real (TREE_TYPE (type), \n+      tree element_type\n+\t= cp_build_qualified_type_real (TREE_TYPE (type),\n \t\t\t\t\ttype_quals,\n \t\t\t\t\tcomplain);\n \n@@ -459,11 +458,11 @@ cp_build_qualified_type_real (tree type,\n \n       /* See if we already have an identically qualified type.  */\n       for (t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))\n-\tif (cp_type_quals (t) == type_quals \n+\tif (cp_type_quals (t) == type_quals\n \t    && TYPE_NAME (t) == TYPE_NAME (type)\n \t    && TYPE_CONTEXT (t) == TYPE_CONTEXT (type))\n \t  break;\n-\t  \n+\n       if (!t)\n \t{\n \t  /* Make a new array type, just like the old one, but with the\n@@ -474,14 +473,14 @@ cp_build_qualified_type_real (tree type,\n \n       /* Even if we already had this variant, we update\n \t TYPE_NEEDS_CONSTRUCTING and TYPE_HAS_NONTRIVIAL_DESTRUCTOR in case\n-\t they changed since the variant was originally created.  \n-\t \n+\t they changed since the variant was originally created.\n+\n \t This seems hokey; if there is some way to use a previous\n \t variant *without* coming through here,\n \t TYPE_NEEDS_CONSTRUCTING will never be updated.  */\n-      TYPE_NEEDS_CONSTRUCTING (t) \n+      TYPE_NEEDS_CONSTRUCTING (t)\n \t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (element_type));\n-      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) \n+      TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n \t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TYPE_MAIN_VARIANT (element_type));\n       return t;\n     }\n@@ -497,7 +496,7 @@ cp_build_qualified_type_real (tree type,\n       t = cp_build_qualified_type_real (t, type_quals, complain);\n       return build_ptrmemfunc_type (t);\n     }\n-  \n+\n   /* A reference, function or method type shall not be cv qualified.\n      [dcl.ref], [dct.fct]  */\n   if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)\n@@ -508,7 +507,7 @@ cp_build_qualified_type_real (tree type,\n       bad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n       type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n     }\n-  \n+\n   /* A restrict-qualified type must be a pointer (or reference)\n      to object or incomplete type.  */\n   if ((type_quals & TYPE_QUAL_RESTRICT)\n@@ -533,21 +532,21 @@ cp_build_qualified_type_real (tree type,\n       if (bad_quals)\n  \t{\n  \t  tree bad_type = build_qualified_type (ptr_type_node, bad_quals);\n- \n+\n  \t  if (!(complain & tf_ignore_bad_quals))\n  \t    error (\"`%V' qualifiers cannot be applied to `%T'\",\n \t\t   bad_type, type);\n  \t}\n     }\n-  \n+\n   /* Retrieve (or create) the appropriately qualified variant.  */\n   result = build_qualified_type (type, type_quals);\n \n   /* If this was a pointer-to-method type, and we just made a copy,\n      then we need to unshare the record that holds the cached\n      pointer-to-member-function type, because these will be distinct\n      between the unqualified and qualified types.  */\n-  if (result != type \n+  if (result != type\n       && TREE_CODE (type) == POINTER_TYPE\n       && TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE)\n     TYPE_LANG_SPECIFIC (result) = NULL;\n@@ -596,46 +595,46 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n       if (new_binfo)\n \treturn new_binfo;\n     }\n-  \n+\n   new_binfo = make_tree_binfo (binfo ? BINFO_N_BASE_BINFOS (binfo) : 0);\n   BINFO_TYPE (new_binfo) = type;\n \n   /* Chain it into the inheritance graph.  */\n   TREE_CHAIN (*igo_prev) = new_binfo;\n   *igo_prev = new_binfo;\n-  \n+\n   if (binfo)\n     {\n       int ix;\n       tree base_binfo;\n-      \n+\n       my_friendly_assert (!BINFO_DEPENDENT_BASE_P (binfo), 20040712);\n       my_friendly_assert (type == BINFO_TYPE (binfo), 20040714);\n-  \n+\n       BINFO_OFFSET (new_binfo) = BINFO_OFFSET (binfo);\n       BINFO_VIRTUALS (new_binfo) = BINFO_VIRTUALS (binfo);\n-      \n+\n       /* We do not need to copy the accesses, as they are read only.  */\n       BINFO_BASE_ACCESSES (new_binfo) = BINFO_BASE_ACCESSES (binfo);\n-      \n+\n       /* Recursively copy base binfos of BINFO.  */\n       for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ix++)\n \t{\n \t  tree new_base_binfo;\n-\t  \n+\n \t  my_friendly_assert (!BINFO_DEPENDENT_BASE_P (base_binfo), 20040713);\n \t  new_base_binfo = copy_binfo (base_binfo, BINFO_TYPE (base_binfo),\n \t\t\t\t       t, igo_prev,\n \t\t\t\t       BINFO_VIRTUAL_P (base_binfo));\n-\t  \n+\n \t  if (!BINFO_INHERITANCE_CHAIN (new_base_binfo))\n \t    BINFO_INHERITANCE_CHAIN (new_base_binfo) = new_binfo;\n \t  BINFO_BASE_APPEND (new_binfo, new_base_binfo);\n \t}\n     }\n   else\n     BINFO_DEPENDENT_BASE_P (new_binfo) = 1;\n-  \n+\n   if (virt)\n     {\n       /* Push it onto the list after any virtual bases it contains\n@@ -644,7 +643,7 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n       BINFO_VIRTUAL_P (new_binfo) = 1;\n       BINFO_INHERITANCE_CHAIN (new_binfo) = TYPE_BINFO (t);\n     }\n-  \n+\n   return new_binfo;\n }\n \f\n@@ -659,7 +658,7 @@ copy_binfo (tree binfo, tree type, tree t, tree *igo_prev, int virt)\n \n static GTY ((param_is (union tree_node))) htab_t list_hash_table;\n \n-struct list_proxy \n+struct list_proxy\n {\n   tree purpose;\n   tree value;\n@@ -688,10 +687,10 @@ static hashval_t\n list_hash_pieces (tree purpose, tree value, tree chain)\n {\n   hashval_t hashcode = 0;\n-  \n+\n   if (chain)\n     hashcode += TREE_HASH (chain);\n-  \n+\n   if (value)\n     hashcode += TREE_HASH (value);\n   else\n@@ -709,8 +708,8 @@ static hashval_t\n list_hash (const void* p)\n {\n   tree t = (tree) p;\n-  return list_hash_pieces (TREE_PURPOSE (t), \n-\t\t\t   TREE_VALUE (t), \n+  return list_hash_pieces (TREE_PURPOSE (t),\n+\t\t\t   TREE_VALUE (t),\n \t\t\t   TREE_CHAIN (t));\n }\n \n@@ -828,13 +827,13 @@ is_overloaded_fn (tree x)\n \n int\n really_overloaded_fn (tree x)\n-{     \n+{\n   /* A baselink is also considered an overloaded function.  */\n   if (TREE_CODE (x) == OFFSET_REF)\n     x = TREE_OPERAND (x, 1);\n   if (BASELINK_P (x))\n     x = BASELINK_FUNCTIONS (x);\n-  \n+\n   return ((TREE_CODE (x) == OVERLOAD && OVL_CHAIN (x))\n \t  || DECL_FUNCTION_TEMPLATE_P (OVL_CURRENT (x))\n \t  || TREE_CODE (x) == TEMPLATE_ID_EXPR);\n@@ -869,7 +868,7 @@ ovl_cons (tree decl, tree chain)\n   TREE_TYPE (result) = unknown_type_node;\n   OVL_FUNCTION (result) = decl;\n   TREE_CHAIN (result) = chain;\n-  \n+\n   return result;\n }\n \n@@ -968,7 +967,7 @@ bind_template_template_parm (tree t, tree newargs)\n   TEMPLATE_TYPE_PARM_INDEX (t2) = copy_node (TEMPLATE_TYPE_PARM_INDEX (t));\n   TEMPLATE_PARM_DECL (TEMPLATE_TYPE_PARM_INDEX (t2)) = decl;\n   TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO (t2)\n-    = tree_cons (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t), \n+    = tree_cons (TEMPLATE_TEMPLATE_PARM_TEMPLATE_DECL (t),\n \t\t newargs, NULL_TREE);\n \n   TREE_TYPE (decl) = t2;\n@@ -1001,13 +1000,13 @@ count_trees (tree t)\n   int n_trees = 0;\n   walk_tree_without_duplicates (&t, count_trees_r, &n_trees);\n   return n_trees;\n-}  \n+}\n \n /* Called from verify_stmt_tree via walk_tree.  */\n \n static tree\n-verify_stmt_tree_r (tree* tp, \n-                    int* walk_subtrees ATTRIBUTE_UNUSED , \n+verify_stmt_tree_r (tree* tp,\n+                    int* walk_subtrees ATTRIBUTE_UNUSED ,\n                     void* data)\n {\n   tree t = *tp;\n@@ -1021,7 +1020,7 @@ verify_stmt_tree_r (tree* tp,\n      there is a circularity in the statement tree.  */\n   if (htab_find (*statements, t))\n     abort ();\n-  \n+\n   slot = htab_find_slot (*statements, t, INSERT);\n   *slot = t;\n \n@@ -1044,8 +1043,8 @@ verify_stmt_tree (tree t)\n /* Called from find_tree via walk_tree.  */\n \n static tree\n-find_tree_r (tree* tp, \n-             int* walk_subtrees ATTRIBUTE_UNUSED , \n+find_tree_r (tree* tp,\n+             int* walk_subtrees ATTRIBUTE_UNUSED ,\n              void* data)\n {\n   if (*tp == (tree) data)\n@@ -1111,8 +1110,8 @@ no_linkage_check (tree t)\n     case FUNCTION_TYPE:\n       {\n \ttree parm;\n-\tfor (parm = TYPE_ARG_TYPES (t); \n-\t     parm && parm != void_list_node; \n+\tfor (parm = TYPE_ARG_TYPES (t);\n+\t     parm && parm != void_list_node;\n \t     parm = TREE_CHAIN (parm))\n \t  {\n \t    r = no_linkage_check (TREE_VALUE (parm));\n@@ -1198,15 +1197,15 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)\n \t  u = build_cplus_new\n \t    (TREE_TYPE (t), break_out_target_exprs (TREE_OPERAND (t, 1)));\n \t}\n-      else \n+      else\n \t{\n \t  u = build_target_expr_with_type\n \t    (break_out_target_exprs (TREE_OPERAND (t, 1)), TREE_TYPE (t));\n \t}\n \n       /* Map the old variable to the new one.  */\n-      splay_tree_insert (target_remap, \n-\t\t\t (splay_tree_key) TREE_OPERAND (t, 0), \n+      splay_tree_insert (target_remap,\n+\t\t\t (splay_tree_key) TREE_OPERAND (t, 0),\n \t\t\t (splay_tree_value) TREE_OPERAND (u, 0));\n \n       /* Replace the old expression with the new version.  */\n@@ -1223,14 +1222,14 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)\n   /* Make a copy of this node.  */\n   return copy_tree_r (tp, walk_subtrees, NULL);\n }\n-  \n+\n /* Replace all remapped VAR_DECLs in T with their new equivalents.\n    DATA is really a splay-tree mapping old variables to new\n    variables.  */\n \n static tree\n-bot_replace (tree* t, \n-             int* walk_subtrees ATTRIBUTE_UNUSED , \n+bot_replace (tree* t,\n+             int* walk_subtrees ATTRIBUTE_UNUSED ,\n              void* data)\n {\n   splay_tree target_remap = ((splay_tree) data);\n@@ -1245,7 +1244,7 @@ bot_replace (tree* t,\n \n   return NULL_TREE;\n }\n-\t\n+\n /* When we parse a default argument expression, we may create\n    temporary variables via TARGET_EXPRs.  When we actually use the\n    default-argument expression, we make a copy of the expression, but\n@@ -1258,8 +1257,8 @@ break_out_target_exprs (tree t)\n   static splay_tree target_remap;\n \n   if (!target_remap_count++)\n-    target_remap = splay_tree_new (splay_tree_compare_pointers, \n-\t\t\t\t   /*splay_tree_delete_key_fn=*/NULL, \n+    target_remap = splay_tree_new (splay_tree_compare_pointers,\n+\t\t\t\t   /*splay_tree_delete_key_fn=*/NULL,\n \t\t\t\t   /*splay_tree_delete_value_fn=*/NULL);\n   walk_tree (&t, bot_manip, target_remap, NULL);\n   walk_tree (&t, bot_replace, target_remap, NULL);\n@@ -1356,7 +1355,7 @@ build_min_non_dep (enum tree_code code, tree non_dep, ...)\n     /* This should not be considered a COMPOUND_EXPR, because it\n        resolves to an overload.  */\n     COMPOUND_EXPR_OVERLOADED (t) = 1;\n-  \n+\n   va_end (p);\n   return t;\n }\n@@ -1373,10 +1372,10 @@ build_shared_int_cst (int i)\n {\n   if (i >= 256)\n     return build_int_2 (i, 0);\n-  \n+\n   if (!shared_int_cache[i])\n     shared_int_cache[i] = build_int_2 (i, 0);\n-  \n+\n   return shared_int_cache[i];\n }\n \n@@ -1389,7 +1388,7 @@ get_type_decl (tree t)\n     return TYPE_STUB_DECL (t);\n   if (t == error_mark_node)\n     return t;\n-  \n+\n   abort ();\n \n   /* Stop compiler from complaining control reaches end of non-void function.  */\n@@ -1440,7 +1439,7 @@ cp_tree_equal (tree t1, tree t2)\n   /* They might have become equal now.  */\n   if (t1 == t2)\n     return true;\n-  \n+\n   if (code1 != code2)\n     return false;\n \n@@ -1487,7 +1486,7 @@ cp_tree_equal (tree t1, tree t2)\n       {\n \ttree o1 = TREE_OPERAND (t1, 0);\n \ttree o2 = TREE_OPERAND (t2, 0);\n-\t\n+\n \t/* Special case: if either target is an unallocated VAR_DECL,\n \t   it means that it's going to be unified with whatever the\n \t   TARGET_EXPR is really supposed to initialize, so treat it\n@@ -1500,10 +1499,10 @@ cp_tree_equal (tree t1, tree t2)\n \t  /*Nop*/;\n \telse if (!cp_tree_equal (o1, o2))\n \t  return false;\n-      \n+\n \treturn cp_tree_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n       }\n-      \n+\n     case WITH_CLEANUP_EXPR:\n       if (!cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0)))\n \treturn false;\n@@ -1532,40 +1531,40 @@ cp_tree_equal (tree t1, tree t2)\n       {\n \tunsigned ix;\n \ttree vec1, vec2;\n-\t\n+\n \tif (!cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0)))\n \t  return false;\n \tvec1 = TREE_OPERAND (t1, 1);\n \tvec2 = TREE_OPERAND (t2, 1);\n \n \tif (!vec1 || !vec2)\n \t  return !vec1 && !vec2;\n-\t\n+\n \tif (TREE_VEC_LENGTH (vec1) != TREE_VEC_LENGTH (vec2))\n \t  return false;\n \n \tfor (ix = TREE_VEC_LENGTH (vec1); ix--;)\n \t  if (!cp_tree_equal (TREE_VEC_ELT (vec1, ix),\n \t\t\t      TREE_VEC_ELT (vec2, ix)))\n \t    return false;\n-\t\n+\n \treturn true;\n       }\n-      \n+\n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       {\n \ttree o1 = TREE_OPERAND (t1, 0);\n \ttree o2 = TREE_OPERAND (t2, 0);\n-\t\n+\n \tif (TREE_CODE (o1) != TREE_CODE (o2))\n \t  return false;\n \tif (TYPE_P (o1))\n \t  return same_type_p (o1, o2);\n \telse\n \t  return cp_tree_equal (o1, o2);\n       }\n-      \n+\n     case PTRMEM_CST:\n       /* Two pointer-to-members are the same if they point to the same\n \t field or function in the same class.  */\n@@ -1588,14 +1587,14 @@ cp_tree_equal (tree t1, tree t2)\n     case 's':\n       {\n \tint i;\n-\t\n+\n \tfor (i = 0; i < TREE_CODE_LENGTH (code1); ++i)\n \t  if (!cp_tree_equal (TREE_OPERAND (t1, i), TREE_OPERAND (t2, i)))\n \t    return false;\n-\t\n+\n \treturn true;\n       }\n-    \n+\n     case 't':\n       return same_type_p (t1, t2);\n     }\n@@ -1620,7 +1619,7 @@ tree\n error_type (tree arg)\n {\n   tree type = TREE_TYPE (arg);\n-  \n+\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     ;\n   else if (TREE_CODE (type) == ERROR_MARK)\n@@ -1673,7 +1672,7 @@ maybe_dummy_object (tree type, tree* binfop)\n {\n   tree decl, context;\n   tree binfo;\n-  \n+\n   if (current_class_type\n       && (binfo = lookup_base (current_class_type, type,\n \t\t\t       ba_ignore | ba_quiet, NULL)))\n@@ -1687,7 +1686,7 @@ maybe_dummy_object (tree type, tree* binfop)\n \n   if (binfop)\n     *binfop = binfo;\n-  \n+\n   if (current_class_ref && context == current_class_type\n       /* Kludge: Make sure that current_class_type is actually\n          correct.  It might not be if we're in the middle of\n@@ -1776,10 +1775,10 @@ const struct attribute_spec cxx_attribute_table[] =\n /* Handle a \"java_interface\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-handle_java_interface_attribute (tree* node, \n-                                 tree name, \n-                                 tree args ATTRIBUTE_UNUSED , \n-                                 int flags, \n+handle_java_interface_attribute (tree* node,\n+                                 tree name,\n+                                 tree args ATTRIBUTE_UNUSED ,\n+                                 int flags,\n                                  bool* no_add_attrs)\n {\n   if (DECL_P (*node)\n@@ -1801,10 +1800,10 @@ handle_java_interface_attribute (tree* node,\n /* Handle a \"com_interface\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-handle_com_interface_attribute (tree* node, \n-                                tree name, \n-                                tree args ATTRIBUTE_UNUSED , \n-                                int flags ATTRIBUTE_UNUSED , \n+handle_com_interface_attribute (tree* node,\n+                                tree name,\n+                                tree args ATTRIBUTE_UNUSED ,\n+                                int flags ATTRIBUTE_UNUSED ,\n                                 bool* no_add_attrs)\n {\n   static int warned;\n@@ -1830,10 +1829,10 @@ handle_com_interface_attribute (tree* node,\n /* Handle an \"init_priority\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-handle_init_priority_attribute (tree* node, \n-                                tree name, \n-                                tree args, \n-                                int flags ATTRIBUTE_UNUSED , \n+handle_init_priority_attribute (tree* node,\n+                                tree name,\n+                                tree args,\n+                                int flags ATTRIBUTE_UNUSED ,\n                                 bool* no_add_attrs)\n {\n   tree initp_expr = TREE_VALUE (args);\n@@ -1842,7 +1841,7 @@ handle_init_priority_attribute (tree* node,\n   int pri;\n \n   STRIP_NOPS (initp_expr);\n-\t  \n+\n   if (!initp_expr || TREE_CODE (initp_expr) != INTEGER_CST)\n     {\n       error (\"requested init_priority is not an integer constant\");\n@@ -1851,7 +1850,7 @@ handle_init_priority_attribute (tree* node,\n     }\n \n   pri = TREE_INT_CST_LOW (initp_expr);\n-\t\n+\n   type = strip_array_types (type);\n \n   if (decl == NULL_TREE\n@@ -1864,7 +1863,7 @@ handle_init_priority_attribute (tree* node,\n \t first time control passes through that\n \t function. This is not precise enough to pin down an\n \t init_priority value, so don't allow it.  */\n-      || current_function_decl) \n+      || current_function_decl)\n     {\n       error (\"can only use `%E' attribute on file-scope definitions \"\n              \"of objects of class type\", name);\n@@ -1883,7 +1882,7 @@ handle_init_priority_attribute (tree* node,\n      language and runtime support implementations.*/\n   if (pri <= MAX_RESERVED_INIT_PRIORITY)\n     {\n-      warning \n+      warning\n \t(\"requested init_priority is reserved for internal use\");\n     }\n \n@@ -1933,7 +1932,7 @@ cp_build_type_attribute_variant (tree type, tree attributes)\n \n   new_type = build_type_attribute_variant (type, attributes);\n   if (TREE_CODE (new_type) == FUNCTION_TYPE\n-      && (TYPE_RAISES_EXCEPTIONS (new_type) \n+      && (TYPE_RAISES_EXCEPTIONS (new_type)\n \t  != TYPE_RAISES_EXCEPTIONS (type)))\n     new_type = build_exception_variant (new_type,\n \t\t\t\t\tTYPE_RAISES_EXCEPTIONS (type));\n@@ -1943,14 +1942,14 @@ cp_build_type_attribute_variant (tree type, tree attributes)\n /* Apply FUNC to all language-specific sub-trees of TP in a pre-order\n    traversal.  Called from walk_tree.  */\n \n-tree \n+tree\n cp_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func,\n \t\t  void *data, void *htab)\n {\n   enum tree_code code = TREE_CODE (*tp);\n   location_t save_locus;\n   tree result;\n-  \n+\n #define WALK_SUBTREE(NODE)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n@@ -2037,7 +2036,7 @@ cp_cannot_inline_tree_fn (tree* fnp)\n     {\n       /* Don't instantiate functions that are not going to be\n \t inlined.  */\n-      if (!DECL_INLINE (DECL_TEMPLATE_RESULT \n+      if (!DECL_INLINE (DECL_TEMPLATE_RESULT\n \t\t\t(template_for_substitution (fn))))\n \treturn 1;\n \n@@ -2121,7 +2120,7 @@ cp_auto_var_in_fn_p (tree var, tree fn)\n /* FN body has been duplicated.  Update language specific fields.  */\n \n void\n-cp_update_decl_after_saving (tree fn, \n+cp_update_decl_after_saving (tree fn,\n                              void* decl_map_)\n {\n   splay_tree decl_map = (splay_tree)decl_map_;\n@@ -2145,15 +2144,15 @@ init_tree (void)\n    pointed to by DATA (which is really a `splay_tree *').  */\n \n static tree\n-mark_local_for_remap_r (tree* tp, \n-                        int* walk_subtrees ATTRIBUTE_UNUSED , \n+mark_local_for_remap_r (tree* tp,\n+                        int* walk_subtrees ATTRIBUTE_UNUSED ,\n                         void* data)\n {\n   tree t = *tp;\n   splay_tree st = (splay_tree) data;\n   tree decl;\n \n-  \n+\n   if (TREE_CODE (t) == DECL_EXPR\n       && nonstatic_local_decl_p (DECL_EXPR_DECL (t)))\n     decl = DECL_EXPR_DECL (t);\n@@ -2172,13 +2171,13 @@ mark_local_for_remap_r (tree* tp,\n       tree copy;\n \n       /* Make a copy.  */\n-      copy = copy_decl_for_inlining (decl, \n-\t\t\t\t     DECL_CONTEXT (decl), \n+      copy = copy_decl_for_inlining (decl,\n+\t\t\t\t     DECL_CONTEXT (decl),\n \t\t\t\t     DECL_CONTEXT (decl));\n \n       /* Remember the copy.  */\n       splay_tree_insert (st,\n-\t\t\t (splay_tree_key) decl, \n+\t\t\t (splay_tree_key) decl,\n \t\t\t (splay_tree_value) copy);\n     }\n \n@@ -2190,8 +2189,8 @@ mark_local_for_remap_r (tree* tp,\n    remaps all local declarations to appropriate replacements.  */\n \n static tree\n-cp_unsave_r (tree* tp, \n-             int* walk_subtrees, \n+cp_unsave_r (tree* tp,\n+             int* walk_subtrees,\n              void* data)\n {\n   splay_tree st = (splay_tree) data;\n@@ -2202,7 +2201,7 @@ cp_unsave_r (tree* tp,\n     {\n       /* Lookup the declaration.  */\n       n = splay_tree_lookup (st, (splay_tree_key) *tp);\n-      \n+\n       /* If it's there, remap it.  */\n       if (n)\n \t*tp = (tree) n->value;"}, {"sha": "363d815251eacae460fe0708aa1539d0d1eed657", "filename": "gcc/dojump.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -187,12 +187,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       break;\n #endif\n \n-    case UNSAVE_EXPR:\n-      do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n-      TREE_OPERAND (exp, 0)\n-\t= lang_hooks.unsave_expr_now (TREE_OPERAND (exp, 0));\n-      break;\n-\n     case NOP_EXPR:\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == COMPONENT_REF\n           || TREE_CODE (TREE_OPERAND (exp, 0)) == BIT_FIELD_REF"}, {"sha": "f2faae301a6a0c40970b69347e9f6221d9c977c4", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -6537,15 +6537,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         return ret;\n       }\n \n-    case UNSAVE_EXPR:\n-      {\n-\trtx temp;\n-\ttemp = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n-\tTREE_OPERAND (exp, 0)\n-\t  = lang_hooks.unsave_expr_now (TREE_OPERAND (exp, 0));\n-\treturn temp;\n-      }\n-\n     case GOTO_EXPR:\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == LABEL_DECL)\n \texpand_goto (TREE_OPERAND (exp, 0));"}, {"sha": "23f7576ff4ee5f73895cf39dd78bbc51f210cfd3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -2027,7 +2027,6 @@ non_lvalue (tree x)\n   case PREINCREMENT_EXPR:\n   case PREDECREMENT_EXPR:\n   case SAVE_EXPR:\n-  case UNSAVE_EXPR:\n   case TRY_CATCH_EXPR:\n   case WITH_CLEANUP_EXPR:\n   case COMPOUND_EXPR:"}, {"sha": "e96f60f2c29320cb0c33bca3eafe012391561acd", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -1,3 +1,8 @@\n+2004-07-28  Eric Christopher  <echristo@redhat.com>\n+\n+\t* lang.c (LANG_HOOKS_UNSAFE_FOR_REEVAL): Delete.\n+\t(java_unsafe_for_reeval): Ditto.\n+\n 2004-07-26    <hp@bitrange.com>\n \n \t* parse.y (build_super_invocation): Adjust declaration order to\n@@ -72,7 +77,7 @@\n \t(start_java_method): Reset uniq.  Create base_decl_map.  Set\n \tfunction_binding_level.\n \t(end_java_method): Null unused fields to save memory.\n-\t\n+\n 2004-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (add_interface_do): Remove.\n@@ -183,8 +188,8 @@\n \t(create_class): Fix comment typo.\n \t(resolve_qualified_expression_name): Pass type of qualifier to\n \tnot_accessible_p, not the type in which target field was found.\n-\t(not_accessible_p): Handle inner classes. Expand protected \n-\tqualifier-subtype check to enclosing instances, but don't apply this \n+\t(not_accessible_p): Handle inner classes. Expand protected\n+\tqualifier-subtype check to enclosing instances, but don't apply this\n \tcheck to static members. Allow protected access to inner classes\n \tof a subtype. Allow private access within common enclosing context.\n \t(build_super_invocation): Get WFL line number info from current\n@@ -195,7 +200,7 @@\n \tcommon_enclosing_instance_p.\n \t* class.c (common_enclosing_context_p): New. Determine if types\n \tshare a common enclosing context, even across static contexts.\n-\t(common_enclosing_instance_p): Renamed from \n+\t(common_enclosing_instance_p): Renamed from\n \tcommon_enclosing_context_p. Determines if types share a common\n \tnon-static enclosing instance.\n \t* java-tree.h (common_enclosing_instance_p): Declare.\n@@ -356,7 +361,7 @@\n \t* parse.y (create_interface): Set correct access modifiers for\n \tinterfaces.\n \t* jcf-write.c (get_classfile_modifiers): New function.\n-\t(generate_classfile): Use get_classfile_modifiers, not \n+\t(generate_classfile): Use get_classfile_modifiers, not\n \tget_access_flags.\n \n 2004-06-26  Bryce McKinlay  <mckinlay@redhat.com>\n@@ -369,7 +374,7 @@\n \n 2004-06-26  Bryce McKinlay  <mckinlay@redhat.com>\n \n-\t* parse.y (qualify_and_find): Pass type decl, not identifier, to \n+\t* parse.y (qualify_and_find): Pass type decl, not identifier, to\n \tload_class.\n \n 2004-06-26  Bryce McKinlay  <mckinlay@redhat.com>\n@@ -403,7 +408,7 @@\n \n 2004-06-22  Andrew Haley  <aph@redhat.com>\n             Ranjit Mathew  <rmathew@hotmail.com>\n-\t\n+\n \tFixes PR java/16113.\n \t* decl.c (force_poplevels): Remove call to expand_end_bindings.\n \n@@ -424,7 +429,7 @@\n \t(emit_init_test_initialization): Likewise.\n \t* java-gimplify.c (java_gimplify_new_array_init): Likewise.\n \t* parse.y (make_qualifed_name, build_array_ref): Likewise.\n-\t\n+\n 2004-06-21  Andrew Haley  <aph@redhat.com>\n \n \t* java-gimplify.c (java_gimplify_block): set TREE_USED on the new\n@@ -455,7 +460,7 @@\n \tdo not set current_function_cannot_inline.\n \t* resource.c (write_resource_constructor): Do not reset\n \tflag_inline_functions around rest_of_compilation.\n-\t\n+\n 2004-06-08  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR java/15769\n@@ -490,8 +495,8 @@\n \n 2004-05-28  Bryce McKinlay  <mckinlay@redhat.com>\n \n-\t* jcf-write.c (generate_bytecode_conditional): Handle binops \n-\tUNLT_EXPR, UNLE_EXPR, UNGT_EXPR, UNGE_EXPR, UNEQ_EXPR, \n+\t* jcf-write.c (generate_bytecode_conditional): Handle binops\n+\tUNLT_EXPR, UNLE_EXPR, UNGT_EXPR, UNGE_EXPR, UNEQ_EXPR,\n \tand LTGT_EXPR.\n \t(generate_bytecode_insns): Likewise.\n \n@@ -599,7 +604,7 @@\n \tFix comment typo.\n \tUse check_pkg_class_access() instead of not_accessible_p()\n \tfor unqualified types.\n-\t(not_accessible_p): Use DECL_CONTEXT (member) instead of \n+\t(not_accessible_p): Use DECL_CONTEXT (member) instead of\n \tREFERENCE for package-private access checking.\n \t(patch_method_invocation): Use accessibility_string() instead\n \tof java_accstring_lookup().\n@@ -626,12 +631,12 @@\n 2004-04-19  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* class.c (make_class_data): Add new field aux_info.\n-\t* decl.c (java_init_decl_processing): Push type and decl for \n+\t* decl.c (java_init_decl_processing): Push type and decl for\n \t`aux_info'.\n \n 2004-04-15  Bryce McKinlay  <mckinlay@redhat.com>\n \n-\t* expr.c (expand_java_NEW): Don't use size argument for \n+\t* expr.c (expand_java_NEW): Don't use size argument for\n \t_Jv_AllocObject calls.\n \t* parse.y (patch_invoke): Likewise.\n \n@@ -642,7 +647,7 @@\n \n 2004-04-12  Bryce McKinlay  <mckinlay@redhat.com>\n \n-\t* class.c (get_interface_method_index): New function. Return dispatch \n+\t* class.c (get_interface_method_index): New function. Return dispatch\n \tindex for interface method.\n \t(make_method_value): For interface methods, set index field to\n \tiface dispatch index, not DECL_VINDEX."}, {"sha": "f81388a4c23d10a1cedc32af018a245f9a49310e", "filename": "gcc/java/lang.c", "status": "modified", "additions": 18, "deletions": 40, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -17,7 +17,7 @@ GNU General Public License for more details.\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA. \n+Boston, MA 02111-1307, USA.\n \n Java and all Java-based marks are trademarks or registered trademarks\n of Sun Microsystems, Inc. in the United States and other countries.\n@@ -59,7 +59,6 @@ static void put_decl_node (tree);\n static void java_print_error_function (diagnostic_context *, const char *);\n static tree java_tree_inlining_walk_subtrees (tree *, int *, walk_tree_fn,\n \t\t\t\t\t      void *, void *);\n-static int java_unsafe_for_reeval (tree);\n static int merge_init_test_initialization (void * *, void *);\n static int inline_init_test_initialization (void * *, void *);\n static bool java_can_use_bit_fields_p (void);\n@@ -221,8 +220,6 @@ struct language_function GTY(())\n #define LANG_HOOKS_POST_OPTIONS java_post_options\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE java_parse_file\n-#undef LANG_HOOKS_UNSAFE_FOR_REEVAL\n-#define LANG_HOOKS_UNSAFE_FOR_REEVAL java_unsafe_for_reeval\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n #define LANG_HOOKS_MARK_ADDRESSABLE java_mark_addressable\n #undef LANG_HOOKS_TRUTHVALUE_CONVERSION\n@@ -672,7 +669,7 @@ java_print_error_function (diagnostic_context *context ATTRIBUTE_UNUSED,\n \t{\n \t  const char *name = lang_printable_name (current_function_decl, 2);\n \t  fprintf (stderr, \"In %s `%s':\\n\",\n-\t\t   (DECL_CONSTRUCTOR_P (current_function_decl) ? \"constructor\" \n+\t\t   (DECL_CONSTRUCTOR_P (current_function_decl) ? \"constructor\"\n \t\t    : \"method\"),\n \t\t   name);\n \t}\n@@ -866,38 +863,19 @@ java_tree_inlining_walk_subtrees (tree *tp ATTRIBUTE_UNUSED,\n   #undef WALK_SUBTREE\n }\n \n-/* Called from unsafe_for_reeval.  */\n-static int\n-java_unsafe_for_reeval (tree t)\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case BLOCK:\n-      /* Our expander tries to expand the variables twice.  Boom.  */\n-      if (BLOCK_EXPR_DECLS (t) != NULL)\n-\treturn 2;\n-      return unsafe_for_reeval (BLOCK_EXPR_BODY (t));\n-\n-    default:\n-      break;\n-    }\n-\n-  return -1;\n-}\n-\n /* Every call to a static constructor has an associated boolean\n    variable which is in the outermost scope of the calling method.\n    This variable is used to avoid multiple calls to the static\n-   constructor for each class.  \n+   constructor for each class.\n \n    It looks something like this:\n \n    foo ()\n    {\n       boolean dummy = OtherClass.is_initialized;\n-  \n+\n      ...\n-  \n+\n      if (! dummy)\n        OtherClass.initialize();\n \n@@ -920,7 +898,7 @@ merge_init_test_initialization (void **entry, void *x)\n   splay_tree decl_map = (splay_tree)x;\n   splay_tree_node n;\n   tree *init_test_decl;\n-  \n+\n   /* See if we have remapped this declaration.  If we haven't there's\n      a bug in the inliner.  */\n   n = splay_tree_lookup (decl_map, (splay_tree_key) ite->value);\n@@ -935,18 +913,18 @@ merge_init_test_initialization (void **entry, void *x)\n   if (!*init_test_decl)\n     *init_test_decl = (tree)n->value;\n \n-  /* This fixes a weird case.  \n+  /* This fixes a weird case.\n \n   The front end assumes that once we have called a method that\n   initializes some class, we can assume the class is initialized.  It\n   does this by setting the DECL_INITIAL of the init_test_decl for that\n   class, and no initializations are emitted for that class.\n-  \n+\n   However, what if the method that is suppoed to do the initialization\n   is itself inlined in the caller?  When expanding the called method\n   we'll assume that the class initialization has already been done,\n   because the DECL_INITIAL of the init_test_decl is set.\n-  \n+\n   To fix this we remove the DECL_INITIAL (in the caller scope) of all\n   the init_test_decls corresponding to classes initialized by the\n   inlined method.  This makes the caller no longer assume that the\n@@ -962,7 +940,7 @@ merge_init_test_initialization (void **entry, void *x)\n void\n java_inlining_merge_static_initializers (tree fn, void *decl_map)\n {\n-  htab_traverse \n+  htab_traverse\n     (DECL_FUNCTION_INIT_TEST_TABLE (fn),\n      merge_init_test_initialization, decl_map);\n }\n@@ -978,8 +956,8 @@ inline_init_test_initialization (void **entry, void *x)\n {\n   struct treetreehash_entry *ite = (struct treetreehash_entry *) *entry;\n   splay_tree decl_map = (splay_tree)x;\n-  \n-  tree h = java_treetreehash_find \n+\n+  tree h = java_treetreehash_find\n     (DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl), ite->key);\n   if (! h)\n     return true;\n@@ -997,7 +975,7 @@ inline_init_test_initialization (void **entry, void *x)\n void\n java_inlining_map_static_initializers (tree fn, void *decl_map)\n {\n-  htab_traverse \n+  htab_traverse\n     (DECL_FUNCTION_INIT_TEST_TABLE (fn),\n      inline_init_test_initialization, decl_map);\n }\n@@ -1029,7 +1007,7 @@ dump_compound_expr (dump_info_p di, tree t)\n \t}\n     }\n }\n-  \n+\n static bool\n java_dump_tree (void *dump_info, tree t)\n {\n@@ -1087,15 +1065,15 @@ java_dump_tree (void *dump_info, tree t)\n \t      dump_child (\"var\", local);\n \t      local = next;\n \t    }\n-\t  \n+\n \t  {\n \t    tree block = BLOCK_EXPR_BODY (t);\n \t    dump_child (\"body\", block);\n \t    block = TREE_CHAIN (block);\n \t  }\n \t}\n       return true;\n-      \n+\n     case COMPOUND_EXPR:\n       if (!dump_flag (di, TDF_SLIM, t))\n \treturn false;\n@@ -1139,13 +1117,13 @@ java_get_callee_fndecl (tree call_expr)\n     return NULL;\n   table = TREE_OPERAND (method, 0);\n   if (! DECL_LANG_SPECIFIC(table)\n-      || !DECL_OWNER (table) \n+      || !DECL_OWNER (table)\n       || TYPE_ATABLE_DECL (DECL_OWNER (table)) != table)\n     return NULL;\n \n   atable_methods = TYPE_ATABLE_METHODS (DECL_OWNER (table));\n   index = TREE_INT_CST_LOW (TREE_OPERAND (method, 1));\n-  \n+\n   /* FIXME: Replace this for loop with a hash table lookup.  */\n   for (element = atable_methods; element; element = TREE_CHAIN (element))\n     {"}, {"sha": "7efa097e9cce74d4cee709c6001f229b18424c2e", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -51,7 +51,6 @@ extern tree lhd_return_null_tree (tree);\n extern tree lhd_do_nothing_iii_return_null_tree (int, int, int);\n extern int lhd_safe_from_p (rtx, tree);\n extern bool lhd_staticp (tree);\n-extern int lhd_unsafe_for_reeval (tree);\n extern void lhd_print_tree_nothing (FILE *, tree, int);\n extern const char *lhd_decl_printable_name (tree, int);\n extern int lhd_types_compatible_p (tree, tree);\n@@ -106,7 +105,6 @@ extern int lhd_gimplify_expr (tree *, tree *, tree *);\n #define LANG_HOOKS_EXPAND_DECL\t\tlhd_expand_decl\n #define LANG_HOOKS_SAFE_FROM_P\t\tlhd_safe_from_p\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL lhd_do_nothing_t\n-#define LANG_HOOKS_UNSAFE_FOR_REEVAL\tlhd_unsafe_for_reeval\n #define LANG_HOOKS_STATICP\t\tlhd_staticp\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL lhd_do_nothing_t\n #define LANG_HOOKS_UNSAVE_EXPR_NOW\tlhd_unsave_expr_now\n@@ -271,7 +269,6 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_TRUTHVALUE_CONVERSION, \\\n   LANG_HOOKS_SAFE_FROM_P, \\\n   LANG_HOOKS_FINISH_INCOMPLETE_DECL, \\\n-  LANG_HOOKS_UNSAFE_FOR_REEVAL, \\\n   LANG_HOOKS_MARK_ADDRESSABLE, \\\n   LANG_HOOKS_STATICP, \\\n   LANG_HOOKS_DUP_LANG_SPECIFIC_DECL, \\"}, {"sha": "e93204240eeec628f400f2cb7b116370639ffa95", "filename": "gcc/langhooks.c", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -60,7 +60,7 @@ lhd_do_nothing_i (int ARG_UNUSED (i))\n /* Do nothing (int, int, int).  Return NULL_TREE.  */\n \n tree\n-lhd_do_nothing_iii_return_null_tree (int ARG_UNUSED (i), \n+lhd_do_nothing_iii_return_null_tree (int ARG_UNUSED (i),\n \t\t\t\t     int ARG_UNUSED (j),\n \t\t\t\t     int ARG_UNUSED (k))\n {\n@@ -123,14 +123,6 @@ lhd_safe_from_p (rtx ARG_UNUSED (x), tree ARG_UNUSED (exp))\n   return 1;\n }\n \n-/* Called from unsafe_for_reeval.  */\n-\n-int\n-lhd_unsafe_for_reeval (tree ARG_UNUSED (t))\n-{\n-  return -1;\n-}\n-\n /* Called from staticp.  */\n \n bool\n@@ -175,7 +167,7 @@ lhd_set_decl_assembler_name (tree decl)\n \t same as that used in the source language.  (That's correct\n \t for C, and GCC used to set DECL_ASSEMBLER_NAME to the same\n \t value as DECL_NAME in build_decl, so this choice provides\n-\t backwards compatibility with existing front-ends.  \n+\t backwards compatibility with existing front-ends.\n \n          Can't use just the variable's own name for a variable whose\n \t scope is less than the whole compilation.  Concatenate a\n@@ -214,7 +206,7 @@ lhd_type_promotes_to (tree ARG_UNUSED (type))\n \n /* Registration of machine- or os-specific builtin types.  */\n void\n-lhd_register_builtin_type (tree ARG_UNUSED (type), \n+lhd_register_builtin_type (tree ARG_UNUSED (type),\n \t\t\t   const char * ARG_UNUSED (name))\n {\n }"}, {"sha": "04dc114d2b771e774a05cf63f8bf67fafe0f0757", "filename": "gcc/langhooks.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -293,11 +293,6 @@ struct lang_hooks\n      compilation.  Default hook is does nothing.  */\n   void (*finish_incomplete_decl) (tree);\n \n-  /* Function used by unsafe_for_reeval.  A non-negative number is\n-     returned directly from unsafe_for_reeval, a negative number falls\n-     through.  The default hook returns a negative number.  */\n-  int (*unsafe_for_reeval) (tree);\n-\n   /* Mark EXP saying that we need to be able to take the address of\n      it; it should not be allocated in a register.  Return true if\n      successful.  */\n@@ -310,8 +305,8 @@ struct lang_hooks\n      DECL_NODE with a newly GC-allocated copy.  */\n   void (*dup_lang_specific_decl) (tree);\n \n-  /* Called before its argument, an UNSAVE_EXPR, is to be\n-     unsaved.  Modify it in-place so that all the evaluate only once\n+  /* Reset argument so that it can be expanded again.\n+     Modify it in-place so that all the evaluate only once\n      things are cleared out.  */\n   tree (*unsave_expr_now) (tree);\n "}, {"sha": "5856ad599d3358306b0d0b47f2c8650ddc1aa465", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -67,8 +67,6 @@ enum c_language_kind c_language = clk_objc;\n #define LANG_HOOKS_TRUTHVALUE_CONVERSION c_objc_common_truthvalue_conversion\n #undef LANG_HOOKS_FINISH_INCOMPLETE_DECL\n #define LANG_HOOKS_FINISH_INCOMPLETE_DECL c_finish_incomplete_decl\n-#undef LANG_HOOKS_UNSAFE_FOR_REEVAL\n-#define LANG_HOOKS_UNSAFE_FOR_REEVAL c_common_unsafe_for_reeval\n #undef LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS\n #define LANG_HOOKS_REDUCE_BIT_FIELD_OPERATIONS true\n #undef LANG_HOOKS_STATICP"}, {"sha": "bb2af8dc2bc671d93f29851dd58bac3b8249f96a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -154,7 +154,7 @@ insert_decl_map (inline_data *id, tree key, tree value)\n \t\t       (splay_tree_value) value);\n }\n \n-/* Remap DECL during the copying of the BLOCK tree for the function. \n+/* Remap DECL during the copying of the BLOCK tree for the function.\n    We are only called to remap local variables in the current function.  */\n \n static tree\n@@ -243,7 +243,7 @@ remap_type (tree type, inline_data *id)\n       insert_decl_map (id, type, type);\n       return type;\n     }\n-  \n+\n   /* We do need a copy.  build and register it now.  If this is a pointer or\n      reference type, remap the designated type and make a new pointer or\n      reference type.  */\n@@ -303,7 +303,7 @@ remap_type (tree type, inline_data *id)\n       if (t && TREE_CODE (t) != INTEGER_CST)\n         walk_tree (&TYPE_MAX_VALUE (new), copy_body_r, id, NULL);\n       return new;\n-    \n+\n     case FUNCTION_TYPE:\n       TREE_TYPE (new) = remap_type (TREE_TYPE (new), id);\n       walk_tree (&TYPE_ARG_TYPES (new), copy_body_r, id, NULL);\n@@ -518,9 +518,6 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n     copy_statement_list (tp);\n   else if (TREE_CODE (*tp) == SAVE_EXPR)\n     remap_save_expr (tp, id->decl_map, walk_subtrees);\n-  else if (TREE_CODE (*tp) == UNSAVE_EXPR)\n-    /* UNSAVE_EXPRs should not be generated until expansion time.  */\n-    abort ();\n   else if (TREE_CODE (*tp) == BIND_EXPR)\n     copy_bind_expr (tp, walk_subtrees, id);\n   else if (TREE_CODE (*tp) == LABELED_BLOCK_EXPR)\n@@ -1206,7 +1203,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     return NULL;\n \n   switch (TREE_CODE (x))\n-    { \n+    {\n     /* Containers have no cost.  */\n     case TREE_LIST:\n     case TREE_VEC:\n@@ -1226,7 +1223,6 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case NOP_EXPR:\n     case VIEW_CONVERT_EXPR:\n     case SAVE_EXPR:\n-    case UNSAVE_EXPR:\n     case ADDR_EXPR:\n     case COMPLEX_EXPR:\n     case EXIT_BLOCK_EXPR:\n@@ -1580,7 +1576,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n \t Note we need to save and restore the saved tree statement iterator\n \t to avoid having it clobbered by expand_calls_inline.  */\n       tree_stmt_iterator save_tsi;\n-     \n+\n       save_tsi = id->tsi;\n       expand_calls_inline (&arg_inits, id);\n       id->tsi = save_tsi;\n@@ -1701,7 +1697,7 @@ static void\n expand_calls_inline (tree *stmt_p, inline_data *id)\n {\n   tree stmt = *stmt_p;\n-  enum tree_code code = TREE_CODE (stmt); \n+  enum tree_code code = TREE_CODE (stmt);\n   int dummy;\n \n   switch (code)\n@@ -2326,7 +2322,7 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       if (TREE_CODE (*tp) == BIND_EXPR)\n \tBIND_EXPR_BLOCK (*tp) = NULL_TREE;\n     }\n- \n+\n   else if (TREE_CODE_CLASS (code) == 't')\n     *walk_subtrees = 0;\n   else if (TREE_CODE_CLASS (code) == 'd')\n@@ -2392,7 +2388,7 @@ mark_local_for_remap_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n \n       /* Copy the decl and remember the copy.  */\n       insert_decl_map (id, decl,\n-\t\t       copy_decl_for_inlining (decl, DECL_CONTEXT (decl), \n+\t\t       copy_decl_for_inlining (decl, DECL_CONTEXT (decl),\n \t\t\t\t\t       DECL_CONTEXT (decl)));\n     }\n \n@@ -2416,7 +2412,7 @@ unsave_r (tree *tp, int *walk_subtrees, void *data)\n     {\n       /* Lookup the declaration.  */\n       n = splay_tree_lookup (st, (splay_tree_key) *tp);\n-      \n+\n       /* If it's there, remap it.  */\n       if (n)\n \t*tp = (tree) n->value;"}, {"sha": "d1479e4869d3e6d1049756bf3e6ce1f5b5e4d2b8", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -754,7 +754,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       {\n \ttree_stmt_iterator si;\n \tbool first = true;\n-  \n+\n \tif ((flags & TDF_SLIM) || !dumping_stmts)\n \t  {\n \t    pp_string (buffer, \"<STATEMENT_LIST>\");\n@@ -1099,12 +1099,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_character (buffer, '>');\n       break;\n \n-    case UNSAVE_EXPR:\n-      pp_string (buffer, \"UNSAVE_EXPR <\");\n-      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n-      pp_character (buffer, '>');\n-      break;\n-\n     case ENTRY_VALUE_EXPR:\n       NIY;\n       break;\n@@ -2051,10 +2045,10 @@ dump_vops (pretty_printer *buffer, tree stmt, int spc, int flags)\n   for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n     {\n       pp_string (buffer, \"#   \");\n-      dump_generic_node (buffer, V_MAY_DEF_RESULT (v_may_defs, i), \n+      dump_generic_node (buffer, V_MAY_DEF_RESULT (v_may_defs, i),\n                          spc + 2, flags, false);\n       pp_string (buffer, \" = V_MAY_DEF <\");\n-      dump_generic_node (buffer, V_MAY_DEF_OP (v_may_defs, i), \n+      dump_generic_node (buffer, V_MAY_DEF_OP (v_may_defs, i),\n                          spc + 2, flags, false);\n       pp_string (buffer, \">;\");\n       newline_and_indent (buffer, spc);\n@@ -2283,7 +2277,7 @@ dump_generic_bb_buff (pretty_printer *buffer, basic_block bb,\n \n   if (bb_ann (bb))\n     dump_phi_nodes (buffer, bb, indent, flags);\n-  \n+\n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       int curr_indent;"}, {"sha": "30fcb556ab308a145201b6ec3c92fd27deb507fb", "filename": "gcc/tree.c", "status": "modified", "additions": 35, "deletions": 153, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -582,7 +582,7 @@ make_tree_binfo_stat (unsigned base_binfos MEM_STAT_DECL)\n   tree t;\n   size_t length = (offsetof (struct tree_binfo, base_binfos)\n \t\t   + VEC_embedded_size (tree, base_binfos));\n-  \n+\n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int) binfo_kind]++;\n   tree_node_sizes[(int) binfo_kind] += length;\n@@ -593,7 +593,7 @@ make_tree_binfo_stat (unsigned base_binfos MEM_STAT_DECL)\n   memset (t, 0, offsetof (struct tree_binfo, base_binfos));\n \n   TREE_SET_CODE (t, TREE_BINFO);\n-  \n+\n   VEC_embedded_init (tree, BINFO_BASE_BINFOS (t), base_binfos);\n \n   return t;\n@@ -1217,7 +1217,7 @@ expr_align (tree t)\n \n     case SAVE_EXPR:         case COMPOUND_EXPR:       case MODIFY_EXPR:\n     case INIT_EXPR:         case TARGET_EXPR:         case WITH_CLEANUP_EXPR:\n-    case CLEANUP_POINT_EXPR:  case UNSAVE_EXPR:\n+    case CLEANUP_POINT_EXPR:\n       /* These don't change the alignment of an object.  */\n       return expr_align (TREE_OPERAND (t, 0));\n \n@@ -1294,7 +1294,7 @@ staticp (tree arg)\n       return true;\n \n     case COMPONENT_REF:\n-      /* If the thing being referenced is not a field, then it is \n+      /* If the thing being referenced is not a field, then it is\n \t something language specific.  */\n       if (TREE_CODE (TREE_OPERAND (arg, 1)) != FIELD_DECL)\n \treturn (*lang_hooks.staticp) (arg);\n@@ -1436,24 +1436,6 @@ skip_simple_arithmetic (tree expr)\n   return inner;\n }\n \n-/* Arrange for an expression to be expanded multiple independent\n-   times.  This is useful for cleanup actions, as the backend can\n-   expand them multiple times in different places.  */\n-\n-tree\n-unsave_expr (tree expr)\n-{\n-  tree t;\n-\n-  /* If this is already protected, no sense in protecting it again.  */\n-  if (TREE_CODE (expr) == UNSAVE_EXPR)\n-    return expr;\n-\n-  t = build1 (UNSAVE_EXPR, TREE_TYPE (expr), expr);\n-  TREE_SIDE_EFFECTS (t) = TREE_SIDE_EFFECTS (expr);\n-  return t;\n-}\n-\n /* Returns the index of the first non-tree operand for CODE, or the number\n    of operands if all are trees.  */\n \n@@ -1533,106 +1515,6 @@ unsave_expr_1 (tree expr)\n       break;\n     }\n }\n-\n-/* Return 0 if it is safe to evaluate EXPR multiple times,\n-   return 1 if it is safe if EXPR is unsaved afterward, or\n-   return 2 if it is completely unsafe.\n-\n-   This assumes that CALL_EXPRs and TARGET_EXPRs are never replicated in\n-   an expression tree, so that it safe to unsave them and the surrounding\n-   context will be correct.\n-\n-   SAVE_EXPRs basically *only* appear replicated in an expression tree,\n-   occasionally across the whole of a function.  It is therefore only\n-   safe to unsave a SAVE_EXPR if you know that all occurrences appear\n-   below the UNSAVE_EXPR.  */\n-\n-int\n-unsafe_for_reeval (tree expr)\n-{\n-  int unsafeness = 0;\n-  enum tree_code code;\n-  int i, tmp, tmp2;\n-  tree exp;\n-  int first_rtl;\n-\n-  if (expr == NULL_TREE)\n-    return 1;\n-\n-  code = TREE_CODE (expr);\n-  first_rtl = first_rtl_op (code);\n-\n-  switch (code)\n-    {\n-    case SAVE_EXPR:\n-      return 2;\n-\n-      /* A label can only be emitted once.  */\n-    case LABEL_EXPR:\n-      return 1;\n-\n-    case BIND_EXPR:\n-      unsafeness = 1;\n-      break;\n-\n-    case TREE_LIST:\n-      for (exp = expr; exp != 0; exp = TREE_CHAIN (exp))\n-\t{\n-\t  tmp = unsafe_for_reeval (TREE_VALUE (exp));\n-\t  unsafeness = MAX (tmp, unsafeness);\n-\t}\n-\n-      return unsafeness;\n-\n-    case CALL_EXPR:\n-      tmp2 = unsafe_for_reeval (TREE_OPERAND (expr, 0));\n-      tmp = unsafe_for_reeval (TREE_OPERAND (expr, 1));\n-      return MAX (MAX (tmp, 1), tmp2);\n-\n-    case TARGET_EXPR:\n-      unsafeness = 1;\n-      break;\n-\n-    case EXIT_BLOCK_EXPR:\n-      /* EXIT_BLOCK_LABELED_BLOCK, a.k.a. TREE_OPERAND (expr, 0), holds\n-\t a reference to an ancestor LABELED_BLOCK, so we need to avoid\n-\t unbounded recursion in the 'e' traversal code below.  */\n-      exp = EXIT_BLOCK_RETURN (expr);\n-      return exp ? unsafe_for_reeval (exp) : 0;\n-\n-    default:\n-      tmp = lang_hooks.unsafe_for_reeval (expr);\n-      if (tmp >= 0)\n-\treturn tmp;\n-      break;\n-    }\n-\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case 'c':  /* a constant */\n-    case 't':  /* a type node */\n-    case 'x':  /* something random, like an identifier or an ERROR_MARK.  */\n-    case 'd':  /* A decl node */\n-      return 0;\n-\n-    case 'e':  /* an expression */\n-    case 'r':  /* a reference */\n-    case 's':  /* an expression with side effects */\n-    case '<':  /* a comparison expression */\n-    case '2':  /* a binary arithmetic expression */\n-    case '1':  /* a unary arithmetic expression */\n-      for (i = first_rtl - 1; i >= 0; i--)\n-\t{\n-\t  tmp = unsafe_for_reeval (TREE_OPERAND (expr, i));\n-\t  unsafeness = MAX (tmp, unsafeness);\n-\t}\n-\n-      return unsafeness;\n-\n-    default:\n-      return 2;\n-    }\n-}\n \f\n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.  */\n@@ -2313,7 +2195,7 @@ do { tree _node = (NODE); \\\n       else if (TREE_CODE (node) == BIT_FIELD_REF)\n \tUPDATE_TITCSE (TREE_OPERAND (node, 2));\n     }\n-\t      \n+\n   /* Now see what's inside.  If it's an INDIRECT_REF, copy our properties from\n      it.  If it's a decl, it's invariant and constant if the decl is static.\n      It's also invariant if it's a decl in the current function.  (Taking the\n@@ -2349,7 +2231,7 @@ do { tree _node = (NODE); \\\n    Constants, decls, types and misc nodes cannot be.\n \n    We define 5 non-variadic functions, from 0 to 4 arguments.  This is\n-   enough for all extant tree codes.  These functions can be called \n+   enough for all extant tree codes.  These functions can be called\n    directly (preferably!), but can also be obtained via GCC preprocessor\n    magic within the build macro.  */\n \n@@ -2515,7 +2397,7 @@ build2_stat (enum tree_code code, tree tt, tree arg0, tree arg1 MEM_STAT_DECL)\n   TREE_READONLY (t) = read_only;\n   TREE_CONSTANT (t) = constant;\n   TREE_INVARIANT (t) = invariant;\n-  TREE_SIDE_EFFECTS (t) = side_effects;  \n+  TREE_SIDE_EFFECTS (t) = side_effects;\n   TREE_THIS_VOLATILE (t)\n     = TREE_CODE_CLASS (code) == 'r' && arg0 && TREE_THIS_VOLATILE (arg0);\n \n@@ -2566,7 +2448,7 @@ build3_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n \t  }\n     }\n \n-  TREE_SIDE_EFFECTS (t) = side_effects;  \n+  TREE_SIDE_EFFECTS (t) = side_effects;\n   TREE_THIS_VOLATILE (t)\n     = TREE_CODE_CLASS (code) == 'r' && arg0 && TREE_THIS_VOLATILE (arg0);\n \n@@ -2598,7 +2480,7 @@ build4_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n   PROCESS_ARG(2);\n   PROCESS_ARG(3);\n \n-  TREE_SIDE_EFFECTS (t) = side_effects;  \n+  TREE_SIDE_EFFECTS (t) = side_effects;\n   TREE_THIS_VOLATILE (t)\n     = TREE_CODE_CLASS (code) == 'r' && arg0 && TREE_THIS_VOLATILE (arg0);\n \n@@ -2700,7 +2582,7 @@ build_decl_stat (enum tree_code code, tree name, tree type MEM_STAT_DECL)\n     layout_decl (t, 0);\n   else if (code == FUNCTION_DECL)\n     DECL_MODE (t) = FUNCTION_MODE;\n-    \n+\n   /* Set default visibility to whatever the user supplied with\n      visibility_specified depending on #pragma GCC visibility.  */\n   DECL_VISIBILITY (t) = default_visibility;\n@@ -3230,7 +3112,7 @@ type_hash_eq (const void *va, const void *vb)\n \t\t      && TREE_CODE (TYPE_ARG_TYPES (b->type)) == TREE_LIST\n \t\t      && type_list_equal (TYPE_ARG_TYPES (a->type),\n \t\t\t\t\t  TYPE_ARG_TYPES (b->type)))));\n-\t\t\t\t\t\t\t\t      \n+\n     case ARRAY_TYPE:\n     case SET_TYPE:\n       return TYPE_DOMAIN (a->type) == TYPE_DOMAIN (b->type);\n@@ -3683,7 +3565,7 @@ simple_cst_equal (tree t1, tree t2)\n \t\t\t TREE_STRING_LENGTH (t1)));\n \n     case CONSTRUCTOR:\n-      return simple_cst_list_equal (CONSTRUCTOR_ELTS (t1), \n+      return simple_cst_list_equal (CONSTRUCTOR_ELTS (t1),\n \t                            CONSTRUCTOR_ELTS (t2));\n \n     case SAVE_EXPR:\n@@ -4325,7 +4207,7 @@ build_method_type (tree basetype, tree type)\n   if (TREE_CODE (type) != FUNCTION_TYPE)\n     abort ();\n \n-  return build_method_type_directly (basetype, \n+  return build_method_type_directly (basetype,\n \t\t\t\t     TREE_TYPE (type),\n \t\t\t\t     TYPE_ARG_TYPES (type));\n }\n@@ -4870,16 +4752,16 @@ decl_type_context (tree decl)\n       case UNION_TYPE:\n       case QUAL_UNION_TYPE:\n \treturn context;\n-\t\n+\n       case TYPE_DECL:\n       case FUNCTION_DECL:\n \tcontext = DECL_CONTEXT (context);\n \tbreak;\n-\t\n+\n       case BLOCK:\n \tcontext = BLOCK_SUPERCONTEXT (context);\n \tbreak;\n-\t\n+\n       default:\n \tabort ();\n       }\n@@ -4918,7 +4800,7 @@ get_callee_fndecl (tree call)\n   if (TREE_CODE (addr) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (addr, 0)) == FUNCTION_DECL)\n     return TREE_OPERAND (addr, 0);\n-  \n+\n   /* We couldn't figure out what was being called.  Maybe the front\n      end has some idea.  */\n   return lang_hooks.lang_get_callee_fndecl (call);\n@@ -4970,11 +4852,11 @@ crc32_string (unsigned chksum, const char *string)\n     {\n       unsigned value = *string << 24;\n       unsigned ix;\n-      \n+\n       for (ix = 8; ix--; value <<= 1)\n   \t{\n   \t  unsigned feedback;\n-  \t  \n+\n   \t  feedback = (value ^ chksum) & 0x80000000 ? 0x04c11db7 : 0;\n  \t  chksum <<= 1;\n  \t  chksum ^= feedback;\n@@ -5189,7 +5071,7 @@ tree_check_failed (const tree node, const char *file,\n       length += strlen (tree_code_name[code]);\n     }\n   va_end (args);\n-  \n+\n   internal_error (\"tree check: expected %s, have %s in %s, at %s:%d\",\n \t\t  buffer, tree_code_name[TREE_CODE (node)],\n \t\t  function, trim_filename (file), line);\n@@ -5226,7 +5108,7 @@ tree_not_check_failed (const tree node, const char *file,\n       length += strlen (tree_code_name[code]);\n     }\n   va_end (args);\n-  \n+\n   internal_error (\"tree check: expected none of %s, have %s in %s, at %s:%d\",\n \t\t  buffer, tree_code_name[TREE_CODE (node)],\n \t\t  function, trim_filename (file), line);\n@@ -5392,7 +5274,7 @@ build_common_tree_nodes (int signed_char)\n   unsigned_intSI_type_node = make_or_reuse_type (GET_MODE_BITSIZE (SImode), 1);\n   unsigned_intDI_type_node = make_or_reuse_type (GET_MODE_BITSIZE (DImode), 1);\n   unsigned_intTI_type_node = make_or_reuse_type (GET_MODE_BITSIZE (TImode), 1);\n-  \n+\n   access_public_node = get_identifier (\"public\");\n   access_protected_node = get_identifier (\"protected\");\n   access_private_node = get_identifier (\"private\");\n@@ -5520,7 +5402,7 @@ reconstruct_complex_type (tree type, tree bottom)\n     {\n       inner = reconstruct_complex_type (TREE_TYPE (type), bottom);\n       outer = build_method_type_directly (TYPE_METHOD_BASETYPE (type),\n-\t\t\t\t\t  inner, \n+\t\t\t\t\t  inner,\n \t\t\t\t\t  TYPE_ARG_TYPES (type));\n     }\n   else\n@@ -5650,7 +5532,7 @@ in_array_bounds_p (tree ref)\n \n   if (TREE_CODE (idx) != INTEGER_CST)\n     return false;\n-\t    \n+\n   min = array_ref_low_bound (ref);\n   max = array_ref_up_bound (ref);\n   if (!min\n@@ -5695,7 +5577,7 @@ fields_compatible_p (tree f1, tree f2)\n     return false;\n \n   if (!lang_hooks.types_compatible_p (TREE_TYPE (f1), TREE_TYPE (f2)))\n-    return false; \n+    return false;\n \n   return true;\n }\n@@ -5746,36 +5628,36 @@ int_cst_value (tree x)\n /* Returns the greatest common divisor of A and B, which must be\n    INTEGER_CSTs.  */\n \n-tree \n+tree\n tree_fold_gcd (tree a, tree b)\n {\n   tree a_mod_b;\n   tree type = TREE_TYPE (a);\n-  \n+\n #if defined ENABLE_CHECKING\n   if (TREE_CODE (a) != INTEGER_CST\n       || TREE_CODE (b) != INTEGER_CST)\n     abort ();\n #endif\n-  \n-  if (integer_zerop (a)) \n+\n+  if (integer_zerop (a))\n     return b;\n-  \n-  if (integer_zerop (b)) \n+\n+  if (integer_zerop (b))\n     return a;\n-  \n+\n   if (tree_int_cst_sgn (a) == -1)\n     a = fold (build2 (MULT_EXPR, type, a,\n \t\t      convert (type, integer_minus_one_node)));\n-  \n+\n   if (tree_int_cst_sgn (b) == -1)\n     b = fold (build2 (MULT_EXPR, type, b,\n \t\t      convert (type, integer_minus_one_node)));\n- \n+\n   while (1)\n     {\n       a_mod_b = fold (build2 (CEIL_MOD_EXPR, type, a, b));\n- \n+\n       if (!TREE_INT_CST_LOW (a_mod_b)\n \t  && !TREE_INT_CST_HIGH (a_mod_b))\n \treturn b;"}, {"sha": "49cb8fb4e2e743ef282ac1d59b87af8f5c0d4e0e", "filename": "gcc/tree.def", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n- \n+\n /* The third argument can be:\n    'x' for an exceptional code (fits no category).\n    't' for a type object code.\n@@ -82,7 +82,7 @@ DEFTREECODE (TREE_VEC, \"tree_vec\", 'x', 0)\n    outermost scope of a particular inlining of a function).\n    BLOCK_ABSTRACT is nonzero if the block represents an abstract\n    instance of a block (i.e. one which is nested within an abstract\n-   instance of an inline function). \n+   instance of an inline function).\n    TREE_ASM_WRITTEN is nonzero if the block was actually referenced\n    in the generated assembly.  */\n DEFTREECODE (BLOCK, \"block\", 'x', 0)\n@@ -272,7 +272,7 @@ DEFTREECODE (REAL_CST, \"real_cst\", 'c', 0)\n DEFTREECODE (COMPLEX_CST, \"complex_cst\", 'c', 0)\n \n /* Contents are in TREE_VECTOR_CST_ELTS field.  */\n-DEFTREECODE (VECTOR_CST, \"vector_cst\", 'c', 0)     \n+DEFTREECODE (VECTOR_CST, \"vector_cst\", 'c', 0)\n \n /* Contents are TREE_STRING_LENGTH and TREE_STRING_POINTER fields.  */\n DEFTREECODE (STRING_CST, \"string_cst\", 'c', 0)\n@@ -369,7 +369,7 @@ DEFTREECODE (COMPONENT_REF, \"component_ref\", 'r', 3)\n    The field can be either a signed or unsigned field;\n    BIT_FIELD_REF_UNSIGNED says which.  */\n DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", 'r', 3)\n-   \n+\n /* C unary `*' or Pascal `^'.  One operand, an expression for a pointer.  */\n DEFTREECODE (INDIRECT_REF, \"indirect_ref\", 'r', 1)\n \n@@ -462,20 +462,20 @@ DEFTREECODE (COND_EXPR, \"cond_expr\", 'e', 3)\n \n /* Declare local variables, including making RTL and allocating space.\n    BIND_EXPR_VARS is a chain of VAR_DECL nodes for the variables.\n-   BIND_EXPR_BODY is the body, the expression to be computed using \n+   BIND_EXPR_BODY is the body, the expression to be computed using\n    the variables.  The value of operand 1 becomes that of the BIND_EXPR.\n    BIND_EXPR_BLOCK is the BLOCK that corresponds to these bindings\n    for debugging purposes.  If this BIND_EXPR is actually expanded,\n    that sets the TREE_USED flag in the BLOCK.\n \n    The BIND_EXPR is not responsible for informing parsers\n    about these variables.  If the body is coming from the input file,\n-   then the code that creates the BIND_EXPR is also responsible for \n+   then the code that creates the BIND_EXPR is also responsible for\n    informing the parser of the variables.\n \n    If the BIND_EXPR is ever expanded, its TREE_USED flag is set.\n    This tells the code for debugging symbol tables not to ignore the BIND_EXPR.\n-   If the BIND_EXPR should be output for debugging but will not be expanded, \n+   If the BIND_EXPR should be output for debugging but will not be expanded,\n    set the TREE_USED flag by hand.\n \n    In order for the BIND_EXPR to be known at all, the code that creates it\n@@ -716,14 +716,6 @@ DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", 'r', 1)\n    will be replaced by the temporary variable that holds the value.  */\n DEFTREECODE (SAVE_EXPR, \"save_expr\", 'e', 1)\n \n-/* For a UNSAVE_EXPR, operand 0 is the value to unsave.  By unsave, we\n-   mean that all _EXPRs such as TARGET_EXPRs, SAVE_EXPRs, CALL_EXPRs,\n-   that are protected from being evaluated more than once should be\n-   reset so that a new expand_expr call of this expr will cause those\n-   to be re-evaluated.  This is useful when we want to reuse a tree in\n-   different places, but where we must re-expand.  */\n-DEFTREECODE (UNSAVE_EXPR, \"unsave_expr\", 'e', 1)\n-\n /* & in C.  Value is the address at which the operand's value resides.\n    Operand may have any mode.  Result mode is Pmode.  */\n DEFTREECODE (ADDR_EXPR, \"addr_expr\", 'e', 1)\n@@ -732,7 +724,7 @@ DEFTREECODE (ADDR_EXPR, \"addr_expr\", 'e', 1)\n    of type EPmode.  Used only for languages that need static chains.  */\n DEFTREECODE (ENTRY_VALUE_EXPR, \"entry_value_expr\", 'e', 1)\n \n-/* Operand0 is a function constant; result is part N of a function \n+/* Operand0 is a function constant; result is part N of a function\n    descriptor of type ptr_mode.  */\n DEFTREECODE (FDESC_EXPR, \"fdesc_expr\", 'e', 2)\n \n@@ -827,7 +819,7 @@ DEFTREECODE (SWITCH_EXPR, \"switch_expr\", 's', 3)\n    label.  CASE_LABEL is the corresponding LABEL_DECL.  */\n DEFTREECODE (CASE_LABEL_EXPR, \"case_label_expr\", 's', 3)\n \n-/* RESX.  Resume execution after an exception.  Operand 0 is a \n+/* RESX.  Resume execution after an exception.  Operand 0 is a\n    number indicating the exception region that is being left.  */\n DEFTREECODE (RESX_EXPR, \"resx_expr\", 's', 1)\n "}, {"sha": "3e672e38878f793c1bd77994a552dface61cdce4", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9f63daea379c0d0c8a30b8f6ea6d8dc6c4ffa415", "patch": "@@ -3169,22 +3169,11 @@ extern int first_rtl_op (enum tree_code);\n \n enum tree_node_structure_enum tree_node_structure (tree);\n \n-/* unsave_expr (EXP) returns an expression equivalent to EXP but it\n-   can be used multiple times and will evaluate EXP in its entirety\n-   each time.  */\n-\n-extern tree unsave_expr (tree);\n-\n /* Reset EXP in place so that it can be expanded again.  Does not\n    recurse into subtrees.  */\n \n extern void unsave_expr_1 (tree);\n \n-/* Return 0 if it is safe to evaluate EXPR multiple times,\n-   return 1 if it is safe if EXPR is unsaved afterward, or\n-   return 2 if it is completely unsafe.  */\n-extern int unsafe_for_reeval (tree);\n-\n /* Return 1 if EXP contains a PLACEHOLDER_EXPR; i.e., if it represents a size\n    or offset that depends on a field within a record.\n "}]}