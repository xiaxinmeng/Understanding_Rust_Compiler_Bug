{"sha": "a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRmNzM3NGU0ZDZiZmI3YTI2YmZiODVjMmM5MTQ2ODhkNGIwN2IxMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-09-05T09:28:21Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-09-05T09:28:21Z"}, "message": "trans.c (convert_with_check): Use a custom base type if the base type of the expression has a different...\n\n\t* gcc-interface/trans.c (convert_with_check): Use a custom base type\n\tif the base type of the expression has a different machine mode.\n\tRename a couple of parameters and local variable.\n\nFrom-SVN: r251705", "tree": {"sha": "b38ddab7872d0c277ff1e5a9c6ca8e4c6e6f347c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b38ddab7872d0c277ff1e5a9c6ca8e4c6e6f347c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10/comments", "author": null, "committer": null, "parents": [{"sha": "3fd9ae9664a57eac0fbf3b88b8f6971d293b13e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd9ae9664a57eac0fbf3b88b8f6971d293b13e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd9ae9664a57eac0fbf3b88b8f6971d293b13e5"}], "stats": {"total": 95, "additions": 55, "deletions": 40}, "files": [{"sha": "ac954d2b04ad6a945af76516d0b6ce530321d3fa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10", "patch": "@@ -1,3 +1,9 @@\n+2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (convert_with_check): Use a custom base type\n+\tif the base type of the expression has a different machine mode.\n+\tRename a couple of parameters and local variable.\n+\n 2017-09-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Address>: Do not strip"}, {"sha": "9163eb10a7c86eb901229b34c00406916134cea3", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=a4f7374e4d6bfb7a26bfb85c2c914688d4b07b10", "patch": "@@ -9252,63 +9252,71 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason, Node_Id gnat_node)\n \f\n /* Return an expression that converts GNU_EXPR to GNAT_TYPE, doing overflow\n    checks if OVERFLOW_P is true and range checks if RANGE_P is true.\n-   GNAT_TYPE is known to be an integral type.  If TRUNCATE_P true, do a\n-   float to integer conversion with truncation; otherwise round.\n-   GNAT_NODE is the GNAT node conveying the source location for which the\n-   error should be signaled.  */\n+   If TRUNCATE_P true, do a float-to-integer conversion with truncation,\n+   otherwise round.  GNAT_NODE is the GNAT node conveying the source location\n+   for which the error should be signaled.  */\n \n static tree\n-convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n-\t\t    bool rangep, bool truncatep, Node_Id gnat_node)\n+convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflow_p,\n+\t\t    bool range_p, bool truncate_p, Node_Id gnat_node)\n {\n   tree gnu_type = get_unpadded_type (gnat_type);\n-  tree gnu_in_type = TREE_TYPE (gnu_expr);\n-  tree gnu_in_basetype = get_base_type (gnu_in_type);\n   tree gnu_base_type = get_base_type (gnu_type);\n+  tree gnu_in_type = TREE_TYPE (gnu_expr);\n+  tree gnu_in_base_type = get_base_type (gnu_in_type);\n   tree gnu_result = gnu_expr;\n \n   /* If we are not doing any checks, the output is an integral type and the\n      input is not a floating-point type, just do the conversion.  This is\n      required for packed array types and is simpler in all cases anyway.   */\n-  if (!rangep\n-      && !overflowp\n+  if (!range_p\n+      && !overflow_p\n       && INTEGRAL_TYPE_P (gnu_base_type)\n-      && !FLOAT_TYPE_P (gnu_in_type))\n+      && !FLOAT_TYPE_P (gnu_in_base_type))\n     return convert (gnu_type, gnu_expr);\n \n-  /* First convert the expression to its base type.  This\n-     will never generate code, but makes the tests below much simpler.\n-     But don't do this if converting from an integer type to an unconstrained\n-     array type since then we need to get the bounds from the original\n-     (unpacked) type.  */\n+  /* If the mode of the input base type is larger, then converting to it below\n+     may pessimize the final conversion step, for example generate a libcall\n+     instead of a simple instruction, so use a narrower type in this case.  */\n+  if (TYPE_MODE (gnu_in_base_type) != TYPE_MODE (gnu_in_type)\n+      && !(TREE_CODE (gnu_in_type) == INTEGER_TYPE\n+\t   && TYPE_BIASED_REPRESENTATION_P (gnu_in_type)))\n+    gnu_in_base_type = gnat_type_for_mode (TYPE_MODE (gnu_in_type),\n+\t\t\t\t\t   TYPE_UNSIGNED (gnu_in_type));\n+\n+  /* First convert the expression to the base type.  This will never generate\n+     code, but makes the tests below simpler.  But don't do this if converting\n+     from an integer type to an unconstrained array type since then we need to\n+     get the bounds from the original (unpacked) type.  */\n   if (TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE)\n-    gnu_result = convert (gnu_in_basetype, gnu_result);\n+    gnu_result = convert (gnu_in_base_type, gnu_result);\n \n-  /* If overflow checks are requested,  we need to be sure the result will\n-     fit in the output base type.  But don't do this if the input\n-     is integer and the output floating-point.  */\n-  if (overflowp\n-      && !(FLOAT_TYPE_P (gnu_base_type) && INTEGRAL_TYPE_P (gnu_in_basetype)))\n+  /* If overflow checks are requested,  we need to be sure the result will fit\n+     in the output base type.  But don't do this if the input is integer and\n+     the output floating-point.  */\n+  if (overflow_p\n+      && !(FLOAT_TYPE_P (gnu_base_type) && INTEGRAL_TYPE_P (gnu_in_base_type)))\n     {\n       /* Ensure GNU_EXPR only gets evaluated once.  */\n       tree gnu_input = gnat_protect_expr (gnu_result);\n       tree gnu_cond = boolean_false_node;\n-      tree gnu_in_lb = TYPE_MIN_VALUE (gnu_in_basetype);\n-      tree gnu_in_ub = TYPE_MAX_VALUE (gnu_in_basetype);\n+      tree gnu_in_lb = TYPE_MIN_VALUE (gnu_in_base_type);\n+      tree gnu_in_ub = TYPE_MAX_VALUE (gnu_in_base_type);\n       tree gnu_out_lb = TYPE_MIN_VALUE (gnu_base_type);\n       tree gnu_out_ub = TYPE_MAX_VALUE (gnu_base_type);\n \n       /* Convert the lower bounds to signed types, so we're sure we're\n \t comparing them properly.  Likewise, convert the upper bounds\n \t to unsigned types.  */\n-      if (INTEGRAL_TYPE_P (gnu_in_basetype) && TYPE_UNSIGNED (gnu_in_basetype))\n+      if (INTEGRAL_TYPE_P (gnu_in_base_type)\n+\t  && TYPE_UNSIGNED (gnu_in_base_type))\n \tgnu_in_lb\n-\t  = convert (gnat_signed_type_for (gnu_in_basetype), gnu_in_lb);\n+\t  = convert (gnat_signed_type_for (gnu_in_base_type), gnu_in_lb);\n \n-      if (INTEGRAL_TYPE_P (gnu_in_basetype)\n-\t  && !TYPE_UNSIGNED (gnu_in_basetype))\n+      if (INTEGRAL_TYPE_P (gnu_in_base_type)\n+\t  && !TYPE_UNSIGNED (gnu_in_base_type))\n \tgnu_in_ub\n-\t  = convert (gnat_unsigned_type_for (gnu_in_basetype), gnu_in_ub);\n+\t  = convert (gnat_unsigned_type_for (gnu_in_base_type), gnu_in_ub);\n \n       if (INTEGRAL_TYPE_P (gnu_base_type) && TYPE_UNSIGNED (gnu_base_type))\n \tgnu_out_lb\n@@ -9328,7 +9336,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t Note that we have to do the comparison which would *fail* in the\n \t case of an error since if it's an FP comparison and one of the\n \t values is a NaN or Inf, the comparison will fail.  */\n-      if (INTEGRAL_TYPE_P (gnu_in_basetype)\n+      if (INTEGRAL_TYPE_P (gnu_in_base_type)\n \t  ? tree_int_cst_lt (gnu_in_lb, gnu_out_lb)\n \t  : (FLOAT_TYPE_P (gnu_base_type)\n \t     ? real_less (&TREE_REAL_CST (gnu_in_lb),\n@@ -9337,10 +9345,10 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \tgnu_cond\n \t  = invert_truthvalue\n \t    (build_binary_op (GE_EXPR, boolean_type_node,\n-\t\t\t      gnu_input, convert (gnu_in_basetype,\n+\t\t\t      gnu_input, convert (gnu_in_base_type,\n \t\t\t\t\t\t  gnu_out_lb)));\n \n-      if (INTEGRAL_TYPE_P (gnu_in_basetype)\n+      if (INTEGRAL_TYPE_P (gnu_in_base_type)\n \t  ? tree_int_cst_lt (gnu_out_ub, gnu_in_ub)\n \t  : (FLOAT_TYPE_P (gnu_base_type)\n \t     ? real_less (&TREE_REAL_CST (gnu_out_ub),\n@@ -9351,7 +9359,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t\t\t     invert_truthvalue\n \t\t\t     (build_binary_op (LE_EXPR, boolean_type_node,\n \t\t\t\t\t       gnu_input,\n-\t\t\t\t\t       convert (gnu_in_basetype,\n+\t\t\t\t\t       convert (gnu_in_base_type,\n \t\t\t\t\t\t\tgnu_out_ub))));\n \n       if (!integer_zerop (gnu_cond))\n@@ -9362,8 +9370,8 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n   /* Now convert to the result base type.  If this is a non-truncating\n      float-to-integer conversion, round.  */\n   if (INTEGRAL_TYPE_P (gnu_base_type)\n-      && FLOAT_TYPE_P (gnu_in_basetype)\n-      && !truncatep)\n+      && FLOAT_TYPE_P (gnu_in_base_type)\n+      && !truncate_p)\n     {\n       REAL_VALUE_TYPE half_minus_pred_half, pred_half;\n       tree gnu_conv, gnu_zero, gnu_comp, calc_type;\n@@ -9375,7 +9383,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t precision from spoiling this property, use the widest hardware\n \t floating-point type if FP_ARITH_MAY_WIDEN is true.  */\n       calc_type\n-\t= fp_arith_may_widen ? longest_float_type_node : gnu_in_basetype;\n+\t= fp_arith_may_widen ? longest_float_type_node : gnu_in_base_type;\n \n       /* Compute the exact value calc_type'Pred (0.5) at compile time.  */\n       fmt = REAL_MODE_FORMAT (TYPE_MODE (calc_type));\n@@ -9400,7 +9408,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t to be scheduled in parallel with retrieval of the constant and\n \t conversion of the input to the calc_type (if necessary).  */\n \n-      gnu_zero = build_real (gnu_in_basetype, dconst0);\n+      gnu_zero = build_real (gnu_in_base_type, dconst0);\n       gnu_result = gnat_protect_expr (gnu_result);\n       gnu_conv = convert (calc_type, gnu_result);\n       gnu_comp\n@@ -9422,9 +9430,10 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \n   /* Finally, do the range check if requested.  Note that if the result type\n      is a modular type, the range check is actually an overflow check.  */\n-  if (rangep\n-      || (TREE_CODE (gnu_base_type) == INTEGER_TYPE\n-\t  && TYPE_MODULAR_P (gnu_base_type) && overflowp))\n+  if (range_p\n+      || (overflow_p\n+\t  && TREE_CODE (gnu_base_type) == INTEGER_TYPE\n+\t  && TYPE_MODULAR_P (gnu_base_type)))\n     gnu_result = emit_range_check (gnu_result, gnat_type, gnat_node);\n \n   return convert (gnu_type, gnu_result);"}]}