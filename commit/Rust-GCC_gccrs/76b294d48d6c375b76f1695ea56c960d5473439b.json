{"sha": "76b294d48d6c375b76f1695ea56c960d5473439b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZiMjk0ZDQ4ZDZjMzc1Yjc2ZjE2OTVlYTU2Yzk2MGQ1NDczNDM5Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-10-04T20:42:58Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-10-04T20:42:58Z"}, "message": "Implement P0091R2, Template argument deduction for class templates.\n\n* parser.c (cp_parser_simple_type_specifier): Parse class placeholder.\nUse the location of the beginning of the type-specifier.\n(cp_parser_init_declarator): Parse deduction guide.\n(cp_parser_diagnose_invalid_type_name): Mention class deduction.\n(cp_parser_type_id_1): Don't accept class placeholder as template arg.\n* cp-tree.h (CLASS_PLACEHOLDER_TEMPLATE): New.\n* decl.c (grokdeclarator): Check for uninitialized auto here.\n(start_decl_1): Not here.\n(cp_finish_decl): Or here.  Don't collapse a list when doing\nclass deduction.\n(grokfndecl): Check deduction guide scope and body.\n* error.c (dump_decl, dump_function_decl, dump_function_name):\nHandle deduction guides.\n* pt.c (make_template_placeholder, do_class_deduction): New.\n(build_deduction_guide, rewrite_template_parm): New.\n(dguide_name, dguide_name_p, deduction_guide_p): New.\n(do_auto_deduction): Call do_class_deduction.\n(splice_late_return_type, is_auto): Handle class placeholders.\n(template_parms_level_to_args): Split from template_parms_to_args.\n(tsubst_template_parms_level): Split from tsubst_template_parms.\n* typeck2.c (build_functional_cast): Handle class placeholder.\n\nFrom-SVN: r240756", "tree": {"sha": "0984f230491f3ffe8ce6006150b0dcd48d966e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0984f230491f3ffe8ce6006150b0dcd48d966e4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76b294d48d6c375b76f1695ea56c960d5473439b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b294d48d6c375b76f1695ea56c960d5473439b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76b294d48d6c375b76f1695ea56c960d5473439b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76b294d48d6c375b76f1695ea56c960d5473439b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8ff04ff92d9d88ca84671e36600572558216eab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ff04ff92d9d88ca84671e36600572558216eab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ff04ff92d9d88ca84671e36600572558216eab2"}], "stats": {"total": 859, "additions": 792, "deletions": 67}, "files": [{"sha": "3fc378ae4637cf956b7a104d74e56385ab6403fb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -1,3 +1,28 @@\n+2016-10-04  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0091R2, Template argument deduction for class templates.\n+\t* parser.c (cp_parser_simple_type_specifier): Parse class placeholder.\n+\tUse the location of the beginning of the type-specifier.\n+\t(cp_parser_init_declarator): Parse deduction guide.\n+\t(cp_parser_diagnose_invalid_type_name): Mention class deduction.\n+\t(cp_parser_type_id_1): Don't accept class placeholder as template arg.\n+\t* cp-tree.h (CLASS_PLACEHOLDER_TEMPLATE): New.\n+\t* decl.c (grokdeclarator): Check for uninitialized auto here.\n+\t(start_decl_1): Not here.\n+\t(cp_finish_decl): Or here.  Don't collapse a list when doing\n+\tclass deduction.\n+\t(grokfndecl): Check deduction guide scope and body.\n+\t* error.c (dump_decl, dump_function_decl, dump_function_name):\n+\tHandle deduction guides.\n+\t* pt.c (make_template_placeholder, do_class_deduction): New.\n+\t(build_deduction_guide, rewrite_template_parm): New.\n+\t(dguide_name, dguide_name_p, deduction_guide_p): New.\n+\t(do_auto_deduction): Call do_class_deduction.\n+\t(splice_late_return_type, is_auto): Handle class placeholders.\n+\t(template_parms_level_to_args): Split from template_parms_to_args.\n+\t(tsubst_template_parms_level): Split from tsubst_template_parms.\n+\t* typeck2.c (build_functional_cast): Handle class placeholder.\n+\n 2016-10-04  Martin Sebor  <msebor@redhat.com>\n \n \tPR c++/77804"}, {"sha": "3fbe1d96c66059c849e25c835fc57dc6fb5e0cc4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -1199,6 +1199,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define vptr_identifier\t\t\tcp_global_trees[CPTI_VPTR_IDENTIFIER]\n /* The name of the std namespace.  */\n #define std_identifier\t\t\tcp_global_trees[CPTI_STD_IDENTIFIER]\n+/* The name of a C++17 deduction guide.  */\n #define lang_name_c\t\t\tcp_global_trees[CPTI_LANG_NAME_C]\n #define lang_name_cplusplus\t\tcp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n \n@@ -5104,6 +5105,10 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define TEMPLATE_TYPE_PARAMETER_PACK(NODE) \\\n   (TEMPLATE_PARM_PARAMETER_PACK (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n \n+/* For a C++17 class deduction placeholder, the template it represents.  */\n+#define CLASS_PLACEHOLDER_TEMPLATE(NODE) \\\n+  (DECL_INITIAL (TYPE_NAME (TEMPLATE_TYPE_PARM_CHECK (NODE))))\n+\n /* Contexts in which auto deduction occurs. These flags are\n    used to control diagnostics in do_auto_deduction.  */\n \n@@ -6027,6 +6032,7 @@ extern int num_template_headers_for_class\t(tree);\n extern void check_template_variable\t\t(tree);\n extern tree make_auto\t\t\t\t(void);\n extern tree make_decltype_auto\t\t\t(void);\n+extern tree make_template_placeholder\t\t(tree);\n extern tree do_auto_deduction                   (tree, tree, tree);\n extern tree do_auto_deduction                   (tree, tree, tree,\n                                                  tsubst_flags_t,\n@@ -6158,6 +6164,9 @@ extern void register_local_specialization       (tree, tree);\n extern tree retrieve_local_specialization       (tree);\n extern tree extract_fnparm_pack                 (tree, tree *);\n extern tree template_parm_to_arg                (tree);\n+extern tree dguide_name\t\t\t\t(tree);\n+extern bool dguide_name_p\t\t\t(tree);\n+extern bool deduction_guide_p\t\t\t(tree);\n \n /* in repo.c */\n extern void init_repo\t\t\t\t(void);"}, {"sha": "6646062e6723eeef84cfd8c45c77926d2e65686c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -5140,7 +5140,7 @@ start_decl_1 (tree decl, bool initialized)\n   else if (aggregate_definition_p && !complete_p)\n     {\n       if (type_uses_auto (type))\n-\terror (\"declaration of %q#D has no initializer\", decl);\n+\tgcc_unreachable ();\n       else\n \terror (\"aggregate %q#D has incomplete type and cannot be defined\",\n \t       decl);\n@@ -6695,12 +6695,11 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t      return;\n \t    }\n \n-\t  error (\"declaration of %q#D has no initializer\", decl);\n-\t  TREE_TYPE (decl) = error_mark_node;\n-\t  return;\n+\t  gcc_unreachable ();\n \t}\n       d_init = init;\n-      if (TREE_CODE (d_init) == TREE_LIST)\n+      if (TREE_CODE (d_init) == TREE_LIST\n+\t  && !CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n \td_init = build_x_compound_expr_from_list (d_init, ELK_INIT,\n \t\t\t\t\t\t  tf_warning_or_error);\n       d_init = resolve_nondeduced_context (d_init, tf_warning_or_error);\n@@ -8182,7 +8181,27 @@ grokfndecl (tree ctype,\n \t}\n     }\n \n-  if (IDENTIFIER_OPNAME_P (DECL_NAME (decl))\n+  if (deduction_guide_p (decl))\n+    {\n+      if (!DECL_NAMESPACE_SCOPE_P (decl))\n+\t{\n+\t  error_at (location, \"deduction guide %qD must be declared at \"\n+\t\t    \"namespace scope\", decl);\n+\t  return NULL_TREE;\n+\t}\n+      tree type = TREE_TYPE (DECL_NAME (decl));\n+      if (CP_DECL_CONTEXT (decl) != CP_TYPE_CONTEXT (type))\n+\t{\n+\t  error_at (location, \"deduction guide %qD must be declared in the \"\n+\t\t    \"same scope as %qT\", decl, type);\n+\t  inform (location_of (type), \"  declared here\");\n+\t  return NULL_TREE;\n+\t}\n+      if (funcdef_flag)\n+\terror_at (location,\n+\t\t  \"deduction guide %qD must not have a function body\", decl);\n+    }\n+  else if (IDENTIFIER_OPNAME_P (DECL_NAME (decl))\n       && !grok_op_properties (decl, /*complain=*/true))\n     return NULL_TREE;\n   else if (UDLIT_OPER_P (DECL_NAME (decl)))\n@@ -11063,12 +11082,19 @@ grokdeclarator (const cp_declarator *declarator,\n       }\n     else if (decl_context == FIELD)\n       {\n-\tif (!staticp && !friendp && TREE_CODE (type) != METHOD_TYPE\n-\t    && type_uses_auto (type))\n-\t  {\n-\t    error (\"non-static data member declared %<auto%>\");\n-\t    type = error_mark_node;\n-\t  }\n+\tif (!staticp && !friendp && TREE_CODE (type) != METHOD_TYPE)\n+\t  if (tree auto_node = type_uses_auto (type))\n+\t    {\n+\t      location_t loc = declspecs->locations[ds_type_spec];\n+\t      if (CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n+\t\terror_at (loc, \"invalid use of template-name %qE without an \"\n+\t\t\t  \"argument list\",\n+\t\t\t  CLASS_PLACEHOLDER_TEMPLATE (auto_node));\n+\t      else\n+\t\terror_at (loc, \"non-static data member declared with \"\n+\t\t\t  \"placeholder %qT\", auto_node);\n+\t      type = error_mark_node;\n+\t    }\n \n \t/* The C99 flexible array extension.  */\n \tif (!staticp && TREE_CODE (type) == ARRAY_TYPE\n@@ -11543,6 +11569,22 @@ grokdeclarator (const cp_declarator *declarator,\n \t  }\n       }\n \n+    if (VAR_P (decl) && !initialized)\n+      if (tree auto_node = type_uses_auto (type))\n+\t{\n+\t  location_t loc = declspecs->locations[ds_type_spec];\n+\t  if (tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n+\t    {\n+\t      error_at (loc, \"invalid use of template-name %qE without an \"\n+\t\t\t\"argument list\", tmpl);\n+\t      inform (loc, \"class template argument deduction \"\n+\t\t      \"requires an initializer\");\n+\t    }\n+\t  else\n+\t    error_at (loc, \"declaration of %q#D has no initializer\", decl);\n+\t  TREE_TYPE (decl) = error_mark_node;\n+\t}\n+\n     if (storage_class == sc_extern && initialized && !funcdef_flag)\n       {\n \tif (toplevel_bindings_p ())"}, {"sha": "20b20b48e9689fc7e929cc4fca51537887bbfc9f", "filename": "gcc/cp/error.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -1159,6 +1159,9 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n \t  dump_type (pp, TREE_TYPE (t), flags);\n \t  break;\n \t}\n+      else if (dguide_name_p (t))\n+\tdump_decl (pp, CLASSTYPE_TI_TEMPLATE (TREE_TYPE (t)),\n+\t\t   TFF_PLAIN_IDENTIFIER);\n       else\n \tpp_cxx_tree_identifier (pp, t);\n       break;\n@@ -1552,8 +1555,8 @@ dump_function_decl (cxx_pretty_printer *pp, tree t, int flags)\n \n   /* Print the return type?  */\n   if (show_return)\n-    show_return = !DECL_CONV_FN_P (t)  && !DECL_CONSTRUCTOR_P (t)\n-\t\t  && !DECL_DESTRUCTOR_P (t);\n+    show_return = (!DECL_CONV_FN_P (t)  && !DECL_CONSTRUCTOR_P (t)\n+\t\t   && !DECL_DESTRUCTOR_P (t) && !deduction_guide_p (t));\n   if (show_return)\n     {\n       tree ret = fndecl_declared_return_type (t);\n@@ -1598,6 +1601,11 @@ dump_function_decl (cxx_pretty_printer *pp, tree t, int flags)\n \n       if (show_return)\n \tdump_type_suffix (pp, TREE_TYPE (fntype), flags);\n+      else if (deduction_guide_p (t))\n+\t{\n+\t  pp_cxx_ws_string (pp, \"->\");\n+\t  dump_type (pp, TREE_TYPE (TREE_TYPE (t)), flags);\n+\t}\n \n       if (flag_concepts)\n         if (tree ci = get_constraints (t))\n@@ -1767,10 +1775,6 @@ dump_function_name (cxx_pretty_printer *pp, tree t, int flags)\n       pp_cxx_ws_string (pp, \"operator\");\n       dump_type (pp, TREE_TYPE (TREE_TYPE (t)), flags);\n     }\n-  else if (name && IDENTIFIER_OPNAME_P (name))\n-    pp_cxx_tree_identifier (pp, name);\n-  else if (name && UDLIT_OPER_P (name))\n-    pp_cxx_tree_identifier (pp, name);\n   else\n     dump_decl (pp, name, flags);\n "}, {"sha": "683a6dda924d386427ffcc27601fe724fa3596bc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 97, "deletions": 6, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -3155,6 +3155,9 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree id,\n       error_at (location,\n \t\t\"invalid use of template-name %qE without an argument list\",\n \t\tdecl);\n+      if (DECL_CLASS_TEMPLATE_P (decl) && cxx_dialect < cxx1z)\n+\tinform (location, \"class template argument deduction is only available \"\n+\t\t\"with -std=c++1z or -std=gnu++1z\");\n       inform (DECL_SOURCE_LOCATION (decl), \"%qD declared here\", decl);\n     }\n   else if (TREE_CODE (id) == BIT_NOT_EXPR)\n@@ -12224,6 +12227,9 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n      linkage-specification\n      namespace-definition\n \n+   C++17:\n+     deduction-guide\n+\n    GNU extension:\n \n    declaration:\n@@ -16150,7 +16156,7 @@ cp_parser_type_specifier (cp_parser* parser,\n      double\n      void\n \n-   C++0x Extension:\n+   C++11 Extension:\n \n    simple-type-specifier:\n      auto\n@@ -16159,6 +16165,10 @@ cp_parser_type_specifier (cp_parser* parser,\n      char32_t\n      __underlying_type ( type-id )\n \n+   C++17 extension:\n+\n+     nested-name-specifier(opt) template-name\n+\n    GNU Extension:\n \n    simple-type-specifier:\n@@ -16429,9 +16439,11 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \n       /* Don't gobble tokens or issue error messages if this is an\n \t optional type-specifier.  */\n-      if (flags & CP_PARSER_FLAGS_OPTIONAL)\n+      if ((flags & CP_PARSER_FLAGS_OPTIONAL) || cxx_dialect >= cxx1z)\n \tcp_parser_parse_tentatively (parser);\n \n+      token = cp_lexer_peek_token (parser->lexer);\n+\n       /* Look for the optional `::' operator.  */\n       global_p\n \t= (cp_parser_global_scope_opt (parser,\n@@ -16445,7 +16457,6 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t\t\t\t\t\t/*type_p=*/false,\n \t\t\t\t\t\t/*is_declaration=*/false)\n \t   != NULL_TREE);\n-      token = cp_lexer_peek_token (parser->lexer);\n       /* If we have seen a nested-name-specifier, and the next token\n \t is `template', then we are using the template-id production.  */\n       if (parser->scope\n@@ -16476,9 +16487,50 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t  && identifier_p (DECL_NAME (type)))\n \tmaybe_note_name_used_in_class (DECL_NAME (type), type);\n       /* If it didn't work out, we don't have a TYPE.  */\n-      if ((flags & CP_PARSER_FLAGS_OPTIONAL)\n+      if (((flags & CP_PARSER_FLAGS_OPTIONAL) || cxx_dialect >= cxx1z)\n \t  && !cp_parser_parse_definitely (parser))\n \ttype = NULL_TREE;\n+      if (!type && cxx_dialect >= cxx1z)\n+\t{\n+\t  if (flags & CP_PARSER_FLAGS_OPTIONAL)\n+\t    cp_parser_parse_tentatively (parser);\n+\n+\t  cp_parser_global_scope_opt (parser,\n+\t\t\t\t      /*current_scope_valid_p=*/false);\n+\t  cp_parser_nested_name_specifier_opt (parser,\n+\t\t\t\t\t       /*typename_keyword_p=*/false,\n+\t\t\t\t\t       /*check_dependency_p=*/true,\n+\t\t\t\t\t       /*type_p=*/false,\n+\t\t\t\t\t       /*is_declaration=*/false);\n+\t  tree name = cp_parser_identifier (parser);\n+\t  if (name && TREE_CODE (name) == IDENTIFIER_NODE\n+\t      && parser->scope != error_mark_node)\n+\t    {\n+\t      tree tmpl = cp_parser_lookup_name (parser, name,\n+\t\t\t\t\t\t none_type,\n+\t\t\t\t\t\t /*is_template=*/false,\n+\t\t\t\t\t\t /*is_namespace=*/false,\n+\t\t\t\t\t\t /*check_dependency=*/true,\n+\t\t\t\t\t\t /*ambiguous_decls=*/NULL,\n+\t\t\t\t\t\t token->location);\n+\t      if (tmpl && tmpl != error_mark_node\n+\t\t  && DECL_CLASS_TEMPLATE_P (tmpl))\n+\t\ttype = make_template_placeholder (tmpl);\n+\t      else\n+\t\t{\n+\t\t  type = error_mark_node;\n+\t\t  if (!cp_parser_simulate_error (parser))\n+\t\t    cp_parser_name_lookup_error (parser, name, tmpl,\n+\t\t\t\t\t\t NLE_TYPE, token->location);\n+\t\t}\n+\t    }\n+\t  else\n+\t    type = error_mark_node;\n+\n+\t  if ((flags & CP_PARSER_FLAGS_OPTIONAL)\n+\t      && !cp_parser_parse_definitely (parser))\n+\t    type = NULL_TREE;\n+\t}\n       if (type && decl_specs)\n \tcp_parser_set_decl_spec_type (decl_specs, type,\n \t\t\t\t      token,\n@@ -18577,10 +18629,28 @@ cp_parser_init_declarator (cp_parser* parser,\n      declared.  */\n   resume_deferring_access_checks ();\n \n-  /* Parse the declarator.  */\n   token = cp_lexer_peek_token (parser->lexer);\n+\n+  cp_parser_declarator_kind cdk = CP_PARSER_DECLARATOR_NAMED;\n+  if (token->type == CPP_OPEN_PAREN\n+      && decl_specifiers->type\n+      && is_auto (decl_specifiers->type)\n+      && CLASS_PLACEHOLDER_TEMPLATE (decl_specifiers->type))\n+    {\n+      // C++17 deduction guide.\n+      cdk = CP_PARSER_DECLARATOR_ABSTRACT;\n+\n+      for (int i = 0; i < ds_last; ++i)\n+\tif (i != ds_type_spec\n+\t    && decl_specifiers->locations[i]\n+\t    && !cp_parser_simulate_error (parser))\n+\t  error_at (decl_specifiers->locations[i],\n+\t\t    \"decl-specifier in declaration of deduction guide\");\n+    }\n+\n+  /* Parse the declarator.  */\n   declarator\n-    = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+    = cp_parser_declarator (parser, cdk,\n \t\t\t    &ctor_dtor_or_conv_p,\n \t\t\t    /*parenthesized_p=*/NULL,\n \t\t\t    member_p, friend_p);\n@@ -18594,6 +18664,17 @@ cp_parser_init_declarator (cp_parser* parser,\n   if (declarator == cp_error_declarator)\n     return error_mark_node;\n \n+  if (cdk == CP_PARSER_DECLARATOR_ABSTRACT)\n+    {\n+      gcc_assert (declarator->kind == cdk_function\n+\t\t  && !declarator->declarator);\n+      tree t = CLASS_PLACEHOLDER_TEMPLATE (decl_specifiers->type);\n+      declarator->declarator = make_id_declarator (NULL_TREE, dguide_name (t),\n+\t\t\t\t\t\t   sfk_none);\n+      declarator->declarator->id_loc\n+\t= decl_specifiers->locations[ds_type_spec];\n+    }\n+\n   /* Check that the number of template-parameter-lists is OK.  */\n   if (!cp_parser_check_declarator_template_parameters (parser, declarator,\n \t\t\t\t\t\t       token->location))\n@@ -20118,6 +20199,16 @@ cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg,\n   cp_parser_type_specifier_seq (parser, /*is_declaration=*/false,\n \t\t\t\tis_trailing_return,\n \t\t\t\t&type_specifier_seq);\n+  if (is_template_arg && type_specifier_seq.type\n+      && TREE_CODE (type_specifier_seq.type) == TEMPLATE_TYPE_PARM\n+      && CLASS_PLACEHOLDER_TEMPLATE (type_specifier_seq.type))\n+    /* A bare template name as a template argument is a template template\n+       argument, not a placeholder, so fail parsing it as a type argument.  */\n+    {\n+      gcc_assert (cp_parser_uncommitted_to_tentative_parse_p (parser));\n+      cp_parser_simulate_error (parser);\n+      return error_mark_node;\n+    }\n   if (type_specifier_seq.type == error_mark_node)\n     return error_mark_node;\n "}, {"sha": "f92366658c9eaa2b7b9aabd880bf648f2dab4bff", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 384, "deletions": 31, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -4272,6 +4272,23 @@ template_parm_to_arg (tree t)\n   return t;\n }\n \n+/* Given a single level of template parameters (a TREE_VEC), return it\n+   as a set of template arguments.  */\n+\n+static tree\n+template_parms_level_to_args (tree parms)\n+{\n+  tree a = copy_node (parms);\n+  TREE_TYPE (a) = NULL_TREE;\n+  for (int i = TREE_VEC_LENGTH (a) - 1; i >= 0; --i)\n+    TREE_VEC_ELT (a, i) = template_parm_to_arg (TREE_VEC_ELT (a, i));\n+\n+  if (CHECKING_P)\n+    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (a, TREE_VEC_LENGTH (a));\n+\n+  return a;\n+}\n+\n /* Given a set of template parameters, return them as a set of template\n    arguments.  The template parameters are represented as a TREE_VEC, in\n    the form documented in cp-tree.h for template arguments.  */\n@@ -4292,15 +4309,7 @@ template_parms_to_args (tree parms)\n \n   for (header = parms; header; header = TREE_CHAIN (header))\n     {\n-      tree a = copy_node (TREE_VALUE (header));\n-      int i;\n-\n-      TREE_TYPE (a) = NULL_TREE;\n-      for (i = TREE_VEC_LENGTH (a) - 1; i >= 0; --i)\n-\tTREE_VEC_ELT (a, i) = template_parm_to_arg (TREE_VEC_ELT (a, i));\n-\n-      if (CHECKING_P)\n-\tSET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (a, TREE_VEC_LENGTH (a));\n+      tree a = template_parms_level_to_args (TREE_VALUE (header));\n \n       if (length > 1)\n \tTREE_VEC_ELT (args, --l) = a;\n@@ -11357,6 +11366,30 @@ tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   return t;\n }\n \n+/* Substitute ARGS into one level PARMS of template parameters.  */\n+\n+static tree\n+tsubst_template_parms_level (tree parms, tree args, tsubst_flags_t complain)\n+{\n+  if (parms == error_mark_node)\n+    return error_mark_node;\n+\n+  tree new_vec = make_tree_vec (TREE_VEC_LENGTH (parms));\n+\n+  for (int i = 0; i < TREE_VEC_LENGTH (new_vec); ++i)\n+    {\n+      tree tuple = TREE_VEC_ELT (parms, i);\n+\n+      if (tuple == error_mark_node)\n+\tcontinue;\n+\n+      TREE_VEC_ELT (new_vec, i) =\n+\ttsubst_template_parm (tuple, args, complain);\n+    }\n+\n+  return new_vec;\n+}\n+\n /* Return the result of substituting ARGS into the template parameters\n    given by PARMS.  If there are m levels of ARGS and m + n levels of\n    PARMS, then the result will contain n levels of PARMS.  For\n@@ -11381,26 +11414,8 @@ tsubst_template_parms (tree parms, tree args, tsubst_flags_t complain)\n        new_parms = &(TREE_CHAIN (*new_parms)),\n \t parms = TREE_CHAIN (parms))\n     {\n-      tree new_vec =\n-\tmake_tree_vec (TREE_VEC_LENGTH (TREE_VALUE (parms)));\n-      int i;\n-\n-      for (i = 0; i < TREE_VEC_LENGTH (new_vec); ++i)\n-\t{\n-          tree tuple;\n-\n-          if (parms == error_mark_node)\n-            continue;\n-\n-          tuple = TREE_VEC_ELT (TREE_VALUE (parms), i);\n-\n-          if (tuple == error_mark_node)\n-            continue;\n-\n-\t  TREE_VEC_ELT (new_vec, i) =\n-\t    tsubst_template_parm (tuple, args, complain);\n-\t}\n-\n+      tree new_vec = tsubst_template_parms_level (TREE_VALUE (parms),\n+\t\t\t\t\t\t  args, complain);\n       *new_parms =\n \ttree_cons (size_int (TMPL_PARMS_DEPTH (parms)\n \t\t\t     - TMPL_ARGS_DEPTH (args)),\n@@ -23940,6 +23955,16 @@ make_auto (void)\n   return make_auto_1 (get_identifier (\"auto\"), true);\n }\n \n+/* Return a C++17 deduction placeholder for class template TMPL.  */\n+\n+tree\n+make_template_placeholder (tree tmpl)\n+{\n+  tree t = make_auto_1 (DECL_NAME (tmpl), true);\n+  CLASS_PLACEHOLDER_TEMPLATE (t) = tmpl;\n+  return t;\n+}\n+\n /* Make a \"constrained auto\" type-specifier. This is an\n    auto type with constraints that must be associated after\n    deduction.  The constraint is formed from the given\n@@ -24097,6 +24122,316 @@ extract_autos (tree type)\n   return tree_vec;\n }\n \n+/* The stem for deduction guide names.  */\n+const char *const dguide_base = \"__dguide_\";\n+\n+/* Return the name for a deduction guide for class template TMPL.  */\n+\n+tree\n+dguide_name (tree tmpl)\n+{\n+  tree type = (TYPE_P (tmpl) ? tmpl : TREE_TYPE (tmpl));\n+  tree tname = TYPE_IDENTIFIER (type);\n+  char *buf = (char *) alloca (1 + strlen (dguide_base)\n+\t\t\t       + IDENTIFIER_LENGTH (tname));\n+  memcpy (buf, dguide_base, strlen (dguide_base));\n+  memcpy (buf + strlen (dguide_base), IDENTIFIER_POINTER (tname),\n+\t  IDENTIFIER_LENGTH (tname) + 1);\n+  tree dname = get_identifier (buf);\n+  TREE_TYPE (dname) = type;\n+  return dname;\n+}\n+\n+/* True if NAME is the name of a deduction guide.  */\n+\n+bool\n+dguide_name_p (tree name)\n+{\n+  return (TREE_TYPE (name)\n+\t  && !strncmp (IDENTIFIER_POINTER (name), dguide_base,\n+\t\t       strlen (dguide_base)));\n+}\n+\n+/* True if FN is a deduction guide.  */\n+\n+bool\n+deduction_guide_p (tree fn)\n+{\n+  if (tree name = DECL_NAME (fn))\n+    return dguide_name_p (name);\n+  return false;\n+}\n+\n+/* OLDDECL is a _DECL for a template parameter.  Return a similar parameter at\n+   LEVEL:INDEX, using tsubst_args and complain for substitution into non-type\n+   template parameter types.  Note that the handling of template template\n+   parameters relies on current_template_parms being set appropriately for the\n+   new template.  */\n+\n+static tree\n+rewrite_template_parm (tree olddecl, unsigned index, unsigned level,\n+\t\t       tree tsubst_args, tsubst_flags_t complain)\n+{\n+  tree oldidx = get_template_parm_index (olddecl);\n+\n+  tree newtype;\n+  if (TREE_CODE (olddecl) == TYPE_DECL\n+      || TREE_CODE (olddecl) == TEMPLATE_DECL)\n+    {\n+      newtype = copy_type (TREE_TYPE (olddecl));\n+      TYPE_MAIN_VARIANT (newtype) = newtype;\n+    }\n+  else\n+    newtype = tsubst (TREE_TYPE (olddecl), tsubst_args,\n+\t\t      complain, NULL_TREE);\n+\n+  tree newdecl\n+    = build_decl (DECL_SOURCE_LOCATION (olddecl), TREE_CODE (olddecl),\n+\t\t  DECL_NAME (olddecl), newtype);\n+  SET_DECL_TEMPLATE_PARM_P (newdecl);\n+\n+  tree newidx;\n+  if (TREE_CODE (olddecl) == TYPE_DECL\n+      || TREE_CODE (olddecl) == TEMPLATE_DECL)\n+    {\n+      newidx = TEMPLATE_TYPE_PARM_INDEX (newtype)\n+\t= build_template_parm_index (index, level, level,\n+\t\t\t\t     newdecl, newtype);\n+      TYPE_STUB_DECL (newtype) = TYPE_NAME (newtype) = newdecl;\n+      TYPE_CANONICAL (newtype) = canonical_type_parameter (newtype);\n+\n+      if (TREE_CODE (olddecl) == TEMPLATE_DECL)\n+\t{\n+\t  DECL_TEMPLATE_RESULT (newdecl)\n+\t    = build_decl (DECL_SOURCE_LOCATION (olddecl), TYPE_DECL,\n+\t\t\t  DECL_NAME (olddecl), newtype);\n+\t  DECL_ARTIFICIAL (DECL_TEMPLATE_RESULT (newdecl)) = true;\n+\t  // First create a copy (ttargs) of tsubst_args with an\n+\t  // additional level for the template template parameter's own\n+\t  // template parameters (ttparms).\n+\t  tree ttparms = (INNERMOST_TEMPLATE_PARMS\n+\t\t\t  (DECL_TEMPLATE_PARMS (olddecl)));\n+\t  const int depth = TMPL_ARGS_DEPTH (tsubst_args);\n+\t  tree ttargs = make_tree_vec (depth + 1);\n+\t  for (int i = 0; i < depth; ++i)\n+\t    TREE_VEC_ELT (ttargs, i) = TREE_VEC_ELT (tsubst_args, i);\n+\t  TREE_VEC_ELT (ttargs, depth)\n+\t    = template_parms_level_to_args (ttparms);\n+\t  // Substitute ttargs into ttparms to fix references to\n+\t  // other template parameters.\n+\t  ttparms = tsubst_template_parms_level (ttparms, ttargs,\n+\t\t\t\t\t\t complain);\n+\t  // Now substitute again with args based on tparms, to reduce\n+\t  // the level of the ttparms.\n+\t  ttargs = current_template_args ();\n+\t  ttparms = tsubst_template_parms_level (ttparms, ttargs,\n+\t\t\t\t\t\t complain);\n+\t  // Finally, tack the adjusted parms onto tparms.\n+\t  ttparms = tree_cons (size_int (depth), ttparms,\n+\t\t\t       current_template_parms);\n+\t  DECL_TEMPLATE_PARMS (newdecl) = ttparms;\n+\t}\n+    }\n+  else\n+    {\n+      tree oldconst = TEMPLATE_PARM_DECL (oldidx);\n+      tree newconst\n+\t= build_decl (DECL_SOURCE_LOCATION (oldconst),\n+\t\t      TREE_CODE (oldconst),\n+\t\t      DECL_NAME (oldconst), newtype);\n+      TREE_CONSTANT (newconst) = TREE_CONSTANT (newdecl)\n+\t= TREE_READONLY (newconst) = TREE_READONLY (newdecl) = true;\n+      SET_DECL_TEMPLATE_PARM_P (newconst);\n+      newidx = build_template_parm_index (index, level, level,\n+\t\t\t\t\t  newconst, newtype);\n+      DECL_INITIAL (newdecl) = DECL_INITIAL (newconst) = newidx;\n+    }\n+\n+  TEMPLATE_PARM_PARAMETER_PACK (newidx)\n+    = TEMPLATE_PARM_PARAMETER_PACK (oldidx);\n+  return newdecl;\n+}\n+\n+/* Returns a C++17 class deduction guide template based on the constructor\n+   CTOR.  */\n+\n+static tree\n+build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n+{\n+  if (outer_args)\n+    ctor = tsubst (ctor, outer_args, complain, ctor);\n+  tree type = DECL_CONTEXT (ctor);\n+  tree fn_tmpl;\n+  if (TREE_CODE (ctor) == TEMPLATE_DECL)\n+    {\n+      fn_tmpl = ctor;\n+      ctor = DECL_TEMPLATE_RESULT (fn_tmpl);\n+    }\n+  else\n+    fn_tmpl = DECL_TI_TEMPLATE (ctor);\n+\n+  tree tparms = DECL_TEMPLATE_PARMS (fn_tmpl);\n+  /* If type is a member class template, DECL_TI_ARGS (ctor) will have fully\n+     specialized args for the enclosing class.  Strip those off, as the\n+     deduction guide won't have those template parameters.  */\n+  tree targs = get_innermost_template_args (DECL_TI_ARGS (ctor),\n+\t\t\t\t\t    TMPL_PARMS_DEPTH (tparms));\n+  /* Discard the 'this' parameter.  */\n+  tree fparms = FUNCTION_ARG_CHAIN (ctor);\n+  tree fargs = TREE_CHAIN (DECL_ARGUMENTS (ctor));\n+  tree ci = get_constraints (ctor);\n+\n+  if (PRIMARY_TEMPLATE_P (fn_tmpl))\n+    {\n+      /* For a member template constructor, we need to flatten the two template\n+\t parameter lists into one, and then adjust the function signature\n+\t accordingly.  This gets...complicated.  */\n+      ++processing_template_decl;\n+      tree save_parms = current_template_parms;\n+\n+      /* For a member template we should have two levels of parms/args, one for\n+\t the class and one for the constructor.  We stripped specialized args\n+\t for further enclosing classes above.  */\n+      const int depth = 2;\n+      gcc_assert (TMPL_ARGS_DEPTH (targs) == depth);\n+\n+      /* Template args for translating references to the two-level template\n+\t parameters into references to the one-level template parameters we are\n+\t creating.  */\n+      tree tsubst_args = copy_node (targs);\n+      TMPL_ARGS_LEVEL (tsubst_args, depth)\n+\t= copy_node (TMPL_ARGS_LEVEL (tsubst_args, depth));\n+\n+      /* Template parms for the constructor template.  */\n+      tree ftparms = TREE_VALUE (tparms);\n+      unsigned flen = TREE_VEC_LENGTH (ftparms);\n+      /* Template parms for the class template.  */\n+      tparms = TREE_CHAIN (tparms);\n+      tree ctparms = TREE_VALUE (tparms);\n+      unsigned clen = TREE_VEC_LENGTH (ctparms);\n+      /* Template parms for the deduction guide start as a copy of the template\n+\t parms for the class.  We set current_template_parms for\n+\t lookup_template_class_1.  */\n+      current_template_parms = tparms = copy_node (tparms);\n+      tree new_vec = TREE_VALUE (tparms) = make_tree_vec (flen + clen);\n+      for (unsigned i = 0; i < clen; ++i)\n+\tTREE_VEC_ELT (new_vec, i) = TREE_VEC_ELT (ctparms, i);\n+\n+      /* Now we need to rewrite the constructor parms to append them to the\n+\t class parms.  */\n+      for (unsigned i = 0; i < flen; ++i)\n+\t{\n+\t  unsigned index = i + clen;\n+\t  unsigned level = 1;\n+\t  tree oldelt = TREE_VEC_ELT (ftparms, i);\n+\t  tree olddecl = TREE_VALUE (oldelt);\n+\t  tree newdecl = rewrite_template_parm (olddecl, index, level,\n+\t\t\t\t\t\ttsubst_args, complain);\n+\t  tree newdef = tsubst_template_arg (TREE_PURPOSE (oldelt),\n+\t\t\t\t\t     tsubst_args, complain, ctor);\n+\t  tree list = build_tree_list (newdef, newdecl);\n+\t  TEMPLATE_PARM_CONSTRAINTS (list)\n+\t    = tsubst_constraint_info (TEMPLATE_PARM_CONSTRAINTS (oldelt),\n+\t\t\t\t      tsubst_args, complain, ctor);\n+\t  TREE_VEC_ELT (new_vec, index) = list;\n+\t  TMPL_ARG (tsubst_args, depth, i) = template_parm_to_arg (list);\n+\t}\n+\n+      /* Now we have a final set of template parms to substitute into the\n+\t function signature.  */\n+      targs = template_parms_to_args (tparms);\n+      fparms = tsubst (fparms, tsubst_args, complain, ctor);\n+      fargs = tsubst (fargs, tsubst_args, complain, ctor);\n+      if (ci)\n+\tci = tsubst_constraint_info (ci, tsubst_args, complain, ctor);\n+\n+      current_template_parms = save_parms;\n+      --processing_template_decl;\n+    }\n+\n+  tree fntype = build_function_type (type, fparms);\n+  tree ded_fn = build_lang_decl_loc (DECL_SOURCE_LOCATION (ctor),\n+\t\t\t\t     FUNCTION_DECL,\n+\t\t\t\t     dguide_name (type), fntype);\n+  DECL_ARGUMENTS (ded_fn) = fargs;\n+  tree ded_tmpl = build_template_decl (ded_fn, tparms, /*member*/false);\n+  DECL_TEMPLATE_RESULT (ded_tmpl) = ded_fn;\n+  TREE_TYPE (ded_tmpl) = TREE_TYPE (ded_fn);\n+  DECL_TEMPLATE_INFO (ded_fn) = build_template_info (ded_tmpl, targs);\n+  if (ci)\n+    set_constraints (ded_tmpl, ci);\n+\n+  return ded_tmpl;\n+}\n+\n+/* Deduce template arguments for the class template TMPL based on the\n+   initializer INIT, and return the resulting type.  */\n+\n+tree\n+do_class_deduction (tree tmpl, tree init, tsubst_flags_t complain)\n+{\n+  gcc_assert (DECL_CLASS_TEMPLATE_P (tmpl));\n+  tree type = TREE_TYPE (tmpl);\n+\n+  vec<tree,va_gc> *args;\n+  if (TREE_CODE (init) == TREE_LIST)\n+    args = make_tree_vector_from_list (init);\n+  else\n+    args = make_tree_vector_single (init);\n+\n+  if (args->length() == 1)\n+    {\n+      /* First try to deduce directly, since we don't have implicitly-declared\n+\t constructors yet.  */\n+      tree parms = build_tree_list (NULL_TREE, type);\n+      tree tparms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl));\n+      tree targs = make_tree_vec (TREE_VEC_LENGTH (tparms));\n+      int err = type_unification_real (tparms, targs, parms, &(*args)[0],\n+\t\t\t\t       1, /*subr*/false, DEDUCE_CALL,\n+\t\t\t\t       LOOKUP_NORMAL, NULL, /*explain*/false);\n+      if (err == 0)\n+\treturn tsubst (type, targs, complain, tmpl);\n+    }\n+\n+  tree dname = dguide_name (tmpl);\n+  tree cands = lookup_qualified_name (CP_DECL_CONTEXT (tmpl), dname,\n+\t\t\t\t      /*type*/false, /*complain*/false,\n+\t\t\t\t      /*hidden*/false);\n+  if (cands == error_mark_node)\n+    cands = NULL_TREE;\n+\n+  tree outer_args = NULL_TREE;\n+  if (DECL_CLASS_SCOPE_P (tmpl)\n+      && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (tmpl)))\n+    {\n+      outer_args = CLASSTYPE_TI_ARGS (DECL_CONTEXT (tmpl));\n+      type = TREE_TYPE (most_general_template (tmpl));\n+    }\n+\n+  if (CLASSTYPE_METHOD_VEC (type))\n+    // FIXME cache artificial deduction guides\n+    for (tree fns = CLASSTYPE_CONSTRUCTORS (type); fns; fns = OVL_NEXT (fns))\n+      {\n+\ttree fn = OVL_CURRENT (fns);\n+\ttree guide = build_deduction_guide (fn, outer_args, complain);\n+\tcands = ovl_cons (guide, cands);\n+      }\n+\n+  if (cands == NULL_TREE)\n+    {\n+      error (\"cannot deduce template arguments for %qT, as it has \"\n+\t     \"no deduction guides or user-declared constructors\", type);\n+      return error_mark_node;\n+    }\n+\n+  tree t = build_new_function_call (cands, &args, /*koenig*/false,\n+\t\t\t\t    complain|tf_decltype);\n+\n+  release_tree_vector (args);\n+\n+  return TREE_TYPE (t);\n+}\n+\n /* Replace occurrences of 'auto' in TYPE with the appropriate type deduced\n    from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.  */\n \n@@ -24175,6 +24510,9 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \t  return error_mark_node;\n \t}\n     }\n+  else if (tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n+    /* C++17 class template argument deduction.  */\n+    return do_class_deduction (tmpl, init, complain);\n   else\n     {\n       tree parms = build_tree_list (NULL_TREE, type);\n@@ -24274,6 +24612,20 @@ splice_late_return_type (tree type, tree late_return_type)\n {\n   if (is_auto (type))\n     {\n+      if (tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (type))\n+\t{\n+\t  if (!late_return_type)\n+\t    error (\"deduction guide must have trailing return type\");\n+\t  else if (CLASS_TYPE_P (late_return_type)\n+\t\t   && CLASSTYPE_TEMPLATE_INFO (late_return_type)\n+\t\t   && CLASSTYPE_TI_TEMPLATE (late_return_type) == tmpl)\n+\t    /* OK */;\n+\t  else\n+\t    error (\"trailing return type %qT of deduction guide is not \"\n+\t\t   \"a specialization of %qT\",\n+\t\t   late_return_type, TREE_TYPE (tmpl));\n+\t}\n+\n       if (late_return_type)\n \treturn late_return_type;\n \n@@ -24288,14 +24640,15 @@ splice_late_return_type (tree type, tree late_return_type)\n }\n \n /* Returns true iff TYPE is a TEMPLATE_TYPE_PARM representing 'auto' or\n-   'decltype(auto)'.  */\n+   'decltype(auto)' or a deduced class template.  */\n \n bool\n is_auto (const_tree type)\n {\n   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n       && (TYPE_IDENTIFIER (type) == get_identifier (\"auto\")\n-\t  || TYPE_IDENTIFIER (type) == get_identifier (\"decltype(auto)\")))\n+\t  || TYPE_IDENTIFIER (type) == get_identifier (\"decltype(auto)\")\n+\t  || CLASS_PLACEHOLDER_TEMPLATE (type)))\n     return true;\n   else\n     return false;"}, {"sha": "a063ea3439234bf5ad3c2a2c4605f5cdc9315875", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -1952,11 +1952,23 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n       return error_mark_node;\n     }\n \n-  if (type_uses_auto (type))\n+  if (tree anode = type_uses_auto (type))\n     {\n-      if (complain & tf_error)\n-\terror (\"invalid use of %<auto%>\");\n-      return error_mark_node;\n+      if (!CLASS_PLACEHOLDER_TEMPLATE (anode))\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"invalid use of %qT\", anode);\n+\t  return error_mark_node;\n+\t}\n+      else if (!parms)\n+\t{\n+\t  if (complain & tf_error)\n+\t    error (\"cannot deduce template arguments for %qT from ()\", anode);\n+\t  return error_mark_node;\n+\t}\n+      else\n+\ttype = do_auto_deduction (type, parms, anode, complain,\n+\t\t\t\t  adc_variable_type);\n     }\n \n   if (processing_template_decl)"}, {"sha": "ad48cf838ffd2b0ccf1f8b5f33b2edf49a824a1e", "filename": "gcc/testsuite/g++.dg/concepts/class-deduction1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass-deduction1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass-deduction1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fclass-deduction1.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"-std=c++1z -fconcepts\" }\n+\n+template <class T>\n+concept bool Isint = __is_same_as(T,int);\n+\n+template <class T>\n+struct A\n+{\n+  int i;\n+  A(...);\n+};\n+\n+template <Isint I>\n+A(I) -> A<I>;\n+\n+A a(1);\n+A a2(1.0);\t\t\t// { dg-error \"\" }"}, {"sha": "b91eb945eb1f709224a0c2af1bc7c57266e83c09", "filename": "gcc/testsuite/g++.dg/concepts/var-concept5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fvar-concept5.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -10,5 +10,5 @@ concept bool C2 = true;\n template<C1 T> // { dg-error \"not a type\" }\n constexpr bool f1( )  { return true; }\n \n-template<C2<int> T> // { dg-error \"expected\" }\n+template<C2<int> T> // { dg-error \"expected|not a type\" }\n constexpr bool f2( )  { return true; }"}, {"sha": "87fced9ac38a6422a7cde41cf7d957606f247806", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction1.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  A(T);\n+};\n+\n+A a (42);"}, {"sha": "8bc4288aa7674baceab01f6dc1d93b90ab043f76", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction10.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction10.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  int i;\n+  A(...);\n+};\n+\n+template <class T>\n+A(T) -> A<T> { }\t\t// { dg-error \"1:function body\" }"}, {"sha": "4e902923b7d7db654d4899b4806e4bd5e1435704", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction11.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction11.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  int i;\n+  A(...);\n+};\n+\n+template <class T>\n+static A(T) -> A<T>;\t\t// { dg-error \"1:decl-specifier\" }"}, {"sha": "9eb541da8f9f616890b5c0ca677d05b9e91fee92", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction12.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction12.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  template<class U, template<U u> class P>\n+  A(T,U,P<42>);\n+};\n+\n+template <int I> struct B { };\n+\n+int i;\n+A a(&i,2,B<42>());\n+\n+template <class,class> class same;\n+template <class T> class same<T,T> {};\n+same<decltype(a), A<int*>> s;"}, {"sha": "0e2d2354288fde4018e66af9ae6cc4cd53e3c99b", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction13.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction13.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  template <class U>\n+  struct B\n+  {\n+    template <class V>\n+    B(T,U,V);\n+  };\n+};\n+\n+A<int>::B b(1,2.0,'\\3');\n+\n+template <class,class> class same;\n+template <class T> class same<T,T> {};\n+same<decltype(b), A<int>::B<double>> s;"}, {"sha": "736b263bcd9526f0400fd16d6c75200f0f795684", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction2.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction2.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  template <class U>\n+  A(T, U);\n+};\n+\n+A a (42, 1.0);"}, {"sha": "ed869655485b4dcf47fec6f04fd12874611b231a", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction3.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction3.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options -std=c++1z }\n+\n+template <int I>\n+struct A { };\n+\n+template <int I>\n+struct B\n+{\n+  template<template<int>class T>\n+  B(T<I>);\n+};\n+\n+A<42> a;\n+B b (a);"}, {"sha": "16c41f43c7eec314c333b38600dd1a6276e1a869", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction4.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction4.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,19 @@\n+// { dg-options -std=c++1z }\n+\n+template <int I, int J>\n+struct A { };\n+\n+template <int I>\n+struct B\n+{\n+  template<int J>\n+  B(A<I,J>);\n+};\n+\n+A<42,24> a;\n+B b (a);\n+\n+int main()\n+{\n+  (B(a));\n+}"}, {"sha": "b94a3008435165836d8700c40e849a99efdcb995", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction5.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction5.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  int i;\n+};\n+\n+A<int> a1;\n+A a(a1);"}, {"sha": "569217d754c58cece918ccef7a04a6465e31d6a4", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction6.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction6.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  int i;\n+};\n+\n+struct B : A<int> {} b;\n+\n+A a(b);"}, {"sha": "8e982b9cff2f81cba521373497f89254c3d8218f", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction7.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction7.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  int i;\n+};\n+\n+template <class T>\n+A(T);\t\t\t       // { dg-error \"must have trailing return type\" }"}, {"sha": "365831598409c26d674ea650eda0536e7a6c9054", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction8.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction8.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T>\n+struct A\n+{\n+  int i;\n+  A(...);\t\t\t// { dg-message \"candidate\" }\n+};\n+\n+A a(42);\t\t\t// { dg-error \"\" }\n+\n+template <class T>\n+A(T) -> A<T>;\n+\n+A a2(42);"}, {"sha": "5a2b4f6e1510634a1ab4e68ff7ed5c974166c3fe", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction9.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction9.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -0,0 +1,18 @@\n+// { dg-options -std=c++1z }\n+\n+namespace N {\n+  template <class T>\n+  struct A\n+  {\n+    int i;\n+    A(...);\n+  };\n+}\n+\n+template <class T>\n+N::A(T) -> N::A<T>;\t\t// { dg-error \"scope\" }\n+\n+namespace N {\n+  template <class T>\n+  A(T) -> A<T>;\n+}"}, {"sha": "d53d3177e6c98eda6ce41473a03591065c8f0927", "filename": "gcc/testsuite/g++.dg/parse/access10.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Faccess10.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -8,4 +8,4 @@ template<int> struct A\n };\n \n // Instead of the bogus error we get a different error.\n-// { dg-error \"template-name\" \"\" { target *-*-* } 7 }\n+// { dg-error \"template-name|expected\" \"\" { target *-*-* } 7 }"}, {"sha": "5c39b602de58cc3ef4e2f6fdd8d90f908cfa30a1", "filename": "gcc/testsuite/g++.dg/parse/decl-specifier-1.C", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdecl-specifier-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdecl-specifier-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdecl-specifier-1.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -5,13 +5,12 @@\n namespace N\n {\n     template<typename> \n-    struct X { };\t\t// { dg-message \"N::X\" }\n+    struct X { };\n }\n \n N::X X;                           // { dg-error \"\" \"\" }\n \n int main()\n {\n-    return sizeof(X);             // { dg-error \"\" \"\" }\n-    // { dg-message \"suggested alternative\" \"suggested alternative\" { target *-*-* } 15 }\n+    return sizeof(X);\t    // { dg-prune-output \"not declared in this scope\" }\n }"}, {"sha": "93c7defb165b19b7cab766b9d7ac13593b53f50a", "filename": "gcc/testsuite/g++.dg/parse/template2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate2.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -3,5 +3,5 @@ namespace N {\n }\n \n int main() {\n-  N::C(); // { dg-error \"template\" }\n+  N::C(); // { dg-error \"template|deduction\" }\n }"}, {"sha": "a8dae01afe2df5673746b08121fa6e584cd38ce5", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb129.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb129.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb129.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb129.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -17,7 +17,7 @@ int main()\n               find_if( l.begin(), l.end(),\n                        // This is a typo, it should be bind2nd, but an\n                        // ICE is not a very helpful diagnostic!\n-                       binder2nd( equal_to<int>(), 2 ) ); // { dg-error \"\" } \n+                       binder2nd( equal_to<int>(), 2 ) ); // { dg-error \"\" \"\" { target c++14_down } }\n       assert( *(it) == 2 );\n }\n "}, {"sha": "3150422e3c5042a5d6016fe4142035f2207ac6fd", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb129a.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb129a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76b294d48d6c375b76f1695ea56c960d5473439b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb129a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb129a.C?ref=76b294d48d6c375b76f1695ea56c960d5473439b", "patch": "@@ -16,7 +16,7 @@ int main()\n               std::find_if( l.begin(), l.end(),\n                        // This is a typo, it should be bind2nd, but an\n                        // ICE is not a very helpful diagnostic!\n-                       std::binder2nd( std::equal_to<int>(), 2 ) ); // { dg-error \"\" } \n+                       std::binder2nd( std::equal_to<int>(), 2 ) ); // { dg-error \"\" \"\" { target c++14_down } }\n       assert( *(it) == 2 );\n }\n "}]}