{"sha": "82b336287a89bc41f0e88b7a067686174219b11d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJiMzM2Mjg3YTg5YmM0MWYwZTg4YjdhMDY3Njg2MTc0MjE5YjExZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-09-12T22:55:23Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-09-12T22:55:23Z"}, "message": "re PR rtl-optimization/37377 (Bootstrap failure compiling libgcc)\n\n2008-09-12  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-opt/37377\n\t\n\t* ira-build.c (common_loop_tree_node_dominator): Remove.\n\t(copy_live_ranges_to_removed_store_destinations): New function.\n\t(regno_top_level_allocno_map): Move to top level from ...\n\t(ira_flattening): ... here.  Use\n\tcopy_live_ranges_to_removed_store_destinations.\n\n\t* ira-emit.c (generate_edge_moves): Fix a comment.\n\nFrom-SVN: r140325", "tree": {"sha": "1509936ba3ec5d5f89573c2cd6bccac4844793e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1509936ba3ec5d5f89573c2cd6bccac4844793e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82b336287a89bc41f0e88b7a067686174219b11d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b336287a89bc41f0e88b7a067686174219b11d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82b336287a89bc41f0e88b7a067686174219b11d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b336287a89bc41f0e88b7a067686174219b11d/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ff5d1e44709af28c0b4982c914f1a5e3fa5a0f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff5d1e44709af28c0b4982c914f1a5e3fa5a0f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff5d1e44709af28c0b4982c914f1a5e3fa5a0f2"}], "stats": {"total": 142, "additions": 77, "deletions": 65}, "files": [{"sha": "5fd70a744c2d01160a26ebb8931e50d20cf73543", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b336287a89bc41f0e88b7a067686174219b11d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b336287a89bc41f0e88b7a067686174219b11d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82b336287a89bc41f0e88b7a067686174219b11d", "patch": "@@ -1,3 +1,15 @@\n+2008-09-12  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-opt/37377\n+\t\n+\t* ira-build.c (common_loop_tree_node_dominator): Remove.\n+\t(copy_live_ranges_to_removed_store_destinations): New function.\n+\t(regno_top_level_allocno_map): Move to top level from ...\n+\t(ira_flattening): ... here.  Use\n+\tcopy_live_ranges_to_removed_store_destinations.\n+\n+\t* ira-emit.c (generate_edge_moves): Fix a comment.\n+\t\n 2008-09-12  Anatoly Sokolov  <aesok@post.ru>\n \n \tPR target/37466"}, {"sha": "fa0a39c192a8da68bef831b17d27fa6a06aabbf1", "filename": "gcc/ira-build.c", "status": "modified", "additions": 60, "deletions": 62, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b336287a89bc41f0e88b7a067686174219b11d/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b336287a89bc41f0e88b7a067686174219b11d/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=82b336287a89bc41f0e88b7a067686174219b11d", "patch": "@@ -2037,21 +2037,59 @@ create_caps (void)\n    the IR for one region but we don't do it because it takes a lot of\n    time.  */\n \n-/* This recursive function returns immediate common dominator of two\n-   loop tree nodes N1 and N2.  */\n-static ira_loop_tree_node_t\n-common_loop_tree_node_dominator (ira_loop_tree_node_t n1,\n-\t\t\t\t ira_loop_tree_node_t n2)\n-{\n-  ira_assert (n1 != NULL && n2 != NULL);\n-  if (n1 == n2)\n-    return n1;\n-  if (n1->level < n2->level)\n-    return common_loop_tree_node_dominator (n1, n2->parent);\n-  else if (n1->level > n2->level)\n-    return common_loop_tree_node_dominator (n1->parent, n2);\n-  else\n-    return common_loop_tree_node_dominator (n1->parent, n2->parent);\n+/* Map: regno -> allocnos which will finally represent the regno for\n+   IR with one region.  */\n+static ira_allocno_t *regno_top_level_allocno_map;\n+\n+/* Process all allocnos originated from pseudo REGNO and copy live\n+   ranges from low level allocnos to final allocnos which are\n+   destinations of removed stores at a loop exit.  Return true if we\n+   copied live ranges.  */\n+static bool\n+copy_live_ranges_to_removed_store_destinations (int regno)\n+{\n+  ira_allocno_t a, parent_a;\n+  ira_loop_tree_node_t parent;\n+  allocno_live_range_t r;\n+  bool merged_p;\n+\n+  merged_p = false;\n+  for (a = ira_regno_allocno_map[regno];\n+       a != NULL;\n+       a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n+    {\n+      if (a != regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))])\n+\t/* This allocno will be removed.  */\n+\tcontinue;\n+      /* Caps will be removed.  */\n+      ira_assert (ALLOCNO_CAP_MEMBER (a) == NULL);\n+      for (parent = ALLOCNO_LOOP_TREE_NODE (a)->parent;\n+\t   parent != NULL;\n+\t   parent = parent->parent)\n+\tif ((parent_a = parent->regno_allocno_map[regno]) == NULL\n+\t    || (parent_a == regno_top_level_allocno_map[REGNO (ALLOCNO_REG\n+\t\t\t\t\t\t\t       (parent_a))]\n+\t\t&& ALLOCNO_MEM_OPTIMIZED_DEST_P (parent_a)))\n+\t  break;\n+      if (parent == NULL || parent_a == NULL)\n+\tcontinue;\n+      if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n+\t{\n+\t  fprintf\n+\t    (ira_dump_file,\n+\t     \"      Coping ranges of a%dr%d to a%dr%d: \",\n+\t     ALLOCNO_NUM (a), REGNO (ALLOCNO_REG (a)),\n+\t     ALLOCNO_NUM (parent_a), REGNO (ALLOCNO_REG (parent_a)));\n+\t  ira_print_live_range_list (ira_dump_file,\n+\t\t\t\t     ALLOCNO_LIVE_RANGES (a));\n+\t}\n+      r = copy_allocno_live_range_list (ALLOCNO_LIVE_RANGES (a));\n+      change_allocno_in_range_list (r, parent_a);\n+      ALLOCNO_LIVE_RANGES (parent_a)\n+\t= merge_ranges (r, ALLOCNO_LIVE_RANGES (parent_a));\n+      merged_p = true;\n+    }\n+  return merged_p;\n }\n \n /* Flatten the IR.  In other words, this function transforms IR as if\n@@ -2066,20 +2104,16 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n   int i, j, num;\n   bool propagate_p, stop_p, keep_p;\n   int hard_regs_num;\n-  bool new_pseudos_p, merged_p;\n+  bool new_pseudos_p, merged_p, mem_dest_p;\n   unsigned int n;\n   enum reg_class cover_class;\n   ira_allocno_t a, parent_a, first, second, node_first, node_second;\n-  ira_allocno_t dominator_a;\n   ira_copy_t cp;\n-  ira_loop_tree_node_t parent, node, dominator;\n+  ira_loop_tree_node_t parent, node;\n   allocno_live_range_t r;\n   ira_allocno_iterator ai;\n   ira_copy_iterator ci;\n   sparseset allocnos_live;\n-  /* Map: regno -> allocnos which will finally represent the regno for\n-     IR with one region.  */\n-  ira_allocno_t *regno_top_level_allocno_map;\n   bool *allocno_propagated_p;\n \n   regno_top_level_allocno_map\n@@ -2093,7 +2127,7 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n   /* Fix final allocno attributes.  */\n   for (i = max_regno_before_emit - 1; i >= FIRST_PSEUDO_REGISTER; i--)\n     {\n-      propagate_p = false;\n+      mem_dest_p = propagate_p = false;\n       for (a = ira_regno_allocno_map[i];\n \t   a != NULL;\n \t   a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n@@ -2111,6 +2145,8 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t      continue;\n \t    }\n \t  ira_assert (ALLOCNO_CAP_MEMBER (parent_a) == NULL);\n+\t  if (ALLOCNO_MEM_OPTIMIZED_DEST (a) != NULL)\n+\t    mem_dest_p = true;\n \t  if (propagate_p)\n \t    {\n \t      if (!allocno_propagated_p [ALLOCNO_NUM (parent_a)])\n@@ -2198,49 +2234,11 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t\t\t\t  [ALLOCNO_REGNO (parent_a)])) == NULL)\n \t\tbreak;\n \t    }\n-\t  if (first != NULL)\n-\t    {\n-\t      parent_a = ALLOCNO_MEM_OPTIMIZED_DEST (first);\n-\t      dominator = common_loop_tree_node_dominator\n-\t\t          (ALLOCNO_LOOP_TREE_NODE (parent_a),\n-\t\t\t   ALLOCNO_LOOP_TREE_NODE (first));\n-\t      dominator_a = dominator->regno_allocno_map[ALLOCNO_REGNO (a)];\n-\t      ira_assert (parent_a != NULL);\n-\t      stop_p = first != a;\n-\t      /* Remember that exit can be to a grandparent (not only\n-\t\t to a parent) or a child of the grandparent.  */\n-\t      for (first = a;;)\n-\t\t{\n-\t\t  if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n-\t\t    {\n-\t\t      fprintf\n-\t\t\t(ira_dump_file,\n-\t\t\t \"      Coping ranges of a%dr%d to a%dr%d: \",\n-\t\t\t ALLOCNO_NUM (first), REGNO (ALLOCNO_REG (first)),\n-\t\t\t ALLOCNO_NUM (parent_a),\n-\t\t\t REGNO (ALLOCNO_REG (parent_a)));\n-\t\t      ira_print_live_range_list (ira_dump_file,\n-\t\t\t\t\t\t ALLOCNO_LIVE_RANGES (first));\n-\t\t    }\n-\t\t  r = copy_allocno_live_range_list (ALLOCNO_LIVE_RANGES\n-\t\t\t\t\t\t    (first));\n-\t\t  change_allocno_in_range_list (r, parent_a);\n-\t\t  ALLOCNO_LIVE_RANGES (parent_a)\n-\t\t    = merge_ranges (r, ALLOCNO_LIVE_RANGES (parent_a));\n-\t\t  merged_p = true;\n-\t\t  if (stop_p)\n-\t\t    break;\n-\t\t  parent = ALLOCNO_LOOP_TREE_NODE (first)->parent;\n-\t\t  ira_assert (parent != NULL);\n-\t\t  first = parent->regno_allocno_map[ALLOCNO_REGNO (a)];\n-\t\t  ira_assert (first != NULL);\n-\t\t  if (first == dominator_a)\n-\t\t    break;\n-\t\t}\n-\t    }\n \t  ALLOCNO_COPIES (a) = NULL;\n \t  regno_top_level_allocno_map[REGNO (ALLOCNO_REG (a))] = a;\n \t}\n+      if (mem_dest_p && copy_live_ranges_to_removed_store_destinations (i))\n+\tmerged_p = true;\n     }\n   ira_free (allocno_propagated_p);\n   ira_assert (new_pseudos_p || ira_max_point_before_emit == ira_max_point);"}, {"sha": "7fdaefb52e54d0dde5907fdcd01e6314e3347ef5", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82b336287a89bc41f0e88b7a067686174219b11d/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82b336287a89bc41f0e88b7a067686174219b11d/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=82b336287a89bc41f0e88b7a067686174219b11d", "patch": "@@ -311,9 +311,11 @@ generate_edge_moves (edge e)\n \tif (REGNO (ALLOCNO_REG (src_allocno))\n \t    == REGNO (ALLOCNO_REG (dest_allocno)))\n \t  continue;\n-\t/* Actually it is not a optimization we need this code because\n-\t   the memory (remember about equivalent memory) might be ROM\n-\t   (or placed in read only section).  */\n+\t/* Remove unnecessary stores at the region exit.  We should do\n+\t   this for readonly memory for sure and this is guaranteed by\n+\t   that we never generate moves on region borders (see\n+\t   checking ira_reg_equiv_invariant_p in function\n+\t   change_loop).  */\n  \tif (ALLOCNO_HARD_REGNO (dest_allocno) < 0\n \t    && ALLOCNO_HARD_REGNO (src_allocno) >= 0\n \t    && not_modified_p (src_allocno, dest_allocno))"}]}