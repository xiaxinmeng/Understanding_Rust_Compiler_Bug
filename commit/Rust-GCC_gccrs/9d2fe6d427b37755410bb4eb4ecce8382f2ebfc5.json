{"sha": "9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5", "node_id": "C_kwDOANBUbNoAKDlkMmZlNmQ0MjdiMzc3NTU0MTBiYjRlYjRlY2NlODM4MmYyZWJmYzU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-06-15T16:40:09Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-06-15T16:40:09Z"}, "message": "Revert recent internal-fn changes [PR105975]\n\nThe recent internal-fn \u201cclean-ups\u201d triggered problems on nvptx\nbecause some of the omp_simt_* patterns had modeless operands.\nI wondered about adapting expand_fn_using_insn to cope with that,\nbut then the problem becomes: what should the mode of operand 0\nbe when there is no lhs?  The answer depends on the target insn.\nFor GOMP_SIMT_ENTER_ALLOC the answer was: use Pmode.\nFor GOMP_SIMT_ORDERED_PRED and others the answer was: elide the call.\n(However, GOMP_SIMT_ORDERED_PRED doesn't seem to have ECF_* flags\nthat would normally allow it to be dropped at the gimple level.)\n\nSo these instructions seem to be special enough that they need\ntheir own code after all.  This patch reverts the second patch\nand most of the first.  The only part retained from the first\nis splitting expand_fn_using_insn out of expand_direct_optab_fn,\nsince I think expand_fn_using_insn could still be useful in future.\n\ngcc/\n\tPR middle-end/105975\n\tRevert everything apart from the expand_fn_using_insn and\n\texpand_direct_optab_fn changes from:\n\n\t* internal-fn.def (DEF_INTERNAL_INSN_FN): New macro.\n\t(GOMP_SIMT_ENTER_ALLOC, GOMP_SIMT_EXIT, GOMP_SIMT_LANE)\n\t(GOMP_SIMT_LAST_LANE, GOMP_SIMT_ORDERED_PRED, GOMP_SIMT_VOTE_ANY)\n\t(GOMP_SIMT_XCHG_BFLY, GOMP_SIMT_XCHG_IDX): Use it.\n\t* internal-fn.h (direct_internal_fn_info::directly_mapped): New\n\tmember variable.\n\t(direct_internal_fn_info::vectorizable): Reduce to 1 bit.\n\t(direct_internal_fn_p): Also return true for internal functions\n\tthat map directly to instructions defined target-insns.def.\n\t(direct_internal_fn): Adjust comment accordingly.\n\t* internal-fn.cc (direct_insn, optab1, optab2, vectorizable_optab1)\n\t(vectorizable_optab2): New local macros.\n\t(not_direct): Initialize directly_mapped.\n\t(mask_load_direct, load_lanes_direct, mask_load_lanes_direct)\n\t(gather_load_direct, len_load_direct, mask_store_direct)\n\t(store_lanes_direct, mask_store_lanes_direct, vec_cond_mask_direct)\n\t(vec_cond_direct, scatter_store_direct, len_store_direct)\n\t(vec_set_direct, unary_direct, binary_direct, ternary_direct)\n\t(cond_unary_direct, cond_binary_direct, cond_ternary_direct)\n\t(while_direct, fold_extract_direct, fold_left_direct)\n\t(mask_fold_left_direct, check_ptrs_direct): Use the macros above.\n\t(expand_GOMP_SIMT_ENTER_ALLOC, expand_GOMP_SIMT_EXIT): Delete\n\t(expand_GOMP_SIMT_LANE, expand_GOMP_SIMT_LAST_LANE): Likewise;\n\t(expand_GOMP_SIMT_ORDERED_PRED, expand_GOMP_SIMT_VOTE_ANY): Likewise.\n\t(expand_GOMP_SIMT_XCHG_BFLY, expand_GOMP_SIMT_XCHG_IDX): Likewise.\n\t(direct_internal_fn_types): Handle functions that map to instructions\n\tdefined in target-insns.def.\n\t(direct_internal_fn_types): Likewise.\n\t(direct_internal_fn_supported_p): Likewise.\n\t(internal_fn_expanders): Likewise.\n\n\t(expand_fn_using_insn): New function,\n\tsplit out and adapted from...\n\t(expand_direct_optab_fn): ...here.\n\t(expand_GOMP_SIMT_ENTER_ALLOC): Use it.\n\t(expand_GOMP_SIMT_EXIT): Likewise.\n\t(expand_GOMP_SIMT_LANE): Likewise.\n\t(expand_GOMP_SIMT_LAST_LANE): Likewise.\n\t(expand_GOMP_SIMT_ORDERED_PRED): Likewise.\n\t(expand_GOMP_SIMT_VOTE_ANY): Likewise.\n\t(expand_GOMP_SIMT_XCHG_BFLY): Likewise.\n\t(expand_GOMP_SIMT_XCHG_IDX): Likewise.", "tree": {"sha": "e9e00eaf8a5adbf1778bb275ba5579b520a67b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9e00eaf8a5adbf1778bb275ba5579b520a67b4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8aaa948059a8b5f0a62ad010d0aa6346b7ac9cd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aaa948059a8b5f0a62ad010d0aa6346b7ac9cd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aaa948059a8b5f0a62ad010d0aa6346b7ac9cd3"}], "stats": {"total": 293, "additions": 206, "deletions": 87}, "files": [{"sha": "91588f8bc9f7c3fe2bac17f3c4e6078cddb7b4d2", "filename": "gcc/internal-fn.cc", "status": "modified", "additions": 189, "deletions": 50, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5/gcc%2Finternal-fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5/gcc%2Finternal-fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.cc?ref=9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5", "patch": "@@ -105,44 +105,37 @@ init_internal_fns ()\n \n /* Create static initializers for the information returned by\n    direct_internal_fn.  */\n-#define not_direct\t\t\t{ -2, -2, false, false }\n-#define direct_insn\t\t\t{ -2, -2, true, false }\n-#define optab1(TYPE0)\t\t\t{ TYPE0, TYPE0, true, false }\n-#define optab2(TYPE0, TYPE1)\t\t{ TYPE0, TYPE1, true, false }\n-#define vectorizable_optab1(TYPE0)\t{ TYPE0, TYPE0, true, true }\n-\n-#define mask_load_direct\t\toptab2 (-1, 2)\n-#define load_lanes_direct\t\toptab1 (-1)\n-#define mask_load_lanes_direct\t\toptab1 (-1)\n-#define gather_load_direct\t\toptab2 (3, 1)\n-#define len_load_direct\t\t\toptab1 (-1)\n-#define mask_store_direct\t\toptab2 (3, 2)\n-#define store_lanes_direct\t\toptab1 (0)\n-#define mask_store_lanes_direct\t\toptab1 (0)\n-#define vec_cond_mask_direct\t\toptab2 (1, 0)\n-#define vec_cond_direct\t\t\toptab2 (2, 0)\n-#define scatter_store_direct\t\toptab2 (3, 1)\n-#define len_store_direct\t\toptab1 (3)\n-#define vec_set_direct\t\t\toptab1 (3)\n-#define unary_direct\t\t\tvectorizable_optab1 (0)\n-#define binary_direct\t\t\tvectorizable_optab1 (0)\n-#define ternary_direct\t\t\tvectorizable_optab1 (0)\n-#define cond_unary_direct\t\tvectorizable_optab1 (1)\n-#define cond_binary_direct\t\tvectorizable_optab1 (1)\n-#define cond_ternary_direct\t\tvectorizable_optab1 (1)\n-#define while_direct\t\t\toptab2 (0, 2)\n-#define fold_extract_direct\t\toptab1 (2)\n-#define fold_left_direct\t\toptab1 (1)\n-#define mask_fold_left_direct\t\toptab1 (1)\n-#define check_ptrs_direct\t\toptab1 (0)\n+#define not_direct { -2, -2, false }\n+#define mask_load_direct { -1, 2, false }\n+#define load_lanes_direct { -1, -1, false }\n+#define mask_load_lanes_direct { -1, -1, false }\n+#define gather_load_direct { 3, 1, false }\n+#define len_load_direct { -1, -1, false }\n+#define mask_store_direct { 3, 2, false }\n+#define store_lanes_direct { 0, 0, false }\n+#define mask_store_lanes_direct { 0, 0, false }\n+#define vec_cond_mask_direct { 1, 0, false }\n+#define vec_cond_direct { 2, 0, false }\n+#define scatter_store_direct { 3, 1, false }\n+#define len_store_direct { 3, 3, false }\n+#define vec_set_direct { 3, 3, false }\n+#define unary_direct { 0, 0, true }\n+#define binary_direct { 0, 0, true }\n+#define ternary_direct { 0, 0, true }\n+#define cond_unary_direct { 1, 1, true }\n+#define cond_binary_direct { 1, 1, true }\n+#define cond_ternary_direct { 1, 1, true }\n+#define while_direct { 0, 2, false }\n+#define fold_extract_direct { 2, 2, false }\n+#define fold_left_direct { 1, 1, false }\n+#define mask_fold_left_direct { 1, 1, false }\n+#define check_ptrs_direct { 0, 0, false }\n \n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,\n #define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) TYPE##_direct,\n #define DEF_INTERNAL_SIGNED_OPTAB_FN(CODE, FLAGS, SELECTOR, SIGNED_OPTAB, \\\n \t\t\t\t     UNSIGNED_OPTAB, TYPE) TYPE##_direct,\n-#define DEF_INTERNAL_INSN_FN(CODE, FLAGS, INSN, NOUTPUTS, NINPUTS) \\\n-  direct_insn,\n #include \"internal-fn.def\"\n   not_direct\n };\n@@ -315,6 +308,57 @@ expand_GOMP_SIMT_ENTER (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* Allocate per-lane storage and begin non-uniform execution region.  */\n+\n+static void\n+expand_GOMP_SIMT_ENTER_ALLOC (internal_fn, gcall *stmt)\n+{\n+  rtx target;\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (lhs)\n+    target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  else\n+    target = gen_reg_rtx (Pmode);\n+  rtx size = expand_normal (gimple_call_arg (stmt, 0));\n+  rtx align = expand_normal (gimple_call_arg (stmt, 1));\n+  class expand_operand ops[3];\n+  create_output_operand (&ops[0], target, Pmode);\n+  create_input_operand (&ops[1], size, Pmode);\n+  create_input_operand (&ops[2], align, Pmode);\n+  gcc_assert (targetm.have_omp_simt_enter ());\n+  expand_insn (targetm.code_for_omp_simt_enter, 3, ops);\n+  if (!rtx_equal_p (target, ops[0].value))\n+    emit_move_insn (target, ops[0].value);\n+}\n+\n+/* Deallocate per-lane storage and leave non-uniform execution region.  */\n+\n+static void\n+expand_GOMP_SIMT_EXIT (internal_fn, gcall *stmt)\n+{\n+  gcc_checking_assert (!gimple_call_lhs (stmt));\n+  rtx arg = expand_normal (gimple_call_arg (stmt, 0));\n+  class expand_operand ops[1];\n+  create_input_operand (&ops[0], arg, Pmode);\n+  gcc_assert (targetm.have_omp_simt_exit ());\n+  expand_insn (targetm.code_for_omp_simt_exit, 1, ops);\n+}\n+\n+/* Lane index on SIMT targets: thread index in the warp on NVPTX.  On targets\n+   without SIMT execution this should be expanded in omp_device_lower pass.  */\n+\n+static void\n+expand_GOMP_SIMT_LANE (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  gcc_assert (targetm.have_omp_simt_lane ());\n+  emit_insn (targetm.gen_omp_simt_lane (target));\n+}\n+\n /* This should get expanded in omp_device_lower pass.  */\n \n static void\n@@ -323,6 +367,119 @@ expand_GOMP_SIMT_VF (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* Lane index of the first SIMT lane that supplies a non-zero argument.\n+   This is a SIMT counterpart to GOMP_SIMD_LAST_LANE, used to represent the\n+   lane that executed the last iteration for handling OpenMP lastprivate.  */\n+\n+static void\n+expand_GOMP_SIMT_LAST_LANE (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx cond = expand_normal (gimple_call_arg (stmt, 0));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  class expand_operand ops[2];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], cond, mode);\n+  gcc_assert (targetm.have_omp_simt_last_lane ());\n+  expand_insn (targetm.code_for_omp_simt_last_lane, 2, ops);\n+  if (!rtx_equal_p (target, ops[0].value))\n+    emit_move_insn (target, ops[0].value);\n+}\n+\n+/* Non-transparent predicate used in SIMT lowering of OpenMP \"ordered\".  */\n+\n+static void\n+expand_GOMP_SIMT_ORDERED_PRED (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx ctr = expand_normal (gimple_call_arg (stmt, 0));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  class expand_operand ops[2];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], ctr, mode);\n+  gcc_assert (targetm.have_omp_simt_ordered ());\n+  expand_insn (targetm.code_for_omp_simt_ordered, 2, ops);\n+  if (!rtx_equal_p (target, ops[0].value))\n+    emit_move_insn (target, ops[0].value);\n+}\n+\n+/* \"Or\" boolean reduction across SIMT lanes: return non-zero in all lanes if\n+   any lane supplies a non-zero argument.  */\n+\n+static void\n+expand_GOMP_SIMT_VOTE_ANY (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx cond = expand_normal (gimple_call_arg (stmt, 0));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  class expand_operand ops[2];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], cond, mode);\n+  gcc_assert (targetm.have_omp_simt_vote_any ());\n+  expand_insn (targetm.code_for_omp_simt_vote_any, 2, ops);\n+  if (!rtx_equal_p (target, ops[0].value))\n+    emit_move_insn (target, ops[0].value);\n+}\n+\n+/* Exchange between SIMT lanes with a \"butterfly\" pattern: source lane index\n+   is destination lane index XOR given offset.  */\n+\n+static void\n+expand_GOMP_SIMT_XCHG_BFLY (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx src = expand_normal (gimple_call_arg (stmt, 0));\n+  rtx idx = expand_normal (gimple_call_arg (stmt, 1));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  class expand_operand ops[3];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], src, mode);\n+  create_input_operand (&ops[2], idx, SImode);\n+  gcc_assert (targetm.have_omp_simt_xchg_bfly ());\n+  expand_insn (targetm.code_for_omp_simt_xchg_bfly, 3, ops);\n+  if (!rtx_equal_p (target, ops[0].value))\n+    emit_move_insn (target, ops[0].value);\n+}\n+\n+/* Exchange between SIMT lanes according to given source lane index.  */\n+\n+static void\n+expand_GOMP_SIMT_XCHG_IDX (internal_fn, gcall *stmt)\n+{\n+  tree lhs = gimple_call_lhs (stmt);\n+  if (!lhs)\n+    return;\n+\n+  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n+  rtx src = expand_normal (gimple_call_arg (stmt, 0));\n+  rtx idx = expand_normal (gimple_call_arg (stmt, 1));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n+  class expand_operand ops[3];\n+  create_output_operand (&ops[0], target, mode);\n+  create_input_operand (&ops[1], src, mode);\n+  create_input_operand (&ops[2], idx, SImode);\n+  gcc_assert (targetm.have_omp_simt_xchg_idx ());\n+  expand_insn (targetm.code_for_omp_simt_xchg_idx, 3, ops);\n+  if (!rtx_equal_p (target, ops[0].value))\n+    emit_move_insn (target, ops[0].value);\n+}\n+\n /* This should get expanded in adjust_simduid_builtins.  */\n \n static void\n@@ -3563,10 +3720,6 @@ tree_pair\n direct_internal_fn_types (internal_fn fn, tree return_type, tree *args)\n {\n   const direct_internal_fn_info &info = direct_internal_fn (fn);\n-  if (info.type0 == -2)\n-    /* Functions created by DEF_INTERNAL_INSN_FN are not type-dependent.  */\n-    return tree_pair {};\n-\n   tree type0 = (info.type0 < 0 ? return_type : TREE_TYPE (args[info.type0]));\n   tree type1 = (info.type1 < 0 ? return_type : TREE_TYPE (args[info.type1]));\n   return tree_pair (type0, type1);\n@@ -3580,10 +3733,6 @@ tree_pair\n direct_internal_fn_types (internal_fn fn, gcall *call)\n {\n   const direct_internal_fn_info &info = direct_internal_fn (fn);\n-  if (info.type0 == -2)\n-    /* Functions created by DEF_INTERNAL_INSN_FN are not type-dependent.  */\n-    return tree_pair {};\n-\n   tree op0 = (info.type0 < 0\n \t      ? gimple_call_lhs (call)\n \t      : gimple_call_arg (call, info.type0));\n@@ -3728,8 +3877,6 @@ direct_internal_fn_supported_p (internal_fn fn, tree_pair types,\n \treturn direct_##TYPE##_optab_supported_p (which_optab, types,\t\\\n \t\t\t\t\t\t  opt_type);\t\t\\\n       }\n-#define DEF_INTERNAL_INSN_FN(CODE, FLAGS, INSN, NOUTPUTS, NINPUTS) \\\n-    case IFN_##CODE: return targetm.have_##INSN ();\n #include \"internal-fn.def\"\n \n     case IFN_LAST:\n@@ -3881,14 +4028,6 @@ set_edom_supported_p (void)\n     optab which_optab = direct_internal_fn_optab (fn, types);\t\t\\\n     expand_##TYPE##_optab_fn (fn, stmt, which_optab);\t\t\t\\\n   }\n-#define DEF_INTERNAL_INSN_FN(CODE, FLAGS, INSN, NOUTPUTS, NINPUTS)\t\\\n-  static void\t\t\t\t\t\t\t\t\\\n-  expand_##CODE (internal_fn, gcall *stmt)\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    gcc_assert (targetm.have_##INSN ());\t\t\t\t\\\n-    expand_fn_using_insn (stmt, targetm.code_for_##INSN,\t\t\\\n-\t\t\t  NOUTPUTS, NINPUTS);\t\t\t\t\\\n-  }\n #include \"internal-fn.def\"\n \n /* Routines to expand each internal function, indexed by function number."}, {"sha": "d2d550d358606022b1cb44fa842f06e0be507bc3", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5", "patch": "@@ -34,7 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t\t   UNSIGNED_OPTAB, TYPE)\n      DEF_INTERNAL_FLT_FN (NAME, FLAGS, OPTAB, TYPE)\n      DEF_INTERNAL_INT_FN (NAME, FLAGS, OPTAB, TYPE)\n-     DEF_INTERNAL_INSN_FN (NAME, FLAGS, INSN, NOUTPUTS, NINPUTS)\n \n    where NAME is the name of the function, FLAGS is a set of\n    ECF_* flags and FNSPEC is a string describing functions fnspec.\n@@ -83,11 +82,6 @@ along with GCC; see the file COPYING3.  If not see\n    says that the function extends the C-level BUILT_IN_<NAME>{,L,LL,IMAX}\n    group of functions to any integral mode (including vector modes).\n \n-   DEF_INTERNAL_INSN_FN defines an internal function that maps to target\n-   instruction INSN, which is one of those defined in target-insns.def.\n-   The instruction has NOUTPUTS output operands (either 0 or 1) and\n-   NINPUTS input operands.\n-\n    Each entry must have a corresponding expander of the form:\n \n      void expand_NAME (gimple_call stmt)\n@@ -126,11 +120,6 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_INTERNAL_OPTAB_FN (NAME, FLAGS, OPTAB, TYPE)\n #endif\n \n-#ifndef DEF_INTERNAL_INSN_FN\n-#define DEF_INTERNAL_INSN_FN(NAME, FLAGS, INSN, NOUTPUTS, NINPUTS) \\\n-  DEF_INTERNAL_FN (NAME, FLAGS | ECF_LEAF, NULL)\n-#endif\n-\n DEF_INTERNAL_OPTAB_FN (MASK_LOAD, ECF_PURE, maskload, mask_load)\n DEF_INTERNAL_OPTAB_FN (LOAD_LANES, ECF_CONST, vec_load_lanes, load_lanes)\n DEF_INTERNAL_OPTAB_FN (MASK_LOAD_LANES, ECF_PURE,\n@@ -326,21 +315,15 @@ DEF_INTERNAL_INT_FN (POPCOUNT, ECF_CONST | ECF_NOTHROW, popcount, unary)\n \n DEF_INTERNAL_FN (GOMP_USE_SIMT, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_ENTER, ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_INSN_FN (GOMP_SIMT_ENTER_ALLOC, ECF_NOTHROW, omp_simt_enter, 1, 2)\n-DEF_INTERNAL_INSN_FN (GOMP_SIMT_EXIT, ECF_NOTHROW, omp_simt_exit, 0, 1)\n-DEF_INTERNAL_INSN_FN (GOMP_SIMT_LANE, ECF_NOVOPS | ECF_NOTHROW,\n-\t\t      omp_simt_lane, 1, 0)\n+DEF_INTERNAL_FN (GOMP_SIMT_ENTER_ALLOC, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_EXIT, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMT_VF, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n-DEF_INTERNAL_INSN_FN (GOMP_SIMT_LAST_LANE, ECF_NOVOPS | ECF_NOTHROW,\n-\t\t      omp_simt_last_lane, 1, 1)\n-DEF_INTERNAL_INSN_FN (GOMP_SIMT_ORDERED_PRED, ECF_NOTHROW,\n-\t\t      omp_simt_ordered, 1, 1)\n-DEF_INTERNAL_INSN_FN (GOMP_SIMT_VOTE_ANY, ECF_NOVOPS | ECF_NOTHROW,\n-\t\t      omp_simt_vote_any, 1, 1)\n-DEF_INTERNAL_INSN_FN (GOMP_SIMT_XCHG_BFLY, ECF_NOVOPS | ECF_NOTHROW,\n-\t\t      omp_simt_xchg_bfly, 1, 2)\n-DEF_INTERNAL_INSN_FN (GOMP_SIMT_XCHG_IDX, ECF_NOVOPS | ECF_NOTHROW,\n-\t\t      omp_simt_xchg_idx, 1, 2)\n+DEF_INTERNAL_FN (GOMP_SIMT_LAST_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_ORDERED_PRED, ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_VOTE_ANY, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_XCHG_BFLY, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n+DEF_INTERNAL_FN (GOMP_SIMT_XCHG_IDX, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_LANE, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_VF, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (GOMP_SIMD_LAST_LANE, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n@@ -450,7 +433,6 @@ DEF_INTERNAL_FN (SHUFFLEVECTOR, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n /* <=> optimization.  */\n DEF_INTERNAL_FN (SPACESHIP, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n \n-#undef DEF_INTERNAL_INSN_FN\n #undef DEF_INTERNAL_INT_FN\n #undef DEF_INTERNAL_FLT_FN\n #undef DEF_INTERNAL_FLT_FLOATN_FN"}, {"sha": "23c014a963c4d72da92c763db87ee486a2adb485", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=9d2fe6d427b37755410bb4eb4ecce8382f2ebfc5", "patch": "@@ -133,8 +133,7 @@ internal_fn_fnspec (enum internal_fn fn)\n   return internal_fn_fnspec_array[(int) fn];\n }\n \n-/* Describes an internal function that maps directly to either an optab\n-   or an instruction defined in target-insns.def.  */\n+/* Describes an internal function that maps directly to an optab.  */\n struct direct_internal_fn_info\n {\n   /* optabs can be parameterized by one or two modes.  These fields describe\n@@ -145,25 +144,24 @@ struct direct_internal_fn_info\n      function isn't directly mapped to an optab.  */\n   signed int type0 : 8;\n   signed int type1 : 8;\n-  /* True if the function is directly mapped to either an optab or an\n-     instruction defined in target-insns.def.  */\n-  unsigned int directly_mapped : 1;\n   /* True if the function is pointwise, so that it can be vectorized by\n      converting the return type and all argument types to vectors of the\n      same number of elements.  E.g. we can vectorize an IFN_SQRT on\n-     floats as an IFN_SQRT on vectors of N floats.  */\n-  unsigned int vectorizable : 1;\n+     floats as an IFN_SQRT on vectors of N floats.\n+\n+     This only needs 1 bit, but occupies the full 16 to ensure a nice\n+     layout.  */\n+  unsigned int vectorizable : 16;\n };\n \n extern const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1];\n \n-/* Return true if FN is mapped directly to either an optab or an instruction\n-   defined in target-insns.def.  */\n+/* Return true if FN is mapped directly to an optab.  */\n \n inline bool\n direct_internal_fn_p (internal_fn fn)\n {\n-  return direct_internal_fn_array[fn].directly_mapped;\n+  return direct_internal_fn_array[fn].type0 >= -1;\n }\n \n /* Return true if FN is a direct internal function that can be vectorized by\n@@ -177,7 +175,7 @@ vectorizable_internal_fn_p (internal_fn fn)\n   return direct_internal_fn_array[fn].vectorizable;\n }\n \n-/* Return information about internal function FN.  Only meaningful\n+/* Return optab information about internal function FN.  Only meaningful\n    if direct_internal_fn_p (FN).  */\n \n inline const direct_internal_fn_info &"}]}