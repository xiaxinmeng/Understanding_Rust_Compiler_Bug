{"sha": "f27be5508a305c4e027b665157787b5ba8c99c62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI3YmU1NTA4YTMwNWM0ZTAyN2I2NjUxNTc3ODdiNWJhOGM5OWM2Mg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2014-02-10T16:25:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2014-02-10T16:25:44Z"}, "message": "re PR middle-end/52306 (ICE in cselib_record_set, at cselib.c:2158)\n\n\tPR middle-end/52306\n\t* reload1.c (emit_input_reload_insns): Do not create invalid RTL\n\twhen changing the SET_DEST of a prior insn to avoid an input\n\treload.\n\n\tPR middle-end-52306\n\t* gcc.c-torture/compile/pr52306.c: New test.\n\nFrom-SVN: r207662", "tree": {"sha": "2b47eead162f5f28d55fcbb730993de7575ea7f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b47eead162f5f28d55fcbb730993de7575ea7f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f27be5508a305c4e027b665157787b5ba8c99c62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27be5508a305c4e027b665157787b5ba8c99c62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f27be5508a305c4e027b665157787b5ba8c99c62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f27be5508a305c4e027b665157787b5ba8c99c62/comments", "author": null, "committer": null, "parents": [{"sha": "7606ae1a4b0abe87ae2fc7f33be840f2e88e1107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7606ae1a4b0abe87ae2fc7f33be840f2e88e1107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7606ae1a4b0abe87ae2fc7f33be840f2e88e1107"}], "stats": {"total": 109, "additions": 107, "deletions": 2}, "files": [{"sha": "5f6252266aa750ad3319c5882f461baef7ceae0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27be5508a305c4e027b665157787b5ba8c99c62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27be5508a305c4e027b665157787b5ba8c99c62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f27be5508a305c4e027b665157787b5ba8c99c62", "patch": "@@ -1,3 +1,10 @@\n+2014-02-10  Jeff Law  <law@redhat.com>\n+\n+\tPR middle-end/52306\n+\t* reload1.c (emit_input_reload_insns): Do not create invalid RTL\n+\twhen changing the SET_DEST of a prior insn to avoid an input\n+\treload.\n+\n 2014-02-10  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* config/rs6000/sysv4.h (ENDIAN_SELECT): Do not attempt to enforce"}, {"sha": "b789ee8f19f309535ef2024f375381edf444dc90", "filename": "gcc/reload1.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27be5508a305c4e027b665157787b5ba8c99c62/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27be5508a305c4e027b665157787b5ba8c99c62/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f27be5508a305c4e027b665157787b5ba8c99c62", "patch": "@@ -7362,9 +7362,18 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t  /* Store into the reload register instead of the pseudo.  */\n \t  SET_DEST (PATTERN (temp)) = reloadreg;\n \n-\t  /* Verify that resulting insn is valid.  */\n+\t  /* Verify that resulting insn is valid. \n+\n+\t     Note that we have replaced the destination of TEMP with\n+\t     RELOADREG.  If TEMP references RELOADREG within an\n+\t     autoincrement addressing mode, then the resulting insn\n+\t     is ill-formed and we must reject this optimization.  */\n \t  extract_insn (temp);\n-\t  if (constrain_operands (1))\n+\t  if (constrain_operands (1)\n+#ifdef AUTO_INC_DEC\n+\t      && ! find_reg_note (temp, REG_INC, reloadreg)\n+#endif\n+\t      )\n \t    {\n \t      /* If the previous insn is an output reload, the source is\n \t\t a reload register, and its spill_reg_store entry will"}, {"sha": "56125ad6f8427835a1261e3a8b3c7d39166ab79b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27be5508a305c4e027b665157787b5ba8c99c62/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27be5508a305c4e027b665157787b5ba8c99c62/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f27be5508a305c4e027b665157787b5ba8c99c62", "patch": "@@ -1,3 +1,8 @@\n+2014-02-10  Jeff Law  <law@redhat.com>\n+\n+\tPR middle-end-52306\n+\t* gcc.c-torture/compile/pr52306.c: New test.\n+\n 2014-02-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++.dg/ext/vector26.C: Use -mmmx for 32-bit x86."}, {"sha": "e82cb2a3053f017a922510d421638d342958aa97", "filename": "gcc/testsuite/gcc.c-torture/compile/pr52306.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f27be5508a305c4e027b665157787b5ba8c99c62/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr52306.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f27be5508a305c4e027b665157787b5ba8c99c62/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr52306.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr52306.c?ref=f27be5508a305c4e027b665157787b5ba8c99c62", "patch": "@@ -0,0 +1,84 @@\n+/* PR middle-end/52306 */\n+\n+struct xmlNs {\n+    const unsigned char *prefix;\n+};\n+\n+struct xmlNode {\n+    const unsigned char *name;\n+    struct xmlNs *ns;\n+    struct xmlNs *nsDef;\n+};\n+\n+struct xsltTemplate {\n+    const unsigned char *name;\n+    int inheritedNsNr;\n+    void *inheritedNs;\n+};\n+\n+struct xsltTemplate *xsltNewTemplate(void);\n+void xsltGetQNameURI(unsigned char**);\n+long xmlMalloc(unsigned long);\n+void xsltGenericDebug(void);\n+int xmlStrEqual(const unsigned char*, const unsigned char*);\n+\n+static void xsltGetInheritedNsList(\n+    struct xsltTemplate *template,\n+    struct xmlNode *node)\n+{\n+    struct xmlNs *cur;\n+    struct xmlNs **ret;\n+    int nbns = 0;\n+    int maxns = 10;\n+    int i;\n+\n+    if (template == 0\n+\t|| template->inheritedNsNr != 0\n+\t|| template->inheritedNs != 0)\n+\treturn;\n+\n+    while (node != 0) {\n+\tcur = node->nsDef;\n+\tret = (struct xmlNs**) xmlMalloc((maxns + 1) * sizeof(struct xmlNs*));\n+\tfor (i = 0; i < nbns; i++)\n+\t    if (cur->prefix == ret[i]->prefix\n+\t\t|| xmlStrEqual(cur->prefix, 0))\n+\t\tbreak;\n+\n+\tif (i >= nbns) {\n+\t    if (nbns >= maxns)\n+\t\treturn;\n+\t    ret[nbns++] = cur;\n+\t}\n+    }\n+}\n+\n+static void\n+xsltParseStylesheetTemplate(struct xmlNode *template)\n+{\n+    struct xsltTemplate *ret;\n+    unsigned char *prop;\n+\n+    ret = xsltNewTemplate();\n+    if (ret == 0)\n+\treturn;\n+    xsltGetInheritedNsList(ret, template);\n+    xsltGenericDebug();\n+    xsltGetQNameURI(&prop);\n+    xmlStrEqual(0, ret->name);\n+}\n+\n+void xsltParseStylesheetTop(struct xmlNode *cur)\n+{\n+    xmlStrEqual(0, 0);\n+\n+    while (cur != 0) {\n+\tif (xmlStrEqual(cur->name, 0))\n+\t    ;\n+\telse if (xmlStrEqual(cur->name, 0))\n+\t    ;\n+\telse if (xmlStrEqual(cur->name, 0))\n+\t    xsltParseStylesheetTemplate(cur);\n+    }\n+}\n+"}]}