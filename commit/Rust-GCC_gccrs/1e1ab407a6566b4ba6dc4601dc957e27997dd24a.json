{"sha": "1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUxYWI0MDdhNjU2NmI0YmE2ZGM0NjAxZGM5NTdlMjc5OTdkZDI0YQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2004-03-13T11:19:23Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2004-03-13T11:19:23Z"}, "message": "arm.c (arm_legitimate_address_p): New argument, OUTER.\n\n* arm.c (arm_legitimate_address_p): New argument, OUTER.  Pass through\nto arm_legitimate_index_p.  Update all callers with SET as default\nvalue.\n(arm_legitimate_index_p): New argument, OUTER.  Restrict the index\nrange if OUTER is a sign-extend operation on QImode.  Correctly\nreject shift operations on sign-extended QImode addresses.\n(bad_signed_byte_operand): Delete.\n(arm_extendqisi_mem_op): New function.\n* arm.h (EXTRA_CONSTRAINT_ARM): Delete.  Replace with...\n(EXTRA_CONSTRAINT_STR_ARM): ... this.  Handle extended address\nconstraints.\n(CONSTRAINT_LEN): New.\n(EXTRA_CONSTRAINT): Delete.  Replace with...\n(EXTRA_CONSTRAINT_STR): ... this.\n(PREDICATE_CODES): Remove bad_signed_byte_operand.\n* arm.md (extendqihi_insn): Use new constraint Uq.  Rework.  Length\nis now always default.\n(define_splits for bad sign-extend loads): Delete.\n(arm_extendqisi, arm_extendqisi_v5): Likewise.\n* arm/vfp.md (arm_movsi_vfp, arm_movdi_vfp, movsf_vfp, movdf_vfp):\nRework 'U' constraint to 'Uv'.\n* arm-protos.h: Remove bad_signed_byte_operand.  Add\narm_extendqisi_mem_op.\n* doc/md.texi (ARM constraints): Rename VFP constraint (now Uv).\nAdd Uq constraint.\n\nFrom-SVN: r79440", "tree": {"sha": "dbf7c69580904f9cdf1218fe8977cffd36e519a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbf7c69580904f9cdf1218fe8977cffd36e519a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/comments", "author": null, "committer": null, "parents": [{"sha": "fa78dbea45b2043cee909f2d2e02d99997ee9baf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa78dbea45b2043cee909f2d2e02d99997ee9baf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa78dbea45b2043cee909f2d2e02d99997ee9baf"}], "stats": {"total": 311, "additions": 121, "deletions": 190}, "files": [{"sha": "e9d553823084c07742acec26b6f2b3c422e535fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "patch": "@@ -1,3 +1,31 @@\n+2004-03-13  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_legitimate_address_p): New argument, OUTER.  Pass through\n+\tto arm_legitimate_index_p.  Update all callers with SET as default\n+\tvalue.\n+\t(arm_legitimate_index_p): New argument, OUTER.  Restrict the index\n+\trange if OUTER is a sign-extend operation on QImode.  Correctly\n+\treject shift operations on sign-extended QImode addresses.\n+\t(bad_signed_byte_operand): Delete.\n+\t(arm_extendqisi_mem_op): New function.\n+\t* arm.h (EXTRA_CONSTRAINT_ARM): Delete.  Replace with...\n+\t(EXTRA_CONSTRAINT_STR_ARM): ... this.  Handle extended address\n+\tconstraints.\n+\t(CONSTRAINT_LEN): New.\n+\t(EXTRA_CONSTRAINT): Delete.  Replace with...\n+\t(EXTRA_CONSTRAINT_STR): ... this.\n+\t(PREDICATE_CODES): Remove bad_signed_byte_operand.\n+\t* arm.md (extendqihi_insn): Use new constraint Uq.  Rework.  Length\n+\tis now always default.\n+\t(define_splits for bad sign-extend loads): Delete.\n+\t(arm_extendqisi, arm_extendqisi_v5): Likewise.\n+\t* arm/vfp.md (arm_movsi_vfp, arm_movdi_vfp, movsf_vfp, movdf_vfp):\n+\tRework 'U' constraint to 'Uv'.\n+\t* arm-protos.h: Remove bad_signed_byte_operand.  Add\n+\tarm_extendqisi_mem_op.\n+\t* doc/md.texi (ARM constraints): Rename VFP constraint (now Uv).\n+\tAdd Uq constraint.\n+\n 2004-03-13  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/rs6000.c (rs6000_va_arg): Replace SPLIT_COMPLEX_ARGS"}, {"sha": "47503fd58f5c270f68468e27ccd35d6e83d24c1e", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "patch": "@@ -50,7 +50,7 @@ extern int arm_split_constant (RTX_CODE, enum machine_mode, HOST_WIDE_INT, rtx,\n extern RTX_CODE arm_canonicalize_comparison (RTX_CODE, rtx *);\n extern int legitimate_pic_operand_p (rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n-extern int arm_legitimate_address_p  (enum machine_mode, rtx, int);\n+extern int arm_legitimate_address_p  (enum machine_mode, rtx, RTX_CODE, int);\n extern int thumb_legitimate_address_p (enum machine_mode, rtx, int);\n extern int thumb_legitimate_offset_p (enum machine_mode, HOST_WIDE_INT);\n extern rtx arm_legitimize_address (rtx, rtx, enum machine_mode);\n@@ -71,9 +71,9 @@ extern int arm_rhsm_operand (rtx, enum machine_mode);\n extern int arm_add_operand (rtx, enum machine_mode);\n extern int arm_addimm_operand (rtx, enum machine_mode);\n extern int arm_not_operand (rtx, enum machine_mode);\n+extern int arm_extendqisi_mem_op (rtx, enum machine_mode);\n extern int offsettable_memory_operand (rtx, enum machine_mode);\n extern int alignable_memory_operand (rtx, enum machine_mode);\n-extern int bad_signed_byte_operand (rtx, enum machine_mode);\n extern int arm_float_rhs_operand (rtx, enum machine_mode);\n extern int arm_float_add_operand (rtx, enum machine_mode);\n extern int power_of_two_operand (rtx, enum machine_mode);"}, {"sha": "4cada0c10ebcdace052902cb2497b37161c1b38c", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 50, "deletions": 65, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "patch": "@@ -64,7 +64,7 @@ static int arm_gen_constant (enum rtx_code, enum machine_mode, HOST_WIDE_INT,\n \t\t\t     rtx, rtx, int, int);\n static unsigned bit_count (unsigned long);\n static int arm_address_register_rtx_p (rtx, int);\n-static int arm_legitimate_index_p (enum machine_mode, rtx, int);\n+static int arm_legitimate_index_p (enum machine_mode, rtx, RTX_CODE, int);\n static int thumb_base_register_rtx_p (rtx, enum machine_mode, int);\n inline static int thumb_index_register_rtx_p (rtx, int);\n static int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n@@ -2719,7 +2719,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t{\n \t  /* The base register doesn't really matter, we only want to\n \t     test the index for the appropriate mode.  */\n-\t  if (!arm_legitimate_index_p (mode, offset, 0))\n+\t  if (!arm_legitimate_index_p (mode, offset, SET, 0))\n \t    {\n \t      if (!no_new_pseudos)\n \t\toffset = force_reg (Pmode, offset);\n@@ -2824,7 +2824,8 @@ arm_address_register_rtx_p (rtx x, int strict_p)\n \n /* Return nonzero if X is a valid ARM state address operand.  */\n int\n-arm_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n+arm_legitimate_address_p (enum machine_mode mode, rtx x, RTX_CODE outer,\n+\t\t\t  int strict_p)\n {\n   if (arm_address_register_rtx_p (x, strict_p))\n     return 1;\n@@ -2837,7 +2838,8 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n \t   && arm_address_register_rtx_p (XEXP (x, 0), strict_p)\n \t   && GET_CODE (XEXP (x, 1)) == PLUS\n \t   && XEXP (XEXP (x, 1), 0) == XEXP (x, 0))\n-    return arm_legitimate_index_p (mode, XEXP (XEXP (x, 1), 1), strict_p);\n+    return arm_legitimate_index_p (mode, XEXP (XEXP (x, 1), 1), outer,\n+\t\t\t\t   strict_p);\n \n   /* After reload constants split into minipools will have addresses\n      from a LABEL_REF.  */\n@@ -2889,9 +2891,9 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n       rtx xop1 = XEXP (x, 1);\n \n       return ((arm_address_register_rtx_p (xop0, strict_p)\n-\t       && arm_legitimate_index_p (mode, xop1, strict_p))\n+\t       && arm_legitimate_index_p (mode, xop1, outer, strict_p))\n \t      || (arm_address_register_rtx_p (xop1, strict_p)\n-\t\t  && arm_legitimate_index_p (mode, xop0, strict_p)));\n+\t\t  && arm_legitimate_index_p (mode, xop0, outer, strict_p)));\n     }\n \n #if 0\n@@ -2902,7 +2904,7 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n       rtx xop1 = XEXP (x, 1);\n \n       return (arm_address_register_rtx_p (xop0, strict_p)\n-\t      && arm_legitimate_index_p (mode, xop1, strict_p));\n+\t      && arm_legitimate_index_p (mode, xop1, outer, strict_p));\n     }\n #endif\n \n@@ -2924,7 +2926,8 @@ arm_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n /* Return nonzero if INDEX is valid for an address index operand in\n    ARM state.  */\n static int\n-arm_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n+arm_legitimate_index_p (enum machine_mode mode, rtx index, RTX_CODE outer,\n+\t\t\tint strict_p)\n {\n   HOST_WIDE_INT range;\n   enum rtx_code code = GET_CODE (index);\n@@ -2949,38 +2952,42 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n \t    && INTVAL (index) < 256\n \t    && INTVAL (index) > -256);\n \n-  /* XXX What about ldrsb?  */\n-  if (GET_MODE_SIZE (mode) <= 4  && code == MULT\n-      && (!arm_arch4 || (mode) != HImode))\n-    {\n-      rtx xiop0 = XEXP (index, 0);\n-      rtx xiop1 = XEXP (index, 1);\n-\n-      return ((arm_address_register_rtx_p (xiop0, strict_p)\n-\t       && power_of_two_operand (xiop1, SImode))\n-\t      || (arm_address_register_rtx_p (xiop1, strict_p)\n-\t\t  && power_of_two_operand (xiop0, SImode)));\n-    }\n-\n   if (GET_MODE_SIZE (mode) <= 4\n-      && (code == LSHIFTRT || code == ASHIFTRT\n-\t  || code == ASHIFT || code == ROTATERT)\n-      && (!arm_arch4 || (mode) != HImode))\n+      && ! (arm_arch4\n+\t    && (mode == HImode\n+\t\t|| (mode == QImode && outer == SIGN_EXTEND))))\n     {\n-      rtx op = XEXP (index, 1);\n+      if (code == MULT)\n+\t{\n+\t  rtx xiop0 = XEXP (index, 0);\n+\t  rtx xiop1 = XEXP (index, 1);\n+\n+\t  return ((arm_address_register_rtx_p (xiop0, strict_p)\n+\t\t   && power_of_two_operand (xiop1, SImode))\n+\t\t  || (arm_address_register_rtx_p (xiop1, strict_p)\n+\t\t      && power_of_two_operand (xiop0, SImode)));\n+\t}\n+      else if (code == LSHIFTRT || code == ASHIFTRT\n+\t       || code == ASHIFT || code == ROTATERT)\n+\t{\n+\t  rtx op = XEXP (index, 1);\n \n-      return (arm_address_register_rtx_p (XEXP (index, 0), strict_p)\n-\t      && GET_CODE (op) == CONST_INT\n-\t      && INTVAL (op) > 0\n-\t      && INTVAL (op) <= 31);\n+\t  return (arm_address_register_rtx_p (XEXP (index, 0), strict_p)\n+\t\t  && GET_CODE (op) == CONST_INT\n+\t\t  && INTVAL (op) > 0\n+\t\t  && INTVAL (op) <= 31);\n+\t}\n     }\n \n-  /* XXX For ARM v4 we may be doing a sign-extend operation during the\n-     load, but that has a restricted addressing range and we are unable\n-     to tell here whether that is the case.  To be safe we restrict all\n-     loads to that range.  */\n+  /* For ARM v4 we may be doing a sign-extend operation during the\n+     load.  */\n   if (arm_arch4)\n-    range = (mode == HImode || mode == QImode) ? 256 : 4096;\n+    {\n+      if (mode == HImode || (outer == SIGN_EXTEND && mode == QImode))\n+\trange = 256;\n+      else\n+\trange = 4096;\n+    }\n   else\n     range = (mode == HImode) ? 4095 : 4096;\n \n@@ -4211,37 +4218,6 @@ arm_reload_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n }\n \n-/* Return 1 if OP is a valid memory address, but not valid for a signed byte\n-   memory access (architecture V4).\n-   MODE is QImode if called when computing constraints, or VOIDmode when\n-   emitting patterns.  In this latter case we cannot use memory_operand()\n-   because it will fail on badly formed MEMs, which is precisely what we are\n-   trying to catch.  */\n-int\n-bad_signed_byte_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  /* A sum of anything more complex than reg + reg or reg + const is bad.  */\n-  if ((GET_CODE (op) == PLUS || GET_CODE (op) == MINUS)\n-      && (!s_register_operand (XEXP (op, 0), VOIDmode)\n-\t  || (!s_register_operand (XEXP (op, 1), VOIDmode)\n-\t      && GET_CODE (XEXP (op, 1)) != CONST_INT)))\n-    return 1;\n-\n-  /* Big constants are also bad.  */\n-  if (GET_CODE (op) == PLUS && GET_CODE (XEXP (op, 1)) == CONST_INT\n-      && (INTVAL (XEXP (op, 1)) > 0xff\n-\t  || -INTVAL (XEXP (op, 1)) > 0xff))\n-    return 1;\n-\n-  /* Everything else is good, or can will automatically be made so.  */\n-  return 0;\n-}\n-\n /* Return TRUE for valid operands for the rhs of an ARM instruction.  */\n int\n arm_rhs_operand (rtx op, enum machine_mode mode)\n@@ -4434,6 +4410,15 @@ cirrus_memory_offset (rtx op)\n   return 0;\n }\n \n+int\n+arm_extendqisi_mem_op (rtx op, enum machine_mode mode)\n+{\n+  if (!memory_operand (op, mode))\n+    return 0;\n+\n+  return arm_legitimate_address_p (mode, XEXP (op, 0), SIGN_EXTEND, 0);\n+}\n+\n /* Return nonzero if OP is a Cirrus or general register.  */\n int\n cirrus_register_operand (rtx op, enum machine_mode mode)"}, {"sha": "86c6f1403e2f10b152900c3c2706ba2168a15a2f", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "patch": "@@ -1471,23 +1471,30 @@ enum reg_class\n    accessed without using a load.\n    'U' is an address valid for VFP load/store insns.  */\n \n-#define EXTRA_CONSTRAINT_ARM(OP, C)\t\t\t\t\t    \\\n-  ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG :    \\\n-   (C) == 'R' ? (GET_CODE (OP) == MEM\t\t\t\t\t    \\\n-\t\t && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\t    \\\n-\t\t && CONSTANT_POOL_ADDRESS_P (XEXP (OP, 0))) :\t\t    \\\n-   (C) == 'S' ? (optimize > 0 && CONSTANT_ADDRESS_P (OP)) :\t\t    \\\n-   (C) == 'T' ? cirrus_memory_offset (OP) : \t\t    \t\t    \\\n-   (C) == 'U' ? vfp_mem_operand (OP) :\t\t\t\t\t    \\\n-   0)\n+#define EXTRA_CONSTRAINT_STR_ARM(OP, C, STR)\t\t\t\\\n+  (((C) == 'Q') ? (GET_CODE (OP) == MEM\t\t\t\t\\\n+\t\t && GET_CODE (XEXP (OP, 0)) == REG) :\t\t\\\n+   ((C) == 'R') ? (GET_CODE (OP) == MEM\t\t\t\t\\\n+\t\t   && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\\\n+\t\t   && CONSTANT_POOL_ADDRESS_P (XEXP (OP, 0))) :\t\\\n+   ((C) == 'S') ? (optimize > 0 && CONSTANT_ADDRESS_P (OP)) :\t\\\n+   ((C) == 'T') ? cirrus_memory_offset (OP) :\t\t\t\\\n+   ((C) == 'U' && (STR)[1] == 'v') ? vfp_mem_operand (OP) :\t\\\n+   ((C) == 'U' && (STR)[1] == 'q')\t\t\t\t\\\n+    ? arm_extendqisi_mem_op (OP, GET_MODE (OP))\t\t\t\\\n+      : 0)\n+\n+#define CONSTRAINT_LEN(C,STR)\t\t\t\t\\\n+  ((C) == 'U' ? 2 : DEFAULT_CONSTRAINT_LEN (C, STR))\n \n #define EXTRA_CONSTRAINT_THUMB(X, C)\t\t\t\t\t\\\n   ((C) == 'Q' ? (GET_CODE (X) == MEM\t\t\t\t\t\\\n \t\t && GET_CODE (XEXP (X, 0)) == LABEL_REF) : 0)\n \n-#define EXTRA_CONSTRAINT(X, C)\t\t\t\t\t\t\\\n-  (TARGET_ARM ?\t\t\t\t\t\t\t\t\\\n-   EXTRA_CONSTRAINT_ARM (X, C) : EXTRA_CONSTRAINT_THUMB (X, C))\n+#define EXTRA_CONSTRAINT_STR(X, C, STR)\t\t\\\n+  (TARGET_ARM\t\t\t\t\t\\\n+   ? EXTRA_CONSTRAINT_STR_ARM (X, C, STR)\t\\\n+   : EXTRA_CONSTRAINT_THUMB (X, C))\n \n #define EXTRA_MEMORY_CONSTRAINT(C, STR) ((C) == 'U')\n \n@@ -2336,7 +2343,7 @@ typedef struct\n \n #define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE,X,WIN)\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n-    if (arm_legitimate_address_p (MODE, X, REG_STRICT_P))\t\\\n+    if (arm_legitimate_address_p (MODE, X, SET, REG_STRICT_P))\t\\\n       goto WIN;\t\t\t\t\t\t\t\\\n   }\n \n@@ -2817,7 +2824,6 @@ extern int making_const_table;\n   {\"thumb_cmpneg_operand\", {CONST_INT}},\t\t\t\t\\\n   {\"thumb_cbrch_target_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n   {\"offsettable_memory_operand\", {MEM}},\t\t\t\t\\\n-  {\"bad_signed_byte_operand\", {MEM}},\t\t\t\t\t\\\n   {\"alignable_memory_operand\", {MEM}},\t\t\t\t\t\\\n   {\"shiftable_operator\", {PLUS, MINUS, AND, IOR, XOR}},\t\t\t\\\n   {\"minmax_operator\", {SMIN, SMAX, UMIN, UMAX}},\t\t\t\\"}, {"sha": "253fe11aeab207b5537c2d2661bb2a32d79f4682", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 9, "deletions": 100, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "patch": "@@ -3748,59 +3748,17 @@\n   }\"\n )\n \n-; Rather than restricting all byte accesses to memory addresses that ldrsb\n-; can handle, we fix up the ones that ldrsb can't grok with a split.\n (define_insn \"*extendqihi_insn\"\n-  [(set (match_operand:HI                 0 \"s_register_operand\" \"=r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\"      \"m\")))]\n+  [(set (match_operand:HI 0 \"s_register_operand\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"Uq\")))]\n   \"TARGET_ARM && arm_arch4\"\n-  \"*\n-  /* If the address is invalid, this will split the instruction into two.  */\n-  if (bad_signed_byte_operand (operands[1], VOIDmode))\n-    return \\\"#\\\";\n-  return \\\"ldr%?sb\\\\t%0, %1\\\";\n-  \"\n+  \"ldr%?sb\\\\t%0, %1\"\n   [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"length\" \"8\")\n    (set_attr \"pool_range\" \"256\")\n    (set_attr \"neg_pool_range\" \"244\")]\n )\n \n-(define_split\n-  [(set (match_operand:HI 0 \"s_register_operand\" \"\")\n-\t(sign_extend:HI (match_operand:QI 1 \"bad_signed_byte_operand\" \"\")))]\n-  \"TARGET_ARM && arm_arch4 && reload_completed\"\n-  [(set (match_dup 3) (match_dup 1))\n-   (set (match_dup 0) (sign_extend:HI (match_dup 2)))]\n-  \"\n-  {\n-    HOST_WIDE_INT offset;\n-\n-    operands[3] = gen_rtx_REG (SImode, REGNO (operands[0]));\n-    operands[2] = gen_rtx_MEM (QImode, operands[3]);\n-    MEM_COPY_ATTRIBUTES (operands[2], operands[1]);\n-    operands[1] = XEXP (operands[1], 0);\n-    if (GET_CODE (operands[1]) == PLUS\n-\t&& GET_CODE (XEXP (operands[1], 1)) == CONST_INT\n-\t&& !(const_ok_for_arm (offset = INTVAL (XEXP (operands[1], 1)))\n-\t     || const_ok_for_arm (-offset)))\n-      {\n-\tHOST_WIDE_INT low = (offset > 0\n-\t\t\t     ? (offset & 0xff) : -((-offset) & 0xff));\n-\tXEXP (operands[2], 0) = plus_constant (operands[3], low);\n-\toperands[1] = plus_constant (XEXP (operands[1], 0), offset - low);\n-      }\n-    /* Ensure the sum is in correct canonical form.  */\n-    else if (GET_CODE (operands[1]) == PLUS\n-\t     && GET_CODE (XEXP (operands[1], 1)) != CONST_INT\n-\t     && !s_register_operand (XEXP (operands[1], 1), VOIDmode))\n-      operands[1] = gen_rtx_PLUS (GET_MODE (operands[1]),\n-\t\t\t\t\t   XEXP (operands[1], 1),\n-\t\t\t\t\t   XEXP (operands[1], 0));\n-  }\"\n-)\n-\n (define_expand \"extendqisi2\"\n   [(set (match_dup 2)\n \t(ashift:SI (match_operand:QI 1 \"general_operand\" \"\")\n@@ -3833,42 +3791,26 @@\n   }\"\n )\n \n-; Rather than restricting all byte accesses to memory addresses that ldrsb\n-; can handle, we fix up the ones that ldrsb can't grok with a split.\n (define_insn \"*arm_extendqisi\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n+\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"Uq\")))]\n   \"TARGET_ARM && arm_arch4 && !arm_arch6\"\n-  \"*\n-  /* If the address is invalid, this will split the instruction into two.  */\n-  if (bad_signed_byte_operand (operands[1], VOIDmode))\n-    return \\\"#\\\";\n-  return \\\"ldr%?sb\\\\t%0, %1\\\";\n-  \"\n+  \"ldr%?sb\\\\t%0, %1\"\n   [(set_attr \"type\" \"load_byte\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"length\" \"8\")\n    (set_attr \"pool_range\" \"256\")\n    (set_attr \"neg_pool_range\" \"244\")]\n )\n \n (define_insn \"*arm_extendqisi_v6\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,m\")))]\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"r,Uq\")))]\n   \"TARGET_ARM && arm_arch6\"\n-  \"*\n-  if (which_alternative == 0)\n-    return \\\"sxtb%?\\\\t%0, %1\\\";\n-\n-  /* If the address is invalid, this will split the instruction into two.  */\n-  if (bad_signed_byte_operand (operands[1], VOIDmode))\n-    return \\\"#\\\";\n-\n-  return \\\"ldr%?sb\\\\t%0, %1\\\";\n-  \"\n+  \"@\n+   sxtb%?\\\\t%0, %1\n+   ldr%?sb\\\\t%0, %1\"\n   [(set_attr \"type\" \"alu_shift,load_byte\")\n    (set_attr \"predicable\" \"yes\")\n-   (set_attr \"length\" \"4,8\")\n    (set_attr \"pool_range\" \"*,256\")\n    (set_attr \"neg_pool_range\" \"*,244\")]\n )\n@@ -3883,39 +3825,6 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n-(define_split\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n-\t(sign_extend:SI (match_operand:QI 1 \"bad_signed_byte_operand\" \"\")))]\n-  \"TARGET_ARM && arm_arch4 && reload_completed\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 0) (sign_extend:SI (match_dup 2)))]\n-  \"\n-  {\n-    HOST_WIDE_INT offset;\n-\n-    operands[2] = gen_rtx_MEM (QImode, operands[0]);\n-    MEM_COPY_ATTRIBUTES (operands[2], operands[1]);\n-    operands[1] = XEXP (operands[1], 0);\n-    if (GET_CODE (operands[1]) == PLUS\n-\t&& GET_CODE (XEXP (operands[1], 1)) == CONST_INT\n-\t&& !(const_ok_for_arm (offset = INTVAL (XEXP (operands[1], 1)))\n-\t     || const_ok_for_arm (-offset)))\n-      {\n-\tHOST_WIDE_INT low = (offset > 0\n-\t\t\t     ? (offset & 0xff) : -((-offset) & 0xff));\n-\tXEXP (operands[2], 0) = plus_constant (operands[0], low);\n-\toperands[1] = plus_constant (XEXP (operands[1], 0), offset - low);\n-      }\n-    /* Ensure the sum is in correct canonical form.  */\n-    else if (GET_CODE (operands[1]) == PLUS\n-\t     && GET_CODE (XEXP (operands[1], 1)) != CONST_INT\n-\t     && !s_register_operand (XEXP (operands[1], 1), VOIDmode))\n-      operands[1] = gen_rtx_PLUS (GET_MODE (operands[1]),\n-\t\t\t\t\t   XEXP (operands[1], 1),\n-\t\t\t\t\t   XEXP (operands[1], 0));\n-  }\"\n-)\n-\n (define_insn \"*thumb_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n \t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"V,m\")))]"}, {"sha": "dd313a9bdcacc628e47ac5528f21c53e54f71c5f", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "patch": "@@ -111,8 +111,8 @@\n ;; ??? For now do not allow loading constants into vfp regs.  This causes\n ;; problems because small constants get converted into adds.\n (define_insn \"*arm_movsi_vfp\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r ,m,!w,r,!w,!w, U\")\n-      (match_operand:SI 1 \"general_operand\"\t   \"rI,K,mi,r,r,!w,!w,Ui,!w\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r ,m,!w,r,!w,!w,  Uv\")\n+      (match_operand:SI 1 \"general_operand\"\t   \"rI,K,mi,r,r,!w,!w,Uvi,!w\"))]\n   \"TARGET_ARM && TARGET_VFP && TARGET_HARD_FLOAT\n    && (   s_register_operand (operands[0], SImode)\n        || s_register_operand (operands[1], SImode))\"\n@@ -136,8 +136,8 @@\n ;; DImode moves\n \n (define_insn \"*arm_movdi_vfp\"\n-  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r,o<>,w,r,w,w ,U\")\n-\t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r ,r,w,w,Ui,w\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r,o<>,w,r,w,w  ,Uv\")\n+\t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r ,r,w,w,Uvi,w\"))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"*\n   switch (which_alternative)\n@@ -168,8 +168,8 @@\n ;; SFmode moves\n \n (define_insn \"*movsf_vfp\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=w,r,w ,U,r ,m,w,r\")\n-\t(match_operand:SF 1 \"general_operand\"\t   \" r,w,UE,w,mE,r,w,r\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=w,r,w  ,Uv,r ,m,w,r\")\n+\t(match_operand:SF 1 \"general_operand\"\t   \" r,w,UvE,w, mE,r,w,r\"))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\n    && (   s_register_operand (operands[0], SFmode)\n        || s_register_operand (operands[1], SFmode))\"\n@@ -192,8 +192,8 @@\n ;; DFmode moves\n \n (define_insn \"*movdf_vfp\"\n-  [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,r,r, m,w ,U,w,r\")\n-\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" r,w,mF,r,UF,w,w,r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,r,r, m,w  ,Uv,w,r\")\n+\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" r,w,mF,r,UvF,w, w,r\"))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"*\n   {"}, {"sha": "a543080967c98bd13c213d9171b3b28bb7ce6433", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e1ab407a6566b4ba6dc4601dc957e27997dd24a/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=1e1ab407a6566b4ba6dc4601dc957e27997dd24a", "patch": "@@ -1360,9 +1360,12 @@ An item in the constant pool\n A symbol in the text segment of the current file\n @end table\n \n-@item U\n+@item Uv\n A memory reference suitable for VFP load/store insns (reg+constant offset)\n \n+@item Uq\n+A memory reference suitable for for the ARMv4 ldrsb instruction.\n+\n @item AVR family---@file{avr.h}\n @table @code\n @item l"}]}