{"sha": "b146446c53f525ad953fc7a886baceca17c74e9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE0NjQ0NmM1M2Y1MjVhZDk1M2ZjN2E4ODZiYWNlY2ExN2M3NGU5YQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-19T12:42:32Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-09-19T12:42:32Z"}, "message": "i386-protos.h (split_double_mode): New prototype.\n\n\t* config/i386/i386-protos.h (split_double_mode): New prototype.\n\t(split_di, split_ti): Remove prototypes.\n\t* config/i386/i386.c (split_double_mode): New function.\n\t(split_di, split_ti): Remove.\n\t(ix86_expand_branch): Use split_double_mode.\n\t(ix86_split_to_parts): Ditto.\n\t(ix86_split_ashl): Ditto.\n\t(ix86_split_ashr): Ditto.\n\t(ix86_split_lshr): Ditto.\n\t(ix86_force_to_memory): Ditto.\n\t* config/i386/i386.md: Use split_double_mode in double-mode splitters.\n\nFrom-SVN: r164413", "tree": {"sha": "1b4337aa39601a07040ac61fbc7e360a1595b2d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b4337aa39601a07040ac61fbc7e360a1595b2d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b146446c53f525ad953fc7a886baceca17c74e9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b146446c53f525ad953fc7a886baceca17c74e9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b146446c53f525ad953fc7a886baceca17c74e9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b146446c53f525ad953fc7a886baceca17c74e9a/comments", "author": null, "committer": null, "parents": [{"sha": "6e687a9ad7da29caabd39b6b120ec49fd108a881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e687a9ad7da29caabd39b6b120ec49fd108a881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e687a9ad7da29caabd39b6b120ec49fd108a881"}], "stats": {"total": 239, "additions": 109, "deletions": 130}, "files": [{"sha": "60cd308e2949d8d2760cebe7fa1acc235986e61c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b146446c53f525ad953fc7a886baceca17c74e9a", "patch": "@@ -1,3 +1,17 @@\n+2010-09-19  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386-protos.h (split_double_mode): New prototype.\n+\t(split_di, split_ti): Remove prototypes.\n+\t* config/i386/i386.c (split_double_mode): New function.\n+\t(split_di, split_ti): Remove.\n+\t(ix86_expand_branch): Use split_double_mode.\n+\t(ix86_split_to_parts): Ditto.\n+\t(ix86_split_ashl): Ditto.\n+\t(ix86_split_ashr): Ditto.\n+\t(ix86_split_lshr): Ditto.\n+\t(ix86_force_to_memory): Ditto.\n+\t* config/i386/i386.md: Use split_double_mode in double-mode splitters.\n+\n 2010-09-18  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/45453\n@@ -16,7 +30,8 @@\n \t(canonicalize_constructor_val): Use it.\n \t(get_symbol_constant_value): Be reaqdy for canonicalize_constructor_val\n \treturning NULL.\n-\t(gimple_fold_obj_type_ref_known_binfo): Use static_object_in_other_unit_p.\n+\t(gimple_fold_obj_type_ref_known_binfo): Use\n+\tstatic_object_in_other_unit_p.\n \n 2010-09-18  Richard Guenther  <rguenther@suse.de>\n \n@@ -35,8 +50,7 @@\n 2010-09-18  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/45709\n-\t* tree-inline.c (copy_phis_for_bb): Fixup new_edge when\n-\twe splitted it.\n+\t* tree-inline.c (copy_phis_for_bb): Fixup new_edge when we splitted it.\n \n 2010-09-17  Sebastian Pop  <sebastian.pop@amd.com>\n \n@@ -48,7 +62,9 @@\n \n 2010-09-17  Sebastian Pop  <sebastian.pop@amd.com>\n \n-\tRevert commit: 2009-12-16  Ben Elliston  <bje@au.ibm.com>\n+\tRevert:\n+\t2009-12-16  Ben Elliston  <bje@au.ibm.com>\n+\n \t* tree-data-ref.c (dot_rdg_1): Added back.\n \t(dot_rdg): Same.  Added \"#if 0\" around system call.\n \n@@ -82,8 +98,7 @@\n \tpassed an invalid value, print an error instead of ICEing.\n \t(valid_psw_flag): New.\n \t(rx_expand_builtin): Call it for setpsw/clrpsw.\n-\t(rx_expand_builtin_mvtipl): Pass an integer to IN_RANGE, not an\n-\tRTX.\n+\t(rx_expand_builtin_mvtipl): Pass an integer to IN_RANGE, not an RTX.\n \n \t* config/rx/rx.md (bitclr): Don't mark the output as early-clobber.\n \t(bitclr_in_memory): Likewise.\n@@ -159,8 +174,7 @@\n \t(do_spec): Remove code concerning combine.\n \t(main): Likewise.\n \t* doc/invoke.texi: Remove traces of -combine.\n-\t* lto-wrapper.c (run_gcc): Do not pass -combine to the compiler\n-\tdriver.\n+\t* lto-wrapper.c (run_gcc): Do not pass -combine to the compiler driver.\n \n 2010-09-17  Richard Guenther  <rguenther@suse.de>\n \n@@ -331,8 +345,7 @@\n \talpha_override_options.\n \t* config/alpha/alpha-protos.h (override_options): Remove.\n \t* config/alpha/alpha.c (override_options): Rename to\n-\talpha_option_override.  Call SUBTARGET_OVERRIDE_OPTIONS.  Make\n-\tstatic.\n+\talpha_option_override.  Call SUBTARGET_OVERRIDE_OPTIONS.  Make static.\n \t(TARGET_OPTION_OVERRIDE): Define.\n \t* config/alpha/alpha.h (OVERRIDE_OPTIONS): Remove.\n \t* config/alpha/vms.h (SUBTARGET_OVERRIDE_OPTIONS): Define instead\n@@ -347,14 +360,12 @@\n \t(arm_override_options): Rename to arm_option_override.  Make\n \tstatic.  Call SUBTARGET_OVERRIDE_OPTIONS.\n \t* config/arm/arm.h (OVERRIDE_OPTIONS): Remove.\n-\t* config/arm/arm.md: Update comment referring to\n-\tarm_override_options.\n+\t* config/arm/arm.md: Update comment referring to arm_override_options.\n \t* config/arm/vxworks.h (SUBTARGET_OVERRIDE_OPTIONS): Define\n \tinstead of OVERRIDE_OPTIONS.\n \t* config/avr/avr-protos.h (avr_override_options): Remove.\n \t* config/avr/avr.c (TARGET_OPTION_OVERRIDE): Define.\n-\t(avr_override_options): Rename to avr_option_override.  Make\n-\tstatic.\n+\t(avr_override_options): Rename to avr_option_override.  Make static.\n \t* config/avr/avr.h (OVERRIDE_OPTIONS): Remove.\n \t* config/bfin/bfin-protos.h (override_options): Remove (twice).\n \t* config/bfin/bfin.c (override_options): Rename to\n@@ -363,13 +374,11 @@\n \t* config/bfin/bfin.h (OVERRIDE_OPTIONS): Remove.\n \t* config/cris/cris-protos.h (cris_override_options): Remove.\n \t* config/cris/cris.c (TARGET_OPTION_OVERRIDE): Define.\n-\t(cris_override_options): Rename to cris_option_override.  Make\n-\tstatic.\n+\t(cris_override_options): Rename to cris_option_override.  Make static.\n \t* config/cris/cris.h (OVERRIDE_OPTIONS): Remove.\n \t* config/frv/frv-protos.h (frv_override_options): Remove.\n \t* config/frv/frv.c (TARGET_OPTION_OVERRIDE): Define.\n-\t(frv_override_options): Rename to frv_option_override.  Make\n-\tstatic.\n+\t(frv_override_options): Rename to frv_option_override.  Make static.\n \t* config/frv/frv.h (OVERRIDE_OPTIONS): Remove.\n \t* config/h8300/h8300-protos.h (h8300_init_once): Remove.\n \t* config/h8300/h8300.c (h8300_init_once): Rename to\n@@ -383,26 +392,22 @@\n \t(ix86_option_override): New.\n \t(TARGET_OPTION_OVERRIDE): Define.\n \t* config/i386/i386.h (OVERRIDE_OPTION): Remove.\n-\t* config/i386/linux64.h (DEFAULT_PCC_STRUCT_RETURN): Update\n-\tcomment.\n+\t* config/i386/linux64.h (DEFAULT_PCC_STRUCT_RETURN): Update comment.\n \t* config/ia64/ia64.c (ia64_file_start): Update comment referring\n \tto ia64_override_options.\n \t* config/iq2000/iq2000-protos.h (override_options): Remove.\n \t* config/iq2000/iq2000.c (TARGET_OPTION_OVERRIDE): Define.\n-\t(override_options): Rename to iq2000_option_override.  Make\n-\tstatic.\n+\t(override_options): Rename to iq2000_option_override.  Make static.\n \t* config/iq2000/iq2000.h (OVERRIDE_OPTIONS): Remove.\n \t* config/lm32/lm32-protos.h (lm32_override_options): Remove.\n \t* config/lm32/lm32.c (TARGET_OPTION_OVERRIDE): Define.\n-\t(lm32_override_options): Rename to lm32_option_override.  Make\n-\tstatic.\n+\t(lm32_override_options): Rename to lm32_option_override.  Make static.\n \t* config/lm32/lm32.h (OVERRIDE_OPTIONS): Remove.\n \t* config/m32r/m32r.c (TARGET_OPTION_OVERRIDE): Define.\n \t(m32r_option_override): New.\n \t(m32r_init): Update comment.\n \t* config/m32r/m32r.h (OVERRIDE_OPTIONS): Remove.\n-\t* config/m68hc11/m68hc11-protos.h (m68hc11_override_options):\n-\tRemove.\n+\t* config/m68hc11/m68hc11-protos.h (m68hc11_override_options): Remove.\n \t* config/m68hc11/m68hc11.c (TARGET_OPTION_OVERRIDE): Define.\n \t(m68hc11_override_options): Rename to m68hc11_option_override.\n \tMake static.  Return void.\n@@ -418,16 +423,13 @@\n \t* config/mcore/mcore.h (OVERRIDE_OPTIONS): Remove.\n \t* config/mep/mep-protos.h (mep_override_options): Remove.\n \t* config/mep/mep.c (TARGET_OPTION_OVERRIDE): Define.\n-\t(mep_override_options): Rename to mep_option_override.  Make\n-\tstatic.\n+\t(mep_override_options): Rename to mep_option_override.  Make static.\n \t* config/mep/mep.h (OVERRIDE_OPTIONS): Remove.\n \t* config/mmix/mmix-protos.h (mmix_override_options): Remove.\n \t* config/mmix/mmix.c (TARGET_OPTION_OVERRIDE): Define.\n-\t(mmix_override_options): Rename to mmix_option_override.  Make\n-\tstatic.\n+\t(mmix_override_options): Rename to mmix_option_override.  Make static.\n \t* config/mmix/mmix.h (OVERRIDE_OPTIONS): Remove.\n-\t* config/mn10300/mn10300-protos.h (mn10300_override_options):\n-\tRemove.\n+\t* config/mn10300/mn10300-protos.h (mn10300_override_options): Remove.\n \t* config/mn10300/mn10300.c (TARGET_OPTION_OVERRIDE): Define.\n \t(mn10300_override_options): Rename to mn10300_option_override.\n \tMake static.\n@@ -444,16 +446,11 @@\n \tMake static.  Update comment and definition of\n \tTARGET_OVERRIDE_OPTIONS_AFTER_CHANGE.\n \t* config/picochip/picochip.h (OVERRIDE_OPTIONS): Remove.\n-\t* config/rs6000/aix43.h (SUBTARGET_OVERRIDE_OPTIONS): Update\n-\tcomment.\n-\t* config/rs6000/aix51.h (SUBTARGET_OVERRIDE_OPTIONS): Update\n-\tcomment.\n-\t* config/rs6000/aix52.h (SUBTARGET_OVERRIDE_OPTIONS): Update\n-\tcomment.\n-\t* config/rs6000/aix53.h (SUBTARGET_OVERRIDE_OPTIONS): Update\n-\tcomment.\n-\t* config/rs6000/aix61.h (SUBTARGET_OVERRIDE_OPTIONS): Update\n-\tcomment.\n+\t* config/rs6000/aix43.h (SUBTARGET_OVERRIDE_OPTIONS): Update comment.\n+\t* config/rs6000/aix51.h (SUBTARGET_OVERRIDE_OPTIONS): Update comment.\n+\t* config/rs6000/aix52.h (SUBTARGET_OVERRIDE_OPTIONS): Update comment.\n+\t* config/rs6000/aix53.h (SUBTARGET_OVERRIDE_OPTIONS): Update comment.\n+\t* config/rs6000/aix61.h (SUBTARGET_OVERRIDE_OPTIONS): Update comment.\n \t* config/rs6000/linux64.h (OPTION_TARGET_CPU_DEFAULT): Define\n \tinstead of OVERRIDE_OPTIONS.\n \t* config/rs6000/rs6000-modes.def: Update comment referring to\n@@ -466,8 +463,7 @@\n \t(rs6000_option_override): New.\n \t* config/rs6000/rs6000.h (OPTION_TARGET_CPU_DEFAULT): Define\n \tinstead of OVERRIDE_OPTIONS.\n-\t* config/rs6000/sysv4.h (SUBTARGET_OVERRIDE_OPTIONS): Update\n-\tcomment.\n+\t* config/rs6000/sysv4.h (SUBTARGET_OVERRIDE_OPTIONS): Update comment.\n \t* config/s390/s390-protos.h (override_options): Remove.\n \t* config/s390/s390.c (override_options): Rename to\n \ts390_option_override.  Make static.\n@@ -510,8 +506,7 @@\n \t* config/vxworks.h: Update comment referring to OVERRIDE_OPTIONS.\n \t* config/xtensa/xtensa-protos.h (override_options): Remove.\n \t* config/xtensa/xtensa.c (TARGET_OPTION_OVERRIDE): Define.\n-\t(override_options): Rename to xtensa_option_override.  Make\n-\tstatic.\n+\t(override_options): Rename to xtensa_option_override.  Make static.\n \t* config/xtensa/xtensa.h (OVERRIDE_OPTIONS): Remove.\n \n 2010-09-16  Richard Guenther  <rguenther@suse.de>\n@@ -5486,7 +5481,7 @@\n \tPR target/45142\n \t* config/i386/sse.md (vec_set<mode>_0): Do not set mode attribute for\n \talternative 2.\n-\t(vec_set<moode>_0 splitter): Use SSEMODE4S mode iterator to also\n+\t(vec_set<mode>_0 splitter): Use SSEMODE4S mode iterator to also\n \tsplit V4SI operands.\n \n 2010-08-01  Anatoly Sokolov  <aesok@post.ru>"}, {"sha": "fd31e9917f5b0945a7339ae0e155e9c8e35f650d", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=b146446c53f525ad953fc7a886baceca17c74e9a", "patch": "@@ -64,8 +64,7 @@ extern bool legitimate_pic_address_disp_p (rtx);\n extern void print_reg (rtx, int, FILE*);\n extern void ix86_print_operand (FILE *, rtx, int);\n \n-extern void split_di (rtx[], int, rtx[], rtx[]);\n-extern void split_ti (rtx[], int, rtx[], rtx[]);\n+extern void split_double_mode (enum machine_mode, rtx[], int, rtx[], rtx[]);\n \n extern const char *output_set_got (rtx, rtx);\n extern const char *output_387_binary_op (rtx, rtx*);"}, {"sha": "9644a64f865fe57500498e466d279c28e485180a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 48, "deletions": 63, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b146446c53f525ad953fc7a886baceca17c74e9a", "patch": "@@ -13248,15 +13248,33 @@ i386_asm_output_addr_const_extra (FILE *file, rtx x)\n   return true;\n }\n \f\n-/* Split one or more DImode RTL references into pairs of SImode\n+/* Split one or more double-mode RTL references into pairs of half-mode\n    references.  The RTL can be REG, offsettable MEM, integer constant, or\n-   CONST_DOUBLE.  \"operands\" is a pointer to an array of DImode RTL to\n+   CONST_DOUBLE.  \"operands\" is a pointer to an array of double-mode RTLs to\n    split and \"num\" is its length.  lo_half and hi_half are output arrays\n    that parallel \"operands\".  */\n \n void\n-split_di (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n+split_double_mode (enum machine_mode mode, rtx operands[],\n+\t\t   int num, rtx lo_half[], rtx hi_half[])\n {\n+  enum machine_mode half_mode;\n+  unsigned int byte;\n+\n+  switch (mode)\n+    {\n+    case TImode:\n+      half_mode = DImode;\n+      break;\n+    case DImode:\n+      half_mode = SImode;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  byte = GET_MODE_SIZE (half_mode);\n+\n   while (num--)\n     {\n       rtx op = operands[num];\n@@ -13265,44 +13283,17 @@ split_di (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n          but we still have to handle it.  */\n       if (MEM_P (op))\n \t{\n-\t  lo_half[num] = adjust_address (op, SImode, 0);\n-\t  hi_half[num] = adjust_address (op, SImode, 4);\n+\t  lo_half[num] = adjust_address (op, half_mode, 0);\n+\t  hi_half[num] = adjust_address (op, half_mode, byte);\n \t}\n       else\n \t{\n-\t  lo_half[num] = simplify_gen_subreg (SImode, op,\n+\t  lo_half[num] = simplify_gen_subreg (half_mode, op,\n \t\t\t\t\t      GET_MODE (op) == VOIDmode\n-\t\t\t\t\t      ? DImode : GET_MODE (op), 0);\n-\t  hi_half[num] = simplify_gen_subreg (SImode, op,\n+\t\t\t\t\t      ? mode : GET_MODE (op), 0);\n+\t  hi_half[num] = simplify_gen_subreg (half_mode, op,\n \t\t\t\t\t      GET_MODE (op) == VOIDmode\n-\t\t\t\t\t      ? DImode : GET_MODE (op), 4);\n-\t}\n-    }\n-}\n-/* Split one or more TImode RTL references into pairs of DImode\n-   references.  The RTL can be REG, offsettable MEM, integer constant, or\n-   CONST_DOUBLE.  \"operands\" is a pointer to an array of DImode RTL to\n-   split and \"num\" is its length.  lo_half and hi_half are output arrays\n-   that parallel \"operands\".  */\n-\n-void\n-split_ti (rtx operands[], int num, rtx lo_half[], rtx hi_half[])\n-{\n-  while (num--)\n-    {\n-      rtx op = operands[num];\n-\n-      /* simplify_subreg refuse to split volatile memory addresses, but we\n-         still have to handle it.  */\n-      if (MEM_P (op))\n-\t{\n-\t  lo_half[num] = adjust_address (op, DImode, 0);\n-\t  hi_half[num] = adjust_address (op, DImode, 8);\n-\t}\n-      else\n-\t{\n-\t  lo_half[num] = simplify_gen_subreg (DImode, op, TImode, 0);\n-\t  hi_half[num] = simplify_gen_subreg (DImode, op, TImode, 8);\n+\t\t\t\t\t      ? mode : GET_MODE (op), byte);\n \t}\n     }\n }\n@@ -16273,9 +16264,10 @@ ix86_expand_compare (enum rtx_code code, rtx op0, rtx op1)\n void\n ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n {\n+  enum machine_mode mode = GET_MODE (op0);\n   rtx tmp;\n \n-  switch (GET_MODE (op0))\n+  switch (mode)\n     {\n     case SFmode:\n     case DFmode:\n@@ -16306,18 +16298,11 @@ ix86_expand_branch (enum rtx_code code, rtx op0, rtx op1, rtx label)\n \t    tmp = op0, op0 = op1, op1 = tmp;\n \t    code = swap_condition (code);\n \t  }\n-\tif (GET_MODE (op0) == DImode)\n-\t  {\n-\t    split_di (&op0, 1, lo+0, hi+0);\n-\t    split_di (&op1, 1, lo+1, hi+1);\n-\t    submode = SImode;\n-\t  }\n-\telse\n-\t  {\n-\t    split_ti (&op0, 1, lo+0, hi+0);\n-\t    split_ti (&op1, 1, lo+1, hi+1);\n-\t    submode = DImode;\n-\t  }\n+\n+\tsplit_double_mode (mode, &op0, 1, lo+0, hi+0);\n+\tsplit_double_mode (mode, &op1, 1, lo+1, hi+1);\n+\n+\tsubmode = mode == DImode ? SImode : DImode;\n \n \t/* When comparing for equality, we can use (hi0^hi1)|(lo0^lo1) to\n \t   avoid two branches.  This costs one extra insn, so disable when\n@@ -16474,7 +16459,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n   enum machine_mode mode =\n     GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n \n-  /* Do not handle DImode compares that go through special path.  */\n+  /* Do not handle double-mode compares that go through special path.  */\n   if (mode == (TARGET_64BIT ? TImode : DImode))\n     return false;\n \n@@ -17686,8 +17671,8 @@ ix86_expand_int_addcc (rtx operands[])\n }\n \n \n-/* Split operands 0 and 1 into SImode parts.  Similar to split_di, but\n-   works for floating pointer parameters and nonoffsetable memories.\n+/* Split operands 0 and 1 into half-mode parts.  Similar to split_double_mode,\n+   but works for floating pointer parameters and nonoffsetable memories.\n    For pushes, it returns just stack offsets; the values will be saved\n    in the right order.  Maximally three parts are generated.  */\n \n@@ -17740,7 +17725,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n   if (!TARGET_64BIT)\n     {\n       if (mode == DImode)\n-\tsplit_di (&operand, 1, &parts[0], &parts[1]);\n+\tsplit_double_mode (mode, &operand, 1, &parts[0], &parts[1]);\n       else\n \t{\n \t  int i;\n@@ -17791,7 +17776,7 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n   else\n     {\n       if (mode == TImode)\n-\tsplit_ti (&operand, 1, &parts[0], &parts[1]);\n+\tsplit_double_mode (mode, &operand, 1, &parts[0], &parts[1]);\n       if (mode == XFmode || mode == TFmode)\n \t{\n \t  enum machine_mode upper_mode = mode==XFmode ? SImode : DImode;\n@@ -17862,7 +17847,7 @@ ix86_split_long_move (rtx operands[])\n   /* The DFmode expanders may ask us to move double.\n      For 64bit target this is single move.  By hiding the fact\n      here we simplify i386.md splitters.  */\n-  if (GET_MODE_SIZE (GET_MODE (operands[0])) == 8 && TARGET_64BIT)\n+  if (TARGET_64BIT && GET_MODE_SIZE (GET_MODE (operands[0])) == 8)\n     {\n       /* Optimize constant pool reference to immediates.  This is used by\n \t fp moves, that force all constants to memory to allow combining.  */\n@@ -18104,7 +18089,7 @@ ix86_split_ashl (rtx *operands, rtx scratch, enum machine_mode mode)\n \n   if (CONST_INT_P (operands[2]))\n     {\n-      (mode == DImode ? split_di : split_ti) (operands, 2, low, high);\n+      split_double_mode (mode, operands, 2, low, high);\n       count = INTVAL (operands[2]) & (single_width * 2 - 1);\n \n       if (count >= single_width)\n@@ -18127,7 +18112,7 @@ ix86_split_ashl (rtx *operands, rtx scratch, enum machine_mode mode)\n       return;\n     }\n \n-  (mode == DImode ? split_di : split_ti) (operands, 1, low, high);\n+  split_double_mode (mode, operands, 1, low, high);\n \n   if (operands[1] == const1_rtx)\n     {\n@@ -18204,7 +18189,7 @@ ix86_split_ashl (rtx *operands, rtx scratch, enum machine_mode mode)\n       if (!rtx_equal_p (operands[0], operands[1]))\n \temit_move_insn (operands[0], operands[1]);\n \n-      (mode == DImode ? split_di : split_ti) (operands, 1, low, high);\n+      split_double_mode (mode, operands, 1, low, high);\n       emit_insn ((mode == DImode\n \t\t  ? gen_x86_shld\n \t\t  : gen_x86_64_shld) (high[0], low[0], operands[2]));\n@@ -18237,7 +18222,7 @@ ix86_split_ashr (rtx *operands, rtx scratch, enum machine_mode mode)\n \n   if (CONST_INT_P (operands[2]))\n     {\n-      (mode == DImode ? split_di : split_ti) (operands, 2, low, high);\n+      split_double_mode (mode, operands, 2, low, high);\n       count = INTVAL (operands[2]) & (single_width * 2 - 1);\n \n       if (count == single_width * 2 - 1)\n@@ -18281,7 +18266,7 @@ ix86_split_ashr (rtx *operands, rtx scratch, enum machine_mode mode)\n       if (!rtx_equal_p (operands[0], operands[1]))\n \temit_move_insn (operands[0], operands[1]);\n \n-      (mode == DImode ? split_di : split_ti) (operands, 1, low, high);\n+      split_double_mode (mode, operands, 1, low, high);\n \n       emit_insn ((mode == DImode\n \t\t  ? gen_x86_shrd\n@@ -18318,7 +18303,7 @@ ix86_split_lshr (rtx *operands, rtx scratch, enum machine_mode mode)\n \n   if (CONST_INT_P (operands[2]))\n     {\n-      (mode == DImode ? split_di : split_ti) (operands, 2, low, high);\n+      split_double_mode (mode, operands, 2, low, high);\n       count = INTVAL (operands[2]) & (single_width * 2 - 1);\n \n       if (count >= single_width)\n@@ -18349,7 +18334,7 @@ ix86_split_lshr (rtx *operands, rtx scratch, enum machine_mode mode)\n       if (!rtx_equal_p (operands[0], operands[1]))\n \temit_move_insn (operands[0], operands[1]);\n \n-      (mode == DImode ? split_di : split_ti) (operands, 1, low, high);\n+      split_double_mode (mode, operands, 1, low, high);\n \n       emit_insn ((mode == DImode\n \t\t  ? gen_x86_shrd\n@@ -26144,7 +26129,7 @@ ix86_force_to_memory (enum machine_mode mode, rtx operand)\n \tcase DImode:\n \t  {\n \t    rtx operands[2];\n-\t    split_di (&operand, 1, operands, operands + 1);\n+\t    split_double_mode (mode, &operand, 1, operands, operands + 1);\n \t    emit_insn (\n \t\t\tgen_rtx_SET (VOIDmode,\n \t\t\t\t     gen_rtx_MEM (SImode,"}, {"sha": "e3161bb7e666fd715cde6259ef0b90c14206c634", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b146446c53f525ad953fc7a886baceca17c74e9a", "patch": "@@ -1640,7 +1640,7 @@\n   [(set (match_dup 0) (match_dup 1))\n    (set (match_dup 2) (match_dup 3))]\n {\n-  split_di (&operands[1], 1, &operands[2], &operands[3]);\n+  split_double_mode (DImode, &operands[1], 1, &operands[2], &operands[3]);\n \n   operands[1] = gen_lowpart (DImode, operands[2]);\n   operands[2] = gen_rtx_MEM (SImode, gen_rtx_PLUS (DImode, stack_pointer_rtx,\n@@ -1657,7 +1657,7 @@\n   [(set (match_dup 0) (match_dup 1))\n    (set (match_dup 2) (match_dup 3))]\n {\n-  split_di (&operands[1], 1, &operands[2], &operands[3]);\n+  split_double_mode (DImode, &operands[1], 1, &operands[2], &operands[3]);\n \n   operands[1] = gen_lowpart (DImode, operands[2]);\n   operands[2] = gen_rtx_MEM (SImode, gen_rtx_PLUS (DImode, stack_pointer_rtx,\n@@ -2050,7 +2050,7 @@\n    && !x86_64_immediate_operand (operands[1], DImode) && 1\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (match_dup 5))]\n-  \"split_di (&operands[0], 2, &operands[2], &operands[4]);\")\n+  \"split_double_mode (DImode, &operands[0], 2, &operands[2], &operands[4]);\")\n \n (define_split\n   [(set (match_operand:DI 0 \"memory_operand\" \"\")\n@@ -2061,7 +2061,7 @@\n    && !x86_64_immediate_operand (operands[1], DImode)\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 4) (match_dup 5))]\n-  \"split_di (&operands[0], 2, &operands[2], &operands[4]);\")\n+  \"split_double_mode (DImode, &operands[0], 2, &operands[2], &operands[4]);\")\n \n (define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n@@ -3598,7 +3598,7 @@\n      \t(zero_extend:DI (match_dup 0)))]\n   \"TARGET_64BIT\"\n   [(set (match_dup 4) (const_int 0))]\n-  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n+  \"split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\")\n \n ;; %%% Kill me once multi-word ops are sane.\n (define_insn \"zero_extendsidi2_1\"\n@@ -3626,7 +3626,7 @@\n   \"!TARGET_64BIT && reload_completed\n    && true_regnum (operands[0]) == true_regnum (operands[1])\"\n   [(set (match_dup 4) (const_int 0))]\n-  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n+  \"split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\")\n \n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n@@ -3636,7 +3636,7 @@\n    && !(MMX_REG_P (operands[0]) || SSE_REG_P (operands[0]))\"\n   [(set (match_dup 3) (match_dup 1))\n    (set (match_dup 4) (const_int 0))]\n-  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n+  \"split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\")\n \n (define_insn \"zero_extend<mode>di2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -3801,7 +3801,7 @@\n    (parallel [(set (match_dup 1) (ashiftrt:SI (match_dup 1) (const_int 31)))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (set (match_dup 4) (match_dup 1))]\n-  \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n+  \"split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\")\n \n ;; Extend to memory case when source register does not die.\n (define_split\n@@ -3812,7 +3812,7 @@\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  split_di (&operands[0], 1, &operands[3], &operands[4]);\n+  split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\n \n   emit_move_insn (operands[3], operands[1]);\n \n@@ -3842,7 +3842,7 @@\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  split_di (&operands[0], 1, &operands[3], &operands[4]);\n+  split_double_mode (DImode, &operands[0], 1, &operands[3], &operands[4]);\n \n   if (true_regnum (operands[3]) != true_regnum (operands[1]))\n     emit_move_insn (operands[3], operands[1]);\n@@ -5570,7 +5570,7 @@\n \t\t       (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n \t\t       (match_dup 5))))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"split_<dwi> (&operands[0], 3, &operands[0], &operands[3]);\")\n+  \"split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);\")\n \n (define_insn \"*add<mode>3_cc\"\n   [(set (reg:CC FLAGS_REG)\n@@ -6600,7 +6600,7 @@\n \t\t       (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n \t\t       (match_dup 5))))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"split_<dwi> (&operands[0], 3, &operands[0], &operands[3]);\")\n+  \"split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);\")\n \n (define_insn \"*sub<mode>_1\"\n   [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m,<r>\")\n@@ -8593,7 +8593,7 @@\n     [(set (match_dup 2)\n \t  (neg:DWIH (match_dup 2)))\n      (clobber (reg:CC FLAGS_REG))])]\n-  \"split_<dwi> (&operands[0], 2, &operands[0], &operands[2]);\")\n+  \"split_double_mode (<DWI>mode, &operands[0], 2, &operands[0], &operands[2]);\")\n \n (define_insn \"*neg<mode>2_1\"\n   [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n@@ -10072,7 +10072,7 @@\n {\n   operands[6] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode));\n \n-  split_<dwi> (&operands[0], 1, &operands[4], &operands[5]);\n+  split_double_mode (<DWI>mode, &operands[0], 1, &operands[4], &operands[5]);\n })\n \n (define_insn_and_split \"ix86_rotr<dwi>3_doubleword\"\n@@ -10100,7 +10100,7 @@\n {\n   operands[6] = GEN_INT (GET_MODE_BITSIZE (<MODE>mode));\n \n-  split_<dwi> (&operands[0], 1, &operands[4], &operands[5]);\n+  split_double_mode (<DWI>mode, &operands[0], 1, &operands[4], &operands[5]);\n })\n \n (define_insn \"*<rotate_insn><mode>3_1\"\n@@ -16055,8 +16055,8 @@\n \t\t      (match_dup 7)\n \t\t      (match_dup 8)))]\n {\n-  split_di (&operands[2], 2, &operands[5], &operands[7]);\n-  split_di (&operands[0], 1, &operands[2], &operands[3]);\n+  split_double_mode (DImode, &operands[2], 2, &operands[5], &operands[7]);\n+  split_double_mode (DImode, &operands[0], 1, &operands[2], &operands[3]);\n })\n \n (define_insn \"*movxfcc_1\""}, {"sha": "9deaf42652acdf14c4103a8685a1639d68a4c781", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b146446c53f525ad953fc7a886baceca17c74e9a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b146446c53f525ad953fc7a886baceca17c74e9a", "patch": "@@ -66,7 +66,7 @@\n \n 2010-09-17  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n-\tPR testsuite/45692\t\n+\tPR testsuite/45692\n \t* objc/execute/exceptions/throw-nil.m: Run the test only with the\n \tGNU runtime.\n "}]}