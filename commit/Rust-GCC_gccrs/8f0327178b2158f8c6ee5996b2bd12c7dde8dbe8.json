{"sha": "8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYwMzI3MTc4YjIxNThmOGM2ZWU1OTk2YjJiZDEyYzdkZGU4ZGJlOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-02T15:36:57Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-02T15:36:57Z"}, "message": "tinfo.h (__class_type_info): Fix illegal declaration.\n\n1999-04-02  Mark Mitchell  <mark@codesourcery.com>\n\t* tinfo.h (__class_type_info): Fix illegal declaration.\n\t* cp-tree.def (TEMPLATE_ID_EXPR): Update comment.\n\t* cp-tree.h (INHERITED_VALUE_BINDING_P): New macro.\n\t(IDENTIFIER_CLASS_VALUE): Improve documentation.\n\t(is_properly_derived_from): Declare.\n\t(invalidate_class_lookup_cache): Likewise.\n\t(maybe_maybe_note_name_used_in_class): Likewise.\n\t(note_name_declared_in_class): Likewise.\n\t(push_using_decl): Remove duplicate declaration.\n\t(id_in_current_class): Remove declaration.\n\t(push_class_binding): Change prototype.\n\t(clear_identitifer_class_values): Declare.\n\t* call.c (is_properly_derived_from): Make it global.\n\t(build_new_function_call): Be careful about updating candidates.\n\t(build_new_method_call): Handle COMPONENT_REFs.  Don't crash when\n\tasked to make illegal calls.\n\t* class.c: Include splay-tree.h.\n\t(class_stack_node): Add names_used slot.\n\t(check_member_decl_is_same_in_complete_scope): Remove.\n\t(add_method): Fix comment.  Push the declaration into class\n\tscope.\n\t(finish_struct_1): When popping the class, pop the bindings too.\n\tRemove check for data member/function member conflict.\n\t(finish_struct): Remove calls to\n\tcheck_member_decl_is_same_in_complete_scope.  Change calls to\n\tpopclass.\n\t(pushclass): Clear names_used in the class stack entry.\n\tUse invalidate_class_lookup_cache to remove cached entries, rather\n\tthan magic values with popclass.  Clear IDENTIFIER_CLASS_VALUE\n\tbefore entering a new class.  Remove dead code.  Don't mess with\n\tcurrent_function_decl when pushing declarations.\n\t(invalidate_class_lookup_cache): New function, split out from ...\n\t(popclass): Here.  Clean up names_used on our way out.\n\t(instantiate_type): Adjust.\n\t(build_self_reference): Don't push the declaration here.\n\t(maybe_note_name_used_in_class): New function.\n\t(note_name_declared_in_class): Likewise.\n\t* decl.c (add_binding): Change prototype.\n\t(find_class_binding_level): New function.\n\t(innermost_nonclass_level): Likewise.\n\t(current_binding_level): Update documentation.\n\t(inner_binding_level): Remove.  Replace with current_binding_level\n\tthroughout.\n\t(push_binding_level): Remove special handling of\n\tclass_binding_level.\n\t(pop_binding_level): Likewise.  Use find_class_binding_level.\n\t(suspend_binding_level): Likewise.\n\t(global_bindings_p): Use innermost_nonclass_level.\n\t(toplevel_bindings_p): Likewise.\n\t(namespace_bindings_p): Likewise.\n\t(pseudo_global_level_p): Likewise.\n\t(push_binding): Clear INHERITED_VALUE_BINDING_P.\n\t(add_binding): Check for illegal multiple declarations.  Return a\n\tvalue indicating whether or not the new binding was legal.\n\t(push_local_binding): Skip over class binding levels.  Check\n\treturn value from add_binding.\n\t(push_class_binding): Set INHERITED_VALUE_BINDING_P.  Call\n\tnote_name_declared_in_class.\n\t(pushlevel_class): Remove \"fake out the rest of the compiler\"\n\tcode.\n\t(poplevel_class): Reset IDENTIFIER_CLASS_VALUEs.\n\t(clear_identifier_class_values): New function.\n\t(pop_from_top_level): Use it.\n\t(pop_everything): Tweak.\n\t(maybe_process_template_type_declaration): Don't push the\n\tdeclaration for the template here.\n\t(pushtag): Don't push tag declarations into class scope here.\n\t(pushdecl): Apply DeMorgan's law for readability.\n\t(pushdecl_class_level): Remove special-case code for\n\tTYPE_BEING_DEFINED.  Handle OVERLOADs and anonymous unions.\n\t(push_class_level_bindng): Deal with inherited bindings.\n\t(lookup_name_real): Remove special-case code for\n\tTYPE_BEING_DEFINED, and some implicit typename magic.\n\t(grokdeclarator): Handle COMPONENT_REF for a template function.\n\t(build_enumerator): Don't call pushdecl_class_level here.\n\t(id_in_current_class): Remove.\n\t* decl2.c (grokfield): Don't call pushdecl_class_level or\n\tcheck_template_shadow.\n\t* errfn.c (cp_file_of): Don't declare.\n\t(cp_line_of): Likewise.\n\t* error.c (dump_decl): Handle an OVERLOAD.\n\t(cp_file_of): Likewise.\n\t(cp_line_of): Likewise.\n\t* init.c (build_member_call): Handle a COMPONENT_REF.\n\t* lex.c (do_identifier): Call maybe_note_name_used_in_class, not\n\tpushdecl_class_level.\n\t* method.c (hack_identifier): Build COMPONENT_REFs for references\n\tto member templates as well as member functions.  Remove dead\n\tcode.\n\t* parse.y (left_curly): Remove.\n\t(nonnested_type): Call maybe_note_name_used_in_class, not\n\tpushdecl_class_level.\n\t* parse.c: Regenerated.\n\t(nested_name_specifier_1): Likewise.\n\t* pt.c (check_explicit_specialization): Adjust, for robustness.\n\t(check_template_shadow): Handle OVERLOADs.\n\t(build_template_decl): Set DECL_CONSTRUCTOR_P on the\n\tTEMPLATE_DECL, if appropriate.\n\t* search.c (envelope_add_decl): Remove.\n\t(dfs_pushdecls): Likewise.\n\t(dfs_compress_decls): Likewise.\n\t(dfs_push_decls): New function.\n\t(dfs_push_type_decls): Likewise.\n\t(setup_class_bindings): Likewise.\n\t(template_self_reference_p): Likewise.\n\t(lookup_field_r): Use it.\n\t(looup_member): Remove old comment.  Deal with ambiguity.\n\t(push_class_decls): Use dfs_push_decls and dfs_push_type_decls,\n\tand remove envelope processing.\n\t* semantics.c (begin_class_definition): Let pushclass push\n\tdeclarations for base classes.\n\t(finish_member_declaration): Push declarations into class scope.\n\t* typeck.c (build_component_ref): Just put an OVERLOAD into the\n\tCOMPONENT_REF, not a TREE_LIST of an OVERLOAD.\n\t(build_x_function_call): Deal with OVERLOAD.  Handle template-ids.\n\t* Makefile.in (class.o): Depend on splay-tree.h.\n\nFrom-SVN: r26133", "tree": {"sha": "02cb3c75e09886d14b7139c3afd1bb1d30e0d868", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02cb3c75e09886d14b7139c3afd1bb1d30e0d868"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/comments", "author": null, "committer": null, "parents": [{"sha": "ae7f727035108e8c78bfa4d2d506041169d0db1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae7f727035108e8c78bfa4d2d506041169d0db1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae7f727035108e8c78bfa4d2d506041169d0db1b"}], "stats": {"total": 7575, "additions": 3829, "deletions": 3746}, "files": [{"sha": "186a1e5e879d0b8f2021a3e3513920c124e22140", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -1,3 +1,123 @@\n+1999-04-02  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* tinfo.h (__class_type_info): Fix illegal declaration.\n+\t\n+\t* cp-tree.def (TEMPLATE_ID_EXPR): Update comment.\n+\t* cp-tree.h (INHERITED_VALUE_BINDING_P): New macro.\n+\t(IDENTIFIER_CLASS_VALUE): Improve documentation.\n+\t(is_properly_derived_from): Declare.\n+\t(invalidate_class_lookup_cache): Likewise.\n+\t(maybe_maybe_note_name_used_in_class): Likewise.\n+\t(note_name_declared_in_class): Likewise.\n+\t(push_using_decl): Remove duplicate declaration.\n+\t(id_in_current_class): Remove declaration.\n+\t(push_class_binding): Change prototype.\n+\t(clear_identitifer_class_values): Declare.\n+\t* call.c (is_properly_derived_from): Make it global.\n+\t(build_new_function_call): Be careful about updating candidates.\n+\t(build_new_method_call): Handle COMPONENT_REFs.  Don't crash when\n+\tasked to make illegal calls.\n+\t* class.c: Include splay-tree.h.\n+\t(class_stack_node): Add names_used slot.\n+\t(check_member_decl_is_same_in_complete_scope): Remove.\n+\t(add_method): Fix comment.  Push the declaration into class\n+\tscope.\n+\t(finish_struct_1): When popping the class, pop the bindings too.\n+\tRemove check for data member/function member conflict.\n+\t(finish_struct): Remove calls to\n+\tcheck_member_decl_is_same_in_complete_scope.  Change calls to\n+\tpopclass.\n+\t(pushclass): Clear names_used in the class stack entry.\n+\tUse invalidate_class_lookup_cache to remove cached entries, rather\n+\tthan magic values with popclass.  Clear IDENTIFIER_CLASS_VALUE\n+\tbefore entering a new class.  Remove dead code.  Don't mess with\n+\tcurrent_function_decl when pushing declarations.\n+\t(invalidate_class_lookup_cache): New function, split out from ...\n+\t(popclass): Here.  Clean up names_used on our way out.\n+\t(instantiate_type): Adjust.\n+\t(build_self_reference): Don't push the declaration here.\n+\t(maybe_note_name_used_in_class): New function.\n+\t(note_name_declared_in_class): Likewise.\n+\t* decl.c (add_binding): Change prototype.\n+\t(find_class_binding_level): New function.\n+\t(innermost_nonclass_level): Likewise.\n+\t(current_binding_level): Update documentation.\n+\t(inner_binding_level): Remove.  Replace with current_binding_level\n+\tthroughout.\n+\t(push_binding_level): Remove special handling of\n+\tclass_binding_level.\n+\t(pop_binding_level): Likewise.  Use find_class_binding_level.\n+\t(suspend_binding_level): Likewise.\n+\t(global_bindings_p): Use innermost_nonclass_level.\n+\t(toplevel_bindings_p): Likewise.\n+\t(namespace_bindings_p): Likewise.\n+\t(pseudo_global_level_p): Likewise.\n+\t(push_binding): Clear INHERITED_VALUE_BINDING_P.\n+\t(add_binding): Check for illegal multiple declarations.  Return a\n+\tvalue indicating whether or not the new binding was legal.\n+\t(push_local_binding): Skip over class binding levels.  Check\n+\treturn value from add_binding.\n+\t(push_class_binding): Set INHERITED_VALUE_BINDING_P.  Call\n+\tnote_name_declared_in_class.\n+\t(pushlevel_class): Remove \"fake out the rest of the compiler\"\n+\tcode.\n+\t(poplevel_class): Reset IDENTIFIER_CLASS_VALUEs.\n+\t(clear_identifier_class_values): New function.\n+\t(pop_from_top_level): Use it.\n+\t(pop_everything): Tweak.\n+\t(maybe_process_template_type_declaration): Don't push the\n+\tdeclaration for the template here.\n+\t(pushtag): Don't push tag declarations into class scope here.\n+\t(pushdecl): Apply DeMorgan's law for readability.\n+\t(pushdecl_class_level): Remove special-case code for\n+\tTYPE_BEING_DEFINED.  Handle OVERLOADs and anonymous unions.\n+\t(push_class_level_bindng): Deal with inherited bindings.\n+\t(lookup_name_real): Remove special-case code for\n+\tTYPE_BEING_DEFINED, and some implicit typename magic.\n+\t(grokdeclarator): Handle COMPONENT_REF for a template function.\n+\t(build_enumerator): Don't call pushdecl_class_level here.\n+\t(id_in_current_class): Remove.\n+\t* decl2.c (grokfield): Don't call pushdecl_class_level or\n+\tcheck_template_shadow.\n+\t* errfn.c (cp_file_of): Don't declare.\n+\t(cp_line_of): Likewise.\n+\t* error.c (dump_decl): Handle an OVERLOAD.\n+\t(cp_file_of): Likewise.\n+\t(cp_line_of): Likewise.\n+\t* init.c (build_member_call): Handle a COMPONENT_REF.\n+\t* lex.c (do_identifier): Call maybe_note_name_used_in_class, not\n+\tpushdecl_class_level.\n+\t* method.c (hack_identifier): Build COMPONENT_REFs for references\n+\tto member templates as well as member functions.  Remove dead\n+\tcode.\n+\t* parse.y (left_curly): Remove.\n+\t(nonnested_type): Call maybe_note_name_used_in_class, not\n+\tpushdecl_class_level.\n+\t* parse.c: Regenerated.\n+\t(nested_name_specifier_1): Likewise.\n+\t* pt.c (check_explicit_specialization): Adjust, for robustness.\n+\t(check_template_shadow): Handle OVERLOADs.\n+\t(build_template_decl): Set DECL_CONSTRUCTOR_P on the\n+\tTEMPLATE_DECL, if appropriate.\n+\t* search.c (envelope_add_decl): Remove.\n+\t(dfs_pushdecls): Likewise.\n+\t(dfs_compress_decls): Likewise.\n+\t(dfs_push_decls): New function.\n+\t(dfs_push_type_decls): Likewise.\n+\t(setup_class_bindings): Likewise.\n+\t(template_self_reference_p): Likewise.\n+\t(lookup_field_r): Use it.\n+\t(looup_member): Remove old comment.  Deal with ambiguity.\n+\t(push_class_decls): Use dfs_push_decls and dfs_push_type_decls,\n+\tand remove envelope processing.\n+\t* semantics.c (begin_class_definition): Let pushclass push\n+\tdeclarations for base classes.\n+\t(finish_member_declaration): Push declarations into class scope.\n+\t* typeck.c (build_component_ref): Just put an OVERLOAD into the\n+\tCOMPONENT_REF, not a TREE_LIST of an OVERLOAD.\n+\t(build_x_function_call): Deal with OVERLOAD.  Handle template-ids.\n+\t* Makefile.in (class.o): Depend on splay-tree.h.\n+\t\n Wed Mar 31 11:30:43 BST 1999  Nathan Sidwell  <nathan@acm.org>\n \n \t* cvt.c (convert_pointer_to_real): Use same_type_p."}, {"sha": "576e97b9538655f34be49acae46fd6f6f2371e2b", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -267,7 +267,8 @@ typeck2.o : typeck2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n typeck.o : typeck.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h\n class.o : class.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n+  $(srcdir)/../../include/splay-tree.h\n call.o : call.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n friend.o : friend.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\"}, {"sha": "f3ef258d8694b4cb50656418368f26bc0b1289c8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -87,7 +87,6 @@ static tree strip_top_quals PROTO((tree));\n static tree non_reference PROTO((tree));\n static tree build_conv PROTO((enum tree_code, tree, tree));\n static int is_subseq PROTO((tree, tree));\n-static int is_properly_derived_from PROTO((tree, tree));\n static int maybe_handle_ref_bind PROTO((tree*, tree*));\n static void maybe_handle_implicit_object PROTO((tree*));\n static struct z_candidate * add_candidate PROTO((struct z_candidate *,\n@@ -2312,6 +2311,8 @@ build_new_function_call (fn, args)\n       for (t1 = fn; t1; t1 = OVL_CHAIN (t1))\n \t{\n \t  tree t = OVL_FUNCTION (t1);\n+\t  struct z_candidate *old_candidates = candidates;\n+\n \t  if (TREE_CODE (t) == TEMPLATE_DECL)\n \t    {\n \t      templates = scratch_tree_cons (NULL_TREE, t, templates);\n@@ -2322,6 +2323,9 @@ build_new_function_call (fn, args)\n \t  else if (! template_only)\n \t    candidates = add_function_candidate\n \t      (candidates, t, args, LOOKUP_NORMAL);\n+\n+\t  if (candidates != old_candidates)\n+\t    candidates->basetype_path = DECL_REAL_CONTEXT (t);\n \t}\n \n       if (! any_viable (candidates))\n@@ -3524,8 +3528,16 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     {\n       explicit_targs = TREE_OPERAND (name, 1);\n       name = TREE_OPERAND (name, 0);\n-      if (TREE_CODE (name) == TEMPLATE_DECL)\n+      if (TREE_CODE_CLASS (TREE_CODE (name)) == 'd')\n \tname = DECL_NAME (name);\n+      else \n+\t{\n+\t  if (TREE_CODE (name) == COMPONENT_REF)\n+\t    name = TREE_OPERAND (name, 1);\n+\t  if (TREE_CODE (name) == OVERLOAD)\n+\t    name = DECL_NAME (OVL_CURRENT (name));\n+\t}\n+\n       template_only = 1;\n     }\n \n@@ -3675,7 +3687,10 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     cp_error (\"abstract virtual `%#D' called from constructor\", cand->fn);\n   if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n       && is_dummy_object (instance_ptr))\n-    cp_error (\"cannot call member function `%D' without object\", cand->fn);\n+    {\n+      cp_error (\"cannot call member function `%D' without object\", cand->fn);\n+      return error_mark_node;\n+    }\n \n   if (DECL_VINDEX (cand->fn) && ! (flags & LOOKUP_NONVIRTUAL)\n       && ((instance == current_class_ref && (dtor_label || ctor_label))\n@@ -3738,7 +3753,7 @@ is_subseq (ics1, ics2)\n /* Returns non-zero iff DERIVED is derived from BASE.  The inputs may\n    be any _TYPE nodes.  */\n \n-static int\n+int\n is_properly_derived_from (derived, base)\n      tree derived;\n      tree base;"}, {"sha": "7fd1eeb4ef50c88d4a5ad752800a0bf58b04d942", "filename": "gcc/cp/class.c", "status": "modified", "additions": 117, "deletions": 137, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -30,6 +30,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n+#include \"splay-tree.h\"\n \n #include \"obstack.h\"\n #define obstack_chunk_alloc xmalloc\n@@ -62,6 +63,9 @@ typedef struct class_stack_node {\n   /* The access specifier pending for new declarations in the scope of\n      this class.  */\n   tree access;\n+\n+  /* If were defining TYPE, the names used in this class.  */\n+  splay_tree names_used;\n }* class_stack_node_t;\n \n /* The stack itself.  This is an dynamically resized array.  The\n@@ -130,7 +134,6 @@ static void build_class_init_list PROTO((tree));\n static int finish_base_struct PROTO((tree, struct base_info *));\n static void finish_struct_methods PROTO((tree));\n static void maybe_warn_about_overly_private_class PROTO ((tree));\n-static void check_member_decl_is_same_in_complete_scope PROTO((tree, tree));\n static tree make_method_vec PROTO((int));\n static void free_method_vec PROTO((tree));\n static tree add_implicitly_declared_members PROTO((tree, int, int, int));\n@@ -1286,7 +1289,7 @@ add_method (type, fields, method)\n \n \t      /* We don't call duplicate_decls here to merge the\n \t\t declarations because that will confuse things if the\n-\t\t methods have inline definitions In particular, we\n+\t\t methods have inline definitions.  In particular, we\n \t\t will crash while processing the definitions.  */\n \t      return;\n \t    }\n@@ -1295,6 +1298,12 @@ add_method (type, fields, method)\n       /* Actually insert the new method.  */\n       TREE_VEC_ELT (method_vec, slot) \n \t= build_overload (method, TREE_VEC_ELT (method_vec, slot));\n+\n+      /* Add the new binding.  */ \n+      if (!DECL_CONSTRUCTOR_P (method)\n+\t  && !DECL_DESTRUCTOR_P (method))\n+\tpush_class_level_binding (DECL_NAME (method),\n+\t\t\t\t  TREE_VEC_ELT (method_vec, slot));\n     }\n   pop_obstacks ();\n }\n@@ -3255,7 +3264,7 @@ finish_struct_1 (t, warn_anon)\n \tcp_error (\"redefinition of `%#T'\", t);\n       else\n \tmy_friendly_abort (172);\n-      popclass (0);\n+      popclass (1);\n       return t;\n     }\n \n@@ -3838,32 +3847,6 @@ finish_struct_1 (t, warn_anon)\n   /* Delete all duplicate fields from the fields */\n   delete_duplicate_fields (fields);\n \n-  /* Catch function/field name conflict.  We don't need to do this for a\n-     signature, since it can only contain the fields constructed in\n-     append_signature_fields.  */\n-  if (! IS_SIGNATURE (t))\n-    {\n-      int n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n-      for (x = fields; x; x = TREE_CHAIN (x))\n-\t{\n-\t  tree name = DECL_NAME (x);\n-\t  int i;\n-\n-\t  if (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x))\n-\t    continue;\n-\n-\t  for (i = 2; i < n_methods && TREE_VEC_ELT (method_vec, i); ++i)\n-\t    if (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i)))\n-\t\t== name)\n-\t      {\n-\t\tcp_error_at (\"data member `%#D' conflicts with\", x);\n-\t\tcp_error_at (\"function member `%#D'\",\n-\t\t\t     OVL_CURRENT (TREE_VEC_ELT (method_vec, i)));\n-\t\tbreak;\n-\t      }\n-\t}\n-    }\n-\n   /* Now we have the nearly final fieldlist for the data fields.  Record it,\n      then lay out the structure or union (including the fields).  */\n \n@@ -4258,54 +4241,6 @@ finish_struct_1 (t, warn_anon)\n   return t;\n }\n \n-/* In [basic.scope.class] we have:\n-\n-     A name N used in a class S shall refer to the same declaration in\n-     its context and when re-evaluated in the completed scope of S.\n-     \n-   This function checks this condition for X, which is a member of\n-   T.  */\n-\n-static void\n-check_member_decl_is_same_in_complete_scope (t, x)\n-     tree t;\n-     tree x;\n-{\n-  /* A name N used in a class S shall refer to the same declaration in\n-     its context and when re-evaluated in the completed scope of S.\n-     \n-     Enums, types and static vars have already been checked.  */\n-  if (TREE_CODE (x) != USING_DECL \n-      && TREE_CODE (x) != TYPE_DECL && !DECL_CLASS_TEMPLATE_P (x)\n-      && TREE_CODE (x) != CONST_DECL && TREE_CODE (x) != VAR_DECL)\n-    {\n-      tree name = DECL_NAME (x);\n-      tree icv;\n-\n-      /* Don't get confused by access decls.  */\n-      if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n-\ticv = IDENTIFIER_CLASS_VALUE (name);\n-      else\n-\ticv = NULL_TREE;\n-\n-      /* This should match pushdecl_class_level.  */\n-      if (icv && icv != x\n-\t  && flag_optional_diags\n-\t  /* Don't complain about constructors.  */\n-\t  && name != constructor_name (current_class_type)\n-\t  /* Or inherited names.  */\n-\t  && id_in_current_class (name)\n-\t  /* Or shadowed tags.  */\n-\t  && !(TREE_CODE (icv) == TYPE_DECL && DECL_CONTEXT (icv) == t))\n-\t{\n-\t  cp_pedwarn_at (\"declaration of identifier `%D' as `%+#D'\",\n-\t\t\t name, x);\n-\t  cp_pedwarn_at (\"conflicts with other use in class as `%#D'\",\n-\t\t\t icv);\n-\t}\n-    }\n-}\n-\n /* When T was built up, the member declarations were added in reverse\n    order.  Rearrange them to declaration order.  */\n \n@@ -4372,14 +4307,6 @@ finish_struct (t, attributes, warn_anon)\n      as necessary.  */\n   unreverse_member_declarations (t);\n \n-  if (flag_optional_diags) \n-    {\n-      for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n-\tcheck_member_decl_is_same_in_complete_scope (t, x);\n-      for (x = TYPE_FIELDS (t); x; x = TREE_CHAIN (x))\n-\tcheck_member_decl_is_same_in_complete_scope (t, x);\n-    }\n-\n   /* Mark all the tags in the class as class-local.  */\n   for (x = CLASSTYPE_TAGS (t); x; x = TREE_CHAIN (x))\n     TREE_NONLOCAL_FLAG (TREE_VALUE (x)) = 0;\n@@ -4413,8 +4340,9 @@ finish_struct (t, attributes, warn_anon)\n     t = finish_struct_1 (t, warn_anon);\n \n   TYPE_BEING_DEFINED (t) = 0;\n+\n   if (current_class_type)\n-    popclass (0);\n+    popclass (1);\n   else\n     error (\"trying to finish struct, but kicked out due to previous parse errors.\");\n \n@@ -4636,6 +4564,7 @@ pushclass (type, modify)\n   current_class_stack[current_class_depth].name = current_class_name;\n   current_class_stack[current_class_depth].type = current_class_type;\n   current_class_stack[current_class_depth].access = current_access_specifier;\n+  current_class_stack[current_class_depth].names_used = 0;\n   current_class_depth++;\n \n   /* Now set up the new type.  */\n@@ -4651,19 +4580,24 @@ pushclass (type, modify)\n \t\t\t      : access_public_node);\n \n   if (previous_class_type != NULL_TREE\n-      && (type != previous_class_type || TYPE_SIZE (previous_class_type) == NULL_TREE)\n+      && (type != previous_class_type \n+\t  || TYPE_SIZE (previous_class_type) == NULL_TREE)\n       && current_class_depth == 1)\n     {\n       /* Forcibly remove any old class remnants.  */\n-      popclass (-1);\n-      previous_class_type = NULL_TREE;\n+      invalidate_class_lookup_cache ();\n \n       /* Now, free the obstack on which we cached all the values.  */\n       obstack_free (&class_cache_obstack, class_cache_firstobj);\n       class_cache_firstobj \n \t= (char*) obstack_finish (&class_cache_obstack);\n     }\n \n+  /* If we're about to enter a nested class, clear\n+     IDENTIFIER_CLASS_VALUE for the enclosing classes.  */\n+  if (modify && current_class_depth > 1)\n+    clear_identifier_class_values ();\n+\n   pushlevel_class ();\n \n #if 0\n@@ -4674,25 +4608,9 @@ pushclass (type, modify)\n   if (modify)\n     {\n       tree tags;\n-      tree this_fndecl = current_function_decl;\n-\n-      if (current_function_decl\n-\t  && DECL_CONTEXT (current_function_decl)\n-\t  && TREE_CODE (DECL_CONTEXT (current_function_decl)) == FUNCTION_DECL)\n-\tcurrent_function_decl = DECL_CONTEXT (current_function_decl);\n-      else\n-\tcurrent_function_decl = NULL_TREE;\n \n       if (type != previous_class_type || current_class_depth > 1)\n-\t{\n-#ifdef MI_MATRIX\n-\t  build_mi_matrix (type);\n-\t  push_class_decls (type);\n-\t  free_mi_matrix ();\n-#else\n-\t  push_class_decls (type);\n-#endif\n-\t}\n+\tpush_class_decls (type);\n       else\n \t{\n \t  tree item;\n@@ -4726,9 +4644,32 @@ pushclass (type, modify)\n \t\t && CLASSTYPE_IS_TEMPLATE (tag_type)))\n \t    pushtag (TREE_PURPOSE (tags), tag_type, 0);\n \t}\n+    }\n+}\n+\n+/* When we exit a toplevel class scope, we save the\n+   IDENTIFIER_CLASS_VALUEs so that we can restore them quickly if we\n+   reenter the class.  Here, we've entered some other class, so we\n+   must invalidate our cache.  */\n \n-      current_function_decl = this_fndecl;\n+void\n+invalidate_class_lookup_cache ()\n+{\n+  tree tags = CLASSTYPE_TAGS (previous_class_type);\n+  tree t;\n+  \n+  /* This code can be seen as a cache miss.  When we've cached a\n+     class' scope's bindings and we can't use them, we need to reset\n+     them.  This is it!  */\n+  for (t = previous_class_values; t; t = TREE_CHAIN (t))\n+    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n+  while (tags)\n+    {\n+      TREE_NONLOCAL_FLAG (TREE_VALUE (tags)) = 0;\n+      tags = TREE_CHAIN (tags);\n     }\n+  \n+  previous_class_type = NULL_TREE;\n }\n  \n /* Get out of the current class scope. If we were in a class scope\n@@ -4740,26 +4681,6 @@ void\n popclass (modify)\n      int modify;\n {\n-  if (modify < 0)\n-    {\n-      /* Back this old class out completely.  */\n-      tree tags = CLASSTYPE_TAGS (previous_class_type);\n-      tree t;\n-\n-      /* This code can be seen as a cache miss.  When we've cached a\n-\t class' scope's bindings and we can't use them, we need to reset\n-\t them.  This is it!  */\n-      for (t = previous_class_values; t; t = TREE_CHAIN (t))\n-\tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n-      while (tags)\n-\t{\n-\t  TREE_NONLOCAL_FLAG (TREE_VALUE (tags)) = 0;\n-\t  tags = TREE_CHAIN (tags);\n-\t}\n-\n-      return;\n-    }\n-\n   if (modify)\n     {\n       /* Just remove from this class what didn't make\n@@ -4787,6 +4708,8 @@ popclass (modify)\n   current_class_name = current_class_stack[current_class_depth].name;\n   current_class_type = current_class_stack[current_class_depth].type;\n   current_access_specifier = current_class_stack[current_class_depth].access;\n+  if (current_class_stack[current_class_depth].names_used)\n+    splay_tree_delete (current_class_stack[current_class_depth].names_used);\n }\n \n /* Returns 1 if current_class_type is either T or a nested type of T.  */\n@@ -5216,24 +5139,22 @@ instantiate_type (lhstype, rhs, complain)\n \ttree field = TREE_OPERAND (rhs, 1);\n \ttree r;\n \n-\tmy_friendly_assert (TREE_CODE (field) == TREE_LIST, 0);\n-\n \tr = instantiate_type (lhstype, field, complain);\n \n \tif (r != error_mark_node && TYPE_PTRMEMFUNC_P (lhstype))\n \t  {\n \t    if (complain)\n \t      {\n \t        tree t = TYPE_PTRMEMFUNC_OBJECT_TYPE (lhstype);\n-\t        tree fn = TREE_VALUE (field);\n-\t        if (TREE_CODE (fn) == OVERLOAD)\n-\t          fn = OVL_FUNCTION (fn);\n-\t        if (TREE_CODE (fn) == FUNCTION_DECL)\n+\n+\t        if (TREE_CODE (field) == OVERLOAD)\n+\t          field = OVL_FUNCTION (field);\n+\t        if (TREE_CODE (field) == FUNCTION_DECL)\n \t          {\n \t\t    cp_error (\"object-dependent reference `%E' can only be used in a call\",\n-\t\t    \t      DECL_NAME (fn));\n+\t\t    \t      DECL_NAME (field));\n   \t    \t    cp_error (\"  to form a pointer to member function, say `&%T::%E'\",\n-\t\t    \t      t, DECL_NAME (fn));\n+\t\t    \t      t, DECL_NAME (field));\n     \t          }\n \t        else\n \t          cp_error (\"object-dependent reference can only be used in a call\");\n@@ -5490,8 +5411,6 @@ build_self_reference ()\n   DECL_CLASS_CONTEXT (value) = current_class_type;\n   DECL_ARTIFICIAL (value) = 1;\n \n-  pushdecl_class_level (value);\n-\n   saved_cas = current_access_specifier;\n   current_access_specifier = access_public_node;\n   finish_member_declaration (value);\n@@ -5568,3 +5487,64 @@ is_base_of_enclosing_class (base, type)\n     }\n   return 0;\n }\n+\n+/* Note that NAME was looked up while the current class was being\n+   defined and that the result of that lookup was DECL.  */\n+\n+void\n+maybe_note_name_used_in_class (name, decl)\n+     tree name;\n+     tree decl;\n+{\n+  splay_tree names_used;\n+\n+  /* If we're not defining a class, there's nothing to do.  */\n+  if (!current_class_type || !TYPE_BEING_DEFINED (current_class_type))\n+    return;\n+  \n+  /* If there's already a binding for this NAME, then we don't have\n+     anything to worry about.  */\n+  if (IDENTIFIER_CLASS_VALUE (name))\n+    return;\n+\n+  if (!current_class_stack[current_class_depth - 1].names_used)\n+    current_class_stack[current_class_depth - 1].names_used\n+      = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n+  names_used = current_class_stack[current_class_depth - 1].names_used;\n+\n+  splay_tree_insert (names_used,\n+\t\t     (splay_tree_key) name, \n+\t\t     (splay_tree_value) decl);\n+}\n+\n+/* Note that NAME was declared (as DECL) in the current class.  Check\n+   to see that the declaration is legal.  */\n+\n+void\n+note_name_declared_in_class (name, decl)\n+     tree name;\n+     tree decl;\n+{\n+  splay_tree names_used;\n+  splay_tree_node n;\n+\n+  /* Look to see if we ever used this name.  */\n+  names_used \n+    = current_class_stack[current_class_depth - 1].names_used;\n+  if (!names_used)\n+    return;\n+\n+  n = splay_tree_lookup (names_used, (splay_tree_key) name);\n+  if (n)\n+    {\n+      /* [basic.scope.class]\n+\t \n+\t A name N used in a class S shall refer to the same declaration\n+\t in its context and when re-evaluated in the completed scope of\n+\t S.  */\n+      cp_error (\"declaration of `%#D'\", decl);\n+      cp_error_at (\"changes meaning of `%s' from `%+#D'\", \n+\t\t   IDENTIFIER_POINTER (DECL_NAME (decl)),\n+\t\t   (tree) n->value);\n+    }\n+}"}, {"sha": "090d83724aca727bd728c3aab4f72dd0cc4972ea", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -170,12 +170,11 @@ DEFTREECODE (USING_DECL, \"using_decl\", 'd', 0)\n /* An un-parsed default argument.  Looks like an IDENTIFIER_NODE.  */\n DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'c', 2)\n \n-/* A template-id, like foo<int>.  The first operand is the template.  \n-   The second is the list of explicitly specified arguments.  The \n-   template will be a FUNCTION_DECL, TEMPLATE_DECL, or a list of\n-   overloaded functions and templates if the template-id refers to\n-   a global template.  If the template-id refers to a member template,\n-   the template may be an IDENTIFIER_NODE.  */\n+/* A template-id, like foo<int>.  The first operand is the template.\n+   The second is the list of explicitly specified arguments.  The\n+   template will be a FUNCTION_DECL, TEMPLATE_DECL, or an OVERLOAD.\n+   If the template-id refers to a member template, the template may be\n+   an IDENTIFIER_NODE.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n /* An association between name and entity. Parameters are the scope"}, {"sha": "6d0b2735bd23f138df3a88200ffcabd82aa25b89", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n       (TREE_CALLS_NEW) (in _EXPR or _REF) (commented-out).\n       TYPE_USES_COMPLEX_INHERITANCE (in _TYPE).\n       C_DECLARED_LABEL_FLAG.\n+      INHERITED_VALUE_BINDING_P (in CPLUS_BINDING)\n    2: IDENTIFIER_OPNAME_P.\n       BINFO_VBASE_MARKED.\n       BINFO_FIELDS_MARKED.\n@@ -134,6 +135,10 @@ typedef struct ptrmem_cst\n    or namespace scope.  */\n #define LOCAL_BINDING_P(NODE) TREE_LANG_FLAG_0(NODE)\n \n+/* Nonzero if BINDING_VALUE is from a base class of the class which is\n+   currently being defined.  */\n+#define INHERITED_VALUE_BINDING_P(NODE) TREE_LANG_FLAG_1(NODE)\n+\n /* For a binding between a name and an entity at a non-local scope,\n    defines the scope where the binding is declared.  (Either a class\n    _TYPE node, or a NAMESPACE_DECL.)  This macro should be used only\n@@ -235,10 +240,10 @@ struct tree_srcloc\n    ? BINDING_VALUE (IDENTIFIER_BINDING (NODE))\t\\\n    : NULL_TREE)\n \n-/* If we are currently in class scope, then IDENTIFIER_CLASS_VALUE\n-   indicates the class-scoped binding of NODE.  This is just a pointer\n-   to the BINDING_VALUE of one of the bindings in the\n-   IDENTIFIER_BINDINGs list, so any time that this is set so is\n+/* If IDENTIFIER_CLASS_VALUE is set, then NODE is bound in the current\n+   class, and IDENTIFIER_CLASS_VALUE is the value binding.  This is\n+   just a pointer to the BINDING_VALUE of one of the bindings in the\n+   IDENTIFIER_BINDINGs list, so any time that this is non-NULL so is\n    IDENTIFIER_BINDING.  */\n #define IDENTIFIER_CLASS_VALUE(NODE) \\\n   (((struct lang_identifier *) (NODE))->class_value)\n@@ -2684,6 +2689,7 @@ extern int can_convert_arg\t\t\tPROTO((tree, tree, tree));\n extern int enforce_access                       PROTO((tree, tree));\n extern tree convert_default_arg                 PROTO((tree, tree, tree));\n extern tree convert_arg_to_ellipsis             PROTO((tree));\n+extern int is_properly_derived_from             PROTO((tree, tree));\n \n /* in class.c */\n extern tree build_vbase_path\t\t\tPROTO((enum tree_code, tree, tree, tree, int));\n@@ -2713,6 +2719,9 @@ extern void warn_hidden\t\t\t\tPROTO((tree));\n extern tree get_enclosing_class\t\t\tPROTO((tree));\n int is_base_of_enclosing_class\t\t\tPROTO((tree, tree));\n extern void unreverse_member_declarations       PROTO((tree));\n+extern void invalidate_class_lookup_cache       PROTO((void));\n+extern void maybe_note_name_used_in_class       PROTO((tree, tree));\n+extern void note_name_declared_in_class         PROTO((tree, tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n@@ -2776,7 +2785,6 @@ extern tree pushdecl_namespace_level            PROTO((tree));\n extern tree push_using_decl                     PROTO((tree, tree));\n extern tree push_using_directive                PROTO((tree));\n extern void push_class_level_binding\t\tPROTO((tree, tree));\n-extern tree push_using_decl                     PROTO((tree, tree));\n extern tree implicitly_declare\t\t\tPROTO((tree));\n extern tree lookup_label\t\t\tPROTO((tree));\n extern tree shadow_label\t\t\tPROTO((tree));\n@@ -2845,7 +2853,6 @@ extern tree maybe_build_cleanup_and_delete\tPROTO((tree));\n extern tree maybe_build_cleanup\t\t\tPROTO((tree));\n extern void cplus_expand_expr_stmt\t\tPROTO((tree));\n extern void finish_stmt\t\t\t\tPROTO((void));\n-extern int id_in_current_class\t\t\tPROTO((tree));\n extern void push_cp_function_context\t\tPROTO((tree));\n extern void pop_cp_function_context\t\tPROTO((tree));\n extern int in_function_p\t\t\tPROTO((void));\n@@ -2856,9 +2863,10 @@ extern void cat_namespace_levels                PROTO((void));\n extern void fixup_anonymous_union               PROTO((tree));\n extern int check_static_variable_definition     PROTO((tree, tree));\n extern void push_local_binding                  PROTO((tree, tree, int));\n-extern void push_class_binding                  PROTO((tree, tree));\n+extern int push_class_binding                   PROTO((tree, tree));\n extern tree check_default_argument              PROTO((tree, tree));\n extern tree push_overloaded_decl\t\tPROTO((tree, int));\n+extern void clear_identifier_class_values       PROTO((void));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree));"}, {"sha": "63f4fec119729b2297db11d619898dfd422d4ed6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 288, "deletions": 195, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -178,7 +178,7 @@ static void check_for_uninitialized_const_var PROTO((tree));\n static unsigned long typename_hash PROTO((hash_table_key));\n static boolean typename_compare PROTO((hash_table_key, hash_table_key));\n static void push_binding PROTO((tree, tree, struct binding_level*));\n-static void add_binding PROTO((tree, tree));\n+static int add_binding PROTO((tree, tree));\n static void pop_binding PROTO((tree, tree));\n static tree local_variable_p PROTO((tree));\n static tree find_binding PROTO((tree, tree));\n@@ -188,6 +188,8 @@ static int lookup_flags PROTO((int, int));\n static tree qualify_lookup PROTO((tree, int));\n static tree record_builtin_java_type PROTO((const char *, int));\n static const char *tag_name PROTO((enum tag_types code));\n+static void find_class_binding_level PROTO((void));\n+static struct binding_level *innermost_nonclass_level PROTO((void));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PROTO((void));\n@@ -716,19 +718,14 @@ struct binding_level\n \n #define NULL_BINDING_LEVEL ((struct binding_level *) NULL)\n   \n-/* The (non-class) binding level currently in effect.  */\n+/* The binding level currently in effect.  */\n \n static struct binding_level *current_binding_level;\n \n /* The binding level of the current class, if any.  */\n \n static struct binding_level *class_binding_level;\n \n-/* The current (class or non-class) binding level currently in effect.  */\n-\n-#define inner_binding_level \\\n-  (class_binding_level ? class_binding_level : current_binding_level)\n-\n /* A chain of binding_level structures awaiting reuse.  */\n \n static struct binding_level *free_binding_level;\n@@ -771,15 +768,7 @@ push_binding_level (newlevel, tag_transparent, keep)\n   /* Add this level to the front of the chain (stack) of levels that\n      are active.  */\n   *newlevel = clear_binding_level;\n-  if (class_binding_level)\n-    {\n-      newlevel->level_chain = class_binding_level;\n-      class_binding_level = (struct binding_level *)0;\n-    }\n-  else\n-    {\n-      newlevel->level_chain = current_binding_level;\n-    }\n+  newlevel->level_chain = current_binding_level;\n   current_binding_level = newlevel;\n   newlevel->tag_transparent = tag_transparent;\n   newlevel->more_cleanups_ok = 1;\n@@ -794,12 +783,25 @@ push_binding_level (newlevel, tag_transparent, keep)\n #endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n }\n \n+/* Find the innermost enclosing class scope, and reset\n+   CLASS_BINDING_LEVEL appropriately.  */\n+\n+static void\n+find_class_binding_level ()\n+{\n+  struct binding_level *level = current_binding_level;\n+\n+  while (level && level->parm_flag != 2)\n+    level = level->level_chain;\n+  if (level && level->parm_flag == 2)\n+    class_binding_level = level;\n+  else\n+    class_binding_level = 0;\n+}\n+\n static void\n pop_binding_level ()\n {\n-  if (class_binding_level)\n-    current_binding_level = class_binding_level;\n-\n   if (global_binding_level)\n     {\n       /* Cannot pop a level, if there are none left to pop.  */\n@@ -828,13 +830,8 @@ pop_binding_level ()\n     if (level->binding_depth != binding_depth)\n       abort ();\n #endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n-      free_binding_level = level;\n-\n-    class_binding_level = current_binding_level;\n-    if (class_binding_level->parm_flag != 2)\n-      class_binding_level = 0;\n-    while (current_binding_level->parm_flag == 2)\n-      current_binding_level = current_binding_level->level_chain;\n+    free_binding_level = level;\n+    find_class_binding_level ();\n   }\n }\n \n@@ -864,14 +861,8 @@ suspend_binding_level ()\n     }\n   is_class_level = 0;\n #endif /* defined(DEBUG_CP_BINDING_LEVELS) */\n-  {\n-    current_binding_level = current_binding_level->level_chain;\n-    class_binding_level = current_binding_level;\n-    if (class_binding_level->parm_flag != 2)\n-      class_binding_level = 0;\n-    while (current_binding_level->parm_flag == 2)\n-      current_binding_level = current_binding_level->level_chain;\n-  }\n+  current_binding_level = current_binding_level->level_chain;\n+  find_class_binding_level ();\n }\n \n static void\n@@ -912,25 +903,44 @@ global_bindings_p ()\n   return current_binding_level == global_binding_level;\n }\n \n+/* Return the innermost binding level that is not for a class scope.  */\n+\n+static struct binding_level *\n+innermost_nonclass_level ()\n+{\n+  struct binding_level *b;\n+\n+  b = current_binding_level;\n+  while (b->parm_flag == 2)\n+    b = b->level_chain;\n+\n+  return b;\n+}\n+\n /* Nonzero if we are currently in a toplevel binding level.  This\n    means either the global binding level or a namespace in a toplevel\n-   binding level.\n-   Since there are no non-toplevel namespace levels, this really\n-   means any namespace or pseudo-global level.  */\n+   binding level.  Since there are no non-toplevel namespace levels,\n+   this really means any namespace or pseudo-global level.  We also\n+   include a class whose context is toplevel.  */\n \n int\n toplevel_bindings_p ()\n {\n-  return current_binding_level->namespace_p \n-    || current_binding_level->pseudo_global;\n+  struct binding_level *b = innermost_nonclass_level ();\n+\n+  return b->namespace_p || b->pseudo_global;\n }\n \n-/* Nonzero if this is a namespace scope.  */\n+/* Nonzero if this is a namespace scope, or if we are defining a class\n+   which is itself at namespace scope, or whose enclosing class is\n+   such a class, etc.  */\n \n int\n namespace_bindings_p ()\n {\n-  return current_binding_level->namespace_p;\n+  struct binding_level *b = innermost_nonclass_level ();\n+\n+  return b->namespace_p;\n }\n \n void\n@@ -974,7 +984,9 @@ declare_namespace_level ()\n int\n pseudo_global_level_p ()\n {\n-  return current_binding_level->pseudo_global;\n+  struct binding_level *b = innermost_nonclass_level ();\n+\n+  return b->pseudo_global;\n }\n \n void\n@@ -1085,6 +1097,7 @@ push_binding (id, decl, level)\n   BINDING_VALUE (binding) = decl;\n   BINDING_TYPE (binding) = NULL_TREE;\n   BINDING_LEVEL (binding) = level;\n+  INHERITED_VALUE_BINDING_P (binding) = 0;\n   LOCAL_BINDING_P (binding) = (level != class_binding_level);\n \n   /* And put it on the front of the ilst of bindings for ID.  */\n@@ -1097,31 +1110,44 @@ push_binding (id, decl, level)\n    stat' hack whereby a non-typedef class-name or enum-name can be\n    bound at the same level as some other kind of entity.  It's the\n    responsibility of the caller to check that inserting this name is\n-   legal here.  */\n-static void\n+   legal here.  Returns nonzero if the new binding was successful.  */\n+static int\n add_binding (id, decl)\n      tree id;\n      tree decl;\n {\n   tree binding = IDENTIFIER_BINDING (id);\n+  int ok = 1;\n \n   if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n     /* The new name is the type name.  */\n     BINDING_TYPE (binding) = decl;\n-  else \n-    {\n-      /* The old name must be the type name.  It was placed in\n-\t IDENTIFIER_VALUE because it was thought, at the point it\n-\t was declared, to be the only entity with such a name.  */\n-      my_friendly_assert (TREE_CODE (BINDING_VALUE (binding)) == TYPE_DECL\n-\t\t\t  && DECL_ARTIFICIAL (BINDING_VALUE (binding)),\n-\t\t\t  0);\n-\n-      /* Move the type name into the type slot; it is now hidden by\n-\t the new binding.  */\n+  else if (!BINDING_VALUE (binding))\n+    /* This situation arises when push_class_level_binding moves an\n+       inherited type-binding out of the way to make room for a new\n+       value binding.  */\n+    BINDING_VALUE (binding) = decl;\n+  else if (TREE_CODE (BINDING_VALUE (binding)) == TYPE_DECL\n+\t   && DECL_ARTIFICIAL (BINDING_VALUE (binding)))\n+    {\n+      /* The old binding was a type name.  It was placed in\n+\t BINDING_VALUE because it was thought, at the point it was\n+\t declared, to be the only entity with such a name.  Move the\n+\t type name into the type slot; it is now hidden by the new\n+\t binding.  */\n       BINDING_TYPE (binding) = BINDING_VALUE (binding);\n       BINDING_VALUE (binding) = decl;\n+      INHERITED_VALUE_BINDING_P (binding) = 0;\n     }\n+  else\n+    {\n+      cp_error (\"declaration of `%#D'\", decl);\n+      cp_error_at (\"conflicts with previous declaration `%#D'\",\n+\t\t   BINDING_VALUE (binding));\n+      ok = 0;\n+    }\n+\n+  return ok;\n }\n \n /* Bind DECL to ID in the current_binding_level.\n@@ -1134,14 +1160,26 @@ push_local_binding (id, decl, flags)\n      tree decl;\n      int flags;\n {\n-  tree d = decl;\n+  struct binding_level *b;\n+\n+  /* Skip over any local classes.  This makes sense if we call\n+     push_local_binding with a friend decl of a local class.  */\n+  b = current_binding_level;\n+  while (b->parm_flag == 2)\n+    b = b->level_chain;\n \n   if (lookup_name_current_level (id))\n-    /* Supplement the existing binding.  */\n-    add_binding (id, d);\n+    {\n+      /* Supplement the existing binding.  */\n+      if (!add_binding (id, decl))\n+\t/* It didn't work.  Something else must be bound at this\n+\t   level.  Do not add DECL to the list of things to pop\n+\t   later.  */\n+\treturn;\n+    }\n   else\n     /* Create a new binding.  */\n-    push_binding (id, d, current_binding_level);\n+    push_binding (id, decl, b);\n \n   if (TREE_CODE (decl) == OVERLOAD || (flags & PUSH_USING))\n     /* We must put the OVERLOAD into a TREE_LIST since the\n@@ -1151,21 +1189,30 @@ push_local_binding (id, decl, flags)\n \n   /* And put DECL on the list of things declared by the current\n      binding level.  */\n-  TREE_CHAIN (decl) = current_binding_level->names;\n-  current_binding_level->names = decl;\n+  TREE_CHAIN (decl) = b->names;\n+  b->names = decl;\n }\n \n-/* Bind DECL to ID in the class_binding_level.  */\n+/* Bind DECL to ID in the class_binding_level.  Returns nonzero if the\n+   binding was successful.  */\n \n-void\n+int\n push_class_binding (id, decl)\n      tree id;\n      tree decl;\n {\n-  if (IDENTIFIER_BINDING (id)\n-      && BINDING_LEVEL (IDENTIFIER_BINDING (id)) == class_binding_level)\n+  int result = 1;\n+  tree binding = IDENTIFIER_BINDING (id);\n+  tree context;\n+\n+  /* Note that we declared this value so that we can issue an error if\n+     this an illegal redeclaration of a name already used for some\n+     other purpose.  */\n+  note_name_declared_in_class (id, decl);\n+\n+  if (binding && BINDING_LEVEL (binding) == class_binding_level)\n     /* Supplement the existing binding.  */\n-    add_binding (id, decl);\n+    result = add_binding (id, decl);\n   else\n     /* Create a new binding.  */\n     push_binding (id, decl, class_binding_level);\n@@ -1176,6 +1223,32 @@ push_class_binding (id, decl)\n      a class-name or enum-name we might prefer a field-name, or some\n      such.  */\n   IDENTIFIER_CLASS_VALUE (id) = BINDING_VALUE (IDENTIFIER_BINDING (id));\n+\n+  /* If this is a binding from a base class, mark it as such.  */\n+  binding = IDENTIFIER_BINDING (id);\n+  if (BINDING_VALUE (binding) == decl && TREE_CODE (decl) != TREE_LIST)\n+    {\n+      if (TREE_CODE (decl) == OVERLOAD)\n+\tcontext = DECL_REAL_CONTEXT (OVL_CURRENT (decl));\n+      else\n+\t{\n+\t  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd',\n+\t\t\t      0);\n+\t  context = DECL_REAL_CONTEXT (decl);\n+\t}\n+\n+      if (is_properly_derived_from (current_class_type, context))\n+\tINHERITED_VALUE_BINDING_P (binding) = 1;\n+      else\n+\tINHERITED_VALUE_BINDING_P (binding) = 0;\n+    }\n+  else if (BINDING_VALUE (binding) == decl)\n+    /* We only encounter a TREE_LIST when push_class_decls detects an\n+       ambiguity.  Such an ambiguity can be overridden by a definition\n+       in this class.  */\n+    INHERITED_VALUE_BINDING_P (binding) = 1;\n+\n+  return result;\n }\n \n /* Remove the binding for DECL which should be the innermost binding\n@@ -1647,14 +1720,6 @@ pushlevel_class ()\n   decl_stack = push_decl_level (decl_stack, &decl_obstack);\n   class_binding_level = current_binding_level;\n   class_binding_level->parm_flag = 2;\n-  /* We have just pushed into a new binding level.  Now, fake out the rest\n-     of the compiler.  Set the `current_binding_level' back to point to\n-     the most closely containing non-class binding level.  */\n-  do\n-    {\n-      current_binding_level = current_binding_level->level_chain;\n-    }\n-  while (current_binding_level->parm_flag == 2);\n }\n \n /* ...and a poplevel for class declarations.  FORCE is used to force\n@@ -1677,10 +1742,37 @@ poplevel_class (force)\n      if we don't touch it here, we're able to use the cache effect if the\n      next time we're entering a class scope, it is the same class.  */\n   if (current_class_depth != 1 || force)\n-    for (shadowed = level->class_shadowed;\n-\t shadowed;\n-\t shadowed = TREE_CHAIN (shadowed))\n-      IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed)) = TREE_VALUE (shadowed);\n+    {\n+      struct binding_level* b;\n+\n+      /* Clear out our IDENTIFIER_CLASS_VALUEs.  */\n+      for (shadowed = level->class_shadowed;\n+\t   shadowed;\n+\t   shadowed = TREE_CHAIN (shadowed))\n+\tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed)) = NULL_TREE;\n+\t\n+      /* Find the next enclosing class, and recreate\n+\t IDENTIFIER_CLASS_VALUEs appropriate for that class.  */\n+      b = level->level_chain;\n+      while (b && b->parm_flag != 2)\n+\tb = b->level_chain;\n+\n+      if (b)\n+\tfor (shadowed = b->class_shadowed; \n+\t     shadowed; \n+\t     shadowed = TREE_CHAIN (shadowed))\n+\t  {\n+\t    tree t;\n+\n+\t    t = IDENTIFIER_BINDING (TREE_PURPOSE (shadowed));\n+\t    while (t && BINDING_LEVEL (t) != b)\n+\t      t = TREE_CHAIN (t);\n+      \n+\t    if (t)\n+\t      IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed)) \n+\t\t= BINDING_VALUE (t);\n+\t  }\n+    }\n   else\n     /* Remember to save what IDENTIFIER's were bound in this scope so we\n        can recover from cache misses.  */\n@@ -1704,9 +1796,6 @@ poplevel_class (force)\n \t\t      class_binding_level->parm_flag,\n \t\t      class_binding_level->keep);\n \n-  if (class_binding_level->parm_flag != 2)\n-    class_binding_level = (struct binding_level *)0;\n-\n   /* Now, pop out of the binding level which we created up in the\n      `pushlevel_class' routine.  */\n #if defined(DEBUG_CP_BINDING_LEVELS)\n@@ -1717,6 +1806,24 @@ poplevel_class (force)\n \n   return block;\n }\n+\n+/* We are entering the scope of a class.  Clear IDENTIFIER_CLASS_VALUE\n+   for any names in enclosing classes.  */\n+\n+void\n+clear_identifier_class_values ()\n+{\n+  tree t;\n+\n+  if (!class_binding_level)\n+    return;\n+\n+  for (t = class_binding_level->class_shadowed;\n+       t;\n+       t = TREE_CHAIN (t))\n+    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n+}\n+\n \f\n /* For debugging.  */\n static int no_print_functions = 0;\n@@ -2202,7 +2309,7 @@ maybe_push_to_top_level (pseudo)\n   extern int current_lang_stacksize;\n   struct saved_scope *s\n     = (struct saved_scope *) xmalloc (sizeof (struct saved_scope));\n-  struct binding_level *b = inner_binding_level;\n+  struct binding_level *b = current_binding_level;\n   tree old_bindings = NULL_TREE;\n \n   push_cp_function_context (NULL_TREE);\n@@ -2296,10 +2403,7 @@ pop_from_top_level ()\n \n   /* Clear out class-level bindings cache.  */\n   if (previous_class_type)\n-    {\n-      popclass (-1);\n-      previous_class_type = NULL_TREE;\n-    }\n+    invalidate_class_lookup_cache ();\n \n   pop_obstacks ();\n \n@@ -2385,14 +2489,14 @@ set_identifier_type_value_with_scope (id, type, b)\n   SET_IDENTIFIER_TYPE_VALUE (id, type);\n }\n \n-/* As set_identifier_type_value_with_scope, but using inner_binding_level.  */\n+/* As set_identifier_type_value_with_scope, but using current_binding_level.  */\n \n void\n set_identifier_type_value (id, type)\n      tree id;\n      tree type;\n {\n-  set_identifier_type_value_with_scope (id, type, inner_binding_level);\n+  set_identifier_type_value_with_scope (id, type, current_binding_level);\n }\n \n /* Return the type associated with id. */\n@@ -2425,9 +2529,9 @@ pop_everything ()\n #ifdef DEBUG_CP_BINDING_LEVELS\n   fprintf (stderr, \"XXX entering pop_everything ()\\n\");\n #endif\n-  while (! toplevel_bindings_p () && ! pseudo_global_level_p ())\n+  while (!toplevel_bindings_p ())\n     {\n-      if (class_binding_level)\n+      if (current_binding_level->parm_flag == 2)\n \tpop_nested_class (1);\n       else\n \tpoplevel (0, 0, 0);\n@@ -2506,8 +2610,6 @@ maybe_process_template_type_declaration (type, globalize, b)\n \t      && !globalize && b->pseudo_global\n \t      && b->level_chain->parm_flag == 2)\n \t    {\n-\t      pushdecl_with_scope (CLASSTYPE_TI_TEMPLATE (type),\n-\t\t\t\t   b->level_chain);\n \t      finish_member_declaration (CLASSTYPE_TI_TEMPLATE (type));\n \t      /* Put this tag on the list of tags for the class, since\n \t\t that won't happen below because B is not the class\n@@ -2538,7 +2640,7 @@ pushtag (name, type, globalize)\n   tree context = 0;\n   tree c_decl = 0;\n \n-  b = inner_binding_level;\n+  b = current_binding_level;\n   while (b->tag_transparent\n \t || (globalize && b->parm_flag == 2))\n     b = b->level_chain;\n@@ -2604,13 +2706,14 @@ pushtag (name, type, globalize)\n \n \t  if (b->parm_flag == 2)\n \t    {\n-\t      pushdecl_class_level (d);\n \t      if (newdecl && !PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t\t/* Put this TYPE_DECL on the TYPE_FIELDS list for the\n \t\t   class.  But if it's a member template class, we\n \t\t   want the TEMPLATE_DECL, not the TYPE_DECL, so this\n \t\t   is done later.  */\n \t\tfinish_member_declaration (d);\n+\t      else\n+\t\tpushdecl_class_level (d);\n \t    }\n \t  else\n \t    d = pushdecl_with_scope (d, b);\n@@ -3942,8 +4045,8 @@ pushdecl (x)\n \t We will reverse them later if necessary.  */\n       TREE_CHAIN (x) = current_binding_level->names;\n       current_binding_level->names = x;\n-      if (! (current_binding_level != global_binding_level \n-\t     || TREE_PERMANENT (x)))\n+      if (current_binding_level == global_binding_level\n+\t  && !TREE_PERMANENT (x))\n \tmy_friendly_abort (124);\n     }\n \n@@ -3987,7 +4090,7 @@ tree\n pushdecl_namespace_level (x)\n      tree x;\n {\n-  register struct binding_level *b = inner_binding_level;\n+  register struct binding_level *b = current_binding_level;\n   register tree t;\n \n   t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace));\n@@ -4048,39 +4151,30 @@ pushdecl_class_level (x)\n {\n   /* Don't use DECL_ASSEMBLER_NAME here!  Everything that looks in class\n      scope looks for the pre-mangled name.  */\n-  register tree name = DECL_NAME (x);\n+  register tree name;\n+\n+  if (TREE_CODE (x) == OVERLOAD)\n+    x = OVL_CURRENT (x);\n+  name = DECL_NAME (x);\n \n   if (name)\n     {\n       if (TYPE_BEING_DEFINED (current_class_type))\n-\t{\n-\t  /* A name N used in a class S shall refer to the same declaration\n-\t     in its context and when re-evaluated in the completed scope of S.\n-\t     Types, enums, and static vars are checked here; other\n-\t     members are checked in finish_struct.  */\n-\t  tree icv = IDENTIFIER_CLASS_VALUE (name);\n-\n-\t  /* This should match check_member_decl_is_same_in_complete_scope.  */\n-\t  if (icv && icv != x\n-\t      && flag_optional_diags\n-\t      /* Don't complain about inherited names.  */\n-\t      && id_in_current_class (name)\n-\t      /* Or shadowed tags.  */\n-\t      && !(DECL_DECLARES_TYPE_P (icv)\n-\t\t   && DECL_CONTEXT (icv) == current_class_type))\n-\t    {\n-\t      cp_pedwarn (\"declaration of identifier `%D' as `%#D'\", name, x);\n-\t      cp_pedwarn_at (\"conflicts with previous use in class as `%#D'\",\n-\t\t\t     icv);\n-\t    }\n-\n-\t  check_template_shadow (x);\n-\t}\n+\tcheck_template_shadow (x);\n \n       push_class_level_binding (name, x);\n       if (TREE_CODE (x) == TYPE_DECL)\n \tset_identifier_type_value (name, TREE_TYPE (x));\n     }\n+  else if (ANON_UNION_TYPE_P (TREE_TYPE (x)))\n+    {\n+      tree f;\n+\n+      for (f = TYPE_FIELDS (TREE_TYPE (x));\n+\t   f;\n+\t   f = TREE_CHAIN (f))\n+\tpushdecl_class_level (f);\n+    }\n }\n \n #if 0\n@@ -4114,6 +4208,7 @@ push_class_level_binding (name, x)\n      tree name;\n      tree x;\n {\n+  tree binding;\n   /* The class_binding_level will be NULL if x is a template \n      parameter name in a member template.  */\n   if (!class_binding_level)\n@@ -4122,19 +4217,64 @@ push_class_level_binding (name, x)\n   /* If this declaration shadows a declaration from an enclosing\n      class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n      we leave this class.  Record the shadowed declaration here.  */\n-  maybe_push_cache_obstack ();\n-  class_binding_level->class_shadowed\n-    = tree_cons (name, IDENTIFIER_CLASS_VALUE (name),\n-\t\t class_binding_level->class_shadowed);\n-  TREE_TYPE (class_binding_level->class_shadowed)\n-    = x;\n-  pop_obstacks ();\n-\n-  /* Put the binding on the stack of bindings for the identifier, and\n-     update IDENTIFIER_CLASS_VALUE.  */\n-  push_class_binding (name, x);\n+  binding = IDENTIFIER_BINDING (name);\n+  if (binding \n+      && ((TREE_CODE (x) == OVERLOAD\n+\t   && BINDING_VALUE (binding)\n+\t   && is_overloaded_fn (BINDING_VALUE (binding)))\n+\t  || INHERITED_VALUE_BINDING_P (binding)))\n+    {\n+      tree shadow;\n+      tree old_decl;\n+\n+      /* If the old binding was from a base class, and was for a tag\n+\t name, slide it over to make room for the new binding.  The\n+\t old binding is still visible if explicitly qualified with a\n+\t class-key.  */\n+      if (INHERITED_VALUE_BINDING_P (binding)\n+\t  && BINDING_VALUE (binding)\n+\t  && TREE_CODE (BINDING_VALUE (binding)) == TYPE_DECL\n+\t  && DECL_ARTIFICIAL (BINDING_VALUE (binding))\n+\t  && !(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)))\n+\t{\n+\t  old_decl = BINDING_TYPE (binding);\n+\t  BINDING_TYPE (binding) = BINDING_VALUE (binding);\n+\t  BINDING_VALUE (binding) = NULL_TREE;\n+\t  INHERITED_VALUE_BINDING_P (binding) = 0;\n+\t}\n+      else\n+\told_decl = BINDING_VALUE (binding);\n+\n+      /* There was already a binding for X containing fewer\n+\t functions than are named in X.  Find the previous\n+\t declaration of X on the class-shadowed list, and update it.  */\n+      for (shadow = class_binding_level->class_shadowed;\n+\t   shadow;\n+\t   shadow = TREE_CHAIN (shadow))\n+\tif (TREE_PURPOSE (shadow) == name\n+\t    && TREE_TYPE (shadow) == old_decl)\n+\t  {\n+\t    BINDING_VALUE (binding) = x;\n+\t    INHERITED_VALUE_BINDING_P (binding) = 0;\n+\t    TREE_TYPE (shadow) = x;\n+\t    return;\n+\t  }\n+    }\n \n-  obstack_ptr_grow (&decl_obstack, x);\n+  /* If we didn't replace an existing binding, put the binding on the\n+     stack of bindings for the identifier, and update\n+     IDENTIFIER_CLASS_VALUE.  */\n+  if (push_class_binding (name, x))\n+    {\n+      maybe_push_cache_obstack ();\n+      class_binding_level->class_shadowed\n+\t= tree_cons (name, IDENTIFIER_CLASS_VALUE (name),\n+\t\t     class_binding_level->class_shadowed);\n+      pop_obstacks ();\n+      /* Record the value we are binding NAME to so that we can know\n+\t what to pop later.  */\n+      TREE_TYPE (class_binding_level->class_shadowed) = x;\n+    }\n }\n \n /* Insert another USING_DECL into the current binding level,\n@@ -5434,26 +5574,6 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t\t   || TREE_CODE (type) == TYPENAME_TYPE)\n \t    /* Someone else will give an error about this if needed.  */\n \t    val = NULL_TREE;\n-\t  else if (TYPE_BEING_DEFINED (type))\n-\t    {\n-\t      val = IDENTIFIER_CLASS_VALUE (name);\n-\t      if (val && DECL_CONTEXT (val) != type)\n-\t\t{\n-\t\t  struct binding_level *b = class_binding_level;\n-\t\t  for (val = NULL_TREE; b; b = b->level_chain)\n-\t\t    {\n-\t\t      tree t = purpose_member (name, b->class_shadowed);\n-\t\t      if (t && TREE_VALUE (t)\n-\t\t\t  && DECL_CONTEXT (TREE_VALUE (t)) == type)\n-\t\t\t{\n-\t\t\t  val = TREE_VALUE (t);\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      if (val == NULL_TREE)\n-\t\tval = lookup_field (type, name, 0, 1);\n-\t    }\n \t  else if (type == current_class_type)\n \t    val = IDENTIFIER_CLASS_VALUE (name);\n \t  else\n@@ -5495,26 +5615,6 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t}\n     }\n \n-  /* If VAL is a type from a dependent base, we're not really supposed\n-     to be able to see it; the fact that we can is the \"implicit\n-     typename\" extension.  We call lookup_field here to turn VAL into\n-     a TYPE_DECL for a TYPENAME_TYPE.  */\n-  if (processing_template_decl && val\n-      && val == IDENTIFIER_CLASS_VALUE (name)\n-      && TREE_CODE (val) == TYPE_DECL\n-      && !currently_open_class (DECL_CONTEXT (val))\n-      && uses_template_parms (current_class_type))\n-    val = lookup_field (current_class_type, name, 0, 1);\n-\n-  /* We don't put names from baseclasses onto the IDENTIFIER_BINDING\n-     list when we're defining a type.  It would probably be simpler to\n-     do this, but we don't.  So, we must lookup names from base\n-     classes explicitly.  */\n-  if (!val && !nonclass \n-      && current_class_type && TYPE_BEING_DEFINED (current_class_type))\n-    val = qualify_lookup (lookup_field (current_class_type, name, 0, 0),\n-\t\t\t  flags);\n-\n   /* The name might be from an enclosing class of the current scope.  */\n   if (!val && !nonclass && current_class_type)\n     val = qualify_lookup (lookup_nested_field (name, !yylex), flags);\n@@ -9072,12 +9172,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\tif (TREE_CODE (fns) == LOOKUP_EXPR)\n \t\t  fns = TREE_OPERAND (fns, 0);\n \n-\t\tif (TREE_CODE (fns) == IDENTIFIER_NODE)\n-\t\t  dname = fns;\n-\t\telse if (is_overloaded_fn (fns))\n-\t\t  dname = DECL_NAME (get_first_fn (fns));\n-\t\telse\n-\t\t  my_friendly_abort (0);\n+\t\tdname = fns;\n+\t\tif (TREE_CODE (dname) == COMPONENT_REF)\n+\t\t  dname = TREE_OPERAND (dname, 1);\n+\t\tif (TREE_CODE (dname) != IDENTIFIER_NODE)\n+\t\t  {\n+\t\t    my_friendly_assert (is_overloaded_fn (dname),\n+\t\t\t\t\t19990331);\n+\t\t    dname = DECL_NAME (get_first_fn (dname));\n+\t\t  }\n \t      }\n \t  /* Fall through. */\n \n@@ -12126,7 +12229,7 @@ xref_tag (code_type_node, name, globalize)\n   enum tree_code code;\n   int temp = 0;\n   register tree ref, t;\n-  struct binding_level *b = inner_binding_level;\n+  struct binding_level *b = current_binding_level;\n   int got_type = 0;\n   tree attributes = NULL_TREE;\n \n@@ -12557,7 +12660,7 @@ start_enum (name)\n      tree name;\n {\n   register tree enumtype = NULL_TREE;\n-  struct binding_level *b = inner_binding_level;\n+  struct binding_level *b = current_binding_level;\n \n   /* We are wasting space here and putting these on the permanent_obstack so\n      that typeid(local enum) will work correctly. */\n@@ -12795,13 +12898,10 @@ build_enumerator (name, value, type)\n  TREE_READONLY (decl) = 1;\n \n  if (context && context == current_class_type)\n-   {\n-     pushdecl_class_level (decl);\n-     /* In something like `struct S { enum E { i = 7 }; };' we put `i'\n-\ton the TYPE_FIELDS list for `S'.  (That's so that you can say\n-\tthings like `S::i' later.)  */\n-     finish_member_declaration (decl);\n-   }\n+   /* In something like `struct S { enum E { i = 7 }; };' we put `i'\n+      on the TYPE_FIELDS list for `S'.  (That's so that you can say\n+      things like `S::i' later.)  */\n+   finish_member_declaration (decl);\n  else\n    {\n      pushdecl (decl);\n@@ -14506,13 +14606,6 @@ revert_static_member_fn (decl, fn, argtypes)\n     *argtypes = args;\n }\n \n-int\n-id_in_current_class (id)\n-     tree id;\n-{\n-  return !!purpose_member (id, class_binding_level->class_shadowed);\n-}\n-\n struct cp_function\n {\n   int returns_value;"}, {"sha": "180de3d6824df740e2b627f7c5bdb256a500c6ec", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -1525,7 +1525,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \tDECL_ASSEMBLER_NAME (value) =\n \t  get_identifier (build_overload_name (TREE_TYPE (value), 1, 1));\n \n-      pushdecl_class_level (value);\n       return value;\n     }\n \n@@ -1611,8 +1610,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       && (TREE_CODE (value) == VAR_DECL || TREE_CODE (value) == FUNCTION_DECL))\n     value = push_template_decl (value);\n \n-  check_template_shadow (value);\n-\n   if (attrlist)\n     cplus_decl_attributes (value, TREE_PURPOSE (attrlist),\n \t\t\t   TREE_VALUE (attrlist));\n@@ -1656,7 +1653,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       DECL_CLASS_CONTEXT (value) = current_class_type;\n \n       cp_finish_decl (value, init, asmspec_tree, 1, flags);\n-      pushdecl_class_level (value);\n       return value;\n     }\n   if (TREE_CODE (value) == FIELD_DECL)"}, {"sha": "58a46af4bad63744c26acc55ab81fc33cdec5075", "filename": "gcc/cp/errfn.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Ferrfn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Ferrfn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferrfn.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -41,8 +41,6 @@ int cp_silent = 0;\n typedef void errorfn ();\t/* deliberately vague */\n \n static void cp_thing PROTO ((errorfn *, int, const char *, va_list));\n-extern char* cp_file_of PROTO((tree));\n-extern int   cp_line_of PROTO((tree));\n \n #define STRDUP(f) (ap = (char *) alloca (strlen (f) +1), strcpy (ap, (f)), ap)\n "}, {"sha": "45b96d7ef401ffe3438e0d453eaed19801d3c0a3", "filename": "gcc/cp/error.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -806,6 +806,10 @@ dump_decl (t, v)\n       }\n       break;\n \n+    case OVERLOAD:\n+      t = OVL_CURRENT (t);\n+      /* Fall through.  */\n+\n     case FUNCTION_DECL:\n       if (GLOBAL_IORD_P (DECL_ASSEMBLER_NAME (t)))\n \tdump_global_iord (DECL_ASSEMBLER_NAME (t));\n@@ -1928,6 +1932,8 @@ cp_file_of (t)\n     return DECL_SOURCE_FILE (DECL_CONTEXT (t));\n   else if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n     return DECL_SOURCE_FILE (TYPE_MAIN_DECL (t));\n+  else if (TREE_CODE (t) == OVERLOAD)\n+    return DECL_SOURCE_FILE (OVL_FUNCTION (t));\n   else\n     return DECL_SOURCE_FILE (t);\n }\n@@ -1945,6 +1951,8 @@ cp_line_of (t)\n \n   if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n     line = DECL_SOURCE_LINE (TYPE_MAIN_DECL (t));\n+  else if (TREE_CODE (t) == OVERLOAD)\n+    line = DECL_SOURCE_LINE (OVL_FUNCTION (t));\n   else\n     line = DECL_SOURCE_LINE (t);\n "}, {"sha": "062620367154429c8ec3a6c4acd51e5c4b2d7611", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -1377,14 +1377,17 @@ build_member_call (type, name, parmlist)\n     return build_x_function_call (lookup_namespace_name (type, name),\n \t\t\t\t  parmlist, current_class_ref);\n \n-  if (TREE_CODE (name) != TEMPLATE_ID_EXPR)\n-    method_name = name;\n-  else\n+  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n     {\n       method_name = TREE_OPERAND (name, 0);\n+      if (TREE_CODE (method_name) == COMPONENT_REF)\n+\tmethod_name = TREE_OPERAND (method_name, 1);\n       if (is_overloaded_fn (method_name))\n \tmethod_name = DECL_NAME (OVL_CURRENT (method_name));\n+      TREE_OPERAND (name, 0) = method_name;\n     }\n+  else\n+    method_name = name;\n \n   if (TREE_CODE (method_name) == BIT_NOT_EXPR)\n     {"}, {"sha": "4d68ba97bf4ff10a3092ad7a995203f3adb8ae66", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -2878,15 +2878,13 @@ do_identifier (token, parsing, args)\n \n   /* Remember that this name has been used in the class definition, as per\n      [class.scope0] */\n-  if (id && current_class_type && parsing\n-      && TYPE_BEING_DEFINED (current_class_type)\n-      && ! IDENTIFIER_CLASS_VALUE (token)\n+  if (id && parsing\n       /* Avoid breaking if we get called for a default argument that\n \t refers to an overloaded method.  Eventually this will not be\n \t necessary, since default arguments shouldn't be parsed until\n \t after the class is complete.  (jason 3/12/97) */\n       && TREE_CODE (id) != OVERLOAD)\n-    pushdecl_class_level (id);\n+    maybe_note_name_used_in_class (token, id);\n \n   if (id == error_mark_node)\n     {"}, {"sha": "d0bbf1546f68f69cf024ec34209f10ed5108fcb7", "filename": "gcc/cp/method.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -1916,31 +1916,24 @@ hack_identifier (value, name)\n       TREE_USED (value) = 1;\n       value = build_component_ref (current_class_ref, name, NULL_TREE, 1);\n     }\n-  else if (TREE_CODE (value) == FUNCTION_DECL\n-\t   && DECL_FUNCTION_MEMBER_P (value))\n+  else if ((TREE_CODE (value) == FUNCTION_DECL\n+\t    && DECL_FUNCTION_MEMBER_P (value))\n+\t   || (TREE_CODE (value) == OVERLOAD\n+\t       && DECL_FUNCTION_MEMBER_P (OVL_CURRENT (value))))\n     {\n       tree decl;\n \n+      if (TREE_CODE (value) == OVERLOAD)\n+\tvalue = OVL_CURRENT (value);\n+\n       if (IS_SIGNATURE (DECL_CLASS_CONTEXT (value)))\n \treturn value;\n \n       decl = maybe_dummy_object (DECL_CLASS_CONTEXT (value), 0);\n       value = build_component_ref (decl, name, NULL_TREE, 1);\n     }\n   else if (really_overloaded_fn (value))\n-    {\n-#if 0\n-      tree t = get_first_fn (value);\n-      for (; t; t = DECL_CHAIN (t))\n-\t{\n-\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t    continue;\n-\n-\t  assemble_external (t);\n-\t  TREE_USED (t) = 1;\n-\t}\n-#endif\n-    }\n+    ;\n   else if (TREE_CODE (value) == OVERLOAD)\n     /* not really overloaded function */\n     mark_used (OVL_FUNCTION (value));"}, {"sha": "6eedc518e86ad13482439ae149177380d0cf468c", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 2987, "deletions": 2993, "changes": 5980, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8"}, {"sha": "476fdcf9f92ea34a3a33a5327cee721f9c6f5941", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -2138,7 +2138,8 @@ structsp:\n \t\t  if (!processing_template_decl)\n \t\t    cp_pedwarn (\"using `typename' outside of template\"); }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n-\t| class_head left_curly \n+\t| class_head '{'\n+                { $<ttype>1 = begin_class_definition ($<ttype>1); }\n           opt.component_decl_list '}' maybe_attribute\n \t\t{ \n \t\t  int semi;\n@@ -2147,7 +2148,7 @@ structsp:\n \t\t    yychar = YYLEX;\n \t\t  semi = yychar == ';';\n \n-\t\t  $<ttype>$ = finish_class_definition ($1, $5, semi); \n+\t\t  $<ttype>$ = finish_class_definition ($1, $6, semi); \n \t\t}\n \t  pending_defargs\n                 {\n@@ -2156,7 +2157,7 @@ structsp:\n \t  pending_inlines\n                 {\n \t\t  finish_inline_definitions ();\n-\t\t  $$.t = $<ttype>6;\n+\t\t  $$.t = $<ttype>7;\n \t\t  $$.new_type_flag = 1; \n \t\t}\n \t| class_head  %prec EMPTY\n@@ -2404,11 +2405,6 @@ base_class_access_list:\n \t\t}\n \t;\n \n-left_curly:\n-\t  '{'\n-                { $<ttype>0 = begin_class_definition ($<ttype>0); }\n-\t;\n-\n opt.component_decl_list:\n \t| component_decl_list\n \t| opt.component_decl_list access_specifier component_decl_list\n@@ -2758,14 +2754,7 @@ nonnested_type:\n \t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n \t\t    {\n \t\t      $$ = lookup_name ($1, 1);\n-\t\t      if (current_class_type\n-\t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n-\t\t\t  && ! IDENTIFIER_CLASS_VALUE ($1))\n-\t\t\t{\n-\t\t\t  /* Remember that this name has been used in the class\n-\t\t\t     definition, as per [class.scope0] */\n-\t\t\t  pushdecl_class_level ($$);\n-\t\t\t}\n+\t\t      maybe_note_name_used_in_class ($1, $$);\n \t\t    }\n \t\t  else\n \t\t    $$ = $1;\n@@ -2925,12 +2914,7 @@ nested_name_specifier_1:\n \t\t  if (TREE_CODE ($1) == IDENTIFIER_NODE)\n \t\t    {\n \t\t      $$ = lastiddecl;\n-\t\t      /* Remember that this name has been used in the class\n-\t\t\t definition, as per [class.scope0] */\n-\t\t      if (current_class_type\n-\t\t\t  && TYPE_BEING_DEFINED (current_class_type)\n-\t\t\t  && ! IDENTIFIER_CLASS_VALUE ($1))\n-\t\t\tpushdecl_class_level ($$);\n+\t\t      maybe_note_name_used_in_class ($1, $$);\n \t\t    }\n \t\t  got_scope = $$ = TYPE_MAIN_VARIANT (TREE_TYPE ($$));\n \t\t}"}, {"sha": "28161b11c31f740c042064ee040d85ab62d8dc04", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -1304,16 +1304,6 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n       if (declarator == error_mark_node)\n \treturn error_mark_node;\n \n-      if (TREE_CODE (TREE_OPERAND (declarator, 0)) == LOOKUP_EXPR)\n-\t{\n-\t  /* A friend declaration.  We can't do much, because we don't\n-\t   know what this resolves to, yet.  */\n-\t  my_friendly_assert (is_friend != 0, 0);\n-\t  my_friendly_assert (!explicit_instantiation, 0);\n-\t  SET_DECL_IMPLICIT_INSTANTIATION (decl);\n-\t  return decl;\n-\t} \n-\n       if (ctype != NULL_TREE && TYPE_BEING_DEFINED (ctype))\n \t{\n \t  if (!explicit_instantiation)\n@@ -1340,6 +1330,15 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \n \t  return decl;\n \t}\n+      else if (TREE_CODE (TREE_OPERAND (declarator, 0)) == LOOKUP_EXPR)\n+\t{\n+\t  /* A friend declaration.  We can't do much, because we don't\n+\t   know what this resolves to, yet.  */\n+\t  my_friendly_assert (is_friend != 0, 0);\n+\t  my_friendly_assert (!explicit_instantiation, 0);\n+\t  SET_DECL_IMPLICIT_INSTANTIATION (decl);\n+\t  return decl;\n+\t} \n       else if (ctype != NULL_TREE \n \t       && (TREE_CODE (TREE_OPERAND (declarator, 0)) ==\n \t\t   IDENTIFIER_NODE))\n@@ -1598,7 +1597,11 @@ void\n check_template_shadow (decl)\n      tree decl;\n {\n-  tree olddecl = IDENTIFIER_VALUE (DECL_NAME (decl));\n+  tree olddecl;\n+\n+  if (TREE_CODE (decl) == OVERLOAD)\n+    decl = OVL_CURRENT (decl);\n+  olddecl = IDENTIFIER_VALUE (DECL_NAME (decl));\n \n   if (current_template_parms && olddecl)\n     {\n@@ -1888,8 +1891,8 @@ build_template_decl (decl, parms)\n   if (DECL_LANG_SPECIFIC (decl))\n     {\n       DECL_CLASS_CONTEXT (tmpl) = DECL_CLASS_CONTEXT (decl);\n-      DECL_STATIC_FUNCTION_P (tmpl) = \n-\tDECL_STATIC_FUNCTION_P (decl);\n+      DECL_STATIC_FUNCTION_P (tmpl) = DECL_STATIC_FUNCTION_P (decl);\n+      DECL_CONSTRUCTOR_P (tmpl) = DECL_CONSTRUCTOR_P (decl);\n     }\n \n   return tmpl;"}, {"sha": "5f4a76fe6cc19c5605ad0dd3ba921e4ce6564a8c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 159, "deletions": 333, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -89,7 +89,6 @@ static int hides PROTO((tree, tree));\n static tree virtual_context PROTO((tree, tree, tree));\n static tree dfs_check_overlap PROTO((tree, void *));\n static tree dfs_no_overlap_yet PROTO((tree, void *));\n-static void envelope_add_decl PROTO((tree, tree, tree *));\n static int get_base_distance_recursive\n \tPROTO((tree, int, int, int, int *, tree *, tree,\n \t       int, int *, int, int));\n@@ -111,8 +110,8 @@ static tree dfs_find_vbases PROTO((tree, void *));\n static tree dfs_clear_vbase_slots PROTO((tree, void *));\n static tree dfs_init_vbase_pointers PROTO((tree, void *));\n static tree dfs_get_vbase_types PROTO((tree, void *));\n-static tree dfs_pushdecls PROTO((tree, void *));\n-static tree dfs_compress_decls PROTO((tree, void *));\n+static tree dfs_push_type_decls PROTO((tree, void *));\n+static tree dfs_push_decls PROTO((tree, void *));\n static tree dfs_unuse_fields PROTO((tree, void *));\n static tree add_conversions PROTO((tree, void *));\n static tree get_virtuals_named_this PROTO((tree, tree));\n@@ -150,6 +149,8 @@ static tree dfs_assert_unmarked_p PROTO ((tree, void *));\n static void assert_canonical_unmarked PROTO ((tree));\n static int protected_accessible_p PROTO ((tree, tree, tree, tree));\n static int friend_accessible_p PROTO ((tree, tree, tree, tree));\n+static void setup_class_bindings PROTO ((tree, int));\n+static int template_self_reference_p PROTO ((tree, tree));\n \n /* Allocate a level of searching.  */\n \n@@ -1175,6 +1176,25 @@ lookup_field_queue_p (binfo, data)\n     return binfo;\n }\n \n+/* Within the scope of a template class, you can refer to the\n+   particular to the current specialization with the name of the\n+   template itself.  For example:\n+   \n+     template <typename T> struct S { S* sp; }\n+\n+   Returns non-zero if DECL is such a declaration in a class TYPE.  */\n+\n+static int\n+template_self_reference_p (type, decl)\n+     tree type;\n+     tree decl;\n+{\n+  return  (CLASSTYPE_USE_TEMPLATE (type)\n+\t   && TREE_CODE (decl) == TYPE_DECL\n+\t   && DECL_ARTIFICIAL (decl)\n+\t   && DECL_NAME (decl) == constructor_name (type));\n+}\n+\n /* DATA is really a struct lookup_field_info.  Look for a field with\n    the name indicated there in BINFO.  If this function returns a\n    non-NULL value it is the result of the lookup.  Called from\n@@ -1206,6 +1226,11 @@ lookup_field_r (binfo, data)\n   if (!nval)\n     return NULL_TREE;\n \n+  /* You must name a template base class with a template-id.  */\n+  if (!same_type_p (type, lfi->type) \n+      && template_self_reference_p (type, nval))\n+    return NULL_TREE;\n+\n   from_dep_base_p = dependent_base_p (binfo);\n   if (lfi->from_dep_base_p && !from_dep_base_p)\n     {\n@@ -1266,7 +1291,12 @@ lookup_field_r (binfo, data)\n \t{\n \t  nval = purpose_member (lfi->name, CLASSTYPE_TAGS (type));\n \t  if (nval)\n-\t    nval = TYPE_MAIN_DECL (TREE_VALUE (nval));\n+\t    {\n+\t      nval = TYPE_MAIN_DECL (TREE_VALUE (nval));\n+\t      if (!same_type_p (type, lfi->type)\n+\t\t  && template_self_reference_p (type, nval))\n+\t\tnval = NULL_TREE;\n+\t    }\n \t}\n \n       if (nval)\n@@ -1300,13 +1330,15 @@ lookup_field_r (binfo, data)\n }\n \n /* Look for a memer named NAME in an inheritance lattice dominated by\n-   XBASETYPE.  PROTECT is zero if we can avoid computing access\n-   information, otherwise it is 1.  WANT_TYPE is 1 when we should only\n-   return TYPE_DECLs, if no TYPE_DECL can be found return NULL_TREE.\n+   XBASETYPE.  PROTECT is 0 or two, we do not check access.  If it is\n+   1, we enforce accessibility.  If PROTECT is zero, then, for an\n+   ambiguous lookup, we return NULL.  If PROTECT is 1, we issue an\n+   error message.  If PROTECT is two 2, we return a TREE_LIST whose\n+   TREE_PURPOSE is error_mark_node and whose TREE_VALUE is the list of\n+   ambiguous candidates.\n \n-   It was not clear what should happen if WANT_TYPE is set, and an\n-   ambiguity is found.  At least one use (lookup_name) to not see\n-   the error.  */\n+   WANT_TYPE is 1 when we should only return TYPE_DECLs, if no\n+   TYPE_DECL can be found return NULL_TREE.  */\n \n tree\n lookup_member (xbasetype, name, protect, want_type)\n@@ -1324,13 +1356,6 @@ lookup_member (xbasetype, name, protect, want_type)\n      checks.  Whereas rval is only set if a proper (not hidden)\n      non-function member is found.  */\n \n-  /* rval_binfo_h and binfo_h are binfo values used when we perform the\n-     hiding checks, as virtual base classes may not be shared.  The strategy\n-     is we always go into the binfo hierarchy owned by TYPE_BINFO of\n-     virtual base classes, as we cross virtual base class lines.  This way\n-     we know that binfo of a virtual base class will always == itself when\n-     found along any line.  (mrs)  */\n-\n   const char *errstr = 0;\n \n   if (xbasetype == current_class_type && TYPE_BEING_DEFINED (xbasetype)\n@@ -1379,6 +1404,21 @@ lookup_member (xbasetype, name, protect, want_type)\n   if (!protect && lfi.ambiguous)\n     return NULL_TREE;\n   \n+  if (protect == 2) \n+    {\n+      if (lfi.ambiguous)\n+\t{\n+\t  /* This flag tells hack_identifier that the lookup is\n+\t     ambiguous.  */\n+\t  TREE_NONLOCAL_FLAG (lfi.ambiguous) = 1;\n+\t  return scratch_tree_cons (error_mark_node,\n+\t\t\t\t    lfi.ambiguous,\n+\t\t\t\t    NULL_TREE);\n+\t}\n+      else\n+\tprotect = 0;\n+    }\n+\n   /* [class.access]\n \n      In the case of overloaded function names, access control is\n@@ -2814,107 +2854,6 @@ note_debug_info_needed (type)\n \f\n /* Subroutines of push_class_decls ().  */\n \n-/* Add in a decl to the envelope.  */\n-static void\n-envelope_add_decl (type, decl, values)\n-     tree type, decl, *values;\n-{\n-  tree context, *tmp;\n-  tree name = DECL_NAME (decl);\n-  int dont_add = 0;\n-\n-  /* Yet Another Implicit Typename Kludge:  Since we don't tsubst\n-     the members for partial instantiations, DECL_CONTEXT (decl) is wrong.\n-     But pretend it's right for this function.  */\n-  if (processing_template_decl)\n-    type = DECL_REAL_CONTEXT (decl);\n-\n-  /* virtual base names are always unique.  */\n-  if (VBASE_NAME_P (name))\n-    *values = NULL_TREE;\n-\n-  /* Possible ambiguity.  If its defining type(s)\n-     is (are all) derived from us, no problem.  */\n-  else if (*values && TREE_CODE (*values) != TREE_LIST)\n-    {\n-      tree value = *values;\n-      /* Only complain if we shadow something we can access.  */\n-      if (warn_shadow && TREE_CODE (decl) == FUNCTION_DECL\n-\t  && ((DECL_LANG_SPECIFIC (*values)\n-\t       && DECL_CLASS_CONTEXT (value) == current_class_type)\n-\t      || ! TREE_PRIVATE (value)))\n-\t/* Should figure out access control more accurately.  */\n-\t{\n-\t  cp_warning_at (\"member `%#D' is shadowed\", value);\n-\t  cp_warning_at (\"by member function `%#D'\", decl);\n-\t  warning (\"in this context\");\n-\t}\n-\n-      context = DECL_REAL_CONTEXT (value);\n-\n-      if (context == type)\n-\t{\n-\t  if (TREE_CODE (value) == TYPE_DECL\n-\t      && DECL_ARTIFICIAL (value))\n-\t    *values = NULL_TREE;\n-\t  else\n-\t    dont_add = 1;\n-\t}\n-      else if (type == current_class_type\n-\t       || DERIVED_FROM_P (context, type))\n-\t{\n-\t  /* Don't add in *values to list */\n-\t  *values = NULL_TREE;\n-\t}\n-      else\n-\t*values = build_tree_list (NULL_TREE, value);\n-    }\n-  else\n-    for (tmp = values; *tmp;)\n-      {\n-\ttree value = TREE_VALUE (*tmp);\n-\tmy_friendly_assert (TREE_CODE (value) != TREE_LIST, 999);\n-\tcontext = (TREE_CODE (value) == FUNCTION_DECL\n-\t\t   && DECL_VIRTUAL_P (value))\n-\t  ? DECL_CLASS_CONTEXT (value)\n-\t    : DECL_CONTEXT (value);\n-\n-\tif (type == current_class_type\n-\t    || DERIVED_FROM_P (context, type))\n-\t  {\n-\t    /* remove *tmp from list */\n-\t    *tmp = TREE_CHAIN (*tmp);\n-\t  }\n-\telse\n-\t  tmp = &TREE_CHAIN (*tmp);\n-      }\n-\n-  if (! dont_add)\n-    {\n-      /* Put the new contents in our envelope.  */\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  *values = tree_cons (name, decl, *values);\n-\t  TREE_NONLOCAL_FLAG (*values) = 1;\n-\t  TREE_TYPE (*values) = unknown_type_node;\n-\t}\n-      else\n-\t{\n-\t  if (*values)\n-\t    {\n-\t      *values = tree_cons (NULL_TREE, decl, *values);\n-\t      /* Mark this as a potentially ambiguous member.  */\n-\t      /* Leaving TREE_TYPE blank is intentional.\n-\t\t We cannot use `error_mark_node' (lookup_name)\n-\t\t or `unknown_type_node' (all member functions use this).  */\n-\t      TREE_NONLOCAL_FLAG (*values) = 1;\n-\t    }\n-\t  else\n-\t    *values = decl;\n-\t}\n-    }\n-}\n-\n /* Returns 1 iff BINFO is a base we shouldn't really be able to see into,\n    because it (or one of the intermediate bases) depends on template parms.  */\n \n@@ -2932,182 +2871,133 @@ dependent_base_p (binfo)\n   return 0;\n }\n \n-/* Add the instance variables which this class contributed to the\n-   current class binding contour.  When a redefinition occurs, if the\n-   redefinition is strictly within a single inheritance path, we just\n-   overwrite the old declaration with the new.  If the fields are not\n-   within a single inheritance path, we must cons them.\n-\n-   In order to know what decls are new (stemming from the current\n-   invocation of push_class_decls) we enclose them in an \"envelope\",\n-   which is a TREE_LIST node where the TREE_PURPOSE slot contains the\n-   new decl (or possibly a list of competing ones), the TREE_VALUE slot\n-   points to the old value and the TREE_CHAIN slot chains together all\n-   envelopes which needs to be \"opened\" in push_class_decls.  Opening an\n-   envelope means: push the old value onto the class_shadowed list,\n-   install the new one and if it's a TYPE_DECL do the same to the\n-   IDENTIFIER_TYPE_VALUE.  Such an envelope is recognized by seeing that\n-   the TREE_PURPOSE slot is non-null, and that it is not an identifier.\n-   Because if it is, it could be a set of overloaded methods from an\n-   outer scope.  */\n-\n-static tree\n-dfs_pushdecls (binfo, data)\n-     tree binfo;\n-     void *data;\n+static void\n+setup_class_bindings (name, type_binding_p)\n+     tree name;\n+     int type_binding_p;\n {\n-  tree *closed_envelopes = (tree *) data;\n-  tree type = BINFO_TYPE (binfo);\n-  tree fields;\n-  tree method_vec;\n-  int dummy = 0;\n+  tree type_binding = NULL_TREE;\n+  tree value_binding;\n \n-  /* Only record types if we're a template base.  */\n-  if (processing_template_decl && type != current_class_type\n-      && dependent_base_p (binfo))\n-    dummy = 1;\n+  /* If we've already done the lookup for this declaration, we're\n+     done.  */\n+  if (IDENTIFIER_CLASS_VALUE (name))\n+    return;\n \n-  for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n+  /* First, deal with the type binding.  */\n+  if (type_binding_p)\n     {\n-      if (dummy && TREE_CODE (fields) != TYPE_DECL)\n-\tcontinue;\n-\n-      /* Unmark so that if we are in a constructor, and then find that\n-\t this field was initialized by a base initializer,\n-\t we can emit an error message.  */\n-      if (TREE_CODE (fields) == FIELD_DECL)\n-\tTREE_USED (fields) = 0;\n-\n-      /* Recurse into anonymous unions.  */\n-      if (DECL_NAME (fields) == NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (fields)) == UNION_TYPE)\n-\t{\n-\t  dfs_pushdecls (TYPE_BINFO (TREE_TYPE (fields)), data);\n-\t  continue;\n-\t}\n-\n-      if (DECL_NAME (fields))\n-\t{\n-\t  tree name = DECL_NAME (fields);\n-\t  tree class_value = IDENTIFIER_CLASS_VALUE (name);\n-\n-\t  /* If the class value is not an envelope of the kind described in\n-\t     the comment above, we create a new envelope.  */\n-\t  maybe_push_cache_obstack ();\n-\t  if (class_value == NULL_TREE || TREE_CODE (class_value) != TREE_LIST\n-\t      || TREE_PURPOSE (class_value) == NULL_TREE\n-\t      || TREE_CODE (TREE_PURPOSE (class_value)) == IDENTIFIER_NODE)\n-\t    {\n-\t      /* See comment above for a description of envelopes.  */\n-\t      *closed_envelopes = tree_cons (NULL_TREE, class_value,\n-\t\t\t\t\t     *closed_envelopes);\n-\t      IDENTIFIER_CLASS_VALUE (name) = *closed_envelopes;\n-\t      class_value = IDENTIFIER_CLASS_VALUE (name);\n-\t    }\n-\n-\t  envelope_add_decl (type, fields, &TREE_PURPOSE (class_value));\n-\t  pop_obstacks ();\n-\t}\n+      type_binding = lookup_member (current_class_type, name,\n+\t\t\t\t    /*protect=*/2,\n+\t\t\t\t    /*want_type=*/1);\n+      if (TREE_CODE (type_binding) == TREE_LIST \n+\t  && TREE_PURPOSE (type_binding) == error_mark_node)\n+\t/* NAME is ambiguous.  */\n+\tpush_class_level_binding (name, TREE_VALUE (type_binding));\n+      else\n+\tpushdecl_class_level (type_binding);\n     }\n \n-  method_vec = CLASS_TYPE_P (type) ? CLASSTYPE_METHOD_VEC (type) : NULL_TREE;\n-  if (method_vec && ! dummy)\n+  /* Now, do the value binding.  */\n+  value_binding = lookup_member (current_class_type, name,\n+\t\t\t\t /*protect=*/2,\n+\t\t\t\t /*want_type=*/0);\n+\n+  if (type_binding_p\n+      && (TREE_CODE (value_binding) == TYPE_DECL\n+\t  || (TREE_CODE (value_binding) == TREE_LIST\n+\t      && TREE_PURPOSE (value_binding) == error_mark_node\n+\t      && (TREE_CODE (TREE_VALUE (TREE_VALUE (value_binding)))\n+\t\t  == TYPE_DECL))))\n+    /* We found a type-binding, even when looking for a non-type\n+       binding.  This means that we already processed this binding\n+       above.  */\n+    my_friendly_assert (type_binding_p, 19990401);\n+  else\n     {\n-      tree *methods;\n-      tree *end;\n-\n-      /* Farm out constructors and destructors.  */\n-      end = TREE_VEC_END (method_vec);\n-\n-      for (methods = &TREE_VEC_ELT (method_vec, 2);\n-\t   *methods && methods != end;\n-\t   methods++)\n+      if (TREE_CODE (value_binding) == TREE_LIST \n+\t  && TREE_PURPOSE (value_binding) == error_mark_node)\n+\t/* NAME is ambiguous.  */\n+\tpush_class_level_binding (name, TREE_VALUE (value_binding));\n+      else\n \t{\n-\t  /* This will cause lookup_name to return a pointer\n-\t     to the tree_list of possible methods of this name.  */\n-\t  tree name;\n-\t  tree class_value;\n-\n-\t  \n-\t  name = DECL_NAME (OVL_CURRENT (*methods));\n-\t  class_value = IDENTIFIER_CLASS_VALUE (name);\n+\t  if (TREE_CODE (value_binding) == TREE_LIST)\n+\t    /* NAME is some overloaded functions.  */\n+\t    value_binding = TREE_VALUE (value_binding);\n+\t  pushdecl_class_level (value_binding);\n+\t}\n+    }\n+}\n \n-\t  maybe_push_cache_obstack ();\n+/* Push class-level declarations for any names appearing in BINFO that\n+   are TYPE_DECLS.  */\n \n-\t  /* If the class value is not an envelope of the kind described in\n-\t     the comment above, we create a new envelope.  */\n-\t  if (class_value == NULL_TREE || TREE_CODE (class_value) != TREE_LIST\n-\t      || TREE_PURPOSE (class_value) == NULL_TREE\n-\t      || TREE_CODE (TREE_PURPOSE (class_value)) == IDENTIFIER_NODE)\n-\t    {\n-\t      /* See comment above for a description of envelopes.  */\n-\t      *closed_envelopes = tree_cons (NULL_TREE, class_value,\n-\t\t\t\t\t     *closed_envelopes);\n-\t      IDENTIFIER_CLASS_VALUE (name) = *closed_envelopes;\n-\t      class_value = IDENTIFIER_CLASS_VALUE (name);\n-\t    }\n+static tree\n+dfs_push_type_decls (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  tree type;\n+  tree fields;\n \n-\t  /* Here we try to rule out possible ambiguities.\n-\t     If we can't do that, keep a TREE_LIST with possibly ambiguous\n-\t     decls in there.  */\n-\t  /* Arbitrarily choose the first function in the list.  This is OK\n-\t     because this is only used for initial lookup; anything that\n-\t     actually uses the function will look it up again.  */\n-\t  envelope_add_decl (type, OVL_CURRENT (*methods),\n-\t\t\t     &TREE_PURPOSE (class_value));\n-\t  pop_obstacks ();\n-\t}\n-    }\n+  type = BINFO_TYPE (binfo);\n+  for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n+    if (DECL_NAME (fields) && TREE_CODE (fields) == TYPE_DECL\n+\t&& !template_self_reference_p (type, fields))\n+      setup_class_bindings (DECL_NAME (fields), /*type_binding_p=*/1);\n \n   /* We can't just use BINFO_MARKED because envelope_add_decl uses\n      DERIVED_FROM_P, which calls get_base_distance.  */\n   SET_BINFO_PUSHDECLS_MARKED (binfo);\n-  \n+\n   return NULL_TREE;\n }\n \n-/* Consolidate unique (by name) member functions.  */\n+/* Push class-level declarations for any names appearing in BINFO that\n+   are not TYPE_DECLS.  */\n \n static tree\n-dfs_compress_decls (binfo, data)\n+dfs_push_decls (binfo, data)\n      tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+     void *data;\n {\n-  tree type = BINFO_TYPE (binfo);\n-  tree method_vec \n-    = CLASS_TYPE_P (type) ? CLASSTYPE_METHOD_VEC (type) : NULL_TREE;\n+  tree type;\n+  tree method_vec;\n+  int dep_base_p;\n \n-  if (processing_template_decl && type != current_class_type\n-      && dependent_base_p (binfo))\n-    /* We only record types if we're a template base.  */;\n-  else if (method_vec != 0)\n+  type = BINFO_TYPE (binfo);\n+  dep_base_p = (processing_template_decl && type != current_class_type\n+\t\t&& dependent_base_p (binfo));\n+  if (!dep_base_p)\n     {\n-      /* Farm out constructors and destructors.  */\n-      tree *methods;\n-      tree *end = TREE_VEC_END (method_vec);\n-\n-      for (methods = &TREE_VEC_ELT (method_vec, 2); \n-\t   methods != end && *methods; methods++)\n+      tree fields;\n+      for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n+\tif (DECL_NAME (fields) \n+\t    && TREE_CODE (fields) != TYPE_DECL\n+\t    && TREE_CODE (fields) != USING_DECL)\n+\t  setup_class_bindings (DECL_NAME (fields), /*type_binding_p=*/0);\n+\telse if (TREE_CODE (fields) == FIELD_DECL\n+\t\t && ANON_UNION_TYPE_P (TREE_TYPE (fields)))\n+\t  dfs_push_decls (TYPE_BINFO (TREE_TYPE (fields)), data);\n+\t  \n+      method_vec = (CLASS_TYPE_P (type) \n+\t\t    ? CLASSTYPE_METHOD_VEC (type) : NULL_TREE);\n+      if (method_vec)\n \t{\n-\t  /* This is known to be an envelope of the kind described before\n-\t     dfs_pushdecls.  */\n-\t  tree class_value = \n-\t    IDENTIFIER_CLASS_VALUE (DECL_NAME (OVL_CURRENT (*methods)));\n-\t  tree tmp = TREE_PURPOSE (class_value);\n-\n-\t  /* This was replaced in scope by somebody else.  Just leave it\n-\t     alone.  */\n-\t  if (TREE_CODE (tmp) != TREE_LIST)\n-\t    continue;\n-\n-\t  if (TREE_CHAIN (tmp) == NULL_TREE\n-\t      && TREE_VALUE (tmp)\n-\t      && OVL_NEXT (TREE_VALUE (tmp)) == NULL_TREE)\n-\t    {\n-\t      TREE_PURPOSE (class_value) = TREE_VALUE (tmp);\n-\t    }\n+\t  tree *methods;\n+\t  tree *end;\n+\n+\t  /* Farm out constructors and destructors.  */\n+\t  end = TREE_VEC_END (method_vec);\n+\n+\t  for (methods = &TREE_VEC_ELT (method_vec, 2);\n+\t       *methods && methods != end;\n+\t       methods++)\n+\t    setup_class_bindings (DECL_NAME (OVL_CURRENT (*methods)), \n+\t\t\t\t  /*type_binding_p=*/0);\n \t}\n     }\n+\n   CLEAR_BINFO_PUSHDECLS_MARKED (binfo);\n \n   return NULL_TREE;\n@@ -3125,7 +3015,6 @@ push_class_decls (type)\n      tree type;\n {\n   struct obstack *ambient_obstack = current_obstack;\n-  tree closed_envelopes = NULL_TREE;\n   search_stack = push_search_level (search_stack, &search_obstack);\n \n   /* Build up all the relevant bindings and such on the cache\n@@ -3134,75 +3023,12 @@ push_class_decls (type)\n   maybe_push_cache_obstack ();\n \n   /* Push class fields into CLASS_VALUE scope, and mark.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_pushdecls, unmarked_pushdecls_p, \n-\t    &closed_envelopes);\n+  dfs_walk (TYPE_BINFO (type), dfs_push_type_decls, unmarked_pushdecls_p, 0);\n \n   /* Compress fields which have only a single entry\n      by a given name, and unmark.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_compress_decls, marked_pushdecls_p,\n-\t    0);\n+  dfs_walk (TYPE_BINFO (type), dfs_push_decls, marked_pushdecls_p, 0);\n \n-  /* Open up all the closed envelopes and push the contained decls into\n-     class scope.  */\n-  while (closed_envelopes)\n-    {\n-      tree new = TREE_PURPOSE (closed_envelopes);\n-      tree id;\n-\n-      /* This is messy because the class value may be a *_DECL, or a\n-\t TREE_LIST of overloaded *_DECLs or even a TREE_LIST of ambiguous\n-\t *_DECLs.  The name is stored at different places in these three\n-\t cases.  */\n-      if (TREE_CODE (new) == TREE_LIST)\n-\t{\n-\t  if (TREE_PURPOSE (new) != NULL_TREE)\n-\t    id = TREE_PURPOSE (new);\n-\t  else\n-\t    {\n-\t      tree node = TREE_VALUE (new);\n-\n-\t      if (TREE_CODE (node) == TYPE_DECL\n-\t\t  && DECL_ARTIFICIAL (node)\n-\t\t  && IS_AGGR_TYPE (TREE_TYPE (node))\n-\t\t  && CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (node)))\n-\t\t{\n-\t\t  tree t = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (node));\n-\t\t  tree n = new;\n-\n-\t\t  for (; n; n = TREE_CHAIN (n))\n-\t\t    {\n-\t\t      tree d = TREE_VALUE (n);\n-\t\t      if (TREE_CODE (d) == TYPE_DECL\n-\t\t\t  && DECL_ARTIFICIAL (node)\n-\t\t\t  && IS_AGGR_TYPE (TREE_TYPE (d))\n-\t\t\t  && CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (d))\n-\t\t\t  && CLASSTYPE_TI_TEMPLATE (TREE_TYPE (d)) == t)\n-\t\t\t/* OK */;\n-\t\t      else\n-\t\t\tbreak;\n-\t\t    }\n-\n-\t\t  if (n == NULL_TREE)\n-\t\t    new = t;\n-\t\t}\n-\t      else while (TREE_CODE (node) == TREE_LIST)\n-\t\tnode = TREE_VALUE (node);\n-\t      id = DECL_NAME (node);\n-\t    }\n-\t}\n-      else\n-\tid = DECL_NAME (new);\n-\n-      /* Install the original class value in order to make\n-\t pushdecl_class_level work correctly.  */\n-      IDENTIFIER_CLASS_VALUE (id) = TREE_VALUE (closed_envelopes);\n-      if (TREE_CODE (new) == TREE_LIST)\n-\tpush_class_level_binding (id, new);\n-      else\n-\tpushdecl_class_level (new);\n-      closed_envelopes = TREE_CHAIN (closed_envelopes);\n-    }\n-  \n   /* Undo the call to maybe_push_cache_obstack above.  */\n   pop_obstacks ();\n "}, {"sha": "c0716d6c84a506ca700ab894a0de1c772965910d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -1295,7 +1295,7 @@ begin_class_definition (t)\n       && TYPE_CONTEXT (t) && TYPE_P (TYPE_CONTEXT (t))\n       && ! current_class_type)\n     push_template_decl (TYPE_STUB_DECL (t));\n-  pushclass (t, 0);\n+  pushclass (t, 1);\n   TYPE_BEING_DEFINED (t) = 1;\n   /* Reset the interface data, at the earliest possible\n      moment, as it might have been set via a class foo;\n@@ -1419,6 +1419,10 @@ finish_member_declaration (decl)\n \t  TREE_CHAIN (decl) = TYPE_FIELDS (current_class_type);\n \t  TYPE_FIELDS (current_class_type) = decl;\n \t}\n+\n+      /* Enter the DECL into the scope of the class.  */\n+      if (TREE_CODE (decl) != USING_DECL)\n+\tpushdecl_class_level (decl);\n     }\n }\n "}, {"sha": "e0b9eec7897075db0755f09a6a8cf49ab9070bef", "filename": "gcc/cp/tinfo.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Ftinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Ftinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.h?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -40,7 +40,7 @@ struct __class_type_info : public __user_type_info {\n     const __user_type_info *base;\n     USItype offset: 29;\n     bool is_virtual: 1;\n-    access access: 2;\n+    enum access access: 2;\n   };\n \n   const base_info *base_list;"}, {"sha": "6016d91df0816f45b6f0e65a5c4d60c57172ab48", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -2191,7 +2191,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t}\n \n \t      ref = build (COMPONENT_REF, unknown_type_node,\n-\t\t\t   datum, fndecls);\n+\t\t\t   datum, TREE_VALUE (fndecls));\n \t      return ref;\n \t    }\n \n@@ -2616,6 +2616,8 @@ build_x_function_call (function, params, decl)\n \t\t&& current_class_type != NULL_TREE\n \t\t&& (IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (function))\n \t\t    == function))\n+\t       || (TREE_CODE (function) == OVERLOAD\n+\t\t   && DECL_FUNCTION_MEMBER_P (OVL_CURRENT (function)))\n \t       || TREE_CODE (function) == IDENTIFIER_NODE\n \t       || TREE_CODE (type) == METHOD_TYPE\n \t       || TYPE_PTRMEMFUNC_P (type));\n@@ -2629,6 +2631,9 @@ build_x_function_call (function, params, decl)\n     {\n       tree basetype = NULL_TREE;\n \n+      if (TREE_CODE (function) == OVERLOAD)\n+\tfunction = OVL_CURRENT (function);\n+\n       if (TREE_CODE (function) == FUNCTION_DECL\n \t  || DECL_FUNCTION_TEMPLATE_P (function))\n \t{\n@@ -2700,7 +2705,14 @@ build_x_function_call (function, params, decl)\n       /* Undo what we did in build_component_ref.  */\n       decl = TREE_OPERAND (function, 0);\n       function = TREE_OPERAND (function, 1);\n-      function = DECL_NAME (OVL_CURRENT (TREE_VALUE (function)));\n+      function = DECL_NAME (OVL_CURRENT (function));\n+\n+      if (template_id)\n+\t{\n+\t  TREE_OPERAND (template_id, 0) = function;\n+\t  function = template_id;\n+\t}\n+\n       return build_method_call (decl, function, params,\n \t\t\t\tNULL_TREE, LOOKUP_NORMAL);\n     }"}, {"sha": "0e4c389b5060a16bfe4a32c1304bb5e1fbcc26a3", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -123,7 +123,7 @@ public:\n   template <class U>\n   friend bool fooy(U u);\n \n-  template <class T161> // ERROR - .*\n+  template <class T161>\n   friend bool foo(T161 u)\n     {\n       Xseven<T161, 5, int> obj;"}, {"sha": "5c3143cdf332f5cbe32782ecfc8237e90fd58408", "filename": "gcc/testsuite/g++.old-deja/g++.other/lookup12.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup12.C?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -0,0 +1,21 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+struct B {\n+  struct X {};\n+};\n+\n+\n+struct D : public B {\n+  void X();\n+\n+  struct X x;\n+\n+  void f();\n+};\n+\n+\n+void D::f() \n+{\n+  struct X y;\n+}"}, {"sha": "65dc9522a76dadc8f33621b54f8e5cd95a9bc05a", "filename": "gcc/testsuite/g++.old-deja/g++.other/using5.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fusing5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fusing5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fusing5.C?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -3,8 +3,6 @@\n // Based on bug report by Klaus-Georg Adams\n // <Klaus-Georg.Adams@chemie.uni-karlsruhe.de>\n \n-// crash test - XFAIL *-*-*\n-\n struct bar {\n   typedef bar t;\n };"}, {"sha": "9cc0d616d63cf712d290860fc3f25f046bf22828", "filename": "gcc/testsuite/g++.old-deja/g++.pt/lookup7.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup7.C?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -0,0 +1,14 @@\n+// Build don't link:\n+// Origin: Jason Merrill <jason@cygnus.com>\n+\n+struct A { typedef int B; };\n+template <int B> struct C : public A { \n+  B b; \n+  void f();\n+};\n+\n+\n+template <int B>\n+void C<B>::f() {\n+  B b;\n+}"}, {"sha": "cc562bf5d754622dc74fd2bb2dd151b0587dab3a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/lookup8.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup8.C?ref=8f0327178b2158f8c6ee5996b2bd12c7dde8dbe8", "patch": "@@ -0,0 +1,15 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T>\n+class X{};\n+\n+class Y : public X<int>\n+{\n+  void f();\n+};\n+\n+void Y::f()\n+{\n+  X x; // ERROR - X is not a type.\n+}"}]}